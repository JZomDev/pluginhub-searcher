package com.weather3d;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CyclesTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CyclesPlugin.class);
		RuneLite.main(args);
	}
}
package com.weather3d;

import com.weather3d.conditions.Biome;
import com.weather3d.conditions.Season;
import com.weather3d.conditions.Weather;
import net.runelite.api.Client;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

public class CyclesOverlay extends OverlayPanel
{
    private final Client client;
    private final CyclesPlugin plugin;
    private final CyclesConfig config;

    @Inject
    private CyclesOverlay(Client client, CyclesPlugin plugin, CyclesConfig config)
    {
        super(plugin);
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.toggleOverlay() || panelComponent == null)
        {
            return null;
        }

        Weather weather = plugin.getCurrentWeather();
        Biome biome = plugin.getCurrentBiome();
        Season season = plugin.getCurrentSeason();

        if (config.miniOverlay())
        {
            renderMiniOverlay(weather, biome, season);
        }
        else
        {
            renderOverlay(weather, biome, season);
        }

        return super.render(graphics);
    }

    private void renderOverlay(Weather weather, Biome biome, Season season)
    {
        panelComponent.getChildren().add(new ImageComponent(weather.getConditionImage()));
        panelComponent.getChildren().add(new ImageComponent(biome.getConditionImage()));
        panelComponent.getChildren().add(new ImageComponent(season.getConditionImage()));
    }

    private void renderMiniOverlay(Weather weather, Biome biome, Season season)
    {
        panelComponent.getChildren().add(new ImageComponent(weather.getMiniConditionImage()));
        panelComponent.getChildren().add(new ImageComponent(biome.getMiniConditionImage()));
        panelComponent.getChildren().add(new ImageComponent(season.getMiniConditionImage()));
    }
}

package com.weather3d;

import com.weather3d.conditions.Biome;

public enum BiomeChunkMap
{
    ARCTIC(Biome.ARCTIC, 5693, 5949, 5950, 6204, 6205, 6206, 6207, 6461, 6462, 6463, 6717, 6718, 6719, 6973, 6974, 7229, 7484, 8252, 8253, 8508, 8509, 8763, 9023, 9276, 9532, 9790, 10042, 10301, 10558, 10559, 10810, 10811, 10812, 11066, 11067, 11068, 11069, 11322, 11323, 11324, 11325, 11326, 11578, 11579, 11580, 11581, 13644),
    BARRENS(Biome.BARRENS, 5691, 5692, 5946, 5947, 5948, 6202, 6203, 6458, 6459, 6460, 6474, 6475, 6714, 6715, 6716, 6730, 6731, 6972, 7228, 9273, 9275, 9531, 9774, 9775, 9784, 9785, 9799, 9812, 10030, 10031, 10040, 10041, 10044, 10286, 10287, 10296, 10297, 10300, 10542, 10543, 10552, 10553, 10554, 10808, 10809, 11830, 12086, 12340, 13130, 13131, 13133, 13134, 13135, 13366, 13386, 13387, 13618, 13622, 13623, 13641, 13642, 13647, 13873, 13874, 13891, 13892, 13893, 13899, 13900, 14147, 14148, 14149, 14155, 14156, 14403, 14404, 14405, 14129, 14130, 14131, 14132, 14142, 14385, 14386, 14387, 14388, 14393, 14398, 14641, 14642, 14644, 14653, 14897, 14898, 14905, 14909, 14910, 15418, 15245, 15246, 15501, 15502),
    CAVE(Biome.CAVE, 4763, 4764, 4768, 5021, 5022, 5023, 5275, 5277, 5279, 5280, 5535, 5536, 5786, 5787, 5789, 6043, 6220, 6223, 6297, 6298, 6299, 6300, 6301, 6303, 6473, 6477, 6483, 6492, 6552, 6553, 6555, 6556, 6557, 6729, 6748, 6808, 6809, 6811, 6812, 6813, 6985, 6989, 6992, 6993, 6995, 7066, 7067, 7068, 7069, 7070, 7234, 7255, 7322, 7323, 7324, 7326, 7490, 7492, 7494, 7496, 7501, 7504, 7505, 7507, 7508, 7509, 7512, 7578, 7579, 7580, 7748, 7749, 7752, 7753, 7754, 7756, 7757, 7758, 7760, 7768, 7777, 7820, 7821, 7827, 8006, 8008, 8009, 8010, 8013, 8015, 8017, 8261, 8268, 8280, 8516, 8519, 8520, 8521, 8530, 8536, 8593, 8781, 8789, 8855, 9027, 9033, 9034, 9050, 9051, 9052, 9053, 9054, 9116, 9123, 9288, 9293, 9295, 9297, 9307, 9362, 9365, 9366, 9369, 9370, 9377, 9538, 9544, 9545, 9549, 9558, 9562, 9563, 9564, 9565, 9620, 9621, 9622, 9623, 9624, 9625, 9626, 9631, 9632, 9634, 9635, 9800, 9805, 9814, 9819, 9821, 9823, 9824, 9875, 9878, 9879, 9880, 9881, 9882, 9886, 9890, 9891, 10056, 10057, 10061, 10070, 10071, 10074, 10075, 10076, 10077, 10078, 10125, 10126, 10127, 10128, 10129, 10131, 10133, 10134, 10135, 10136, 10137, 10138, 10139, 10140, 10142, 10144, 10309, 10310, 10317, 10321, 10322, 10333, 10335, 10336, 10381, 10382, 10383, 10384, 10387, 10388, 10389, 10390, 10391, 10392, 10393, 10394, 10400, 10556, 10575, 10591, 10592, 10637, 10638, 10639, 10640, 10642, 10646, 10647, 10648, 10652, 10653, 10658, 10821, 10822, 10823, 10831, 10833, 10834, 10835, 10842, 10894, 10895, 10899, 10903, 10904, 10905, 10906, 10907, 10908, 10910, 10911, 11077, 11078, 11079, 11088, 11150, 11151, 11153, 11154, 11164, 11165, 11166, 11167, 11345, 11346, 11347, 11408, 11409, 11410, 11402, 11417, 11418, 11419, 11420, 11421, 11422, 11423, 11425, 11588, 11589, 11599, 11601, 11602, 11603, 11610, 11611, 11662, 11665, 11666, 11668, 11670, 11673, 11674, 11675, 11676, 11677, 11678, 11679, 11857, 11866, 11867, 11924, 11925, 11926, 11927, 11928, 11929, 11930, 11937, 12100, 12109, 12113, 12117, 12122, 12124, 12126, 12127, 12181, 12183, 12184, 12185, 12186, 12187, 12190, 12369, 12422, 12423, 12424, 12425, 12433, 12436, 12437, 12438, 12439, 12440, 12441, 12442, 12443, 12611, 12612, 12613, 12615, 12616, 12621, 12625, 12633, 12636, 12678, 12679, 12680, 12681, 12693, 12694, 12695, 12696, 12697, 12698, 12700, 12701, 12702, 12703, 12867, 12869, 12889, 12892, 12934, 12935, 12936, 12937, 12945, 12949, 12950, 12951, 12952, 12953, 12954, 12955, 12957, 12958, 12959, 12961, 13122, 13123, 13125, 13128, 13136, 13137, 13138, 13139, 13140, 13141, 13142, 13143, 13144, 13145, 13190, 13191, 13192, 13193, 13199, 13203, 13204, 13205, 13206, 13209, 13210, 13391, 13393, 13394, 13395, 13396, 13397, 13398, 13399, 13400, 13401, 13446, 13447, 43448, 13449, 13456, 13457, 13461, 13466, 13469, 13470, 13702, 13703, 13704, 13705, 13712, 13717, 13718, 13720, 13721, 13722, 13725, 13726, 13958, 13959, 13960, 13961, 13972, 13974, 13975, 13977, 13978, 13979, 14214, 14215, 14216, 14217, 14231, 14232, 14233, 14234, 14235, 14242, 14243, 14475, 14486, 14487, 14488, 14495, 14496, 14679, 14680, 14681, 14742, 14744, 14745, 14716, 14747, 14915, 14916, 14935, 14936, 14937, 14994, 14995, 14999, 15007, 15008, 15191, 15192, 15193, 15248, 15251, 15264, 15512, 15515),
    COSMOS(Biome.COSMOS, 8267, 8523, 8779, 9035, 9048, 9285, 9291, 9540, 9541, 9547, 9559, 9560, 9796, 9797, 9802, 9803, 9816, 9817, 10058, 10059, 10307, 10313, 10314, 10315, 10567, 10568, 10569, 10570, 10571, 10824, 10825, 10826, 10827, 10828, 11080, 11081, 11082, 11083, 11339, 11591, 11595, 11605, 11850, 11851, 12102, 12106, 12107, 12108, 12115, 12362, 12363, 12875, 13148, 13462, 13463, 14227, 14228, 14483, 14484, 14739, 14740),
    DESERT(Biome.DESERT, 12105, 12332, 12585, 12586, 12587, 12588, 12589, 12590, 12591, 12841, 12842, 12843, 12844, 12845, 12846, 12847, 12848, 13098, 13099, 13100, 13101, 13102, 13103, 13104, 13105, 13106, 13107, 13353, 13354, 13355, 13356, 13357, 13358, 13359, 13360, 13361, 13362, 13363, 13611, 13612, 13613, 13614, 13615, 13616, 13617, 13869, 13870, 13871, 13872),
    FOREST(Biome.FOREST, 4403, 4404, 4405, 4660, 4661, 5172, 5173, 5427, 5428, 5429, 5683, 5684, 5686, 5687, 5688, 5938, 5941, 5942, 5943, 5944, 5945, 6197, 6198, 6199, 6200, 6201, 6453, 6454, 6455, 6711, 6722, 6997, 7515, 7516, 7517, 7518, 7766, 7767, 7771, 7772, 7773, 7774, 8022, 8023, 8027, 8028, 8029, 8030, 8283, 8284, 8285, 8286, 8524, 8539, 8540, 8541, 8542, 8236, 8237, 8238, 8491, 8492, 8493, 8494, 8495, 8496, 8497, 8498, 8499, 8500, 8747, 8748, 8749, 8750, 8753, 8754, 8755, 8756, 9003, 9004, 9005, 9006, 9009, 9010, 9011, 9012, 9014, 9015, 9016, 9017, 9260, 9261, 9262, 9265, 9271, 9272, 9287, 9524, 9525, 9526, 9527, 9528, 9776, 9777, 9780, 9781, 9782, 9783, 10032, 10033, 10034, 10036, 10037, 10038, 10039, 10288, 10289, 10290, 10293, 10294, 10544, 10545, 10546, 10549, 10550, 10551, 10804, 10805, 10806, 10807, 10847, 10848, 11060, 11061, 11062, 11103, 11316, 11317, 11570, 11572, 11573, 11574, 11593, 11616, 11826, 11829, 12085, 12338, 12341, 12594, 12637, 12638, 12639, 12893, 12894, 12895, 13149, 13150, 13151, 13108, 13109, 13110, 13364, 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432, 15159),
    GRASSLAND(Biome.GRASSLAND, 4665, 4666, 4914, 4915, 4921, 4922, 5170, 5171, 5178, 5679, 5680, 5935, 5936, 5937, 6190, 6191, 6192, 6193, 6446, 6447, 6448, 6449, 6702, 6703, 6704, 6705, 6958, 6959, 6960, 6961, 7216, 7217, 6456, 6457, 6494, 6495, 6496, 6710, 6712, 6713, 6750, 6751, 6752, 6965, 6966, 6967, 6968, 6969, 7006, 7007, 7008, 7222, 7223, 7224, 7238, 7257, 7478, 7479, 7502, 7513, 7514, 7769, 7770, 8025, 8026, 8288, 8525, 8534, 9520, 9779, 10035, 10291, 10292, 10547, 10548, 10803, 11343, 11571, 11827, 11828, 12079, 12080, 12082, 12083, 12084, 12335, 12336, 12337, 12339, 12342, 12592, 12595, 12596, 12597, 12598, 12619, 12622, 12623, 12850, 12851, 12852, 12853, 12854, 13365, 13404, 13643, 13646, 13658, 13659, 13898, 13914, 13915, 15428),
    LAVA_CAVE(Biome.LAVA_CAVE, 5789, 9043, 9363, 9551, 9552, 9619, 9807, 9808, 10063, 10064, 10643, 10644, 10645, 10649, 10650, 10900, 10901, 10902, 11156, 11157, 11158, 11413, 11414, 11416, 11672, 12119, 12192, 12193, 12690, 12946, 13202, 13464, 13465, 15262, 15263),
    MOUNTAIN(Biome.MOUNTAIN, 4659, 4662, 4663, 4916, 4917, 4918, 4919, 4923, 4924, 5174, 5179, 5180, 5433, 5434, 5435, 5681, 5682, 5689, 5690, 5939, 5940, 6194, 6195, 6450, 6451, 6706, 6707, 8501, 8757, 9013, 9264, 9266, 9267, 9268, 9269, 9270, 9521, 9522, 9523, 9778, 11063, 11064, 11065, 11102, 11104, 11314, 11315, 11318, 11319, 11320, 11321, 11359, 11360, 11575, 11576, 11577, 12640, 12896, 13152, 13405, 13406, 13407, 13408),
    SWAMP(Biome.SWAMP, 4664, 4920, 5175, 5176, 5177, 5430, 5431, 5432, 5677, 5678, 6727, 8014, 8270, 8526, 8751, 8752, 8782, 9007, 9008, 9038, 9263, 9294, 9519, 9550, 9806, 10846, 11335, 12593, 12849, 13619, 13620, 13621, 13645, 13875, 13876, 13877, 13878, 13879, 14133, 14134, 14135, 14389, 14390, 14391, 14394, 14395, 14476, 14477, 14478, 14643, 14645, 14646, 14647, 14649, 14650, 14651, 14732, 14733, 14734, 14899, 14900, 14901),
    TROPICAL(Biome.TROPICAL, 4911, 4912, 4913, 5165, 5166, 5167, 5169, 5421, 5422, 5423, 5424, 5425, 5426, 5933, 5934, 6486, 6487, 6488, 6489, 6742, 6743, 6744, 6745, 6970, 6971, 7225, 7226, 7227, 7242, 7243, 7244, 7499, 7500, 7755, 7763, 8011, 8012, 8276, 8278, 8527, 8528, 8784, 10055, 10311, 13660, 13913, 13916, 14169, 14170, 14686, 14687, 14942, 14943, 9772, 9773, 10028, 10029, 10284, 10285, 10794, 10795, 10801, 10802, 11050, 11051, 11053, 11054, 11055, 11056, 11057, 11058, 11059, 11309, 11310, 11311, 11312, 11313, 11562, 11565, 11566, 11567, 11568, 11569, 11821, 11822, 11823, 11824, 11825, 12078, 12081, 14637, 14638, 14639, 14652, 14894, 14895, 14906, 14907, 14908, 15148, 15149, 15150, 15151, 15162, 15163, 15164, 15405, 15406, 15407, 15418),
    WILDERNESS(Biome.WILDERNESS, 11831, 11832, 11833, 11834, 11835, 11836, 11837, 12087, 12088, 12089, 12090, 12091, 12092, 12093, 12343, 12344, 12345, 12346, 12347, 12348, 12349, 12599, 12600, 12601, 12602, 12603, 12604, 12605, 12855, 12856, 12857, 12858, 12859, 12860, 12861, 13111, 13112, 13113, 13114, 13115, 13116, 13117, 13367, 13368, 13369, 13370, 13371, 13372, 13373, 13624)
    ;

    final Biome biomeCondition;
    final int[] chunks;

    BiomeChunkMap(Biome biomeCondition, int... chunks)
    {
        this.biomeCondition = biomeCondition;
        this.chunks = chunks;
    }

    public static Biome checkBiome(int regionID)
    {
        for (BiomeChunkMap chunk : BiomeChunkMap.values())
        {
            for (int e : chunk.chunks)
            {
                if (e == regionID)
                {
                    return chunk.biomeCondition;
                }
            }
        }
        return Biome.CAVE;
    }
}

package com.weather3d;

import net.runelite.client.config.*;

@ConfigGroup("3Dweather")
public interface CyclesConfig extends Config {

	enum WeatherType {
		DYNAMIC,
		ASHFALL,
		CLEAR,
		CLOUDY,
		FOGGY,
		PARTLY_CLOUDY,
		RAINY,
		SNOWY,
		STARRY,
		STORMY
	}

	enum SeasonType {
		DYNAMIC,
		HD_117,
		SPRING,
		SUMMER,
		AUTUMN,
		WINTER
	}

	@ConfigSection(
			name = "General",
			description = "General settings",
			position = 0
	)
	String generalSettings = "generalSettings";

	@ConfigItem(
			keyName = "weatherType",
			name = "Weather Type",
			description = "Determines the current Weather (Dynamic automatically cycles based on Season and Biome)",
			section = generalSettings,
			position = 1
	)
	default WeatherType weatherType()
	{
		return WeatherType.DYNAMIC;
	}

	@ConfigItem(
			keyName = "seasonType",
			name = "Season Type",
			description = "Determines the current Season and its Weather cycle (only relevant if Weather Type is Dynamic)",
			section = generalSettings,
			position = 2
	)
	default SeasonType seasonType()
	{
		return SeasonType.DYNAMIC;
	}

	@ConfigItem(
			keyName = "toggleOverlay",
			name = "Enable Overlay",
			description = "Displays an overlay indicating Weather, Biome, and Season",
			section = generalSettings,
			position = 3
	)
	default boolean toggleOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "miniOverlay",
			name = "Enable Mini Overlay",
			description = "Displays a mini overlay indicating Weather, Biome, and Season",
			section = generalSettings,
			position = 4
	)
	default boolean miniOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "disableWeatherUnderground",
			name = "Disable Weather Underground",
			description = "Prevents Weather from occurring while in Cave or Lava Cave Biomes, regardless of the set Weather Type",
			section = generalSettings,
			position = 5
	)
	default boolean disableWeatherUnderground()
	{
		return true;
	}

	@ConfigSection(
			name = "Audio",
			description = "Audio settings",
			position = 6
	)
	String audioSettings = "audioSettings";

	@ConfigItem(
			keyName = "toggleAmbience",
			name = "Enable Ambience",
			description = "Toggles ambient Weather sounds on/off",
			section = audioSettings,
			position = 7
	)
	default boolean toggleAmbience()
	{
		return true;
	}

	@ConfigItem(
			keyName = "ambientVolume",
			name = "Ambient Volume",
			description = "Sets the volume of ambient Weather sounds",
			section = audioSettings,
			position = 8
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int ambientVolume()
	{
		return 50;
	}

	@ConfigItem(
		keyName = "useAreaSoundsVolume",
		name = "Use Area Sounds Volume",
		description = "Use the in-game \"Area Sounds\" audio setting, overriding the \"Ambient Volume\" setting",
		section = audioSettings,
		position = 9
	)
	default boolean useAreaSoundsVolume()
	{
		return false;
	}

	@ConfigItem(
			keyName = "muffledVolume",
			name = "Muffled Volume",
			description = "Sets the volume of muffled Weather sounds while indoors",
			section = audioSettings,
			position = 10
	)
	@Units(Units.PERCENT)
	@Range(max = 100)
	default int muffledVolume()
	{
		return 50;
	}

	@ConfigItem(
			keyName = "disableIndoorMuffling",
			name = "Disable Indoor Muffling",
			description = "Prevents ambience sound from being muffled while standing indoors.",
			section = audioSettings,
			position = 11
	)
	default boolean disableIndoorMuffling()
	{
		return false;
	}

	@ConfigSection(
			name = "Weathers",
			description = "Weather Options",
			position = 12
	)
	String weatherToggles = "weatherToggles";

	@ConfigItem(
			keyName = "enableRain",
			name = "Rain Enabled",
			description = "Allows Rain objects to appear while Rainy or Stormy",
			section = weatherToggles,
			position = 13
	)
	default boolean enableRain()
	{
		return true;
	}

	//set mins?

	@ConfigItem(
			keyName = "rainDensity",
			name = "Rain Density",
			description = "<html>Sets the number of Rain objects that spawn while Rainy<br>Max = 2000</html>",
			section = weatherToggles,
			position = 14
	)
	@Range(max = 2000)
	default int rainDensity()
	{
		return 400;
	}

	@ConfigItem(
			keyName = "stormDensity",
			name = "Storm Density",
			description = "<html>Sets the number of Rain objects that spawn while Stormy<br>Max = 3000</html>",
			section = weatherToggles,
			position = 15
	)
	@Range(max = 3000)
	default int stormDensity()
	{
		return 600;
	}

	@ConfigItem(
			keyName = "enableSnow",
			name = "Snow Enabled",
			description = "Allows Snow objects to appear while Snowy",
			section = weatherToggles,
			position = 16
	)
	default boolean enableSnow()
	{
		return true;
	}

	@ConfigItem(
			keyName = "snowDensity",
			name = "Snow Density",
			description = "<html>Sets the number of Snow objects that spawn while Snowy<br>Max = 2000</html>",
			section = weatherToggles,
			position = 17
	)
	@Range(max = 2000)
	default int snowDensity()
	{
		return 400;
	}

	@ConfigItem(
			keyName = "enableClouds",
			name = "Clouds Enabled",
			description = "Allows Cloud objects to appear while Cloudy or Partly Cloudy",
			section = weatherToggles,
			position = 18
	)
	default boolean enableClouds()
	{
		return true;
	}

	@ConfigItem(
			keyName = "cloudyDensity",
			name = "Cloud Density",
			description = "<html>Sets the number of Cloud objects that spawn while Cloudy<br>Max = 1000</html>",
			section = weatherToggles,
			position = 19
	)
	@Range(max = 1000)
	default int cloudyDensity()
	{
		return 200;
	}

	@ConfigItem(
			keyName = "partlyCloudyDensity",
			name = "Partly Cloudy Density",
			description = "<html>Sets the number of Cloud objects that spawn while Partly Cloudy<br>Max = 300</html>",
			section = weatherToggles,
			position = 20
	)
	@Range(max = 300)
	default int partlyCloudyDensity()
	{
		return 50;
	}

	@ConfigItem(
			keyName = "enableAsh",
			name = "Ash Enabled",
			description = "Allows Ash objects to appear while in Ashfall",
			section = weatherToggles,
			position = 21
	)
	default boolean enableAsh()
	{
		return false;
	}

	@ConfigItem(
			keyName = "ashfallDensity",
			name = "Ashfall Density",
			description = "<html>Sets the number of Ash objects that spawn while in Ashfall<br>Max = 1200</html>",
			section = weatherToggles,
			position = 22
	)
	@Range(max = 1200)
	default int ashfallDensity()
	{
		return 200;
	}

	@ConfigItem(
			keyName = "enableFog",
			name = "Fog Enabled",
			description = "Allows Fog objects to appear while Foggy",
			section = weatherToggles,
			position = 23
	)
	default boolean enableFog()
	{
		return false;
	}

	@ConfigItem(
			keyName = "foggyDensity",
			name = "Fog Density",
			description = "<html>Sets the number of Fog objects that spawn while Foggy<br>Max = 1800</html>",
			section = weatherToggles,
			position = 24
	)
	@Range(max = 1800)
	default int foggyDensity()
	{
		return 500;
	}

	@ConfigItem(
			keyName = "enableStars",
			name = "Stars Enabled",
			description = "Allows Star objects to appear while in other Realms",
			section = weatherToggles,
			position = 25
	)
	default boolean enableStars()
	{
		return true;
	}

	@ConfigItem(
			keyName = "starryDensity",
			name = "Stars Density",
			description = "<html>Sets the number of Star objects that spawn while Starry<br>Max = 2000</html>",
			section = weatherToggles,
			position = 26
	)
	@Range(max = 2000)
	default int starryDensity()
	{
		return 400;
	}

	@ConfigItem(
			keyName = "enableWintertodtSnow",
			name = "Enable Wintertodt Snow",
			description = "Allows Snow objects to appear at Wintertodt while Snowing (may make it difficult to see incoming attacks)",
			section = weatherToggles,
			position = 27
	)
	default boolean enableWintertodtSnow()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableLightning",
			name = "Enable Lightning",
			description = "PHOTOSENSITIVITY WARNING - Allows Lightning flashes to occur during Stormy weather",
			section = weatherToggles,
			position = 28
	)
	default boolean enableLightning()
	{
		return false;
	}
}

package com.weather3d;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.RuneLiteObject;

@Getter
@AllArgsConstructor
public class WeatherObject
{
    private RuneLiteObject runeLiteObject;
    private int objVariant;
}

package com.weather3d.conditions;

import lombok.Getter;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

@Getter
public enum Biome
{
    ARCTIC("Arctic", "/Biome - Arctic.png", "/Biome - Arctic - Mini.png"),
    BARRENS("Barrens", "/Biome - Barrens.png", "/Biome - Barrens - Mini.png"),
    CAVE("Caves", "/Biome - Cave.png", "/Biome - Cave - Mini.png"),
    COSMOS("Cosmos", "/Biome - Cosmos.png", "/Biome - Cosmos - Mini.png"),
    DESERT("Desert", "/Biome - Desert.png", "/Biome - Desert - Mini.png"),
    FOREST("Woodland", "/Biome - Forest.png", "/Biome - Forest - Mini.png"),
    GRASSLAND("Grassland", "/Biome - Grassland.png", "/Biome - Grassland - Mini.png"),
    LAVA_CAVE("Lava Caves", "/Biome - Lava Cave.png", "/Biome - Lava Cave - Mini.png"),
    MOUNTAIN("Mountains", "/Biome - Mountain.png", "/Biome - Mountain - Mini.png"),
    SWAMP("Swamp", "/Biome - Swamp.png", "/Biome - Swamp - Mini.png"),
    TROPICAL("Tropics", "/Biome - Tropical.png", "/Biome - Tropical - Mini.png"),
    WILDERNESS("Wilderness", "/Biome - Wilderness.png", "/Biome - Wilderness - Mini.png")
    ;

    private final String name;
    private final BufferedImage conditionImage;
    private final BufferedImage miniConditionImage;

    Biome(String name, String imageFile, String miniImageFile)
    {
        this.name = name;
        this.conditionImage = ImageUtil.loadImageResource(getClass(), imageFile);
        this.miniConditionImage = ImageUtil.loadImageResource(getClass(), miniImageFile);
    }
}

package com.weather3d.conditions;

import com.weather3d.audio.SoundEffect;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

@Getter
public enum Weather {
    ASHFALL("Ashfall", "/Weather - Ashfall.png", "/Weather - Ashfall - Mini.png",true, 3, 60, false, null,
            1200, 800, 4),
    CLOUDY("Cloudy", "/Weather - Cloudy.png", "/Weather - Cloudy - Mini.png",true, 3, 300, false, null,
            1000, 600, 200),
    STARRY("Otherworldly", "/Weather - Cosmos.png", "/Weather - Cosmos - Mini.png", true, 3, 60, false, null,
            2000, 1000, 8),
    COVERED("Sheltered", "/Weather - Covered.png", "/Weather - Covered - Mini.png", false, 1, 60, false, null,
            0, 0, 1),
    FOGGY("Foggy", "/Weather - Foggy.png", "/Weather - Foggy - Mini.png", true, 3, 60, false, null,
            1800, 1100, 200),
    PARTLY_CLOUDY("Partly Cloudy", "/Weather - Partly Cloudy.png", "/Weather - Partly Cloudy - Mini.png", true, 3, 300, false, null,
            300, 200, 200),
    RAINY("Raining", "/Weather - Raining.png", "/Weather - Raining - Mini.png", true, 3, 60, true, SoundEffect.RAIN,
            2000, 1200, 2),
    SNOWY("Snowing", "/Weather - Snow.png", "/Weather - Snow - Mini.png", true, 3, 60, true, SoundEffect.WIND,
            1800, 1200, 4),
    STORMY("Stormy", "/Weather - Stormy.png", "/Weather - Stormy - Mini.png", true, 3, 60, true, SoundEffect.THUNDERSTORM,
            3000, 1400, 1),
    SUNNY("Clear", "/Weather - Sunny.png", "/Weather - Sunny - Mini.png", false, 1, 60, false, null,
            0, 0, 1),
    ;

    private final String name;
    private final BufferedImage conditionImage;
    private final BufferedImage miniConditionImage;
    private final boolean hasPrecipitation;
    private final int modelVariety;
    private final int objRadius;
    private final boolean hasSound;
    private final SoundEffect soundEffect;
    private final int maxObjects;
    private final int maxObjectVolume;
    private final int changeRate;

    Weather(String name, String imageFile, String miniImageFile, boolean hasPrecipitation, int modelVariety, int objRadius, boolean hasSound, SoundEffect soundEffect, int maxObjects, int maxObjectVolume, int changeRate)
    {
        this.name = name;
        this.conditionImage = ImageUtil.loadImageResource(getClass(), imageFile);
        this.miniConditionImage = ImageUtil.loadImageResource(getClass(), miniImageFile);
        this.hasPrecipitation = hasPrecipitation;
        this.modelVariety = modelVariety;
        this.objRadius = objRadius;
        this.hasSound = hasSound;
        this.soundEffect = soundEffect;
        this.maxObjects = maxObjects;
        this.maxObjectVolume = maxObjectVolume;
        this.changeRate = changeRate;
    }
}

package com.weather3d.conditions;

import com.weather3d.WeatherObject;
import com.weather3d.audio.SoundPlayer;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;

@Getter
@Setter
@AllArgsConstructor
public class WeatherManager
{
    private Weather weatherType;
    private SoundPlayer[] soundPlayers;
    private int soundPlayerTimer;
    private ArrayList<WeatherObject> weatherObjArray;
    private int startRotation;
    private boolean isFading;

    public SoundPlayer getPrimarySoundPlayer()
    {
        if (soundPlayers[1].isPrimarySoundPlayer())
        {
            soundPlayers[1].setPrimarySoundPlayer(true);
            soundPlayers[0].setPrimarySoundPlayer(false);
            return soundPlayers[1];
        }

        soundPlayers[0].setPrimarySoundPlayer(true);
        soundPlayers[1].setPrimarySoundPlayer(false);
        return soundPlayers[0];
    }

    public void switchSoundPlayerPriority()
    {
        SoundPlayer primSoundPlayer = getPrimarySoundPlayer();
        SoundPlayer secSoundPlayer;

        if (primSoundPlayer == soundPlayers[0])
        {
            secSoundPlayer = soundPlayers[1];
        }
        else
        {
            secSoundPlayer = soundPlayers[0];
        }

        primSoundPlayer.setPrimarySoundPlayer(false);

        secSoundPlayer.setPrimarySoundPlayer(true);
    }

    public void stopManagerSoundPlayers()
    {
        setSoundPlayerTimer(0);
        for (SoundPlayer soundPlayer : soundPlayers)
        {
            soundPlayer.stopClip();
        }
    }
}

package com.weather3d.conditions;

import lombok.Getter;
import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

@Getter
public enum Season
{
    SPRING("Spring", "/Season - Spring.png", "/Season - Spring - Mini.png"),
    SUMMER("Summer", "/Season - Summer.png", "/Season - Summer - Mini.png"),
    AUTUMN("Autumn", "/Season - Autumn.png", "/Season - Autumn - Mini.png"),
    WINTER("Winter", "/Season - Winter.png", "/Season - Winter - Mini.png")
    ;

    private final String name;
    private final BufferedImage conditionImage;
    private final BufferedImage miniConditionImage;

    Season(String name, String imageFile, String miniImageFile)
    {
        this.name = name;
        this.conditionImage = ImageUtil.loadImageResource(getClass(), imageFile);
        this.miniConditionImage = ImageUtil.loadImageResource(getClass(), miniImageFile);
    }
}

package com.weather3d;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

public class CyclesClock
{
    private static final ZoneId JAGEX = ZoneId.of("Europe/London");
    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("DDD:hh:mm");

    public static int getTimeMinutes()
    {
        String currentTime = getJagexTime();
        String[] currentTimeArray = currentTime.split(":");
        return Integer.valueOf(currentTimeArray[2]);
    }

    public static int getTimeHours()
    {
        String currentTime = getJagexTime();
        String[] currentTimeArray = currentTime.split(":");
        return Integer.valueOf(currentTimeArray[1]);
    }

    public static int getTimeDays()
    {
        String currentTime = getJagexTime();
        String[] currentTimeArray = currentTime.split(":");
        return Integer.valueOf(currentTimeArray[0]);
    }

    public static String getJagexTime()
    {
        LocalDateTime time = LocalDateTime.now(JAGEX);
        return time.format(TIME_FORMAT);
    }
}

package com.weather3d;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class LightningOverlay extends Overlay
{
    private final Client client;
    private final CyclesPlugin plugin;
    private final CyclesConfig config;

    @Inject
    private LightningOverlay(Client client, CyclesPlugin plugin, CyclesConfig config)
    {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.enableLightning() || !plugin.flashLightning)
        {
            return null;
        }

        Dimension dimensions = client.getRealDimensions();
        graphics.setColor(Color.WHITE);
        graphics.fillRect(0, 0, dimensions.width, dimensions.height);
        plugin.flashLightning = false;
        return null;
    }
}

package com.weather3d;

import com.weather3d.conditions.Weather;
import lombok.Getter;
import net.runelite.api.*;

import javax.inject.Inject;
import java.util.Arrays;

@Getter
public class ModelHandler
{
    @Inject
    private Client client;

    private Model ashModel;
    private Model ashModel2;
    private Model ashModel3;
    private Model cloudModel;
    private Model cloudModel2;
    private Model cloudModel3;
    private Model cloudModelTP;
    private Model cloudModelTP2;
    private Model cloudModelTP3;
    private Model fogModel;
    private Model fogModel2;
    private Model fogModel3;
    private Model rainModel;
    private Model rainModel2;
    private Model rainModel3;
    private Model snowModel;
    private Model snowModel2;
    private Model snowModel3;
    private Model starModel;
    private Model starModel2;
    private Model starModel3;
    private Model starModelTP;
    private Model starModelTP2;
    private Model starModelTP3;
    private Model stormModel;
    private Model stormModel2;
    private Model stormModel3;
    private Animation ashAnimation;
    private Animation cloudAnimation;
    private Animation fogAnimation;
    private Animation rainAnimation;
    private Animation snowAnimation;
    private Animation starAnimation;
    private final int ASH_MODEL = 27835;
    private final int ASH_ANIMATION = 7000;
    private final int CLOUD_MODEL = 4086;
    private final int CLOUD_ANIMATION = 6470;
    private final int FOG_MODEL = 29290;
    private final int FOG_ANIMATION = 4516;
    private final int RAIN_MODEL = 15524;
    private final int RAIN_ANIMATION = 7001;
    private final int SNOW_MODEL = 27835;
    private final int SNOW_ANIMATION = 7000;
    private final int STAR_MODEL = 16374;
    private final int STAR_ANIMATION = 7971;

    public void loadModels()
    {
        ModelData ashModelData = client.loadModelData(ASH_MODEL).cloneColors().cloneVertices();
        ModelData ashModelData2 = client.loadModelData(ASH_MODEL).cloneColors().cloneVertices();
        ModelData ashModelData3 = client.loadModelData(ASH_MODEL).cloneColors().cloneVertices();
        short[] ashFaceColours = ashModelData.getFaceColors();
        short[] ashFaceColours2 = ashModelData2.getFaceColors();
        short[] ashFaceColours3 = ashModelData3.getFaceColors();
        short ashColour1 = JagexColor.packHSL(39, 1, 40);
        short ashColour2 = JagexColor.packHSL(39, 1, 40);
        ashModel = ashModelData.scale(128, 192, 128).translate(0, 180, 0).recolor(ashFaceColours[0], ashColour1).recolor(ashFaceColours[2], ashColour2).light();
        ashModel2 = ashModelData2.scale(128, 192, 128).translate(0, 180, 0).recolor(ashFaceColours2[0], ashColour1).recolor(ashFaceColours2[2], ashColour2).rotateY90Ccw().light();
        ashModel3 = ashModelData3.scale(128, 192, 128).translate(0, 180, 0).recolor(ashFaceColours3[0], ashColour1).recolor(ashFaceColours3[2], ashColour2).rotateY270Ccw().light();

        ModelData cloudModelData = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData cloudModelData2 = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData cloudModelData3 = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        short cloudFaceColour = cloudModelData.getFaceColors()[0];
        short cloudReplaceColour = JagexColor.packHSL(54, 0, 110);
        cloudModel = cloudModelData.scale(650, 325, 650).translate(0, -1000, 0).recolor(cloudFaceColour, cloudReplaceColour).light();
        cloudModel2 = cloudModelData2.scale(1000, 500, 1000).translate(0, -1400, 0).recolor(cloudFaceColour, cloudReplaceColour).rotateY90Ccw().light();
        cloudModel3 = cloudModelData3.scale(800, 400, 800).translate(0, -1200, 0).recolor(cloudFaceColour, cloudReplaceColour).rotateY180Ccw().light();

        ModelData cloudTPModelData = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData cloudTPModelData2 = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData cloudTPModelData3 = client.loadModelData(CLOUD_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        cloudModelTP = cloudTPModelData.scale(650, 325, 650).translate(0, -1000, 0).recolor(cloudFaceColour, cloudReplaceColour).light();
        cloudModelTP2 = cloudTPModelData2.scale(1000, 500, 1000).translate(0, -1400, 0).recolor(cloudFaceColour, cloudReplaceColour).rotateY90Ccw().light();
        cloudModelTP3 = cloudTPModelData3.scale(800, 400, 800).translate(0, -1200, 0).recolor(cloudFaceColour, cloudReplaceColour).rotateY180Ccw().light();
        byte[] cloudMDTP = cloudTPModelData.getFaceTransparencies();
        byte[] cloudMDTP2 = cloudTPModelData2.getFaceTransparencies();
        byte[] cloudMDTP3 = cloudTPModelData3.getFaceTransparencies();
        Arrays.fill(cloudMDTP, (byte) -23);
        Arrays.fill(cloudMDTP2, (byte) -23);
        Arrays.fill(cloudMDTP3, (byte) -23);

        ModelData fogModelData = client.loadModelData(FOG_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData fogModelData2 = client.loadModelData(FOG_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        ModelData fogModelData3 = client.loadModelData(FOG_MODEL).cloneVertices().cloneColors().cloneTransparencies();
        short fogFaceColour = fogModelData.getFaceColors()[0];
        short fogReplaceColour = JagexColor.packHSL(54, 0, 77);
        fogModel = fogModelData.scale(190, 110, 190).recolor(fogFaceColour, fogReplaceColour).translate(0, -70, 0).light(200, ModelData.DEFAULT_CONTRAST, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        fogModel2 = fogModelData2.scale(190, 110, 190).recolor(fogFaceColour, fogReplaceColour).translate(0, -100, 0).light(200, ModelData.DEFAULT_CONTRAST, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        fogModel3 = fogModelData3.scale(190, 110, 190).recolor(fogFaceColour, fogReplaceColour).translate(0, -85, 0).light(200, ModelData.DEFAULT_CONTRAST, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        byte[] fogTransparency = fogModelData.getFaceTransparencies();
        byte[] fogTransparency2 = fogModelData2.getFaceTransparencies();
        byte[] fogTransparency3 = fogModelData3.getFaceTransparencies();
        Arrays.fill(fogTransparency, (byte) -15);
        Arrays.fill(fogTransparency2, (byte) -15);
        Arrays.fill(fogTransparency3, (byte) -15);

        ModelData snowModelData = client.loadModelData(SNOW_MODEL).cloneVertices();
        ModelData snowModelData2 = client.loadModelData(SNOW_MODEL).cloneVertices();
        ModelData snowModelData3 = client.loadModelData(SNOW_MODEL).cloneVertices();
        snowModel = snowModelData.scale(128, 192, 128).translate(0, 190, 0).light();
        snowModel2 = snowModelData2.scale(128, 192, 128).translate(0, 190, 0).rotateY90Ccw().light();
        snowModel3 = snowModelData3.scale(128, 192, 128).translate(0, 190, 0).rotateY270Ccw().light();

        ModelData rainModelData = client.loadModelData(RAIN_MODEL).cloneVertices();
        ModelData rainModelData2 = client.loadModelData(RAIN_MODEL).cloneVertices();
        ModelData rainModelData3 = client.loadModelData(RAIN_MODEL).cloneVertices();
        short[] rainFaceColours = rainModelData.getFaceColors();
        short[] rainFaceColours2 = rainModelData2.getFaceColors();
        short[] rainFaceColours3 = rainModelData3.getFaceColors();
        short rainRippleColour = JagexColor.packHSL(32, 1, JagexColor.LUMINANCE_MAX);
        short rainDropColour = JagexColor.packHSL(32, 1, 120);
        rainModel = rainModelData.scale(100, 256, 100).recolor(rainFaceColours[0], rainRippleColour).recolor(rainFaceColours[23], rainDropColour).light();
        rainModel2 = rainModelData2.scale(90, 256, 90).recolor(rainFaceColours2[0], rainRippleColour).recolor(rainFaceColours2[23], rainDropColour).rotateY90Ccw().light();
        rainModel3 = rainModelData3.scale(110, 256, 110).recolor(rainFaceColours3[0], rainRippleColour).recolor(rainFaceColours3[23], rainDropColour).rotateY270Ccw().light();

        ModelData stormModelData = client.loadModelData(RAIN_MODEL).cloneColors().cloneVertices();
        ModelData stormModelData2 = client.loadModelData(RAIN_MODEL).cloneColors().cloneVertices();
        ModelData stormModelData3 = client.loadModelData(RAIN_MODEL).cloneColors().cloneVertices();
        short[] stormFaceColours = stormModelData.getFaceColors();
        short[] stormFaceColours2 = stormModelData2.getFaceColors();
        short[] stormFaceColours3 = stormModelData3.getFaceColors();
        short stormRippleColour = JagexColor.packHSL(38, 1, 110);
        short stormDropColour = JagexColor.packHSL(38, 2, 105);
        stormModel = stormModelData.scale(110, 410, 110).recolor(stormFaceColours[0], stormRippleColour).recolor(stormFaceColours[23], stormDropColour).light();
        stormModel2 = stormModelData2.scale(100, 410, 100).recolor(stormFaceColours2[0], stormRippleColour).recolor(stormFaceColours2[23], stormDropColour).rotateY90Ccw().light();
        stormModel3 = stormModelData3.scale(120, 410, 120).recolor(stormFaceColours3[0], stormRippleColour).recolor(stormFaceColours3[23], stormDropColour).rotateY90Ccw().light();

        ModelData starModelData = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        ModelData starModelData2 = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        ModelData starModelData3 = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        short[] starFaceColours = starModelData.getFaceColors();
        short[] starFaceColours2 = starModelData2.getFaceColors();
        short[] starFaceColours3 = starModelData3.getFaceColors();
        short starShellReplaceColour = JagexColor.packHSL(10, 4, 60);
        short starInsideReplaceColour = JagexColor.packHSL(10, 6, 80);
        starModel = starModelData.scale(80, 80, 80).translate(0, -1400, 0).recolor(starFaceColours[0], starShellReplaceColour).recolor(starFaceColours[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        starModel2 = starModelData2.scale(65, 65, 65).translate(0, -1500, 0).recolor(starFaceColours2[0], starShellReplaceColour).recolor(starFaceColours2[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        starModel3 = starModelData3.scale(95, 95, 95).translate(0, -1300, 0).recolor(starFaceColours3[0], starShellReplaceColour).recolor(starFaceColours3[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);

        ModelData starModelDataTP = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        ModelData starModelDataTP2 = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        ModelData starModelDataTP3 = client.loadModelData(STAR_MODEL).cloneColors().cloneVertices().cloneTransparencies();
        short[] starFaceColoursTP = starModelDataTP.getFaceColors();
        short[] starFaceColoursTP2 = starModelDataTP2.getFaceColors();
        short[] starFaceColoursTP3 = starModelDataTP3.getFaceColors();
        starModelTP = starModelDataTP.scale(80, 80, 80).translate(0, -1400, 0).recolor(starFaceColoursTP[0], starShellReplaceColour).recolor(starFaceColoursTP[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        starModelTP2 = starModelDataTP2.scale(65, 65, 65).translate(0, -1500, 0).recolor(starFaceColoursTP2[0], starShellReplaceColour).recolor(starFaceColoursTP2[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        starModelTP3 = starModelDataTP3.scale(95, 95, 95).translate(0, -1300, 0).recolor(starFaceColoursTP3[0], starShellReplaceColour).recolor(starFaceColoursTP3[45], starInsideReplaceColour).light(ModelData.DEFAULT_AMBIENT, 1400, ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        byte[] starMDTP = starModelDataTP.getFaceTransparencies();
        byte[] starMDTP2 = starModelDataTP2.getFaceTransparencies();
        byte[] starMDTP3 = starModelDataTP3.getFaceTransparencies();
        Arrays.fill(starMDTP, (byte) -80);
        Arrays.fill(starMDTP2, (byte) -80);
        Arrays.fill(starMDTP3, (byte) -80);

        ashAnimation = client.loadAnimation(ASH_ANIMATION);
        cloudAnimation = client.loadAnimation(CLOUD_ANIMATION);
        fogAnimation = client.loadAnimation(CLOUD_ANIMATION);
        rainAnimation = client.loadAnimation(RAIN_ANIMATION);
        snowAnimation = client.loadAnimation(SNOW_ANIMATION);
        starAnimation = client.loadAnimation(STAR_ANIMATION);
    }

    public Model getWeatherModel(Weather currentWeather, int alternative)
    {
        switch (currentWeather)
        {
            case ASHFALL:
                switch(alternative)
                {
                    default:
                    case 1:
                        return ashModel;
                    case 2:
                        return ashModel2;
                    case 3:
                        return ashModel3;
                }
            case CLOUDY:
            case PARTLY_CLOUDY:
                switch(alternative)
                {
                    default:
                    case 1:
                        return cloudModel;
                    case 2:
                        return cloudModel2;
                    case 3:
                        return cloudModel3;
                }
            case STARRY:
                switch(alternative)
                {
                    default:
                    case 1:
                        return starModel;
                    case 2:
                        return starModel2;
                    case 3:
                        return starModel3;
                }
            case FOGGY:
                return fogModel;
            case SNOWY:
                switch (alternative)
                {
                    default:
                    case 1:
                        return snowModel;
                    case 2:
                        return snowModel2;
                    case 3:
                        return snowModel3;
                }
            case RAINY:
                switch (alternative)
                {
                    default:
                    case 1:
                        return rainModel;
                    case 2:
                        return rainModel2;
                    case 3:
                        return rainModel3;
                }
            case STORMY:
                switch (alternative)
                {
                    default:
                    case 1:
                        return stormModel;
                    case 2:
                        return stormModel2;
                    case 3:
                        return stormModel3;
                }
            default:
            case COVERED:
            case SUNNY:
                return null;
        }
    }

    public Animation getWeatherAnimation(Weather currentWeather)
    {
        switch (currentWeather)
        {
            case ASHFALL:
                return ashAnimation;
            case CLOUDY:
            case PARTLY_CLOUDY:
                return cloudAnimation;
            case STARRY:
                return starAnimation;
            case FOGGY:
                return fogAnimation;
            case SNOWY:
                return snowAnimation;
            case RAINY:
            case STORMY:
                return rainAnimation;
            default:
            case COVERED:
            case SUNNY:
                return null;
        }
    }

    public Model getTransparentModel(Weather weatherType, int objectVariant)
    {
        switch (weatherType)
        {
            default:
            case CLOUDY:
            case PARTLY_CLOUDY:
                switch (objectVariant)
                {
                    default:
                    case 1:
                        return cloudModelTP;
                    case 2:
                        return cloudModelTP2;
                    case 3:
                        return cloudModelTP3;
                }
            case STARRY:
                switch (objectVariant)
                {
                    default:
                    case 1:
                        return starModelTP;
                    case 2:
                        return starModelTP2;
                    case 3:
                        return starModelTP3;
                }
        }
    }

    public Model getRegularModel(Weather weatherType, int objectVariant)
    {
        switch (weatherType)
        {
            default:
            case CLOUDY:
            case PARTLY_CLOUDY:
                switch (objectVariant)
                {
                    default:
                    case 1:
                        return cloudModel;
                    case 2:
                        return cloudModel2;
                    case 3:
                        return cloudModel3;
                }
            case STARRY:
                switch (objectVariant)
                {
                    default:
                    case 1:
                        return starModel;
                    case 2:
                        return starModel2;
                    case 3:
                        return starModel3;
                }
        }
    }

    public int getModelRadius(Weather weatherType)
    {
        switch (weatherType)
        {
            default:
            case ASHFALL:
            case STARRY:
            case RAINY:
            case STORMY:
            case SNOWY:
                return 60;
            case CLOUDY:
            case PARTLY_CLOUDY:
                //Size should be 500 but auto-disappear makes it irrelevant
                return 60;
            case FOGGY:
                return 90;
        }
    }
}

package com.weather3d;

import com.google.inject.Provides;
import com.weather3d.audio.SoundEffect;
import com.weather3d.audio.SoundPlayer;
import com.weather3d.conditions.Biome;
import com.weather3d.conditions.Season;
import com.weather3d.conditions.Weather;
import com.weather3d.conditions.WeatherManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.swing.*;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Random;

import static com.weather3d.CyclesConfig.SeasonType.DYNAMIC;
import static com.weather3d.CyclesConfig.SeasonType.HD_117;
import static com.weather3d.audio.SoundEffect.*;

@Slf4j
@PluginDescriptor(
	name = "3D Weather",
	description = "Creates immersive 3D Weather with dynamic Weather cycles and ambience",
	tags = {"immersion,", "weather", "ambience", "audio", "graphics"}
)
public class CyclesPlugin extends Plugin
{
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private CyclesConfig config;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private CyclesOverlay cyclesOverlay;
	@Inject
	private LightningOverlay lightningOverlay;
	@Inject
	private ConfigManager configManager;
	@Inject
	private PluginManager pluginManager;
	@Inject
	private ModelHandler modelHandler;

	private final Random random = new Random();
	private final ArrayList<WeatherManager> weatherManagerList = new ArrayList<>();
	private boolean loadedAnimsModels = false;
	private boolean conditionsSynced = false;
	private boolean isPlayerIndoors = false;
	public boolean flashLightning = false;
    private int savedChunk = 0;
	private int savedZPlane = -1;
	private int zoneObjRecovery = 0;
	private final int WINTERTODT_CHUNK = 6462;
	private final int OBJ_ROTATION_CONSTANT = 20;
	private final int MODEL_TRANSPARENT_SWAP_DISTANCE = 3000;
	private final int MODEL_DISAPPEAR_DISTANCE = 2500;
	private final int FOG_RADIUS = 100;

	@Getter
	private Season currentSeason = Season.SPRING;
	@Getter
	private Biome currentBiome = Biome.GRASSLAND;
	@Getter
	private Weather currentWeather;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(cyclesOverlay);
		overlayManager.add(lightningOverlay);

		if (client.getLocalPlayer() != null)
		{
			syncBiome();
			syncSeason();
			setConfigWeather();
			handleWeatherManagers();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientThread.invoke(this::clearAllWeatherManagers);
		overlayManager.remove(cyclesOverlay);
		overlayManager.remove(lightningOverlay);
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			Weather weatherType = weatherManager.getWeatherType();

			if (weatherType == Weather.CLOUDY
					|| weatherType == Weather.PARTLY_CLOUDY
					|| weatherType == Weather.STARRY)
			{
				LocalPoint localPoint = new LocalPoint(client.getCameraX(), client.getCameraY());

				for (WeatherObject weatherObject : weatherManager.getWeatherObjArray())
				{
					RuneLiteObject runeLiteObject = weatherObject.getRuneLiteObject();
					int objectVariant = weatherObject.getObjVariant();
					int distance = runeLiteObject.getLocation().distanceTo(localPoint);

					if (distance < MODEL_DISAPPEAR_DISTANCE)
					{
						runeLiteObject.setActive(false);
						continue;
					}

					runeLiteObject.setActive(true);

					if (distance < MODEL_TRANSPARENT_SWAP_DISTANCE)
					{
						runeLiteObject.setModel(modelHandler.getTransparentModel(weatherType, objectVariant));
						continue;
					}

					runeLiteObject.setModel(modelHandler.getRegularModel(weatherType, objectVariant));
				}
			}
		}
	}


	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (!loadedAnimsModels)
		{
			modelHandler.loadModels();
			loadedAnimsModels = true;
		}

		if (!conditionsSynced)
		{
			setConfigWeather();
			if (currentWeather.isHasPrecipitation())
			{
				handleWeatherManagers();
			}
			conditionsSynced = true;
		}

		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		syncSeason();
		syncBiome();

		isPlayerIndoors = true;
		WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();
		for (Tile t : getAvailableTiles())
		{
			if (t.getWorldLocation().getX() == playerLoc.getX() && t.getWorldLocation().getY() == playerLoc.getY())
			{
				isPlayerIndoors = false;
			}
		}

		if (config.weatherType() == CyclesConfig.WeatherType.DYNAMIC)
		{
			Weather nextWeather = syncWeather(currentSeason, currentBiome);

			if (nextWeather != currentWeather)
			{
				setConfigWeather();
				handleWeatherManagers();
			}
			conditionsSynced = true;
		}

		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager wm = weatherManagerList.get(i);
			if (wm.isFading())
			{
				fadeWeatherManager(wm);
			}
			else
			{
				handleWeatherChanges(wm);
			}

			handleSoundChanges(wm);
		}

		clearFadedWeatherManagers();

		if (savedZPlane != client.getPlane())
		{
			transitionZPlane();
			savedZPlane = client.getPlane();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		GameState gameState = event.getGameState();
		if (gameState == GameState.LOGIN_SCREEN || gameState == GameState.LOGIN_SCREEN_AUTHENTICATOR || gameState == GameState.STARTING)
		{
			clientThread.invoke(this::clearAllWeatherManagers);
			return;
		}

		if (gameState != GameState.LOGGED_IN)
			return;

		syncBiome();
		syncSeason();
		setConfigWeather();
		handleWeatherManagers();
		handleZoneTransition();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (!event.getGroup().equals("3Dweather"))
			return;

		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		String key = event.getKey();

		if (key.equals("weatherType"))
		{
			setConfigWeather();
			handleWeatherManagers();
			return;
		}

		if (key.equals("disableWeatherUnderground"))
		{
			if (!config.disableWeatherUnderground())
				return;

			if (currentBiome == Biome.CAVE || currentBiome == Biome.LAVA_CAVE)
				clientThread.invoke(this::clearAllWeatherManagers);
		}

		if (key.equals("seasonType"))
		{
			syncSeason();
			return;
		}

		if (key.equals("ashfallDensity"))
			handleConfigDensityChange(Weather.ASHFALL, config.ashfallDensity());

		if (key.equals("rainDensity"))
			handleConfigDensityChange(Weather.RAINY, config.rainDensity());

		if (key.equals("stormDensity"))
			handleConfigDensityChange(Weather.STORMY, config.stormDensity());

		if (key.equals("snowDensity"))
			handleConfigDensityChange(Weather.SNOWY, config.snowDensity());

		if (key.equals("partlyCloudyDensity"))
			handleConfigDensityChange(Weather.PARTLY_CLOUDY, config.partlyCloudyDensity());

		if (key.equals("cloudyDensity"))
			handleConfigDensityChange(Weather.CLOUDY, config.cloudyDensity());

		if (key.equals("foggyDensity"))
			handleConfigDensityChange(Weather.FOGGY, config.foggyDensity());

		if (key.equals("starryDensity"))
			handleConfigDensityChange(Weather.STARRY, config.starryDensity());

		if (event.getKey().equals("toggleOverlay"))
		{
			if (config.toggleOverlay())
			{
				overlayManager.add(cyclesOverlay);
				return;
			}

			overlayManager.remove(cyclesOverlay);
			return;
		}

		if (event.getKey().equals("toggleAmbience"))
		{
			for (int i = 0; i < weatherManagerList.size(); i++)
			{
				WeatherManager weatherManager = weatherManagerList.get(i);
				if (weatherManager.getWeatherType().isHasSound())
				{
					if (config.toggleAmbience())
					{
						handleSoundChanges(weatherManager);
						return;
					}

					weatherManager.stopManagerSoundPlayers();
				}
			}
			return;
		}

		if (key.equals("enableRain"))
		{
			handleConfigEnableChange(Weather.RAINY, Boolean.getBoolean(event.getNewValue()));
			handleConfigEnableChange(Weather.STORMY, Boolean.getBoolean(event.getNewValue()));
		}

		if (key.equals("enableSnow"))
			handleConfigEnableChange(Weather.SNOWY, Boolean.getBoolean(event.getNewValue()));

		if (key.equals("enableClouds"))
		{
			handleConfigEnableChange(Weather.CLOUDY, Boolean.getBoolean(event.getNewValue()));
			handleConfigEnableChange(Weather.PARTLY_CLOUDY, Boolean.getBoolean(event.getNewValue()));
		}

		if (key.equals("enableAsh"))
			handleConfigEnableChange(Weather.ASHFALL, Boolean.getBoolean(event.getNewValue()));

		if (key.equals("enableFog"))
			handleConfigEnableChange(Weather.FOGGY, Boolean.getBoolean(event.getNewValue()));

		if (key.equals("enableStars"))
			handleConfigEnableChange(Weather.STARRY, Boolean.getBoolean(event.getNewValue()));


		if (event.getKey().equals("enableWintertodtSnow"))
		{
			if (config.enableWintertodtSnow())
				return;

			int playerChunk = client.getLocalPlayer().getWorldLocation().getRegionID();

			if (playerChunk == WINTERTODT_CHUNK)
			{
				for (int i = 0; i < weatherManagerList.size(); i++)
				{
					WeatherManager weatherManager = weatherManagerList.get(i);
					if (weatherManager.getWeatherType() == Weather.SNOWY)
					{
						clientThread.invoke(() -> clearWeatherObjects(weatherManager));
						clientThread.invoke(weatherManager::stopManagerSoundPlayers);
					}
				}
			}
		}
	}

	private int getAmbientVolume()
	{
		return config.useAreaSoundsVolume() ?
			client.getPreferences().getAreaSoundEffectVolume() : config.ambientVolume();
	}

	private void handleConfigEnableChange(Weather weather, boolean enabled)
	{
		if (enabled)
			return;

		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			if (weatherManager.getWeatherType() == weather)
			{
				clientThread.invoke(() -> clearWeatherObjects(weatherManager));
				clientThread.invoke(weatherManager::stopManagerSoundPlayers);
			}
		}
	}

	private void handleConfigDensityChange(Weather weatherType, int newDensity)
	{
		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			Weather weather = weatherManager.getWeatherType();
			if (weather != weatherType)
				continue;

			if (weather.isHasPrecipitation())
			{
				ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();

				while (array.size() > newDensity)
				{
					removeWeatherObject(0, array);
				}
			}
		}
	}

	public void handleWeatherManagers()
	{
		boolean activeManager = false;
		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			weatherManager.setFading(true);
			if (weatherManager.getWeatherType() == currentWeather)
			{
				weatherManager.setFading(false);
				activeManager = true;
			}
		}

		if (!activeManager && currentWeather.isHasPrecipitation())
			SwingUtilities.invokeLater(this::createWeatherManager);
	}

	public void handleSoundChanges(WeatherManager weatherManager)
	{
		//Update soundplayer timers
		for (SoundPlayer sp : weatherManager.getSoundPlayers())
		{
			if (sp.isPlaying())
			{
				sp.setTimer(sp.getTimer() + 1);
			}
		}

		Weather weather = weatherManager.getWeatherType();

		if (!weather.isHasSound() || !config.toggleAmbience())
			return;

		if (config.weatherType() != CyclesConfig.WeatherType.DYNAMIC && config.disableWeatherUnderground() && (currentBiome == Biome.CAVE || currentBiome == Biome.LAVA_CAVE))
			return;

		//Fade out inappropriate weathermanager soundplayers
		if (weather != currentWeather)
		{
			for (SoundPlayer sp : weatherManager.getSoundPlayers())
			{
				if (sp.isPlaying())
				{
					if (!sp.isFading())
					{
						sp.setFading(true);
						sp.smoothVolumeChange(0, 6000);
					}
				}
			}
			return;
		}
		else
		{
			//This happens when you switch from weather condition A to weather condition B and then back to A again before the first transition was finished
			if (weatherManager.getPrimarySoundPlayer().isFading())
			{
				weatherManager.getPrimarySoundPlayer().setFading(false);
				weatherManager.getPrimarySoundPlayer().getVolumeChangeHandler().interrupt(); //stop fading oot
			}
		}

		//The following code of this function only runs on the appropriate weathermanager

		SoundEffect appropriateSound;
		boolean muffled = false;
		SoundEffect outdoorSound = weatherManager.getWeatherType().getSoundEffect();
		if (isPlayerIndoors && !config.disableIndoorMuffling())
		{
			if (outdoorSound == RAIN)
			{
				appropriateSound = RAIN_MUFFLED;
				muffled = true;
			}
			else if (outdoorSound == THUNDERSTORM)
			{
				appropriateSound = THUNDERSTORM_MUFFLED;
				muffled = true;
			}
			else if (outdoorSound == WIND)
			{
				appropriateSound = WIND_MUFFLED;
				muffled = true;
			}
			else
			{
				appropriateSound = outdoorSound;
			}
		}
		else
		{
			appropriateSound = outdoorSound;
		}

		// Make sure the primary soundplayer is at the right volume, if it's not already fading in or whatever
		int currentVolume = weatherManager.getPrimarySoundPlayer().getCurrentVolume();
		int volumeGoal = getVolumeGoal(muffled, weather);
		int changeRate = 6000;

		if (weatherManager.getPrimarySoundPlayer().getCurrentTrack() != null && currentVolume != volumeGoal)
		{
			//If the volume change handler is uninitialized, or is initialized and isn't currently changing the volume
			if (weatherManager.getPrimarySoundPlayer().getVolumeChangeHandler() == null || !weatherManager.getPrimarySoundPlayer().getVolumeChangeHandler().isAlive())
			{
				log.debug("Primary at wrong volume. Setting back to " + volumeGoal);
				weatherManager.getPrimarySoundPlayer().smoothVolumeChange(volumeGoal, changeRate);
			}
		}

		// Initialize the primary soundplayer if it ain't initialized yet, or is not playing for some reason
		if (weatherManager.getPrimarySoundPlayer().getCurrentTrack() == null || !weatherManager.getPrimarySoundPlayer().isPlaying())
		{
			log.debug("Initializing soundplayer at volume " + (int)(getAmbientVolume() * getWeatherDensityFactor(weather)));
			weatherManager.getPrimarySoundPlayer().setVolumeLevel(0);
			weatherManager.getPrimarySoundPlayer().smoothVolumeChange(volumeGoal, 12000);
			weatherManager.getPrimarySoundPlayer().playClip(appropriateSound);
		}
		//Handle looping, as well as muffling/unmuffling of sound when player walks indoors/outdoors
		else if (weatherManager.getPrimarySoundPlayer().getCurrentTrack() != appropriateSound || weatherManager.getPrimarySoundPlayer().getTimer() > 230)
		{
			log.debug("Looping because " + weatherManager.getPrimarySoundPlayer().getCurrentTrack() + " != " + appropriateSound + " or it was just time to loop");
			weatherManager.getPrimarySoundPlayer().smoothVolumeChange(0, changeRate);
			weatherManager.switchSoundPlayerPriority();
			if (!weatherManager.getPrimarySoundPlayer().isPlaying())
			{
				weatherManager.getPrimarySoundPlayer().setVolumeLevel(0);
				weatherManager.getPrimarySoundPlayer().playClip(appropriateSound);
			}
			weatherManager.getPrimarySoundPlayer().smoothVolumeChange(volumeGoal, changeRate);
		}

		if (weather == Weather.STORMY && (weatherManager.getPrimarySoundPlayer().getTimer() == 90 || weatherManager.getPrimarySoundPlayer().getTimer() == 138))
			flashLightning = true;
	}

	public int getObjectTarget(Weather weather)
	{
		switch (weather)
		{
			case ASHFALL:
				return config.ashfallDensity();
			case FOGGY:
				return config.foggyDensity();
			case RAINY:
				return config.rainDensity();
			case SNOWY:
				return config.snowDensity();
			case CLOUDY:
				return config.cloudyDensity();
			case STARRY:
				return config.starryDensity();
			case STORMY:
				return config.stormDensity();
			case PARTLY_CLOUDY:
				return config.partlyCloudyDensity();
			default:
			case SUNNY:
			case COVERED:
				return 0;
		}
	}

	public int getVolumeGoal(boolean muffled, Weather weather)
	{
		double weatherDensityFactor = getWeatherDensityFactor(weather);
		double volumeDouble = getAmbientVolume() * weatherDensityFactor;

		if (muffled)
			volumeDouble = config.muffledVolume() * weatherDensityFactor;

		return (int) volumeDouble;
	}

	public double getWeatherDensityFactor(Weather weather)
	{
		double factor = (double) weather.getMaxObjects() / (double) weather.getMaxObjectVolume();
		if (factor > 1)
			factor = 1;

		return factor;
	}

	public boolean weatherEnabled(Weather weather)
	{
		switch (weather)
		{
			case ASHFALL:
				return config.enableAsh();
			case FOGGY:
				return config.enableFog();
			case RAINY:
			case STORMY:
				return config.enableRain();
			case SNOWY:
				return config.enableSnow();
			case CLOUDY:
			case PARTLY_CLOUDY:
				return config.enableClouds();
			case STARRY:
				return config.enableStars();
			default:
			case COVERED:
			case SUNNY:
				return true;
		}
	}

	public void createWeatherManager()
	{
		SoundPlayer[] soundPlayers = new SoundPlayer[]{new SoundPlayer(), new SoundPlayer()};
		WeatherManager weatherManager = new WeatherManager(currentWeather, soundPlayers, 0, new ArrayList<>(), 0, false);
		weatherManagerList.add(weatherManager);
	}

	public void fadeWeatherManager(WeatherManager weatherManager)
	{
		int trimNumber = weatherManager.getWeatherType().getMaxObjects() / OBJ_ROTATION_CONSTANT;
		ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();

		if (trimNumber < array.size() / OBJ_ROTATION_CONSTANT)
			trimNumber = array.size() / OBJ_ROTATION_CONSTANT;

		if (trimNumber == 0)
			trimNumber = 1;

		trimWeatherArray(weatherManager, 0, trimNumber);
	}

	public void clearFadedWeatherManagers()
	{
		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);

			if (weatherManager.isFading() && weatherManager.getWeatherObjArray().isEmpty())
			{
				boolean readyToRemove = true;

				for (SoundPlayer soundPlayer : weatherManager.getSoundPlayers())
				{
					if (soundPlayer.isPlaying())
					{
						readyToRemove = false;
					}
				}

				if (readyToRemove)
				{
					weatherManagerList.remove(weatherManager);
					i--;
				}
			}
		}
	}

	public void clearAllWeatherManagers()
	{
		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			clearWeatherObjects(weatherManager);
			weatherManager.stopManagerSoundPlayers();
		}
		weatherManagerList.clear();
	}

	public void handleWeatherChanges(WeatherManager weatherManager)
	{
		Weather weather = weatherManager.getWeatherType();

		if (config.weatherType() != CyclesConfig.WeatherType.DYNAMIC && config.disableWeatherUnderground() && (currentBiome == Biome.CAVE || currentBiome == Biome.LAVA_CAVE))
			return;

		if (!weatherEnabled(weather))
			return;

		if (!config.enableWintertodtSnow() && weather == Weather.SNOWY)
		{
			int playerChunk = client.getLocalPlayer().getWorldLocation().getRegionID();
			if (playerChunk == WINTERTODT_CHUNK)
			{
				return;
			}
		}

		int objectTarget = getObjectTarget(weather);
		ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();

		if (array.size() < objectTarget)
		{
			if (zoneObjRecovery > 0)
			{
				relocateObjects(weatherManager, objectTarget / (OBJ_ROTATION_CONSTANT / 2));
				zoneObjRecovery--;
			}
			renderWeather(objectTarget / OBJ_ROTATION_CONSTANT, weatherManager);
		}
		else if (array.size() == objectTarget && client.getTickCount() % weather.getChangeRate() == 0)
		{
			relocateObjects(weatherManager, objectTarget / OBJ_ROTATION_CONSTANT);
		}
	}

	private void renderWeather(int objects, WeatherManager weatherManager)
	{
		Weather weather = weatherManager.getWeatherType();
		int z = client.getPlane();
		ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();
		Animation weatherAnimation = modelHandler.getWeatherAnimation(weather);
		int alternate = 1;
		ArrayList<Tile> availableTiles = getAvailableTiles();

		for (int i = 0; i < objects; i++)
		{
			int roll;
			Tile openTile;
			switch (weather)
			{
				default:
					roll = random.nextInt(availableTiles.size());
					openTile = availableTiles.get(roll);
			}

			WeatherObject weatherObject = createWeatherObject(weather, weatherAnimation, openTile.getLocalLocation(), z, alternate);
			alternate += 1;
			if (alternate > weather.getModelVariety())
				alternate = 1;

			array.add(weatherObject);
			if (array.size() == getObjectTarget(weather))
				return;
		}
	}

	public WeatherObject createWeatherObject(Weather weather, Animation weatherAnimation, LocalPoint lp, int plane, int objectVariant)
	{
		RuneLiteObject runeLiteObject = client.createRuneLiteObject();
		Model weatherModel = modelHandler.getWeatherModel(weather, objectVariant);
		int radius = modelHandler.getModelRadius(weather);
		boolean drawFrontTilesFirst = true;
		if (plane > 0)
		{
			radius = 0;
			drawFrontTilesFirst = false;
		}

		runeLiteObject.setModel(weatherModel);
		runeLiteObject.setRadius(radius);
		runeLiteObject.setDrawFrontTilesFirst(drawFrontTilesFirst);
		runeLiteObject.setAnimation(weatherAnimation);
		runeLiteObject.setLocation(lp, plane);
		runeLiteObject.setShouldLoop(true);
		runeLiteObject.setActive(true);
		return new WeatherObject(runeLiteObject, objectVariant);
	}

	public void removeWeatherObject(int index, ArrayList<WeatherObject> weatherArray)
	{
		if (index >= weatherArray.size())
			return;

		WeatherObject weatherObject = weatherArray.get(index);
		clientThread.invokeLater(() -> weatherObject.getRuneLiteObject().setActive(false));
		weatherArray.remove(index);
	}

	public void clearWeatherObjects(WeatherManager weatherManager)
	{
		ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();

		for (WeatherObject weatherObject : array)
			weatherObject.getRuneLiteObject().setActive(false);

		array.clear();
	}

	public void trimWeatherArray(WeatherManager weatherManager, int start, int end)
	{
		for (int i = start; i < end; i++)
			removeWeatherObject(start, weatherManager.getWeatherObjArray());
	}

	public void relocateObjects(WeatherManager weatherManager, int numToRelocate)
	{
		int z = client.getPlane();
		int beginRotation = weatherManager.getStartRotation();
		ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();
		Weather weather = weatherManager.getWeatherType();
		ArrayList<Tile> availableTiles = getAvailableTiles();

		for (int i = beginRotation; i < beginRotation + numToRelocate; i++)
		{
			int roll;
			Tile nextTile;
			switch (weather)
			{
				/*
				case FOGGY:
					roll = random.nextInt(availableFogTiles.size());
					nextTile = availableFogTiles.get(roll);
					break;

				 */
				default:
					roll = random.nextInt(availableTiles.size());
					nextTile = availableTiles.get(roll);
			}

			if (i >= array.size())
			{
				break;
			}

			WeatherObject weatherObject = array.get(i);
			RuneLiteObject runeLiteObject = weatherObject.getRuneLiteObject();
			runeLiteObject.setLocation(nextTile.getLocalLocation(), z);
			runeLiteObject.setAnimation(modelHandler.getWeatherAnimation(weather));
		}

		weatherManager.setStartRotation(beginRotation + numToRelocate);

		if (beginRotation > getObjectTarget(weather))
			weatherManager.setStartRotation(0);
	}

	public void transitionZPlane()
	{
		if (!currentWeather.isHasPrecipitation())
		{
			clearAllWeatherManagers();
			return;
		}

		handleZoneTransition();
	}

	public void handleZoneTransition()
	{
		if (config.weatherType() != CyclesConfig.WeatherType.DYNAMIC && config.disableWeatherUnderground() && (currentBiome == Biome.CAVE || currentBiome == Biome.LAVA_CAVE))
		{
			clientThread.invoke(this::clearAllWeatherManagers);
			return;
		}

		for (int i = 0; i < weatherManagerList.size(); i++)
		{
			WeatherManager weatherManager = weatherManagerList.get(i);
			Weather weatherType = weatherManager.getWeatherType();
			ArrayList<WeatherObject> array = weatherManager.getWeatherObjArray();
			int size = (int) (array.size() * 0.8);
			clearWeatherObjects(weatherManager);
			if (weatherType == currentWeather)
			{
				renderWeather(size, weatherManager);
				zoneObjRecovery = 4;
			}
		}
	}

	public ArrayList<Tile> getAvailableTiles()
	{
		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getTiles();
		byte[][][] settings = client.getTileSettings();
		int zLayer = client.getPlane();
		ArrayList<Tile> availableTiles = new ArrayList<>();

		for (int z = 0; z <= zLayer; z++)
		{
			for (int x = 0; x < Constants.SCENE_SIZE; ++x)
			{
				for (int y = 0; y < Constants.SCENE_SIZE; ++y)
				{
					Tile tile = tiles[z][x][y];

					if (tile == null)
						continue;

					int flag = settings[z][x][y];

					if ((flag & Constants.TILE_FLAG_UNDER_ROOF) != 0)
						continue;

					if (zLayer > 0)
					{
						boolean bridgeFlag = false;
						for (int i = 0; i < 4; i++)
						{
							int floorFlag = settings[i][x][y];
							if ((floorFlag & Constants.TILE_FLAG_BRIDGE) != 0)
							{
								bridgeFlag = true;
								break;
							}
						}

						if (bridgeFlag)
						{
							continue;
						}
					}

					availableTiles.add(tile);

					/*
					if (wallCollision(tile))
						continue;

					availableFogTiles.add(tile);

					 */
				}
			}
		}
		return availableTiles;
	}

	private boolean wallCollision(Tile targetTile)
	{
		Scene scene = client.getScene();
		Tile[][][] tiles = scene.getTiles();
		int zLayer = client.getPlane();

		for (int z = 0; z <= zLayer; z++)
		{
			for (int x = 0; x < Constants.SCENE_SIZE; ++x)
			{
				for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
					Tile tile = tiles[z][x][y];

					if (tile == null)
						continue;

					if (tile.getWallObject() == null)
						continue;

					if (tile.getLocalLocation().distanceTo(targetTile.getLocalLocation()) < FOG_RADIUS)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public void setConfigWeather()
	{
		switch(config.weatherType())
		{
			case ASHFALL:
				currentWeather = Weather.ASHFALL;
				break;
			default:
			case DYNAMIC:
				currentWeather = syncWeather(currentSeason, currentBiome);
				break;
			case CLOUDY:
				currentWeather = Weather.CLOUDY;
				break;
			case CLEAR:
				currentWeather = Weather.SUNNY;
				break;
			case FOGGY:
				currentWeather = Weather.FOGGY;
				break;
			case PARTLY_CLOUDY:
				currentWeather = Weather.PARTLY_CLOUDY;
				break;
			case RAINY:
				currentWeather = Weather.RAINY;
				break;
			case SNOWY:
				currentWeather = Weather.SNOWY;
				break;
			case STARRY:
				currentWeather = Weather.STARRY;
				break;
			case STORMY:
				currentWeather = Weather.STORMY;
				break;
		}
	}

	private Weather syncWeather(Season seasonCondition, Biome biomeCondition)
	{
		int totalMin = CyclesClock.getTimeHours() * 60 + CyclesClock.getTimeMinutes();
		int cycleSegment = (totalMin / 15) % 12;
		for (WeatherForecast forecast : WeatherForecast.values())
		{
			if (forecast.getSeasonCondition() == seasonCondition && forecast.getBiomeCondition() == biomeCondition)
			{
				return forecast.getForecastArray()[cycleSegment];
			}
		}
		return Weather.COVERED;
	}

	private void syncBiome()
	{
		WorldPoint wp = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation(), client.getPlane());
		int playerChunk = wp.getRegionID();

		if (savedChunk != playerChunk)
		{
			currentBiome = BiomeChunkMap.checkBiome(playerChunk);
			savedChunk = playerChunk;
		}
	}

	private void syncSeason()
	{
		boolean is117Enabled = pluginManager.getPlugins().stream()
			.filter((plugin) -> plugin.getName().equals("117 HD"))
			.map((plugin) -> pluginManager.isPluginEnabled(plugin)).findFirst().orElse(false);

		// If the season type is 117 and it's not enabled then fallback to DYNAMIC
		CyclesConfig.SeasonType seasonType = config.seasonType().equals(HD_117) && !is117Enabled ? DYNAMIC : config.seasonType();

        switch (seasonType)
		{
			default:
			case DYNAMIC:
				switch ((CyclesClock.getTimeDays() / 7) % 4)
				{
					default:
					case 0:
						currentSeason = Season.SPRING;
						return;
					case 1:
						currentSeason = Season.SUMMER;
						return;
					case 2:
						currentSeason = Season.AUTUMN;
						return;
					case 3:
						currentSeason = Season.WINTER;
						return;
				}
			case SPRING:
				currentSeason =  Season.SPRING;
				return;
			case SUMMER:
				currentSeason =  Season.SUMMER;
				return;
			case AUTUMN:
				currentSeason =  Season.AUTUMN;
				return;
			case WINTER:
				currentSeason =  Season.WINTER;
			case HD_117:
				try
				{
					String seasonalTheme = configManager.getConfiguration("hd", "seasonalTheme", String.class);
					switch (seasonalTheme)
					{
						case "AUTOMATIC":
							// Not a fan of repeating 117's logic here, but can't think of a better way.
							// Source: https://github.com/117HD/RLHD/blob/ec91118e3190add9b821350576af56af1c723848/src/main/java/rs117/hd/HdPlugin.java#L2399-L2416
							ZonedDateTime time = ZonedDateTime.now(ZoneOffset.UTC);
							switch (time.getMonth()) {
								case SEPTEMBER:
								case OCTOBER:
								case NOVEMBER:
									currentSeason = Season.AUTUMN;
									break;
								case DECEMBER:
								case JANUARY:
								case FEBRUARY:
									currentSeason = Season.WINTER;
                                    break;
								default:
									currentSeason = Season.SUMMER;
                                    break;
							}
							break;
						case "SUMMER":
							currentSeason = Season.SUMMER;
							break;
						case "WINTER":
							currentSeason = Season.WINTER;
                            break;
						case "AUTUMN":
							currentSeason = Season.AUTUMN;
                    }
				}
				catch (Exception e)
				{}
				break;
		}
	}

	@Provides
    CyclesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CyclesConfig.class);
	}
}
package com.weather3d;

import com.weather3d.conditions.Biome;
import com.weather3d.conditions.Season;
import com.weather3d.conditions.Weather;
import lombok.Getter;

public enum WeatherForecast {
    SPRING_ARCTIC(Season.SPRING, Biome.ARCTIC, new Weather[]
            {Weather.CLOUDY, Weather.SNOWY, Weather.SNOWY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.FOGGY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.CLOUDY}),
    SPRING_BARRENS(Season.SPRING, Biome.BARRENS, new Weather[]
            {Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.STORMY, Weather.PARTLY_CLOUDY, Weather.SUNNY,  Weather.PARTLY_CLOUDY}),
    SPRING_CAVE(Season.SPRING, Biome.CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    SPRING_COSMOS(Season.SPRING, Biome.COSMOS, new Weather[]
            {Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY}),
    SPRING_DESERT(Season.SPRING, Biome.DESERT, new Weather[]
            {Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY}),
    SPRING_FOREST(Season.SPRING, Biome.FOREST, new Weather[]
            {Weather.SUNNY, Weather.FOGGY, Weather.RAINY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.RAINY, Weather.STORMY, Weather.CLOUDY}),
    SPRING_GRASSLAND(Season.SPRING, Biome.GRASSLAND, new Weather[]
            {Weather.RAINY, Weather.STORMY, Weather.SUNNY, Weather.CLOUDY, Weather.FOGGY, Weather.SUNNY, Weather.RAINY, Weather.CLOUDY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.SUNNY}),
    SPRING_LAVA_CAVE(Season.SPRING, Biome.LAVA_CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    SPRING_MOUNTAIN(Season.SPRING, Biome.MOUNTAIN, new Weather[]
            {Weather.STORMY, Weather.SNOWY, Weather.CLOUDY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.CLOUDY, Weather.SNOWY, Weather.SNOWY, Weather.STORMY, Weather.SUNNY, Weather.CLOUDY}),
    SPRING_SWAMP(Season.SPRING, Biome.SWAMP, new Weather[]
            {Weather.FOGGY, Weather.RAINY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.SUNNY, Weather.RAINY, Weather.CLOUDY, Weather.FOGGY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.FOGGY}),
    SPRING_TROPICAL(Season.SPRING, Biome.TROPICAL, new Weather[]
            {Weather.RAINY, Weather.STORMY, Weather.RAINY, Weather.CLOUDY, Weather.STORMY, Weather.RAINY, Weather.RAINY, Weather.SUNNY, Weather.CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.CLOUDY}),
    SPRING_WILDERNESS(Season.SPRING, Biome.WILDERNESS, new Weather[]
            {Weather.ASHFALL, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.ASHFALL, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.ASHFALL, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.ASHFALL, Weather.SUNNY}),

    SUMMER_ARCTIC(Season.SUMMER, Biome.ARCTIC, new Weather[]
            {Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.FOGGY, Weather.SUNNY, Weather.CLOUDY, Weather.STORMY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.STORMY}),
    SUMMER_BARRENS(Season.SUMMER, Biome.BARRENS, new Weather[]
            {Weather.SUNNY, Weather.SUNNY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.STORMY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.STORMY, Weather.CLOUDY}),
    SUMMER_CAVE(Season.SUMMER, Biome.CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    SUMMER_COSMOS(Season.SUMMER, Biome.COSMOS, new Weather[]
            {Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY}),
    SUMMER_DESERT(Season.SUMMER, Biome.DESERT, new Weather[]
            {Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY}),
    SUMMER_FOREST(Season.SUMMER, Biome.FOREST, new Weather[]
            {Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.STORMY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.RAINY}),
    SUMMER_GRASSLAND(Season.SUMMER, Biome.GRASSLAND, new Weather[]
            {Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.STORMY, Weather.RAINY, Weather.PARTLY_CLOUDY}),
    SUMMER_LAVA_CAVE(Season.SUMMER, Biome.LAVA_CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    SUMMER_MOUNTAIN(Season.SUMMER, Biome.MOUNTAIN, new Weather[]
            {Weather.RAINY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.STORMY, Weather.RAINY, Weather.CLOUDY, Weather.FOGGY, Weather.RAINY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY}),
    SUMMER_SWAMP(Season.SUMMER, Biome.SWAMP, new Weather[]
            {Weather.SUNNY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.FOGGY, Weather.RAINY, Weather.CLOUDY, Weather.RAINY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.RAINY}),
    SUMMER_TROPICAL(Season.SUMMER, Biome.TROPICAL, new Weather[]
            {Weather.STORMY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.STORMY, Weather.RAINY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.RAINY}),
    SUMMER_WILDERNESS(Season.SUMMER, Biome.WILDERNESS, new Weather[]
            {Weather.ASHFALL, Weather.ASHFALL, Weather.ASHFALL, Weather.SUNNY, Weather.SUNNY, Weather.ASHFALL, Weather.SUNNY, Weather.ASHFALL, Weather.ASHFALL, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY}),

    AUTUMN_ARCTIC(Season.AUTUMN, Biome.ARCTIC, new Weather[]
            {Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.SNOWY, Weather.SUNNY, Weather.FOGGY, Weather.FOGGY, Weather.CLOUDY, Weather.SNOWY, Weather.CLOUDY}),
    AUTUMN_BARRENS(Season.AUTUMN, Biome.BARRENS, new Weather[]
            {Weather.RAINY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.STORMY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.PARTLY_CLOUDY}),
    AUTUMN_CAVE(Season.AUTUMN, Biome.CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    AUTUMN_COSMOS(Season.AUTUMN, Biome.COSMOS, new Weather[]
            {Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY}),
    AUTUMN_DESERT(Season.AUTUMN, Biome.DESERT, new Weather[]
            {Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY}),
    AUTUMN_FOREST(Season.AUTUMN, Biome.FOREST, new Weather[]
            {Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.RAINY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.CLOUDY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.SUNNY}),
    AUTUMN_GRASSLAND(Season.AUTUMN, Biome.GRASSLAND, new Weather[]
            {Weather.FOGGY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.SUNNY, Weather.CLOUDY, Weather.STORMY, Weather.SUNNY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.SUNNY}),
    AUTUMN_LAVA_CAVE(Season.AUTUMN, Biome.LAVA_CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    AUTUMN_MOUNTAIN(Season.AUTUMN, Biome.MOUNTAIN, new Weather[]
            {Weather.FOGGY, Weather.SNOWY, Weather.CLOUDY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.STORMY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.STORMY}),
    AUTUMN_SWAMP(Season.AUTUMN, Biome.SWAMP, new Weather[]
            {Weather.FOGGY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.RAINY, Weather.FOGGY, Weather.STORMY, Weather.FOGGY, Weather.RAINY, Weather.RAINY, Weather.FOGGY, Weather.CLOUDY}),
    AUTUMN_TROPICAL(Season.AUTUMN, Biome.TROPICAL, new Weather[]
            {Weather.RAINY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.STORMY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.STORMY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.STORMY}),
    AUTUMN_WILDERNESS(Season.AUTUMN, Biome.WILDERNESS, new Weather[]
            {Weather.PARTLY_CLOUDY, Weather.ASHFALL, Weather.SUNNY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.ASHFALL, Weather.ASHFALL, Weather.PARTLY_CLOUDY, Weather.ASHFALL, Weather.SUNNY, Weather.SUNNY, Weather.ASHFALL}),

    WINTER_ARCTIC(Season.WINTER, Biome.ARCTIC, new Weather[]
            {Weather.SNOWY, Weather.SNOWY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SNOWY, Weather.SNOWY, Weather.FOGGY, Weather.SNOWY, Weather.CLOUDY, Weather.SNOWY, Weather.FOGGY}),
    WINTER_BARRENS(Season.WINTER, Biome.BARRENS, new Weather[]
            {Weather.FOGGY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.CLOUDY, Weather.STORMY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.STORMY, Weather.CLOUDY, Weather.STORMY, Weather.SUNNY}),
    WINTER_CAVE(Season.WINTER, Biome.CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    WINTER_COSMOS(Season.WINTER, Biome.COSMOS, new Weather[]
            {Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.STARRY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY, Weather.SUNNY}),
    WINTER_DESERT(Season.WINTER, Biome.DESERT, new Weather[]
            {Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.CLOUDY, Weather.SUNNY, Weather.SUNNY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.PARTLY_CLOUDY, Weather.PARTLY_CLOUDY, Weather.SUNNY}),
    WINTER_FOREST(Season.WINTER, Biome.FOREST, new Weather[]
            {Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.FOGGY, Weather.SUNNY, Weather.CLOUDY, Weather.SNOWY, Weather.SNOWY, Weather.CLOUDY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SUNNY}),
    WINTER_GRASSLAND(Season.WINTER, Biome.GRASSLAND, new Weather[]
            {Weather.SNOWY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.FOGGY, Weather.SNOWY, Weather.SNOWY, Weather.PARTLY_CLOUDY, Weather.SUNNY, Weather.SNOWY, Weather.CLOUDY, Weather.PARTLY_CLOUDY}),
    WINTER_LAVA_CAVE(Season.WINTER, Biome.LAVA_CAVE, new Weather[]
            {Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED, Weather.COVERED}),
    WINTER_MOUNTAIN(Season.WINTER, Biome.MOUNTAIN, new Weather[]
            {Weather.SNOWY, Weather.SNOWY, Weather.STORMY, Weather.SNOWY, Weather.CLOUDY, Weather.STORMY, Weather.SNOWY, Weather.FOGGY, Weather.SUNNY, Weather.STORMY, Weather.STORMY, Weather.CLOUDY}),
    WINTER_SWAMP(Season.WINTER, Biome.SWAMP, new Weather[]
            {Weather.SNOWY, Weather.FOGGY, Weather.RAINY, Weather.FOGGY, Weather.PARTLY_CLOUDY, Weather.SNOWY, Weather.SUNNY, Weather.FOGGY, Weather.SNOWY, Weather.RAINY, Weather.SNOWY, Weather.FOGGY}),
    WINTER_TROPICAL(Season.WINTER, Biome.TROPICAL, new Weather[]
            {Weather.RAINY, Weather.CLOUDY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.RAINY, Weather.CLOUDY, Weather.STORMY, Weather.RAINY, Weather.PARTLY_CLOUDY, Weather.STORMY, Weather.RAINY}),
    WINTER_WILDERNESS(Season.WINTER, Biome.WILDERNESS, new Weather[]
            {Weather.STORMY, Weather.SUNNY, Weather.ASHFALL, Weather.ASHFALL, Weather.SUNNY, Weather.STORMY, Weather.ASHFALL, Weather.ASHFALL, Weather.SUNNY, Weather.STORMY, Weather.STORMY, Weather.ASHFALL}),

    ;

    @Getter
    final Season seasonCondition;
    @Getter
    final Biome biomeCondition;
    @Getter
    final Weather[] forecastArray;

    WeatherForecast(Season seasonCondition, Biome biomeCondition, Weather[] forecastArray)
    {
        this.seasonCondition = seasonCondition;
        this.biomeCondition = biomeCondition;
        this.forecastArray = forecastArray;
    }
}

package com.weather3d.audio;

import lombok.Getter;

@Getter
public enum SoundEffect {
    RAIN("https://github.com/ScreteMonge/WeatherAmbience/raw/main/617078__mikaelacampbell18__rain-forest-steady_edited.mp3", false),
    THUNDERSTORM("https://github.com/ScreteMonge/WeatherAmbience/raw/main/180327__aeonemi__lighting-strike-and-thunder_edited.mp3", false),
    WIND("https://github.com/ScreteMonge/WeatherAmbience/raw/main/201208__rivv3t__raw-wind_edited.mp3", false),
    RAIN_MUFFLED("https://github.com/ScreteMonge/WeatherAmbience/raw/main/617078__mikaelacampbell18__rain-forest-steady_edited_MUFFLED.mp3", true),
    THUNDERSTORM_MUFFLED("https://github.com/ScreteMonge/WeatherAmbience/raw/main/180327__aeonemi__lighting-strike-and-thunder_edited_MUFFLED.mp3", true),
    WIND_MUFFLED("https://github.com/ScreteMonge/WeatherAmbience/raw/main/201208__rivv3t__raw-wind_edited_MUFFLED.mp3", true)
    ;

    private final String soundFile;
    private final boolean muffled;

    SoundEffect(String soundFile, boolean muffled)
    {
        this.soundFile = soundFile;
        this.muffled = muffled;
    }
}

package com.weather3d.audio;

import com.weather3d.CyclesConfig;
import com.weather3d.CyclesPlugin;
import com.weather3d.audio.SoundEffect;
import jaco.mp3.player.MP3Player;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.sound.sampled.*;
import java.io.File;
import java.net.URL;

@Getter
@Setter
@Slf4j
public class SoundPlayer
{
    @Inject
    private CyclesPlugin plugin;
    @Inject
    private CyclesConfig config;
    @Inject
    private SourceDataLine sourceDataLine;
    @Inject
    private AudioSystem audioSystem;

    private boolean isFading = false;
    private boolean primarySoundPlayer = false;
    private int timer = 0;
    private SoundEffect currentTrack;
    private boolean ambienceError = false;
    private final MP3Player trackPlayer = new MP3Player();
    private Thread handlePlayThread = null;
    private Thread volumeChangeHandler = null;

    public void playClip(SoundEffect soundEffect)
    {
        setTimer(0);
        //A PC having no audio output seems to cause massive issues. This appears to fix it by testing whether the audio system is active
        AudioFormat format = new AudioFormat(1000, 16, 2, true, false);
        try
        {
            AudioSystem.getLine(new DataLine.Info(SourceDataLine.class, format));
        }
        catch (Exception e)
        {
            return;
        }

        trackPlayer.getPlayList().clear();
        handlePlayThread = new Thread(() -> {
            try
            {
                String soundLink = soundEffect.getSoundFile();
                if (soundLink.toLowerCase().startsWith("http"))
                    trackPlayer.addToPlayList(new URL(soundLink));
                else
                    trackPlayer.addToPlayList(new File(soundLink)); //this is here for local testing
                trackPlayer.play();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        });
        currentTrack = soundEffect;
        handlePlayThread.start();
    }

    public void stopClip()
    {
        log.debug(currentTrack + " SoundPlayer STOPPING!");
        trackPlayer.stop();
        setTimer(0);
    }

    public boolean isPlaying()
    {
        return trackPlayer.isPlaying();
    }

    public int getCurrentVolume()
    {
        return trackPlayer.getVolume();
    }

    public void smoothVolumeChange(int endVolume, int milliseconds)
    {
        if (volumeChangeHandler != null )
            volumeChangeHandler.interrupt();

        volumeChangeHandler = new Thread(() ->
        {
            try
            {
                int startVolume = getCurrentVolume();
                long startTime = System.currentTimeMillis();
                long endTime = startTime + milliseconds;
                while (System.currentTimeMillis() < endTime)
                {
                    double percentProgress = ((double)(System.currentTimeMillis() - startTime))/ (endTime - startTime);
                    int newVolume = (int)(startVolume +  sigmoid(percentProgress) * (endVolume - startVolume));
                    setVolumeLevel(newVolume);
                    Thread.sleep(100);
                }
                setVolumeLevel(endVolume);
                if (endVolume == 0)
                {
                    setFading(false);
                    stopClip();
                }
            }
            catch (InterruptedException e)
            {
                return;
            }
        });
        volumeChangeHandler.start();
    }

    private double sigmoid(double percentProgress)
    {
        percentProgress = percentProgress * Math.E * 4;
        return (Math.exp(percentProgress - Math.E * 2))/(Math.exp(percentProgress - Math.E * 2) + 1);
    }

    public void setVolumeLevel(int volume)
    {
        if (volume < 0)
            volume = 0;

        if (volume > 100)
            volume = 100;

        trackPlayer.setVolume(volume);
    }
}

