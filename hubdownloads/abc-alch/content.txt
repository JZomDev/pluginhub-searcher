package com.vartan;

import com.vartan.abc.AbcAlchPlugin;
import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AbcAlchTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AbcAlchPlugin.class);
		RuneLite.main(args);
	}
}
package com.vartan.abc.util;

import java.awt.*;

public class PointUtil {
    public static Point toAwtPoint(net.runelite.api.Point point) {
        return new Point(point.getX(), point.getY());
    }
}

package com.vartan.abc.util;

public class IntegerUtil {
    private static final String[] UNITS = {"", "k", "m", "b", "t"};

    public static String toShorthand(int number) {
        return toShorthand(number, 1);
    }

    public static String toShorthand(int number, int decimals) {
        int unitIndex = 0;
        double output = number;
        while (output >= 1000 && unitIndex < UNITS.length - 1) {
            output /= 1000;
            unitIndex++;
        }
        double roundingMultiplier = (int) Math.pow(10, decimals);
        double scalar = (Math.round(output * roundingMultiplier) / roundingMultiplier);
        String scalarString;
        if (scalar == (int) scalar) {
            scalarString = String.format("%d", (int) scalar);
        } else {
            scalarString = String.format("%s", scalar);
        }
        return scalarString + UNITS[unitIndex];
    }
}

package com.vartan.abc;

import com.vartan.abc.model.Spell;
import com.vartan.abc.util.PointUtil;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.*;

public class AbcAlchOverlay extends Overlay {

    private static int[] SPELLBOOK_ICON_IDS = {
            ComponentID.RESIZABLE_VIEWPORT_MAGIC_ICON,
            ComponentID.RESIZABLE_VIEWPORT_BOTTOM_LINE_MAGIC_ICON,
            ComponentID.FIXED_VIEWPORT_MAGIC_ICON
    };

    private final Client client;
    private final AbcAlchConfig config;
    private final AbcAlchPlugin plugin;

    private Rectangle alchBounds = null;
    private Rectangle optimalItemBounds = null;
    private Rectangle alchIntersection = null;

    @Inject
    private AbcAlchOverlay(Client client, AbcAlchPlugin plugin, AbcAlchConfig config) {
        super(plugin);
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
        this.client = client;
        this.config = config;
        this.plugin = plugin;
    }

    public Dimension render(Graphics2D graphics) {
        // TODO: Update bounds less often, this doesn't need to be recalculated every frame.
        Widget magicWidget = client.getWidget(InterfaceID.SPELLBOOK, Spell.HIGH_LEVEL_ALCHEMY.widgetChildId);
        if (magicWidget != null) {
            Rectangle maybeBounds = magicWidget.getBounds();
            if (maybeBounds != null) {
                alchBounds = maybeBounds;
            }
        }
        updateInventoryBounds(graphics);


        if (!plugin.alchOverlayTimer.isRunning()) {
            // Don't draw the overlay when the user isn't alching.
            return null;
        }

        if (alchBounds != null && config.showAlchBounds()) {
            graphics.setColor(config.alchBoundsColor());
            graphics.draw(alchBounds);
        }

        if (optimalItemBounds != null && config.showItemBounds()) {
            graphics.setColor(config.itemBoundsColor());
            graphics.draw(optimalItemBounds);
        }
        renderAlchIntersection(graphics, magicWidget);
        renderSpellbookClickHint(graphics, magicWidget);
        return null;
    }

    private void renderAlchIntersection(Graphics2D graphics, Widget magicWidget) {
        if (alchIntersection == null || !config.showAlchIntersection()) {
            return;
        }
        double magicReadyPercent = plugin.magicTicker.getPercentDone();
        boolean isReady = magicReadyPercent == 1.0;
        boolean mouseIntersects = alchIntersectionContainsMouse();

        Rectangle fillRect = getAlchFillRect(magicReadyPercent);
        // Draw an opaque border around the progress bar to make its position more obvious.

        Color statusColor = isReady ? config.readyColor() : config.pendingColor();
        graphics.setColor(statusColor);
        graphics.draw(fillRect);

        // Fill translucent progress bar inside the intersection box.
        graphics.setColor(getAlchIntersectionColor((float) magicReadyPercent));
        graphics.fill(fillRect);

        boolean menuIsCast = plugin.menuIsCast();
        if (magicWidget != null && !magicWidget.isHidden() || (menuIsCast && mouseIntersects)) {
            graphics.setColor(statusColor);
        } else {
            // Make it obvious to the user that clicking the intersection box will not alch.
            graphics.setColor(config.misclickColor());
        }
        graphics.draw(alchIntersection);

        graphics.setColor(new Color(1, 1, 1, .5f));
    }

    private boolean alchIntersectionContainsMouse() {
        return alchIntersection.contains(PointUtil.toAwtPoint(client.getMouseCanvasPosition()));
    }

    public void renderSpellbookClickHint(Graphics2D graphics, Widget magicWidget) {
        if (!config.spellbookClickHint() || plugin.hideSpellbookHintTimer.isRunning() || (magicWidget != null && !magicWidget.isHidden())) {
            // Don't render the spellbook hint if the spellbook is open and the alch spell is visible.
            return;
        }
        if (plugin.alchOverlayTimer.getTicksElapsed() == 0) {
            // Don't render the spellbook hint during the first tick before the client returns to the
            // spellbook tab.
            return;
        }
        if(plugin.magicTicker.isRunning() && plugin.alchOverlayTimer.getTicksElapsed() > plugin.magicTicker.getFullValue()) {
            // The user may have queued the next alch, avoid showing spellbook hint until the current
            // is complete.
            return;
        }
        Widget spellbookTab = getVisibleSpellbookTabWidget();
        if (spellbookTab == null) {
            // Don't render the spellbook hint if the spellbook tab is hidden.
            return;
        }
        boolean menuIsCast = plugin.menuIsCast();
        if (menuIsCast) {
            // Don't render the spellbook hint if the alch spell is selected.
            return;
        }
        graphics.setColor(config.spellbookClickHintColor());
        graphics.draw(spellbookTab.getBounds());
    }

    private Widget getVisibleSpellbookTabWidget() {
        Widget tabWidget = null;
        for (int i = 0; i < SPELLBOOK_ICON_IDS.length && tabWidget == null; i++) {
            tabWidget = client.getWidget(SPELLBOOK_ICON_IDS[i]);
            if(tabWidget != null && tabWidget.isHidden()) {
                tabWidget = null;
            }
        }
        return tabWidget;
    }

    public Color getAlchIntersectionColor(float magicReadyPercent) {
        Color readyColor = config.readyColor();
        Color pendingColor = config.pendingColor();
        float magicRemainingPercent = 1f - magicReadyPercent;

        return new Color(
                Math.min(1f, readyColor.getRed() / 255f * magicReadyPercent + pendingColor.getRed() / 255f * magicRemainingPercent),
                Math.min(1f, readyColor.getGreen() / 255f * magicReadyPercent + pendingColor.getGreen() / 255f * magicRemainingPercent),
                Math.min(1f, readyColor.getBlue() / 255f * magicReadyPercent + pendingColor.getBlue() / 255f * magicRemainingPercent),
                (float) config.intersectionFillOpacity() * (readyColor.getAlpha() / 255f * magicReadyPercent + pendingColor.getAlpha() / 255f * magicRemainingPercent)
        );
    }


    public void updateInventoryBounds(Graphics2D graphics) {
        Widget inventoryWidget = client.getWidget(ComponentID.INVENTORY_CONTAINER);

        if (inventoryWidget == null || alchBounds == null || inventoryWidget.isHidden()) {
            return;
        }
        Widget[] dynamicChildren = inventoryWidget.getDynamicChildren();
        if (dynamicChildren.length == 0) {
            return;
        }

        double largestIntersectionArea = 1;
        Rectangle largestOverlapItemBounds = null;
        Rectangle largestOverlapIntersection = null;
        // Find the inventory slot with the largest overlap with the alchemy spell.
        for (Widget item : dynamicChildren) {
            if (item == null || item.isHidden()) {
                continue;
            }

            Rectangle itemBounds = item.getBounds();
            if (itemBounds == null) {
                continue;
            }
            Rectangle intersection = alchBounds.intersection(itemBounds);
            if (intersection.isEmpty()) {
                // An empty rectangle does not necessarily have a width/height of 0.
                // Negative values were observed, which results in a misleading positive area calculation.
                continue;
            }

            double intersectionArea = intersection.getWidth() * intersection.getHeight();
            if (intersectionArea > largestIntersectionArea) {
                largestIntersectionArea = intersectionArea;
                largestOverlapItemBounds = itemBounds;
                largestOverlapIntersection = intersection;
            }
        }
        if (largestOverlapItemBounds != null) {
            this.optimalItemBounds = largestOverlapItemBounds;
            this.alchIntersection = largestOverlapIntersection;
        }
    }

    /**
     * Generates the progress bar for the alchemy timer.
     * <p>
     * The Rectangle grow from the bottom upwards if the y-axis is larger, otherwise it will grow from the left
     * rightwards.
     *
     * @param magicReadyPercent % of the timer has completed.
     * @return Progress bar rectangle
     */
    private Rectangle getAlchFillRect(double magicReadyPercent) {
        if (alchIntersection.getHeight() > alchIntersection.getWidth()) {
            int indicatorY = (int) Math.round(alchIntersection.getY() + alchIntersection.getHeight() * (1.0 - magicReadyPercent));
            int indicatorHeight = (int) Math.round(alchIntersection.getHeight() * magicReadyPercent);
            return new Rectangle((int) alchIntersection.getX(), indicatorY, (int) alchIntersection.getWidth(), indicatorHeight);
        } else {
            return new Rectangle((int) alchIntersection.getX(), (int) alchIntersection.getY(),
                    (int) Math.round(alchIntersection.getWidth() * magicReadyPercent), (int) Math.round(alchIntersection.getHeight()));
        }
    }
}


package com.vartan.abc;

import com.vartan.abc.model.SoundEffect;
import net.runelite.api.SoundEffectVolume;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup("AbcAlchemy")
public interface AbcAlchConfig extends Config {

    @ConfigSection(
            name = "Alch Intersection",
            description = "Alch Intersection",
            position = 0)
    String alchIntersectionSection = "Alch Intersection";

    @ConfigItem(
            keyName = "showAlchIntersection",
            name = "Show alch intersection",
            description = "Whether to draw an indicator in the 'sweet spot' where the alchemy spell overlaps most " +
                    "over an item slot.",
            section = alchIntersectionSection,
            position = 0
    )
    default boolean showAlchIntersection() {
        return true;
    }

    @ConfigItem(
            keyName = "readyColor",
            name = "Ready color",
            description = "Shown on the spellbook when alchemy is ready, and in the inventory when the mouse is over " +
                    "the alch intersection area.",
            section = alchIntersectionSection,
            position = 1
    )
    default Color readyColor() {
        return Color.GREEN;
    }

    @ConfigItem(
            keyName = "pendingColor",
            name = "Pending color",
            description = "Shown while the player is busy casting alchemy.",
            section = alchIntersectionSection,
            position = 2
    )
    default Color pendingColor() {
        return Color.YELLOW;
    }

    @ConfigItem(
            keyName = "misclickColor",
            name = "Misclick color",
            description = "Shown when the next click will perform alchemy and the mouse isn't in the alch " +
                    "intersection area, or otherwise when clicking in the intersection would not be productive.",
            section = alchIntersectionSection,
            position = 3
    )
    default Color misclickColor() {
        return Color.RED;
    }

    @ConfigItem(
            keyName = "intersectionFillOpacity",
            name = "Intersection fill opacity",
            description = "From 0-1, how opaque should the intersection be filled?",
            section = alchIntersectionSection,
            position = 4
    )
    default double intersectionFillOpacity() {
        return 0.5;
    }

    @ConfigSection(
            name = "Misc",
            description = "Miscellaneous Settings",
            position = 1)
    String miscSection = "Misc";


    @ConfigItem(
            keyName = "showAlchBounds",
            name = "Show alch bounds",
            description = "Whether to draw a box around the alchemy spell.",
            section = miscSection,
            position = 0
    )
    default boolean showAlchBounds() {
        return false;
    }

    @ConfigItem(
            keyName = "Alch bounds color",
            name = "Alch bounds color",
            description = "What color to draw around the alchemy spell, when enabled.",
            section = miscSection,
            position = 1
    )
    default Color alchBoundsColor() {
        return Color.PINK;
    }

    @ConfigItem(
            keyName = "showItemBounds",
            name = "Show item bounds",
            description = "Whether to draw a box around the optimal item slot that intersects most with the alchemy " +
                    "spell.",
            section = miscSection,
            position = 2
    )
    default boolean showItemBounds() {
        return false;
    }

    @ConfigItem(
            keyName = "Alch item color",
            name = "Item bounds color",
            description = "What color to draw around the optimal item, when enabled.",
            section = miscSection,
            position = 3
    )
    default Color itemBoundsColor() {
        return Color.ORANGE;
    }

    @ConfigItem(
            keyName = "audioHintVolume",
            name = "Audio hint volume",
            description = "The volume of the alch ready audio hint, from 0-127. 0 fully disables audio hints.",
            section = miscSection,
            position = 4
    )
    @Range(max = SoundEffectVolume.HIGH)
    default int audioHintVolume() {
        return 0;
    }

    @ConfigItem(
            keyName = "audioHintSoundEffect",
            name = "Audio hint sound effect",
            description = "Which sound effect plays when alch is ready. Disabled when audio hint volume is 0.",
            section = miscSection,
            position = 5
    )
    default SoundEffect audioHintSoundEffect() {
        return SoundEffect.UI_BOOP;
    }

    @ConfigItem(
            keyName = "spellbookClickHint",
            name = "Spellbook click hint",
            description = "Whether to draw a box around the spellbook tab when clicking it is necessary for the next " +
                    "alch.",
            section = miscSection,
            position = 5
    )
    default boolean spellbookClickHint() {
        return true;
    }

    @ConfigItem(
            keyName = "spellbookClickHintColor",
            name = "Spellbook click hint Color",
            description = "What color to draw around the spellbook when spellbook click hint is enabled.",
            section = miscSection,
            position = 6
    )
    default Color spellbookClickHintColor() {
        return Color.GREEN;
    }
}

package com.vartan.abc;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Ordering;
import com.google.inject.Provides;
import com.vartan.abc.model.AlchItem;
import com.vartan.abc.model.Spell;
import com.vartan.abc.model.TickCounter;
import com.vartan.abc.model.XpTracker;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.item.ItemPrice;
import net.runelite.http.api.item.ItemStats;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

@Slf4j
@PluginDescriptor(
        name = "ABC Alchemy"
)
public class AbcAlchPlugin extends Plugin {
    private static final int TICKS_PER_MINUTE = 100;
    public final TickCounter magicTicker = new TickCounter();
    /**
     * When this timer is running, the alch overlay and spellbook hint will be visible.
     * <p>
     * It is set to 1 minute whenever alchemy is being cast.
     */
    public final TickCounter alchOverlayTimer = new TickCounter();

    /** When this timer is running, the spellbook hint will be hidden. */
    public final TickCounter hideSpellbookHintTimer = new TickCounter();

    /**
     * Whether to update the price list at the next available time, at which point this will be reset to false.
     */
    public boolean readyForPriceUpdate = true;
    /**
     * Whether to use wiki prices.
     */
    public boolean useWikiPrices = true;
    @Inject
    private Client client;
    @Inject
    private AbcAlchConfig config;
    @Inject
    private AbcAlchOverlay abcAlchOverlay;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private ClientToolbar clientToolbar;
    /**
     * List of all items, sorted by alch profit.
     */
    private List<AlchItem> alchItems;
    /**
     * A list of tick counters for the application. These are ticked in onGameTick.
     */
    private final ArrayList<TickCounter> tickCounters = new ArrayList<>();
    /**
     * The RuneLite sidebar navigation button.
     */
    private NavigationButton navButton;
    /**
     * Plugin sidebar panel.
     */
    private AbcAlchPanel panel;
    /**
     * Keeps track of XP differences.
     */
    private final XpTracker xpTracker = new XpTracker(ImmutableList.of(Skill.MAGIC));

    @Override
    protected void startUp() throws Exception {
        if (client.getGameState() == GameState.LOGGED_IN) {
            onLoginOrActivated();
        }
        panel = new AbcAlchPanel(this, client, itemManager);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/icon.png");

        navButton = NavigationButton.builder()
                .tooltip("ABC Alchemy")
                .icon(icon)
                .priority(2)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        tickCounters.add(magicTicker);
        tickCounters.add(alchOverlayTimer);
        tickCounters.add(hideSpellbookHintTimer);
        overlayManager.add(abcAlchOverlay);

    }

    public void updatePriceList() {
        // TODO: Inquire about making a PR which introduces a function that returns all GE tradeable ItemPrices.
        List<ItemPrice> itemPrices = this.itemManager.search("");
        int natureRunePrice = this.itemManager.getItemPrice(ItemID.NATURE_RUNE);

        ArrayList<AlchItem> tempAlchItems = new ArrayList<>();
        for (ItemPrice price : itemPrices) {
            int itemId = price.getId();
            ItemComposition itemComposition = this.itemManager.getItemComposition(itemId);
            ItemStats itemStats = itemManager.getItemStats(itemId, false);
            String name = price.getName();
            // Filter out any useless items.
            if (itemStats == null || itemComposition == null || name.length() == 0) {
                continue;
            }

            int gePrice = this.useWikiPrices ? itemManager.getWikiPrice(price) : price.getPrice();
            int highAlchPrice = itemComposition.getHaPrice();
            int highAlchProfit = highAlchPrice - gePrice - natureRunePrice;
            int geLimit = itemStats.getGeLimit();
            if (highAlchProfit < 0) {
                // Avoid creating entries for items that will never be displayed.
                continue;
            }

            BufferedImage image = itemManager.getImage(itemId, geLimit, false);
            tempAlchItems.add(new AlchItem(name, gePrice, highAlchPrice, highAlchProfit, geLimit, image));
        }
        // Sort by high alchemy profit,
        this.alchItems = Ordering.from(Comparator.comparing(AlchItem::getHighAlchProfit)).reverse().immutableSortedCopy(tempAlchItems);

        SwingUtilities.invokeLater(() -> panel.updateItemList());
        readyForPriceUpdate = false;
    }


    @Override
    protected void shutDown() throws Exception {
        clientToolbar.removeNavigation(navButton);
        overlayManager.remove(abcAlchOverlay);
        // Remove counters since they will be reinstalled on startup.
        for(TickCounter counter : tickCounters) {
            tickCounters.remove(counter);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN) {
            onLoginOrActivated();
        }
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
        boolean wasAlch = menuOptionClicked.getMenuAction() == MenuAction.WIDGET_TARGET_ON_WIDGET && menuOptionClicked.getMenuTarget().contains("High Level Alchemy");
        if(wasAlch) {
            hideSpellbookHintTimer.set(Spell.HIGH_LEVEL_ALCHEMY.cooldown + 1);
        }
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event) {
        final Actor actor = event.getActor();
        final String actorName = actor.getName();

        if (actor != client.getLocalPlayer()) {
            // We only care about the player
        }
        // TODO: track animations for actions which prevent alching, such as agility.
    }

    @Provides
    AbcAlchConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AbcAlchConfig.class);
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        tickCounters.forEach(TickCounter::tick);

        if (magicTicker.justElapsed() && alchOverlayTimer.isRunning()) {
            // The overlay timer is checked to ensure we only play audio hints
            // after a user has actually cast an alchemy spell. Since we infer
            // a spell is cast using XP gained on a tick, there can otherwise be
            // false positives when other spells (such as combat spells) provide
            // the same exact XP.
            maybePlayAudioHint();
        }

        if (readyForPriceUpdate && client.getGameState() == GameState.LOGGED_IN) {
            updatePriceList();
        }

        if (menuIsCast()) {
            alchOverlayTimer.set(TICKS_PER_MINUTE);
        }
    }

    private void maybePlayAudioHint() {
        int volume = config.audioHintVolume();
        if (volume != 0) {
            client.playSoundEffect(config.audioHintSoundEffect().id, volume);
        }
    }

    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        Skill skill = statChanged.getSkill();
        int xpDiff = xpTracker.onStatChanged(statChanged);
        if (xpDiff < 0) {
            // Exit early if this skill isn't tracked in XpTracker.
            return;
        }

        if (Objects.requireNonNull(skill) == Skill.MAGIC) {
            for (Spell spell : Spell.values()) {
                if (xpDiff == spell.xpGained) {
                    onMagicXpGained(spell);
                    break;
                }
            }
        }
    }

    private void onMagicXpGained(Spell spell) {
        magicTicker.set(spell.cooldown);
    }


    public List<AlchItem> getAlchItems() {
        return this.alchItems;
    }

    /**
     * Whether the user is currently casting alchemy.
     */
    public boolean menuIsCast() {
        // TODO: Support Low Alch.
        Widget selectedWidget = client.getSelectedWidget();
        Widget alchWidget = client.getWidget(InterfaceID.SPELLBOOK, Spell.HIGH_LEVEL_ALCHEMY.widgetChildId);
        return selectedWidget != null && selectedWidget == alchWidget;
    }

    /**
     * Run when the user logs in, or when they enable the plugin while logged in.
     */
    private void onLoginOrActivated() {
        readyForPriceUpdate = true;
        xpTracker.update(client);
    }
}

package com.vartan.abc;

import com.vartan.abc.model.AlchItem;
import com.vartan.abc.util.IntegerUtil;
import net.runelite.api.Client;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.image.BufferedImage;

public class AbcAlchPanel extends PluginPanel {

    private static final String[] PRICE_SOURCE_OPTIONS = {"Wiki Prices", "Standard Prices"};
    private static final int WIKI_PRICES_INDEX = 0;
    private final Client client;
    private final ItemManager itemManager;
    JTextField minimumTradeLimitField;
    JTextField maxPriceField;
    JComboBox priceSourceBox;
    AbcAlchPlugin plugin;
    JPanel alchList;
    JButton searchButton;

    public AbcAlchPanel(AbcAlchPlugin plugin, Client client, ItemManager itemManager) {
        super();
        this.plugin = plugin;
        this.client = client;
        this.itemManager = itemManager;
        this.searchButton = new JButton("Search");
        DocumentListener onInputChanged = new DocumentListener() {
            void update(DocumentEvent e) {
                searchButton.setText("Search");
                searchButton.revalidate();
            }

            @Override
            public void insertUpdate(DocumentEvent e) {
                update(e);
            }
            @Override
            public void removeUpdate(DocumentEvent e) {
                update(e);
            }
            @Override
            public void changedUpdate(DocumentEvent e) {
                update(e);
            }
        };

        setBorder(new EmptyBorder(6, 6, 6, 6));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        final JPanel layoutPanel = new JPanel();
        BoxLayout boxLayout = new BoxLayout(layoutPanel, BoxLayout.Y_AXIS);
        layoutPanel.setLayout(boxLayout);
        add(layoutPanel, BorderLayout.NORTH);
        maxPriceField = new JTextField();
        JPanel maxPriceRow = createLabeledRow("Max Price:", maxPriceField);
        maxPriceRow.setToolTipText("Filters out items with a GE price more than the given value. 0 to disable.");
        layoutPanel.add(maxPriceRow);
        maxPriceField.getDocument().addDocumentListener(onInputChanged);

        minimumTradeLimitField = new JTextField();
        JPanel minimumTradeLimitRow = createLabeledRow("Min Trade Limit:", minimumTradeLimitField);
        minimumTradeLimitRow.setToolTipText("Filters out items with a trade limit less than the given value. " + "0 to disable.");
        layoutPanel.add(minimumTradeLimitRow);
        minimumTradeLimitField.getDocument().addDocumentListener(onInputChanged);

        priceSourceBox = new JComboBox(PRICE_SOURCE_OPTIONS);
        priceSourceBox.setSelectedIndex(0);
        priceSourceBox.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.useWikiPrices = priceSourceBox.getSelectedIndex() == WIKI_PRICES_INDEX;
                plugin.readyForPriceUpdate = true;
            }
        });
        layoutPanel.add(createLabeledRow("Price Source:", priceSourceBox));

        searchButton.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                plugin.readyForPriceUpdate = true;
            }
        });
        layoutPanel.add(searchButton);

        alchList = new JPanel();
        layoutPanel.add(alchList);
        BoxLayout alchListBoxLayout = new BoxLayout(alchList, BoxLayout.Y_AXIS);
        alchList.setLayout(alchListBoxLayout);
        alchList.add(new JLabel("Prices will appear once an account is logged in."));

        updateItemList();
        add(alchList);
    }

    private static int readNumericTextField(JTextField field) {
        try {
            return Integer.parseInt(field.getText());
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    private static JPanel createLabeledRow(String label, Component item) {
        JPanel rowPanel = new JPanel();
        rowPanel.setLayout(new GridLayout(1, 2));
        rowPanel.add(new JLabel(label));
        rowPanel.add(item);

        return rowPanel;
    }

    /**
     * Clears and regenerates the item list panel using the list of alch items.
     */
    public void updateItemList() {
        searchButton.setText("Refresh");
        searchButton.revalidate();
        if (plugin.getAlchItems() == null) {
            return;
        }
        alchList.removeAll();
        for (AlchItem item : plugin.getAlchItems()) {
            int geLimit = item.getGeLimit();
            int minimumTradeLimit = readNumericTextField(this.minimumTradeLimitField);
            int maxPrice = readNumericTextField(this.maxPriceField);
            boolean filterGeLimit = geLimit != 0 && minimumTradeLimit != 0 && geLimit < minimumTradeLimit;
            boolean filterPrice = maxPrice != 0 && item.getGePrice() >= maxPrice;
            if (filterGeLimit || filterPrice) {
                continue;
            }
            if (item.getHighAlchProfit() <= 0) {
                break;
            }

            JPanel alchItemContainer = generateItemContainer(item);
            alchList.add(alchItemContainer);
        }
        alchList.revalidate();
    }

    private JPanel generateItemContainer(AlchItem item) {
        // Create the container for the entire item.
        JPanel alchItemContainer = new JPanel();
        alchItemContainer.setBorder(BorderFactory.createEmptyBorder(3, 3, 3, 3));
        alchItemContainer.setLayout(new BoxLayout(alchItemContainer, BoxLayout.X_AXIS));
        alchList.add(alchItemContainer);

        // Add the image to the left.
        BufferedImage itemImage = item.getImage();
        JLabel iconLabel = new JLabel(new ImageIcon(itemImage));
        iconLabel.setToolTipText(item.getName() + " has a Grand Exchange buy limit of " +
                item.getGeLimit() + " every 4 hours");
        alchItemContainer.add(iconLabel);

        // Create a panel for the content on the right
        JPanel alchItemContent = new JPanel();
        alchItemContent.setLayout(new BoxLayout(alchItemContent, BoxLayout.Y_AXIS));
        alchItemContainer.add(alchItemContent);

        // Item name goes on top
        JLabel itemNameLabel = new JLabel(item.getName(), SwingConstants.LEFT);
        itemNameLabel.setForeground(Color.WHITE);
        alchItemContent.setAlignmentX(Component.LEFT_ALIGNMENT);
        alchItemContent.add(itemNameLabel);

        // Add subtext under item name.
        JPanel subtextContainer = createSubtextContainer(item);
        alchItemContent.add(subtextContainer);
        return alchItemContainer;
    }

    /**
     * Creates a grid showing alch price/profit and ge price.
     */
    private JPanel createSubtextContainer(AlchItem item) {
        // Create subtext grid to distribute metadata evenly
        JPanel subtextContainer = new JPanel();
        subtextContainer.setLayout(new GridLayout(2, 2));

        Font smallFont = FontManager.getRunescapeSmallFont();

        // High Alch Price
        JLabel alchPriceLabel = new JLabel("Alch: " + IntegerUtil.toShorthand(item.getHighAlchPrice()));
        alchPriceLabel.setToolTipText("High Alch Price: " + item.getHighAlchPrice());
        alchPriceLabel.setForeground(Color.YELLOW);
        alchPriceLabel.setFont(smallFont);
        subtextContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
        subtextContainer.add(alchPriceLabel);

        // Profit
        JLabel alchProfitLabel = new JLabel("Profit: " + IntegerUtil.toShorthand(item.getHighAlchProfit()));
        alchProfitLabel.setToolTipText("High Alch Profit: " + item.getHighAlchProfit());
        alchProfitLabel.setForeground(Color.GREEN);
        alchProfitLabel.setFont(smallFont);
        subtextContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
        subtextContainer.add(alchProfitLabel);

        // GE Price
        JLabel gePriceLabel = new JLabel("GE: " + IntegerUtil.toShorthand(item.getGePrice()));
        gePriceLabel.setToolTipText("Grand Exchange Price: " + item.getGePrice());
        gePriceLabel.setForeground(Color.ORANGE);
        gePriceLabel.setFont(smallFont);
        subtextContainer.setAlignmentX(Component.LEFT_ALIGNMENT);
        subtextContainer.add(gePriceLabel);
        return subtextContainer;
    }
}

package com.vartan.abc.model;

public enum SoundEffect {
    UI_BOOP(2266),
    GE_INCREMENT_PLOP(3929),
    GE_DECREMENT_PLOP(3930),
    GE_ADD_OFFER_DINGALING(3925),
    GE_COLLECT_BLOOP(3928),
    GE_COIN_TINKLE(3924),
    CLOSE_DOOR(60),
    OPEN_DOOR(62),
    ITEM_DROP(2739),
    ITEM_PICKUP(2582),
    PICK_PLANT_BLOOP(2581),
    BURY_BONES(2738),
    TINDER_STRIKE(2597),
    FIRE_WOOSH(2596),
    TREE_FALLING(2734),
    TREE_CHOP(2735),
    MINING_TINK(3220),
    COOK_WOOSH(2577),
    MAGIC_SPLASH_BOING(227),
    SMITH_ANVIL_TINK(3790),
    SMITH_ANVIL_TONK(3791),
    NPC_TELEPORT_WOOSH(1930),
    TELEPORT_VWOOP(200),
    ZERO_DAMAGE_SPLAT(511),
    TAKE_DAMAGE_SPLAT(510),
    ATTACK_HIT(2498),
    PRAYER_DEACTIVE_VWOOP(2663),
    PRAYER_DEPLETE_TWINKLE(2672),
    TOWN_CRIER_BELL_DING(3813),
    TOWN_CRIER_BELL_DONG(3817),
    TOWN_CRIER_SHOUT_SQUEAK(3816);

    public final int id;

    SoundEffect(int soundEffectId) {
        this.id = soundEffectId;
    }
}

package com.vartan.abc.model;

public enum Spell {
    LOW_LEVEL_ALCHEMY(31, 3, 21),
    HIGH_LEVEL_ALCHEMY(65, 5, 44);

    public final int xpGained;
    /**
     * The number of game ticks after casting until the spell cools down.
     */
    public final int cooldown;
    public final int widgetChildId;

    Spell(int xpGained, int cooldown, int widgetChildId) {
        this.xpGained = xpGained;
        this.cooldown = cooldown;
        this.widgetChildId = widgetChildId;
    }
}

package com.vartan.abc.model;

import com.vartan.abc.util.IntegerUtil;
import net.runelite.client.ui.FontManager;

import java.awt.*;
import java.awt.image.BufferedImage;

public class AlchItem {
    private final String name;
    private final int gePrice;
    private final int geLimit;
    private final BufferedImage image;
    private final int highAlchPrice;
    private final int highAlchProfit;

    public AlchItem(String name, int gePrice, int highAlchPrice, int highAlchProfit, int geLimit, BufferedImage image) {
        this.name = name;
        this.gePrice = gePrice;
        this.highAlchPrice = highAlchPrice;
        this.highAlchProfit = highAlchProfit;
        this.geLimit = geLimit;
        this.image = createAlchImage(image, geLimit);
    }

    private static BufferedImage createAlchImage(BufferedImage bufferedImage, int geLimit) {
        Font smallFont = FontManager.getRunescapeSmallFont();
        Graphics2D imageIconGraphics = bufferedImage.createGraphics();
        String geLimitString = IntegerUtil.toShorthand(geLimit);
        imageIconGraphics.setFont(smallFont);
        imageIconGraphics.setColor(Color.BLACK);
        imageIconGraphics.drawString(geLimitString, 6, 11);
        imageIconGraphics.setColor(Color.YELLOW);
        imageIconGraphics.drawString(geLimitString, 5, 10);
        imageIconGraphics.dispose();
        return bufferedImage;
    }

    public int getGePrice() {
        return gePrice;
    }

    public int getGeLimit() {
        return geLimit;
    }

    public int getHighAlchProfit() {
        return highAlchProfit;
    }

    public String getName() {
        return name;
    }

    public int getHighAlchPrice() {
        return highAlchPrice;
    }

    public BufferedImage getImage() {
        return image;
    }
}

package com.vartan.abc.model;


import java.time.Duration;
import java.time.Instant;

public class TickCounter {
    private static final int GAME_TICK_DURATION_MS = 600;
    private int ticks = 0;
    private int fullValue = 0;
    private Instant lastTick = Instant.now();

    public TickCounter() {

    }

    public TickCounter(int ticks) {
        set(ticks);
    }

    public boolean isRunning() {
        return ticks > 0;
    }

    public int getTicksRemaining() {
        return Math.max(ticks, 0);
    }
    public int getTicksElapsed() {
        return fullValue - getTicksRemaining();
    }

    public boolean justElapsed() {
        return ticks == 0;
    }

    public void reset() {
        ticks = fullValue;
    }

    public void set(int value) {
        fullValue = value;
        ticks = value;
    }

    public void tick() {
        lastTick = Instant.now();
        if (ticks >= 0) {
            ticks--;
        }
    }

    public double getPercentDone() {
        int wholeTicksRemaining = getTicksRemaining();
        if (wholeTicksRemaining <= 0) {
            return 1;
        }
        double msSinceLastTick = (double) Duration.between(this.lastTick, Instant.now()).toMillis();

        double fractionalTickPercent = Math.min(
                msSinceLastTick / GAME_TICK_DURATION_MS,
                // Avoid showing close to 100% done on the final tick. The final tick should only be estimated 75% of its
                // duration.
                wholeTicksRemaining == 1 ? 0.75 : 1
        );

        double ticksRemaining = wholeTicksRemaining - fractionalTickPercent;
        double ticksPercent = 1.0 - ticksRemaining / (double) fullValue;
        return ticksPercent;
    }

    /** Returns the full value of the timer when it was set. */
    public int getFullValue() {
        return fullValue;
    }
}

package com.vartan.abc.model;

import com.google.common.collect.ImmutableMap;
import net.runelite.api.Client;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;

import java.util.List;

public class XpTracker {
    private final ImmutableMap<Skill, AmountDiffer> xpDiffs;

    public XpTracker(List<Skill> skills) {
        ImmutableMap.Builder<Skill, AmountDiffer> xpDiffsBuilder = ImmutableMap.builder();
        for (Skill skill : skills) {
            xpDiffsBuilder.put(skill, new AmountDiffer());
        }
        xpDiffs = xpDiffsBuilder.build();
    }

    public void update(Client client) {
        for (Skill skill : this.xpDiffs.keySet()) {
            AmountDiffer xpDiff = this.xpDiffs.get(skill);
            xpDiff.put(client.getSkillExperience(skill));
        }
    }

    /**
     * Returns the xp change since this function was last called. If this skill is not being tracked, it returns -1.
     */
    public int onStatChanged(StatChanged statChanged) {
        Skill skill = statChanged.getSkill();
        if (!xpDiffs.containsKey(skill)) {
            // Exit immediately if this is not a skill we are tracking.
            return -1;
        }

        int currentXp = statChanged.getXp();
        int xpDiff = xpDiffs.get(skill).put(currentXp).getDiff();

        return xpDiff;
    }
}

package com.vartan.abc.model;

public class Animation {
    public static int NONE = -1;
    public static int HIGH_LEVEL_ALCHEMY = 713;
}

package com.vartan.abc.model;

public class AmountDiffer {
    private int previousValue = 0;
    private int currentValue;
    private int emptyValues = 2;

    public AmountDiffer() {
    }

    public AmountDiffer(int currentValue) {
        this.put(currentValue);
    }

    public AmountDiffer put(int currentValue) {
        this.previousValue = this.currentValue;
        this.currentValue = currentValue;
        this.emptyValues = Math.max(emptyValues - 1, 0);
        return this;
    }

    public int getDiff() {
        if (emptyValues > 0) {
            return 0;
        }
        return this.currentValue - this.previousValue;
    }

    public void reset(int currentValue) {
        this.emptyValues = 1;
        this.currentValue = currentValue;
    }
}

