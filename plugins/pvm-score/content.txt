package com.pvmscore;

import com.google.inject.Provider;
import com.google.inject.Provides;

import javax.inject.Inject;
import javax.swing.*;

import com.pvmscore.overlay.BossPointsOverlay;
import com.pvmscore.panel.PvMPluginPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreClient;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.image.BufferedImage;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

@Slf4j
@PluginDescriptor(
	name = "PvM Score",
	configName = "PvmScoreConfig"
)
public class PvmScorePlugin extends Plugin
{
	private static final String MENU_TITLE = "PvM Score";

	@Inject
	private Client client;

	@Inject
	private HiscoreClient hiscoreClient;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PvmScoreConfig config;

	Set<Player> previousPlayerSet;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Provider<MenuManager> menuManager;

	@Inject
	SpriteManager spriteManager;

	@Inject
	PvmScoreConfig pvmScoreConfig;

	BossPointsOverlay bossPointsOverlay;

	private PvMPluginPanel pvmPluginPanel;
	private NavigationButton navButton;

	private PlayerManager playerManager;

	private boolean firstTick = true;

	public static final String YELLOW = "ffff00";
	public static final String GREEN = "00ff00";
	public static final String RED = "ff0000";
	public static final String ORANGE = "ff9040";

	private int tickCount = -1;

	@Override
	protected void startUp() throws Exception
	{
		this.playerManager = new PlayerManager(client, hiscoreClient);
		menuManager.get().addPlayerMenuItem(MENU_TITLE);

		pvmPluginPanel = injector.getInstance(PvMPluginPanel.class);
		pvmPluginPanel.init(playerManager, spriteManager);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "game_icon_tzkalzuk.png");

		navButton = NavigationButton.builder()
				.tooltip("PvM-Score Panel")
				.icon(icon)
				.priority(5)
				.panel(pvmPluginPanel)
				.build();

		bossPointsOverlay = new BossPointsOverlay(client);

		overlayManager.add(bossPointsOverlay);
		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		menuManager.get().removePlayerMenuItem(MENU_TITLE);
		overlayManager.remove(bossPointsOverlay);
		clientToolbar.removeNavigation(navButton);
		navButton = null;
		pvmPluginPanel = null;
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuOption().equals(MENU_TITLE))
		{
			try
			{
				SwingUtilities.invokeAndWait(() -> clientToolbar.openPanel(navButton));
			}
			catch (InterruptedException | InvocationTargetException e)
			{
				throw new RuntimeException(e);
			}

			String target = Text.sanitize(Text.removeTags(event.getMenuEntry().getTarget()));

			String playerName = target.substring(0, target.indexOf("(score-")).trim();

			if (!playerManager.getPlayer(playerName).hasFetchedKcs()) {

				pvmPluginPanel.loading(playerName);
				playerManager.getPlayer(playerName).fetchPlayerKC().whenComplete((result, error) -> {
					pvmPluginPanel.update(playerName);
				});
			} else {
				pvmPluginPanel.update(playerName);
			}
		}

	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		Stream.of(event.getMenuEntries())
				.filter(e -> e.getOption().equals(MENU_TITLE))
				.forEach(menuEntry -> {
					Actor actor = menuEntry.getActor();

					if (actor instanceof Player) {
						Player player = (Player) actor;
						String playerName = player.getName();
						PlayerManager.PlayerStat playerStat = playerManager.getPlayer(playerName);
						if (playerStat != null) {
							menuEntry.setTarget(updateTarget(menuEntry, playerStat));
						}
					}
				});
	}

	private String updateTarget(MenuEntry menuEntry, PlayerManager.PlayerStat playerStat) {
		String s = menuEntry.getTarget();

		String newLevel = String.format("(score-%s)", playerStat.getLevel());

		// Replace the level text
		s = s.replaceAll("\\(level-\\d+\\)", newLevel);

		String color = colorLevelCompare(playerStat);

		if (!color.isBlank()) {
			// Replace the second <col=> tag
			s = s.replaceAll("(<col=[^>]+>[^<]+)<col=[^>]+>", "$1<col="
					+ colorLevelCompare(playerStat) + ">");
		}

		return s;
	}

	private String colorLevelCompare(PlayerManager.PlayerStat playerStat) {
		String color = "";

		if (playerStat.getLevel().equals("?")) {
			return "";
		}

		if (Integer.parseInt(playerStat.getLevel()) >
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = RED;
		} else if (Integer.parseInt(playerStat.getLevel()) ==
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = YELLOW;
		} else if (Integer.parseInt(playerStat.getLevel()) <
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = GREEN;
		}

		return color;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		//if game log in set first tick to true;
		if (gameStateChanged.getGameState().equals(GameState.LOGGED_IN)) {
			firstTick = true;
		}
	}

	@Subscribe
	public void onGameTick(final GameTick event) {

		// because LOGGED_IN Game state will have an incomplete local player.
		if (firstTick) {
			firstTick = false;
			playerManager.initLocalPlayer().whenComplete((result, ignore) -> {
				pvmPluginPanel.update(Text.sanitize(playerManager.getLocalPlayer().getPlayer().getName()));
			});
		}

		updateWorldPlayersState();

		if (pvmScoreConfig.enablePointDrop()) {
			handleNpc();
		}
	}

	private void updateWorldPlayersState() {
		IndexedObjectSet<? extends Player> players = client.getTopLevelWorldView().players();

		players.forEach(player -> {
			playerManager.addPlayer(player);
		});

		Set<Player> curr = StreamSupport.stream(players.stream().spliterator(), false).collect(Collectors.toSet());

		// this deals with players going away. I'm not super confident this is the best way to do this.
		if (previousPlayerSet != null) {
			Set<Player> removed = new HashSet<>(previousPlayerSet);
			removed.removeAll(curr);

			removed.forEach(p -> {
				log.debug("removing player {}", p.getName());
				playerManager.removePlayer(p);
			});
		}
		previousPlayerSet = curr;
		playerManager.processLookups();
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event)
	{
		bossPointsOverlay.notifyKill(event.getNpc());
		tickCount = 0;
	}


	private void handleNpc() {
		if (tickCount >= 0) {
			tickCount++;

			if (tickCount >= 3) {
				bossPointsOverlay.notifyNotKill();
				tickCount = -1;
			}
		}
	}

	@Provides
	PvmScoreConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvmScoreConfig.class);
	}

}

package com.pvmscore;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("pvmscore")
public interface PvmScoreConfig extends Config
{
	@ConfigItem(
		keyName = "enablePointDrop",
		name = "Enable Point Drops",
		description = "Enables point drops when bosses are killed.",
		position = 0
	)
	default boolean enablePointDrop()
	{
		return true;
	}
}

package com.pvmscore;

import com.google.common.collect.ImmutableList;
import net.runelite.client.hiscore.HiscoreSkill;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static net.runelite.client.hiscore.HiscoreSkill.*;

public class PvmScore
{

    public static final int GRAND_MASTER_POINTS = 50;
    public static final int HARD_MODE_RAIDS_POINTS = 25;
    public static final int RAIDS_POINTS = 10;
    public static final int MASTER_POINTS = 5;
    public static final int ELITE_POINTS = 3;
    public static final int HARD_POINTS = 2;
    public static final int DEFAULT_POINTS = 1;

    public static final List<Integer> POINT_VALUES = List.of(GRAND_MASTER_POINTS,
            HARD_MODE_RAIDS_POINTS,
            RAIDS_POINTS,
            MASTER_POINTS,
            ELITE_POINTS,
            HARD_POINTS,
            DEFAULT_POINTS);

    public static final int DIVISOR = 1;

    //50 pts
    public static final List<HiscoreSkill> GRAND_MASTER_BOSSES = ImmutableList.of(
            TZKAL_ZUK, SOL_HEREDIT
    );

    //25 pts
    public static final List<HiscoreSkill> HARD_MODE_RAIDS = ImmutableList.of(
            CHAMBERS_OF_XERIC_CHALLENGE_MODE, THEATRE_OF_BLOOD_HARD_MODE, TOMBS_OF_AMASCUT_EXPERT
    );

    //10 pts
    public static final List<HiscoreSkill> RAIDS = ImmutableList.of(
            CHAMBERS_OF_XERIC, THEATRE_OF_BLOOD, TOMBS_OF_AMASCUT
    );

    //5 pts
    public static final List<HiscoreSkill> MASTER_BOSSES = ImmutableList.of(
            TZTOK_JAD, // being included here because of time? Maybe move up.
            THE_WHISPERER,
            DUKE_SUCELLUS,
            THE_LEVIATHAN,
            VARDORVIS,
            YAMA,
            PHOSANIS_NIGHTMARE,
            THE_CORRUPTED_GAUNTLET,
            DOOM_OF_MOKHAIOTL,
            NEX /* This one is tough because of masses? */
    );

    //3 pts
    public static final List<HiscoreSkill> ELITE_BOSSES = ImmutableList.of(
            CALLISTO,
            VENENATIS,
            VETION,
            THE_GAUNTLET,
            PHANTOM_MUSPAH,
            ARAXXOR,
            NIGHTMARE, /* This one is tough because of masses? */
            CORPOREAL_BEAST
    );

    //2 pts
    public static final List<HiscoreSkill> HARD_BOSSES = ImmutableList.of(
            ZULRAH,
            VORKATH,
            ALCHEMICAL_HYDRA
    );

    //1 pt
    public static final List<HiscoreSkill> BOSSES = ImmutableList.of(
            ABYSSAL_SIRE, AMOXLIATL, ARTIO, BARROWS_CHESTS,
            BRYOPHYTA, CALVARION, CERBERUS,
            CHAOS_ELEMENTAL, CHAOS_FANATIC, COMMANDER_ZILYANA, CRAZY_ARCHAEOLOGIST, DAGANNOTH_PRIME,
            DAGANNOTH_REX, DAGANNOTH_SUPREME, DERANGED_ARCHAEOLOGIST, GENERAL_GRAARDOR,
            GIANT_MOLE, GROTESQUE_GUARDIANS, HESPORI,
            KALPHITE_QUEEN, KING_BLACK_DRAGON, KRAKEN,
            KREEARRA, KRIL_TSUTSAROTH, LUNAR_CHESTS, MIMIC, OBOR,
            SARACHNIS, SCORPIA, SCURRIUS,
            SHELLBANE_GRYPHON, SKOTIZO,
            SPINDEL, TEMPOROSS, THE_HUEYCOATL,
            THE_ROYAL_TITANS, THERMONUCLEAR_SMOKE_DEVIL, WINTERTODT,
            ZALCANO
    );

    private static final Map<List<HiscoreSkill>, Integer> BOSS_LIST_TO_POINT_MAP =
            Map.of(GRAND_MASTER_BOSSES, GRAND_MASTER_POINTS,
                    HARD_MODE_RAIDS, HARD_MODE_RAIDS_POINTS,
                    RAIDS, RAIDS_POINTS,
                    MASTER_BOSSES, MASTER_POINTS,
                    ELITE_BOSSES, ELITE_POINTS,
                    HARD_BOSSES, HARD_POINTS,
                    BOSSES, DEFAULT_POINTS
            );

    public static final List<List<HiscoreSkill>> ALL = List.of(
            GRAND_MASTER_BOSSES,
            HARD_MODE_RAIDS,
            RAIDS,
            MASTER_BOSSES,
            ELITE_BOSSES, HARD_BOSSES, BOSSES);

    public static Map<HiscoreSkill, Integer> FULL_POINT_MAPPINGS;

    static {

        FULL_POINT_MAPPINGS = BOSS_LIST_TO_POINT_MAP.entrySet().stream()
                .flatMap(entry -> entry.getKey().stream()
                        .map(boss -> Map.entry(boss, entry.getValue())))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public static int getScore(Map<HiscoreSkill, Integer> kcs, int divisor) {
        AtomicInteger score = new AtomicInteger();
        kcs.forEach((hiscore, kc) -> {

            if (BOSSES.contains(hiscore)) {
                score.addAndGet(DEFAULT_POINTS * kc);
            } else if(HARD_BOSSES.contains(hiscore)) {
                score.addAndGet(HARD_POINTS * kc);
            } else if(ELITE_BOSSES.contains(hiscore)) {
                score.addAndGet(ELITE_POINTS * kc);
            } else if(MASTER_BOSSES.contains(hiscore)) {
                score.addAndGet(MASTER_POINTS * kc);
            } else if(RAIDS.contains(hiscore)) {
                score.addAndGet(RAIDS_POINTS * kc);
            } else if(HARD_MODE_RAIDS.contains(hiscore)) {
                score.addAndGet(HARD_MODE_RAIDS_POINTS * kc);
            } else if(GRAND_MASTER_BOSSES.contains(hiscore)) {
                score.addAndGet(GRAND_MASTER_POINTS * kc);
            }

        });

        return score.get() / divisor;
    }


}

package com.pvmscore.overlay;

import com.pvmscore.PvmScore;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import static com.pvmscore.PvmScore.DEFAULT_POINTS;

public class BossPointsOverlay extends Overlay {

    private int points = -1;
    private int yOffset = 0;  // Track vertical offset
    private static final int MOVE_SPEED = 2;  // Pixels to move up per render

    private final boolean testing = false;
    private final Client client;

    public BossPointsOverlay(Client client) {
        this.client = client;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        return drawSomething(graphics);
    }

    private Dimension drawSomething(Graphics2D graphics) {
        if (points == -1) {
            return null;
        }

        String text = String.format("+%d", points);

        Point textLocation = client.getLocalPlayer()
                .getCanvasTextLocation(graphics, text, client.getLocalPlayer().getLogicalHeight() + 100 + yOffset);

        OverlayUtil.renderTextLocation(graphics, textLocation, text, ColorScheme.TEXT_COLOR);

        // Move up for next render
        yOffset += MOVE_SPEED;
        return null;
    }

    public void notifyNotKill() {
        points = -1;
    }

    public void notifyKill(NPC npc) {
        AtomicInteger pts = new AtomicInteger(-1);
        AtomicBoolean found = new AtomicBoolean(false);

        if (testing) {
            points = 1;
            yOffset = 0;  // Reset offset on new kill
            return;
        }

        for (List<HiscoreSkill> bosses: PvmScore.ALL) {
            bosses.forEach(boss -> {
                if (boss.getName().equals(npc.getName())) {
                    pts.set(PvmScore.FULL_POINT_MAPPINGS.get(boss));
                    found.set(true);
                }
            });

            if (found.get()) {
                break;
            }
        }

        points = pts.get();
        yOffset = 0;  // Reset offset on new kill
    }
}

package com.pvmscore;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.hiscore.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Slf4j
public class PlayerManager {

    @Getter
    private final ConcurrentHashMap<String, PlayerStat> activeUsernameToKillList = new ConcurrentHashMap<>();

    private final HashMap<String, PlayerStat> cachedUsernameToKillList = new HashMap<>();

    private final ExecutorService executor = Executors.newFixedThreadPool(10);

    private final Queue<PlayerStat> kcLookupQueue = new ConcurrentLinkedQueue<>();

    private final Client client;
    private final HiscoreClient hiscoreClient;
    private Player localPlayer;

    public PlayerManager(Client client, HiscoreClient hiscoreClient) {
        this.client = client;
        this.hiscoreClient = hiscoreClient;
    }

    public PlayerStat getLocalPlayer() {
        if (localPlayer != null) {
            return this.activeUsernameToKillList.get(localPlayer.getName());
        } else {
            return new PlayerStat(null);
        }
    }

    public CompletableFuture<HiscoreResult> initLocalPlayer() {
        this.localPlayer = client.getLocalPlayer();
        PlayerStat localPlayerStat = new PlayerStat(this.localPlayer);

        return localPlayerStat.fetchPlayerKC().whenComplete((result, err) -> {

            if (err != null) {
                log.error("Error fetching Kc's for local player on log in.");
            }

            this.activeUsernameToKillList.put(Objects.requireNonNull(this.localPlayer.getName()), localPlayerStat);
            log.debug("Finished fetching local player.");

        });
    }

    public void addPlayer(Player player) {

        if (player == null || player.getName() == null) {
            return;
        }

        if (activeUsernameToKillList.containsKey(player.getName())) {
            return;
        }

        if (activeUsernameToKillList.size() > 1000) {
            return;
        }

        if (cachedUsernameToKillList.containsKey(player.getName())) {
            activeUsernameToKillList.putIfAbsent(player.getName(), cachedUsernameToKillList.get(player.getName()));
            cachedUsernameToKillList.remove(player.getName());
        } else {
            PlayerStat ps = new PlayerStat(player);
            activeUsernameToKillList.putIfAbsent(player.getName(), ps);
            this.kcLookupQueue.offer(ps);
        }
    }

    public void removePlayer(Player player) {
        String name =  Objects.requireNonNull(player.getName());
        PlayerStat stats = activeUsernameToKillList.remove(name);
        if (stats != null && stats.hasFetchedKcs) {
            log.debug("Caching player who left scene {}", name);
            cachedUsernameToKillList.put(name, stats);
        }

    }

    public PlayerStat getPlayer(String name) {
        return this.activeUsernameToKillList.get(name);
    }


    public void processLookups() {
        if (this.kcLookupQueue.isEmpty()) {
            return;
        }

        PlayerStat ps = this.kcLookupQueue.poll();
        executor.submit(ps::fetchPlayerKC);
    }


    public class PlayerStat
    {
        @Getter
        private final Player player;

        @Getter
        private final Map<HiscoreSkill, Integer> killCounts;

        private boolean hasFetchedKcs = false;

        private int calculatedLevel = -1;
        private int calculatedKc = -1;

        private List<Map.Entry<HiscoreSkill, Integer>> sorted;

        PlayerStat(Player player) {
            this.player = player;
            this.killCounts = new HashMap<>();
        }

        private void addKc(HiscoreSkill boss, int kc) {
            this.killCounts.put(boss, kc);
        }

        public List<Map.Entry<HiscoreSkill, Integer>> getSorted() {

            if (!hasFetchedKcs) {
                kcLookupQueue.offer(this);
                return Collections.EMPTY_LIST;
            }

            if (sorted == null) {
                sorted = killCounts.entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                        .collect(Collectors.toList());
            }
            return sorted;
        }

        public boolean hasFetchedKcs() {
            return this.hasFetchedKcs;
        }

        public String getLevel() {
            if (!hasFetchedKcs) {
                if (!kcLookupQueue.contains(this)){
                    kcLookupQueue.offer(this);
                }
                return "?";
            }

            return String.valueOf(calculateScore());
        }

        public String getTotalKc() {
            if (!hasFetchedKcs) {
                if (!kcLookupQueue.contains(this)){
                    kcLookupQueue.offer(this);
                }
                return "?";
            }

            return String.valueOf(calculateTotalKc());
        }

        private int calculateTotalKc() {
            if (calculatedKc != -1) {
                return this.calculatedKc;
            }

            AtomicInteger total = new AtomicInteger();

            this.killCounts.values().forEach(total::addAndGet);

            this.calculatedKc = total.get();
            return this.calculatedKc;

        }

        private int calculateScore() {
            if (calculatedLevel != -1) {
                return this.calculatedLevel;
            }

            this.calculatedLevel = PvmScore.getScore(getKillCounts(), PvmScore.DIVISOR);

            return calculatedLevel;
        }

        synchronized public CompletableFuture<HiscoreResult> fetchPlayerKC()
        {
            long start = System.currentTimeMillis();

            log.debug("Attempting to fetch KC's for player {}", player.getName());

            return hiscoreClient.lookupAsync(player.getName(), HiscoreEndpoint.NORMAL)
                    .whenComplete((result, err) -> {

                        if (err != null) {
                            log.error("Error fetching Kc's for {}", player.getName());
                            return;
                        }

                        result.getSkills().forEach((hiscore, skill) -> {
                            if (hiscore.getType().equals(HiscoreSkillType.BOSS)) {
                                if (skill.getLevel() > 0) {
                                    this.addKc(hiscore, skill.getLevel());
                                }
                            }
                        });

                    calculateScore();
                    getSorted();
                    hasFetchedKcs = true;
                    long end = System.currentTimeMillis();
                    log.debug("Hiscore Fetch took {} seconds for {}.", (end - start) / 1000, player.getName());
                });
        }


    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nonnull;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.Locale;

public class GMPanelParent extends PluginPanel {

    GMPanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat) {

        setBorder(new EmptyBorder(3, 3, 3, 3));

        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel solPanel = new GMPanel(spriteManager, HiscoreSkill.SOL_HEREDIT, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.SOL_HEREDIT, 0));
        JPanel zukPanel = new GMPanel(spriteManager, HiscoreSkill.TZKAL_ZUK, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.TZKAL_ZUK, 0));

        add(solPanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(zukPanel);

        setVisible(true);
    }

    private class GMPanel extends JPanel {

        public GMPanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, int kc)
        {

            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            Color borderColor = new Color(58, 58, 58);

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, borderColor),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            JLabel boss = getBossLabelName(hiscoreSkill);

            String kcFormatted = QuantityFormatter.quantityToStackSize(kc);
            JLabel kcLabel = new JLabel(StringUtils.capitalize(kcFormatted));

            kcLabel.setForeground(Color.YELLOW);

            kcLabel.setFont(FontManager.getRunescapeFont());
            kcLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(kc));
            kcLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

        @Nonnull
        private JLabel getBossLabelName(HiscoreSkill hiscoreSkill) {
            String bossName = "";

            if (hiscoreSkill.equals(HiscoreSkill.TZKAL_ZUK)) {
                bossName = "Zuk";
            }

            if (hiscoreSkill.equals(HiscoreSkill.SOL_HEREDIT)) {
                bossName = "Sol";
            }

            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);
            return boss;
        }

    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Player;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.util.List;
import java.util.Map;

@Slf4j
public class PvMPluginPanel extends PluginPanel {

    public final static String NO_PLAYER_SELECTED = "No player selected";
    public final static String NO_PLAYER_SELECTED_LEVEL = "Score: ?";
    public final static String NO_PLAYER_SELECTED_KC = "Total kills: ?";

    private static final String LOADING_TEXT = "loading...";

    private GridBagConstraints c;
    private JPanel bossPanels;
    private JPanel topThreePanel;
    private HeaderPanel header;
    private JPanel raidsPanel;
    private JPanel hardModeRaidsPanel;

    private JPanel gmPanel;

    private PlayerManager playerManager;
    private SpriteManager spriteManager;

    private GroupLayout layout;

    private JButton resetToSelf;

    public void init(PlayerManager playerManager, SpriteManager spriteManager) {
        this.playerManager = playerManager;
        this.spriteManager = spriteManager;

        layout = new GroupLayout(this);
        setLayout(layout);
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        this.raidsPanel = new RaidsPanelParent(spriteManager, null, false);

        this.gmPanel = new GMPanelParent(spriteManager, null);

        this.hardModeRaidsPanel = new RaidsPanelParent(spriteManager, null, true);

        this.topThreePanel = new TopThreePanelParent(spriteManager, null);

        this.bossPanels = new JPanel(new GridBagLayout());

        c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;

        header = new HeaderPanel();

        resetToSelf = new JButton();
        resetToSelf.setBackground(ColorScheme.DARK_GRAY_COLOR);
        resetToSelf.setFont(FontManager.getRunescapeSmallFont());
        resetToSelf.add(new JLabel("Reset to Me"));
        resetToSelf.addActionListener(e -> {
            Player localPlayer = playerManager.getLocalPlayer().getPlayer();

            if (localPlayer != null) {
                update(localPlayer.getName());
            }
        });

        header.add(resetToSelf);

        setLayout();
    }

    public PvMPluginPanel()
    {

    }

    private void setLayout() {
        layout.setHorizontalGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(header)
                        .addComponent(hardModeRaidsPanel)
                        .addComponent(gmPanel)
                        .addComponent(raidsPanel)
                        .addComponent(topThreePanel)
                        .addComponent(bossPanels)
                )
        );

        layout.setVerticalGroup(layout.createSequentialGroup()
                .addComponent(header)
                .addGap(10)
                .addComponent(gmPanel)
                .addGap(10)
                .addComponent(hardModeRaidsPanel)
                .addGap(10)
                .addComponent(raidsPanel)
                .addGap(10)
                .addComponent(topThreePanel)
                .addGap(10)
                .addComponent(bossPanels)
        );
    }

    public void loading(String playerName) {
        header.nameLabel.setText("Player: " + playerName);
        header.scoreLabel.setText("Score: " + LOADING_TEXT);
        header.totalKcLabel.setText("Total kills: " + LOADING_TEXT);
    }

    public void update(String playerName)
    {
        PlayerManager.PlayerStat playerStat;
        if (playerName.isEmpty() || playerName == null)
        {
            this.header.nameLabel.setText(NO_PLAYER_SELECTED);
            this.header.scoreLabel.setText(NO_PLAYER_SELECTED_LEVEL);
            this.header.totalKcLabel.setText(NO_PLAYER_SELECTED_KC);
            return;
        }
        else
        {
            playerStat = playerManager.getPlayer(playerName);
            this.header.nameLabel.setText("Player: " + playerName);
            this.header.scoreLabel.setText("Score: " + playerStat.getLevel());
            this.header.totalKcLabel.setText("Total kills: " + playerStat.getTotalKc());
        }

        SwingUtilities.invokeLater(() ->
                {
                    removeAll();
                    bossPanels.removeAll();

                    topThreePanel = new TopThreePanelParent(spriteManager, playerStat);
                    raidsPanel = new RaidsPanelParent(spriteManager, playerStat, false);
                    hardModeRaidsPanel = new RaidsPanelParent(spriteManager, playerStat, true);
                    gmPanel = new GMPanelParent(spriteManager, playerStat);

                    List<Map.Entry<HiscoreSkill, Integer>> sorted = playerStat.getSorted();
                    if (playerStat.hasFetchedKcs()){
                        for (int i = 3; i < sorted.size(); i++) {
                            int currKc = sorted.get(i).getValue();
                            bossPanels.add(new BossPanel(sorted.get(i).getKey(), currKc), c);
                            c.gridy++;
                        }
                        header.revalidate();
                        header.repaint();
                    }

                    setLayout();

                }
        );
    }
}

package com.pvmscore.panel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import java.awt.*;

import static com.pvmscore.panel.PvMPluginPanel.*;

public class HeaderPanel extends PluginPanel {

    public JLabel nameLabel;
    public JLabel scoreLabel;
    public JLabel totalKcLabel;

    public HeaderPanel() {
        BoxLayout groupLayout = new BoxLayout(this, BoxLayout.Y_AXIS);
        setLayout(groupLayout);
        setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(1, 1, 1, 1, new Color(58, 58, 58)),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));


        nameLabel = new JLabel(NO_PLAYER_SELECTED);
        nameLabel.setForeground(Color.YELLOW);
        nameLabel.setFont(FontManager.getRunescapeBoldFont());
        nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        scoreLabel = new JLabel(NO_PLAYER_SELECTED_LEVEL);
        scoreLabel.setForeground(Color.YELLOW);
        scoreLabel.setFont(FontManager.getRunescapeFont());
        scoreLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        totalKcLabel = new JLabel(NO_PLAYER_SELECTED_KC);
        totalKcLabel.setForeground(Color.YELLOW);
        totalKcLabel.setFont(FontManager.getRunescapeFont());
        totalKcLabel.setAlignmentX(Component.LEFT_ALIGNMENT);


        setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(nameLabel);
        add(scoreLabel);
        add(totalKcLabel);

    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nonnull;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class RaidsPanelParent extends PluginPanel {

    RaidsPanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat, boolean hardMode) {

        setBorder(new EmptyBorder(3, 3, 3, 3));

        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel;
        JPanel middlePanel;
        JPanel bottomPanel;
        if (hardMode) {
            topPanel = new RaidsPanel(spriteManager, HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, getHardModeKcs(playerStat).get(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE), true);
            middlePanel = new RaidsPanel(spriteManager, HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE, getHardModeKcs(playerStat).get(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE), true);
            bottomPanel = new RaidsPanel(spriteManager, HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT, getHardModeKcs(playerStat).get(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT), true);
        } else {
            topPanel = new RaidsPanel(spriteManager, HiscoreSkill.CHAMBERS_OF_XERIC, getRaidsKc(playerStat).get(HiscoreSkill.CHAMBERS_OF_XERIC), false);
            middlePanel = new RaidsPanel(spriteManager, HiscoreSkill.THEATRE_OF_BLOOD, getRaidsKc(playerStat).get(HiscoreSkill.THEATRE_OF_BLOOD), false);
            bottomPanel = new RaidsPanel(spriteManager, HiscoreSkill.TOMBS_OF_AMASCUT, getRaidsKc(playerStat).get(HiscoreSkill.TOMBS_OF_AMASCUT), false);
        }

        add(topPanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(middlePanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(bottomPanel);

        setVisible(true);
    }

    private Map<HiscoreSkill, Integer> getHardModeKcs(PlayerManager.PlayerStat playerStat) {
        Map<HiscoreSkill, Integer> result = new HashMap<>();
        result.put(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, 0));
        result.put(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE, 0));
        result.put(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT, 0));

        return result;
    }

    private Map<HiscoreSkill, Integer> getRaidsKc(PlayerManager.PlayerStat playerStat) {
        Map<HiscoreSkill, Integer> result = new HashMap<>();
        result.put(HiscoreSkill.CHAMBERS_OF_XERIC, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.CHAMBERS_OF_XERIC, 0));
        result.put(HiscoreSkill.THEATRE_OF_BLOOD, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.THEATRE_OF_BLOOD, 0));
        result.put(HiscoreSkill.TOMBS_OF_AMASCUT, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.TOMBS_OF_AMASCUT, 0));

        return result;
    }

    private class RaidsPanel extends JPanel {

        public RaidsPanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, int kc, boolean hardMode)
        {

            Color borderColor;
            if (hardMode) {
                setBackground(new Color(97, 57, 52));
                borderColor = new Color(30, 30, 30);
            } else {
                setBackground(ColorScheme.DARKER_GRAY_COLOR);
                borderColor = new Color(58, 58, 58);
            }

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, borderColor),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            JLabel boss = getBossLabelName(hiscoreSkill);

            String kcFormatted = QuantityFormatter.quantityToStackSize(kc);
            JLabel kcLabel = new JLabel(StringUtils.capitalize(kcFormatted));

            kcLabel.setForeground(Color.YELLOW);

            kcLabel.setFont(FontManager.getRunescapeFont());
            kcLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(kc));
            kcLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

        @Nonnull
        private JLabel getBossLabelName(HiscoreSkill hiscoreSkill) {
            String bossName = "";

            if (hiscoreSkill.equals(HiscoreSkill.CHAMBERS_OF_XERIC)) {
                bossName = "CoX";
            }

            if (hiscoreSkill.equals(HiscoreSkill.THEATRE_OF_BLOOD)) {
                bossName = "ToB";
            }

            if (hiscoreSkill.equals(HiscoreSkill.TOMBS_OF_AMASCUT)) {
                bossName = "ToA";
            }

            if (hiscoreSkill.equals(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE)) {
                bossName = "CoX CM";
            }

            if (hiscoreSkill.equals(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE)) {
                bossName = "ToB HM";
            }

            if (hiscoreSkill.equals(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT)) {
                bossName = "ToA Ex";
            }

            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);
            return boss;
        }

    }

}

package com.pvmscore.panel;

import com.pvmscore.PvmScore;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.text.NumberFormat;
import java.util.Locale;

public class BossPanel extends PluginPanel {

    BossPanel(HiscoreSkill hiscoreSkill, Integer kc)
    {
        setBorder(new EmptyBorder(3, 3, 3, 3));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);

        String bossLabel = StringUtils.capitalize(hiscoreSkill.getName().toLowerCase());
        bossLabel += " (" + PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill)
                + (PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill) > 1 ? "pts" : "pt") + ")";

        JLabel boss = new JLabel(bossLabel);
        boss.setFont(FontManager.getRunescapeSmallFont());
        boss.setForeground(Color.GRAY);
        String kcFormatted = QuantityFormatter.quantityToStackSize(kc);
        JLabel kcLabel = new JLabel(StringUtils.capitalize(kcFormatted));

        kcLabel.setForeground(Color.YELLOW);

        kcLabel.setFont(FontManager.getRunescapeFont());
        kcLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(kc));

        layout.setVerticalGroup(layout.createParallelGroup()
                .addGroup(layout.createSequentialGroup()
                        .addComponent(boss)
                        .addComponent(kcLabel)
                )

        );

        layout.setHorizontalGroup(layout.createSequentialGroup()
                .addGap(8)
                .addGroup(layout.createParallelGroup()
                        .addComponent(boss)
                        .addComponent(kcLabel)
                )
        );

    }
}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import com.pvmscore.PvmScore;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Locale;

public class TopThreePanelParent extends PluginPanel
{

    TopThreePanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat) {

        setBorder(new EmptyBorder(3, 3, 3, 3));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        ArrayList<JPanel> panels = new ArrayList<>();
        for(int i = 0; i < 3; i++) {

            HiscoreSkill hiscoreSkill;
            int kc;

            if (playerStat == null || !playerStat.hasFetchedKcs() || playerStat.getSorted().size() <= i) {
                hiscoreSkill = null;
                kc = 0;
            } else {
                hiscoreSkill = playerStat.getSorted().get(i).getKey();
                kc = playerStat.getSorted().get(i).getValue();
            }

            JPanel panel = new TopThreePanel(spriteManager, hiscoreSkill, kc);
            panels.add(panel);
        }

        panels.forEach(p -> {
            add(p);
            add(Box.createVerticalStrut(6)); // spacing
        });

        setVisible(true);
    }

    private class TopThreePanel extends PluginPanel {

        TopThreePanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, Integer kc)
        {
            setBackground(ColorScheme.DARKER_GRAY_COLOR);

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, new Color(58, 58, 58)),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            String bossName = (hiscoreSkill != null) ? StringUtils.capitalize(hiscoreSkill.getName().toLowerCase()) : "None";
            bossName += (hiscoreSkill != null) ? " (" + PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill)
                    + (PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill) > 1 ? "pts" : "pt") + ")" : "";
            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);

            String kcFormatted = QuantityFormatter.quantityToStackSize(kc);
            JLabel kcLabel = new JLabel(StringUtils.capitalize(kcFormatted));

            kcLabel.setForeground(Color.YELLOW);

            kcLabel.setFont(FontManager.getRunescapeFont());
            kcLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(kc));
            kcLabel.setHorizontalAlignment(SwingConstants.CENTER);


            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

    }

}

package com.pvmscore;

import net.runelite.client.hiscore.HiscoreSkill;
import org.junit.Before;
import org.junit.Test;

import java.util.HashMap;
import java.util.Map;

import static org.junit.Assert.assertEquals;

public class ScoreCalculatorTest {

    private Map<HiscoreSkill, Integer> killCounts;

    //better for more accurate testing of the point calculations
    private final int defaultDivisor = 1;

    @Before
    public void setUp() {
        killCounts = new HashMap<>();
    }

    @Test
    public void testEmptyKillCounts() {
        int score = PvmScore.getScore(killCounts, defaultDivisor);
        assertEquals(0, score);
    }

    @Test
    public void testDefaultBossPoints() {
        killCounts.put(HiscoreSkill.OBOR, 10);

        int expected = (PvmScore.DEFAULT_POINTS * 10) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testHardBossPoints() {
        killCounts.put(HiscoreSkill.VORKATH, 5);

        int expected = (PvmScore.HARD_POINTS * 5) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testEliteBossPoints() {
        killCounts.put(HiscoreSkill.VETION, 3);

        int expected = (PvmScore.ELITE_POINTS * 3) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testMasterBossPoints() {
        killCounts.put(HiscoreSkill.TZKAL_ZUK, 1);

        int expected = (PvmScore.GRAND_MASTER_POINTS * 1) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testRaidsPoints() {
        killCounts.put(HiscoreSkill.CHAMBERS_OF_XERIC, 50);

        int expected = (PvmScore.RAIDS_POINTS * 50) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testHardModeRaidsPoints() {
        killCounts.put(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, 10);

        int expected = (PvmScore.HARD_MODE_RAIDS_POINTS * 10) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testGrandMasterBossPoints() {
        killCounts.put(HiscoreSkill.SOL_HEREDIT, 5);

        int expected = (PvmScore.GRAND_MASTER_POINTS * 5) / defaultDivisor;
        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testMultipleBossTypes() {
        killCounts.put(HiscoreSkill.ABYSSAL_SIRE, 10);      // DEFAULT_POINTS
        killCounts.put(HiscoreSkill.VORKATH, 5);                // HARD_POINTS
        killCounts.put(HiscoreSkill.CORPOREAL_BEAST, 3);          // ELITE_POINTS

        int expected = (
                (PvmScore.DEFAULT_POINTS * 10) +
                        (PvmScore.HARD_POINTS * 5) +
                        (PvmScore.ELITE_POINTS * 3)
        ) / defaultDivisor;

        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }

    @Test
    public void testZeroKillCount() {
        killCounts.put(HiscoreSkill.ZULRAH, 0);

        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(0, score);
    }

    @Test
    public void testDivisionByHundredRoundsDown() {

        int divisor = 100;

        killCounts.put(HiscoreSkill.SCURRIUS, 99);

        int score = PvmScore.getScore(killCounts, divisor);

        assertEquals(0, score);
    }

    @Test
    public void testLargeKillCounts() {
        killCounts.put(HiscoreSkill.CHAOS_ELEMENTAL, 10000);
        killCounts.put(HiscoreSkill.VORKATH, 5000);

        int expected = (
                (PvmScore.DEFAULT_POINTS * 10000) +
                        (PvmScore.HARD_POINTS * 5000)
        ) / defaultDivisor;

        int score = PvmScore.getScore(killCounts, defaultDivisor);

        assertEquals(expected, score);
    }
}


package com.pvmscore;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PvMScorePluginTest {
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(PvmScorePlugin.class);
        RuneLite.main(args);
    }
}

