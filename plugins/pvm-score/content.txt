package com.pvmscore;

import com.google.inject.Provider;
import com.google.inject.Provides;

import javax.inject.Inject;
import javax.swing.*;

import com.pvmscore.overlay.BossPointsOverlay;
import com.pvmscore.panel.PvMPluginPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreClient;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

import java.awt.image.BufferedImage;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

@Slf4j
@PluginDescriptor(
	name = "PvM Score",
	configName = "PvmScoreConfig"
)
public class PvmScorePlugin extends Plugin
{
	private static final String MENU_TITLE = "PvM Score";

	@Inject
	private Client client;

	@Inject
	private HiscoreClient hiscoreClient;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PvmScoreConfig config;

	Set<Player> previousPlayerSet;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Provider<MenuManager> menuManager;

	@Inject
	SpriteManager spriteManager;

	@Inject
	PvmScoreConfig pvmScoreConfig;

	BossPointsOverlay bossPointsOverlay;

	private PvMPluginPanel pvmPluginPanel;
	private NavigationButton navButton;

	private PlayerManager playerManager;

	private boolean firstTick = true;

	public static final String YELLOW = "ffff00";
	public static final String GREEN = "00ff00";
	public static final String RED = "ff0000";
	public static final String ORANGE = "ff9040";

	private int tickCount = -1;

	@Override
	protected void startUp() throws Exception
	{
		this.playerManager = new PlayerManager(client, hiscoreClient);
		menuManager.get().addPlayerMenuItem(MENU_TITLE);

		pvmPluginPanel = injector.getInstance(PvMPluginPanel.class);
		pvmPluginPanel.init(playerManager, spriteManager);

		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "game_icon_tzkalzuk.png");

		navButton = NavigationButton.builder()
				.tooltip("PvM-Score Panel")
				.icon(icon)
				.priority(5)
				.panel(pvmPluginPanel)
				.build();

		bossPointsOverlay = new BossPointsOverlay(client);

		overlayManager.add(bossPointsOverlay);
		clientToolbar.addNavigation(navButton);
	}

	@Override
	protected void shutDown() throws Exception
	{
		menuManager.get().removePlayerMenuItem(MENU_TITLE);
		overlayManager.remove(bossPointsOverlay);
		clientToolbar.removeNavigation(navButton);
		navButton = null;
		pvmPluginPanel = null;
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (event.getMenuOption().equals(MENU_TITLE))
		{
			try
			{
				SwingUtilities.invokeAndWait(() -> clientToolbar.openPanel(navButton));
			}
			catch (InterruptedException | InvocationTargetException e)
			{
				throw new RuntimeException(e);
			}

			String target = Text.sanitize(Text.removeTags(event.getMenuEntry().getTarget()));

			String playerName = target.substring(0, target.indexOf("(score-")).trim();

			if (!playerManager.getPlayer(playerName).hasFetchedKcs()) {

				pvmPluginPanel.loading(playerName);
				playerManager.getPlayer(playerName).fetchPlayerKC().whenComplete((result, error) -> {
					pvmPluginPanel.update(playerName);
				});
			} else {
				pvmPluginPanel.update(playerName);
			}
			pvmPluginPanel.clearSearchBar();
		}

	}

	@Subscribe
	public void onMenuOpened(MenuOpened event)
	{
		Stream.of(event.getMenuEntries())
				.filter(e -> e.getOption().equals(MENU_TITLE))
				.forEach(menuEntry -> {
					Actor actor = menuEntry.getActor();

					if (actor instanceof Player) {
						Player player = (Player) actor;
						String playerName = player.getName();
						PlayerManager.PlayerStat playerStat = playerManager.getPlayer(playerName);
						if (playerStat != null) {
							menuEntry.setTarget(updateTarget(menuEntry, playerStat));
						}
					}
				});
	}

	private String updateTarget(MenuEntry menuEntry, PlayerManager.PlayerStat playerStat) {
		String s = menuEntry.getTarget();

		String newLevel = String.format("(score-%s)", playerStat.getLevel());

		// Replace the level text
		s = s.replaceAll("\\(level-\\d+\\)", newLevel);

		String color = colorLevelCompare(playerStat);

		if (!color.isBlank()) {
			// Replace the second <col=> tag
			s = s.replaceAll("(<col=[^>]+>[^<]+)<col=[^>]+>", "$1<col="
					+ colorLevelCompare(playerStat) + ">");
		}

		return s;
	}

	private String colorLevelCompare(PlayerManager.PlayerStat playerStat) {
		String color = "";

		if (playerStat.getLevel().equals("?")) {
			return "";
		}

		if (Integer.parseInt(playerStat.getLevel()) >
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = RED;
		} else if (Integer.parseInt(playerStat.getLevel()) ==
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = YELLOW;
		} else if (Integer.parseInt(playerStat.getLevel()) <
				Integer.parseInt(this.playerManager.getLocalPlayer().getLevel())) {
			color = GREEN;
		}

		return color;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		//if game log in set first tick to true;
		if (gameStateChanged.getGameState().equals(GameState.LOGIN_SCREEN)) {
			firstTick = true;
		}
	}

	@Subscribe
	public void onGameTick(final GameTick event) {

		// because LOGGED_IN Game state will have an incomplete local player.
		if (firstTick) {
			firstTick = false;
			playerManager.initLocalPlayer().whenComplete((result, ignore) -> {
				pvmPluginPanel.update(Text.sanitize(playerManager.getLocalPlayer().getPlayer()));
			});
		}

		updateWorldPlayersState();

		if (pvmScoreConfig.enablePointDrop()) {
			handleNpc();
		}
	}

	private void updateWorldPlayersState() {
		IndexedObjectSet<? extends Player> players = client.getTopLevelWorldView().players();

		players.forEach(player -> {
			playerManager.addPlayer(player.getName());
		});

		Set<Player> curr = StreamSupport.stream(players.stream().spliterator(), false).collect(Collectors.toSet());

		// this deals with players going away. I'm not super confident this is the best way to do this.
		if (previousPlayerSet != null) {
			Set<Player> removed = new HashSet<>(previousPlayerSet);
			removed.removeAll(curr);

			removed.forEach(p -> {
				log.debug("removing player {}", p.getName());
				playerManager.removePlayer(p);
			});
		}
		previousPlayerSet = curr;
		playerManager.processLookups();
	}

	@Subscribe
	public void onNpcLootReceived(NpcLootReceived event)
	{
		bossPointsOverlay.notifyKill(event.getNpc());
		tickCount = 0;
	}


	private void handleNpc() {
		if (tickCount >= 0) {
			tickCount++;

			if (tickCount >= 3) {
				bossPointsOverlay.notifyNotKill();
				tickCount = -1;
			}
		}
	}

	@Provides
	PvmScoreConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(PvmScoreConfig.class);
	}

}

package com.pvmscore;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("pvmscore")
public interface PvmScoreConfig extends Config
{
	@ConfigItem(
		keyName = "enablePointDrop",
		name = "Enable Point Drops",
		description = "Enables point drops when bosses are killed.",
		position = 0
	)
	default boolean enablePointDrop()
	{
		return true;
	}
}

package com.pvmscore;

import com.google.common.collect.ImmutableList;
import net.runelite.client.hiscore.HiscoreSkill;

import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

import static net.runelite.client.hiscore.HiscoreSkill.*;

public class PvmScore
{

    public static final int GRAND_MASTER_POINTS = 50;
    public static final int HARD_MODE_RAIDS_POINTS = 25;
    public static final int RAIDS_POINTS = 10;
    public static final int MASTER_POINTS = 5;
    public static final int ELITE_POINTS = 3;
    public static final int HARD_POINTS = 2;
    public static final int DEFAULT_POINTS = 1;

    public static final List<Integer> POINT_VALUES = List.of(GRAND_MASTER_POINTS,
            HARD_MODE_RAIDS_POINTS,
            RAIDS_POINTS,
            MASTER_POINTS,
            ELITE_POINTS,
            HARD_POINTS,
            DEFAULT_POINTS);

    public static final int DIVISOR = 1;

    //50 pts
    public static final List<HiscoreSkill> GRAND_MASTER_BOSSES = ImmutableList.of(
            TZKAL_ZUK, SOL_HEREDIT
    );

    //25 pts
    public static final List<HiscoreSkill> HARD_MODE_RAIDS = ImmutableList.of(
            CHAMBERS_OF_XERIC_CHALLENGE_MODE, THEATRE_OF_BLOOD_HARD_MODE, TOMBS_OF_AMASCUT_EXPERT
    );

    //10 pts
    public static final List<HiscoreSkill> RAIDS = ImmutableList.of(
            CHAMBERS_OF_XERIC, THEATRE_OF_BLOOD, TOMBS_OF_AMASCUT
    );

    //5 pts
    public static final List<HiscoreSkill> MASTER_BOSSES = ImmutableList.of(
            PHOSANIS_NIGHTMARE,
            THE_CORRUPTED_GAUNTLET,
            YAMA,
            DOOM_OF_MOKHAIOTL,
            NEX
    );

    //3 pts
    public static final List<HiscoreSkill> ELITE_BOSSES = ImmutableList.of(
            TZTOK_JAD,
            THE_WHISPERER,
            DUKE_SUCELLUS,
            THE_LEVIATHAN,
            VARDORVIS,
            PHANTOM_MUSPAH,
            ARAXXOR,
            NIGHTMARE,
            CORPOREAL_BEAST,
            CALLISTO,
            VENENATIS,
            VETION,
            SPINDEL,
            THE_GAUNTLET,
            ZULRAH,
            VORKATH,
            ALCHEMICAL_HYDRA,
            CERBERUS,
            COMMANDER_ZILYANA,
            GENERAL_GRAARDOR,
            KREEARRA,
            KRIL_TSUTSAROTH
    );

    //2 pts
    public static final List<HiscoreSkill> HARD_BOSSES = ImmutableList.of(
            ABYSSAL_SIRE,
            ARTIO,
            CALVARION,
            DAGANNOTH_PRIME,
            DAGANNOTH_REX,
            DAGANNOTH_SUPREME,
            LUNAR_CHESTS,
            KALPHITE_QUEEN
    );


    //1 pt
    public static final List<HiscoreSkill> BOSSES = ImmutableList.of(
            AMOXLIATL,
            BARROWS_CHESTS,
            BRYOPHYTA,
            CHAOS_ELEMENTAL,
            CHAOS_FANATIC,
            CRAZY_ARCHAEOLOGIST,
            DERANGED_ARCHAEOLOGIST,
            GIANT_MOLE,
            GROTESQUE_GUARDIANS,
            HESPORI,
            KING_BLACK_DRAGON,
            KRAKEN,
            MIMIC,
            OBOR,
            SARACHNIS,
            SCORPIA,
            SCURRIUS,
            SHELLBANE_GRYPHON,
            SKOTIZO,
            TEMPOROSS,
            THE_HUEYCOATL,
            THE_ROYAL_TITANS,
            THERMONUCLEAR_SMOKE_DEVIL,
            WINTERTODT,
            ZALCANO
    );

    private static final Map<List<HiscoreSkill>, Integer> BOSS_LIST_TO_POINT_MAP =
            Map.of(GRAND_MASTER_BOSSES, GRAND_MASTER_POINTS,
                    HARD_MODE_RAIDS, HARD_MODE_RAIDS_POINTS,
                    RAIDS, RAIDS_POINTS,
                    MASTER_BOSSES, MASTER_POINTS,
                    ELITE_BOSSES, ELITE_POINTS,
                    HARD_BOSSES, HARD_POINTS,
                    BOSSES, DEFAULT_POINTS
            );

    public static final List<List<HiscoreSkill>> ALL = List.of(
            GRAND_MASTER_BOSSES,
            HARD_MODE_RAIDS,
            RAIDS,
            MASTER_BOSSES,
            ELITE_BOSSES, HARD_BOSSES, BOSSES);

    public static Map<HiscoreSkill, Integer> FULL_POINT_MAPPINGS;

    static {

        FULL_POINT_MAPPINGS = BOSS_LIST_TO_POINT_MAP.entrySet().stream()
                .flatMap(entry -> entry.getKey().stream()
                        .map(boss -> Map.entry(boss, entry.getValue())))
                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    public static int getScore(Map<HiscoreSkill, Integer> kcs, int divisor) {
        AtomicInteger score = new AtomicInteger();
        kcs.forEach((hiscore, kc) -> {

            if (BOSSES.contains(hiscore)) {
                score.addAndGet(DEFAULT_POINTS * kc);
            } else if(HARD_BOSSES.contains(hiscore)) {
                score.addAndGet(HARD_POINTS * kc);
            } else if(ELITE_BOSSES.contains(hiscore)) {
                score.addAndGet(ELITE_POINTS * kc);
            } else if(MASTER_BOSSES.contains(hiscore)) {
                score.addAndGet(MASTER_POINTS * kc);
            } else if(RAIDS.contains(hiscore)) {
                score.addAndGet(RAIDS_POINTS * kc);
            } else if(HARD_MODE_RAIDS.contains(hiscore)) {
                score.addAndGet(HARD_MODE_RAIDS_POINTS * kc);
            } else if(GRAND_MASTER_BOSSES.contains(hiscore)) {
                score.addAndGet(GRAND_MASTER_POINTS * kc);
            }

        });

        return score.get() / divisor;
    }

}

package com.pvmscore.overlay;

import com.pvmscore.PvmScore;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayUtil;

import java.awt.*;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import static com.pvmscore.PvmScore.DEFAULT_POINTS;

public class BossPointsOverlay extends Overlay {

    private int points = -1;
    private int yOffset = 0;  // Track vertical offset
    private static final int MOVE_SPEED = 2;  // Pixels to move up per render

    private final boolean testing = false;
    private final Client client;

    public BossPointsOverlay(Client client) {
        this.client = client;
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        return drawSomething(graphics);
    }

    private Dimension drawSomething(Graphics2D graphics) {
        if (points == -1) {
            return null;
        }

        String text = String.format("+%d", points);

        Point textLocation = client.getLocalPlayer()
                .getCanvasTextLocation(graphics, text, client.getLocalPlayer().getLogicalHeight() + 100 + yOffset);

        OverlayUtil.renderTextLocation(graphics, textLocation, text, ColorScheme.TEXT_COLOR);

        // Move up for next render
        yOffset += MOVE_SPEED;
        return null;
    }

    public void notifyNotKill() {
        points = -1;
    }

    public void notifyKill(NPC npc) {
        AtomicInteger pts = new AtomicInteger(-1);
        AtomicBoolean found = new AtomicBoolean(false);

        if (testing) {
            points = 1;
            yOffset = 0;  // Reset offset on new kill
            return;
        }

        for (List<HiscoreSkill> bosses: PvmScore.ALL) {
            bosses.forEach(boss -> {
                if (boss.getName().equals(npc.getName())) {
                    pts.set(PvmScore.FULL_POINT_MAPPINGS.get(boss));
                    found.set(true);
                }
            });

            if (found.get()) {
                break;
            }
        }

        points = pts.get();
        yOffset = 0;  // Reset offset on new kill
    }
}

package com.pvmscore;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.hiscore.*;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@Slf4j
public class PlayerManager {

    @Getter
    private final ConcurrentHashMap<String, PlayerStat> activeUsernameToKillList = new ConcurrentHashMap<>();

    private final HashMap<String, PlayerStat> cachedUsernameToKillList = new HashMap<>();

    private final ExecutorService executor = Executors.newFixedThreadPool(10);

    private final Queue<PlayerStat> kcLookupQueue = new ConcurrentLinkedQueue<>();

    private final Client client;
    private final HiscoreClient hiscoreClient;
    private Player localPlayer;

    public PlayerManager(Client client, HiscoreClient hiscoreClient) {
        this.client = client;
        this.hiscoreClient = hiscoreClient;
    }

    public PlayerStat getLocalPlayer() {
        if (localPlayer != null) {
            return this.activeUsernameToKillList.get(localPlayer.getName());
        } else {
            return new PlayerStat(null);
        }
    }

    public CompletableFuture<HiscoreResult> initLocalPlayer() {
        this.localPlayer = client.getLocalPlayer();
        PlayerStat localPlayerStat = new PlayerStat(this.localPlayer.getName());

        return localPlayerStat.fetchPlayerKC().whenComplete((result, err) -> {

            if (err != null) {
                log.error("Error fetching Kc's for local player on log in.");
            }

            this.activeUsernameToKillList.put(Objects.requireNonNull(this.localPlayer.getName()), localPlayerStat);
            log.debug("Finished fetching local player.");

        });
    }

    public PlayerStat addPlayer(String player) {

        if (player == null) {
            return null;
        }

        if (activeUsernameToKillList.containsKey(player)) {
            return activeUsernameToKillList.get(player);
        }

        if (activeUsernameToKillList.size() > 1000) {
            return null;
        }

        if (cachedUsernameToKillList.containsKey(player)) {
            activeUsernameToKillList.putIfAbsent(player, cachedUsernameToKillList.get(player));
            return cachedUsernameToKillList.remove(player);
        } else {
            PlayerStat ps = new PlayerStat(player);
            activeUsernameToKillList.putIfAbsent(player, ps);
            this.kcLookupQueue.offer(ps);
            return ps;
        }
    }

    // TODO refactor to a string?
    public void removePlayer(Player player) {
        String name =  Objects.requireNonNull(player.getName());
        PlayerStat stats = activeUsernameToKillList.remove(name);
        if (stats != null && stats.hasFetchedKcs) {
            log.debug("Caching player who left scene {}", name);
            cachedUsernameToKillList.put(name, stats);
        }

    }

    public PlayerStat getPlayer(String name) {
        return this.activeUsernameToKillList.get(name);
    }


    public void processLookups() {
        if (this.kcLookupQueue.isEmpty()) {
            return;
        }

        PlayerStat ps = this.kcLookupQueue.poll();
        executor.submit(ps::fetchPlayerKC);
    }


    public class PlayerStat
    {
        @Getter
        private final String player;

        @Getter
        private final Map<HiscoreSkill, Integer> killCounts;
        @Getter
        private final Map<HiscoreSkill, Integer> pointCounts;

        private boolean hasFetchedKcs = false;

        private int calculatedLevel = -1;
        private int calculatedKc = -1;

        private List<Map.Entry<HiscoreSkill, Integer>> sortedByKc;
        private List<Map.Entry<HiscoreSkill, Integer>> sortedByScore;

        PlayerStat(String player) {
            this.player = player;
            this.killCounts = new HashMap<>();
            this.pointCounts = new HashMap<>(); // because its convenient to look these up later by Hiscore.
        }

        private void addKc(HiscoreSkill boss, int kc) {
            this.killCounts.put(boss, kc);
        }

        public List<Map.Entry<HiscoreSkill, Integer>> getSortedByScore() {
            if (!hasFetchedKcs) {
                kcLookupQueue.offer(this);
                return Collections.EMPTY_LIST;
            }

            if (sortedByScore == null) {
                sortedByScore = new ArrayList<>();
                //make a copy of kill counts so we don't mutate it.
                Map<HiscoreSkill, Integer> copy = new HashMap<>(killCounts);

                copy.entrySet().forEach((hiscore) -> {
                    int points = hiscore.getValue() * PvmScore.FULL_POINT_MAPPINGS.get(hiscore.getKey());
                    hiscore.setValue(points);
                    sortedByScore.add(hiscore);
                    pointCounts.put(hiscore.getKey(), points);
                });

                sortedByScore = sortedByScore.stream()
                        .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                        .collect(Collectors.toList());
            }

            return sortedByScore;
        }

        public List<Map.Entry<HiscoreSkill, Integer>> getSortedByKC() {

            if (!hasFetchedKcs) {
                kcLookupQueue.offer(this);
                return Collections.EMPTY_LIST;
            }

            if (sortedByKc == null) {
                sortedByKc = killCounts.entrySet().stream()
                        .sorted(Map.Entry.comparingByValue(Comparator.reverseOrder()))
                        .collect(Collectors.toList());
            }
            return sortedByKc;
        }

        public boolean hasFetchedKcs() {
            return this.hasFetchedKcs;
        }

        public String getLevel() {
            if (!hasFetchedKcs) {
                if (!kcLookupQueue.contains(this)){
                    kcLookupQueue.offer(this);
                }
                return "?";
            }

            return String.valueOf(calculateScore());
        }

        public String getTotalKc() {
            if (!hasFetchedKcs) {
                if (!kcLookupQueue.contains(this)){
                    kcLookupQueue.offer(this);
                }
                return "?";
            }

            return String.valueOf(calculateTotalKc());
        }

        private int calculateTotalKc() {
            if (calculatedKc != -1) {
                return this.calculatedKc;
            }

            AtomicInteger total = new AtomicInteger();

            this.killCounts.values().forEach(total::addAndGet);

            this.calculatedKc = total.get();
            return this.calculatedKc;

        }

        private int calculateScore() {
            if (calculatedLevel != -1) {
                return this.calculatedLevel;
            }

            this.calculatedLevel = PvmScore.getScore(getKillCounts(), PvmScore.DIVISOR);

            return calculatedLevel;
        }

        synchronized public CompletableFuture<HiscoreResult> fetchPlayerKC()
        {
            long start = System.currentTimeMillis();

            log.debug("Attempting to fetch KC's for player {}", player);

            return hiscoreClient.lookupAsync(player, HiscoreEndpoint.NORMAL)
                    .whenComplete((result, err) -> {

                        if (err != null) {
                            log.error("Error fetching Kc's for {}", player);
                            return;
                        }

                        result.getSkills().forEach((hiscore, skill) -> {
                            if (hiscore.getType().equals(HiscoreSkillType.BOSS)) {
                                if (skill.getLevel() > 0) {
                                    this.addKc(hiscore, skill.getLevel());
                                }
                            }
                        });

                    calculateScore();
                    getSortedByKC();
                    hasFetchedKcs = true;
                    long end = System.currentTimeMillis();
                    log.debug("Hiscore Fetch took {} seconds for {}.", (end - start) / 1000, player);
                });
        }


    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nonnull;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.Locale;

public class GMPanelParent extends PluginPanel {

    GMPanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat) {

        setBorder(new EmptyBorder(3, 3, 3, 3));

        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel solPanel = new GMPanel(spriteManager, HiscoreSkill.SOL_HEREDIT, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.SOL_HEREDIT, 0));
        JPanel zukPanel = new GMPanel(spriteManager, HiscoreSkill.TZKAL_ZUK, playerStat == null ? 0 : playerStat.getKillCounts().getOrDefault(HiscoreSkill.TZKAL_ZUK, 0));

        add(solPanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(zukPanel);

        setVisible(true);
    }

    private class GMPanel extends JPanel {

        public GMPanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, int kc)
        {

            setBackground(ColorScheme.DARKER_GRAY_COLOR);
            Color borderColor = new Color(58, 58, 58);

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, borderColor),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            JLabel boss = getBossLabelName(hiscoreSkill);

            String kcFormatted = QuantityFormatter.quantityToStackSize(kc);
            JLabel kcLabel = new JLabel(StringUtils.capitalize(kcFormatted));

            kcLabel.setForeground(Color.YELLOW);

            kcLabel.setFont(FontManager.getRunescapeFont());
            kcLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(kc));
            kcLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(kcLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

        @Nonnull
        private JLabel getBossLabelName(HiscoreSkill hiscoreSkill) {
            String bossName = "";

            if (hiscoreSkill.equals(HiscoreSkill.TZKAL_ZUK)) {
                bossName = "Zuk";
            }

            if (hiscoreSkill.equals(HiscoreSkill.SOL_HEREDIT)) {
                bossName = "Sol";
            }

            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);
            return boss;
        }

    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.Collections;
import java.util.List;
import java.util.Map;

@Slf4j
public class PvMPluginPanel extends PluginPanel {

    public final static String NO_PLAYER_SELECTED = "No player selected";
    public final static String NO_PLAYER_SELECTED_LEVEL = "Score: ?";
    public final static String NO_PLAYER_SELECTED_KC = "Total kills: ?";

    private static final String LOADING_TEXT = "loading...";

    private GridBagConstraints c;
    private JPanel bossPanels;
    private JPanel topThreePanel;
    private HeaderPanel header;
    private JPanel raidsPanel;
    private JPanel hardModeRaidsPanel;

    private JPanel gmPanel;

    private PlayerManager playerManager;
    private SpriteManager spriteManager;

    private GroupLayout layout;

    private JButton resetToSelf;
    private JButton sort;
    private boolean sortByKc = false;
    private static final String SORT_BY_KC = "Sort by KC";
    private static final String SORT_BY_PTS = "Sort by Points";

    private String currentSort = SORT_BY_PTS;

    private PlayerManager.PlayerStat currentPlayer = null;
    private IconTextField searchBar;
    private boolean loading = false;

    public void init(PlayerManager playerManager, SpriteManager spriteManager) {
        this.playerManager = playerManager;
        this.spriteManager = spriteManager;

        layout = new GroupLayout(this);
        setLayout(layout);
        setBorder(new EmptyBorder(10, 10, 10, 10));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        this.raidsPanel = new RaidsPanelParent(spriteManager, null, false, sortByKc);

        this.gmPanel = new GMPanelParent(spriteManager, null);

        this.hardModeRaidsPanel = new RaidsPanelParent(spriteManager, null, true, sortByKc);

        this.topThreePanel = new TopThreePanelParent(spriteManager, null, Collections.EMPTY_LIST, sortByKc);

        this.bossPanels = new JPanel(new GridBagLayout());

        c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 0;

        header = new HeaderPanel();

        resetToSelf = new JButton();
        resetToSelf.setBackground(ColorScheme.DARK_GRAY_COLOR);
        resetToSelf.setFont(FontManager.getRunescapeFont());
        resetToSelf.setText("Reset to Me");
        resetToSelf.addActionListener(e -> {
            String localPlayer = playerManager.getLocalPlayer().getPlayer();

            if (localPlayer != null) {
                update(localPlayer);
            }
        });

        sort = new JButton();
        sort.setBackground(ColorScheme.DARK_GRAY_COLOR);
        sort.setFont(FontManager.getRunescapeFont());
        sort.setText(currentSort);
        sort.addActionListener(e -> {
            sortByKc = !sortByKc;

            if (currentPlayer != null) {
                update(currentPlayer.getPlayer());
            }
        });

        header.add(resetToSelf);
        header.add(sort);

        initSearchBar();
//        header.add(searchBar);

        setLayout();
    }

    public PvMPluginPanel()
    {

    }

    private void initSearchBar() {
        searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setEditable(true);
        searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
        searchBar.setMinimumSize(new Dimension(0, 30));
        searchBar.addActionListener(e -> {
            loading(searchBar.getText());
            playerManager.addPlayer(searchBar.getText()).fetchPlayerKC()
                    .whenComplete((r, throwable) ->
                            update(searchBar.getText())
            );
        });
        searchBar.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (e.getClickCount() != 2)
                {
                    return;
                }

                loading(searchBar.getText());
                playerManager.addPlayer(searchBar.getText()).fetchPlayerKC()
                        .whenComplete((r, throwable) -> {
                    update(searchBar.getText());
                });
            }
        });
        searchBar.addClearListener(() ->
        {
            searchBar.setIcon(IconTextField.Icon.SEARCH);
            searchBar.setEditable(true);
            loading = false;
        });

    }

    private void setLayout() {
        layout.setHorizontalGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                        .addComponent(searchBar)
                        .addComponent(header)
                        .addComponent(hardModeRaidsPanel)
                        .addComponent(gmPanel)
                        .addComponent(raidsPanel)
                        .addComponent(topThreePanel)
                        .addComponent(bossPanels)
                )
        );

        layout.setVerticalGroup(layout.createSequentialGroup()
                .addComponent(searchBar)
                .addGap(3)
                .addComponent(header)
                .addGap(10)
                .addComponent(gmPanel)
                .addGap(10)
                .addComponent(hardModeRaidsPanel)
                .addGap(10)
                .addComponent(raidsPanel)
                .addGap(10)
                .addComponent(topThreePanel)
                .addGap(10)
                .addComponent(bossPanels)
        );
    }

    public void loading(String playerName) {
        loading = true;
        header.nameLabel.setText("Player: " + playerName);
        header.scoreLabel.setText("Score: " + LOADING_TEXT);
        header.totalKcLabel.setText("Total kills: " + LOADING_TEXT);
    }

    public void clearSearchBar() {
        SwingUtilities.invokeLater(() -> {
            this.searchBar.setText("");
        });
    }

    public void update(String playerName)
    {
        loading = false;
        PlayerManager.PlayerStat playerStat;

        if (playerName.isEmpty() || playerName == null)
        {
            this.header.nameLabel.setText(NO_PLAYER_SELECTED);
            this.header.scoreLabel.setText(NO_PLAYER_SELECTED_LEVEL);
            this.header.totalKcLabel.setText(NO_PLAYER_SELECTED_KC);
            currentPlayer = null;
            return;
        }
        else
        {
            playerStat = playerManager.getPlayer(playerName);

            if (currentPlayer == null || !currentPlayer.equals(playerStat)) {
                currentPlayer = playerStat;
            }

            this.header.nameLabel.setText("Player: " + playerName);
            this.header.scoreLabel.setText("Score: " + currentPlayer.getLevel());
            this.header.totalKcLabel.setText("Total kills: " + currentPlayer.getTotalKc());
            currentPlayer.getSortedByKC(); //init
            currentPlayer.getSortedByScore(); //init
        }

        SwingUtilities.invokeLater(() ->
                {
                    removeAll();
                    bossPanels.removeAll();

                    raidsPanel = new RaidsPanelParent(spriteManager, currentPlayer, false, sortByKc);
                    hardModeRaidsPanel = new RaidsPanelParent(spriteManager, currentPlayer, true, sortByKc);
                    gmPanel = new GMPanelParent(spriteManager, currentPlayer);

                    List<Map.Entry<HiscoreSkill, Integer>> sorted;


                    if (sortByKc) {
                        sort.setText(SORT_BY_PTS);

                        sorted = currentPlayer.getSortedByKC();
                        topThreePanel = new TopThreePanelParent(spriteManager, currentPlayer, sorted, sortByKc);
                    } else {
                        sort.setText(SORT_BY_KC);

                        sorted = currentPlayer.getSortedByScore();
                        topThreePanel = new TopThreePanelParent(spriteManager, currentPlayer, sorted, sortByKc);
                    }

                    if (currentPlayer.hasFetchedKcs()){
                        for (int i = 3; i < sorted.size(); i++) {
                            int currVal = sorted.get(i).getValue();
                            bossPanels.add(new BossPanel(sorted.get(i).getKey(), currVal, sortByKc), c);
                            c.gridy++;
                        }
                        header.revalidate();
                        header.repaint();
                    }

                    setLayout();

                }
        );
    }
}

package com.pvmscore.panel;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import java.awt.*;

import static com.pvmscore.panel.PvMPluginPanel.*;

public class HeaderPanel extends PluginPanel {

    public JLabel nameLabel;
    public JLabel scoreLabel;
    public JLabel totalKcLabel;

    public HeaderPanel() {
        BoxLayout groupLayout = new BoxLayout(this, BoxLayout.Y_AXIS);
        setLayout(groupLayout);
        setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(1, 1, 1, 1, new Color(58, 58, 58)),
                BorderFactory.createEmptyBorder(5, 5, 5, 5)));


        nameLabel = new JLabel(NO_PLAYER_SELECTED);
        nameLabel.setForeground(Color.YELLOW);
        nameLabel.setFont(FontManager.getRunescapeBoldFont());
        nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        scoreLabel = new JLabel(NO_PLAYER_SELECTED_LEVEL);
        scoreLabel.setForeground(Color.YELLOW);
        scoreLabel.setFont(FontManager.getRunescapeFont());
        scoreLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        totalKcLabel = new JLabel(NO_PLAYER_SELECTED_KC);
        totalKcLabel.setForeground(Color.YELLOW);
        totalKcLabel.setFont(FontManager.getRunescapeFont());
        totalKcLabel.setAlignmentX(Component.LEFT_ALIGNMENT);


        setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(nameLabel);
        add(scoreLabel);
        add(totalKcLabel);

    }

}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Nonnull;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

public class RaidsPanelParent extends PluginPanel {

    RaidsPanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat, boolean hardMode, boolean sortByKc) {

        setBorder(new EmptyBorder(3, 3, 3, 3));

        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));

        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel topPanel;
        JPanel middlePanel;
        JPanel bottomPanel;
        if (hardMode) {
            topPanel = new RaidsPanel(spriteManager, HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, getHardModeKcs(playerStat, sortByKc).get(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE), true, sortByKc);
            middlePanel = new RaidsPanel(spriteManager, HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE, getHardModeKcs(playerStat, sortByKc).get(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE), true, sortByKc);
            bottomPanel = new RaidsPanel(spriteManager, HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT, getHardModeKcs(playerStat, sortByKc).get(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT), true, sortByKc);
        } else {
            topPanel = new RaidsPanel(spriteManager, HiscoreSkill.CHAMBERS_OF_XERIC, getRaidsKc(playerStat, sortByKc).get(HiscoreSkill.CHAMBERS_OF_XERIC), false, sortByKc);
            middlePanel = new RaidsPanel(spriteManager, HiscoreSkill.THEATRE_OF_BLOOD, getRaidsKc(playerStat, sortByKc).get(HiscoreSkill.THEATRE_OF_BLOOD), false, sortByKc);
            bottomPanel = new RaidsPanel(spriteManager, HiscoreSkill.TOMBS_OF_AMASCUT, getRaidsKc(playerStat, sortByKc).get(HiscoreSkill.TOMBS_OF_AMASCUT), false, sortByKc);
        }

        add(topPanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(middlePanel);
        add(Box.createHorizontalStrut(6)); // spacing
        add(bottomPanel);

        setVisible(true);
    }

    private Map<HiscoreSkill, Integer> getHardModeKcs(PlayerManager.PlayerStat playerStat, boolean sortByKc) {
        Map<HiscoreSkill, Integer> result = new HashMap<>();
        result.put(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE,
                playerStat == null ? 0 : (sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE, 0)
        );
        result.put(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE,
                playerStat == null ? 0 : (sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE, 0)
        );
        result.put(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT,
                playerStat == null ? 0 : (sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT, 0)
        );

        return result;
    }

    private Map<HiscoreSkill, Integer> getRaidsKc(PlayerManager.PlayerStat playerStat, boolean sortByKc) {
        Map<HiscoreSkill, Integer> result = new HashMap<>();
        result.put(HiscoreSkill.CHAMBERS_OF_XERIC,
                playerStat == null ? 0 :(sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.CHAMBERS_OF_XERIC, 0));
        result.put(HiscoreSkill.THEATRE_OF_BLOOD,
                playerStat == null ? 0 : (sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.THEATRE_OF_BLOOD, 0));
        result.put(HiscoreSkill.TOMBS_OF_AMASCUT,
                playerStat == null ? 0 : (sortByKc ? playerStat.getKillCounts() : playerStat.getPointCounts()).getOrDefault(HiscoreSkill.TOMBS_OF_AMASCUT, 0));

        return result;
    }

    private class RaidsPanel extends JPanel {

        public RaidsPanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, int val, boolean hardMode, boolean sortByKc)
        {

            Color borderColor;
            if (hardMode) {
                setBackground(new Color(97, 57, 52));
                borderColor = new Color(30, 30, 30);
            } else {
                setBackground(ColorScheme.DARKER_GRAY_COLOR);
                borderColor = new Color(58, 58, 58);
            }

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, borderColor),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            JLabel boss = getBossLabelName(hiscoreSkill);

            String kcFormatted = QuantityFormatter.quantityToStackSize(val) + (sortByKc ? " kc" : " pts");
            JLabel valLabel = new JLabel(StringUtils.capitalize(kcFormatted));

            valLabel.setForeground(Color.YELLOW);

            valLabel.setFont(FontManager.getRunescapeFont());
            valLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(val));
            valLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(valLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(valLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

        @Nonnull
        private JLabel getBossLabelName(HiscoreSkill hiscoreSkill) {
            String bossName = translateName(hiscoreSkill);

            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);
            return boss;
        }

    }

    public static String translateName(HiscoreSkill hiscoreSkill) {
        if (hiscoreSkill.equals(HiscoreSkill.CHAMBERS_OF_XERIC)) {
            return  "CoX";
        }

        if (hiscoreSkill.equals(HiscoreSkill.THEATRE_OF_BLOOD)) {
            return "ToB";
        }

        if (hiscoreSkill.equals(HiscoreSkill.TOMBS_OF_AMASCUT)) {
            return "ToA";
        }

        if (hiscoreSkill.equals(HiscoreSkill.CHAMBERS_OF_XERIC_CHALLENGE_MODE)) {
            return "CoX CM";
        }

        if (hiscoreSkill.equals(HiscoreSkill.THEATRE_OF_BLOOD_HARD_MODE)) {
            return "ToB HM";
        }

        if (hiscoreSkill.equals(HiscoreSkill.TOMBS_OF_AMASCUT_EXPERT)) {
            return "ToA Ex";
        }

        return StringUtils.capitalize(hiscoreSkill.getName().toLowerCase());
    }

}

package com.pvmscore.panel;

import com.pvmscore.PvmScore;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.text.NumberFormat;
import java.util.Locale;

public class BossPanel extends PluginPanel {

    BossPanel(HiscoreSkill hiscoreSkill, Integer val, boolean sortByKc)
    {
        setBorder(new EmptyBorder(3, 3, 3, 3));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);

        String bossLabel = StringUtils.capitalize(hiscoreSkill.getName().toLowerCase());
        bossLabel += " (" + PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill)
                + (PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill) > 1 ? "pts" : "pt") + ")";

        JLabel boss = new JLabel(bossLabel);
        boss.setFont(FontManager.getRunescapeSmallFont());
        boss.setForeground(Color.GRAY);
        String kcFormatted = QuantityFormatter.quantityToStackSize(val);
        JLabel valLabel = new JLabel(StringUtils.capitalize(kcFormatted) + (sortByKc ? " kc" : " pts"));

        valLabel.setForeground(Color.YELLOW);

        valLabel.setFont(FontManager.getRunescapeFont());
        valLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(val));

        layout.setVerticalGroup(layout.createParallelGroup()
                .addGroup(layout.createSequentialGroup()
                        .addComponent(boss)
                        .addComponent(valLabel)
                )

        );

        layout.setHorizontalGroup(layout.createSequentialGroup()
                .addGap(8)
                .addGroup(layout.createParallelGroup()
                        .addComponent(boss)
                        .addComponent(valLabel)
                )
        );

    }
}

package com.pvmscore.panel;

import com.pvmscore.PlayerManager;
import com.pvmscore.PvmScore;
import net.runelite.api.gameval.SpriteID;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.hiscore.HiscoreSkill;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.StringUtils;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static com.pvmscore.panel.RaidsPanelParent.translateName;

public class TopThreePanelParent extends PluginPanel
{

    TopThreePanelParent(SpriteManager spriteManager, PlayerManager.PlayerStat playerStat, List<Map.Entry<HiscoreSkill, Integer>> sorted,  boolean sortByKc) {

        setBorder(new EmptyBorder(3, 3, 3, 3));
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        ArrayList<JPanel> panels = new ArrayList<>();
        for(int i = 0; i < 3; i++) {

            HiscoreSkill hiscoreSkill;
            int kc;

            if (playerStat == null || !playerStat.hasFetchedKcs() || sorted.size() <= i) {
                hiscoreSkill = null;
                kc = 0;
            } else {
                hiscoreSkill = sorted.get(i).getKey();
                kc = sorted.get(i).getValue();
            }

            JPanel panel = new TopThreePanel(spriteManager, hiscoreSkill, kc, sortByKc);
            panels.add(panel);
        }

        panels.forEach(p -> {
            add(p);
            add(Box.createVerticalStrut(6)); // spacing
        });

        setVisible(true);
    }

    private class TopThreePanel extends PluginPanel {

        TopThreePanel(SpriteManager spriteManager, HiscoreSkill hiscoreSkill, Integer val, boolean sortByKc)
        {
            setBackground(ColorScheme.DARKER_GRAY_COLOR);

            // Move border to the panel
            setBorder(new CompoundBorder(
                    BorderFactory.createMatteBorder(1, 1, 1, 1, new Color(58, 58, 58)),
                    BorderFactory.createEmptyBorder(5, 5, 5, 5)));

            // Make panel fill its parent's width
            setAlignmentX(Component.CENTER_ALIGNMENT);

            GroupLayout layout = new GroupLayout(this);
            this.setLayout(layout);

            String bossName = (hiscoreSkill != null) ? translateName(hiscoreSkill) : "None";
            bossName += (hiscoreSkill != null) ? " (" + PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill)
                    + (PvmScore.FULL_POINT_MAPPINGS.get(hiscoreSkill) > 1 ? "pts" : "pt") + ")" : "";
            JLabel boss = new JLabel(bossName);
            boss.setFont(FontManager.getRunescapeBoldFont());
            boss.setForeground(Color.GRAY);

            String kcFormatted = QuantityFormatter.quantityToStackSize(val);
            JLabel valLabel = new JLabel(StringUtils.capitalize(kcFormatted) + (sortByKc ? " kc" : " pts"));

            valLabel.setForeground(Color.YELLOW);

            valLabel.setFont(FontManager.getRunescapeFont());
            valLabel.setToolTipText(NumberFormat.getNumberInstance(Locale.US).format(val));
            valLabel.setHorizontalAlignment(SwingConstants.CENTER);


            JLabel spriteLabel = new JLabel();

            spriteManager.getSpriteAsync(hiscoreSkill == null ? SpriteID.SideIcons.COMBAT : hiscoreSkill.getSpriteId(), 0,
                    (sprite) ->
                            SwingUtilities.invokeLater(() ->
                            {
                                final BufferedImage scaledSprite = ImageUtil.
                                        resizeImage(ImageUtil.resizeCanvas(sprite, 25, 25), 20, 20);
                                spriteLabel.setIcon(new ImageIcon(scaledSprite));
                            }));

            layout.setVerticalGroup(layout.createParallelGroup()
                    .addGroup(layout.createSequentialGroup()
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(valLabel)
                    )
            );

            layout.setHorizontalGroup(layout.createSequentialGroup()
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
                    .addGroup(layout.createParallelGroup(GroupLayout.Alignment.CENTER)
                            .addComponent(spriteLabel)
                            .addComponent(boss)
                            .addComponent(valLabel)
                    )
                    .addContainerGap(GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE) // flexible left gap
            );
        }

    }

}

package com.pvmscore;

import net.runelite.client.hiscore.HiscoreSkill;
import org.junit.Before;
import org.junit.Test;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static net.runelite.client.hiscore.HiscoreSkill.*;
import static org.junit.Assert.*;

public class PvmScoreTest {

    private Map<HiscoreSkill, Integer> killCounts;

    @Before
    public void setUp() {
        killCounts = new HashMap<>();
    }

    @Test
    public void testEmptyKillCounts() {
        int score = PvmScore.getScore(killCounts, 1);
        assertEquals(0, score);
    }

    @Test
    public void testEachBossCategoryPoints() {
        // Grand Master
        killCounts.put(TZKAL_ZUK, 1);
        assertEquals(50, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Hard Mode Raids
        killCounts.put(CHAMBERS_OF_XERIC_CHALLENGE_MODE, 1);
        assertEquals(25, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Raids
        killCounts.put(CHAMBERS_OF_XERIC, 1);
        assertEquals(10, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Master
        killCounts.put(PHOSANIS_NIGHTMARE, 1);
        assertEquals(5, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Elite
        killCounts.put(ZULRAH, 1);
        assertEquals(3, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Hard
        killCounts.put(ARTIO, 1);
        assertEquals(2, PvmScore.getScore(killCounts, 1));
        killCounts.clear();

        // Default
        killCounts.put(KING_BLACK_DRAGON, 1);
        assertEquals(1, PvmScore.getScore(killCounts, 1));
    }

    @Test
    public void testMultipleKillsCalculation() {
        killCounts.put(ZULRAH, 100);
        assertEquals(300, PvmScore.getScore(killCounts, 1));
    }

    @Test
    public void testMixedBossCategories() {
        killCounts.put(TZKAL_ZUK, 2);                    // 100 pts
        killCounts.put(CHAMBERS_OF_XERIC, 10);           // 100 pts
        killCounts.put(ZULRAH, 50);                      // 150 pts
        killCounts.put(KING_BLACK_DRAGON, 20);           // 20 pts

        assertEquals(370, PvmScore.getScore(killCounts, 1));
    }

    @Test
    public void testDivisionByDivisor() {
        killCounts.put(TZKAL_ZUK, 10);

        assertEquals(500, PvmScore.getScore(killCounts, 1));
        assertEquals(50, PvmScore.getScore(killCounts, 10));
        assertEquals(5, PvmScore.getScore(killCounts, 100));
    }

    @Test
    public void testUnknownBossIgnored() {
        killCounts.put(ATTACK, 99);
        assertEquals(0, PvmScore.getScore(killCounts, 1));
    }

    @Test
    public void testNoDuplicateBossesInLists() {
        Map<HiscoreSkill, Integer> bossCounts = new HashMap<>();

        for (List<HiscoreSkill> bossList : PvmScore.ALL) {
            for (HiscoreSkill boss : bossList) {
                bossCounts.put(boss, bossCounts.getOrDefault(boss, 0) + 1);
            }
        }

        for (Map.Entry<HiscoreSkill, Integer> entry : bossCounts.entrySet()) {
            if (entry.getValue() > 1) {
                fail("Boss " + entry.getKey() + " appears in " + entry.getValue() + " categories");
            }
        }
    }
}
package com.pvmscore;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PvMScorePluginTest {
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(PvmScorePlugin.class);
        RuneLite.main(args);
    }
}

