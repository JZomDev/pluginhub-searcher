package com.soulflamerange;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

@Slf4j
class SoulflameRangeOverlay extends Overlay
{
	private final Client client;
	private final SoulflameRangePlugin plugin;
	private final SoulflameRangeConfig config;
	private final PanelComponent panelComponent = new PanelComponent();

	@Inject
	private SoulflameRangeOverlay(Client client, SoulflameRangePlugin plugin, SoulflameRangeConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(Overlay.PRIORITY_HIGH);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		boolean showRange = config.showRange();
		boolean showRangeSquare = config.showRangeSquare();
		boolean isEquipped = plugin.isSoulflameHornsEquipped();
		
		if (!isEquipped)
		{
			// Still draw other players' ranges even if local player doesn't have horn
			if (config.showOtherPlayers() && showRangeSquare)
			{
				drawOtherPlayersRanges(graphics);
			}
			return null;
		}

		int range = plugin.getRange();
		if (range <= 0)
		{
			return null;
		}

		// Draw range square on the game world for local player (controlled by showRangeSquare)
		if (showRangeSquare && client.getLocalPlayer() != null)
		{
			drawRangeSquare(graphics, client.getLocalPlayer().getWorldLocation(), range, config.rangeColor());
		}

		// Draw other players' ranges (controlled by showOtherPlayers and showRangeSquare)
		if (config.showOtherPlayers() && showRangeSquare)
		{
			drawOtherPlayersRanges(graphics);
		}

		// Draw info panel (controlled by showRange)
		if (!showRange)
		{
			return null;
		}

		panelComponent.getChildren().clear();
		panelComponent.setBackgroundColor(new Color(0, 0, 0, 150));

		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Soulflame Horn")
			.color(Color.ORANGE)
			.build());

		panelComponent.getChildren().add(TitleComponent.builder()
			.text("Range: " + range + " tiles")
			.color(Color.WHITE)
			.build());

		return panelComponent.render(graphics);
	}

	private void drawRangeSquare(Graphics2D graphics, WorldPoint playerWorldPoint, int range, Color rangeColor)
	{
		if (playerWorldPoint == null)
		{
			return;
		}

		// Draw a square around the player showing the range
		// The range is the radius, so we need to draw from -range to +range
		// Get the four corners of the square
		WorldPoint[] corners = new WorldPoint[4];
		corners[0] = new WorldPoint(playerWorldPoint.getX() - range, playerWorldPoint.getY() - range, playerWorldPoint.getPlane());
		corners[1] = new WorldPoint(playerWorldPoint.getX() + range, playerWorldPoint.getY() - range, playerWorldPoint.getPlane());
		corners[2] = new WorldPoint(playerWorldPoint.getX() + range, playerWorldPoint.getY() + range, playerWorldPoint.getPlane());
		corners[3] = new WorldPoint(playerWorldPoint.getX() - range, playerWorldPoint.getY() + range, playerWorldPoint.getPlane());

		// Convert world points to screen coordinates and draw lines
		int[] xPoints = new int[4];
		int[] yPoints = new int[4];
		boolean allVisible = true;

		// Get the center point for calculating offsets at ground level
		LocalPoint centerLocal = LocalPoint.fromWorld(client, playerWorldPoint);
		if (centerLocal == null)
		{
			return;
		}
		// Use zOffset of 0 to get ground level coordinates
		net.runelite.api.Point centerScreen = Perspective.localToCanvas(client, centerLocal, playerWorldPoint.getPlane(), 0);
		if (centerScreen == null)
		{
			return;
		}

		for (int i = 0; i < 4; i++)
		{
			LocalPoint localPoint = LocalPoint.fromWorld(client, corners[i]);
			if (localPoint == null)
			{
				allVisible = false;
				break;
			}

			// Convert to screen coordinates at ground level (zOffset of 0 means ground level)
			net.runelite.api.Point screenPoint = Perspective.localToCanvas(client, localPoint, playerWorldPoint.getPlane(), 0);
			if (screenPoint == null)
			{
				allVisible = false;
				break;
			}

			// Use the exact corner coordinates without any offset
			xPoints[i] = screenPoint.getX();
			yPoints[i] = screenPoint.getY();
		}

		if (allVisible)
		{
			// Draw outline only with transparency
			Polygon square = new Polygon(xPoints, yPoints, 4);
			graphics.setColor(new Color(rangeColor.getRed(), rangeColor.getGreen(), rangeColor.getBlue(), 150));
			graphics.setStroke(new java.awt.BasicStroke(2));
			graphics.drawPolygon(square);
		}
	}

	private void drawOtherPlayersRanges(Graphics2D graphics)
	{
		// Check all players in the area
		for (Player player : client.getPlayers())
		{
			if (player == null || player == client.getLocalPlayer())
			{
				continue;
			}

			// Check if player has Soulflame horn equipped by checking their appearance
			if (hasSoulflameHorn(player))
			{
				WorldPoint playerWorldPoint = player.getWorldLocation();
				if (playerWorldPoint == null)
				{
					continue;
				}

				// We can't get other players' varbit values directly
				// Use the configured radius for other players
				int otherPlayerRange = config.otherPlayersRadius();
				
				// Clamp to valid range (0-3)
				if (otherPlayerRange < 0)
				{
					otherPlayerRange = 0;
				}
				else if (otherPlayerRange > 3)
				{
					otherPlayerRange = 3;
				}
				
				// Only draw if range > 0
				if (otherPlayerRange > 0)
				{
					drawRangeSquare(graphics, playerWorldPoint, otherPlayerRange, config.otherPlayersColor());
				}
			}
		}
	}

	private boolean hasSoulflameHorn(Player player)
	{
		if (player == null)
		{
			return false;
		}

		// Check the player's composition for equipment
		net.runelite.api.PlayerComposition composition = player.getPlayerComposition();
		if (composition == null)
		{
			return false;
		}

		// Check the weapon slot for Soulflame horn
		// Equipment slots: 3 = weapon
		int weaponId = composition.getEquipmentId(net.runelite.api.kit.KitType.WEAPON);
		return weaponId == 30759; // SOULFLAME_HORNS item ID
	}
}


package com.soulflamerange;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Soulflame Range"
)
public class SoulflameRangePlugin extends Plugin
{
	// Item IDs for Soulflame horns variants
	private static final int SOULFLAME_HORNS = 30759;

	@Inject
	private Client client;

	@Inject
	private SoulflameRangeConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private SoulflameRangeOverlay overlay;

	private boolean isSoulflameHornsEquipped = false;
	private int currentRange = 0;

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		// log.info("Soulflame Range plugin started!");
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		// log.debug("Soulflame Range plugin stopped!");
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			// Check equipment when player logs in
			checkEquippedHorns();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		ItemContainer container = event.getItemContainer();
		if (container == null)
		{
			return;
		}

		int containerId = container.getId();
		// log.debug("ItemContainerChanged - Container ID: {} (94=Equipment, 93=Inventory)", containerId);
		
		// Check equipment container (94) to see if horn is equipped
		if (containerId == 94)
		{
			// logAllEquipmentSlots(container);
			checkEquippedHorns(container);
		}
		// else
		// {
		// 	log.debug("Ignoring container {} - not equipment", containerId);
		// }
	}

	// private void logAllEquipmentSlots(ItemContainer equipment)
	// {
	// 	if (equipment == null)
	// 	{
	// 		log.debug("Equipment container is null");
	// 		return;
	// 	}
	//
	// 	log.info("=== Equipment Slots ===");
	// 	for (int i = 0; i < equipment.size(); i++)
	// 	{
	// 		Item item = equipment.getItem(i);
	// 		if (item != null)
	// 		{
	// 			log.info("Slot {}: Item ID {} (Quantity: {})", i, item.getId(), item.getQuantity());
	// 		}
	// 		else
	// 		{
	// 			log.debug("Slot {}: Empty", i);
	// 		}
	// 	}
	// 	log.info("=======================");
	// }

	private void checkEquippedHorns()
	{
		ItemContainer equipment = client.getItemContainer(94);
		checkEquippedHorns(equipment);
	}

	private void checkEquippedHorns(ItemContainer equipment)
	{
		if (equipment == null)
		{
			// log.info("Equipment container is null - setting equipped to false");
			isSoulflameHornsEquipped = false;
			currentRange = 0;
			return;
		}

		// Check all equipment slots for the Soulflame horn
		// (It can be in different slots depending on how it's equipped)
		boolean found = false;
		int foundSlot = -1;
		for (int i = 0; i < equipment.size(); i++)
		{
			Item item = equipment.getItem(i);
			if (item != null && item.getId() == SOULFLAME_HORNS)
			{
				found = true;
				foundSlot = i;
				// log.info("Found Soulflame horn in equipment slot {}", i);
				break;
			}
		}

		boolean wasEquipped = isSoulflameHornsEquipped;
		isSoulflameHornsEquipped = found;
		
		// if (!found)
		// {
		// 	log.info("Soulflame horn NOT found in equipment - checked all {} slots", equipment.size());
		// }
		
		if (wasEquipped != isSoulflameHornsEquipped)
		{
			// log.info("Soulflame horns equipped status changed: {} -> {} (slot: {})", wasEquipped, isSoulflameHornsEquipped, foundSlot);
			if (isSoulflameHornsEquipped)
			{
				updateRange();
			}
			else
			{
				currentRange = 0;
				// log.info("Horn unequipped - range reset to 0");
			}
		}
		else if (isSoulflameHornsEquipped && found)
		{
			// Update range even if already equipped (in case config changed)
			updateRange();
		}
		else if (!found && isSoulflameHornsEquipped)
		{
			// Horn was equipped but now not found - reset
			// log.info("Horn no longer found in equipment - resetting");
			isSoulflameHornsEquipped = false;
			currentRange = 0;
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		// First verify the horn is actually equipped before updating range
		// Re-check equipment to ensure state is correct
		ItemContainer equipment = client.getItemContainer(94);
		boolean actuallyEquipped = false;
		
		if (equipment != null)
		{
			for (int i = 0; i < equipment.size(); i++)
			{
				Item item = equipment.getItem(i);
				if (item != null && item.getId() == SOULFLAME_HORNS)
				{
					actuallyEquipped = true;
					break;
				}
			}
		}
		
		// Only update if horn is actually equipped
		if (actuallyEquipped)
		{
			// Update equipped state if it was wrong
			if (!isSoulflameHornsEquipped)
			{
				isSoulflameHornsEquipped = true;
				// log.info("Horn detected as equipped via varbit change");
			}
			
			int varbitId = event.getVarbitId();
			
			// Skip invalid varbit IDs
			if (varbitId < 0)
			{
				return;
			}
			
			// Check if this is the known radius varbit (16264)
			// Auto-detect by checking if the varbit value is 0-3
			try
			{
				int value = client.getVarbitValue(varbitId);
				if (varbitId == 16264 || (value >= 0 && value <= 3))
				{
					// log.info("Radius varbit {} changed to {}, updating range", varbitId, value);
					updateRange();
				}
			}
			catch (Exception e)
			{
				// Varbit doesn't exist or can't be read, ignore it
				// log.debug("Could not read varbit {}: {}", varbitId, e.getMessage());
			}
		}
		else
		{
			// Horn not equipped - reset if it was marked as equipped
			if (isSoulflameHornsEquipped)
			{
				// log.info("Horn not found in equipment during varbit change - resetting");
				isSoulflameHornsEquipped = false;
				currentRange = 0;
			}
		}
	}

	private void updateRange()
	{
		// First verify the horn is actually equipped before reading the varbit
		ItemContainer equipment = client.getItemContainer(94);
		boolean actuallyEquipped = false;
		
		if (equipment != null)
		{
			for (int i = 0; i < equipment.size(); i++)
			{
				Item item = equipment.getItem(i);
				if (item != null && item.getId() == SOULFLAME_HORNS)
				{
					actuallyEquipped = true;
					break;
				}
			}
		}
		
		if (!actuallyEquipped)
		{
			// log.debug("Horn not equipped - not updating range");
			currentRange = 0;
			return;
		}
		
		// The Soulflame horn stores its radius (0-3) in varbit 16264
		int[] possibleVarbits = {
			16264, // Soulflame horn radius varbit
		};
		
		boolean found = false;
		for (int varbitId : possibleVarbits)
		{
			try
			{
				int radiusValue = client.getVarbitValue(varbitId);
				// Radius should be 0-3
				if (radiusValue >= 0 && radiusValue <= 3)
				{
					currentRange = radiusValue;
					// log.info("Found horn radius from varbit {}: {}", varbitId, currentRange);
					found = true;
					break;
				}
			}
			catch (Exception e)
			{
				// Continue to next varbit
			}
		}
		
		if (!found)
		{
			// Default to 0 if we can't detect it
			currentRange = 0;
			// log.warn("Could not detect horn radius. Current range set to: {}", currentRange);
		}
	}

	public boolean isSoulflameHornsEquipped()
	{
		return isSoulflameHornsEquipped;
	}

	public int getRange()
	{
		// Always verify the horn is actually equipped before returning range
		if (!isSoulflameHornsEquipped)
		{
			return 0;
		}
		
		// Double-check equipment to ensure state is correct
		ItemContainer equipment = client.getItemContainer(94);
		if (equipment != null)
		{
			boolean found = false;
			for (int i = 0; i < equipment.size(); i++)
			{
				Item item = equipment.getItem(i);
				if (item != null && item.getId() == SOULFLAME_HORNS)
				{
					found = true;
					break;
				}
			}
			
			if (!found)
			{
				// Horn not actually equipped - reset state
				// log.debug("Horn not found in equipment in getRange() - resetting");
				isSoulflameHornsEquipped = false;
				currentRange = 0;
				return 0;
			}
		}
		
		// Return the detected radius (0-3)
		return currentRange;
	}


	@Provides
	SoulflameRangeConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SoulflameRangeConfig.class);
	}
}

package com.soulflamerange;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("soulflamerange")
public interface SoulflameRangeConfig extends Config
{
	@ConfigItem(
		keyName = "showRange",
		name = "Show Range",
		description = "Display the range text panel showing the range in tiles"
	)
	default boolean showRange()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showRangeSquare",
		name = "Show Range Square",
		description = "Display the border/square outline on the game world showing the range"
	)
	default boolean showRangeSquare()
	{
		return true;
	}

	@ConfigItem(
		keyName = "rangeColor",
		name = "Range Color",
		description = "Color of the range square"
	)
	default Color rangeColor()
	{
		return Color.ORANGE;
	}

	@ConfigItem(
		keyName = "showOtherPlayers",
		name = "Show Other Players' Range",
		description = "Display range squares for other players who have the Soulflame horn equipped"
	)
	default boolean showOtherPlayers()
	{
		return true;
	}

	@ConfigItem(
		keyName = "otherPlayersColor",
		name = "Other Players' Range Color",
		description = "Color of the range square for other players"
	)
	default Color otherPlayersColor()
	{
		return Color.CYAN;
	}

	@ConfigItem(
		keyName = "otherPlayersRadius",
		name = "Other Players' Radius",
		description = "Radius (0-3) to display for other players' Soulflame horns"
	)
	default int otherPlayersRadius()
	{
		return 3;
	}
}


package com.soulflamerange;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;
import net.runelite.client.plugins.Plugin;

public class SoulflameRangePluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin((Class<? extends Plugin>) SoulflameRangePlugin.class);
		RuneLite.main(args);
	}
}
