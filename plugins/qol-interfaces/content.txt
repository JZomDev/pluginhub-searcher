package com.transparentui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.input.MouseListener;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class GrandExchangeOverlay extends Overlay implements MouseListener
{
    private static final int GE_INTERFACE_ID = InterfaceID.GRAND_EXCHANGE;
    private static final int GE_HISTORY_CHILD_ID = 3; // 465.3 - History button

    private static final int MAINMODAL_GROUP = 161;
    private static final int MAINMODAL_CHILD = 16;

    private static final int DRAG_BUTTON_WIDTH = 40;
    private static final int DRAG_BUTTON_HEIGHT = 20;
    private static final int DRAG_BUTTON_OFFSET_X = 5; // Gap after History button

    private final Client client;
    private final TransparentInterfacesConfig config;

    // Store the cumulative offset from default
    private int offsetX = 0;
    private int offsetY = 0;

    // Store the base position (captured once when GE opens)
    private int baseRelX = -1;
    private int baseRelY = -1;

    // Drag state
    private boolean isDragging = false;
    private Point dragStartMouse = null;
    private int dragStartOffsetX = 0;
    private int dragStartOffsetY = 0;

    // Cached drag button bounds
    private Rectangle dragButtonBounds = null;

    @Inject
    public GrandExchangeOverlay(Client client, TransparentInterfacesConfig config)
    {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    /**
     * Called from plugin on every game tick to maintain position
     */
    public void onGameTick()
    {
        if (!config.moveableGE())
        {
            return;
        }

        applyOffset();
    }

    /**
     * Called right before each frame renders - this is the key to preventing flicker
     */
    public void onBeforeRender()
    {
        if (!config.moveableGE())
        {
            return;
        }

        applyOffset();
    }

    private void applyOffset()
    {
        if (offsetX == 0 && offsetY == 0)
        {
            return;
        }

        Widget geWindow = client.getWidget(GE_INTERFACE_ID, 0);
        if (geWindow == null || geWindow.isHidden())
        {
            return;
        }

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal == null)
        {
            return;
        }

        // Capture base position once
        if (baseRelX == -1)
        {
            baseRelX = mainModal.getRelativeX();
            baseRelY = mainModal.getRelativeY();
        }

        // Apply offset directly using setRelativeX/Y
        mainModal.setRelativeX(baseRelX + offsetX);
        mainModal.setRelativeY(baseRelY + offsetY);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.moveableGE())
        {
            if (offsetX != 0 || offsetY != 0)
            {
                resetPosition();
            }
            dragButtonBounds = null;
            return null;
        }

        Widget geWindow = client.getWidget(GE_INTERFACE_ID, 0);
        if (geWindow == null || geWindow.isHidden())
        {
            dragButtonBounds = null;
            // Reset base position when GE closes
            baseRelX = -1;
            baseRelY = -1;
            return null;
        }

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal == null)
        {
            dragButtonBounds = null;
            return null;
        }

        // Capture base position once when GE first opens
        if (baseRelX == -1)
        {
            baseRelX = mainModal.getRelativeX();
            baseRelY = mainModal.getRelativeY();
        }

        // Apply offset every frame
        if (offsetX != 0 || offsetY != 0)
        {
            mainModal.setRelativeX(baseRelX + offsetX);
            mainModal.setRelativeY(baseRelY + offsetY);
        }

        // Find History button to position our drag button next to it
        Widget historyButton = client.getWidget(GE_INTERFACE_ID, GE_HISTORY_CHILD_ID);
        if (historyButton == null || historyButton.isHidden())
        {
            dragButtonBounds = null;
            return null;
        }

        Rectangle historyBounds = historyButton.getBounds();
        if (historyBounds == null)
        {
            dragButtonBounds = null;
            return null;
        }

        // Position drag button to the right of History button
        int buttonX = historyBounds.x + historyBounds.width + DRAG_BUTTON_OFFSET_X;
        int buttonY = historyBounds.y + (historyBounds.height - DRAG_BUTTON_HEIGHT) / 2;

        dragButtonBounds = new Rectangle(buttonX, buttonY, DRAG_BUTTON_WIDTH, DRAG_BUTTON_HEIGHT);

        // Draw the drag button
        Color bgColor = isDragging ? new Color(80, 60, 40) : new Color(60, 50, 40);
        graphics.setColor(bgColor);
        graphics.fillRect(buttonX, buttonY, DRAG_BUTTON_WIDTH, DRAG_BUTTON_HEIGHT);

        // Border
        graphics.setColor(new Color(100, 80, 60));
        graphics.drawRect(buttonX, buttonY, DRAG_BUTTON_WIDTH - 1, DRAG_BUTTON_HEIGHT - 1);

        // Text
        graphics.setColor(new Color(255, 152, 31)); // OSRS orange
        FontMetrics fm = graphics.getFontMetrics();
        String text = "Drag";
        int textX = buttonX + (DRAG_BUTTON_WIDTH - fm.stringWidth(text)) / 2;
        int textY = buttonY + (DRAG_BUTTON_HEIGHT + fm.getAscent() - fm.getDescent()) / 2;
        graphics.drawString(text, textX, textY);

        return null;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent e)
    {
        if (!config.moveableGE() || dragButtonBounds == null)
        {
            return e;
        }

        if (dragButtonBounds.contains(e.getPoint()))
        {
            isDragging = true;
            dragStartMouse = e.getPoint();
            dragStartOffsetX = offsetX;
            dragStartOffsetY = offsetY;
            e.consume();
        }

        return e;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent e)
    {
        if (isDragging)
        {
            isDragging = false;
            dragStartMouse = null;
            e.consume();
        }
        return e;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent e)
    {
        if (!isDragging || dragStartMouse == null)
        {
            return e;
        }

        Point currentMouse = e.getPoint();
        int deltaX = currentMouse.x - dragStartMouse.x;
        int deltaY = currentMouse.y - dragStartMouse.y;

        offsetX = dragStartOffsetX + deltaX;
        offsetY = dragStartOffsetY + deltaY;

        // Apply immediately during drag
        applyOffset();

        e.consume();
        return e;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent e)
    {
        return e;
    }

    public void resetPosition()
    {
        offsetX = 0;
        offsetY = 0;
        baseRelX = -1;
        baseRelY = -1;
        isDragging = false;
        dragStartMouse = null;
        dragButtonBounds = null;

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal != null)
        {
            mainModal.revalidate();
        }

        Widget geWindow = client.getWidget(GE_INTERFACE_ID, 0);
        if (geWindow != null)
        {
            geWindow.revalidate();
        }
    }
}

package com.transparentui;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.BeforeRender;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
    name = "QOL Interfaces",
    description = "Quality of life improvements for game interfaces - transparency, repositioning, and more",
    tags = {"interface", "transparency", "ui", "grand exchange", "bank", "qol", "moveable"}
)
public class TransparentInterfacesPlugin extends Plugin
{
    // Grand Exchange: 465.2[0]
    private static final int GE_INTERFACE_ID = InterfaceID.GRAND_EXCHANGE;
    private static final int GE_BACKGROUND_CHILD_ID = 2;

    // Bank: 12.2[0]
    private static final int BANK_INTERFACE_ID = InterfaceID.BANK;
    private static final int BANK_BACKGROUND_CHILD_ID = 2;

    @Inject
    private Client client;

    @Inject
    private TransparentInterfacesConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private MouseManager mouseManager;

    @Inject
    private GrandExchangeOverlay geOverlay;

    @Inject
    private BankOverlay bankOverlay;

    @Inject
    private TradeOverlay tradeOverlay;

    @Override
    protected void startUp() throws Exception
    {
        log.debug("Transparent Interfaces started!");
        overlayManager.add(geOverlay);
        overlayManager.add(bankOverlay);
        overlayManager.add(tradeOverlay);
        mouseManager.registerMouseListener(geOverlay);
        mouseManager.registerMouseListener(bankOverlay);
        applyGETransparency();
        applyBankTransparency();
    }

    @Override
    protected void shutDown() throws Exception
    {
        log.debug("Transparent Interfaces stopped!");
        mouseManager.unregisterMouseListener(geOverlay);
        mouseManager.unregisterMouseListener(bankOverlay);
        overlayManager.remove(geOverlay);
        overlayManager.remove(bankOverlay);
        overlayManager.remove(tradeOverlay);
        geOverlay.resetPosition();
        bankOverlay.resetPosition();
        resetGETransparency();
        resetBankTransparency();
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        geOverlay.onGameTick();
        bankOverlay.onGameTick();
    }

    @Subscribe
    public void onBeforeRender(BeforeRender event)
    {
        // Apply position right before each frame renders to prevent flicker
        geOverlay.onBeforeRender();
        bankOverlay.onBeforeRender();
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (event.getGroupId() == GE_INTERFACE_ID)
        {
            applyGETransparency();
        }
        else if (event.getGroupId() == BANK_INTERFACE_ID)
        {
            applyBankTransparency();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (event.getGroup().equals("transparentinterfaces"))
        {
            applyGETransparency();
            applyBankTransparency();
        }
    }

    private void applyGETransparency()
    {
        Widget geFrame = client.getWidget(GE_INTERFACE_ID, GE_BACKGROUND_CHILD_ID);

        if (geFrame == null)
        {
            return;
        }

        // Get the first sub-child (465.2[0]) which is the actual background
        Widget[] children = geFrame.getDynamicChildren();
        if (children == null || children.length == 0)
        {
            return;
        }

        Widget geBackground = children[0];
        if (geBackground != null)
        {
            // 200 = transparent, 0 = opaque
            int opacity = config.hideGEBackground() ? 200 : 0;
            geBackground.setOpacity(opacity);
            log.debug("Applied GE background opacity: {}", opacity);
        }
    }

    private void resetGETransparency()
    {
        Widget geFrame = client.getWidget(GE_INTERFACE_ID, GE_BACKGROUND_CHILD_ID);

        if (geFrame == null)
        {
            return;
        }

        Widget[] children = geFrame.getDynamicChildren();
        if (children == null || children.length == 0)
        {
            return;
        }

        Widget geBackground = children[0];
        if (geBackground != null)
        {
            geBackground.setOpacity(0);
            log.debug("Reset GE background opacity to default");
        }
    }

    private void applyBankTransparency()
    {
        Widget bankFrame = client.getWidget(BANK_INTERFACE_ID, BANK_BACKGROUND_CHILD_ID);

        if (bankFrame == null)
        {
            return;
        }

        Widget[] children = bankFrame.getDynamicChildren();
        if (children == null || children.length == 0)
        {
            return;
        }

        Widget bankBackground = children[0];
        if (bankBackground != null)
        {
            int opacity = config.hideBankBackground() ? 200 : 0;
            bankBackground.setOpacity(opacity);
            log.debug("Applied Bank background opacity: {}", opacity);
        }
    }

    private void resetBankTransparency()
    {
        Widget bankFrame = client.getWidget(BANK_INTERFACE_ID, BANK_BACKGROUND_CHILD_ID);

        if (bankFrame == null)
        {
            return;
        }

        Widget[] children = bankFrame.getDynamicChildren();
        if (children == null || children.length == 0)
        {
            return;
        }

        Widget bankBackground = children[0];
        if (bankBackground != null)
        {
            bankBackground.setOpacity(0);
            log.debug("Reset Bank background opacity to default");
        }
    }

    @Provides
    TransparentInterfacesConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(TransparentInterfacesConfig.class);
    }
}

package com.transparentui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.NameableContainer;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.Text;

public class TradeOverlay extends Overlay
{
    // Trade main screen (first screen)
    private static final int TRADE_MAIN_GROUP = 335;
    private static final int TRADE_MAIN_TITLE_CHILD = 31; // "Trading with: PlayerName"
    private static final int TRADE_MAIN_WINDOW_CHILD = 0; // Main trade window container

    private final Client client;
    private final TransparentInterfacesConfig config;

    // Track what we've already modified to avoid re-processing
    private String lastModifiedPlayer = null;

    @Inject
    public TradeOverlay(Client client, TransparentInterfacesConfig config)
    {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.tradeFriendWarning())
        {
            lastModifiedPlayer = null;
            return null;
        }

        // Only show on first trade screen (not confirmation screen)
        Widget tradeMainTitle = client.getWidget(TRADE_MAIN_GROUP, TRADE_MAIN_TITLE_CHILD);
        if (tradeMainTitle == null || tradeMainTitle.isHidden())
        {
            lastModifiedPlayer = null;
            return null;
        }

        String titleText = tradeMainTitle.getText();
        if (titleText == null)
        {
            lastModifiedPlayer = null;
            return null;
        }

        // Extract just the player name (remove any tags and existing suffixes we may have added)
        String cleanTitle = Text.removeTags(titleText);

        // Check for "Trading with:" or "Trading With:" (case insensitive)
        String lowerTitle = cleanTitle.toLowerCase();
        if (!lowerTitle.startsWith("trading with:"))
        {
            lastModifiedPlayer = null;
            return null;
        }

        // Extract player name after "Trading with:" (13 characters)
        String playerName = cleanTitle.substring(13).trim();

        // Remove any existing suffix we added (in case of re-render)
        if (playerName.contains(" - ("))
        {
            playerName = playerName.substring(0, playerName.indexOf(" - (")).trim();
        }

        if (playerName.isEmpty())
        {
            return null;
        }

        // Check friend and clan status
        boolean isFriend = isOnFriendsList(playerName);
        boolean isClanMember = isInClan(playerName);

        // Build the new title with clan status suffix (colored)
        String clanSuffix = isClanMember
            ? " - <col=00ff00>(Same Clan)</col>"
            : " - <col=ff0000>(Not in Clan)</col>";
        String newTitleStr = "Trading with: " + playerName + clanSuffix;

        // Update the widget text if needed
        if (!newTitleStr.equals(lastModifiedPlayer))
        {
            tradeMainTitle.setText(newTitleStr);
            lastModifiedPlayer = newTitleStr;
        }

        // Draw the friend status message at bottom of trade window (independent of clan status)
        Widget tradeWindow = client.getWidget(TRADE_MAIN_GROUP, TRADE_MAIN_WINDOW_CHILD);
        if (tradeWindow != null)
        {
            renderFriendStatus(graphics, tradeWindow, playerName, isFriend);
        }

        return null;
    }

    private void renderFriendStatus(Graphics2D graphics, Widget anchorWidget, String playerName, boolean isFriend)
    {
        Rectangle widgetBounds = anchorWidget.getBounds();
        if (widgetBounds == null)
        {
            return;
        }

        String message;
        Color textColor;

        if (isFriend)
        {
            message = playerName + " is on your friends list";
            textColor = new Color(0, 255, 0); // Green
        }
        else
        {
            message = playerName + " is NOT on your friends list";
            textColor = new Color(255, 0, 0); // Red
        }

        // Draw the message inside the trade window near the bottom
        FontMetrics fm = graphics.getFontMetrics();
        int textWidth = fm.stringWidth(message);
        int textX = widgetBounds.x + (widgetBounds.width - textWidth) / 2;
        int textY = widgetBounds.y + widgetBounds.height - 35;

        // Draw shadow for better visibility
        graphics.setColor(Color.BLACK);
        graphics.drawString(message, textX + 1, textY + 1);

        // Draw main text
        graphics.setColor(textColor);
        graphics.drawString(message, textX, textY);
    }

    private boolean isOnFriendsList(String playerName)
    {
        NameableContainer<Friend> friendContainer = client.getFriendContainer();
        if (friendContainer == null)
        {
            return false;
        }

        String normalizedName = Text.standardize(playerName);

        for (Friend friend : friendContainer.getMembers())
        {
            if (friend != null)
            {
                String friendName = Text.standardize(friend.getName());
                if (friendName.equals(normalizedName))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean isInClan(String playerName)
    {
        ClanChannel clanChannel = client.getClanChannel();
        if (clanChannel == null)
        {
            return false;
        }

        String normalizedName = Text.standardize(playerName);

        for (ClanChannelMember member : clanChannel.getMembers())
        {
            if (member != null)
            {
                String memberName = Text.standardize(member.getName());
                if (memberName.equals(normalizedName))
                {
                    return true;
                }
            }
        }

        return false;
    }
}

package com.transparentui;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("transparentinterfaces")
public interface TransparentInterfacesConfig extends Config
{
    @ConfigItem(
        keyName = "hideGEBackground",
        name = "Hide GE Background",
        description = "Toggle the Grand Exchange background transparent",
        position = 1
    )
    default boolean hideGEBackground()
    {
        return false;
    }

    @ConfigItem(
        keyName = "hideBankBackground",
        name = "Hide Bank Background",
        description = "Toggle the Bank background transparent",
        position = 2
    )
    default boolean hideBankBackground()
    {
        return false;
    }

    @ConfigItem(
        keyName = "moveableGE",
        name = "Moveable GE",
        description = "Allow dragging the Grand Exchange interface to reposition it",
        position = 3
    )
    default boolean moveableGE()
    {
        return false;
    }

    @ConfigItem(
        keyName = "moveableBank",
        name = "Moveable Bank",
        description = "Allow dragging the Bank interface to reposition it",
        position = 4
    )
    default boolean moveableBank()
    {
        return false;
    }

    @ConfigItem(
        keyName = "tradeFriendWarning",
        name = "Trade Friend Warning",
        description = "Show if trade partner is on your friends list",
        position = 5
    )
    default boolean tradeFriendWarning()
    {
        return true;
    }
}

package com.transparentui;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.input.MouseListener;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class BankOverlay extends Overlay implements MouseListener
{
    private static final int BANK_INTERFACE_ID = InterfaceID.BANK;

    private static final int MAINMODAL_GROUP = 161;
    private static final int MAINMODAL_CHILD = 16;

    private static final int DRAG_BUTTON_WIDTH = 40;
    private static final int DRAG_BUTTON_HEIGHT = 20;

    private final Client client;
    private final TransparentInterfacesConfig config;

    // Store the cumulative offset from default
    private int offsetX = 0;
    private int offsetY = 0;

    // Store the base position (captured once when Bank opens)
    private int baseRelX = -1;
    private int baseRelY = -1;

    // Drag state
    private boolean isDragging = false;
    private Point dragStartMouse = null;
    private int dragStartOffsetX = 0;
    private int dragStartOffsetY = 0;

    // Cached drag button bounds
    private Rectangle dragButtonBounds = null;

    @Inject
    public BankOverlay(Client client, TransparentInterfacesConfig config)
    {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
        setPriority(OverlayPriority.HIGH);
    }

    /**
     * Called from plugin on every game tick to maintain position
     */
    public void onGameTick()
    {
        if (!config.moveableBank())
        {
            return;
        }

        applyOffset();
    }

    /**
     * Called right before each frame renders - this is the key to preventing flicker
     */
    public void onBeforeRender()
    {
        if (!config.moveableBank())
        {
            return;
        }

        applyOffset();
    }

    private void applyOffset()
    {
        if (offsetX == 0 && offsetY == 0)
        {
            return;
        }

        Widget bankWindow = client.getWidget(BANK_INTERFACE_ID, 0);
        if (bankWindow == null || bankWindow.isHidden())
        {
            return;
        }

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal == null)
        {
            return;
        }

        // Capture base position once
        if (baseRelX == -1)
        {
            baseRelX = mainModal.getRelativeX();
            baseRelY = mainModal.getRelativeY();
        }

        // Apply offset directly using setRelativeX/Y
        mainModal.setRelativeX(baseRelX + offsetX);
        mainModal.setRelativeY(baseRelY + offsetY);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (!config.moveableBank())
        {
            if (offsetX != 0 || offsetY != 0)
            {
                resetPosition();
            }
            dragButtonBounds = null;
            return null;
        }

        Widget bankWindow = client.getWidget(BANK_INTERFACE_ID, 0);
        if (bankWindow == null || bankWindow.isHidden())
        {
            dragButtonBounds = null;
            // Reset base position when Bank closes
            baseRelX = -1;
            baseRelY = -1;
            return null;
        }

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal == null)
        {
            dragButtonBounds = null;
            return null;
        }

        // Capture base position once when Bank first opens
        if (baseRelX == -1)
        {
            baseRelX = mainModal.getRelativeX();
            baseRelY = mainModal.getRelativeY();
        }

        // Apply offset every frame
        if (offsetX != 0 || offsetY != 0)
        {
            mainModal.setRelativeX(baseRelX + offsetX);
            mainModal.setRelativeY(baseRelY + offsetY);
        }

        // Get bank window bounds to position drag button
        Rectangle bankBounds = bankWindow.getBounds();
        if (bankBounds == null)
        {
            dragButtonBounds = null;
            return null;
        }

        // Position drag button between GP counter and title text (in the title bar area)
        int buttonX = bankBounds.x + 115;
        int buttonY = bankBounds.y + 8;

        dragButtonBounds = new Rectangle(buttonX, buttonY, DRAG_BUTTON_WIDTH, DRAG_BUTTON_HEIGHT);

        // Draw the drag button
        Color bgColor = isDragging ? new Color(80, 60, 40) : new Color(60, 50, 40);
        graphics.setColor(bgColor);
        graphics.fillRect(buttonX, buttonY, DRAG_BUTTON_WIDTH, DRAG_BUTTON_HEIGHT);

        // Border
        graphics.setColor(new Color(100, 80, 60));
        graphics.drawRect(buttonX, buttonY, DRAG_BUTTON_WIDTH - 1, DRAG_BUTTON_HEIGHT - 1);

        // Text
        graphics.setColor(new Color(255, 152, 31)); // OSRS orange
        FontMetrics fm = graphics.getFontMetrics();
        String text = "Drag";
        int textX = buttonX + (DRAG_BUTTON_WIDTH - fm.stringWidth(text)) / 2;
        int textY = buttonY + (DRAG_BUTTON_HEIGHT + fm.getAscent() - fm.getDescent()) / 2;
        graphics.drawString(text, textX, textY);

        return null;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent e)
    {
        if (!config.moveableBank() || dragButtonBounds == null)
        {
            return e;
        }

        if (dragButtonBounds.contains(e.getPoint()))
        {
            isDragging = true;
            dragStartMouse = e.getPoint();
            dragStartOffsetX = offsetX;
            dragStartOffsetY = offsetY;
            e.consume();
        }

        return e;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent e)
    {
        if (isDragging)
        {
            isDragging = false;
            dragStartMouse = null;
            e.consume();
        }
        return e;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent e)
    {
        if (!isDragging || dragStartMouse == null)
        {
            return e;
        }

        Point currentMouse = e.getPoint();
        int deltaX = currentMouse.x - dragStartMouse.x;
        int deltaY = currentMouse.y - dragStartMouse.y;

        offsetX = dragStartOffsetX + deltaX;
        offsetY = dragStartOffsetY + deltaY;

        // Apply immediately during drag
        applyOffset();

        e.consume();
        return e;
    }

    @Override
    public MouseEvent mouseClicked(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent e)
    {
        return e;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent e)
    {
        return e;
    }

    public void resetPosition()
    {
        offsetX = 0;
        offsetY = 0;
        baseRelX = -1;
        baseRelY = -1;
        isDragging = false;
        dragStartMouse = null;
        dragButtonBounds = null;

        Widget mainModal = client.getWidget(MAINMODAL_GROUP, MAINMODAL_CHILD);
        if (mainModal != null)
        {
            mainModal.revalidate();
        }

        Widget bankWindow = client.getWidget(BANK_INTERFACE_ID, 0);
        if (bankWindow != null)
        {
            bankWindow.revalidate();
        }
    }
}

package com.transparentui;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class TransparentInterfacesPluginTest
{
    public static void main(String[] args) throws Exception
    {
        ExternalPluginManager.loadBuiltin(TransparentInterfacesPlugin.class);
        RuneLite.main(args);
    }
}

