/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
@ConfigGroup("globalchat")
public interface GlobalChatConfig extends Config {

    @ConfigItem(
            keyName = "readOnlyMode",
            name = "Read-Only Mode",
            description = "Activating this allows you to view global chat messages, but your typed messages will not be broadcast globally, similar to if the plugin was off.",
            position = 1
    )
    default boolean readOnlyMode() {
        return false;
    }

    @ConfigItem(
            keyName = "showPlayerLookup",
            name = "Show Player Lookup",
            description = "Show 'GC Status' option when right-clicking players to check if they're connected to Global Chat.",
            position = 2
    )
    default boolean showPlayerLookup() {
        return true;
    }
    @ConfigItem(
        keyName = "filterOutFromBelowCblvl",
        name = "Hide Msgs < CB Level",
        description = "This hides all messages from users below the specified combat level. It's usedful for blocking the low level spam bots",
        position = 3
)
@Range(
    min = 3,
    max = 126
)
default int filterOutFromBelowCblvl() {
    return 4;
}

@ConfigItem(
    keyName = "updateNotificationShown",
    name = "",
    description = "",
    hidden = true
)
default String updateNotificationShown() {
    return "";
}

}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.Font;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URI;
import java.util.List;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.Map;
import javax.swing.Box;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JToggleButton;
import javax.swing.SwingConstants;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.api.Client;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GlobalChatInfoPanel extends PluginPanel {

    private static final String PATREON_URL = "https://patreon.com/global_chat_plugin";
    private static final String GITHUB_URL = "https://github.com/RusseII/region-chat";
    private static final String DISCORD_URL = "https://discord.gg/runelite";

    private final ConfigManager configManager;
    private final boolean developerMode;
    private final AblyManager ablyManager;
    private final SupporterManager supporterManager;
    private final Client client;
    private final OkHttpClient httpClient;
    private final Gson gson;
    private JLabel totalUsersLabel;
    private JLabel currentWorldUsersLabel;
    private JLabel topWorldLabel;
    private JLabel readOnlyStatusLabel;
    private JLabel connectionStatusLabel;
    private JLabel connectionLimitsLabel;
    private Timer userCountUpdateTimer;
    private Timer connectionStatusTimer;
    private ConnectionStatsResponse connectionStats = null;
    private boolean hasReceivedValidData = false;

    public GlobalChatInfoPanel() {
        super(true); // Use built-in RuneLite scrolling
        this.configManager = null;
        this.developerMode = false;
        this.ablyManager = null;
        this.supporterManager = null;
        this.client = null;
        this.httpClient = null; // Don't create fresh instance
        this.gson = null; // Don't create fresh instance
        init();
    }

    public GlobalChatInfoPanel(boolean developerMode, AblyManager ablyManager, SupporterManager supporterManager, Client client, OkHttpClient httpClient, Gson gson, ConfigManager configManager) {
        super(true); // Use built-in RuneLite scrolling
        this.configManager = configManager;
        this.developerMode = developerMode;
        this.ablyManager = ablyManager;
        this.supporterManager = supporterManager;
        this.client = client;
        this.httpClient = httpClient;
        this.gson = gson;
        init();
    }

    private void init() {
        setBorder(new EmptyBorder(10, 10, 10, 10));
        
        // Use standard PluginPanel approach - add content directly
        JPanel contentPanel = createContent();
        add(contentPanel, BorderLayout.CENTER);
    }

    private JPanel createContent() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setOpaque(true); // Ensure background is painted

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.NORTH;
        gbc.insets = new Insets(0, 0, 0, 0); // Reset insets for first item

        // Title
        panel.add(createTitle(), gbc);

        // User count section
        gbc.gridy++;
        gbc.insets = new Insets(10, 0, 0, 0);
        panel.add(createUserCountSection(), gbc);

        // Readonly mode toggle section
        gbc.gridy++;
        gbc.insets = new Insets(10, 0, 0, 0);
        panel.add(createReadOnlyToggleSection(), gbc);

        gbc.gridy++;
        panel.add(createSupportSection(), gbc);

        // Add supporters section if we have the manager
        if (supporterManager != null) {
            gbc.gridy++;
            panel.add(createSupportersSection(), gbc);
        }

        gbc.gridy++;
        panel.add(createLinks(), gbc);

        // Debug section if enabled
        if (developerMode && ablyManager != null) {
            gbc.gridy++;
            panel.add(createDebugSection(), gbc);
        }

        // Push everything to top
        gbc.gridy++;
        gbc.weighty = 1.0;
        panel.add(Box.createVerticalGlue(), gbc);

        return panel;
    }

    private JPanel createTitle() {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        titlePanel.setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(0, 0, 2, 0, ColorScheme.BRAND_ORANGE),
                new EmptyBorder(5, 0, 5, 0)));

        JLabel title = new JLabel("Global Chat", SwingConstants.CENTER);
        title.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 16f));
        title.setForeground(ColorScheme.BRAND_ORANGE);
        titlePanel.add(title, BorderLayout.CENTER);

        return titlePanel;
    }


    private JPanel createSupportSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Keep Global Chat Running!");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // Warning text
        JLabel warningText = new JLabel(
                "<html><b style='color: #ff6b6b;'>WARNING: Service will go offline when limits are reached!</b></html>");
        warningText.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        gbc.insets = new Insets(0, 0, 10, 0);
        panel.add(warningText, gbc);
        gbc.gridy++;

        // Current status
        JLabel currentStatus = new JLabel("<html>" +
                "<b>Service Limits:</b><br>" +
                "- <b>Connection limit:</b> 200 concurrent users" +
                "</html>");
        currentStatus.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        currentStatus.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 15, 0);
        panel.add(currentStatus, gbc);
        gbc.gridy++;

        // Benefits text
        JLabel benefitsText = new JLabel("<html>" +
                "<b style='color: #4CAF50;'>Your support will:</b><br>" +
                "- Increase connection limits (more players can chat)<br>" +
                "- Keep the service running 24/7<br>" +
                "- Enable new features and improvements" +
                "</html>");
        benefitsText.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        benefitsText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 15, 0);
        panel.add(benefitsText, gbc);
        gbc.gridy++;

        // Patreon button
        JButton patreonBtn = new JButton("Support on Patreon");
        patreonBtn.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        patreonBtn.setForeground(Color.WHITE);
        patreonBtn.setBackground(ColorScheme.BRAND_ORANGE);
        patreonBtn.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE.darker(), 1),
                new EmptyBorder(12, 20, 12, 20)));
        patreonBtn.setFocusPainted(false);
        patreonBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        patreonBtn.addActionListener(e -> openURL(PATREON_URL));
        
        // Add hover effect
        patreonBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                patreonBtn.setBackground(ColorScheme.BRAND_ORANGE.brighter());
            }
            @Override
            public void mouseExited(MouseEvent e) {
                patreonBtn.setBackground(ColorScheme.BRAND_ORANGE);
            }
        });
        
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(patreonBtn, gbc);

        return panel;
    }

    private JPanel createSupportersSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Amazing Supporters");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        List<Supporter> supporters = supporterManager.getSupporters();

        if (supporters.isEmpty()) {
            JLabel noSupportersLabel = new JLabel("<html><i>No supporters yet - be the first!</i></html>");
            noSupportersLabel.setFont(FontManager.getRunescapeFont().deriveFont(12f));
            noSupportersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            gbc.insets = new Insets(0, 0, 0, 0);
            panel.add(noSupportersLabel, gbc);
        } else {
            // Display supporters by tier
            for (int i = 0; i < supporters.size(); i++) {
                Supporter supporter = supporters.get(i);
                JPanel supporterPanel = createSupporterPanel(supporter);
                gbc.insets = new Insets(0, 0, i == supporters.size() - 1 ? 0 : 4, 0);
                panel.add(supporterPanel, gbc);
                gbc.gridy++;
            }
        }

        return panel;
    }

    private JPanel createSupporterPanel(Supporter supporter) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
            BorderFactory.createLineBorder(getTierColor(supporter.tier), 1),
            new EmptyBorder(8, 12, 8, 12)));

        JLabel nameLabel = new JLabel(supporter.getDisplayName());
        nameLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        nameLabel.setForeground(Color.WHITE);

        JLabel tierLabel = new JLabel(supporter.getTierDisplay());
        tierLabel.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        tierLabel.setForeground(getTierColor(supporter.tier));

        JPanel textPanel = new JPanel(new BorderLayout());
        textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textPanel.add(nameLabel, BorderLayout.NORTH);
        textPanel.add(tierLabel, BorderLayout.SOUTH);

        // Add tier badge
        JLabel badge = new JLabel(getTierBadge(supporter.tier));
        badge.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 11f));
        badge.setForeground(getTierColor(supporter.tier));

        panel.add(textPanel, BorderLayout.CENTER);
        panel.add(badge, BorderLayout.EAST);

        return panel;
    }

    private Color getTierColor(String tier) {
        switch (tier.toLowerCase()) {
            case "bronze":
                return new Color(205, 127, 50); // Bronze
            case "silver":
                return new Color(192, 192, 192); // Silver
            case "gold":
                return new Color(255, 215, 0); // Gold
            case "platinum":
                return new Color(229, 228, 226); // Platinum
            default:
                return ColorScheme.LIGHT_GRAY_COLOR;
        }
    }

    private String getTierBadge(String tier) {
        switch (tier.toLowerCase()) {
            case "bronze":
                return "★";
            case "silver":
                return "★★";
            case "gold":
                return "★★★";
            case "platinum":
                return "★★★★";
            default:
                return "★";
        }
    }

    private JPanel createLinks() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Community & Help");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // GitHub button
        JButton githubBtn = createStyledButton("View on GitHub", ColorScheme.MEDIUM_GRAY_COLOR);
        githubBtn.addActionListener(e -> openURL(GITHUB_URL));
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(githubBtn, gbc);
        gbc.gridy++;

        // Issues button
        JButton issuesBtn = createStyledButton("Report Issues", ColorScheme.MEDIUM_GRAY_COLOR);
        issuesBtn.addActionListener(e -> openURL(GITHUB_URL + "/issues"));
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(issuesBtn, gbc);

        return panel;
    }

    private JPanel createDebugSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Debug Tools");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // Debug info
        JLabel debugInfo = new JLabel("<html>Test error message display (developer mode only)</html>");
        debugInfo.setFont(FontManager.getRunescapeFont().deriveFont(10f));
        debugInfo.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(debugInfo, gbc);
        gbc.gridy++;

        // Test capacity button
        JButton testCapacityBtn = createStyledButton("Test Capacity Error", ColorScheme.MEDIUM_GRAY_COLOR);
        testCapacityBtn.addActionListener(e -> ablyManager.testCapacityError());
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(testCapacityBtn, gbc);
        gbc.gridy++;

        // Test connection button
        JButton testConnectionBtn = createStyledButton("Test Connection Error", ColorScheme.MEDIUM_GRAY_COLOR);
        testConnectionBtn.addActionListener(e -> ablyManager.testConnectionError());
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(testConnectionBtn, gbc);
        gbc.gridy++;
        
        // Test update button
        JButton testUpdateBtn = createStyledButton("Test Update Notification", ColorScheme.MEDIUM_GRAY_COLOR);
        testUpdateBtn.addActionListener(e -> ablyManager.testUpdateNotification());
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(testUpdateBtn, gbc);

        return panel;
    }


    private JButton createStyledButton(String text, Color backgroundColor) {
        JButton button = new JButton(text);
        button.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        button.setForeground(Color.WHITE);
        button.setBackground(backgroundColor);
        button.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(backgroundColor.darker(), 1),
                new EmptyBorder(12, 20, 12, 20)));
        button.setFocusPainted(false);
        button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

        // Add hover effect
        Color originalColor = backgroundColor;
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(originalColor.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(originalColor);
            }
        });

        return button;
    }

    private void openURL(String url) {
        try {
            if (Desktop.isDesktopSupported()) {
                Desktop.getDesktop().browse(new URI(url));
            }
        } catch (Exception e) {
            log.error("Failed to open URL: " + url, e);
        }
    }

    private JPanel createUserCountSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Connection Status
        connectionStatusLabel = new JLabel("● Checking connection...");
        connectionStatusLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        updateConnectionStatus();
        gbc.insets = new Insets(0, 0, 5, 0);
        panel.add(connectionStatusLabel, gbc);
        gbc.gridy++;

        // Connection limits (dynamic) - start with loading message
        connectionLimitsLabel = new JLabel("<html>Loading connection info...</html>");
        connectionLimitsLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        connectionLimitsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 10, 0);
        panel.add(connectionLimitsLabel, gbc);
        gbc.gridy++;

        // Fetch connection stats immediately - let failure states handle retries
        if (httpClient != null && gson != null) {
            fetchConnectionStats();
        }

        // Title
        // JLabel titleLabel = new JLabel("Online Users");
        // titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        // titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        // gbc.insets = new Insets(0, 0, 12, 0);
        // panel.add(titleLabel, gbc);
        // gbc.gridy++;

        // Total users
        // totalUsersLabel = new JLabel("Total Online: Loading...");
        // totalUsersLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        // totalUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        // gbc.insets = new Insets(0, 0, 3, 0);
        // panel.add(totalUsersLabel, gbc);
        // gbc.gridy++;

        // Current world users
        // currentWorldUsersLabel = new JLabel("Current World: Loading...");
        // currentWorldUsersLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        // currentWorldUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        // gbc.insets = new Insets(0, 0, 3, 0);
        // panel.add(currentWorldUsersLabel, gbc);
        // gbc.gridy++;

        // Top world
        // topWorldLabel = new JLabel("Top World: Loading...");
        // topWorldLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        // topWorldLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        // gbc.insets = new Insets(0, 0, 0, 0);
        // panel.add(topWorldLabel, gbc);

        // Start periodic updates
        // startUserCountUpdates(); // Commented out - online users disabled
        startConnectionStatusUpdates();

        return panel;
    }

    private void startUserCountUpdates() {
        // Initial update
        updateUserCounts();
        
        // Update every 30 seconds
        userCountUpdateTimer = new Timer(30000, e -> {
            updateUserCounts();
            fetchConnectionStats();
        });
        userCountUpdateTimer.start();
    }

    private void updateUserCounts() {
        // Skip if we don't have the required dependencies (test constructor)
        if (httpClient == null || gson == null) {
            return;
        }
        
        Request request = new Request.Builder()
            .url("https://global-chat-frontend.vercel.app/api/user-counts")
            .build();
        
        httpClient.newCall(request).enqueue(new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, java.io.IOException e) {
                log.debug("Failed to fetch user counts: {}", e.getMessage());
            }

            @Override
            public void onResponse(okhttp3.Call call, Response response) throws java.io.IOException {
                try {
                    if (response.isSuccessful() && response.body() != null) {
                        String responseBody = response.body().string();
                        UserCountResponse userCountResponse = gson.fromJson(responseBody, UserCountResponse.class);
                        
                        if (userCountResponse != null) {
                            // Get current world count if available
                            String currentWorldId = getCurrentWorldId();
                            int currentWorldCount = 0;
                            if (currentWorldId != null && userCountResponse.worldCounts != null) {
                                Integer worldCount = userCountResponse.worldCounts.get(currentWorldId);
                                if (worldCount != null) {
                                    currentWorldCount = worldCount;
                                }
                            }
                            
                            // Find top world
                            String topWorldId = null;
                            int topWorldCount = 0;
                            if (userCountResponse.worldCounts != null) {
                                for (Map.Entry<String, Integer> entry : userCountResponse.worldCounts.entrySet()) {
                                    if (entry.getValue() > topWorldCount) {
                                        topWorldCount = entry.getValue();
                                        topWorldId = entry.getKey();
                                    }
                                }
                            }
                            
                            UserCountData data = new UserCountData(userCountResponse.totalOnline, currentWorldCount, currentWorldId, topWorldId, topWorldCount);
                            
                            // Update UI on EDT
                            javax.swing.SwingUtilities.invokeLater(() -> {
                                // Only update if the labels exist (not commented out)
                                if (totalUsersLabel != null) {
                                    if (data.totalOnline > 0) {
                                        totalUsersLabel.setText("Total Online: " + data.totalOnline + " players");
                                        totalUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    } else {
                                        totalUsersLabel.setText("Total Online: Unavailable");
                                        totalUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    }
                                }
                                
                                if (data.currentWorldId != null && currentWorldUsersLabel != null) {
                                    if (data.currentWorldCount > 0) {
                                        currentWorldUsersLabel.setText("World " + data.currentWorldId + ": " + data.currentWorldCount + " players");
                                        currentWorldUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    } else {
                                        currentWorldUsersLabel.setText("World " + data.currentWorldId + ": 0 players");
                                        currentWorldUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    }
                                } else if (currentWorldUsersLabel != null) {
                                    currentWorldUsersLabel.setText("Current World: Not connected");
                                    currentWorldUsersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                }
                                
                                // Update top world
                                if (topWorldLabel != null) {
                                    if (data.topWorldId != null && data.topWorldCount > 0) {
                                        topWorldLabel.setText("Top World " + data.topWorldId + ": " + data.topWorldCount + " players");
                                        topWorldLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    } else {
                                        topWorldLabel.setText("Top World: No data");
                                        topWorldLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                                    }
                                }
                            });
                        }
                    }
                } finally {
                    response.close();
                }
            }
        });
    }

    private void fetchConnectionStats() {
        fetchConnectionStatsWithRetry(0);
    }

    private void fetchConnectionStatsWithRetry(int attemptCount) {
        // Skip if we don't have the required dependencies
        if (httpClient == null || gson == null) {
            return;
        }
        
        // Don't retry indefinitely
        if (attemptCount >= 3) {
            log.debug("Max retry attempts reached for connection stats, giving up");
            return;
        }
        
        Request request = new Request.Builder()
                .url("https://global-chat-frontend.vercel.app/api/stats/connections")
                .build();

        httpClient.newCall(request).enqueue(new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, java.io.IOException e) {
                log.warn("Error fetching connection stats (attempt {}): {}", attemptCount + 1, e.getMessage());
                
                // Retry on network failures with exponential backoff
                if (attemptCount < 2) {
                    int delayMs = 1000 * (int) Math.pow(2, attemptCount); // 1s, 2s, 4s
                    SwingUtilities.invokeLater(() -> {
                        Timer retryTimer = new Timer(delayMs, retryEvent -> {
                            fetchConnectionStatsWithRetry(attemptCount + 1);
                        });
                        retryTimer.setRepeats(false);
                        retryTimer.start();
                    });
                }
            }

            @Override
            public void onResponse(okhttp3.Call call, Response response) throws java.io.IOException {
                try {
                    if (response.isSuccessful() && response.body() != null) {
                        String responseBody = response.body().string();
                        parseConnectionStatsResponse(responseBody);
                        log.debug("Successfully fetched connection stats on attempt {}", attemptCount + 1);
                    } else {
                        log.warn("Failed to fetch connection stats: HTTP {} (attempt {})", response.code(), attemptCount + 1);
                        
                        // Retry on HTTP errors (5xx server errors, but not 4xx client errors)
                        if (response.code() >= 500 && attemptCount < 2) {
                            int delayMs = 2000 * (attemptCount + 1); // 2s, 4s
                            SwingUtilities.invokeLater(() -> {
                                Timer retryTimer = new Timer(delayMs, retryEvent -> {
                                    fetchConnectionStatsWithRetry(attemptCount + 1);
                                });
                                retryTimer.setRepeats(false);
                                retryTimer.start();
                            });
                        }
                    }
                } finally {
                    response.close();
                }
            }
        });
    }
    
    private void parseConnectionStatsResponse(String json) {
        try {
            ConnectionStatsResponse response = gson.fromJson(json, ConnectionStatsResponse.class);
            
            if (response != null && response.maxConnections > 0) {
                // Don't update to 0 if we already have valid non-zero data
                if (this.connectionStats != null && 
                    this.connectionStats.currentConnections > 0 && 
                    response.currentConnections == 0) {
                    log.debug("Ignoring suspicious 0 connection count when we have existing data showing {}", 
                        this.connectionStats.currentConnections);
                    return;
                }
                
                // On initial load, don't display 0 connections - wait for real data
                if (!hasReceivedValidData && response.currentConnections == 0) {
                    log.debug("Ignoring initial 0 connection count, waiting for real data");
                    return;
                }
                
                // Mark that we've received valid data if connections > 0
                if (response.currentConnections > 0) {
                    hasReceivedValidData = true;
                }
                
                this.connectionStats = response;
                updateConnectionDisplay();
                log.debug("Updated connection stats: {}/{}", response.currentConnections, response.maxConnections);
            }
        } catch (Exception e) {
            log.error("Error parsing connection stats response", e);
        }
    }
    
    private void updateConnectionDisplay() {
        SwingUtilities.invokeLater(() -> {
            if (connectionLimitsLabel == null) {
                return;
            }
            
            if (connectionStats == null) {
                connectionLimitsLabel.setText("<html>Loading connection info...</html>");
                connectionLimitsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
                return;
            }
            
            double connectionUtilization = connectionStats.currentConnections * 100.0 / connectionStats.maxConnections;
            
            String statusText;
            if (connectionUtilization >= 100) {
                // Over capacity - show warning with player impact
                statusText = String.format(
                    "<html><b>Connections:</b> %d / %d (%.1f%%)<br>" +
                    "<b style='color: #ff9040;'>Some players can't connect to Global Chat! Support on Patreon to increase connection limits.</b></html>",
                    connectionStats.currentConnections,
                    connectionStats.maxConnections,
                    connectionUtilization
                );
            } else {
                // Normal display
                statusText = String.format(
                    "<html><b>Connections:</b> %d / %d (%.1f%%)</html>",
                    connectionStats.currentConnections,
                    connectionStats.maxConnections,
                    connectionUtilization
                );
            }
            
            connectionLimitsLabel.setText(statusText);
            
            // Color code based on connection utilization
            if (connectionUtilization >= 100) {
                connectionLimitsLabel.setForeground(Color.RED); // Over limit!
            } else if (connectionUtilization > 90) {
                connectionLimitsLabel.setForeground(Color.RED); // Critical
            } else if (connectionUtilization > 75) {
                connectionLimitsLabel.setForeground(Color.ORANGE); // Warning
            } else {
                connectionLimitsLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR); // Normal
            }
        });
    }
    
    private String getCurrentWorldId() {
        if (client != null) {
            int worldId = client.getWorld();
            if (worldId > 0) {
                return String.valueOf(worldId);
            }
        }
        return null;
    }
    
    private static class UserCountResponse {
        @SerializedName("totalOnline")
        public int totalOnline;
        
        @SerializedName("worldCounts")
        public Map<String, Integer> worldCounts;
        
        @SerializedName("error")
        public String error;
    }

    private static class ConnectionStatsResponse {
        @SerializedName("currentConnections")
        public int currentConnections;
        
        @SerializedName("maxConnections")  
        public int maxConnections;
        
        @SerializedName("currentChannels")
        public int currentChannels;
        
        @SerializedName("maxChannels")
        public int maxChannels;
        
        @SerializedName("error")
        public String error;
    }
    
    private static class UserCountData {
        final int totalOnline;
        final int currentWorldCount;
        final String currentWorldId;
        final String topWorldId;
        final int topWorldCount;
        
        UserCountData(int totalOnline, int currentWorldCount, String currentWorldId, String topWorldId, int topWorldCount) {
            this.totalOnline = totalOnline;
            this.currentWorldCount = currentWorldCount;
            this.currentWorldId = currentWorldId;
            this.topWorldId = topWorldId;
            this.topWorldCount = topWorldCount;
        }
    }
    
    private JPanel createReadOnlyToggleSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(10, 10, 10, 10)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Chat Mode");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // Description
        JLabel descLabel = new JLabel("<html>" +
            "- Normal Mode: View + Send messages globally<br>" +
            "- Read-Only: View only, no global sending" +
            "</html>");
        descLabel.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        descLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 6, 0);
        panel.add(descLabel, gbc);
        gbc.gridy++;

        // Toggle button
        JToggleButton toggleButton = new JToggleButton();
        toggleButton.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        toggleButton.setFocusPainted(false);
        toggleButton.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        toggleButton.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(8, 15, 8, 15)));

        // Get current state from config
        boolean currentReadOnly = false;
        if (configManager != null) {
            currentReadOnly = configManager.getConfiguration("globalchat", "readOnlyMode", Boolean.class);
        }
        
        // Set initial state
        toggleButton.setSelected(currentReadOnly);
        updateToggleButtonAppearance(toggleButton, currentReadOnly);

        // Add click listener
        toggleButton.addActionListener(e -> {
            boolean newState = toggleButton.isSelected();
            if (configManager != null) {
                configManager.setConfiguration("globalchat", "readOnlyMode", newState);
            }
            updateToggleButtonAppearance(toggleButton, newState);
            updateStatusLabel(newState);
        });

        // Add hover effects
        toggleButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                toggleButton.setBackground(ColorScheme.MEDIUM_GRAY_COLOR.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                updateToggleButtonAppearance(toggleButton, toggleButton.isSelected());
            }
        });

        gbc.insets = new Insets(0, 0, 6, 0);
        panel.add(toggleButton, gbc);
        gbc.gridy++;

        // Status indicator
        readOnlyStatusLabel = new JLabel();
        readOnlyStatusLabel.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        readOnlyStatusLabel.setHorizontalAlignment(SwingConstants.CENTER);
        updateStatusLabel(currentReadOnly);
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(readOnlyStatusLabel, gbc);

        return panel;
    }

    private void updateToggleButtonAppearance(JToggleButton button, boolean readOnly) {
        if (readOnly) {
            button.setText("Read-Only: View Only");
            button.setBackground(ColorScheme.MEDIUM_GRAY_COLOR); // Secondary button style
            button.setForeground(Color.WHITE); // Standard white text
            button.setToolTipText("Click to enable sending messages globally");
        } else {
            button.setText("Normal: View + Send");
            button.setBackground(ColorScheme.MEDIUM_GRAY_COLOR); // Secondary button style
            button.setForeground(Color.WHITE); // Standard white text
            button.setToolTipText("Click to disable sending messages globally");
        }
    }

    private void updateStatusLabel(boolean readOnly) {
        if (readOnlyStatusLabel != null) {
            if (readOnly) {
                readOnlyStatusLabel.setText("<html><i>Warning: Messages will not be sent globally</i></html>");
                readOnlyStatusLabel.setForeground(new Color(255, 180, 180)); // Keep warning color
            } else {
                readOnlyStatusLabel.setText(""); // No status text when normal
                readOnlyStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            }
        }
    }

    public void refreshUserCounts() {
        // updateUserCounts(); // Commented out - online users disabled
    }
    
    public void cleanup() {
        if (userCountUpdateTimer != null) {
            userCountUpdateTimer.stop();
        }
        if (connectionStatusTimer != null) {
            connectionStatusTimer.stop();
        }
    }
    
    private void updateConnectionStatus() {
        if (connectionStatusLabel == null) return;
        
        javax.swing.SwingUtilities.invokeLater(() -> {
            if (ablyManager == null) {
                connectionStatusLabel.setText("\u25cf Not initialized");
                connectionStatusLabel.setForeground(Color.GRAY);
            } else if (ablyManager.isConnected()) {
                connectionStatusLabel.setText("\u25cf Connected to Global Chat");
                connectionStatusLabel.setForeground(new Color(0, 200, 0)); // Green
            } else {
                connectionStatusLabel.setText("\u25cf Disconnected");
                connectionStatusLabel.setForeground(new Color(200, 0, 0)); // Red
            }
        });
    }
    
    private void startConnectionStatusUpdates() {
        // Update immediately
        updateConnectionStatus();
        fetchConnectionStats();
        
        // Update connection status every 2 seconds (responsive)
        connectionStatusTimer = new Timer(2000, e -> updateConnectionStatus());
        connectionStatusTimer.start();
        
        // Update connection stats every 30 seconds (less frequent)
        Timer connectionStatsTimer = new Timer(30000, e -> fetchConnectionStats());
        connectionStatsTimer.start();
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import java.util.HashSet;
import java.util.Arrays;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import javax.inject.Named;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.realtime.ChannelState;
import io.ably.lib.realtime.CompletionListener;
import io.ably.lib.types.AblyException;
import io.ably.lib.types.ChannelOptions;
import io.ably.lib.types.ClientOptions;
import io.ably.lib.types.Message;
import io.ably.lib.types.Param;
import java.util.Base64;

import java.util.Set;
import java.util.HashMap;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.WorldType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;
import net.runelite.api.Player;
import net.runelite.api.Constants;
import net.runelite.api.Friend;
import net.runelite.client.callback.ClientThread;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Singleton
public class AblyManager {

	public static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

	private static final int OVERHEAD_TEXT_TICK_TIMEOUT = 5;
	private static final int CYCLES_FOR_OVERHEAD_TEXT = OVERHEAD_TEXT_TICK_TIMEOUT * CYCLES_PER_GAME_TICK;
	
	// Initialize spam messages once as a static final set
	private static final Set<String> SPAM_MESSAGES = new HashSet<>(Arrays.asList(
		"In the name of Saradomin, protector of us all, I now join you in the eyes of Saradomin.",
		"Thy cause was false, thy skills did lack; See you in Lumbridge when you get back.",
		"Go in peace in the name of Saradomin; May his glory shine upon you like the sun.",
		"The currency of goodness is honour; It retains its value through scarcity. This is Saradomin's wisdom.",
		"Two great warriors, joined by hand, to spread destruction across the land. In Zamorak's name, now two are one.",
		"The weak deserve to die, so the strong may flourish. This is the creed of Zamorak.",
		"May your bloodthirst never be sated, and may all your battles be glorious. Zamorak bring you strength.",
		"There is no opinion that cannot be proven true...by crushing those who choose to disagree with it. Zamorak give me strength!",
		"Battles are not lost and won; They simply remove the weak from the equation. Zamorak give me strength!",
		"Those who fight, then run away, shame Zamorak with their cowardice. Zamorak give me strength!",
		"Battle is by those who choose to disagree with it. Zamorak give me strength!",
		"Strike fast, strike hard, strike true: The strength of Zamorak will be with you. Zamorak give me strength!",
		"Light and dark, day and night, balance arises from contrast. I unify thee in the name of Guthix.",
		"Thy death was not in vain, for it brought some balance to the world. May Guthix bring you rest.",
		"May you walk the path, and never fall, for Guthix walks beside thee on thy journey. May Guthix bring you peace.",
		"The trees, the earth, the sky, the waters; All play their part upon this land. May Guthix bring you balance.",
		"Big High War God want great warriors. Because you can make more... I bind you in Big High War God name.",
		"You not worthy of Big High War God; you die too easy.",
		"Big High War God make you strong... so you smash enemies.",
		"War is best, peace is for weak. If you not worthy of Big High War God... you get made dead soon.",
		"As ye vow to be at peace with each other... and to uphold high values of morality and friendship... I now pronounce you united in the law of Armadyl.",
		"Thou didst fight true... but the foe was too great. May thy return be as swift as the flight of Armadyl.",
		"For thy task is lawful... May the blessing of Armadyl be upon thee.",
		"Peace shall bring thee wisdom; Wisdom shall bring thee peace. This is the law of Armadyl.",
		"Ye faithful and loyal to the Great Lord... May ye together succeed in your deeds. Ye are now joined by the greatest power.",
		"Thy faith faltered, no power could save thee. Like the Great Lord, one day you shall rise again.",
		"By day or night, in defeat or victory... the power of the Great Lord be with thee.",
		"Follower of the Great Lord be relieved: One day your loyalty will be rewarded. Power to the Great Lord!",
		"Just say neigh to gambling!", "Eww stinky!", "I will burn with you.",
		"Burn with me!", "Here fishy fishies!",
		"For Camelot!", "Raarrrrrgggggghhhhhhh", "Taste vengeance!", "Smashing!", "*yawn*",
		// Messages from tobMistakeTrackerSpam
		"I'm planking!",
		"I'm drowning in Maiden's blood!",
		"I'm stunned!",
		"Bye!",
		"I'm eating cabbages!",
		"I can't count to four!",
		"I'm PKing my team!",
		"I was stuck in a web!",
		"I'm healing Verzik!",
		// Messages from TOAMistakeTrackerSpam
		"Argh! It burns!",
		"Come on and slam!",
		"Ah! It burns!",
		"Embrace Darkness!",
		"I'm too slow!",
		"I'm griefing!",
		"?",
		"This jug feels a little light...",
		"I'm drowning in acid!",
		"I'm on a blood cloud!",
		"Nihil!",
		"I'm surfing!",
		"I'm exploding!",
		"The swarms are going in!",
		"I've been hatched!",
		"I'm fuming!",
		"The sky is falling!",
		"I've been corrupted!",
		"It's venomous!",
		"Come on and slam!|And welcome to the jam!",
		"I got rocked!",
		"They see me rollin'...",
		"It's raining!",
		"Who put that there?",
		"I'm going down!",
		"I'm disco-ing!",
		"I'm dancing!",
		"I'm winded!",
		"I'm getting bombed!",
		"I'm in jail!",
		"What even was that attack?",
		"I'm tripping!"
	));

	private final Client client;
	private final SupporterManager supporterManager;

	@Inject
	Gson gson;


	private final Map<String, String> previousMessages = new HashMap<>();

	private final HashMap<String, Integer> playerCombats = new HashMap<>();

	@Inject
	ChatMessageManager chatMessageManager;

	@Inject
	ClientThread clientThread;

	private final GlobalChatConfig config;
	private final boolean developerMode;

	private AblyRealtime ablyRealtime;
	private volatile boolean isConnecting = false;
	private ExecutorService publishExecutor;
	private volatile boolean shuttingDown = false;
	private final Map<String, Boolean> channelSubscriptionStatus = new HashMap<>();
	private final Map<String, Long> lastMessageTime = new HashMap<>();
	private final Map<Integer, Long> lastErrorMessageTimePerWorld = new HashMap<>();
	private static final long ERROR_MESSAGE_COOLDOWN = 1800000; // 30 minutes

	@Inject
	public AblyManager(Client client, GlobalChatConfig config, @Named("developerMode") boolean developerMode, SupporterManager supporterManager) {
		this.client = client;
		this.config = config;
		this.developerMode = developerMode;
		this.supporterManager = supporterManager;
		this.publishExecutor = createPublishExecutor();
	}
	
	private ExecutorService createPublishExecutor() {
		return Executors.newSingleThreadExecutor(r -> {
			Thread t = new Thread(r, "AblyPublisher");
			t.setDaemon(true);
			return t;
		});
	}
	
	private synchronized void ensureExecutorAvailable() {
		if (publishExecutor == null || publishExecutor.isShutdown() || publishExecutor.isTerminated()) {
			publishExecutor = createPublishExecutor();
			log.debug("Recreated publish executor");
		}
	}

	public void startConnection(String playerName) {
		// Reset shutdown flag when starting a new connection
		shuttingDown = false;
		
		// Prevent multiple concurrent connections with atomic check-and-set
		synchronized (this) {
			if (isConnecting) {
				log.debug("Connection already in progress, skipping");
				return;
			}
			
			// Check if already connected
			if (ablyRealtime != null) {
				try {
					io.ably.lib.realtime.ConnectionState state = ablyRealtime.connection.state;
					if (state == io.ably.lib.realtime.ConnectionState.connected) {
						log.debug("Already connected, skipping");
						return;
					}
					if (state == io.ably.lib.realtime.ConnectionState.connecting) {
						log.debug("Connection already in progress, skipping");
						return;
					}
				} catch (Exception e) {
					log.debug("Error checking connection state", e);
				}
			}
			
			isConnecting = true;
		}
		
		try {
			setupAblyInstances(playerName);
		} catch (Exception e) {
			handleAblyError(e);
		} finally {
			isConnecting = false;
		}
	}

	public void closeSpecificChannel(String channelName) {
		if (ablyRealtime == null) {
			log.debug("AblyRealtime is null, cannot close channel: {}", channelName);
			return;
		}
		
		if (publishExecutor == null) {
			log.debug("PublishExecutor is null, cannot close channel: {}", channelName);
			return;
		}
		
		// Move channel detachment to background executor
		ensureExecutorAvailable();
		publishExecutor.submit(() -> {
			try {
				ablyRealtime.channels.get(channelName).detach();
				log.debug("Closed channel: {}", channelName);
			} catch (AblyException err) {
				log.error("Error detaching from channel: {}", channelName, err);
			}
		});
		
		// Thread-safe update of local state
		synchronized (channelSubscriptionStatus) {
			channelSubscriptionStatus.remove(channelName);
		}
	}
	
	public boolean isConnected() {
		if (ablyRealtime == null) return false;
		
		try {
			// Check basic connection state
			if (ablyRealtime.connection.state != io.ably.lib.realtime.ConnectionState.connected) {
				return false;
			}
			
			// Thread-safe check of channel subscriptions
			synchronized (channelSubscriptionStatus) {
				// Check that we have channels subscribed
				if (channelSubscriptionStatus.isEmpty()) {
					return false; // No channels subscribed means not connected
				}
				
				// Verify ALL channel subscriptions succeeded
				boolean allChannelsSuccessful = channelSubscriptionStatus.values().stream()
					.allMatch(status -> status);
				
				return allChannelsSuccessful;
			}
		} catch (Exception e) {
			log.debug("Error checking connection state", e);
			return false;
		}
	}


	public void closeConnection() {
		// Capture reference to avoid race conditions
		final AblyRealtime connectionToClose = ablyRealtime;
		
		// Immediately null out the reference to prevent new operations
		ablyRealtime = null;
		
		if (connectionToClose != null) {
			// Check if we're already shutting down to avoid submitting new tasks
			if (publishExecutor != null && !publishExecutor.isShutdown()) {
				ensureExecutorAvailable();
				publishExecutor.submit(() -> {
					try {
						log.debug("Closing Ably connection in background");
						connectionToClose.close();
						log.debug("Connection properly closed");
					} catch (Exception e) {
						log.error("Error closing connection", e);
					}
				});
			} else {
				// If executor is shutting down, close synchronously
				try {
					log.debug("Closing Ably connection synchronously during shutdown");
					connectionToClose.close();
				} catch (Exception e) {
					log.error("Error closing connection during shutdown", e);
				}
			}
		}
		
		// Note: Don't shutdown executor here since we just submitted a task to it
		// The executor will be shut down when the plugin stops
	}
	
	public void shutdown() {
		log.debug("Shutting down AblyManager");
		// Set shutdown flag to prevent new tasks
		shuttingDown = true;
		
		// First close any active connection
		closeConnection();
		
		// Then shutdown the executor - just shutdown without blocking
		if (publishExecutor != null && !publishExecutor.isShutdown()) {
			publishExecutor.shutdown();
		}
	}

	public boolean isUnderCbLevel(String username) {
		String cleanedName = Text.sanitize(username);
		Integer cachedCbLevel = playerCombats.get(cleanedName);
		if (cachedCbLevel != null) {
			return cachedCbLevel < config.filterOutFromBelowCblvl();
		}

		// This method should only use cached data since it can be called from any thread
		// Player combat levels are cached in handleAblyMessage when messages are received
		return false; // If no cached level, assume not under cb level
	}

	public boolean isSpam(String message) {
		// Simply check against the pre-initialized static set
		return SPAM_MESSAGES.contains(message);
	}

	public boolean publishMessage(String t, String message, String channel, String to) {
		// Build message on client thread (need client data)
		try {
			if (client.getLocalPlayer() == null) {
				return false;
			}
			if (config.readOnlyMode()) {
				return false;
			}

			// Gather all client data needed for the message
			String username = Text.removeTags(client.getLocalPlayer().getName());
			String symbol = getAccountIcon();
			
			// Determine channel options based on message type
			ChannelOptions options;
			if (t.equals("p")) {
				Friend friend = client.getFriendContainer().findByName(to);
				if (friend == null) {
					return false;
				}
				String key = String.valueOf(friend.getWorld());
				String paddedKeyString = padKey(key, 16);
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				options = ChannelOptions.withCipherKey(base64EncodedKey);
			} else {
				String paddedKeyString = padKey("pub", 16);
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				options = ChannelOptions.withCipherKey(base64EncodedKey);
			}

			// Build the message JSON
			JsonObject msg = io.ably.lib.util.JsonUtils.object()
					.add("symbol", symbol)
					.add("username", username)
					.add("message", message)
					.add("type", t)
					.add("to", to)
					.toJson();

			// Push actual publishing to executor to avoid blocking client thread
			ensureExecutorAvailable();
			publishExecutor.submit(() -> {
				try {
					if (ablyRealtime == null) {
						log.debug("AblyRealtime is null, cannot publish message");
						return;
					}
					
					Channel currentChannel = ablyRealtime.channels.get(channel, options);
					currentChannel.publish("event", msg);
					log.debug("Published message to channel: {}", channel);
				} catch (AblyException err) {
					log.error("Ably publish error", err);
					handleAblyError(err);
				}
			});
			
			return true;
		} catch (Exception err) {
			log.error("Error preparing message for publish", err);
			return false;
		}
	}

	public void publishMessageAsync(String t, String message, String channel, String to, java.util.function.Consumer<Boolean> callback) {
		// Build message on client thread (need client data)
		try {
			if (client.getLocalPlayer() == null) {
				if (callback != null) callback.accept(false);
				return;
			}
			if (config.readOnlyMode()) {
				if (callback != null) callback.accept(false);
				return;
			}

			// Gather all client data needed for the message
			String username = Text.removeTags(client.getLocalPlayer().getName());
			String symbol = getAccountIcon();
			
			// Determine channel options based on message type
			ChannelOptions options;
			if (t.equals("p")) {
				Friend friend = client.getFriendContainer().findByName(to);
				if (friend == null) {
					if (callback != null) callback.accept(false);
					return;
				}
				String key = String.valueOf(friend.getWorld());
				String paddedKeyString = padKey(key, 16);
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				options = ChannelOptions.withCipherKey(base64EncodedKey);
			} else {
				String paddedKeyString = padKey("pub", 16);
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				options = ChannelOptions.withCipherKey(base64EncodedKey);
			}

			// Build the message JSON
			JsonObject msg = io.ably.lib.util.JsonUtils.object()
					.add("symbol", symbol)
					.add("username", username)
					.add("message", message)
					.add("type", t)
					.add("to", to)
					.toJson();

			// Push actual publishing to executor to avoid blocking client thread
			ensureExecutorAvailable();
			publishExecutor.submit(() -> {
				try {
					if (ablyRealtime == null) {
						log.debug("AblyRealtime is null, cannot publish message");
						if (callback != null) callback.accept(false);
						return;
					}
					
					Channel currentChannel = ablyRealtime.channels.get(channel, options);
					currentChannel.publish("event", msg);
					log.debug("Published message to channel: {}", channel);
					if (callback != null) callback.accept(true);
				} catch (AblyException err) {
					log.error("Ably publish error", err);
					handleAblyError(err);
					if (callback != null) callback.accept(false);
				}
			});
			
		} catch (Exception err) {
			log.error("Error preparing message for publish", err);
			if (callback != null) callback.accept(false);
		}
	}

	public void handleMessage(Message message) {
		if (client.getGameState() == GameState.LOGGED_IN) {
			handleAblyMessage(message);
		}
	}


	private String getValidAccountIcon(String accountIcon) {
		if (accountIcon.equals("<img=2>"))
			return accountIcon;
		if (accountIcon.equals("<img=10>"))
			return accountIcon;
		if (accountIcon.equals("<img=3>"))
			return accountIcon;
		// Allow supporter icons
		if (accountIcon.equals("<img=313> "))
			return accountIcon;
		if (accountIcon.equals("<img=312> "))
			return accountIcon;
		if (accountIcon.equals("<img=314> "))
			return accountIcon;
		return "";
	}

	private void handleAblyMessage(Message message) {
		// Parse message data on background thread (safe - just parsing JSON)
		GlobalChatMessage msg = gson.fromJson((JsonElement) message.data, GlobalChatMessage.class);
		String username = Text.removeTags(msg.username);
		String receivedMsg = Text.removeTags(msg.message); // Clean message for display
		
		if (!shouldShowMessge(username, receivedMsg, false)) {
			return;
		}
		if (!shouldShowCurrentMessage(receivedMsg, username)) {
			return;
		}

		String baseSymbol = getValidAccountIcon(msg.symbol);
		
		// Add supporter icon if user is a supporter
		String supporterIcon = supporterManager.getSupporterIcon(username);
		if (!supporterIcon.isEmpty()) {
			if (baseSymbol.isEmpty()) {
				baseSymbol = supporterIcon;
			} else {
				baseSymbol = supporterIcon + " " + baseSymbol;
			}
		}

		if (msg.type.equals("w")) {
			baseSymbol = "<img=19> " + baseSymbol;
		}

		if (username.length() > 12) {
			return;
		}

		// Final variable for lambda capture
		final String symbol = baseSymbol;

		// Move all client data access to client thread
		clientThread.invokeLater(() -> {
			if (client.getGameState() != GameState.LOGGED_IN) {
				return true;
			}

			final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
					.append(receivedMsg);

			if (msg.type.equals("p") && client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null 
					&& !username.equals(client.getLocalPlayer().getName())
					&& msg.to.equals(client.getLocalPlayer().getName())) {

				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.PRIVATECHAT)
						.name(symbol + username)
						.runeLiteFormattedMessage(chatMessageBuilder.build())
						.build());
			} else if (msg.type.equals("w")) {

				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.PUBLICCHAT)
						.name(symbol + username)
						.runeLiteFormattedMessage(chatMessageBuilder.build())
						.build());

				// Cache combat level while accessing player data
				for (Player player : client.getPlayers()) {
					if (player != null &&
							player.getName() != null &&
							username.equals(player.getName())) {
						
						// Cache the combat level for future use
						playerCombats.put(Text.sanitize(player.getName()), player.getCombatLevel());
						
						player.setOverheadText(receivedMsg);
						player.setOverheadCycle(CYCLES_FOR_OVERHEAD_TEXT);
						break;
					}
				}

			} else if (msg.type.equals("f") && client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null
					&& !username.equals(client.getLocalPlayer().getName())) {

				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.FRIENDSCHAT)
						.name(symbol + username).sender(msg.to)
						.runeLiteFormattedMessage(chatMessageBuilder.build())
						.build());
			} else if (msg.type.equals("c") && client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null
					&& !username.equals(client.getLocalPlayer().getName())) {

				chatMessageManager.queue(QueuedMessage.builder()
						.type(ChatMessageType.CLAN_CHAT)
						.name(symbol + username).sender(msg.to)
						.runeLiteFormattedMessage(chatMessageBuilder.build())
						.build());
			}
			
			return true;
		});
	}

	// Checks for bits someone could insert in to be icons
	// Important in case it's a JMod icon or something
	private boolean isInvalidUsername(String username) {
		return username.toLowerCase().startsWith("mod ");
	}
	

	public boolean shouldShowCurrentMessage(String message, String name) {
		// Spam is now blocked at publish time, so no need to check here
		if (isInvalidUsername(name))
			return false;

		if (isUnderCbLevel(name)) {
			return false;
		}
		
		return true;
	}
	
	// New method: Only check spam and rate limiting for publishers
	// Always filter spam and invalid usernames regardless of user settings
	public boolean shouldPublishMessage(String message, String name) {
		// Always block spam messages from being published (saves money)
		if (isSpam(message)) {
			return false;
		}
		
		if (isInvalidUsername(name))
			return false;
		
		// Rate limiting: prevent spam by limiting message frequency
		if (!canSendMessage(name)) {
			return false;
		}
		
		return true;
	}
	
	private boolean canSendMessage(String user) {
		long now = System.currentTimeMillis();
		Long lastTime = lastMessageTime.get(user);
		if (lastTime != null && now - lastTime < 100) { // 100ms cooldown
			return false;
		}
		lastMessageTime.put(user, now);
		return true;
	}

	public boolean shouldShowMessge(String name, String message, Boolean set) {
		final String sanitizedName = Text.toJagexName(Text.removeTags(name));

		String prevMessage = previousMessages.get(sanitizedName);

		// If someone is spamming the same message during a session, block it
		if (message.equals(prevMessage)) {
			return false;
		}
		if (set) {
			previousMessages.put(sanitizedName, message);
		}

		return true;
	}

	private void setupAblyInstances(String playerName) {
		try {
			ClientOptions clientOptions = new ClientOptions();
			String name = Text.sanitize(playerName);
			Param[] params = new Param[] {
					new Param("clientId", name),
			};
			clientOptions.authHeaders = params;
			clientOptions.authUrl = "https://global-chat-plugin.vercel.app/api/token";
			
			// Critical: Disable echo messages to reduce message count by 50%
			clientOptions.echoMessages = false;
			
			// Connection timeouts not available in this Ably version
			// Will rely on default timeout behavior
			
			ablyRealtime = new AblyRealtime(clientOptions);
			
			// Add connection state monitoring
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.disconnected, state -> {
				log.warn("Connection disconnected: " + state.reason);
				// Thread-safe clear of channel subscription status since we're disconnected
				synchronized (channelSubscriptionStatus) {
					channelSubscriptionStatus.clear();
				}
			});
			
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.failed, state -> {
				log.error("Connection failed: " + state.reason);
				// Thread-safe clear of channel subscription status on failure
				synchronized (channelSubscriptionStatus) {
					channelSubscriptionStatus.clear();
				}
			});
			
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.connected, state -> {
				log.debug("Connection established successfully");
			});
			
			// Handle connection state changes that indicate we need to resubscribe
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.connecting, state -> {
				log.debug("Connection is reconnecting...");
			});
			
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.suspended, state -> {
				log.warn("Connection suspended: " + state.reason);
			});
			
		} catch (AblyException e) {
			log.error("Failed to setup Ably connection", e);
			handleAblyError(e);
		}
	}


	private static String padKey(String key, int length) {
		if (key.length() >= length) {
			return key.substring(0, length);
		}
		StringBuilder keyBuilder = new StringBuilder(key);
		while (keyBuilder.length() < length) {
			keyBuilder.append("0"); // Pad the key with zeros
		}
		return keyBuilder.toString();
	}

	public void subscribeToCorrectChannel(String channelName, String key) {
		if (ablyRealtime == null) {
			log.debug("AblyRealtime is null, cannot subscribe to channel: {}", channelName);
			return;
		}

		// Prevent duplicate subscriptions - check if already subscribed
		synchronized (channelSubscriptionStatus) {
			Boolean currentStatus = channelSubscriptionStatus.get(channelName);
			if (currentStatus != null && currentStatus) {
				log.debug("Already subscribed to channel: {}, skipping", channelName);
				return;
			}
			// Mark as pending subscription to prevent race conditions
			channelSubscriptionStatus.put(channelName, false);
		}

		// Prepare channel options on calling thread (fast)
		try {
			String paddedKeyString = padKey(key, 16);
			String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
			ChannelOptions options = ChannelOptions.withCipherKey(base64EncodedKey);
			
			// Move actual subscription to background executor
			ensureExecutorAvailable();
			publishExecutor.submit(() -> {
				try {
					Channel currentChannel = ablyRealtime.channels.get(channelName, options);
					currentChannel.subscribe(this::handleMessage);
					
					// Mark channel as successfully subscribed (thread-safe update)
					synchronized (channelSubscriptionStatus) {
						channelSubscriptionStatus.put(channelName, true);
					}
					
					log.debug("Successfully subscribed to channel: {}", channelName);
				} catch (AblyException err) {
					log.error("Ably subscribe error for channel: {}", channelName, err);
					// Mark channel subscription as failed
					synchronized (channelSubscriptionStatus) {
						channelSubscriptionStatus.put(channelName, false);
					}
					handleAblyError(err);
				}
			});
		} catch (AblyException err) {
			log.error("Error preparing channel options for: {}", channelName, err);
			synchronized (channelSubscriptionStatus) {
				channelSubscriptionStatus.put(channelName, false);
			}
		}
	}

	private String getAccountIcon() {
		if (client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
			return "<img=33>";
		}
		switch (client.getAccountType()) {
			case IRONMAN:
				return "<img=2>";
			case HARDCORE_IRONMAN:
				return "<img=10>";
			case ULTIMATE_IRONMAN:
				return "<img=3>";
		}

		return "";
	}
	
	// Debug methods to test error dialogs (only available in developer mode)
	public void testCapacityError() {
		if (developerMode) {
			log.debug("Testing capacity error dialog (developer mode)");
			showInGameErrorMessage(
				"<col=ff9040>[DEBUG] Global Chat is at capacity!</col> " +
				"The plugin has reached its usage limits. " +
				"<col=00ff00>Support on Patreon to help increase limits!</col>"
			);
		}
	}
	
	public void testConnectionError() {
		if (developerMode) {
			log.debug("Testing connection error dialog (developer mode)");
			showInGameErrorMessage(
				"<col=ff0000>[DEBUG] Global Chat connection error!</col> " +
				"Service may be temporarily unavailable. Try again later."
			);
		}
	}
	
	public void testUpdateNotification() {
		if (developerMode) {
			log.debug("Testing update notification (developer mode)");
			showUpdateNotification(
				"<col=00ff00>Global Chat v2.0 is here!</col> " +
				"New: Better error handling, redesigned info panel, spam prevention, and cost optimizations. " +
				"<col=ff9040>Support on Patreon to increase service limits!</col>"
			);
		}
	}
	
	private void handleAblyError(Exception e) {
		String errorMessage = e.getMessage();
		if (errorMessage == null) {
			errorMessage = e.getClass().getSimpleName();
		}
		
		// Check for common limit-related errors
		if (errorMessage.contains("limit") || 
			errorMessage.contains("quota") || 
			errorMessage.contains("exceeded") ||
			errorMessage.contains("capacity") ||
			errorMessage.contains("rate") ||
			e instanceof AblyException && ((AblyException) e).errorInfo != null && 
			(((AblyException) e).errorInfo.code == 40005 || // Connection limit
			 ((AblyException) e).errorInfo.code == 40006 || // Message limit
			 ((AblyException) e).errorInfo.code == 40007)) { // Channel limit
			
			// Show in-game chat message with rate limiting
			showInGameErrorMessage(
				"<col=ff9040>Global Chat connection failed!</col> " +
				"Rate limits have been reached. " +
				"<col=00ff00>Subscribe on Patreon for higher limits!</col>"
			);
		} else {
			// For other errors, show a connection error with limit information
			showInGameErrorMessage(
				"<col=ff0000>Global Chat is hitting its connection limit!</col> " +
				"<col=00ff00>Subscribe to Patreon to increase limits.</col>"
			);
		}
	}
	
	private void showInGameErrorMessage(String message) {
		// Rate limiting: only show error messages every 30 minutes per world to prevent spam
		long now = System.currentTimeMillis();
		int currentWorld = client.getWorld();
		
		// Check if we've shown an error for this world recently
		Long lastErrorTime = lastErrorMessageTimePerWorld.get(currentWorld);
		if (lastErrorTime != null && now - lastErrorTime < ERROR_MESSAGE_COOLDOWN) {
			log.debug("Error message rate limited for world {}, skipping", currentWorld);
			return;
		}
		
		if (client.getGameState() == GameState.LOGGED_IN) {
			lastErrorMessageTimePerWorld.put(currentWorld, now);
			log.debug("Sending error message to chat for world {}", currentWorld);
			
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.GAMEMESSAGE)
				.runeLiteFormattedMessage(message)
				.build());
		}
	}
	
	public void showUpdateNotification(String message) {
		log.debug("Showing update notification");
		
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(message)
			.build());
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import net.runelite.client.callback.ClientThread;

import com.google.inject.Provides;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import com.google.gson.Gson;
import com.google.gson.JsonObject;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.inject.Named;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClanChannelChanged;
import net.runelite.api.events.FriendsChatChanged;
import net.runelite.api.events.FriendsChatMemberJoined;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.menus.MenuManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import javax.imageio.ImageIO;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.MenuEntry;
import net.runelite.api.MenuAction;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@PluginDescriptor(name = "Global Chat", description = "Talk anywhere!", tags = {
		"chat" })
public class GlobalChatPlugin extends Plugin {
	@Inject
	private AblyManager ablyManager;

	@Inject
	private Client client;

	@Inject
	@Getter
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	private GlobalChatInfoPanel infoPanel;
	private NavigationButton navButton;

	@Getter
	@Setter
	private boolean shouldConnect = true;

	@Getter
	@Setter
	private String friendsChat;

	@Getter
	@Setter
	private String theClanName;

	public static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

	@Getter
	@Setter
	private String theGuesttheClanName;

	private long lastFailedSendMessageTime = 0;
	private static final long FAILED_SEND_MESSAGE_COOLDOWN = 1800000; // 30 minutes

	private long lastReconnectAttempt = 0;
	private int reconnectAttempts = 0;

	@Getter
	private final HashMap<String, ArrayList<String>> previousMessages = new HashMap<>();

	@Getter
	@Inject
	@Named("developerMode")
	private boolean developerMode;

	@Inject
	private GlobalChatConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private SupporterManager supporterManager;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Inject
	private MenuManager menuManager;

	private ScheduledExecutorService scheduler;

	// Tracking for chat command transformations
	private final Map<String, Long> pendingCommands = new HashMap<>();
	private final Map<String, String> commandTransformations = new HashMap<>();

	@Override
	protected void startUp() throws Exception {
		// Initialize scheduler for delayed operations
		scheduler = Executors.newSingleThreadScheduledExecutor();

		// Clear old pending commands periodically
		scheduler.scheduleAtFixedRate(() -> {
			long now = System.currentTimeMillis();
			pendingCommands.entrySet().removeIf(entry -> now - entry.getValue() > 5000); // 5 second cleanup
		}, 10, 10, TimeUnit.SECONDS);

		// Auto-reconnect mechanism - try to reconnect every 10 seconds if disconnected
		scheduler.scheduleAtFixedRate(() -> {
			try {
				// Move client data access to client thread to avoid thread safety issues
				clientThread.invokeLater(() -> {
					if (client.getGameState() == GameState.LOGGED_IN &&
							client.getLocalPlayer() != null &&
							!ablyManager.isConnected()) {

						long now = System.currentTimeMillis();

						// Implement exponential backoff to prevent spam
						long backoffTime = Math.min(60000,
								10000 * (long) Math.pow(2, Math.min(reconnectAttempts / 3, 4)));
						if (now - lastReconnectAttempt < backoffTime) {
							return true; // Skip this attempt due to backoff
						}

						String playerName = client.getLocalPlayer().getName();
						String world = String.valueOf(client.getWorld());
						if (playerName != null && !playerName.isEmpty()) {
							lastReconnectAttempt = now;
							reconnectAttempts++;

							// Only log every 3rd attempt to reduce spam
							if (reconnectAttempts % 3 == 1) {
								log.debug("Auto-reconnect attempt #{} for player: {}", reconnectAttempts, playerName);
							}

							// Execute reconnection off client thread
							scheduler.execute(() -> {
								ablyManager.startConnection(playerName);

								// Re-subscribe to channels using captured world info
								ablyManager.subscribeToCorrectChannel("p:" + playerName, world);
								ablyManager.subscribeToCorrectChannel("w:" + world, "pub");

								// Re-subscribe to friends chat if available
								clientThread.invokeLater(() -> {
									FriendsChatManager friendsChatManager = client.getFriendsChatManager();
									if (friendsChatManager != null && friendsChatManager.getOwner() != null) {
										String friendsChat = friendsChatManager.getOwner();
										ablyManager.subscribeToCorrectChannel("f:" + friendsChat, "pub");
									}
									return true;
								});
							});
						}
					} else if (ablyManager.isConnected()) {
						// Reset reconnect attempts on successful connection
						reconnectAttempts = 0;
					}
					return true;
				});
			} catch (Exception e) {
				log.debug("Error during auto-reconnect attempt", e);
			}
		}, 10, 10, TimeUnit.SECONDS);

		// ablyManager.startConnection();
		onLoggedInGameState(); // Call this to handle turning plugin on when already logged in, should do
								// nothing on initial call

		// Setup info panel
		infoPanel = new GlobalChatInfoPanel(developerMode, ablyManager, supporterManager, client, okHttpClient, gson,
				configManager);
		log.debug("Created GlobalChatInfoPanel");

		log.debug("Global Chat plugin started successfully");

		// Add player menu item for GC Status if lookup is enabled
		if (config.showPlayerLookup()) {
			menuManager.addPlayerMenuItem("GC Status");
		}

		// Create navigation button with simple icon
		navButton = NavigationButton.builder()
				.tooltip("Global Chat Info")
				.priority(0)
				.panel(infoPanel)
				.icon(createSimpleIcon())
				.build();

		clientToolbar.addNavigation(navButton);
		log.debug("Added Global Chat navigation button to toolbar");
	}

	@Override
	protected void shutDown() throws Exception {
		// Shutdown AblyManager properly
		ablyManager.shutdown();
		shouldConnect = true;

		// Clean up scheduler - just shutdown without blocking
		if (scheduler != null) {
			scheduler.shutdown();
		}

		// Clean up supporter manager
		if (supporterManager != null) {
			supporterManager.shutdown();
		}

		// Clean up UI panel
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}

		// Clean up menu manager
		if (config.showPlayerLookup()) {
			menuManager.removePlayerMenuItem("GC Status");
		}

		// Clean up info panel
		if (infoPanel != null) {
			infoPanel.cleanup();
		}
	}

	@Subscribe
	public void onWorldChanged(WorldChanged worldChanged) {
		shouldConnect = true;

		// Force cleanup before reconnecting
		ablyManager.closeConnection();

		// Do all client data validation on client thread, then start connection
		clientThread.invokeLater(() -> {
			if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null) {
				String playerName = client.getLocalPlayer().getName();
				// All conditions satisfied, start connection after brief delay for cleanup
				scheduler.schedule(() -> {
					ablyManager.startConnection(playerName);
					// Refresh user counts after world change
					if (infoPanel != null) {
						infoPanel.refreshUserCounts();
					}
				}, 100, TimeUnit.MILLISECONDS);
			}
			return true;
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGED_IN) {
			onLoggedInGameState();
		}
		if (event.getGameState() == GameState.LOGIN_SCREEN) {
			onLoggedOut();
		}
	}

	@Subscribe
	public void onFriendsChatMemberJoined(FriendsChatMemberJoined event) {
		final FriendsChatMember member = event.getMember();
		if (member == null || member.getName() == null) {
			return;
		}
		String memberName = member.getName().replace('\u00A0', ' ').trim();
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getName() == null) {
			return;
		}
		String playerName = localPlayer.getName().replace('\u00A0', ' ').trim();

		Boolean isCurrentUser = memberName.equals(playerName);

		if (isCurrentUser) {
			FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null) {
				friendsChat = friendsChatManager.getOwner();
				ablyManager.subscribeToCorrectChannel("f:" + friendsChat, "pub");
			}
		}
	}

	private void onLoggedInGameState() {
		clientThread.invokeLater(() -> {
			// Get all client data first, then execute off client thread
			if (client.getGameState() != GameState.LOGGED_IN) {
				return true;
			}

			final Player player = client.getLocalPlayer();
			if (player == null) {
				return false;
			}
			final String name = player.getName();
			if (name == null) {
				return false;
			}
			if (name.equals("") || !shouldConnect) {
				return false;
			}

			// Get all needed client data
			String world = String.valueOf(client.getWorld());

			// All conditions satisfied, execute connection logic off client thread
			scheduler.execute(() -> {
				ablyManager.startConnection(name);
				ablyManager.subscribeToCorrectChannel("p:" + name, world);
				ablyManager.subscribeToCorrectChannel("w:" + world, "pub");
				shouldConnect = false;

				// Show update notification if needed
				showUpdateNotificationIfNeeded();
			});

			return true;
		});
	}

	private void onLoggedOut() {
		clientThread.invokeLater(() -> {
			// we return true in this case as something went wrong and somehow the state
			// isn't logged in, so we don't
			// want to keep scheduling this task.
			if (client.getGameState() != GameState.LOGIN_SCREEN) {
				return true;
			}
			shouldConnect = true;
			ablyManager.closeConnection();
			// ablyManager.startConnection();

			return true;
		});
	}

	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged event) {
		ClanChannel clanChannel = event.getClanChannel();
		boolean inClanNow = clanChannel != null;
		String channelName = (inClanNow && clanChannel != null) ? clanChannel.getName() : null;
		boolean isGuest = event.isGuest();

		if (!inClanNow) {
			String channelPrefix = isGuest ? "c:" + theGuesttheClanName
					: "c:" +
							theClanName;
			if (ablyManager != null) {
				ablyManager.closeSpecificChannel(channelPrefix);
			}

			if (isGuest) {
				theGuesttheClanName = null;
			} else {
				theClanName = null;
			}
		} else {
			String targetChannelName = "c:" + channelName;
			ablyManager.subscribeToCorrectChannel(targetChannelName, "pub");

			if (isGuest) {
				theGuesttheClanName = channelName;
			} else {
				theClanName = channelName;
			}
		}
	}

	@Subscribe
	public void onFriendsChatChanged(FriendsChatChanged event) {
		if (!event.isJoined()) {
			if (friendsChat != null) {
				ablyManager.closeSpecificChannel("f:" + friendsChat);
				friendsChat = null;
			}
		}
	}

	// Single method approach using scheduler to handle transformation detection
	@Subscribe
	public void onChatMessage(ChatMessage event) {
		String cleanedMessage = Text.removeTags(event.getMessage());
		String cleanedName = Text.sanitize(event.getName());
		boolean isPublic = event.getType().equals(ChatMessageType.PUBLICCHAT);

		boolean isLocalPlayerSendingMessage = cleanedName.equals(client.getLocalPlayer().getName());

		log.debug("Chat event - Type: {}, IsLocal: {}", event.getType(), isLocalPlayerSendingMessage);

		if (isPublic && isLocalPlayerSendingMessage) {
			log.debug("Processing local public message from: '{}'", cleanedName);

			// Check if this is a command
			if (cleanedMessage.matches("^![a-zA-Z]+.*")) {
				log.debug("Chat command detected: '{}'", cleanedMessage);

				// Store original message and schedule transformation check
				String originalMessage = cleanedMessage;
				pendingCommands.put(originalMessage, System.currentTimeMillis());

				// Capture MessageNode reference on client thread (safe)
				final MessageNode messageNode = event.getMessageNode();

				// Check for transformation immediately and retry on failure
				checkForTransformationWithRetry(originalMessage, cleanedName, messageNode, 1);

			} else {
				publishMessageToGlobalChat("w", cleanedMessage, cleanedName, "REGULAR_MESSAGE");
			}
		}

		handleAllGlobalMessages(event, cleanedMessage, cleanedName, isLocalPlayerSendingMessage);
	}

	private void checkForTransformationWithRetry(String originalMessage, String playerName, MessageNode messageNode,
			int attempt) {
		// Immediately check for transformation
		checkForTransformation(originalMessage, playerName, messageNode, attempt, (success) -> {
			if (!success && attempt < 2) {
				// Retry once after 150ms delay if first attempt failed
				scheduler.schedule(() -> {
					if (pendingCommands.containsKey(originalMessage)) {
						checkForTransformationWithRetry(originalMessage, playerName, messageNode, attempt + 1);
					}
				}, 150, TimeUnit.MILLISECONDS);
			}
		});
	}

	private void checkForTransformation(String originalMessage, String playerName, MessageNode messageNode,
			int attempt) {
		checkForTransformation(originalMessage, playerName, messageNode, attempt, null);
	}

	private void checkForTransformation(String originalMessage, String playerName, MessageNode messageNode,
			int attempt, java.util.function.Consumer<Boolean> callback) {
		try {
			log.debug("Checking transformation attempt #{} for command: '{}'", attempt, originalMessage);

			if (messageNode != null) {
				// Access MessageNode from client thread to ensure thread safety
				clientThread.invokeLater(() -> {
					try {
						String runeLiteMessage = messageNode.getRuneLiteFormatMessage();
						String currentMessage = runeLiteMessage != null ? Text.removeTags(runeLiteMessage)
								: originalMessage; // Fallback to original if no RuneLite message

						boolean transformationFound = !originalMessage.equals(currentMessage);
						if (transformationFound) {
							log.debug("Command transformed: '{}' -> '{}'", originalMessage, currentMessage);
							commandTransformations.put(originalMessage, currentMessage);
							// Send the transformed message (without color formatting)
							publishMessageToGlobalChat("w", currentMessage, playerName, "TRANSFORMATION_DETECTED");
							pendingCommands.remove(originalMessage);
							if (callback != null)
								callback.accept(true);
						} else if (attempt >= 2) {
							// Final attempt - no transformation found, send original
							publishMessageToGlobalChat("w", originalMessage, playerName, "COMMAND_NO_TRANSFORMATION");
							pendingCommands.remove(originalMessage);
							if (callback != null)
								callback.accept(true);
						} else {
							// No transformation yet, signal failure for retry
							if (callback != null)
								callback.accept(false);
						}
					} catch (Exception e) {
						log.error("Error accessing MessageNode for '{}': ", originalMessage, e);
						if (attempt >= 2) {
							publishMessageToGlobalChat("w", originalMessage, playerName, "MESSAGENODE_ACCESS_ERROR");
							pendingCommands.remove(originalMessage);
							if (callback != null)
								callback.accept(true);
						} else {
							if (callback != null)
								callback.accept(false);
						}
					}
					return true;
				});
			} else {
				if (attempt >= 2) {
					publishMessageToGlobalChat("w", originalMessage, playerName, "MESSAGENODE_NULL");
					pendingCommands.remove(originalMessage);
					if (callback != null)
						callback.accept(true);
				} else {
					if (callback != null)
						callback.accept(false);
				}
			}

		} catch (Exception e) {
			log.error("Error checking transformation for '{}': ", originalMessage, e);
			if (attempt >= 2) {
				publishMessageToGlobalChat("w", originalMessage, playerName, "TRANSFORMATION_CHECK_ERROR");
				pendingCommands.remove(originalMessage);
				if (callback != null)
					callback.accept(true);
			} else {
				if (callback != null)
					callback.accept(false);
			}
		}
	}

	private void publishMessageToGlobalChat(String type, String message, String playerName, String approach) {
		// Check for spam BEFORE publishing to save costs
		if (!ablyManager.shouldPublishMessage(message, playerName)) {
			return;
		}

		// Only use client thread to build the message with world data
		clientThread.invokeLater(() -> {
			try {
				String channel = type + ":" + String.valueOf(client.getWorld());
				ablyManager.shouldShowMessge(playerName, message, true);

				// Move actual publishing off client thread to background executor
				ablyManager.publishMessageAsync(type, message, channel, "", (success) -> {
					if (!success) {
						// Handle failure on client thread since UI operations are needed
						clientThread.invokeLater(() -> {
							removeGlobalChatIconFromRecentMessage(message);
							return true;
						});
					}
				});
			} catch (Exception e) {
				log.error("Error preparing message for publish: '{}'", message, e);
				// Remove global chat icon from the message since it failed to publish
				removeGlobalChatIconFromRecentMessage(message);
			}
			return true;
		});
	}

	private void handleAllGlobalMessages(ChatMessage event, String cleanedMessage, String cleanedName,
			boolean isLocalPlayerSendingMessage) {
		if (event.getType().equals(ChatMessageType.PUBLICCHAT) && isLocalPlayerSendingMessage) {
			// Handle icons for regular messages (non-commands) only
			if (!cleanedMessage.matches("^![a-zA-Z]+.*")) {
				// Modify message to include icons if not in read-only mode and connected
				if (!config.readOnlyMode() && ablyManager.isConnected()) {
					// Remove the original message
					final ChatLineBuffer lineBuffer = client.getChatLineMap().get(ChatMessageType.PUBLICCHAT.getType());
					lineBuffer.removeMessageNode(event.getMessageNode());

					// Get icons (match the format used for received messages)
					String accountIcon = getAccountIcon();
					String supporterIcon = supporterManager.getSupporterIcon(cleanedName);
					String symbol = accountIcon; // Start with account icon

					// Add supporter icon if user is a supporter
					if (!supporterIcon.isEmpty()) {
						if (symbol.isEmpty()) {
							symbol = supporterIcon;
						} else {
							symbol = supporterIcon + " " + symbol;
						}
					}

					// Add global chat icon
					symbol = "<img=19> " + symbol;

					// Re-add the message with icons
					client.addChatMessage(ChatMessageType.PUBLICCHAT, symbol + cleanedName, cleanedMessage, null);
				}
			}
		} else if (event.getType().equals(ChatMessageType.PRIVATECHAT)
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.PRIVATECHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
			// } else if (event.getType().equals(ChatMessageType.PRIVATECHATOUT)) {
			// if (cleanedName != null && !cleanedName.isEmpty()) {
			// if (!ablyManager.shouldPublishMessage(cleanedMessage,
			// client.getLocalPlayer().getName())) {
			// return;
			// }
			// ablyManager.shouldShowMessge(client.getLocalPlayer().getName(),
			// cleanedMessage, true);
			// ablyManager.publishMessage("p", cleanedMessage, "p:" + cleanedName,
			// cleanedName);
			// }
		} else if (event.getType().equals(ChatMessageType.FRIENDSCHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.FRIENDSCHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.CLAN_CHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.CLAN_CHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.CLAN_GUEST_CHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.CLAN_GUEST_CHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.FRIENDSCHAT) && isLocalPlayerSendingMessage) {
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return;
			}
			ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true);
			FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null) {
				ablyManager.publishMessage("f", cleanedMessage, "f:" + friendsChat,
						friendsChatManager.getName());
			}
		} else if (event.getType().equals(ChatMessageType.CLAN_CHAT) && isLocalPlayerSendingMessage) {
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return;
			}
			ablyManager.shouldShowMessge(client.getLocalPlayer().getName(), cleanedMessage, true);
			ClanChannel clanChannel = client.getClanChannel();
			if (clanChannel != null) {
				ablyManager.publishMessage("c", cleanedMessage, "c:" + clanChannel.getName(),
						clanChannel.getName());
			}
		} else if (event.getType().equals(ChatMessageType.CLAN_GUEST_CHAT) && isLocalPlayerSendingMessage) {
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return;
			}
			ablyManager.shouldShowMessge(client.getLocalPlayer().getName(), cleanedMessage, true);
			ClanChannel guestClanChannel = client.getGuestClanChannel();
			if (guestClanChannel != null) {
				ablyManager.publishMessage("c", cleanedMessage, "c:" + guestClanChannel.getName(),
						guestClanChannel.getName());
			}
		} else {
			ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true);
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked event) {
		// Handle player menu clicks from MenuManager
		if (event.getMenuAction() == MenuAction.RUNELITE_PLAYER && event.getMenuOption().equals("GC Status")) {
			String target = Text.removeTags(event.getMenuTarget());
			checkPlayerGlobalChatStatus(target);
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event) {
		// Check if player lookup feature is enabled
		if (!config.showPlayerLookup()) {
			return;
		}

		String target = Text.removeTags(event.getTarget());

		// Add option for chat messages (when right-clicking a name in any chat)
		if (event.getOption().equals("Add friend") || event.getOption().equals("Message")) {
			client.createMenuEntry(-2)
					.setOption("GC Status")
					.setTarget(event.getTarget())
					.setType(MenuAction.RUNELITE)
					.onClick(e -> checkPlayerGlobalChatStatus(target));
		}
	}

	private void checkPlayerGlobalChatStatus(String playerName) {
		// Extract just the player name from "PlayerName (level-123)" format
		String extractedName = playerName;
		if (extractedName.contains("(level-")) {
			extractedName = extractedName.substring(0, extractedName.indexOf("(level-")).trim();
		}
		final String cleanName = Text.sanitize(extractedName);

		// Show checking message on client thread
		clientThread.invokeLater(() -> {
			String checkingMessage = "<col=ff9040>Checking Global Chat status for " + cleanName + "...</col>";
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", checkingMessage, null);
			return true;
		});

		// Make async request to check status
		String apiUrl = "https://global-chat-frontend.vercel.app/api/check-player-status?playerName=" + cleanName;
		Request request = new Request.Builder()
				.url(apiUrl)
				.get()
				.build();

		okHttpClient.newCall(request).enqueue(new okhttp3.Callback() {
			@Override
			public void onFailure(okhttp3.Call call, java.io.IOException e) {
				log.error("Error checking player status for " + cleanName, e);
				clientThread.invokeLater(() -> {
					String errorMessage = "<col=ff0000>Failed to check Global Chat status for " + cleanName + "</col>";
					client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", errorMessage, null);
					return true;
				});
			}

			@Override
			public void onResponse(okhttp3.Call call, okhttp3.Response response) throws java.io.IOException {
				try {
					if (response.isSuccessful() && response.body() != null) {
						String responseBody = response.body().string();
						JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);

						boolean isConnected = jsonResponse.get("connectedToGlobalChat").getAsBoolean();

						// Show result in chat
						clientThread.invokeLater(() -> {
							String statusColor = isConnected ? "00ff00" : "ff0000";
							String statusText = isConnected ? "CONNECTED" : "NOT CONNECTED";
							String resultMessage = "<col=" + statusColor + ">Global Chat: " + cleanName + " is "
									+ statusText + "</col>";
							client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", resultMessage, null);
							return true;
						});
					} else {
						// Handle error response
						clientThread.invokeLater(() -> {
							String errorMessage = "<col=ff0000>Failed to check Global Chat status for " + cleanName
									+ " (HTTP " + response.code() + ")</col>";
							client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", errorMessage, null);
							return true;
						});
					}
				} catch (Exception e) {
					log.error("Error parsing response for " + cleanName, e);
					clientThread.invokeLater(() -> {
						String errorMessage = "<col=ff0000>Failed to check Global Chat status for " + cleanName
								+ "</col>";
						client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", errorMessage, null);
						return true;
					});
				} finally {
					response.close();
				}
			}
		});
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event) {

		if ("chatFilterCheck".equals(event.getEventName())) {

			int[] intStack = client.getIntStack();
			int intStackSize = client.getIntStackSize();
			// Extract the message type and message content from the event.
			final int messageType = intStack[intStackSize - 2];
			final int messageId = intStack[intStackSize - 1];

			final MessageNode messageNode = client.getMessages().get(messageId);
			final String name = messageNode.getName();
			if (name == null) {
				return;
			}
			String cleanedName = Text.sanitize(name);
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer == null || localPlayer.getName() == null) {
				return;
			}
			boolean isLocalPlayerSendingMessage = cleanedName.equals(localPlayer.getName());

			boolean shouldConsiderHiding = !isLocalPlayerSendingMessage
					&& ChatMessageType.of(messageType) == ChatMessageType.PUBLICCHAT;

			if (shouldConsiderHiding && ablyManager.isUnderCbLevel(cleanedName)) {
				intStack[intStackSize - 3] = 0;
			}

		}

	}

	@Subscribe(priority = -2) // conflicts with chat filter plugin without this priority
	public void onOverheadTextChanged(OverheadTextChanged event) {
		if (!(event.getActor() instanceof Player) || event.getActor().getName() == null)
			return;
		String cleanedName = Text.sanitize(event.getActor().getName());
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getName() == null) {
			return;
		}
		boolean isLocalPlayerSendingMessage = cleanedName.equals(localPlayer.getName());

		if (!isLocalPlayerSendingMessage && ablyManager.isUnderCbLevel(cleanedName)) {
			event.getActor().setOverheadText("");
		}

	}

	private void showUpdateNotificationIfNeeded() {
		// Define the current version - update this when you want to show a new
		// notification
		String currentVersion = "v2.3.0";

		// Check if notification for this version has been shown
		String lastNotificationVersion = config.updateNotificationShown();

		if (!currentVersion.equals(lastNotificationVersion)) {
			// Show in-game chat message directly
			ablyManager.showUpdateNotification(
					"<col=00ff00>Global Chat v2.3 is here!</col> " +
							"<col=ff9040>New: Right-click any player to check if they're connected to Global Chat! Plus chat commands work seamlessly (!task, !kc), live connection status, see who's online in the info panel, and read-only mode option. "
							+
							"Support on Patreon to unlock higher message limits!</col>");

			// Mark this version as notified
			configManager.setConfiguration("globalchat", "updateNotificationShown", currentVersion);
		}
	}

	@Provides
	GlobalChatConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(GlobalChatConfig.class);
	}

	private void removeGlobalChatIconFromRecentMessage(String message) {
		try {
			// Don't show error messages if read-only mode is enabled
			if (config.readOnlyMode()) {
				return;
			}

			// Rate limiting: only show error message every 30 minutes to prevent spam
			long now = System.currentTimeMillis();
			if (now - lastFailedSendMessageTime < FAILED_SEND_MESSAGE_COOLDOWN) {
				return; // Skip showing message if within cooldown period
			}

			if (client.getGameState() == GameState.LOGGED_IN) {
				lastFailedSendMessageTime = now;
				client.addChatMessage(ChatMessageType.GAMEMESSAGE, "",
						"<col=ff0000>Message failed to send to Global Chat</col>", null);
			}
		} catch (Exception e) {
			log.error("Error notifying about failed message publish", e);
		}
	}

	private String getAccountIcon() {
		if (client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
			return "<img=33>";
		}
		switch (client.getAccountType()) {
			case IRONMAN:
				return "<img=2>";
			case HARDCORE_IRONMAN:
				return "<img=10>";
			case ULTIMATE_IRONMAN:
				return "<img=3>";
			default:
				return "";
		}
	}

	private BufferedImage createSimpleIcon() {
		try {
			// Load the icon from project root
			BufferedImage image = ImageIO.read(getClass().getResourceAsStream("/icon.png"));

			// Resize to 16x16 if needed
			if (image.getWidth() != 16 || image.getHeight() != 16) {
				BufferedImage resized = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
				Graphics2D g2 = resized.createGraphics();
				g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
				g2.drawImage(image, 0, 0, 16, 16, null);
				g2.dispose();
				return resized;
			}

			return image;
		} catch (Exception e) {
			log.error("Failed to load icon from project root", e);
			return null;
		}
	}

	// @Subscribe(priority = -2)
	// public void onClientTick(ClientTick clientTick) {
	// if (client.isMenuOpen()) {
	// return;
	// }

	// MenuEntry[] menuEntries = client.getMenuEntries();

	// for (MenuEntry entry : menuEntries) {
	// MenuAction type = entry.getType();

	// if (type == WALK
	// || type == WIDGET_TARGET_ON_PLAYER
	// || type == ITEM_USE_ON_PLAYER
	// || type == PLAYER_FIRST_OPTION
	// || type == PLAYER_SECOND_OPTION
	// || type == PLAYER_THIRD_OPTION
	// || type == PLAYER_FOURTH_OPTION
	// || type == PLAYER_FIFTH_OPTION
	// || type == PLAYER_SIXTH_OPTION
	// || type == PLAYER_SEVENTH_OPTION
	// || type == PLAYER_EIGHTH_OPTION
	// || type == RUNELITE_PLAYER) {
	// Player[] players = client.getCachedPlayers();
	// Player player = null;

	// int identifier = entry.getIdentifier();

	// // 'Walk here' identifiers are offset by 1 because the default
	// // identifier for this option is 0, which is also a player index.
	// if (type == WALK) {
	// identifier--;
	// }

	// if (identifier >= 0 && identifier < players.length) {
	// player = players[identifier];

	// }

	// if (player == null) {
	// return;
	// }

	// String oldTarget = entry.getTarget();
	// String newTarget = decorateTarget(oldTarget, player.getName());

	// entry.setTarget(newTarget);
	// }

	// }
	// }

}

package com.globalchat;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@Singleton
public class SupporterManager {
    private static final String SUPPORTERS_URL = "https://global-chat-plugin.vercel.app/api/supporters";
    private static final long REFRESH_INTERVAL_MINUTES = 10;

    private final Gson gson;
    private final OkHttpClient httpClient;
    private final ScheduledExecutorService scheduler;
    private List<Supporter> supporters = new ArrayList<>();
    private int totalSupport = 0;
    private String lastUpdated = "";

    @Inject
    public SupporterManager(Gson gson, OkHttpClient httpClient) {
        this.gson = gson;
        this.httpClient = httpClient;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();

        // Initial fetch
        fetchSupporters();

        // Schedule periodic refresh
        scheduler.scheduleAtFixedRate(this::fetchSupporters,
                REFRESH_INTERVAL_MINUTES, REFRESH_INTERVAL_MINUTES, TimeUnit.MINUTES);
    }

    public void shutdown() {
        scheduler.shutdown();
    }

    public List<Supporter> getSupporters() {
        return new ArrayList<>(supporters);
    }

    public int getTotalSupport() {
        return totalSupport;
    }

    public String getLastUpdated() {
        return lastUpdated;
    }

    public boolean isSupporter(String username) {
        if (username == null)
            return false;
        return supporters.stream()
                .anyMatch(supporter -> supporter.name != null &&
                        supporter.name.equalsIgnoreCase(username.trim()));
    }

    public String getSupporterIcon(String username) {
        if (username == null)
            return "";

        return supporters.stream()
                .filter(supporter -> supporter.name != null &&
                        supporter.name.equalsIgnoreCase(username.trim()))
                .findFirst()
                .map(this::getTierIcon)
                .orElse("");
    }

    private String getTierIcon(Supporter supporter) {
        // Use RuneScape item icons for different tiers
        if (supporter.amount >= 50) {
            return "<img=314> "; // Gold
        } else if (supporter.amount >= 20) {
            return "<img=312> "; // Silver
        } else if (supporter.amount >= 5) {
            return "<img=313> "; // Bronze
        } else {
            return ""; // No icon
        }
    }

    private void fetchSupporters() {
        Request request = new Request.Builder()
                .url(SUPPORTERS_URL)
                .build();

        httpClient.newCall(request).enqueue(new okhttp3.Callback() {
            @Override
            public void onFailure(okhttp3.Call call, java.io.IOException e) {
                log.error("Error fetching supporters", e);
            }

            @Override
            public void onResponse(okhttp3.Call call, Response response) throws java.io.IOException {
                try {
                    if (response.isSuccessful() && response.body() != null) {
                        String responseBody = response.body().string();
                        parseSupportersResponse(responseBody);
                        log.debug("Successfully fetched {} supporters", supporters.size());
                    } else {
                        log.warn("Failed to fetch supporters: HTTP {}", response.code());
                    }
                } finally {
                    response.close();
                }
            }
        });
    }

    private void parseSupportersResponse(String json) {
        try {
            Type responseType = new TypeToken<SupportersResponse>() {
            }.getType();
            SupportersResponse response = gson.fromJson(json, responseType);

            if (response != null && response.supporters != null) {
                this.supporters = response.supporters;
                this.totalSupport = response.totalSupport;
                this.lastUpdated = response.lastUpdated;
            }
        } catch (Exception e) {
            log.error("Error parsing supporters response", e);
        }
    }

    private static class SupportersResponse {
        public List<Supporter> supporters;
        public int totalSupport;
        public String lastUpdated;
    }
}
package com.globalchat;

public class Supporter {
    public String name;
    public String tier;
    public int amount;
    public boolean isPublic;

    public Supporter(String name, String tier, int amount, boolean isPublic) {
        this.name = name;
        this.tier = tier;
        this.amount = amount;
        this.isPublic = isPublic;
    }

    public String getDisplayName() {
        return isPublic ? name : "Anonymous";
    }

    public String getTierDisplay() {
        return tier + " Supporter";
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

public class GlobalChatMessage {
	public String username;
	public String symbol;
	public String message;
	public String global;
	public String to;

	public String type;

	public GlobalChatMessage(String username, String symbol, String message, String type, String to) {
		this.username = username;
		this.symbol = symbol;
		this.message = message;
		this.type = type;
		this.to = to;

	}
}

package com.globalchat;

import com.globalchat.GlobalChatPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GlobalChatTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(GlobalChatPlugin.class);
		RuneLite.main(args);
	}
}
