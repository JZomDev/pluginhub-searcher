/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
@ConfigGroup("globalchat")
public interface GlobalChatConfig extends Config {

    @ConfigItem(
            keyName = "readOnlyMode",
            name = "Read-Only Mode",
            description = "Activating this allows you to view global chat messages, but your typed messages will not be broadcast globally, similar to if the plugin was off.",
            position = 1
    )
    default boolean readOnlyMode() {
        return false;
    }
    @ConfigItem(
        keyName = "filterOutFromBelowCblvl",
        name = "Hide Msgs < CB Level",
        description = "This hides all messages from users below the specified combat level. It's usedful for blocking the low level spam bots",
        position = 3
)
@Range(
    min = 3,
    max = 126
)
default int filterOutFromBelowCblvl() {
    return 4;
}

@ConfigItem(
    keyName = "updateNotificationShown",
    name = "",
    description = "",
    hidden = true
)
default String updateNotificationShown() {
    return "";
}

}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridBagLayout;
import java.awt.GridBagConstraints;
import java.awt.Insets;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URI;
import java.util.List;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.BorderFactory;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.SwingConstants;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GlobalChatInfoPanel extends PluginPanel {

    private static final String PATREON_URL = "https://patreon.com/global_chat_plugin";
    private static final String GITHUB_URL = "https://github.com/RusseII/region-chat";
    private static final String DISCORD_URL = "https://discord.gg/runelite";

    private final ConfigManager configManager;
    private final boolean developerMode;
    private final AblyManager ablyManager;
    private final SupporterManager supporterManager;

    public GlobalChatInfoPanel() {
        super(false);
        this.configManager = null;
        this.developerMode = false;
        this.ablyManager = null;
        this.supporterManager = null;
        init();
    }

    public GlobalChatInfoPanel(boolean developerMode, AblyManager ablyManager, SupporterManager supporterManager) {
        super(false);
        this.configManager = null;
        this.developerMode = developerMode;
        this.ablyManager = ablyManager;
        this.supporterManager = supporterManager;
        init();
    }

    private void init() {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(15, 15, 15, 15));
        add(createContent(), BorderLayout.CENTER);
    }

    private JPanel createContent() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.NORTH;

        // Title
        panel.add(createTitle(), gbc);

        // Spacing
        gbc.gridy++;
        gbc.insets = new Insets(15, 0, 0, 0);

        // Settings button
        panel.add(createSettingsButton(), gbc);

        gbc.gridy++;
        panel.add(createSupportSection(), gbc);

        // Add supporters section if we have the manager
        if (supporterManager != null) {
            gbc.gridy++;
            panel.add(createSupportersSection(), gbc);
        }

        gbc.gridy++;
        panel.add(createLinks(), gbc);

        // Debug section if enabled
        if (developerMode && ablyManager != null) {
            gbc.gridy++;
            panel.add(createDebugSection(), gbc);
        }

        // Push everything to top
        gbc.gridy++;
        gbc.weighty = 1.0;
        panel.add(Box.createVerticalGlue(), gbc);

        return panel;
    }

    private JPanel createTitle() {
        JPanel titlePanel = new JPanel(new BorderLayout());
        titlePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        titlePanel.setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(0, 0, 2, 0, ColorScheme.BRAND_ORANGE),
                new EmptyBorder(5, 0, 8, 0)));

        JLabel title = new JLabel("Global Chat", SwingConstants.CENTER);
        title.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 18f));
        title.setForeground(ColorScheme.BRAND_ORANGE);
        titlePanel.add(title, BorderLayout.CENTER);

        return titlePanel;
    }

    private JPanel createSettingsButton() {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton settingsBtn = new JButton("Open Plugin Settings");
        settingsBtn.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        settingsBtn.setForeground(Color.WHITE);
        settingsBtn.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
        settingsBtn.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR.darker(), 1),
                new EmptyBorder(10, 20, 10, 20)));
        settingsBtn.setFocusPainted(false);
        settingsBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

        // Add hover effect
        settingsBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                settingsBtn.setBackground(ColorScheme.MEDIUM_GRAY_COLOR.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                settingsBtn.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }
        });

        settingsBtn.addActionListener(e -> {
            // Show helpful instructions since we can't directly open settings
            javax.swing.JOptionPane.showMessageDialog(
                    this,
                    "To access plugin settings:\n\n" +
                            "1. Click the Settings button in RuneLite's sidebar\n" +
                            "2. Search for 'Global Chat' or scroll to find it\n" +
                            "3. Configure your preferences there\n\n" +
                            "Available settings:\n" +
                            "- Read-Only Mode\n" +
                            "- Combat Level Filter",
                    "Plugin Settings Location",
                    javax.swing.JOptionPane.INFORMATION_MESSAGE);
        });

        panel.add(settingsBtn, BorderLayout.CENTER);
        return panel;
    }

    private JPanel createSupportSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Keep Global Chat Running!");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // Warning text
        JLabel warningText = new JLabel(
                "<html><b style='color: #ff6b6b;'>WARNING: Service will go offline when limits are reached!</b></html>");
        warningText.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        gbc.insets = new Insets(0, 0, 10, 0);
        panel.add(warningText, gbc);
        gbc.gridy++;

        // Current status
        JLabel currentStatus = new JLabel("<html>" +
                "<b>Current Status and Limits:</b><br>" +
                "- <b>Connection limit:</b> 200 concurrent users<br>" +
                "- <b>Message limit:</b> 6 million per month<br>" +
                "- <b>Channel limit:</b> 200 active channels" +
                "</html>");
        currentStatus.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        currentStatus.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 15, 0);
        panel.add(currentStatus, gbc);
        gbc.gridy++;

        // Benefits text
        JLabel benefitsText = new JLabel("<html>" +
                "<b style='color: #4CAF50;'>Your support will:</b><br>" +
                "- Increase connection limits (more players can chat)<br>" +
                "- Increase message limits (no more outages)<br>" +
                "- Keep the service running 24/7<br>" +
                "- Enable new features and improvements" +
                "</html>");
        benefitsText.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        benefitsText.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 15, 0);
        panel.add(benefitsText, gbc);
        gbc.gridy++;

        // Patreon button
        JButton patreonBtn = new JButton("Support on Patreon");
        patreonBtn.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        patreonBtn.setForeground(Color.WHITE);
        patreonBtn.setBackground(ColorScheme.BRAND_ORANGE);
        patreonBtn.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE.darker(), 1),
                new EmptyBorder(12, 20, 12, 20)));
        patreonBtn.setFocusPainted(false);
        patreonBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
        patreonBtn.addActionListener(e -> openURL(PATREON_URL));
        
        // Add hover effect
        patreonBtn.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                patreonBtn.setBackground(ColorScheme.BRAND_ORANGE.brighter());
            }
            @Override
            public void mouseExited(MouseEvent e) {
                patreonBtn.setBackground(ColorScheme.BRAND_ORANGE);
            }
        });
        
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(patreonBtn, gbc);

        return panel;
    }

    private JPanel createSupportersSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Amazing Supporters");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        List<Supporter> supporters = supporterManager.getSupporters();

        if (supporters.isEmpty()) {
            JLabel noSupportersLabel = new JLabel("<html><i>No supporters yet - be the first!</i></html>");
            noSupportersLabel.setFont(FontManager.getRunescapeFont().deriveFont(11f));
            noSupportersLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
            gbc.insets = new Insets(0, 0, 0, 0);
            panel.add(noSupportersLabel, gbc);
        } else {
            // Display supporters by tier
            for (int i = 0; i < supporters.size(); i++) {
                Supporter supporter = supporters.get(i);
                JPanel supporterPanel = createSupporterPanel(supporter);
                gbc.insets = new Insets(0, 0, i == supporters.size() - 1 ? 0 : 4, 0);
                panel.add(supporterPanel, gbc);
                gbc.gridy++;
            }
        }

        return panel;
    }

    private JPanel createSupporterPanel(Supporter supporter) {
        JPanel panel = new JPanel(new BorderLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
            BorderFactory.createLineBorder(getTierColor(supporter.tier), 1),
            new EmptyBorder(8, 12, 8, 12)));

        JLabel nameLabel = new JLabel(supporter.getDisplayName());
        nameLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 11f));
        nameLabel.setForeground(Color.WHITE);

        JLabel tierLabel = new JLabel(supporter.getTierDisplay());
        tierLabel.setFont(FontManager.getRunescapeFont().deriveFont(10f));
        tierLabel.setForeground(getTierColor(supporter.tier));

        JPanel textPanel = new JPanel(new BorderLayout());
        textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textPanel.add(nameLabel, BorderLayout.NORTH);
        textPanel.add(tierLabel, BorderLayout.SOUTH);

        // Add tier badge
        JLabel badge = new JLabel(getTierBadge(supporter.tier));
        badge.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 10f));
        badge.setForeground(getTierColor(supporter.tier));

        panel.add(textPanel, BorderLayout.CENTER);
        panel.add(badge, BorderLayout.EAST);

        return panel;
    }

    private Color getTierColor(String tier) {
        switch (tier.toLowerCase()) {
            case "bronze":
                return new Color(205, 127, 50); // Bronze
            case "silver":
                return new Color(192, 192, 192); // Silver
            case "gold":
                return new Color(255, 215, 0); // Gold
            case "platinum":
                return new Color(229, 228, 226); // Platinum
            default:
                return ColorScheme.LIGHT_GRAY_COLOR;
        }
    }

    private String getTierBadge(String tier) {
        switch (tier.toLowerCase()) {
            case "bronze":
                return "★";
            case "silver":
                return "★★";
            case "gold":
                return "★★★";
            case "platinum":
                return "★★★★";
            default:
                return "★";
        }
    }

    private JPanel createLinks() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Community & Help");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // GitHub button
        JButton githubBtn = createStyledButton("View on GitHub", ColorScheme.MEDIUM_GRAY_COLOR);
        githubBtn.addActionListener(e -> openURL(GITHUB_URL));
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(githubBtn, gbc);
        gbc.gridy++;

        // Issues button
        JButton issuesBtn = createStyledButton("Report Issues", ColorScheme.MEDIUM_GRAY_COLOR);
        issuesBtn.addActionListener(e -> openURL(GITHUB_URL + "/issues"));
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(issuesBtn, gbc);

        return panel;
    }

    private JPanel createDebugSection() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        // Title
        JLabel titleLabel = new JLabel("Debug Tools");
        titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
        titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(titleLabel, gbc);
        gbc.gridy++;

        // Debug info
        JLabel debugInfo = new JLabel("<html>Test error message display (developer mode only)</html>");
        debugInfo.setFont(FontManager.getRunescapeFont().deriveFont(11f));
        debugInfo.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        gbc.insets = new Insets(0, 0, 12, 0);
        panel.add(debugInfo, gbc);
        gbc.gridy++;

        // Test capacity button
        JButton testCapacityBtn = createStyledButton("Test Capacity Error", ColorScheme.MEDIUM_GRAY_COLOR);
        testCapacityBtn.addActionListener(e -> ablyManager.testCapacityError());
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(testCapacityBtn, gbc);
        gbc.gridy++;

        // Test connection button
        JButton testConnectionBtn = createStyledButton("Test Connection Error", ColorScheme.MEDIUM_GRAY_COLOR);
        testConnectionBtn.addActionListener(e -> ablyManager.testConnectionError());
        gbc.insets = new Insets(0, 0, 8, 0);
        panel.add(testConnectionBtn, gbc);
        gbc.gridy++;
        
        // Test update button
        JButton testUpdateBtn = createStyledButton("Test Update Notification", ColorScheme.MEDIUM_GRAY_COLOR);
        testUpdateBtn.addActionListener(e -> ablyManager.testUpdateNotification());
        gbc.insets = new Insets(0, 0, 0, 0);
        panel.add(testUpdateBtn, gbc);

        return panel;
    }

    private JPanel createSectionContainer(String title) {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setBorder(new CompoundBorder(
                BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
                new EmptyBorder(15, 15, 15, 15)));

        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.weightx = 1.0;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.anchor = GridBagConstraints.WEST;

        if (title != null) {
            JLabel titleLabel = new JLabel(title);
            titleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));
            titleLabel.setForeground(ColorScheme.BRAND_ORANGE);
            gbc.insets = new Insets(0, 0, 12, 0);
            panel.add(titleLabel, gbc);
            gbc.gridy++;
        }

        return panel;
    }

    private JButton createStyledButton(String text, Color backgroundColor) {
        JButton button = new JButton(text);
        button.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 12f));
        button.setForeground(Color.WHITE);
        button.setBackground(backgroundColor);
        button.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(backgroundColor.darker(), 1),
                new EmptyBorder(12, 20, 12, 20)));
        button.setFocusPainted(false);
        button.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));

        // Add hover effect
        Color originalColor = backgroundColor;
        button.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                button.setBackground(originalColor.brighter());
            }

            @Override
            public void mouseExited(MouseEvent e) {
                button.setBackground(originalColor);
            }
        });

        return button;
    }

    private void openURL(String url) {
        try {
            if (Desktop.isDesktopSupported()) {
                Desktop.getDesktop().browse(new URI(url));
            }
        } catch (Exception e) {
            log.error("Failed to open URL: " + url, e);
        }
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import java.util.HashSet;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import javax.inject.Named;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.realtime.ChannelState;
import io.ably.lib.realtime.CompletionListener;
import io.ably.lib.types.AblyException;
import io.ably.lib.types.ChannelOptions;
import io.ably.lib.types.ClientOptions;
import io.ably.lib.types.Message;
import io.ably.lib.types.Param;
import java.util.Base64;

import java.util.Set;
import java.util.HashMap;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.WorldType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;
import net.runelite.api.Player;
import net.runelite.api.Constants;
import net.runelite.api.Friend;
import lombok.extern.slf4j.Slf4j;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;

@Slf4j
@Singleton
public class AblyManager {

	public static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

	private static final int OVERHEAD_TEXT_TICK_TIMEOUT = 5;
	private static final int CYCLES_FOR_OVERHEAD_TEXT = OVERHEAD_TEXT_TICK_TIMEOUT * CYCLES_PER_GAME_TICK;

	private final Client client;
	private final SupporterManager supporterManager;

	@Inject
	Gson gson;


	private final Map<String, String> previousMessages = new HashMap<>();

	private final HashMap<String, Integer> playerCombats = new HashMap<>();

	private boolean changingChannels;

	@Inject
	ChatMessageManager chatMessageManager;

	private final GlobalChatConfig config;
	private final boolean developerMode;

	private AblyRealtime ablyRealtime;
	private volatile boolean isConnecting = false;
	private final Map<String, Long> channelLastActivity = new HashMap<>();
	private final Map<String, Long> lastMessageTime = new HashMap<>();
	private long lastErrorMessageTime = 0;
	private static final long ERROR_MESSAGE_COOLDOWN = 300000; // 5 minutes

	@Inject
	public AblyManager(Client client, GlobalChatConfig config, @Named("developerMode") boolean developerMode, SupporterManager supporterManager) {
		this.client = client;
		this.config = config;
		this.developerMode = developerMode;
		this.supporterManager = supporterManager;
	}

	public void startConnection(String playerName) {
		// Prevent multiple concurrent connections
		if (isConnecting) {
			log.debug("Connection already in progress, skipping");
			return;
		}
		
		// Check if already connected
		if (ablyRealtime != null) {
			try {
				if (ablyRealtime.connection.state == io.ably.lib.realtime.ConnectionState.connected) {
					log.debug("Already connected, skipping");
					return;
				}
			} catch (Exception e) {
				log.debug("Error checking connection state", e);
			}
		}
		
		isConnecting = true;
		try {
			setupAblyInstances(playerName);
		} catch (Exception e) {
			handleAblyError(e);
		} finally {
			isConnecting = false;
		}
	}

	public void closeSpecificChannel(String channelName) {
		try {
			ablyRealtime.channels.get(channelName).detach();
			channelLastActivity.remove(channelName);
		} catch (AblyException err) {
			log.error("error", err);
		}
	}
	
	public boolean isConnected() {
		if (ablyRealtime == null) return false;
		try {
			return ablyRealtime.connection.state == io.ably.lib.realtime.ConnectionState.connected;
		} catch (Exception e) {
			log.debug("Error checking connection state", e);
			return false;
		}
	}

	public void cleanupInactiveChannels() {
		if (ablyRealtime == null) return;
		
		long now = System.currentTimeMillis();
		channelLastActivity.entrySet().removeIf(entry -> {
			if (now - entry.getValue() > 300000) { // 5 minutes
				try {
					ablyRealtime.channels.get(entry.getKey()).detach();
					log.debug("Cleaned up inactive channel: " + entry.getKey());
				} catch (Exception e) {
					log.debug("Error cleaning up channel: " + entry.getKey(), e);
				}
				return true;
			}
			return false;
		});
	}
	
	private void markChannelActive(String channelName) {
		channelLastActivity.put(channelName, System.currentTimeMillis());
	}

	public void closeConnection() {
		if (ablyRealtime != null) {
			try {
				// Explicitly close all channels first
				try {
					// Just force close - channel iteration not available in this API
					log.debug("Forcing connection close");
				} catch (Exception e) {
					log.debug("Error during channel cleanup", e);
				}
				
				// Force close connection
				ablyRealtime.close();
				
				log.debug("Connection properly closed");
				
			} catch (Exception e) {
				log.error("Error closing connection", e);
			} finally {
				ablyRealtime = null;
			}
		}
	}

	public boolean isUnderCbLevel(String username) {
		String cleanedName = Text.sanitize(username);
		Integer cachedCbLevel = playerCombats.get(cleanedName);
		if (cachedCbLevel != null) {
			return cachedCbLevel < config.filterOutFromBelowCblvl();
		}

		for (Player player : client.getPlayers()) {
			if (player != null && player.getName() != null && cleanedName.equals(player.getName())) {
				playerCombats.put(cleanedName, player.getCombatLevel());
				return player.getCombatLevel() < config.filterOutFromBelowCblvl();
			}
		}
		return false; // If no matching player is found, return false.
	}

	public boolean isSpam(String message) {

		Set<String> spamMessages = new HashSet<>();
		spamMessages
				.addAll(Arrays.asList(
						"In the name of Saradomin, protector of us all, I now join you in the eyes of Saradomin.",
						"Thy cause was false, thy skills did lack; See you in Lumbridge when you get back.",
						"Go in peace in the name of Saradomin; May his glory shine upon you like the sun.",
						"The currency of goodness is honour; It retains its value through scarcity. This is Saradomin's wisdom.",
						"Two great warriors, joined by hand, to spread destruction across the land. In Zamorak's name, now two are one.",
						"The weak deserve to die, so the strong may flourish. This is the creed of Zamorak.",
						"May your bloodthirst never be sated, and may all your battles be glorious. Zamorak bring you strength.",
						"There is no opinion that cannot be proven true...by crushing those who choose to disagree with it. Zamorak give me strength!",
						"Battles are not lost and won; They simply remove the weak from the equation. Zamorak give me strength!",
						"Those who fight, then run away, shame Zamorak with their cowardice. Zamorak give me strength!",
						"Battle is by those who choose to disagree with it. Zamorak give me strength!",
						"Strike fast, strike hard, strike true: The strength of Zamorak will be with you. Zamorak give me strength!",
						"Light and dark, day and night, balance arises from contrast. I unify thee in the name of Guthix.",
						"Thy death was not in vain, for it brought some balance to the world. May Guthix bring you rest.",
						"May you walk the path, and never fall, for Guthix walks beside thee on thy journey. May Guthix bring you peace.",
						"The trees, the earth, the sky, the waters; All play their part upon this land. May Guthix bring you balance.",
						"Big High War God want great warriors. Because you can make more... I bind you in Big High War God name.",
						"You not worthy of Big High War God; you die too easy.",
						"Big High War God make you strong... so you smash enemies.",
						"War is best, peace is for weak. If you not worthy of Big High War God... you get made dead soon.",
						"As ye vow to be at peace with each other... and to uphold high values of morality and friendship... I now pronounce you united in the law of Armadyl.",
						"Thou didst fight true... but the foe was too great. May thy return be as swift as the flight of Armadyl.",
						"For thy task is lawful... May the blessing of Armadyl be upon thee.",
						"Peace shall bring thee wisdom; Wisdom shall bring thee peace. This is the law of Armadyl.",
						"Ye faithful and loyal to the Great Lord... May ye together succeed in your deeds. Ye are now joined by the greatest power.",
						"Thy faith faltered, no power could save thee. Like the Great Lord, one day you shall rise again.",
						"By day or night, in defeat or victory... the power of the Great Lord be with thee.",
						"Follower of the Great Lord be relieved: One day your loyalty will be rewarded. Power to the Great Lord!",
						"Just say neigh to gambling!", "Eww stinky!", "I will burn with you.",
						"Burn with me!", "Here fishy fishies!",
						"For Camelot!", "Raarrrrrgggggghhhhhhh", "Taste vengeance!", "Smashing!", "*yawn*"));
		// Messages from tobMistakeTrackerSpam
		spamMessages.addAll(Arrays.asList(
				"I'm planking!", // Note: Only need to add "I'm planking!" once
				"I'm drowning in Maiden's blood!",
				"I'm stunned!",
				"Bye!",
				"I'm eating cabbages!",
				"I can't count to four!",
				"I'm PKing my team!",
				"I was stuck in a web!",
				"I'm healing Verzik!"));
		// Messages from TOAMistakeTrackerSpam
		spamMessages.addAll(Arrays.asList(
				"Argh! It burns!",
				"Come on and slam!",
				"Ah! It burns!",
				"Embrace Darkness!",
				"I'm too slow!",
				"I'm griefing!",
				"?",
				"This jug feels a little light...",
				"I'm drowning in acid!",
				"I'm on a blood cloud!",
				"Nihil!",
				"I'm surfing!",
				"I'm exploding!",
				"The swarms are going in!",
				"I've been hatched!",
				"I'm fuming!",
				"The sky is falling!",
				"I've been corrupted!",
				"It's venomous!",
				"Come on and slam!|And welcome to the jam!",
				"I got rocked!",
				"They see me rollin'...",
				"It's raining!",
				"Who put that there?",
				"I'm going down!",
				"I'm disco-ing!",
				"I'm dancing!",
				"I'm winded!",
				"I'm getting bombed!",
				"I'm in jail!",
				"What even was that attack?",
				"I'm tripping!"));

		// Check if the message is in the set
		return spamMessages.contains(message);
	}

	public void publishMessage(String t, String message, String channel, String to) {
		try {

			Channel currentChannel;
			if (t.equals("p")) {
				Friend friend = client.getFriendContainer().findByName(to);
				String key = String.valueOf(friend.getWorld());
				String paddedKeyString = padKey(key, 16); // Ensure the key is 16 bytes long
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				ChannelOptions options = ChannelOptions.withCipherKey(base64EncodedKey);
				currentChannel = ablyRealtime.channels.get(channel, options);

			} else {
				String paddedKeyString = padKey("pub", 16); // Ensure the key is 16 bytes long
				String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
				ChannelOptions options = ChannelOptions.withCipherKey(base64EncodedKey);
				currentChannel = ablyRealtime.channels.get(channel, options);

			}
			if (client.getLocalPlayer() == null) {
				return;
			}
			if (config.readOnlyMode()) {
				return;
			}

			String username = Text.removeTags(client.getLocalPlayer().getName());
			JsonObject msg = io.ably.lib.util.JsonUtils.object()
					.add("symbol", getAccountIcon())
					.add("username", username)
					.add("message", message).add("type", t).add("to", to).toJson();
			currentChannel.publish("event", msg);
		} catch (AblyException err) {
			log.error("Ably publish error", err);
			handleAblyError(err);
		}
	}

	public void handleMessage(Message message) {
		if (client.getGameState() == GameState.LOGGED_IN) {
			// Mark channel as active when receiving messages
			markChannelActive(message.name);
			handleAblyMessage(message);
		}
	}


	private String getValidAccountIcon(String accountIcon) {
		if (accountIcon.equals("<img=2>"))
			return accountIcon;
		if (accountIcon.equals("<img=10>"))
			return accountIcon;
		if (accountIcon.equals("<img=3>"))
			return accountIcon;
		// Allow supporter icons
		if (accountIcon.equals("<img=313> "))
			return accountIcon;
		if (accountIcon.equals("<img=312> "))
			return accountIcon;
		if (accountIcon.equals("<img=314> "))
			return accountIcon;
		return "";
	}

	private void handleAblyMessage(Message message) {
		if (client.getGameState() != GameState.LOGGED_IN) {
			return;
		}

		GlobalChatMessage msg = gson.fromJson((JsonElement) message.data, GlobalChatMessage.class);
		String username = Text.removeTags(msg.username);
		String receivedMsg = Text.removeTags(msg.message);
		if (!shouldShowMessge(username, receivedMsg, false)) {
			return;
		}
		if (!shouldShowCurrentMessage(receivedMsg, username)) {
			return;
		}

		String symbol = getValidAccountIcon(msg.symbol);
		
		// Add supporter icon if user is a supporter
		String supporterIcon = supporterManager.getSupporterIcon(username);
		if (!supporterIcon.isEmpty()) {
			if (symbol.isEmpty()) {
				symbol = supporterIcon;
			} else {
				symbol = supporterIcon + " " + symbol;
			}
		}

		if (msg.type.equals("w")) {
			symbol = "<img=19> " + symbol;
		}

		final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
				.append(receivedMsg);

		if (username.length() > 12) {
			return;
		}
		if (msg.type.equals("p") && !username.equals(client.getLocalPlayer().getName())
				&& msg.to.equals(client.getLocalPlayer().getName())) {

			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.PRIVATECHAT)
					.name(symbol + username)
					.runeLiteFormattedMessage(chatMessageBuilder.build())
					.build());
		} else if (msg.type.equals("w")) {

			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.PUBLICCHAT)
					.name(symbol + username)
					.runeLiteFormattedMessage(chatMessageBuilder.build())
					.build());

			for (Player player : client.getPlayers()) {
				if (player != null &&
						player.getName() != null &&
						username.equals(player.getName())) {
					player.setOverheadText(receivedMsg);
					player.setOverheadCycle(CYCLES_FOR_OVERHEAD_TEXT);

					return;
				}
			}

		}

		else if (msg.type.equals("f") && !username.equals(client.getLocalPlayer().getName())) {

			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.FRIENDSCHAT)
					.name(symbol + username).sender(msg.to)
					.runeLiteFormattedMessage(chatMessageBuilder.build())
					.build());
		} else if (msg.type.equals("c") && !username.equals(client.getLocalPlayer().getName())) {

			chatMessageManager.queue(QueuedMessage.builder()
					.type(ChatMessageType.CLAN_CHAT)
					.name(symbol + username).sender(msg.to)
					.runeLiteFormattedMessage(chatMessageBuilder.build())
					.build());
		}

	}

	// Checks for bits someone could insert in to be icons
	// Important in case it's a JMod icon or something
	private boolean isInvalidUsername(String username) {
		return username.toLowerCase().startsWith("mod ");
	}

	public boolean shouldShowCurrentMessage(String message, String name) {
		// Spam is now blocked at publish time, so no need to check here
		if (isInvalidUsername(name))
			return false;

		if (isUnderCbLevel(name)) {
			return false;
		}
		
		return true;
	}
	
	// New method: Only check spam and rate limiting for publishers
	// Always filter spam and invalid usernames regardless of user settings
	public boolean shouldPublishMessage(String message, String name) {
		// Always block spam messages from being published (saves money)
		if (isSpam(message)) {
			return false;
		}
		
		if (isInvalidUsername(name))
			return false;
		
		// Rate limiting: prevent spam by limiting message frequency
		if (!canSendMessage(name)) {
			return false;
		}
		
		return true;
	}
	
	private boolean canSendMessage(String user) {
		long now = System.currentTimeMillis();
		Long lastTime = lastMessageTime.get(user);
		if (lastTime != null && now - lastTime < 100) { // 100ms cooldown
			return false;
		}
		lastMessageTime.put(user, now);
		return true;
	}

	public boolean shouldShowMessge(String name, String message, Boolean set) {
		final String sanitizedName = Text.toJagexName(Text.removeTags(name));

		String prevMessage = previousMessages.get(sanitizedName);

		// If someone is spamming the same message during a session, block it
		if (message.equals(prevMessage)) {
			return false;
		}
		if (set) {
			previousMessages.put(sanitizedName, message);
		}

		return true;
	}

	private void setupAblyInstances(String playerName) {
		try {
			ClientOptions clientOptions = new ClientOptions();
			String name = Text.sanitize(playerName);
			Param[] params = new Param[] {
					new Param("clientId", name),
			};
			clientOptions.authHeaders = params;
			clientOptions.authUrl = "https://global-chat-plugin.vercel.app/api/token";
			
			// Critical: Disable echo messages to reduce message count by 50%
			clientOptions.echoMessages = false;
			
			// Connection timeouts not available in this Ably version
			// Will rely on default timeout behavior
			
			ablyRealtime = new AblyRealtime(clientOptions);
			
			// Add connection state monitoring
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.disconnected, state -> {
				log.warn("Connection disconnected: " + state.reason);
			});
			
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.failed, state -> {
				log.error("Connection failed: " + state.reason);
			});
			
			ablyRealtime.connection.on(io.ably.lib.realtime.ConnectionEvent.connected, state -> {
				log.debug("Connection established successfully");
			});
			
		} catch (AblyException e) {
			log.error("Failed to setup Ably connection", e);
			handleAblyError(e);
		}
	}


	private static String padKey(String key, int length) {
		if (key.length() >= length) {
			return key.substring(0, length);
		}
		StringBuilder keyBuilder = new StringBuilder(key);
		while (keyBuilder.length() < length) {
			keyBuilder.append("0"); // Pad the key with zeros
		}
		return keyBuilder.toString();
	}

	public Channel subscribeToCorrectChannel(String channelName, String key) {

		try {
			String paddedKeyString = padKey(key, 16); // Ensure the key is 16 bytes long
			String base64EncodedKey = Base64.getEncoder().encodeToString(paddedKeyString.getBytes());
			ChannelOptions options = ChannelOptions.withCipherKey(base64EncodedKey);
			Channel currentChannel = ablyRealtime.channels.get(channelName, options);
			currentChannel.subscribe(this::handleMessage);
			
			// Mark channel as active for cleanup tracking
			markChannelActive(channelName);
			
			return currentChannel;
		} catch (AblyException err) {
			log.error("Ably subscribe error", err);
			handleAblyError(err);
		}
		return null;

	}

	private String getAccountIcon() {
		if (client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
			return "<img=33>";
		}
		switch (client.getAccountType()) {
			case IRONMAN:
				return "<img=2>";
			case HARDCORE_IRONMAN:
				return "<img=10>";
			case ULTIMATE_IRONMAN:
				return "<img=3>";
		}

		return "";
	}
	
	// Debug methods to test error dialogs (only available in developer mode)
	public void testCapacityError() {
		if (developerMode) {
			log.debug("Testing capacity error dialog (developer mode)");
			showInGameErrorMessage(
				"<col=ff9040>[DEBUG] Global Chat is at capacity!</col> " +
				"The plugin has reached its usage limits. " +
				"<col=00ff00>Support on Patreon to help increase limits!</col>"
			);
		}
	}
	
	public void testConnectionError() {
		if (developerMode) {
			log.debug("Testing connection error dialog (developer mode)");
			showInGameErrorMessage(
				"<col=ff0000>[DEBUG] Global Chat connection error!</col> " +
				"Service may be temporarily unavailable. Try again later."
			);
		}
	}
	
	public void testUpdateNotification() {
		if (developerMode) {
			log.debug("Testing update notification (developer mode)");
			showUpdateNotification(
				"<col=00ff00>Global Chat v2.0 is here!</col> " +
				"New: Better error handling, redesigned info panel, spam prevention, and cost optimizations. " +
				"<col=ff9040>Support on Patreon to increase service limits!</col>"
			);
		}
	}
	
	private void handleAblyError(Exception e) {
		String errorMessage = e.getMessage();
		if (errorMessage == null) {
			errorMessage = e.getClass().getSimpleName();
		}
		
		// Check for common limit-related errors
		if (errorMessage.contains("limit") || 
			errorMessage.contains("quota") || 
			errorMessage.contains("exceeded") ||
			errorMessage.contains("capacity") ||
			errorMessage.contains("rate") ||
			e instanceof AblyException && ((AblyException) e).errorInfo != null && 
			(((AblyException) e).errorInfo.code == 40005 || // Connection limit
			 ((AblyException) e).errorInfo.code == 40006 || // Message limit
			 ((AblyException) e).errorInfo.code == 40007)) { // Channel limit
			
			// Show in-game chat message with rate limiting
			showInGameErrorMessage(
				"<col=ff9040>Global Chat is at capacity!</col> " +
				"The plugin has reached its usage limits. " +
				"<col=00ff00>Support on Patreon to help increase limits!</col>"
			);
		} else {
			// For other errors, show a generic connection error
			showInGameErrorMessage(
				"<col=ff0000>Global Chat connection error!</col> " +
				"Service may be temporarily unavailable. Try again later."
			);
		}
	}
	
	private void showInGameErrorMessage(String message) {
		// Rate limiting: only show error messages every 5 minutes to prevent spam
		long now = System.currentTimeMillis();
		if (now - lastErrorMessageTime < ERROR_MESSAGE_COOLDOWN) {
			log.debug("Error message rate limited, skipping");
			return;
		}
		
		if (client.getGameState() == GameState.LOGGED_IN) {
			lastErrorMessageTime = now;
			log.debug("Sending error message to chat");
			
			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.GAMEMESSAGE)
				.runeLiteFormattedMessage(message)
				.build());
		}
	}
	
	public void showUpdateNotification(String message) {
		log.debug("Showing update notification");
		
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(message)
			.build());
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

import net.runelite.client.callback.ClientThread;

import com.google.inject.Provides;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.inject.Named;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.events.WorldChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClanChannelChanged;
import net.runelite.api.events.FriendsChatChanged;
import net.runelite.api.events.FriendsChatMemberJoined;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.net.URL;
import javax.imageio.ImageIO;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@PluginDescriptor(name = "Global Chat", description = "Talk anywhere!", tags = {
		"chat" })
public class GlobalChatPlugin extends Plugin {
	@Inject
	private AblyManager ablyManager;

	@Inject
	private Client client;

	@Inject
	@Getter
	private ClientThread clientThread;

	@Inject
	private ClientToolbar clientToolbar;

	private GlobalChatInfoPanel infoPanel;
	private NavigationButton navButton;

	@Getter
	@Setter
	private boolean shouldConnect = true;

	@Getter
	@Setter
	private String friendsChat;

	@Getter
	@Setter
	private String theClanName;

	public static final int CYCLES_PER_GAME_TICK = Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

	@Getter
	@Setter
	private String theGuesttheClanName;

	@Getter
	private final HashMap<String, ArrayList<String>> previousMessages = new HashMap<>();

	@Getter
	@Inject
	@Named("developerMode")
	private boolean developerMode;

	@Inject
	private GlobalChatConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private SupporterManager supporterManager;

	private ScheduledExecutorService scheduler;

	@Override
	protected void startUp() throws Exception {
		// Initialize scheduler for delayed operations
		scheduler = Executors.newSingleThreadScheduledExecutor();
		
		// ablyManager.startConnection();
		onLoggedInGameState(); // Call this to handle turning plugin on when already logged in, should do
								// nothing on initial call

		// Setup info panel
		infoPanel = new GlobalChatInfoPanel(developerMode, ablyManager, supporterManager);
		log.debug("Created GlobalChatInfoPanel");

		// Create navigation button with simple icon
		navButton = NavigationButton.builder()
				.tooltip("Global Chat Info")
				.priority(0)
				.panel(infoPanel)
				.icon(createSimpleIcon())
				.build();

		clientToolbar.addNavigation(navButton);
		log.debug("Added Global Chat navigation button to toolbar");
	}

	@Override
	protected void shutDown() throws Exception {
		ablyManager.closeConnection();
		shouldConnect = true;

		// Clean up scheduler
		if (scheduler != null) {
			scheduler.shutdown();
		}

		// Clean up supporter manager
		if (supporterManager != null) {
			supporterManager.shutdown();
		}

		// Clean up UI panel
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}
	}

	@Subscribe
	public void onWorldChanged(WorldChanged worldChanged) {
		shouldConnect = true;

		// Force cleanup before reconnecting
		ablyManager.closeConnection();

		// Do all client data validation on client thread, then start connection
		clientThread.invokeLater(() -> {
			if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null) {
				String playerName = client.getLocalPlayer().getName();
				// All conditions satisfied, start connection after brief delay for cleanup
				scheduler.schedule(() -> ablyManager.startConnection(playerName), 100, TimeUnit.MILLISECONDS);
			}
			return true;
		});
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGED_IN) {
			onLoggedInGameState();
		}
		if (event.getGameState() == GameState.LOGIN_SCREEN) {
			onLoggedOut();
		}
	}

	@Subscribe
	public void onFriendsChatMemberJoined(FriendsChatMemberJoined event) {
		final FriendsChatMember member = event.getMember();
		if (member == null || member.getName() == null) {
			return;
		}
		String memberName = member.getName().replace('\u00A0', ' ').trim();
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getName() == null) {
			return;
		}
		String playerName = localPlayer.getName().replace('\u00A0', ' ').trim();

		Boolean isCurrentUser = memberName.equals(playerName);

		if (isCurrentUser) {
			FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null) {
				friendsChat = friendsChatManager.getOwner();
				ablyManager.subscribeToCorrectChannel("f:" + friendsChat, "pub");
			}
		}
	}

	private void onLoggedInGameState() {
		clientThread.invokeLater(() -> {
			// Get all client data first, then execute off client thread
			if (client.getGameState() != GameState.LOGGED_IN) {
				return true;
			}

			final Player player = client.getLocalPlayer();
			if (player == null) {
				return false;
			}
			final String name = player.getName();
			if (name == null) {
				return false;
			}
			if (name.equals("") || !shouldConnect) {
				return false;
			}

			// Get all needed client data
			String world = String.valueOf(client.getWorld());
			
			// All conditions satisfied, execute connection logic off client thread
			scheduler.execute(() -> {
				ablyManager.startConnection(name);
				ablyManager.subscribeToCorrectChannel("p:" + name, world);
				ablyManager.subscribeToCorrectChannel("w:" + world, "pub");
				shouldConnect = false;

				// Show update notification if needed
				showUpdateNotificationIfNeeded();
			});

			return true;
		});
	}

	private void onLoggedOut() {
		clientThread.invokeLater(() -> {
			// we return true in this case as something went wrong and somehow the state
			// isn't logged in, so we don't
			// want to keep scheduling this task.
			if (client.getGameState() != GameState.LOGIN_SCREEN) {
				return true;
			}
			shouldConnect = true;
			ablyManager.closeConnection();
			// ablyManager.startConnection();

			return true;
		});
	}

	@Subscribe
	public void onClanChannelChanged(ClanChannelChanged event) {
		ClanChannel clanChannel = event.getClanChannel();
		boolean inClanNow = clanChannel != null;
		String channelName = (inClanNow && clanChannel != null) ? clanChannel.getName() : null;
		boolean isGuest = event.isGuest();

		if (!inClanNow) {
			String channelPrefix = isGuest ? "c:" + theGuesttheClanName
					: "c:" +
							theClanName;
			ablyManager.closeSpecificChannel(channelPrefix);

			if (isGuest) {
				theGuesttheClanName = null;
			} else {
				theClanName = null;
			}
		} else {
			String targetChannelName = "c:" + channelName;
			ablyManager.subscribeToCorrectChannel(targetChannelName, "pub");

			if (isGuest) {
				theGuesttheClanName = channelName;
			} else {
				theClanName = channelName;
			}
		}
	}

	@Subscribe
	public void onFriendsChatChanged(FriendsChatChanged event) {
		if (!event.isJoined()) {
			if (friendsChat != null) {
				ablyManager.closeSpecificChannel("f:" + friendsChat);
				friendsChat = null;
			}
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		String cleanedMessage = Text.removeTags(event.getMessage());

		String cleanedName = Text.sanitize(event.getName());
		boolean isPublic = event.getType().equals(ChatMessageType.PUBLICCHAT);

		boolean isLocalPlayerSendingMessage = cleanedName.equals(client.getLocalPlayer().getName());
		if (isPublic && isLocalPlayerSendingMessage) {
			// Check for spam BEFORE publishing to save costs
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return; // Don't publish spam messages
			}

			ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true);

			// Modify message to include icons if not in read-only mode and connected
			if (!config.readOnlyMode() && ablyManager.isConnected()) {
				// Remove the original message
				final ChatLineBuffer lineBuffer = client.getChatLineMap().get(ChatMessageType.PUBLICCHAT.getType());
				lineBuffer.removeMessageNode(event.getMessageNode());
				
				// Get icons (match the format used for received messages)
				String accountIcon = getAccountIcon();
				String supporterIcon = supporterManager.getSupporterIcon(cleanedName);
				String symbol = accountIcon; // Start with account icon
				
				// Add supporter icon if user is a supporter
				if (!supporterIcon.isEmpty()) {
					if (symbol.isEmpty()) {
						symbol = supporterIcon;
					} else {
						symbol = supporterIcon + " " + symbol;
					}
				}
				
				// Add global chat icon
				symbol = "<img=19> " + symbol;
				
				// Re-add the message with icons
				client.addChatMessage(ChatMessageType.PUBLICCHAT, symbol + cleanedName, cleanedMessage, null);
			}
			
			// Publish to global chat
			ablyManager.publishMessage("w", cleanedMessage, "w:" + String.valueOf(client.getWorld()), "");
			// Disable functality for publishing direct messages
			// } else if (event.getType().equals(ChatMessageType.PRIVATECHATOUT)) {
			// ablyManager.shouldShowMessge(client.getLocalPlayer().getName(),
			// cleanedMessage, true);
			// ablyManager.publishMessage("p", cleanedMessage, "p:" + cleanedName,
			// cleanedName);
		} else if (event.getType().equals(ChatMessageType.PRIVATECHAT)
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.PRIVATECHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.FRIENDSCHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.FRIENDSCHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.CLAN_CHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.CLAN_CHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.CLAN_GUEST_CHAT) && !isLocalPlayerSendingMessage
				&& !ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true)) {
			final ChatLineBuffer lineBuffer = client.getChatLineMap()
					.get(ChatMessageType.CLAN_GUEST_CHAT.getType());
			lineBuffer.removeMessageNode(event.getMessageNode());
		} else if (event.getType().equals(ChatMessageType.FRIENDSCHAT) && isLocalPlayerSendingMessage) {
			// Check for spam BEFORE publishing to save costs
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return; // Don't publish spam messages
			}

			ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true);
			FriendsChatManager friendsChatManager = client.getFriendsChatManager();
			if (friendsChatManager != null) {
				ablyManager.publishMessage("f", cleanedMessage, "f:" + friendsChat,
						friendsChatManager.getName());
			}
		} else if (event.getType().equals(ChatMessageType.CLAN_CHAT)
				&& isLocalPlayerSendingMessage) {
			// Check for spam BEFORE publishing to save costs
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return; // Don't publish spam messages
			}

			ablyManager.shouldShowMessge(client.getLocalPlayer().getName(), cleanedMessage, true);
			ClanChannel clanChannel = client.getClanChannel();
			if (clanChannel != null) {
				ablyManager.publishMessage("c", cleanedMessage, "c:" + clanChannel.getName(),
						clanChannel.getName());
			}
		} else if (event.getType().equals(ChatMessageType.CLAN_GUEST_CHAT)
				&& isLocalPlayerSendingMessage) {
			// Check for spam BEFORE publishing to save costs
			if (!ablyManager.shouldPublishMessage(cleanedMessage, cleanedName)) {
				return; // Don't publish spam messages
			}

			ablyManager.shouldShowMessge(client.getLocalPlayer().getName(), cleanedMessage, true);
			ClanChannel guestClanChannel = client.getGuestClanChannel();
			if (guestClanChannel != null) {
				ablyManager.publishMessage("c", cleanedMessage, "c:" + guestClanChannel.getName(),
						guestClanChannel.getName());
			}
		} else {

			ablyManager.shouldShowMessge(cleanedName, cleanedMessage, true);
		}
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event) {

		if ("chatFilterCheck".equals(event.getEventName())) {

			int[] intStack = client.getIntStack();
			int intStackSize = client.getIntStackSize();
			// Extract the message type and message content from the event.
			final int messageType = intStack[intStackSize - 2];
			final int messageId = intStack[intStackSize - 1];

			final MessageNode messageNode = client.getMessages().get(messageId);
			final String name = messageNode.getName();
			if (name == null) {
				return;
			}
			String cleanedName = Text.sanitize(name);
			Player localPlayer = client.getLocalPlayer();
			if (localPlayer == null || localPlayer.getName() == null) {
				return;
			}
			boolean isLocalPlayerSendingMessage = cleanedName.equals(localPlayer.getName());

			boolean shouldConsiderHiding = !isLocalPlayerSendingMessage
					&& ChatMessageType.of(messageType) == ChatMessageType.PUBLICCHAT;

			if (shouldConsiderHiding && ablyManager.isUnderCbLevel(cleanedName)) {
				intStack[intStackSize - 3] = 0;
			}

		}

	}

	@Subscribe(priority = -2) // conflicts with chat filter plugin without this priority
	public void onOverheadTextChanged(OverheadTextChanged event) {
		if (!(event.getActor() instanceof Player) || event.getActor().getName() == null)
			return;
		String cleanedName = Text.sanitize(event.getActor().getName());
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null || localPlayer.getName() == null) {
			return;
		}
		boolean isLocalPlayerSendingMessage = cleanedName.equals(localPlayer.getName());

		if (!isLocalPlayerSendingMessage && ablyManager.isUnderCbLevel(cleanedName)) {
			event.getActor().setOverheadText("");
		}

	}

	private void showUpdateNotificationIfNeeded() {
		// Define the current version - update this when you want to show a new
		// notification
		String currentVersion = "v2.0.0";

		// Check if notification for this version has been shown
		String lastNotificationVersion = config.updateNotificationShown();

		if (!currentVersion.equals(lastNotificationVersion)) {
			// Show in-game chat message directly
			ablyManager.showUpdateNotification(
					"<col=00ff00>Global Chat v2.0 is here!</col> " +
							"New: Better error handling, redesigned info panel, spam prevention, and cost optimizations. "
							+
							"<col=ff9040>Support on Patreon to increase service limits!</col>");

			// Mark this version as notified
			configManager.setConfiguration("globalchat", "updateNotificationShown", currentVersion);
		}
	}

	@Provides
	GlobalChatConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(GlobalChatConfig.class);
	}

	private String getAccountIcon() {
		if (client.getWorldType().contains(WorldType.TOURNAMENT_WORLD)) {
			return "<img=33>";
		}
		switch (client.getAccountType()) {
			case IRONMAN:
				return "<img=2>";
			case HARDCORE_IRONMAN:
				return "<img=10>";
			case ULTIMATE_IRONMAN:
				return "<img=3>";
			default:
				return "";
		}
	}

	private BufferedImage createSimpleIcon() {
		try {
			// Load the icon from project root
			BufferedImage image = ImageIO.read(new java.io.File("icon.png"));

			// Resize to 16x16 if needed
			if (image.getWidth() != 16 || image.getHeight() != 16) {
				BufferedImage resized = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
				Graphics2D g2 = resized.createGraphics();
				g2.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);
				g2.drawImage(image, 0, 0, 16, 16, null);
				g2.dispose();
				return resized;
			}

			return image;
		} catch (Exception e) {
			log.error("Failed to load icon from project root", e);
			return null;
		}
	}

	// @Subscribe(priority = -2)
	// public void onClientTick(ClientTick clientTick) {
	// if (client.isMenuOpen()) {
	// return;
	// }

	// MenuEntry[] menuEntries = client.getMenuEntries();

	// for (MenuEntry entry : menuEntries) {
	// MenuAction type = entry.getType();

	// if (type == WALK
	// || type == WIDGET_TARGET_ON_PLAYER
	// || type == ITEM_USE_ON_PLAYER
	// || type == PLAYER_FIRST_OPTION
	// || type == PLAYER_SECOND_OPTION
	// || type == PLAYER_THIRD_OPTION
	// || type == PLAYER_FOURTH_OPTION
	// || type == PLAYER_FIFTH_OPTION
	// || type == PLAYER_SIXTH_OPTION
	// || type == PLAYER_SEVENTH_OPTION
	// || type == PLAYER_EIGHTH_OPTION
	// || type == RUNELITE_PLAYER) {
	// Player[] players = client.getCachedPlayers();
	// Player player = null;

	// int identifier = entry.getIdentifier();

	// // 'Walk here' identifiers are offset by 1 because the default
	// // identifier for this option is 0, which is also a player index.
	// if (type == WALK) {
	// identifier--;
	// }

	// if (identifier >= 0 && identifier < players.length) {
	// player = players[identifier];

	// }

	// if (player == null) {
	// return;
	// }

	// String oldTarget = entry.getTarget();
	// String newTarget = decorateTarget(oldTarget, player.getName());

	// entry.setTarget(newTarget);
	// }

	// }
	// }

}

package com.globalchat;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@Singleton
public class SupporterManager {
    private static final String SUPPORTERS_URL = "https://global-chat-plugin.vercel.app/api/supporters";
    private static final long REFRESH_INTERVAL_MINUTES = 10;

    private final Gson gson;
    private final OkHttpClient httpClient;
    private final ScheduledExecutorService scheduler;
    private List<Supporter> supporters = new ArrayList<>();
    private int totalSupport = 0;
    private String lastUpdated = "";

    @Inject
    public SupporterManager(Gson gson, OkHttpClient httpClient) {
        this.gson = gson;
        this.httpClient = httpClient;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();

        // Initial fetch
        fetchSupporters();

        // Schedule periodic refresh
        scheduler.scheduleAtFixedRate(this::fetchSupporters,
                REFRESH_INTERVAL_MINUTES, REFRESH_INTERVAL_MINUTES, TimeUnit.MINUTES);
    }

    public void shutdown() {
        scheduler.shutdown();
    }

    public List<Supporter> getSupporters() {
        return new ArrayList<>(supporters);
    }

    public int getTotalSupport() {
        return totalSupport;
    }

    public String getLastUpdated() {
        return lastUpdated;
    }

    public boolean isSupporter(String username) {
        if (username == null)
            return false;
        return supporters.stream()
                .anyMatch(supporter -> supporter.name != null &&
                        supporter.name.equalsIgnoreCase(username.trim()));
    }

    public String getSupporterIcon(String username) {
        if (username == null)
            return "";

        return supporters.stream()
                .filter(supporter -> supporter.name != null &&
                        supporter.name.equalsIgnoreCase(username.trim()))
                .findFirst()
                .map(this::getTierIcon)
                .orElse("");
    }

    private String getTierIcon(Supporter supporter) {
        // Use RuneScape item icons for different tiers
        if (supporter.amount >= 50) {
            return "<img=314> "; // Gold
        } else if (supporter.amount >= 20) {
            return "<img=312> "; // Silver
        } else if (supporter.amount >= 5) {
            return "<img=313> "; // Bronze
        } else {
            return ""; // No icon
        }
    }

    private void fetchSupporters() {
        CompletableFuture.runAsync(() -> {
            try {
                Request request = new Request.Builder()
                        .url(SUPPORTERS_URL)
                        .build();

                try (Response response = httpClient.newCall(request).execute()) {
                    if (response.isSuccessful() && response.body() != null) {
                        String responseBody = response.body().string();
                        parseSupportersResponse(responseBody);
                        log.debug("Successfully fetched {} supporters", supporters.size());
                    } else {
                        log.warn("Failed to fetch supporters: HTTP {}", response.code());
                    }
                }
            } catch (Exception e) {
                log.error("Error fetching supporters", e);
            }
        });
    }

    private void parseSupportersResponse(String json) {
        try {
            Type responseType = new TypeToken<SupportersResponse>() {
            }.getType();
            SupportersResponse response = gson.fromJson(json, responseType);

            if (response != null && response.supporters != null) {
                this.supporters = response.supporters;
                this.totalSupport = response.totalSupport;
                this.lastUpdated = response.lastUpdated;
            }
        } catch (Exception e) {
            log.error("Error parsing supporters response", e);
        }
    }

    private static class SupportersResponse {
        public List<Supporter> supporters;
        public int totalSupport;
        public String lastUpdated;
    }
}
package com.globalchat;

public class Supporter {
    public String name;
    public String tier;
    public int amount;
    public boolean isPublic;

    public Supporter(String name, String tier, int amount, boolean isPublic) {
        this.name = name;
        this.tier = tier;
        this.amount = amount;
        this.isPublic = isPublic;
    }

    public String getDisplayName() {
        return isPublic ? name : "Anonymous";
    }

    public String getTierDisplay() {
        return tier + " Supporter";
    }
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.globalchat;

public class GlobalChatMessage {
	public String username;
	public String symbol;
	public String message;
	public String global;
	public String to;

	public String type;

	public GlobalChatMessage(String username, String symbol, String message, String type, String to) {
		this.username = username;
		this.symbol = symbol;
		this.message = message;
		this.type = type;
		this.to = to;

	}
}

package com.globalchat;

import com.globalchat.GlobalChatPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GlobalChatTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(GlobalChatPlugin.class);
		RuneLite.main(args);
	}
}
