package com.example.enums;

public enum FontType
{
	RUNESCAPE("RuneScape"),
	ARIAL("Arial"),
	VERDANA("Verdana"),
	TAHOMA("Tahoma"),
	COURIER_NEW("Courier New"),
	TIMES_NEW_ROMAN("Times New Roman"),
	COMIC_SANS_MS("Comic Sans MS"),
	IMPACT("Impact"),
	LUCIDA_CONSOLE("Lucida Console");

	private final String fontName;

	FontType(String fontName)
	{
		this.fontName = fontName;
	}

	public String getFontName()
	{
		return fontName;
	}
}



package com.example.enums;

public enum HighlightType
{
	TILE("Tile"),
	DISCO("Disco"),
	OUTLINE("Outline");

	private final String displayName;

	HighlightType(String displayName)
	{
		this.displayName = displayName;
	}

	@Override
	public String toString()
	{
		return displayName;
	}
}



package com.example.model;

import lombok.Data;

@Data
public class AfkStatus
{
	private String status;
	private long endTime;
	private long startTime;
	private int streak;
	private long lastActivityTime;
	private String icon;

	public AfkStatus(String status, long endTime, long startTime, int streak, long lastActivityTime, String icon)
	{
		this.status = status;
		this.endTime = endTime;
		this.startTime = startTime;
		this.streak = streak;
		this.lastActivityTime = lastActivityTime;
		this.icon = icon;
	}

	public AfkStatus()
	{
		this("", 0, 0, 0, 0, "");
	}
}



package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CustomKeyword
{
	private String keyword;
	private String statusText;
	private String icon;
}



package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PlayerStats
{
	private int afkCount;
	private long totalAfkTime;
	private long lastAfkTime;
}



package com.example.config;

import com.example.enums.FontType;
import com.example.enums.HighlightType;
import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup("brb")
public interface BrbConfig extends Config
{
	@ConfigSection(
		name = "Display Settings",
		description = "Settings for how AFK status is displayed",
		position = 0
	)
	String displaySection = "display";

	@ConfigSection(
		name = "Text Settings",
		description = "Settings for text appearance and position",
		position = 1
	)
	String textSection = "text";

	@ConfigSection(
		name = "Advanced Features",
		description = "Additional features and customization",
		position = 2
	)
	String advancedSection = "advanced";

	@Range(min = -200, max = 200)
	@ConfigItem(
		keyName = "textOffsetX",
		name = "Text X Offset",
		description = "Horizontal offset for AFK text (negative = left, positive = right)",
		section = textSection,
		position = 0
	)
	default int textOffsetX()
	{
		return -5;
	}

	@Range(min = -200, max = 200)
	@ConfigItem(
		keyName = "textOffsetY",
		name = "Text Y Offset",
		description = "Vertical offset for AFK text (negative = up, positive = down)",
		section = textSection,
		position = 1
	)
	default int textOffsetY()
	{
		return 25;
	}

	@ConfigItem(
		keyName = "textFontType",
		name = "Text Font",
		description = "Font type for AFK text",
		section = textSection,
		position = 2
	)
	default FontType textFontType()
	{
		return FontType.RUNESCAPE;
	}

	@ConfigItem(
		keyName = "textFontSize",
		name = "Text Font Size",
		description = "Font size for AFK text",
		section = textSection,
		position = 3
	)
	default int textFontSize()
	{
		return 15;
	}

	@ConfigItem(
		keyName = "textFontBold",
		name = "Bold Text",
		description = "Use bold font for AFK text",
		section = textSection,
		position = 4
	)
	default boolean textFontBold()
	{
		return true;
	}

	@ConfigItem(
		keyName = "textColor",
		name = "Text Color",
		description = "Color for AFK text",
		section = textSection,
		position = 5
	)
	default Color textColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		keyName = "showCountdown",
		name = "Show Countdown",
		description = "Display countdown timer for time-based AFK messages",
		section = displaySection,
		position = 0
	)
	default boolean showCountdown()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightAfkPlayer",
		name = "Highlight AFK Player",
		description = "Highlight the character of AFK players",
		section = displaySection,
		position = 1
	)
	default boolean highlightAfkPlayer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightType",
		name = "Highlight Type",
		description = "Type of highlight to use for AFK players",
		section = displaySection,
		position = 2
	)
	default HighlightType highlightType()
	{
		return HighlightType.OUTLINE;
	}

	@ConfigItem(
		keyName = "highlightColor",
		name = "Highlight Color",
		description = "Color used to highlight AFK players",
		section = displaySection,
		position = 3
	)
	default Color highlightColor()
	{
		return new Color(0xFF0000);
	}

	@Range(min = 1, max = 20)
	@ConfigItem(
		keyName = "highlightWidth",
		name = "Highlight Width",
		description = "Width/thickness of the highlight (for Glow, Disco, and Outline)",
		section = displaySection,
		position = 4
	)
	default int highlightWidth()
	{
		return 3;
	}

	@Range(min = 0, max = 20)
	@ConfigItem(
		keyName = "highlightFeather",
		name = "Highlight Feather",
		description = "Feather/softness of the highlight edge (for Glow, Disco, and Outline)",
		section = displaySection,
		position = 5
	)
	default int highlightFeather()
	{
		return 0;
	}


	@ConfigItem(
		keyName = "showMinimapIndicator",
		name = "Show Minimap Indicator",
		description = "Display indicator on minimap for AFK players",
		section = advancedSection,
		position = 0
	)
	default boolean showMinimapIndicator()
	{
		return true;
	}

	@ConfigItem(
		keyName = "customKeywords",
		name = "Custom Keywords",
		description = "Custom keywords and status messages (format: keyword:status:icon, e.g., coffee:Getting Coffee:‚òï,work:At Work:üíº)",
		section = advancedSection,
		position = 1
	)
	default String customKeywords()
	{
		return "coffee:Getting Coffee:‚òï,work:At Work:üíº";
	}

	@ConfigItem(
		keyName = "autoRemoveInactive",
		name = "Auto-Remove Inactive",
		description = "Automatically remove AFK status after player is inactive for specified minutes",
		section = advancedSection,
		position = 2
	)
	default boolean autoRemoveInactive()
	{
		return false;
	}

	@ConfigItem(
		keyName = "inactiveTimeoutMinutes",
		name = "Inactive Timeout (minutes)",
		description = "Minutes of inactivity before auto-removing AFK status",
		section = advancedSection,
		position = 3
	)
	default int inactiveTimeoutMinutes()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "highlightFriendsClan",
		name = "Highlight Friends/Clan",
		description = "Highlight friends and clan members more prominently",
		section = advancedSection,
		position = 4
	)
	default boolean highlightFriendsClan()
	{
		return true;
	}

	@ConfigItem(
		keyName = "friendsClanColor",
		name = "Friends/Clan Highlight Color",
		description = "Color used to highlight friends and clan members",
		section = advancedSection,
		position = 5
	)
	default Color friendsClanColor()
	{
		return new Color(0xF100FF);
	}

}


package com.example.overlay;

import com.example.BrbPlugin;
import com.example.config.BrbConfig;
import com.example.model.AfkStatus;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

public class BrbMinimapOverlay extends Overlay
{
	private final Client client;
	private final BrbPlugin plugin;
	private final BrbConfig config;

	@Inject
	private BrbMinimapOverlay(Client client, BrbPlugin plugin, BrbConfig config)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showMinimapIndicator())
		{
			return null;
		}

		Map<String, AfkStatus> afkPlayers = plugin.getAfkPlayers();
		if (afkPlayers.isEmpty())
		{
			return null;
		}

		java.util.List<Player> players = client.getPlayers();
		if (players == null || players.isEmpty())
		{
			return null;
		}

		for (Player player : players)
		{
			if (player == null || player.getName() == null)
			{
				continue;
			}

			String normalizedName = plugin.normalizePlayerName(player.getName());
			if (normalizedName == null || normalizedName.isEmpty())
			{
				continue;
			}

			AfkStatus status = afkPlayers.get(normalizedName);
			if (status == null)
			{
				continue;
			}

			renderMinimapIndicator(graphics, player, status);
		}

		return null;
	}

	private void renderMinimapIndicator(Graphics2D graphics, Player player, AfkStatus status)
	{
		LocalPoint localPoint = player.getLocalLocation();
		if (localPoint == null)
		{
			return;
		}

		Point minimapPoint = Perspective.localToMinimap(client, localPoint);
		if (minimapPoint == null)
		{
			return;
		}

		String normalizedName = plugin.normalizePlayerName(player.getName());
		boolean isFriendOrClan = plugin.isFriendOrClanMember(normalizedName);
		Color indicatorColor = isFriendOrClan && config.highlightFriendsClan() 
			? config.friendsClanColor() 
			: config.highlightColor();

		int x = (int) minimapPoint.getX() - 3;
		int y = (int) minimapPoint.getY() - 3;
		graphics.setColor(indicatorColor);
		graphics.fillOval(x, y, 6, 6);
		graphics.setColor(Color.WHITE);
		graphics.drawOval(x, y, 6, 6);
	}
}



package com.example.overlay;

import com.example.BrbPlugin;
import com.example.config.BrbConfig;
import com.example.enums.FontType;
import com.example.enums.HighlightType;
import com.example.model.AfkStatus;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class BrbOverlay extends Overlay
{
	private final Client client;
	private final BrbPlugin plugin;
	private final BrbConfig config;
	private final ModelOutlineRenderer modelOutlineRenderer;

	@Inject
	private BrbOverlay(Client client, BrbPlugin plugin, BrbConfig config, ModelOutlineRenderer modelOutlineRenderer)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.modelOutlineRenderer = modelOutlineRenderer;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Map<String, AfkStatus> afkPlayers = plugin.getAfkPlayers();
		
		if (afkPlayers.isEmpty())
		{
			return null;
		}

		List<Player> players = client.getPlayers();
		if (players == null || players.isEmpty())
		{
			return null;
		}

		for (Player player : players)
		{
			if (player == null || player.getName() == null)
			{
				continue;
			}

			String normalizedName = plugin.normalizePlayerName(player.getName());
			if (normalizedName == null || normalizedName.isEmpty())
			{
				continue;
			}

			AfkStatus status = afkPlayers.get(normalizedName);
			if (status == null)
			{
				continue;
			}

			boolean isFriendOrClan = plugin.isFriendOrClanMember(normalizedName);
			Color highlightColor = isFriendOrClan && config.highlightFriendsClan() 
				? config.friendsClanColor() 
				: config.highlightColor();

			if (config.highlightAfkPlayer())
			{
				renderPlayerHighlight(graphics, player, config.highlightType(), highlightColor);
			}

			renderPlayerText(graphics, player, status, isFriendOrClan);
		}

		return null;
	}

	private void renderPlayerText(Graphics2D graphics, Player player, AfkStatus status, boolean isFriendOrClan)
	{
		LocalPoint localPoint = player.getLocalLocation();
		if (localPoint == null)
		{
			return;
		}

		String displayText = status.getStatus();
		
		if (config.textFontType() == FontType.RUNESCAPE && status.getIcon() != null && !status.getIcon().isEmpty())
		{
			displayText = status.getIcon() + " " + displayText;
		}
		
		if (config.showCountdown())
		{
			if (status.getEndTime() > 0)
			{
				long remainingMs = status.getEndTime() - System.currentTimeMillis();
				if (remainingMs > 0)
				{
					long remainingSeconds = remainingMs / 1000;
					long minutes = remainingSeconds / 60;
					long seconds = remainingSeconds % 60;
					
					if (minutes > 0)
					{
						displayText += String.format(" (%dm %ds)", minutes, seconds);
					}
					else
					{
						displayText += String.format(" (%ds)", seconds);
					}
				}
				else
				{
					long lateMs = System.currentTimeMillis() - status.getEndTime();
					long lateSeconds = lateMs / 1000;
					long lateMinutes = lateSeconds / 60;
					lateSeconds = lateSeconds % 60;
					
					if (lateMinutes > 0)
					{
						displayText += String.format(" (%dm %ds late)", lateMinutes, lateSeconds);
					}
					else
					{
						displayText += String.format(" (%ds late)", lateSeconds);
					}
				}
			}
			else
			{
				long elapsedMs = System.currentTimeMillis() - status.getStartTime();
				long elapsedSeconds = elapsedMs / 1000;
				long minutes = elapsedSeconds / 60;
				long seconds = elapsedSeconds % 60;
				
				if (minutes > 0)
				{
					displayText += String.format(" (%dm %ds)", minutes, seconds);
				}
				else
				{
					displayText += String.format(" (%ds)", seconds);
				}
			}
		}

		Point textLocation = Perspective.getCanvasTextLocation(
			client,
			graphics,
			localPoint,
			displayText,
			player.getLogicalHeight() + config.textOffsetY()
		);

		if (textLocation == null)
		{
			return;
		}

		int x = textLocation.getX() + config.textOffsetX();
		int y = textLocation.getY();

		Font originalFont = graphics.getFont();
		Color originalColor = graphics.getColor();
		
		Font textFont;
		if (config.textFontType() == FontType.RUNESCAPE)
		{
			Font baseFont = FontManager.getRunescapeFont();
			if (baseFont == null)
			{
				baseFont = FontManager.getRunescapeSmallFont();
			}
			
			if (baseFont != null)
			{
				textFont = baseFont.deriveFont((float) config.textFontSize());
			}
			else
			{
				textFont = new Font("Arial", Font.PLAIN, config.textFontSize());
			}
		}
		else
		{
			int fontStyle = config.textFontBold() ? Font.BOLD : Font.PLAIN;
			textFont = new Font(config.textFontType().getFontName(), fontStyle, config.textFontSize());
		}
		
		Color textColor = isFriendOrClan && config.highlightFriendsClan() 
			? config.friendsClanColor() 
			: config.textColor();

		graphics.setFont(textFont);
		graphics.setColor(textColor);

		graphics.setColor(Color.BLACK);
		for (int dx = -1; dx <= 1; dx++)
		{
			for (int dy = -1; dy <= 1; dy++)
			{
				if (dx != 0 || dy != 0)
				{
					graphics.drawString(displayText, x + dx, y + dy);
				}
			}
		}
		
		graphics.setColor(textColor);
		graphics.drawString(displayText, x, y);

		graphics.setFont(originalFont);
		graphics.setColor(originalColor);
	}

	private void renderPlayerHighlight(Graphics2D graphics, Player player, HighlightType highlightType, Color color)
	{
		LocalPoint localPoint = player.getLocalLocation();
		if (localPoint == null)
		{
			return;
		}

		switch (highlightType)
		{
			case TILE:
				renderTileHighlight(graphics, localPoint, color);
				break;
			case DISCO:
				renderDiscoHighlight(graphics, player, localPoint);
				break;
			case OUTLINE:
				renderOutlineHighlight(graphics, player, localPoint, color);
				break;
		}
	}

	private void renderTileHighlight(Graphics2D graphics, LocalPoint localPoint, Color color)
	{
		Polygon tilePoly = Perspective.getCanvasTilePoly(client, localPoint);
		if (tilePoly == null)
		{
			return;
		}

		graphics.setColor(color);
		graphics.setStroke(new java.awt.BasicStroke(2));
		graphics.drawPolygon(tilePoly);
		
		Color fillColor = new Color(
			color.getRed(),
			color.getGreen(),
			color.getBlue(),
			50
		);
		graphics.setColor(fillColor);
		graphics.fillPolygon(tilePoly);
	}

	private void renderDiscoHighlight(Graphics2D graphics, Player player, LocalPoint localPoint)
	{
		int width = config.highlightWidth();
		int feather = config.highlightFeather();
		
		// Generate rainbow color based on current time
		Color rainbowColor = getRainbowColor();
		
		Color fillColor = new Color(
			rainbowColor.getRed(),
			rainbowColor.getGreen(),
			rainbowColor.getBlue(),
			150
		);

		// Create multiple layers for glow effect with rainbow color
		int outerWidth = width + feather * 2;
		int midWidth = width + feather;
		
		if (outerWidth > 0)
		{
			modelOutlineRenderer.drawOutline(player, outerWidth, fillColor, feather * 2);
		}
		if (midWidth > 0)
		{
			modelOutlineRenderer.drawOutline(player, midWidth, fillColor, feather);
		}
		if (width > 0)
		{
			modelOutlineRenderer.drawOutline(player, width, rainbowColor, 0);
		}
	}

	private void renderOutlineHighlight(Graphics2D graphics, Player player, LocalPoint localPoint, Color color)
	{
		int width = config.highlightWidth();
		int feather = config.highlightFeather();
		modelOutlineRenderer.drawOutline(player, width, color, feather);
	}

	private Color getRainbowColor()
	{
		long time = System.currentTimeMillis();
		// Cycle through hue over 3 seconds (3000ms)
		float hue = (time % 3000) / 3000.0f;
		
		// Convert HSL to RGB
		// H: hue (0-1), S: saturation (1.0 = full), L: lightness (0.5 = medium)
		float saturation = 1.0f;
		float lightness = 0.5f;
		
		float c = (1 - Math.abs(2 * lightness - 1)) * saturation;
		float x = c * (1 - Math.abs((hue * 6) % 2 - 1));
		float m = lightness - c / 2;
		
		float r, g, b;
		if (hue < 1.0f / 6)
		{
			r = c;
			g = x;
			b = 0;
		}
		else if (hue < 2.0f / 6)
		{
			r = x;
			g = c;
			b = 0;
		}
		else if (hue < 3.0f / 6)
		{
			r = 0;
			g = c;
			b = x;
		}
		else if (hue < 4.0f / 6)
		{
			r = 0;
			g = x;
			b = c;
		}
		else if (hue < 5.0f / 6)
		{
			r = x;
			g = 0;
			b = c;
		}
		else
		{
			r = c;
			g = 0;
			b = x;
		}
		
		return new Color(
			(int) ((r + m) * 255),
			(int) ((g + m) * 255),
			(int) ((b + m) * 255)
		);
	}
}



package com.example;

import com.example.config.BrbConfig;
import com.example.model.AfkStatus;
import com.example.model.CustomKeyword;
import com.example.model.PlayerStats;
import com.example.overlay.BrbMinimapOverlay;
import com.example.overlay.BrbOverlay;
import com.google.inject.Provides;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.FriendsChatMember;
import net.runelite.api.Player;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

@Slf4j
@PluginDescriptor(
	name = "Away Status",
	description = "Displays AFK status above players when they type keywords like 'brb', 'afk', or '2mins'",
	tags = {"afk", "brb", "status", "overlay", "away"}
)
public class BrbPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private BrbConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BrbOverlay overlay;

	@Inject
	private BrbMinimapOverlay minimapOverlay;

	private final Map<String, AfkStatus> afkPlayers = new ConcurrentHashMap<>();
	private final Map<String, PlayerStats> playerStats = new ConcurrentHashMap<>();
	private final Map<String, CustomKeyword> customKeywords = new HashMap<>();
	private static final Map<String, CustomKeyword> DEFAULT_KEYWORDS = new HashMap<>();
	static
	{
		DEFAULT_KEYWORDS.put("brb toilet", new CustomKeyword("brb toilet", "BRB Toilet", "üöΩ"));
		DEFAULT_KEYWORDS.put("brb piss", new CustomKeyword("brb piss", "BRB", "üöΩ"));
		DEFAULT_KEYWORDS.put("brb bathroom", new CustomKeyword("brb bathroom", "BRB", "üöΩ"));
		DEFAULT_KEYWORDS.put("gonna go eat", new CustomKeyword("gonna go eat", "Getting Food", "üçî"));
		DEFAULT_KEYWORDS.put("going to eat", new CustomKeyword("going to eat", "Getting Food", "üçî"));
		DEFAULT_KEYWORDS.put("gonna eat", new CustomKeyword("gonna eat", "Getting Food", "üçî"));
		DEFAULT_KEYWORDS.put("brb food", new CustomKeyword("brb food", "Getting Food", "üçî"));
		DEFAULT_KEYWORDS.put("brb eating", new CustomKeyword("brb eating", "Getting Food", "üçî"));
		DEFAULT_KEYWORDS.put("brb coffee", new CustomKeyword("brb coffee", "Getting Coffee", "‚òï"));
		DEFAULT_KEYWORDS.put("gonna get coffee", new CustomKeyword("gonna get coffee", "Getting Coffee", "‚òï"));
		DEFAULT_KEYWORDS.put("going to get coffee", new CustomKeyword("going to get coffee", "Getting Coffee", "‚òï"));
		DEFAULT_KEYWORDS.put("brb smoke", new CustomKeyword("brb smoke", "BRB Smoke", "üö¨"));
		DEFAULT_KEYWORDS.put("brb smoking", new CustomKeyword("brb smoking", "BRB Smoke", "üö¨"));
		DEFAULT_KEYWORDS.put("gonna smoke", new CustomKeyword("gonna smoke", "BRB Smoke", "üö¨"));
		DEFAULT_KEYWORDS.put("going to smoke", new CustomKeyword("going to smoke", "BRB Smoke", "üö¨"));
		DEFAULT_KEYWORDS.put("brb shower", new CustomKeyword("brb shower", "BRB Shower", "üöø"));
		DEFAULT_KEYWORDS.put("gonna shower", new CustomKeyword("gonna shower", "BRB Shower", "üöø"));
		DEFAULT_KEYWORDS.put("going to shower", new CustomKeyword("going to shower", "BRB Shower", "üöø"));
		DEFAULT_KEYWORDS.put("brb phone", new CustomKeyword("brb phone", "BRB Phone", "üì±"));
		DEFAULT_KEYWORDS.put("phone call", new CustomKeyword("phone call", "BRB Phone", "üì±"));
		DEFAULT_KEYWORDS.put("brb call", new CustomKeyword("brb call", "BRB Phone", "üì±"));
	}

	private final Map<String, WorldPoint> playerPositions = new ConcurrentHashMap<>();
	private static final String[] KEYWORDS = {"brb", "be right back", "afk", "away"};
	private static final Pattern TIME_PATTERN = Pattern.compile(
		"(\\d+)\\s*(min(?:ute)?s?|sec(?:ond)?s?|m|s)",
		Pattern.CASE_INSENSITIVE
	);

	public String normalizePlayerName(String name)
	{
		if (name == null)
		{
			return null;
		}
		return name.replaceAll("<img=\\d+>", "")
			.replaceAll("\\p{Zs}+", " ")
			.replaceAll("\\s+", " ")
			.trim();
	}

	@Override
	protected void startUp() throws Exception
	{
		overlayManager.add(overlay);
		overlayManager.add(minimapOverlay);
		parseCustomKeywords();
	}

	private void parseCustomKeywords()
	{
		customKeywords.clear();
		customKeywords.putAll(DEFAULT_KEYWORDS);
		
		String keywordsStr = config.customKeywords();
		if (keywordsStr == null || keywordsStr.trim().isEmpty())
		{
			return;
		}

		String[] entries = keywordsStr.split(",");
		for (String entry : entries)
		{
			String[] parts = entry.trim().split(":");
			if (parts.length >= 2)
			{
				String keyword = parts[0].trim().toLowerCase();
				String status = parts[1].trim();
				String icon = parts.length >= 3 ? parts[2].trim() : "";
				customKeywords.put(keyword, new CustomKeyword(keyword, status, icon));
			}
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(overlay);
		overlayManager.remove(minimapOverlay);
		afkPlayers.clear();
		playerStats.clear();
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.PUBLICCHAT && 
			event.getType() != ChatMessageType.PRIVATECHAT &&
			event.getType() != ChatMessageType.MODCHAT &&
			event.getType() != ChatMessageType.FRIENDSCHAT)
		{
			return;
		}

		String message = event.getMessage();
		if (message == null)
		{
			return;
		}

		message = message.toLowerCase();
		String rawPlayerName = event.getName();
		String playerName = normalizePlayerName(rawPlayerName);
		
		if (playerName == null || playerName.isEmpty())
		{
			return;
		}

		// If player is already AFK and types anything, remove AFK status
		if (afkPlayers.containsKey(playerName))
		{
			afkPlayers.remove(playerName);
			playerPositions.remove(playerName);
		}
		
		// Check if they said "back" - if so, just return (no new status)
		Pattern backPattern = Pattern.compile("\\bback\\b", Pattern.CASE_INSENSITIVE);
		if (backPattern.matcher(message).find())
		{
			return;
		}

		CustomKeyword customKeyword = null;
		for (Map.Entry<String, CustomKeyword> entry : customKeywords.entrySet())
		{
			String keyword = entry.getKey();
			Pattern keywordPattern = Pattern.compile("(^|\\s)" + Pattern.quote(keyword) + "(\\s|$|[.,!?])", Pattern.CASE_INSENSITIVE);
			if (keywordPattern.matcher(message).find())
			{
				customKeyword = entry.getValue();
				break;
			}
		}

		boolean hasKeyword = false;
		if (customKeyword == null)
		{
			for (String keyword : KEYWORDS)
			{
				Pattern keywordPattern = Pattern.compile("\\b" + Pattern.quote(keyword) + "(?=\\s|\\d|\\b|$)", Pattern.CASE_INSENSITIVE);
				if (keywordPattern.matcher(message).find())
				{
					hasKeyword = true;
					break;
				}
			}
		}

		if (!hasKeyword && customKeyword == null)
		{
			return;
		}

		if (customKeyword != null)
		{
			String statusText = customKeyword.getStatusText();
			String icon = customKeyword.getIcon();
			
			long durationMs = 0;
			Matcher timeMatcher = TIME_PATTERN.matcher(message);
			if (timeMatcher.find())
			{
				try
				{
					int amount = Integer.parseInt(timeMatcher.group(1));
					String unit = timeMatcher.group(2).toLowerCase();
					
					if (unit.startsWith("min") || unit.equals("m"))
					{
						if (amount > 60) amount = 60;
						durationMs = amount * 60 * 1000L;
						statusText += " " + amount + " min" + (amount != 1 ? "s" : "");
					}
					else if (unit.startsWith("sec") || unit.equals("s"))
					{
						durationMs = amount * 1000L;
						statusText += " " + amount + " sec" + (amount != 1 ? "s" : "");
					}
				}
				catch (NumberFormatException e)
				{
					// Invalid time amount, ignore
				}
			}
			
			AfkStatus existingStatus = afkPlayers.get(playerName);
			int streak = (existingStatus != null) ? existingStatus.getStreak() + 1 : 1;
			
			long currentTime = System.currentTimeMillis();
			long endTime = durationMs > 0 ? currentTime + durationMs : 0;
			long startTime = existingStatus != null && existingStatus.getEndTime() == 0 
				? existingStatus.getStartTime() 
				: currentTime;
			
			AfkStatus status = new AfkStatus(statusText, endTime, startTime, streak, currentTime, icon);
			afkPlayers.put(playerName, status);
			updateStatistics(playerName, durationMs);
			return;
		}

		long durationMs = 0;
		String statusText = "AFK";
		String icon = "‚è∏Ô∏è";

		Pattern brbPattern = Pattern.compile("\\b(brb|be right back)(?=\\s|\\d|\\b|$)", Pattern.CASE_INSENSITIVE);
		Pattern afkPattern = Pattern.compile("\\bafk(?=\\s|\\d|\\b|$)", Pattern.CASE_INSENSITIVE);
		boolean isBrb = brbPattern.matcher(message).find();
		boolean isAfk = afkPattern.matcher(message).find();
		
		if (isBrb)
		{
			statusText = "BRB";
			icon = "üí§";
		}
		else if (isAfk)
		{
			statusText = "AFK";
			icon = "‚è∏Ô∏è";
		}
		
		Matcher timeMatcher = TIME_PATTERN.matcher(message);
		if (timeMatcher.find())
		{
			try
			{
				int amount = Integer.parseInt(timeMatcher.group(1));
				String unit = timeMatcher.group(2).toLowerCase();
				
				if (unit.startsWith("min") || unit.equals("m"))
				{
					if (amount > 60)
					{
						amount = 60;
					}
					durationMs = amount * 60 * 1000L;
					statusText = statusText + " " + amount + " min" + (amount != 1 ? "s" : "");
					icon = "‚è∞";
				}
				else if (unit.startsWith("sec") || unit.equals("s"))
				{
					durationMs = amount * 1000L;
					statusText = statusText + " " + amount + " sec" + (amount != 1 ? "s" : "");
					icon = "‚è∞";
				}
			}
			catch (NumberFormatException e)
			{
				// Invalid time amount, ignore
			}
		}

		AfkStatus existingStatus = afkPlayers.get(playerName);
		int streak = (existingStatus != null) ? existingStatus.getStreak() + 1 : 1;

		long currentTime = System.currentTimeMillis();
		long endTime = durationMs > 0 ? currentTime + durationMs : 0;
		long startTime = existingStatus != null && existingStatus.getEndTime() == 0 
			? existingStatus.getStartTime() 
			: currentTime;
		
		AfkStatus status = new AfkStatus(statusText, endTime, startTime, streak, currentTime, icon);
		afkPlayers.put(playerName, status);
		
		Player player = findPlayerByName(playerName);
		if (player != null)
		{
			playerPositions.put(playerName, player.getWorldLocation());
		}

		updateStatistics(playerName, durationMs);
	}

	private void updateStatistics(String playerName, long durationMs)
	{
		PlayerStats stats = playerStats.get(playerName);
		if (stats == null)
		{
			stats = new PlayerStats(0, 0, System.currentTimeMillis());
		}
		stats.setAfkCount(stats.getAfkCount() + 1);
		stats.setTotalAfkTime(stats.getTotalAfkTime() + durationMs);
		stats.setLastAfkTime(System.currentTimeMillis());
		playerStats.put(playerName, stats);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		parseCustomKeywords();

		java.util.List<Player> players = client.getPlayers();
		if (players != null)
		{
			for (Player player : players)
			{
				if (player == null || player.getName() == null)
				{
					continue;
				}

				String playerName = normalizePlayerName(player.getName());
				
				if (playerName == null || playerName.isEmpty() || !afkPlayers.containsKey(playerName))
				{
					continue;
				}

				WorldPoint currentPosition = player.getWorldLocation();
				WorldPoint lastPosition = playerPositions.get(playerName);

				if (lastPosition != null && !currentPosition.equals(lastPosition))
				{
					afkPlayers.remove(playerName);
					playerPositions.remove(playerName);
				}
				else
				{
					playerPositions.put(playerName, currentPosition);
				}
			}
		}

		playerPositions.keySet().retainAll(afkPlayers.keySet());

		if (config.autoRemoveInactive())
		{
			long currentTime = System.currentTimeMillis();
			long timeoutMs = config.inactiveTimeoutMinutes() * 60 * 1000L;
			
			afkPlayers.entrySet().removeIf(entry -> {
				AfkStatus status = entry.getValue();
				long inactiveTime = currentTime - status.getLastActivityTime();
				return inactiveTime > timeoutMs;
			});
		}
	}

	@Provides
	BrbConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BrbConfig.class);
	}

	public Map<String, AfkStatus> getAfkPlayers()
	{
		return afkPlayers;
	}

	public Map<String, PlayerStats> getPlayerStats()
	{
		return playerStats;
	}

	public boolean isFriendOrClanMember(String playerName)
	{
		if (!config.highlightFriendsClan() || playerName == null)
		{
			return false;
		}

		String normalizedName = normalizePlayerName(playerName);
		if (client.isFriended(normalizedName, false))
		{
			return true;
		}

		FriendsChatManager friendsChatManager = client.getFriendsChatManager();
		if (friendsChatManager != null)
		{
			for (FriendsChatMember member : friendsChatManager.getMembers())
			{
				if (member != null)
				{
					String memberName = normalizePlayerName(member.getName());
					if (normalizedName.equals(memberName))
					{
						return true;
					}
				}
			}
		}

		ClanChannel clanChannel = client.getClanChannel();
		if (clanChannel != null)
		{
			for (ClanChannelMember member : clanChannel.getMembers())
			{
				if (member != null)
				{
					String memberName = normalizePlayerName(member.getName());
					if (normalizedName.equals(memberName))
					{
						return true;
					}
				}
			}
		}

		return false;
	}

	private Player findPlayerByName(String playerName)
	{
		java.util.List<Player> players = client.getPlayers();
		if (players == null)
		{
			return null;
		}

		for (Player player : players)
		{
			if (player != null)
			{
				String rawName = player.getName();
				String name = normalizePlayerName(rawName);
				
				if (name != null && name.equals(playerName))
				{
					return player;
				}
			}
		}
		
		return null;
	}
}


package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BrbPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BrbPlugin.class);
		RuneLite.main(args);
	}
}


