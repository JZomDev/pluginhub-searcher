package com.discordchatlogger;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup(DiscordChatLoggerConfig.GROUP)
public interface DiscordChatLoggerConfig extends Config{
    String GROUP = "discordchatlogger";

    @ConfigSection(
            name = "Private",
            description = "Options for private message logging",
            position = 100
    )
    String privateOptions = "privateOptions";

    @ConfigItem(
            keyName = "useprivate",
            name = "Log Private Messages",
            description = "Send private messages to discord webhook",
            position = 1,
            section = privateOptions
    )
    default boolean logPrivateChat()
    {
        return false;
    }

    @ConfigItem(
            keyName = "webhookprivate",
            name = "Webhook URL",
            description = "The Discord Webhook URL for private messages",
            position = 2,
            section = privateOptions
    )
    String webhookPrivate();

    @ConfigSection(
            name = "Group",
            description = "Options for group message logging",
            position = 300
    )
    String groupOptions = "groupOptions";

    @ConfigItem(
            keyName = "usegroup",
            name = "Log Group Messages",
            description = "Send group messages to discord webhook",
            position = 1,
            section = groupOptions
    )
    default boolean logGroupChat()
    {
        return false;
    }

    @ConfigItem(
            keyName = "webhookgroup",
            name = "Webhook URL",
            description = "Send group messages to discord webhook",
            position = 2,
            section = groupOptions
    )
    String webhookGroup();

    @ConfigItem(
            keyName = "usegroupname",
            name = "Include Group Name",
            description = "Include group name in discord message",
            position = 3,
            section = groupOptions
    )
    default boolean includeGroupName()
    {
        return true;
    }

    @ConfigSection(
            name = "Friends Chat",
            description = "Options for friends chat message logging",
            position = 200
    )
    String friendsChatOptions = "friendsChatOptions";

    @ConfigItem(
            keyName = "usefriendsChat",
            name = "Log Friends Chat Messages",
            description = "Send friends chat messages to discord webhook",
            position = 1,
            section = friendsChatOptions
    )
    default boolean logFriendsChat() { return false; }

    @ConfigItem(
            keyName = "webhookfriendsChat",
            name = "Webhook URL",
            description = "Send friends chat messages to discord webhook",
            position = 2,
            section = friendsChatOptions
    )
    String webhookFriendsChat();

    @ConfigItem(
            keyName = "includeFriendsChatName",
            name = "Include Friends Chat Name",
            description = "Include friends chat name in discord message",
            position = 3,
            section = friendsChatOptions
    )
    default boolean includeFriendsChatName()
    {
        return true;
    }

    @ConfigSection(
            name = "Clan Chat",
            description = "Options for clan chat message logging",
            position = 200
    )
    String clanChatOptions = "clanChatOptions";

    @ConfigItem(
            keyName = "useClanChat",
            name = "Log Clan Chat Messages",
            description = "Send clan chat messages to discord webhook",
            position = 1,
            section = clanChatOptions
    )
    default boolean logClanChat() { return false; }

    @ConfigItem(
            keyName = "webhookClanChat",
            name = "Webhook URL",
            description = "Send clan chat messages to discord webhook",
            position = 2,
            section = clanChatOptions
    )
    String webhookClanChat();

    @ConfigItem(
            keyName = "includeClanChatName",
            name = "Include Clan Chat Name",
            description = "Include clan chat name in discord message",
            position = 3,
            section = clanChatOptions
    )
    default boolean includeClanChatName()
    {
        return true;
    }

    @ConfigSection(
            name = "Logging",
            description = "General options for logging",
            position = 400
    )
    String loggingOptions = "loggingOptions";

    @ConfigItem(
            keyName = "logself",
            name = "Log Self",
            description = "Include messages sent",
            position = 1,
            section = loggingOptions
    )
    default boolean logSelf()
    {
        return true;
    }

    @ConfigItem(
            keyName = "logOthers",
            name = "Log Others",
            description = "Include messages received",
            position = 2,
            section = loggingOptions
    )
    default boolean logOthers()
    {
        return true;
    }

    @ConfigItem(
            keyName = "includeusername",
            name = "Include Username",
            description = "Include own RSN in the post",
            position = 3,
            section = loggingOptions
    )
    default boolean includeUsername()
    {
        return true;
    }

    @ConfigItem(
            keyName = "includeotherusername",
            name = "Include Other's Username",
            description = "Include Other's RSN in the post",
            position = 4,
            section = loggingOptions
    )
    default boolean includeOtherUsername()
    {
        return true;
    }
}
package com.discordchatlogger;

import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.helpers.*;
import com.discordchatlogger.helpers.clan.ClanChatHelper;
import com.discordchatlogger.helpers.group.GroupChatHelper;
import com.discordchatlogger.helpers.group.GroupMessageHelper;
import com.google.inject.Provides;
import net.runelite.api.*;

import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;


@Slf4j
@PluginDescriptor(
        name = "Discord Chat Logger"
)
public class DiscordChatLoggerPlugin extends Plugin {
    @Provides
    DiscordChatLoggerConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(DiscordChatLoggerConfig.class);
    }
    @Inject private Client client;
    @Inject private DiscordChatLoggerConfig config;
    @Inject private DiscordHelper discordHelper;

    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        ChatMessageType chatMessageType = chatMessage.getType();
        if (chatMessageType == ChatMessageType.GAMEMESSAGE || chatMessageType == ChatMessageType.SPAM) {
            return;
        }
         ChatHelper chatHelper = null;
        switch (chatMessageType) {
            case FRIENDSCHAT:
                chatHelper = new FriendsChatHelper(client, config, chatMessage);
                break;
            case PRIVATECHAT:
            case PRIVATECHATOUT:
                chatHelper = new PrivateChatHelper(client, config, chatMessage);
                break;
            case CLAN_GIM_CHAT:
                chatHelper = new GroupChatHelper(client, config, chatMessage);
                break;
            case CLAN_GIM_MESSAGE:
                chatHelper = new GroupMessageHelper(client, config, chatMessage);
                break;
            case CLAN_CHAT:
                chatHelper = new ClanChatHelper(client, config, chatMessage);
                break;
        }
        if (chatHelper == null) {
            return;
        }

        WebhookBody webhookBody = chatHelper.handleChatMessage(chatMessage);
        if (webhookBody == null) {
            return;
        }
        discordHelper.sendWebhookBody(webhookBody, chatMessageType);
    }
}
package com.discordchatlogger.domain;

import java.util.ArrayList;
import java.util.List;
import lombok.Data;

@Data
public class WebhookBody
{
    private String content;
    private List<Embed> embeds = new ArrayList<>();

    public WebhookBody() {}

    public WebhookBody(String content) {
        this.content = content;
    }

    @Data
    static class Embed
    {
        final UrlEmbed image;
    }

    @Data
    static class UrlEmbed
    {
        final String url;
    }
}

package com.discordchatlogger.helpers;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.utils.ChatMessageUtils;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

public abstract class ChatHelper {
    protected Client client;
    protected DiscordChatLoggerConfig config;
    protected final ChatMessage chatMessage;
    protected final ChatMessageType chatMessageType;
    protected final String playerName;
    protected final String messageAuthor;

    public ChatHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        this.client = client;
        this.config = config;
        this.chatMessage = chatMessage;
        this.chatMessageType = chatMessage.getType();
        this.playerName = client.getLocalPlayer().getName();
        this.messageAuthor = ChatMessageUtils.getSanitizedAuthor(chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (shouldMessageBeLogged()) {
            String stringBuilder = buildPrefix() + buildSuffix();
            return new WebhookBody(stringBuilder);
        } else {
            return null;
        }
    }

    protected boolean shouldMessageBeLogged() {
        if (playerName.equals(messageAuthor) && config.logSelf()) {
            return true;
        } else if (!playerName.equals(messageAuthor) && config.logOthers()) {
            return true;
        }
        return false;
    }

    protected String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        if (playerName.equals(messageAuthor) && config.includeUsername()
                || !playerName.equals(messageAuthor) && config.includeOtherUsername())
            stringBuilder.append("**").append(messageAuthor).append("**").append(" : ");

        return stringBuilder.toString();
    }

    protected String buildSuffix() {
        return ChatMessageUtils.getSanitizedChatContent(chatMessage);
    }
}

package com.discordchatlogger.helpers.clan;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.helpers.ChatHelper;
import com.discordchatlogger.utils.ChatMessageUtils;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

public class ClanChatHelper extends ChatHelper {

    public ClanChatHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        super(client, config, chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (!config.logClanChat())
            return null;
        return super.handleChatMessage(chatMessage);
    }

    @Override
    protected  String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        if (config.includeClanChatName()) {
            String clanChatName = ChatMessageUtils.getSanitizedSender(chatMessage);
            stringBuilder.append("**[").append(clanChatName).append("]** ");
        }
        stringBuilder.append(super.buildPrefix());
        return stringBuilder.toString();
    }
}
package com.discordchatlogger.helpers;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import okhttp3.*;

import static net.runelite.http.api.RuneLiteAPI.GSON;
import javax.inject.Inject;
import java.io.IOException;
import com.google.common.base.Strings;

@Slf4j
public class DiscordHelper {
    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private DiscordChatLoggerConfig config;

    public void sendWebhookBody(WebhookBody webhookBody, ChatMessageType chatMessageType) {
        String configUrl = getWebhookUrl(chatMessageType);
        if (Strings.isNullOrEmpty(configUrl))
                return;

        HttpUrl url = HttpUrl.parse(configUrl);
        MultipartBody.Builder requestBodyBuilder = new MultipartBody.Builder()
                .setType(MultipartBody.FORM)
                .addFormDataPart("payload_json", GSON.toJson(webhookBody));

        buildRequestAndSend(url, requestBodyBuilder);
    }

    private String getWebhookUrl(ChatMessageType chatMessageType) {
        if (chatMessageType == ChatMessageType.PRIVATECHAT || chatMessageType == ChatMessageType.PRIVATECHATOUT) {
            return config.webhookPrivate();
        } else if (chatMessageType == ChatMessageType.FRIENDSCHAT) {
            return config.webhookFriendsChat();
        } else if (chatMessageType == ChatMessageType.CLAN_GIM_CHAT || chatMessageType == ChatMessageType.CLAN_GIM_MESSAGE) {
            return config.webhookGroup();
        } else if (chatMessageType == ChatMessageType.CLAN_CHAT) {
            return config.webhookClanChat();
        } else {
            return null;
        }
    }

    private void buildRequestAndSend(HttpUrl url, MultipartBody.Builder requestBodyBuilder)
    {
        RequestBody requestBody = requestBodyBuilder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(requestBody)
                .build();
        sendRequest(request);
    }

    private void sendRequest(Request request)
    {
        okHttpClient.newCall(request).enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Error submitting webhook", e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException
            {
                response.close();
            }
        });
    }
}

package com.discordchatlogger.helpers;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.utils.ChatMessageUtils;
import com.discordchatlogger.domain.WebhookBody;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;

public class FriendsChatHelper extends ChatHelper {

    public FriendsChatHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        super(client, config, chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (!config.logFriendsChat())
            return null;
        return super.handleChatMessage(chatMessage);
    }

    @Override
    protected  String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        if (config.includeFriendsChatName()) {
            String friendsChatName = ChatMessageUtils.getSanitizedSender(chatMessage);
            stringBuilder.append("**[").append(friendsChatName).append("]** ");
        }
        stringBuilder.append(super.buildPrefix());
        return stringBuilder.toString();
    }
}

package com.discordchatlogger.helpers.group;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.helpers.ChatHelper;
import com.discordchatlogger.utils.ChatMessageUtils;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

public class GroupChatHelper extends ChatHelper {

    public GroupChatHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        super(client, config, chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (!config.logGroupChat())
            return null;
        return super.handleChatMessage(chatMessage);
    }

    @Override
    protected  String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        if (config.includeGroupName()) {
            String groupChatName = ChatMessageUtils.getSanitizedSender(chatMessage);
            stringBuilder.append("**[").append(groupChatName).append("]** ");
        }
        stringBuilder.append(super.buildPrefix());
        return stringBuilder.toString();
    }
}

package com.discordchatlogger.helpers.group;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.helpers.ChatHelper;
import com.discordchatlogger.utils.ChatMessageUtils;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

public class GroupMessageHelper extends ChatHelper {

    public GroupMessageHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        super(client, config, chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (!config.logGroupChat())
            return null;
        return super.handleChatMessage(chatMessage);
    }

    @Override
    protected boolean shouldMessageBeLogged() {
        String sanitizedMessage = chatMessage.getMessage().replaceAll("\\u00a0", " ");
        if (sanitizedMessage.contains(playerName) && config.logSelf()) {
            return true;
        } else if (!sanitizedMessage.contains(playerName) && config.logOthers()) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    protected  String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        if (config.includeGroupName()) {
            String groupChatName = ChatMessageUtils.getSanitizedSender(chatMessage);
            stringBuilder.append("**[").append(groupChatName).append("]** ");
        }
        return stringBuilder.toString();
    }
}

package com.discordchatlogger.helpers;

import com.discordchatlogger.DiscordChatLoggerConfig;
import com.discordchatlogger.domain.WebhookBody;
import com.discordchatlogger.utils.ChatMessageUtils;
import com.google.common.base.Strings;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;

public class PrivateChatHelper extends ChatHelper {
    public PrivateChatHelper(Client client, DiscordChatLoggerConfig config, ChatMessage chatMessage) {
        super(client, config, chatMessage);
    }

    public WebhookBody handleChatMessage(ChatMessage chatMessage) {
        if (!config.logPrivateChat())
            return null;
        return super.handleChatMessage(chatMessage);
    }

    @Override
    protected  String buildPrefix() {
        StringBuilder stringBuilder = new StringBuilder();
        String messageAuthor = null;
        String messageReceiver = null;
        String playerName = client.getLocalPlayer().getName();

        if (chatMessage.getType() == ChatMessageType.PRIVATECHAT && config.logOthers()) {
            messageAuthor = ChatMessageUtils.getSanitizedAuthor(chatMessage);
            messageReceiver = playerName;
        } else if (chatMessage.getType() == ChatMessageType.PRIVATECHATOUT && config.logSelf()) {
            messageAuthor = playerName;
            messageReceiver = ChatMessageUtils.getSanitizedAuthor(chatMessage);
        }

        if (Strings.isNullOrEmpty(messageAuthor) || Strings.isNullOrEmpty(messageReceiver))
            return null;


        if(config.includeOtherUsername()) {
            if (messageAuthor.equals(playerName)) {
                stringBuilder.append("To **").append(messageReceiver).append("**").append(" : ");
            }
            if (messageReceiver.equals(playerName)) {
                stringBuilder.append("From **").append(messageAuthor).append("**").append(" : ");
            }
        }
        return stringBuilder.toString();
    }
}

package com.discordchatlogger.utils;

import net.runelite.api.events.ChatMessage;
import net.runelite.client.util.Text;

public class ChatMessageUtils {
    public static String getSanitizedAuthor(ChatMessage chatMessage) {
        return Text.removeTags(chatMessage.getName()).replaceAll("[^0-9a-zA-Z ]+", " ");
    }

    public static String getSanitizedSender(ChatMessage chatMessage) {
        return Text.removeTags(chatMessage.getSender()).replaceAll("[^0-9a-zA-Z ]+", " ");
    }

    public static String getSanitizedChatContent(ChatMessage chatMessage) {
        String messageContent = Text.removeTags(chatMessage.getMessage());
        return messageContent
                .replaceAll("@everyone", "@ everyone")
                .replaceAll("@here", "@ here")
                .replaceAll("~", "\\~")
                .replaceAll("`", "\\`");
    }
}

package com.discordchatlogger;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DiscordChatLoggerPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DiscordChatLoggerPlugin.class);
		RuneLite.main(args);
	}
}
