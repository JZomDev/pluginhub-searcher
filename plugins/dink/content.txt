package dinkplugin;

import dinkplugin.domain.AchievementDiary;
import dinkplugin.domain.ChatNotificationType;
import dinkplugin.domain.ChatPrivacyMode;
import dinkplugin.domain.ClueTier;
import dinkplugin.domain.CombatAchievementTier;
import dinkplugin.domain.ConfigImportPolicy;
import dinkplugin.domain.ExceptionalDeath;
import dinkplugin.domain.ExternalScreenshotPolicy;
import dinkplugin.domain.FilterMode;
import dinkplugin.domain.LeagueTaskDifficulty;
import dinkplugin.domain.PlayerLookupService;
import dinkplugin.domain.SeasonalPolicy;
import dinkplugin.notifiers.ChatNotifier;
import dinkplugin.util.Utils;
import net.runelite.api.Experience;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

import java.awt.Color;
import java.util.EnumSet;
import java.util.Set;

@ConfigGroup(SettingsManager.CONFIG_GROUP)
public interface DinkPluginConfig extends Config {

    @ConfigSection(
        name = "Webhook Overrides",
        description = "Allows webhook data to be sent to a different URL, for the various notifiers",
        position = -20,
        closedByDefault = true
    )
    String webhookSection = "Webhook Overrides";

    @ConfigSection(
        name = "Collection Log",
        description = "Settings for notifying about collection log",
        position = 0,
        closedByDefault = true
    )
    String collectionSection = "Collection Log";

    @ConfigSection(
        name = "Pet",
        description = "Settings for notifying when obtaining a pet",
        position = 10,
        closedByDefault = true
    )
    String petSection = "Pet";

    @ConfigSection(
        name = "Levels",
        description = "Settings for notifying when levelling a skill",
        position = 20,
        closedByDefault = true
    )
    String levelSection = "Levels";

    @ConfigSection(
        name = "Loot",
        description = "Settings for notifying when loot is dropped",
        position = 30,
        closedByDefault = true
    )
    String lootSection = "Loot";

    @ConfigSection(
        name = "Death",
        description = "Settings for notifying when you die",
        position = 40,
        closedByDefault = true
    )
    String deathSection = "Death";

    @ConfigSection(
        name = "Slayer",
        description = "Settings for notifying when you complete a slayer task",
        position = 50,
        closedByDefault = true
    )
    String slayerSection = "Slayer";

    @ConfigSection(
        name = "Quests",
        description = "Settings for notifying when you complete a quest",
        position = 60,
        closedByDefault = true
    )
    String questSection = "Quests";

    @ConfigSection(
        name = "Clue Scrolls",
        description = "Settings for notifying when you complete a clue scroll",
        position = 70,
        closedByDefault = true
    )
    String clueSection = "Clue Scrolls";

    @ConfigSection(
        name = "Speedruns",
        description = "Settings for notifying when you finish a speedrun",
        position = 80,
        closedByDefault = true
    )
    String speedrunSection = "Speedruns";

    @ConfigSection(
        name = "Kill Count",
        description = "Settings for notifying when you kill a boss",
        position = 90,
        closedByDefault = true
    )
    String killCountSection = "Kill Count";

    @ConfigSection(
        name = "Combat Tasks",
        description = "Settings for notifying when you complete a combat achievement",
        position = 100,
        closedByDefault = true
    )
    String combatTaskSection = "Combat Tasks";

    @ConfigSection(
        name = "Achievement Diary",
        description = "Settings for notifying when you complete an Achievement Diary",
        position = 110,
        closedByDefault = true
    )
    String diarySection = "Achievement Diary";

    @ConfigSection(
        name = "BA Gambles",
        description = "Settings for notifying when you gamble at Barbarian Assault",
        position = 120,
        closedByDefault = true
    )
    String gambleSection = "BA Gambles";

    @ConfigSection(
        name = "Player Kills",
        description = "Settings for notifying when you kill another player",
        position = 130,
        closedByDefault = true
    )
    String pkSection = "Player Kills";

    @ConfigSection(
        name = "Group Storage",
        description = "Settings for notifying when you deposit or withdraw items from group ironman shared storage",
        position = 140,
        closedByDefault = true
    )
    String groupStorageSection = "Group Storage";

    @ConfigSection(
        name = "Grand Exchange",
        description = "Settings for notifying when you buy or sell items from the Grand Exchange",
        position = 150,
        closedByDefault = true
    )
    String grandExchangeSection = "Grand Exchange";

    @ConfigSection(
        name = "Player Trades",
        description = "Settings for notifying when you trade with another player",
        position = 160,
        closedByDefault = true
    )
    String tradeSection = "Player Trades";

    @ConfigSection(
        name = "Custom Chat Messages",
        description = "Settings for notifying when you receive specific messages from the game",
        position = 170,
        closedByDefault = true
    )
    String chatSection = "Custom Chat Messages";

    @ConfigSection(
        name = "External Plugin Requests",
        description = "Settings for notifying when other plugins request Dink notifications to be fired",
        position = 180,
        closedByDefault = true
    )
    String externalSection = "External Plugin Requests";

    @ConfigSection(
        name = "Leagues",
        description = "Settings for notifying when you complete league tasks, unlock areas, and redeem relics",
        position = 200,
        closedByDefault = true
    )
    String leaguesSection = "Leagues";

    @ConfigSection(
        name = "Advanced",
        description = "Do not modify without fully understanding these settings",
        position = 1000,
        closedByDefault = true
    )
    String advancedSection = "Advanced";

    @ConfigItem(
        keyName = VersionManager.VERSION_CONFIG_KEY,
        name = "Plugin Version",
        description = "The latest dink version used by the player that has a notable changelog entry",
        hidden = true
    )
    default String pluginVersion() {
        return "";
    }

    @ConfigItem(
        keyName = "maxRetries",
        name = "Webhook Max Retries",
        description = "The maximum number of retry attempts for sending a webhook message. Negative implies no attempts",
        position = 1000,
        section = advancedSection
    )
    default int maxRetries() {
        return 3;
    }

    @ConfigItem(
        keyName = "baseRetryDelay",
        name = "Webhook Retry Base Delay",
        description = "The base number of milliseconds to wait before attempting a retry for a webhook message",
        position = 1001,
        section = advancedSection
    )
    @Units(Units.MILLISECONDS)
    default int baseRetryDelay() {
        return 2000;
    }

    @ConfigItem(
        keyName = "imageWriteTimeout",
        name = "Image Upload Timeout",
        description = "The maximum number of seconds that uploading a screenshot can take before timing out",
        position = 1002,
        section = advancedSection
    )
    @Units(Units.SECONDS)
    default int imageWriteTimeout() {
        return 30; // elevated from okhttp default of 10
    }

    @ConfigItem(
        keyName = "screenshotScale",
        name = "Screenshot Scale",
        description = "Resizes screenshots in each dimension by the specified percentage.<br/>" +
            "Useful to avoid Discord's max upload size of 8MB or reduce bandwidth",
        position = 1003,
        section = advancedSection
    )
    @Units(Units.PERCENT)
    @Range(min = 1, max = 100)
    default int screenshotScale() {
        return 100;
    }

    @ConfigItem(
        keyName = "discordRichEmbeds",
        name = "Use Rich Embeds",
        description = "Whether Discord's rich embed format should be used for webhooks",
        position = 1004,
        section = advancedSection
    )
    default boolean discordRichEmbeds() {
        return true;
    }

    @ConfigItem(
        keyName = "embedFooterText",
        name = "Embed Footer Text",
        description = "The text in the footer of rich embed webhook messages. If empty, no footer will be sent",
        position = 1005,
        section = advancedSection
    )
    default String embedFooterText() {
        return "Powered by Dink";
    }

    @ConfigItem(
        keyName = "embedFooterIcon",
        name = "Embed Footer Icon",
        description = "The URL for the footer icon image of rich embed webhooks. Requires footer text to not be empty",
        position = 1006,
        section = advancedSection
    )
    default String embedFooterIcon() {
        return "https://github.com/pajlads/DinkPlugin/raw/master/icon.png";
    }

    @ConfigItem(
        keyName = "ignoredNames", // historical name, preserved for backwards compatibility
        name = "Filtered RSNs",
        description = "Restrict what player names can trigger notifications (One name per line)<br/>" +
            "This acts as an allowlist or denylist based on the 'RSN Filter Mode' setting below.",
        position = 1007,
        section = advancedSection
    )
    default String filteredNames() {
        return "";
    }

    @ConfigItem(
        keyName = "nameFilterMode",
        name = "RSN Filter Mode",
        description = "Allow Mode: Only allow notifications for RSNs on the list above (discouraged).<br/>" +
            "Deny Mode: Prevent notifications from RSNs on the list above (default/recommended).",
        position = 1008,
        section = advancedSection
    )
    default FilterMode nameFilterMode() {
        return FilterMode.DENY;
    }

    @ConfigItem(
        keyName = "nameFilterMode",
        name = "",
        description = ""
    )
    void setNameFilterMode(FilterMode filterMode);

    @ConfigItem(
        keyName = "playerLookupService",
        name = "Player Lookup Service",
        description = "The service used to lookup a players account, to make their name clickable in Discord embeds",
        position = 1009,
        section = advancedSection
    )
    default PlayerLookupService playerLookupService() {
        return PlayerLookupService.OSRS_HISCORE;
    }

    @ConfigItem(
        keyName = "chatPrivacy",
        name = "Hide Chat in Images",
        description = "Whether to hide the chat box and private messages when capturing screenshots.<br/>" +
            "Note: visually you may notice the chat box momentarily flicker as it is hidden for the screenshot.<br/>" +
            "Warning: 'Hide Split PMs' has no effect if 'Split friends private chat' is not enabled in the game settings",
        position = 1010,
        section = advancedSection
    )
    default ChatPrivacyMode chatPrivacy() {
        return ChatPrivacyMode.HIDE_SPLIT_PM;
    }

    @ConfigItem(
        keyName = "chatPrivacy",
        name = "",
        description = ""
    )
    void setChatPrivacy(ChatPrivacyMode mode);

    @ConfigItem(
        keyName = "sendDiscordUser",
        name = "Send Discord Profile",
        description = "Whether to send your discord user information to the webhook server via metadata",
        position = 1011,
        section = advancedSection
    )
    default boolean sendDiscordUser() {
        return true;
    }

    @ConfigItem(
        keyName = "sendClanName",
        name = "Send Clan Name",
        description = "Whether to send your clan information to the webhook server via metadata",
        position = 1012,
        section = advancedSection
    )
    default boolean sendClanName() {
        return true;
    }

    @ConfigItem(
        keyName = "sendGroupIronClanName",
        name = "Send GIM Clan Name",
        description = "Whether to send your group ironman clan information to the webhook server via metadata",
        position = 1013,
        section = advancedSection
    )
    default boolean sendGroupIronClanName() {
        return true;
    }

    @ConfigItem(
        keyName = "threadNameTemplate",
        name = "Forum Thread Name",
        description = "Thread name template to use for Discord Forum Channels<br/>" +
            "Use %TYPE% to insert the notification type<br/>" +
            "Use %MESSAGE% to insert the notification message<br/>" +
            "Use %USERNAME% to insert the player name",
        position = 1013,
        section = advancedSection
    )
    default String threadNameTemplate() {
        return "[%TYPE%] %MESSAGE%";
    }

    @ConfigItem(
        keyName = "metadataWebhook",
        name = "Custom Metadata Handler",
        description = "Webhook URL for custom handlers to receive regular information about the player.<br/>" +
            "Not recommended for use with Discord webhooks, as it could cause spam.<br/>" +
            "You can target multiple webhooks by specifying their URLs on separate lines",
        position = 1014,
        section = advancedSection
    )
    default String metadataWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "seasonalPolicy",
        name = "Seasonal Policy",
        description = "Whether to send notifications that occur on seasonal worlds like Leagues.<br/>" +
            "If 'Use Leagues URL' is enabled but no Leagues Override URL is set, notifications will still be sent to your normal webhook URLs.<br/>" +
            "Note: the Leagues-specific notifier uses an independent config option to toggle messages",
        position = 1015,
        section = advancedSection
    )
    default SeasonalPolicy seasonalPolicy() {
        return SeasonalPolicy.FORWARD_TO_LEAGUES;
    }

    @ConfigItem(
        keyName = "seasonalPolicy",
        name = "",
        description = ""
    )
    void setSeasonalPolicy(SeasonalPolicy policy);

    @ConfigItem(
        keyName = "includeLocation",
        name = "Include Location",
        description = "Whether to include the player location and world in notification metadata.",
        position = 1016,
        section = advancedSection
    )
    default boolean includeLocation() {
        return true;
    }

    @ConfigItem(
        keyName = SettingsManager.DYNAMIC_IMPORT_CONFIG_KEY,
        name = "Dynamic Config URL",
        description = "Synchronizes your Dink configuration with the specified URL.<br/>" +
            "Whenever Dink starts, it imports the config offered by the URL.<br/>" +
            "The config applies to all webhooks, so ensure you trust this URL.<br/>" +
            "Only one URL is supported",
        position = 1017,
        section = advancedSection
    )
    default String dynamicConfigUrl() {
        return "";
    }

    @ConfigItem(
        keyName = "importPolicy",
        name = "Import Policy",
        description = "Whether certain settings should be overwritten on import, rather than merging.<br/>" +
            "Relevant for both ::DinkImport and 'Dynamic Config URL'",
        position = 1018,
        section = advancedSection
    )
    default Set<ConfigImportPolicy> importPolicy() {
        return EnumSet.noneOf(ConfigImportPolicy.class);
    }

    @ConfigItem(
        keyName = "includeClientFrame",
        name = "Include Client Frame",
        description = "Whether to include the client frame in screenshots.",
        position = 1019,
        section = advancedSection
    )
    default boolean includeClientFrame() {
        return false;
    }

    @ConfigItem(
        keyName = "embedColor",
        name = "Embed Color",
        description = "The highlight color for rich embeds.",
        position = 1020,
        section = advancedSection
    )
    default Color embedColor() {
        return Utils.PINK;
    }

    @ConfigItem(
        keyName = "discordWebhook", // do not rename; would break old configs
        name = "Primary Webhook URLs",
        description = "The default webhook URL to send notifications to, if no override is specified.<br/>" +
            "You can target multiple webhooks by specifying their URLs on separate lines",
        position = -20
    )
    default String primaryWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "collectionWebhook",
        name = "Collection Webhook Override",
        description = "If non-empty, collection messages are sent to this URL, instead of the primary URL",
        position = -19,
        section = webhookSection
    )
    default String collectionWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "petWebhook",
        name = "Pet Webhook Override",
        description = "If non-empty, pet messages are sent to this URL, instead of the primary URL",
        position = -18,
        section = webhookSection
    )
    default String petWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "levelWebhook",
        name = "Level Webhook Override",
        description = "If non-empty, level up messages are sent to this URL, instead of the primary URL",
        position = -17,
        section = webhookSection
    )
    default String levelWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "lootWebhook",
        name = "Loot Webhook Override",
        description = "If non-empty, loot messages are sent to this URL, instead of the primary URL",
        position = -16,
        section = webhookSection
    )
    default String lootWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "deathWebhook",
        name = "Death Webhook Override",
        description = "If non-empty, death messages are sent to this URL, instead of the primary URL",
        position = -15,
        section = webhookSection
    )
    default String deathWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "slayerWebhook",
        name = "Slayer Webhook Override",
        description = "If non-empty, slayer messages are sent to this URL, instead of the primary URL",
        position = -14,
        section = webhookSection
    )
    default String slayerWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "questWebhook",
        name = "Quest Webhook Override",
        description = "If non-empty, quest messages are sent to this URL, instead of the primary URL",
        position = -13,
        section = webhookSection
    )
    default String questWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "clueWebhook",
        name = "Clue Webhook Override",
        description = "If non-empty, clue messages are sent to this URL, instead of the primary URL",
        position = -12,
        section = webhookSection
    )
    default String clueWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "speedrunWebhook",
        name = "Speedrun Webhook Override",
        description = "If non-empty, speedrun messages are sent to this URL, instead of the primary URL",
        position = -11,
        section = webhookSection
    )
    default String speedrunWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "killCountWebhook",
        name = "Kill Count Webhook Override",
        description = "If non-empty, kill count messages are sent to this URL, instead of the primary URL",
        position = -10,
        section = webhookSection
    )
    default String killCountWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "combatTaskWebhook",
        name = "Combat Task Webhook Override",
        description = "If non-empty, combat task messages are sent to this URL, instead of the primary URL",
        position = -9,
        section = webhookSection
    )
    default String combatTaskWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "diaryWebhook",
        name = "Diary Webhook Override",
        description = "If non-empty, achievement diary messages are sent to this URL, instead of the primary URL",
        position = -8,
        section = webhookSection
    )
    default String diaryWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "gambleWebhook",
        name = "BA Gamble Webhook Override",
        description = "If non-empty, BA gamble messages are sent to this URL, instead of the primary URL",
        position = -7,
        section = webhookSection
    )
    default String gambleWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "pkWebhook",
        name = "Player Kill Webhook Override",
        description = "If non-empty, PK messages are sent to this URL, instead of the primary URL",
        position = -6,
        section = webhookSection
    )
    default String pkWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "groupStorageWebhook",
        name = "Group Storage Webhook Override",
        description = "If non-empty, Group Storage messages are sent to this URL, instead of the primary URL",
        position = -5,
        section = webhookSection
    )
    default String groupStorageWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "grandExchangeWebhook",
        name = "Grand Exchange Webhook Override",
        description = "If non-empty, Grand Exchange messages are sent to this URL, instead of the primary URL",
        position = -4,
        section = webhookSection
    )
    default String grandExchangeWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "tradeWebhook",
        name = "Trade Webhook Override",
        description = "If non-empty, Trading messages are sent to this URL, instead of the primary URL",
        position = -3,
        section = webhookSection
    )
    default String tradeWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "chatWebhook",
        name = "Chat Webhook Override",
        description = "If non-empty, filtered chat messages are sent to this URL, instead of the primary URL",
        position = -2,
        section = webhookSection
    )
    default String chatWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "externalWebhook",
        name = "External Webhook Override",
        description = "If non-empty, external plugin messages that don't provide a custom URL are by default sent to this URL, instead of the primary URL",
        position = -1,
        section = webhookSection
    )
    default String externalWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "leaguesWebhook",
        name = "Leagues Webhook Override",
        description = "If non-empty, Leagues messages are sent to this URL, instead of the primary URL.<br/>" +
            "Note: this only applies to the Leagues notifier, not every notifier in a seasonal world",
        position = 0,
        section = webhookSection
    )
    default String leaguesWebhook() {
        return "";
    }

    @ConfigItem(
        keyName = "collectionLogEnabled",
        name = "Enable collection log",
        description = "Enable notifications for collection log.<br/>" +
            "Requires 'Chat > Collection log - New addition notification' setting to be enabled",
        position = 1,
        section = collectionSection
    )
    default boolean notifyCollectionLog() {
        return false;
    }

    @ConfigItem(
        keyName = "collectionSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 2,
        section = collectionSection
    )
    default boolean collectionSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "collectionNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %ITEM% to insert the item name<br/>" +
            "Use %COMPLETED% to insert the number of completed entries<br/>" +
            "Use %TOTAL_POSSIBLE% to insert the number of possible entries",
        position = 3,
        section = collectionSection
    )
    default String collectionNotifyMessage() {
        return "%USERNAME% has added %ITEM% to their collection";
    }

    @ConfigItem(
        keyName = "petEnabled",
        name = "Enable pets",
        description = "Enable notifications for obtaining pets",
        position = 10,
        section = petSection
    )
    default boolean notifyPet() {
        return false;
    }

    @ConfigItem(
        keyName = "petSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 11,
        section = petSection
    )
    default boolean petSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "petNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %GAME_MESSAGE% to insert the game message associated with this type of pet drop",
        position = 12,
        section = petSection
    )
    default String petNotifyMessage() {
        return "%USERNAME% %GAME_MESSAGE%";
    }

    @ConfigItem(
        keyName = "levelEnabled",
        name = "Enable level",
        description = "Enable notifications for gaining levels",
        position = 20,
        section = levelSection
    )
    default boolean notifyLevel() {
        return false;
    }

    @ConfigItem(
        keyName = "levelSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 21,
        section = levelSection
    )
    default boolean levelSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "levelNotifyVirtual",
        name = "Notify on Virtual Levels",
        description = "Whether level notifications should be fired beyond level 99.<br/>" +
            "Will also notify upon reaching 200M XP",
        position = 22,
        section = levelSection
    )
    default boolean levelNotifyVirtual() {
        return true;
    }

    @ConfigItem(
        keyName = "levelNotifyCombat",
        name = "Notify for Combat Levels",
        description = "Whether notifications should occur for combat level increases",
        position = 23,
        section = levelSection
    )
    default boolean levelNotifyCombat() {
        return false;
    }

    @ConfigItem(
        keyName = "levelInterval",
        name = "Notify Interval",
        description = "Level interval between when a notification should be sent",
        position = 24,
        section = levelSection
    )
    default int levelInterval() {
        return 1;
    }

    @ConfigItem(
        keyName = "levelMinValue",
        name = "Minimum Skill Level",
        description = "The minimum skill level required to send a notification.<br/>" +
            "Useful for filtering out low-level notifications",
        position = 25,
        section = levelSection
    )
    default int levelMinValue() {
        return 1;
    }

    @ConfigItem(
        keyName = "levelIntervalOverride",
        name = "Interval Override Level",
        description = "All level ups starting from this override level send a notification, disregarding the configured Notify Interval.<br/>" +
            "Disabled when set to 0",
        position = 26,
        section = levelSection
    )
    default int levelIntervalOverride() {
        return 0;
    }

    @ConfigItem(
        keyName = "xpInterval",
        name = "Post-99 XP Interval",
        description = "XP interval at which to fire notifications (in millions).<br/>" +
            "Does not apply to skills that are below level 99.<br/>" +
            "Does <i>not</i> depend on the 'Notify on Virtual Levels' setting.<br/>" +
            "If enabled, fires for 200M XP, even if not divisible by the interval.<br/>" +
            "Disabled if set to 0",
        position = 27,
        section = levelSection
    )
    @Units("M xp")
    @Range(max = Experience.MAX_SKILL_XP / 1_000_000) // [0, 200]
    default int xpInterval() {
        return 5;
    }

    @ConfigItem(
        keyName = "levelNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %SKILL% to insert the levelled skill(s)<br/>" +
            "Use %TOTAL_LEVEL% to insert the updated total level<br/>" +
            "Use %TOTAL_XP% to insert the updated overall experience",
        position = 29,
        section = levelSection
    )
    default String levelNotifyMessage() {
        return "%USERNAME% has levelled %SKILL%";
    }

    @ConfigItem(
        keyName = "lootEnabled",
        name = "Enable loot",
        description = "Enable notifications for gaining loot",
        position = 30,
        section = lootSection
    )
    default boolean notifyLoot() {
        return false;
    }

    @ConfigItem(
        keyName = "lootSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 31,
        section = lootSection
    )
    default boolean lootSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "lootIcons",
        name = "Show loot icons",
        description = "Show icons for the loot obtained as additional embeds",
        position = 32,
        section = lootSection
    )
    default boolean lootIcons() {
        return false;
    }

    @ConfigItem(
        keyName = "minLootValue",
        name = "Min Loot value",
        description = "The minimum value of an item for a notification to be sent.<br/>" +
            "For PK chests, the <i>total</i> value of the items is compared with this threshold",
        position = 33,
        section = lootSection
    )
    default int minLootValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "lootImageMinValue",
        name = "Screenshot Min Value",
        description = "The minimum combined loot value to send a screenshot.<br/>" +
            "Must have 'Send Image' enabled",
        position = 34,
        section = lootSection
    )
    default int lootImageMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "lootIncludePlayer",
        name = "Include PK Loot",
        description = "Allow notifications for loot from player kills",
        position = 35,
        section = lootSection
    )
    default boolean includePlayerLoot() {
        return true;
    }

    @ConfigItem(
        keyName = "lootRedirectPlayerKill",
        name = "Send PK Loot to PK URL",
        description = "Whether to send PK loot to the PK override webhook URL, rather than the loot URL.<br/>" +
            "Must have 'Include PK Loot' (above) enabled.<br/>" +
            "Has no effect if the Player Kills notifier override URL is absent",
        position = 35,
        section = lootSection
    )
    default boolean lootRedirectPlayerKill() {
        return false;
    }

    @ConfigItem(
        keyName = "lootIncludeClueScrolls",
        name = "Include Clue Loot",
        description = "Allow notifications for loot from Clue Scrolls",
        position = 36,
        section = lootSection
    )
    default boolean lootIncludeClueScrolls() {
        return true;
    }

    @ConfigItem(
        keyName = "lootIncludeGambles",
        name = "Include BA Gambles",
        description = "Allow notifications for barbarian assault high gambles",
        position = 36,
        section = lootSection
    )
    default boolean lootIncludeGambles() {
        return false;
    }

    @ConfigItem(
        keyName = "lootItemAllowlist",
        name = "Item Allowlist",
        description = "Always fire notifications for these items, despite value settings.<br/>" +
            "Place one item name per line (case-insensitive; asterisks are wildcards)",
        position = 37,
        section = lootSection
    )
    default String lootItemAllowlist() {
        return "";
    }

    @ConfigItem(
        keyName = "lootItemDenylist",
        name = "Item Denylist",
        description = "Never fire notifications for these items, despite value or rarity settings.<br/>" +
            "Place one item name per line (case-insensitive; asterisks are wildcards)",
        position = 37,
        section = lootSection
    )
    default String lootItemDenylist() {
        return "";
    }

    @ConfigItem(
        keyName = "lootRarityThreshold",
        name = "Rarity Override (1 in X)",
        description = "Fires notifications for sufficiently rare drops, despite the 'Min Loot value' threshold.<br/>" +
            "Corresponds to a 1 in X chance. For example, 100 notifies for items with 1% drop rate or rarer.<br/>" +
            "Has no effect when set to zero.<br/>" +
            "Currently only applies to NPC drops",
        position = 38,
        section = lootSection
    )
    default int lootRarityThreshold() {
        return 0;
    }

    @ConfigItem(
        keyName = "lootRarityValueIntersection",
        name = "Require both Rarity and Value",
        description = "Whether items must exceed <i>both</i> the Min Value AND Rarity thresholds to be notified.<br/>" +
            "Does not apply to drops where Dink lacks rarity data.<br/>" +
            "Currently only impacts NPC drops",
        position = 39,
        section = lootSection
    )
    default boolean lootRarityValueIntersection() {
        return false;
    }

    @ConfigItem(
        keyName = "lootNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %LOOT% to insert the loot<br/>" +
            "Use %SOURCE% to show the source of the loot",
        position = 40,
        section = lootSection
    )
    default String lootNotifyMessage() {
        return "%USERNAME% has looted: \n\n%LOOT%\nFrom: %SOURCE%";
    }

    @ConfigItem(
        keyName = "deathEnabled",
        name = "Enable Death",
        description = "Enable notifications for when you die",
        position = 40,
        section = deathSection
    )
    default boolean notifyDeath() {
        return false;
    }

    @ConfigItem(
        keyName = "deathSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 41,
        section = deathSection
    )
    default boolean deathSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "deathEmbedProtected",
        name = "Embed Kept Items",
        description = "Whether embeds of the protected items should be sent to the webhook",
        position = 42,
        section = deathSection
    )
    default boolean deathEmbedKeptItems() {
        return false;
    }

    @ConfigItem(
        keyName = "deathIgnoreSafe",
        name = "Ignore Safe Deaths",
        description = "Whether deaths in safe areas should be ignored.<br/>" +
            "Exceptions to this rule can be configured below",
        position = 43,
        section = deathSection
    )
    default boolean deathIgnoreSafe() {
        return true;
    }

    @ConfigItem(
        keyName = "deathSafeExceptions",
        name = "Safe Exceptions",
        description = "Safe deaths that should trigger notifications even when 'Ignore Safe Deaths' is enabled.<br/>" +
            "Hold Control while clicking on the options to select multiple exceptions",
        position = 44,
        section = deathSection
    )
    default Set<ExceptionalDeath> deathSafeExceptions() {
        return EnumSet.of(ExceptionalDeath.FIGHT_CAVE, ExceptionalDeath.INFERNO);
    }

    @ConfigItem(
        keyName = "deathIgnoredRegions",
        name = "Ignored Region IDs",
        description = "User-specified, comma-separated Region IDs where deaths should be ignored.<br/>" +
            "Use the '::dinkregion' chat command or an online map to obtain the region IDs.<br/>" +
            "For example, Prifddinas spans 12894, 12895, 13150, 13151",
        position = 45,
        section = deathSection
    )
    default String deathIgnoredRegions() {
        return "123, 456, 789";
    }

    @ConfigItem(
        keyName = "deathMinValue",
        name = "Min Lost Value",
        description = "The minimum value of the lost items for a notification to be sent.<br/>" +
            "This setting does not apply for safe deaths",
        position = 46,
        section = deathSection
    )
    default int deathMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "deathNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %VALUELOST% to insert the GE value of the stuff you lost",
        position = 47,
        section = deathSection
    )
    default String deathNotifyMessage() {
        return "%USERNAME% has died...";
    }

    @ConfigItem(
        keyName = "deathNotifPvpEnabled",
        name = "Distinguish PvP deaths",
        description = "Should the plugin use a different message for dying in PvP?",
        position = 48,
        section = deathSection
    )
    default boolean deathNotifPvpEnabled() {
        return true;
    }

    @ConfigItem(
        keyName = "deathNotifPvpMessage",
        name = "PvP notification message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %PKER% to insert the killer<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %VALUELOST% to insert the GE value of the stuff you lost",
        position = 49,
        section = deathSection
    )
    default String deathNotifPvpMessage() {
        return "%USERNAME% has just been PKed by %PKER% for %VALUELOST% gp...";
    }

    @ConfigItem(
        keyName = "slayerEnabled",
        name = "Enable Slayer",
        description = "Enable notifications for when you complete a slayer task",
        position = 50,
        section = slayerSection
    )
    default boolean notifySlayer() {
        return false;
    }

    @ConfigItem(
        keyName = "slayerSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 51,
        section = slayerSection
    )
    default boolean slayerSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "slayerPointThreshold",
        name = "Min Slayer Points",
        description = "The minimum slayer task points to warrant a notification",
        position = 52,
        section = slayerSection
    )
    default int slayerPointThreshold() {
        return 0;
    }

    @ConfigItem(
        keyName = "slayerNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %TASK% to insert your task<br/>" +
            "Use %POINTS% to show how many points you obtained<br/>" +
            "Use %TASKCOUNT% to show how many tasks you have completed",
        position = 53,
        section = slayerSection
    )
    default String slayerNotifyMessage() {
        return "%USERNAME% has completed a slayer task: %TASK%, getting %POINTS% points and making that %TASKCOUNT% tasks completed";
    }

    @ConfigItem(
        keyName = "questEnabled",
        name = "Enable Quest",
        description = "Enable notifications for when you complete a quest",
        position = 60,
        section = questSection
    )
    default boolean notifyQuest() {
        return false;
    }

    @ConfigItem(
        keyName = "questSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 61,
        section = questSection
    )
    default boolean questSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "questNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %QUEST% to insert the quest that you completed",
        position = 62,
        section = questSection
    )
    default String questNotifyMessage() {
        return "%USERNAME% has completed a quest: %QUEST%";
    }

    @ConfigItem(
        keyName = "clueEnabled",
        name = "Enable Clue Scrolls",
        description = "Enable notifications for when you complete a clue scroll",
        position = 70,
        section = clueSection
    )
    default boolean notifyClue() {
        return false;
    }

    @ConfigItem(
        keyName = "clueSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 71,
        section = clueSection
    )
    default boolean clueSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "clueShowItems",
        name = "Show Item Icons",
        description = "Show item icons gained from the clue as embeds",
        position = 72,
        section = clueSection
    )
    default boolean clueShowItems() {
        return false;
    }

    @ConfigItem(
        keyName = "clueMinTier",
        name = "Min Tier",
        description = "The minimum tier of the clue scroll for a notification to be sent",
        position = 73,
        section = clueSection
    )
    default ClueTier clueMinTier() {
        return ClueTier.BEGINNER;
    }

    @ConfigItem(
        keyName = "clueMinValue",
        name = "Min Value",
        description = "The minimum value of the combined items for a notification to be sent",
        position = 74,
        section = clueSection
    )
    default int clueMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "clueImageMinValue",
        name = "Screenshot Min Value",
        description = "The minimum combined value of the items to send a screenshot.<br/>" +
            "Must have 'Send Image' enabled",
        position = 75,
        section = clueSection
    )
    default int clueImageMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "clueNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %CLUE% to insert the clue type<br/>" +
            "Use %LOOT% to show the loot obtained<br/>" +
            "Use %COUNT% to insert how many of those clue types you have completed",
        position = 76,
        section = clueSection
    )
    default String clueNotifyMessage() {
        return "%USERNAME% has completed a %CLUE% clue, they have completed %COUNT%.\nThey obtained:\n\n%LOOT%";
    }

    @ConfigItem(
        keyName = "speedrunEnabled",
        name = "Enable speedruns",
        description = "Enable notifications for when you complete a speedrun",
        position = 80,
        section = speedrunSection
    )
    default boolean notifySpeedrun() {
        return false;
    }

    @ConfigItem(
        keyName = "speedrunSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 81,
        section = speedrunSection
    )
    default boolean speedrunSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "speedrunPBOnly",
        name = "Notify on Personal Best only",
        description = "Enable notifications only for your best runs",
        position = 82,
        section = speedrunSection
    )
    default boolean speedrunPBOnly() {
        return true;
    }

    @ConfigItem(
        keyName = "speedrunPBMessage",
        name = "PB message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/> +" +
            "Use %QUEST% to insert the quest name<br/>" +
            "Use %TIME% to insert your new time",
        position = 83,
        section = speedrunSection
    )
    default String speedrunPBMessage() {
        return "%USERNAME% has just beat their personal best in a speedrun of %QUEST% with a time of %TIME%";
    }

    @ConfigItem(
        keyName = "speedrunMessage",
        name = "Notification message",
        description = "The message to be sent through the webhook.<br/> +" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %QUEST% to insert the quest name<br/>" +
            "Use %TIME% to insert your new time<br/>" +
            "Use %BEST% to insert your PB",
        position = 84,
        section = speedrunSection
    )
    default String speedrunMessage() {
        return "%USERNAME% has just finished a speedrun of %QUEST% with a time of %TIME% (their PB is %BEST%)";
    }

    @ConfigItem(
        keyName = "killCountEnabled",
        name = "Enable Kill Count",
        description = "Enable notifications for boss kill count milestones",
        position = 90,
        section = killCountSection
    )
    default boolean notifyKillCount() {
        return false;
    }

    @ConfigItem(
        keyName = "killCountSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 91,
        section = killCountSection
    )
    default boolean killCountSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "killCountInitial",
        name = "Initial Boss Kill",
        description = "Notify on the first ever kill of any boss",
        position = 92,
        section = killCountSection
    )
    default boolean killCountNotifyInitial() {
        return true;
    }

    @ConfigItem(
        keyName = "killCountPB",
        name = "Personal Best",
        description = "Notify on achieving a new personal best time",
        position = 93,
        section = killCountSection
    )
    default boolean killCountNotifyBestTime() {
        return true;
    }

    @ConfigItem(
        keyName = "killCountInterval",
        name = "Kill Count Interval",
        description = "Interval between when a notification should be sent",
        position = 94,
        section = killCountSection
    )
    default int killCountInterval() {
        return 50;
    }

    @ConfigItem(
        keyName = "killCountPenanceQueen",
        name = "Barbarian Assault",
        description = "Notify for any Penance Queen kills",
        position = 95,
        section = killCountSection
    )
    default boolean killCountPenanceQueen() {
        return true;
    }

    @ConfigItem(
        keyName = "killCountMessage",
        name = "Notification Message",
        description = "The message to be sent to the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %BOSS% to insert the NPC name<br/>" +
            "Use %COUNT% to insert the kill count",
        position = 96,
        section = killCountSection
    )
    default String killCountMessage() {
        return "%USERNAME% has defeated %BOSS% with a completion count of %COUNT%";
    }

    @ConfigItem(
        keyName = "killCountBestTimeMessage",
        name = "PB Notification Message",
        description = "The message to be sent to the webhook upon a personal best time.<br/>" +
            "Use %USERNAME% to insert your username,<br/>" +
            "Use %BOSS% to insert the NPC name<br/>" +
            "Use %COUNT% to insert the kill count<br/>" +
            "Use %TIME% to insert the completion time",
        position = 97,
        section = killCountSection
    )
    default String killCountBestTimeMessage() {
        return "%USERNAME% has defeated %BOSS% with a new personal best time of %TIME% and a completion count of %COUNT%";
    }

    @ConfigItem(
        keyName = "combatTaskEnabled",
        name = "Enable Combat Tasks",
        description = "Enable notifications for combat achievements",
        position = 100,
        section = combatTaskSection
    )
    default boolean notifyCombatTask() {
        return false;
    }

    @ConfigItem(
        keyName = "combatTaskSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 101,
        section = combatTaskSection
    )
    default boolean combatTaskSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "combatTaskMinTier",
        name = "Min Tier",
        description = "Minimum combat achievement tier to warrant a notification",
        position = 102,
        section = combatTaskSection
    )
    default CombatAchievementTier minCombatAchievementTier() {
        return CombatAchievementTier.EASY;
    }

    @ConfigItem(
        keyName = "combatTaskMessage",
        name = "Notification Message",
        description = "The message to be sent to the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %TIER% to insert the task tier<br/>" +
            "Use %TASK% to insert the task name<br/>" +
            "Use %POINTS% to insert the task points<br/>" +
            "Use %TOTAL_POINTS% to insert the total points earned across tasks",
        position = 103,
        section = combatTaskSection
    )
    default String combatTaskMessage() {
        return "%USERNAME% has completed %TIER% combat task: %TASK%";
    }

    @ConfigItem(
        keyName = "combatTaskUnlockMessage",
        name = "Reward Unlock Notification Message",
        description = "The message to be sent to the webhook upon unlocking the rewards for a tier completion.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %TIER% to insert the task tier<br/>" +
            "Use %TASK% to insert the task name<br/>" +
            "Use %POINTS% to insert the task points<br/>" +
            "Use %TOTAL_POINTS% to insert the total points earned across tasks<br/>" +
            "Use %COMPLETED% to insert the completed tier",
        position = 104,
        section = combatTaskSection
    )
    default String combatTaskUnlockMessage() {
        return "%USERNAME% has unlocked the rewards for the %COMPLETED% tier, by completing the combat task: %TASK%";
    }

    @ConfigItem(
        keyName = "diaryEnabled",
        name = "Enable Diary",
        description = "Enable notifications for achievement diary completions",
        position = 110,
        section = diarySection
    )
    default boolean notifyAchievementDiary() {
        return false;
    }

    @ConfigItem(
        keyName = "diarySendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 111,
        section = diarySection
    )
    default boolean diarySendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "diaryMinDifficulty",
        name = "Min Difficulty",
        description = "Minimum achievement diary difficulty to warrant a notification",
        position = 112,
        section = diarySection
    )
    default AchievementDiary.Difficulty minDiaryDifficulty() {
        return AchievementDiary.Difficulty.EASY;
    }

    @ConfigItem(
        keyName = "diaryMessage",
        name = "Notification Message",
        description = "The message to be sent to the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %DIFFICULTY% to insert the diary difficulty<br/>" +
            "Use %AREA% to insert the diary area<br/>" +
            "Use %TOTAL% to insert the total diaries completed<br/>" +
            "Use %TASKS_COMPLETE% to insert the tasks completed across all diaries<br/>" +
            "Use %TASKS_TOTAL% to insert the total tasks possible across all diaries<br/>" +
            "Use %AREA_TASKS_COMPLETE% to insert the tasks completed within the area<br/>" +
            "Use %AREA_TASKS_TOTAL% to insert the total tasks possible within the area",
        position = 113,
        section = diarySection
    )
    default String diaryNotifyMessage() {
        return "%USERNAME% has completed the %DIFFICULTY% %AREA% Achievement Diary, for a total of %TOTAL% diaries completed";
    }

    @ConfigItem(
        keyName = "gambleEnabled",
        name = "Enable BA Gamble",
        description = "Enable notifications for Barbarian Assault high level gambles",
        position = 120,
        section = gambleSection
    )
    default boolean notifyGamble() {
        return false;
    }

    @ConfigItem(
        keyName = "gambleSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 121,
        section = gambleSection
    )
    default boolean gambleSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "gambleInterval",
        name = "Notify Interval",
        description = "Interval between when a notification should be sent",
        position = 122,
        section = gambleSection
    )
    @Range(min = 1)
    default int gambleInterval() {
        return 100;
    }

    @ConfigItem(
        keyName = "gambleRareLoot",
        name = "Always notify for rare loot",
        description = "Always send a notification upon receiving a dragon chainbody or med helm from a gamble",
        position = 123,
        section = gambleSection
    )
    default boolean gambleRareLoot() {
        return true;
    }

    @ConfigItem(
        keyName = "gambleNotifMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook every gamble interval.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %COUNT% to insert the gamble count<br/>" +
            "Use %LOOT% to insert the loot",
        position = 124,
        section = gambleSection
    )
    default String gambleNotifyMessage() {
        return "%USERNAME% has reached %COUNT% high gambles";
    }

    @ConfigItem(
        keyName = "gambleRareNotifMessage",
        name = "Rare Loot Notification Message",
        description = "The message to be sent through the webhook for rare loot.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %COUNT% to insert the gamble count<br/>" +
            "Use %LOOT% to insert the loot",
        position = 125,
        section = gambleSection
    )
    default String gambleRareNotifyMessage() {
        return "%USERNAME% has received rare loot at gamble count %COUNT%: \n\n%LOOT%";
    }

    @ConfigItem(
        keyName = "pkEnabled",
        name = "Enable Player Kills",
        description = "Enable notifications upon killing other players",
        position = 130,
        section = pkSection
    )
    default boolean notifyPk() {
        return false;
    }

    @ConfigItem(
        keyName = "pkSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 131,
        section = pkSection
    )
    default boolean pkSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "pkSkipSafe",
        name = "Ignore Safe Deaths",
        description = "Whether notifications should be skipped for kills in safe areas.<br/>" +
            "This includes Clan Wars, Duel Arena, Fight Pit, Last Man Standing, etc.",
        position = 132,
        section = pkSection
    )
    default boolean pkSkipSafe() {
        return true;
    }

    @ConfigItem(
        keyName = "pkSkipFriendly",
        name = "Ignore Friendlies",
        description = "Whether notifications should be skipped upon killing friends, clan members, or team mates",
        position = 133,
        section = pkSection
    )
    default boolean pkSkipFriendly() {
        return false;
    }

    @ConfigItem(
        keyName = "pkMinValue",
        name = "Min Value",
        description = "The minimum value of the victim's visible equipment to send a notification.<br/>" +
            "This does not include equipment you cannot see or items in their inventory.",
        position = 134,
        section = pkSection
    )
    default int pkMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "pkIncludeLocation",
        name = "Include Location",
        description = "Whether notifications should include the world and location of the killed player.",
        position = 135,
        section = pkSection
    )
    default boolean pkIncludeLocation() {
        return true;
    }

    @ConfigItem(
        keyName = "pkNotifyMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %TARGET% to insert the victim's username",
        position = 136,
        section = pkSection
    )
    default String pkNotifyMessage() {
        return "%USERNAME% has PK'd %TARGET%";
    }

    @ConfigItem(
        keyName = "groupStorageEnabled",
        name = "Enable Transactions",
        description = "Enable notifications upon group storage transactions",
        position = 140,
        section = groupStorageSection
    )
    default boolean notifyGroupStorage() {
        return false;
    }

    @ConfigItem(
        keyName = "groupStorageSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 141,
        section = groupStorageSection
    )
    default boolean groupStorageSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "groupStorageMinValue",
        name = "Min Value",
        description = "The minimum value of the deposits or withdrawals to send a notification",
        position = 142,
        section = groupStorageSection
    )
    default int groupStorageMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "groupStorageIncludeClan",
        name = "Include Group Name",
        description = "Whether notifications should include the GIM clan name",
        position = 143,
        section = groupStorageSection
    )
    default boolean groupStorageIncludeClan() {
        return true;
    }

    @ConfigItem(
        keyName = "groupStorageIncludePrice",
        name = "Include Price",
        description = "Whether price should be included on individual items,<br/>" +
            "and a Net Value field generated for notifications",
        position = 144,
        section = groupStorageSection
    )
    default boolean groupStorageIncludePrice() {
        return true;
    }

    @ConfigItem(
        keyName = "groupStorageNotifyMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %DEPOSITED% to insert the list of deposited items<br/>" +
            "Use %WITHDRAWN% to insert the list of withdrawn items",
        position = 145,
        section = groupStorageSection
    )
    default String groupStorageNotifyMessage() {
        return "%USERNAME% has deposited:\n%DEPOSITED%\n\n%USERNAME% has withdrawn:\n%WITHDRAWN%";
    }

    @ConfigItem(
        keyName = "notifyGrandExchange",
        name = "Enable GE Transactions",
        description = "Enable notifications upon grand exchange transactions",
        position = 150,
        section = grandExchangeSection
    )
    default boolean notifyGrandExchange() {
        return false;
    }

    @ConfigItem(
        keyName = "grandExchangeSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 151,
        section = grandExchangeSection
    )
    default boolean grandExchangeSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "grandExchangeIncludeCancelled",
        name = "Include Cancelled",
        description = "Enable notifications upon cancelling offers.<br/>" +
            "Cancellation events require the trade's partial progress to exceed the configured minimum value.<br/>" +
            "If 'Min Value' is set to 0, then cancellation events will also fire for completely unfilled orders",
        position = 152,
        section = grandExchangeSection
    )
    default boolean grandExchangeIncludeCancelled() {
        return false;
    }

    @ConfigItem(
        keyName = "grandExchangeMinValue",
        name = "Min Value",
        description = "The minimum value of the transacted items to send a notification",
        position = 153,
        section = grandExchangeSection
    )
    default int grandExchangeMinValue() {
        return 100_000;
    }

    @Range(min = -1)
    @Units(Units.MINUTES)
    @ConfigItem(
        keyName = "grandExchangeProgressSpacingMinutes",
        name = "In Progress Spacing",
        description = "The number of minutes that must pass since the last notification to notify for an in-progress trade.<br/>" +
            "Set to -1 to never notify for in-progress trades",
        position = 154,
        section = grandExchangeSection
    )
    default int grandExchangeProgressSpacingMinutes() {
        return -1; // corresponds to no notifications for partial progress
    }

    @ConfigItem(
        keyName = "grandExchangeNotifyMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %TYPE% to insert the type of transaction (bought or sold)<br/>" +
            "Use %ITEM% to insert the transacted item<br/>" +
            "Use %STATUS% to insert the trade status (e.g., Completed, In Progress, Cancelled)",
        position = 155,
        section = grandExchangeSection
    )
    default String grandExchangeNotifyMessage() {
        return "%USERNAME% %TYPE% %ITEM% on the GE";
    }

    @ConfigItem(
        keyName = "notifyTrades",
        name = "Enable Trades",
        description = "Enable notifications upon completed player trades",
        position = 160,
        section = tradeSection
    )
    default boolean notifyTrades() {
        return false;
    }

    @ConfigItem(
        keyName = "tradeSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 161,
        section = tradeSection
    )
    default boolean tradeSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "tradeMinValue",
        name = "Min Value",
        description = "The minimum total value of the traded items to send a notification",
        position = 162,
        section = tradeSection
    )
    default int tradeMinValue() {
        return 0;
    }

    @ConfigItem(
        keyName = "tradeNotifyMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %COUNTERPARTY% to insert the name of the other player<br/>" +
            "Use %IN_VALUE% to insert the value of the items received from the counterparty<br/>" +
            "Use %OUT_VALUE% to insert the value of the items given to the counterparty",
        position = 163,
        section = tradeSection
    )
    default String tradeNotifyMessage() {
        return "%USERNAME% traded with %COUNTERPARTY%";
    }

    @ConfigItem(
        keyName = "notifyChat",
        name = "Enable Chat Notifications",
        description = "Enable notifications upon receiving specific chat messages",
        position = 170,
        section = chatSection
    )
    default boolean notifyChat() {
        return false;
    }

    @ConfigItem(
        keyName = "chatSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 171,
        section = chatSection
    )
    default boolean chatSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "chatMessageTypes",
        name = "Message Types",
        description = "The types of chat messages that can trigger notifications",
        position = 172,
        section = chatSection
    )
    default Set<ChatNotificationType> chatMessageTypes() {
        return EnumSet.of(ChatNotificationType.GAME, ChatNotificationType.COMMAND);
    }

    @ConfigItem(
        keyName = ChatNotifier.PATTERNS_CONFIG_KEY,
        name = "Message Filters",
        description = "The chat message patterns that should trigger notifications.<br/>" +
            "Place one pattern per line (case-insensitive; asterisks are wildcards)",
        position = 173,
        section = chatSection
    )
    default String chatPatterns() {
        return "You've unlocked an emote: *\n" +
            "You've completed the * event*\n" + // for holiday events
            "You have accepted * into *.\n" + // for clan recruitment
            "You will be logged out in approximately 30 minutes.*\n" +
            "You will be logged out in approximately 10 minutes.*\n" +
            "::TriggerDink\n";
    }

    @ConfigItem(
        keyName = "chatNotifyMessage",
        name = "Notification Message",
        description = "The message to be sent through the webhook.<br/>" +
            "Use %USERNAME% to insert your username<br/>" +
            "Use %MESSAGE% to insert the chat message<br/>" +
            "Use %SENDER% to insert the sender of the message",
        position = 174,
        section = chatSection
    )
    default String chatNotifyMessage() {
        return "%USERNAME% received a chat message:\n\n```\n%MESSAGE%\n```";
    }

    @ConfigItem(
        keyName = "notifyExternal",
        name = "Enable External Plugin Notifications",
        description = "Enable notifications upon requests by other plugins",
        position = 180,
        section = externalSection
    )
    default boolean notifyExternal() {
        return false;
    }

    @ConfigItem(
        keyName = "externalSendImage",
        name = "Send Image",
        description = "Controls whether screenshots should be included with the notification",
        position = 181,
        section = externalSection
    )
    default ExternalScreenshotPolicy externalSendImage() {
        return ExternalScreenshotPolicy.REQUESTED;
    }

    @ConfigItem(
        keyName = "notifyLeagues",
        name = "Enable Leagues",
        description = "Enable notifications upon various leagues events",
        position = 200,
        section = leaguesSection
    )
    default boolean notifyLeagues() {
        return false;
    }

    @ConfigItem(
        keyName = "leaguesSendImage",
        name = "Send Image",
        description = "Send image with the notification",
        position = 201,
        section = leaguesSection
    )
    default boolean leaguesSendImage() {
        return true;
    }

    @ConfigItem(
        keyName = "leaguesAreaUnlock",
        name = "Send Area Unlocks",
        description = "Send notifications upon area unlocks",
        position = 202,
        section = leaguesSection
    )
    default boolean leaguesAreaUnlock() {
        return true;
    }

    @ConfigItem(
        keyName = "leaguesRelicUnlock",
        name = "Send Relic Unlocks",
        description = "Send notifications upon relic unlocks",
        position = 203,
        section = leaguesSection
    )
    default boolean leaguesRelicUnlock() {
        return true;
    }

    @ConfigItem(
        keyName = "leaguesTaskCompletion",
        name = "Send Completed Tasks",
        description = "Send notifications upon completing a task",
        position = 204,
        section = leaguesSection
    )
    default boolean leaguesTaskCompletion() {
        return true;
    }

    @ConfigItem(
        keyName = "leaguesMasteryUnlock",
        name = "Send Mastery Unlocks",
        description = "Send notifications upon combat mastery selections",
        position = 205,
        section = leaguesSection
    )
    default boolean leaguesMasteryUnlock() {
        return true;
    }

    @ConfigItem(
        keyName = "leaguesTaskMinTier",
        name = "Task Min Difficulty",
        description = "The minimum tier of a task for a notification to be sent",
        position = 206,
        section = leaguesSection
    )
    default LeagueTaskDifficulty leaguesTaskMinTier() {
        return LeagueTaskDifficulty.EASY;
    }

}

package dinkplugin.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.time.Duration;
import java.time.format.DateTimeParseException;

/**
 * Serializes and deserializes {@link Duration} instances
 * from their equivalent ISO-8601 string representation.
 * <p>
 * This adapter exists because GSON does not ship with
 * a module for the Java 8 time API.
 *
 * @see <a href="https://github.com/google/gson/issues/1059">GSON Issue</a>
 */
public class DurationAdapter extends TypeAdapter<Duration> {
    @Override
    public void write(JsonWriter out, Duration duration) throws IOException {
        out.value(duration != null ? duration.toString() : null);
    }

    @Override
    public Duration read(JsonReader in) throws IOException {
        if (in.hasNext()) {
            try {
                return Duration.parse(in.nextString());
            } catch (DateTimeParseException ignored) {
            }
        }
        return null;
    }
}

package dinkplugin.util;

import com.google.common.collect.ImmutableSet;
import dinkplugin.message.Embed;
import dinkplugin.message.Field;
import dinkplugin.message.templating.Evaluable;
import dinkplugin.message.templating.Replacements;
import dinkplugin.notifiers.data.SerializedItemStack;
import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.runelite.api.ItemID.*;

@UtilityClass
public class ItemUtils {

    final String ITEM_CACHE_BASE_URL = "https://static.runelite.net/cache/item/";

    public final Collection<Integer> COIN_VARIATIONS = new HashSet<>(ItemVariationMapping.getVariations(ItemID.COINS));

    private final Set<Integer> NEVER_KEPT_ITEMS = ImmutableSet.of(
        CLUE_BOX, LOOTING_BAG, FLAMTAER_BAG, JAR_GENERATOR,
        AMULET_OF_THE_DAMNED, RING_OF_CHAROS, RING_OF_CHAROSA,
        BRACELET_OF_ETHEREUM, BRACELET_OF_ETHEREUM_UNCHARGED,
        AVAS_ACCUMULATOR, AVAS_ATTRACTOR, MAGIC_SECATEURS, MAGIC_BUTTERFLY_NET,
        COOKING_GAUNTLETS, GOLDSMITH_GAUNTLETS, CHAOS_GAUNTLETS, STEEL_GAUNTLETS,
        SILLY_JESTER_HAT, SILLY_JESTER_TOP, SILLY_JESTER_TIGHTS, SILLY_JESTER_BOOTS,
        LUNAR_HELM, LUNAR_TORSO, LUNAR_LEGS, LUNAR_GLOVES, LUNAR_BOOTS,
        LUNAR_CAPE, LUNAR_AMULET, LUNAR_RING, LUNAR_STAFF,
        SHATTERED_RELICS_ADAMANT_TROPHY, SHATTERED_RELICS_BRONZE_TROPHY, SHATTERED_RELICS_DRAGON_TROPHY,
        SHATTERED_RELICS_IRON_TROPHY, SHATTERED_RELICS_MITHRIL_TROPHY, SHATTERED_RELICS_RUNE_TROPHY, SHATTERED_RELICS_STEEL_TROPHY,
        TRAILBLAZER_ADAMANT_TROPHY, TRAILBLAZER_BRONZE_TROPHY, TRAILBLAZER_DRAGON_TROPHY, TRAILBLAZER_IRON_TROPHY,
        TRAILBLAZER_MITHRIL_TROPHY, TRAILBLAZER_RUNE_TROPHY, TRAILBLAZER_STEEL_TROPHY,
        TWISTED_ADAMANT_TROPHY, TWISTED_BRONZE_TROPHY, TWISTED_DRAGON_TROPHY, TWISTED_IRON_TROPHY,
        TWISTED_MITHRIL_TROPHY, TWISTED_RUNE_TROPHY, TWISTED_STEEL_TROPHY
    );

    private final BinaryOperator<Item> SUM_ITEM_QUANTITIES = (a, b) -> new Item(a.getId(), a.getQuantity() + b.getQuantity());
    private final BinaryOperator<ItemStack> SUM_ITEM_STACK_QUANTITIES = (a, b) -> new ItemStack(a.getId(), a.getQuantity() + b.getQuantity());

    public boolean isItemNeverKeptOnDeath(int itemId) {
        // https://oldschool.runescape.wiki/w/Items_Kept_on_Death#Items_that_are_never_kept
        // https://oldschoolrunescape.fandom.com/wiki/Items_Kept_on_Death#Items_that_are_never_kept
        return NEVER_KEPT_ITEMS.contains(itemId);
    }

    public long getPrice(@NotNull ItemManager itemManager, int itemId) {
        return getPrice(itemManager, itemId, null);
    }

    private int getPrice(@NotNull ItemManager itemManager, int itemId, @Nullable ItemComposition item) {
        // GE price sourced from wiki with anti-manipulation massaging by runelite
        int price = itemManager.getItemPrice(itemId);
        if (price <= 0) {
            // fallback: store price
            ItemComposition ic = item != null ? item : itemManager.getItemComposition(itemId);
            price = ic.getPrice();
        }
        return price;
    }

    public long getTotalPrice(@NotNull Iterable<SerializedItemStack> items) {
        long sum = 0L;
        for (SerializedItemStack item : items) {
            sum += item.getTotalPrice();
        }
        return sum;
    }

    public Collection<Item> getItems(Client client) {
        return Stream.of(InventoryID.INVENTORY, InventoryID.EQUIPMENT)
            .map(client::getItemContainer)
            .filter(Objects::nonNull)
            .map(ItemContainer::getItems)
            .flatMap(Arrays::stream)
            .filter(Objects::nonNull)
            .filter(item -> item.getId() >= 0) // -1 implies empty slot
            .collect(Collectors.toList());
    }

    public <K, V> Map<K, V> reduce(@NotNull Iterable<V> items, Function<V, K> deriveKey, BinaryOperator<V> aggregate) {
        final Map<K, V> map = new LinkedHashMap<>();
        items.forEach(v -> map.merge(deriveKey.apply(v), v, aggregate));
        return map;
    }

    public Map<Integer, Item> reduceItems(@NotNull Iterable<Item> items) {
        return reduce(items, Item::getId, SUM_ITEM_QUANTITIES);
    }

    @NotNull
    public Collection<ItemStack> reduceItemStack(@NotNull Iterable<ItemStack> items) {
        return reduce(items, ItemStack::getId, SUM_ITEM_STACK_QUANTITIES).values();
    }

    public SerializedItemStack stackFromItem(ItemManager itemManager, Item item) {
        return stackFromItem(itemManager, item.getId(), item.getQuantity());
    }

    public SerializedItemStack stackFromItem(ItemManager itemManager, int id, int quantity) {
        ItemComposition composition = itemManager.getItemComposition(id);
        int price = getPrice(itemManager, id, composition);
        return new SerializedItemStack(id, quantity, price, String.valueOf(composition.getMembersName()));
    }

    public String formatStack(SerializedItemStack item, boolean includePrice) {
        if (includePrice) {
            return String.format("%d x %s (%s)", item.getQuantity(), item.getName(), QuantityFormatter.quantityToStackSize(item.getTotalPrice()));
        }

        return String.format("%d x %s", item.getQuantity(), item.getName());
    }

    public Evaluable templateStack(SerializedItemStack item, boolean includePrice) {
        if (includePrice) {
            return Replacements.ofMultiple("",
                Replacements.ofText(String.valueOf(item.getQuantity())),
                Replacements.ofText(" x "),
                Replacements.ofWiki(item.getName()),
                Replacements.ofText(" (" + QuantityFormatter.quantityToStackSize(item.getTotalPrice()) + ")")
            );
        }

        return Replacements.ofMultiple("",
            Replacements.ofText(String.valueOf(item.getQuantity())),
            Replacements.ofText(" x "),
            Replacements.ofWiki(item.getName())
        );
    }

    public String getItemImageUrl(int itemId) {
        return ITEM_CACHE_BASE_URL + "icon/" + itemId + ".png";
    }

    public String getNpcImageUrl(int npcId) {
        return String.format("https://chisel.weirdgloop.org/static/img/osrs-npc/%d_128.png", npcId);
    }

    public List<Embed> buildEmbeds(int[] itemIds) {
        return Arrays.stream(itemIds)
            .mapToObj(ItemUtils::getItemImageUrl)
            .map(Embed::ofImage)
            .collect(Collectors.toList());
    }

    public String formatGold(long amount) {
        return Field.formatBlock("ldif", QuantityFormatter.quantityToStackSize(amount) + " gp");
    }

}

package dinkplugin.util;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

/**
 * This thread-safe singleton holds a mapping of item names to their item id, using the RuneLite API.
 * <p>
 * Unlike {@link net.runelite.client.game.ItemManager#search(String)}, this mapping supports untradable items.
 */
@Slf4j
@Singleton
public class ItemSearcher {
    private final Map<String, Integer> itemIdByName = Collections.synchronizedMap(new HashMap<>(16384));
    private @Inject OkHttpClient httpClient;
    private @Inject Gson gson;

    /**
     * @param name the exact in-game name of an item
     * @return the id associated with the item name, or null if not found
     */
    @Nullable
    public Integer findItemId(@NotNull String name) {
        return itemIdByName.get(name);
    }

    /**
     * Begins the initialization process for {@link #itemIdByName}
     * by querying item names and noted item ids from the RuneLite API,
     * before passing them to {@link #populate(Map, Set)}
     *
     * @implNote This operation does not block the current thread,
     * by utilizing OkHttp's thread pool and Java's Fork-Join common pool.
     */
    @Inject
    void init() {
        queryNamesById()
            .thenAcceptBothAsync(
                queryNotedItemIds().exceptionally(e -> {
                    log.error("Failed to read noted items", e);
                    return Collections.emptySet();
                }),
                this::populate
            )
            .exceptionally(e -> {
                log.error("Failed to read item names", e);
                return null;
            });
    }

    /**
     * Populates {@link #itemIdByName} with the inverted mappings of {@code namesById},
     * while skipping noted items specified in {@code notedIds}.
     *
     * @param namesById a mapping of item id's to the corresponding in-game name
     * @param notedIds  the id's of noted items
     * @implNote When multiple non-noted item id's have the same in-game name, only the earliest id is saved
     */
    @VisibleForTesting
    void populate(@NotNull Map<Integer, String> namesById, @NotNull Set<Integer> notedIds) {
        namesById.forEach((id, name) -> {
            if (!notedIds.contains(id))
                itemIdByName.putIfAbsent(name, id);
        });

        log.debug("Completed initialization of item cache with {} entries", itemIdByName.size());
    }

    /**
     * @return a mapping of item ids to their in-game names, provided by the RuneLite API
     */
    private CompletableFuture<Map<Integer, String>> queryNamesById() {
        return queryCache("names.json", new TypeToken<Map<Integer, String>>() {});
    }

    /**
     * @return a set of id's of noted items, provided by the RuneLite API
     */
    private CompletableFuture<Set<Integer>> queryNotedItemIds() {
        return queryCache("notes.json", new TypeToken<Map<Integer, Integer>>() {})
            .thenApply(Map::keySet);
    }

    /**
     * @param fileName the name of the file to query from RuneLite's cache
     * @param type     a type token that indicates how the json response should be parsed
     * @return the transformed cache response, wrapped in a future
     */
    private <T> CompletableFuture<T> queryCache(@NotNull String fileName, @NotNull TypeToken<T> type) {
        return Utils.readJson(httpClient, gson, ItemUtils.ITEM_CACHE_BASE_URL + fileName, type);
    }
}

/*
 * Adapted from https://github.com/runelite/runelite/pull/11580
 * which is available under the following license:
 *
 * BSD 2-Clause License
 *
 * Copyright (c) 2016-2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package dinkplugin.util;

import com.google.common.collect.ImmutableList;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@UtilityClass
public class QuestUtils {

    private final Pattern QUEST_PATTERN_1 = Pattern.compile(".+?ve\\.*? (?<verb>been|rebuilt|.+?ed)? ?(?:the )?'?(?<quest>.+?)'?(?: [Qq]uest)?[!.]?$");
    private final Pattern QUEST_PATTERN_2 = Pattern.compile("'?(?<quest>.+?)'?(?: [Qq]uest)? (?<verb>[a-z]\\w+?ed)?(?: f.*?)?[!.]?$");
    private final Collection<String> RFD_TAGS = ImmutableList.of("Another Cook", "freed", "defeated", "saved");
    private final Collection<String> WORD_QUEST_IN_NAME_TAGS = ImmutableList.of("Another Cook", "Doric", "Heroes", "Legends", "Observatory", "Olaf", "Waterfall");
    private final Map<String, String> QUEST_REPLACEMENTS = Map.of(
        "Lumbridge Cook... again", "Another Cook's",
        "Skrach 'Bone Crusher' Uglogwee", "Skrach Uglogwee"
    );

    @Nullable
    public String parseQuestWidget(final String text) {
        Matcher matcher = getMatcher(text);
        if (matcher == null) {
            log.warn("Unable to match quest: {}", text);
            return null;
        }

        String quest = matcher.group("quest");
        quest = QUEST_REPLACEMENTS.getOrDefault(quest, quest);

        String verb = StringUtils.defaultString(matcher.group("verb"));

        if (verb.contains("kind of")) {
            log.debug("Skipping partial completion of quest: {}", quest);
            return null;
        } else if (verb.contains("completely")) {
            quest += " II";
        }

        if (RFD_TAGS.stream().anyMatch((quest + verb)::contains)) {
            quest = "Recipe for Disaster - " + quest;
        }

        if (WORD_QUEST_IN_NAME_TAGS.stream().anyMatch(quest::contains)) {
            quest += " Quest";
        }

        return quest;
    }

    @Nullable
    private Matcher getMatcher(String text) {
        if (text == null)
            return null;

        // "You have completed The Corsair Curse!"
        Matcher questMatch1 = QUEST_PATTERN_1.matcher(text);
        if (questMatch1.matches())
            return questMatch1;

        // "'One Small Favour' completed!"
        Matcher questMatch2 = QUEST_PATTERN_2.matcher(text);
        if (questMatch2.matches())
            return questMatch2;

        return null;
    }

}

package dinkplugin.util;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import dinkplugin.notifiers.ClueNotifier;
import dinkplugin.notifiers.KillCountNotifier;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.chatcommands.ChatCommandsPlugin;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.LootTrackerConfig;
import net.runelite.client.plugins.loottracker.LootTrackerPlugin;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.OptionalDouble;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

@Slf4j
@Singleton
public class KillCountService {

    public static final String GAUNTLET_NAME = "Gauntlet", GAUNTLET_BOSS = "Crystalline Hunllef";
    public static final String CG_NAME = "Corrupted Gauntlet", CG_BOSS = "Corrupted Hunllef";
    public static final String HERBIBOAR = "Herbiboar";
    public static final String TOA = "Tombs of Amascut";
    public static final String TOB = "Theatre of Blood";
    public static final String COX = "Chambers of Xeric";

    private static final String RL_CHAT_CMD_PLUGIN_NAME = ChatCommandsPlugin.class.getSimpleName().toLowerCase();
    private static final String RL_LOOT_PLUGIN_NAME = LootTrackerPlugin.class.getSimpleName().toLowerCase();
    private static final String RIFT_PREFIX = "Amount of rifts you have closed: ";
    private static final String HERBIBOAR_PREFIX = "Your herbiboar harvest count is: ";

    public static final Set<Integer> SPECIAL_LOOT_NPC_IDS = Set.of(
        NpcID.THE_WHISPERER, NpcID.THE_WHISPERER_12205, NpcID.THE_WHISPERER_12206, NpcID.THE_WHISPERER_12207,
        NpcID.ARAXXOR, NpcID.ARAXXOR_13669, 14148, 14149
    );
    public static final Set<String> SPECIAL_LOOT_NPC_NAMES = Set.of("The Whisperer", "Araxxor", "Branda the Fire Queen", "Eldric the Ice King");

    @Inject
    private ConfigManager configManager;

    @Inject
    private Gson gson;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private RarityService rarityService;

    private final Cache<String, Integer> killCounts = CacheBuilder.newBuilder()
        .expireAfterAccess(10, TimeUnit.MINUTES)
        .maximumSize(64L)
        .build();

    @Getter
    @Nullable
    private Drop lastDrop = null;

    public void reset() {
        this.lastDrop = null;
        this.killCounts.invalidateAll();
    }

    public void onNpcKill(NpcLootReceived event) {
        NPC npc = event.getNpc();
        int id = npc.getId();
        if (SPECIAL_LOOT_NPC_IDS.contains(id)) {
            // LootReceived is fired for certain NPCs rather than NpcLootReceived, but return here just in case upstream changes their implementation.
            return;
        }

        String name = npc.getName();
        if (GAUNTLET_BOSS.equals(name) || CG_BOSS.equals(name)) {
            // already handled by onGameMessage
            return;
        }
        if (name != null) {
            this.incrementKills(LootRecordType.NPC, name, event.getItems());
        }
    }

    public void onPlayerKill(PlayerLootReceived event) {
        String name = event.getPlayer().getName();
        if (name != null) {
            this.incrementKills(LootRecordType.PLAYER, name, event.getItems());
        }
    }

    public void onLoot(LootReceived event) {
        boolean increment;
        switch (event.getType()) {
            case NPC:
                // Special case: upstream fires LootReceived for certain NPCs, but not NpcLootReceived
                increment = SPECIAL_LOOT_NPC_NAMES.contains(event.getName());
                break;
            case PLAYER:
                increment = false; // handled by PlayerLootReceived
                break;
            default:
                increment = true;
                break;
        }

        if (increment) {
            this.incrementKills(event.getType(), getStandardizedSource(event), event.getItems());
        }
    }

    public void onGameMessage(String message) {
        // update cached clue casket count
        Map.Entry<String, Integer> clue = ClueNotifier.parse(message);
        if (clue != null) {
            String tier = Utils.ucFirst(clue.getKey());
            int count = clue.getValue() - 1; // decremented since onLoot will increment
            killCounts.put("Clue Scroll (" + tier + ")", count);
            return;
        }

        // guardians of the rift count (for pet tracking)
        if (message.startsWith(RIFT_PREFIX)) {
            int riftCount = Integer.parseInt(message.substring(RIFT_PREFIX.length(), message.length() - 1).replace(",", ""));
            killCounts.put("Guardians of the Rift", riftCount);
            return;
        }

        // herbiboar count (for pet tracking)
        if (message.startsWith(HERBIBOAR_PREFIX)) {
            int harvestCount = Integer.parseInt(message.substring(HERBIBOAR_PREFIX.length(), message.length() - 1).replace(",", ""));
            killCounts.put(HERBIBOAR, harvestCount);
            return;
        }

        // update cached KC via boss chat message with robustness for chat event coming before OR after the loot event
        KillCountNotifier.parseBoss(message).ifPresent(pair -> {
            String boss = pair.getKey();
            Integer kc = pair.getValue();

            // Update cache. We store kc - 1 since onNpcLootReceived will increment; kc - 1 + 1 == kc
            String cacheKey = getCacheKey(LootRecordType.UNKNOWN, boss);
            killCounts.asMap().merge(cacheKey, kc - 1, Math::max);

            if (boss.equals(GAUNTLET_BOSS) || boss.equals(CG_BOSS) || boss.startsWith(TOA) || boss.startsWith(TOB) || boss.startsWith(COX)) {
                // populate lastDrop to workaround loot tracker quirks
                this.lastDrop = new Drop(boss, LootRecordType.EVENT, Collections.emptyList());

                if (!ConfigUtil.isPluginDisabled(configManager, RL_LOOT_PLUGIN_NAME)) {
                    // onLoot will already increment kc, no need to schedule task below.
                    // this early return also simplifies our test code
                    return;
                }
            }

            // However: we don't know if boss message appeared before/after the loot event.
            // If after, we should store kc. If before, we should store kc - 1.
            // Given this uncertainty, we wait so that the loot event has passed, and then we can store latest kc.
            executor.schedule(() -> {
                killCounts.asMap().merge(cacheKey, kc, Math::max);
            }, 15, TimeUnit.SECONDS);
        });
    }

    public String getStandardizedSource(LootReceived event) {
        if (isCorruptedGauntlet(event)) {
            return KillCountService.CG_NAME;
        } else if (lastDrop != null && shouldUseChatName(event)) {
            return lastDrop.getSource(); // distinguish entry/expert/challenge modes
        }
        return event.getName();
    }

    private boolean shouldUseChatName(LootReceived event) {
        assert lastDrop != null;
        String lastSource = lastDrop.getSource();
        Predicate<String> coincides = source -> source.equals(event.getName()) && lastSource.startsWith(source);
        return coincides.test(TOA) || coincides.test(TOB) || coincides.test(COX);
    }

    /**
     * @param event a loot received event that was just fired
     * @return whether the event represents corrupted gauntlet
     * @apiNote Useful to distinguish normal vs. corrupted gauntlet since the base loot tracker plugin does not,
     * which was <a href="https://github.com/pajlads/DinkPlugin/issues/469">reported</a> to our issue tracker.
     */
    private boolean isCorruptedGauntlet(LootReceived event) {
        return event.getType() == LootRecordType.EVENT && lastDrop != null && "The Gauntlet".equals(event.getName())
            && (CG_NAME.equals(lastDrop.getSource()) || CG_BOSS.equals(lastDrop.getSource()));
    }

    @Nullable
    public Duration getPb(String boss) {
        if (ConfigUtil.isPluginDisabled(configManager, RL_CHAT_CMD_PLUGIN_NAME)) return null;
        Double pb = configManager.getRSProfileConfiguration("personalbest", cleanBossName(boss), double.class);
        if (pb == null) return null;
        int seconds = pb.intValue();
        double millis = (pb - seconds) * 1000;
        return Duration.ofSeconds(seconds).plusMillis((long) millis);
    }

    @Nullable
    public Integer getKillCount(LootRecordType type, String sourceName) {
        if (sourceName == null) return null;
        Integer stored = getStoredKillCount(type, sourceName);
        if (stored != null) {
            return killCounts.asMap().merge(getCacheKey(type, sourceName), stored, Math::max);
        }
        return killCounts.getIfPresent(getCacheKey(type, sourceName));
    }

    private void incrementKills(@NotNull LootRecordType type, @NotNull String sourceName, @NotNull Collection<ItemStack> items) {
        String cacheKey = getCacheKey(type, sourceName);
        killCounts.asMap().compute(cacheKey, (key, cachedKc) -> {
            if (cachedKc != null) {
                // increment kill count
                return cachedKc + 1;
            } else {
                // pull kc from loot tracker or chat commands plugin
                Integer kc = getStoredKillCount(type, sourceName);
                // increment if found
                return kc != null ? kc + 1 : null;
            }
        });
        this.lastDrop = new Drop(sourceName, type, items);
    }

    /**
     * @param type       {@link LootReceived#getType()}
     * @param sourceName {@link NPC#getName()} or {@link LootReceived#getName()}
     * @return the kill count stored by base runelite plugins
     */
    @Nullable
    private Integer getStoredKillCount(@NotNull LootRecordType type, @NotNull String sourceName) {
        // get kc from base runelite chat commands plugin (if enabled)
        if (!ConfigUtil.isPluginDisabled(configManager, RL_CHAT_CMD_PLUGIN_NAME)) {
            Integer kc = configManager.getRSProfileConfiguration("killcount", cleanBossName(sourceName), int.class);
            if (kc != null) {
                return kc - 1; // decremented since chat event typically occurs before loot event
            }
        }

        SerializedLoot lootRecord = getLootTrackerRecord(type, sourceName);
        return lootRecord != null ? lootRecord.getKills() : null;
    }

    @Nullable
    public SerializedLoot getLootTrackerRecord(@NotNull LootRecordType type, @NotNull String sourceName) {
        if (ConfigUtil.isPluginDisabled(configManager, RL_LOOT_PLUGIN_NAME)) {
            // assume stored kc is useless if loot tracker plugin is disabled
            return null;
        }
        String json = configManager.getConfiguration(LootTrackerConfig.GROUP,
            configManager.getRSProfileKey(),
            "drops_" + type + "_" + sourceName
        );
        if (json == null) {
            // no kc stored implies first kill
            return new SerializedLoot();
        }
        try {
            SerializedLoot lootRecord = gson.fromJson(json, SerializedLoot.class);

            // loot tracker doesn't count kill if no loot - https://github.com/runelite/runelite/issues/5077
            OptionalDouble nothingProbability = rarityService.getRarity(sourceName, -1, 0);
            if (nothingProbability.isPresent() && nothingProbability.getAsDouble() < 1.0) {
                // estimate the actual kc (including kills with no loot)
                int kc = (int) Math.round(lootRecord.getKills() / (1 - nothingProbability.getAsDouble()));
                return lootRecord.withKills(kc);
            } else {
                return lootRecord;
            }
        } catch (JsonSyntaxException e) {
            // should not occur unless loot tracker changes stored loot POJO structure
            log.warn("Failed to read kills from loot tracker config", e);
            return null;
        }
    }

    /**
     * @param boss {@link LootReceived#getName()}
     * @return lowercase boss name that {@link ChatCommandsPlugin} uses during serialization
     */
    private static String cleanBossName(String boss) {
        if ("The Gauntlet".equalsIgnoreCase(boss)) return "gauntlet";
        if ("The Leviathan".equalsIgnoreCase(boss)) return "leviathan";
        if ("The Whisperer".equalsIgnoreCase(boss)) return "whisperer";
        if (boss.startsWith("Barrows")) return "barrows chests";
        if (boss.endsWith("Hallowed Sepulchre)")) return "hallowed sepulchre";
        if (boss.endsWith("Tempoross)")) return "tempoross";
        if (boss.endsWith("Wintertodt)")) return "wintertodt";
        return StringUtils.remove(boss.toLowerCase(), ':');
    }

    private static String getCacheKey(@NotNull LootRecordType type, @NotNull String sourceName) {
        switch (type) {
            case PICKPOCKET:
                return "pickpocket_" + sourceName;
            case PLAYER:
                return "player_" + sourceName;
            default:
                if ("The Gauntlet".equals(sourceName)) return GAUNTLET_BOSS;
                if (CG_NAME.equals(sourceName)) return CG_BOSS;
                return sourceName;
        }
    }

}

package dinkplugin.util;

import com.google.gson.Gson;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class RarityService extends AbstractRarityService {
    @Inject
    RarityService(Gson gson, ItemManager itemManager) {
        super("/npc_drops.json", 1024, gson, itemManager);
    }
}

package dinkplugin.util;

import com.google.common.math.DoubleMath;
import lombok.experimental.UtilityClass;

import java.math.BigDecimal;
import java.math.MathContext;

@UtilityClass
public class MathUtils {
    public static final double EPSILON = 0.00001;
    private static final int[] FACTORIALS;

    public int sum(int[] array) {
        int x = 0;
        for (int i : array) {
            x += i;
        }
        return x;
    }

    public boolean lessThanOrEqual(double a, double b) {
        return a < b || DoubleMath.fuzzyEquals(a, b, EPSILON);
    }

    public String formatPercentage(double d, int sigFigs) {
        return BigDecimal.valueOf(d * 100)
            .round(new MathContext(sigFigs))
            .stripTrailingZeros()
            .toPlainString() + '%';
    }

    public double cumulativeGeometric(double p, int kTrials) {
        assert kTrials > 0;
        return 1 - Math.pow(1 - p, kTrials); // https://en.wikipedia.org/wiki/Geometric_distribution
    }

    public double binomialProbability(double p, int nTrials, int kSuccess) {
        // https://en.wikipedia.org/wiki/Binomial_distribution#Probability_mass_function
        return binomialCoefficient(nTrials, kSuccess) * Math.pow(p, kSuccess) * Math.pow(1 - p, nTrials - kSuccess);
    }

    private int binomialCoefficient(int n, int k) {
        assert n < FACTORIALS.length && k <= n && k >= 0;
        return FACTORIALS[n] / (FACTORIALS[k] * FACTORIALS[n - k]); // https://en.wikipedia.org/wiki/nCk
    }

    static {
        // precompute factorials from 0 to 9 for n-choose-k formula
        int n = 10; // max rolls in npc_drops.json is 9 (for Bloodthirsty Leagues IV tier 5 relic)
        int[] facts = new int[n];
        facts[0] = 1; // 0! = 1
        for (int i = 1; i < n; i++) {
            facts[i] = i * facts[i - 1];
        }
        FACTORIALS = facts;
    }
}

package dinkplugin.util;

import com.google.common.collect.ImmutableSet;
import dinkplugin.domain.AccountType;
import dinkplugin.domain.Danger;
import dinkplugin.domain.ExceptionalDeath;
import lombok.experimental.UtilityClass;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.api.WorldView;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.annotations.Varp;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import java.util.Collections;
import java.util.EnumSet;
import java.util.Set;

@UtilityClass
public class WorldUtils {

    private final Set<WorldType> IGNORED_WORLDS = EnumSet.of(WorldType.PVP_ARENA, WorldType.QUEST_SPEEDRUNNING, WorldType.BETA_WORLD, WorldType.NOSAVE_MODE, WorldType.TOURNAMENT_WORLD);

    private final Set<Integer> BA_REGIONS = ImmutableSet.of(7508, 7509, 10322);
    private final Set<Integer> CASTLE_WARS_REGIONS = ImmutableSet.of(9520, 9620);
    private final Set<Integer> CLAN_WARS_REGIONS = ImmutableSet.of(12621, 12622, 12623, 13130, 13131, 13133, 13134, 13135, 13386, 13387, 13390, 13641, 13642, 13643, 13644, 13645, 13646, 13647, 13899, 13900, 14155, 14156);
    private final Set<Integer> COX_REGIONS = ImmutableSet.of(12889, 13136, 13137, 13138, 13139, 13140, 13141, 13145, 13393, 13394, 13395, 13396, 13397, 13401);
    private final Set<Integer> GALVEK_REGIONS = ImmutableSet.of(6486, 6487, 6488, 6489, 6742, 6743, 6744, 6745);
    private final Set<Integer> GAUNTLET_REGIONS = ImmutableSet.of(7512, 7768, 12127); // includes CG
    private final Set<Integer> LMS_REGIONS = ImmutableSet.of(13658, 13659, 13660, 13914, 13915, 13916, 13918, 13919, 13920, 14174, 14175, 14176, 14430, 14431, 14432);
    private final Set<Integer> POH_REGIONS = ImmutableSet.of(7257, 7513, 7514, 7769, 7770, 8025, 8026);
    private final Set<Integer> SOUL_REGIONS = ImmutableSet.of(8493, 8748, 8749, 9005);
    private final Set<Integer> TOA_REGIONS = ImmutableSet.of(14160, 14162, 14164, 14674, 14676, 15184, 15186, 15188, 15696, 15698, 15700);
    private final Set<Integer> TOB_REGIONS = ImmutableSet.of(12611, 12612, 12613, 12867, 12869, 13122, 13123, 13125, 13379);
    private final Set<Integer> ZULRAH_REGIONS = Set.of(9007, 9008);
    private final int INFERNO_REGION = 9043;
    private final int CREATURE_GRAVEYARD_REGION = 13462;
    private final int NMZ_REGION = 9033;
    private final int TZHAAR_CAVE = 9551;
    public final @VisibleForTesting int TZHAAR_PIT = 9552;
    public final int FORTIS_REGION = 7216;

    private final @Varbit int KARAMJA_RESURRECTION_USED = 4557;
    private final @Varbit int WESTERN_RESURRECTION_USED = 4565;

    /**
     * @see <a href="https://oldschool.runescape.wiki/w/RuneScape:Varbit/6104">Wiki</a>
     */
    private final @Varbit int DRAGON_SLAYER_II_PROGRESS = 6104;

    /**
     * @see <a href="https://oldschool.runescape.wiki/w/RuneScape:Varplayer/2926">Wiki</a>
     */
    private final @Varp int INSIDE_RAID_OR_CHALLENGE = 2926;

    /**
     * @see <a href="https://chisel.weirdgloop.org/varbs/display?varbit=6104#ChangeFrequencyTitle">Chisel</a>
     */
    private final int DRAGON_SLAYER_II_COMPLETED = 215;

    @Nullable
    public static WorldPoint getLocation(Client client) {
        return getLocation(client, client.getLocalPlayer());
    }

    @Nullable
    public static WorldPoint getLocation(Client client, Actor actor) {
        if (actor == null)
            return null;

        WorldView wv = actor.getWorldView();
        if (wv.isInstance())
            return WorldPoint.fromLocalInstance(client, actor.getLocalLocation(), wv.getPlane());

        return actor.getWorldLocation();
    }

    public boolean isIgnoredWorld(Set<WorldType> worldType) {
        return !Collections.disjoint(IGNORED_WORLDS, worldType);
    }

    public boolean isPvpWorld(Set<WorldType> worldType) {
        return worldType.contains(WorldType.PVP) || worldType.contains(WorldType.DEADMAN);
    }

    public boolean isPvpSafeZone(Client client) {
        Widget widget = client.getWidget(ComponentID.PVP_SAFE_ZONE);
        return widget != null && !widget.isHidden();
    }

    public boolean isBarbarianAssault(int regionId) {
        return BA_REGIONS.contains(regionId);
    }

    public boolean isCastleWars(int regionId) {
        return CASTLE_WARS_REGIONS.contains(regionId);
    }

    public boolean isChambersOfXeric(int regionId) {
        return COX_REGIONS.contains(regionId);
    }

    public boolean isClanWars(int regionId) {
        return CLAN_WARS_REGIONS.contains(regionId);
    }

    public boolean isGalvekRematch(Client client, int regionId) {
        return GALVEK_REGIONS.contains(regionId) && client.getVarbitValue(DRAGON_SLAYER_II_PROGRESS) >= DRAGON_SLAYER_II_COMPLETED;
    }

    public boolean isGauntlet(int regionId) {
        return GAUNTLET_REGIONS.contains(regionId);
    }

    public boolean isInferno(Client client, int regionId) {
        return regionId == INFERNO_REGION && client.getVarpValue(INSIDE_RAID_OR_CHALLENGE) == 0;
    }

    /**
     * Checks whether the player is within TzHaar-Ket-Rak's Challenges
     * The in-game region is the same as the inferno, but a varp value is different
     */
    public boolean isJadChallenges(Client client, int regionId) {
        return regionId == INFERNO_REGION && client.getVarpValue(INSIDE_RAID_OR_CHALLENGE) > 0;
    }

    public boolean isLastManStanding(Client client) {
        if (LMS_REGIONS.contains(getLocation(client).getRegionID()))
            return true;

        Widget widget = client.getWidget(ComponentID.LMS_INGAME_INFO);
        return widget != null && !widget.isHidden();
    }

    public boolean isMageTrainingArena(int regionId) {
        return regionId == CREATURE_GRAVEYARD_REGION;
    }

    public boolean isNightmareZone(int regionId) {
        return regionId == NMZ_REGION;
    }

    public boolean isPestControl(Client client) {
        Widget widget = client.getWidget(ComponentID.PEST_CONTROL_BLUE_SHIELD);
        return widget != null && !widget.isHidden();
    }

    public boolean isPlayerOwnedHouse(int regionId) {
        return POH_REGIONS.contains(regionId);
    }

    public boolean isSafeArea(Client client) {
        return getDangerLevel(client, getLocation(client).getRegionID(), Collections.emptySet()) == Danger.SAFE;
    }

    public boolean isSoulWars(int regionId) {
        return SOUL_REGIONS.contains(regionId);
    }

    public boolean isAmascutTombs(int regionId) {
        return TOA_REGIONS.contains(regionId);
    }

    public boolean isTheatreOfBlood(int regionId) {
        return TOB_REGIONS.contains(regionId);
    }

    public boolean isTzHaarFightCave(int regionId) {
        return regionId == TZHAAR_CAVE;
    }

    public boolean isTzHaarFightPit(int regionId) {
        return regionId == TZHAAR_PIT;
    }

    public boolean isZulrah(int regionId) {
        return ZULRAH_REGIONS.contains(regionId);
    }

    public Danger getDangerLevel(Client client, int regionId, Set<ExceptionalDeath> exceptions) {
        if (isGauntlet(regionId)) {
            // Players can't take items in or out of (Corrupted) Gauntlet, so these deaths are effectively safe
            // However: any Gauntlet death is still dangerous for hardcore (group) ironmen
            return Utils.getAccountType(client).isHardcore() ? Danger.DANGEROUS : Danger.SAFE;
        }

        if (isAmascutTombs(regionId)) {
            // ToA is technically a dangerous activity, but multiple attempts can be permitted
            // the real TOA death is detected via game message in death notifier
            // However: any TOA death is still dangerous for hardcore (group) ironmen
            return checkException(Utils.getAccountType(client).isHardcore(), exceptions, ExceptionalDeath.TOA);
        }

        if (isTheatreOfBlood(regionId)) {
            // ToB is another dangerous activity, but the whole party needs to wipe for it to be a dangerous event
            // So we use HUD text to detect the real tob death in the notifier itself
            // However: any TOB death is still dangerous for hardcore (group) ironmen
            return checkException(Utils.getAccountType(client).isHardcore(), exceptions, ExceptionalDeath.TOB);
        }

        if (isChambersOfXeric(regionId)) {
            return checkException(Utils.getAccountType(client) == AccountType.HARDCORE_GROUP_IRONMAN, exceptions, ExceptionalDeath.COX);
        }

        if (isInferno(client, regionId)) {
            return checkException(Utils.getAccountType(client) == AccountType.HARDCORE_GROUP_IRONMAN, exceptions, ExceptionalDeath.INFERNO);
        }

        if (isJadChallenges(client, regionId)) {
            return checkException(Utils.getAccountType(client) == AccountType.HARDCORE_GROUP_IRONMAN, exceptions, ExceptionalDeath.JAD_CHALLENGES);
        }

        if (isTzHaarFightCave(regionId)) {
            if (Utils.getAccountType(client) == AccountType.HARDCORE_GROUP_IRONMAN) {
                return Danger.DANGEROUS;
            }
            if (exceptions.contains(ExceptionalDeath.FIGHT_CAVE)) {
                return Danger.EXCEPTIONAL;
            }
            if (client.getVarbitValue(KARAMJA_RESURRECTION_USED) == 0 && exceptions.contains(ExceptionalDeath.DIARY_RESURRECTION) && client.getVarbitValue(Varbits.DIARY_KARAMJA_ELITE) > 0) {
                // Karamja Elite diary completion allows 1 free daily resurrection: https://github.com/pajlads/DinkPlugin/issues/548
                return Danger.EXCEPTIONAL;
            }
            return Danger.SAFE;
        }

        if (isZulrah(regionId) && client.getVarbitValue(WESTERN_RESURRECTION_USED) == 0 && client.getVarbitValue(Varbits.DIARY_WESTERN_ELITE) > 0) {
            // Western Provinces Elite diary completion allows 1 free daily resurrection: https://github.com/pajlads/DinkPlugin/issues/548
            return exceptions.contains(ExceptionalDeath.DIARY_RESURRECTION) ? Danger.EXCEPTIONAL : Danger.SAFE;
        }

        if (isBarbarianAssault(regionId) || isNightmareZone(regionId)  || isMageTrainingArena(regionId)
            || isPestControl(client) || isGalvekRematch(client, regionId)) {
            // All PvM activities are dangerous for Hardcore group iron players
            return Utils.getAccountType(client) == AccountType.HARDCORE_GROUP_IRONMAN ? Danger.DANGEROUS : Danger.SAFE;
        }

        if (isCastleWars(regionId) || isClanWars(regionId) || isSoulWars(regionId) || isPlayerOwnedHouse(regionId)
            || isLastManStanding(client) || isTzHaarFightPit(regionId)) {
            return Danger.SAFE;
        }

        return Danger.DANGEROUS;
    }

    private Danger checkException(boolean dangerous, Set<ExceptionalDeath> exceptions, ExceptionalDeath exception) {
        if (dangerous) return Danger.DANGEROUS;
        if (exceptions.contains(exception)) return Danger.EXCEPTIONAL;
        return Danger.SAFE;
    }

}

package dinkplugin.util;

import com.google.common.hash.HashCode;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import dinkplugin.DinkPluginConfig;
import dinkplugin.domain.AccountType;
import dinkplugin.domain.ChatPrivacyMode;
import lombok.experimental.UtilityClass;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Component;
import net.runelite.api.annotations.VarCStr;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.Text;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.imageio.ImageIO;
import javax.swing.SwingUtilities;
import java.awt.Color;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Reader;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.regex.Pattern;

@Slf4j
@UtilityClass
public class Utils {

    public static final String WIKI_IMG_BASE_URL = "https://oldschool.runescape.wiki/images/";

    public final Color GREEN = ColorUtil.fromHex("006c4c"); // dark shade of PINK in CIELCh_uv color space
    public final Color PINK = ColorUtil.fromHex("#f40098"); // analogous to RED in CIELCh_uv color space
    public final Color RED = ColorUtil.fromHex("#ca2a2d"); // red used in pajaW

    private final char ELLIPSIS = '\u2026'; // ''

    @VisibleForTesting
    public final @VarCStr int TOA_MEMBER_NAME = 1099, TOB_MEMBER_NAME = 330;
    private final int TOA_PARTY_MAX_SIZE = 8, TOB_PARTY_MAX_SIZE = 5;

    private final @Component int PRIVATE_CHAT_WIDGET = WidgetUtil.packComponentId(InterfaceID.PRIVATE_CHAT, 0);

    /**
     * Custom padding for applying SHA-256 to a long.
     * SHA-256 adds '0' padding bits such that L+1+K+64 mod 512 == 0.
     * Long is 64 bits and this padding is 376 bits, so L = 440. Thus, minimal K = 7.
     * This padding differentiates our hash results, and only incurs a ~1% performance penalty.
     *
     * @see #dinkHash(long)
     */
    private static final byte[] DINK_HASH_PADDING = "JennaRaidingDreamSeedZeroPercentOptionsForAnts!"
        .getBytes(StandardCharsets.UTF_8); // DO NOT CHANGE

    /**
     * Truncates text at the last space to conform with the specified max length.
     *
     * @param text      The text to be truncated
     * @param maxLength The maximum allowed length of the text
     * @return the truncated text
     */
    public String truncate(String text, int maxLength) {
        if (text.length() <= maxLength) return text;

        int lastSpace = text.lastIndexOf(' ', maxLength - 1);
        if (lastSpace <= 0) {
            return text.substring(0, maxLength - 1) + ELLIPSIS;
        } else {
            return text.substring(0, lastSpace) + ELLIPSIS;
        }
    }

    public String sanitize(String str) {
        if (str == null || str.isEmpty()) return "";
        return Text.removeTags(str.replace("<br>", "\n")).replace('\u00A0', ' ').trim();
    }

    /**
     * Converts text into "upper case first" form, as is used by OSRS for item names.
     *
     * @param text the string to be transformed
     * @return the text with only the first character capitalized
     */
    public String ucFirst(@NotNull String text) {
        if (text.length() < 2) return text.toUpperCase();
        return Character.toUpperCase(text.charAt(0)) + text.substring(1).toLowerCase();
    }

    /**
     * Converts simple patterns (asterisk is the only special character) into regexps.
     *
     * @param pattern a simple pattern (asterisks are wildcards, and the rest is a string literal)
     * @return a compiled regular expression associated with the simple pattern
     * @see DinkPluginConfig#lootItemAllowlist()
     * @see DinkPluginConfig#lootItemDenylist()
     */
    public Pattern regexify(@NotNull String pattern) {
        final int len = pattern.length();
        final StringBuilder sb = new StringBuilder(len + 2 + 4);
        int startIndex = 0;

        if (!pattern.startsWith("*")) {
            sb.append('^');
        } else {
            startIndex++;
        }

        int i;
        while ((i = pattern.indexOf('*', startIndex)) >= 0) {
            String section = pattern.substring(startIndex, i);
            sb.append(Pattern.quote(section));
            sb.append(".*");
            startIndex = i + 1;
        }

        if (startIndex < len) {
            sb.append(Pattern.quote(pattern.substring(startIndex)));
            sb.append('$');
        }

        return Pattern.compile(sb.toString(), Pattern.CASE_INSENSITIVE);
    }

    /**
     * @param a some string
     * @param b another string
     * @return whether either string contains the other
     */
    public boolean containsEither(@NotNull String a, @NotNull String b) {
        if (a.length() >= b.length()) {
            return a.contains(b);
        } else {
            return b.contains(a);
        }
    }

    /**
     * @param client {@link Client}
     * @return the name of the local player
     */
    @Nullable
    public String getPlayerName(Client client) {
        var player = client.getLocalPlayer();
        return player != null ? player.getName() : null;
    }

    /**
     * Transforms the value from {@link Varbits#ACCOUNT_TYPE} to a convenient enum.
     *
     * @param client {@link Client}
     * @return {@link AccountType}
     * @apiNote This function should only be called from the client thread.
     */
    public AccountType getAccountType(@NotNull Client client) {
        return AccountType.get(client.getVarbitValue(Varbits.ACCOUNT_TYPE));
    }

    @Nullable
    public String getChatBadge(@NotNull AccountType type, boolean seasonal) {
        if (seasonal) {
            return WIKI_IMG_BASE_URL + "Leagues_chat_badge.png";
        }
        switch (type) {
            case IRONMAN:
                return WIKI_IMG_BASE_URL + "Ironman_chat_badge.png";
            case ULTIMATE_IRONMAN:
                return WIKI_IMG_BASE_URL + "Ultimate_ironman_chat_badge.png";
            case HARDCORE_IRONMAN:
                return WIKI_IMG_BASE_URL + "Hardcore_ironman_chat_badge.png";
            case GROUP_IRONMAN:
                return WIKI_IMG_BASE_URL + "Group_ironman_chat_badge.png";
            case HARDCORE_GROUP_IRONMAN:
                return WIKI_IMG_BASE_URL + "Hardcore_group_ironman_chat_badge.png";
            case UNRANKED_GROUP_IRONMAN:
                return WIKI_IMG_BASE_URL + "Unranked_group_ironman_chat_badge.png";
            default:
                return null;
        }
    }

    @Nullable
    public Collection<String> getBossParty(@NotNull Client client, @NotNull String source) {
        switch (source) {
            case "Chambers of Xeric":
            case "Chambers of Xeric Challenge Mode":
                return Utils.getXericChambersParty(client);
            case "Tombs of Amascut":
            case "Tombs of Amascut: Entry Mode":
            case "Tombs of Amascut: Expert Mode":
                return Utils.getAmascutTombsParty(client);
            case "Theatre of Blood":
            case "Theatre of Blood: Entry Mode":
            case "Theatre of Blood: Hard Mode":
                return Utils.getBloodTheatreParty(client);
            default:
                return null;
        }
    }

    private Collection<String> getXericChambersParty(@NotNull Client client) {
        Widget widget = client.getWidget(InterfaceID.RAIDING_PARTY, 10);
        if (widget == null) return Collections.emptyList();

        Widget[] children = widget.getChildren();
        if (children == null) return Collections.emptyList();

        List<String> names = new ArrayList<>(children.length / 4);
        for (Widget child : children) {
            String name = sanitize(child.getName());
            if (!name.isEmpty()) {
                names.add(name);
            }
        }
        return names;
    }

    private Collection<String> getAmascutTombsParty(@NotNull Client client) {
        return getVarcStrings(client, TOA_MEMBER_NAME, TOA_PARTY_MAX_SIZE);
    }

    private Collection<String> getBloodTheatreParty(@NotNull Client client) {
        return getVarcStrings(client, TOB_MEMBER_NAME, TOB_PARTY_MAX_SIZE);
    }

    private List<String> getVarcStrings(@NotNull Client client, @VarCStr final int initialVarcId, final int maxSize) {
        List<String> strings = new ArrayList<>(maxSize);
        for (int i = 0; i < maxSize; i++) {
            String name = client.getVarcStrValue(initialVarcId + i);
            if (name == null || name.isEmpty()) continue;
            strings.add(name.replace('\u00A0', ' '));
        }
        return strings;
    }

    public static boolean hideWidget(boolean shouldHide, Client client, @Component int info) {
        if (!shouldHide)
            return false;

        Widget widget = client.getWidget(info);
        if (widget == null || widget.isHidden())
            return false;

        widget.setHidden(true);
        return true;
    }

    public static void unhideWidget(boolean shouldUnhide, Client client, ClientThread clientThread, @Component int info) {
        if (!shouldUnhide)
            return;

        clientThread.invoke(() -> {
            Widget widget = client.getWidget(info);
            if (widget != null)
                widget.setHidden(false);
        });
    }

    public BufferedImage rescale(BufferedImage input, double percent) {
        if (percent + Math.ulp(1.0) >= 1.0)
            return input;

        AffineTransform rescale = AffineTransform.getScaleInstance(percent, percent);
        AffineTransformOp operation = new AffineTransformOp(rescale, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);

        BufferedImage output = new BufferedImage((int) (input.getWidth() * percent), (int) (input.getHeight() * percent), input.getType());
        operation.filter(input, output);
        return output;
    }

    public byte[] convertImageToByteArray(BufferedImage bufferedImage, String format) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        boolean foundWriter = ImageIO.write(bufferedImage, format, byteArrayOutputStream);
        if (!foundWriter)
            throw new IllegalArgumentException(String.format("Specified format '%s' was not in supported formats: %s", format, Arrays.toString(ImageIO.getWriterFormatNames())));
        return byteArrayOutputStream.toByteArray();
    }

    public void captureScreenshot(Client client, ClientThread clientThread, DrawManager drawManager, ImageCapture imageCapture, ExecutorService executor, DinkPluginConfig config, Consumer<Image> consumer) {
        ChatPrivacyMode privacyMode = config.chatPrivacy();
        boolean chatHidden = hideWidget(privacyMode == ChatPrivacyMode.HIDE_ALL, client, ComponentID.CHATBOX_FRAME);
        boolean whispersHidden = hideWidget(privacyMode != ChatPrivacyMode.HIDE_NONE, client, PRIVATE_CHAT_WIDGET);
        drawManager.requestNextFrameListener(frame -> {
            if (config.includeClientFrame()) {
                executor.execute(() -> consumer.accept(imageCapture.addClientFrame(frame)));
            } else {
                consumer.accept(frame);
            }

            unhideWidget(chatHidden, client, clientThread, ComponentID.CHATBOX_FRAME);
            unhideWidget(whispersHidden, client, clientThread, PRIVATE_CHAT_WIDGET);
        });
    }

    public boolean hasImage(@NotNull MultipartBody body) {
        return body.parts().stream().anyMatch(part -> {
            MediaType type = part.body().contentType();
            return type != null && "image".equals(type.type());
        });
    }

    public CompletableFuture<String> readClipboard() {
        CompletableFuture<String> future = new CompletableFuture<>();
        SwingUtilities.invokeLater(() -> {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                String data = (String) clipboard.getData(DataFlavor.stringFlavor);
                future.complete(data);
            } catch (Exception e) {
                log.warn("Failed to read from clipboard", e);
                future.completeExceptionally(e);
            }
        });
        return future;
    }

    public CompletableFuture<Void> copyToClipboard(String text) {
        CompletableFuture<Void> future = new CompletableFuture<>();
        SwingUtilities.invokeLater(() -> {
            try {
                Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                StringSelection content = new StringSelection(text);
                clipboard.setContents(content, content);
                future.complete(null);
            } catch (Exception e) {
                log.warn("Failed to copy to clipboard", e);
                future.completeExceptionally(e);
            }
        });
        return future;
    }

    public <T> CompletableFuture<T> readJson(@NotNull OkHttpClient httpClient, @NotNull Gson gson, @NotNull String url, @NotNull TypeToken<T> type) {
        return readUrl(httpClient, url, reader -> gson.fromJson(reader, type.getType()));
    }

    public <T> CompletableFuture<T> readUrl(@NotNull OkHttpClient httpClient, @NotNull String url, @NotNull Function<Reader, T> transformer) {
        CompletableFuture<T> future = new CompletableFuture<>();
        Request request = new Request.Builder().url(url).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                assert response.body() != null;
                try (Reader reader = response.body().charStream()) {
                    future.complete(transformer.apply(reader));
                } catch (Exception e) {
                    future.completeExceptionally(e);
                } finally {
                    response.close();
                }
            }
        });
        return future;
    }

    /**
     * @param l the long to hash
     * @return SHA-224 with custom padding
     * @see #DINK_HASH_PADDING
     */
    public String dinkHash(long l) {
        MessageDigest hash;
        try {
            hash = MessageDigest.getInstance("SHA-224");
        } catch (NoSuchAlgorithmException e) {
            log.warn("Account hash will not be included in notification metadata", e);
            return null;
        }
        byte[] input = ByteBuffer.allocate(8 + DINK_HASH_PADDING.length)
            .putLong(l)
            .put(DINK_HASH_PADDING)
            .array();
        // noinspection UnstableApiUsage - no longer @Beta as of v32.0.0
        return HashCode.fromBytes(hash.digest(input)).toString();
    }

}

package dinkplugin.util;

import lombok.Value;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;

import java.time.Instant;
import java.util.Collection;

@Value
public class Drop {
    String source;
    LootRecordType category;
    Collection<ItemStack> items;
    Instant time = Instant.now();

    public static String getAction(LootRecordType type) {
        switch (type) {
            case NPC:
                return "Kill";
            case PLAYER:
                return "Player Kill";
            case PICKPOCKET:
                return "Pickpocket";
            default:
                return "Completion";
        }
    }
}

package dinkplugin.util;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.With;

/**
 * Contains kill count observed by base runelite loot tracker plugin, stored in profile configuration.
 *
 * @see <a href="https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/loottracker/ConfigLoot.java#L41">RuneLite class</a>
 */
@Data
@With
@Setter(AccessLevel.PRIVATE)
@NoArgsConstructor
@AllArgsConstructor
public class SerializedLoot {
    private int kills;
    private int[] drops;

    public int getQuantity(int itemId) {
        final int n = drops != null ? drops.length : 0;
        for (int i = 0; i < n; i += 2) {
            if (drops[i] == itemId) {
                return drops[i + 1];
            }
        }
        return 0;
    }
}

package dinkplugin.util;

import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.annotations.Varbit;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import java.time.Duration;
import java.time.LocalTime;
import java.time.temporal.Temporal;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.time.temporal.ChronoField.HOUR_OF_DAY;
import static java.time.temporal.ChronoField.MILLI_OF_SECOND;
import static java.time.temporal.ChronoField.MINUTE_OF_HOUR;
import static java.time.temporal.ChronoField.SECOND_OF_MINUTE;

@UtilityClass
public class TimeUtils {

    private final Pattern TIME_PATTERN = Pattern.compile("\\b(?:(?<hours>\\d+):)?(?<minutes>\\d+):(?<seconds>\\d{2})(?:\\.(?<fractional>\\d{2}))?\\b");

    @VisibleForTesting
    public final @Varbit int ENABLE_PRECISE_TIMING = 11866;

    public boolean isPreciseTiming(@NotNull Client client) {
        return client.getVarbitValue(ENABLE_PRECISE_TIMING) > 0;
    }

    @NotNull
    public Duration parseTime(@NotNull String in) {
        Matcher m = TIME_PATTERN.matcher(in);
        if (!m.find()) return Duration.ZERO;

        int minutes = Integer.parseInt(m.group("minutes"));
        int seconds = Integer.parseInt(m.group("seconds"));

        Duration d = Duration.ofMinutes(minutes).plusSeconds(seconds);

        String hours = m.group("hours");
        if (hours != null) {
            d = d.plusHours(Integer.parseInt(hours));
        }

        String fractional = m.group("fractional");
        if (fractional != null) {
            // osrs sends 2 digits, but this is robust to changes
            String f = fractional.length() < 3 ? StringUtils.rightPad(fractional, 3, '0') : fractional.substring(0, 3);
            d = d.plusMillis(Integer.parseInt(f));
        }

        return d;
    }

    @NotNull
    public String format(@Nullable Duration duration, boolean precise) {
        Temporal time = ObjectUtils.defaultIfNull(duration, Duration.ZERO).addTo(LocalTime.of(0, 0));
        StringBuilder sb = new StringBuilder();

        int h = time.get(HOUR_OF_DAY);
        if (h > 0)
            sb.append(String.format("%02d", h)).append(':');

        sb.append(String.format("%02d", time.get(MINUTE_OF_HOUR))).append(':');
        sb.append(String.format("%02d", time.get(SECOND_OF_MINUTE)));

        if (precise)
            sb.append('.').append(String.format("%02d", time.get(MILLI_OF_SECOND) / 10));

        return sb.toString();
    }

}

package dinkplugin.util;

import com.google.gson.annotations.SerializedName;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import org.jetbrains.annotations.NotNull;

@Data
@Setter(AccessLevel.PRIVATE)
public class SerializedOffer {
    private GrandExchangeOfferState state;
    private @SerializedName("itemId") int id;
    private @SerializedName("totalQuantity") int quantity;
    private int price;
    private int spent;

    public boolean equalsOffer(@NotNull GrandExchangeOffer o) {
        return state == o.getState() && id == o.getItemId() && quantity == o.getTotalQuantity()
            && price == o.getPrice() && spent == o.getSpent();
    }
}

package dinkplugin.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import okhttp3.HttpUrl;

import java.io.IOException;

public class HttpUrlAdapter extends TypeAdapter<HttpUrl> {
    @Override
    public void write(JsonWriter out, HttpUrl url) throws IOException {
        out.value(url != null ? url.toString() : null);
    }

    @Override
    public HttpUrl read(JsonReader in) throws IOException {
        return in.hasNext() ? HttpUrl.parse(in.nextString()) : null;
    }
}

package dinkplugin.util;

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
public abstract class AbstractRarityService {

    protected final Gson gson;
    protected final ItemManager itemManager;
    protected final Map<String, Collection<RareDrop>> dropsBySourceName;

    AbstractRarityService(String resourceName, int expectedSize, Gson gson, ItemManager itemManager) {
        this.gson = gson;
        this.itemManager = itemManager;
        this.dropsBySourceName = new HashMap<>(expectedSize);

        Map<String, List<RawDrop>> raw;
        try (InputStream is = getClass().getResourceAsStream(resourceName);
             Reader reader = new BufferedReader(new InputStreamReader(Objects.requireNonNull(is)))) {
            raw = gson.fromJson(reader, new TypeToken<Map<String, List<RawDrop>>>() {}.getType());
        } catch (Exception e) {
            log.error("Failed to read monster drop rates", e);
            return;
        }

        raw.forEach((sourceName, rawDrops) -> {
            ArrayList<RareDrop> drops = rawDrops.stream()
                .map(RawDrop::transform)
                .flatMap(Collection::stream)
                .collect(Collectors.toCollection(ArrayList::new));
            drops.trimToSize();
            dropsBySourceName.put(sourceName, drops);
        });
    }

    public OptionalDouble getRarity(String sourceName, int itemId, int quantity) {
        ItemComposition composition = itemId >= 0 ? itemManager.getItemComposition(itemId) : null;
        int canonical = composition != null && composition.getNote() != -1 ? composition.getLinkedNoteId() : itemId;
        String itemName = composition != null ? composition.getMembersName() : "";
        Collection<Integer> variants = new HashSet<>(
            ItemVariationMapping.getVariations(ItemVariationMapping.map(canonical))
        );
        return dropsBySourceName.getOrDefault(sourceName, Collections.emptyList())
            .stream()
            .filter(drop -> drop.getMinQuantity() <= quantity && quantity <= drop.getMaxQuantity())
            .filter(drop -> {
                int id = drop.getItemId();
                if (id == itemId) return true;
                return variants.contains(id) && itemName.equals(itemManager.getItemComposition(id).getMembersName());
            })
            .mapToDouble(RareDrop::getProbability)
            .reduce(Double::sum);
    }

    @Value
    protected static class RareDrop {
        int itemId;
        int minQuantity;
        int maxQuantity;
        double probability;
    }

    @Data
    @Setter(AccessLevel.PRIVATE)
    private static class RawDrop {
        private @SerializedName("i") int itemId;
        private @SerializedName("r") Integer rolls;
        private @SerializedName("d") double denominator;
        private @SerializedName("q") Integer quantity;
        private @SerializedName("m") Integer quantMin;
        private @SerializedName("n") Integer quantMax;

        Collection<RareDrop> transform() {
            int rounds = rolls != null ? rolls : 1;
            int min = quantMin != null ? quantMin : quantity;
            int max = quantMax != null ? quantMax : quantity;
            double prob = 1 / denominator;

            if (rounds == 1) {
                return List.of(new RareDrop(itemId, min, max, prob));
            }
            List<RareDrop> drops = new ArrayList<>(rounds);
            for (int successCount = 1; successCount <= rounds; successCount++) {
                double density = MathUtils.binomialProbability(prob, rounds, successCount);
                drops.add(new RareDrop(itemId, min * successCount, max * successCount, density));
            }
            return drops;
        }
    }
}

package dinkplugin.util;

import com.google.gson.Gson;
import lombok.experimental.UtilityClass;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.RuneLiteConfig;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.Color;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.regex.Pattern;
import java.util.stream.Stream;

@UtilityClass
public class ConfigUtil {

    private final Pattern DELIM = Pattern.compile("[,;\\n]");

    public Stream<String> readDelimited(String value) {
        if (value == null) return Stream.empty();
        return DELIM.splitAsStream(value)
            .map(String::trim)
            .filter(StringUtils::isNotEmpty);
    }

    public boolean isPluginDisabled(ConfigManager configManager, String simpleLowerClassName) {
        return "false".equals(configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, simpleLowerClassName));
    }

    @Nullable
    public Object convertTypeFromJson(@NotNull Gson gson, @NotNull Type type, @NotNull Object in) {
        if (in instanceof Boolean)
            return type == boolean.class || type == Boolean.class ? in : null;

        if (in instanceof Number) {
            Number n = (Number) in;

            if (type == int.class || type == Integer.class)
                return n.intValue();

            if (type == long.class || type == Long.class)
                return n.longValue();

            if (type == float.class || type == Float.class)
                return n.floatValue();

            if (type == double.class || type == Double.class)
                return n.doubleValue();

            if (type == byte.class || type == Byte.class)
                return n.byteValue();

            if (type == short.class || type == Short.class)
                return n.shortValue();

            if (type == Instant.class)
                return Instant.ofEpochMilli(n.longValue());

            if (type == Duration.class)
                return Duration.ofMillis(n.longValue());

            return null;
        }

        if (in instanceof String) {
            String s = (String) in;

            if (type == String.class)
                return s;

            if (type == Color.class)
                return ColorUtil.fromString(s);

            if (type instanceof Class && ((Class<?>) type).isEnum()) {
                try {
                    // noinspection unchecked,rawtypes
                    return Enum.valueOf((Class<? extends Enum>) type, s);
                } catch (Exception e) {
                    return null;
                }
            }

            if (type == Instant.class) {
                try {
                    return Instant.parse(s);
                } catch (Exception e) {
                    return null;
                }
            }

            if (type == Duration.class) {
                try {
                    return Duration.parse(s);
                } catch (Exception e) {
                    return null;
                }
            }
        }

        if (in instanceof Collection && type instanceof ParameterizedType) {
            Type rawType = ((ParameterizedType) type).getRawType();
            if (rawType instanceof Class && Collection.class.isAssignableFrom((Class<?>) rawType)) {
                try {
                    return gson.fromJson(gson.toJson(in), type); // inefficient, but unimportant
                } catch (Exception e) {
                    return null;
                }
            }
        }

        return null;
    }

    public boolean isSettingsOpen(@NotNull Client client) {
        Widget widget = client.getWidget(ComponentID.SETTINGS_INIT);
        return widget != null && !widget.isHidden();
    }

    public boolean isKillCountFilterInvalid(int varbitValue) {
        // spam filter must be disabled for kill count chat message
        return varbitValue > 0;
    }

    public boolean isCollectionLogInvalid(int varbitValue) {
        // collection log notifier requires chat or pop-up notification
        return varbitValue == 0;
    }

    public boolean isRepeatPopupInvalid(int varbitValue) {
        // we discourage repeat notifications for combat task notifier if unintentional
        return varbitValue > 0;
    }

    public boolean isPetLootInvalid(int varbitValue) {
        // LOOT_DROP_NOTIFICATIONS and UNTRADEABLE_LOOT_DROPS must both be set to 1 for reliable pet name parsing
        return varbitValue < 1;
    }
}

package dinkplugin.util;

import lombok.Value;
import net.runelite.discord.DiscordUser;
import org.jetbrains.annotations.Nullable;

@Value
public class DiscordProfile {
    String id;
    String name;
    String avatarHash;

    public static DiscordProfile of(@Nullable DiscordUser user) {
        if (user == null || user.userId == null) return null;
        return new DiscordProfile(user.userId, user.username, user.avatar);
    }
}

package dinkplugin.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.awt.Color;
import java.io.IOException;

/**
 * Serializes and deserializes {@link Color} instances
 * from their decimal representation.
 * <p>
 * Discord requires this decimal format, rather than a hex string
 * that the default RuneLite GSON instance would produce.
 */
public class ColorAdapter extends TypeAdapter<Color> {
    @Override
    public void write(JsonWriter out, Color color) throws IOException {
        out.value(color != null ? color.getRGB() ^ 0xFF000000 : null);
    }

    @Override
    public Color read(JsonReader in) throws IOException {
        if (in.hasNext()) {
            return new Color(in.nextInt());
        }
        return null;
    }
}

package dinkplugin.util;

import com.google.gson.Gson;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.OptionalDouble;

@Singleton
public class ThievingService extends AbstractRarityService {

    @Inject
    ThievingService(Gson gson, ItemManager itemManager) {
        super("/thieving.json", 32, gson, itemManager);
    }

    @Override
    public OptionalDouble getRarity(String sourceName, int itemId, int quantity) {
        if (itemId == ItemID.BLOOD_SHARD) {
            // https://oldschool.runescape.wiki/w/Blood_shard#Item_sources
            return OptionalDouble.of(1.0 / 5000);
        }

        if (itemId == ItemID.ENHANCED_CRYSTAL_TELEPORT_SEED) {
            // https://oldschool.runescape.wiki/w/Enhanced_crystal_teleport_seed#Item_sources
            return OptionalDouble.of(1.0 / 1024);
        }

        return super.getRarity(sourceName, itemId, quantity);
    }

}

package dinkplugin.util;

import com.google.common.collect.ImmutableMap;
import dinkplugin.DinkPluginConfig;
import dinkplugin.domain.FilterMode;
import dinkplugin.domain.PlayerLookupService;
import lombok.Builder;
import lombok.NonNull;
import lombok.Singular;
import lombok.Value;
import lombok.experimental.Accessors;
import lombok.experimental.UtilityClass;
import net.runelite.client.config.ConfigManager;
import org.jetbrains.annotations.Nullable;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

@UtilityClass
public class MigrationUtil {

    public static final Map<String, Function<DinkPluginConfig, Metadata>> PLUGIN_METADATA;

    public Metadata findMetadata(String key, DinkPluginConfig config) {
        var fast = PLUGIN_METADATA.get(key);
        if (fast != null) return fast.apply(config);

        for (var func : PLUGIN_METADATA.values()) {
            var meta = func.apply(config);
            if (meta.matchesName(key))
                return meta;
        }
        return null;
    }

    private Metadata getAdamMappings(DinkPluginConfig config) {
        // https://github.com/Adam-/runelite-plugins/blob/discord-loot-logger/src/main/java/info/sigterm/plugins/discordlootlogger/DiscordLootLoggerConfig.java
        return Metadata.builder()
            .configGroup("discordlootlogger")
            .pluginClassName("DiscordLootLoggerPlugin")
            .alias("lootlogger")
            .alias("adam")
            .notifierEnabledKey("lootEnabled")
            .mapping("webhook", config.lootWebhook().isBlank() ? "discordWebhook" : "lootWebhook")
            .mapping("sendScreenshot", "lootSendImage")
            .mapping("lootvalue", "minLootValue")
            .build();
    }

    private Metadata getBoredskaMappings(DinkPluginConfig config) {
        // https://github.com/Boredska/gim-bank-discord/blob/master/src/main/java/gim/bank/discord/GimBankDiscordConfig.java
        return Metadata.builder()
            .configGroup("gimbankdiscord")
            .pluginClassName("GimBankDiscordPlugin")
            .aliases(Set.of("gim", "bank", "gimbank", "boredska"))
            .notifierEnabledKey("groupStorageEnabled")
            .mapping("webhook", config.groupStorageWebhook().isBlank() && config.notifyGroupStorage() ? "discordWebhook" : "groupStorageWebhook")
            .build();
    }

    private Metadata getBossHusoMappings(DinkPluginConfig config) {
        // https://github.com/BossHuso/discord-rare-drop-notificater/blob/master/src/main/java/com/masterkenth/DiscordRareDropNotificaterConfig.java
        Function<Object, Object> itemListTransformer = v -> ConfigUtil
            .readDelimited(v.toString())
            .map(s -> '*' + s + '*')
            .collect(Collectors.joining("\n"));
        return Metadata.builder()
            .configGroup("discordraredropnotificater")
            .pluginClassName("DiscordRareDropNotificaterPlugin")
            .notifierEnabledKey("lootEnabled")
            .aliases(Set.of("discordraredropnotifier", "rare", "huso", "bosshuso"))
            .mapping("webhookurl", config.lootWebhook().isBlank() ? "discordWebhook" : "lootWebhook")
            .mapping("minrarity", "lootRarityThreshold")
            .mapping("minvalue", "minLootValue")
            .mapping("andinsteadofor", "lootRarityValueIntersection")
            .mapping("sendscreenshot", "lootSendImage")
            .mapping("ignoredkeywords", "lootItemDenylist")
            .mapping("whiteListedItems", "lootItemAllowlist")
            .mapping("sendEmbeddedMessage", "discordRichEmbeds")
            .mapping("whiteListedRSNs", "ignoredNames")
            .configValueTransformer("whiteListedItems", itemListTransformer)
            .configValueTransformer("ignoredkeywords", itemListTransformer)
            .configValueTransformer("whiteListedRSNs", names -> {
                if (!names.toString().isBlank() && config.nameFilterMode() == FilterMode.DENY) {
                    if (config.filteredNames().isBlank()) {
                        config.setNameFilterMode(FilterMode.ALLOW);
                    } else {
                        return "";
                    }
                }
                return names;
            })
            .build();
    }

    private Metadata getJakeMappings(DinkPluginConfig config) {
        // https://github.com/MidgetJake/UniversalDiscordNotifier/blob/master/src/main/java/universalDiscord/UniversalDiscordConfig.java
        return Metadata.builder()
            .configGroup("universalDiscord")
            .pluginClassName("UniversalDiscordPlugin")
            .aliases(Set.of("universaldiscordnotifications", "universal", "jake", "midgetjake"))
            .mapping("discordWebhook", "discordWebhook")
            .mapping("playerUrl", "playerLookupService")
            .mapping("collectionLogEnabled", "collectionLogEnabled")
            .mapping("collectionSendImage", "collectionSendImage")
            .mapping("collectionNotifMessage", "collectionNotifMessage")
            .mapping("petEnabled", "petEnabled")
            .mapping("petSendImage", "petSendImage")
            .mapping("petNotifMessage", "petNotifMessage")
            .mapping("levelEnabled", "levelEnabled")
            .mapping("levelSendImage", "levelSendImage")
            .mapping("levelInterval", "levelInterval")
            .mapping("levelNotifMessage", "levelNotifMessage")
            .mapping("lootEnabled", "lootEnabled")
            .mapping("lootSendImage", "lootSendImage")
            .mapping("lootIcons", "lootIcons")
            .mapping("minLootValue", "minLootValue")
            .mapping("lootNotifMessage", "lootNotifMessage")
            .mapping("deathEnabled", "deathEnabled")
            .mapping("deathSendImage", "deathSendImage")
            .mapping("deathNotifMessage", "deathNotifMessage")
            .mapping("slayerEnabled", "slayerEnabled")
            .mapping("slayerSendImage", "slayerSendImage")
            .mapping("slayerNotifMessage", "slayerNotifMessage")
            .mapping("questEnabled", "questEnabled")
            .mapping("questSendImage", "questSendImage")
            .mapping("questNotifMessage", "questNotifMessage")
            .mapping("clueEnabled", "clueEnabled")
            .mapping("clueSendImage", "clueSendImage")
            .mapping("clueShowItems", "clueShowItems")
            .mapping("clueMinValue", "clueMinValue")
            .mapping("clueNotifMessage", "clueNotifMessage")
            .configValueTransformer("playerUrl", v -> {
                switch (v.toString()) {
                    case "TEMPLEOSRS":
                        return PlayerLookupService.TEMPLE_OSRS.name();
                    case "WISEOLDMAN":
                        return PlayerLookupService.WISE_OLD_MAN.name();
                    default:
                        return v;
                }
            })
            .build();
    }

    private Metadata getJamesMappings(DinkPluginConfig config) {
        // https://github.com/jamesdrudolph/Discord-Death-Notifications/blob/master/src/main/java/moe/cuteanimegirls/discorddeathnotifications/DeathNotificationsConfig.java
        return Metadata.builder()
            .configGroup("discorddeathnotifications")
            .pluginClassName("DeathNotificationsPlugin")
            .alias("death")
            .alias("elguy")
            .notifierEnabledKey("deathEnabled")
            .mapping("webhook", config.deathWebhook().isBlank() ? "discordWebhook" : "deathWebhook")
            .mapping("deathMessage", "deathNotifMessage")
            .configValueTransformer("deathMessage", msg -> "%USERNAME% " + msg)
            .build();
    }

    private Metadata getPaulMappings(DinkPluginConfig config) {
        // https://github.com/PJGJ210/Discord-Collection-Logger/blob/master/src/main/java/discordcollectionlogger/DiscordCollectionLoggerConfig.java
        return Metadata.builder()
            .configGroup("discordcollectionlogger")
            .pluginClassName("DiscordCollectionLoggerPlugin")
            .alias("collection")
            .alias("paul")
            .notifierEnabledKey("collectionLogEnabled")
            .mapping("webhook", config.collectionWebhook().isBlank() ? "discordWebhook" : "collectionWebhook")
            .mapping("sendScreenshot", "collectionSendImage")
            .mapping("includepets", config.notifyPet() ? "" : "petEnabled")
            .build();
    }

    private Metadata getRinzMappings(DinkPluginConfig config) {
        // https://github.com/RinZJ/better-discord-loot-logger/blob/master/src/main/java/com/betterdiscordlootlogger/BetterDiscordLootLoggerConfig.java
        return Metadata.builder()
            .configGroup("betterdiscordlootlogger")
            .pluginClassName("BetterDiscordLootLoggerPlugin")
            .alias("betterloot")
            .alias("rinz")
            .notifierEnabledKey("lootEnabled")
            .mapping("webhook", config.lootWebhook().isBlank() ? "discordWebhook" : "lootWebhook")
            .mapping("sendScreenshot", "lootSendImage")
            .mapping("pets", config.notifyPet() ? "" : "petEnabled")
            .mapping("valuableDropThreshold", "minLootValue")
            .mapping("collectionLogItem", config.notifyCollectionLog() ? "" : "collectionLogEnabled")
            .build();
    }

    private Metadata getShamerMappings(DinkPluginConfig config) {
        // https://github.com/jack0lantern/raidshamer/blob/main/src/main/java/ejedev/raidshamer/RaidShamerConfig.java
        return Metadata.builder()
            .configGroup("raidshamer")
            .pluginClassName("RaidShamerPlugin")
            .alias("deathshamer")
            .alias("botanophobia")
            .notifierEnabledKey("deathEnabled")
            .mapping("webhookLink", config.deathWebhook().isBlank() ? "discordWebhook" : "deathWebhook")
            .mapping("captureOwnDeaths", config.notifyDeath() ? "" : "deathEnabled")
            .build();
    }

    private Metadata getTakamokMappings(DinkPluginConfig config) {
        // https://github.com/ATremonte/Discord-Level-Notifications/blob/master/src/main/java/com/discordlevelnotifications/LevelNotificationsConfig.java
        return Metadata.builder()
            .configGroup("discordlevelnotifications")
            .pluginClassName("LevelNotificationsPlugin")
            .alias("level")
            .alias("takamok")
            .notifierEnabledKey("levelEnabled")
            .mapping("webhook", config.levelWebhook().isBlank() ? "discordWebhook" : "levelWebhook")
            .mapping("sendScreenshot", "levelSendImage")
            .mapping("minimumLevel", "levelMinValue")
            .mapping("levelInterval", "levelInterval")
            .build();
    }

    @Value
    @Builder
    @Accessors(fluent = true)
    public static class Metadata {
        @NonNull
        String configGroup;

        @Singular
        @NonNull
        Map<String, String> mappings;

        @NonNull
        String pluginClassName;

        @Nullable
        String notifierEnabledKey;

        @Singular
        @Nullable
        Map<String, Function<Object, Object>> configValueTransformers;

        @Singular
        @NonNull
        Set<String> aliases;

        public Map<String, Object> readConfig(ConfigManager configManager, Map<String, Type> configValueTypes) {
            Map<String, Object> valuesByKey = new HashMap<>(mappings.size() * 4 / 3);
            mappings.forEach((sourceKey, dinkKey) -> {
                Type valueType = configValueTypes.get(dinkKey);
                if (valueType == null) return;

                var sourceValue = configManager.getConfiguration(configGroup, sourceKey, valueType);
                if (sourceValue != null) {
                    var transformedValue = transform(sourceKey, sourceValue);
                    valuesByKey.put(dinkKey, transformedValue);
                }
            });
            return valuesByKey;
        }

        public boolean shouldEnableNotifier(ConfigManager configManager) {
            return notifierEnabledKey != null && !ConfigUtil.isPluginDisabled(configManager, pluginClassName.toLowerCase());
        }

        boolean matchesName(String key) {
            return pluginClassName.equalsIgnoreCase(key) || configGroup.equals(key) || aliases.contains(key.toLowerCase());
        }

        private Object transform(String configKey, Object configValue) {
            if (configValueTransformers == null) return configValue;
            return configValueTransformers.getOrDefault(configKey, v -> v).apply(configValue);
        }
    }

    static {
        PLUGIN_METADATA = ImmutableMap.<String, Function<DinkPluginConfig, Metadata>>builder()
            .put("BetterDiscordLootLogger", MigrationUtil::getRinzMappings)
            .put("DiscordCollectionLogger", MigrationUtil::getPaulMappings)
            .put("DiscordDeathNotifications", MigrationUtil::getJamesMappings)
            .put("DiscordLevelNotifications", MigrationUtil::getTakamokMappings)
            .put("DiscordLootLogger", MigrationUtil::getAdamMappings)
            .put("DiscordRareDropNotifier", MigrationUtil::getBossHusoMappings)
            .put("GIMBankDiscord", MigrationUtil::getBoredskaMappings)
            .put("RaidShamer", MigrationUtil::getShamerMappings)
            .put("UniversalDiscordNotifications", MigrationUtil::getJakeMappings)
            .build();
    }
}

package dinkplugin.util;

import lombok.Value;
import net.runelite.api.Client;

@Value
public class Region {
    int regionId;
    int plane;
    boolean instanced;

    public static Region of(Client client, int regionId) {
        return new Region(regionId, client.getPlane(), client.isInInstancedRegion());
    }

    public static Region of(Client client) {
        return of(client, WorldUtils.getLocation(client).getRegionID());
    }
}

package dinkplugin.util;

import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;

import java.io.IOException;
import java.time.Instant;
import java.time.format.DateTimeParseException;

/**
 * Serialized and deserializes {@link Instant} instances
 * from their equivalent ISO-8601 string representation.
 * <p>
 * Discord requires this string format, rather than epoch milliseconds
 * that the default RuneLite GSON instance would produce.
 */
public class InstantAdapter extends TypeAdapter<Instant> {
    @Override
    public void write(JsonWriter out, Instant instant) throws IOException {
        out.value(instant != null ? instant.toString() : null);
    }

    @Override
    public Instant read(JsonReader in) throws IOException {
        if (in.hasNext()) {
            try {
                return Instant.parse(in.nextString());
            } catch (DateTimeParseException ignored) {
            }
        }
        return null;
    }
}

package dinkplugin.util;

import lombok.Value;

@Value
public class SerializedPet {
    int itemId;
    String name;
}

package dinkplugin;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import dinkplugin.domain.ChatPrivacyMode;
import dinkplugin.domain.ConfigImportPolicy;
import dinkplugin.domain.FilterMode;
import dinkplugin.domain.SeasonalPolicy;
import dinkplugin.notifiers.ChatNotifier;
import dinkplugin.notifiers.CollectionNotifier;
import dinkplugin.notifiers.CombatTaskNotifier;
import dinkplugin.notifiers.KillCountNotifier;
import dinkplugin.notifiers.PetNotifier;
import dinkplugin.util.MigrationUtil;
import dinkplugin.util.Utils;
import dinkplugin.util.WorldUtils;
import lombok.RequiredArgsConstructor;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.events.ConfigChanged;
import okhttp3.CacheControl;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.SwingUtilities;
import java.io.IOException;
import java.lang.reflect.Type;
import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.TreeSet;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import static dinkplugin.util.ConfigUtil.*;

@Slf4j
@Singleton
@RequiredArgsConstructor(onConstructor_ = { @Inject })
public class SettingsManager {
    public static final String CONFIG_GROUP = "dinkplugin";
    public static final String DYNAMIC_IMPORT_CONFIG_KEY = "dynamicConfigUrl";

    private static final Set<Integer> PROBLEMATIC_VARBITS;

    /**
     * Maps our setting keys to their type for safe serialization and deserialization.
     */
    private final Map<String, Type> configValueTypes = new HashMap<>();

    /**
     * Maps section names to the corresponding config item keys to allow for selective export.
     */
    private final Map<String, Collection<String>> keysBySection = new HashMap<>();

    /**
     * The key names of config items that are hidden (and, thus, should not be exported).
     */
    private final Collection<String> hiddenConfigKeys = new HashSet<>();

    /**
     * Set of our config keys that correspond to webhook URL lists.
     * <p>
     * These are used for special logic to merge the previous value with the new value during config imports.
     */
    private Collection<String> webhookConfigKeys;

    /**
     * User-specified RSNs that should or should not (depending on filter mode) trigger webhook notifications.
     */
    private final Collection<String> filteredNames = new HashSet<>();

    private final AtomicBoolean justLoggedIn = new AtomicBoolean();

    private final Gson gson;
    private final Client client;
    private final ClientThread clientThread;
    private final DinkPlugin plugin;
    private final DinkPluginConfig config;
    private final ConfigManager configManager;
    private final OkHttpClient httpClient;

    private volatile Instant lastDynamicImport = null;

    /**
     * Check whether a username complies with the configured RSN filter list.
     *
     * @param name the local player's name
     * @return whether notifications for this player should be sent
     */
    @Synchronized
    public boolean isNamePermitted(String name) {
        if (name == null) return false;
        if (filteredNames.isEmpty()) return true;
        return (config.nameFilterMode() == FilterMode.ALLOW) == filteredNames.contains(name.toLowerCase());
    }

    @VisibleForTesting
    public void init() {
        migrateBoolean("ignoreSeasonalWorlds", ignoreSeasonal -> ignoreSeasonal ? SeasonalPolicy.REJECT : SeasonalPolicy.ACCEPT, config::setSeasonalPolicy);
        migrateBoolean("screenshotHideChat", hide -> hide ? ChatPrivacyMode.HIDE_ALL : ChatPrivacyMode.HIDE_NONE, config::setChatPrivacy);

        setFilteredNames(config.filteredNames());
        configManager.getConfigDescriptor(config).getItems().forEach(item -> {
            String key = item.key();
            configValueTypes.put(key, item.getType());

            if (item.getItem().hidden()) {
                hiddenConfigKeys.add(key);
            }

            String section = item.getItem().section();
            if (StringUtils.isNotEmpty(section)) {
                keysBySection.computeIfAbsent(
                    section.toLowerCase().replace(" ", ""),
                    s -> new HashSet<>()
                ).add(key);
            }
        });
        hiddenConfigKeys.add("importPolicy"); // not hidden, but shouldn't be overwritten
        webhookConfigKeys = ImmutableSet.<String>builder()
            .add("discordWebhook") // DinkPluginConfig#primaryWebhook
            .addAll(keysBySection.getOrDefault(DinkPluginConfig.webhookSection.toLowerCase().replace(" ", ""), Collections.emptySet()))
            .add("metadataWebhook") // MetaNotifier's configuration is in the Advanced section
            .build();
        importDynamicConfig(config.dynamicConfigUrl());
    }

    void onCommand(CommandExecuted event) {
        String cmd = event.getCommand();
        String[] args = event.getArguments();
        if ("DinkImport".equalsIgnoreCase(cmd)) {
            importConfig();
        } else if ("DinkExport".equalsIgnoreCase(cmd)) {
            Predicate<String> includeKey;
            if (args == null || args.length == 0) {
                includeKey = k -> !webhookConfigKeys.contains(k);
            } else {
                includeKey = k -> false;

                for (String arg : args) {
                    if ("all".equalsIgnoreCase(arg)) {
                        includeKey = k -> true;
                        break;
                    } else if ("webhooks".equalsIgnoreCase(arg)) {
                        includeKey = includeKey.or(webhookConfigKeys::contains);
                    } else {
                        Collection<String> sectionKeys = keysBySection.get(arg.toLowerCase());
                        if (sectionKeys != null) {
                            includeKey = includeKey.or(sectionKeys::contains);
                        } else {
                            plugin.addChatWarning(String.format("Failed to identify config section to export: \"%s\"", arg));
                            return;
                        }
                    }
                }
            }

            exportConfig(includeKey);
        } else if ("DinkHash".equalsIgnoreCase(cmd)) {
            CompletableFuture.completedFuture(client.getAccountHash())
                .thenApplyAsync(Utils::dinkHash)
                .thenCompose(Utils::copyToClipboard)
                .thenRun(() -> plugin.addChatSuccess("Copied your dink hash to clipboard"))
                .exceptionally(t -> {
                    plugin.addChatWarning("Failed to copy your dink hash to clipboard");
                    return null;
                });
        } else if ("DinkRegion".equalsIgnoreCase(cmd)) {
            int regionId = WorldUtils.getLocation(client).getRegionID();
            plugin.addChatSuccess(String.format("Your current region ID is: %d", regionId));
        } else if ("DinkMigrate".equalsIgnoreCase(cmd)) {
            if (args == null || args.length == 0) {
                plugin.addChatWarning("Please specify which plugin's settings to migrate or 'all'. " +
                    "Supported plugins include: " + String.join(", ", MigrationUtil.PLUGIN_METADATA.keySet()));
            } else if (args.length > 1) {
                plugin.addChatWarning("Please only specify one plugin at a time to migrate");
            } else {
                String key = args[0];
                if ("all".equalsIgnoreCase(key)) {
                    MigrationUtil.PLUGIN_METADATA.values()
                        .forEach(func -> migrateConfig(func.apply(config)));
                } else {
                    var metadata = MigrationUtil.findMetadata(key, config);
                    if (metadata == null) {
                        plugin.addChatWarning("Failed to recognize plugin name to be migrated");
                        return;
                    }
                    migrateConfig(metadata);
                }
                plugin.addChatSuccess("Finished migrating configs from other plugins. " +
                    "Please verify the latest Dink settings and disable your other webhook plugins");
            }
        }
    }

    void onConfigChanged(ConfigChanged event) {
        String key = event.getKey();
        String value = event.getNewValue();

        if ("ignoredNames".equals(key)) {
            setFilteredNames(value);
            return;
        }

        if (DYNAMIC_IMPORT_CONFIG_KEY.equals(key)) {
            importDynamicConfig(value);
            return;
        }

        if (value != null && value.isEmpty() && ("embedFooterText".equals(key) || "embedFooterIcon".equals(key) || "deathIgnoredRegions".equals(key) || ChatNotifier.PATTERNS_CONFIG_KEY.equals(key))) {
            SwingUtilities.invokeLater(() -> {
                if (StringUtils.isEmpty(configManager.getConfiguration(CONFIG_GROUP, key))) {
                    // non-empty string so runelite doesn't overwrite the value on next start; see https://github.com/pajlads/DinkPlugin/issues/453
                    configManager.setConfiguration(CONFIG_GROUP, key, " ");
                }
            });
            return;
        }

        if (client.getGameState() == GameState.LOGGED_IN) {
            if ("killCountEnabled".equals(key) && "true".equals(value)) {
                clientThread.invokeLater(() -> {
                    if (isKillCountFilterInvalid(client.getVarbitValue(KillCountNotifier.KILL_COUNT_SPAM_FILTER))) {
                        plugin.addChatWarning(KillCountNotifier.SPAM_WARNING);
                    }
                });
                return;
            }

            if ("combatTaskEnabled".equals(key) && "true".equals(value)) {
                clientThread.invokeLater(() -> {
                    if (isRepeatPopupInvalid(client.getVarbitValue(CombatTaskNotifier.COMBAT_TASK_REPEAT_POPUP))) {
                        plugin.addChatWarning(CombatTaskNotifier.REPEAT_WARNING);
                    }
                });
                return;
            }

            if ("collectionLogEnabled".equals(key) && "true".equals(value)) {
                clientThread.invokeLater(() -> {
                    if (isCollectionLogInvalid(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION))) {
                        plugin.addChatWarning(CollectionNotifier.ADDITION_WARNING);
                    }
                });
                return;
            }

            if ("petEnabled".equals(key) && "true".equals(value)) {
                clientThread.invokeLater(() -> {
                    if (isPetLootInvalid(client.getVarbitValue(PetNotifier.UNTRADEABLE_LOOT_DROPS)) || isPetLootInvalid(client.getVarbitValue(PetNotifier.LOOT_DROP_NOTIFICATIONS))) {
                        plugin.addChatWarning(PetNotifier.UNTRADEABLE_WARNING);
                    }
                });
            }
        }
    }

    void onGameState(GameState oldState, GameState newState) {
        if (newState != GameState.LOGGED_IN) {
            justLoggedIn.set(false);
            return;
        } else {
            justLoggedIn.set(true);
        }

        if (oldState == GameState.HOPPING) {
            // avoid repeated warnings after login
            return;
        }

        // Since varbit values default to zero and no VarbitChanged occurs if the
        // newly received value is equal to the existing value, we must manually
        // check those where 0 is an invalid value deserving of a warning.
        clientThread.invokeLater(() -> {
            if (justLoggedIn.get())
                return false; // try again on next tick

            if (config.notifyCollectionLog() && client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) == 0) {
                warnForGameSetting(CollectionNotifier.ADDITION_WARNING);
            }

            if (config.notifyPet() && (client.getVarbitValue(PetNotifier.UNTRADEABLE_LOOT_DROPS) == 0 || client.getVarbitValue(PetNotifier.LOOT_DROP_NOTIFICATIONS) == 0)) {
                warnForGameSetting(PetNotifier.UNTRADEABLE_WARNING);
            }

            return true;
        });

        // refresh dynamic config if it's been 3+ hours
        var lastImport = lastDynamicImport;
        if (lastImport != null && Duration.between(lastImport, Instant.now()).toHours() >= 3) {
            importDynamicConfig(config.dynamicConfigUrl());
        }
    }

    void onTick() {
        // indicate when we've been logged in for more than a single tick
        justLoggedIn.compareAndSet(client.getGameState() == GameState.LOGGED_IN, false);
    }

    void onVarbitChanged(VarbitChanged event) {
        int id = event.getVarbitId();
        if (PROBLEMATIC_VARBITS.contains(id))
            clientThread.invoke(() -> checkVarbits(id, client.getVarbitValue(id)));
    }

    boolean hasModifiedConfig() {
        for (String webhookConfigKey : webhookConfigKeys) {
            String webhookUrl = configManager.getConfiguration(SettingsManager.CONFIG_GROUP, webhookConfigKey);
            if (webhookUrl != null && !webhookUrl.isEmpty()) {
                return true;
            }
        }
        return config.notifyAchievementDiary() || config.notifyClue() || config.notifyCollectionLog() ||
            config.notifyCombatTask() || config.notifyDeath() || config.notifyGamble() ||
            config.notifyGrandExchange() || config.notifyGroupStorage() || config.notifyKillCount() ||
            config.notifyLeagues() || config.notifyLevel() || config.notifyLoot() || config.notifyPet() ||
            config.notifyPk() || config.notifyQuest() || config.notifySlayer() || config.notifySpeedrun() ||
            config.notifyTrades();
    }

    private boolean checkVarbits(int id, int value) {
        if (client.getGameState() != GameState.LOGGED_IN)
            return false; // try again on next tick

        if (justLoggedIn.get())
            return value == 0; // try again next tick, unless would already be handled by invokeLater above

        if (id == KillCountNotifier.KILL_COUNT_SPAM_FILTER && isKillCountFilterInvalid(value) && config.notifyKillCount()) {
            warnForGameSetting(KillCountNotifier.SPAM_WARNING);
        }

        if (id == CombatTaskNotifier.COMBAT_TASK_REPEAT_POPUP && isRepeatPopupInvalid(value) && config.notifyCombatTask()) {
            warnForGameSetting(CombatTaskNotifier.REPEAT_WARNING);
        }

        if (id == Varbits.COLLECTION_LOG_NOTIFICATION && isCollectionLogInvalid(value) && config.notifyCollectionLog()) {
            warnForGameSetting(CollectionNotifier.ADDITION_WARNING);
        }

        if ((id == PetNotifier.LOOT_DROP_NOTIFICATIONS || id == PetNotifier.UNTRADEABLE_LOOT_DROPS) && isPetLootInvalid(value) && config.notifyPet()) {
            warnForGameSetting(PetNotifier.UNTRADEABLE_WARNING);
        }

        return true;
    }

    private void warnForGameSetting(String message) {
        if (isSettingsOpen(client)) {
            plugin.addChatWarning(message);
        } else {
            log.warn(message);
        }
    }

    @Synchronized
    private void setFilteredNames(String configValue) {
        filteredNames.clear();
        readDelimited(configValue)
            .map(String::toLowerCase)
            .forEach(filteredNames::add);
        log.debug("Updated RSN Filter List to: {}", filteredNames);
    }

    private <T> void migrateBoolean(String key, Function<Boolean, T> transform, Consumer<T> consumer) {
        Boolean bool = configManager.getConfiguration(CONFIG_GROUP, key, Boolean.TYPE);
        if (bool == null) return;
        consumer.accept(transform.apply(bool));
        configManager.unsetConfiguration(CONFIG_GROUP, key);
    }

    private void migrateConfig(MigrationUtil.Metadata data) {
        handleImport(data.readConfig(configManager, configValueTypes), true);
        if (data.shouldEnableNotifier(configManager)) {
            configManager.setConfiguration(CONFIG_GROUP, data.notifierEnabledKey(), true);
        }
    }

    private void importDynamicConfig(String url) {
        if (url == null || url.isBlank()) return;

        HttpUrl httpUrl = HttpUrl.parse(url);
        if (httpUrl == null) {
            plugin.addChatWarning("The specified Dynamic Config URL is invalid");
            return;
        }

        Request request = new Request.Builder().url(httpUrl).cacheControl(CacheControl.FORCE_NETWORK).build();
        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) {
                ResponseBody body = response.body();
                if (body == null) {
                    plugin.addChatWarning("The specified Dynamic Config URL did not provide any settings to import");
                    return;
                }

                Map<String, Object> map;
                try {
                    map = gson.fromJson(body.charStream(), new TypeToken<Map<String, Object>>() {}.getType());
                } catch (Exception e) {
                    log.warn("Could not deserialize dynamic config", e);
                    plugin.addChatWarning("Failed to parse settings from the Dynamic Config URL");
                    return;
                } finally {
                    body.close();
                }

                // prevent never-ending requests if service always yields a different config URL
                map.remove(DYNAMIC_IMPORT_CONFIG_KEY);

                handleImport(map, true);
                lastDynamicImport = Instant.now();
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                log.warn("Could not reach dynamic config url", e);
                plugin.addChatWarning("Failed to read the specified Dynamic Config URL");
            }
        });
    }

    /**
     * Exports the full Dink config to a JSON map, excluding empty lists,
     * which is copied to the user's clipboard in string form
     */
    @Synchronized
    private void exportConfig(@NotNull Predicate<String> exportKey) {
        String prefix = CONFIG_GROUP + '.';
        Map<String, Object> configMap = configManager.getConfigurationKeys(prefix)
            .stream()
            .map(prop -> prop.substring(prefix.length()))
            .filter(key -> !hiddenConfigKeys.contains(key))
            .filter(exportKey)
            .map(key -> Pair.of(key, configValueTypes.get(key)))
            .filter(pair -> pair.getValue() != null)
            .map(pair -> Pair.of(pair.getKey(), configManager.getConfiguration(CONFIG_GROUP, pair.getKey(), pair.getValue())))
            .filter(pair -> pair.getValue() != null)
            .filter(pair -> {
                // only serialize webhook urls if they are not blank
                if (webhookConfigKeys.contains(pair.getKey())) {
                    Object value = pair.getValue();
                    return value instanceof String && StringUtils.isNotBlank((String) value);
                }

                // always serialize everything else
                return true;
            })
            .collect(Collectors.toMap(Pair::getKey, Pair::getValue));

        Utils.copyToClipboard(gson.toJson(configMap))
            .thenRun(() -> plugin.addChatSuccess("Copied current configuration to clipboard"))
            .exceptionally(e -> {
                plugin.addChatWarning("Failed to copy config to clipboard");
                return null;
            });
    }

    /**
     * Imports a Dink JSON config export from the user's clipboard
     */
    @Synchronized
    private void importConfig() {
        Utils.readClipboard()
            .thenApplyAsync(json -> {
                if (json == null || json.isEmpty()) {
                    plugin.addChatWarning("Clipboard was empty");
                    return null;
                }

                try {
                    return gson.<Map<String, Object>>fromJson(json, new TypeToken<Map<String, Object>>() {}.getType());
                } catch (Exception e) {
                    String warning = "Failed to parse config from clipboard";
                    log.warn(warning, e);
                    plugin.addChatWarning(warning);
                    return null;
                }
            })
            .thenAcceptAsync(m -> handleImport(m, false))
            .exceptionally(e -> {
                plugin.addChatWarning("Failed to read clipboard");
                return null;
            });
    }

    @Synchronized
    private void handleImport(Map<String, Object> map, boolean quiet) {
        if (map == null) return;

        Set<ConfigImportPolicy> policies = config.importPolicy();
        AtomicInteger numUpdated = new AtomicInteger();
        Collection<String> mergedConfigs = new TreeSet<>();
        map.forEach((key, rawValue) -> {
            Type valueType = configValueTypes.get(key);
            if (valueType == null) {
                log.debug("Encountered unrecognized config mapping during import: {} = {}", key, rawValue);
                return;
            }

            if (rawValue == null) {
                log.debug("Encountered null value for config key: {}", key);
                return;
            }

            if (hiddenConfigKeys.contains(key)) {
                log.debug("Skipping importing hidden config item: {} = {}", key, rawValue);
                return;
            }

            Object value = convertTypeFromJson(gson, valueType, rawValue);
            if (value == null) {
                log.debug("Encountered config value with incorrect type: {} = {}", key, rawValue);
                return;
            }

            Object prevValue = configManager.getConfiguration(CONFIG_GROUP, key, valueType);
            Object newValue;

            if (shouldMerge(policies, key)) {
                // special case: multi-line configs that should be merged (rather than replaced)
                assert prevValue == null || prevValue instanceof String;
                Collection<String> lines = readDelimited((String) prevValue).collect(Collectors.toCollection(LinkedHashSet::new));

                int oldCount = lines.size();
                assert value instanceof String;
                long added = readDelimited((String) value)
                    .map(lines::add)
                    .filter(Boolean::booleanValue)
                    .count();

                if (added > 0) {
                    newValue = String.join("\n", lines);

                    if (oldCount > 0) {
                        String displayName = "discordWebhook".equals(key) ? "primaryWebhook" : key;
                        mergedConfigs.add(displayName);
                    }
                } else {
                    newValue = null;
                }
            } else {
                if (Objects.equals(value, prevValue)) {
                    newValue = null;
                } else {
                    newValue = value;
                }
            }

            if (newValue != null) {
                configManager.setConfiguration(CONFIG_GROUP, key, newValue);
                numUpdated.incrementAndGet();
            }
        });

        int count = numUpdated.get();
        if (quiet && count <= 0) {
            log.debug("Updated 0 config settings from map of size {}", map.size());
            return;
        }

        plugin.addChatSuccess(
            String.format(
                "Updated %d config settings (from %d total specified in import). " +
                    "Please close and open the plugin settings panel for these changes to be visually reflected.",
                count,
                map.size()
            )
        );

        if (!mergedConfigs.isEmpty()) {
            plugin.addChatSuccess("The following settings were merged (rather than being overwritten): " + String.join(", ", mergedConfigs));
        }
    }

    private boolean shouldMerge(Set<ConfigImportPolicy> policies, String configKey) {
        if ("lootItemAllowlist".equals(configKey) || "lootItemDenylist".equals(configKey)) {
            return !policies.contains(ConfigImportPolicy.OVERWRITE_ITEM_LISTS);
        }
        if (webhookConfigKeys.contains(configKey)) {
            return !policies.contains(ConfigImportPolicy.OVERWRITE_WEBHOOKS);
        }
        return "ignoredNames".equals(configKey);
    }

    static {
        PROBLEMATIC_VARBITS = ImmutableSet.of(
            KillCountNotifier.KILL_COUNT_SPAM_FILTER,
            CombatTaskNotifier.COMBAT_TASK_REPEAT_POPUP,
            Varbits.COLLECTION_LOG_NOTIFICATION,
            PetNotifier.LOOT_DROP_NOTIFICATIONS,
            PetNotifier.UNTRADEABLE_LOOT_DROPS
        );
    }
}

package dinkplugin.notifiers;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import dinkplugin.message.Embed;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.GrandExchangeNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.SerializedOffer;
import dinkplugin.util.Utils;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.grandexchange.GrandExchangePlugin;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
public class GrandExchangeNotifier extends BaseNotifier {
    private static final Set<Integer> TAX_EXEMPT_ITEMS;
    private static final int LOGIN_DELAY = 2;
    private static final String RL_GE_PLUGIN_NAME = GrandExchangePlugin.class.getSimpleName().toLowerCase();
    private final AtomicInteger initTicks = new AtomicInteger();
    private final Map<Integer, Instant> progressNotificationTimeBySlot = new HashMap<>();

    @Inject
    private Gson gson;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Override
    public boolean isEnabled() {
        return config.notifyGrandExchange() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.grandExchangeWebhook();
    }

    public void onAccountChange() {
        progressNotificationTimeBySlot.clear();
    }

    public void onGameStateChange(GameStateChanged event) {
        if (event.getGameState() != GameState.LOGGED_IN)
            initTicks.set(LOGIN_DELAY);
    }

    public void onTick() {
        initTicks.updateAndGet(i -> Math.max(i - 1, 0));
    }

    public void onOfferChange(int slot, GrandExchangeOffer offer) {
        if (shouldNotify(slot, offer)) {
            handleNotify(slot, offer);
        }
    }

    private void handleNotify(int slot, GrandExchangeOffer offer) {
        log.debug("Notifying for slot={}, item={}, quantity={}, targetPrice={}, spent={}, state={}",
            slot, offer.getItemId(), offer.getQuantitySold(), offer.getPrice(), offer.getSpent(), offer.getState());

        ItemComposition comp = itemManager.getItemComposition(offer.getItemId());
        SerializedItemStack item = new SerializedItemStack(offer.getItemId(), offer.getQuantitySold(), getUnitPrice(offer), comp.getMembersName());
        long marketPrice = ItemUtils.getPrice(itemManager, offer.getItemId());
        OfferType type = getType(offer.getState());
        Long tax = type == OfferType.SELL ? calculateTax(item.getPriceEach(), item.getQuantity(), item.getId()) : null;

        List<Embed> embeds;
        if (config.grandExchangeSendImage() || !config.discordRichEmbeds()) {
            embeds = Collections.emptyList();
        } else {
            embeds = ItemUtils.buildEmbeds(new int[] { offer.getItemId() });
        }

        String playerName = Utils.getPlayerName(client);
        Template message = Template.builder()
            .template(config.grandExchangeNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%TYPE%", Replacements.ofText(type.getDisplayName()))
            .replacement("%ITEM%", ItemUtils.templateStack(item, true))
            .replacement("%STATUS%", Replacements.ofText(getHumanStatus(offer.getState())))
            .build();
        createMessage(config.grandExchangeSendImage(), NotificationBody.builder()
            .type(NotificationType.GRAND_EXCHANGE)
            .text(message)
            .embeds(embeds)
            .extra(new GrandExchangeNotificationData(slot + 1, offer.getState(), item, marketPrice, offer.getPrice(), offer.getTotalQuantity(), tax))
            .playerName(playerName)
            .build());
    }

    private boolean shouldNotify(int slot, GrandExchangeOffer offer) {
        // During login, we only care about offers that have been completed, and that were *not* observed by the RuneLite GE plugin
        // This makes sure we don't fire any duplicate notifications for offers that were finished while we were online
        if (initTicks.get() > 0) {
            // check if offer is a completion
            if (offer.getState() != GrandExchangeOfferState.BOUGHT && offer.getState() != GrandExchangeOfferState.SOLD)
                return false;

            // require GE plugin to be enabled so that observed trades are written to config
            // however: not bullet-proof since GE plugin could've been disabled during the initial trade completion
            if (ConfigUtil.isPluginDisabled(configManager, RL_GE_PLUGIN_NAME))
                return false;

            // check whether the completion has already been observed
            if (getSavedOffer(slot).filter(saved -> saved.equalsOffer(offer)).isPresent())
                return false;
        }

        if (!isEnabled())
            return false;

        boolean valuable = getTransactedValue(offer) >= config.grandExchangeMinValue();

        switch (offer.getState()) {
            case EMPTY:
                if (client.getGameState() == GameState.LOGGED_IN)
                    progressNotificationTimeBySlot.remove(slot);
                return false;

            case BOUGHT:
            case SOLD:
                progressNotificationTimeBySlot.remove(slot);
                return valuable;

            case CANCELLED_BUY:
            case CANCELLED_SELL:
                progressNotificationTimeBySlot.remove(slot);
                return valuable && config.grandExchangeIncludeCancelled();

            case BUYING:
            case SELLING:
                if (!valuable || offer.getQuantitySold() <= 0)
                    return false;

                if (offer.getQuantitySold() >= offer.getTotalQuantity())
                    return false; // ignore since BOUGHT/SOLD is about to occur

                int spacing = config.grandExchangeProgressSpacingMinutes();
                if (spacing < 0)
                    return false; // negative => no in-progress notifications allowed

                if (getSavedOffer(slot).filter(saved -> saved.equalsOffer(offer)).isPresent())
                    return false; // ignore since quantity already observed (relevant when trade limit is binding)

                // convert minutes to seconds, but treat 0 minutes as 2 seconds to workaround duplicate RL events
                long spacingSeconds = spacing > 0 ? spacing * 60L : 2L;

                Instant now = Instant.now();
                Instant prior = progressNotificationTimeBySlot.get(slot);
                if (prior == null || Duration.between(prior, now).getSeconds() >= spacingSeconds) {
                    return progressNotificationTimeBySlot.put(slot, now) == prior;
                }
                return false;

            default:
                return false;
        }
    }

    private Optional<SerializedOffer> getSavedOffer(int slot) {
        return Optional.ofNullable(configManager.getRSProfileConfiguration("geoffer", String.valueOf(slot)))
            .map(json -> {
                try {
                    return gson.fromJson(json, SerializedOffer.class);
                } catch (JsonSyntaxException e) {
                    log.warn("Failed to read saved GE offer", e);
                    return null;
                }
            });
    }

    public static String getHumanStatus(GrandExchangeOfferState state) {
        switch (state) {
            case CANCELLED_BUY:
            case CANCELLED_SELL:
                return "Cancelled";

            case BUYING:
            case SELLING:
                return "In Progress";

            case BOUGHT:
            case SOLD:
                return "Completed";

            default:
                return null;
        }
    }

    private static OfferType getType(GrandExchangeOfferState state) {
        switch (state) {
            case BUYING:
            case CANCELLED_BUY:
            case BOUGHT:
                return OfferType.BUY;

            case SELLING:
            case CANCELLED_SELL:
            case SOLD:
                return OfferType.SELL;

            default:
                return null;
        }
    }

    private static long getTransactedValue(GrandExchangeOffer offer) {
        long spent = offer.getSpent();
        return spent > 0 ? spent : (long) offer.getQuantitySold() * offer.getPrice();
    }

    private static int getUnitPrice(GrandExchangeOffer offer) {
        int quantity = offer.getQuantitySold();
        int spent = offer.getSpent();
        return quantity > 0 && spent > 0 ? spent / quantity : offer.getPrice();
    }

    private static long calculateTax(int unitPrice, int quantity, int itemId) {
        // https://secure.runescape.com/m=news/grand-exchange-tax--item-sink?oldschool=1
        if (unitPrice < 100 || TAX_EXEMPT_ITEMS.contains(itemId)) {
            return 0L;
        }
        int price = Math.min(unitPrice, 500_000_000);
        int unitTax = (int) Math.floor(price * 0.01);
        return (long) unitTax * quantity;
    }

    @Getter
    @RequiredArgsConstructor
    private enum OfferType {
        BUY("bought"),
        SELL("sold");

        private final String displayName;
    }

    static {
        // https://oldschool.runescape.wiki/w/Category:Items_exempt_from_Grand_Exchange_tax
        TAX_EXEMPT_ITEMS = ImmutableSet.of(
            ItemID.CHISEL, ItemID.SEED_DIBBER, ItemID.GARDENING_TROWEL,
            ItemID.GLASSBLOWING_PIPE, ItemID.HAMMER, ItemID.NEEDLE,
            ItemID.PESTLE_AND_MORTAR, ItemID.RAKE, ItemID.SAW,
            ItemID.SECATEURS, ItemID.SHEARS, ItemID.SPADE,
            ItemID.WATERING_CAN, ItemID.OLD_SCHOOL_BOND
        );
    }
}

package dinkplugin.notifiers;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import dinkplugin.domain.ExternalNotificationRequest;
import dinkplugin.domain.ExternalScreenshotPolicy;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.ExternalNotificationData;
import dinkplugin.util.HttpUrlAdapter;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.client.callback.ClientThread;
import okhttp3.HttpUrl;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

@Slf4j
@Singleton
public class ExternalPluginNotifier extends BaseNotifier {

    private ClientThread clientThread;
    private Gson gson;

    @Override
    public boolean isEnabled() {
        return config.notifyExternal() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.externalWebhook();
    }

    @Inject
    void init(ClientThread clientThread, Gson gson) {
        this.clientThread = clientThread;
        this.gson = gson.newBuilder()
            .registerTypeAdapter(HttpUrl.class, new HttpUrlAdapter())
            .create();
    }

    public void onNotify(Map<String, Object> data) {
        if (!isEnabled()) {
            log.debug("Skipping requested external dink since notifier is disabled: {}", data);
            return;
        }

        // ensure input urls are specified correctly
        if (!isUrlInputValid(data.get("urls"))) {
            log.warn("Skipping externally-requested dink due to invalid 'urls' format from {}", data.get("sourcePlugin"));
            return;
        }

        // parse request
        ExternalNotificationRequest input;
        try {
            input = gson.fromJson(gson.toJsonTree(data), ExternalNotificationRequest.class);
        } catch (JsonSyntaxException e) {
            log.warn("Failed to parse requested webhook notification from an external plugin: {}", data, e);
            return;
        }

        // validate request
        if (input.getSourcePlugin() == null || input.getSourcePlugin().isBlank()) {
            log.info("Skipping externally-requested dink due to missing 'sourcePlugin': {}", data);
            return;
        }

        if (input.getText() == null || input.getText().isBlank()) {
            log.info("Skipping externally-requested dink due to missing 'text': {}", data);
            return;
        }

        if (input.getThumbnail() != null && HttpUrl.parse(input.getThumbnail()) == null) {
            log.debug("Replacing invalid thumbnail url: {}", input.getThumbnail());
            input.setThumbnail(NotificationType.EXTERNAL_PLUGIN.getThumbnail());
        }

        // process request
        this.handleNotify(input);
    }

    private void handleNotify(ExternalNotificationRequest input) {
        var player = Utils.getPlayerName(client);
        var template = Template.builder()
            .template(input.getText())
            .replacements(Objects.requireNonNullElseGet(input.getReplacements(), () -> new HashMap<>(2)))
            .replacement("%USERNAME%", Replacements.ofText(player))
            .build();

        var footer = String.format("Sent by %s via Dink", input.getSourcePlugin());

        var policy = config.externalSendImage();
        boolean image = policy != ExternalScreenshotPolicy.NEVER
            && client.getGameState().getState() >= GameState.LOGGING_IN.getState()
            && (policy == ExternalScreenshotPolicy.ALWAYS || input.isImageRequested());
        var body = NotificationBody.builder()
            .type(NotificationType.EXTERNAL_PLUGIN)
            .playerName(player)
            .text(template)
            .customTitle(input.getTitle())
            .customFooter(footer)
            .thumbnailUrl(input.getThumbnail())
            .extra(new ExternalNotificationData(input.getSourcePlugin(), input.getFields(), input.getMetadata()))
            .build();

        var urls = input.getUrls(this::getWebhookUrl);
        clientThread.invoke(() -> createMessage(urls, image, body));
    }

    private static boolean isUrlInputValid(Object urls) {
        if (urls == null) {
            return true; // use urls specified in dink's config
        }
        if (!(urls instanceof Iterable)) {
            return false; // we try to convert to list in ExternalNotificationRequest
        }
        for (Object url : (Iterable<?>) urls) {
            if (!(url instanceof HttpUrl))
                return false; // received non-HttpUrl; input should be rejected
        }
        return true; // all elements are HttpUrl instances; proceed as normal
    }

}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.SpeedrunNotificationData;
import dinkplugin.util.QuestUtils;
import dinkplugin.util.TimeUtils;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import org.jetbrains.annotations.VisibleForTesting;

import java.time.Duration;

@Slf4j
public class SpeedrunNotifier extends BaseNotifier {
    static final @VisibleForTesting int SPEEDRUN_COMPLETED_GROUP_ID = 781;
    static final @VisibleForTesting int SPEEDRUN_COMPLETED_QUEST_NAME_CHILD_ID = 4;
    static final @VisibleForTesting int SPEEDRUN_COMPLETED_DURATION_CHILD_ID = 10;
    static final @VisibleForTesting int SPEEDRUN_COMPLETED_PB_CHILD_ID = 12;
    private boolean isPersonalBest = false;

    @Override
    public boolean isEnabled() {
        // intentionally doesn't call super as WorldUtils.isIgnoredWorld includes speedrunning
        return config.notifySpeedrun() && settingsManager.isNamePermitted(client.getLocalPlayer().getName());
    }

    @Override
    protected String getWebhookUrl() {
        return config.speedrunWebhook();
    }

    public void reset() {
        isPersonalBest = false;
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == SPEEDRUN_COMPLETED_GROUP_ID && isEnabled()) {
            Widget questName = client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_QUEST_NAME_CHILD_ID);
            Widget duration = client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID);
            Widget personalBest = client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_PB_CHILD_ID);
            if (questName != null && duration != null && personalBest != null) {
                this.attemptNotify(QuestUtils.parseQuestWidget(questName.getText()), duration.getText(), personalBest.getText());
            } else {
                log.error("Found speedrun finished widget (group id {}) but it is missing something, questName={}, duration={}, pb={}", SPEEDRUN_COMPLETED_GROUP_ID, questName, duration, personalBest);
            }
        }
    }

    private void attemptNotify(String questName, String duration, String pb) {
        if (!isPersonalBest && config.speedrunPBOnly()) {
            return;
        }

        // pb or notifying on non-pb; take the right string and format placeholders
        Template notifyMessage = Template.builder()
            .template(isPersonalBest ? config.speedrunPBMessage() : config.speedrunMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%QUEST%", Replacements.ofWiki(questName))
            .replacement("%TIME%", Replacements.ofText(duration))
            .replacement("%BEST%", Replacements.ofText(pb))
            .build();

        // Reformat the durations for the extra object
        Duration bestTime = TimeUtils.parseTime(pb);
        Duration currentTime = TimeUtils.parseTime(duration);

        createMessage(config.speedrunSendImage(), NotificationBody.builder()
            .text(notifyMessage)
            .extra(new SpeedrunNotificationData(questName, bestTime.toString(), currentTime.toString(), isPersonalBest))
            .type(NotificationType.SPEEDRUN)
            .build());
        this.reset();
    }

    public void onGameMessage(String chatMessage) {
        if (!isEnabled()) {
            return;
        }

        if (chatMessage.startsWith("Speedrun duration: ")) {
            isPersonalBest = chatMessage.endsWith(" (new personal best)");
        }
    }
}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.GroupStorageNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemUtils;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.annotations.Interface;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.stream.Collectors;

/**
 * Tracks when items are deposited or withdrawn to GIM shared storage.
 * <p>
 * This is achieved by comparing snapshots of the player's inventory
 * when the storage is opened and when the transaction is saved.
 * When the difference between these two snapshots is non-empty,
 * we fire a notification (given the configured min value is satisfied).
 */
@Singleton
public class GroupStorageNotifier extends BaseNotifier {

    /**
     * The Group ID for tracking when GIM shared storage is opened.
     */
    static final @VisibleForTesting int GROUP_STORAGE_WIDGET_GROUP = InterfaceID.GROUP_STORAGE;

    /**
     * The Group ID of the widget that appears over the chat box
     * when the storage transaction is saved/committed.
     */
    static final @VisibleForTesting @Interface int GROUP_STORAGE_SAVING_WIDGET_ID = 293;

    /**
     * The message to indicate that a list of deposits or withdrawals is empty.
     */
    static final @VisibleForTesting String EMPTY_TRANSACTION = "N/A";

    /**
     * Adds two integers, but yields null if the sum is zero
     * (which removes the entry via Map#merge in {@link GroupStorageNotifier#computeDifference(Map, Map)}).
     */
    private static final BinaryOperator<Integer> SUM;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ItemManager itemManager;

    /**
     * Items in the player's inventory when the group storage was opened.
     * Entries map item id to total quantity (across stacks).
     */
    private Map<Integer, Integer> initialInventory = Collections.emptyMap();

    @Override
    public boolean isEnabled() {
        return config.notifyGroupStorage() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.groupStorageWebhook();
    }

    public void reset() {
        clientThread.invoke(() -> initialInventory = Collections.emptyMap());
    }

    public void onWidgetLoad(WidgetLoaded event) {
        if (event.getGroupId() != GROUP_STORAGE_WIDGET_GROUP)
            return;

        clientThread.invokeLater(() -> {
            ItemContainer inv = getInventory();
            if (inv == null)
                return false;

            initialInventory = reduce(inv.getItems());
            return true;
        });
    }

    public void onWidgetClose(WidgetClosed event) {
        if (event.getGroupId() != GROUP_STORAGE_SAVING_WIDGET_ID)
            return;

        Widget widget = client.getWidget(GROUP_STORAGE_SAVING_WIDGET_ID, 1);
        if (widget == null)
            return;

        if (isEnabled() && StringUtils.containsIgnoreCase(widget.getText(), "Saving")) {
            ItemContainer inv = getInventory();
            if (inv != null) {
                Map<Integer, Integer> updatedInventory = reduce(inv.getItems());
                Map<Integer, Integer> delta = computeDifference(initialInventory, updatedInventory);
                if (!delta.isEmpty()) {
                    handleNotify(delta);
                }
            }
        }

        this.reset();
    }

    private void handleNotify(Map<Integer, Integer> inventoryChanges) {
        // Calculate transaction information
        List<SerializedItemStack> deposits = new ArrayList<>();
        List<SerializedItemStack> withdrawals = new ArrayList<>();
        long debits = 0, credits = 0;
        for (Map.Entry<Integer, Integer> entry : inventoryChanges.entrySet()) {
            int diff = entry.getValue(); // positive=withdraw, negative=deposit
            SerializedItemStack item = ItemUtils.stackFromItem(itemManager, entry.getKey(), Math.abs(diff));
            long stackPrice = item.getTotalPrice();
            if (diff < 0) {
                deposits.add(item);
                debits += stackPrice;
            } else {
                withdrawals.add(item);
                credits += stackPrice;
            }
        }
        long netValue = debits - credits;

        // Ensure transaction is large enough to be logged
        if (debits < config.groupStorageMinValue() && credits < config.groupStorageMinValue())
            return;

        // Sort lists so more valuable item transactions are at the top
        Comparator<SerializedItemStack> valuable = Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed();
        deposits.sort(valuable);
        withdrawals.sort(valuable);

        // Convert lists to strings
        BiFunction<Collection<SerializedItemStack>, String, String> formatItems = (items, linePrefix) -> {
            if (items.isEmpty()) return EMPTY_TRANSACTION;
            return items.stream()
                .map(n -> ItemUtils.formatStack(n, config.groupStorageIncludePrice()))
                .collect(Collectors.joining('\n' + linePrefix, linePrefix, ""));
        };
        String depositString = formatItems.apply(deposits, "+ ");
        String withdrawalString = formatItems.apply(withdrawals, "- ");

        // Build content
        String playerName = client.getLocalPlayer().getName();
        String content = StringUtils.replaceEach(config.groupStorageNotifyMessage(),
            new String[] { "%USERNAME%", "%DEPOSITED%", "%WITHDRAWN%" },
            new String[] { playerName, depositString, withdrawalString }
        );
        Template formattedText = Template.builder()
            .template("$s$")
            .replacementBoundary("$")
            .replacement("$s$", Replacements.ofBlock("diff", content))
            .build();

        // Populate metadata
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            deposits,
            withdrawals,
            netValue,
            getGroupName(),
            config.groupStorageIncludePrice()
        );

        // Fire notification (delayed by a tick for screenshotHideChat reliability)
        clientThread.invokeAtTickEnd(() -> createMessage(config.groupStorageSendImage(),
            NotificationBody.builder()
                .type(NotificationType.GROUP_STORAGE)
                .text(formattedText)
                .playerName(playerName)
                .extra(extra)
                .build())
        );
    }

    /**
     * @return the name of the ironman group
     */
    private String getGroupName() {
        if (!config.groupStorageIncludeClan()) return null;
        ClanChannel channel = client.getClanChannel(ClanID.GROUP_IRONMAN);
        return channel != null ? channel.getName() : null;
    }

    /**
     * Upon opening the group's shared storage, the inventory is replaced
     * by a temporary container ({@link InventoryID#GROUP_STORAGE_INV}),
     * which reflects intermediate changes before the transaction is committed.
     * We prefer reading from this "fake" inventory when available.
     * On storage open, it is a server-validated copy of the local inventory.
     * On save, it has modifications that may not yet be reflected in the real inventory.
     *
     * @return the player's inventory
     */
    private ItemContainer getInventory() {
        ItemContainer inv = client.getItemContainer(InventoryID.GROUP_STORAGE_INV);
        return inv != null ? inv : client.getItemContainer(InventoryID.INVENTORY);
    }

    /**
     * @param items array of items (e.g., in the player's inventory)
     * @return mappings of item id to total quantity of the item (across stacks)
     */
    private Map<Integer, Integer> reduce(Item[] items) {
        return Arrays.stream(items)
            .filter(Objects::nonNull)
            .filter(item -> item.getId() >= 0)
            .filter(item -> item.getQuantity() > 0)
            .collect(Collectors.toMap(this::getItemId, Item::getQuantity, Integer::sum));
    }

    /**
     * @param item the item whose ID to query
     * @return the canonical item ID
     */
    private int getItemId(Item item) {
        int id = item.getId();
        if (ItemUtils.COIN_VARIATIONS.contains(id))
            return ItemID.COINS; // use single ID for all coins
        return itemManager.canonicalize(id); // un-noted, un-placeholdered, un-worn
    }

    /**
     * @param before the reduced item mappings when the group storage was first opened
     * @param after  the reduced item mappings after the save operation
     * @param <K>    generic key to merge the maps (always Integer in this notifier)
     * @return mappings of item id to change in quantity, excluding items with no change
     */
    private static <K> Map<K, Integer> computeDifference(Map<K, Integer> before, Map<K, Integer> after) {
        Map<K, Integer> delta = new HashMap<>(after);
        before.forEach((id, quantity) -> delta.merge(id, -quantity, SUM));
        return delta;
    }

    static {
        SUM = (a, b) -> {
            int sum = a + b;
            return sum != 0 ? sum : null;
        };
    }
}

package dinkplugin.notifiers;

import dinkplugin.domain.AchievementDiary;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.DiaryNotificationData;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static dinkplugin.domain.AchievementDiary.DIARIES;

@Slf4j
@Singleton
public class DiaryNotifier extends BaseNotifier {

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,script3971%5D.cs2">CS2 Reference</a>
     */
    static final int COMPLETED_TASKS_SCRIPT_ID = 3971;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,script3980%5D.cs2">CS2 Reference</a>
     */
    static final int TOTAL_TASKS_SCRIPT_ID = 3980;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,summary_diary_completed%5D.cs2">CS2 Reference</a>
     */
    private static final int COMPLETED_AREA_TASKS_SCRIPT_ID = 4072;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,summary_diary_total%5D.cs2">CS2 Reference</a>
     */
    private static final int TOTAL_AREA_TASKS_SCRIPT_ID = 4073;

    private static final Pattern COMPLETION_REGEX = Pattern.compile("Congratulations! You have completed all of the (?<difficulty>.+) tasks in the (?<area>.+) area");
    private final Map<Integer, Integer> diaryCompletionById = new ConcurrentHashMap<>();
    private final AtomicInteger initDelayTicks = new AtomicInteger();
    private final AtomicInteger cooldownTicks = new AtomicInteger();

    @Inject
    private ClientThread clientThread;

    @Override
    public boolean isEnabled() {
        return config.notifyAchievementDiary() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.diaryWebhook();
    }

    public void reset() {
        this.diaryCompletionById.clear();
        this.initDelayTicks.set(0);
        this.cooldownTicks.set(0);
    }

    public void onGameState(GameStateChanged event) {
        if (event.getGameState() != GameState.LOGGED_IN)
            this.reset();
    }

    public void onTick() {
        if (client.getGameState() != GameState.LOGGED_IN)
            return;

        cooldownTicks.getAndUpdate(i -> Math.max(i - 1, 0));
        int ticks = initDelayTicks.getAndUpdate(i -> Math.max(i - 1, 0));
        if (ticks > 0) {
            if (ticks == 1) {
                this.initCompleted();
            }
        } else if (diaryCompletionById.size() < DIARIES.size() && super.isEnabled()) {
            // mark diary completions to be initialized later
            this.initDelayTicks.set(4);
        }
    }

    public void onMessageBox(String message) {
        if (!isEnabled()) return;

        Matcher matcher = COMPLETION_REGEX.matcher(message);
        if (matcher.find()) {
            String difficultyStr = matcher.group("difficulty");
            AchievementDiary.Difficulty difficulty;
            try {
                difficulty = AchievementDiary.Difficulty.valueOf(difficultyStr.toUpperCase());
            } catch (IllegalArgumentException e) {
                log.warn("Failed to match diary difficulty: {}", difficultyStr);
                return;
            }

            String area = matcher.group("area").trim();
            Optional<AchievementDiary> found = DIARIES.values().stream()
                .filter(e -> e.getDifficulty() == difficulty && Utils.containsEither(e.getArea(), area))
                .findAny();
            if (found.isPresent()) {
                AchievementDiary diary = found.get();
                int varbitId = diary.getId();
                if (isComplete(varbitId, 1)) {
                    diaryCompletionById.put(varbitId, 1);
                } else {
                    diaryCompletionById.put(varbitId, 2);
                }
                if (!checkDifficulty(difficulty)) return;

                clientThread.invokeLater(() -> handle(diary)); // 20ms delay to run scripts cleanly
            } else {
                log.warn("Failed to match diary area: {}", area);
            }
        }
    }

    public void onVarbitChanged(VarbitChanged event) {
        int id = event.getVarbitId();
        if (id < 0) return;
        AchievementDiary diary = DIARIES.get(id);
        if (diary == null) return;
        if (!super.isEnabled()) return;
        if (diaryCompletionById.isEmpty()) {
            if (client.getGameState() == GameState.LOGGED_IN && isComplete(id, event.getValue())) {
                // this log only occurs in exceptional circumstances (i.e., completion within seconds of logging in or enabling the plugin)
                log.info("Skipping {} {} diary completion that occurred before map initialization", diary.getDifficulty(), diary.getArea());
            }
            return;
        }

        int value = event.getValue();
        Integer previous = diaryCompletionById.get(id);
        if (previous == null) {
            // this log should not occur, barring a jagex oddity
            log.warn("Resetting since {} {} diary was not initialized with a valid value; received new value of {}", diary.getDifficulty(), diary.getArea(), value);
            reset();
        } else if (value < previous) {
            // this log should not occur, barring a jagex/runelite oddity
            log.info("Resetting since it appears {} {} diary has lost progress from {}; received new value of {}", diary.getDifficulty(), diary.getArea(), previous, value);
            reset();
        } else if (value > previous) {
            diaryCompletionById.put(id, value);

            if (isComplete(id, value)) {
                if (checkDifficulty(diary.getDifficulty())) {
                    clientThread.invokeLater(() -> handle(diary)); // 20ms delay to run scripts cleanly
                } else {
                    log.debug("Skipping {} {} diary due to low difficulty", diary.getDifficulty(), diary.getArea());
                }
            } else {
                // Karamja special case
                log.info("Skipping {} {} diary start (not a completion with value {})", diary.getDifficulty(), diary.getArea(), value);
            }
        }
    }

    private void handle(AchievementDiary diary) {
        if (cooldownTicks.getAndSet(2) > 0) {
            log.debug("Skipping diary completion during cooldown: {} {}", diary.getDifficulty(), diary.getArea());
            return;
        }

        client.runScript(DiaryNotifier.COMPLETED_TASKS_SCRIPT_ID);
        int completedTasks = client.getIntStack()[0];
        client.runScript(DiaryNotifier.TOTAL_TASKS_SCRIPT_ID);
        int totalTasks = client.getIntStack()[0];

        client.runScript(COMPLETED_AREA_TASKS_SCRIPT_ID, diary.getAreaId());
        int completedAreaTasks = client.getIntStack()[0];
        client.runScript(TOTAL_AREA_TASKS_SCRIPT_ID, diary.getAreaId());
        int totalAreaTasks = client.getIntStack()[0];

        int completedDiaries = getTotalCompleted();
        String player = Utils.getPlayerName(client);
        Template message = Template.builder()
            .template(config.diaryNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(player))
            .replacement("%DIFFICULTY%", Replacements.ofText(diary.getDifficulty().toString()))
            .replacement("%AREA%", Replacements.ofWiki(diary.getArea(), diary.getArea() + " Diary"))
            .replacement("%TOTAL%", Replacements.ofText(String.valueOf(completedDiaries)))
            .replacement("%TASKS_COMPLETE%", Replacements.ofText(String.valueOf(completedTasks)))
            .replacement("%TASKS_TOTAL%", Replacements.ofText(String.valueOf(totalTasks)))
            .replacement("%AREA_TASKS_COMPLETE%", Replacements.ofText(String.valueOf(completedAreaTasks)))
            .replacement("%AREA_TASKS_TOTAL%", Replacements.ofText(String.valueOf(totalAreaTasks)))
            .build();

        createMessage(config.diarySendImage(), NotificationBody.builder()
            .type(NotificationType.ACHIEVEMENT_DIARY)
            .text(message)
            .extra(new DiaryNotificationData(diary.getArea(), diary.getDifficulty(), completedDiaries, completedTasks, totalTasks, completedAreaTasks, totalAreaTasks))
            .playerName(player)
            .build());
    }

    private boolean checkDifficulty(AchievementDiary.Difficulty difficulty) {
        return config.notifyAchievementDiary() && difficulty.ordinal() >= config.minDiaryDifficulty().ordinal();
    }

    private int getTotalCompleted() {
        int n = 0;

        for (Map.Entry<Integer, Integer> entry : diaryCompletionById.entrySet()) {
            int id = entry.getKey();
            int value = entry.getValue();
            if (isComplete(id, value)) {
                n++;
            }
        }

        return n;
    }

    private void initCompleted() {
        if (!super.isEnabled()) return;
        for (Integer id : DIARIES.keySet()) {
            int value = client.getVarbitValue(id);
            if (value >= 0) {
                diaryCompletionById.put(id, value);
            }
        }
        log.debug("Finished initializing current diary completions: {} out of {}", getTotalCompleted(), diaryCompletionById.size());
    }

    public static boolean isComplete(int id, int value) {
        if (id == 3578 || id == 3599 || id == 3611) {
            // Karamja special case (except Elite): 0 = not started, 1 = started, 2 = completed tasks
            return value > 1;
        } else {
            // otherwise: 0 = not started, 1 = completed
            return value > 0;
        }
    }
}

package dinkplugin.notifiers;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.PlayerKillNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.WorldUtils;
import net.runelite.api.Actor;
import net.runelite.api.Hitsplat;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Skill;
import net.runelite.api.WorldType;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.kit.KitType;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;
import java.util.WeakHashMap;
import java.util.concurrent.TimeUnit;

@Singleton
public class PlayerKillNotifier extends BaseNotifier {

    private static final KitType[] EQUIPMENT;

    /**
     * Contains the damage inflicted by the local player on various targets in a short time period.
     * <p>
     * Uses weak keys to not hinder garbage collection
     * (and avoid synchronization if we were forced to do Map#clear on plugin shutdown).
     */
    private final Map<Player, Integer> attacked = new WeakHashMap<>(4);

    private final Cache<Actor, Boolean> recentlyNotified = CacheBuilder.newBuilder()
        .weakKeys()
        .expireAfterAccess(5, TimeUnit.SECONDS)
        .build();

    @Inject
    private ItemManager itemManager;

    @Override
    public boolean isEnabled() {
        if (!config.notifyPk())
            return false;

        // duplicated logic from super class but allow Duel Arena
        EnumSet<WorldType> world = client.getWorldType().clone(); // fast on RegularEnumSet
        world.remove(WorldType.PVP_ARENA);
        return !WorldUtils.isIgnoredWorld(world) && settingsManager.isNamePermitted(client.getLocalPlayer().getName());
    }

    @Override
    protected String getWebhookUrl() {
        return config.pkWebhook();
    }

    public void onHitsplat(HitsplatApplied event) {
        Hitsplat hit = event.getHitsplat();
        int amount = hit.getAmount();
        if (amount <= 0 || !hit.isMine())
            return;

        if (!config.notifyPk())
            return;

        Actor actor = event.getActor();
        if (actor == client.getLocalPlayer() || !(actor instanceof Player))
            return;

        // multi-tick spec already killed them on a previous tick - https://github.com/pajlads/DinkPlugin/issues/466
        if (recentlyNotified.getIfPresent(actor) != null)
            return;

        Player target = (Player) actor;
        attacked.merge(target, amount, Integer::sum);
    }

    public void onTick() {
        // micro-optimization: this check is very fast for empty WeakHashMap & can avoid creating a HashIterator
        if (attacked.isEmpty())
            return;

        attacked.forEach((target, damage) -> {
            if (target.isDead())
                handleKill(target, damage);
        });

        attacked.clear();
    }

    private void handleKill(Player target, int myLastDamage) {
        if (!isEnabled())
            return;

        if (config.pkSkipFriendly() && isFriendly(target))
            return;

        if (config.pkSkipSafe() && (WorldUtils.isSafeArea(client) || client.getWorldType().contains(WorldType.PVP_ARENA)))
            return;

        Map<KitType, SerializedItemStack> equipment = getEquipment(target.getPlayerComposition());
        long value = ItemUtils.getTotalPrice(equipment.values());
        long minValue = config.pkMinValue();
        if (value < minValue)
            return;

        boolean sendLocation = config.pkIncludeLocation();
        PlayerKillNotificationData extra = new PlayerKillNotificationData(
            target.getName(),
            target.getCombatLevel(),
            equipment,
            sendLocation ? client.getWorld() : null,
            sendLocation ? WorldUtils.getLocation(client, target) : null,
            client.getBoostedSkillLevel(Skill.HITPOINTS),
            myLastDamage
        );

        String localPlayer = client.getLocalPlayer().getName();
        Template message = Template.builder()
            .template(config.pkNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(localPlayer))
            .replacement("%TARGET%", Replacements.ofLink(target.getName(), config.playerLookupService().getPlayerUrl(target.getName())))
            .build();

        createMessage(config.pkSendImage(), NotificationBody.builder()
            .type(NotificationType.PLAYER_KILL)
            .text(message)
            .extra(extra)
            .playerName(localPlayer)
            .build());

        recentlyNotified.put(target, Boolean.TRUE);
    }

    private boolean isFriendly(Player target) {
        return target.isFriend() || target.isClanMember() || target.isFriendsChatMember()
            || (target.getTeam() != 0 && target.getTeam() == client.getLocalPlayer().getTeam());
    }

    private Map<KitType, SerializedItemStack> getEquipment(PlayerComposition comp) {
        if (comp == null) return Collections.emptyMap();

        int[] equipmentIds = comp.getEquipmentIds();
        int n = equipmentIds.length;

        Map<KitType, SerializedItemStack> map = new EnumMap<>(KitType.class);
        for (KitType slot : EQUIPMENT) {
            int index = slot.getIndex();
            if (index >= n) continue;
            int id = equipmentIds[index];
            if (id >= PlayerComposition.ITEM_OFFSET) {
                SerializedItemStack item = ItemUtils.stackFromItem(itemManager, id - PlayerComposition.ITEM_OFFSET, 1);
                map.put(slot, item);
            }
        }
        return map;
    }

    static {
        // omits ARMS, HAIR, JAW because they don't correspond to items
        EQUIPMENT = new KitType[] {
            KitType.HEAD,
            KitType.CAPE,
            KitType.AMULET,
            KitType.WEAPON,
            KitType.TORSO,
            KitType.SHIELD,
            KitType.LEGS,
            KitType.HANDS,
            KitType.BOOTS
        };
    }
}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.notifiers.data.TradeNotificationData;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.annotations.Interface;
import net.runelite.api.annotations.VarCStr;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Image;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@Singleton
public class TradeNotifier extends BaseNotifier {
    @VisibleForTesting
    public static final String TRADE_ACCEPTED_MESSAGE = "Accepted trade.";
    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bclientscript%2Ctrade_partner_set%5D.cs2#L3">CS2 Reference</a>
     */
    @VisibleForTesting
    public static final @VarCStr int TRADE_COUNTERPARTY_VAR = 357;
    private static final @Interface int TRADE_CONFIRMATION_GROUP = 334;

    @Inject
    private ClientThread clientThread;

    @Inject
    private DrawManager drawManager;

    @Inject
    private ImageCapture imageCapture;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private ItemManager itemManager;

    private final AtomicReference<Image> image = new AtomicReference<>();

    @Override
    public boolean isEnabled() {
        return config.notifyTrades() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.tradeWebhook();
    }

    public void reset() {
        image.lazySet(null);
    }

    public void onTradeMessage(String message) {
        if (!TRADE_ACCEPTED_MESSAGE.equals(message) || !isEnabled()) {
            this.reset();
            return;
        }

        ItemContainer tradeInv = client.getItemContainer(InventoryID.TRADE);
        ItemContainer otherInv = client.getItemContainer(InventoryID.TRADEOTHER);
        if (tradeInv == null && otherInv == null) {
            log.debug("Could not find traded items!");
            this.reset();
            return;
        }
        Item[] trade = tradeInv != null ? tradeInv.getItems() : new Item[0];
        Item[] other = otherInv != null ? otherInv.getItems() : new Item[0];
        long receiveValue = getTotalValue(other);
        long giveValue = getTotalValue(trade);
        if (receiveValue + giveValue < config.tradeMinValue()) {
            this.reset();
            return;
        }
        List<SerializedItemStack> received = getItems(other);
        List<SerializedItemStack> disbursed = getItems(trade);

        String localPlayer = client.getLocalPlayer().getName();
        String counterparty = Utils.sanitize(client.getVarcStrValue(TRADE_COUNTERPARTY_VAR));
        Template content = Template.builder()
            .template(config.tradeNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(localPlayer))
            .replacement("%COUNTERPARTY%", Replacements.ofLink(counterparty, config.playerLookupService().getPlayerUrl(counterparty)))
            .replacement("%IN_VALUE%", Replacements.ofText(QuantityFormatter.quantityToStackSize(receiveValue)))
            .replacement("%OUT_VALUE%", Replacements.ofText(QuantityFormatter.quantityToStackSize(giveValue)))
            .build();

        createMessage(config.tradeSendImage(), NotificationBody.builder()
            .text(content)
            .extra(new TradeNotificationData(counterparty, received, disbursed, receiveValue, giveValue))
            .playerName(localPlayer)
            .screenshotOverride(image.get())
            .type(NotificationType.TRADE)
            .build()
        );

        this.reset();
    }

    public void onWidgetLoad(WidgetLoaded event) {
        if (event.getGroupId() == TRADE_CONFIRMATION_GROUP) {
            Utils.captureScreenshot(client, clientThread, drawManager, imageCapture, executor, config, image::set);
        }
    }

    public void onWidgetClose(WidgetClosed event) {
        // relevant when local player declines a trade since no chat message occurs
        if (event.getGroupId() == TRADE_CONFIRMATION_GROUP) {
            clientThread.invokeAtTickEnd(this::reset);
        }
    }

    private long getTotalValue(Item[] items) {
        long v = 0;
        for (Item item : items) {
            v += ItemUtils.getPrice(itemManager, item.getId()) * item.getQuantity();
        }
        return v;
    }

    private List<SerializedItemStack> getItems(Item[] items) {
        if (items.length == 0) {
            return Collections.emptyList();
        }
        Map<Integer, Integer> quantityById = new HashMap<>(items.length * 4 / 3);
        for (Item item : items) {
            quantityById.merge(item.getId(), item.getQuantity(), Integer::sum);
        }
        List<SerializedItemStack> stacks = new ArrayList<>(quantityById.size());
        quantityById.forEach((id, quantity) -> stacks.add(ItemUtils.stackFromItem(itemManager, id, quantity)));
        return stacks;
    }
}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;

@Value
@EqualsAndHashCode(callSuper = false)
public class LeaguesMasteryNotificationData extends NotificationData {

    /**
     * Melee, Ranged, or Magic.
     */
    String masteryType;

    /**
     * Ranges from 1 to 6.
     */
    int masteryTier;

}

package dinkplugin.notifiers.data;

import lombok.Value;

@Value
public class Progress {
    int completed;
    int total;

    public static Progress of(int completed, int total) {
        if (total <= 0 || completed < 0) return null;
        return new Progress(completed, total);
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.util.ItemUtils;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.apache.commons.lang3.StringUtils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class GroupStorageNotificationData extends NotificationData {
    Collection<SerializedItemStack> deposits;
    Collection<SerializedItemStack> withdrawals;
    long netValue;
    String groupName;
    transient boolean includePrice;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);
        if (StringUtils.isNotBlank(groupName))
            fields.add(new Field("Group", Field.formatBlock(null, groupName)));
        if (includePrice) {
            fields.add(new Field("Net Value (GE)", ItemUtils.formatGold(netValue)));
        }
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.util.Region;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;

@Value
@EqualsAndHashCode(callSuper = false)
public class DeathNotificationData extends NotificationData {

    long valueLost;

    boolean isPvp;

    /**
     * @deprecated in favor of {@link #getKillerName()}
     */
    @Nullable
    @Deprecated
    String pker;

    @Nullable
    String killerName;

    @Nullable
    Integer killerNpcId;

    @NotNull
    Collection<SerializedItemStack> keptItems;

    @NotNull
    Collection<SerializedItemStack> lostItems;

    @NotNull
    Region location;

}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@Value
@EqualsAndHashCode(callSuper = false)
public class SlayerNotificationData extends NotificationData {

    @NotNull
    String slayerTask;

    @NotNull
    String slayerCompleted;

    @NotNull
    String slayerPoints;

    @Nullable // if jagex changes format of slayerTask
    Integer killCount;

    @Nullable // if jagex changes format of slayerTask
    String monster;

}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.Collection;
import java.util.Map;

@Value
@EqualsAndHashCode(callSuper = false)
public class XpNotificationData extends NotificationData {
    Map<String, Integer> xpData;
    Collection<String> milestoneAchieved;
    int interval;
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.util.Drop;
import dinkplugin.util.ItemUtils;
import lombok.Value;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Objects;

@Value
public class LootNotificationData extends NotificationData {
    Collection<SerializedItemStack> items;
    String source;
    LootRecordType category;

    @Nullable
    Integer killCount;

    @Nullable
    Double rarestProbability;

    @Nullable
    Collection<String> party;

    @Nullable
    Integer npcId;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(4);
        if (killCount != null) {
            fields.add(
                new Field(
                    Drop.getAction(category) + " Count",
                    Field.formatBlock("", QuantityFormatter.quantityToStackSize(killCount))
                )
            );
        }
        fields.add(
            new Field(
                "Total Value",
                ItemUtils.formatGold(items.stream().mapToLong(SerializedItemStack::getTotalPrice).sum())
            )
        );
        if (rarestProbability != null) {
            fields.add(new Field("Item Rarity", Field.formatProbability(rarestProbability)));
        }
        if (party != null && !party.isEmpty()) {
            fields.add(new Field("Party Size", Field.formatBlock("", String.valueOf(party.size()))));
        }
        return fields;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof LootNotificationData)) return false;
        LootNotificationData that = (LootNotificationData) o;
        return category == that.category && Objects.equals(source, that.source)
            && Objects.equals(killCount, that.killCount) && Objects.equals(rarestProbability, that.rarestProbability)
            && items.containsAll(that.items) && that.items.containsAll(items); // for ease of testing
    }

    @Override
    public int hashCode() {
        return Objects.hash(items, source, category, killCount, rarestProbability);
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeSet;
import java.util.stream.Collectors;

import static dinkplugin.notifiers.LevelNotifier.LEVEL_FOR_MAX_XP;
import static net.runelite.api.Experience.MAX_REAL_LEVEL;

@Value
@EqualsAndHashCode(callSuper = false)
public class LevelNotificationData extends NotificationData {
    Map<String, Integer> levelledSkills;
    Map<String, Integer> allSkills;
    CombatLevel combatLevel;

    @Override
    public List<Field> getFields() {
        if (levelledSkills.containsValue(MAX_REAL_LEVEL)) {
            return Collections.singletonList(
                new Field(
                    "Total Skills at Level 99+",
                    collectMaxedSkills(MAX_REAL_LEVEL)
                )
            );
        }

        if (levelledSkills.containsValue(LEVEL_FOR_MAX_XP)) {
            return Collections.singletonList(
                new Field(
                    "Total Skills at Max XP",
                    collectMaxedSkills(LEVEL_FOR_MAX_XP)
                )
            );
        }

        return super.getFields();
    }

    private String collectMaxedSkills(int minLevel) {
        Collection<String> maxed = allSkills.entrySet().stream()
            .filter(e -> e.getValue() >= minLevel)
            .map(Map.Entry::getKey)
            .collect(Collectors.toCollection(TreeSet::new));
        return Field.formatBlock("", maxed.size() + ": " + String.join(", ", maxed));
    }

    @Value
    public static class CombatLevel {
        int value;
        Boolean increased;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.domain.CombatAchievementTier;
import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class CombatAchievementData extends NotificationData {

    /**
     * The tier of the task that was just completed.
     */
    @NotNull
    CombatAchievementTier tier;

    /**
     * The name of the task that was just completed.
     */
    @NotNull
    String task;

    /**
     * The number of points rewarded for completing this task.
     */
    int taskPoints;

    /**
     * The total points that have been earned by the player from tasks across tiers.
     */
    int totalPoints;

    /**
     * The marginal points that have been obtained towards the next rewards unlock.
     * <p>
     * Formula: totalPoints - previousUnlockThreshold
     * <p>
     * Range: [0, tierTotalPoints - 1]
     * <p>
     * This field is <i>not</i> populated if the player has completed all tiers.
     */
    @Nullable
    Integer tierProgress;

    /**
     * The total points within a tier to unlock the next reward.
     * <p>
     * Formula: {@code tierProgress + pointsUntilNextUnlock}
     * <p>
     * This can be transformed to the cumulative points threshold via:
     * {@code (totalPoints - tierProgress) + tierTotalPoints}
     * <p>
     * This field is <i>not</i> populated if the player has completed all tiers.
     */
    @Nullable
    Integer tierTotalPoints;

    /**
     * The total points achievable
     */
    int totalPossiblePoints;

    /**
     * The current tier the player holds
     */
    @Nullable
    CombatAchievementTier currentTier;

    /**
     * The next tier to be unlocked
     */
    @Nullable
    CombatAchievementTier nextTier;

    /**
     * The tier whose rewards were just unlocked,
     * <i>if</i> the player just completed the tier.
     */
    @Nullable
    CombatAchievementTier justCompletedTier;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(3);
        fields.add(new Field("Points Earned", Field.formatBlock(null, String.valueOf(taskPoints))));
        fields.add(new Field("Total Points", Field.formatBlock(null, String.valueOf(totalPoints))));
        if (tierProgress != null && tierTotalPoints != null)
            fields.add(new Field("Next Unlock Progress", Field.formatProgress(tierProgress, tierTotalPoints)));
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.util.ItemUtils;
import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.Collections;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class ClueNotificationData extends NotificationData {
    String clueType;
    int numberCompleted;
    List<SerializedItemStack> items;

    @Override
    public List<Field> getFields() {
        return Collections.singletonList(
            new Field(
                "Total Value",
                ItemUtils.formatGold(items.stream().mapToLong(SerializedItemStack::getTotalPrice).sum())
            )
        );
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class LeaguesRelicNotificationData extends NotificationData {

    @NotNull
    String relic;
    int tier;
    int requiredPoints;
    int totalPoints;

    @Nullable // if relics for all 8 tiers have now been unlocked
    Integer pointsUntilNextTier;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);
        fields.add(
            new Field(
                "Total Points",
                Field.formatBlock("", String.valueOf(totalPoints))
            )
        );
        if (pointsUntilNextTier != null) {
            fields.add(
                new Field(
                    "Points until next Relic",
                    Field.formatBlock("", String.valueOf(pointsUntilNextTier))
                )
            );
        }
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.util.ItemUtils;
import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class TradeNotificationData extends NotificationData {
    String counterparty;
    List<SerializedItemStack> receivedItems;
    List<SerializedItemStack> givenItems;
    long receivedValue;
    long givenValue;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);
        fields.add(new Field("Received Value", ItemUtils.formatGold(receivedValue)));
        fields.add(new Field("Given Value", ItemUtils.formatGold(givenValue)));
        return fields;
    }
}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class GambleNotificationData extends NotificationData {
    int gambleCount;
    List<SerializedItemStack> items;
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class LeaguesAreaNotificationData extends NotificationData {

    @NotNull
    String area;

    int index;

    int tasksCompleted;

    @Nullable // if player has already unlocked all three regions
    Integer tasksUntilNextArea;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);
        fields.add(
            new Field("Tasks Completed", Field.formatBlock("", String.valueOf(tasksCompleted)))
        );
        if (tasksUntilNextArea != null) {
            fields.add(
                new Field("Tasks until next Area", Field.formatBlock("", String.valueOf(tasksUntilNextArea)))
            );
        }
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.domain.LootCriteria;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.util.Set;

@Getter
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class AnnotatedItemStack extends SerializedItemStack {
    private final Set<LootCriteria> criteria;

    public AnnotatedItemStack(int id, int quantity, int priceEach, String name, Set<LootCriteria> criteria) {
        super(id, quantity, priceEach, name);
        this.criteria = criteria;
    }

    public static AnnotatedItemStack of(SerializedItemStack i, Set<LootCriteria> criteria) {
        return new AnnotatedItemStack(i.getId(), i.getQuantity(), i.getPriceEach(), i.getName(), criteria);
    }
}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;

@Value
@EqualsAndHashCode(callSuper = false)
public class SpeedrunNotificationData extends NotificationData {
    /**
     * The name of the quest (e.g. "Cook's Assistant")
     */
    @NotNull
    String questName;

    /**
     * The player's personal best of this quest
     */
    @NotNull
    String personalBest;

    /**
     * The time it took the player to finish the quest
     */
    @NotNull
    String currentTime;

    /**
     * Denotes whether this run was a new personal best or not.
     * If the player ties with their previous personal best, this will be set to false.
     */
    boolean isPersonalBest;
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.util.Drop;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class CollectionNotificationData extends NotificationData {

    @NotNull
    String itemName;

    @Nullable
    Integer itemId;

    @Nullable
    Long price;

    @Nullable
    Integer completedEntries;

    @Nullable
    Integer totalEntries;

    @Nullable
    String dropperName;

    @Nullable
    LootRecordType dropperType;

    @Nullable
    Integer dropperKillCount;

    @Nullable
    Double dropRate;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(5);
        if (completedEntries != null && totalEntries != null) {
            fields.add(
                new Field("Completed", Field.formatProgress(completedEntries, totalEntries))
            );
        }
        if (dropperKillCount != null) {
            assert dropperName != null && dropperType != null;
            fields.add(
                new Field("Source", Field.formatBlock("", dropperName))
            );
            fields.add(
                new Field(
                    Drop.getAction(dropperType) + " Count",
                    Field.formatBlock("", QuantityFormatter.quantityToStackSize(dropperKillCount))
                )
            );
        }
        if (dropRate != null) {
            fields.add(new Field("Drop Rate", Field.formatProbability(dropRate)));
        }
        if (dropperKillCount != null && dropRate != null) {
            fields.add(Field.ofLuck(dropRate, dropperKillCount));
        }
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.domain.LootCriteria;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.util.Set;

@Getter
@ToString(callSuper = true)
@EqualsAndHashCode(callSuper = true)
public class RareItemStack extends AnnotatedItemStack {
    private final double rarity;

    public RareItemStack(int id, int quantity, int priceEach, String name, Set<LootCriteria> criteria, double rarity) {
        super(id, quantity, priceEach, name, criteria);
        this.rarity = rarity;
    }

    public static RareItemStack of(AnnotatedItemStack i, double rarity) {
        return new RareItemStack(i.getId(), i.getQuantity(), i.getPriceEach(), i.getName(), i.getCriteria(), rarity);
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;

import java.util.Collections;
import java.util.List;

public abstract class NotificationData {
    public List<Field> getFields() {
        return Collections.emptyList();
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.domain.AchievementDiary;
import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class DiaryNotificationData extends NotificationData {

    /**
     * The area of the diary that was just completed.
     */
    String area;

    /**
     * The difficulty of the diary that was just completed.
     */
    AchievementDiary.Difficulty difficulty;

    /**
     * The number of diaries that have been completed across all regions and difficulties.
     */
    int total;

    /**
     * The number of diary tasks that have been completed across all regions and difficulties.
     */
    int tasksCompleted;

    /**
     * The total number of diary tasks within the game across all regions and difficulties.
     */
    int tasksTotal;

    /**
     * The number of diary tasks completed within this specific area.
     */
    int areaTasksCompleted;

    /**
     * The total number of diary tasks possible within this specific area.
     */
    int areaTasksTotal;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);

        if (areaTasksCompleted > 0 && areaTasksTotal > 0) {
            fields.add(
                new Field(area + " Progress", Field.formatProgress(areaTasksCompleted, areaTasksTotal))
            );
        }

        if (tasksCompleted > 0 && tasksTotal > 0) {
            fields.add(
                new Field("Overall Progress", Field.formatProgress(tasksCompleted, tasksTotal))
            );
        }

        return fields;
    }
}

package dinkplugin.notifiers.data;

import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.ChatMessageType;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.events.ChatMessage;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

@Value
@EqualsAndHashCode(callSuper = false)
public class ChatNotificationData extends NotificationData {

    @NotNull
    ChatMessageType type;

    /**
     * {@link ChatMessage#getName()} when available; otherwise {@link  ChatMessage#getSender()}.
     * When {@link #getType()} is {@link ChatMessageType#UNKNOWN}, this field corresponds to the originating runelite event.
     */
    @Nullable
    String source;

    /**
     * Clan title of the player that sent the message.
     * Only populated when {@link #getType()} is {@link ChatMessageType#CLAN_CHAT}
     * or {@link ChatMessageType#CLAN_GUEST_CHAT} or {@link ChatMessageType#CLAN_GIM_CHAT}
     * or sometimes {@link ChatMessageType#CLAN_MESSAGE} (for user joins).
     */
    @Nullable
    ClanTitle clanTitle;

    @NotNull
    String message;

}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import dinkplugin.notifiers.GrandExchangeNotifier;
import dinkplugin.util.ItemUtils;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.GrandExchangeOfferState;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class GrandExchangeNotificationData extends NotificationData {

    /**
     * The slot index (one-based) for this transaction.
     * This ranges from 1 to 8 (inclusive) for members, and 1 to 3 (inclusive) for F2P.
     */
    int slot;

    /**
     * The trade offer status.
     * Will not be {@link GrandExchangeOfferState#EMPTY}.
     */
    @NotNull
    GrandExchangeOfferState status;

    /**
     * The transacted item, including the number of items transacted and the pre-tax average price.
     */
    @NotNull
    SerializedItemStack item;

    /**
     * The current market price for the transacted item, according to wiki data.
     * This can differ from the transacted price contained in {@link #getItem()}.
     */
    long marketPrice;

    /**
     * The limit order price selected by the user for the offer.
     * For sell (buy) offers, this is a lower (upper) bound on the price contained in {@link #getItem()}.
     */
    long targetPrice;

    /**
     * The total number of items that the player wishes to buy within this slot.
     * When {@link #getStatus()} is {@link GrandExchangeOfferState#BOUGHT} or {@link GrandExchangeOfferState#SOLD},
     * this quantity is equivalent to the quantity contained within {@link #getItem()}.
     */
    int targetQuantity;

    /**
     * GP corresponding to the 1 percent tax that is levied on the seller for this transaction.
     * This field is not included when purchasing items.
     */
    @Nullable
    Long sellerTax;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(4);
        fields.add(
            new Field("Status", Field.formatBlock("", GrandExchangeNotifier.getHumanStatus(status)))
        );

        if (status == GrandExchangeOfferState.BUYING || status == GrandExchangeOfferState.SELLING) {
            fields.add(
                new Field("Target Quantity", Field.formatBlock("", String.valueOf(targetQuantity)))
            );
        }

        if (sellerTax != null && sellerTax > 0) {
            fields.add(
                new Field("After-Tax Value", ItemUtils.formatGold(item.getTotalPrice() - sellerTax))
            );
        }

        if (marketPrice > 0) {
            fields.add(
                new Field("Market Unit Price", ItemUtils.formatGold(marketPrice))
            );
        }

        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.domain.LeagueTaskDifficulty;
import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class LeaguesTaskNotificationData extends NotificationData {

    @NotNull
    String taskName;

    @NotNull
    LeagueTaskDifficulty difficulty;

    int taskPoints;
    int totalPoints;
    int tasksCompleted;

    @Nullable // if player has already unlocked all three regions
    Integer tasksUntilNextArea;

    @Nullable // if player has already unlocked a tier 8 relic (highest)
    Integer pointsUntilNextRelic;

    @Nullable // if player has already earned the dragon trophy (highest)
    Integer pointsUntilNextTrophy;

    @Nullable // if the player did not earn a new trophy with this task completion
    String earnedTrophy;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(3);
        fields.add(new Field("Total Tasks", Field.formatBlock("", String.valueOf(tasksCompleted))));
        fields.add(new Field("Total Points", Field.formatBlock("", String.valueOf(totalPoints))));
        if (earnedTrophy == null && tasksUntilNextArea != null) {
            fields.add(new Field("Tasks until next Area", Field.formatBlock("", String.valueOf(tasksUntilNextArea))));
        } else if (earnedTrophy == null && pointsUntilNextRelic != null) {
            fields.add(new Field("Points until next Relic", Field.formatBlock("", String.valueOf(pointsUntilNextRelic))));
        } else if (pointsUntilNextTrophy != null) {
            fields.add(new Field("Points until next Trophy", Field.formatBlock("", String.valueOf(pointsUntilNextTrophy))));
        }
        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class PetNotificationData extends NotificationData {

    /**
     * The name of the pet.
     * <p>
     * This field is null when the name cannot be read from untradeable drop, collection log, or clan chat notification.
     */
    @Nullable
    String petName;

    /**
     * The milestone (e.g., skill XP, boss KC) at which this pet was acquiried.
     * <p>
     * This field relies upon clan chat notifications.
     */
    @Nullable
    String milestone;

    /**
     * Whether this pet is (currently) already owned.
     */
    boolean duplicate;

    /**
     * Whether the pet is already owned or was previously owned.
     * <p>
     * This field relies upon collection log chat notifications.
     */
    @Nullable
    Boolean previouslyOwned;

    /**
     * The approximate drop rate of the pet.
     * <p>
     * This value is least accurate for skilling pets and raids.
     */
    @Nullable
    Double rarity;

    /**
     * The approximate number of actions performed that would roll a drop table containing the pet.
     * <p>
     * This value is least accurate for skilling pets and pets dropped by multiple NPCs.
     */
    @Nullable
    Integer estimatedActions;

    @Nullable
    transient Double luck;

    @Override
    public List<Field> getFields() {
        if (petName == null || petName.isEmpty())
            return super.getFields();

        List<Field> fields = new ArrayList<>(5);
        fields.add(new Field("Name", Field.formatBlock("", petName)));
        String status = getStatus();
        if (status != null)
            fields.add(new Field("Status", Field.formatBlock("", status)));
        if (milestone != null)
            fields.add(new Field("Milestone", Field.formatBlock("", milestone)));
        if (rarity != null)
            fields.add(new Field("Rarity", Field.formatProbability(rarity)));
        if (luck != null)
            fields.add(Field.ofLuck(luck));
        return fields;
    }

    private String getStatus() {
        if (duplicate) return "Already owned";
        if (previouslyOwned == null) return null;
        return previouslyOwned ? "Previously owned" : "New!";
    }
}

package dinkplugin.notifiers.data;

import com.google.gson.annotations.JsonAdapter;
import dinkplugin.message.Field;
import dinkplugin.util.DurationAdapter;
import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import lombok.experimental.Accessors;
import org.jetbrains.annotations.Nullable;

import java.time.Duration;
import java.util.Collection;
import java.util.List;

@With
@Value
@EqualsAndHashCode(callSuper = false)
public class BossNotificationData extends NotificationData {
    String boss;
    Integer count;
    String gameMessage;
    @JsonAdapter(DurationAdapter.class)
    Duration time;
    @Accessors(fluent = true)
    Boolean isPersonalBest;
    @Nullable
    @JsonAdapter(DurationAdapter.class)
    Duration personalBest;
    @Nullable
    Collection<String> party;

    @Override
    public List<Field> getFields() {
        if (party != null && !party.isEmpty()) {
            return List.of(new Field("Party Size", Field.formatBlock("", String.valueOf(party.size()))));
        }
        return super.getFields();
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.kit.KitType;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@Value
@EqualsAndHashCode(callSuper = false)
public class PlayerKillNotificationData extends NotificationData {

    String victimName;
    int victimCombatLevel;
    Map<KitType, SerializedItemStack> victimEquipment;
    @Nullable Integer world;
    @Nullable WorldPoint location;
    int myHitpoints;
    int myLastDamage;

    @Override
    public List<Field> getFields() {
        if (location == null)
            return super.getFields();

        List<Field> fields = new ArrayList<>(2);

        fields.add(
            new Field(
                "World",
                Field.formatBlock("", String.valueOf(world))
            )
        );

        fields.add(
            new Field(
                "Location",
                Field.formatBlock("",
                    String.format("X: %d, Y: %d, Plane: %d", location.getX(), location.getY(), location.getPlane())
                )
            )
        );

        return fields;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;

import java.util.List;
import java.util.Map;

@Value
@EqualsAndHashCode(callSuper = false)
public class ExternalNotificationData extends NotificationData {
    String sourcePlugin;
    @EqualsAndHashCode.Include
    transient List<Field> fields;
    Map<String, Object> metadata;
}

package dinkplugin.notifiers.data;

import dinkplugin.util.SerializedPet;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.Nullable;

import java.util.List;
import java.util.Map;

@Value
@EqualsAndHashCode(callSuper = false)
public class LoginNotificationData extends NotificationData {
    int world;

    @Nullable // requires QUEST_TAB==0; i.e., character summary is selected
    Progress collectionLog;
    Progress combatAchievementPoints;
    Progress achievementDiary;
    Progress achievementDiaryTasks;
    BarbarianAssault barbarianAssault;
    SkillData skills;
    Progress questCount;
    Progress questPoints;
    SlayerData slayer;
    @Nullable // requires Chat Commands plugin to be enabled
    List<SerializedPet> pets;

    @Value
    public static class SkillData {
        long totalExperience;
        int totalLevel;
        Map<String, Integer> levels;
        Map<String, Integer> experience;
    }

    @Value
    public static class BarbarianAssault {
        int highGambleCount;
    }

    @Value
    public static class SlayerData {
        int points;
        int streak;
    }
}

package dinkplugin.notifiers.data;

import dinkplugin.message.Field;
import lombok.EqualsAndHashCode;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.List;

@Value
@EqualsAndHashCode(callSuper = false)
public class QuestNotificationData extends NotificationData {

    @NotNull
    String questName;

    @Nullable
    Integer completedQuests;

    @Nullable
    Integer totalQuests;

    @Nullable
    Integer questPoints;

    @Nullable
    Integer totalQuestPoints;

    @Override
    public List<Field> getFields() {
        List<Field> fields = new ArrayList<>(2);

        if (completedQuests != null && totalQuests != null)
            fields.add(new Field("Completed Quests", Field.formatProgress(completedQuests, totalQuests)));

        if (questPoints != null && totalQuestPoints != null)
            fields.add(new Field("Quest Points", Field.formatProgress(questPoints, totalQuestPoints)));

        return fields;
    }
}

package dinkplugin.notifiers.data;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
@AllArgsConstructor
public class SerializedItemStack {
    private int id;
    private int quantity;
    private int priceEach;
    private String name;

    public long getTotalPrice() {
        return (long) priceEach * quantity;
    }
}

package dinkplugin.notifiers;

import dinkplugin.domain.AccountType;
import dinkplugin.domain.Danger;
import dinkplugin.domain.ExceptionalDeath;
import dinkplugin.message.Embed;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.notifiers.data.DeathNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.Region;
import dinkplugin.util.Utils;
import dinkplugin.util.WorldUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.ParamID;
import net.runelite.api.Player;
import net.runelite.api.Prayer;
import net.runelite.api.SkullIcon;
import net.runelite.api.Varbits;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.NPCManager;
import org.apache.commons.lang3.ArrayUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.BiPredicate;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class DeathNotifier extends BaseNotifier {

    private static final String ATTACK_OPTION = "Attack";

    private static final String TOA_DEATH_MSG = "You failed to survive the Tombs of Amascut";

    private static final String TOB_DEATH_MSG = "Your party has failed";

    private static final String FORTIS_DOOM_MSG = "You have been doomed!";

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bclientscript,tob_hud_portal%5D.cs2">CS2 Reference</a>
     */
    private static final int TOB_HUB_PORTAL_SCRIPT = 2307;

    /**
     * Checks whether the actor is alive and interacting with the specified player.
     */
    private static final BiPredicate<Player, Actor> INTERACTING;

    /**
     * Checks whether a NPC is a valid candidate to be our killer.
     */
    private static final Predicate<NPCComposition> NPC_VALID;

    /**
     * Orders NPCs by their likelihood of being our killer.
     */
    private static final BiFunction<NPCManager, Player, Comparator<NPC>> NPC_COMPARATOR;

    /**
     * Orders actors by their likelihood of being the killer of the specified player.
     */
    private static final Function<Player, Comparator<Player>> PK_COMPARATOR;

    /**
     * User-specified Region IDs where death notifications should not be triggered.
     */
    private final Collection<Integer> ignoredRegions = new HashSet<>();

    @Inject
    private ItemManager itemManager;

    @Inject
    private NPCManager npcManager;

    @Inject
    private ClientThread clientThread;

    /**
     * Tracks the last {@link Actor} our local player interacted with,
     * for the purposes of attributing deaths to particular {@link Player}'s.
     * <p>
     * Note: this is wrapped in a weak reference to allow garbage collection,
     * for example if the {@link Actor} despawns.
     * As a result, the underlying reference can be null.
     *
     * @see #identifyKiller()
     */
    private WeakReference<Actor> lastTarget = new WeakReference<>(null);

    @Override
    public boolean isEnabled() {
        return config.notifyDeath() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.deathWebhook();
    }

    public void init() {
        clientThread.invoke(() -> setIgnoredRegions(config.deathIgnoredRegions()));
    }

    public void reset() {
        clientThread.invoke(() -> setIgnoredRegions(null));
    }

    public void onConfigChanged(String key, String value) {
        if ("deathIgnoredRegions".equals(key)) {
            clientThread.invoke(() -> setIgnoredRegions(value));
        }
    }

    public void onActorDeath(ActorDeath actor) {
        boolean self = client.getLocalPlayer() == actor.getActor();

        if (self && isEnabled())
            handleNotify(null);

        if (self || actor.getActor() == lastTarget.get())
            lastTarget = new WeakReference<>(null);
    }

    public void onGameMessage(String message) {
        var player = client.getLocalPlayer();
        if (message.equals(FORTIS_DOOM_MSG) && player.getHealthRatio() > 0 && WorldUtils.getLocation(client, player).getRegionID() == WorldUtils.FORTIS_REGION && isEnabled()) {
            // https://github.com/pajlads/DinkPlugin/issues/472
            // Doom modifier can kill the player without health reaching zero, so ActorDeath isn't fired
            handleNotify(Danger.DANGEROUS);
            return;
        }

        if (shouldNotifyExceptionalDangerousDeath(ExceptionalDeath.TOA) && message.contains(TOA_DEATH_MSG)) {
            // https://github.com/pajlads/DinkPlugin/issues/316
            // though, hardcore (group) ironmen just use the normal ActorDeath trigger for TOA
            handleNotify(Danger.DANGEROUS);
        }
    }

    public void onScript(ScriptPreFired event) {
        if (event.getScriptId() == TOB_HUB_PORTAL_SCRIPT && event.getScriptEvent() != null &&
            shouldNotifyExceptionalDangerousDeath(ExceptionalDeath.TOB)) {
            Object[] args = event.getScriptEvent().getArguments();
            if (args != null && args.length > 1) {
                Object text = args[1];
                if (text instanceof String && ((String) text).contains(TOB_DEATH_MSG)) {
                    // https://oldschool.runescape.wiki/w/Theatre_of_Blood#Death_within_the_Theatre
                    handleNotify(Danger.DANGEROUS);
                }
            }
        }
    }

    public void onInteraction(InteractingChanged event) {
        if (event.getSource() == client.getLocalPlayer() && event.getTarget() != null && event.getTarget().getCombatLevel() > 0) {
            lastTarget = new WeakReference<>(event.getTarget());
        }
    }

    private void handleNotify(Danger dangerOverride) {
        int regionId = WorldUtils.getLocation(client).getRegionID();
        if (ignoredRegions.contains(regionId))
            return;

        Danger danger = dangerOverride != null ? dangerOverride : WorldUtils.getDangerLevel(client, regionId, config.deathSafeExceptions());
        if (danger == Danger.SAFE && config.deathIgnoreSafe())
            return;

        Collection<Item> items = ItemUtils.getItems(client);
        List<Pair<Item, Long>> itemsByPrice = getPricedItems(itemManager, items);

        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split;
        if (danger == Danger.DANGEROUS) {
            int keepCount = getKeepCount();
            split = splitItemsByKept(itemsByPrice, keepCount);
        } else {
            split = Pair.of(itemsByPrice, Collections.emptyList());
        }
        List<Pair<Item, Long>> keptItems = split.getLeft();
        List<Pair<Item, Long>> lostItems = split.getRight();

        long losePrice = lostItems.stream()
            .mapToLong(pair -> pair.getValue() * pair.getKey().getQuantity())
            .sum();

        int valueThreshold = config.deathMinValue();
        if (danger == Danger.DANGEROUS && losePrice < valueThreshold) {
            log.debug("Skipping death notification; total value of lost items {} is below minimum lost value {}", losePrice, valueThreshold);
            return;
        }

        Actor killer = identifyKiller();
        boolean pk = killer instanceof Player;
        boolean npc = killer instanceof NPC;
        String killerName = killer != null ? StringUtils.defaultIfEmpty(killer.getName(), "?") : null;
        Template notifyMessage = buildMessage(killerName, losePrice, pk, npc);

        List<SerializedItemStack> lostStacks = getStacks(itemManager, lostItems, true);
        List<SerializedItemStack> keptStacks = getStacks(itemManager, keptItems, false);
        List<Embed> keptItemEmbeds;
        if (config.deathEmbedKeptItems()) {
            keptItemEmbeds = ItemUtils.buildEmbeds(
                keptItems.stream()
                    .map(Pair::getKey)
                    .mapToInt(Item::getId)
                    .distinct()
                    .toArray()
            );
        } else {
            keptItemEmbeds = Collections.emptyList();
        }

        DeathNotificationData extra = new DeathNotificationData(
            losePrice,
            pk,
            pk ? killerName : null,
            killerName,
            npc ? ((NPC) killer).getId() : null,
            keptStacks,
            lostStacks,
            Region.of(client, regionId)
        );

        createMessage(config.deathSendImage(), NotificationBody.builder()
            .text(notifyMessage)
            .extra(extra)
            .embeds(keptItemEmbeds)
            .type(NotificationType.DEATH)
            .build());
    }

    private Template buildMessage(String killer, long losePrice, boolean pk, boolean npc) {
        boolean pvp = pk && config.deathNotifPvpEnabled();
        String template;
        if (pvp)
            template = config.deathNotifPvpMessage();
        else
            template = config.deathNotifyMessage();

        Template.TemplateBuilder builder = Template.builder()
            .template(template)
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%VALUELOST%", Replacements.ofText(String.valueOf(losePrice)));
        if (pvp) {
            builder.replacement("%PKER%", Replacements.ofText(killer));
        } else if (npc) {
            builder.replacement("%NPC%", Replacements.ofWiki(killer));
        }
        return builder.build();
    }

    private boolean shouldNotifyExceptionalDangerousDeath(ExceptionalDeath death) {
        if (!config.deathIgnoreSafe()) {
            // safe death notifications are enabled => we already notified
            return false;
        }

        if (config.deathSafeExceptions().contains(death)) {
            // safe deaths are ignored, but this death is exceptional => we already notified
            return false;
        }

        if (Utils.getAccountType(client).isHardcore() && death != ExceptionalDeath.FIGHT_CAVE) {
            // the PvM death is actually dangerous since hardcore => we already notified
            return false;
        }

        // notifier must be enabled to dink when the actually dangerous death occurs
        return isEnabled();
    }

    private void setIgnoredRegions(@Nullable String configValue) {
        ignoredRegions.clear();
        ConfigUtil.readDelimited(configValue).forEach(str -> {
            try {
                int regionId = Integer.parseInt(str);
                ignoredRegions.add(regionId);
            } catch (NumberFormatException e) {
                log.warn("Failed to parse death ignored region as integer: {}", str);
            }
        });
        log.debug("Updated ignored regions to: {}", ignoredRegions);
    }

    /**
     * @return the number of items the player would keep on an unsafe death
     */
    private int getKeepCount() {
        if (Utils.getAccountType(client) == AccountType.ULTIMATE_IRONMAN)
            return 0;

        var skull = client.getLocalPlayer().getSkullIcon();
        int keepCount = skull == SkullIcon.NONE ? 3 : 0;
        if (client.isPrayerActive(Prayer.PROTECT_ITEM))
            keepCount++;
        return keepCount;
    }

    /**
     * @return the inferred {@link Actor} who killed us, or null if not killed by an external source
     */
    @Nullable
    private Actor identifyKiller() {
        // must be in unsafe wildness or pvp world to be pk'd
        boolean pvpEnabled = !WorldUtils.isPvpSafeZone(client) &&
            (client.getVarbitValue(Varbits.IN_WILDERNESS) > 0 || WorldUtils.isPvpWorld(client.getWorldType()));

        Player localPlayer = client.getLocalPlayer();
        Predicate<Actor> interacting = a -> INTERACTING.test(localPlayer, a);

        // O(1) fast path based on last outbound interaction
        Actor lastTarget = this.lastTarget.get();
        if (checkLastInteraction(localPlayer, lastTarget, pvpEnabled))
            return lastTarget;

        // find another player interacting with us (that is preferably not a friend or clan member)
        if (pvpEnabled) {
            Optional<? extends Player> pker = client.getTopLevelWorldView().players().stream()
                .filter(interacting)
                .min(PK_COMPARATOR.apply(localPlayer)); // O(n)
            if (pker.isPresent())
                return pker.get();
        }

        // otherwise search through NPCs interacting with us
        return client.getTopLevelWorldView().npcs().stream()
            .filter(interacting)
            .filter(npc -> NPC_VALID.test(npc.getTransformedComposition()))
            .min(NPC_COMPARATOR.apply(npcManager, localPlayer)) // O(n)
            .orElse(null);
    }

    /**
     * @param localPlayer {@link net.runelite.api.Client#getLocalPlayer()}
     * @param actor       the {@link Actor} that is a candidate killer from {@link #lastTarget}
     * @param pvpEnabled  whether a player could be our killer (e.g., in wilderness)
     * @return whether the specified actor is the likely killer of the local player
     */
    private static boolean checkLastInteraction(Player localPlayer, Actor actor, boolean pvpEnabled) {
        if (!INTERACTING.test(localPlayer, actor))
            return false;

        if (actor instanceof Player) {
            Player other = (Player) actor;
            return pvpEnabled && !other.isClanMember() && !other.isFriend() && !other.isFriendsChatMember();
        }

        if (actor instanceof NPC) {
            NPCComposition npc = ((NPC) actor).getTransformedComposition();
            return NPC_VALID.test(npc) && ArrayUtils.contains(npc.getActions(), ATTACK_OPTION);
        }

        log.warn("Encountered unknown type of Actor; was neither Player nor NPC!");
        return false;
    }

    /**
     * @param itemManager {@link ItemManager}
     * @param items       the items whose prices should be queried
     * @return pairs of the passed items to their price, sorted by most expensive unit price first
     */
    @NotNull
    private static List<Pair<Item, Long>> getPricedItems(ItemManager itemManager, Collection<Item> items) {
        return items.stream()
            .map(item -> Pair.of(item, ItemUtils.getPrice(itemManager, item.getId())))
            .sorted(Comparator.<Pair<Item, Long>>comparingLong(Pair::getValue).reversed())
            .collect(Collectors.toList());
    }

    /**
     * Takes the complete list of items in the player's inventory and assigns them to separate lists,
     * depending on whether they would be kept or lost upon an unsafe death.
     *
     * @param itemsByPrice inventory items transformed by {@link #getPricedItems(ItemManager, Collection)}
     * @param keepCount    the number of items kept on death
     * @return the kept items on death (left) and lost items on death (right), in stable order, in separate lists
     */
    @NotNull
    @VisibleForTesting
    static Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> splitItemsByKept(List<Pair<Item, Long>> itemsByPrice, int keepCount) {
        final List<Pair<Item, Long>> keep = new ArrayList<>(keepCount);
        final List<Pair<Item, Long>> lost = new ArrayList<>(Math.max(itemsByPrice.size() - keepCount, 0));

        int kept = 0;
        for (Pair<Item, Long> item : itemsByPrice) {
            int id = item.getKey().getId();

            if (id == ItemID.OLD_SCHOOL_BOND || id == ItemID.OLD_SCHOOL_BOND_UNTRADEABLE) {
                // deliberately do not increment kept
                keep.add(item);
                continue;
            }

            boolean neverKept = ItemUtils.isItemNeverKeptOnDeath(id);
            for (int i = 0; i < item.getKey().getQuantity(); i++) {
                if (kept < keepCount && !neverKept) {
                    keep.add(Pair.of(new Item(id, 1), item.getValue()));
                    kept++;
                } else {
                    lost.add(Pair.of(new Item(id, item.getKey().getQuantity() - i), item.getValue()));
                    break;
                }
            }
        }

        return Pair.of(keep, lost);
    }

    /**
     * Converts {@code pricedItems} into {@link SerializedItemStack} with optional reduction
     * (to reflect the cumulative item quantity across inventory slots).
     *
     * @param itemManager {@link ItemManager}
     * @param pricedItems the items to be converted into {@link SerializedItemStack}
     * @param reduce      whether multiple stacks of the same item should be aggregated to a single stack
     * @return the (optionally reduced) {@link SerializedItemStack}'s associated with {@code pricedItems}
     */
    @NotNull
    private static List<SerializedItemStack> getStacks(ItemManager itemManager, List<Pair<Item, Long>> pricedItems, boolean reduce) {
        Collection<Item> items = pricedItems.stream().map(Pair::getLeft).collect(Collectors.toList());
        if (reduce) {
            items = ItemUtils.reduceItems(items).values();
        }
        return items.stream()
            .map(item -> ItemUtils.stackFromItem(itemManager, item))
            .collect(Collectors.toList());
    }

    static {
        INTERACTING = (localPlayer, a) -> a != null && !a.isDead() && a.getInteracting() == localPlayer;

        NPC_VALID = comp -> comp != null && comp.isInteractible() && !comp.isFollower() && comp.getCombatLevel() > 0;

        NPC_COMPARATOR = (npcManager, localPlayer) -> Comparator
            .comparing(
                NPC::getTransformedComposition,
                Comparator.nullsFirst(
                    Comparator
                        .comparing(
                            (NPCComposition comp) -> comp.getStringValue(ParamID.NPC_HP_NAME),
                            Comparator.comparing(StringUtils::isNotEmpty) // prefer has name in hit points UI
                        )
                        .thenComparing(comp -> ArrayUtils.contains(comp.getActions(), ATTACK_OPTION)) // prefer explicitly attackable
                        .thenComparingInt(NPCComposition::getCombatLevel) // prefer high level
                        .thenComparingInt(NPCComposition::getSize) // prefer large
                        .thenComparing(NPCComposition::isMinimapVisible) // prefer visible on minimap
                        .thenComparing(
                            // prefer high max health
                            comp -> npcManager.getHealth(comp.getId()),
                            Comparator.nullsFirst(Comparator.naturalOrder())
                        )
                )
            )
            .thenComparingInt(p -> -localPlayer.getLocalLocation().distanceTo(p.getLocalLocation())) // prefer nearby
            .reversed(); // for consistency with PK_COMPARATOR such that Stream#min should be used in #identifyKiller

        PK_COMPARATOR = localPlayer -> Comparator
            .comparing(Player::isClanMember) // prefer not in clan
            .thenComparing(Player::isFriend) // prefer not friend
            .thenComparing(Player::isFriendsChatMember) // prefer not fc
            .thenComparingInt(p -> Math.abs(localPlayer.getCombatLevel() - p.getCombatLevel())) // prefer similar level
            .thenComparingInt(p -> -p.getCombatLevel()) // prefer higher level for a given absolute level gap
            .thenComparing(p -> p.getOverheadIcon() == null) // prefer praying
            .thenComparing(p -> p.getTeam() == localPlayer.getTeam()) // prefer different team cape
            .thenComparingInt(p -> localPlayer.getLocalLocation().distanceTo(p.getLocalLocation())); // prefer nearby
    }
}

package dinkplugin.notifiers;

import dinkplugin.domain.LootCriteria;
import dinkplugin.message.Embed;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Evaluable;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.templating.impl.JoiningReplacement;
import dinkplugin.notifiers.data.AnnotatedItemStack;
import dinkplugin.notifiers.data.LootNotificationData;
import dinkplugin.notifiers.data.RareItemStack;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.KillCountService;
import dinkplugin.util.MathUtils;
import dinkplugin.util.ThievingService;
import dinkplugin.util.RarityService;
import dinkplugin.util.Utils;
import dinkplugin.util.WorldUtils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collection;
import java.util.EnumSet;
import java.util.List;
import java.util.OptionalDouble;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class LootNotifier extends BaseNotifier {

    @Inject
    private ItemManager itemManager;

    @Inject
    private KillCountService killCountService;

    @Inject
    private RarityService rarityService;

    @Inject
    private ThievingService thievingService;

    private final Collection<Pattern> itemNameAllowlist = new CopyOnWriteArrayList<>();
    private final Collection<Pattern> itemNameDenylist = new CopyOnWriteArrayList<>();

    @Override
    public boolean isEnabled() {
        return config.notifyLoot() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.lootWebhook();
    }

    public void init() {
        itemNameAllowlist.clear();
        itemNameAllowlist.addAll(
            ConfigUtil.readDelimited(config.lootItemAllowlist())
                .map(Utils::regexify)
                .collect(Collectors.toList())
        );

        itemNameDenylist.clear();
        itemNameDenylist.addAll(
            ConfigUtil.readDelimited(config.lootItemDenylist())
                .map(Utils::regexify)
                .collect(Collectors.toList())
        );
    }

    public void onConfigChanged(String key, String value) {
        Collection<Pattern> itemNames;
        if ("lootItemAllowlist".equals(key)) {
            itemNames = itemNameAllowlist;
        } else if ("lootItemDenylist".equals(key)) {
            itemNames = itemNameDenylist;
        } else {
            return;
        }

        itemNames.clear();
        itemNames.addAll(
            ConfigUtil.readDelimited(value)
                .map(Utils::regexify)
                .collect(Collectors.toList())
        );
    }

    public void onNpcLootReceived(NpcLootReceived event) {
        if (!isEnabled()) return;

        NPC npc = event.getNpc();
        int id = npc.getId();
        if (KillCountService.SPECIAL_LOOT_NPC_IDS.contains(id)) {
            // LootReceived is fired for certain NPCs rather than NpcLootReceived, but return here just in case upstream changes their implementation.
            return;
        }

        this.handleNotify(event.getItems(), npc.getName(), LootRecordType.NPC, id);
    }

    public void onPlayerLootReceived(PlayerLootReceived event) {
        if (WorldUtils.isSafeArea(client))
            return;

        if (config.includePlayerLoot() && isEnabled())
            this.handleNotify(event.getItems(), event.getPlayer().getName(), LootRecordType.PLAYER, null);
    }

    public void onLootReceived(LootReceived lootReceived) {
        if (!isEnabled()) return;

        // only consider non-NPC and non-PK loot
        if (lootReceived.getType() == LootRecordType.EVENT || lootReceived.getType() == LootRecordType.PICKPOCKET) {
            if ("Barbarian Assault high gamble".equals(lootReceived.getName()) && !config.lootIncludeGambles()) {
                // skip ba gambles, depending on config (since we have GambleNotifier)
                return;
            }

            if (!config.lootIncludeClueScrolls() && StringUtils.startsWithIgnoreCase(lootReceived.getName(), "Clue Scroll")) {
                // skip clue scroll loot, depending on config
                return;
            }

            String source = killCountService.getStandardizedSource(lootReceived);
            this.handleNotify(lootReceived.getItems(), source, lootReceived.getType(), null);
        } else if (lootReceived.getType() == LootRecordType.NPC && KillCountService.SPECIAL_LOOT_NPC_NAMES.contains(lootReceived.getName())) {
            // Special case: upstream fires LootReceived for certain NPCs, but not NpcLootReceived
            this.handleNotify(lootReceived.getItems(), lootReceived.getName(), lootReceived.getType(), null);
        }
    }

    private void handleNotify(Collection<ItemStack> items, String dropper, LootRecordType type, Integer npcId) {
        final Integer kc = killCountService.getKillCount(type, dropper);
        final int minValue = config.minLootValue();
        final boolean icons = config.lootIcons();

        Collection<ItemStack> reduced = ItemUtils.reduceItemStack(items);
        List<SerializedItemStack> serializedItems = new ArrayList<>(reduced.size());
        List<Embed> embeds = new ArrayList<>(icons ? reduced.size() : 0);

        JoiningReplacement.JoiningReplacementBuilder lootMessage = JoiningReplacement.builder().delimiter("\n");
        long totalStackValue = 0;
        boolean sendMessage = false;
        SerializedItemStack max = null;
        RareItemStack rarest = null;

        final double rarityThreshold = config.lootRarityThreshold() > 0 ? 1.0 / config.lootRarityThreshold() : Double.NaN;
        final boolean intersection = config.lootRarityValueIntersection() && Double.isFinite(rarityThreshold);
        for (ItemStack item : reduced) {
            SerializedItemStack stack = ItemUtils.stackFromItem(itemManager, item.getId(), item.getQuantity());
            long totalPrice = stack.getTotalPrice();

            OptionalDouble rarity;
            if (type == LootRecordType.NPC) {
                rarity = rarityService.getRarity(dropper, item.getId(), item.getQuantity());
            } else if (type == LootRecordType.PICKPOCKET) {
                rarity = thievingService.getRarity(dropper, item.getId(), item.getQuantity());
            } else {
                rarity = OptionalDouble.empty();
            }

            boolean shouldSend;
            var criteria = EnumSet.noneOf(LootCriteria.class);
            if (totalPrice >= minValue) {
                criteria.add(LootCriteria.VALUE);
            }
            if (MathUtils.lessThanOrEqual(rarity.orElse(1), rarityThreshold)) {
                criteria.add(LootCriteria.RARITY);
            }
            if (intersection) {
                shouldSend = criteria.contains(LootCriteria.VALUE) && (rarity.isEmpty() || criteria.contains(LootCriteria.RARITY));
            } else {
                shouldSend = criteria.contains(LootCriteria.VALUE) || criteria.contains(LootCriteria.RARITY);
            }

            boolean denied = matches(itemNameDenylist, stack.getName());
            if (denied) {
                shouldSend = false;
                criteria.add(LootCriteria.DENYLIST);
            } else {
                if (matches(itemNameAllowlist, stack.getName())) {
                    shouldSend = true;
                    criteria.add(LootCriteria.ALLOWLIST);
                }
                if (max == null || totalPrice > max.getTotalPrice()) {
                    max = stack;
                }
            }

            if (shouldSend) {
                sendMessage = true;
                lootMessage.component(ItemUtils.templateStack(stack, true));
                if (icons) embeds.add(Embed.ofImage(ItemUtils.getItemImageUrl(item.getId())));
            }

            var annotated = AnnotatedItemStack.of(stack, criteria);
            if (rarity.isPresent()) {
                RareItemStack rareStack = RareItemStack.of(annotated, rarity.getAsDouble());
                serializedItems.add(rareStack);
                if (!denied && (rarest == null || rareStack.getRarity() < rarest.getRarity())) {
                    rarest = rareStack;
                }
            } else {
                serializedItems.add(annotated);
            }
            totalStackValue += totalPrice;
        }

        Evaluable lootMsg;
        if (!sendMessage) {
            if (totalStackValue >= minValue && max != null && "Loot Chest".equalsIgnoreCase(dropper)) {
                // Special case: PK loot keys should trigger notification if total value exceeds configured minimum even
                // if no single item itself would exceed the min value config - github.com/pajlads/DinkPlugin/issues/403
                sendMessage = true;
                lootMsg = Replacements.ofMultiple(" ",
                    Replacements.ofText("Various items including:"),
                    ItemUtils.templateStack(max, true)
                );
            } else {
                lootMsg = null;
            }
        } else {
            lootMsg = lootMessage.build();
        }

        if (sendMessage) {
            if (npcId == null && (type == LootRecordType.NPC || type == LootRecordType.PICKPOCKET)) {
                npcId = client.getTopLevelWorldView().npcs().stream()
                    .filter(npc -> dropper.equals(npc.getName()))
                    .findAny()
                    .map(NPC::getId)
                    .orElse(null);
            }

            String overrideUrl = getWebhookUrl();
            if (config.lootRedirectPlayerKill() && !config.pkWebhook().isBlank()) {
                if (type == LootRecordType.PLAYER || (type == LootRecordType.EVENT && "Loot Chest".equals(dropper))) {
                    overrideUrl = config.pkWebhook();
                }
            }
            Double rarity = rarest != null ? rarest.getRarity() : null;
            boolean screenshot = config.lootSendImage() && totalStackValue >= config.lootImageMinValue();
            Collection<String> party = type == LootRecordType.EVENT ? Utils.getBossParty(client, dropper) : null;
            Evaluable source = type == LootRecordType.PLAYER
                ? Replacements.ofLink(dropper, config.playerLookupService().getPlayerUrl(dropper))
                : Replacements.ofWiki(dropper);
            Template notifyMessage = Template.builder()
                .template(config.lootNotifyMessage())
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
                .replacement("%LOOT%", lootMsg)
                .replacement("%TOTAL_VALUE%", Replacements.ofText(QuantityFormatter.quantityToStackSize(totalStackValue)))
                .replacement("%SOURCE%", source)
                .build();
            createMessage(overrideUrl, screenshot,
                NotificationBody.builder()
                    .text(notifyMessage)
                    .embeds(embeds)
                    .extra(new LootNotificationData(serializedItems, dropper, type, kc, rarity, party, npcId))
                    .type(NotificationType.LOOT)
                    .thumbnailUrl(ItemUtils.getItemImageUrl(max.getId()))
                    .build()
            );
        }
    }

    private static boolean matches(Collection<Pattern> regexps, String input) {
        for (Pattern regex : regexps) {
            if (regex.matcher(input).find())
                return true;
        }
        return false;
    }

}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.util.QuestUtils;
import dinkplugin.util.Utils;
import dinkplugin.notifiers.data.QuestNotificationData;
import net.runelite.api.VarPlayer;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;

public class QuestNotifier extends BaseNotifier {

    /*
     * https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,questlist_completed%5D.cs2#L5
     */
    @Varbit
    public static final int COMPLETED_ID = 6347, TOTAL_ID = 11877;

    /*
     * https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,questlist_qp%5D.cs2#L5
     */
    @Varbit
    @VisibleForTesting
    static final int QP_TOTAL_ID = 1782;

    @Inject
    private ClientThread clientThread;

    @Override
    public boolean isEnabled() {
        return config.notifyQuest() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.questWebhook();
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.QUEST_COMPLETED && isEnabled()) {
            Widget quest = client.getWidget(ComponentID.QUEST_COMPLETED_NAME_TEXT);
            if (quest != null) {
                String questText = quest.getText();
                // 1 tick delay to ensure relevant varbits have been processed by the client
                clientThread.invokeLater(() -> handleNotify(questText));
            }
        }
    }

    private void handleNotify(String questText) {
        int completedQuests = client.getVarbitValue(COMPLETED_ID);
        int totalQuests = client.getVarbitValue(TOTAL_ID);
        boolean validQuests = completedQuests > 0 && totalQuests > 0;

        int questPoints = client.getVarpValue(VarPlayer.QUEST_POINTS);
        int totalQuestPoints = client.getVarbitValue(QP_TOTAL_ID);
        boolean validPoints = questPoints > 0 && totalQuestPoints > 0;

        String parsed = QuestUtils.parseQuestWidget(questText);
        if (parsed == null) return;

        Template notifyMessage = Template.builder()
            .template(config.questNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%QUEST%", Replacements.ofWiki(parsed))
            .build();

        QuestNotificationData extra = new QuestNotificationData(
            parsed,
            validQuests ? completedQuests : null,
            validQuests ? totalQuests : null,
            validPoints ? questPoints : null,
            validPoints ? totalQuestPoints : null
        );

        createMessage(config.questSendImage(), NotificationBody.builder()
            .text(notifyMessage)
            .extra(extra)
            .type(NotificationType.QUEST)
            .build());
    }
}

package dinkplugin.notifiers;

import com.google.common.collect.ImmutableSet;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Evaluable;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.templating.impl.JoiningReplacement;
import dinkplugin.notifiers.data.GambleNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemSearcher;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.Utils;
import lombok.NonNull;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import java.util.Collection;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;

@Slf4j
public class GambleNotifier extends BaseNotifier {
    // itemName (x quantity)![ tertiaryReward!] gc: n
    private static final Pattern GAMBLE_REGEX = Pattern.compile("^(.+?)!\\s*(.+!)?\\s+High level gamble count: (\\d+).*");
    private static final Pattern ITEM_QUANTITY_REGEX = Pattern.compile("^(.+?)\\(x (\\d+)\\)$");
    // penance pet is not actually present in dialog message, but it's here in case it's ever added
    private static final Collection<String> RARE_LOOT = ImmutableSet.of("dragon chainbody", "dragon med helm", "pet penance queen");

    @Inject
    private ItemSearcher itemSearcher;

    @Inject
    private ItemManager itemManager;

    @Override
    public boolean isEnabled() {
        return config.notifyGamble() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.gambleWebhook();
    }

    public void onMesBoxNotification(String message) {
        if (!isEnabled()) return;
        ParsedData data = parse(message);
        if (data != null) {
            handleNotify(data);
        }
    }

    private void handleNotify(ParsedData data) {
        String messageFormat;
        if (config.gambleRareLoot() && RARE_LOOT.contains(data.itemName.toLowerCase())) {
            messageFormat = config.gambleRareNotifyMessage();
        } else if (data.gambleCount % config.gambleInterval() == 0) {
            messageFormat = config.gambleNotifyMessage();
        } else {
            return;
        }
        String player = Utils.getPlayerName(client);
        List<SerializedItemStack> items = serializeItems(data);
        Template message = Template.builder()
            .template(messageFormat)
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(player))
            .replacement("%COUNT%", Replacements.ofText(String.valueOf(data.gambleCount)))
            .replacement("%LOOT%", lootSummary(items))
            .build();
        createMessage(config.gambleSendImage(), NotificationBody.builder()
            .text(message)
            .extra(new GambleNotificationData(data.gambleCount, items))
            .type(NotificationType.BARBARIAN_ASSAULT_GAMBLE)
            .build());
    }

    private static Evaluable lootSummary(List<SerializedItemStack> items) {
        JoiningReplacement.JoiningReplacementBuilder builder = JoiningReplacement.builder().delimiter("\n");
        items.forEach(item -> builder.component(ItemUtils.templateStack(item, true)));
        return builder.build();
    }

    private List<SerializedItemStack> serializeItems(ParsedData data) {
        return Stream.of(Pair.of(data.itemName, data.itemQuantity), Pair.of(data.tertiaryItem, 1))
            .filter(p -> p.getLeft() != null)
            .map(p -> Pair.of(itemSearcher.findItemId(p.getLeft()), p.getRight()))
            .filter(p -> p.getLeft() != null)
            .map(p -> ItemUtils.stackFromItem(itemManager, p.getLeft(), p.getRight()))
            .collect(Collectors.toList());
    }

    @Nullable
    @VisibleForTesting
    static ParsedData parse(String message) {
        Matcher matcher = GAMBLE_REGEX.matcher(message);
        if (!matcher.matches()) return null;
        String rawItem = matcher.group(1).trim();
        String itemName = rawItem;
        int itemQuantity = 1;
        Matcher quantityMatcher = ITEM_QUANTITY_REGEX.matcher(rawItem);
        if (quantityMatcher.matches()) {
            itemName = quantityMatcher.group(1).trim();
            itemQuantity = Integer.parseInt(quantityMatcher.group(2));
        }
        String tertiary = matcher.group(2);
        if (tertiary != null) {
            tertiary = StringUtils.removeEnd(tertiary, "!").trim();
        }
        int gambleCount = Integer.parseInt(matcher.group(3));
        return new ParsedData(itemName, itemQuantity, tertiary, gambleCount);
    }

    @Value
    @VisibleForTesting
    static class ParsedData {
        @NonNull
        String itemName;
        int itemQuantity;
        // https://oldschool.runescape.wiki/w/Barbarian_Assault/Rewards#Tertiary_High_Gamble_Rewards
        @Nullable
        String tertiaryItem;
        int gambleCount;
    }
}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.PetNotificationData;
import dinkplugin.util.ItemSearcher;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.KillCountService;
import dinkplugin.util.MathUtils;
import dinkplugin.util.SerializedLoot;
import dinkplugin.util.Utils;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Setter;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.IntToDoubleFunction;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import static dinkplugin.notifiers.CollectionNotifier.COLLECTION_LOG_REGEX;
import static java.util.Map.entry;

@Singleton
public class PetNotifier extends BaseNotifier {

    @Varbit
    public static final int LOOT_DROP_NOTIFICATIONS = 5399;

    @Varbit
    public static final int UNTRADEABLE_LOOT_DROPS = 5402;

    public static final String UNTRADEABLE_WARNING = "Pet Notifier cannot reliably identify pet names unless you enable the game setting: Untradeable loot notifications";

    @VisibleForTesting
    static final Pattern PET_REGEX = Pattern.compile("You (?:have a funny feeling like you|feel something weird sneaking).*");

    @VisibleForTesting
    static final Pattern CLAN_REGEX = Pattern.compile("\\b(?<user>[\\w\\s]+) (?:has a funny feeling like .+ followed|feels something weird sneaking into .+ backpack): (?<pet>.+) at (?<milestone>.+)");

    private static final Pattern UNTRADEABLE_REGEX = Pattern.compile("Untradeable drop: (.+)");
    private static final Map<String, Source> PET_NAMES_TO_SOURCE;
    private static final String PRIMED_NAME = "";

    /**
     * The maximum number ticks to wait for {@link #milestone} to be populated,
     * before firing notification with only the {@link #petName}.
     *
     * @see #ticksWaited
     */
    @VisibleForTesting
    static final int MAX_TICKS_WAIT = 5;

    /**
     * Tracks the number of ticks that occur where {@link #milestone} is not populated
     * while {@link #petName} <i>is</i> populated.
     *
     * @see #onTick()
     */
    private final AtomicInteger ticksWaited = new AtomicInteger();

    @Inject
    private ItemSearcher itemSearcher;

    @Inject
    private KillCountService killCountService;

    @Setter(AccessLevel.PRIVATE)
    private volatile String petName = null;

    private volatile String milestone = null;

    private volatile boolean duplicate = false;

    private volatile boolean backpack = false;

    private volatile boolean collection = false;

    @Override
    public boolean isEnabled() {
        return config.notifyPet() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.petWebhook();
    }

    public void onChatMessage(String chatMessage) {
        if (isEnabled()) {
            if (petName == null) {
                if (PET_REGEX.matcher(chatMessage).matches()) {
                    // Prime the notifier to trigger next tick
                    this.petName = PRIMED_NAME;
                    this.duplicate = chatMessage.contains("would have been");
                    this.backpack = chatMessage.contains(" backpack");
                }
            } else if (PRIMED_NAME.equals(petName) || !collection) {
                parseItemFromGameMessage(chatMessage)
                    .filter(item -> item.getItemName().startsWith("Pet ") || PET_NAMES_TO_SOURCE.containsKey(Utils.ucFirst(item.getItemName())))
                    .ifPresent(parseResult -> {
                        setPetName(parseResult.getItemName());
                        if (parseResult.isCollectionLog()) {
                            this.collection = true;
                        }
                    });
            } else {
                // ignore; we already know the pet name
            }
        }
    }

    public void onClanNotification(String message) {
        if (petName == null) {
            // We have not received the normal message about a pet drop, so this clan message cannot be relevant to us
            return;
        }

        Matcher matcher = CLAN_REGEX.matcher(message);
        if (matcher.find()) {
            String user = matcher.group("user").trim();
            if (user.equals(Utils.getPlayerName(client))) {
                this.petName = matcher.group("pet");
                this.milestone = StringUtils.removeEnd(matcher.group("milestone"), ".");
            }
        }
    }

    public void onTick() {
        if (petName == null)
            return;

        if (milestone != null || ticksWaited.incrementAndGet() > MAX_TICKS_WAIT) {
            // ensure notifier was not disabled during wait ticks
            if (isEnabled()) {
                this.handleNotify();
            }
            this.reset();
        }
    }

    public void reset() {
        this.petName = null;
        this.milestone = null;
        this.duplicate = false;
        this.backpack = false;
        this.collection = false;
        this.ticksWaited.set(0);
    }

    private void handleNotify() {
        Boolean previouslyOwned;
        if (duplicate) {
            previouslyOwned = true;
        } else if (client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) % 2 == 1) {
            // when collection log chat notification is enabled, presence or absence of notification indicates ownership history
            previouslyOwned = !collection;
        } else {
            previouslyOwned = null;
        }

        String gameMessage;
        if (backpack) {
            gameMessage = "feels something weird sneaking into their backpack";
        } else if (previouslyOwned != null && previouslyOwned) {
            gameMessage = "has a funny feeling like they would have been followed...";
        } else {
            gameMessage = "has a funny feeling like they're being followed";
        }

        Template notifyMessage = Template.builder()
            .template(config.petNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%GAME_MESSAGE%", Replacements.ofText(gameMessage))
            .build();

        String pet = petName != null ? Utils.ucFirst(petName) : null;
        String thumbnail = Optional.ofNullable(pet)
            .filter(s -> !s.isEmpty())
            .map(itemSearcher::findItemId)
            .map(ItemUtils::getItemImageUrl)
            .orElse(null);

        Source source = petName != null ? PET_NAMES_TO_SOURCE.get(pet) : null;
        Double rarity = source != null ? source.getProbability(client, killCountService) : null;
        Integer actions = rarity != null ? source.estimateActions(client, killCountService) : null;
        Double luck = actions != null && (previouslyOwned == null || !previouslyOwned)
            ? source.calculateLuck(client, killCountService, rarity, actions) : null;

        PetNotificationData extra = new PetNotificationData(StringUtils.defaultIfEmpty(petName, null), milestone, duplicate, previouslyOwned, rarity, actions, luck);

        createMessage(config.petSendImage(), NotificationBody.builder()
            .extra(extra)
            .text(notifyMessage)
            .thumbnailUrl(thumbnail)
            .type(NotificationType.PET)
            .build());
    }

    private static Optional<ParseResult> parseItemFromGameMessage(String message) {
        Matcher untradeableMatcher = UNTRADEABLE_REGEX.matcher(message);
        if (untradeableMatcher.find()) {
            return Optional.of(new ParseResult(untradeableMatcher.group(1), false));
        }

        Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(message);
        if (collectionMatcher.find()) {
            return Optional.of(new ParseResult(collectionMatcher.group("itemName"), true));
        }

        return Optional.empty();
    }

    @Value
    private static class ParseResult {
        String itemName;
        boolean collectionLog;
    }

    private static abstract class Source {
        abstract Double getProbability(Client client, KillCountService kcService);

        abstract Integer estimateActions(Client client, KillCountService kcService);

        Double calculateLuck(Client client, KillCountService kcService, double probability, int killCount) {
            return MathUtils.cumulativeGeometric(probability, killCount);
        }
    }

    private static abstract class MultiSource extends Source {
        abstract double[] getRates(Client client);

        abstract int[] getActions(Client client, KillCountService kcService);

        @Override
        Integer estimateActions(Client client, KillCountService kcService) {
            int sum = MathUtils.sum(getActions(client, kcService));
            return sum > 0 ? sum : null;
        }

        @Override
        Double getProbability(Client client, KillCountService kcService) {
            final int[] actions = getActions(client, kcService);
            final int totalActions = MathUtils.sum(actions);
            if (totalActions <= 0) return null;

            final double[] rates = getRates(client);
            double weighted = 0;
            for (int i = 0, n = actions.length; i < n; i++) {
                weighted += rates[i] * actions[i] / totalActions;
            }
            return weighted;
        }

        @Override
        Double calculateLuck(Client client, KillCountService kcService, double probability, int killCount) {
            final int[] actions = getActions(client, kcService);
            final double[] rates = getRates(client);
            double p = 1;
            for (int i = 0, n = actions.length; i < n; i++) {
                p *= Math.pow(1 - rates[i], actions[i]); // similar to geometric distribution survival function
            }
            return 1 - p;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = true)
    private static class SkillSource extends MultiSource {
        Skill skill;
        int baseChance;
        int actionXp;

        @Override
        double[] getRates(Client client) {
            final int n = Experience.MAX_REAL_LEVEL;
            double[] rates = new double[n];
            for (int level = 1; level <= n; level++) {
                rates[level - 1] = 1.0 / (baseChance - 25 * level);
            }
            return rates;
        }

        @Override
        int[] getActions(Client client, KillCountService kcService) {
            final int currentLevel = client.getRealSkillLevel(skill);
            final int currentXp = client.getSkillExperience(skill);
            final int[] actions = new int[currentLevel];
            int prevXp = 0;
            for (int lvl = 1; lvl <= currentLevel; lvl++) {
                int xp = Math.min(Experience.getXpForLevel(lvl + 1), currentXp);
                int deltaXp = xp - prevXp;
                prevXp = xp;
                actions[lvl - 1] = Math.round(1f * deltaXp / actionXp);
            }
            return actions;
        }

        @Override
        Integer estimateActions(Client client, KillCountService kcService) {
            return client.getSkillExperience(skill) / actionXp;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = true)
    private static class KcSource extends Source {
        String name;
        Double probability;

        @Override
        Double getProbability(Client client, KillCountService kcService) {
            return this.probability;
        }

        @Override
        Integer estimateActions(Client client, KillCountService kcService) {
            Integer kc = kcService.getKillCount(LootRecordType.UNKNOWN, name);
            return kc != null && kc > 0 ? kc : null;
        }
    }

    @Value
    @EqualsAndHashCode(callSuper = false)
    private static class MultiKcSource extends MultiSource {
        String[] names;
        double[] rates;

        public MultiKcSource(String source1, double prob1, String source2, double prob2) {
            this.names = new String[] { source1, source2 };
            this.rates = new double[] { prob1, prob2 };
        }

        @Override
        int[] getActions(Client client, KillCountService kcService) {
            final int n = names.length;
            int[] actions = new int[n];
            for (int i = 0; i < n; i++) {
                Integer kc = kcService.getKillCount(LootRecordType.UNKNOWN, names[i]);
                if (kc == null) continue;
                actions[i] = kc;
            }
            return actions;
        }

        @Override
        double[] getRates(Client client) {
            return this.rates;
        }
    }

    static {
        PET_NAMES_TO_SOURCE = Map.<String, Source>ofEntries(
            entry("Abyssal orphan", new KcSource("Abyssal Sire", 1.0 / 2_560)),
            entry("Abyssal protector", new Source() {
                @Override
                Double getProbability(Client client, KillCountService kcService) {
                    return 1.0 / 4_000;
                }

                @Override
                Integer estimateActions(Client client, KillCountService kcService) {
                    Integer kc = kcService.getKillCount(LootRecordType.EVENT, "Guardians of the Rift");
                    return kc != null && kc > 0 ? kc * 3 : null;
                }
            }),
            entry("Baby chinchompa", new SkillSource(Skill.HUNTER, 82_758, 315)), // black chinchompas
            entry("Baby mole", new KcSource("Giant Mole", 1.0 / 3_000)),
            entry("Baron", new KcSource("Duke Sucellus", 1.0 / 2_500)),
            entry("Bran", new KcSource("Royal Titans", null)), // unknown drop rate
            entry("Butch", new KcSource("Vardorvis", 1.0 / 3_000)),
            entry("Beaver", new SkillSource(Skill.WOODCUTTING, 264_336, 85)), // teaks
            entry("Bloodhound", new KcSource("Clue Scroll (master)", 1.0 / 1_000)),
            entry("Callisto cub", new MultiKcSource("Callisto", 1.0 / 1_500, "Artio", 1.0 / 2_800)),
            entry("Chompy chick", new KcSource("Chompy bird", 1.0 / 500)),
            entry("Giant squirrel", new MultiSource() {
                private final Map<String, Integer> courses = Map.ofEntries(
                    entry("Gnome Stronghold Agility", 35_609),
                    entry("Shayzien Agility Course", 31_804),
                    entry("Shayzien Advanced Agility Course", 29_738),
                    entry("Agility Pyramid", 9_901),
                    entry("Penguin Agility", 9_779),
                    entry("Barbarian Outpost", 44_376),
                    entry("Agility Arena", 26_404),
                    entry("Ape Atoll Agility", 37_720),
                    entry("Wilderness Agility", 34_666),
                    entry("Werewolf Agility", 32_597),
                    entry("Dorgesh-Kaan Agility Course", 10_561),
                    entry("Prifddinas Agility Course", 25_146),
                    entry("Draynor Village Rooftop", 33_005),
                    entry("Al Kharid Rooftop", 26_648),
                    entry("Varrock Rooftop", 24_410),
                    entry("Canifis Rooftop", 36_842),
                    entry("Falador Rooftop", 26_806),
                    entry("Seers' Village Rooftop", 35_205),
                    entry("Pollnivneach Rooftop", 33_422),
                    entry("Rellekka Rooftop", 31_063),
                    entry("Ardougne Rooftop", 34_440),
                    entry("Hallowed Sepulchre Floor 1", 35_000),
                    entry("Hallowed Sepulchre Floor 2", 16_000),
                    entry("Hallowed Sepulchre Floor 3", 8_000),
                    entry("Hallowed Sepulchre Floor 4", 4_000),
                    entry("Hallowed Sepulchre Floor 5", 2_000)
                );

                @Override
                public int[] getActions(Client client, KillCountService kcService) {
                    return courses.keySet()
                        .stream()
                        .mapToInt(course -> {
                            Integer count = kcService.getKillCount(LootRecordType.UNKNOWN, course);
                            return count != null && count > 0 ? count + 1 : 0;
                        })
                        .toArray();
                }

                @Override
                public double[] getRates(Client client) {
                    int level = client.getRealSkillLevel(Skill.AGILITY);
                    IntToDoubleFunction calc = base -> 1.0 / (base - level * 25); // see SkillSource
                    return courses.entrySet()
                        .stream()
                        .mapToDouble(entry -> {
                            if (entry.getKey().startsWith("Hallowed"))
                                return 1.0 / entry.getValue();
                            return calc.applyAsDouble(entry.getValue());
                        })
                        .toArray();
                }
            }),
            entry("Hellpuppy", new KcSource("Cerberus", 1.0 / 3_000)),
            entry("Herbi", new KcSource("Herbiboar", 1.0 / 6_500)),
            entry("Heron", new SkillSource(Skill.FISHING, 257_770, 100)), // swordfish
            entry("Ikkle hydra", new KcSource("Alchemical Hydra", 1.0 / 3_000)),
            entry("Jal-nib-rek", new KcSource("TzKal-Zuk", 1.0 / 100)),
            entry("Kalphite princess", new KcSource("Kalphite Queen", 1.0 / 3_000)),
            entry("Lil' creator", new KcSource("Spoils of war", 1.0 / 400)),
            entry("Lil' zik", new KcSource(" Theatre of Blood", 1.0 / 650)), // assume normal mode
            entry("Lil'viathan", new KcSource("The Leviathan", 1.0 / 2_500)),
            entry("Little nightmare", new KcSource("Nightmare", 1.0 / 3_200)), // assume team size 4
            entry("Moxi", new KcSource("Amoxliatl", 1.0 / 3_000)),
            entry("Muphin", new KcSource("Phantom Muspah", 1.0 / 2_500)),
            entry("Nexling", new KcSource("Nex", 1.0 / 500)),
            entry("Nid", new KcSource("Araxxor", 1.0 / 3000)),
            entry("Noon", new KcSource("Grotesque Guardians", 1.0 / 3_000)),
            entry("Olmlet", new Source() {
                @Override
                Double getProbability(Client client, KillCountService kcService) {
                    // https://oldschool.runescape.wiki/w/Ancient_chest#Unique_drop_table
                    int totalPoints = client.getVarbitValue(Varbits.TOTAL_POINTS);
                    if (totalPoints <= 0) {
                        totalPoints = 26_025;
                    }
                    return 0.01 * (totalPoints / 8_676) / 53;
                }

                @Override
                Integer estimateActions(Client client, KillCountService kcService) {
                    return Stream.of("", " Challenge Mode")
                        .map(suffix -> "Chambers of Xeric" + suffix)
                        .map(event -> kcService.getKillCount(LootRecordType.EVENT, event))
                        .filter(Objects::nonNull)
                        .reduce(Integer::sum)
                        .orElse(null);
                }
            }),
            entry("Pet chaos elemental", new MultiKcSource("Chaos Elemental", 1.0 / 300, "Chaos Fanatic", 1.0 / 1_000)),
            entry("Pet dagannoth prime", new KcSource("Dagannoth Prime", 1.0 / 5_000)),
            entry("Pet dagannoth rex", new KcSource("Dagannoth Rex", 1.0 / 5_000)),
            entry("Pet dagannoth supreme", new KcSource("Dagannoth Supreme", 1.0 / 5_000)),
            entry("Pet dark core", new KcSource("Corporeal Beast", 1.0 / 5_000)),
            entry("Pet general graardor", new KcSource("General Graardor", 1.0 / 5_000)),
            entry("Pet k'ril tsutsaroth", new KcSource("K'ril Tsutsaroth", 1.0 / 5_000)),
            entry("Pet kraken", new KcSource("Kraken", 1.0 / 5_000)),
            entry("Pet penance queen", new Source() {
                @Override
                Double getProbability(Client client, KillCountService kcService) {
                    return 1.0 / 1_000;
                }

                @Override
                Integer estimateActions(Client client, KillCountService kcService) {
                    return client.getVarbitValue(Varbits.BA_GC);
                }
            }),
            entry("Pet smoke devil", new KcSource("Thermonuclear smoke devil", 1.0 / 3_000)),
            entry("Pet snakeling", new KcSource("Zulrah", 1.0 / 4_000)),
            entry("Pet zilyana", new KcSource("Commander Zilyana", 1.0 / 5_000)),
            entry("Phoenix", new KcSource("Wintertodt", 1.0 / 5_000)),
            entry("Prince black dragon", new KcSource("King Black Dragon", 1.0 / 3_000)),
            entry("Quetzin", new MultiKcSource("Hunters' loot sack (expert)", 1.0 / 1_000, "Hunters' loot sack (master)", 1.0 / 1_000)),
            entry("Rift guardian", new SkillSource(Skill.RUNECRAFT, 1_795_758, 10)), // lava runes
            entry("Rock golem", new SkillSource(Skill.MINING, 211_886, 65)), // gemstones
            entry("Rocky", new SkillSource(Skill.THIEVING, 36_490, 42)), // stalls
            entry("Scorpia's offspring", new KcSource("Scorpia", 1 / 2015.75)),
            entry("Scurry", new KcSource("Scurrius", 1.0 / 3_000)),
            entry("Skotos", new KcSource("Skotizo", 1.0 / 65)),
            entry("Smolcano", new KcSource("Zalcano", 1.0 / 2_250)),
            entry("Smol heredit", new Source() {
                @Override
                Double getProbability(Client client, KillCountService kcService) {
                    return 1.0 / 200;
                }

                @Override
                Integer estimateActions(Client client, KillCountService kcService) {
                    SerializedLoot lootRecord = kcService.getLootTrackerRecord(LootRecordType.EVENT, "Fortis Colosseum");
                    return lootRecord != null ? lootRecord.getQuantity(ItemID.DIZANAS_QUIVER_UNCHARGED) : null;
                }
            }),
            entry("Sraracha", new KcSource("Sarachnis", 1.0 / 3_000)),
            entry("Tangleroot", new SkillSource(Skill.FARMING, 7_500, 119)), // mushrooms
            entry("Tiny tempor", new KcSource("Reward pool (Tempoross)", 1.0 / 8_000)),
            entry("Tumeken's guardian", new Source() {
                @Override
                Double getProbability(Client client, KillCountService kcService) {
                    // https://oldschool.runescape.wiki/w/Chest_(Tombs_of_Amascut)#Tertiary_rewards
                    int rewardPoints = client.getVarbitValue(Varbits.TOTAL_POINTS);
                    int raidLevels = Math.min(client.getVarbitValue(Varbits.TOA_RAID_LEVEL), 550);
                    int x = Math.min(raidLevels, 400);
                    int y = Math.max(raidLevels - 400, 0);
                    return 0.01 * rewardPoints / (350_000 - 700 * (x + y / 3)); // assume latest is representative
                }

                @Override
                Integer estimateActions(Client client, KillCountService kcService) {
                    return Stream.of("", ": Entry Mode", ": Expert Mode")
                        .map(suffix -> "Tombs of Amascut" + suffix)
                        .map(event -> kcService.getKillCount(LootRecordType.EVENT, event))
                        .filter(Objects::nonNull)
                        .reduce(Integer::sum)
                        .orElse(null);
                }
            }),
            entry("Tzrek-jad", new KcSource("TzTok-Jad", 1.0 / 200)),
            entry("Venenatis spiderling", new MultiKcSource("Venenatis", 1.0 / 1_500, "Spindel", 1.0 / 2_800)),
            entry("Vet'ion jr.", new MultiKcSource("Vet'ion", 1.0 / 1_500, "Calvar'ion", 1.0 / 2_800)),
            entry("Vorki", new KcSource("Vorkath", 1.0 / 3_000)),
            entry("Wisp", new KcSource("The Whisperer", 1.0 / 2_000)),
            entry("Youngllef", new MultiKcSource("Gauntlet", 1.0 / 2_000, "Corrupted Gauntlet", 1.0 / 800))
        );
    }
}

package dinkplugin.notifiers;

import com.google.common.collect.ImmutableSet;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.templating.impl.JoiningReplacement;
import dinkplugin.notifiers.data.LevelNotificationData;
import dinkplugin.notifiers.data.XpNotificationData;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.WorldType;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

import static net.runelite.api.Experience.MAX_REAL_LEVEL;

@Slf4j
@Singleton
public class LevelNotifier extends BaseNotifier {
    public static final int LEVEL_FOR_MAX_XP = Experience.MAX_VIRT_LEVEL + 1; // 127
    static final @VisibleForTesting int INIT_GAME_TICKS = 16; // ~10s
    private static final Set<WorldType> SPECIAL_WORLDS = EnumSet.of(WorldType.PVP_ARENA, WorldType.QUEST_SPEEDRUNNING, WorldType.BETA_WORLD, WorldType.NOSAVE_MODE, WorldType.TOURNAMENT_WORLD, WorldType.DEADMAN, WorldType.SEASONAL);
    private static final int SKILL_COUNT = Skill.values().length;
    private static final String COMBAT_NAME = "Combat";
    private static final Set<String> COMBAT_COMPONENTS;
    private final BlockingQueue<String> levelledSkills = new ArrayBlockingQueue<>(SKILL_COUNT + 1);
    private final Set<Skill> xpReached = EnumSet.noneOf(Skill.class);
    private final Map<String, Integer> currentLevels = new HashMap<>();
    private final Map<Skill, Integer> currentXp = new EnumMap<>(Skill.class);
    private int ticksWaited = 0;
    private int initTicks = 0;
    private Set<WorldType> specialWorldType = null;

    @Inject
    private ClientThread clientThread;

    @Override
    protected String getWebhookUrl() {
        return config.levelWebhook();
    }

    private void initLevels() {
        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int level = client.getRealSkillLevel(skill); // O(1)
            if (level >= MAX_REAL_LEVEL) {
                level = getLevel(xp);
            }
            currentLevels.put(skill.getName(), level);
            currentXp.put(skill, xp);
        }
        currentLevels.put(COMBAT_NAME, calculateCombatLevel());
        this.initTicks = 0;
        this.specialWorldType = getSpecialWorldTypes();
        log.debug("Initialized current skill levels: {}", currentLevels);
    }

    public void reset() {
        levelledSkills.clear();
        clientThread.invoke(() -> {
            this.initTicks = 0;
            this.ticksWaited = 0;
            xpReached.clear();
            currentXp.clear();
            currentLevels.clear();
            this.specialWorldType = null;
        });
    }

    public void onTick() {
        if (this.initTicks > INIT_GAME_TICKS) {
            initLevels();
            return;
        }

        if (currentLevels.size() < SKILL_COUNT) {
            this.initTicks++;
            return;
        }

        if (levelledSkills.isEmpty() && xpReached.isEmpty()) {
            return;
        }

        // We wait a couple extra ticks so we can ensure that we process all the levels of the previous tick
        if (++this.ticksWaited > 2) {
            this.ticksWaited = 0;
            // ensure notifier was not disabled during ticks waited
            if (isEnabled()) {
                attemptNotify();
            } else {
                levelledSkills.clear();
            }
        }
    }

    public void onStatChanged(StatChanged statChange) {
        this.handleLevelUp(statChange.getSkill(), statChange.getLevel(), statChange.getXp());
    }

    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN) {
            this.reset();
        } else if (gameStateChanged.getGameState() == GameState.LOGGED_IN && !getSpecialWorldTypes().equals(this.specialWorldType)) {
            // world switched where player may have different level profiles; re-initialize
            this.reset();
        }
    }

    private void handleLevelUp(Skill skill, int level, int xp) {
        if (xp <= 0 || level <= 1 || !isEnabled()) return;

        Integer previousXp = currentXp.put(skill, xp);
        if (previousXp == null) {
            return;
        }

        String skillName = skill.getName();
        int virtualLevel = level < MAX_REAL_LEVEL ? level : getLevel(xp); // avoid log(n) query when not needed
        Integer previousLevel = currentLevels.put(skillName, virtualLevel);

        if (previousLevel == null) {
            this.initTicks = INIT_GAME_TICKS; // force init on next tick
            return;
        }

        if (virtualLevel < previousLevel || xp < previousXp) {
            // base skill level should never regress; reset notifier state
            reset();
            return;
        }

        // Check normal skill level up
        final boolean enabled = config.notifyLevel();
        checkLevelUp(enabled, skillName, previousLevel, virtualLevel);

        // Check if xp milestone reached
        int xpInterval = config.xpInterval() * 1_000_000;
        if (enabled && xpInterval > 0 && level >= MAX_REAL_LEVEL && xp > previousXp) {
            int remainder = xp % xpInterval;
            if (remainder == 0 || xp - remainder > previousXp || xp >= Experience.MAX_SKILL_XP) {
                log.debug("Observed XP milestone for {} to {}", skill, xp);
                xpReached.add(skill);
                this.ticksWaited = 0;
            }
        }

        // Skip combat level checking if no level up has occurred
        if (virtualLevel <= previousLevel) {
            // only return if we don't need to initialize combat level for the first time
            if (currentLevels.containsKey(COMBAT_NAME))
                return;
        }

        // Check for combat level increase
        if (COMBAT_COMPONENTS.contains(skillName) && currentLevels.size() >= SKILL_COUNT) {
            int combatLevel = calculateCombatLevel();
            Integer previousCombatLevel = currentLevels.put(COMBAT_NAME, combatLevel);
            checkLevelUp(enabled && config.levelNotifyCombat(), COMBAT_NAME, previousCombatLevel, combatLevel);
        }
    }

    private void checkLevelUp(boolean configEnabled, String skill, Integer previousLevel, int currentLevel) {
        if (previousLevel == null || currentLevel <= previousLevel) {
            log.trace("Ignoring non-level-up for {}: {}", skill, currentLevel);
            return;
        }

        if (!configEnabled) {
            log.trace("Ignoring level up of {} to {} due to disabled config setting", skill, currentLevel);
            return;
        }

        if (!checkLevelInterval(previousLevel, currentLevel, COMBAT_NAME.equals(skill))) {
            log.trace("Ignoring level up of {} from {} to {} that does not align with config interval", skill, previousLevel, currentLevel);
            return;
        }

        if (levelledSkills.offer(skill)) {
            log.debug("Observed level up for {} to {}", skill, currentLevel);

            // allow more accumulation of level ups into single notification
            this.ticksWaited = 0;
        }
    }

    private void attemptNotify() {
        notifyLevels();
        notifyXp();
    }

    private void notifyXp() {
        final int n = xpReached.size();
        if (n == 0) return;

        int interval = Math.max(config.xpInterval(), 1) * 1_000_000;
        Map<String, Integer> current = new HashMap<>(32);
        currentXp.forEach((k, v) -> current.put(k.getName(), v));
        List<String> milestones = new ArrayList<>(n);
        JoiningReplacement.JoiningReplacementBuilder skillMessage = JoiningReplacement.builder().delimiter(", ");
        for (Skill skill : xpReached) {
            int xp = currentXp.getOrDefault(skill, 0);
            xp -= xp % interval;
            milestones.add(skill.getName());
            skillMessage.component(
                JoiningReplacement.builder()
                    .component(Replacements.ofWiki(skill.getName()))
                    .component(Replacements.ofText(String.format(" to %s XP", QuantityFormatter.formatNumber(xp))))
                    .build()
            );
        }
        xpReached.clear();

        String totalXp = QuantityFormatter.formatNumber(client.getOverallExperience());
        String thumbnail = n == 1 ? getSkillIcon(milestones.get(0)) : null;
        Template fullNotification = Template.builder()
            .template(config.levelNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%SKILL%", skillMessage.build())
            .replacement("%TOTAL_LEVEL%", Replacements.ofText(String.valueOf(client.getTotalLevel())))
            .replacement("%TOTAL_XP%", Replacements.ofText(totalXp))
            .build();

        createMessage(config.levelSendImage(), NotificationBody.builder()
            .text(fullNotification)
            .extra(new XpNotificationData(current, milestones, interval))
            .type(NotificationType.XP_MILESTONE)
            .thumbnailUrl(thumbnail)
            .build());
    }

    private void notifyLevels() {
        int n = levelledSkills.size();
        if (n == 0) return;

        // Prepare level state
        int totalLevel = client.getTotalLevel();
        List<String> levelled = new ArrayList<>(n);
        int count = levelledSkills.drainTo(levelled);
        if (count == 0) return;

        Map<String, Integer> lSkills = new HashMap<>(count);
        Map<String, Integer> currentLevels = new HashMap<>(this.currentLevels);

        // Build skillMessage and populate lSkills
        JoiningReplacement.JoiningReplacementBuilder skillMessage = JoiningReplacement.builder();
        for (int index = 0; index < count; index++) {
            String skill = levelled.get(index);
            if (index > 0) {
                if (count > 2) {
                    skillMessage.component(Replacements.ofText(","));
                }
                skillMessage.component(Replacements.ofText(" "));
                if (index + 1 == count) {
                    skillMessage.component(Replacements.ofText("and "));
                }
            }
            Integer level = currentLevels.get(skill);
            skillMessage
                .component(Replacements.ofWiki(skill, COMBAT_NAME.equals(skill) ? "Combat level" : skill))
                .component(Replacements.ofText(" to " + (level < LEVEL_FOR_MAX_XP ? level : "Max XP (200M)")));
            lSkills.put(skill, level);
        }

        // Separately check for combat level increase for extra data
        Boolean combatLevelUp = lSkills.remove(COMBAT_NAME) != null; // remove Combat from levelledSkills
        Integer combatLevel = currentLevels.remove(COMBAT_NAME); // remove Combat from allSkills
        if (combatLevel == null) {
            combatLevelUp = null; // combat level was not populated, so it is unclear whether combat level increased
            combatLevel = calculateCombatLevel(); // populate combat level for extra data
        } else if (!config.levelNotifyCombat()) {
            combatLevelUp = null; // if levelNotifyCombat is disabled, it is unclear whether combat level increased
        }
        LevelNotificationData.CombatLevel combatData = new LevelNotificationData.CombatLevel(combatLevel, combatLevelUp);

        // Select relevant thumbnail url
        String thumbnail;
        if (count == 1) {
            // Use skill icon if only one skill was levelled up
            thumbnail = getSkillIcon(levelled.get(0));
        } else if (combatLevelUp != null && combatLevelUp && count == 2) {
            // Upon a combat level increase, use icon of the other combat-related skill that was levelled up
            String skill = levelled.get(0);
            if (COMBAT_NAME.equals(skill))
                skill = levelled.get(1);
            thumbnail = getSkillIcon(skill);
        } else {
            // Fall back to NotificationType#getThumbnail
            thumbnail = null;
        }

        // Populate message template
        Template fullNotification = Template.builder()
            .template(config.levelNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%SKILL%", skillMessage.build())
            .replacement("%TOTAL_LEVEL%", Replacements.ofText(String.valueOf(totalLevel)))
            .replacement("%TOTAL_XP%", Replacements.ofText(QuantityFormatter.formatNumber(client.getOverallExperience())))
            .build();

        // Fire notification
        createMessage(config.levelSendImage(), NotificationBody.builder()
            .text(fullNotification)
            .extra(new LevelNotificationData(lSkills, currentLevels, combatData))
            .type(NotificationType.LEVEL)
            .thumbnailUrl(thumbnail)
            .build());
    }

    private boolean checkLevelInterval(int previous, int level, boolean skipVirtualCheck) {
        if (level < config.levelMinValue())
            return false;

        if (!skipVirtualCheck && level > MAX_REAL_LEVEL && !config.levelNotifyVirtual())
            return false;

        int interval = config.levelInterval();
        if (interval <= 1 || level == MAX_REAL_LEVEL || level == LEVEL_FOR_MAX_XP)
            return true;

        int intervalOverride = config.levelIntervalOverride();
        if (intervalOverride > 0 && level >= intervalOverride) {
            return true;
        }
        // Check levels in (previous, current] for divisibility by interval
        // Allows for firing notification if jumping over a level that would've notified
        int remainder = level % interval;
        return remainder == 0 || (level - remainder) > previous;
    }

    private int calculateCombatLevel() {
        return Experience.getCombatLevel(
            getRealLevel(Skill.ATTACK),
            getRealLevel(Skill.STRENGTH),
            getRealLevel(Skill.DEFENCE),
            getRealLevel(Skill.HITPOINTS),
            getRealLevel(Skill.MAGIC),
            getRealLevel(Skill.RANGED),
            getRealLevel(Skill.PRAYER)
        );
    }

    private int getRealLevel(Skill skill) {
        Integer cachedLevel = currentLevels.get(skill.getName());
        return cachedLevel != null
            ? Math.min(cachedLevel, MAX_REAL_LEVEL)
            : client.getRealSkillLevel(skill);
    }

    private int getLevel(int xp) {
        // treat 200M XP as level 127
        if (xp >= Experience.MAX_SKILL_XP)
            return LEVEL_FOR_MAX_XP;

        // log(n) operation to support virtual levels
        return Experience.getLevelForXp(xp);
    }

    private Set<WorldType> getSpecialWorldTypes() {
        var world = client.getWorldType().clone();
        world.retainAll(SPECIAL_WORLDS); // O(1)
        return world;
    }

    private static String getSkillIcon(String skillName) {
        return Utils.WIKI_IMG_BASE_URL + skillName + "_icon.png";
    }

    static {
        COMBAT_COMPONENTS = ImmutableSet.of(
            Skill.ATTACK.getName(),
            Skill.STRENGTH.getName(),
            Skill.DEFENCE.getName(),
            Skill.HITPOINTS.getName(),
            Skill.MAGIC.getName(),
            Skill.RANGED.getName(),
            Skill.PRAYER.getName()
        );
    }
}

package dinkplugin.notifiers;

import dinkplugin.DinkPluginConfig;
import dinkplugin.SettingsManager;
import dinkplugin.domain.SeasonalPolicy;
import dinkplugin.message.DiscordMessageHandler;
import dinkplugin.message.NotificationBody;
import dinkplugin.util.WorldUtils;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import org.apache.commons.lang3.StringUtils;

import javax.inject.Inject;
import java.util.Set;

public abstract class BaseNotifier {

    @Inject
    protected DinkPluginConfig config;

    @Inject
    protected SettingsManager settingsManager;

    @Inject
    protected Client client;

    @Inject
    private DiscordMessageHandler messageHandler;

    public boolean isEnabled() {
        Set<WorldType> world = client.getWorldType();
        if (config.seasonalPolicy() == SeasonalPolicy.REJECT && world.contains(WorldType.SEASONAL)) {
            return false;
        }
        if (WorldUtils.isIgnoredWorld(world)) {
            return false;
        }
        Player player = client.getLocalPlayer();
        return player != null && settingsManager.isNamePermitted(player.getName());
    }

    protected abstract String getWebhookUrl();

    protected final void createMessage(boolean sendImage, NotificationBody<?> body) {
        this.createMessage(getWebhookUrl(), sendImage, body);
    }

    protected final void createMessage(String overrideUrl, boolean sendImage, NotificationBody<?> body) {
        String override;
        if (StringUtils.isNotBlank(config.leaguesWebhook()) && config.seasonalPolicy() == SeasonalPolicy.FORWARD_TO_LEAGUES && client.getWorldType().contains(WorldType.SEASONAL)) {
            override = config.leaguesWebhook();
        } else {
            override = overrideUrl;
        }
        String url = StringUtils.isNotBlank(override) ? override : config.primaryWebhook();
        messageHandler.createMessage(url, sendImage, body);
    }

}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.CollectionNotificationData;
import dinkplugin.util.Drop;
import dinkplugin.util.ItemSearcher;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.KillCountService;
import dinkplugin.util.RarityService;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varp;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;
import java.util.OptionalDouble;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
public class CollectionNotifier extends BaseNotifier {
    static final Pattern COLLECTION_LOG_REGEX = Pattern.compile("New item added to your collection log: (?<itemName>(.*))");
    public static final String ADDITION_WARNING = "Collection notifier will not fire unless you enable the game setting: Collection log - New addition notification";
    private static final int POPUP_PREFIX_LENGTH = "New item:".length();

    /*
     * https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bclientscript,collection_init_frame%5D.cs2#L3
     */
    public static final @Varp int COMPLETED_VARP = 2943, TOTAL_VARP = 2944;

    static final @VisibleForTesting int TOTAL_ENTRIES = 1_560; // fallback if TOTAL_VARP is not populated

    private static final Duration RECENT_DROP = Duration.ofSeconds(30L);

    /**
     * The number of completed entries in the collection log, as implied by {@link #COMPLETED_VARP}.
     */
    private final AtomicInteger completed = new AtomicInteger(-1);

    private final AtomicBoolean popupStarted = new AtomicBoolean(false);

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ItemSearcher itemSearcher;

    @Inject
    private KillCountService killCountService;

    @Inject
    private RarityService rarityService;

    @Override
    public boolean isEnabled() {
        return config.notifyCollectionLog() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.collectionWebhook();
    }

    public void reset() {
        // note: unlike other notifiers, we do not need to reset completed after each message
        // in fact, resetting would be problematic for an edge case with multiple completions in a single tick
        this.completed.set(-1);
        this.popupStarted.set(false);
    }

    public void onGameState(GameState newState) {
        if (newState != GameState.HOPPING && newState != GameState.LOGGED_IN)
            this.reset();
    }

    public void onTick() {
        if (client.getGameState() != GameState.LOGGED_IN) {
            // this shouldn't ever happen, but just in case
            completed.set(-1);
        } else if (completed.get() < 0) {
            // initialize collection log entry completion count
            int varpValue = client.getVarpValue(COMPLETED_VARP);
            if (varpValue > 0)
                completed.set(varpValue);
        }
    }

    public void onVarPlayer(VarbitChanged event) {
        if (event.getVarpId() != COMPLETED_VARP)
            return;

        // we only care about this event when the notifier is disabled
        // to keep `completed` updated when `handleNotify` is not being called
        if (!config.notifyCollectionLog()) {
            completed.set(event.getValue());
        }
    }

    public void onChatMessage(String chatMessage) {
        if (!isEnabled() || client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION) != 1) {
            // require notifier enabled without popup mode to use chat event
            return;
        }

        Matcher collectionMatcher = COLLECTION_LOG_REGEX.matcher(chatMessage);
        if (collectionMatcher.find()) {
            String item = collectionMatcher.group("itemName");
            clientThread.invokeLater(() -> handleNotify(item));
        }
    }

    public void onScript(int scriptId) {
        if (scriptId == ScriptID.NOTIFICATION_START) {
            popupStarted.set(true);
        } else if (scriptId == ScriptID.NOTIFICATION_DELAY) {
            String topText = client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT);
            if (popupStarted.getAndSet(false) && "Collection log".equalsIgnoreCase(topText) && isEnabled()) {
                String bottomText = Utils.sanitize(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT));
                handleNotify(bottomText.substring(POPUP_PREFIX_LENGTH).trim());
            }
        }
    }

    private void handleNotify(String itemName) {
        // varp isn't updated for a few ticks, so we increment the count locally.
        // this approach also has the benefit of yielding incrementing values even when
        // multiple collection log entries are completed within a single tick.
        int completed = this.completed.updateAndGet(i -> i >= 0 ? i + 1 : i);
        int total = client.getVarpValue(TOTAL_VARP); // unique; doesn't over-count duplicates
        boolean varpValid = total > 0 && completed > 0;
        if (!varpValid) {
            // This occurs if the player doesn't have the character summary tab selected
            log.debug("Collection log progress varps were invalid ({} / {})", completed, total);
        }

        // build message
        Template notifyMessage = Template.builder()
            .template(config.collectionNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
            .replacement("%ITEM%", Replacements.ofWiki(itemName))
            .replacement("%COMPLETED%", Replacements.ofText(completed > 0 ? String.valueOf(completed) : "?"))
            .replacement("%TOTAL_POSSIBLE%", Replacements.ofText(String.valueOf(total > 0 ? total : TOTAL_ENTRIES)))
            .build();

        // populate metadata
        Integer itemId = itemSearcher.findItemId(itemName);
        Long price = itemId != null ? ItemUtils.getPrice(itemManager, itemId) : null;
        Drop loot = itemId != null ? getLootSource(itemId) : null;
        Integer killCount = loot != null ? killCountService.getKillCount(loot.getCategory(), loot.getSource()) : null;
        OptionalDouble rarity = loot != null && loot.getCategory() == LootRecordType.NPC ?
            rarityService.getRarity(loot.getSource(), itemId, 1) : OptionalDouble.empty();
        CollectionNotificationData extra = new CollectionNotificationData(
            itemName,
            itemId,
            price,
            varpValid ? completed : null,
            varpValid ? total : null,
            loot != null ? loot.getSource() : null,
            loot != null ? loot.getCategory() : null,
            killCount,
            rarity.isPresent() ? rarity.getAsDouble() : null
        );

        createMessage(config.collectionSendImage(), NotificationBody.builder()
            .text(notifyMessage)
            .thumbnailUrl(itemId != null ? ItemUtils.getItemImageUrl(itemId) : null)
            .extra(extra)
            .type(NotificationType.COLLECTION)
            .build());
    }

    @Nullable
    private Drop getLootSource(int itemId) {
        Drop drop = killCountService.getLastDrop();
        if (drop == null) return null;
        if (Duration.between(drop.getTime(), Instant.now()).compareTo(RECENT_DROP) > 0) return null;
        for (ItemStack item : drop.getItems()) {
            if (item.getId() == itemId) {
                return drop;
            }
        }
        return null;
    }

}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.BossNotificationData;
import dinkplugin.util.KillCountService;
import dinkplugin.util.TimeUtils;
import dinkplugin.util.Utils;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;

@Slf4j
@Singleton
public class KillCountNotifier extends BaseNotifier {

    @Varbit
    public static final int KILL_COUNT_SPAM_FILTER = 4930;
    public static final String SPAM_WARNING = "Kill Count Notifier requires disabling the in-game setting: Filter out boss kill-count with spam-filter";

    private static final Pattern PRIMARY_REGEX = Pattern.compile("Your (?<key>.+)\\s(?<type>kill|chest|completion|harvest)\\s?count is: ?(?<value>[\\d,]+)\\b", Pattern.CASE_INSENSITIVE);
    private static final Pattern SECONDARY_REGEX = Pattern.compile("Your (?:completed|subdued) (?<key>.+) count is: (?<value>[\\d,]+)\\b");
    private static final Pattern TIME_REGEX = Pattern.compile("(?:Duration|time|Subdued in):? (?<time>[\\d:]+(?:.\\d+)?)\\.?(?: Personal best: (?<pbtime>[\\d:+]+(?:.\\d+)?))?", Pattern.CASE_INSENSITIVE);

    private static final String BA_BOSS_NAME = "Penance Queen";

    /**
     * The maximum number of ticks to hold onto a fight duration without a corresponding boss name.
     * <p>
     * Note: unlike other notifiers, this is applied asymmetrically
     * (i.e., we do not wait for fight duration if only boss name was received on the tick)
     */
    @VisibleForTesting
    static final int MAX_BAD_TICKS = 10;

    @Inject
    private KillCountService kcService;

    private final AtomicInteger badTicks = new AtomicInteger();
    private final AtomicReference<BossNotificationData> data = new AtomicReference<>();

    @Override
    public boolean isEnabled() {
        return config.notifyKillCount() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.killCountWebhook();
    }

    public void reset() {
        this.data.set(null);
        this.badTicks.set(0);
    }

    public void onGameMessage(String message) {
        if (isEnabled())
            parse(client, message).ifPresent(this::updateData);
    }

    public void onFriendsChatNotification(String message) {
        // For CoX, Jagex sends duration via FRIENDSCHATNOTIFICATION
        if (message.startsWith("Congratulations - your raid is complete!"))
            this.onGameMessage(message);
    }

    public void onWidget(WidgetLoaded event) {
        if (!isEnabled())
            return;

        // Barbarian Assault: Track Penance Queen kills
        if (config.killCountPenanceQueen() && event.getGroupId() == InterfaceID.BA_REWARD) {
            Widget widget = client.getWidget(ComponentID.BA_REWARD_REWARD_TEXT);
            // https://oldschool.runescape.wiki/w/Barbarian_Assault/Rewards#Earning_Honour_points
            if (widget != null && widget.getText().contains("80 ") && widget.getText().contains("5 ")) {
                int gambleCount = client.getVarbitValue(Varbits.BA_GC);
                this.data.set(new BossNotificationData(BA_BOSS_NAME, gambleCount, "The Queen is dead!", null, null, null, null));
            }
        }
    }

    public void onTick() {
        BossNotificationData data = this.data.get();
        if (data != null) {
            if (data.getBoss() != null && data.getCount() != null) {
                // ensure notifier was not disabled during bad ticks wait period
                if (isEnabled()) {
                    // once boss name has arrived, we notify at tick end (even if duration hasn't arrived)
                    handleKill(data);
                }
                reset();
            } else if (badTicks.incrementAndGet() > MAX_BAD_TICKS) {
                // after receiving fight duration, allow up to 10 ticks for boss name to arrive.
                // if boss name doesn't arrive in time, reset (to avoid stale data contaminating later notifications)
                reset();
            }
        }
    }

    private void handleKill(BossNotificationData data) {
        // ensure data is present
        if (data.getBoss() == null || data.getCount() == null)
            return;

        // ensure interval met or pb or ba, depending on config
        boolean isPb = data.isPersonalBest() == Boolean.TRUE;
        boolean ba = data.getBoss().equals(BA_BOSS_NAME);
        if (!checkKillInterval(data.getCount(), isPb) && !ba)
            return;

        // populate personalBest if absent
        if (data.getPersonalBest() == null && !isPb) {
            Duration pb = kcService.getPb(data.getBoss());
            if (pb != null && (data.getTime() == null || pb.compareTo(data.getTime()) < 0)) {
                data = data.withPersonalBest(pb);
            }
        }

        // Assemble content
        String player = Utils.getPlayerName(client);
        String time = TimeUtils.format(data.getTime(), TimeUtils.isPreciseTiming(client));
        Template content = Template.builder()
            .template(isPb ? config.killCountBestTimeMessage() : config.killCountMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(player))
            .replacement("%BOSS%", Replacements.ofWiki(data.getBoss()))
            .replacement("%COUNT%", Replacements.ofText(data.getCount() + (ba ? " high gambles" : "")))
            .replacement("%TIME%", Replacements.ofText(time))
            .build();

        // Call webhook
        createMessage(config.killCountSendImage(), NotificationBody.builder()
            .text(content)
            .extra(data)
            .playerName(player)
            .type(NotificationType.KILL_COUNT)
            .build());
    }

    private boolean checkKillInterval(int killCount, boolean pb) {
        if (pb && config.killCountNotifyBestTime())
            return true;

        if (killCount == 1 && config.killCountNotifyInitial())
            return true;

        int interval = config.killCountInterval();
        return interval <= 1 || killCount % interval == 0;
    }

    private void updateData(BossNotificationData updated) {
        data.getAndUpdate(old -> {
            if (old == null) {
                return updated;
            } else {
                // Boss data and timing are sent in separate messages
                // where the order of the messages differs depending on the boss.
                // Here, we update data without setting any not-null values back to null.
                String boss = defaultIfNull(updated.getBoss(), old.getBoss());
                boolean tob = boss != null && boss.startsWith("Theatre of Blood"); // prefer challenge time message that comes first: https://github.com/pajlads/DinkPlugin/issues/585
                return new BossNotificationData(
                    boss,
                    defaultIfNull(updated.getCount(), old.getCount()),
                    defaultIfNull(updated.getGameMessage(), old.getGameMessage()),
                    updated.getTime() == null || (tob && old.getTime() != null) ? old.getTime() : updated.getTime(),
                    updated.isPersonalBest() == null || (tob && old.isPersonalBest() != null) ? old.isPersonalBest() : updated.isPersonalBest(),
                    updated.getPersonalBest() == null || (tob && old.getPersonalBest() != null) ? old.getPersonalBest() : updated.getPersonalBest(),
                    defaultIfNull(updated.getParty(), old.getParty())
                );
            }
        });
    }

    private static Optional<BossNotificationData> parse(Client client, String message) {
        if (message.startsWith("Preparation")) return Optional.empty();
        Optional<Pair<String, Integer>> boss = parseBoss(message);
        if (boss.isPresent())
            return boss.map(pair -> new BossNotificationData(pair.getLeft(), pair.getRight(), message, null, null, null, Utils.getBossParty(client, pair.getLeft())));

        // TOB reports final wave duration before challenge time in the same message; skip to the part we care about
        int tobIndex = message.startsWith("Wave") ? message.indexOf(KillCountService.TOB) : -1;
        String msg = tobIndex < 0 ? message : message.substring(tobIndex);

        return parseTime(msg).map(t -> new BossNotificationData(tobIndex < 0 ? null : KillCountService.TOB, null, null, t.getTime(), t.isPb(), t.getPb(), null));
    }

    private static Optional<ParsedTime> parseTime(String message) {
        Matcher matcher = TIME_REGEX.matcher(message);
        if (matcher.find()) {
            Duration duration = TimeUtils.parseTime(matcher.group("time"));
            boolean isPb = message.toLowerCase().contains("(new personal best)");
            String pbTime = matcher.group("pbtime");
            Duration pb = pbTime != null ? TimeUtils.parseTime(pbTime) : null;
            return Optional.of(new ParsedTime(duration, isPb, pb));
        }
        return Optional.empty();
    }

    public static Optional<Pair<String, Integer>> parseBoss(String message) {
        Matcher primary = PRIMARY_REGEX.matcher(message);
        Matcher secondary; // lazy init
        if (primary.find()) {
            String boss = parsePrimaryBoss(primary.group("key"), primary.group("type"));
            String count = primary.group("value");
            return result(boss, count);
        } else if ((secondary = SECONDARY_REGEX.matcher(message)).find()) {
            String key = parseSecondary(secondary.group("key"));
            String value = secondary.group("value");
            return result(key, value);
        }
        return Optional.empty();
    }

    private static Optional<Pair<String, Integer>> result(String boss, String count) {
        // safely transform (String, String) => (String, Int)
        try {
            return Optional.ofNullable(boss).map(k -> Pair.of(boss, Integer.parseInt(count.replace(",", ""))));
        } catch (NumberFormatException e) {
            log.debug("Failed to parse kill count [{}] for boss [{}]", count, boss);
            return Optional.empty();
        }
    }

    @Nullable
    private static String parsePrimaryBoss(String boss, String type) {
        switch (type.toLowerCase()) {
            case "chest":
                if ("Barrows".equalsIgnoreCase(boss))
                    return boss;
                if ("Lunar".equals(boss))
                    return boss + " " + type;
                return null;

            case "completion":
                if (KillCountService.GAUNTLET_NAME.equalsIgnoreCase(boss))
                    return KillCountService.GAUNTLET_BOSS;
                if (KillCountService.CG_NAME.equalsIgnoreCase(boss))
                    return KillCountService.CG_BOSS;
                return null;

            case "harvest":
                if (KillCountService.HERBIBOAR.equalsIgnoreCase(boss))
                    return KillCountService.HERBIBOAR;

            case "kill":
                return boss;

            default:
                return null;
        }
    }

    private static String parseSecondary(String boss) {
        if (boss == null || "Wintertodt".equalsIgnoreCase(boss))
            return boss;

        int modeSeparator = boss.lastIndexOf(':');
        String raid = modeSeparator > 0 ? boss.substring(0, modeSeparator) : boss;
        if (raid.equalsIgnoreCase(KillCountService.TOB)
            || raid.equalsIgnoreCase(KillCountService.TOA)
            || raid.equalsIgnoreCase(KillCountService.COX)
            || raid.equalsIgnoreCase(KillCountService.COX + " Challenge Mode"))
            return boss;

        return null;
    }

    @Value
    private static class ParsedTime {
        Duration time;
        boolean isPb;
        @Nullable Duration pb;
    }
}

package dinkplugin.notifiers;

import com.google.common.collect.ImmutableMap;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.util.Utils;
import dinkplugin.domain.CombatAchievementTier;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.notifiers.data.CombatAchievementData;
import net.runelite.api.annotations.Varbit;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Optional;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class CombatTaskNotifier extends BaseNotifier {
    private static final Pattern ACHIEVEMENT_PATTERN = Pattern.compile("Congratulations, you've completed an? (?<tier>\\w+) combat task: (?<task>.+)\\.");
    private static final Pattern TASK_POINTS = Pattern.compile("\\s+\\(\\d+ points?\\)$");
    public static final String REPEAT_WARNING = "Combat Task notifier will fire duplicates unless you disable the game setting: Combat Achievement Tasks - Repeat completion";

    @Varbit
    public static final int COMBAT_TASK_REPEAT_POPUP = 12456;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,ca_tasks_progress_bar%5D.cs2#L58">CS2 Reference</a>
     */
    @Varbit
    public static final int TOTAL_POINTS_ID = 14815;

    @Varbit
    public static final int GRANDMASTER_TOTAL_POINTS_ID = 14814;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/master/scripts/%5Bproc,ca_tasks_progress_bar%5D.cs2#L6-L11">CS2 Reference</a>
     */
    @VisibleForTesting
    public static final Map<CombatAchievementTier, Integer> CUM_POINTS_VARBIT_BY_TIER;

    /**
     * The cumulative points needed to unlock rewards for each tier, in a Red-Black tree.
     * <p>
     * This is populated by {@link #initThresholds()} based on {@link #CUM_POINTS_VARBIT_BY_TIER}.
     *
     * @see <a href="https://gachi.gay/01CAv">Rewards Thresholds at the launch of the points-based system</a>
     */
    private final NavigableMap<Integer, CombatAchievementTier> cumulativeUnlockPoints = new TreeMap<>();

    @Inject
    private ClientThread clientThread;

    @Override
    public boolean isEnabled() {
        return config.notifyCombatTask() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.combatTaskWebhook();
    }

    public void onTick() {
        if (cumulativeUnlockPoints.size() < CUM_POINTS_VARBIT_BY_TIER.size())
            initThresholds();
    }

    public void onGameMessage(String message) {
        if (isEnabled())
            parse(message).ifPresent(pair -> handle(pair.getLeft(), pair.getRight()));
    }

    private void handle(CombatAchievementTier tier, String task) {
        if (tier.ordinal() < config.minCombatAchievementTier().ordinal())
            return;

        // delay notification for varbits to be updated
        clientThread.invokeAtTickEnd(() -> {
            int taskPoints = tier.getPoints();
            int totalPoints = client.getVarbitValue(TOTAL_POINTS_ID);
            int totalPossiblePoints = client.getVarbitValue(GRANDMASTER_TOTAL_POINTS_ID);

            var nextThreshold = cumulativeUnlockPoints.ceilingEntry(totalPoints + 1);
            Map.Entry<Integer, CombatAchievementTier> prev = cumulativeUnlockPoints.floorEntry(totalPoints);
            int prevThreshold = prev != null ? prev.getKey() : 0;

            Integer tierProgress, tierTotalPoints;
            if (nextThreshold != null) {
                tierProgress = totalPoints - prevThreshold;
                tierTotalPoints = nextThreshold.getKey() - prevThreshold;
            } else {
                tierProgress = tierTotalPoints = null;
            }

            boolean crossedThreshold = prevThreshold > 0 && totalPoints - taskPoints < prevThreshold;
            CombatAchievementTier completedTier = crossedThreshold ? prev.getValue() : null;
            String completedTierName = completedTier != null ? completedTier.getDisplayName() : "N/A";
            CombatAchievementTier currentTier = crossedThreshold || prev == null ? null : prev.getValue();
            CombatAchievementTier nextTier = nextThreshold != null ? nextThreshold.getValue() : null;

            String player = Utils.getPlayerName(client);
            Template message = Template.builder()
                .template(crossedThreshold ? config.combatTaskUnlockMessage() : config.combatTaskMessage())
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText(player))
                .replacement("%TIER%", Replacements.ofText(tier.toString()))
                .replacement("%TASK%", Replacements.ofWiki(task))
                .replacement("%POINTS%", Replacements.ofText(String.valueOf(taskPoints)))
                .replacement("%TOTAL_POINTS%", Replacements.ofText(String.valueOf(totalPoints)))
                .replacement("%COMPLETED%", Replacements.ofText(completedTierName))
                .build();

            createMessage(config.combatTaskSendImage(), NotificationBody.<CombatAchievementData>builder()
                .type(NotificationType.COMBAT_ACHIEVEMENT)
                .text(message)
                .playerName(player)
                .extra(new CombatAchievementData(tier, task, taskPoints, totalPoints, tierProgress, tierTotalPoints, totalPossiblePoints, currentTier, nextTier, completedTier))
                .build());
        });
    }

    private void initThresholds() {
        CUM_POINTS_VARBIT_BY_TIER.forEach((tier, varbitId) -> {
            int cumulativePoints = client.getVarbitValue(varbitId);
            if (cumulativePoints > 0)
                cumulativeUnlockPoints.put(cumulativePoints, tier);
        });
    }

    @VisibleForTesting
    static Optional<Pair<CombatAchievementTier, String>> parse(String message) {
        Matcher matcher = ACHIEVEMENT_PATTERN.matcher(message);
        if (!matcher.find()) return Optional.empty();
        return Optional.of(matcher.group("tier"))
            .map(CombatAchievementTier.TIER_BY_LOWER_NAME::get)
            .map(tier -> Pair.of(
                tier,
                TASK_POINTS.matcher(
                    matcher.group("task")
                ).replaceFirst("") // remove points suffix
            ));
    }

    static {
        // noinspection UnstableApiUsage (builderWithExpectedSize is no longer @Beta in snapshot guava)
        CUM_POINTS_VARBIT_BY_TIER = ImmutableMap.<CombatAchievementTier, Integer>builderWithExpectedSize(6)
            .put(CombatAchievementTier.EASY, 4132) // 33 = 33 * 1
            .put(CombatAchievementTier.MEDIUM, 10660) // 115 = 33 + 41 * 2
            .put(CombatAchievementTier.HARD, 10661) // 304 = 115 + 63 * 3
            .put(CombatAchievementTier.ELITE, 14812) // 820 = 304 + 129 * 4
            .put(CombatAchievementTier.MASTER, 14813) // 1465 = 820 + 129 * 5
            .put(CombatAchievementTier.GRANDMASTER, GRANDMASTER_TOTAL_POINTS_ID) // 2005 = 1465 + 90 * 6
            .build();
    }
}

package dinkplugin.notifiers;

import dinkplugin.domain.ChatNotificationType;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.ChatNotificationData;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.Utils;
import lombok.Synchronized;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanID;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.util.Text;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import javax.inject.Singleton;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static dinkplugin.domain.ChatNotificationType.*;

@Singleton
public class ChatNotifier extends BaseNotifier {
    public static final String PATTERNS_CONFIG_KEY = "chatPatterns";

    private final Collection<Pattern> regexps = new CopyOnWriteArrayList<>();

    @Override
    public boolean isEnabled() {
        return config.notifyChat() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.chatWebhook();
    }

    public void init() {
        this.loadPatterns(config.chatPatterns());
    }

    @Synchronized
    public void reset() {
        regexps.clear();
    }

    public void onConfig(String key, String value) {
        if (PATTERNS_CONFIG_KEY.equals(key)) {
            this.loadPatterns(value);
        }
    }

    public void onMessage(@NotNull ChatMessageType messageType, @Nullable String source, @NotNull String message) {
        ChatNotificationType type = ChatNotificationType.MAPPINGS.get(messageType);
        if (type != null && config.chatMessageTypes().contains(type) && isEnabled() && hasMatch(message)) {
            String cleanSource = source != null ? Text.sanitize(source) : null;
            this.handleNotify(type, messageType, cleanSource, message);
        }
    }

    public void onCommand(CommandExecuted event) {
        if (config.chatMessageTypes().contains(COMMAND) && isEnabled()) {
            String fullMessage = join(event);
            if (hasMatch(fullMessage)) {
                this.handleNotify(COMMAND, ChatMessageType.UNKNOWN, "CommandExecuted", fullMessage);
            }
        }
    }

    public void onNotification(NotificationFired event) {
        var types = config.chatMessageTypes();
        if (event.getNotification().isGameMessage() && client.getGameState() == GameState.LOGGED_IN && types.contains(GAME)) {
            return; // avoid duplicate notification (since runelite will also post to chat)
        }
        if (types.contains(RUNELITE) && isEnabled() && hasMatch(event.getMessage())) {
            this.handleNotify(RUNELITE, ChatMessageType.UNKNOWN, "NotificationFired", event.getMessage());
        }
    }

    private void handleNotify(ChatNotificationType dinkType, ChatMessageType type, String source, String message) {
        var clanTitle = getClanTitle(type, source, message);
        String playerName = Utils.getPlayerName(client);
        Template template = Template.builder()
            .template(config.chatNotifyMessage())
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%MESSAGE%", Replacements.ofText(message))
            .replacement("%SENDER%", Replacements.ofText(getSender(dinkType, source)))
            .build();
        createMessage(config.chatSendImage(), NotificationBody.builder()
            .text(template)
            .type(NotificationType.CHAT)
            .extra(new ChatNotificationData(type, source, clanTitle, message))
            .playerName(playerName)
            .build());
    }

    private boolean hasMatch(String chatMessage) {
        for (Pattern pattern : regexps) {
            if (pattern.matcher(chatMessage).find())
                return true;
        }
        return false;
    }

    @Synchronized
    private void loadPatterns(String configValue) {
        regexps.clear();
        regexps.addAll(
            ConfigUtil.readDelimited(configValue)
                .map(Utils::regexify)
                .collect(Collectors.toList())
        );
    }

    @Nullable
    private ClanTitle getClanTitle(@NotNull ChatMessageType type, @Nullable String source, @NotNull String message) {
        if (type == ChatMessageType.CLAN_MESSAGE && message.endsWith(" has joined.")) {
            String name = message.substring(0, message.length() - " has joined.".length());
            var title = getClanTitle(ChatMessageType.CLAN_CHAT, name);
            return title != null ? title : getClanTitle(ChatMessageType.CLAN_GUEST_CHAT, name);
        }
        return getClanTitle(type, source);
    }

    @Nullable
    private ClanTitle getClanTitle(@NotNull ChatMessageType type, @Nullable String name) {
        if (name == null) return null;

        ClanChannel channel;
        ClanSettings settings;
        if (type == ChatMessageType.CLAN_CHAT) {
            channel = client.getClanChannel();
            settings = client.getClanSettings();
        } else if (type == ChatMessageType.CLAN_GUEST_CHAT) {
            channel = client.getGuestClanChannel();
            settings = client.getGuestClanSettings();
        } else if (type == ChatMessageType.CLAN_GIM_CHAT) {
            channel = client.getClanChannel(ClanID.GROUP_IRONMAN);
            settings = client.getClanSettings(ClanID.GROUP_IRONMAN);
        } else {
            channel = null;
            settings = null;
        }

        ClanChannelMember member;
        if (channel == null || settings == null || (member = channel.findMember(name)) == null) {
            return null;
        }
        return settings.titleForRank(member.getRank());
    }

    private static String getSender(ChatNotificationType type, String source) {
		if (source == null || source.isEmpty() || type == COMMAND || type == RUNELITE) {
			return "[" + type + "]";
		}
		return source;
    }

    private static String join(CommandExecuted event) {
        StringBuilder sb = new StringBuilder();
        sb.append("::").append(event.getCommand());

        String[] args = event.getArguments();
        if (args != null) {
            for (String arg : args) {
                sb.append(' ').append(arg);
            }
        }
        return sb.toString();
    }
}

package dinkplugin.notifiers;

import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Evaluable;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.templating.impl.JoiningReplacement;
import dinkplugin.util.Utils;
import dinkplugin.notifiers.data.SlayerNotificationData;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Singleton;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
public class SlayerNotifier extends BaseNotifier {
    private static final Pattern BOSS_REGEX = Pattern.compile("You are granted .+ Slayer XP for completing your boss task against(?: the)? (?<name>.+)\\.$");
    @VisibleForTesting
    static final Pattern SLAYER_TASK_REGEX = Pattern.compile("You have completed your task! You killed (?<task>[\\d,]+ [^.]+)\\..*");
    private static final Pattern SLAYER_COMPLETE_REGEX = Pattern.compile("You've completed (?:at least )?(?<taskCount>[\\d,]+) (?:Wilderness )?tasks?(?: and received (?<points>[\\d,]+) points, giving you a total of [\\d,]+|\\.You'll be eligible to earn reward points if you complete tasks from a more advanced Slayer Master\\.| and reached the maximum amount of Slayer points \\((?<points2>[\\d,]+)\\))?");
    private static final Pattern TASK_MONSTER_REGEX = Pattern.compile("^(?<count>\\d*)\\s*(?<monster>.+)$");

    private final AtomicReference<String> slayerTask = new AtomicReference<>("");
    private final AtomicInteger badTicks = new AtomicInteger(); // used to prevent notifs from using stale data

    @Override
    public boolean isEnabled() {
        return config.notifySlayer() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.slayerWebhook();
    }

    public void onChatMessage(String chatMessage) {
        if (isEnabled()) {
            if (slayerTask.get().isEmpty()) {
                Matcher bossMatcher = BOSS_REGEX.matcher(chatMessage);
                if (bossMatcher.find()) {
                    String name = bossMatcher.group("name");
                    this.slayerTask.set(name.endsWith(" boss") ? name.substring(0, name.length() - " boss".length()) : name);
                    return;
                }
            }

            Matcher taskMatcher = SLAYER_TASK_REGEX.matcher(chatMessage);
            if (taskMatcher.find()) {
                String task = taskMatcher.group("task");
                slayerTask.getAndUpdate(old -> {
                    if (old == null || old.isEmpty())
                        return task;
                    return String.format("%s %s", task.substring(0, task.indexOf(' ')), old);
                });
                return;
            }

            if (slayerTask.get().isEmpty()) {
                return;
            }

            Matcher pointsMatcher = SLAYER_COMPLETE_REGEX.matcher(chatMessage);
            if (pointsMatcher.find()) {
                String slayerPoints = pointsMatcher.group("points");
                String slayerTasksCompleted = pointsMatcher.group("taskCount");

                if (slayerPoints == null) {
                    slayerPoints = pointsMatcher.group("points2");
                }

                // 3 different cases of seeing points, so in our worst case it's 0
                if (slayerPoints == null) {
                    slayerPoints = "0";
                }

                this.handleNotify(slayerPoints, slayerTasksCompleted);
            }
        }
    }

    public void onTick() {
        // Track how many ticks occur where we only have partial slayer data
        if (!slayerTask.get().isEmpty())
            badTicks.getAndIncrement();

        // Clear data if 2 ticks pass with only partial parsing
        if (badTicks.get() > 1)
            reset();
    }

    private void handleNotify(String slayerPoints, String slayerCompleted) {
        String task = slayerTask.get();
        if (task.isEmpty() || slayerPoints.isEmpty() || slayerCompleted.isEmpty()) {
            return;
        }

        int threshold = config.slayerPointThreshold();
        if (threshold <= 0 || Integer.parseInt(slayerPoints.replace(",", "")) >= threshold) {
            Optional<Pair<Integer, String>> parsedTask = parseTask(task);
            Integer marginalKillCount = parsedTask.map(Pair::getLeft).orElse(null);
            String monster = parsedTask.map(Pair::getRight).orElse(null);

            Template notifyMessage = Template.builder()
                .template(config.slayerNotifyMessage())
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
                .replacement("%TASK%", buildTask(task, monster, marginalKillCount))
                .replacement("%TASKCOUNT%", Replacements.ofText(slayerCompleted))
                .replacement("%POINTS%", Replacements.ofText(slayerPoints))
                .build();

            createMessage(config.slayerSendImage(), NotificationBody.builder()
                .text(notifyMessage)
                .extra(new SlayerNotificationData(task, slayerCompleted, slayerPoints, marginalKillCount, monster))
                .type(NotificationType.SLAYER)
                .build());
        }

        this.reset();
    }

    public void reset() {
        slayerTask.set("");
        badTicks.set(0);
    }

    @NotNull
    private static Evaluable buildTask(@NotNull String rawTask, @Nullable String monster, @Nullable Integer count) {
        if (count == null || monster == null)
            return Replacements.ofText(rawTask);

        return JoiningReplacement.builder()
            .component(Replacements.ofText(String.valueOf(count)))
            .delimiter(" ")
            .component(Replacements.ofWiki(monster))
            .build();
    }

    @NotNull
    private static Optional<Pair<Integer, String>> parseTask(@NotNull String task) {
        Matcher m = TASK_MONSTER_REGEX.matcher(task);
        if (!m.find()) return Optional.empty();
        return Optional.of(Pair.of(Integer.parseInt(m.group("count")), m.group("monster")));
    }
}

package dinkplugin.notifiers;

import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import dinkplugin.domain.AchievementDiary;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.LoginNotificationData;
import dinkplugin.notifiers.data.Progress;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.SerializedPet;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.chatcommands.ChatCommandsPlugin;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@Singleton
public class MetaNotifier extends BaseNotifier {
    static final @VisibleForTesting String RL_CHAT_CMD_PLUGIN_NAME = ChatCommandsPlugin.class.getSimpleName().toLowerCase();
    static final @VisibleForTesting int INIT_TICKS = 10; // 6 seconds after login

    private final AtomicInteger loginTicks = new AtomicInteger(-1);

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    @Inject
    private Gson gson;

    @Override
    public boolean isEnabled() {
        return StringUtils.isNotBlank(config.metadataWebhook()) && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.metadataWebhook();
    }

    public void onGameState(GameState oldState, GameState newState) {
        // inspect oldState because we don't want a notification on each world hop
        if (oldState == GameState.LOGGING_IN && newState == GameState.LOGGED_IN) {
            loginTicks.set(INIT_TICKS);
        }
        // check if the oldState is any that can be considered "in game", and if the new state is "LOGIN_SCREEN"
        if ((oldState == GameState.LOGGED_IN || oldState == GameState.CONNECTION_LOST || oldState == GameState.HOPPING)
            && newState == GameState.LOGIN_SCREEN && isEnabled()) {
            notifyLogout();
        }
    }

    public void onTick() {
        if (loginTicks.getAndUpdate(i -> Math.max(-1, i - 1)) == 0 && isEnabled()) {
            clientThread.invokeLater(this::notifyLogin); // just 20ms later to be able to run client scripts cleanly
        }
    }

    private void notifyLogin() {
        // Gather data points
        int world = client.getWorld();

        int collectionCompleted = client.getVarpValue(CollectionNotifier.COMPLETED_VARP);
        int collectionTotal = client.getVarpValue(CollectionNotifier.TOTAL_VARP);

        int combatAchievementPoints = client.getVarbitValue(CombatTaskNotifier.TOTAL_POINTS_ID);
        int combatAchievementPointsTotal = client.getVarbitValue(CombatTaskNotifier.GRANDMASTER_TOTAL_POINTS_ID);

        int diaryCompleted = AchievementDiary.DIARIES.keySet()
            .stream()
            .mapToInt(id -> DiaryNotifier.isComplete(id, client.getVarbitValue(id)) ? 1 : 0)
            .sum();
        int diaryTotal = AchievementDiary.DIARIES.size();
        client.runScript(DiaryNotifier.COMPLETED_TASKS_SCRIPT_ID);
        int diaryTaskCompleted = client.getIntStack()[0];
        client.runScript(DiaryNotifier.TOTAL_TASKS_SCRIPT_ID);
        int diaryTaskTotal = client.getIntStack()[0];

        int gambleCount = client.getVarbitValue(Varbits.BA_GC);

        long experienceTotal = client.getOverallExperience();
        int levelTotal = client.getTotalLevel();
        Map<String, Integer> skillLevels = new HashMap<>(32);
        Map<String, Integer> skillExperience = new HashMap<>(32);
        for (Skill skill : Skill.values()) {
            int xp = client.getSkillExperience(skill);
            int lvl = client.getRealSkillLevel(skill);
            int virtualLevel = lvl < 99 ? lvl : Experience.getLevelForXp(xp);
            skillExperience.put(skill.getName(), xp);
            skillLevels.put(skill.getName(), virtualLevel);
        }

        int questsCompleted = client.getVarbitValue(QuestNotifier.COMPLETED_ID);
        int questsTotal = client.getVarbitValue(QuestNotifier.TOTAL_ID);
        int questPoints = client.getVarpValue(VarPlayer.QUEST_POINTS);
        int questPointsTotal = client.getVarbitValue(QuestNotifier.QP_TOTAL_ID);

        int slayerPoints = client.getVarbitValue(Varbits.SLAYER_POINTS);
        int slayerStreak = client.getVarbitValue(Varbits.SLAYER_TASK_STREAK);

        // Fire notification
        String playerName = Utils.getPlayerName(client);
        Template message = Template.builder()
            .replacementBoundary("%")
            .template("%USERNAME% logged into World %WORLD%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%WORLD%", Replacements.ofText(String.valueOf(world)))
            .build();
        LoginNotificationData extra = new LoginNotificationData(
            world,
            Progress.of(collectionCompleted, collectionTotal),
            Progress.of(combatAchievementPoints, combatAchievementPointsTotal),
            Progress.of(diaryCompleted, diaryTotal),
            Progress.of(diaryTaskCompleted, diaryTaskTotal),
            new LoginNotificationData.BarbarianAssault(gambleCount),
            new LoginNotificationData.SkillData(experienceTotal, levelTotal, skillLevels, skillExperience),
            Progress.of(questsCompleted, questsTotal),
            Progress.of(questPoints, questPointsTotal),
            new LoginNotificationData.SlayerData(slayerPoints, slayerStreak),
            getPets()
        );
        createMessage(false, NotificationBody.builder()
            .type(NotificationType.LOGIN)
            .text(message)
            .extra(extra)
            .playerName(playerName)
            .build()
        );
    }

    private void notifyLogout() {
        String playerName = Utils.getPlayerName(client);
        Template message = Template.builder()
            .replacementBoundary("%")
            .template("%USERNAME% logged out")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .build();

        createMessage(false, NotificationBody.builder()
            .type(NotificationType.LOGOUT)
            .text(message)
            .playerName(playerName)
            .build()
        );
    }

    @VisibleForTesting
    List<SerializedPet> getPets() {
        if (ConfigUtil.isPluginDisabled(configManager, RL_CHAT_CMD_PLUGIN_NAME))
            return null;

        String json = configManager.getRSProfileConfiguration("chatcommands", "pets2");
        if (json == null || json.isEmpty())
            return null;

        int[] petItemIds;
        try {
            petItemIds = gson.fromJson(json, int[].class);
        } catch (JsonSyntaxException e) {
            log.info("Failed to deserialize owned pet IDs", e);
            return null;
        }

        List<SerializedPet> pets = new ArrayList<>(petItemIds.length);
        for (int itemId : petItemIds) {
            pets.add(new SerializedPet(itemId, client.getItemDefinition(itemId).getMembersName()));
        }
        return pets;
    }

}

package dinkplugin.notifiers;

import dinkplugin.domain.LeagueRelicTier;
import dinkplugin.domain.LeagueTaskDifficulty;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.LeaguesAreaNotificationData;
import dinkplugin.notifiers.data.LeaguesMasteryNotificationData;
import dinkplugin.notifiers.data.LeaguesRelicNotificationData;
import dinkplugin.notifiers.data.LeaguesTaskNotificationData;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.StructComposition;
import net.runelite.api.WorldType;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.annotations.Varp;
import net.runelite.client.callback.ClientThread;
import org.jetbrains.annotations.VisibleForTesting;

import javax.inject.Inject;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.TreeMap;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Slf4j
public class LeaguesNotifier extends BaseNotifier {
    private static final String AREA_UNLOCK_PREFIX = "Congratulations, you've unlocked a new area: ";
    private static final String RELIC_UNLOCK_PREFIX = "Congratulations, you've unlocked a new Relic: ";
    private static final Pattern TASK_REGEX = Pattern.compile("Congratulations, you've completed an? (?<tier>\\w+) task: (?<task>.+)\\.");
    private static final Pattern MASTERY_REGEX = Pattern.compile("Congratulations, you've unlocked a new .+ Combat Mastery: (?<type>\\w+) (?<tier>\\w+)\\.");

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/fa31b06ec5a9f6636bf9b9d5cbffbb71df022d06/scripts/%5Bproc%2Cleague_areas_progress_bar%5D.cs2#L177">CS2 Reference</a>
     */
    @VisibleForTesting
    static final @Varbit int TASKS_COMPLETED_ID = 10046; // TODO: is this still correct for V? (was used in II, III, IV)

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/fa31b06ec5a9f6636bf9b9d5cbffbb71df022d06/scripts/%5Bproc%2Cscript730%5D.cs2#L86">CS2 Reference</a>
     */
    @VisibleForTesting
    static final @Varp int POINTS_EARNED_ID = 2614; // TODO: is this still correct for V? (was used in III, IV)

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/fa31b06ec5a9f6636bf9b9d5cbffbb71df022d06/scripts/%5Bproc%2Cleague_areas_draw_interface%5D.cs2#L28-L55">CS2 Reference</a>
     */
    @VisibleForTesting
    static final @Varbit int FIVE_AREAS = 10666, FOUR_AREAS = 10665, THREE_AREAS = 10664, TWO_AREAS = 10663; // TODO: are these still correct?

    @VisibleForTesting
    static final int FIRST_AREA_TASKS = 90, SECOND_AREA_TASKS = 200, THIRD_AREA_TASKS = 400;

    /**
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/fa31b06ec5a9f6636bf9b9d5cbffbb71df022d06/scripts/[proc%2Cscript2451].cs2#L3-L6">CS2 Reference</a>
     * @see <a href="https://abextm.github.io/cache2/#/viewer/enum/2670">Enum Reference</a>
     * @see <a href="https://abextm.github.io/cache2/#/viewer/struct/4699">Struct Reference</a>
     */
    @VisibleForTesting
    static final @Varbit int LEAGUES_VERSION = 10032; // TODO: ensure this changed to 5 for Leagues V

    /**
     * Value associated with {@link #LEAGUES_VERSION} for the current league.
     */
    @VisibleForTesting
    static final int CURRENT_LEAGUE_VERSION = 5;

    /**
     * Short name for the current league.
     */
    @VisibleForTesting
    static final String CURRENT_LEAGUE_NAME = "Raging Echoes";

    /**
     * Trophy name by the required points, in a binary search tree.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Trailblazer_Reloaded_League#Trophies">Wiki Reference</a>
     * @see <a href="https://github.com/Joshua-F/cs2-scripts/blob/fa31b06ec5a9f6636bf9b9d5cbffbb71df022d06/scripts/%5Bproc%2Cscript731%5D.cs2#L3">CS2 Reference</a>
     */
    private static final NavigableMap<Integer, String> TROPHY_BY_POINTS;

    /**
     * Mapping of the points required to unlock each relic tier.
     */
    private static final NavigableMap<Integer, LeagueRelicTier> TIER_BY_POINTS;

    /**
     * Mapping of each relic name to the tier (1-8).
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Trailblazer_Reloaded_League/Relics">Wiki Reference</a>
     */
    private static final Map<String, LeagueRelicTier> TIER_BY_RELIC;

    /**
     * Mapping of the number of tasks required to unlock an area to the area index (0-3).
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Trailblazer_Reloaded_League/Areas">Wiki reference</a>
     */
    private static final NavigableMap<Integer, Integer> AREA_BY_TASKS;

    private static final Map<String, Integer> ROMAN_NUMERALS;

    @Inject
    private ClientThread clientThread;

    @Override
    public boolean isEnabled() {
        return config.notifyLeagues() &&
            client.getVarbitValue(LEAGUES_VERSION) == CURRENT_LEAGUE_VERSION &&
            client.getWorldType().contains(WorldType.SEASONAL) &&
            settingsManager.isNamePermitted(client.getLocalPlayer().getName());
    }

    @Override
    protected String getWebhookUrl() {
        return config.leaguesWebhook();
    }

    public void onGameMessage(String message) {
        if (!isEnabled()) {
            return;
        }
        if (message.startsWith(AREA_UNLOCK_PREFIX)) {
            if (config.leaguesAreaUnlock()) {
                String area = message.substring(AREA_UNLOCK_PREFIX.length(), message.length() - 1);
                notifyAreaUnlock(area);
            }
            return;
        }
        if (message.startsWith(RELIC_UNLOCK_PREFIX)) {
            if (config.leaguesRelicUnlock()) {
                String relic = message.substring(RELIC_UNLOCK_PREFIX.length(), message.length() - 1);
                notifyRelicUnlock(relic);
            }
            return;
        }
        if (config.leaguesTaskCompletion()) {
            Matcher matcher = TASK_REGEX.matcher(message);
            if (matcher.find()) {
                LeagueTaskDifficulty tier = LeagueTaskDifficulty.TIER_BY_LOWER_NAME.get(matcher.group("tier"));
                if (tier != null && tier.ordinal() >= config.leaguesTaskMinTier().ordinal()) {
                    notifyTaskCompletion(tier, matcher.group("task"));
                }
                return;
            }
        }
        if (config.leaguesMasteryUnlock()) {
            var matcher = MASTERY_REGEX.matcher(message);
            if (matcher.find()) {
                String type = matcher.group("type");
                String tier = matcher.group("tier");
                notifyCombatMastery(type, tier);
            }
        }
    }

    private void notifyCombatMastery(String type, String romanTier) {
        Integer tier = ROMAN_NUMERALS.get(romanTier);
        if (tier == null) {
            log.warn("Could not parse combat mastery tier: {}", romanTier);
            return;
        }
        String playerName = Utils.getPlayerName(client);
        Template text = Template.builder()
            .template("%USERNAME% unlocked a new Combat Mastery: %MASTERY%.")
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%MASTERY%", Replacements.ofWiki(type + " " + romanTier))
            .build();
        createMessage(config.leaguesSendImage(), NotificationBody.builder()
            .type(NotificationType.LEAGUES_MASTERY)
            .text(text)
            .extra(new LeaguesMasteryNotificationData(type, tier))
            .playerName(playerName)
            .seasonalWorld(true)
            .build());
    }

    private void notifyAreaUnlock(String area) {
        Map.Entry<Integer, String> unlocked = numAreasUnlocked();

        int tasksCompleted = client.getVarbitValue(TASKS_COMPLETED_ID);
        Integer tasksForNextArea = AREA_BY_TASKS.ceilingKey(tasksCompleted + 1);
        Integer tasksUntilNextArea = tasksForNextArea != null ? tasksForNextArea - tasksCompleted : null;

        if (unlocked == null) {
            int i = AREA_BY_TASKS.floorEntry(Math.max(tasksCompleted, 0)).getValue();
            unlocked = Map.entry(i, ith(i));
        }

        String playerName = Utils.getPlayerName(client);
        Template text = Template.builder()
            .template("%USERNAME% selected their %I_TH% region: %AREA%.")
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%I_TH%", Replacements.ofText(unlocked.getValue()))
            .replacement("%AREA%", Replacements.ofWiki(area, CURRENT_LEAGUE_NAME + " League/Areas/" + area))
            .build();
        createMessage(config.leaguesSendImage(), NotificationBody.builder()
            .type(NotificationType.LEAGUES_AREA)
            .text(text)
            .extra(new LeaguesAreaNotificationData(area, unlocked.getKey(), tasksCompleted, tasksUntilNextArea))
            .playerName(playerName)
            .seasonalWorld(true)
            .build());
    }

    private void notifyRelicUnlock(String relic) {
        int points = client.getVarpValue(POINTS_EARNED_ID);
        Integer pointsOfNextTier = TIER_BY_POINTS.ceilingKey(points + 1);
        Integer pointsUntilNextTier = pointsOfNextTier != null ? pointsOfNextTier - points : null;

        LeagueRelicTier relicTier = TIER_BY_RELIC.getOrDefault(relic, LeagueRelicTier.UNKNOWN);
        int tier = relicTier.ordinal();
        int requiredPoints = TIER_BY_POINTS.floorKey(points);

        String playerName = Utils.getPlayerName(client);
        Template text = Template.builder()
            .template("%USERNAME% unlocked a Tier %TIER% Relic: %RELIC%.")
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%TIER%", Replacements.ofText(String.valueOf(tier)))
            .replacement("%RELIC%", Replacements.ofWiki(relic))
            .build();
        createMessage(config.leaguesSendImage(), NotificationBody.builder()
            .type(NotificationType.LEAGUES_RELIC)
            .text(text)
            .extra(new LeaguesRelicNotificationData(relic, tier, requiredPoints, points, pointsUntilNextTier))
            .playerName(playerName)
            .seasonalWorld(true)
            .build());
    }

    private void notifyTaskCompletion(LeagueTaskDifficulty tier, String task) {
        int taskPoints = tier.getPoints();
        int totalPoints = client.getVarpValue(POINTS_EARNED_ID);
        int tasksCompleted = client.getVarbitValue(TASKS_COMPLETED_ID);
        String playerName = Utils.getPlayerName(client);

        Integer nextAreaTasks = AREA_BY_TASKS.ceilingKey(tasksCompleted + 1);
        Integer tasksUntilNextArea = nextAreaTasks != null ? nextAreaTasks - tasksCompleted : null;

        Map.Entry<Integer, String> trophy = TROPHY_BY_POINTS.floorEntry(totalPoints);
        Integer prevTrophyPoints;
        if (trophy != null) {
            prevTrophyPoints = TROPHY_BY_POINTS.floorKey(totalPoints - taskPoints);
        } else {
            prevTrophyPoints = null;
        }
        boolean newTrophy = trophy != null && (prevTrophyPoints == null || trophy.getKey() > prevTrophyPoints);
        String justEarnedTrophy = newTrophy ? trophy.getValue() : null;
        Integer nextTrophyPoints = TROPHY_BY_POINTS.ceilingKey(totalPoints + 1);
        Integer pointsUntilNextTrophy = nextTrophyPoints != null ? nextTrophyPoints - totalPoints : null;

        Integer nextRelicPoints = TIER_BY_POINTS.ceilingKey(totalPoints + 1);
        Integer pointsUntilNextRelic = nextRelicPoints != null ? nextRelicPoints - totalPoints : null;

        Template text = Template.builder()
            .template(newTrophy
                ? "%USERNAME% completed a %TIER% task, %TASK%, unlocking the %TROPHY% trophy!"
                : "%USERNAME% completed a %TIER% task: %TASK%.")
            .replacementBoundary("%")
            .replacement("%USERNAME%", Replacements.ofText(playerName))
            .replacement("%TIER%", Replacements.ofText(tier.getDisplayName()))
            .replacement("%TASK%", Replacements.ofWiki(task, CURRENT_LEAGUE_NAME + " League/Tasks"))
            .replacement("%TROPHY%", newTrophy
                ? Replacements.ofWiki(trophy.getValue(), String.format("%s %s trophy", CURRENT_LEAGUE_NAME, trophy.getValue().toLowerCase()))
                : Replacements.ofText("?"))
            .build();
        createMessage(config.leaguesSendImage(), NotificationBody.builder()
            .type(NotificationType.LEAGUES_TASK)
            .text(text)
            .extra(new LeaguesTaskNotificationData(task, tier, taskPoints, totalPoints, tasksCompleted, tasksUntilNextArea, pointsUntilNextRelic, pointsUntilNextTrophy, justEarnedTrophy))
            .playerName(playerName)
            .seasonalWorld(true)
            .build());
    }

    /**
     * @return the number of areas that have been unlocked as integer and human name
     */
    private Map.Entry<Integer, String> numAreasUnlocked() {
        // While Jagex's code has 5 areas (2 default, 3 discretionary),
        // most players think just in terms of the 3 discretionary areas,
        // so we disregard Misthalin and consider Karamja as the zeroth area.
        // Thus, the number of unlocked areas is bounded by 3 (instead of 5).
        if (client.getVarbitValue(FIVE_AREAS) > 0) {
            return Map.entry(3, ith(3));
        }
        if (client.getVarbitValue(FOUR_AREAS) > 0) {
            return Map.entry(2, ith(2));
        }
        if (client.getVarbitValue(THREE_AREAS) > 0) {
            return Map.entry(1, ith(1));
        }
        if (client.getVarbitValue(TWO_AREAS) > 0) {
            return Map.entry(0, ith(0)); // Karamja
        }
        return null;
    }

    private static String ith(int i) {
        if (i == 0) return "zeroth";
        if (i == 1) return "first";
        if (i == 2) return "second";
        if (i == 3) return "third";
        if (i == 4) return "fourth";
        if (i == 5) return "fifth";
        return String.valueOf(i);
    }

    public void init() {
        clientThread.invokeLater(() -> {
            StructComposition leaguesStruct;
            try {
                leaguesStruct = client.getStructComposition(client.getEnum(2670).getIntVals()[CURRENT_LEAGUE_VERSION - 1]);
            } catch (Exception e) {
                log.warn("Could not find current leagues struct", e);
                return;
            }

            try {
                initTrophies(leaguesStruct);
                log.debug("Trophies: {}", TROPHY_BY_POINTS);
            } catch (Exception e) {
                log.warn("Failed to initialize trophies", e);
            }

            try {
                initRelics(leaguesStruct);
                log.debug("Relics: {}", TIER_BY_RELIC);
                log.debug("Tiers: {}", TIER_BY_POINTS);
            } catch (Exception e) {
                log.warn("Failed to initialize relics", e);
            }
        });
    }

    /**
     * Overwrites {@code TROPHY_BY_POINTS} with thresholds defined in cache
     */
    private void initTrophies(StructComposition leaguesStruct) {
        int[] thresholds = client.getEnum(leaguesStruct.getIntValue(1857)).getIntVals();
        int n = thresholds.length;
        if (n > 0) {
            var names = List.copyOf(TROPHY_BY_POINTS.values());
            TROPHY_BY_POINTS.clear();
            for (int i = 0; i < n; i++) {
                TROPHY_BY_POINTS.put(thresholds[i], names.get(i));
            }
        }
    }

    /**
     * Overwrites {@code TIER_BY_RELIC} with data from cache
     */
    private void initRelics(StructComposition leaguesStruct) {
        int[] tierStructs = client.getEnum(leaguesStruct.getIntValue(870)).getIntVals();
        LeagueRelicTier[] tiers = LeagueRelicTier.values();
        var pointsMap = new TreeMap<Integer, LeagueRelicTier>();
        pointsMap.put(-1, LeagueRelicTier.UNKNOWN);
        for (int tierIndex = 1; tierIndex <= tierStructs.length; tierIndex++) {
            var tier = tierIndex < tiers.length ? tiers[tierIndex] : LeagueRelicTier.UNKNOWN;
            var tierStruct = client.getStructComposition(tierStructs[tierIndex - 1]);
            pointsMap.put(tierStruct.getIntValue(877), tier);

            var relicStructs = client.getEnum(tierStruct.getIntValue(878)).getIntVals();
            for (int relicStruct : relicStructs) {
                var name = client.getStructComposition(relicStruct).getStringValue(879);
                TIER_BY_RELIC.put(name, tier);
            }
        }
        if (pointsMap.size() > 1) {
            TIER_BY_POINTS.clear();
            TIER_BY_POINTS.putAll(pointsMap);
        }
    }

    static {
        ROMAN_NUMERALS = Map.of("I", 1, "II", 2, "III", 3, "IV", 4, "V", 5, "VI", 6);

        AREA_BY_TASKS = Collections.unmodifiableNavigableMap(
            new TreeMap<>(Map.of(0, 0, FIRST_AREA_TASKS, 1, SECOND_AREA_TASKS, 2, THIRD_AREA_TASKS, 3))
        );

        NavigableMap<Integer, String> thresholds = new TreeMap<>();
        thresholds.put(2_000, "Bronze");
        thresholds.put(4_000, "Iron");
        thresholds.put(10_000, "Steel");
        thresholds.put(20_000, "Mithril");
        thresholds.put(30_000, "Adamant");
        thresholds.put(45_000, "Rune");
        thresholds.put(60_000, "Dragon");
        TROPHY_BY_POINTS = thresholds;

        TIER_BY_POINTS = Arrays.stream(LeagueRelicTier.values())
            .collect(Collectors.toMap(LeagueRelicTier::getDefaultPoints, Function.identity(), (a, b) -> null, TreeMap::new));

        TIER_BY_RELIC = new HashMap<>(Map.ofEntries(
            Map.entry("Animal Wrangler", LeagueRelicTier.ONE),
            Map.entry("Lumberjack", LeagueRelicTier.ONE),
            Map.entry("Power Miner", LeagueRelicTier.ONE),
            Map.entry("Corner Cutter", LeagueRelicTier.TWO),
            Map.entry("Dodgy Deals", LeagueRelicTier.TWO),
            Map.entry("Friendly Forager", LeagueRelicTier.TWO),
            Map.entry("Bank Heist", LeagueRelicTier.THREE),
            Map.entry("Clue Compass", LeagueRelicTier.THREE),
            Map.entry("Fairy's Flight", LeagueRelicTier.THREE),
            Map.entry("Equilibrium", LeagueRelicTier.FOUR),
            Map.entry("Golden God", LeagueRelicTier.FOUR),
            Map.entry("Reloaded", LeagueRelicTier.FOUR),
            Map.entry("Production Master", LeagueRelicTier.FIVE),
            Map.entry("Slayer Master", LeagueRelicTier.FIVE),
            Map.entry("Treasure Arbiter", LeagueRelicTier.FIVE),
            Map.entry("Total Recall", LeagueRelicTier.SIX),
            Map.entry("Banker's Note", LeagueRelicTier.SIX),
            Map.entry("Grimoire", LeagueRelicTier.SEVEN),
            Map.entry("Overgrown", LeagueRelicTier.SEVEN),
            Map.entry("Pocket Kingdom", LeagueRelicTier.SEVEN),
            Map.entry("Guardian", LeagueRelicTier.EIGHT),
            Map.entry("Last Stand", LeagueRelicTier.EIGHT),
            Map.entry("Specialist", LeagueRelicTier.EIGHT)
        ));
    }
}

package dinkplugin.notifiers;

import dinkplugin.domain.ClueTier;
import dinkplugin.message.Embed;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Evaluable;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.message.templating.impl.JoiningReplacement;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.Utils;
import dinkplugin.notifiers.data.ClueNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.QuantityFormatter;
import org.jetbrains.annotations.Nullable;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class ClueNotifier extends BaseNotifier {
    private static final Pattern CLUE_SCROLL_REGEX = Pattern.compile("You have completed (?<scrollCount>\\d+) (?<scrollType>\\w+) Treasure Trails?\\.");
    private final AtomicInteger badTicks = new AtomicInteger(); // used to prevent notifs from using stale data
    private volatile int clueCount = -1;
    private volatile String clueType = "";

    @Inject
    private ItemManager itemManager;

    @Override
    public boolean isEnabled() {
        return config.notifyClue() && super.isEnabled();
    }

    @Override
    protected String getWebhookUrl() {
        return config.clueWebhook();
    }

    public void onChatMessage(String chatMessage) {
        if (isEnabled()) {
            Map.Entry<String, Integer> result = parse(chatMessage);
            if (result != null && checkClueTier(result.getKey())) {
                // game message always occurs before widget load; save this data
                this.clueCount = result.getValue();
                this.clueType = result.getKey();
            }
        }
    }

    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.CLUESCROLL_REWARD && isEnabled()) {
            Widget clue = client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER);
            if (clue != null && !clueType.isEmpty()) {
                Widget[] children = clue.getChildren();
                if (children == null) return;

                Map<Integer, Integer> clueItems = new HashMap<>();
                for (Widget child : children) {
                    if (child == null) continue;

                    int quantity = child.getItemQuantity();
                    int itemId = child.getItemId();
                    if (itemId > -1 && quantity > 0) {
                        clueItems.merge(itemId, quantity, Integer::sum);
                    }
                }

                this.handleNotify(clueItems);
            }
        }
    }

    public void onTick() {
        // Track how many ticks occur where we only have partial clue data
        if (!clueType.isEmpty())
            badTicks.getAndIncrement();

        // Clear data if 2 ticks pass with only partial parsing (both events should occur within same tick)
        if (badTicks.get() > 1)
            reset();
    }

    private void handleNotify(Map<Integer, Integer> clueItems) {
        JoiningReplacement.JoiningReplacementBuilder lootMessage = JoiningReplacement.builder().delimiter("\n");
        AtomicLong totalPrice = new AtomicLong();
        List<SerializedItemStack> itemStacks = new ArrayList<>(clueItems.size());
        List<Embed> embeds = new ArrayList<>(config.clueShowItems() ? clueItems.size() : 0);

        clueItems.forEach((itemId, quantity) -> {
            SerializedItemStack stack = ItemUtils.stackFromItem(itemManager, itemId, quantity);
            totalPrice.addAndGet(stack.getTotalPrice());
            itemStacks.add(stack);
            lootMessage.component(getItemMessage(stack, embeds));
        });

        if (totalPrice.get() >= config.clueMinValue()) {
            boolean screenshot = config.clueSendImage() && totalPrice.get() >= config.clueImageMinValue();
            Template notifyMessage = Template.builder()
                .template(config.clueNotifyMessage())
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText(Utils.getPlayerName(client)))
                .replacement("%CLUE%", Replacements.ofWiki(clueType, "Clue scroll (" + clueType + ")"))
                .replacement("%COUNT%", Replacements.ofText(String.valueOf(clueCount)))
                .replacement("%TOTAL_VALUE%", Replacements.ofText(QuantityFormatter.quantityToStackSize(totalPrice.get())))
                .replacement("%LOOT%", lootMessage.build())
                .build();
            String icon = String.format("https://oldschool.runescape.wiki/images/Clue_scroll_(%s).png", clueType.toLowerCase());
            createMessage(screenshot,
                NotificationBody.builder()
                    .text(notifyMessage)
                    .extra(new ClueNotificationData(clueType, clueCount, itemStacks))
                    .type(NotificationType.CLUE)
                    .embeds(embeds)
                    .thumbnailUrl(icon)
                    .build()
            );
        }

        this.reset();
    }

    private Evaluable getItemMessage(SerializedItemStack item, Collection<Embed> embeds) {
        if (config.clueShowItems())
            embeds.add(Embed.ofImage(ItemUtils.getItemImageUrl(item.getId())));
        return ItemUtils.templateStack(item, true);
    }

    private boolean checkClueTier(String clueType) {
        ClueTier tier = ClueTier.parse(clueType);
        if (tier == null) {
            log.warn("Failed to parse clue tier: {}", clueType);
            return true; // permissive approach
        }
        return tier.ordinal() >= config.clueMinTier().ordinal();
    }

    public void reset() {
        this.clueCount = -1;
        this.clueType = "";
        this.badTicks.set(0);
    }

    @Nullable
    public static Map.Entry<String, Integer> parse(String gameMessage) {
        Matcher clueMatcher = CLUE_SCROLL_REGEX.matcher(gameMessage);
        if (!clueMatcher.find()) return null;
        String tier = clueMatcher.group("scrollType");
        String count = clueMatcher.group("scrollCount");
        return Map.entry(tier, Integer.parseInt(count));
    }

}

package dinkplugin;

import dinkplugin.util.Utils;
import lombok.Value;
import net.runelite.api.GameState;
import net.runelite.client.config.ConfigManager;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Comparator;
import java.util.NavigableMap;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Singleton
public class VersionManager {
    public static final String VERSION_CONFIG_KEY = "pluginVersion";
    private static final long NOTIFICATION_DELAY_SECONDS = 3;
    private static final NavigableMap<Version, String> VERSIONS = new TreeMap<>(
        Comparator.comparingInt(Version::getMajor)
            .thenComparingInt(Version::getMinor)
            .thenComparingInt(Version::getPatch)
    );

    private final Version latest = VERSIONS.lastKey();

    @Inject
    private DinkPlugin plugin;

    @Inject
    private DinkPluginConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private SettingsManager settingsManager;

    @Inject
    private ScheduledExecutorService executor;

    void onStart() {
        if (config.pluginVersion().isEmpty()) {
            if (settingsManager.hasModifiedConfig()) {
                // Dink was already installed/used & launched for the first time since VersionManager was created
                setStoredVersion("1.8.4");
            } else {
                // first time launching Dink; no chat message necessary
                setStoredVersion(latest.toString());
            }
        }
    }

    void onGameState(GameState oldState, GameState newState) {
        if (newState != GameState.LOGGED_IN || oldState != GameState.LOGGING_IN) {
            // only check version when LOGGING_IN => LOGGED_IN
            return;
        }

        Version storedVersion = Version.of(config.pluginVersion());
        if (storedVersion == null || storedVersion.equals(latest)) {
            return;
        }

        setStoredVersion(latest.toString());
        executor.schedule(() -> {
            SortedMap<Version, String> latestUpdates = VERSIONS.tailMap(storedVersion, false);
            if (latestUpdates.isEmpty()) {
                return;
            }
            String displayVersion = latest.getPatch() == 0
                ? String.format("%d.%d.X", latest.getMajor(), latest.getMinor()) // avoids needing changelog for each patch
                : latest.toString();
            plugin.addChatMessage(
                "Updated to v" + displayVersion,
                Utils.GREEN,
                String.join("; ", latestUpdates.values())
            );
        }, NOTIFICATION_DELAY_SECONDS, TimeUnit.SECONDS);
    }

    void onProfileChange() {
        // if profile changes, set pluginVersion to latest so users don't see old changelogs on login
        setStoredVersion(latest.toString());
    }

    private void setStoredVersion(String version) {
        configManager.setConfiguration(SettingsManager.CONFIG_GROUP, VERSION_CONFIG_KEY, version);
    }

    private static void register(String version, String changelog) {
        VERSIONS.put(Version.of(version), changelog);
    }

    @Value
    private static class Version {
        int major;
        int minor;
        int patch;

        @Override
        public String toString() {
            return String.format("%d.%d.%d", major, minor, patch);
        }

        @Nullable
        public static Version of(@NotNull String version) {
            String[] parts = StringUtils.split(version, '.');
            if (parts.length < 3) return null;
            int major, minor, patch;
            try {
                major = Integer.parseInt(parts[0]);
                minor = Integer.parseInt(parts[1]);
                patch = Integer.parseInt(parts[2]);
            } catch (NumberFormatException ignored) {
                return null;
            }
            return new Version(major, minor, patch);
        }
    }

    static {
        register("1.9.0", "Notifications now report monster drop rarity");
        register("1.10.0", "Chat messages that match custom patterns can trigger notifications");
        register("1.10.1", "Level notifier now triggers at XP milestones with 5M as the default interval");
        register("1.10.2", "Chat notifier can read commands and RL notifications");
        register("1.10.5", "Pet notifications now report rarity and luck");
        register("1.10.12", "Rarity is now reported for notable pickpocket loot");
        register("1.10.14", "Kill count notifier now triggers for Herbiboar and Leagues notifier has been re-enabled");
    }
}

package dinkplugin;

import com.google.inject.Provides;
import dinkplugin.notifiers.ChatNotifier;
import dinkplugin.notifiers.ClueNotifier;
import dinkplugin.notifiers.CollectionNotifier;
import dinkplugin.notifiers.CombatTaskNotifier;
import dinkplugin.notifiers.DeathNotifier;
import dinkplugin.notifiers.DiaryNotifier;
import dinkplugin.notifiers.ExternalPluginNotifier;
import dinkplugin.notifiers.GambleNotifier;
import dinkplugin.notifiers.GrandExchangeNotifier;
import dinkplugin.notifiers.GroupStorageNotifier;
import dinkplugin.notifiers.KillCountNotifier;
import dinkplugin.notifiers.LeaguesNotifier;
import dinkplugin.notifiers.LevelNotifier;
import dinkplugin.notifiers.LootNotifier;
import dinkplugin.notifiers.MetaNotifier;
import dinkplugin.notifiers.PetNotifier;
import dinkplugin.notifiers.PlayerKillNotifier;
import dinkplugin.notifiers.QuestNotifier;
import dinkplugin.notifiers.SlayerNotifier;
import dinkplugin.notifiers.SpeedrunNotifier;
import dinkplugin.notifiers.TradeNotifier;
import dinkplugin.util.KillCountService;
import dinkplugin.util.Utils;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.GameState;
import net.runelite.api.events.AccountHashChanged;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.UsernameChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.RuneLite;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.Color;
import java.util.Map;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@PluginDescriptor(
    name = "Dink",
    description = "Discord-compatible webhook notifications for Loot, Death, Levels, CLog, KC, Diary, Quests, etc.",
    tags = { "loot", "logger", "collection", "pet", "death", "xp", "level", "notifications", "discord", "speedrun",
        "diary", "combat achievements", "combat task", "barbarian assault", "high level gambles" }
)
public class DinkPlugin extends Plugin {
    public static final String USER_AGENT = RuneLite.USER_AGENT + " (Dink/1.x)";

    private @Inject ChatMessageManager chatManager;

    private @Inject SettingsManager settingsManager;
    private @Inject VersionManager versionManager;

    private @Inject KillCountService killCountService;

    private @Inject CollectionNotifier collectionNotifier;
    private @Inject PetNotifier petNotifier;
    private @Inject LevelNotifier levelNotifier;
    private @Inject LootNotifier lootNotifier;
    private @Inject DeathNotifier deathNotifier;
    private @Inject SlayerNotifier slayerNotifier;
    private @Inject QuestNotifier questNotifier;
    private @Inject ClueNotifier clueNotifier;
    private @Inject SpeedrunNotifier speedrunNotifier;
    private @Inject LeaguesNotifier leaguesNotifier;
    private @Inject KillCountNotifier killCountNotifier;
    private @Inject CombatTaskNotifier combatTaskNotifier;
    private @Inject DiaryNotifier diaryNotifier;
    private @Inject GambleNotifier gambleNotifier;
    private @Inject PlayerKillNotifier pkNotifier;
    private @Inject GroupStorageNotifier groupStorageNotifier;
    private @Inject GrandExchangeNotifier grandExchangeNotifier;
    private @Inject MetaNotifier metaNotifier;
    private @Inject TradeNotifier tradeNotifier;
    private @Inject ChatNotifier chatNotifier;
    private @Inject ExternalPluginNotifier externalNotifier;

    private final AtomicReference<GameState> gameState = new AtomicReference<>();

    private Map<String, Runnable> configDisabledTasks;

    @Inject
    protected void init() {
        // clear out state that could be stale if notifier is enabled again
        this.configDisabledTasks = Map.of(
            "collectionLogEnabled", collectionNotifier::reset,
            "diaryEnabled", diaryNotifier::reset,
            "levelEnabled", levelNotifier::reset,
            "speedrunEnabled", speedrunNotifier::reset
        );
    }

    @Override
    protected void startUp() {
        log.debug("Started up Dink");
        settingsManager.init();
        versionManager.onStart();
        lootNotifier.init();
        deathNotifier.init();
        chatNotifier.init();
        // leaguesNotifier.init();
    }

    @Override
    protected void shutDown() {
        log.debug("Shutting down Dink");
        this.resetNotifiers();
        gameState.lazySet(null);
    }

    void resetNotifiers() {
        collectionNotifier.reset();
        petNotifier.reset();
        clueNotifier.reset();
        diaryNotifier.reset();
        levelNotifier.reset();
        deathNotifier.reset();
        slayerNotifier.reset();
        killCountNotifier.reset();
        groupStorageNotifier.reset();
        speedrunNotifier.reset();
        tradeNotifier.reset();
        chatNotifier.reset();
    }

    @Provides
    DinkPluginConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(DinkPluginConfig.class);
    }

    @Subscribe
    public void onAccountHashChanged(AccountHashChanged event) {
        grandExchangeNotifier.onAccountChange();
    }

    @Subscribe
    public void onCommandExecuted(CommandExecuted event) {
        settingsManager.onCommand(event);
        chatNotifier.onCommand(event);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!SettingsManager.CONFIG_GROUP.equals(event.getGroup())) {
            return;
        }

        settingsManager.onConfigChanged(event);
        lootNotifier.onConfigChanged(event.getKey(), event.getNewValue());
        deathNotifier.onConfigChanged(event.getKey(), event.getNewValue());
        chatNotifier.onConfig(event.getKey(), event.getNewValue());

        if ("false".equals(event.getNewValue())) {
            Runnable task = configDisabledTasks.get(event.getKey());
            if (task != null) task.run();
        }
    }

    @Subscribe
    public void onUsernameChanged(UsernameChanged usernameChanged) {
        levelNotifier.reset();
        killCountService.reset();
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged) {
        GameState newState = gameStateChanged.getGameState();
        if (newState == GameState.LOADING) {
            // an intermediate state that is irrelevant for our notifiers; ignore
            return;
        }

        GameState previousState = gameState.getAndSet(newState);
        if (previousState == newState) {
            // no real change occurred (just momentarily went through LOADING); ignore
            return;
        }

        versionManager.onGameState(previousState, newState);
        settingsManager.onGameState(previousState, newState);
        collectionNotifier.onGameState(newState);
        levelNotifier.onGameStateChanged(gameStateChanged);
        diaryNotifier.onGameState(gameStateChanged);
        grandExchangeNotifier.onGameStateChange(gameStateChanged);
        metaNotifier.onGameState(previousState, newState);
    }

    @Subscribe
    public void onStatChanged(StatChanged statChange) {
        levelNotifier.onStatChanged(statChange);
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        settingsManager.onTick();
        collectionNotifier.onTick();
        petNotifier.onTick();
        clueNotifier.onTick();
        slayerNotifier.onTick();
        levelNotifier.onTick();
        combatTaskNotifier.onTick();
        diaryNotifier.onTick();
        killCountNotifier.onTick();
        pkNotifier.onTick();
        grandExchangeNotifier.onTick();
        metaNotifier.onTick();
    }

    @Subscribe(priority = 1) // run before the base loot tracker plugin
    public void onChatMessage(ChatMessage message) {
        String chatMessage = Utils.sanitize(message.getMessage());
        String source = message.getName() != null && !message.getName().isEmpty() ? message.getName() : message.getSender();
        chatNotifier.onMessage(message.getType(), source, chatMessage);
        switch (message.getType()) {
            case GAMEMESSAGE:
                if ("runelite".equals(source)) {
                    // filter out plugin-sourced chat messages
                    return;
                }

                collectionNotifier.onChatMessage(chatMessage);
                petNotifier.onChatMessage(chatMessage);
                killCountService.onGameMessage(chatMessage);
                slayerNotifier.onChatMessage(chatMessage);
                clueNotifier.onChatMessage(chatMessage);
                killCountNotifier.onGameMessage(chatMessage);
                combatTaskNotifier.onGameMessage(chatMessage);
                deathNotifier.onGameMessage(chatMessage);
                speedrunNotifier.onGameMessage(chatMessage);
                leaguesNotifier.onGameMessage(chatMessage);
                break;

            case FRIENDSCHATNOTIFICATION:
                killCountNotifier.onFriendsChatNotification(chatMessage);
                // intentional fallthrough to clan notifications

            case CLAN_MESSAGE:
            case CLAN_GUEST_MESSAGE:
            case CLAN_GIM_MESSAGE:
                petNotifier.onClanNotification(chatMessage);
                break;

            case MESBOX:
                diaryNotifier.onMessageBox(chatMessage);
                gambleNotifier.onMesBoxNotification(chatMessage);
                break;

            case TRADE:
                tradeNotifier.onTradeMessage(chatMessage);
                break;

            default:
                // do nothing
                break;
        }
    }

    @Subscribe(priority = 1) // run before the base GE plugin
    public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged event) {
        grandExchangeNotifier.onOfferChange(event.getSlot(), event.getOffer());
    }

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied event) {
        pkNotifier.onHitsplat(event);
    }

    @Subscribe
    public void onActorDeath(ActorDeath actor) {
        deathNotifier.onActorDeath(actor);
    }

    @Subscribe
    public void onInteractingChanged(InteractingChanged event) {
        deathNotifier.onInteraction(event);
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event) {
        collectionNotifier.onScript(event.getScriptId());
        deathNotifier.onScript(event);
    }

    @Subscribe(priority = 1) // run before the base loot tracker plugin
    public void onNpcLootReceived(NpcLootReceived npcLootReceived) {
        killCountService.onNpcKill(npcLootReceived);
        lootNotifier.onNpcLootReceived(npcLootReceived);
    }

    @Subscribe
    public void onPlayerLootReceived(PlayerLootReceived playerLootReceived) {
        killCountService.onPlayerKill(playerLootReceived);
        lootNotifier.onPlayerLootReceived(playerLootReceived);
    }

    @Subscribe
    public void onProfileChanged(ProfileChanged event) {
        versionManager.onProfileChange();
    }

    @Subscribe
    public void onLootReceived(LootReceived lootReceived) {
        killCountService.onLoot(lootReceived);
        lootNotifier.onLootReceived(lootReceived);
    }

    @Subscribe
    public void onNotificationFired(NotificationFired event) {
        chatNotifier.onNotification(event);
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event) {
        settingsManager.onVarbitChanged(event);
        collectionNotifier.onVarPlayer(event);
        diaryNotifier.onVarbitChanged(event);
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        questNotifier.onWidgetLoaded(event);
        clueNotifier.onWidgetLoaded(event);
        speedrunNotifier.onWidgetLoaded(event);
        groupStorageNotifier.onWidgetLoad(event);
        killCountNotifier.onWidget(event);
        tradeNotifier.onWidgetLoad(event);
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event) {
        groupStorageNotifier.onWidgetClose(event);
        tradeNotifier.onWidgetClose(event);
    }

    @Subscribe
    public void onPluginMessage(PluginMessage event) {
        if ("dink".equalsIgnoreCase(event.getNamespace()) && "notify".equalsIgnoreCase(event.getName())) {
            externalNotifier.onNotify(event.getData());
        }
    }

    public void addChatSuccess(String message) {
        addChatMessage("Success", Utils.GREEN, message);
    }

    public void addChatWarning(String message) {
        addChatMessage("Warning", Utils.RED, message);
    }

    void addChatMessage(String category, Color color, String message) {
        String formatted = String.format("[%s] %s: %s",
            ColorUtil.wrapWithColorTag(getName(), Utils.PINK),
            category,
            ColorUtil.wrapWithColorTag(message, color)
        );

        chatManager.queue(
            QueuedMessage.builder()
                .type(ChatMessageType.CONSOLE)
                .runeLiteFormattedMessage(formatted)
                .build()
        );
    }
}

package dinkplugin.domain;

public enum LootCriteria {
    ALLOWLIST,
    DENYLIST,
    VALUE,
    RARITY
}

package dinkplugin.domain;

import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public enum ClueTier {
    BEGINNER,
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER;

    private static final Map<String, ClueTier> MAPPINGS;
    private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

    @Override
    public String toString() {
        return this.displayName;
    }

    @Nullable
    public static ClueTier parse(@NotNull String tier) {
        return MAPPINGS.get(tier.toUpperCase());
    }

    static {
        MAPPINGS = Arrays.stream(values()).collect(Collectors.toMap(Enum::name, Function.identity()));
    }
}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ConfigImportPolicy {
    OVERWRITE_WEBHOOKS("Overwrite Webhooks"),
    OVERWRITE_ITEM_LISTS("Overwrite Item Lists");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Getter
@RequiredArgsConstructor
public enum LeagueTaskDifficulty {
    EASY(10),
    MEDIUM(30),
    HARD(80),
    ELITE(200),
    MASTER(400);

    /**
     * Points earned from completed a task of the given difficulty.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Raging_Echoes_League/Tasks">Wiki Reference</a>
     */
    private final int points;
    private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

    @Override
    public String toString() {
        return this.displayName;
    }

    public static final Map<String, LeagueTaskDifficulty> TIER_BY_LOWER_NAME = Collections.unmodifiableMap(
        Arrays.stream(values()).collect(Collectors.toMap(t -> t.name().toLowerCase(), Function.identity()))
    );
}

package dinkplugin.domain;

import net.runelite.api.ChatMessageType;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;

import static net.runelite.api.ChatMessageType.*;

/**
 * A condensed version of {@link ChatMessageType} for more user-friendly configuration.
 */
public enum ChatNotificationType {
    GAME("Game Engine", GAMEMESSAGE, ENGINE, CONSOLE, SPAM, MESBOX, DIALOG, BROADCAST, LOGINLOGOUTNOTIFICATION, PLAYERRELATED, SNAPSHOTFEEDBACK),
    CLAN("Clan Notifications", CLAN_MESSAGE, CLAN_GIM_MESSAGE, CLAN_GUEST_MESSAGE, FRIENDSCHATNOTIFICATION),
    TRADES("Trades and Duels", TRADE, TRADE_SENT, TRADEREQ, CHALREQ_TRADE, CHALREQ_FRIENDSCHAT, CHALREQ_CLANCHAT),
    PUBLIC("Public Chats", PUBLICCHAT, MODCHAT, AUTOTYPER, MODAUTOTYPER),
    PRIVATE("Non-Public Chats", PRIVATECHAT, PRIVATECHATOUT, MODPRIVATECHAT, FRIENDSCHAT, CLAN_CHAT, CLAN_GUEST_CHAT),
    COMMAND("Client Commands"),
    RUNELITE("RuneLite Notifications");

    public static final Map<ChatMessageType, ChatNotificationType> MAPPINGS;

    private final String displayName;
    private final ChatMessageType[] types;

    ChatNotificationType(String displayName, ChatMessageType... types) {
        this.displayName = displayName;
        this.types = types;
    }

    @Override
    public String toString() {
        return this.displayName;
    }

    static {
        Map<ChatMessageType, ChatNotificationType> map = new EnumMap<>(ChatMessageType.class);
        for (ChatNotificationType value : values()) {
            for (ChatMessageType type : value.types) {
                map.put(type, value);
            }
        }
        MAPPINGS = Collections.unmodifiableMap(map);
    }
}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum FilterMode {
    ALLOW("Exclusively Allow"),
    DENY("Selectively Deny");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import dinkplugin.message.Field;
import dinkplugin.message.templating.impl.SimpleReplacement;
import lombok.Data;
import org.jetbrains.annotations.Nullable;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Supplier;
import java.util.stream.Collectors;

@Data
public class ExternalNotificationRequest {

    private String sourcePlugin;
    private String text;
    private boolean imageRequested;
    private @Nullable String title;
    private @Nullable String thumbnail;
    private @Nullable List<Field> fields;
    private @Nullable Map<String, SimpleReplacement> replacements;
    private @Nullable Map<String, Object> metadata;
    private @Nullable List<String> urls;

    public String getUrls(Supplier<String> defaultValue) {
        return urls != null
            ? urls.stream().filter(Objects::nonNull).collect(Collectors.joining("\n"))
            : defaultValue.get();
    }

    public List<Field> getFields() {
        return this.fields != null ? this.fields : Collections.emptyList();
    }

}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

/**
 * Safe deaths that can be customized to trigger death notifications even in dangerous-only mode.
 */
@RequiredArgsConstructor
public enum ExceptionalDeath {
    COX("Chambers of Xeric"),
    DIARY_RESURRECTION("Diary Resurrection"),
    FIGHT_CAVE("Fight Caves"),
    INFERNO("Inferno"),
    JAD_CHALLENGES("Jad challenges"),
    TOB("Theatre of Blood"),
    TOA("Tombs of Amascut");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ExternalScreenshotPolicy {
    ALWAYS("Always"),
    REQUESTED("When requested"),
    NEVER("Never");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import lombok.Getter;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Getter
public enum CombatAchievementTier {
    EASY,
    MEDIUM,
    HARD,
    ELITE,
    MASTER,
    GRANDMASTER;

    /**
     * The points-based achievement system assigns one point to {@link #EASY} tasks,
     * and increments by one for each difficulty level.
     *
     * @see <a href="https://gachi.gay/01CAv">Point values documented in blog post</a>
     */
    private final int points = this.ordinal() + 1;
    private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

    @Override
    public String toString() {
        return this.displayName;
    }

    public static final Map<String, CombatAchievementTier> TIER_BY_LOWER_NAME = Collections.unmodifiableMap(
        Arrays.stream(values()).collect(Collectors.toMap(t -> t.name().toLowerCase(), Function.identity()))
    );
}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum SeasonalPolicy {
    ACCEPT("Notify normally"),
    FORWARD_TO_LEAGUES("Use Leagues URL"),
    REJECT("Off");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;

import java.util.Arrays;
import java.util.Collections;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

@Getter
@RequiredArgsConstructor
public enum AchievementDiary {
    ARDOUGNE_EASY(Varbits.DIARY_ARDOUGNE_EASY, 1, "Ardougne", Difficulty.EASY),
    ARDOUGNE_MEDIUM(Varbits.DIARY_ARDOUGNE_MEDIUM, 1, "Ardougne", Difficulty.MEDIUM),
    ARDOUGNE_HARD(Varbits.DIARY_ARDOUGNE_HARD, 1, "Ardougne", Difficulty.HARD),
    ARDOUGNE_ELITE(Varbits.DIARY_ARDOUGNE_ELITE, 1, "Ardougne", Difficulty.ELITE),
    DESERT_EASY(Varbits.DIARY_DESERT_EASY, 5, "Desert", Difficulty.EASY),
    DESERT_MEDIUM(Varbits.DIARY_DESERT_MEDIUM, 5, "Desert", Difficulty.MEDIUM),
    DESERT_HARD(Varbits.DIARY_DESERT_HARD, 5, "Desert", Difficulty.HARD),
    DESERT_ELITE(Varbits.DIARY_DESERT_ELITE, 5, "Desert", Difficulty.ELITE),
    FALADOR_EASY(Varbits.DIARY_FALADOR_EASY, 2, "Falador", Difficulty.EASY),
    FALADOR_MEDIUM(Varbits.DIARY_FALADOR_MEDIUM, 2, "Falador", Difficulty.MEDIUM),
    FALADOR_HARD(Varbits.DIARY_FALADOR_HARD, 2, "Falador", Difficulty.HARD),
    FALADOR_ELITE(Varbits.DIARY_FALADOR_ELITE, 2, "Falador", Difficulty.ELITE),
    FREMENNIK_EASY(Varbits.DIARY_FREMENNIK_EASY, 3, "Fremennik", Difficulty.EASY),
    FREMENNIK_MEDIUM(Varbits.DIARY_FREMENNIK_MEDIUM, 3, "Fremennik", Difficulty.MEDIUM),
    FREMENNIK_HARD(Varbits.DIARY_FREMENNIK_HARD, 3, "Fremennik", Difficulty.HARD),
    FREMENNIK_ELITE(Varbits.DIARY_FREMENNIK_ELITE, 3, "Fremennik", Difficulty.ELITE),
    KANDARIN_EASY(Varbits.DIARY_KANDARIN_EASY, 4, "Kandarin", Difficulty.EASY),
    KANDARIN_MEDIUM(Varbits.DIARY_KANDARIN_MEDIUM, 4, "Kandarin", Difficulty.MEDIUM),
    KANDARIN_HARD(Varbits.DIARY_KANDARIN_HARD, 4, "Kandarin", Difficulty.HARD),
    KANDARIN_ELITE(Varbits.DIARY_KANDARIN_ELITE, 4, "Kandarin", Difficulty.ELITE),
    KARAMJA_EASY(Varbits.DIARY_KARAMJA_EASY, 0, "Karamja", Difficulty.EASY),
    KARAMJA_MEDIUM(Varbits.DIARY_KARAMJA_MEDIUM, 0, "Karamja", Difficulty.MEDIUM),
    KARAMJA_HARD(Varbits.DIARY_KARAMJA_HARD, 0, "Karamja", Difficulty.HARD),
    KARAMJA_ELITE(Varbits.DIARY_KARAMJA_ELITE, 0, "Karamja", Difficulty.ELITE),
    KOUREND_EASY(Varbits.DIARY_KOUREND_EASY, 11, "Kourend & Kebos", Difficulty.EASY),
    KOUREND_MEDIUM(Varbits.DIARY_KOUREND_MEDIUM, 11, "Kourend & Kebos", Difficulty.MEDIUM),
    KOUREND_HARD(Varbits.DIARY_KOUREND_HARD, 11, "Kourend & Kebos", Difficulty.HARD),
    KOUREND_ELITE(Varbits.DIARY_KOUREND_ELITE, 11, "Kourend & Kebos", Difficulty.ELITE),
    LUMBRIDGE_EASY(Varbits.DIARY_LUMBRIDGE_EASY, 6, "Lumbridge & Draynor", Difficulty.EASY),
    LUMBRIDGE_MEDIUM(Varbits.DIARY_LUMBRIDGE_MEDIUM, 6, "Lumbridge & Draynor", Difficulty.MEDIUM),
    LUMBRIDGE_HARD(Varbits.DIARY_LUMBRIDGE_HARD, 6, "Lumbridge & Draynor", Difficulty.HARD),
    LUMBRIDGE_ELITE(Varbits.DIARY_LUMBRIDGE_ELITE, 6, "Lumbridge & Draynor", Difficulty.ELITE),
    MORYTANIA_EASY(Varbits.DIARY_MORYTANIA_EASY, 7, "Morytania", Difficulty.EASY),
    MORYTANIA_MEDIUM(Varbits.DIARY_MORYTANIA_MEDIUM, 7, "Morytania", Difficulty.MEDIUM),
    MORYTANIA_HARD(Varbits.DIARY_MORYTANIA_HARD, 7, "Morytania", Difficulty.HARD),
    MORYTANIA_ELITE(Varbits.DIARY_MORYTANIA_ELITE, 7, "Morytania", Difficulty.ELITE),
    VARROCK_EASY(Varbits.DIARY_VARROCK_EASY, 8, "Varrock", Difficulty.EASY),
    VARROCK_MEDIUM(Varbits.DIARY_VARROCK_MEDIUM, 8, "Varrock", Difficulty.MEDIUM),
    VARROCK_HARD(Varbits.DIARY_VARROCK_HARD, 8, "Varrock", Difficulty.HARD),
    VARROCK_ELITE(Varbits.DIARY_VARROCK_ELITE, 8, "Varrock", Difficulty.ELITE),
    WESTERN_EASY(Varbits.DIARY_WESTERN_EASY, 10, "Western Provinces", Difficulty.EASY),
    WESTERN_MEDIUM(Varbits.DIARY_WESTERN_MEDIUM, 10, "Western Provinces", Difficulty.MEDIUM),
    WESTERN_HARD(Varbits.DIARY_WESTERN_HARD, 10, "Western Provinces", Difficulty.HARD),
    WESTERN_ELITE(Varbits.DIARY_WESTERN_ELITE, 10, "Western Provinces", Difficulty.ELITE),
    WILDERNESS_EASY(Varbits.DIARY_WILDERNESS_EASY, 9, "Wilderness", Difficulty.EASY),
    WILDERNESS_MEDIUM(Varbits.DIARY_WILDERNESS_MEDIUM, 9, "Wilderness", Difficulty.MEDIUM),
    WILDERNESS_HARD(Varbits.DIARY_WILDERNESS_HARD, 9, "Wilderness", Difficulty.HARD),
    WILDERNESS_ELITE(Varbits.DIARY_WILDERNESS_ELITE, 9, "Wilderness", Difficulty.ELITE);

    public static final Map<Integer, AchievementDiary> DIARIES = Collections.unmodifiableMap(
        Arrays.stream(values()).collect(Collectors.toMap(AchievementDiary::getId, Function.identity()))
    );

    @Varbit
    private final int id;
    private final int areaId;
    private final String area;
    private final Difficulty difficulty;

    public enum Difficulty {
        EASY,
        MEDIUM,
        HARD,
        ELITE;

        private final String displayName = this.name().charAt(0) + this.name().substring(1).toLowerCase();

        @Override
        public String toString() {
            return this.displayName;
        }
    }
}

package dinkplugin.domain;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum LeagueRelicTier {
    UNKNOWN(-1),
    ONE(0),
    TWO(750),
    THREE(1_500),
    FOUR(2_500),
    FIVE(5_000),
    SIX(8_000),
    SEVEN(16_000),
    EIGHT(25_000);

    /**
     * Points required to unlock a relic of a given tier.
     *
     * @see <a href="https://oldschool.runescape.wiki/w/Trailblazer_Reloaded_League/Relics">Wiki Reference</a>
     */
    private final int defaultPoints;

}

package dinkplugin.domain;

public enum AccountType {
    NORMAL,
    IRONMAN,
    ULTIMATE_IRONMAN,
    HARDCORE_IRONMAN,
    GROUP_IRONMAN,
    HARDCORE_GROUP_IRONMAN,
    UNRANKED_GROUP_IRONMAN;

    private static final AccountType[] TYPES = values();

    public boolean isHardcore() {
        return this == HARDCORE_IRONMAN || this == HARDCORE_GROUP_IRONMAN;
    }

    /**
     * @param varbitValue the value associated with {@link net.runelite.api.Varbits#ACCOUNT_TYPE}
     * @return the equivalent enum value
     */
    public static AccountType get(int varbitValue) {
        if (varbitValue < 0 || varbitValue >= TYPES.length) return null;
        return TYPES[varbitValue];
    }
}

package dinkplugin.domain;

/**
 * Designates whether deaths involve loss of items.
 */
public enum Danger {
    SAFE,
    DANGEROUS,
    EXCEPTIONAL // safe deaths that should be treated as special (e.g., bypass deathIgnoreSafe)
}

package dinkplugin.domain;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum ChatPrivacyMode {
    HIDE_NONE("Show All"),
    HIDE_SPLIT_PM("Hide Split PMs"),
    HIDE_ALL("Hide All");

    private final String displayName;

    @Override
    public String toString() {
        return this.displayName;
    }
}

package dinkplugin.domain;

import com.google.common.net.UrlEscapers;

public enum PlayerLookupService {
    NONE("None"),
    OSRS_HISCORE("OSRS HiScore"),
    CRYSTAL_MATH_LABS("Crystal Math Labs"),
    TEMPLE_OSRS("Temple OSRS"),
    WISE_OLD_MAN("Wise Old Man"),
    COLLECTION_LOG("CollectionLog.net");

    private final String name;

    PlayerLookupService(String name) {
        this.name = name;
    }

    public String getPlayerUrl(String playerName) {
        String escapedName = UrlEscapers.urlPathSegmentEscaper().escape(playerName);
        switch (this) {
            case OSRS_HISCORE:
                return "https://secure.runescape.com/m=hiscore_oldschool/hiscorepersonal?user1=" + escapedName;
            case WISE_OLD_MAN:
                return "https://wiseoldman.net/players/" + escapedName;
            case CRYSTAL_MATH_LABS:
                return "https://crystalmathlabs.com/track.php?player=" + escapedName;
            case TEMPLE_OSRS:
                return "https://templeosrs.com/player/overview.php?player=" + escapedName;
            case COLLECTION_LOG:
                return "https://collectionlog.net/log/" + escapedName;
            case NONE:
            default:
                return null;
        }
    }

    @Override
    public String toString() {
        return name;
    }
}

package dinkplugin.message.templating;

@FunctionalInterface
public interface Evaluable {
    String evaluate(boolean rich);
}

package dinkplugin.message.templating;

import lombok.Builder;
import lombok.Singular;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Map;
import java.util.Objects;

@Value
@Builder
public class Template implements Evaluable {
    @NotNull
    String template;

    @Singular
    Map<String, Evaluable> replacements;

    @Nullable
    String replacementBoundary; // e.g., "%"

    @Override
    public String evaluate(boolean rich) {
        if (replacementBoundary != null) {
            return evaluateFast(rich);
        }
        return evaluateSlow(rich);
    }

    private String evaluateSlow(boolean rich) {
        String message = template;
        for (Map.Entry<String, Evaluable> e : replacements.entrySet()) {
            message = message.replace(e.getKey(), e.getValue().evaluate(rich));
        }
        return message;
    }

    private String evaluateFast(boolean rich) {
        assert replacementBoundary != null;
        StringBuilder message = new StringBuilder(template);
        int i = message.indexOf(replacementBoundary);
        while (i != -1) {
            int next = message.indexOf(replacementBoundary, i + 1);
            if (next < 0) break;

            int endExclusive = next + 1;
            String key = message.substring(i, endExclusive);
            Evaluable replacement = replacements.get(key);
            if (replacement != null) {
                String evaluated = replacement.evaluate(rich);
                message.replace(i, endExclusive, evaluated);
                i = endExclusive + evaluated.length() - key.length();
            } else {
                i = next;
            }
        }
        return message.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Template)) return false;

        // custom equals/hashCode based on outputs (rather than inputs) for ease of testing notifiers
        Template other = (Template) o;
        return this.evaluate(false).equals(other.evaluate(false))
            && this.evaluate(true).equals(other.evaluate(true));
    }

    @Override
    public int hashCode() {
        return Objects.hash(this.evaluate(false), this.evaluate(true));
    }
}

package dinkplugin.message.templating;

import com.google.common.net.UrlEscapers;
import dinkplugin.message.Field;
import dinkplugin.message.templating.impl.JoiningReplacement;
import lombok.Value;
import lombok.experimental.UtilityClass;

import java.util.Arrays;

@UtilityClass
public class Replacements {

    public Evaluable ofText(String text) {
        return new Text(text);
    }

    public Evaluable ofLink(String text, String link) {
        return link != null ? new TextWithLink(text, link) : ofText(text);
    }

    public Evaluable ofWiki(String text, String searchPhrase) {
        return ofLink(text, "https://oldschool.runescape.wiki/w/Special:Search?search=" + UrlEscapers.urlPathSegmentEscaper().escape(searchPhrase));
    }

    public Evaluable ofWiki(String phrase) {
        return ofWiki(phrase, phrase);
    }

    public Evaluable ofBlock(String language, String content) {
        return new CodeBlock(language, content);
    }

    public Evaluable ofMultiple(String delim, Evaluable... components) {
        return JoiningReplacement.builder()
            .delimiter(delim)
            .components(Arrays.asList(components))
            .build();
    }

    @Value
    private static class Text implements Evaluable {
        String text;

        @Override
        public String evaluate(boolean rich) {
            return text;
        }
    }

    @Value
    private static class TextWithLink implements Evaluable {
        String text;
        String link;

        @Override
        public String evaluate(boolean rich) {
            return rich ? String.format("[%s](%s)", text, link) : text;
        }
    }

    @Value
    private static class CodeBlock implements Evaluable {
        String language;
        String text;

        @Override
        public String evaluate(boolean rich) {
            return rich ? Field.formatBlock(language, text) : text;
        }
    }

}

package dinkplugin.message.templating.impl;

import dinkplugin.message.templating.Evaluable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.jetbrains.annotations.Nullable;

@Data
@Setter(AccessLevel.PRIVATE)
@NoArgsConstructor
@AllArgsConstructor
public class SimpleReplacement implements Evaluable {

    private String value;

    @Nullable
    private String richValue;

    @Override
    public String evaluate(boolean rich) {
        return rich && richValue != null ? richValue : value;
    }

}

package dinkplugin.message.templating.impl;

import dinkplugin.message.templating.Evaluable;
import lombok.Builder;
import lombok.Singular;
import lombok.Value;

import java.util.Iterator;
import java.util.List;

@Value
@Builder
public class JoiningReplacement implements Evaluable {
    @Singular
    List<Evaluable> components;
    @Builder.Default
    String delimiter = "";

    @Override
    public String evaluate(boolean rich) {
        if (components.isEmpty())
            return "";

        StringBuilder sb = new StringBuilder();
        Iterator<Evaluable> it = components.iterator();
        sb.append(it.next().evaluate(rich));
        while (it.hasNext()) {
            sb.append(delimiter);
            sb.append(it.next().evaluate(rich));
        }
        return sb.toString();
    }
}

package dinkplugin.message;

import com.google.gson.annotations.JsonAdapter;
import dinkplugin.util.ColorAdapter;
import dinkplugin.util.InstantAdapter;
import lombok.Builder;
import lombok.Value;

import java.awt.Color;
import java.time.Instant;
import java.util.List;

/**
 * A rich embed object used for notifications.
 * <p>
 * Notifications build one big embed with the fields of this class from {@link NotificationBody}
 */
@Value
@Builder
public class Embed {
    // The max size of the image before we rescale it to fit Discords file upload limits https://discord.com/developers/docs/reference#uploading-files
    public static final int MAX_IMAGE_SIZE = 8_000_000; // 8MB
    public static final int MAX_TITLE_LENGTH = 256;
    public static final int MAX_DESCRIPTION_LENGTH = 4096;
    public static final int MAX_FOOTER_LENGTH = 2048;
    public static final int MAX_EMBEDS = 10;

    /**
     * Filled in with the title of {@link NotificationBody}.
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/title.html">Example</a>
     */
    String title;

    /**
     * Includes the text of the notifier (e.g., {@link NotificationBody#getText()} is "Forsen has levelled Attack to 100")
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/description.html">Example</a>
     */
    String description;

    /**
     * Author of the embed object.
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/author.html">Example</a>
     */
    Author author;

    /**
     * Color trim of the rich embed
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/color.html">Example</a>
     */
    @JsonAdapter(ColorAdapter.class)
    Color color;

    /**
     * Embedded image.
     * <p>
     * Typically, this contains the screenshot of the notification, but can also be an item image.
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/image.html">Example</a>
     */
    UrlEmbed image;

    /**
     * Filled in with the notification's icon: {@link NotificationType#getThumbnail()}
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/thumbnail.html">Example</a>
     */
    UrlEmbed thumbnail;

    /**
     * Contains extra notifier-specific fields.
     * <p>
     * For example, the loot notifier contains a field with the total value of the loot
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/fields.html">Example</a>
     */
    List<Field> fields;

    /**
     * Embed footer.
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/footer.html">Example</a>
     */
    Footer footer;

    /**
     * Timestamp at the bottom of the embed object, serialized to long.
     *
     * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/timestamp.html">Example</a>
     */
    @JsonAdapter(InstantAdapter.class)
    Instant timestamp;

    /**
     * Helper function to construct a simple embed that only contains an image
     *
     * @param url the url of the image
     * @return embed object
     */
    public static Embed ofImage(String url) {
        return Embed.builder()
            .image(new UrlEmbed(url))
            .build();
    }

    @Value
    public static class UrlEmbed {
        String url;
    }
}

package dinkplugin.message;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

import static dinkplugin.util.Utils.WIKI_IMG_BASE_URL;

@Getter
@RequiredArgsConstructor
public enum NotificationType {
    CLUE("Clue Scroll", "clueImage.png", WIKI_IMG_BASE_URL + "Clue_scroll_%28Song_of_the_Elves%29.png"),
    COLLECTION("Collection Log", "collectionImage.png", WIKI_IMG_BASE_URL + "Collection_log.png"),
    DEATH("Player Death", "deathImage.png", WIKI_IMG_BASE_URL + "Items_kept_on_death.png"),
    LEVEL("Level Up", "levelImage.png", WIKI_IMG_BASE_URL + "Stats_icon.png"),
    LOOT("Loot Drop", "lootImage.png", WIKI_IMG_BASE_URL + "Rare_drop_table.png"),
    PET("Pet Obtained", "petImage.png", WIKI_IMG_BASE_URL + "Call_follower.png"),
    QUEST("Quest Completed", "questImage.png", WIKI_IMG_BASE_URL + "Quest_point_icon.png"),
    SLAYER("Slayer Task", "slayerImage.png", WIKI_IMG_BASE_URL + "Slayer_helmet_(i).png"),
    SPEEDRUN("Quest Speedrunning", "speedrunImage.png", WIKI_IMG_BASE_URL + "Giant_stopwatch.png"),
    KILL_COUNT("Completion Count", "killCountImage.png", WIKI_IMG_BASE_URL + "Enchanted_gem.png"),
    COMBAT_ACHIEVEMENT("Combat Achievement", "combatTaskImage.png", WIKI_IMG_BASE_URL + "Combat_achievements.png"),
    ACHIEVEMENT_DIARY("Achievement Diary", "achievementDiaryImage.png", WIKI_IMG_BASE_URL + "Achievement_Diaries_icon.png"),
    BARBARIAN_ASSAULT_GAMBLE("Barbarian Assault Gamble", "baGambleImage.png", WIKI_IMG_BASE_URL + "Barbarian_Assault_logo.jpg"),
    PLAYER_KILL("Player Kill", "playerKillImage.png", WIKI_IMG_BASE_URL + "Skull_(status)_icon.png"),
    GROUP_STORAGE("Group Shared Storage", "groupStorage.png", WIKI_IMG_BASE_URL + "Coins_10000.png"),
    GRAND_EXCHANGE("Grand Exchange", "grandExchange.png", WIKI_IMG_BASE_URL + "Grand_Exchange_icon.png"),
    LEAGUES_AREA("Area Unlocked", "leaguesArea.png", WIKI_IMG_BASE_URL + "Raging_Echoes_League_-_%3F_Relic.png"),
    LEAGUES_MASTERY("Mastery Unlocked", "leaguesMastery.png", WIKI_IMG_BASE_URL + "Raging_Echoes_League_combat_masteries_icon.png"),
    LEAGUES_RELIC("Relic Chosen", "leaguesRelic.png", WIKI_IMG_BASE_URL + "Raging_Echoes_League_relic_icon_-_detail.png"),
    LEAGUES_TASK("Task Completed", "leaguesTask.png", WIKI_IMG_BASE_URL + "Raging_Echoes_League_icon.png"),
    LOGIN("Player Login", "login.png", WIKI_IMG_BASE_URL + "Prop_sword.png"),
    LOGOUT("Player Logout", "logout.png", WIKI_IMG_BASE_URL + "Prop_sword.png"),
    TRADE("Player Trade", "trade.png", WIKI_IMG_BASE_URL + "Inventory.png"),
    CHAT("Chat Notification", "chat.png", WIKI_IMG_BASE_URL + "Toggle_Chat_effects.png"),
    XP_MILESTONE("XP Milestone", "xpImage.png", WIKI_IMG_BASE_URL + "Lamp.png"),
    EXTERNAL_PLUGIN("External Plugin", "externalImage.png", "https://raw.githubusercontent.com/runelite/runelite/refs/heads/master/runelite-client/src/main/resources/net/runelite/client/plugins/config/plugin_hub_icon.png");

    private final String title;

    /**
     * Name of the screenshot file
     */
    private final String screenshot;

    /**
     * Link to the notifier icon
     */
    private final String thumbnail;

}

package dinkplugin.message;

import com.google.gson.annotations.SerializedName;
import lombok.Builder;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Sends along a small customizable snippet & icon at the bottom of the embed
 *
 * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/footer.html">Example</a>
 */
@Value
@Builder
public class Footer {
    @NotNull
    String text;

    @Nullable
    @SerializedName("icon_url")
    String iconUrl;
}

package dinkplugin.message;

import com.google.gson.annotations.SerializedName;
import lombok.Builder;
import lombok.Value;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * The top block of our rich Discord embed, describing the RS user
 *
 * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/author.html">Example</a>
 */
@Value
@Builder
public class Author {
    /**
     * Name of the user the webhook is sent for
     */
    @NotNull
    String name;

    /**
     * Icon of the user, auto filled with your Runelite chat badge (e.g. Ironman badge or Hardcore Ironman badge)
     */
    @Nullable
    @SerializedName("icon_url")
    String iconUrl;

    /**
     * Makes name a href and opens a browser with the url when clicked
     */
    @Nullable
    String url;
}

package dinkplugin.message;

import com.google.gson.annotations.SerializedName;
import dinkplugin.DinkPluginConfig;
import dinkplugin.domain.AccountType;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.NotificationData;
import dinkplugin.util.DiscordProfile;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.With;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.awt.Image;
import java.util.LinkedList;
import java.util.List;

@Value
@With
@Builder(toBuilder = true)
@AllArgsConstructor
public class NotificationBody<T extends NotificationData> {

    static final int MAX_THREAD_NAME_LENGTH = 100; // not explicitly documented by Discord

    /*
     * Dink fields
     */
    @NotNull
    NotificationType type;
    String playerName;
    AccountType accountType;
    String dinkAccountHash;
    @Nullable
    String clanName;
    @Nullable
    String groupIronClanName;
    boolean seasonalWorld;
    @Nullable
    Integer world;
    @Nullable
    Integer regionId;
    @Nullable
    T extra;
    @NotNull
    @EqualsAndHashCode.Include
    transient Template text;

    /*
     * Discord fields
     */

    /**
     * Information about the current discord user, acquired via RPC (handled by base RuneLite).
     * <p>
     * This is only sent if {@link DinkPluginConfig#sendDiscordUser()} is enabled.
     * While this field is not used by Discord, it can be useful for custom webhook handlers that forward to Discord.
     */
    @Nullable
    DiscordProfile discordUser;

    /**
     * Filled in with the text of the notifier (e.g., {@link #getText()} is "Forsen has levelled Attack to 100")
     * <p>
     * This is done by {@link DiscordMessageHandler#createMessage} if {@link dinkplugin.DinkPluginConfig#discordRichEmbeds()} is disabled.
     */
    @Nullable
    @SerializedName("content")
    String computedDiscordContent;

    /**
     * An optional title to override that of {@link NotificationType#getThumbnail}
     * within the embed constructed by {@link DiscordMessageHandler#createMessage}
     */
    @Nullable
    @EqualsAndHashCode.Include
    transient String customTitle;

    /**
     * An optional footer text to override that of {@link DinkPluginConfig#embedFooterText}
     * within the embed constructed by {@link DiscordMessageHandler#createMessage}
     */
    @Nullable
    @EqualsAndHashCode.Include
    transient String customFooter;

    /**
     * An optional thumbnail to override that of {@link NotificationType#getThumbnail}
     * within the embed constructed by {@link DiscordMessageHandler#createMessage}
     */
    @Nullable
    @EqualsAndHashCode.Exclude
    transient String thumbnailUrl;

    @Builder.Default
    List<Embed> embeds = new LinkedList<>();

    /**
     * The thread name; must only be specified for forum channels when thread_id is not present
     *
     * @see #MAX_THREAD_NAME_LENGTH
     */
    @Nullable
    @SerializedName("thread_name")
    String threadName;

    /**
     * The IDs of the set of tags that have been applied to a thread in a GUILD_FORUM or a GUILD_MEDIA channel
     */
    @Nullable
    @SerializedName("applied_tags")
    Long[] appliedTags;

    /**
     * An optional screenshot to use, instead of capturing one from {@link DiscordMessageHandler}
     */
    @Nullable
    @EqualsAndHashCode.Exclude
    transient Image screenshotOverride;

}

package dinkplugin.message;

import dinkplugin.util.MathUtils;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.apache.commons.lang3.StringUtils;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

/**
 * Describes a Discord rich embed field
 *
 * @see <a href="https://birdie0.github.io/discord-webhooks-guide/structure/embed/fields.html">Example</a>
 */
@Data
@Setter(AccessLevel.PRIVATE)
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Field {
    private @NotNull String name;
    private @NotNull String value;
    private @Nullable Boolean inline;

    public Field(String name, String value) {
        this(name, value, true);
    }

    public static Field ofLuck(double probability, int kTrials) {
        return ofLuck(MathUtils.cumulativeGeometric(probability, kTrials));
    }

    public static Field ofLuck(double geomCdf) {
        String percentile = geomCdf < 0.5
            ? "Top " + MathUtils.formatPercentage(geomCdf, 2) + " (Lucky)"
            : "Bottom " + MathUtils.formatPercentage(1 - geomCdf, 2) + " (Unlucky)";
        return new Field("Luck", Field.formatBlock("", percentile));
    }

    public static String formatBlock(String codeBlockLanguage, String content) {
        return String.format("```%s\n%s\n```", StringUtils.defaultString(codeBlockLanguage), content);
    }

    public static String formatProgress(int completed, int total) {
        assert total != 0;
        double percent = 100.0 * completed / total;
        return Field.formatBlock("", String.format("%d/%d (%.1f%%)", completed, total, percent));
    }

    public static String formatProbability(double p) {
        String percentage = MathUtils.formatPercentage(p, 3);
        double denominator = 1 / p;
        return Field.formatBlock("", String.format("1 in %.1f (%s)", denominator, percentage));
    }
}

package dinkplugin.message;

import com.google.gson.Gson;
import dinkplugin.DinkPlugin;
import dinkplugin.DinkPluginConfig;
import dinkplugin.domain.PlayerLookupService;
import dinkplugin.domain.SeasonalPolicy;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.NotificationData;
import dinkplugin.util.ConfigUtil;
import dinkplugin.util.DiscordProfile;
import dinkplugin.util.Utils;
import dinkplugin.util.WorldUtils;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WorldType;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.discord.DiscordService;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageCapture;
import net.runelite.client.util.ImageUtil;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.HttpUrl;
import okhttp3.Interceptor;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.annotations.VisibleForTesting;

import javax.imageio.ImageIO;
import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;
import java.util.stream.Collectors;

@Slf4j
@Singleton
public class DiscordMessageHandler {

    private final Gson gson;
    private final Client client;
    private final DrawManager drawManager;
    private final OkHttpClient httpClient;
    private final DinkPluginConfig config;
    private final ScheduledExecutorService executor;
    private final ClientThread clientThread;
    private final DiscordService discordService;
    private final ImageCapture imageCapture;

    @Inject
    @VisibleForTesting
    public DiscordMessageHandler(Gson gson, Client client, DrawManager drawManager, OkHttpClient httpClient, DinkPluginConfig config, ScheduledExecutorService executor, ClientThread clientThread, DiscordService discordService, ImageCapture imageCapture) {
        this.gson = gson;
        this.client = client;
        this.drawManager = drawManager;
        this.config = config;
        this.executor = executor;
        this.clientThread = clientThread;
        this.discordService = discordService;
        this.imageCapture = imageCapture;
        this.httpClient = httpClient.newBuilder()
            .addInterceptor(chain -> {
                Request request = chain.request().newBuilder()
                    .header("User-Agent", DinkPlugin.USER_AGENT)
                    .build();
                Interceptor.Chain updatedChain = chain;
                // Allow longer timeout when writing a screenshot file to overcome slow internet speeds
                if (request.body() instanceof MultipartBody && Utils.hasImage((MultipartBody) request.body())) {
                    updatedChain = chain.withWriteTimeout(Math.max(config.imageWriteTimeout(), 0), TimeUnit.SECONDS);
                }
                return updatedChain.proceed(request);
            })
            .addInterceptor(chain -> {
                Request request = chain.request();
                Response response = chain.proceed(request);
                String method = request.method();
                // http status code 307 can be useful for custom webhook handlers to redirect requests as seen in https://github.com/pajlads/DinkPlugin/issues/482
                // however, runelite uses okhttp 3.14.9, which does not follow RFC 7231 for code 307 (or RFC 7238 for code 308).
                // while this was fixed in okhttp 4.6.0 (released on 2020-04-28), we need this interceptor to patch this issue for now
                if (!method.equals("GET") && !method.equals("HEAD")) {
                    int code = response.code();
                    if (code == 307 || code == 308) {
                        String redirectUrl = response.header("Location");
                        if (redirectUrl != null) {
                            Request updatedRequest = request.newBuilder().url(redirectUrl).build();
                            return chain.proceed(updatedRequest);
                        }
                    }
                }
                return response;
            })
            .build();
    }

    public void createMessage(String webhookUrl, boolean sendImage, @NonNull NotificationBody<?> inputBody) {
        if (StringUtils.isBlank(webhookUrl)) return;

        Collection<HttpUrl> urlList = Arrays.stream(StringUtils.split(webhookUrl, '\n'))
            .filter(StringUtils::isNotBlank)
            .map(HttpUrl::parse)
            .filter(Objects::nonNull)
            .filter(url -> !"example.com".equalsIgnoreCase(url.host()))
            .collect(Collectors.toList());
        if (urlList.isEmpty()) return;

        NotificationBody<?> mBody = enrichBody(inputBody, sendImage);
        if (sendImage) {
            // optionally hide chat for privacy in screenshot
            captureScreenshot(config.screenshotScale() / 100.0, mBody.getScreenshotOverride())
                .thenApply(image ->
                    RequestBody.create(MediaType.parse("image/" + image.getKey()), image.getValue())
                )
                .exceptionally(e -> {
                    log.warn("There was an error creating bytes from captured image", e);
                    return null;
                })
                .thenAccept(image -> sendToMultiple(urlList, mBody, image));
        } else {
            sendToMultiple(urlList, mBody, null);
        }
    }

    private void sendToMultiple(Collection<HttpUrl> urls, NotificationBody<?> body, @Nullable RequestBody image) {
        urls.forEach(url -> executor.execute(() -> sendMessage(url, injectThreadName(url, body, false), image, 0)));
    }

    private void sendMessage(HttpUrl url, NotificationBody<?> mBody, @Nullable RequestBody image, int attempt) {
        BiConsumer<NotificationBody<?>, Throwable> retry = (body, e) -> {
            log.trace(String.format("Failed to send webhook message to %s on attempt %d", url, attempt), e);

            if (attempt == 0) {
                log.warn("There was an error sending the webhook message", e);
            }

            int maxRetries = config.maxRetries();
            if (attempt < maxRetries) {
                long baseDelay = config.baseRetryDelay();
                if (baseDelay > 0) {
                    long delay = baseDelay * (1L << Math.min(attempt, 16)); // exponential backoff
                    executor.schedule(() -> sendMessage(url, body, image, attempt + 1), delay, TimeUnit.MILLISECONDS);
                    log.debug("Scheduled webhook message for retry in {} milliseconds", delay);
                } else {
                    log.debug("Skipping retry attempts for failed webhook since base delay is not positive");
                }
            } else if (maxRetries > 0) {
                log.warn("Exhausted retry attempts when sending the webhook message", e);
            } else {
                log.debug("Skipping retry attempts for failed webhook since max retries is not positive");
            }
        };

        Request request = new Request.Builder()
            .url(url)
            .post(createBody(mBody, image))
            .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                retry.accept(mBody, e);
            }

            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                if (response.isSuccessful()) {
                    log.trace("Successfully sent webhook message to {} after {} attempts", url, attempt + 1);

                    if (response.body() != null) {
                        response.close();
                    }
                } else {
                    String body = response.body() != null ? response.body().string() : null;

                    // Update thread_name to comply with discord forum channel specification
                    if (response.code() == 400 && "application/json".equals(response.header("Content-Type"))) {
                        DiscordErrorMessage error = gson.fromJson(body, DiscordErrorMessage.class);

                        // "Webhooks posted to forum channels must have a thread_name or thread_id"
                        if (error.getCode() == 220001) {
                            retry.accept(
                                injectThreadName(url, mBody, true),
                                new RuntimeException(error.getMessage())
                            );
                            return;
                        }

                        // "Webhooks can only create threads in forum channels"
                        if (error.getCode() == 220003) {
                            retry.accept(mBody.withThreadName(null), new RuntimeException(error.getMessage()));
                            return;
                        }
                    }

                    // retry with no change to NotificationBody
                    retry.accept(mBody, new RuntimeException(String.format("Received unsuccessful http response: %d - %s - %s", response.code(), response.message(), body)));
                }
            }
        });
    }

    private NotificationBody<?> enrichBody(NotificationBody<?> mBody, boolean sendImage) {
        if (mBody.getPlayerName() == null) {
            mBody = mBody.withPlayerName(Utils.getPlayerName(client));
        }

        if (mBody.getAccountType() == null) {
            mBody = mBody.withAccountType(Utils.getAccountType(client));
        }

        if (mBody.getDinkAccountHash() == null) {
            long id = client.getAccountHash();
            if (id != -1) {
                mBody = mBody.withDinkAccountHash(Utils.dinkHash(id));
            }
        }

        if (config.seasonalPolicy() != SeasonalPolicy.REJECT && !mBody.isSeasonalWorld() && client.getWorldType().contains(WorldType.SEASONAL)) {
            mBody = mBody.withSeasonalWorld(true);
        }

        NotificationBody.NotificationBodyBuilder<?> builder = mBody.toBuilder();

        if (config.includeLocation()) {
            if (mBody.getWorld() == null) {
                builder.world(client.getWorld());
            }

            if (mBody.getRegionId() == null) {
                var loc = WorldUtils.getLocation(client);
                if (loc != null) {
                    builder.regionId(loc.getRegionID());
                }
            }
        }

        if (config.sendDiscordUser()) {
            builder.discordUser(DiscordProfile.of(discordService.getCurrentUser()));
        }

        if (config.sendClanName()) {
            ClanChannel clan = client.getClanChannel(ClanID.CLAN);
            if (clan != null) {
                builder.clanName(clan.getName());
            }
        }

        if (config.sendGroupIronClanName()) {
            ClanChannel gim = client.getClanChannel(ClanID.GROUP_IRONMAN);
            if (gim != null) {
                builder.groupIronClanName(gim.getName());
            }
        }

        if (config.discordRichEmbeds()) {
            builder.embeds(computeEmbeds(mBody, sendImage, config));
        } else {
            builder.computedDiscordContent(mBody.getText().evaluate(false));
        }

        return builder.build();
    }

    private NotificationBody<?> injectThreadName(HttpUrl url, NotificationBody<?> mBody, boolean force) {
        Collection<String> queryParams = url.queryParameterNames();
        if (force || (queryParams.contains("forum") && !queryParams.contains("thread_id"))) {
            String type = mBody.isSeasonalWorld() ? "Seasonal - " + mBody.getType().getTitle() : mBody.getType().getTitle();
            String threadName = Template.builder()
                .template(config.threadNameTemplate())
                .replacementBoundary("%")
                .replacement("%TYPE%", Replacements.ofText(type))
                .replacement("%MESSAGE%", mBody.getText())
                .replacement("%USERNAME%", Replacements.ofText(mBody.getPlayerName()))
                .build()
                .evaluate(false);
            Long[] appliedTags = ConfigUtil.readDelimited(url.queryParameter("applied_tags"))
                .map(tag -> {
                    try {
                        return Long.parseLong(tag);
                    } catch (NumberFormatException ignored) {
                        return null;
                    }
                })
                .filter(Objects::nonNull)
                .toArray(Long[]::new);
            return mBody.toBuilder()
                .threadName(Utils.truncate(StringUtils.normalizeSpace(threadName), NotificationBody.MAX_THREAD_NAME_LENGTH))
                .appliedTags(appliedTags)
                .build();
        }
        return mBody;
    }

    private MultipartBody createBody(NotificationBody<?> mBody, @Nullable RequestBody image) {
        MultipartBody.Builder requestBody = new MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart("payload_json", gson.toJson(mBody));
        if (image != null) {
            String screenshotFileName = mBody.getType().getScreenshot();
            requestBody.addFormDataPart("file", screenshotFileName, image);
        }
        return requestBody.build();
    }

    /**
     * Captures the next frame and applies the specified rescaling
     * while abiding by {@link Embed#MAX_IMAGE_SIZE}.
     *
     * @param scalePercent {@link DinkPluginConfig#screenshotScale()} divided by 100.0
     * @param screenshotOverride an optional image to use instead of grabbing a frame from {@link DrawManager}
     * @return future of the image byte array by the image format name
     * @apiNote scalePercent should be in (0, 1]
     * @implNote the image format is either "png" (lossless) or "jpeg" (lossy), both of which can be used in MIME type
     */
    private CompletableFuture<Map.Entry<String, byte[]>> captureScreenshot(double scalePercent, @Nullable Image screenshotOverride) {
        CompletableFuture<Image> future = new CompletableFuture<>();
        if (screenshotOverride != null) {
            future.complete(screenshotOverride);
        } else {
            Utils.captureScreenshot(client, clientThread, drawManager, imageCapture, executor, config, future::complete);
        }
        return future.thenApplyAsync(ImageUtil::bufferedImageFromImage, executor)
            .thenApply(input -> Utils.rescale(input, scalePercent))
            .thenApply(image -> {
                try {
                    String format = "png"; // lossless
                    return Pair.of(format, Utils.convertImageToByteArray(image, format));
                } catch (IOException e) {
                    throw new CompletionException("Could not convert image to byte array", e);
                }
            })
            .thenApply(pair -> {
                byte[] bytes = pair.getValue();
                int n = bytes.length;
                if (n <= Embed.MAX_IMAGE_SIZE)
                    return pair; // already compliant; no further rescale necessary

                // calculate scale factor to comply with MAX_IMAGE_SIZE
                double factor = Math.sqrt(1.0 * Embed.MAX_IMAGE_SIZE / n);

                // bytes => original image => rescaled image => updated bytes
                try (InputStream is = new ByteArrayInputStream(bytes)) {
                    String format = "jpeg"; // lossy
                    BufferedImage rescaled = Utils.rescale(ImageIO.read(is), factor);
                    return Pair.of(format, Utils.convertImageToByteArray(rescaled, format));
                } catch (Exception e) {
                    throw new CompletionException("Failed to resize image below Discord size limit", e);
                }
            });
    }

    private static List<Embed> computeEmbeds(@NotNull NotificationBody<?> body, boolean screenshot, DinkPluginConfig config) {
        NotificationType type = body.getType();
        NotificationData extra = body.getExtra();
        String footerText = body.getCustomFooter() != null ? body.getCustomFooter() : config.embedFooterText();
        String footerIcon = config.embedFooterIcon();
        PlayerLookupService playerLookupService = config.playerLookupService();

        Author author = Author.builder()
            .name(body.getPlayerName())
            .url(playerLookupService.getPlayerUrl(body.getPlayerName()))
            .iconUrl(Utils.getChatBadge(body.getAccountType(), body.isSeasonalWorld()))
            .build();
        Footer footer = StringUtils.isBlank(footerText) ? null : Footer.builder()
            .text(Utils.truncate(footerText, Embed.MAX_FOOTER_LENGTH))
            .iconUrl(StringUtils.isBlank(footerIcon) ? null : footerIcon)
            .build();
        String title = body.getCustomTitle() != null ? body.getCustomTitle() : type.getTitle();
        String thumbnail = body.getThumbnailUrl() != null
            ? body.getThumbnailUrl()
            : type.getThumbnail();

        List<Embed> embeds = new ArrayList<>(body.getEmbeds() != null ? body.getEmbeds().subList(0, Math.min(body.getEmbeds().size(), Embed.MAX_EMBEDS - 1)) : Collections.emptyList());
        embeds.add(0,
            Embed.builder()
                .author(author)
                .color(config.embedColor())
                .title(Utils.truncate(body.isSeasonalWorld() ? "[Seasonal] " + title : title, Embed.MAX_TITLE_LENGTH))
                .description(Utils.truncate(body.getText().evaluate(config.discordRichEmbeds()), Embed.MAX_DESCRIPTION_LENGTH))
                .image(screenshot ? new Embed.UrlEmbed("attachment://" + type.getScreenshot()) : null)
                .thumbnail(new Embed.UrlEmbed(thumbnail))
                .fields(extra != null ? extra.getFields() : Collections.emptyList())
                .footer(footer)
                .timestamp(footer != null ? Instant.now() : null)
                .build()
        );
        return embeds;
    }

}

package dinkplugin.message;

import lombok.AccessLevel;
import lombok.Data;
import lombok.Setter;

/**
 * @see <a href="https://discord.com/developers/docs/reference#error-messages">Error Message Format</a>
 */
@Data
@Setter(AccessLevel.PRIVATE)
class DiscordErrorMessage {
    /**
     * @see <a href="https://discord.com/developers/docs/topics/opcodes-and-status-codes#json">Possible Error Codes</a>
     */
    int code;
    String message;
}

package dinkplugin.util;

import com.google.gson.Gson;
import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.MockedTestBase;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.http.api.RuneLiteAPI;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mockito;

import java.util.OptionalDouble;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

abstract class AbstractRarityServiceTest extends MockedTestBase {
    private static final double DELTA = MathUtils.EPSILON;

    @Bind
    protected final Gson gson = RuneLiteAPI.GSON;

    @Bind
    protected final ItemManager itemManager = Mockito.mock(ItemManager.class);

    protected abstract AbstractRarityService getService();

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // default item mock
        Mockito.doAnswer(invocation -> {
            ItemComposition comp = mock(ItemComposition.class);
            when(comp.getMembersName()).thenReturn("?");
            when(comp.getNote()).thenReturn(-1);
            return comp;
        }).when(itemManager).getItemComposition(anyInt());
    }

    protected void test(String npcName, int itemId, int quantity, double expectedProbability) {
        OptionalDouble rarity = getService().getRarity(npcName, itemId, quantity);
        assertTrue(rarity.isPresent());
        assertEquals(expectedProbability, rarity.getAsDouble(), DELTA);
    }

    protected void mockItem(int id, String name, boolean noted) {
        ItemComposition item = mock(ItemComposition.class);
        when(item.getName()).thenReturn(name);
        when(item.getMembersName()).thenReturn(name);
        when(item.getNote()).thenReturn(noted ? 799 : -1);
        when(item.getLinkedNoteId()).thenReturn(noted ? id - 1 : id + 1);
        when(itemManager.getItemComposition(id)).thenReturn(item);
    }

    protected void mockItem(int id, String name) {
        this.mockItem(id, name, false);
    }
}

package dinkplugin.util;

import net.runelite.client.callback.ClientThread;

import java.util.function.BooleanSupplier;

public class BlockingClientThread extends ClientThread {
    @Override
    public void invoke(Runnable r) {
        r.run();
    }

    @Override
    public void invoke(BooleanSupplier r) {
        invokeSupplier(r);
    }

    @Override
    public void invokeLater(Runnable r) {
        r.run();
    }

    @Override
    public void invokeLater(BooleanSupplier r) {
        invokeSupplier(r);
    }

    @Override
    public void invokeAtTickEnd(Runnable r) {
        r.run();
    }

    private void invokeSupplier(BooleanSupplier r) {
        while (true) {
            if (r.getAsBoolean())
                break;
        }
    }
}

package dinkplugin.util;

import com.google.inject.testing.fieldbinder.Bind;
import lombok.Getter;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.util.OptionalDouble;

import static org.junit.jupiter.api.Assertions.assertFalse;

class RarityServiceTest extends AbstractRarityServiceTest {

    @Bind
    @Getter
    private final RarityService service = Mockito.spy(new RarityService(gson, itemManager));

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // actual item mocks
        mockItem(ItemID.DRAGON_SPEAR, "Dragon spear");
        mockItem(ItemID.DRAGON_AXE, "Dragon axe");
        mockItem(ItemID.SHARK, "Shark");
        mockItem(ItemID.SNAPE_GRASS, "Snape grass");
        mockItem(ItemID.GOBLIN_SKULL, "Goblin skull");
        mockItem(ItemID.COINS, "Coins");
        mockItem(ItemID.COINS_995, "Coins");
        mockItem(ItemID.ARMADYL_HILT, "Armadyl hilt");
        mockItem(ItemID.STEEL_ARROW, "Steel arrow");
        mockItem(ItemID.SILVER_ORE, "Silver ore");
        mockItem(ItemID.SILVER_ORE + 1, "Silver ore", true);
        mockItem(ItemID.UNCUT_RUBY, "Uncut ruby");
        mockItem(ItemID.ECUMENICAL_KEY, "Ecumenical key");
        mockItem(ItemID.DEATH_RUNE, "Death rune");
        mockItem(ItemID.SNAPE_GRASS_SEED, "Snape grass seed");
        mockItem(ItemID.DRAGONSTONE, "Dragonstone");
        mockItem(ItemID.ANCIENT_SHARD, "Ancient shard");
        mockItem(ItemID.LARRANS_KEY, "Larran's key");
        mockItem(ItemID.UNIDENTIFIED_RARE_FOSSIL, "Unidentified rare fossil");
        mockItem(ItemID.GRIMY_GUAM_LEAF, "Grimy guam leaf");
        mockItem(ItemID.DUST_BATTLESTAFF, "Dust battlestaff");
        mockItem(ItemID.GRIMY_AVANTOE, "Grimy avantoe");
        mockItem(ItemID.FIRE_TALISMAN, "Fire talisman");
        mockItem(ItemID.CLUE_SCROLL_ELITE, "Clue scroll (elite)");
        mockItem(ItemID.CLUE_SCROLL_ELITE_12157, "Clue scroll (elite)"); // wiki prefers this ID
        mockItem(ItemID.SUPERANTIPOISON2, "Superantipoison(2)");
        mockItem(ItemID.SUPERANTIPOISON3, "Superantipoison(3)");
    }

    @Test
    @DisplayName("Ensure accurate rarity for very rare drops")
    void testVeryRare() {
        test("Aberrant spectre", ItemID.DRAGON_SPEAR, 1, 1.0 / 139_810);
    }

    @Test
    @DisplayName("Ensure accurate rarity for rare drops")
    void testRare() {
        test("Dagannoth Supreme", ItemID.DRAGON_AXE, 1, 1.0 / 128);
    }

    @Test
    @DisplayName("Ensure accurate rarity for uncommon drops")
    void testUncommon() {
        test("Dagannoth Supreme", ItemID.SHARK, 5, 5.0 / 128);
    }

    @Test
    @DisplayName("Ensure accurate rarity for common drops")
    void testCommon() {
        test("Bree", ItemID.SNAPE_GRASS, 5, 7.0 / 127);
    }

    @Test
    @DisplayName("Ensure drops are de-duplicated across combat levels")
    void testCombatLevel() {
        test("Goblin", ItemID.GOBLIN_SKULL, 1, 1.0 / 4);
    }

    @Test
    @DisplayName("Ensure drop is matched despite which coin item variation is present")
    void testCoins() {
        test("Cave goblin miner", ItemID.COINS, 6, 1 / 6.4);
        test("Cave goblin miner", ItemID.COINS_995, 6, 1 / 6.4);
    }

    @Test
    @DisplayName("Ensure correct drop rate is found when an item has different rates for different quantities")
    void testSingleRepeated() {
        test("Gorak", ItemID.COINS, 475, 1.0 / 16);
    }

    @Test
    @DisplayName("Ensure drop is matched when NPC has a non-alphanumeric name")
    void testSpecialName() {
        test("Kree'arra", ItemID.ARMADYL_HILT, 1, 1.0 / 508);
    }

    @Test
    @DisplayName("Ensure drop is matched when quantity covers a range")
    void testRange() {
        test("Bree", ItemID.COINS, 1_469, 124.0 / 16_129);
    }

    @Test
    @DisplayName("Ensure probabilities are summed when multiple ranges apply")
    void testRangeRepeated() {
        test("Dagannoth Supreme", ItemID.STEEL_ARROW, 150, 1.0 / 1024 + 5.0 / 128);
    }

    @Test
    @DisplayName("Ensure correct range is used when there are multiple with non-overlapping domains")
    void testRangesExclusive() {
        test("Kree'arra", ItemID.COINS, 20_750, 1.25 / 127);
    }

    @Test
    @DisplayName("Treat noted items as un-noted in accordance with wiki item rendering")
    void testNoted() {
        test("Dagannoth Supreme", ItemID.SILVER_ORE + 1, 100, 1.0 / 1024);
    }

    @Test
    @DisplayName("Use standard drop rate when ring of wealth offers better drop rate")
    void testRingWealthMissing() {
        test("Dagannoth Supreme", ItemID.UNCUT_RUBY, 1, 1.0 / 182);
    }

    @Test
    @DisplayName("Use worst drop rate for ecumenical key assuming no Combat Achievements")
    void testEcumenical() {
        test("Gorak", ItemID.ECUMENICAL_KEY, 1, 1.0 / 60);
    }

    @Test
    @DisplayName("Ensure correct drop rate is calculated when multiple rolls are performed")
    void testMultipleRolls() {
        double p = 1.0 / 25;
        test("Vorkath", ItemID.DEATH_RUNE, 800, p * p);
        test("Vorkath", ItemID.DEATH_RUNE, 400, 2 * p * (1 - p));
    }

    @Test
    @DisplayName("Ensure accurate drop rate for rare seed table")
    void testSeeds() {
        test("Sarachnis", ItemID.SNAPE_GRASS_SEED, 5, 1.0 / 2_950);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for rate drop table")
    void testRareTable() {
        test("Dagannoth Supreme", ItemID.DRAGONSTONE, 1, 1.0 / 1_024);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for catacombs table")
    void testCatacombs() {
        test("Hellhound", ItemID.ANCIENT_SHARD, 1, 1.0 / 256);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for wilderness slayer table")
    void testSlayerWildy() {
        test("Moss giant", ItemID.LARRANS_KEY, 1, 1.0 / 533);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for fossil table")
    void testFossil() {
        test("Lobstrosity", ItemID.UNIDENTIFIED_RARE_FOSSIL, 1, 1.0 / 700);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for herb table")
    void testHerb() {
        test("Hydra", ItemID.GRIMY_GUAM_LEAF, 1, 1.0 / 128);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for superior slayer table")
    void testSuperiorSlayer() {
        test("Cockathrice", ItemID.DUST_BATTLESTAFF, 1, 1.0 / 341);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for useful herb table")
    void testHerbUseful() {
        test("Rune dragon", ItemID.GRIMY_AVANTOE, 1, 1 / 50.8);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for talisman table")
    void testTalisman() {
        test("Wallasalki", ItemID.FIRE_TALISMAN, 1, 1.0 / 112);
    }

    @Test
    @DisplayName("Ensure accurate drop rate for clue scrolls")
    void testClueScroll() {
        test("Dagannoth Supreme", ItemID.CLUE_SCROLL_ELITE, 1, 1.0 / 750);
    }

    @Test
    @DisplayName("Drop should not match if quantity is wrong")
    void testInvalidQuantity() {
        OptionalDouble rarity = service.getRarity("Dagannoth Supreme", ItemID.SILVER_ORE, 42);
        assertFalse(rarity.isPresent());
    }

    @Test
    @DisplayName("Ensure accurate drop rate for 'Nothing'")
    void testNothing() {
        test("Air elemental", -1, 0, 1 / 128.2);
    }

    @Test
    @DisplayName("Ignore 'Nothing' if an 'Always' drop is present")
    void testFakeNothing() {
        // bones are always dropped, so loot tracker kc is correct, even though wiki includes a 'Nothing' entry
        OptionalDouble rarity = service.getRarity("Afflicted", -1, 0);
        assertFalse(rarity.isPresent());
    }

    @Test
    @DisplayName("Ensure monster name excludes any parenthetical suffix from the wiki")
    void testSuffix() {
        // RarityCalculator removes wiki's (monster) suffix: https://oldschool.runescape.wiki/w/TzHaar-Mej_(monster)
        test("TzHaar-Mej", ItemID.OBSIDIAN_CAPE, 1, 1.0 / 4_096);
    }

    @Test
    @DisplayName("Ensure accurate rate when monster can drop multiple variations of the same item")
    void testVariations() {
        test("Tribesman", ItemID.SUPERANTIPOISON2, 1, 1.0 / 46);
        test("Tribesman", ItemID.SUPERANTIPOISON3, 1, 1.0 / 138);
    }

}

package dinkplugin.util;

import lombok.SneakyThrows;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class BlockingExecutor implements ScheduledExecutorService {
    private final ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor();

    @Override
    public ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) {
        return schedule(() -> {
            command.run();
            return null;
        }, delay, unit);
    }

    @Override
    @SneakyThrows
    public <V> ScheduledFuture<V> schedule(Callable<V> callable, long delay, TimeUnit unit) {
        ScheduledFuture<V> fut = exec.schedule(callable, delay, unit);
        fut.get();
        return fut;
    }

    @Override
    public ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void shutdown() {
        exec.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        return exec.shutdownNow();
    }

    @Override
    public boolean isShutdown() {
        return exec.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return exec.isTerminated();
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return exec.awaitTermination(timeout, unit);
    }

    @Override
    @SneakyThrows
    public <T> Future<T> submit(Callable<T> task) {
        Future<T> fut = exec.submit(task);
        fut.get();
        return fut;
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return submit(() -> {
            task.run();
            return result;
        });
    }

    @Override
    public Future<?> submit(Runnable task) {
        return submit(task, null);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return exec.invokeAll(tasks);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return exec.invokeAll(tasks, timeout, unit);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException {
        return exec.invokeAny(tasks);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        return exec.invokeAny(tasks);
    }

    @Override
    public void execute(Runnable command) {
        submit(command);
    }
}

package dinkplugin.util;

import lombok.experimental.UtilityClass;

import javax.imageio.ImageIO;
import java.awt.Color;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.io.InputStream;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

@UtilityClass
public class TestImageUtil {

    public Image getExample() {
        try (InputStream inputStream = TestImageUtil.class.getResourceAsStream("/screenshot.png")) {
            if (inputStream != null)
                return ImageIO.read(inputStream);
        } catch (Exception ignored) {
        }
        return random(960, 640);
    }

    public Image random(final int width, final int height) {
        Random rand = ThreadLocalRandom.current();
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                image.setRGB(x, y, new Color(rand.nextFloat(), rand.nextFloat(), rand.nextFloat()).getRGB());
            }
        }
        return image;
    }

}

package dinkplugin.util;

import com.google.inject.testing.fieldbinder.Bind;
import lombok.Getter;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import static org.junit.jupiter.api.Assertions.assertFalse;

class ThievingServiceTest extends AbstractRarityServiceTest {

    @Bind
    @Getter
    private final ThievingService service = Mockito.spy(new ThievingService(gson, itemManager));

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // item mocks
        mockItem(ItemID.BLOOD_SHARD, "Blood shard");
        mockItem(ItemID.ENHANCED_CRYSTAL_TELEPORT_SEED, "Enhanced crystal teleport seed");
        mockItem(ItemID.UNCUT_DIAMOND, "Uncut diamond");
        mockItem(ItemID.CLUE_SCROLL_EASY, "Clue scroll (easy)");
        mockItem(ItemID.CLUE_SCROLL_EASY_2711, "Clue scroll (easy)");
        mockItem(ItemID.CLUE_SCROLL_MEDIUM, "Clue scroll (medium)");
        mockItem(ItemID.CLUE_SCROLL_MEDIUM_2809, "Clue scroll (medium)");
        mockItem(ItemID.CLUE_SCROLL_HARD, "Clue scroll (hard)");
        mockItem(ItemID.CLUE_SCROLL_HARD_3560, "Clue scroll (hard)");
        mockItem(ItemID.CLUE_SCROLL_ELITE, "Clue scroll (elite)");
        mockItem(ItemID.CLUE_SCROLL_ELITE_12157, "Clue scroll (elite)");
        mockItem(ItemID.CLUE_SCROLL_ELITE_12075, "Clue scroll (elite)");
        mockItem(ItemID.HAM_CLOAK, "Ham cloak");
        mockItem(ItemID.HAM_BOOTS, "Ham boots");
        mockItem(ItemID.SNAPE_GRASS_SEED, "Snape grass seed");
        mockItem(ItemID.SNAPDRAGON_SEED, "Snapdragon seed");
    }

    @Test
    void testFarmer() {
        test("Master Farmer", ItemID.SNAPE_GRASS_SEED, 1, 1.0 / 260);
        test("Master Farmer", ItemID.SNAPDRAGON_SEED, 1, 1.0 / 2083);

        assertFalse(service.getRarity("Farmer", ItemID.SNAPDRAGON_SEED, 1).isPresent());
    }

    @Test
    void testHam() {
        test("H.A.M. Member", ItemID.HAM_CLOAK, 1, 1.0 / 100);
        test("H.A.M. Member", ItemID.HAM_BOOTS, 1, 1.0 / 100);

        assertFalse(service.getRarity("Thief", ItemID.HAM_BOOTS, 1).isPresent());
    }

    @Test
    void testCitizen() {
        test("Wealthy citizen", ItemID.CLUE_SCROLL_EASY, 1, 1.0 / 85);

        assertFalse(service.getRarity("Wealthy citizen", ItemID.CLUE_SCROLL_HARD, 1).isPresent());
    }

    @Test
    void testPaladin() {
        test("Paladin", ItemID.CLUE_SCROLL_HARD, 1, 1.0 / 1000);
    }

    @Test
    void testGnome() {
        test("Gnome", ItemID.CLUE_SCROLL_MEDIUM, 1, 1.0 / 150);
    }

    @Test
    void testHero() {
        test("Hero", ItemID.CLUE_SCROLL_ELITE, 1, 1.0 / 1400);
        test("Hero", ItemID.CLUE_SCROLL_ELITE_12075, 1, 1.0 / 1400);
        test("Hero", ItemID.CLUE_SCROLL_ELITE_12157, 1, 1.0 / 1400);
    }

    @Test
    void testVyre() {
        test("Caninelle Draynar", ItemID.BLOOD_SHARD, 1, 1.0 / 5000);
        test("Grigor Rasputin", ItemID.BLOOD_SHARD, 1, 1.0 / 5000);
        test("Valentina Diaemus", ItemID.BLOOD_SHARD, 1, 1.0 / 5000);
    }

    @Test
    void testElf() {
        test("Arvel", ItemID.ENHANCED_CRYSTAL_TELEPORT_SEED, 1, 1.0 / 1024);
        test("Indis", ItemID.ENHANCED_CRYSTAL_TELEPORT_SEED, 1, 1.0 / 1024);
    }

    @Test
    void testHur() {
        test("TzHaar-Hur", ItemID.UNCUT_DIAMOND, 1, 1.0 / 195);
    }

}

package dinkplugin.util;

import com.google.gson.Gson;
import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.MockedTestBase;
import net.runelite.api.ItemID;
import net.runelite.http.api.RuneLiteAPI;
import okhttp3.OkHttpClient;
import org.junit.jupiter.api.Test;
import org.mockito.Spy;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

class ItemSearcherTest extends MockedTestBase {

    @Bind
    private final Gson gson = RuneLiteAPI.GSON;

    @Bind
    private final OkHttpClient httpClient = new OkHttpClient();

    @Spy
    @Bind
    private ItemSearcher itemSearcher;

    @Test
    void test() {
        // Wait for http calls to complete
        verify(itemSearcher, timeout(30_000).atLeastOnce()).populate(any(), any());

        // Ensure correct item mappings are populated
        assertEquals(ItemID.JAR_OF_MIASMA, itemSearcher.findItemId("Jar of miasma"));
        assertEquals(ItemID.UNSIRED, itemSearcher.findItemId("Unsired"));

        assertEquals(ItemID.ALCHEMICAL_HYDRA_HEADS, itemSearcher.findItemId("Alchemical hydra heads"));

        assertEquals(ItemID.AHRIMS_STAFF, itemSearcher.findItemId("Ahrim's staff"));

        assertEquals(ItemID.BRYOPHYTAS_ESSENCE, itemSearcher.findItemId("Bryophyta's essence"));

        assertEquals(ItemID.DRAGON_2H_SWORD, itemSearcher.findItemId("Dragon 2h sword"));
        assertEquals(ItemID.DRAGON_LEGSSKIRT_ORNAMENT_KIT, itemSearcher.findItemId("Dragon legs/skirt ornament kit"));

        assertEquals(ItemID.PET_DAGANNOTH_PRIME, itemSearcher.findItemId("Pet dagannoth prime"));
        assertEquals(ItemID.PET_KRIL_TSUTSAROTH, itemSearcher.findItemId("Pet k'ril tsutsaroth"));
        assertEquals(ItemID.HELLPUPPY, itemSearcher.findItemId("Hellpuppy"));
        assertEquals(ItemID.BABY_MOLE, itemSearcher.findItemId("Baby mole"));
        assertEquals(ItemID.SCORPIAS_OFFSPRING, itemSearcher.findItemId("Scorpia's offspring"));
        assertEquals(ItemID.VETION_JR, itemSearcher.findItemId("Vet'ion jr."));

        assertEquals(ItemID.FEDORA, itemSearcher.findItemId("Fedora"));

        assertEquals(ItemID.SEERCULL, itemSearcher.findItemId("Seercull"));

        assertEquals(ItemID.TZREKJAD, itemSearcher.findItemId("Tzrek-jad"));
        assertEquals(ItemID.JALNIBREK, itemSearcher.findItemId("Jal-nib-rek"));
        assertEquals(ItemID.TOKTZKETXIL, itemSearcher.findItemId("Toktz-ket-xil"));

        assertEquals(ItemID.ENHANCED_CRYSTAL_WEAPON_SEED, itemSearcher.findItemId("Enhanced crystal weapon seed"));

        assertEquals(ItemID.GODSWORD_SHARD_2, itemSearcher.findItemId("Godsword shard 2"));

        assertEquals(ItemID.KQ_HEAD, itemSearcher.findItemId("Kq head"));

        assertEquals(ItemID.TORVA_PLATELEGS_DAMAGED, itemSearcher.findItemId("Torva platelegs (damaged)"));

        assertEquals(ItemID.GIANT_EGG_SACFULL, itemSearcher.findItemId("Giant egg sac(full)"));

        assertEquals(ItemID.TOME_OF_WATER_EMPTY, itemSearcher.findItemId("Tome of water (empty)"));

        assertEquals(ItemID.ZULANDRA_TELEPORT, itemSearcher.findItemId("Zul-andra teleport"));

        assertEquals(ItemID.SCYTHE_OF_VITUR_UNCHARGED, itemSearcher.findItemId("Scythe of vitur (uncharged)"));

        assertEquals(ItemID.ELIDINIS_WARD, itemSearcher.findItemId("Elidinis' ward"));

        assertEquals(ItemID.ICTHLARINS_SHROUD_TIER_2, itemSearcher.findItemId("Icthlarin's shroud (tier 2)"));

        assertEquals(ItemID.BREACH_OF_THE_SCARAB, itemSearcher.findItemId("Breach of the scarab"));

        assertEquals(ItemID.MENAPHITE_ORNAMENT_KIT, itemSearcher.findItemId("Menaphite ornament kit"));

        assertEquals(ItemID.AMULET_OF_DEFENCE_T, itemSearcher.findItemId("Amulet of defence (t)"));

        assertEquals(ItemID.RUNE_SCIMITAR_ORNAMENT_KIT_SARADOMIN, itemSearcher.findItemId("Rune scimitar ornament kit (saradomin)"));

        assertEquals(ItemID.BLACK_PLATEBODY_H2, itemSearcher.findItemId("Black platebody (h2)"));

        assertEquals(ItemID.RING_OF_3RD_AGE, itemSearcher.findItemId("Ring of 3rd age"));

        assertEquals(ItemID.OBSIDIAN_CAPE_R, itemSearcher.findItemId("Obsidian cape (r)"));

        assertEquals(ItemID.CHARGE_DRAGONSTONE_JEWELLERY_SCROLL, itemSearcher.findItemId("Charge dragonstone jewellery scroll"));
    }

}

package dinkplugin.util;

import org.junit.jupiter.api.Test;

import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class UtilsTest {

    @Test
    void truncate() {
        assertEquals("Hello world", Utils.truncate("Hello world", 200));
        assertEquals("Hello world", Utils.truncate("Hello world", 11));
        assertEquals("Helloworld", Utils.truncate("Helloworld", 10));
        assertEquals("Hellowor", Utils.truncate("Helloworld", 9));
        assertEquals("Hello", Utils.truncate("Hello world", 9));
        assertEquals("Hello", Utils.truncate("Hello worldly beings", 10));
        assertEquals("Hello worldly", Utils.truncate("Hello worldly beings", 16));
        assertEquals("Hello worldly", Utils.truncate("Hello worldly beings", 15));
        assertEquals("Hello worldly", Utils.truncate("Hello worldly beings", 14));
        assertEquals("Hello", Utils.truncate("Hello worldly beings", 13));
    }

    @Test
    void regexify() {
        Pattern a = Utils.regexify("Hello world!");
        assertEquals("^\\QHello world!\\E$", a.pattern());
        assertTrue(a.matcher("Hello world!").find());
        assertTrue(a.matcher("hello world!").find());
        assertFalse(a.matcher("Hello world").find());
        assertFalse(a.matcher("Hello world!!").find());
        assertFalse(a.matcher("Hi Hello world!").find());

        Pattern b = Utils.regexify("Hello.world!");
        assertEquals("^\\QHello.world!\\E$", b.pattern());
        assertTrue(b.matcher("Hello.world!").find());
        assertFalse(b.matcher("Hello world!").find());
        assertFalse(b.matcher("Hello.world!!").find());

        Pattern c = Utils.regexify("Hello world!*");
        assertEquals("^\\QHello world!\\E.*", c.pattern());
        assertTrue(c.matcher("Hello world!").find());
        assertTrue(c.matcher("Hello world!~").find());
        assertFalse(c.matcher("Hi Hello world!").find());
        assertFalse(c.matcher("Hello world").find());

        Pattern d = Utils.regexify("*Hello world!");
        assertEquals("\\QHello world!\\E$", d.pattern());
        assertTrue(d.matcher("Hello world!").find());
        assertTrue(d.matcher("Hi Hello world!").find());
        assertFalse(d.matcher("Hello world!!").find());
        assertFalse(d.matcher("Hello world").find());

        Pattern e = Utils.regexify("*Hello world!*");
        assertEquals("\\QHello world!\\E.*", e.pattern());
        assertTrue(e.matcher("Hello world!").find());
        assertTrue(e.matcher("Hi Hello world!").find());
        assertTrue(e.matcher("Hello world!!").find());
        assertTrue(e.matcher("Hi Hello world!!").find());
        assertFalse(e.matcher("Hi Hello cruel world!!").find());

        Pattern f = Utils.regexify("*Hello*world!*");
        assertEquals("\\QHello\\E.*\\Qworld!\\E.*", f.pattern());
        assertTrue(f.matcher("Hello world!").find());
        assertTrue(f.matcher("Hi Hello world!").find());
        assertTrue(f.matcher("Hello world!!").find());
        assertTrue(f.matcher("Hi Hello world!!").find());
        assertTrue(f.matcher("Hi hello World!!").find());
        assertTrue(f.matcher("Hi Hello cruel world!!").find());

        Pattern g = Utils.regexify("Membership's price is $12.49");
        assertTrue(g.matcher("Membership's price is $12.49").find());
        assertFalse(g.matcher("Membership's price is $12.499").find());
        assertFalse(g.matcher("Membershipss price is $12.49").find());
        assertFalse(g.matcher("Membership's price is $12349").find());

        Pattern h = Utils.regexify("Membership's price is $12.49*");
        assertTrue(h.matcher("Membership's price is $12.49").find());
        assertTrue(h.matcher("Membership's price is $12.499").find());
        assertFalse(h.matcher("A Membership's price is $12.49").find());

        Pattern i = Utils.regexify("dragon*");
        assertTrue(i.matcher("dragon pickaxe").find());
        assertTrue(i.matcher("dragon claws").find());
        assertFalse(i.matcher("iron pickaxe").find());

        Pattern j = Utils.regexify("*orb");
        assertTrue(j.matcher("awakener's orb").find());
        assertTrue(j.matcher("commorb").find());
        assertFalse(j.matcher("commorb v2").find());

        Pattern k = Utils.regexify("vorkath's head");
        assertTrue(k.matcher("vorkath's head").find());
        assertFalse(k.matcher("vorki").find());
        assertFalse(k.matcher("iron pickaxe").find());

        Pattern l = Utils.regexify("clue scroll*");
        assertTrue(l.matcher("clue scroll (elite)").find());
        assertTrue(l.matcher("clue scroll (beginner)").find());
        assertTrue(l.matcher("clue scroll (easy)").find());
        assertFalse(l.matcher("clue bottle (beginner)").find());
        assertFalse(l.matcher("iron pickaxe").find());

        Pattern m = Utils.regexify("jar of*");
        assertTrue(m.matcher("jar of dirt").find());
        assertTrue(m.matcher("jar of smoke").find());
        assertTrue(m.matcher("jar of dust").find());
        assertTrue(m.matcher("jar of spirits").find());
        assertFalse(m.matcher("iron pickaxe").find());
    }

    @Test
    void sanitize() {
        assertEquals("Congratulations, you've unlocked a new Relic: Archer's Embrace.", Utils.sanitize("Congratulations, you've unlocked a new Relic: <col=ff7700>Archer's Embrace</col>."));
        assertEquals("Congratulations, you've completed an easy task: Obtain a Gem While Mining.", Utils.sanitize("Congratulations, you've completed an easy task: <col=ff7700>Obtain a Gem While Mining</col>."));

        assertEquals("", Utils.sanitize(null));
        assertEquals("", Utils.sanitize(""));

        assertEquals("foo\nbar", Utils.sanitize("foo<br>bar"));

        assertEquals("foo bar", Utils.sanitize("foo\u00A0bar"));
    }

}

package dinkplugin.util;

import com.google.common.collect.Iterators;
import lombok.RequiredArgsConstructor;
import net.runelite.api.IndexedObjectSet;
import org.jetbrains.annotations.NotNull;

import java.util.Arrays;
import java.util.Iterator;
import java.util.Spliterator;

@RequiredArgsConstructor
public final class IndexedArray<T> implements IndexedObjectSet<T> {
    private final T[] array;

    @Override
    public T byIndex(int index) {
        return array[index];
    }

    @NotNull
    @Override
    public Iterator<T> iterator() {
        return Iterators.forArray(array);
    }

    @Override
    public Spliterator<T> spliterator() {
        return Arrays.spliterator(array);
    }
}

package dinkplugin.util;

import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.Collections;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class ConfigUtilTest {

    @Test
    void readDelimited() {
        assertEquals(Collections.emptyList(), ConfigUtil.readDelimited(null).collect(Collectors.toList()));
        assertEquals(Collections.singletonList("ruby"), ConfigUtil.readDelimited("ruby").collect(Collectors.toList()));

        // Empty lines are stripped
        assertEquals(Collections.singletonList("ruby"), ConfigUtil.readDelimited("ruby\n").collect(Collectors.toList()));

        // spaces before and after entries are trimmed
        assertEquals(Collections.singletonList("ruby"), ConfigUtil.readDelimited("ruby ").collect(Collectors.toList()));

        // Delimitations work with ,
        assertEquals(Arrays.asList("ruby", "blueberry"), ConfigUtil.readDelimited("ruby , blueberry").collect(Collectors.toList()));

        // Delimitations work with ;
        assertEquals(Arrays.asList("ruby", "blueberry"), ConfigUtil.readDelimited("ruby ; blueberry").collect(Collectors.toList()));

        // Delimitations work with new line
        assertEquals(Arrays.asList("ruby", "blueberry"), ConfigUtil.readDelimited("ruby \n blueberry").collect(Collectors.toList()));
    }

}

package dinkplugin.util;

import com.google.gson.Gson;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class SerializedLootTest {

    @Test
    void deserialize() {
        String json = "{\"type\":\"NPC\",\"name\":\"Bryophyta\",\"kills\":16,\"first\":1708910620551,\"last\":1708983457752,\"drops\":[23182,16,532,16,1618,5,1620,5,2363,2,560,100,1079,2,890,100,1303,1,1113,2,1147,2,562,200,1124,5,1289,4,563,200]}";
        SerializedLoot lootRecord = new Gson().fromJson(json, SerializedLoot.class);
        assertEquals(16, lootRecord.getKills());
        assertEquals(2, lootRecord.getQuantity(ItemID.RUNE_CHAINBODY));
    }

}

package dinkplugin;

import com.google.inject.Guice;
import com.google.inject.testing.fieldbinder.BoundFieldModule;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.MockitoAnnotations;

public abstract class MockedTestBase {

    private AutoCloseable mocks;

    @BeforeEach
    protected void setUp() {
        this.mocks = MockitoAnnotations.openMocks(this);
        Guice.createInjector(BoundFieldModule.of(this)).injectMembers(this);
    }

    @AfterEach
    protected void cleanUp() throws Exception {
        mocks.close();
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.LootCriteria;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.AnnotatedItemStack;
import dinkplugin.notifiers.data.LootNotificationData;
import dinkplugin.notifiers.data.RareItemStack;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.KillCountService;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.events.PlayerLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.plugins.loottracker.LootTrackerConfig;
import net.runelite.client.util.QuantityFormatter;
import net.runelite.http.api.loottracker.LootRecordType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mockito;

import java.util.Arrays;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class LootNotifierTest extends MockedNotifierTest {

    private static final int SHARD_PRICE = 10_000_000;
    private static final int LARRAN_PRICE = 150_000;
    private static final int RUBY_PRICE = 900;
    private static final int OPAL_PRICE = 600;
    private static final int TUNA_PRICE = 100;
    private static final String LOOTED_NAME = "Rasmus";

    @Bind
    @InjectMocks
    LootNotifier notifier;

    @Bind
    @InjectMocks
    KillCountService killCountService;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyLoot()).thenReturn(true);
        when(config.lootSendImage()).thenReturn(false);
        when(config.lootIcons()).thenReturn(false);
        when(config.minLootValue()).thenReturn(500);
        when(config.includePlayerLoot()).thenReturn(true);
        when(config.lootIncludeClueScrolls()).thenReturn(true);
        when(config.lootNotifyMessage()).thenReturn("%USERNAME% has looted: %LOOT% from %SOURCE% for %TOTAL_VALUE% gp");

        // init client mocks
        WorldPoint location = new WorldPoint(0, 0, 0);
        when(localPlayer.getWorldLocation()).thenReturn(location);

        // init item mocks
        mockItem(ItemID.BLOOD_SHARD, SHARD_PRICE, "Blood shard");
        mockItem(ItemID.LARRANS_KEY, LARRAN_PRICE, "Larran's key");
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
        mockItem(ItemID.OPAL, OPAL_PRICE, "Opal");
        mockItem(ItemID.TUNA, TUNA_PRICE, "Tuna");
    }

    private void mockWorldNpcs(NPC npc) {
        mockNpcs(new NPC[] { npc });
    }

    @Test
    void testNotifyNpc() {
        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Rasmus";
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(9999);
        mockWorldNpcs(npc);
        int kc = 69;
        when(configManager.getConfiguration(eq(LootTrackerConfig.GROUP), any(), eq("drops_NPC_" + name)))
            .thenReturn("{\"type\":\"NPC\",\"name\":\"Rasmus\",\"kills\":" + kc +
                ",\"first\":1667708688588,\"last\":1667708688588,\"drops\":[526,69,1603,1]}");

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %d gp", PLAYER_NAME, RUBY_PRICE, RUBY_PRICE))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), name, LootRecordType.NPC, kc + 1, null, null, 9999))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyNpcRarity() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE + 1);
        when(config.lootRarityThreshold()).thenReturn(100);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(NpcID.ICE_SPIDER);
        mockWorldNpcs(npc);

        // fire event
        var criteria = EnumSet.of(LootCriteria.RARITY);
        double rarity = 1.0 / 208;
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message
        String value = QuantityFormatter.quantityToStackSize(LARRAN_PRICE);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{key}} (%s) from {{source}} for %s gp", PLAYER_NAME, value, value))
                        .replacement("{{key}}", Replacements.ofWiki("Larran's key"))
                        .replacement("{{source}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new RareItemStack(ItemID.LARRANS_KEY, 1, LARRAN_PRICE, "Larran's key", criteria, rarity)), name, LootRecordType.NPC, 1, rarity, null, NpcID.ICE_SPIDER))
                .type(NotificationType.LOOT)
                .thumbnailUrl(ItemUtils.getItemImageUrl(ItemID.LARRANS_KEY))
                .build()
        );
    }

    @Test
    @SuppressWarnings("unused")
    void testIgnoreNpcRarity() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE + 1);
        when(config.lootRarityThreshold()).thenReturn(300);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);

        // fire event
        double rarity = 1.0 / 208;
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test // https://github.com/pajlads/DinkPlugin/issues/446
    @SuppressWarnings("unused")
    void testIgnoreRarityDenyList() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE + 1);
        when(config.lootRarityThreshold()).thenReturn(100);
        notifier.onConfigChanged("lootItemDenylist", "Larran's key");

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);

        // fire event
        double rarity = 1.0 / 208;
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyAllowlist() {
        // prepare mocks
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);

        // fire event
        notifier.onConfigChanged("lootItemAllowlist", "salmon\nraw trout\ntuna\npike");
        PlayerLootReceived event = new PlayerLootReceived(player, Collections.singletonList(new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{tuna}} (%d) from {{source}} for %d gp", PLAYER_NAME, TUNA_PRICE, TUNA_PRICE))
                        .replacement("{{tuna}}", Replacements.ofWiki("Tuna"))
                        .replacement("{{source}}", Replacements.ofLink(LOOTED_NAME, config.playerLookupService().getPlayerUrl(LOOTED_NAME)))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.of(LootCriteria.ALLOWLIST))), LOOTED_NAME, LootRecordType.PLAYER, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyAllowlistWildcard() {
        // prepare mocks
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);

        // fire event
        notifier.onConfigChanged("lootItemAllowlist", "salmon\nraw trout\ntun*\npike");
        PlayerLootReceived event = new PlayerLootReceived(player, Collections.singletonList(new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{tuna}} (%d) from {{source}} for %d gp", PLAYER_NAME, TUNA_PRICE, TUNA_PRICE))
                        .replacement("{{tuna}}", Replacements.ofWiki("Tuna"))
                        .replacement("{{source}}", Replacements.ofLink(LOOTED_NAME, config.playerLookupService().getPlayerUrl(LOOTED_NAME)))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.of(LootCriteria.ALLOWLIST))), LOOTED_NAME, LootRecordType.PLAYER, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testIgnoreDenylist() {
        // fire event
        notifier.onConfigChanged("lootItemDenylist", "Ruby");
        LootReceived event = new LootReceived(LOOTED_NAME, 99, LootRecordType.PICKPOCKET, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreDenylistWildcard() {
        // fire event
        notifier.onConfigChanged("lootItemDenylist", "Rub*");
        LootReceived event = new LootReceived(LOOTED_NAME, 99, LootRecordType.PICKPOCKET, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    @DisplayName("Ensure LootReceived event for The Whisperer fires a notification - https://github.com/pajlads/DinkPlugin/pull/286")
    void testNotifyWhisperer() {
        String name = "The Whisperer";
        NPC npc = Mockito.mock(NPC.class);
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(NpcID.THE_WHISPERER);
        mockWorldNpcs(npc);

        // fire event
        LootReceived event = new LootReceived(name, 99, LootRecordType.NPC, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %d gp", PLAYER_NAME, RUBY_PRICE, RUBY_PRICE))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), name, LootRecordType.NPC, 1, null, null, NpcID.THE_WHISPERER))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    @DisplayName("Ensure NpcLootReceived for The Whisperer doesn't fire a notification - https://github.com/pajlads/DinkPlugin/pull/286")
    void testIgnoreWhispererNpcLootReceived() {
        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "The Whisperer";
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(NpcID.THE_WHISPERER);

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)));
        plugin.onNpcLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreNpc() {
        // prepare mocks
        NPC npc = mock(NPC.class);
        when(npc.getName()).thenReturn(LOOTED_NAME);

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, Collections.singletonList(new ItemStack(ItemID.TUNA, 1)));
        plugin.onNpcLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyPickpocket() {
        String name = "Remus Kaninus";
        NPC npc = Mockito.mock(NPC.class);
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(NpcID.REMUS_KANINUS);
        mockWorldNpcs(npc);

        // fire event
        LootReceived event = new LootReceived(name, -1, LootRecordType.PICKPOCKET, Collections.singletonList(new ItemStack(ItemID.BLOOD_SHARD, 1)), 1);
        plugin.onLootReceived(event);

        // verify notification message
        double rarity = 1.0 / 5000;
        String price = QuantityFormatter.quantityToStackSize(SHARD_PRICE);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{shard}} (%s) from {{source}} for %s gp", PLAYER_NAME, price, price))
                        .replacement("{{shard}}", Replacements.ofWiki("Blood shard"))
                        .replacement("{{source}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new RareItemStack(ItemID.BLOOD_SHARD, 1, SHARD_PRICE, "Blood shard", EnumSet.of(LootCriteria.VALUE), rarity)), name, LootRecordType.PICKPOCKET, 1, rarity, null, NpcID.REMUS_KANINUS))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testIgnorePickpocket() {
        // fire event
        LootReceived event = new LootReceived(LOOTED_NAME, 99, LootRecordType.PICKPOCKET, Collections.singletonList(new ItemStack(ItemID.TUNA, 1)), 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyClue() {
        // prepare completion count
        killCountService.onGameMessage("You have completed 42 medium Treasure Trails.");

        // fire event
        String source = "Clue Scroll (Medium)";
        LootReceived event = new LootReceived(source, -1, LootRecordType.EVENT, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %d gp", PLAYER_NAME, RUBY_PRICE, RUBY_PRICE))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(source))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), source, LootRecordType.EVENT, 42, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testIgnoreClue() {
        // update config mock
        when(config.lootIncludeClueScrolls()).thenReturn(false);

        // fire event
        LootReceived event = new LootReceived("Clue Scroll (Medium)", -1, LootRecordType.EVENT, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyPlayer() {
        // prepare mocks
        when(config.pkWebhook()).thenReturn("https://example.com/");
        when(config.lootRedirectPlayerKill()).thenReturn(false);
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);

        // fire event
        PlayerLootReceived event = new PlayerLootReceived(player, Arrays.asList(new ItemStack(ItemID.RUBY, 1), new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %s gp", PLAYER_NAME, RUBY_PRICE, QuantityFormatter.quantityToStackSize(RUBY_PRICE + TUNA_PRICE)))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofLink(LOOTED_NAME, config.playerLookupService().getPlayerUrl(LOOTED_NAME)))
                        .build()
                )
                .extra(new LootNotificationData(Arrays.asList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE)), new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.noneOf(LootCriteria.class))), LOOTED_NAME, LootRecordType.PLAYER, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyPlayerForwarded() {
        // prepare mocks
        String overrideUrl = "https://example.com/";
        when(config.pkWebhook()).thenReturn(overrideUrl);
        when(config.lootRedirectPlayerKill()).thenReturn(true);
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);

        // fire event
        PlayerLootReceived event = new PlayerLootReceived(player, Arrays.asList(new ItemStack(ItemID.RUBY, 1), new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            overrideUrl,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %s gp", PLAYER_NAME, RUBY_PRICE, QuantityFormatter.quantityToStackSize(RUBY_PRICE + TUNA_PRICE)))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofLink(LOOTED_NAME, config.playerLookupService().getPlayerUrl(LOOTED_NAME)))
                        .build()
                )
                .extra(new LootNotificationData(Arrays.asList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE)), new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.noneOf(LootCriteria.class))), LOOTED_NAME, LootRecordType.PLAYER, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyPlayerForwardBlank() {
        // prepare mocks
        when(config.pkWebhook()).thenReturn("");
        when(config.lootRedirectPlayerKill()).thenReturn(true);
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);

        // fire event
        PlayerLootReceived event = new PlayerLootReceived(player, Arrays.asList(new ItemStack(ItemID.RUBY, 1), new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d) from {{source}} for %s gp", PLAYER_NAME, RUBY_PRICE, QuantityFormatter.quantityToStackSize(RUBY_PRICE + TUNA_PRICE)))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofLink(LOOTED_NAME, config.playerLookupService().getPlayerUrl(LOOTED_NAME)))
                        .build()
                )
                .extra(new LootNotificationData(Arrays.asList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE)), new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.noneOf(LootCriteria.class))), LOOTED_NAME, LootRecordType.PLAYER, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyPkChest() {
        // update mocks
        final int minValue = 750;
        when(config.minLootValue()).thenReturn(minValue);
        assert OPAL_PRICE < minValue && TUNA_PRICE < minValue;

        // fire event
        String source = "Loot Chest";
        List<ItemStack> items = List.of(new ItemStack(ItemID.OPAL, 1), new ItemStack(ItemID.TUNA, 2));
        int totalValue = OPAL_PRICE + 2 * TUNA_PRICE;
        LootReceived event = new LootReceived(source, -1, LootRecordType.EVENT, items, 1);
        plugin.onLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: Various items including: 1 x {{opal}} (%d) from {{source}} for %s gp", PLAYER_NAME, OPAL_PRICE, QuantityFormatter.quantityToStackSize(totalValue)))
                        .replacement("{{opal}}", Replacements.ofWiki("Opal"))
                        .replacement("{{source}}", Replacements.ofWiki(source))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new AnnotatedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal", EnumSet.noneOf(LootCriteria.class)), new AnnotatedItemStack(ItemID.TUNA, 2, TUNA_PRICE, "Tuna", EnumSet.noneOf(LootCriteria.class))), source, LootRecordType.EVENT, 1, null, null, null))
                .type(NotificationType.LOOT)
                .thumbnailUrl(ItemUtils.getItemImageUrl(ItemID.TUNA))
                .build()
        );
    }

    @Test
    void testIgnorePkChest() {
        // update mocks
        final int minValue = 750;
        when(config.minLootValue()).thenReturn(minValue);
        assert OPAL_PRICE < minValue && TUNA_PRICE < minValue;

        // fire event
        String source = "Loot Chest";
        List<ItemStack> items = List.of(new ItemStack(ItemID.OPAL, 1), new ItemStack(ItemID.TUNA, 1));
        LootReceived event = new LootReceived(source, -1, LootRecordType.EVENT, items, 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnorePlayer() {
        // prepare mocks
        Player player = mock(Player.class);
        when(player.getName()).thenReturn(LOOTED_NAME);
        when(config.includePlayerLoot()).thenReturn(false);

        // fire event
        PlayerLootReceived event = new PlayerLootReceived(player, Arrays.asList(new ItemStack(ItemID.RUBY, 1), new ItemStack(ItemID.TUNA, 1)));
        plugin.onPlayerLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyMultiple() {
        // fire event
        int total = RUBY_PRICE + OPAL_PRICE + TUNA_PRICE;
        LootReceived event = new LootReceived(
            LOOTED_NAME,
            99,
            LootRecordType.EVENT,
            Arrays.asList(
                new ItemStack(ItemID.RUBY, 1),
                new ItemStack(ItemID.OPAL, 1),
                new ItemStack(ItemID.TUNA, 1)
            ),
            3
        );
        plugin.onLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{ruby}} (%d)\n1 x {{opal}} (%d) from {{source}} for %s gp", PLAYER_NAME, RUBY_PRICE, OPAL_PRICE, QuantityFormatter.quantityToStackSize(total)))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{opal}}", Replacements.ofWiki("Opal"))
                        .replacement("{{source}}", Replacements.ofWiki(LOOTED_NAME))
                        .build()
                )
                .extra(new LootNotificationData(Arrays.asList(new AnnotatedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE)), new AnnotatedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal", EnumSet.of(LootCriteria.VALUE)), new AnnotatedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna", EnumSet.noneOf(LootCriteria.class))), LOOTED_NAME, LootRecordType.EVENT, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyRepeated() {
        // fire event
        int total = TUNA_PRICE * 5;
        LootReceived event = new LootReceived(
            LOOTED_NAME,
            99,
            LootRecordType.EVENT,
            Arrays.asList(
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1)
            ),
            5
        );
        plugin.onLootReceived(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 5 x {{tuna}} (%d) from {{source}} for %s gp", PLAYER_NAME, 5 * TUNA_PRICE, QuantityFormatter.quantityToStackSize(total)))
                        .replacement("{{tuna}}", Replacements.ofWiki("Tuna"))
                        .replacement("{{source}}", Replacements.ofWiki(LOOTED_NAME))
                        .build()
                )
                .extra(new LootNotificationData(Collections.singletonList(new AnnotatedItemStack(ItemID.TUNA, 5, TUNA_PRICE, "Tuna", EnumSet.of(LootCriteria.VALUE))), LOOTED_NAME, LootRecordType.EVENT, 1, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testIgnoreRepeated() {
        // fire event
        LootReceived event = new LootReceived(
            LOOTED_NAME,
            99,
            LootRecordType.EVENT,
            Arrays.asList(
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1),
                new ItemStack(ItemID.TUNA, 1)
            ),
            4
        );
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyGauntlet() {
        // prepare data
        int kc = 123;
        int quantity = 24;
        String total = QuantityFormatter.quantityToStackSize(quantity * RUBY_PRICE);
        String source = "The Gauntlet";
        List<ItemStack> items = List.of(new ItemStack(ItemID.RUBY, quantity));

        // fire events
        killCountService.onGameMessage(String.format("Your Gauntlet completion count is: %d.", kc));
        plugin.onLootReceived(new LootReceived(source, -1, LootRecordType.EVENT, items, 1));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: %d x {{ruby}} (%s) from {{source}} for %s gp", PLAYER_NAME, quantity, total, total))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(source))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new AnnotatedItemStack(ItemID.RUBY, quantity, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), source, LootRecordType.EVENT, kc, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyCorruptedGauntlet() {
        // prepare data
        int kc = 123;
        int quantity = 24;
        String total = QuantityFormatter.quantityToStackSize(quantity * RUBY_PRICE);
        String source = "The Gauntlet";
        String realSource = "Corrupted Gauntlet";
        List<ItemStack> items = List.of(new ItemStack(ItemID.RUBY, quantity));

        // fire events
        killCountService.onGameMessage(String.format("Your Corrupted Gauntlet completion count is: %d.", kc));
        plugin.onLootReceived(new LootReceived(source, -1, LootRecordType.EVENT, items, 1));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: %d x {{ruby}} (%s) from {{source}} for %s gp", PLAYER_NAME, quantity, total, total))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(realSource))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new AnnotatedItemStack(ItemID.RUBY, quantity, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), realSource, LootRecordType.EVENT, kc, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyAmascut() {
        // prepare data
        int kc = 123;
        int quantity = 24;
        String total = QuantityFormatter.quantityToStackSize(quantity * RUBY_PRICE);
        String source = "Tombs of Amascut";
        List<ItemStack> items = List.of(new ItemStack(ItemID.RUBY, quantity));

        // fire events
        killCountService.onGameMessage(String.format("Your completed %s count is: %d.", source, kc));
        plugin.onLootReceived(new LootReceived("Tombs of Amascut", -1, LootRecordType.EVENT, items, 1));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: %d x {{ruby}} (%s) from {{source}} for %s gp", PLAYER_NAME, quantity, total, total))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(source))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new AnnotatedItemStack(ItemID.RUBY, quantity, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), source, LootRecordType.EVENT, kc, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyAmascutExpert() {
        // prepare data
        int kc = 123;
        int quantity = 24;
        String total = QuantityFormatter.quantityToStackSize(quantity * RUBY_PRICE);
        String source = "Tombs of Amascut: Expert Mode";
        List<ItemStack> items = List.of(new ItemStack(ItemID.RUBY, quantity));

        // fire events
        killCountService.onGameMessage(String.format("Your completed %s count is: %d.", source, kc));
        plugin.onLootReceived(new LootReceived("Tombs of Amascut", -1, LootRecordType.EVENT, items, 1));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: %d x {{ruby}} (%s) from {{source}} for %s gp", PLAYER_NAME, quantity, total, total))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .replacement("{{source}}", Replacements.ofWiki(source))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new AnnotatedItemStack(ItemID.RUBY, quantity, RUBY_PRICE, "Ruby", EnumSet.of(LootCriteria.VALUE))), source, LootRecordType.EVENT, kc, null, null, null))
                .type(NotificationType.LOOT)
                .build()
        );
    }

    @Test
    void testNotifyRarityValueIntersectionValue() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE);
        when(config.lootRarityThreshold()).thenReturn(100);
        when(config.lootRarityValueIntersection()).thenReturn(true);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);
        when(npc.getId()).thenReturn(NpcID.ICE_SPIDER);
        mockWorldNpcs(npc);

        // fire event
        double rarity = 1.0 / 208;
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message
        var criteria = EnumSet.of(LootCriteria.VALUE, LootCriteria.RARITY);
        String value = QuantityFormatter.quantityToStackSize(LARRAN_PRICE);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has looted: 1 x {{key}} (%s) from {{source}} for %s gp", PLAYER_NAME, value, value))
                        .replacement("{{key}}", Replacements.ofWiki("Larran's key"))
                        .replacement("{{source}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new LootNotificationData(List.of(new RareItemStack(ItemID.LARRANS_KEY, 1, LARRAN_PRICE, "Larran's key", criteria, rarity)), name, LootRecordType.NPC, 1, rarity, null, NpcID.ICE_SPIDER))
                .type(NotificationType.LOOT)
                .thumbnailUrl(ItemUtils.getItemImageUrl(ItemID.LARRANS_KEY))
                .build()
        );
    }

    @Test
    void testIgnoreRarityValueIntersectionRarityTooLow() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE - 1);
        when(config.lootRarityThreshold()).thenReturn(1000);
        when(config.lootRarityValueIntersection()).thenReturn(true);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message doesn't fire
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreRarityValueIntersectionValueTooLow() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE + 1);
        when(config.lootRarityThreshold()).thenReturn(100);
        when(config.lootRarityValueIntersection()).thenReturn(true);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.LARRANS_KEY, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message doesn't fire
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreRarityValueIntersectionRarityAbsent() {
        // update config mocks
        when(config.minLootValue()).thenReturn(LARRAN_PRICE + 1);
        when(config.lootRarityThreshold()).thenReturn(1);
        when(config.lootRarityValueIntersection()).thenReturn(true);

        // prepare mocks
        NPC npc = mock(NPC.class);
        String name = "Ice spider";
        when(npc.getName()).thenReturn(name);

        // fire event
        NpcLootReceived event = new NpcLootReceived(npc, List.of(new ItemStack(ItemID.TUNA, 1)));
        plugin.onNpcLootReceived(event);

        // verify notification message doesn't fire
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyLoot()).thenReturn(false);

        // fire event
        LootReceived event = new LootReceived(LOOTED_NAME, 99, LootRecordType.PICKPOCKET, Collections.singletonList(new ItemStack(ItemID.RUBY, 1)), 1);
        plugin.onLootReceived(event);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.GambleNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemSearcher;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;

import java.util.Arrays;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class GambleNotifierTest extends MockedNotifierTest {
    private static final int GRANITE_HELM_PRICE = 29_000;
    private static final int DRAGON_CHAINBODY_PRICE = 150_000;
    private static final int ELITE_CLUE_PRICE = 0;

    @Bind
    @InjectMocks
    GambleNotifier notifier;

    @Bind
    @Mock
    ItemSearcher itemSearcher;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        when(config.notifyGamble()).thenReturn(true);
        when(config.gambleSendImage()).thenReturn(true);
        when(config.gambleInterval()).thenReturn(10);
        when(config.gambleRareLoot()).thenReturn(true);
        when(config.gambleNotifyMessage()).thenReturn("%USERNAME% has reached %COUNT% high gambles");
        when(config.gambleRareNotifyMessage()).thenReturn("%USERNAME% has received rare loot at gamble count %COUNT%: \n\n%LOOT%");

        mockItem(ItemID.GRANITE_HELM, GRANITE_HELM_PRICE, "Granite helm");
        mockItem(ItemID.DRAGON_CHAINBODY, DRAGON_CHAINBODY_PRICE, "Dragon chainbody");
        mockItem(ItemID.CLUE_SCROLL_ELITE, ELITE_CLUE_PRICE, "Clue scroll (elite)");
        when(itemSearcher.findItemId("Granite helm")).thenReturn(ItemID.GRANITE_HELM);
        when(itemSearcher.findItemId("Dragon chainbody")).thenReturn(ItemID.DRAGON_CHAINBODY);
        when(itemSearcher.findItemId("Clue scroll (elite)")).thenReturn(ItemID.CLUE_SCROLL_ELITE);
    }

    @Test
    void testNotifyInterval() {
        notifier.onMesBoxNotification("Granite helm! High level gamble count: 20.");

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate(PLAYER_NAME + " has reached 20 high gambles"))
                .extra(new GambleNotificationData(20, Collections.singletonList(new SerializedItemStack(ItemID.GRANITE_HELM, 1, GRANITE_HELM_PRICE, "Granite helm"))))
                .type(NotificationType.BARBARIAN_ASSAULT_GAMBLE)
                .build()
        );
    }

    @Test
    void testTertiaryLoot() {
        notifier.onMesBoxNotification("Granite helm! Clue scroll (elite)! High level gamble count: 10.");

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate(PLAYER_NAME + " has reached 10 high gambles"))
                .extra(new GambleNotificationData(10, Arrays.asList(
                    new SerializedItemStack(ItemID.GRANITE_HELM, 1, GRANITE_HELM_PRICE, "Granite helm"),
                    new SerializedItemStack(ItemID.CLUE_SCROLL_ELITE, 1, ELITE_CLUE_PRICE, "Clue scroll (elite)")
                )))
                .type(NotificationType.BARBARIAN_ASSAULT_GAMBLE)
                .build()
        );
    }

    @Test
    void testIgnoredInterval() {
        notifier.onMesBoxNotification("Watermelon seed (x 50)! High level gamble count: 21.");
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testRareLoot() {
        notifier.onMesBoxNotification("Dragon chainbody! High level gamble count: 11.");

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has received rare loot at gamble count 11: \n\n1 x {{dchain}} (150K)")
                        .replacement("{{dchain}}", Replacements.ofWiki("Dragon chainbody"))
                        .build()
                )
                .extra(new GambleNotificationData(11, Collections.singletonList(new SerializedItemStack(ItemID.DRAGON_CHAINBODY, 1, DRAGON_CHAINBODY_PRICE, "Dragon chainbody"))))
                .type(NotificationType.BARBARIAN_ASSAULT_GAMBLE)
                .build()
        );
    }

    @Test
    void testIgnoredRareLootInterval() {
        when(config.gambleRareLoot()).thenReturn(false);
        notifier.onMesBoxNotification("Dragon chainbody! High level gamble count: 13.");
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        when(config.notifyGamble()).thenReturn(false);
        notifier.onMesBoxNotification("Dragon chainbody! High level gamble count: 100.");
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.AccountType;
import dinkplugin.domain.ExceptionalDeath;
import dinkplugin.message.Embed;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.DeathNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.Region;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.NpcID;
import net.runelite.api.ParamID;
import net.runelite.api.Player;
import net.runelite.api.Prayer;
import net.runelite.api.SkullIcon;
import net.runelite.api.Varbits;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.InteractingChanged;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mockito;

import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.List;
import java.util.stream.Collectors;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class DeathNotifierTest extends MockedNotifierTest {

    private static final int RUBY_PRICE = 900;
    private static final int SHARK_PRICE = 700;
    private static final int OPAL_PRICE = 600;
    private static final int COAL_PRICE = 200;
    private static final int TUNA_PRICE = 100;

    @Bind
    @InjectMocks
    DeathNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyDeath()).thenReturn(true);
        when(config.deathNotifPvpEnabled()).thenReturn(true);
        when(config.deathSendImage()).thenReturn(false);
        when(config.deathEmbedKeptItems()).thenReturn(true);
        when(config.deathIgnoreSafe()).thenReturn(true);
        when(config.deathNotifyMessage()).thenReturn("%USERNAME% has died, losing %VALUELOST% gp");
        when(config.deathNotifPvpMessage()).thenReturn("%USERNAME% has been PKed by %PKER% for %VALUELOST% gp");

        // init client mocks
        when(client.getVarbitValue(Varbits.IN_WILDERNESS)).thenReturn(1);
        mockNpcs(new NPC[0]);
        mockPlayers(new Player[0]);
        WorldPoint location = new WorldPoint(0, 0, 0);
        when(localPlayer.getWorldLocation()).thenReturn(location);
        when(localPlayer.getLocalLocation()).thenReturn(new LocalPoint(0, 0));
        when(localPlayer.getSkullIcon()).thenReturn(SkullIcon.NONE);

        // init item mocks
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
        mockItem(ItemID.SHARK, SHARK_PRICE, "Shark");
        mockItem(ItemID.OPAL, OPAL_PRICE, "Opal");
        mockItem(ItemID.COAL, COAL_PRICE, "Coal");
        mockItem(ItemID.TUNA, TUNA_PRICE, "Tuna");

        // init npc mocks
        when(npcManager.getHealth(anyInt())).thenReturn(50);
    }

    @Test
    void testNotifyEmpty() {
        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, Collections.emptyList(), Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotify() {
        // prepare mocks
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.asList(
            new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby"),
            new SerializedItemStack(ItemID.SHARK, 1, SHARK_PRICE, "Shark"),
            new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal"),
            new SerializedItemStack(ItemID.COAL, 1, COAL_PRICE, "Coal")
        );
        List<SerializedItemStack> lost = Collections.singletonList(
            new SerializedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna")
        );
        List<Embed> embeds = Arrays.asList(
            Embed.ofImage("https://static.runelite.net/cache/item/icon/" + ItemID.RUBY + ".png"),
            Embed.ofImage("https://static.runelite.net/cache/item/icon/" + ItemID.SHARK + ".png"),
            Embed.ofImage("https://static.runelite.net/cache/item/icon/" + ItemID.OPAL + ".png"),
            Embed.ofImage("https://static.runelite.net/cache/item/icon/" + ItemID.COAL + ".png")
        );
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, TUNA_PRICE)))
                .extra(new DeathNotificationData(TUNA_PRICE, false, null, null, null, kept, lost, Region.of(client)))
                .type(NotificationType.DEATH)
                .embeds(embeds)
                .build()
        );
    }

    @Test
    void testNotifyPk() {
        // prepare mocks
        String pker = "Rasmus";
        Player other = mock(Player.class);
        when(other.getName()).thenReturn(pker);
        when(other.getInteracting()).thenReturn(localPlayer);
        Player[] candidates = { mock(Player.class), mock(Player.class), other, mock(Player.class) };
        mockPlayers(candidates);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has been PKed by %s for %d gp", PLAYER_NAME, pker, 0)))
                .extra(new DeathNotificationData(0L, true, pker, pker, null, Collections.emptyList(), Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyPkInteraction() {
        // prepare mocks
        String pker = "Rasmus";
        Player other = mock(Player.class);
        when(other.getName()).thenReturn(pker);
        when(other.getInteracting()).thenReturn(localPlayer);
        when(other.getCombatLevel()).thenReturn(50);
        when(localPlayer.getCombatLevel()).thenReturn(50);

        // fire events
        plugin.onInteractingChanged(new InteractingChanged(other, localPlayer));
        plugin.onInteractingChanged(new InteractingChanged(localPlayer, other));
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has been PKed by %s for %d gp", PLAYER_NAME, pker, 0)))
                .extra(new DeathNotificationData(0L, true, pker, pker, null, Collections.emptyList(), Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyNotPk() {
        // prepare mocks: look like PK, but not in wilderness
        Player other = mock(Player.class);
        when(other.getName()).thenReturn("Rasmus");
        when(other.getInteracting()).thenReturn(localPlayer);
        mockPlayers(new Player[] { other });
        when(client.getVarbitValue(Varbits.IN_WILDERNESS)).thenReturn(0);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify non-PK notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, Collections.emptyList(), Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyNpc() {
        // init mocks
        String name = "Guard";
        NPC other = mock(NPC.class);
        when(other.getName()).thenReturn(name);
        when(other.getId()).thenReturn(NpcID.GUARD);
        when(other.isDead()).thenReturn(false);
        when(other.getCombatLevel()).thenReturn(21);
        when(other.getInteracting()).thenReturn(localPlayer);
        when(other.getLocalLocation()).thenReturn(new LocalPoint(1, 1));

        NPCComposition comp = mock(NPCComposition.class);
        when(other.getTransformedComposition()).thenReturn(comp);
        when(comp.isInteractible()).thenReturn(true);
        when(comp.isFollower()).thenReturn(false);
        when(comp.getSize()).thenReturn(1);
        when(comp.isMinimapVisible()).thenReturn(true);
        when(comp.getId()).thenReturn(NpcID.GUARD);
        when(comp.getName()).thenReturn(name);
        when(comp.getStringValue(ParamID.NPC_HP_NAME)).thenReturn(name);
        when(comp.getCombatLevel()).thenReturn(21);
        when(comp.getActions()).thenReturn(new String[] { "Pickpocket", "Attack", "Examine" });

        when(npcManager.getHealth(NpcID.GUARD)).thenReturn(22);
        mockNpcs(new NPC[] { other });
        when(config.deathNotifyMessage()).thenReturn("%USERNAME% has died to %NPC%");

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has died to {{npc}}")
                        .replacement("{{npc}}", Replacements.ofWiki(name))
                        .build()
                )
                .extra(new DeathNotificationData(0L, false, null, name, NpcID.GUARD, Collections.emptyList(), Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyValue() {
        // prepare mocks
        when(config.deathMinValue()).thenReturn(TUNA_PRICE - 1);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.asList(
            ItemUtils.stackFromItem(itemManager, items[0]),
            ItemUtils.stackFromItem(itemManager, items[3]),
            ItemUtils.stackFromItem(itemManager, items[4]),
            ItemUtils.stackFromItem(itemManager, items[2])
        );
        List<SerializedItemStack> lost = Collections.singletonList(
            ItemUtils.stackFromItem(itemManager, items[1])
        );
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, TUNA_PRICE)))
                .extra(new DeathNotificationData(TUNA_PRICE, false, null, null, null, kept, lost, Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifySafe() {
        // update config mock
        when(config.deathIgnoreSafe()).thenReturn(false);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(config.deathMinValue()).thenReturn(TUNA_PRICE + 1);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // mock castle wars
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(2400, 3100, 0));

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.stream(items)
            .map(i -> ItemUtils.stackFromItem(itemManager, i))
            .sorted(Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed())
            .collect(Collectors.toList());
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, kept, Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyAmascut() {
        // update mocks
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3520, 5120, 0));
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        notifier.onGameMessage("You failed to survive the Tombs of Amascut");

        // verify notification
        List<SerializedItemStack> kept = Arrays.asList(
            ItemUtils.stackFromItem(itemManager, items[0]),
            ItemUtils.stackFromItem(itemManager, items[3]),
            ItemUtils.stackFromItem(itemManager, items[4]),
            ItemUtils.stackFromItem(itemManager, items[2])
        );
        List<SerializedItemStack> lost = Collections.singletonList(
            ItemUtils.stackFromItem(itemManager, items[1])
        );
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, TUNA_PRICE)))
                .extra(new DeathNotificationData(TUNA_PRICE, false, null, null, null, kept, lost, Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyAmascutSafe() {
        // update mocks
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3520, 5120, 0));
        when(config.deathIgnoreSafe()).thenReturn(false);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.stream(items)
            .map(i -> ItemUtils.stackFromItem(itemManager, i))
            .sorted(Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed())
            .collect(Collectors.toList());
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, kept, Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyAmascutExceptional() {
        // update mocks
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3520, 5120, 0));
        when(config.deathIgnoreSafe()).thenReturn(true);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(config.deathSafeExceptions()).thenReturn(EnumSet.of(ExceptionalDeath.TOA));
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.stream(items)
            .map(i -> ItemUtils.stackFromItem(itemManager, i))
            .sorted(Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed())
            .collect(Collectors.toList());
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, kept, Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );

        // fire event
        notifier.onGameMessage("You failed to survive the Tombs of Amascut");

        // ensure toa death message is ignored in exceptional mode (since a notification already fired)
        Mockito.verifyNoMoreInteractions(messageHandler);
    }

    @Test
    void testNotifyAmascutHardcoreIron() {
        // update mocks
        when(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).thenReturn(AccountType.HARDCORE_IRONMAN.ordinal());
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3520, 5120, 0));
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.asList(
            ItemUtils.stackFromItem(itemManager, items[0]),
            ItemUtils.stackFromItem(itemManager, items[3]),
            ItemUtils.stackFromItem(itemManager, items[4]),
            ItemUtils.stackFromItem(itemManager, items[2])
        );
        List<SerializedItemStack> lost = Collections.singletonList(
            ItemUtils.stackFromItem(itemManager, items[1])
        );
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, TUNA_PRICE)))
                .extra(new DeathNotificationData(TUNA_PRICE, false, null, null, null, kept, lost, Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );

        // ensure TOA death chat message is ignored for HCIM
        notifier.onGameMessage("You failed to survive the Tombs of Amascut");
        Mockito.verifyNoMoreInteractions(messageHandler);
    }

    @Test
    void testIgnoreAmascut() {
        // update mocks
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3520, 5120, 0));
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyGauntletSafe() {
        // update mocks
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1950, 5650, 0));
        when(config.deathIgnoreSafe()).thenReturn(false);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> kept = Arrays.stream(items)
            .map(i -> ItemUtils.stackFromItem(itemManager, i))
            .sorted(Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed())
            .collect(Collectors.toList());
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, 0)))
                .extra(new DeathNotificationData(0L, false, null, null, null, kept, Collections.emptyList(), Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testNotifyGauntletHardcore() {
        // update mocks
        when(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).thenReturn(3);
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1950, 5650, 0));
        when(config.deathIgnoreSafe()).thenReturn(true);
        when(config.deathEmbedKeptItems()).thenReturn(false);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // verify notification
        List<SerializedItemStack> lost = Collections.singletonList(ItemUtils.stackFromItem(itemManager, items[0]));
        List<SerializedItemStack> kept = Arrays.stream(items)
            .skip(1) // tuna is lost (least valuable)
            .map(i -> ItemUtils.stackFromItem(itemManager, i))
            .sorted(Comparator.comparingLong(SerializedItemStack::getTotalPrice).reversed())
            .collect(Collectors.toList());
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has died, losing %d gp", PLAYER_NAME, TUNA_PRICE)))
                .extra(new DeathNotificationData(TUNA_PRICE, false, null, null, null, kept, lost, Region.of(client)))
                .type(NotificationType.DEATH)
                .build()
        );
    }

    @Test
    void testIgnoreGauntlet() {
        // mock corrupted gauntlet
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(1950, 5650, 0));

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnore() {
        // prepare mock
        Player other = mock(Player.class);

        // fire event
        plugin.onActorDeath(new ActorDeath(other));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreSafe() {
        // mock castle wars
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(2400, 3100, 0));

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreCustom() {
        // update config mocks
        when(config.deathIgnoredRegions()).thenReturn("12336");
        notifier.init();

        // mock tutorial island
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(3100, 3100, 0));

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyDeath()).thenReturn(false);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreValue() {
        // prepare mocks
        when(config.deathMinValue()).thenReturn(TUNA_PRICE + 1);
        when(client.isPrayerActive(Prayer.PROTECT_ITEM)).thenReturn(true);
        Item[] items = {
            new Item(ItemID.RUBY, 1),
            new Item(ItemID.TUNA, 1),
            new Item(ItemID.COAL, 1),
            new Item(ItemID.SHARK, 1),
            new Item(ItemID.OPAL, 1),
        };
        ItemContainer inv = mock(ItemContainer.class);
        when(client.getItemContainer(InventoryID.INVENTORY)).thenReturn(inv);
        when(inv.getItems()).thenReturn(items);

        // fire event
        plugin.onActorDeath(new ActorDeath(localPlayer));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import com.google.gson.Gson;
import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.DinkPlugin;
import dinkplugin.DinkPluginConfig;
import dinkplugin.MockedTestBase;
import dinkplugin.SettingsManager;
import dinkplugin.domain.AccountType;
import dinkplugin.domain.FilterMode;
import dinkplugin.domain.PlayerLookupService;
import dinkplugin.message.DiscordMessageHandler;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.templating.Template;
import dinkplugin.util.BlockingClientThread;
import dinkplugin.util.BlockingExecutor;
import dinkplugin.util.IndexedArray;
import dinkplugin.util.TestImageUtil;
import dinkplugin.util.Utils;
import lombok.SneakyThrows;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.IndexedObjectSet;
import net.runelite.api.ItemComposition;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigDescriptor;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.discord.DiscordService;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.util.ImageCapture;
import net.runelite.http.api.RuneLiteAPI;
import okhttp3.Dispatcher;
import okhttp3.OkHttpClient;
import org.mockito.Mock;
import org.mockito.Mockito;

import java.awt.Image;
import java.util.Collections;
import java.util.EnumSet;
import java.util.concurrent.ScheduledExecutorService;
import java.util.function.Consumer;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

abstract class MockedNotifierTest extends MockedTestBase {

    protected static final String PLAYER_NAME = "dank dank";
    protected static final String PRIMARY_WEBHOOK_URL = System.getenv("TEST_WEBHOOK_URL");

    @Bind
    protected DinkPluginConfig config = Mockito.mock(DinkPluginConfig.class);

    @Bind
    protected Client client = Mockito.mock(Client.class);

    @Bind
    protected ClientThread clientThread = Mockito.spy(new BlockingClientThread());

    @Mock
    protected Player localPlayer;

    @Mock
    protected WorldView worldView;

    @Bind
    protected DrawManager drawManager = Mockito.mock(DrawManager.class);

    @Bind
    protected ImageCapture imageCapture = Mockito.mock(ImageCapture.class);

    @Bind
    protected Gson gson = RuneLiteAPI.GSON;

    @Bind
    protected OkHttpClient httpClient = new OkHttpClient();

    @Bind
    protected ScheduledExecutorService executor = new BlockingExecutor();

    @Bind
    protected DiscordService discordService = Mockito.mock(DiscordService.class);

    @Bind
    protected ChatMessageManager chatManager = Mockito.mock(ChatMessageManager.class);

    @Bind
    protected ItemManager itemManager = Mockito.mock(ItemManager.class);

    @Bind
    protected NPCManager npcManager = Mockito.mock(NPCManager.class);

    @Bind
    protected DinkPlugin plugin = Mockito.spy(DinkPlugin.class);

    @Bind
    protected ConfigManager configManager = Mockito.mock(ConfigManager.class);

    @Bind
    protected SettingsManager settingsManager = Mockito.spy(new SettingsManager(gson, client, clientThread, plugin, config, configManager, httpClient));

    @Bind
    protected DiscordMessageHandler messageHandler = Mockito.spy(new DiscordMessageHandler(gson, client, drawManager, httpClient, config, executor, clientThread, discordService, imageCapture));

    @Override
    protected void setUp() {
        super.setUp();

        // init client mocks
        when(client.getWorldType()).thenReturn(EnumSet.noneOf(WorldType.class));
        when(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).thenReturn(AccountType.GROUP_IRONMAN.ordinal());
        when(client.isPrayerActive(any())).thenReturn(false);
        when(client.getTopLevelWorldView()).thenReturn(worldView);
        when(client.getLocalPlayer()).thenReturn(localPlayer);
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(localPlayer.getName()).thenReturn(PLAYER_NAME);
        when(localPlayer.getWorldLocation()).thenReturn(new WorldPoint(2500, 2500, 0));
        when(localPlayer.getWorldView()).thenReturn(worldView);

        doAnswer(invocation -> {
            Consumer<Image> callback = invocation.getArgument(0);
            callback.accept(TestImageUtil.getExample());
            return null;
        }).when(drawManager).requestNextFrameListener(any());

        ConfigDescriptor configDescriptor = mock(ConfigDescriptor.class);
        when(configManager.getConfigDescriptor(any())).thenReturn(configDescriptor);
        when(configDescriptor.getItems()).thenReturn(Collections.emptyList());

        // init config mocks
        when(config.pluginVersion()).thenReturn("");
        when(config.primaryWebhook()).thenReturn(PRIMARY_WEBHOOK_URL);
        when(config.maxRetries()).thenReturn(0);
        when(config.baseRetryDelay()).thenReturn(2000);
        when(config.imageWriteTimeout()).thenReturn(30_000);
        when(config.screenshotScale()).thenReturn(95);
        when(config.discordRichEmbeds()).thenReturn(!"false".equalsIgnoreCase(System.getenv("TEST_WEBHOOK_RICH")));
        when(config.embedFooterText()).thenReturn("Powered by Dink");
        when(config.embedFooterIcon()).thenReturn("https://github.com/pajlads/DinkPlugin/raw/master/icon.png");
        when(config.playerLookupService()).thenReturn(PlayerLookupService.OSRS_HISCORE);
        when(config.threadNameTemplate()).thenReturn("[%TYPE%] %MESSAGE%");
        when(config.nameFilterMode()).thenReturn(FilterMode.DENY);
        when(config.embedColor()).thenReturn(Utils.PINK);
    }

    protected void mockItem(int id, int price, String name) {
        when(itemManager.getItemPrice(id)).thenReturn(price);
        ItemComposition item = mock(ItemComposition.class);
        when(item.getName()).thenReturn(name);
        when(item.getMembersName()).thenReturn(name);
        when(item.getNote()).thenReturn(-1);
        when(client.getItemDefinition(id)).thenReturn(item);
        when(itemManager.getItemComposition(id)).thenReturn(item);
        when(itemManager.canonicalize(id)).thenReturn(id);
    }

    protected void mockNpcs(NPC[] npcs) {
        Mockito.<IndexedObjectSet<? extends NPC>>when(worldView.npcs())
            .thenReturn(new IndexedArray<>(npcs));
    }

    protected void mockPlayers(Player[] players) {
        Mockito.<IndexedObjectSet<? extends Player>>when(worldView.players())
            .thenReturn(new IndexedArray<>(players));
    }

    @SneakyThrows
    protected void verifyCreateMessage(String url, boolean image, NotificationBody<?> body) {
        Mockito.verify(messageHandler).createMessage(url, image, body);

        // wait for http calls to complete
        if (url != null && !url.isEmpty() && !"https://example.com/".equals(url)) {
            Dispatcher dispatcher = httpClient.dispatcher();
            while (dispatcher.queuedCallsCount() > 0 || dispatcher.runningCallsCount() > 0) {
                // noinspection BusyWait - comply with discord's undocumented 30/60s ratelimit
                Thread.sleep(2000L);
            }
        }
    }

    protected static Template buildTemplate(String text) {
        return Template.builder().template(text).build();
    }

}

package dinkplugin.notifiers;

import dinkplugin.domain.CombatAchievementTier;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.stream.Stream;

import static dinkplugin.domain.CombatAchievementTier.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;

class CombatTaskMatcherTest {

    @ParameterizedTest(name = "Combat Achievement regex should match: {0}")
    @ArgumentsSource(AchievementProvider.class)
    void shouldParse(String message, Pair<CombatAchievementTier, String> expected) {
        assertEquals(expected, CombatTaskNotifier.parse(message).orElse(null));
    }

    @ParameterizedTest(name = "Combat Achievement regex should not match: {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen",
            "Your heriboar harvest count is: 69.",
            "Your King Black Dragon kill count is: 581.",
            "You have completed your task! You killed 31 TzKal-Zuk. You gained 75 xp.",
            "Congratulations, you just advanced a Strength level.",
            "Congratulations, you've completed a gachi combat task: Swordfight with the homies."
        }
    )
    void shouldNotParse(String message) {
        assertFalse(CombatTaskNotifier.parse(message).isPresent());
    }

    private static class AchievementProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of(
                    "Congratulations, you've completed an easy combat task: Defence? What Defence?.",
                    Pair.of(EASY, "Defence? What Defence?")
                ),
                Arguments.of(
                    "Congratulations, you've completed an easy combat task: A Slow Death.",
                    Pair.of(EASY, "A Slow Death")
                ),
                Arguments.of(
                    "Congratulations, you've completed a medium combat task: Fire in the Hole!.",
                    Pair.of(MEDIUM, "Fire in the Hole!")
                ),
                Arguments.of(
                    "Congratulations, you've completed a medium combat task: I'd rather Be Illiterate.",
                    Pair.of(MEDIUM, "I'd rather Be Illiterate")
                ),
                Arguments.of(
                    "Congratulations, you've completed a hard combat task: Whack-a-Mole.",
                    Pair.of(HARD, "Whack-a-Mole")
                ),
                Arguments.of(
                    "Congratulations, you've completed a master combat task: Nibblers, Begone!.",
                    Pair.of(MASTER, "Nibblers, Begone!")
                ),
                Arguments.of(
                    "Congratulations, you've completed a grandmaster combat task: Inferno Grandmaster.",
                    Pair.of(GRANDMASTER, "Inferno Grandmaster")
                ),
                Arguments.of(
                    "Congratulations, you've completed a hard combat task: I Can't Reach That (3 points).",
                    Pair.of(HARD, "I Can't Reach That")
                )
            );
        }
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.ChatNotificationType;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.ChatNotificationData;
import net.runelite.api.ChatMessageType;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanRank;
import net.runelite.api.clan.ClanSettings;
import net.runelite.api.clan.ClanTitle;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.config.Notification;
import net.runelite.client.events.NotificationFired;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.awt.TrayIcon;
import java.util.EnumSet;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class ChatNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    ChatNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // config mocks
        when(config.notifyChat()).thenReturn(true);
        when(config.chatMessageTypes()).thenReturn(EnumSet.of(ChatNotificationType.GAME, ChatNotificationType.COMMAND, ChatNotificationType.RUNELITE, ChatNotificationType.CLAN));
        when(config.chatNotifyMessage()).thenReturn("%SENDER%: %USERNAME% received a chat message:\n\n```\n%MESSAGE%\n```");
        setPatterns("You will be logged out in approximately 10 minutes.*\n" +
            "You will be logged out in approximately 5 minutes.*\n" +
            "Dragon impling is in the area\n" +
            "::TriggerDink\n" +
            "* has joined.");
    }

    @Test
    void testNotify() {
        // fire event
        String message = "You will be logged out in approximately 10 minutes.";
        notifier.onMessage(ChatMessageType.GAMEMESSAGE, null, message);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("[Game Engine]: " + PLAYER_NAME + " received a chat message:\n\n```\n" + message + "\n```")
                        .build()
                )
                .extra(new ChatNotificationData(ChatMessageType.GAMEMESSAGE, null, null, message))
                .type(NotificationType.CHAT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyCommand() {
        // fire event
        String message = "::TriggerDink";
        notifier.onCommand(new CommandExecuted(message.substring(2), new String[0]));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("[Client Commands]: " + PLAYER_NAME + " received a chat message:\n\n```\n" + message + "\n```")
                        .build()
                )
                .extra(new ChatNotificationData(ChatMessageType.UNKNOWN, "CommandExecuted", null, message))
                .type(NotificationType.CHAT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyTray() {
        // fire event
        String message = "Dragon impling is in the area";
        notifier.onNotification(new NotificationFired(Notification.ON, message, TrayIcon.MessageType.INFO));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("[RuneLite Notifications]: " + PLAYER_NAME + " received a chat message:\n\n```\n" + message + "\n```")
                        .build()
                )
                .extra(new ChatNotificationData(ChatMessageType.UNKNOWN, "NotificationFired", null, message))
                .type(NotificationType.CHAT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyClan() {
        // update mocks
        var channel = mock(ClanChannel.class);
        var settings = mock(ClanSettings.class);
        when(client.getClanChannel()).thenReturn(channel);
        when(client.getClanSettings()).thenReturn(settings);

        var rank = ClanRank.OWNER;
        var title = new ClanTitle(rank.getRank(), "Queen");
        when(settings.titleForRank(rank)).thenReturn(title);

        var member = mock(ClanChannelMember.class);
        when(channel.findMember("Poki")).thenReturn(member);
        when(member.getRank()).thenReturn(rank);

        // fire event
        String message = "Poki has joined.";
        notifier.onMessage(ChatMessageType.CLAN_MESSAGE, "", message);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("[Clan Notifications]: " + PLAYER_NAME + " received a chat message:\n\n```\n" + message + "\n```")
                        .build()
                )
                .extra(new ChatNotificationData(ChatMessageType.CLAN_MESSAGE, "", title, message))
                .type(NotificationType.CHAT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyPlayer() {
        // update mocks
        when(config.chatMessageTypes()).thenReturn(EnumSet.of(ChatNotificationType.PUBLIC));
        setPatterns("*");

        // fire event
        String source = "forsen";
        String message = "Basedge";
        notifier.onMessage(ChatMessageType.PUBLICCHAT, source, message);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(source + ": " + PLAYER_NAME + " received a chat message:\n\n```\n" + message + "\n```")
                        .build()
                )
                .extra(new ChatNotificationData(ChatMessageType.PUBLICCHAT, source, null, message))
                .type(NotificationType.CHAT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testIgnore() {
        // fire event
        notifier.onMessage(ChatMessageType.GAMEMESSAGE, null, "You will be logged out in approximately 30 minutes.");
        notifier.onMessage(ChatMessageType.PUBLICCHAT, null, "You will be logged out in approximately 10 minutes.");
        notifier.onMessage(ChatMessageType.TRADE, null, "You will be logged out in approximately 10 minutes.");
        notifier.onMessage(ChatMessageType.PRIVATECHAT, null, "You will be logged out in approximately 10 minutes.");
        notifier.onCommand(new CommandExecuted("You", "will be logged out in approximately 10 minutes.".split(" ")));
        notifier.onCommand(new CommandExecuted("DontTriggerDink", new String[0]));
        notifier.onNotification(new NotificationFired(Notification.ON, "TriggerDink", TrayIcon.MessageType.INFO));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // update config mock
        when(config.notifyChat()).thenReturn(false);

        // fire event
        notifier.onMessage(ChatMessageType.GAMEMESSAGE, null, "You will be logged out in approximately 10 minutes.");
        notifier.onCommand(new CommandExecuted("TriggerDink", new String[0]));

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private void setPatterns(String configValue) {
        when(config.chatPatterns()).thenReturn(configValue);
        notifier.onConfig(ChatNotifier.PATTERNS_CONFIG_KEY, configValue);
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.CombatAchievementTier;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.CombatAchievementData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class CombatTaskNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    CombatTaskNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyCombatTask()).thenReturn(true);
        when(config.combatTaskSendImage()).thenReturn(false);
        when(config.combatTaskMessage()).thenReturn("%USERNAME% has completed %TIER% combat task: %TASK%");
        when(config.combatTaskUnlockMessage()).thenReturn("%USERNAME% has unlocked the rewards for the %COMPLETED% tier, by completing the combat task: %TASK%");
        when(config.minCombatAchievementTier()).thenReturn(CombatAchievementTier.HARD);

        // init client mocks
        when(client.getVarbitValue(
            CombatTaskNotifier.CUM_POINTS_VARBIT_BY_TIER.get(CombatAchievementTier.EASY)
        )).thenReturn(33);
        when(client.getVarbitValue(
            CombatTaskNotifier.CUM_POINTS_VARBIT_BY_TIER.get(CombatAchievementTier.MEDIUM)
        )).thenReturn(115);
        when(client.getVarbitValue(
            CombatTaskNotifier.CUM_POINTS_VARBIT_BY_TIER.get(CombatAchievementTier.HARD)
        )).thenReturn(304);
        when(client.getVarbitValue(
            CombatTaskNotifier.CUM_POINTS_VARBIT_BY_TIER.get(CombatAchievementTier.MASTER)
        )).thenReturn(1465);
        when(client.getVarbitValue(
            CombatTaskNotifier.CUM_POINTS_VARBIT_BY_TIER.get(CombatAchievementTier.GRANDMASTER)
        )).thenReturn(2005);
    }

    @Test
    void testNotify() {
        // update mock
        when(client.getVarbitValue(CombatTaskNotifier.TOTAL_POINTS_ID)).thenReturn(200);

        // send fake message
        notifier.onTick();
        notifier.onGameMessage("Congratulations, you've completed a hard combat task: Whack-a-Mole.");

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has completed %s combat task: {{task}}", PLAYER_NAME, "Hard"))
                        .replacement("{{task}}", Replacements.ofWiki("Whack-a-Mole"))
                        .build()
                )
                .extra(new CombatAchievementData(CombatAchievementTier.HARD, "Whack-a-Mole", 3, 200, 85, 189, 2005,  CombatAchievementTier.MEDIUM, CombatAchievementTier.HARD, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.COMBAT_ACHIEVEMENT)
                .build()
        );
    }

    @Test
    void testNotifyUnlock() {
        // init thresholds
        notifier.onTick();

        // calculate points
        int oldPoints = 1460;
        CombatAchievementTier taskTier = CombatAchievementTier.GRANDMASTER;
        int newPoints = oldPoints + taskTier.getPoints();
        when(client.getVarbitValue(CombatTaskNotifier.TOTAL_POINTS_ID)).thenReturn(newPoints);

        // fire completion message
        notifier.onGameMessage("Congratulations, you've completed a grandmaster combat task: No Pressure (6 points).");

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildUnlockTemplate("Master", "No Pressure"))
                .extra(new CombatAchievementData(CombatAchievementTier.GRANDMASTER, "No Pressure", 6, 1466, 1466 - 1465, 2005 - 1465, 2005, null, CombatAchievementTier.GRANDMASTER, CombatAchievementTier.MASTER))
                .playerName(PLAYER_NAME)
                .type(NotificationType.COMBAT_ACHIEVEMENT)
                .build()
        );
    }

    @Test
    void testNotifyUnlockGrand() {
        // init thresholds
        notifier.onTick();

        // calculate points
        int oldPoints = 1999;
        CombatAchievementTier taskTier = CombatAchievementTier.GRANDMASTER;
        int newPoints = oldPoints + taskTier.getPoints();
        when(client.getVarbitValue(CombatTaskNotifier.TOTAL_POINTS_ID)).thenReturn(newPoints);

        // fire completion message
        notifier.onGameMessage("Congratulations, you've completed a grandmaster combat task: No Pressure (6 points).");

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildUnlockTemplate("Grandmaster", "No Pressure"))
                .extra(new CombatAchievementData(CombatAchievementTier.GRANDMASTER, "No Pressure", 6, 2005, null, null, 2005, null, null, CombatAchievementTier.GRANDMASTER))
                .playerName(PLAYER_NAME)
                .type(NotificationType.COMBAT_ACHIEVEMENT)
                .build()
        );
    }

    @Test
    void testSkipped() {
        // send too easy achievement
        notifier.onGameMessage("Congratulations, you've completed an easy combat task: A Slow Death.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnore() {
        // send unrelated message
        notifier.onGameMessage("Congratulations, you've completed a gachi combat task: Swordfight with the homies.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyCombatTask()).thenReturn(false);

        // send fake message
        notifier.onGameMessage("Congratulations, you've completed a hard combat task: Whack-a-Mole.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private static Template buildUnlockTemplate(String tier, String task) {
        return Template.builder()
            .template(String.format("%s has unlocked the rewards for the %s tier, by completing the combat task: {{task}}", PLAYER_NAME, tier))
            .replacement("{{task}}", Replacements.ofWiki(task))
            .build();
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.FilterMode;
import dinkplugin.domain.SeasonalPolicy;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.notifiers.data.PetNotificationData;
import dinkplugin.util.ItemSearcher;
import dinkplugin.util.ItemUtils;
import dinkplugin.util.KillCountService;
import dinkplugin.util.MathUtils;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.client.events.NpcLootReceived;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;

import java.util.Collections;
import java.util.EnumSet;
import java.util.stream.IntStream;

import static dinkplugin.notifiers.PetNotifier.MAX_TICKS_WAIT;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class PetNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    PetNotifier notifier;

    @Bind
    @Mock
    ItemSearcher itemSearcher;

    @Bind
    @InjectMocks
    KillCountService killCountService;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyPet()).thenReturn(true);
        when(config.petSendImage()).thenReturn(false);
        when(config.petNotifyMessage()).thenReturn("%USERNAME% got a pet");
    }

    @Test
    void testNotify() {
        // update mocks
        when(config.petNotifyMessage()).thenReturn("%USERNAME% %GAME_MESSAGE%");

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " feels something weird sneaking into their backpack"))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyDuplicate() {
        // update mocks
        when(config.petNotifyMessage()).thenReturn("%USERNAME% %GAME_MESSAGE%");

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you would have been followed...");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, true, true, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " has a funny feeling like they would have been followed..."))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyCollection() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);
        when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(1);
        String npcName = "TzTok-Jad";
        NPC npc = mock(NPC.class);
        when(npc.getName()).thenReturn(npcName);
        when(npc.getId()).thenReturn(NpcID.TZTOKJAD);
        int kc = 100;
        double rarity = 1.0 / 200;
        double luck = MathUtils.cumulativeGeometric(rarity, kc);
        when(configManager.getRSProfileConfiguration("killcount", npcName.toLowerCase(), int.class)).thenReturn(kc);
        killCountService.onNpcKill(new NpcLootReceived(npc, Collections.emptyList()));

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onChatMessage("New item added to your collection log: " + petName);
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, null, false, false, rarity, kc, luck))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyLostExistingCollection() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);
        when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(1);

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onChatMessage("Untradeable drop: " + petName);
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, null, false, true, 1.0 / 200, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyUntradeable() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onChatMessage("Untradeable drop: " + petName);
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, null, false, null, 1.0 / 200, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyUntradeableDuplicate() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you would have been followed...");
        notifier.onChatMessage("Untradeable drop: " + petName);
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, null, true, true, 1.0 / 200, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyUntradeableNotARealPet() {
        String petName = "Forsen";
        int itemId = ItemID.TZREKJAD;

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onChatMessage("Untradeable drop: " + petName);
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyMultipleSameName() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onChatMessage("Untradeable drop: " + petName);
        notifier.onTick();

        notifier.onChatMessage("random unrelated chat message");
        notifier.onClanNotification("random unrelated clan message");
        notifier.onTick();

        notifier.onClanNotification(
            String.format(
                "[ClanName] %s has a funny feeling like he would have been followed: %s at 50 killcount.",
                PLAYER_NAME,
                petName
            )
        );
        notifier.onTick();

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, "50 killcount", false, null, 1.0 / 200, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyClan() {
        String petName = "TzRek-Jad";
        int itemId = ItemID.TZREKJAD;

        // prepare mocks
        when(itemSearcher.findItemId("Tzrek-jad")).thenReturn(itemId);

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        notifier.onTick();

        notifier.onChatMessage("random unrelated chat message");
        notifier.onClanNotification("random unrelated clan message");
        notifier.onTick();

        notifier.onClanNotification(
            String.format(
                "[ClanName] %s has a funny feeling like he would have been followed: %s at 50 killcount.",
                PLAYER_NAME,
                petName
            )
        );
        notifier.onTick();

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(petName, "50 killcount", false, null, 1.0 / 200, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .thumbnailUrl(ItemUtils.getItemImageUrl(itemId))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyOverride() {
        // update mocks
        when(config.petNotifyMessage()).thenReturn("%USERNAME% %GAME_MESSAGE%");

        // define url override
        when(config.petWebhook()).thenReturn("https://example.com");

        // send fake message
        notifier.onChatMessage("You have a funny feeling like you're being followed.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled at override url
        verifyCreateMessage(
            "https://example.com",
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " has a funny feeling like they're being followed"))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testIgnore() {
        // send non-pet message
        notifier.onChatMessage("You feel Forsen's warmth behind you.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyPet()).thenReturn(false);

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifySeasonal() {
        // update mocks
        when(config.seasonalPolicy()).thenReturn(SeasonalPolicy.ACCEPT);
        when(client.getWorldType()).thenReturn(EnumSet.of(WorldType.SEASONAL));

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testIgnoreSeasonal() {
        // update mocks
        when(config.seasonalPolicy()).thenReturn(SeasonalPolicy.REJECT);
        when(client.getWorldType()).thenReturn(EnumSet.of(WorldType.SEASONAL));

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyIrrelevantNameIgnore() {
        // ignore notifications for an irrelevant player
        when(config.filteredNames()).thenReturn("xqc");
        settingsManager.init();

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .type(NotificationType.PET)
                .build()
        );
    }

    @Test
    void testNotifyNameAllowList() {
        // only allow notifications for "dank dank"
        when(config.nameFilterMode()).thenReturn(FilterMode.ALLOW);
        when(config.filteredNames()).thenReturn(PLAYER_NAME);
        settingsManager.init();

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .extra(new PetNotificationData(null, null, false, null, null, null, null))
                .text(buildTemplate(PLAYER_NAME + " got a pet"))
                .type(NotificationType.PET)
                .build());
    }

    @Test
    void testIgnoreNameAllowList() {
        // only allow notifications for a different player
        when(config.nameFilterMode()).thenReturn(FilterMode.ALLOW);
        when(config.filteredNames()).thenReturn("xqc");
        settingsManager.init();

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoredPlayerName() {
        // ignore notifications for our player name
        when(config.filteredNames()).thenReturn(PLAYER_NAME);
        settingsManager.init();

        // send fake message
        notifier.onChatMessage("You feel something weird sneaking into your backpack.");
        IntStream.rangeClosed(0, MAX_TICKS_WAIT).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.AccountType;
import dinkplugin.domain.LeagueRelicTier;
import dinkplugin.domain.LeagueTaskDifficulty;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.LeaguesAreaNotificationData;
import dinkplugin.notifiers.data.LeaguesMasteryNotificationData;
import dinkplugin.notifiers.data.LeaguesRelicNotificationData;
import dinkplugin.notifiers.data.LeaguesTaskNotificationData;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled; // unused when there's an active leagues
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.EnumSet;

import static dinkplugin.notifiers.LeaguesNotifier.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class LeaguesNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    LeaguesNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // client mocks
        when(client.getWorldType()).thenReturn(EnumSet.of(WorldType.SEASONAL));
        when(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).thenReturn(AccountType.IRONMAN.ordinal());
        when(client.getVarbitValue(LeaguesNotifier.LEAGUES_VERSION)).thenReturn(LeaguesNotifier.CURRENT_LEAGUE_VERSION);

        // config mocks
        when(config.notifyLeagues()).thenReturn(true);
        when(config.leaguesAreaUnlock()).thenReturn(true);
        when(config.leaguesRelicUnlock()).thenReturn(true);
        when(config.leaguesTaskCompletion()).thenReturn(true);
        when(config.leaguesMasteryUnlock()).thenReturn(true);
        when(config.leaguesTaskMinTier()).thenReturn(LeagueTaskDifficulty.HARD);
    }

    @Test
    void notifyMastery() {
        // fire event
        notifier.onGameMessage("Congratulations, you've unlocked a new Melee Combat Mastery: Melee I.");

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_MASTERY)
                .text(
                    Template.builder()
                        .template(String.format("%s unlocked a new Combat Mastery: {{mastery}}.", PLAYER_NAME))
                        .replacement("{{mastery}}", Replacements.ofWiki("Melee I"))
                        .build()
                )
                .extra(new LeaguesMasteryNotificationData("Melee", 1))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyArea() {
        // update client mocks
        int tasksCompleted = 200;
        int totalPoints = 100 * 10 + 100 * 40;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);
        when(client.getVarbitValue(LeaguesNotifier.TWO_AREAS)).thenReturn(2);
        when(client.getVarbitValue(LeaguesNotifier.THREE_AREAS)).thenReturn(4);
        when(client.getVarbitValue(LeaguesNotifier.FOUR_AREAS)).thenReturn(8);

        // fire event
        notifier.onGameMessage("Congratulations, you've unlocked a new area: Kandarin.");

        // verify notification
        String area = "Kandarin";
        int tasksUntilNextArea = THIRD_AREA_TASKS - tasksCompleted;
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_AREA)
                .text(
                    Template.builder()
                        .template(String.format("%s selected their second region: {{area}}.", PLAYER_NAME))
                        .replacement("{{area}}", Replacements.ofWiki(area, CURRENT_LEAGUE_NAME + " League/Areas/" + area))
                        .build()
                )
                .extra(new LeaguesAreaNotificationData(area, 2, tasksCompleted, tasksUntilNextArea))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyAreaKaramja() {
        // update client mocks
        int tasksCompleted = 2;
        int totalPoints = 2 * 10;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);
        when(client.getVarbitValue(LeaguesNotifier.TWO_AREAS)).thenReturn(2);

        // fire event
        notifier.onGameMessage("Congratulations, you've unlocked a new area: Karamja.");

        // verify notification
        String area = "Karamja";
        int tasksUntilNextArea = FIRST_AREA_TASKS - tasksCompleted;
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_AREA)
                .text(
                    Template.builder()
                        .template(String.format("%s selected their zeroth region: {{area}}.", PLAYER_NAME))
                        .replacement("{{area}}", Replacements.ofWiki(area, CURRENT_LEAGUE_NAME + " League/Areas/" + area))
                        .build()
                )
                .extra(new LeaguesAreaNotificationData(area, 0, tasksCompleted, tasksUntilNextArea))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyRelic() {
        // update client mocks
        int tasksCompleted = 2;
        int totalPoints = 2 * 10;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);

        // fire event
        notifier.onGameMessage("Congratulations, you've unlocked a new Relic: Animal Wrangler.");

        // verify notification
        String relic = "Animal Wrangler";
        int pointsUntilNextTier = LeagueRelicTier.TWO.getDefaultPoints() - totalPoints;
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_RELIC)
                .text(
                    Template.builder()
                        .template(String.format("%s unlocked a Tier 1 Relic: {{relic}}.", PLAYER_NAME))
                        .replacement("{{relic}}", Replacements.ofWiki(relic))
                        .build()
                )
                .extra(new LeaguesRelicNotificationData(relic, 1, 0, totalPoints, pointsUntilNextTier))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyTask() {
        // update client mocks
        int tasksCompleted = 101;
        int totalPoints = 100 * 10 + 80;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard task: The Frozen Door.");

        // verify notification
        String taskName = "The Frozen Door";
        LeagueTaskDifficulty difficulty = LeagueTaskDifficulty.HARD;
        int tasksUntilNextArea = SECOND_AREA_TASKS - tasksCompleted;
        int pointsUntilNextRelic = LeagueRelicTier.THREE.getDefaultPoints() - totalPoints;
        int pointsUntilNextTrophy = 2_000 - totalPoints;
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_TASK)
                .text(
                    Template.builder()
                        .template(String.format("%s completed a %s task: {{task}}.", PLAYER_NAME, "Hard"))
                        .replacement("{{task}}", Replacements.ofWiki(taskName, CURRENT_LEAGUE_NAME + " League/Tasks"))
                        .build()
                )
                .extra(new LeaguesTaskNotificationData(taskName, difficulty, difficulty.getPoints(), totalPoints, tasksCompleted, tasksUntilNextArea, pointsUntilNextRelic, pointsUntilNextTrophy, null))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyTaskTrophyBronze() {
        // update client mocks
        int tasksCompleted = 113;
        int totalPoints = 100 * 10 + 80 * 13; // 2040 >= 2000
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard task: The Frozen Door.");

        // verify notification
        String taskName = "The Frozen Door";
        LeagueTaskDifficulty difficulty = LeagueTaskDifficulty.HARD;
        int tasksUntilNextArea = SECOND_AREA_TASKS - tasksCompleted;
        int pointsUntilNextRelic = LeagueRelicTier.FOUR.getDefaultPoints() - totalPoints;
        int pointsUntilNextTrophy = 4_000 - totalPoints;
        String trophy = "Bronze";
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_TASK)
                .text(
                    Template.builder()
                        .template(String.format("%s completed a %s task, {{task}}, unlocking the {{trophy}} trophy!", PLAYER_NAME, "Hard"))
                        .replacement("{{task}}", Replacements.ofWiki(taskName, CURRENT_LEAGUE_NAME + " League/Tasks"))
                        .replacement("{{trophy}}", Replacements.ofWiki(trophy, CURRENT_LEAGUE_NAME + " " + trophy.toLowerCase() + " trophy"))
                        .build()
                )
                .extra(new LeaguesTaskNotificationData(taskName, difficulty, difficulty.getPoints(), totalPoints, tasksCompleted, tasksUntilNextArea, pointsUntilNextRelic, pointsUntilNextTrophy, trophy))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void notifyTaskTrophyIron() {
        // update mocks
        int tasksCompleted = 200;
        int totalPoints = 100 * 10 + 100 * 30; // 4000 >= 4000
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);
        when(config.leaguesTaskMinTier()).thenReturn(LeagueTaskDifficulty.EASY);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a medium task: Equip Amy's Saw.");

        // verify notification
        String taskName = "Equip Amy's Saw";
        LeagueTaskDifficulty difficulty = LeagueTaskDifficulty.MEDIUM;
        int tasksUntilNextArea = THIRD_AREA_TASKS - tasksCompleted;
        int pointsUntilNextRelic = LeagueRelicTier.FIVE.getDefaultPoints() - totalPoints;
        int pointsUntilNextTrophy = 10_000 - totalPoints;
        String trophy = "Iron";
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.LEAGUES_TASK)
                .text(
                    Template.builder()
                        .template(String.format("%s completed a %s task, {{task}}, unlocking the {{trophy}} trophy!", PLAYER_NAME, "Medium"))
                        .replacement("{{task}}", Replacements.ofWiki(taskName, CURRENT_LEAGUE_NAME + " League/Tasks"))
                        .replacement("{{trophy}}", Replacements.ofWiki(trophy, CURRENT_LEAGUE_NAME + " " + trophy.toLowerCase() + " trophy"))
                        .build()
                )
                .extra(new LeaguesTaskNotificationData(taskName, difficulty, difficulty.getPoints(), totalPoints, tasksCompleted, tasksUntilNextArea, pointsUntilNextRelic, pointsUntilNextTrophy, trophy))
                .playerName(PLAYER_NAME)
                .seasonalWorld(true)
                .build()
        );
    }

    @Test
    void ignoreTaskTier() {
        // update config mock
        when(config.leaguesTaskMinTier()).thenReturn(LeagueTaskDifficulty.ELITE);

        // update client mocks
        int tasksCompleted = 101;
        int totalPoints = 100 * 10 + 40;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard task: The Frozen Door.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnored() {
        // update config mocks
        when(config.leaguesAreaUnlock()).thenReturn(false);
        when(config.leaguesRelicUnlock()).thenReturn(false);
        when(config.leaguesTaskCompletion()).thenReturn(false);
        when(config.leaguesMasteryUnlock()).thenReturn(false);

        // update client mocks
        int tasksCompleted = 101;
        int totalPoints = 100 * 10 + 80;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);
        when(client.getVarbitValue(LeaguesNotifier.TWO_AREAS)).thenReturn(2);
        when(client.getVarbitValue(LeaguesNotifier.THREE_AREAS)).thenReturn(4);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard task: The Frozen Door.");
        notifier.onGameMessage("Congratulations, you've unlocked a new Relic: Animal Wrangler.");
        notifier.onGameMessage("Congratulations, you've unlocked a new area: Kandarin.");
        notifier.onGameMessage("Congratulations, you've unlocked a new Melee Combat Mastery: Melee I.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // update config mocks
        when(config.notifyLeagues()).thenReturn(false);

        // update client mocks
        int tasksCompleted = 101;
        int totalPoints = 100 * 10 + 80;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);
        when(client.getVarbitValue(LeaguesNotifier.TWO_AREAS)).thenReturn(2);
        when(client.getVarbitValue(LeaguesNotifier.THREE_AREAS)).thenReturn(4);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard task: The Frozen Door.");
        notifier.onGameMessage("Congratulations, you've unlocked a new Relic: Animal Wrangler.");
        notifier.onGameMessage("Congratulations, you've unlocked a new area: Kandarin.");
        notifier.onGameMessage("Congratulations, you've unlocked a new Melee Combat Mastery: Melee I.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void ignoreIrrelevant() {
        // update client mocks
        int tasksCompleted = 101;
        int totalPoints = 100 * 10 + 80;
        when(client.getVarbitValue(LeaguesNotifier.TASKS_COMPLETED_ID)).thenReturn(tasksCompleted);
        when(client.getVarpValue(LeaguesNotifier.POINTS_EARNED_ID)).thenReturn(totalPoints);

        // fire event
        notifier.onGameMessage("Congratulations, you've completed a hard combat task: Ready to Pounce.");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.notifiers.data.TradeNotificationData;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.List;

import static org.mockito.Mockito.any;
import static org.mockito.Mockito.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class TradeNotifierTest extends MockedNotifierTest {
    private static final String COUNTERPARTY = "Billy";

    private static final int OPAL_PRICE = 600;
    private static final int RUBY_PRICE = 900;

    @Bind
    @InjectMocks
    TradeNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyTrades()).thenReturn(true);
        when(config.tradeMinValue()).thenReturn(2000);
        when(config.tradeNotifyMessage()).thenReturn("%USERNAME% traded with %COUNTERPARTY%");

        // init item mocks
        mockItem(ItemID.OPAL, OPAL_PRICE, "Opal");
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
    }

    @Test
    void testNotify() {
        // update mocks
        when(client.getVarcStrValue(TradeNotifier.TRADE_COUNTERPARTY_VAR)).thenReturn(COUNTERPARTY);

        ItemContainer tradeContainer = mock(ItemContainer.class);
        Item[] tradeItems = {new Item(ItemID.OPAL, 2)};
        when(tradeContainer.getItems()).thenReturn(tradeItems);
        when(client.getItemContainer(InventoryID.TRADE)).thenReturn(tradeContainer);

        ItemContainer otherContainer = mock(ItemContainer.class);
        Item[] otherItems = {new Item(ItemID.RUBY, 1)};
        when(otherContainer.getItems()).thenReturn(otherItems);
        when(client.getItemContainer(InventoryID.TRADEOTHER)).thenReturn(otherContainer);

        // fire event
        notifier.onTradeMessage(TradeNotifier.TRADE_ACCEPTED_MESSAGE);

        // verify handled
        List<SerializedItemStack> received = List.of(
            new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby")
        );
        List<SerializedItemStack> discarded = List.of(
            new SerializedItemStack(ItemID.OPAL, 2, OPAL_PRICE, "Opal")
        );
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("%USERNAME% traded with %COUNTERPARTY%")
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .replacement("%COUNTERPARTY%", Replacements.ofLink(COUNTERPARTY, config.playerLookupService().getPlayerUrl(COUNTERPARTY)))
                        .build()
                )
                .extra(new TradeNotificationData(COUNTERPARTY, received, discarded, RUBY_PRICE, 2 * OPAL_PRICE))
                .type(NotificationType.TRADE)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testIgnoreValue() {
        // update mocks
        when(client.getVarcStrValue(TradeNotifier.TRADE_COUNTERPARTY_VAR)).thenReturn(COUNTERPARTY);

        ItemContainer tradeContainer = mock(ItemContainer.class);
        Item[] tradeItems = {new Item(ItemID.OPAL, 1)};
        when(tradeContainer.getItems()).thenReturn(tradeItems);
        when(client.getItemContainer(InventoryID.TRADE)).thenReturn(tradeContainer);

        ItemContainer otherContainer = mock(ItemContainer.class);
        Item[] otherItems = {new Item(ItemID.RUBY, 1)};
        when(otherContainer.getItems()).thenReturn(otherItems);
        when(client.getItemContainer(InventoryID.TRADEOTHER)).thenReturn(otherContainer);

        // fire event
        notifier.onTradeMessage(TradeNotifier.TRADE_ACCEPTED_MESSAGE);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // update mocks
        when(config.notifyTrades()).thenReturn(false);
        when(client.getVarcStrValue(TradeNotifier.TRADE_COUNTERPARTY_VAR)).thenReturn(COUNTERPARTY);

        ItemContainer tradeContainer = mock(ItemContainer.class);
        Item[] tradeItems = {new Item(ItemID.OPAL, 2)};
        when(tradeContainer.getItems()).thenReturn(tradeItems);
        when(client.getItemContainer(InventoryID.TRADE)).thenReturn(tradeContainer);

        ItemContainer otherContainer = mock(ItemContainer.class);
        Item[] otherItems = {new Item(ItemID.RUBY, 1)};
        when(otherContainer.getItems()).thenReturn(otherItems);
        when(client.getItemContainer(InventoryID.TRADEOTHER)).thenReturn(otherContainer);

        // fire event
        notifier.onTradeMessage(TradeNotifier.TRADE_ACCEPTED_MESSAGE);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.regex.Matcher;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

class MatchersTest {

    @ParameterizedTest(name = "Slayer task completion message should trigger {0}")
    @ArgumentsSource(SlayerTaskProvider.class)
    void slayerTaskCompletionRegexFindsMatch(String message, String task) {
        Matcher matcher = SlayerNotifier.SLAYER_TASK_REGEX.matcher(message);
        assertTrue(matcher.find());
        assertEquals(task, matcher.group("task"));
    }

    @ParameterizedTest(name = "Slayer task completion message should not trigger {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen",
            "You're assigned to kill kalphite; only 3 more to go.",
            "You've completed 234 tasks and received 15 points, giving you a total of 801; return to a Slayer master."
        }
    )
    void slayerTaskCompletionRegexDoesNotMatch(String message) {
        Matcher matcher = SlayerNotifier.SLAYER_TASK_REGEX.matcher(message);
        assertFalse(matcher.find());
    }

    private static class SlayerTaskProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of(
                    "You have completed your task! You killed 125 Kalphite. You gained 11,150 xp.",
                    "125 Kalphite"
                ),
                Arguments.of("You have completed your task! You killed 7 Ankous. You gained 75 xp.", "7 Ankous"),
                Arguments.of(
                    "You have completed your task! You killed 134 Abyssal demons. You gained 75 xp.",
                    "134 Abyssal demons"
                ),
                Arguments.of(
                    "You have completed your task! You killed 134 Fossil Island Wyverns. You gained 75 xp.",
                    "134 Fossil Island Wyverns"
                ),
                Arguments.of("You have completed your task! You killed 31 Kree'Arra. You gained 75 xp.", "31 Kree'Arra"),
                Arguments.of("You have completed your task! You killed 31 TzKal-Zuk. You gained 75 xp.", "31 TzKal-Zuk")
            );
        }
    }

    @ParameterizedTest(name = "Collection log message should trigger {0}")
    @ArgumentsSource(CollectionLogProvider.class)
    void collectionLogRegexFindsMatch(String message, String item) {
        Matcher matcher = CollectionNotifier.COLLECTION_LOG_REGEX.matcher(message);
        assertTrue(matcher.find());
        assertEquals(item, matcher.group("itemName"));
    }

    @ParameterizedTest(name = "Collection log message should not trigger {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen" // todo: add more bad examples
        }
    )
    void collectionLogRegexDoesNotMatch(String message) {
        Matcher matcher = CollectionNotifier.COLLECTION_LOG_REGEX.matcher(message);
        assertFalse(matcher.find());
    }

    private static class CollectionLogProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of("New item added to your collection log: Red d'hide body (t)",
                    "Red d'hide body (t)"),
                Arguments.of("New item added to your collection log: Rune full helm (g)",
                    "Rune full helm (g)"),
                Arguments.of("New item added to your collection log: Robin hood hat",
                    "Robin hood hat"),
                Arguments.of("New item added to your collection log: Amulet of glory (t4)",
                    "Amulet of glory (t4)"),
                Arguments.of("New item added to your collection log: Blue d'hide chaps (t)",
                    "Blue d'hide chaps (t)"),
                Arguments.of("New item added to your collection log: Lumberjack boots",
                    "Lumberjack boots")
            );
        }
    }

    @ParameterizedTest(name = "Kill count message should trigger on: {0}")
    @ArgumentsSource(KillCountProvider.class)
    void killCountRegexFindsMatch(String message, Pair<String, Integer> expected) {
        assertEquals(expected, KillCountNotifier.parseBoss(message).orElse(null));
    }

    @ParameterizedTest(name = "Kill count message should not trigger on: {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen"
        }
    )
    void killCountRegexDoesNotMatch(String message) {
        assertFalse(KillCountNotifier.parseBoss(message).isPresent());
    }

    private static class KillCountProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                // standard kill count string
                Arguments.of("Your King Black Dragon kill count is: 581.", Pair.of("King Black Dragon", 581)),
                Arguments.of("Your Cerberus kill count is: 3273.", Pair.of("Cerberus", 3273)),
                Arguments.of("Your K'ril Tsutsaroth kill count is: 481", Pair.of("K'ril Tsutsaroth", 481)),
                Arguments.of("Your TzTok-Jad kill count is: 46", Pair.of("TzTok-Jad", 46)),

                // skilling special case
                Arguments.of("Your subdued Wintertodt count is: 359", Pair.of("Wintertodt", 359)),
                Arguments.of("Your herbiboar harvest count is: 2332.", Pair.of("Herbiboar", 2332)),

                // minigame special cases
                Arguments.of("Your Barrows chest count is: 268", Pair.of("Barrows", 268)),
                Arguments.of("Your Gauntlet completion count is: 8", Pair.of("Crystalline Hunllef", 8)),
                Arguments.of("Your Corrupted Gauntlet completion count is: 109", Pair.of("Corrupted Hunllef", 109)),

                // raid special cases
                Arguments.of("Your completed Theatre of Blood: Entry Mode count is: 1", Pair.of("Theatre of Blood: Entry Mode", 1)),
                Arguments.of("Your completed Theatre of Blood count is: 951", Pair.of("Theatre of Blood", 951)),
                Arguments.of("Your completed Theatre of Blood: Hard Mode count is: 2", Pair.of("Theatre of Blood: Hard Mode", 2)),
                Arguments.of("Your completed Chambers of Xeric count is: 138", Pair.of("Chambers of Xeric", 138)),
                Arguments.of("Your completed Chambers of Xeric Challenge Mode count is: 138", Pair.of("Chambers of Xeric Challenge Mode", 138)),
                Arguments.of("Your completed Tombs of Amascut: Entry Mode count is: 7", Pair.of("Tombs of Amascut: Entry Mode", 7)),
                Arguments.of("Your completed Tombs of Amascut count is: 101", Pair.of("Tombs of Amascut", 101)),
                Arguments.of("Your completed Tombs of Amascut: Expert Mode count is: 3", Pair.of("Tombs of Amascut: Expert Mode", 3))
            );
        }
    }

    @ParameterizedTest(name = "Gamble message should trigger {0}")
    @ArgumentsSource(GambleProvider.class)
    void gambleRegexFindsMatch(String message, GambleNotifier.ParsedData data) {
        assertEquals(data, GambleNotifier.parse(message));
    }

    @ParameterizedTest(name = "Gamble message should not trigger {0}")
    @ValueSource(
        strings = {
            "Coal (x 150)! Low level gamble count: 14.",
            "Rune full helm! Medium level gamble count: 3.",
            "High level gamble count: 100."
        }
    )
    void gambleRegexDoesNotMatch(String message) {
        assertNull(GambleNotifier.parse(message));
    }

    private static class GambleProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of("Magic seed! High level gamble count: 1.", new GambleNotifier.ParsedData("Magic seed", 1, null, 1)),
                Arguments.of("Limpwurt root (x 37)! High level gamble count: 65.", new GambleNotifier.ParsedData("Limpwurt root", 37, null, 65)),
                Arguments.of("Farseer helm! Clue scroll (elite)! High level gamble count: 774.", new GambleNotifier.ParsedData("Farseer helm", 1, "Clue scroll (elite)", 774)),
                Arguments.of("Law rune (x 270)! Clue scroll (elite)! High level gamble count: 1762.", new GambleNotifier.ParsedData("Law rune", 270, "Clue scroll (elite)", 1762))
            );
        }
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.notifiers.data.LoginNotificationData;
import dinkplugin.notifiers.data.Progress;
import dinkplugin.util.SerializedPet;
import net.runelite.api.Experience;
import net.runelite.api.GameState;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.client.config.RuneLiteConfig;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class MetaNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    MetaNotifier notifier;

    int world = 420;
    int level = 50;
    long xp = Experience.getXpForLevel(level);
    int skillCount = Skill.values().length;
    String url = StringUtils.isNotBlank(PRIMARY_WEBHOOK_URL) ? PRIMARY_WEBHOOK_URL : "https://example.com";

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // update config mocks
        when(config.metadataWebhook()).thenReturn(url);

        // update client mocks
        when(client.getWorld()).thenReturn(world);

        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(1312);
        when(client.getVarpValue(CollectionNotifier.TOTAL_VARP)).thenReturn(1477);

        when(client.getVarbitValue(CombatTaskNotifier.TOTAL_POINTS_ID)).thenReturn(1984);
        when(client.getVarbitValue(CombatTaskNotifier.GRANDMASTER_TOTAL_POINTS_ID)).thenReturn(2005);

        when(client.getVarbitValue(Varbits.DIARY_FALADOR_EASY)).thenReturn(1);
        when(client.getVarbitValue(Varbits.DIARY_VARROCK_EASY)).thenReturn(1);
        when(client.getVarbitValue(Varbits.DIARY_WILDERNESS_EASY)).thenReturn(1);

        when(client.getVarbitValue(Varbits.BA_GC)).thenReturn(666);

        when(client.getRealSkillLevel(any())).thenReturn(level);
        when(client.getSkillExperience(any())).thenReturn((int) xp);
        when(client.getTotalLevel()).thenReturn(skillCount * level);
        when(client.getOverallExperience()).thenReturn(skillCount * xp);

        when(client.getVarbitValue(QuestNotifier.COMPLETED_ID)).thenReturn(21);
        when(client.getVarbitValue(QuestNotifier.TOTAL_ID)).thenReturn(158);
        when(client.getVarpValue(VarPlayer.QUEST_POINTS)).thenReturn(43);
        when(client.getVarbitValue(QuestNotifier.QP_TOTAL_ID)).thenReturn(300);

        when(client.getVarbitValue(Varbits.SLAYER_POINTS)).thenReturn(2484);
        when(client.getVarbitValue(Varbits.SLAYER_TASK_STREAK)).thenReturn(300);

        // too lazy to mock script results, just return zero so excluded from serialization in tests
        when(client.getIntStack()).thenReturn(new int[1]);
    }

    @Test
    void testNotify() {
        // fire event
        notifier.onGameState(GameState.LOGGING_IN, GameState.LOGGED_IN);
        IntStream.rangeClosed(0, MetaNotifier.INIT_TICKS).forEach(i -> notifier.onTick());

        // verify handled
        Map<String, Integer> levels = Arrays.stream(Skill.values())
            .collect(Collectors.toMap(Skill::getName, s -> level));
        Map<String, Integer> exp = Arrays.stream(Skill.values())
            .collect(Collectors.toMap(Skill::getName, s -> (int) xp));
        LoginNotificationData extra = new LoginNotificationData(world,
            Progress.of(1312, 1477),
            Progress.of(1984, 2005),
            Progress.of(3, 48),
            null,
            new LoginNotificationData.BarbarianAssault(666),
            new LoginNotificationData.SkillData(xp * skillCount, level * skillCount, levels, exp),
            Progress.of(21, 158), Progress.of(43, 300),
            new LoginNotificationData.SlayerData(2484, 300),
            null
        );
        verifyCreateMessage(
            url,
            false,
            NotificationBody.builder()
                .extra(extra)
                .text(buildTemplate(PLAYER_NAME + " logged into World " + world))
                .type(NotificationType.LOGIN)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyWithoutCollection() {
        // update client mock
        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(0);
        when(client.getVarpValue(CollectionNotifier.TOTAL_VARP)).thenReturn(0);

        // fire events
        notifier.onGameState(GameState.LOGGING_IN, GameState.LOGGED_IN);
        IntStream.rangeClosed(0, MetaNotifier.INIT_TICKS).forEach(i -> notifier.onTick());

        // verify handled
        Map<String, Integer> levels = Arrays.stream(Skill.values())
            .collect(Collectors.toMap(Skill::getName, s -> level));
        Map<String, Integer> exp = Arrays.stream(Skill.values())
            .collect(Collectors.toMap(Skill::getName, s -> (int) xp));
        LoginNotificationData extra = new LoginNotificationData(world,
            null, // collection log data should not be present
            Progress.of(1984, 2005),
            Progress.of(3, 48),
            null,
            new LoginNotificationData.BarbarianAssault(666),
            new LoginNotificationData.SkillData(xp * skillCount, level * skillCount, levels, exp),
            Progress.of(21, 158), Progress.of(43, 300),
            new LoginNotificationData.SlayerData(2484, 300),
            null
        );
        verifyCreateMessage(
            url,
            false,
            NotificationBody.builder()
                .extra(extra)
                .text(buildTemplate(PLAYER_NAME + " logged into World " + world))
                .type(NotificationType.LOGIN)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testDisabled() {
        // update config mock
        when(config.metadataWebhook()).thenReturn("");

        // fire event
        notifier.onGameState(GameState.LOGGING_IN, GameState.LOGGED_IN);
        IntStream.rangeClosed(0, MetaNotifier.INIT_TICKS).forEach(i -> notifier.onTick());

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testPetDeserialization() {
        when(configManager.getConfiguration(RuneLiteConfig.GROUP_NAME, MetaNotifier.RL_CHAT_CMD_PLUGIN_NAME))
            .thenReturn(Boolean.TRUE.toString());

        when(configManager.getRSProfileConfiguration("chatcommands", "pets2"))
            .thenReturn(String.format("[%d, %d]", ItemID.HERBI, ItemID.BABY_MOLE));

        mockItem(ItemID.HERBI, 0, "Herbi");
        mockItem(ItemID.BABY_MOLE, 0, "Baby mole");

        List<SerializedPet> expected = List.of(
            new SerializedPet(ItemID.HERBI, "Herbi"),
            new SerializedPet(ItemID.BABY_MOLE, "Baby mole")
        );
        Assertions.assertEquals(expected, notifier.getPets());
    }

    @Test
    void testLogoutNotify() {
        // Update config mock
        when(config.metadataWebhook()).thenReturn(url);

        // fire event
        notifier.onGameState(GameState.LOGGED_IN, GameState.LOGIN_SCREEN);
        // verify notifier
        verifyCreateMessage(
            url,
            false,
            NotificationBody.builder()
                .text(buildTemplate(PLAYER_NAME + " logged out"))
                .type(NotificationType.LOGOUT)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testLogoutDisabled() {
        // update config mock
        when(config.metadataWebhook()).thenReturn("");

        // fire event
        notifier.onGameState(GameState.LOGGED_IN, GameState.LOGIN_SCREEN);
        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.util.TimeUtils;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.notifiers.data.BossNotificationData;
import dinkplugin.util.Utils;
import net.runelite.api.NPC;
import net.runelite.api.Varbits;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.http.api.RuneLiteAPI;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.time.Duration;
import java.util.Collections;
import java.util.List;
import java.util.stream.IntStream;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class KillCountNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    KillCountNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyKillCount()).thenReturn(true);
        when(config.killCountNotifyBestTime()).thenReturn(true);
        when(config.killCountSendImage()).thenReturn(true);
        when(config.killCountMessage()).thenReturn("%USERNAME% has defeated %BOSS% with a completion count of %COUNT%");
        when(config.killCountBestTimeMessage()).thenReturn("%USERNAME% has defeated %BOSS% with a new personal best time of %TIME% and a completion count of %COUNT%");

        // init client mocks
        when(client.getVarbitValue(TimeUtils.ENABLE_PRECISE_TIMING)).thenReturn(1);
        mockNpcs(new NPC[0]);
    }

    @Test
    void testNotifyInterval() {
        // more mocks
        when(config.killCountNotifyInitial()).thenReturn(false);
        when(config.killCountInterval()).thenReturn(70);
        when(configManager.getRSProfileConfiguration("personalbest", "king black dragon", double.class)).thenReturn(29.6);

        // fire event
        String gameMessage = "Your King Black Dragon kill count is: 420.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildTemplate("King Black Dragon", 420))
            .extra(new BossNotificationData("King Black Dragon", 420, gameMessage, null, null, Duration.ofSeconds(29).plusMillis(600), null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testNotifyInitial() {
        // more config
        when(config.killCountNotifyInitial()).thenReturn(true);
        when(config.killCountInterval()).thenReturn(99);

        // fire event
        String gameMessage = "Your King Black Dragon kill count is: 1.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate("King Black Dragon", 1))
                .extra(new BossNotificationData("King Black Dragon", 1, gameMessage, null, null, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testIgnore() {
        // more config
        when(config.killCountNotifyInitial()).thenReturn(false);
        when(config.killCountInterval()).thenReturn(99);

        // fire event
        String gameMessage = "Your King Black Dragon kill count is: 1.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // more config
        when(config.notifyKillCount()).thenReturn(false);
        when(config.killCountNotifyInitial()).thenReturn(true);
        when(config.killCountInterval()).thenReturn(1);

        // fire event
        String gameMessage = "Your King Black Dragon kill count is: 1.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        String gameMessage = "Your Zulrah kill count is: 12.";
        notifier.onGameMessage(gameMessage);
        notifier.onGameMessage("Fight duration: 0:56.50 (new personal best).");
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildPbTemplate("Zulrah", "00:56.50", 12))
            .extra(new BossNotificationData("Zulrah", 12, gameMessage, Duration.ofSeconds(56).plusMillis(500), true, null, null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testNotifyPbDelayed() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Fight duration: 1:54.00 (new personal best)");
        IntStream.range(0, KillCountNotifier.MAX_BAD_TICKS - 1).forEach(i -> notifier.onTick());
        String gameMessage = "Your Grotesque Guardians kill count is: 79.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildPbTemplate("Grotesque Guardians", "01:54.00", 79))
            .extra(new BossNotificationData("Grotesque Guardians", 79, gameMessage, Duration.ofMinutes(1).plusSeconds(54), true, null, null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testNotifyExtremeDelayMissingPb() {
        // more config
        when(config.killCountInterval()).thenReturn(1);

        // fire events
        notifier.onGameMessage("Fight duration: 1:54.00 (new personal best)");
        IntStream.range(0, KillCountNotifier.MAX_BAD_TICKS + 1).forEach(i -> notifier.onTick());
        String gameMessage = "Your Grotesque Guardians kill count is: 80.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildTemplate("Grotesque Guardians", 80))
            .extra(new BossNotificationData("Grotesque Guardians", 80, gameMessage, null, null, null, null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testNotifyPbLong() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        String gameMessage = "Your Zulrah kill count is: 1.";
        notifier.onGameMessage(gameMessage);
        notifier.onGameMessage("Fight duration: 1:00:56.50 (new personal best).");
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Zulrah", "01:00:56.50", 1))
                .extra(new BossNotificationData("Zulrah", 1, gameMessage, Duration.ofHours(1).plusSeconds(56).plusMillis(500), true, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyPbImprecise() {
        // more mocks
        when(config.killCountInterval()).thenReturn(99);
        when(client.getVarbitValue(TimeUtils.ENABLE_PRECISE_TIMING)).thenReturn(0);

        // fire events
        String gameMessage = "Your Zulrah kill count is: 13.";
        notifier.onGameMessage(gameMessage);
        notifier.onGameMessage("Fight duration: 0:56 (new personal best).");
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildPbTemplate("Zulrah", "00:56", 13))
            .extra(new BossNotificationData("Zulrah", 13, gameMessage, Duration.ofSeconds(56), true, null, null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testNotifyChambersPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onFriendsChatNotification("Congratulations - your raid is complete!\nTeam size: 24+ players Duration: 36:04.20 (new personal best)");
        String gameMessage = "Your completed Chambers of Xeric count is: 125.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Chambers of Xeric", "36:04.20", 125))
                .extra(new BossNotificationData("Chambers of Xeric", 125, gameMessage, Duration.ofMinutes(36).plusSeconds(4).plusMillis(200), true, null, Collections.emptyList()))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyChambersInterval() {
        // more config
        when(config.killCountNotifyInitial()).thenReturn(false);
        when(config.killCountInterval()).thenReturn(25);

        // fire events
        notifier.onFriendsChatNotification("Congratulations - your raid is complete!\nTeam size: Solo Duration: 46:31.80 Personal best: 40:24.60");
        String gameMessage = "Your completed Chambers of Xeric count is: 150.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate("Chambers of Xeric", 150))
                .extra(new BossNotificationData("Chambers of Xeric", 150, gameMessage, Duration.ofMinutes(46).plusSeconds(31).plusMillis(800), false, Duration.ofMinutes(40).plusSeconds(24).plusMillis(600), Collections.emptyList()))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyTobPb() {
        // more config
        when(config.killCountNotifyInitial()).thenReturn(false);
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Wave 'The Final Challenge' (Normal Mode) complete!\nDuration: 7:42.60\nTheatre of Blood completion time: 21:33.60 (new personal best)");
        notifier.onGameMessage("Theatre of Blood total completion time: 25:28.80 (new personal best)");
        String gameMessage = "Your completed Theatre of Blood count is: 1.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Theatre of Blood", "21:33.60", 1))
                .extra(new BossNotificationData("Theatre of Blood", 1, gameMessage, Duration.ofMinutes(21).plusSeconds(33).plusMillis(600), true, null, Collections.emptyList()))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyTobInterval() {
        // more config
        when(config.killCountInterval()).thenReturn(5);

        // fire events
        notifier.onGameMessage("Wave 'The Final Challenge' (Normal Mode) complete!\nDuration: 6:37.80\nTheatre of Blood completion time: 19:26.40. Personal best: 19:24.00");
        notifier.onGameMessage("Theatre of Blood total completion time: 26:34.20 (new personal best)");
        String gameMessage = "Your completed Theatre of Blood count is: 5.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate("Theatre of Blood", 5))
                .extra(new BossNotificationData("Theatre of Blood", 5, gameMessage, Duration.ofMinutes(19).plusSeconds(26).plusMillis(400), false, Duration.ofMinutes(19).plusSeconds(24), Collections.emptyList()))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyGauntletPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Challenge duration: 10:25 (new personal best).");
        notifier.onGameMessage("Preparation time: 7:09.60. Hunllef kill time: 3:15.40.");
        String gameMessage = "Your Gauntlet completion count is: 10.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Crystalline Hunllef", "10:25.00", 10))
                .extra(new BossNotificationData("Crystalline Hunllef", 10, gameMessage, Duration.ofMinutes(10).plusSeconds(25), true, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyTemporossPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Subdued in 6:30 (new personal best).");
        String gameMessage = "Your Tempoross kill count is: 69.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Tempoross", "06:30.00", 69))
                .extra(new BossNotificationData("Tempoross", 69, gameMessage, Duration.ofMinutes(6).plusSeconds(30), true, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyTombsPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // mock party
        List<String> party = List.of(PLAYER_NAME, "Rasmus", "Romy");
        for (int i = 0; i < party.size(); i++) {
            when(client.getVarcStrValue(Utils.TOA_MEMBER_NAME + i)).thenReturn(party.get(i));
        }

        // fire events
        notifier.onGameMessage("Tombs of Amascut: Expert Mode total completion time: 25:00 (new personal best)");
        String gameMessage = "Your completed Tombs of Amascut: Expert Mode count is: 8.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildPbTemplate("Tombs of Amascut: Expert Mode", "25:00.00", 8))
                .extra(new BossNotificationData("Tombs of Amascut: Expert Mode", 8, gameMessage, Duration.ofMinutes(25), true, null, party))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(6);

        // fire events
        String gameMessage = "Your Zulrah kill count is: 12.";
        notifier.onGameMessage(gameMessage);
        notifier.onGameMessage("Fight duration: 0:59.30. Personal best: 0:56.50");
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate("Zulrah", 12))
                .extra(new BossNotificationData("Zulrah", 12, gameMessage, Duration.ofSeconds(59).plusMillis(300), false, Duration.ofSeconds(56).plusMillis(500), null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyPerilousMoons() {
        // update config mocks
        when(config.killCountInterval()).thenReturn(10);

        // fire events
        String gameMessage = "Your Lunar Chest count is: 30.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .text(buildTemplate("Lunar Chest", 30))
                .extra(new BossNotificationData("Lunar Chest", 30, gameMessage, null, null, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testNotifyBarbarianAssault() {
        // update mocks
        int count = 420;
        String boss = "Penance Queen";
        when(config.killCountPenanceQueen()).thenReturn(true);
        when(config.killCountSendImage()).thenReturn(false);
        when(client.getVarbitValue(Varbits.BA_GC)).thenReturn(count);
        Widget widget = mock(Widget.class);
        when(widget.getText()).thenReturn("Reward:<br>80 Healer points<br>5 Defender points<br>5 Collector points<br>5 Attacker points");
        when(client.getWidget(ComponentID.BA_REWARD_REWARD_TEXT)).thenReturn(widget);

        // fire event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.BA_REWARD);
        notifier.onWidget(event);
        notifier.onTick();

        // check notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has defeated {{boss}} with a completion count of " + count + " high gambles")
                        .replacement("{{boss}}", Replacements.ofWiki(boss))
                        .build()
                )
                .extra(new BossNotificationData(boss, count, "The Queen is dead!", null, null, null, null))
                .playerName(PLAYER_NAME)
                .type(NotificationType.KILL_COUNT)
                .build()
        );
    }

    @Test
    void testIgnoreBarbarianAssault() {
        // update mocks
        when(config.killCountPenanceQueen()).thenReturn(false);
        when(client.getVarbitValue(Varbits.BA_GC)).thenReturn(420);
        Widget widget = mock(Widget.class);
        when(widget.getText()).thenReturn("Reward:<br>80 Healer points<br>5 Defender points<br>5 Collector points<br>5 Attacker points");
        when(client.getWidget(ComponentID.BA_REWARD_REWARD_TEXT)).thenReturn(widget);

        // fire event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.BA_REWARD);
        notifier.onWidget(event);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        String gameMessage = "Your Zulrah kill count is: 12.";
        notifier.onGameMessage(gameMessage);
        notifier.onGameMessage("Fight duration: 0:59.30. Personal best: 0:56.50");
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreChambersNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onFriendsChatNotification("Congratulations - your raid is complete!\nTeam size: Solo Duration: 46:31.80 Personal best: 40:24.60");
        String gameMessage = "Your completed Chambers of Xeric count is: 147.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreTemporossNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Subdued in 6:13. Personal best: 5:57");
        String gameMessage = "Your Tempoross kill count is: 69.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreTombsNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Tombs of Amascut total completion time: 29:45.60. Personal best: 25:08.40");
        String gameMessage = "Your completed Tombs of Amascut count is: 40.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreTheatreNoPb() {
        // more config
        when(config.killCountInterval()).thenReturn(99);

        // fire events
        notifier.onGameMessage("Theatre of Blood total completion time: 23:42.60. Personal best: 20:47.00");
        String gameMessage = "Your completed Theatre of Blood count is: 17.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // ensure no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testPrimaryWithComma() {
        // more config
        when(config.killCountInterval()).thenReturn(1);

        // fire event
        String gameMessage = "Your King Black Dragon kill count is: 1,337.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildTemplate("King Black Dragon", 1337))
            .extra(new BossNotificationData("King Black Dragon", 1337, gameMessage, null, null, null, null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    @Test
    void testSecondaryWithComma() {
        // more config
        when(config.killCountInterval()).thenReturn(1);

        // fire events
        notifier.onGameMessage("Subdued in 6:13. Personal best: 5:57");
        String gameMessage = "Your Tempoross kill count is: 1,337.";
        notifier.onGameMessage(gameMessage);
        notifier.onTick();

        // check notification
        NotificationBody<BossNotificationData> body = NotificationBody.<BossNotificationData>builder()
            .text(buildTemplate("Tempoross", 1337))
            .extra(new BossNotificationData("Tempoross", 1337, gameMessage, Duration.ofMinutes(6).plusSeconds(13), false, Duration.ofMinutes(5).plusSeconds(57), null))
            .playerName(PLAYER_NAME)
            .type(NotificationType.KILL_COUNT)
            .build();

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            body
        );

        assertDoesNotThrow(() -> RuneLiteAPI.GSON.toJson(body));
    }

    private static Template buildTemplate(String boss, int count) {
        return Template.builder()
            .template(PLAYER_NAME + " has defeated {{boss}} with a completion count of " + count)
            .replacement("{{boss}}", Replacements.ofWiki(boss))
            .build();
    }

    private static Template buildPbTemplate(String boss, String time, int count) {
        return Template.builder()
            .template(String.format("%s has defeated {{boss}} with a new personal best time of %s and a completion count of %d", PLAYER_NAME, time, count))
            .replacement("{{boss}}", Replacements.ofWiki(boss))
            .build();
    }
}

package dinkplugin.notifiers;

import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.regex.Matcher;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class PetMatcherTest {

    @ParameterizedTest(name = "Pet message should trigger {0}")
    @ValueSource(
        strings = {
            "You have a funny feeling like you're being followed.",
            "You have a funny feeling like you would have been followed...",
            "You feel something weird sneaking into your backpack."
        }
    )
    void petRegexFindsMatch(String message) {
        Matcher matcher = PetNotifier.PET_REGEX.matcher(message);
        assertTrue(matcher.find());
    }

    @ParameterizedTest(name = "Pet message should not trigger {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen",
            "You feel like you forgot to turn the stove off"
        }
    )
    void petRegexDoesNotMatch(String message) {
        Matcher matcher = PetNotifier.PET_REGEX.matcher(message);
        assertFalse(matcher.find());
    }

    @ParameterizedTest(name = "Pet name should be parsed from: {0}")
    @ArgumentsSource(ClanPetProvider.class)
    void petNameMatches(String message, String user, String pet) {
        Matcher matcher = PetNotifier.CLAN_REGEX.matcher(message);
        assertTrue(matcher.find());
        assertEquals(user, matcher.group("user"));
        assertEquals(pet, matcher.group("pet"));
    }

    @ParameterizedTest(name = "Pet name should be not parsed from {0}")
    @ValueSource(
        strings = {
            "Forsen: forsen",
            "You feel like you forgot to turn the stove off"
        }
    )
    void petNameDoesNotMatch(String message) {
        Matcher matcher = PetNotifier.CLAN_REGEX.matcher(message);
        assertFalse(matcher.find());
    }

    private static class ClanPetProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of("[Log Dog LLC] Clipper has a funny feeling like he's being followed: Little nightmare at 2,678 killcount.", "Clipper", "Little nightmare"),
                Arguments.of("[Muu] Majin Muu has a funny feeling like she's being followed: Herbi at 3,054 harvest count.", "Majin Muu", "Herbi"),
                Arguments.of("[Dankermen] pajdank has a funny feeling like he's being followed: Rocky at 5,850,317 XP.", "pajdank", "Rocky"),
                /*
                You have a funny feeling like you're being followed.
                New item added to your collection log: Lil' creator
                CL Locked received a drop: Lil' creator
                [Boss Locked] CL Locked has a funny feeling like he's being followed: Lil' creator at 22 crates.
                [Boss Locked] CL Locked received a new collection log item: Lil' creator (86/1476)
                From https://youtu.be/6jFmC8E0ypI?t=858
                 */
                Arguments.of("[Boss Locked] CL Locked has a funny feeling like he's being followed: Lil' creator at 22 crates.", "CL Locked", "Lil' creator"),
                Arguments.of("[Outer Void] Dash Inc feels something weird sneaking into his backpack: Heron at 8,426,283 XP.", "Dash Inc", "Heron")
            );
        }
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.CollectionNotificationData;
import dinkplugin.util.ItemSearcher;
import dinkplugin.util.KillCountService;
import net.runelite.api.GameState;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.ScriptID;
import net.runelite.api.VarClientStr;
import net.runelite.api.Varbits;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.events.NpcLootReceived;
import net.runelite.client.game.ItemStack;
import net.runelite.http.api.loottracker.LootRecordType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;

import java.util.List;
import java.util.function.BiFunction;

import static dinkplugin.notifiers.CollectionNotifier.TOTAL_ENTRIES;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class CollectionNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    CollectionNotifier notifier;

    @Bind
    @Mock
    ItemSearcher itemSearcher;

    @Bind
    @InjectMocks
    KillCountService killCountService;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init client mocks
        when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(1);
        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(0);
        when(client.getVarpValue(CollectionNotifier.TOTAL_VARP)).thenReturn(TOTAL_ENTRIES);
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        notifier.onTick();

        VarbitChanged initCompleted = new VarbitChanged();
        initCompleted.setVarpId(CollectionNotifier.COMPLETED_VARP);
        initCompleted.setValue(0);
        notifier.onVarPlayer(initCompleted);

        // init config mocks
        when(config.notifyCollectionLog()).thenReturn(true);
        when(config.collectionSendImage()).thenReturn(false);
        when(config.collectionNotifyMessage()).thenReturn("%USERNAME% has added %ITEM% to their collection");
    }

    @Test
    void testNotify() {
        String item = "Seercull";
        int price = 23_000;
        when(itemSearcher.findItemId(item)).thenReturn(ItemID.SEERCULL);
        mockItem(ItemID.SEERCULL, price, item);

        // prepare kc
        int kc = 150;
        double rarity = 1.0 / 128;
        String source = "Dagannoth Supreme";
        NPC npc = mock(NPC.class);
        when(npc.getName()).thenReturn(source);
        when(npc.getId()).thenReturn(NpcID.DAGANNOTH_SUPREME);
        when(configManager.getRSProfileConfiguration("killcount", source.toLowerCase(), int.class)).thenReturn(kc);
        killCountService.onNpcKill(new NpcLootReceived(npc, List.of(new ItemStack(ItemID.SEERCULL, 1))));

        // send fake message
        notifier.onChatMessage("New item added to your collection log: " + item);

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has added {{item}} to their collection", PLAYER_NAME))
                        .replacement("{{item}}", Replacements.ofWiki(item))
                        .build()
                )
                .extra(new CollectionNotificationData(item, ItemID.SEERCULL, (long) price, 1, TOTAL_ENTRIES, source, LootRecordType.NPC, kc, rarity))
                .type(NotificationType.COLLECTION)
                .build()
        );
    }

    @Test
    void testNotifyPopup() {
        // prepare item
        String item = "Seercull";
        int price = 23_000;
        when(itemSearcher.findItemId(item)).thenReturn(ItemID.SEERCULL);
        when(itemManager.getItemPrice(ItemID.SEERCULL)).thenReturn(price);

        // update mocks
        when(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)).thenReturn(3);
        when(client.getVarcStrValue(VarClientStr.NOTIFICATION_TOP_TEXT)).thenReturn("Collection log");
        when(client.getVarcStrValue(VarClientStr.NOTIFICATION_BOTTOM_TEXT)).thenReturn("New item:<br>" + item);

        // send chat event (to be ignored)
        notifier.onChatMessage("New item added to your collection log: " + item);

        // ensure no notification yet
        Mockito.verifyNoInteractions(messageHandler);

        // send script events
        notifier.onScript(ScriptID.NOTIFICATION_START);
        notifier.onScript(ScriptID.NOTIFICATION_DELAY);

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has added {{item}} to their collection", PLAYER_NAME))
                        .replacement("{{item}}", Replacements.ofWiki(item))
                        .build()
                )
                .extra(new CollectionNotificationData(item, ItemID.SEERCULL, (long) price, 1, TOTAL_ENTRIES, null, null, null, null))
                .type(NotificationType.COLLECTION)
                .build()
        );
    }

    @Test
    void testNotifyFresh() {
        notifier.reset();

        /*
         * first notification: no varbit data
         */
        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(0);
        when(client.getVarpValue(CollectionNotifier.TOTAL_VARP)).thenReturn(0);

        String item = "Seercull";
        int price = 23_000;
        when(itemSearcher.findItemId(item)).thenReturn(ItemID.SEERCULL);
        when(itemManager.getItemPrice(ItemID.SEERCULL)).thenReturn(price);

        // send fake message
        notifier.onChatMessage("New item added to your collection log: " + item);

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has added {{item}} to their collection", PLAYER_NAME))
                        .replacement("{{item}}", Replacements.ofWiki(item))
                        .build()
                )
                .extra(new CollectionNotificationData(item, ItemID.SEERCULL, (long) price, null, null, null, null, null, null))
                .type(NotificationType.COLLECTION)
                .build()
        );

        /*
         * jagex sends varbit data shortly after the notification
         */
        BiFunction<Integer, Integer, VarbitChanged> varpEvent = (id, value) -> {
            VarbitChanged e = new VarbitChanged();
            e.setVarpId(id);
            e.setValue(value);
            return e;
        };

        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(1);
        notifier.onVarPlayer(varpEvent.apply(CollectionNotifier.COMPLETED_VARP, 1));

        when(client.getVarpValue(CollectionNotifier.TOTAL_VARP)).thenReturn(TOTAL_ENTRIES);
        notifier.onVarPlayer(varpEvent.apply(CollectionNotifier.TOTAL_VARP, TOTAL_ENTRIES));

        when(client.getVarpValue(CollectionNotifier.COMPLETED_VARP)).thenReturn(100);
        notifier.onVarPlayer(varpEvent.apply(CollectionNotifier.COMPLETED_VARP, 100));

        notifier.onTick();

        /*
         * a later notification occurs
         */
        String item2 = "Seers ring";
        int price2 = 420_000;
        when(itemSearcher.findItemId(item2)).thenReturn(ItemID.SEERS_RING);
        when(itemManager.getItemPrice(ItemID.SEERS_RING)).thenReturn(price2);

        // send fake message
        notifier.onChatMessage("New item added to your collection log: " + item2);

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has added {{item}} to their collection", PLAYER_NAME))
                        .replacement("{{item}}", Replacements.ofWiki(item2))
                        .build()
                )
                .extra(new CollectionNotificationData(item2, ItemID.SEERS_RING, (long) price2, 101, TOTAL_ENTRIES, null, null, null, null))
                .type(NotificationType.COLLECTION)
                .build()
        );
    }

    @Test
    void testIgnore() {
        // send unrelated message
        notifier.onChatMessage("New item added to your backpack: weed");

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyCollectionLog()).thenReturn(false);

        // send fake message
        String item = "Seercull";
        notifier.onChatMessage("New item added to your collection log: " + item);

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.SlayerNotificationData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class SlayerNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    SlayerNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifySlayer()).thenReturn(true);
        when(config.slayerSendImage()).thenReturn(false);
        when(config.slayerPointThreshold()).thenReturn(1);
        when(config.slayerNotifyMessage()).thenReturn("%USERNAME% has completed: %TASK%, getting %POINTS% points for a total %TASKCOUNT% tasks completed");
    }

    @Test
    void testNotify() {
        // fire chat messages
        notifier.onChatMessage("You have completed your task! You killed 1 TzTok-Jad. You gained 69,420 xp.");
        notifier.onChatMessage("You've completed 100 tasks and received 10 points, giving you a total of 200; return to a Slayer master.");

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(1, "TzTok-Jad", 10, 100))
                .extra(new SlayerNotificationData("1 TzTok-Jad", "100", "10", 1, "TzTok-Jad"))
                .type(NotificationType.SLAYER)
                .build()
        );
    }

    @Test
    void testNotifyThousand() {
        when(config.slayerPointThreshold()).thenReturn(1000);

        // fire chat messages
        notifier.onChatMessage("You have completed your task! You killed 245 Cave Kraken. You gained 62,475 xp.");
        notifier.onChatMessage("You've completed 1,000 tasks and received 1,000 points, giving you a total of 2,584, return to a Slayer master.");

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(245, "Cave Kraken", "1,000", "1,000"))
                .extra(new SlayerNotificationData("245 Cave Kraken", "1,000", "1,000", 245, "Cave Kraken"))
                .type(NotificationType.SLAYER)
                .build()
        );
    }

    @Test
    void testNotifyBoss() {
        // fire chat messages
        notifier.onChatMessage("You are granted an extra reward of 5k Slayer XP for completing your boss task against the Cave Kraken boss.");
        notifier.onChatMessage("You have completed your task! You killed 50 Bosses. You gained 14,200 xp.");
        notifier.onChatMessage("You've completed 150 tasks and received 10 points, giving you a total of 200; return to a Slayer master.");

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(50, "Cave Kraken", 10, 150))
                .extra(new SlayerNotificationData("50 Cave Kraken", "150", "10", 50, "Cave Kraken"))
                .type(NotificationType.SLAYER)
                .build()
        );
    }

    @Test
    void testNotifyBarrows() {
        // fire chat messages
        notifier.onChatMessage("You are granted an extra reward of 5k Slayer XP for completing your boss task against Barrows brothers.");
        notifier.onChatMessage("You have completed your task! You killed 36 Bosses. You gained 8,943 xp.");
        notifier.onChatMessage("You've completed 881 tasks and received 20 points, giving you a total of 689; return to a Slayer master.");

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(36, "Barrows brothers", 20, 881))
                .extra(new SlayerNotificationData("36 Barrows brothers", "881", "20", 36, "Barrows brothers"))
                .type(NotificationType.SLAYER)
                .build()
        );
    }

    @Test
    void testNotifyChaos() {
        // fire chat messages
        notifier.onChatMessage("You are granted an extra reward of 5k Slayer XP for completing your boss task against the Chaos Elemental.");
        notifier.onChatMessage("You have completed your task! You killed 11 Bosses. You gained 7,954 xp.");
        notifier.onChatMessage("You've completed 242 tasks and received 15 points, giving you a total of 3,254; return to a Slayer master.");

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(11, "Chaos Elemental", 15, 242))
                .extra(new SlayerNotificationData("11 Chaos Elemental", "242", "15", 11, "Chaos Elemental"))
                .type(NotificationType.SLAYER)
                .build()
        );
    }

    @Test
    void testIgnorePoints() {
        // fire chat messages
        notifier.onChatMessage("You have completed your task! You killed 1 TzTok-Jad. You gained 69,420 xp.");
        notifier.onChatMessage("You've completed 101 tasks and received 0 points, giving you a total of 200; return to a Slayer master.");

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifySlayer()).thenReturn(false);

        // fire chat messages
        notifier.onChatMessage("You have completed your task! You killed 1 TzTok-Jad. You gained 69,420 xp.");
        notifier.onChatMessage("You've completed 100 tasks and received 10 points, giving you a total of 200; return to a Slayer master.");

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private static Template buildTemplate(int count, String monster, Object points, Object completed) {
        return Template.builder()
            .template(String.format("%s has completed: %d {{monster}}, getting %s points for a total %s tasks completed", PLAYER_NAME, count, points, completed))
            .replacement("{{monster}}", Replacements.ofWiki(monster))
            .build();
    }
}

package dinkplugin.notifiers;

import net.runelite.api.Item;
import net.runelite.api.ItemID;
import org.apache.commons.lang3.tuple.Pair;
import org.junit.jupiter.api.Test;

import java.util.List;
import java.util.function.Function;

import static dinkplugin.notifiers.DeathNotifier.splitItemsByKept;
import static java.util.Arrays.asList;
import static java.util.Collections.singletonList;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;

class DeathNotifierItemTest {
    private static final Pair<Item, Long> BOND, EGG, GRAIN, POT, SALMON, TUNA, BAG, CLUE, JESTER, TROPHY, AVA;

    @Test
    void testSplit() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(EGG, GRAIN, POT, SALMON, TUNA), 3);
        assertEquals(asList(EGG, GRAIN, POT), split.getLeft());
        assertEquals(asList(SALMON, TUNA), split.getRight());
    }

    @Test
    void testSplitStackable() {
        int total = 30, keep = 3;
        long price = 2;
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(
            singletonList(Pair.of(new Item(ItemID.FEATHER, total), price)),
            keep
        );

        Pair<Item, Long> feather = Pair.of(new Item(ItemID.FEATHER, 1), price);
        assertEquals(
            asList(feather, feather, feather), // IntStream.range(0, keep).mapToObj(i -> feather).collect(Collectors.toList()),
            split.getLeft()
        );
        assertEquals(
            singletonList(Pair.of(new Item(ItemID.FEATHER, total - keep), price)),
            split.getRight()
        );
    }

    @Test
    void testSplitProtected() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(EGG, GRAIN, POT, SALMON, TUNA), 4);
        assertEquals(asList(EGG, GRAIN, POT, SALMON), split.getLeft());
        assertEquals(singletonList(TUNA), split.getRight());
    }

    @Test
    void testSplitBond() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(BOND, BOND, BOND, BOND, BOND, EGG), 3);
        assertEquals(asList(BOND, BOND, BOND, BOND, BOND, EGG), split.getLeft());
        assertTrue(split.getRight().isEmpty());
    }

    @Test
    void testSplitSkulled() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(BOND, GRAIN), 0);
        assertEquals(singletonList(BOND), split.getLeft());
        assertEquals(singletonList(GRAIN), split.getRight());
    }

    @Test
    void testSplitSkulledProtect() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(BOND, GRAIN, EGG), 1);
        assertEquals(asList(BOND, GRAIN), split.getLeft());
        assertEquals(singletonList(EGG), split.getRight());
    }

    @Test
    void testSplitSkulledProtectOrdered() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(BOND, EGG, GRAIN), 1);
        assertEquals(asList(BOND, EGG), split.getLeft());
        assertEquals(singletonList(GRAIN), split.getRight());
    }

    @Test
    void testSplitNeverKept() {
        Pair<List<Pair<Item, Long>>, List<Pair<Item, Long>>> split = splitItemsByKept(asList(BAG, EGG, CLUE, BOND, JESTER, TROPHY, GRAIN, AVA, POT, TUNA), 3);
        assertEquals(asList(EGG, BOND, GRAIN, POT), split.getLeft());
        assertEquals(asList(BAG, CLUE, JESTER, TROPHY, AVA, TUNA), split.getRight());
    }

    static {
        Function<Integer, Pair<Item, Long>> item = id -> Pair.of(new Item(id, 1), 0L);

        BOND = item.apply(ItemID.OLD_SCHOOL_BOND);
        EGG = item.apply(ItemID.EGG);
        GRAIN = item.apply(ItemID.GRAIN);
        POT = item.apply(ItemID.POT);
        SALMON = item.apply(ItemID.SALMON);
        TUNA = item.apply(ItemID.TUNA);
        BAG = item.apply(ItemID.LOOTING_BAG);
        CLUE = item.apply(ItemID.CLUE_BOX);
        JESTER = item.apply(ItemID.SILLY_JESTER_HAT);
        TROPHY = item.apply(ItemID.TRAILBLAZER_DRAGON_TROPHY);
        AVA = item.apply(ItemID.AVAS_ACCUMULATOR);
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.Embed;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.GrandExchangeNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.ItemUtils;
import lombok.Value;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.ItemID;
import net.runelite.client.util.QuantityFormatter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.*;

public class GrandExchangeNotifierTest extends MockedNotifierTest {

    private static final int RUBY_PRICE = 900;
    private static final int OPAL_PRICE = 600;

    @Bind
    @InjectMocks
    GrandExchangeNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // config mocks
        when(config.notifyGrandExchange()).thenReturn(true);
        when(config.grandExchangeMinValue()).thenReturn(5000);
        when(config.grandExchangeProgressSpacingMinutes()).thenReturn(-1);
        when(config.grandExchangeNotifyMessage()).thenReturn("%USERNAME% %TYPE% %ITEM% on the GE");

        // item mocks
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
        mockItem(ItemID.OPAL, OPAL_PRICE, "Opal");
    }

    @Test
    void testNotifyBuy() {
        // fire event
        Offer offer = new Offer(10, ItemID.RUBY, 10, RUBY_PRICE, 10_000, GrandExchangeOfferState.BOUGHT);
        notifier.onOfferChange(0, offer);

        // verify notification
        verifyNotification(0, offer, "bought", "Ruby", RUBY_PRICE, null);
    }

    @Test
    void testNotifySell() {
        // fire event
        Offer offer = new Offer(10, ItemID.OPAL, 10, OPAL_PRICE, 7_000, GrandExchangeOfferState.SOLD);
        notifier.onOfferChange(1, offer);

        // verify notification
        verifyNotification(1, offer, "sold", "Opal", OPAL_PRICE, 10 * 7L);
    }

    @Test
    void testIgnoreValue() {
        // fire event
        Offer offer = new Offer(10, ItemID.OPAL, 5, OPAL_PRICE, 3_500, GrandExchangeOfferState.SOLD);
        notifier.onOfferChange(1, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreBuying() {
        // fire event
        Offer offer = new Offer(10, ItemID.RUBY, 50, RUBY_PRICE, 10_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(0, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreSelling() {
        // fire event
        Offer offer = new Offer(10, ItemID.OPAL, 50, OPAL_PRICE, 3_500, GrandExchangeOfferState.SELLING);
        notifier.onOfferChange(1, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyPartialDifferentSlots() {
        // update config mock
        when(config.grandExchangeProgressSpacingMinutes()).thenReturn(0);

        // fire event
        Offer offer = new Offer(11, ItemID.RUBY, 50, RUBY_PRICE, 11_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(1, offer);

        // verify notification
        verifyNotification(1, offer, "bought", "Ruby", RUBY_PRICE, null);

        // fire second event without spacing
        Offer offer2 = new Offer(22, ItemID.OPAL, 60, OPAL_PRICE, 15_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(2, offer2);

        // verify second notification
        verifyNotification(2, offer2, "bought", "Opal", OPAL_PRICE, null);
    }

    @Test
    void testNotifySpacing() throws InterruptedException {
        // update config mock
        when(config.grandExchangeProgressSpacingMinutes()).thenReturn(0);

        // fire event
        Offer offer = new Offer(11, ItemID.RUBY, 50, RUBY_PRICE, 11_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(0, offer);

        // verify notification
        verifyNotification(0, offer, "bought", "Ruby", RUBY_PRICE, null);

        // allow time to pass
        Thread.sleep(2500);

        // fire second event
        Offer offer2 = new Offer(22, ItemID.RUBY, 50, RUBY_PRICE, 22_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(0, offer2);

        // verify second notification
        verifyNotification(0, offer2, "bought", "Ruby", RUBY_PRICE, null);
    }

    @Test
    void testIgnoreSpacing() {
        // update config mock
        when(config.grandExchangeProgressSpacingMinutes()).thenReturn(0);

        // fire event
        Offer offer = new Offer(10, ItemID.RUBY, 50, RUBY_PRICE, 10_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(0, offer);

        // fire second event without spacing
        Offer offer2 = new Offer(20, ItemID.RUBY, 50, RUBY_PRICE, 10_000, GrandExchangeOfferState.BUYING);
        notifier.onOfferChange(0, offer2);

        // verify first notification
        verifyNotification(0, offer, "bought", "Ruby", RUBY_PRICE, null);

        // ensure no notification for second event
        verifyNoMoreInteractions(messageHandler);
    }

    @Test
    void testNotifyCancelled() {
        // update config mock
        when(config.grandExchangeIncludeCancelled()).thenReturn(true);

        // fire event
        Offer offer = new Offer(11, ItemID.RUBY, 50, RUBY_PRICE, 11_000, GrandExchangeOfferState.CANCELLED_BUY);
        notifier.onOfferChange(0, offer);

        // verify notification
        verifyNotification(0, offer, "bought", "Ruby", RUBY_PRICE, null);
    }

    @Test
    void testIgnoreCancelledValue() {
        // update config mock
        when(config.grandExchangeIncludeCancelled()).thenReturn(true);

        // fire event
        Offer offer = new Offer(2, ItemID.RUBY, 50, RUBY_PRICE, 2_000, GrandExchangeOfferState.CANCELLED_BUY);
        notifier.onOfferChange(0, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreCancelled() {
        // fire event
        Offer offer = new Offer(11, ItemID.RUBY, 50, RUBY_PRICE, 11_000, GrandExchangeOfferState.CANCELLED_BUY);
        notifier.onOfferChange(0, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // update config mock
        when(config.notifyGrandExchange()).thenReturn(false);

        // fire event
        Offer offer = new Offer(10, ItemID.RUBY, 10, RUBY_PRICE, 10_000, GrandExchangeOfferState.BOUGHT);
        notifier.onOfferChange(0, offer);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private void verifyNotification(int slot, Offer offer, String type, String itemName, long marketPrice, Long tax) {
        SerializedItemStack item = new SerializedItemStack(offer.getItemId(), offer.getQuantitySold(), offer.getSpent() / offer.getQuantitySold(), itemName);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.GRAND_EXCHANGE)
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " {{type}} {{quantity}} x {{item}} ({{value}}) on the GE")
                        .replacement("{{type}}", Replacements.ofText(type))
                        .replacement("{{quantity}}", Replacements.ofText(String.valueOf(offer.getQuantitySold())))
                        .replacement("{{item}}", Replacements.ofWiki(itemName))
                        .replacement("{{value}}", Replacements.ofText(QuantityFormatter.quantityToStackSize(item.getTotalPrice())))
                        .build()
                )
                .embeds(Collections.singletonList(Embed.ofImage(ItemUtils.getItemImageUrl(item.getId()))))
                .extra(new GrandExchangeNotificationData(slot + 1, offer.getState(), item, marketPrice, offer.getPrice(), offer.getTotalQuantity(), tax))
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Value
    private static class Offer implements GrandExchangeOffer {
        int quantitySold;
        int itemId;
        int totalQuantity;
        int price;
        int spent;
        GrandExchangeOfferState state;
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.AchievementDiary;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.DiaryNotificationData;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.events.VarbitChanged;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mockito;

import java.util.stream.IntStream;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@SuppressWarnings("MagicConstant")
class DiaryNotifierTest extends MockedNotifierTest {

    private static final int COMPLETED_TASKS = 469;
    private static final int TOTAL_TASKS = 492;

    private static final int KARAMJA_TASKS_FROM_EASY_TO_HARD = 10 + 19 + 10;
    private static final int KARAMJA_TOTAL_TASKS = KARAMJA_TASKS_FROM_EASY_TO_HARD + 5;

    @Bind
    @InjectMocks
    DiaryNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyAchievementDiary()).thenReturn(true);
        when(config.diarySendImage()).thenReturn(false);
        when(config.minDiaryDifficulty()).thenReturn(AchievementDiary.Difficulty.MEDIUM);
        when(config.diaryNotifyMessage()).thenReturn("%USERNAME% has completed the %DIFFICULTY% %AREA% Diary, for a total of %TOTAL%");

        // init client mocks
        when(client.getGameState()).thenReturn(GameState.LOGGED_IN);
        when(client.getIntStack()).thenReturn(
            new int[] { COMPLETED_TASKS }, // first COMPLETED_TASKS_SCRIPT_ID is run
            new int[] { TOTAL_TASKS }, // then TOTAL_TASKS_SCRIPT_ID is run
            new int[] { KARAMJA_TASKS_FROM_EASY_TO_HARD }, // then COMPLETED_AREA_TASKS_SCRIPT_ID
            new int[] { KARAMJA_TOTAL_TASKS } // then TOTAL_AREA_TASKS_SCRIPT_ID
        );
    }

    @Test
    void testNotifyFirst() {
        // initially 0 diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(0);
        when(config.minDiaryDifficulty()).thenReturn(AchievementDiary.Difficulty.EASY);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        int tasksCompleted = 11;
        int totalAreaTasks = 11 + 12 + 10 + 6;
        when(client.getIntStack()).thenReturn(
            new int[] { tasksCompleted }, // first COMPLETED_TASKS_SCRIPT_ID is run
            new int[] { TOTAL_TASKS }, // then TOTAL_TASKS_SCRIPT_ID is run
            new int[] { tasksCompleted }, // then COMPLETED_AREA_TASKS_SCRIPT_ID is run
            new int[] { totalAreaTasks } // then TOTAL_TASKS_SCRIPT_ID is run
        );
        int id = Varbits.DIARY_DESERT_EASY;
        plugin.onVarbitChanged(event(id, 1));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(AchievementDiary.Difficulty.EASY, "Desert", 1))
                .extra(new DiaryNotificationData("Desert", AchievementDiary.Difficulty.EASY, 1, tasksCompleted, TOTAL_TASKS, tasksCompleted, totalAreaTasks))
                .type(NotificationType.ACHIEVEMENT_DIARY)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyKaramja() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);
        int total = AchievementDiary.DIARIES.size() - 3;

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary started
        int id = Varbits.DIARY_KARAMJA_HARD;
        plugin.onVarbitChanged(event(id, 2));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(AchievementDiary.Difficulty.HARD, "Karamja", total + 1))
                .extra(new DiaryNotificationData("Karamja", AchievementDiary.Difficulty.HARD, total + 1, COMPLETED_TASKS, TOTAL_TASKS, KARAMJA_TASKS_FROM_EASY_TO_HARD, KARAMJA_TOTAL_TASKS))
                .type(NotificationType.ACHIEVEMENT_DIARY)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyKaramjaMessageBox() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);
        int total = AchievementDiary.DIARIES.size() - 3;

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        notifier.onMessageBox("Congratulations! You have completed all of the hard tasks in the Karamja area. Speak to Pirate Jackie the Fruit to claim your reward.");

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(AchievementDiary.Difficulty.HARD, "Karamja", total + 1))
                .extra(new DiaryNotificationData("Karamja", AchievementDiary.Difficulty.HARD, total + 1, COMPLETED_TASKS, TOTAL_TASKS, KARAMJA_TASKS_FROM_EASY_TO_HARD, KARAMJA_TOTAL_TASKS))
                .type(NotificationType.ACHIEVEMENT_DIARY)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testDontNotifyKaramjaMessageBox() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        notifier.onMessageBox("Congratulations! You have completed all of the easy tasks in the Karamja area. Speak to Pirate Jackie the Fruit to claim your reward.");

        // verify no notification message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyWesternMessageBox() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);
        when(client.getVarbitValue(Varbits.DIARY_WESTERN_HARD)).thenReturn(0);
        int total = AchievementDiary.DIARIES.size() - 3 - 1;

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        int westernTasksFromEasyToHard = 11 + 13 + 13;
        int westernTasksTotal = westernTasksFromEasyToHard + 7;
        when(client.getIntStack()).thenReturn(
            new int[] { COMPLETED_TASKS }, // first COMPLETED_TASKS_SCRIPT_ID is run
            new int[] { TOTAL_TASKS }, // then TOTAL_TASKS_SCRIPT_ID is run
            new int[] { westernTasksFromEasyToHard }, // then COMPLETED_AREA_TASKS_SCRIPT_ID
            new int[] { westernTasksTotal } // then TOTAL_AREA_TASKS_SCRIPT_ID
        );
        notifier.onMessageBox("Congratulations! You have completed all of the hard tasks in the Western Province area. Speak to the Elder Gnome child at the Gnome Stronghold to claim your reward.");

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(AchievementDiary.Difficulty.HARD, "Western Provinces", total + 1))
                .extra(new DiaryNotificationData("Western Provinces", AchievementDiary.Difficulty.HARD, total + 1, COMPLETED_TASKS, TOTAL_TASKS, westernTasksFromEasyToHard, westernTasksTotal))
                .type(NotificationType.ACHIEVEMENT_DIARY)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    @Test
    void testNotifyCooldown() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);
        int total = AchievementDiary.DIARIES.size() - 3;

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        int id = Varbits.DIARY_KARAMJA_HARD;
        plugin.onVarbitChanged(event(id, 2));

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(AchievementDiary.Difficulty.HARD, "Karamja", total + 1))
                .extra(new DiaryNotificationData("Karamja", AchievementDiary.Difficulty.HARD, total + 1, COMPLETED_TASKS, TOTAL_TASKS, KARAMJA_TASKS_FROM_EASY_TO_HARD, KARAMJA_TOTAL_TASKS))
                .type(NotificationType.ACHIEVEMENT_DIARY)
                .playerName(PLAYER_NAME)
                .build()
        );

        // trigger message box
        notifier.onMessageBox("Congratulations! You have completed all of the hard tasks in the Karamja area. Speak to Pirate Jackie the Fruit to claim your reward.");

        // ensure no notification
        Mockito.verifyNoMoreInteractions(messageHandler);
    }

    @Test
    void testIgnoreKaramja() {
        // initially 0 diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(0);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary started
        int id = Varbits.DIARY_KARAMJA_HARD;
        plugin.onVarbitChanged(event(id, 1));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreCompleted() {
        // initially many diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(1);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger varbit event
        int id = Varbits.DIARY_DESERT_ELITE;
        plugin.onVarbitChanged(event(id, 1));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreUninitialized() {
        // trigger varbit event
        int id = Varbits.DIARY_DESERT_ELITE;
        plugin.onVarbitChanged(event(id, 1));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreDifficulty() {
        // initially 0 diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(0);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger varbit event
        int id = Varbits.DIARY_FALADOR_EASY;
        plugin.onVarbitChanged(event(id, 1));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyAchievementDiary()).thenReturn(false);

        // initially 0 diary completions
        when(client.getVarbitValue(anyInt())).thenReturn(0);

        // perform enough ticks to trigger diary initialization
        IntStream.range(0, 16).forEach(i -> notifier.onTick());

        // trigger diary completion
        int id = Varbits.DIARY_DESERT_ELITE;
        plugin.onVarbitChanged(event(id, 1));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private static VarbitChanged event(int id, int value) {
        VarbitChanged event = new VarbitChanged();
        event.setVarbitId(id);
        event.setValue(value);
        return event;
    }

    private static Template buildTemplate(AchievementDiary.Difficulty difficulty, String area, int total) {
        return Template.builder()
            .template(String.format("%s has completed the %s {{area}} Diary, for a total of %d", PLAYER_NAME, difficulty, total))
            .replacement("{{area}}", Replacements.ofWiki(area, area + " Diary"))
            .build();
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.SpeedrunNotificationData;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.time.Duration;

import static dinkplugin.notifiers.SpeedrunNotifier.SPEEDRUN_COMPLETED_DURATION_CHILD_ID;
import static dinkplugin.notifiers.SpeedrunNotifier.SPEEDRUN_COMPLETED_GROUP_ID;
import static dinkplugin.notifiers.SpeedrunNotifier.SPEEDRUN_COMPLETED_PB_CHILD_ID;
import static dinkplugin.notifiers.SpeedrunNotifier.SPEEDRUN_COMPLETED_QUEST_NAME_CHILD_ID;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class SpeedrunNotifierTest extends MockedNotifierTest {

    private static final String QUEST_NAME = "Cook's Assistant";
    private static final String PERSONAL_BEST = "1:30.25";

    @Bind
    @InjectMocks
    SpeedrunNotifier notifier;

    private static Template buildTemplate(String quest, String time) {
        return Template.builder()
            .template(String.format("%s has beat their PB of {{quest}} with a time of %s", PLAYER_NAME, time))
            .replacement("{{quest}}", Replacements.ofWiki(quest))
            .build();
    }

    private static Template buildNonPersonalBestTemplate(String quest, String time) {
        return Template.builder()
            .template(String.format("%s has just finished a speedrun of {{quest}} with a time of %s (their PB is %s)", PLAYER_NAME, time, PERSONAL_BEST))
            .replacement("{{quest}}", Replacements.ofWiki(quest))
            .build();
    }

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifySpeedrun()).thenReturn(true);
        when(config.speedrunPBOnly()).thenReturn(true);
        when(config.speedrunSendImage()).thenReturn(false);
        when(config.speedrunPBMessage()).thenReturn("%USERNAME% has beat their PB of %QUEST% with a time of %TIME%");
        when(config.speedrunMessage()).thenReturn("%USERNAME% has just finished a speedrun of %QUEST% with a time of %TIME% (their PB is %BEST%)");

        // init common widget mocks
        Widget quest = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_QUEST_NAME_CHILD_ID)).thenReturn(quest);
        when(quest.getText()).thenReturn("You have completed " + QUEST_NAME + "!");

        Widget pb = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_PB_CHILD_ID)).thenReturn(pb);
        when(pb.getText()).thenReturn(PERSONAL_BEST);
    }

    @Test
    void testNotify() {
        String latest = "1:15.30";

        // mock widget
        Widget time = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s (new personal best)", latest));
        plugin.onWidgetLoaded(event());

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(QUEST_NAME, latest))
                .extra(new SpeedrunNotificationData(QUEST_NAME, Duration.ofMinutes(1).plusSeconds(30).plusMillis(250).toString(), Duration.ofMinutes(1).plusSeconds(15).plusMillis(300).toString(), true))
                .type(NotificationType.SPEEDRUN)
                .build()
        );
    }

    @Test
    void testNotifyNotPersonalBest() {
        String latest = "1:40.30";

        // mock widget
        Widget time = mock(Widget.class);
        when(config.speedrunPBOnly()).thenReturn(false);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s", latest));
        plugin.onWidgetLoaded(event());

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildNonPersonalBestTemplate(QUEST_NAME, latest))
                .extra(new SpeedrunNotificationData(QUEST_NAME, Duration.ofMinutes(1).plusSeconds(30).plusMillis(250).toString(), Duration.ofMinutes(1).plusSeconds(40).plusMillis(300).toString(), false))
                .type(NotificationType.SPEEDRUN)
                .build()
        );
    }

    @Test
    void testIgnoreNonPersonalBest() {
        String latest = "1:45.30";

        // mock widget
        Widget time = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s", latest));
        plugin.onWidgetLoaded(event());

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifySpeedrun()).thenReturn(false);

        // mock widget
        String latest = "1:15.30";
        Widget time = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s (new personal best)", latest));
        plugin.onWidgetLoaded(event());

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testNotifyDenyList() {
        // configure irrelevant deny list
        when(config.filteredNames()).thenReturn("pajlads");
        settingsManager.init();

        // mock widget
        String latest = "1:15.30";
        Widget time = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s (new personal best)", latest));
        plugin.onWidgetLoaded(event());

        // check notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(QUEST_NAME, latest))
                .extra(new SpeedrunNotificationData(QUEST_NAME, Duration.ofMinutes(1).plusSeconds(30).plusMillis(250).toString(), Duration.ofMinutes(1).plusSeconds(15).plusMillis(300).toString(), true))
                .type(NotificationType.SPEEDRUN)
                .build()
        );
    }

    @Test
    void testIgnoreDenyList() {
        String latest = "1:15.30";

        // configure deny list
        when(config.filteredNames()).thenReturn(PLAYER_NAME);
        settingsManager.init();

        // mock widget
        Widget time = mock(Widget.class);
        when(client.getWidget(SPEEDRUN_COMPLETED_GROUP_ID, SPEEDRUN_COMPLETED_DURATION_CHILD_ID)).thenReturn(time);
        when(time.getText()).thenReturn(latest);

        // fire fake event
        notifier.onGameMessage(String.format("Speedrun duration: %s (new personal best)", latest));
        plugin.onWidgetLoaded(event());

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private WidgetLoaded event() {
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(SPEEDRUN_COMPLETED_GROUP_ID);
        return event;
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.AccountType;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.GroupStorageNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.Varbits;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanID;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetModalMode;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Arrays;
import java.util.Collections;

import static dinkplugin.notifiers.GroupStorageNotifier.EMPTY_TRANSACTION;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class GroupStorageNotifierTest extends MockedNotifierTest {

    private static final String GROUP_NAME = "Dink QA";
    private static final int OPAL_PRICE = 600;
    private static final int RUBY_PRICE = 900;
    private static final int TUNA_PRICE = 100;
    private static final WidgetLoaded LOAD_EVENT;
    private static final WidgetClosed CLOSE_EVENT;

    @Bind
    @InjectMocks
    GroupStorageNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.discordRichEmbeds()).thenReturn(true);
        when(config.notifyGroupStorage()).thenReturn(true);
        when(config.groupStorageSendImage()).thenReturn(false);
        when(config.groupStorageIncludeClan()).thenReturn(true);
        when(config.groupStorageIncludePrice()).thenReturn(true);
        when(config.groupStorageNotifyMessage())
            .thenReturn("%USERNAME% has deposited:\n%DEPOSITED%\n\n%USERNAME% has withdrawn:\n%WITHDRAWN%");

        // init item mocks
        mockItem(ItemID.COINS, 1, "Coins");
        mockItem(ItemID.OPAL, OPAL_PRICE, "Opal");
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
        mockItem(ItemID.TUNA, TUNA_PRICE, "Tuna");
        mockItem(ItemID.TUNA_26149, TUNA_PRICE, "Tuna");
        when(itemManager.canonicalize(ItemID.TUNA_26149)).thenReturn(ItemID.TUNA);

        // init group mock
        when(client.getVarbitValue(Varbits.ACCOUNT_TYPE)).thenReturn(AccountType.HARDCORE_GROUP_IRONMAN.ordinal());
        ClanChannel channel = mock(ClanChannel.class);
        when(channel.getName()).thenReturn(GROUP_NAME);
        when(client.getClanChannel(ClanID.GROUP_IRONMAN)).thenReturn(channel);
    }

    @Test
    void testNotify() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.singletonList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby")),
            Collections.singletonList(new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal")),
            RUBY_PRICE - OPAL_PRICE,
            GROUP_NAME,
            true
        );

        verifyNotification(extra, "+ 1 x Ruby (" + RUBY_PRICE + ")", "- 1 x Opal (" + OPAL_PRICE + ")");
    }

    @Test
    void testNotifyNonePrice() {
        when(config.groupStorageIncludePrice()).thenReturn(false);

        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 2), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.singletonList(new SerializedItemStack(ItemID.RUBY, 2, RUBY_PRICE, "Ruby")),
            Collections.singletonList(new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal")),
            (2*RUBY_PRICE) - OPAL_PRICE,
            GROUP_NAME,
            false
        );

        verifyNotification(extra, "+ 2 x Ruby", "- 1 x Opal");
    }

    @Test
    void testNotifyCoins() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.COINS_6964, 100) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.COINS_8890, 1000) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.emptyList(),
            Collections.singletonList(new SerializedItemStack(ItemID.COINS, 900, 1, "Coins")),
            -900,
            GROUP_NAME,
            true
        );

        verifyNotification(extra, EMPTY_TRANSACTION, "- 900 x Coins (900)");
    }

    @Test
    void testNotifyStackable() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 2), new Item(ItemID.COINS_6964, 100), new Item(ItemID.COINS_995, 150) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.RUBY, 1), new Item(ItemID.COINS_8890, 1000), new Item(ItemID.COINS, 50) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.emptyList(),
            Collections.singletonList(new SerializedItemStack(ItemID.COINS, 800, 1, "Coins")),
            -800,
            GROUP_NAME,
            true
        );

        verifyNotification(extra, EMPTY_TRANSACTION, "- 800 x Coins (800)");
    }

    @Test
    void testNotifyMultipleDebit() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        mockContainer(new Item[0]);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Arrays.asList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby"), new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal")),
            Collections.emptyList(),
            RUBY_PRICE + OPAL_PRICE,
            GROUP_NAME,
            true
        );

        verifyNotification(extra, "+ 1 x Ruby (" + RUBY_PRICE + ")\n+ 1 x Opal (" + OPAL_PRICE + ")", EMPTY_TRANSACTION);
    }

    @Test
    void testNotifyMultipleCredit() {
        // mock initial inventory state
        mockContainer(new Item[0]);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.emptyList(),
            Arrays.asList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby"), new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal")),
            -(RUBY_PRICE + OPAL_PRICE),
            GROUP_NAME,
            true
        );

        verifyNotification(extra, EMPTY_TRANSACTION, "- 1 x Ruby (" + RUBY_PRICE + ")\n- 1 x Opal (" + OPAL_PRICE + ")");
    }

    @Test
    void testNotifyNoted() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.TUNA, 2) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA_26149, 3) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.emptyList(),
            Collections.singletonList(new SerializedItemStack(ItemID.TUNA, 1, TUNA_PRICE, "Tuna")),
            -TUNA_PRICE,
            GROUP_NAME,
            true
        );

        verifyNotification(extra, EMPTY_TRANSACTION, "- 1 x Tuna (" + TUNA_PRICE + ")");
    }

    @Test
    void testWithoutGroupName() {
        // update config mocks
        when(config.groupStorageIncludeClan()).thenReturn(false);

        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // verify notification message
        GroupStorageNotificationData extra = new GroupStorageNotificationData(
            Collections.singletonList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby")),
            Collections.singletonList(new SerializedItemStack(ItemID.OPAL, 1, OPAL_PRICE, "Opal")),
            RUBY_PRICE - OPAL_PRICE,
            null,
            true
        );

        verifyNotification(extra, "+ 1 x Ruby (" + RUBY_PRICE + ")", "- 1 x Opal (" + OPAL_PRICE + ")");
    }

    @Test
    void testIgnoreNoted() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.TUNA, 2) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA_26149, 2) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreValue() {
        // update config mocks
        when(config.groupStorageMinValue()).thenReturn(RUBY_PRICE + 1);

        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreZero() {
        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.RUBY, 1) };
        mockContainer(updatedItems);

        mockSaveWidget();
        notifier.onWidgetClose(CLOSE_EVENT);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnore() {
        // update mocks
        when(config.notifyGroupStorage()).thenReturn(false);

        // mock initial inventory state
        Item[] initialItems = { new Item(ItemID.RUBY, 1), new Item(ItemID.TUNA, 1) };
        mockContainer(initialItems);
        notifier.onWidgetLoad(LOAD_EVENT);

        // mock updated inventory
        Item[] updatedItems = { new Item(ItemID.TUNA, 1), new Item(ItemID.OPAL, 1) };
        mockContainer(updatedItems);
        notifier.onWidgetClose(CLOSE_EVENT);

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private void verifyNotification(GroupStorageNotificationData extra, String deposited, String withdrawn) {
        String text = String.format(
            "%s has deposited:\n%s\n\n%s has withdrawn:\n%s",
            PLAYER_NAME, deposited, PLAYER_NAME, withdrawn
        );

        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template("{{x}}")
                        .replacement("{{x}}", Replacements.ofBlock("diff", text))
                        .build()
                )
                .extra(extra)
                .type(NotificationType.GROUP_STORAGE)
                .playerName(PLAYER_NAME)
                .build()
        );
    }

    private void mockContainer(Item[] items) {
        ItemContainer container = mock(ItemContainer.class);
        when(container.getItems()).thenReturn(items);
        when(client.getItemContainer(InventoryID.GROUP_STORAGE_INV)).thenReturn(container);
    }

    private void mockSaveWidget() {
        Widget widget = mock(Widget.class);
        when(client.getWidget(GroupStorageNotifier.GROUP_STORAGE_SAVING_WIDGET_ID, 1)).thenReturn(widget);
        when(widget.getText()).thenReturn("Saving...");
    }

    static {
        LOAD_EVENT = new WidgetLoaded();
        LOAD_EVENT.setGroupId(GroupStorageNotifier.GROUP_STORAGE_WIDGET_GROUP);
        CLOSE_EVENT = new WidgetClosed(GroupStorageNotifier.GROUP_STORAGE_SAVING_WIDGET_ID, WidgetModalMode.MODAL_NOCLICKTHROUGH, true);
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.QuestNotificationData;
import net.runelite.api.VarPlayer;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import static dinkplugin.util.QuestUtils.parseQuestWidget;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class QuestNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    QuestNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyQuest()).thenReturn(true);
        when(config.questSendImage()).thenReturn(false);
        when(config.questNotifyMessage()).thenReturn("%USERNAME% has completed: %QUEST%");

    }

    @Test
    void testNotify() {
        // init client mocks
        when(client.getVarbitValue(QuestNotifier.COMPLETED_ID)).thenReturn(22);
        when(client.getVarbitValue(QuestNotifier.TOTAL_ID)).thenReturn(156);
        when(client.getVarpValue(VarPlayer.QUEST_POINTS)).thenReturn(44);
        when(client.getVarbitValue(QuestNotifier.QP_TOTAL_ID)).thenReturn(293);

        // mock widget
        Widget questWidget = mock(Widget.class);
        when(client.getWidget(ComponentID.QUEST_COMPLETED_NAME_TEXT)).thenReturn(questWidget);
        when(questWidget.getText()).thenReturn("You have completed the Dragon Slayer I quest!");

        // send event
        plugin.onWidgetLoaded(event(InterfaceID.QUEST_COMPLETED));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has completed: {{quest}}")
                        .replacement("{{quest}}", Replacements.ofWiki("Dragon Slayer I"))
                        .build()
                )
                .extra(new QuestNotificationData("Dragon Slayer I", 22, 156, 44, 293))
                .type(NotificationType.QUEST)
                .build()
        );
    }

    @Test
    void testIgnore() {
        // send unrelated event
        plugin.onWidgetLoaded(event(-1));

        // verify no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyQuest()).thenReturn(false);

        // mock widget
        Widget questWidget = mock(Widget.class);
        when(client.getWidget(ComponentID.QUEST_COMPLETED_NAME_TEXT)).thenReturn(questWidget);
        when(questWidget.getText()).thenReturn("You have completed the Dragon Slayer quest!");

        // send event
        plugin.onWidgetLoaded(event(InterfaceID.QUEST_COMPLETED));

        // verify no message
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void parseWidgets() {
        assertEquals("Recipe for Disaster - Another Cook's Quest", parseQuestWidget("You have completed Another Cook's Quest!"));
        assertEquals("Recipe for Disaster - Another Cook's Quest", parseQuestWidget("You have assisted the Lumbridge Cook... again!"));
        assertEquals("Recipe for Disaster - Goblin Generals", parseQuestWidget("You have freed the Goblin Generals!"));
        assertEquals("Recipe for Disaster - Sir Amik Varze", parseQuestWidget("You have freed Sir Amik Varze!"));
        assertEquals("Recipe for Disaster - Skrach Uglogwee", parseQuestWidget("You have freed Skrach 'Bone Crusher' Uglogwee!"));
        assertEquals("Recipe for Disaster", parseQuestWidget("You have completed Recipe for Disaster!"));

        assertEquals("Doric's Quest", parseQuestWidget("You have completed Doric's Quest!"));
        assertEquals("Heroes Quest", parseQuestWidget("You have completed the Heroes' Quest!"));

        assertEquals("Dragon Slayer II", parseQuestWidget("You have completed Dragon Slayer II!"));
        assertEquals("Rag and Bone Man II", parseQuestWidget("You have completed Rag and Bone Man II!"));
        assertEquals("Fairytale II - Cure a Queen", parseQuestWidget("You have completed Fairytale II - Cure a Queen!"));

        assertNull(parseQuestWidget("You have... kind of... completed Hazeel Cult!"));
        assertEquals("Hazeel Cult", parseQuestWidget("You have completed Hazeel Cult!"));
    }

    private static WidgetLoaded event(int id) {
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(id);
        return event;
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.ClueTier;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.ClueNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import net.runelite.api.ItemID;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class ClueNotifierTest extends MockedNotifierTest {

    private static final int RUBY_PRICE = 900;
    private static final int TUNA_PRICE = 100;

    @Bind
    @InjectMocks
    ClueNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyClue()).thenReturn(true);
        when(config.clueSendImage()).thenReturn(false);
        when(config.clueShowItems()).thenReturn(false);
        when(config.clueMinTier()).thenReturn(ClueTier.MEDIUM);
        when(config.clueMinValue()).thenReturn(500);
        when(config.clueNotifyMessage()).thenReturn("%USERNAME% has completed a %CLUE% clue, for a total of %COUNT%. They obtained: %LOOT%");

        // init item mocks
        mockItem(ItemID.RUBY, RUBY_PRICE, "Ruby");
        mockItem(ItemID.TUNA, TUNA_PRICE, "Tuna");
    }

    @Test
    void testNotify() {
        // fire chat event
        notifier.onChatMessage("You have completed 1312 medium Treasure Trails.");

        // mock widgets
        Widget widget = mock(Widget.class);
        when(client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER)).thenReturn(widget);

        Widget child = mock(Widget.class);
        when(child.getItemQuantity()).thenReturn(1);
        when(child.getItemId()).thenReturn(ItemID.RUBY);

        Widget[] children = { child };
        when(widget.getChildren()).thenReturn(children);

        // fire widget event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.CLUESCROLL_REWARD);
        plugin.onWidgetLoaded(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has completed a {{tier}} clue, for a total of %d. They obtained: 1 x {{ruby}} (%d)", PLAYER_NAME, 1312, RUBY_PRICE))
                        .replacement("{{tier}}", Replacements.ofWiki("medium", "Clue scroll (medium)"))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .build()
                )
                .extra(new ClueNotificationData("medium", 1312, Collections.singletonList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby"))))
                .type(NotificationType.CLUE)
                .build()
        );
    }

    @Test
    void testNotifyFirst() {
        // update config mock
        when(config.clueMinTier()).thenReturn(ClueTier.EASY);

        // fire chat event
        notifier.onChatMessage("You have completed 1 easy Treasure Trail.");

        // mock widgets
        Widget widget = mock(Widget.class);
        when(client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER)).thenReturn(widget);

        Widget child = mock(Widget.class);
        when(child.getItemQuantity()).thenReturn(1);
        when(child.getItemId()).thenReturn(ItemID.RUBY);

        Widget[] children = { child };
        when(widget.getChildren()).thenReturn(children);

        // fire widget event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.CLUESCROLL_REWARD);
        plugin.onWidgetLoaded(event);

        // verify notification message
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(String.format("%s has completed a {{tier}} clue, for a total of %d. They obtained: 1 x {{ruby}} (%d)", PLAYER_NAME, 1, RUBY_PRICE))
                        .replacement("{{tier}}", Replacements.ofWiki("easy", "Clue scroll (easy)"))
                        .replacement("{{ruby}}", Replacements.ofWiki("Ruby"))
                        .build()
                )
                .extra(new ClueNotificationData("easy", 1, Collections.singletonList(new SerializedItemStack(ItemID.RUBY, 1, RUBY_PRICE, "Ruby"))))
                .type(NotificationType.CLUE)
                .build()
        );
    }

    @Test
    void testIgnoreTier() {
        // fire chat event
        notifier.onChatMessage("You have completed 1312 beginner Treasure Trails.");

        // mock widgets
        Widget widget = mock(Widget.class);
        when(client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER)).thenReturn(widget);

        Widget child = mock(Widget.class);
        when(child.getItemQuantity()).thenReturn(1);
        when(child.getItemId()).thenReturn(ItemID.RUBY);

        Widget[] children = { child };
        when(widget.getChildren()).thenReturn(children);

        // fire widget event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.CLUESCROLL_REWARD);
        plugin.onWidgetLoaded(event);

        // ensure no notification was fired
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreLoot() {
        // fire chat event
        notifier.onChatMessage("You have completed 1337 medium Treasure Trails.");

        // mock widgets
        Widget widget = mock(Widget.class);
        when(client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER)).thenReturn(widget);

        Widget child = mock(Widget.class);
        when(child.getItemQuantity()).thenReturn(1);
        when(child.getItemId()).thenReturn(ItemID.TUNA);

        Widget[] children = { child };
        when(widget.getChildren()).thenReturn(children);

        // fire widget event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.CLUESCROLL_REWARD);
        plugin.onWidgetLoaded(event);

        // ensure no notification was fired
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyClue()).thenReturn(false);

        // fire chat event
        notifier.onChatMessage("You have completed 1312 medium Treasure Trails.");

        // mock widgets
        Widget widget = mock(Widget.class);
        when(client.getWidget(ComponentID.CLUESCROLL_REWARD_ITEM_CONTAINER)).thenReturn(widget);

        Widget child = mock(Widget.class);
        when(child.getItemQuantity()).thenReturn(1);
        when(child.getItemId()).thenReturn(ItemID.RUBY);

        Widget[] children = { child };
        when(widget.getChildren()).thenReturn(children);

        // fire widget event
        WidgetLoaded event = new WidgetLoaded();
        event.setGroupId(InterfaceID.CLUESCROLL_REWARD);
        plugin.onWidgetLoaded(event);

        // ensure no notification was fired
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.PlayerLookupService;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.PlayerKillNotificationData;
import dinkplugin.notifiers.data.SerializedItemStack;
import dinkplugin.util.WorldUtils;
import net.runelite.api.Actor;
import net.runelite.api.Hitsplat;
import net.runelite.api.HitsplatID;
import net.runelite.api.ItemID;
import net.runelite.api.Player;
import net.runelite.api.PlayerComposition;
import net.runelite.api.Skill;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.kit.KitType;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Collections;
import java.util.EnumMap;
import java.util.Map;

import static net.runelite.api.HitsplatID.DAMAGE_OTHER;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class PlayerKillNotifierTest extends MockedNotifierTest {

    private static final String TARGET = "Romy";
    private static final int LEVEL = 99;
    private static final int MY_HP = 10;
    private static final int WORLD = 420;
    private static final WorldPoint LOCATION = new WorldPoint(3000, 4000, 0);
    private static final int WEAPON_PRICE = 100_000;
    private static final int TOP_PRICE = 120_000;
    private static final int LEGS_PRICE = 80_000;
    private static final int HAND_PRICE = 100_000;
    private static final int SHIELD_PRICE = 200;
    private static final int EQUIPMENT_VALUE = WEAPON_PRICE + TOP_PRICE + LEGS_PRICE + HAND_PRICE + SHIELD_PRICE;
    private static final Map<KitType, SerializedItemStack> EQUIPMENT;

    @Bind
    @InjectMocks
    PlayerKillNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyPk()).thenReturn(true);
        when(config.pkMinValue()).thenReturn(EQUIPMENT_VALUE);
        when(config.pkIncludeLocation()).thenReturn(true);
        when(config.pkNotifyMessage()).thenReturn("%USERNAME% has PK'd %TARGET%");
        when(config.playerLookupService()).thenReturn(PlayerLookupService.NONE);

        // init client mocks
        when(client.getWorld()).thenReturn(WORLD);
        when(client.getBoostedSkillLevel(Skill.HITPOINTS)).thenReturn(MY_HP);

        // init item mocks
        for (SerializedItemStack item : EQUIPMENT.values()) {
            mockItem(item.getId(), item.getPriceEach(), item.getName());
        }
    }

    @Test
    void testNotify() {
        // init mocks
        when(config.playerLookupService()).thenReturn(PlayerLookupService.OSRS_HISCORE);
        Player target = mockPlayer();

        // fire event
        int damage = 12;
        notifier.onHitsplat(event(target, damage));
        notifier.onTick();

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has PK'd {{target}}")
                        .replacement("{{target}}", Replacements.ofLink(TARGET, PlayerLookupService.OSRS_HISCORE.getPlayerUrl(TARGET)))
                        .build()
                )
                .type(NotificationType.PLAYER_KILL)
                .playerName(PLAYER_NAME)
                .extra(new PlayerKillNotificationData(TARGET, LEVEL, EQUIPMENT, WORLD, LOCATION, MY_HP, damage))
                .build()
        );
    }

    @Test
    void testNotifyMulti() {
        // init mocks
        Player target = mockPlayer();

        // fire events
        notifier.onHitsplat(event(target, 5));
        notifier.onHitsplat(event(target, 7));
        notifier.onTick();

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has PK'd %s", PLAYER_NAME, TARGET)))
                .type(NotificationType.PLAYER_KILL)
                .playerName(PLAYER_NAME)
                .extra(new PlayerKillNotificationData(TARGET, LEVEL, EQUIPMENT, WORLD, LOCATION, MY_HP, 12))
                .build()
        );
    }

    @Test
    void testNotifyMultiOther() {
        // init mocks
        Player target = mockPlayer();

        // fire event
        int damage = 12;
        notifier.onHitsplat(event(target, damage));
        HitsplatApplied eventOther = new HitsplatApplied();
        eventOther.setActor(target);
        eventOther.setHitsplat(new Hitsplat(DAMAGE_OTHER, 13, 1));
        notifier.onHitsplat(eventOther);
        notifier.onTick();

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(buildTemplate(String.format("%s has PK'd %s", PLAYER_NAME, TARGET)))
                .type(NotificationType.PLAYER_KILL)
                .playerName(PLAYER_NAME)
                .extra(new PlayerKillNotificationData(TARGET, LEVEL, EQUIPMENT, WORLD, LOCATION, MY_HP, damage))
                .build()
        );
    }

    @Test
    void testIgnoreValue() {
        // init mocks
        Player target = mockPlayer();
        target.getPlayerComposition().getEquipmentIds()[KitType.SHIELD.getIndex()] = 0;

        // fire event
        notifier.onHitsplat(event(target, 13));
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreZero() {
        // init mocks
        Player target = mockPlayer();

        // fire event
        notifier.onHitsplat(event(target, 0));
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreSafe() {
        // init mocks
        Player target = mockPlayer();
        when(config.pkSkipSafe()).thenReturn(true);
        when(localPlayer.getWorldLocation()).thenReturn(
            WorldPoint.fromRegion(WorldUtils.TZHAAR_PIT, 0, 0, 0)
        );

        // fire event
        notifier.onHitsplat(event(target, 14));
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreFriendly() {
        // init mocks
        Player target = mockPlayer();
        when(config.pkSkipFriendly()).thenReturn(true);
        when(target.isFriend()).thenReturn(true);

        // fire event
        notifier.onHitsplat(event(target, 15));
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // init mocks
        Player target = mockPlayer();
        when(config.notifyPk()).thenReturn(false);

        // fire event
        notifier.onHitsplat(event(target, 16));
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreOther() {
        // init mocks
        Player target = mockPlayer();

        // fire event
        HitsplatApplied event = new HitsplatApplied();
        event.setActor(target);
        event.setHitsplat(new Hitsplat(DAMAGE_OTHER, 17, 1));
        notifier.onHitsplat(event);
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreSelf() {
        // fire event
        HitsplatApplied event = new HitsplatApplied();
        event.setActor(localPlayer);
        event.setHitsplat(new Hitsplat(HitsplatID.DAMAGE_ME, 18, 1));
        notifier.onHitsplat(event);
        notifier.onTick();

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private Player mockPlayer() {
        Player target = mock(Player.class);
        when(target.getName()).thenReturn(TARGET);
        when(target.isDead()).thenReturn(true);
        when(target.getCombatLevel()).thenReturn(LEVEL);
        when(target.getWorldLocation()).thenReturn(LOCATION);
        when(target.getWorldView()).thenReturn(worldView);
        PlayerComposition comp = mock(PlayerComposition.class);
        when(target.getPlayerComposition()).thenReturn(comp);
        int[] equipment = new int[KitType.values().length];
        EQUIPMENT.forEach((kit, item) -> equipment[kit.getIndex()] = item.getId() + PlayerComposition.ITEM_OFFSET);
        when(comp.getEquipmentIds()).thenReturn(equipment);
        return target;
    }

    private static HitsplatApplied event(Actor actor, int amount) {
        HitsplatApplied e = new HitsplatApplied();
        e.setActor(actor);
        e.setHitsplat(new Hitsplat(HitsplatID.DAMAGE_ME, amount, 1));
        return e;
    }

    static {
        Map<KitType, SerializedItemStack> m = new EnumMap<>(KitType.class);
        m.put(KitType.WEAPON, new SerializedItemStack(ItemID.ANCIENT_STAFF, 1, WEAPON_PRICE, "Ancient staff"));
        m.put(KitType.TORSO, new SerializedItemStack(ItemID.MYSTIC_ROBE_TOP, 1, TOP_PRICE, "Mystic robe top"));
        m.put(KitType.LEGS, new SerializedItemStack(ItemID.MYSTIC_ROBE_BOTTOM, 1, LEGS_PRICE, "Mystic robe bottom"));
        m.put(KitType.HANDS, new SerializedItemStack(ItemID.BARROWS_GLOVES, 1, HAND_PRICE, "Barrows gloves"));
        m.put(KitType.SHIELD, new SerializedItemStack(ItemID.UNHOLY_BOOK, 1, SHIELD_PRICE, "Unholy book"));
        EQUIPMENT = Collections.unmodifiableMap(m);
    }
}

package dinkplugin.notifiers;

import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.domain.ExternalScreenshotPolicy;
import dinkplugin.message.Field;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.ExternalNotificationData;
import net.runelite.client.events.PluginMessage;
import okhttp3.HttpUrl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

public class ExternalPluginNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    ExternalPluginNotifier notifier;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // update config mocks
        when(config.notifyExternal()).thenReturn(true);
        when(config.externalSendImage()).thenReturn(ExternalScreenshotPolicy.REQUESTED);
    }

    @Test
    void testNotify() {
        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", samplePayload(null)));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("Hello %TARGET% from %USERNAME%")
                        .replacement("%TARGET%", Replacements.ofText("world"))
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testNoReplacements() {
        // fire event
        var payload = samplePayload(null);
        payload.remove("replacements");
        payload.put("text", "text with no replacements");
        plugin.onPluginMessage(new PluginMessage("dink", "notify", payload));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("text with no replacements")
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testMissingReplacement() {
        // fire event
        var payload = samplePayload(null);
        payload.remove("replacements");
        payload.put("text", "text with no custom replacement %USERNAME%");
        plugin.onPluginMessage(new PluginMessage("dink", "notify", payload));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("text with no custom replacement %USERNAME%")
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testPatternWithoutReplacement() {
        // fire event
        var payload = samplePayload(null);
        payload.remove("replacements");
        payload.put("text", "text with no custom replacement %XD%");
        plugin.onPluginMessage(new PluginMessage("dink", "notify", payload));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("text with no custom replacement %XD%")
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testFallbackUrl() {
        // update config mocks
        String url = "https://example.com/";
        when(config.externalWebhook()).thenReturn(url);

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", samplePayload(null)));

        // verify notification
        verifyCreateMessage(
            url,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("Hello %TARGET% from %USERNAME%")
                        .replacement("%TARGET%", Replacements.ofText("world"))
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testImage() {
        // update config mocks
        when(config.externalSendImage()).thenReturn(ExternalScreenshotPolicy.ALWAYS);

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", samplePayload(null)));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("Hello %TARGET% from %USERNAME%")
                        .replacement("%TARGET%", Replacements.ofText("world"))
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testRequestImage() {
        // prepare payload
        var data = samplePayload(null);
        data.put("imageRequested", true);

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", data));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            true,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("Hello %TARGET% from %USERNAME%")
                        .replacement("%TARGET%", Replacements.ofText("world"))
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testRequestImageDenied() {
        // update config mocks
        when(config.externalSendImage()).thenReturn(ExternalScreenshotPolicy.NEVER);

        // prepare payload
        var data = samplePayload(null);
        data.put("imageRequested", true);

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", data));

        // verify notification
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .type(NotificationType.EXTERNAL_PLUGIN)
                .playerName(PLAYER_NAME)
                .customTitle("My Title")
                .customFooter("Sent by MyExternalPlugin via Dink")
                .text(
                    Template.builder()
                        .template("Hello %TARGET% from %USERNAME%")
                        .replacement("%TARGET%", Replacements.ofText("world"))
                        .replacement("%USERNAME%", Replacements.ofText(PLAYER_NAME))
                        .build()
                )
                .extra(new ExternalNotificationData("MyExternalPlugin", List.of(new Field("sample key", "sample value", null)), Collections.singletonMap("hello", "world")))
                .build()
        );
    }

    @Test
    void testIgnoreNamespace() {
        // fire event
        plugin.onPluginMessage(new PluginMessage("DANK", "notify", samplePayload("https://example.com/")));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreName() {
        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "donk", samplePayload("https://example.com/")));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreBadUrls() {
        // prepare payload
        var data = samplePayload(null);
        data.put("urls", List.of("https://example.com/"));

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", data));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // update config mocks
        when(config.notifyExternal()).thenReturn(false);

        // fire event
        plugin.onPluginMessage(new PluginMessage("dink", "notify", samplePayload("https://example.com/")));

        // ensure no notification
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private static Map<String, Object> samplePayload(String url) {
        Map<String, Object> data = new HashMap<>();
        data.put("text", "Hello %TARGET% from %USERNAME%");
        data.put("title", "My Title");
        data.put("thumbnail", "not a url . com");
        data.put("fields", List.of(createField("sample key", "sample value")));
        data.put("replacements", Map.of("%TARGET%", createTextReplacement("world")));
        data.put("metadata", Map.of("hello", "world"));
        data.put("sourcePlugin", "MyExternalPlugin");
        if (url != null) {
            data.put("urls", Collections.singletonList(HttpUrl.parse(url)));
        }
        return data;
    }

    private static Map<String, Object> createField(String name, String value) {
        return Map.of("name", name, "value", value);
    }

    private static Map<String, String> createTextReplacement(String text) {
        return Map.of("value", text);
    }

}

package dinkplugin.notifiers;

import com.google.common.collect.ImmutableMap;
import com.google.inject.testing.fieldbinder.Bind;
import dinkplugin.message.NotificationBody;
import dinkplugin.message.NotificationType;
import dinkplugin.message.templating.Replacements;
import dinkplugin.message.templating.Template;
import dinkplugin.notifiers.data.LevelNotificationData;
import dinkplugin.notifiers.data.XpNotificationData;
import net.runelite.api.Experience;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

class LevelNotifierTest extends MockedNotifierTest {

    @Bind
    @InjectMocks
    LevelNotifier notifier;
    int initialCombatLevel;
    LevelNotificationData.CombatLevel unchangedCombatLevel;

    @Override
    @BeforeEach
    protected void setUp() {
        super.setUp();

        // init config mocks
        when(config.notifyLevel()).thenReturn(true);
        when(config.levelSendImage()).thenReturn(false);
        when(config.levelNotifyVirtual()).thenReturn(true);
        when(config.levelNotifyCombat()).thenReturn(true);
        when(config.levelInterval()).thenReturn(5);
        when(config.levelNotifyMessage()).thenReturn("%USERNAME% has levelled %SKILL%");
        when(config.levelIntervalOverride()).thenReturn(95);

        // init base level
        when(client.getRealSkillLevel(any())).thenReturn(1);
        mockLevel(Skill.ATTACK, 99);
        mockLevel(Skill.HITPOINTS, 10);
        mockLevel(Skill.HUNTER, 4);
        mockLevel(Skill.SLAYER, 96);
        mockLevel(Skill.FARMING, 99);
        when(client.getSkillExperience(Skill.FARMING)).thenReturn(Experience.MAX_SKILL_XP);
        initialCombatLevel = Experience.getCombatLevel(99, 1, 1, 10, 1, 1, 1);
        unchangedCombatLevel = new LevelNotificationData.CombatLevel(initialCombatLevel, false);
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 0, 1, 1));
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, 14_000_000, 99, 99));
        plugin.onStatChanged(new StatChanged(Skill.HITPOINTS, 1200, 10, 10));
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 300, 4, 4));
        plugin.onStatChanged(new StatChanged(Skill.SLAYER, 9_800_000, 96, 96));
        plugin.onStatChanged(new StatChanged(Skill.FARMING, Experience.MAX_SKILL_XP, 99, 99));
        IntStream.rangeClosed(0, LevelNotifier.INIT_GAME_TICKS + 1).forEach(i -> notifier.onTick());
    }

    @Test
    void testNotify() {
        Map<String, Integer> expectedSkills = skillsMap("Agility", 5);
        int totalLevel = expectedSkills.values().stream().mapToInt(i -> i).sum();
        when(client.getTotalLevel()).thenReturn(totalLevel);
        when(config.levelNotifyMessage()).thenReturn("%USERNAME% has levelled %SKILL%, achieving a total level of %TOTAL_LEVEL%");

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 400, 5, 5));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 5, achieving a total level of {{total}}")
                        .replacement("{{skill}}", Replacements.ofWiki("Agility"))
                        .replacement("{{total}}", Replacements.ofText(String.valueOf(totalLevel)))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Agility", 5), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyJump() {
        Map<String, Integer> expectedSkills = skillsMap("Hunter", 6);

        // fire skill event (4 => 6, skipping 5 while 5 is level interval)
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 600, 6, 6));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 6")
                        .replacement("{{skill}}", Replacements.ofWiki("Hunter"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Hunter", 6), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyVirtual() {
        Map<String, Integer> expectedSkills = skillsMap("Attack", 100);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, 15_000_000, 99, 100));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 100")
                        .replacement("{{skill}}", Replacements.ofWiki("Attack"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Attack", 100), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyMaxExperience() {
        Map<String, Integer> expectedSkills = skillsMap("Hunter", 127);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 200_000_000, 99, 126));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to Max XP (200M)")
                        .replacement("{{skill}}", Replacements.ofWiki("Hunter"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Hunter", 127), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyTwo() {
        Map<String, Integer> expectedSkills = skillsMap(
            new String[] { "Agility", "Hunter" },
            new int[] { 5, 99 }
        );

        // fire skill events
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 400, 5, 5));
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 14_000_000, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{s1}} to 5 and {{s2}} to 99")
                        .replacement("{{s1}}", Replacements.ofWiki("Agility"))
                        .replacement("{{s2}}", Replacements.ofWiki("Hunter"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Agility", 5, "Hunter", 99), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyMany() {
        Map<String, Integer> expectedSkills = skillsMap(
            new String[] { "Agility", "Attack", "Hunter" },
            new int[] { 5, 100, 5 }
        );

        // fire skill events
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 400, 5, 5));
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, 15_000_000, 99, 100));
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 400, 5, 5));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{s1}} to 5, {{s2}} to 100, and {{s3}} to 5")
                        .replacement("{{s1}}", Replacements.ofWiki("Agility"))
                        .replacement("{{s2}}", Replacements.ofWiki("Attack"))
                        .replacement("{{s3}}", Replacements.ofWiki("Hunter"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Agility", 5, "Attack", 100, "Hunter", 5), expectedSkills, unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyCombat() {
        Map<String, Integer> expectedSkills = skillsMap("Hitpoints", 13);

        // update config mocks
        when(config.levelInterval()).thenReturn(18); // won't trigger on hp @ 13, will trigger on combat level @ 36

        // fire skill event
        mockLevel(Skill.HITPOINTS, 13);
        plugin.onStatChanged(new StatChanged(Skill.HITPOINTS, 2000, 13, 13));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        LevelNotificationData.CombatLevel combatLevel = new LevelNotificationData.CombatLevel(initialCombatLevel + 1, true);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 36")
                        .replacement("{{skill}}", Replacements.ofWiki("Combat", "Combat level"))
                        .build()
                )
                .extra(new LevelNotificationData(Collections.emptyMap(), expectedSkills, combatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyTwoCombat() {
        Map<String, Integer> expectedSkills = skillsMap("Hitpoints", 13);

        // update config mocks
        when(config.levelInterval()).thenReturn(1);

        // fire skill event
        mockLevel(Skill.HITPOINTS, 13);
        plugin.onStatChanged(new StatChanged(Skill.HITPOINTS, 2000, 13, 13));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        LevelNotificationData.CombatLevel combatLevel = new LevelNotificationData.CombatLevel(initialCombatLevel + 1, true);
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{s1}} to 13 and {{s2}} to 36")
                        .replacement("{{s1}}", Replacements.ofWiki("Hitpoints"))
                        .replacement("{{s2}}", Replacements.ofWiki("Combat", "Combat level"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Hitpoints", 13), expectedSkills, combatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testNotifyXp() {
        // update config mocks
        when(config.xpInterval()).thenReturn(5);
        when(config.levelNotifyVirtual()).thenReturn(false);

        // prepare state
        int attackXp = 15_000_100;
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(attackXp);
        Map<String, Integer> map = xpMap();
        long total = map.values().stream().mapToInt(i -> i).sum();
        when(client.getOverallExperience()).thenReturn(total);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, attackXp, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 15,000,000 XP")
                        .replacement("{{skill}}", Replacements.ofWiki("Attack"))
                        .build()
                )
                .extra(new XpNotificationData(map, List.of(Skill.ATTACK.getName()), 5_000_000))
                .type(NotificationType.XP_MILESTONE)
                .build()
        );
    }

    @Test
    void testNotifyXpExact() {
        // update config mocks
        when(config.xpInterval()).thenReturn(5);
        when(config.levelNotifyVirtual()).thenReturn(false);

        // prepare state
        int attackXp = 15_000_000;
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(attackXp);
        Map<String, Integer> map = xpMap();
        long total = map.values().stream().mapToInt(i -> i).sum();
        when(client.getOverallExperience()).thenReturn(total);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, attackXp, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 15,000,000 XP")
                        .replacement("{{skill}}", Replacements.ofWiki("Attack"))
                        .build()
                )
                .extra(new XpNotificationData(map, List.of(Skill.ATTACK.getName()), 5_000_000))
                .type(NotificationType.XP_MILESTONE)
                .build()
        );
    }

    @Test
    void testNotifyXpJump() {
        // update config mocks
        when(config.xpInterval()).thenReturn(5);
        when(config.levelNotifyVirtual()).thenReturn(false);

        // prepare state
        int attackXp = 20_000_999;
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(attackXp);
        Map<String, Integer> map = xpMap();
        long total = map.values().stream().mapToInt(i -> i).sum();
        when(client.getOverallExperience()).thenReturn(total);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, attackXp, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 20,000,000 XP")
                        .replacement("{{skill}}", Replacements.ofWiki("Attack"))
                        .build()
                )
                .extra(new XpNotificationData(map, List.of(Skill.ATTACK.getName()), 5_000_000))
                .type(NotificationType.XP_MILESTONE)
                .build()
        );
    }

    @Test
    void testNotifyXpMultiple() {
        // update config mocks
        when(config.xpInterval()).thenReturn(5);
        when(config.levelNotifyVirtual()).thenReturn(false);

        // prepare state
        int skillXp = 15_000_100;
        when(client.getSkillExperience(Skill.ATTACK)).thenReturn(skillXp);
        when(client.getSkillExperience(Skill.SLAYER)).thenReturn(skillXp);

        Map<String, Integer> map = xpMap();
        long total = map.values().stream().mapToInt(i -> i).sum();
        when(client.getOverallExperience()).thenReturn(total);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, skillXp, 99, 99));
        plugin.onStatChanged(new StatChanged(Skill.SLAYER, skillXp, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // verify handled
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{s1}} to 15,000,000 XP, {{s2}} to 15,000,000 XP")
                        .replacement("{{s1}}", Replacements.ofWiki("Attack"))
                        .replacement("{{s2}}", Replacements.ofWiki("Slayer"))
                        .build()
                )
                .extra(new XpNotificationData(map, List.of(Skill.ATTACK.getName(), Skill.SLAYER.getName()), 5_000_000))
                .type(NotificationType.XP_MILESTONE)
                .build()
        );
    }

    @Test
    void testIgnoreXpMax() {
        // update config mocks
        when(config.xpInterval()).thenReturn(5);
        when(config.levelNotifyVirtual()).thenReturn(false);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.FARMING, Experience.MAX_SKILL_XP, 99, 99));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    @DisplayName("Ensure the combat level notification isn't fired when notifyLevel is disabled")
    void testDisabledCombatLevel() {
        // update config mocks
        when(config.notifyLevel()).thenReturn(false);
        when(config.levelInterval())
            .thenReturn(
                18); // won't trigger on hp @ 13, will trigger on combat level @ 36

        // fire skill event
        mockLevel(Skill.HITPOINTS, 13);
        plugin.onStatChanged(new StatChanged(Skill.HITPOINTS, 2000, 13, 13));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreInterval() {
        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 100, 2, 2));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testOverrideInterval() {
        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.SLAYER, 10_695_000, 97, 97));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure a notification occurred
        verifyCreateMessage(
            PRIMARY_WEBHOOK_URL,
            false,
            NotificationBody.builder()
                .text(
                    Template.builder()
                        .template(PLAYER_NAME + " has levelled {{skill}} to 97")
                        .replacement("{{skill}}", Replacements.ofWiki("Slayer"))
                        .build()
                )
                .extra(new LevelNotificationData(ImmutableMap.of("Slayer", 97), skillsMap("Slayer", 97), unchangedCombatLevel))
                .type(NotificationType.LEVEL)
                .build()
        );
    }

    @Test
    void testIgnoreVirtual() {
        // update config mock
        when(config.levelNotifyVirtual()).thenReturn(false);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.ATTACK, 15_000_000, 99, 100));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreMaxExperience() {
        // update config mock
        when(config.levelNotifyVirtual()).thenReturn(false);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.HUNTER, 200_000_000, 99, 126));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testIgnoreAlreadyMaxExperience() {
        // update skill mocks
        Skill skill = Skill.CONSTRUCTION;
        when(client.getRealSkillLevel(skill)).thenReturn(99);
        when(client.getSkillExperience(skill)).thenReturn(Experience.MAX_SKILL_XP);
        when(config.levelNotifyVirtual()).thenReturn(false);
        plugin.onStatChanged(new StatChanged(skill, Experience.MAX_SKILL_XP, 99, 126));
        when(config.levelNotifyVirtual()).thenReturn(true);

        // fire skill event
        plugin.onStatChanged(new StatChanged(skill, 200_000_001, 99, 126));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    @Test
    void testDisabled() {
        // disable notifier
        when(config.notifyLevel()).thenReturn(false);

        // fire skill event
        plugin.onStatChanged(new StatChanged(Skill.AGILITY, 400, 5, 5));

        // let ticks pass
        IntStream.range(0, 4).forEach(i -> notifier.onTick());

        // ensure no notification occurred
        verify(messageHandler, never()).createMessage(any(), anyBoolean(), any());
    }

    private void mockLevel(Skill skill, int level) {
        when(client.getRealSkillLevel(skill)).thenReturn(level);
        when(client.getSkillExperience(skill)).thenReturn(Experience.getXpForLevel(level));
    }

    private Map<String, Integer> skillsMap(String skill, int level) {
        return skillsMap(new String[] { skill }, new int[] { level });
    }

    private Map<String, Integer> skillsMap(String[] skills, int[] updatedLevels) {
        Map<String, Integer> m = Arrays.stream(Skill.values())
            .collect(Collectors.toMap(Skill::getName, skill -> {
                int lvl = client.getRealSkillLevel(skill);
                if (lvl < 99) return lvl;
                int xp = client.getSkillExperience(skill);
                if (xp == Experience.MAX_SKILL_XP) return LevelNotifier.LEVEL_FOR_MAX_XP;
                return Experience.getLevelForXp(xp);
            }));
        for (int i = 0; i < skills.length; i++) {
            m.put(skills[i], updatedLevels[i]);
        }
        return m;
    }

    private Map<String, Integer> xpMap() {
        Skill[] skills = Skill.values();
        Map<String, Integer> m = new HashMap<>(skills.length);
        for (Skill skill : skills) {
            m.put(skill.getName(), client.getSkillExperience(skill));
        }
        return m;
    }
}

package dinkplugin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import lombok.Data;
import lombok.Value;
import net.runelite.api.ItemID;
import net.runelite.client.util.Text;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;

import java.io.BufferedWriter;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.regex.Pattern;

@Tag("generator")
class RarityCalculator {

    private static final String MONSTERS_URL = "https://raw.githubusercontent.com/Flipping-Utilities/parsed-osrs/main/data/monsters/all-monsters.json";

    private static final Comparator<Transformed> COMPARATOR = Comparator.comparingInt(Transformed::getItemId)
        .thenComparing(Transformed::getDenominator)
        .thenComparing(Transformed::getRolls, Comparator.nullsFirst(Comparator.naturalOrder()))
        .thenComparing(Transformed::getQuantity, Comparator.nullsLast(Comparator.naturalOrder()))
        .thenComparing(Transformed::getQuantMin, Comparator.nullsLast(Comparator.naturalOrder()))
        .thenComparing(Transformed::getQuantMax, Comparator.nullsLast(Comparator.naturalOrder()));

    private static final Pattern PARENTHETICAL_SUFFIX = Pattern.compile("\\s\\(.+\\)$");

    private final Gson gson = new GsonBuilder().create();
    private final OkHttpClient httpClient = new OkHttpClient();

    @Test
    void calculateMonsterRates() throws IOException {
        List<Monster> monsters;
        try (Response response = httpClient.newCall(new Request.Builder().url(MONSTERS_URL).build()).execute()) {
            if (!response.isSuccessful() || response.body() == null) {
                throw new RuntimeException("Could not read parsed monsters file");
            }
            monsters = gson.fromJson(response.body().charStream(), new TypeToken<List<Monster>>() {}.getType());
        }

        SortedMap<String, Collection<Transformed>> map = new TreeMap<>();
        for (Monster npc : monsters) {
            Collection<Transformed> drops = npc.getTransformed();
            if (drops.isEmpty()) continue;

            String name = PARENTHETICAL_SUFFIX.matcher(Text.removeTags(npc.getName()).replace("&#039;", "'")).replaceFirst("");
            map.putIfAbsent(name, drops);
        }

        String output = gson.toJson(map).replace(".00,", ",");
        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get("./src/main/resources/npc_drops.json"))) {
            writer.write(output);
            writer.newLine();
        }
    }

    @Data
    static class Monster {
        private int id;
        private String name;
        private List<Drop> drops;

        Collection<Transformed> getTransformed() {
            if (drops == null || drops.isEmpty()) return Collections.emptyList();
            SortedSet<Transformed> set = new TreeSet<>(COMPARATOR);
            boolean hasAlways = drops.stream().anyMatch(d -> "Always".equals(d.getRarity()));
            for (Drop drop : drops) {
                Transformed transformed = drop.transform();
                if (transformed == null) continue;
                if (hasAlways && transformed.getItemId() < 0) continue;
                set.add(transformed);
            }
            return set;
        }
    }

    @Data
    static class Drop {
        private String name;
        private String quantity;
        private String rarity;
        private Integer itemId;

        public Transformed transform() {
            if ("Nothing".equalsIgnoreCase(name)) {
                this.itemId = -1;
                this.quantity = "0";
            }
            if ("Tooth half of key (moon key)".equalsIgnoreCase(name)) {
                // Workaround for https://discord.com/channels/790429747364626452/954397870889529385/1294355009798017044
                this.itemId = ItemID.TOOTH_HALF_OF_KEY_30105;
            }
            if (itemId == null || rarity == null || quantity == null) return null;
            if (rarity.equals("Always") || rarity.equals("Varies") || rarity.equals("Random") || rarity.equals("Once") || rarity.equals("Unknown")) return null;
            if (quantity.equals("Unknown") || quantity.equals("N/A")) return null;

            int item = itemId == ItemID.COINS_995 || itemId == ItemID.COINS_6964 || itemId == ItemID.COINS_8890 ? ItemID.COINS : itemId;

            String cleanQuantity = StringUtils.removeEnd(quantity, "\u00A0");
            Integer q, min, max;
            String[] quantParts = StringUtils.split(cleanQuantity, ";");
            if (quantParts.length == 1) {
                q = Integer.parseInt(cleanQuantity.trim());
                min = max = null;
            } else {
                q = null;
                min = Integer.parseInt(quantParts[0].trim());
                max = Integer.parseInt(quantParts[quantParts.length - 1].trim());
            }

            int rollsDelim = rarity.indexOf("");
            Integer rolls;
            String cleanRarity;
            if (rollsDelim < 0) {
                rolls = null;
                cleanRarity = rarity.replace("~", "");
            } else {
                rolls = Integer.parseInt(rarity.substring(0, rollsDelim - 1).trim());
                cleanRarity = rarity.substring(rollsDelim + 2).replace("~", "");
            }

            BigDecimal denom;
            switch (cleanRarity) {
                case "Common":
                    denom = BigDecimal.valueOf(10);
                    break;
                case "Uncommon":
                    denom = BigDecimal.valueOf(50);
                    break;
                case "Rare":
                    denom = BigDecimal.valueOf(400);
                    break;
                case "Very rare":
                    denom = BigDecimal.valueOf(2000);
                    break;
                default:
                    String fraction = cleanRarity.endsWith("%") ? cleanRarity.substring(0, cleanRarity.length() - 1) + "/100" : cleanRarity;
                    String[] parts = StringUtils.split(fraction, '/');
                    if (parts.length != 2) throw new IllegalArgumentException(rarity);
                    double d = Double.parseDouble(parts[1]) / Double.parseDouble(parts[0]);
                    denom = BigDecimal.valueOf(d).setScale(2, RoundingMode.HALF_EVEN);
                    break;
            }

            return new Transformed(item, rolls, denom, q, min, max);
        }
    }

    @Value
    static class Transformed {
        @SerializedName("i") int itemId;
        @SerializedName("r") Integer rolls;
        @SerializedName("d") BigDecimal denominator;
        @SerializedName("q") Integer quantity;
        @SerializedName("m") Integer quantMin;
        @SerializedName("n") Integer quantMax;
    }
}

package dinkplugin;

import dinkplugin.util.ItemUtils;
import net.runelite.api.ItemID;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.stream.Stream;

import net.runelite.client.game.ItemStack;

import static org.junit.jupiter.api.Assertions.assertTrue;

class UtilsTest {

    @Test
    void coinVariations() {
        assertTrue(ItemUtils.COIN_VARIATIONS.contains(ItemID.COINS));
        assertTrue(ItemUtils.COIN_VARIATIONS.contains(ItemID.COINS_995));
        assertTrue(ItemUtils.COIN_VARIATIONS.contains(ItemID.COINS_6964));
        assertTrue(ItemUtils.COIN_VARIATIONS.contains(ItemID.COINS_8890));
    }

    @ParameterizedTest(name = "Item stack should be reduced {0}")
    @ArgumentsSource(ItemStackReductionProvider.class)
    void itemStackShouldBeReduced(Collection<ItemStack> input, Collection<ItemStack> reduced) {
        Collection<ItemStack> output = ItemUtils.reduceItemStack(input);
        assertTrue(reduced.containsAll(output));
        assertTrue(output.containsAll(reduced));
    }

    private static class ItemStackReductionProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of(Collections.emptyList(), Collections.emptyList()),
                Arguments.of(Collections.singletonList(new ItemStack(69, 1)), Collections.singletonList(new ItemStack(69, 1))),
                Arguments.of(
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(70, 1)),
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(70, 1))
                ),
                Arguments.of(
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(69, 1)),
                    Collections.singletonList(new ItemStack(69, 2))
                ),
                Arguments.of(
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(69, 2)),
                    Collections.singletonList(new ItemStack(69, 3))
                ),
                Arguments.of(
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(70, 2), new ItemStack(69, 3)),
                    Arrays.asList(new ItemStack(69, 4), new ItemStack(70, 2))
                ),
                Arguments.of(
                    Arrays.asList(new ItemStack(69, 1), new ItemStack(69, 2), new ItemStack(69, 3)),
                    Collections.singletonList(new ItemStack(69, 6))
                )
            );
        }
    }
}

package dinkplugin;

import dinkplugin.util.WorldUtils;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.ArgumentsProvider;
import org.junit.jupiter.params.provider.ArgumentsSource;

import java.util.Set;
import java.util.stream.Stream;
import java.util.EnumSet;

import net.runelite.api.WorldType;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

class IgnoredWorldTest {
    @ParameterizedTest(name = "World should not be ignored {0}")
    @ArgumentsSource(NonIgnoredWorldTypeProvider.class)
    void worldShouldNotBeIgnored(Set<WorldType> worldType) {
        assertFalse(WorldUtils.isIgnoredWorld(worldType));
    }

    private static class NonIgnoredWorldTypeProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of(EnumSet.of(WorldType.MEMBERS)),
                Arguments.of(EnumSet.noneOf(WorldType.class)),
                Arguments.of(EnumSet.of(WorldType.SKILL_TOTAL)),
                Arguments.of(EnumSet.of(WorldType.FRESH_START_WORLD))
            );
        }
    }

    @ParameterizedTest(name = "World should be ignored {0}")
    @ArgumentsSource(IgnoredWorldTypeProvider.class)
    void worldShouldBeIgnored(Set<WorldType> worldType) {
        assertTrue(WorldUtils.isIgnoredWorld(worldType));
    }

    private static class IgnoredWorldTypeProvider implements ArgumentsProvider {
        @Override
        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
            return Stream.of(
                Arguments.of(EnumSet.of(WorldType.PVP_ARENA)),
                Arguments.of(EnumSet.of(WorldType.QUEST_SPEEDRUNNING)),
                Arguments.of(EnumSet.of(WorldType.NOSAVE_MODE)),
                Arguments.of(EnumSet.of(WorldType.TOURNAMENT_WORLD)),
                Arguments.of(EnumSet.of(WorldType.FRESH_START_WORLD, WorldType.NOSAVE_MODE))
            );
        }
    }
}

package dinkplugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class DinkTest {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(DinkPlugin.class);
        RuneLite.main(args);
    }
}

package dinkplugin.message.templating;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class TemplateTest {

    @Test
    void noReplacements() {
        assertEquals(
            "Hello world!",
            Template.builder()
                .template("Hello world!")
                .build()
                .evaluate(true)
        );
    }

    @Test
    void noReplacementsFast() {
        assertEquals(
            "Hello world!",
            Template.builder()
                .template("Hello world!")
                .replacementBoundary("%")
                .build()
                .evaluate(true)
        );
    }

    @Test
    void unusedReplacements() {
        assertEquals(
            "Hello world!",
            Template.builder()
                .template("Hello world!")
                .replacement("%PLANET%", Replacements.ofText("Earth"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void unusedReplacementsFast() {
        assertEquals(
            "Hello world!",
            Template.builder()
                .template("Hello world!")
                .replacementBoundary("%")
                .replacement("%PLANET%", Replacements.ofText("Earth"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void withReplacements() {
        assertEquals(
            "dank dank has killed Monk",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(false)
        );
    }

    @Test
    void withReplacementsFast() {
        assertEquals(
            "dank dank has killed Monk",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(false)
        );
    }

    @Test
    void withRichReplacements() {
        assertEquals(
            "dank dank has killed [Monk](https://oldschool.runescape.wiki/w/Special:Search?search=Monk)",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void withRichReplacementsFast() {
        assertEquals(
            "dank dank has killed [Monk](https://oldschool.runescape.wiki/w/Special:Search?search=Monk)",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void missingReplacements() {
        assertEquals(
            "%USERNAME% has killed Monk",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(false)
        );
    }

    @Test
    void missingReplacementsFast() {
        assertEquals(
            "%USERNAME% has killed Monk",
            Template.builder()
                .template("%USERNAME% has killed %TARGET%")
                .replacementBoundary("%")
                .replacement("%TARGET%", Replacements.ofWiki("Monk"))
                .build()
                .evaluate(false)
        );
    }

    @Test
    void withRichLink() {
        assertEquals(
            "dank dank has pk'd [Forsen](https://secure.runescape.com/m=hiscore_oldschool/hiscorepersonal?user1=Forsen)",
            Template.builder()
                .template("%USERNAME% has pk'd %TARGET%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofLink("Forsen", "https://secure.runescape.com/m=hiscore_oldschool/hiscorepersonal?user1=Forsen"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void withRichLinkFast() {
        assertEquals(
            "dank dank has pk'd [Forsen](https://secure.runescape.com/m=hiscore_oldschool/hiscorepersonal?user1=Forsen)",
            Template.builder()
                .template("%USERNAME% has pk'd %TARGET%")
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofLink("Forsen", "https://secure.runescape.com/m=hiscore_oldschool/hiscorepersonal?user1=Forsen"))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void withRichNullLink() {
        assertEquals(
            "dank dank has pk'd Forsen",
            Template.builder()
                .template("%USERNAME% has pk'd %TARGET%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofLink("Forsen", null))
                .build()
                .evaluate(true)
        );
    }

    @Test
    void withRichNullLinkFast() {
        assertEquals(
            "dank dank has pk'd Forsen",
            Template.builder()
                .template("%USERNAME% has pk'd %TARGET%")
                .replacementBoundary("%")
                .replacement("%USERNAME%", Replacements.ofText("dank dank"))
                .replacement("%TARGET%", Replacements.ofLink("Forsen", null))
                .build()
                .evaluate(true)
        );
    }
}

