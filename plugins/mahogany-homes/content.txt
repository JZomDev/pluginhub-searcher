/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum RequiredMaterialsByTier
{
	// East Ardy
	JESS(new RequiredMaterials(9, 11, 0, 1),
		new RequiredMaterials(9, 11, 0, 1),
		new RequiredMaterials(12, 15, 0, 1),
		new RequiredMaterials(14, 15, 0, 1)),
	NOELLA(new RequiredMaterials(11, 12, 0, 0),
		new RequiredMaterials(11, 12, 0, 0),
		new RequiredMaterials(11, 15, 0, 0),
		new RequiredMaterials(12, 15, 0, 0)),
	ROSS(new RequiredMaterials(8, 11, 0, 1),
		new RequiredMaterials(8, 11, 0, 1),
		new RequiredMaterials(8, 11, 1, 1),
		new RequiredMaterials(10, 11, 0, 1)),

	// Falador
	LARRY(new RequiredMaterials(8, 12, 0, 1),
		new RequiredMaterials(8, 12, 0, 1),
		new RequiredMaterials(9, 12, 0, 1),
		new RequiredMaterials(12, 12, 0, 1)),
	NORMAN(new RequiredMaterials(11, 11, 0, 1),
		new RequiredMaterials(10, 11, 0, 1),
		new RequiredMaterials(9, 13, 0, 1),
		new RequiredMaterials(12, 13, 0, 1)),
	TAU(new RequiredMaterials(8, 12, 0, 1),
		new RequiredMaterials(8, 12, 0, 1),
		new RequiredMaterials(9, 13, 0, 1),
		new RequiredMaterials(12, 13, 0, 1)),

	// Hosidius
	BARBARA(new RequiredMaterials(3, 8, 0, 1),
		new RequiredMaterials(3, 8, 0, 1),
		new RequiredMaterials(9, 10, 0, 1),
		new RequiredMaterials(9, 10, 0, 1)),
	LEELA(new RequiredMaterials(8, 9, 0, 1),
		new RequiredMaterials(8, 9, 0, 1),
		new RequiredMaterials(9, 10, 0, 1),
		new RequiredMaterials(12, 13, 0, 1)),
	MARIAH(new RequiredMaterials(7, 11, 0, 1),
		new RequiredMaterials(7, 11, 0, 1),
		new RequiredMaterials(11, 14, 0, 1),
		new RequiredMaterials(13, 14, 0, 1)),

	// Varrock
	BOB(new RequiredMaterials(13, 14, 0, 0),
		new RequiredMaterials(13, 14, 0, 0),
		new RequiredMaterials(13, 17, 0, 0),
		new RequiredMaterials(16, 17, 0, 0)),
	JEFF(new RequiredMaterials(11, 13, 0, 0),
		new RequiredMaterials(11, 13, 0, 0),
		new RequiredMaterials(11, 16, 0, 0),
		new RequiredMaterials(15, 16, 0, 0)),
	SARAH(new RequiredMaterials(11, 11, 0, 1),
		new RequiredMaterials(11, 11, 0, 1),
		new RequiredMaterials(11, 11, 0, 1),
		new RequiredMaterials(11, 11, 0, 1)),
	;

	private final RequiredMaterials beginner;
	private final RequiredMaterials novice;
	private final RequiredMaterials adept;
	private final RequiredMaterials expert;

	public RequiredMaterials getByTier(final int tier)
	{
		switch (tier)
		{
			case 1:
				return beginner;
			case 2:
				return novice;
			case 3:
				return adept;
			case 4:
				return expert;
			default:
				return null;
		}
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.NpcID;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.text.WordUtils;

@Getter
enum Home
{
	// area is based on bounds of house not area at which stuff loads in for the homes
	// Ardy
	JESS(new WorldArea(2611, 3290, 14, 7, 0), "Upstairs of the building south of the church in East Ardougne",
		NpcID.JESS, new WorldPoint(2621, 3292, 0), TeleportItems.JESS, RequiredMaterialsByTier.JESS, HotspotObjects.JESS, true, 17026, 16685),
	NOELLA(new WorldArea(2652, 3317, 15, 8, 0), "North of East Ardougne market",
		NpcID.NOELLA, new WorldPoint(2659, 3322, 0), TeleportItems.NOELLA, RequiredMaterialsByTier.NOELLA, HotspotObjects.NOELLA, 17026, 16685, 15645, 15648),
	ROSS(new WorldArea(2609, 3313, 11, 9, 0), "North of the church in East Ardougne",
		NpcID.ROSS, new WorldPoint(2613, 3316, 0), TeleportItems.ROSS, RequiredMaterialsByTier.ROSS, HotspotObjects.ROSS, 16683, 16679),

	// Falador
	LARRY(new WorldArea(3033, 3360, 10, 9, 0), "North of the fountain in Falador",
		NpcID.LARRY_10418, new WorldPoint(3038, 3364, 0), TeleportItems.LARRY, RequiredMaterialsByTier.LARRY, HotspotObjects.LARRY, 24075, 24076),
	NORMAN(new WorldArea(3034, 3341, 8, 8, 0), "South of the fountain in Falador",
		NpcID.NORMAN, new WorldPoint(3038, 3344, 0), TeleportItems.NORMAN, RequiredMaterialsByTier.NORMAN, HotspotObjects.NORMAN, true, 24082, 24085),
	TAU(new WorldArea(3043, 3340, 10, 11, 0), "South east of the fountain in Falador",
		NpcID.TAU, new WorldPoint(3047, 3345, 0), TeleportItems.TAU, RequiredMaterialsByTier.TAU, HotspotObjects.TAU),

	// Hosidus
	BARBARA(new WorldArea(1746, 3531, 10, 11, 0), "South of Hosidius, near the mill",
		NpcID.BARBARA, new WorldPoint(1750, 3534, 0), TeleportItems.BARBARA, RequiredMaterialsByTier.BARBARA, HotspotObjects.BARBARA),
	LEELA(new WorldArea(1781, 3589, 9, 8, 0), "East of the town market in Hosidius",
		NpcID.LEELA_10423, new WorldPoint(1785, 3592, 0), TeleportItems.LEELA, RequiredMaterialsByTier.LEELA, HotspotObjects.LEELA, 11794, 11802),
	MARIAH(new WorldArea(1762, 3618, 10, 7, 0), "West of the estate agents in Hosidius",
		NpcID.MARIAH, new WorldPoint(1766, 3621, 0), TeleportItems.MARIAH, RequiredMaterialsByTier.MARIAH, HotspotObjects.MARIAH, 11794, 11802),

	// Varrock
	BOB(new WorldArea(3234, 3482, 10, 10, 0), "North-east Varrock, opposite the church",
		NpcID.BOB_10414, new WorldPoint(3238, 3486, 0), TeleportItems.BOB, RequiredMaterialsByTier.BOB, HotspotObjects.BOB, 11797, 11799),
	JEFF(new WorldArea(3235, 3445, 10, 12, 0), "Middle of Varrock, west of the museum",
		NpcID.JEFF_10415, new WorldPoint(3239, 3450, 0), TeleportItems.JEFF, RequiredMaterialsByTier.JEFF, HotspotObjects.JEFF, 11789, 11793),
	SARAH(new WorldArea(3232, 3381, 8, 7, 0), "Along the south wall of Varrock",
		NpcID.SARAH_10416, new WorldPoint(3235, 3384, 0), TeleportItems.SARAH, RequiredMaterialsByTier.SARAH, HotspotObjects.SARAH);

	private final WorldArea area;
	private final String hint;
	private final int npcId;
	private final WorldPoint location;
	private final Integer[] ladders;
	private final TeleportItems teleportItems;
	private final RequiredMaterialsByTier requiredMaterialsByTier;
	private final boolean npcUpstairs;
	private final HotspotObjects hotspotObjects;

	Home(final WorldArea area, final String hint, final int npcId, final WorldPoint location, final TeleportItems teleportItems,
		final RequiredMaterialsByTier requiredMaterials, final HotspotObjects hotspotObjects, final Integer... ladders)
	{
		this(area, hint, npcId, location, teleportItems, requiredMaterials, hotspotObjects, false, ladders);
	}

	Home(final WorldArea area, final String hint, final int npcId, final WorldPoint location, final TeleportItems teleportItems,
		final RequiredMaterialsByTier requiredMaterials, final HotspotObjects hotspotObjects, final boolean npcUpstairs, final Integer... ladders)
	{
		this.area = area;
		this.hint = hint;
		this.npcId = npcId;
		this.location = location;
		this.ladders = ladders;
		this.teleportItems = teleportItems;
		this.hotspotObjects = hotspotObjects;
		this.requiredMaterialsByTier = requiredMaterials;
		this.npcUpstairs = npcUpstairs;
	}

	String getName()
	{
		return WordUtils.capitalize(name().toLowerCase());
	}

	private static final ImmutableSet<Integer> LADDERS;
	static
	{
		final ImmutableSet.Builder<Integer> b = new ImmutableSet.Builder<>();
		for (final Home h : values())
		{
			b.add(h.getLadders());
		}
		LADDERS = b.build();
	}

	static boolean isLadder(final int objID)
	{
		return LADDERS.contains(objID);
	}
}

package thestonedturtle.mahoganyhomes;

import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;

public enum TeleportItems
{
	// East Ardy
	JESS(new TeleportItem(ItemID.ARDOUGNE_TELEPORT, 38),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 40),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 40),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_4, 70),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_3, 70),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_2, 70),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_1, 70)),
	NOELLA(new TeleportItem(ItemID.ARDOUGNE_TELEPORT, 16),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_4, 96),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_3, 96),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_2, 96),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_1, 96),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 100),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 100)),
	ROSS(new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 56),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 56),
		new TeleportItem(ItemID.ARDOUGNE_TELEPORT, 60),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_4, 92),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_3, 92),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_2, 92),
		new TeleportItem(ItemID.ARDOUGNE_CLOAK_1, 92)),

	// Falador
	LARRY(new TeleportItem(ItemID.RING_OF_WEALTH_I5, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_I4, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_I3, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_I2, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_I1, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_5, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_4, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_3, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_2, 37),
		new TeleportItem(ItemID.RING_OF_WEALTH_1, 37),
		new TeleportItem(ItemID.SKILLS_NECKLACE6, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE5, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE4, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE3, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE2, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE1, 38),
		new TeleportItem(ItemID.FALADOR_TELEPORT, 67),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 80),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 80)),
	NORMAN(new TeleportItem(ItemID.RING_OF_WEALTH_I5, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_I4, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_I3, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_I2, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_I1, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_5, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_4, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_3, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_2, 38),
		new TeleportItem(ItemID.RING_OF_WEALTH_1, 38),
		new TeleportItem(ItemID.SKILLS_NECKLACE6, 39),
		new TeleportItem(ItemID.SKILLS_NECKLACE5, 39),
		new TeleportItem(ItemID.SKILLS_NECKLACE4, 39),
		new TeleportItem(ItemID.SKILLS_NECKLACE3, 39),
		new TeleportItem(ItemID.SKILLS_NECKLACE2, 39),
		new TeleportItem(ItemID.SKILLS_NECKLACE1, 39),
		new TeleportItem(ItemID.FALADOR_TELEPORT, 70),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 71),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 71)),
	TAU(new TeleportItem(ItemID.SKILLS_NECKLACE6, 45),
		new TeleportItem(ItemID.SKILLS_NECKLACE5, 45),
		new TeleportItem(ItemID.SKILLS_NECKLACE4, 45),
		new TeleportItem(ItemID.SKILLS_NECKLACE3, 45),
		new TeleportItem(ItemID.SKILLS_NECKLACE2, 45),
		new TeleportItem(ItemID.SKILLS_NECKLACE1, 45),
		new TeleportItem(ItemID.RING_OF_WEALTH_I5, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_I4, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_I3, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_I2, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_I1, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_5, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_4, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_3, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_2, 47),
		new TeleportItem(ItemID.RING_OF_WEALTH_1, 47),
		new TeleportItem(ItemID.FALADOR_TELEPORT, 78),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 79),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 79)),

	// Hosidius
	BARBARA(new TeleportItem(ItemID.TELEPORT_TO_HOUSE, 14),
		new TeleportItem(ItemID.HOSIDIUS_TELEPORT, 14),
		new TeleportItem(ItemID.CONSTRUCT_CAPE, 14),
		new TeleportItem(ItemID.CONSTRUCT_CAPET, 14),
		new TeleportItem(ItemID.XERICS_TALISMAN, 27),
		new TeleportItem(ItemID.KHAREDSTS_MEMOIRS, 70),
		new TeleportItem(ItemID.BOOK_OF_THE_DEAD, 70)),
	LEELA(new TeleportItem(ItemID.XERICS_TALISMAN, 30),
		new TeleportItem(ItemID.KHAREDSTS_MEMOIRS, 67),
		new TeleportItem(ItemID.BOOK_OF_THE_DEAD, 67),
		new TeleportItem(ItemID.TELEPORT_TO_HOUSE, 72),
		new TeleportItem(ItemID.HOSIDIUS_TELEPORT, 72)),
	MARIAH(new TeleportItem(ItemID.XERICS_TALISMAN, 50),
		new TeleportItem(ItemID.KHAREDSTS_MEMOIRS, 56),
		new TeleportItem(ItemID.BOOK_OF_THE_DEAD, 56),
		new TeleportItem(ItemID.TELEPORT_TO_HOUSE, 100),
		new TeleportItem(ItemID.HOSIDIUS_TELEPORT, 100)),

	// Varrock
	BOB(new TeleportItem(ItemID.VARROCK_TELEPORT, 60),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 100),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 100)),
	JEFF(new TeleportItem(ItemID.VARROCK_TELEPORT, 23),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 30),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 30)),
	SARAH(new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE, 28),
		new TeleportItem(ItemID.ACHIEVEMENT_DIARY_CAPE_T, 28),
		new TeleportItem(ItemID.VARROCK_TELEPORT, 37));

	private final TeleportItem[] teleportItems;

	TeleportItems(TeleportItem... items)
	{
		this.teleportItems = items;
	}

	public TeleportItem getClosestTeleportItemOnPlayer(Client client)
	{
		ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY.getId());
		ItemContainer equipmentContainer = client.getItemContainer(InventoryID.EQUIPMENT.getId());

		for (TeleportItem teleportItem : teleportItems)
		{
			if (inventoryContainer != null && inventoryContainer.contains(teleportItem.ItemId))
			{
				return teleportItem;
			}

			if (equipmentContainer != null && equipmentContainer.contains(teleportItem.ItemId))
			{
				return teleportItem;
			}
		}

		return null;
	}
}

/*
 * Copyright (c) 2022, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.util.Set;
import lombok.AllArgsConstructor;
import lombok.Getter;

public enum HotspotObjects
{
	// East Ardy
	JESS(new HotspotObject(40171, HotspotType.B2),
		new HotspotObject(40172, HotspotType.B2),
		new HotspotObject(40173, HotspotType.B2),
		new HotspotObject(40174, HotspotType.B2),
		new HotspotObject(40175, HotspotType.B3),
		new HotspotObject(40176, HotspotType.B3),
		new HotspotObject(40177, HotspotType.RP),
		new HotspotObject(40299, HotspotType.SB)),
	NOELLA(new HotspotObject(40156, HotspotType.B2),
		new HotspotObject(40157, HotspotType.B2),
		new HotspotObject(40158, HotspotType.RP),
		new HotspotObject(40159, HotspotType.RP),
		new HotspotObject(40160, HotspotType.B2),
		new HotspotObject(40161, HotspotType.B3),
		new HotspotObject(40162, HotspotType.B3),
		new HotspotObject(40163, HotspotType.RP)),
	ROSS(new HotspotObject(40164, HotspotType.SB),
		new HotspotObject(40165, HotspotType.B2),
		new HotspotObject(40166, HotspotType.B2),
		new HotspotObject(40167, HotspotType.B3),
		new HotspotObject(40168, HotspotType.RP),
		new HotspotObject(40169, HotspotType.B2),
		new HotspotObject(40170, HotspotType.RP)),

	// Falador
	LARRY(new HotspotObject(40297, HotspotType.SB),
		new HotspotObject(40095, HotspotType.B2),
		new HotspotObject(40096, HotspotType.B2),
		new HotspotObject(40097, HotspotType.B3),
		new HotspotObject(40298, HotspotType.RP),
		new HotspotObject(40098, HotspotType.B3),
		new HotspotObject(40099, HotspotType.RP)),
	NORMAN(new HotspotObject(40296, HotspotType.SB),
		new HotspotObject(40089, HotspotType.RP),
		new HotspotObject(40090, HotspotType.B3),
		new HotspotObject(40091, HotspotType.B3),
		new HotspotObject(40092, HotspotType.B2),
		new HotspotObject(40093, HotspotType.B2),
		new HotspotObject(40094, HotspotType.B2)),
	TAU(new HotspotObject(40083, HotspotType.SB),
		new HotspotObject(40084, HotspotType.B3),
		new HotspotObject(40085, HotspotType.B3),
		new HotspotObject(40086, HotspotType.B2),
		new HotspotObject(40087, HotspotType.B2),
		new HotspotObject(40088, HotspotType.B2),
		new HotspotObject(40295, HotspotType.RP)),

	// Hosidius
	BARBARA(new HotspotObject(40011, HotspotType.RP),
		new HotspotObject(40293, HotspotType.SB),
		new HotspotObject(40012, HotspotType.B3),
		new HotspotObject(40294, HotspotType.B2),
		new HotspotObject(40013, HotspotType.B2),
		new HotspotObject(40014, HotspotType.B1),
		new HotspotObject(40015, HotspotType.B1)),
	LEELA(new HotspotObject(40007, HotspotType.B2),
		new HotspotObject(40008, HotspotType.B2),
		new HotspotObject(40290, HotspotType.SB),
		new HotspotObject(40291, HotspotType.B3),
		new HotspotObject(40009, HotspotType.B3),
		new HotspotObject(40010, HotspotType.RP),
		new HotspotObject(40292, HotspotType.B2)),
	MARIAH(new HotspotObject(40002, HotspotType.B3),
		new HotspotObject(40287, HotspotType.SB),
		new HotspotObject(40003, HotspotType.B2),
		new HotspotObject(40288, HotspotType.B2),
		new HotspotObject(40004, HotspotType.B2),
		new HotspotObject(40005, HotspotType.B2),
		new HotspotObject(40006, HotspotType.B2),
		new HotspotObject(40289, HotspotType.RP)),


	// Varrock
	BOB(new HotspotObject(39981, HotspotType.B4),
		new HotspotObject(39982, HotspotType.RP),
		new HotspotObject(39983, HotspotType.B2),
		new HotspotObject(39984, HotspotType.B2),
		new HotspotObject(39985, HotspotType.B2),
		new HotspotObject(39986, HotspotType.B2),
		new HotspotObject(39987, HotspotType.B2),
		new HotspotObject(39988, HotspotType.B2)),
	JEFF(new HotspotObject(39989, HotspotType.B3),
		new HotspotObject(39990, HotspotType.B2),
		new HotspotObject(39991, HotspotType.B2),
		new HotspotObject(39992, HotspotType.B3),
		new HotspotObject(39993, HotspotType.B2),
		new HotspotObject(39994, HotspotType.B2),
		new HotspotObject(39995, HotspotType.RP),
		new HotspotObject(39996, HotspotType.B1)),
	SARAH(new HotspotObject(39997, HotspotType.B3),
		new HotspotObject(39998, HotspotType.B2),
		new HotspotObject(39999, HotspotType.B2),
		new HotspotObject(40000, HotspotType.B2),
		new HotspotObject(40286, HotspotType.SB),
		new HotspotObject(40001, HotspotType.B2))
	;

	public final HotspotObject[] objects;

	HotspotObjects(HotspotObject... objects)
	{
		this.objects = objects;
	}

	RequiredMaterials getRequiredMaterialsForVarbs(Set<Integer> repairableVarbs)
	{
		final RequiredMaterials required = new RequiredMaterials(0, 0, 0, 0);

		final int startingVarb = Hotspot.MAHOGANY_HOMES_HOTSPOT_1.getVarb();
		for (int i = 0; i < this.objects.length; i++)
		{
			// hotspotObjects are added in order where it's index in the array is the offset from the starting varb
			if (!repairableVarbs.contains(startingVarb + i))
			{
				continue;
			}

			final HotspotType type = this.objects[i].getType();
			switch (type.getMaterial())
			{
				case PLANK:
				{
					int n = required.MinPlanks + type.getNumOfMaterial();
					required.setMinPlanks(n);
					required.setMaxPlanks(n);
					break;
				}
				case STEEL_BAR:
				{
					int n = required.MinSteelBars + type.getNumOfMaterial();
					required.setMinSteelBars(n);
					required.setMaxSteelBars(n);
					break;
				}
			}
		}

		return required;
	}

	@AllArgsConstructor
	@Getter
	public static class HotspotObject
	{
		private final int objectId;
		private final HotspotType type;
	}

	public enum MaterialType
	{
		PLANK,
		STEEL_BAR
	}

	@AllArgsConstructor
	@Getter
	public enum HotspotType
	{
		//Remove & Build Furniture (1 plank)
		B1(MaterialType.PLANK, 1),
		//Remove & Build Furniture (2 plank)
		B2(MaterialType.PLANK, 2),
		//Remove & Build Furniture (3 plank)
		B3(MaterialType.PLANK, 3),
		//Remove & Build Furniture (4 plank)
		B4(MaterialType.PLANK, 4),
		//Repair Furniture (1 plank)
		RP(MaterialType.PLANK, 1),
		//Repair Furniture (1 steel bar)
		SB(MaterialType.STEEL_BAR, 1);

		private final MaterialType material;
		private final int numOfMaterial;
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import net.runelite.api.Player;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;

class MahoganyHomesOverlay extends OverlayPanel
{
	static final String RESET_SESSION_OPTION = "Reset";
	static final String CLEAR_OPTION = "Clear";
	static final String TIMEOUT_OPTION = "Timeout";

	private static final String UNICODE_CHECK_MARK = "\u2713";
	private static final String UNICODE_BALLOT_X = "\u2717";

	private final MahoganyHomesPlugin plugin;
	private final MahoganyHomesConfig config;

	@Inject
	MahoganyHomesOverlay(MahoganyHomesPlugin plugin, MahoganyHomesConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.LOW);
		setLayer(OverlayLayer.UNDER_WIDGETS);
		this.plugin = plugin;
		this.config = config;

		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Mahogany Homes Overlay"));
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY, TIMEOUT_OPTION, "Mahogany Homes Plugin"));
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY, RESET_SESSION_OPTION, "Session Data"));
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY, CLEAR_OPTION, "Contract"));
	}

	// Adds a line to the panel describing a material. type is the
	// un-pluralized name of the material, min and max are the range
	// required, and have is the number in the player's inventory.
	void addMaterialLine(String type, int min, int max, int have)
	{
		if (min == 0 && max == 0)
		{
			return;
		}
		LineComponent.LineComponentBuilder line = LineComponent.builder();

		if (min == max)
		{
			String plural = min > 1 ? "s" : "";
			line = line.left(String.format("%d %s%s", min, type, plural));
		}
		else
		{
			// Always pluralize by adding an "s"
			line = line.left(String.format("%d - %d %ss", min, max, type));
		}

		// If asked for, add a colored symbol on the right depicting if
		// the player has enough supplies.
		if (config.checkSupplies())
		{
			if (have >= max)
			{
				line = line.right(UNICODE_CHECK_MARK).rightColor(Color.GREEN);
			}
			else if (have >= min)
			{
				// Player has between max and min, so it's not
				// certain if they have enough.
				line = line.right("?").rightColor(Color.YELLOW);
			}
			else
			{
				line = line.right(UNICODE_BALLOT_X).rightColor(Color.RED);
			}
			// Ensure font used to render symbols properly across platforms.
			line = line.rightFont(FontManager.getDefaultFont());
		}
		panelComponent.getChildren().add(line.build());
	}

	// Adds lines to the panel describing the materials required.
	void addRequiredMaterials(RequiredMaterials mats)
	{
		if (mats == null)
		{
			return;
		}

		addMaterialLine("Plank", mats.MinPlanks, mats.MaxPlanks, plugin.getNumPlanksInInventory());
		addMaterialLine("Steel Bar", mats.MinSteelBars, mats.MaxSteelBars, plugin.getNumSteelBarsInInventory());
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Home home = plugin.getCurrentHome();
		final Player player = plugin.getClient().getLocalPlayer();
		if (plugin.isPluginTimedOut() || !config.textOverlay() || player == null)
		{
			return null;
		}

		if (home != null)
		{
			addLine(home.getName());
			addLine(home.getHint());

			if (plugin.distanceBetween(home.getArea(), player.getWorldLocation()) > 0)
			{
				if (config.showRequiredMaterials() && plugin.getContractTier() > 0)
				{
					addLine("");

					addRequiredMaterials(home.getRequiredMaterialsByTier().getByTier(plugin.getContractTier()));
				}

				if (config.worldMapIcon())
				{
					addLine("");
					addLine("Click the house icon on your world map to see where to go");
				}
			}
			else
			{
				if (config.showRequiredMaterials() && plugin.getContractTier() > 0)
				{
					final RequiredMaterials requiredMaterials = home.getHotspotObjects().getRequiredMaterialsForVarbs(plugin.getRepairableVarbs());
					// We only want to add an empty line if there's something to be displayed
					if (requiredMaterials.MinPlanks > 0 || requiredMaterials.MinSteelBars > 0)
					{
						addLine("");
					}

					addRequiredMaterials(requiredMaterials);
				}

				addLine("");
				final int count = plugin.getCompletedCount();
				if (count > 0)
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left(count + " task(s) remaining")
						.leftColor(Color.RED)
						.build());
				}
				else
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left("All tasks completed, speak to " + home.getName())
						.leftColor(Color.GREEN)
						.build());
				}
			}
		}

		if (config.showSessionStats() && plugin.getSessionContracts() > 0)
		{
			if (home != null)
			{
				addLine("");
			}
			addLine("Contracts Done: " + plugin.getSessionContracts());
			addLine("Points Earned: " + plugin.getSessionPoints());
		}

		return super.render(graphics);
	}

	private void addLine(final String left)
	{
		panelComponent.getChildren().add(LineComponent.builder().left(left).build());
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.api.Player;
import net.runelite.api.TileObject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

class MahoganyHomesHighlightOverlay extends Overlay
{
	public static final Color CLICKBOX_BORDER_COLOR = Color.ORANGE;
	public static final Color CLICKBOX_HOVER_BORDER_COLOR = CLICKBOX_BORDER_COLOR.darker();

	private final MahoganyHomesPlugin plugin;
	private final MahoganyHomesConfig config;

	@Inject
	MahoganyHomesHighlightOverlay(MahoganyHomesPlugin plugin, MahoganyHomesConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Home home = plugin.getCurrentHome();
		final Player player = plugin.getClient().getLocalPlayer();
		if (plugin.isPluginTimedOut() || home == null || player == null)
		{
			return null;
		}

		// Player is not at the home yet, do not render anything
		if (plugin.distanceBetween(home.getArea(), plugin.getClient().getLocalPlayer().getWorldLocation()) > 0)
		{
			return null;
		}

		final int playerPlane = plugin.getClient().getTopLevelWorldView().getPlane();
		int countOnFloor = 0;
		for (TileObject gameObject : plugin.getObjectsToMark())
		{
			if (gameObject.getPlane() != playerPlane)
			{
				continue;
			}

			if (plugin.distanceBetween(home.getArea(), gameObject.getWorldLocation()) > 0)
			{
				// Object not inside area for this house.
				continue;
			}

			final Hotspot spot = Hotspot.getByObjectId(gameObject.getId());
			if (spot == null)
			{
				continue;
			}

			// Do not highlight if it doesn't require attention
			if (!plugin.doesHotspotRequireAttention(spot.getVarb()))
			{
				continue;
			}

			countOnFloor++;
			// Do not highlight the hotspot if the config is disabled. Because of countOnFloor we still need this loop.
			if (!config.highlightHotspots())
			{
				continue;
			}

			final net.runelite.api.Point mousePosition = plugin.getClient().getMouseCanvasPosition();
			OverlayUtil.renderHoverableArea(graphics, gameObject.getClickbox(), mousePosition,
				config.highlightHotspotColor(), CLICKBOX_BORDER_COLOR, CLICKBOX_HOVER_BORDER_COLOR);
		}

		if (config.highlightStairs())
		{
			for (TileObject gameObject : plugin.getLaddersToMark())
			{
				// Object is on a different floor somehow?
				if (gameObject.getPlane() != playerPlane)
				{
					continue;
				}

				// Object not inside area for this house.
				if (plugin.distanceBetween(home.getArea(), gameObject.getWorldLocation()) > 0)
				{
					continue;
				}

				final boolean onSameFloorAsNpc = home.isNpcUpstairs() ? playerPlane > 0 : playerPlane == 0;
				final int remainingTasks = plugin.getCompletedCount();

				// If all remaining tasks are on this floor there's no need to highlight stairs
				// However if we're not on the same floor we need to highlight the stairs when there's no tasks left
				if (countOnFloor == remainingTasks && (onSameFloorAsNpc || countOnFloor > 0))
				{
					continue;
				}

				final net.runelite.api.Point mousePosition = plugin.getClient().getMouseCanvasPosition();
				OverlayUtil.renderHoverableArea(graphics, gameObject.getClickbox(), mousePosition,
					config.highlightStairsColor(), CLICKBOX_BORDER_COLOR, CLICKBOX_HOVER_BORDER_COLOR);
			}
		}

		return null;
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(MahoganyHomesConfig.GROUP_NAME)
public interface MahoganyHomesConfig extends Config
{
	String GROUP_NAME = "MahoganyHomes";
	String HOME_KEY = "currentHome";
	String TIER_KEY = "currentTier";
	String WORLD_MAP_KEY = "worldMapIcon";
	String HINT_ARROW_KEY = "displayHintArrows";
	String SESSION_TIMEOUT_KEY = "sessionTimeout";
	String SHORTEST_PATH_KEY = "shortestPath";

	@ConfigItem(
		keyName = WORLD_MAP_KEY,
		name = "Display World Map Icon",
		description = "Configures whether an icon will be displayed on the world map showing where to go for your current contract",
		position = 0
	)
	default boolean worldMapIcon()
	{
		return true;
	}

	@ConfigItem(
		keyName = HINT_ARROW_KEY,
		name = "Display Hint Arrows",
		description = "Configures whether or not to display the hint arrows",
		position = 1
	)
	default boolean displayHintArrows()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showRequiredMaterials",
		name = "Display Required Materials",
		description = "Configures whether or not to display the required materials for your current task",
		position = 2
	)
	default boolean showRequiredMaterials()
	{
		return true;
	}

	@ConfigItem(
			keyName = "shortestPath",
			name = "Use 'Shortest Path' plugin",
			description = "Draws the shortest path to the assigned house on the map.<br/>" +
					"The plugin 'Shortest Path' needs to be enabled for this to work",
			position = 3
	)
	default boolean useShortestPath()
	{
		return false;
	}

	@ConfigSection(
		name = "Highlight Options",
		description = "Settings related to the highlighting of objects and items",
		position = 100,
		closedByDefault = true
	)
	String highlightSection = "highlightSection";

	@ConfigItem(
		keyName = "highlightHotspots",
		name = "Highlight Building Hotspots",
		description = "Configures whether or not the building hotspots will be highlighted",
		section = highlightSection,
		position = 0
	)
	default boolean highlightHotspots()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightHotspotColor",
		name = "Building Hotspot Highlight Color",
		description = "Configures the color the hotspots will be highlighted",
		section = highlightSection,
		position = 1
	)
	default Color highlightHotspotColor()
	{
		return new Color(0, 255, 0, 50);
	}

	@ConfigItem(
		keyName = "highlightStairs",
		name = "Highlight Stairs",
		description = "Configures whether or not the stairs will be highlighted",
		section = highlightSection,
		position = 2
	)
	default boolean highlightStairs()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightStairsColor",
		name = "Stairs Highlight Color",
		description = "Configures the color the stairs will be highlighted",
		section = highlightSection,
		position = 3
	)
	default Color highlightStairsColor()
	{
		return new Color(0, 255, 0, 20);
	}

	@ConfigItem(
		keyName = "highlightTeleports",
		name = "Highlight Teleport Items",
		description = "Configures whether or not the teleport items will be highlighted",
		section = highlightSection,
		position = 4
	)
	default boolean highlightTeleports()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightTeleportsColor",
		name = "Teleport Item Highlight Color",
		description = "Configures the color your teleports will be highlighted",
		section = highlightSection,
		position = 5
	)
	default Color highlightTeleportsColor()
	{
		return new Color(0, 255, 255, 50);
	}

	@ConfigSection(
		name = "Overlay Options",
		description = "Settings related to the overlay boxes",
		position = 200,
		closedByDefault = true
	)
	String overlaySection = "overlaySection";

	@ConfigItem(
		keyName = "textOverlay",
		name = "Display Text Overlay",
		description = "Configures whether or not the text overlay will be displayed for your current contract",
		section = overlaySection,
		position = 0
	)
	default boolean textOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showSessionStats",
		name = "Display Session Stats",
		description = "Configures whether or not the amount of contracts and the points received from those contracts is displayed inside the overlay<br/>" +
			"'Display Text Overlay' must be enabled for this to work",
		section = overlaySection,
		position = 1
	)
	default boolean showSessionStats()
	{
		return true;
	}

	@Range(
		min = 1,
		max = 60
	)
	@ConfigItem(
		keyName = SESSION_TIMEOUT_KEY,
		name = "Session Timeout",
		description = "Configures how many minutes must pass before the session timeouts after not having any activity.<br/>" +
			"Value must be between 1 and 60 minute(s)",
		section = overlaySection,
		position = 2
	)
	default int sessionTimeout()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "checkSupplies",
		name = "Check Supplies",
		description = "Checks if you have enough supplies in your inventory to complete your current contract.<br/>" +
			"If the Plank Sack plugin is installed, it will include all planks within the plank sack regardless of plank type",
		position = 10
	)
	default boolean checkSupplies()
	{
		return true;
	}
}

package thestonedturtle.mahoganyhomes;

import lombok.AllArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@Setter
public class RequiredMaterials
{
	public int MinPlanks;
	public int MaxPlanks;
	public int MinSteelBars;
	public int MaxSteelBars;
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import javax.annotation.Nullable;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
enum Hotspot
{
	MAHOGANY_HOMES_HOTSPOT_1(10554,
		ImmutableSet.of(39981, 39989, 39997, 40002, 40007, 40011, 40083, 40156, 40164, 40171, 40296, 40297)),
	MAHOGANY_HOMES_HOTSPOT_2(10555,
		ImmutableSet.of(39982, 39990, 39998, 40008, 40084, 40089, 40095, 40157, 40165, 40172, 40287, 40293)),
	MAHOGANY_HOMES_HOTSPOT_3(10556,
		ImmutableSet.of(39983, 39991, 39999, 40003, 40012, 40085, 40090, 40096, 40158, 40166, 40173, 40290)),
	MAHOGANY_HOMES_HOTSPOT_4(10557,
		ImmutableSet.of(39984, 39992, 40000, 40086, 40091, 40097, 40159, 40167, 40174, 40288, 40291, 40294)),
	MAHOGANY_HOMES_HOTSPOT_5(10558,
		ImmutableSet.of(39985, 39993, 40004, 40009, 40013, 40087, 40092, 40160, 40168, 40175, 40286, 40298)),
	MAHOGANY_HOMES_HOTSPOT_6(10559,
		ImmutableSet.of(39986, 39994, 40001, 40005, 40010, 40014, 40088, 40093, 40098, 40161, 40169, 40176)),
	MAHOGANY_HOMES_HOTSPOT_7(10560,
		ImmutableSet.of(39987, 39995, 40006, 40015, 40094, 40099, 40162, 40170, 40177, 40292, 40295)),
	MAHOGANY_HOMES_HOTSPOT_8(10561,
		ImmutableSet.of(39988, 39996, 40163, 40289, 40299)),
	;

	private final int varb;
	private final ImmutableSet<Integer> objectIds;

	private static final ImmutableMap<Integer, Hotspot> HOTSPOT_BY_OBJECT_ID;
	static
	{
		final ImmutableMap.Builder<Integer, Hotspot> objects = new ImmutableMap.Builder<>();
		for (final Hotspot hotspot : values())
		{
			hotspot.getObjectIds().forEach(id -> objects.put(id, hotspot));
		}
		HOTSPOT_BY_OBJECT_ID = objects.build();
	}

	@Nullable
	static Hotspot getByObjectId(final int objectId)
	{
		return HOTSPOT_BY_OBJECT_ID.get(objectId);
	}

	static boolean isHotspotObject(final int id)
	{
		return HOTSPOT_BY_OBJECT_ID.containsKey(id);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.awt.image.BufferedImage;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;

class MahoganyHomesWorldPoint extends WorldMapPoint
{
	private final MahoganyHomesPlugin plugin;
	private final Point point;

	MahoganyHomesWorldPoint(final WorldPoint worldPoint, final MahoganyHomesPlugin plugin)
	{
		super(worldPoint, null);
		this.plugin = plugin;

		final BufferedImage image = plugin.getMapArrow();
		point = new Point(image.getWidth() / 2, image.getHeight());

		this.setSnapToEdge(true);
		this.setJumpOnClick(true);
		this.setImage(image);
		this.setImagePoint(point);
		this.setName("Mahogany Homes Contract");
	}

	@Override
	public void onEdgeSnap()
	{
		this.setImage(plugin.getMapIcon());
		this.setImagePoint(null);
	}

	@Override
	public void onEdgeUnsnap()
	{
		this.setImage(plugin.getMapArrow());
		this.setImagePoint(point);
	}
}

package thestonedturtle.mahoganyhomes;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class TeleportItem
{
	public int ItemId;
	public int Distance;
}

package thestonedturtle.mahoganyhomes;

import com.google.common.annotations.VisibleForTesting;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.UsernameChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.OverlayMenuClicked;
import net.runelite.client.events.PluginMessage;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.worldmap.WorldMapPointManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Mahogany Homes"
)
public class MahoganyHomesPlugin extends Plugin
{
	@VisibleForTesting
	static final Pattern CONTRACT_PATTERN = Pattern.compile("(Please could you g|G)o see (\\w*)[ ,][\\w\\s,-]*[?.] You can get another job once you have furnished \\w* home\\.");
	@VisibleForTesting
	static final Pattern REMINDER_PATTERN = Pattern.compile("You're currently on an? (\\w*) Contract\\. Go see (\\w*)[ ,][\\w\\s,-]*\\. You can get another job once you have furnished \\w* home\\.");
	private static final Pattern CONTRACT_FINISHED = Pattern.compile("You have completed [\\d,]* contracts with a total of [\\d,]* points?\\.");
	private static final Pattern CONTRACT_ASSIGNED = Pattern.compile("(\\w*) Contract: Go see [\\w\\s,-]*\\.");
	private static final Pattern REQUEST_CONTACT_TIER = Pattern.compile("Could I have an? (\\w*) contract please\\?");

	private static final List<Integer> PLANK_IDS = Arrays.asList(ItemID.PLANK, ItemID.OAK_PLANK, ItemID.TEAK_PLANK, ItemID.MAHOGANY_PLANK);

	private static final String PLANK_SACK_GROUP_NAME = "planksack";

	private static final String PLANK_COUNT_KEY = "plankcount";

	@Getter
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ConfigManager configManager;

	@Inject
	private MahoganyHomesConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private MahoganyHomesOverlay textOverlay;

	@Inject
	private MahoganyHomesHighlightOverlay highlightOverlay;

	@Inject
	private TeleportItemOverlay teleportItemOverlay;

	@Inject
	private WorldMapPointManager worldMapPointManager;

	@Inject
	private EventBus eventBus;

	@Provides
	MahoganyHomesConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(MahoganyHomesConfig.class);
	}

	@Getter
	private final List<GameObject> objectsToMark = new ArrayList<>();
	@Getter
	private final List<GameObject> laddersToMark = new ArrayList<>();
	// Varb values: 0=default, 1=Needs repair, 2=Repaired, 3=Remove 4=Bulld 5-8=Built Tiers
	private final HashMap<Integer, Integer> varbMap = new HashMap<>();

	private BufferedImage mapIcon;
	private BufferedImage mapArrow;

	@Getter
	private Home currentHome;
	private boolean varbChange;
	private boolean wasTimedOut;
	@Getter
	private int contractTier = 0;

	@Getter
	public TeleportItem teleportItem;

	@Getter
	private int numPlanksInInventory = 0;
	@Getter
	private int numSteelBarsInInventory = 0;

	// Used to auto disable plugin if nothing has changed recently.
	private Instant lastChanged;
	private int lastCompletedCount = -1;

	@Getter
	private int sessionContracts = 0;
	@Getter
	private int sessionPoints = 0;

	private Duration pluginTimeoutDuration = Duration.ofMinutes(5);

	@Override
	public void startUp()
	{
		overlayManager.add(textOverlay);
		overlayManager.add(highlightOverlay);
		overlayManager.add(teleportItemOverlay);
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			clientThread.invoke(this::loadFromConfig);
			clientThread.invoke(this::updateVarbMap);
		}
		lastChanged = Instant.now();
		lastCompletedCount = 0;
		pluginTimeoutDuration = Duration.ofMinutes(config.sessionTimeout());
	}

	@Override
	public void shutDown()
	{
		overlayManager.remove(textOverlay);
		overlayManager.remove(highlightOverlay);
		overlayManager.remove(teleportItemOverlay);
		worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
		client.clearHintArrow();
		varbMap.clear();
		objectsToMark.clear();
		laddersToMark.clear();
		currentHome = null;
		mapIcon = null;
		mapArrow = null;
		teleportItem = null;
		lastChanged = null;
		lastCompletedCount = -1;
		contractTier = 0;
		numPlanksInInventory = 0;
		numSteelBarsInInventory = 0;
		wasTimedOut = false;
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged c)
	{
		if (c.getGroup().equals(PLANK_SACK_GROUP_NAME) && c.getKey().equals(PLANK_COUNT_KEY))
		{
			if (contractTier > 0 && !isPluginTimedOut())
			{
				updateResourcesInInventory();
			}
			return;
		}
		if (!c.getGroup().equals(MahoganyHomesConfig.GROUP_NAME))
		{
			return;
		}

		if (c.getKey().equals(MahoganyHomesConfig.WORLD_MAP_KEY))
		{
			worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
			if (config.worldMapIcon() && currentHome != null)
			{
				worldMapPointManager.add(new MahoganyHomesWorldPoint(currentHome.getLocation(), this));
			}
		}
		else if (c.getKey().equals(MahoganyHomesConfig.HINT_ARROW_KEY))
		{
			client.clearHintArrow();
			if (client.getLocalPlayer() != null)
			{
				refreshHintArrow(client.getLocalPlayer().getWorldLocation());
			}
		}
		else if (c.getKey().equals(MahoganyHomesConfig.SESSION_TIMEOUT_KEY))
		{
			pluginTimeoutDuration = Duration.ofMinutes(config.sessionTimeout());
		}
		else if (c.getKey().equals(MahoganyHomesConfig.SHORTEST_PATH_KEY))
		{

			if (config.useShortestPath() && currentHome != null && client.getLocalPlayer() != null)
			{
				setShortestPath(client.getLocalPlayer().getWorldLocation(), currentHome.getLocation());
			}
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		// Defer to game tick for better performance
		varbChange = true;
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOADING)
		{
			objectsToMark.clear();
			laddersToMark.clear();
		}
	}

	@Subscribe
	public void onUsernameChanged(UsernameChanged e)
	{
		loadFromConfig();
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		processGameObjects(event.getGameObject(), null);
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		processGameObjects(null, event.getGameObject());
	}

	@Subscribe
	public void onOverlayMenuClicked(OverlayMenuClicked e)
	{
		if (!e.getOverlay().equals(textOverlay))
		{
			return;
		}

		if (e.getEntry().getOption().equals(MahoganyHomesOverlay.CLEAR_OPTION))
		{
			setCurrentHome(null);
			updateConfig();
			lastChanged = null;
		}

		if (e.getEntry().getOption().equals(MahoganyHomesOverlay.TIMEOUT_OPTION))
		{
			lastChanged = Instant.now().minus(pluginTimeoutDuration);
			// Remove worldPoint and clear hint arrow when plugin times out
			worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
			client.clearHintArrow();
			wasTimedOut = true;
		}

		if (e.getEntry().getOption().equals(MahoganyHomesOverlay.RESET_SESSION_OPTION))
		{
			sessionContracts = 0;
			sessionPoints = 0;
		}
	}

	@Subscribe
	public void onGameTick(GameTick t)
	{
		if (contractTier == 0 || currentHome == null)
		{
			checkForContractTierDialog();
		}

		checkForAssignmentDialog();

		if (currentHome == null)
		{
			return;
		}

		if (varbChange)
		{
			varbChange = false;
			updateVarbMap();

			// If we couldn't find their contract tier recalculate it when they get close
			if (contractTier == 0)
			{
				calculateContractTier();
			}

			final int completed = getCompletedCount();
			if (completed != lastCompletedCount)
			{
				if (wasTimedOut)
				{
					// Refreshes hint arrow and world map icon if necessary
					setCurrentHome(currentHome);
					updateVarbMap();
					wasTimedOut = false;
				}

				lastCompletedCount = completed;
				lastChanged = Instant.now();
			}
		}

		// The plugin automatically disables after 5 minutes of inactivity.
		if (isPluginTimedOut())
		{
			if (!wasTimedOut)
			{
				// Remove worldPoint and clear hint arrow when plugin times out
				worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
				client.clearHintArrow();
			}
			wasTimedOut = true;
			return;
		}

		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

		refreshHintArrow(playerLocation);
		refreshTeleportItem(playerLocation);
	}

	@Subscribe
	public void onChatMessage(ChatMessage e)
	{
		if (!e.getType().equals(ChatMessageType.GAMEMESSAGE))
		{
			return;
		}

		final Matcher matcher = CONTRACT_ASSIGNED.matcher(Text.removeTags(e.getMessage()));
		if (matcher.matches())
		{
			final String type = matcher.group(1).toLowerCase();
			setContactTierFromString(type);
			updateResourcesInInventory();
		}

		if (CONTRACT_FINISHED.matcher(Text.removeTags(e.getMessage())).matches())
		{
			sessionContracts++;
			sessionPoints += getPointsForCompletingTask();
			setCurrentHome(null);
			updateConfig();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		if (contractTier == 0 || isPluginTimedOut())
		{
			return;
		}
		if (event.getContainerId() == InventoryID.INVENTORY.getId())
		{
			updateResourcesInInventory();
		}
	}


	private void checkForContractTierDialog()
	{
		final Widget dialog = client.getWidget(ComponentID.DIALOG_PLAYER_TEXT);
		if (dialog == null)
		{
			return;
		}

		final String text = Text.sanitizeMultilineText(dialog.getText());
		final Matcher matcher = REQUEST_CONTACT_TIER.matcher(text);
		if (matcher.matches())
		{
			final String type = matcher.group(1).toLowerCase();
			setContactTierFromString(type);
			updateResourcesInInventory();
		}
	}

	private void setContactTierFromString (String tier)
	{
		switch (tier)
		{
			case "beginner":
				contractTier = 1;
				break;
			case "novice":
				contractTier = 2;
				break;
			case "adept":
				contractTier = 3;
				break;
			case "expert":
				contractTier = 4;
				break;
		}
	}

	// Check for NPC dialog assigning or reminding us of a contract
	private void checkForAssignmentDialog()
	{
		final Widget dialog = client.getWidget(ComponentID.DIALOG_NPC_TEXT);
		if (dialog == null)
		{
			return;
		}

		final String npcText = Text.sanitizeMultilineText(dialog.getText());
		final Matcher startContractMatcher = CONTRACT_PATTERN.matcher(npcText);
		final Matcher reminderContract = REMINDER_PATTERN.matcher(npcText);
		String name = null;
		int tier = -1;
		if (startContractMatcher.matches())
		{
			name = startContractMatcher.group(2);
		}
		else if (reminderContract.matches())
		{
			name = reminderContract.group(2);
			tier = getTierByText(reminderContract.group(1));
		}

		if (name != null)
		{
			// They may have asked for a contract but already had one, check the configs
			if (contractTier == 0)
			{
				loadFromConfig();
				// If the config matches the assigned value then do nothing
				if (currentHome != null && currentHome.getName().equalsIgnoreCase(name))
				{
					return;
				}
			}

			// If we could parse the tier from the message (only for reminders) make sure the current tier matches it
			// update the tier and config with the parsed value
			if (tier != -1)
			{
				contractTier = tier;
			}
			updateResourcesInInventory();

			for (final Home h : Home.values())
			{
				if (h.getName().equalsIgnoreCase(name) && (currentHome != h || isPluginTimedOut()))
				{
					setCurrentHome(h);
					updateConfig();
					break;
				}
			}
		}
	}

	private void setCurrentHome(final Home h)
	{
		currentHome = h;
		client.clearHintArrow();
		lastChanged = Instant.now();
		lastCompletedCount = 0;
		varbMap.clear();

		if (currentHome == null)
		{
			worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
			contractTier = 0;
			teleportItem = null;
			numPlanksInInventory = 0;
			numSteelBarsInInventory = 0;
			return;
		}

		if (config.worldMapIcon())
		{
			worldMapPointManager.removeIf(MahoganyHomesWorldPoint.class::isInstance);
			worldMapPointManager.add(new MahoganyHomesWorldPoint(h.getLocation(), this));
		}

		if (config.useShortestPath() && client.getLocalPlayer() != null)
		{
			WorldPoint playerWp = client.getLocalPlayer().getWorldLocation();
			setShortestPath(playerWp, h.getLocation());
		}

		if (config.displayHintArrows() && client.getLocalPlayer() != null)
		{
			refreshHintArrow(client.getLocalPlayer().getWorldLocation());
		}

		if (config.highlightTeleports() && client.getLocalPlayer() != null)
		{
			clientThread.invoke(this::updateTeleportItem);
		}
	}

	private void updateTeleportItem()
	{
		teleportItem = currentHome.getTeleportItems().getClosestTeleportItemOnPlayer(client);
	}

	private void processGameObjects(final GameObject cur, final GameObject prev)
	{
		objectsToMark.remove(prev);
		laddersToMark.remove(prev);

		if (cur == null || (!Hotspot.isHotspotObject(cur.getId()) && !Home.isLadder(cur.getId())))
		{
			return;
		}

		if (Hotspot.isHotspotObject(cur.getId()))
		{
			objectsToMark.add(cur);
			return;
		}

		if (Home.isLadder(cur.getId()))
		{
			laddersToMark.add(cur);
		}
	}

	private void updateVarbMap()
	{
		varbMap.clear();

		for (final Hotspot spot : Hotspot.values())
		{
			varbMap.put(spot.getVarb(), client.getVarbitValue(spot.getVarb()));
		}
	}

	private void loadFromConfig()
	{
		final String group = MahoganyHomesConfig.GROUP_NAME + "." + client.getAccountHash();
		final String name = configManager.getConfiguration(group, MahoganyHomesConfig.HOME_KEY);
		if (name == null)
		{
			return;
		}

		try
		{
			final Home h = Home.valueOf(name.trim().toUpperCase());
			setCurrentHome(h);
		}
		catch (IllegalArgumentException e)
		{
			log.warn("Stored unrecognized home: {}", name);
			currentHome = null;
			configManager.setConfiguration(group, MahoganyHomesConfig.HOME_KEY, null);
		}

		// Get contract tier from config if home was loaded successfully
		if (currentHome == null)
		{
			return;
		}

		final String tier = configManager.getConfiguration(group, MahoganyHomesConfig.TIER_KEY);
		if (tier == null)
		{
			return;
		}

		try
		{
			contractTier = Integer.parseInt(tier);
		}
		catch (IllegalArgumentException e)
		{
			log.warn("Stored unrecognized contract tier: {}", tier);
			contractTier = 0;
			configManager.unsetConfiguration(group, MahoganyHomesConfig.TIER_KEY);
		}
		updateResourcesInInventory();
	}

	private void updateConfig()
	{
		final String group = MahoganyHomesConfig.GROUP_NAME + "." + client.getAccountHash();
		if (currentHome == null)
		{
			configManager.unsetConfiguration(group, MahoganyHomesConfig.HOME_KEY);
			configManager.unsetConfiguration(group, MahoganyHomesConfig.TIER_KEY);
		}
		else
		{
			configManager.setConfiguration(group, MahoganyHomesConfig.HOME_KEY, currentHome.getName());
			configManager.setConfiguration(group, MahoganyHomesConfig.TIER_KEY, contractTier);
		}
	}

	private void refreshHintArrow(final WorldPoint playerPos)
	{
		client.clearHintArrow();
		if (currentHome == null || !config.displayHintArrows())
		{
			return;
		}

		if (distanceBetween(currentHome.getArea(), playerPos) > 0)
		{
			client.setHintArrow(currentHome.getLocation());
		}
		else
		{
			// We are really close to house, only display a hint arrow if we are done.
			if (getCompletedCount() != 0)
			{
				return;
			}

			final Optional<NPC> npc = client.getNpcs().stream().filter(n -> n.getId() == currentHome.getNpcId()).findFirst();
			if (npc.isPresent())
			{
				client.setHintArrow(npc.get());
				return;
			}

			// Couldn't find the NPC, find the closest ladder to player
			WorldPoint location = null;
			int distance = Integer.MAX_VALUE;
			for (final GameObject obj : laddersToMark)
			{
				// Ensure ladder isn't in a nearby home.
				if (distanceBetween(currentHome.getArea(), obj.getWorldLocation()) > 0)
				{
					continue;
				}

				int diff = obj.getWorldLocation().distanceTo(client.getLocalPlayer().getWorldLocation());
				if (diff < distance)
				{
					distance = diff;
					location = obj.getWorldLocation();
				}
			}

			if (location != null)
			{
				client.setHintArrow(location);
			}
		}
	}

	int getCompletedCount()
	{
		if (currentHome == null)
		{
			return -1;
		}

		int count = 0;
		for (final Hotspot hotspot : Hotspot.values())
		{
			final boolean requiresAttention = doesHotspotRequireAttention(hotspot.getVarb());
			if (!requiresAttention)
			{
				continue;
			}

			count++;
		}

		return count;
	}

	boolean doesHotspotRequireAttention(final int varb)
	{
		final Integer val = varbMap.get(varb);
		if (val == null)
		{
			return false;
		}

		return val == 1 || val == 3 || val == 4;
	}

	// This check assumes objects are on the same plane as the WorldArea (ignores plane differences)
	int distanceBetween(final WorldArea area, final WorldPoint point)
	{
		return area.distanceTo(new WorldPoint(point.getX(), point.getY(), area.getPlane()));
	}

	BufferedImage getMapIcon()
	{
		if (mapIcon != null)
		{
			return mapIcon;
		}

		mapIcon = ImageUtil.getResourceStreamFromClass(getClass(), "map-icon.png");
		return mapIcon;
	}

	BufferedImage getMapArrow()
	{
		if (mapArrow != null)
		{
			return mapArrow;
		}

		mapArrow = ImageUtil.getResourceStreamFromClass(getClass(), "map-arrow-icon.png");
		return mapArrow;
	}

	boolean isPluginTimedOut()
	{
		return lastChanged != null && Duration.between(lastChanged, Instant.now()).compareTo(pluginTimeoutDuration) >= 0;
	}

	int getPointsForCompletingTask()
	{
		// Contracts reward 2-5 points depending on tier
		return getContractTier() + 1;
	}

	private void calculateContractTier()
	{
		int tier = 0;
		// Values 5-8 are the tier of contract completed
		for (int val : varbMap.values())
		{
			tier = Math.max(tier, val);
		}

		// Normalizes tier from 5-8 to 1-4
		tier -= 4;
		contractTier = Math.max(tier, 0);
	}

	public Set<Integer> getRepairableVarbs()
	{
		return varbMap.keySet()
			.stream()
			.filter(this::doesHotspotRequireAttention)
			.collect(Collectors.toSet());
	}

	private void refreshTeleportItem(final WorldPoint playerPos)
	{
		if (currentHome == null || teleportItem == null || !config.highlightTeleports())
		{
			return;
		}

		if (distanceBetween(currentHome.getArea(), playerPos) - teleportItem.Distance < 10)
		{
			teleportItem = null;
		}
	}

	private int getTierByText(final String tierText)
	{
		switch (tierText)
		{
			case "Beginner":
				return 1;
			case "Novice":
				return 2;
			case "Adept":
				return 3;
			case "Expert":
				return 4;
			default:
				return -1;
		}
	}

	void updateResourcesInInventory()
	{
		if (contractTier == 0)
		{
			this.numPlanksInInventory = 0;
			this.numSteelBarsInInventory = 0;
			return;
		}

		ItemContainer inventoryContainer = client.getItemContainer(InventoryID.INVENTORY.getId());
		if (inventoryContainer == null)
		{
			return;
		}

		int num_planks = inventoryContainer.count(PLANK_IDS.get(contractTier - 1));
		Integer plank_sack_plugin_count = configManager.getRSProfileConfiguration(PLANK_SACK_GROUP_NAME, PLANK_COUNT_KEY, Integer.class);
		if (plank_sack_plugin_count != null)
		{
			num_planks += plank_sack_plugin_count;
		}

		this.numPlanksInInventory = num_planks;
		this.numSteelBarsInInventory = inventoryContainer.count(ItemID.STEEL_BAR);;
	}

	void setShortestPath(final WorldPoint start, final WorldPoint target)
	{
		if (config.useShortestPath() && start != null && target != null)
		{
			Map<String, Object> data = new HashMap<>();
			data.put("start", start);
			data.put("target", target);
			eventBus.post(new PluginMessage("shortestpath", "path", data));
		}
	}
}

package thestonedturtle.mahoganyhomes;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;
import net.runelite.client.util.ImageUtil;

class TeleportItemOverlay extends WidgetItemOverlay
{
	private final ItemManager itemManager;
	private final MahoganyHomesPlugin plugin;
	private final MahoganyHomesConfig config;

	@Inject
	private TeleportItemOverlay(ItemManager itemManager, MahoganyHomesPlugin plugin, MahoganyHomesConfig config)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.config = config;
		showOnInventory();
		showOnEquipment();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		TeleportItem teleportItem = plugin.teleportItem;

		if (teleportItem == null || itemId != teleportItem.ItemId || !config.highlightTeleports())
		{
			return;
		}

		Color color = config.highlightTeleportsColor();

		if (color == null)
		{
			return;
		}

		Rectangle bounds = itemWidget.getCanvasBounds();

		final BufferedImage outline = itemManager.getItemOutline(teleportItem.ItemId, itemWidget.getQuantity(), new Color(color.getRGB()));
		graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);

		Image image = ImageUtil.fillImage(itemManager.getImage(teleportItem.ItemId, itemWidget.getQuantity(), false), color);
		graphics.drawImage(image, (int) bounds.getX(), (int) bounds.getY(), null);
	}
}

/*
 * Copyright (c) 2020, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package thestonedturtle.mahoganyhomes;

import java.util.regex.Matcher;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class MahoganyHomesTest
{
	@Test
	public void testAssignmentRegexPattern()
	{
		matchContractAssignment("Jess", "Please could you go see Jess, upstairs of the building south of the church in East Ardougne? You can get another job once you have furnished her home.");
		matchContractAssignment("Jess", "Go see Jess, upstairs of the building south of the church in East Ardougne. You can get another job once you have furnished her home.");

		matchContractAssignment("Sarah", "Please could you go see Sarah along the south wall of Varrock? You can get another job once you have furnished her home.");
		matchContractAssignment("Sarah", "Go see Sarah along the south wall of Varrock. You can get another job once you have furnished her home.");

		matchContractAssignment("Bob", "Please could you go see Bob in north-east Varrock, opposite the church? You can get another job once you have furnished his home.");
		matchContractAssignment("Bob", "Go see Bob in north-east Varrock, opposite the church. You can get another job once you have furnished his home.");

		matchContractAssignment("Barbara", "Please could you go see Barbara, south of Hosidius, near the mill for us? You can get another job once you have furnished her home.");
	}

	private void matchContractAssignment(final String name, final String message)
	{
		final Matcher matcher = MahoganyHomesPlugin.CONTRACT_PATTERN.matcher(message);
		assertTrue(matcher.matches());
		assertEquals(name, matcher.group(2));
	}

	@Test
	public void testReminderRegexPattern()
	{
		matchReminderContract("Expert", "Ross", "You're currently on an Expert Contract. Go see Ross, north of the church in East Ardounge. You can get another job once you have furnished his home.");
		matchReminderContract("Expert", "Jess", "You're currently on an Expert Contract. Go see Jess, upstairs of the building south of the church in East Ardougne. You can get another job once you have furnished her home.");
		matchReminderContract("Expert", "Barbara", "You're currently on an Expert Contract. Go see Barbara, south of Hosidius, near the mill. You can get another job once you have furnished her home.");
		matchReminderContract("Hard", "Bob", "You're currently on a Hard Contract. Go see Bob in north-east Varrock, opposite the church. You can get another job once you have furnished his home.");
        matchReminderContract("Novice", "Barbara", "You're currently on a Novice Contract. Go see Barbara, south of Hosidius, near the mill. You can get another job once you have furnished her home.");
	}

	private void matchReminderContract(final String tier, final String name, final String message)
	{
		final Matcher matcher = MahoganyHomesPlugin.REMINDER_PATTERN.matcher(message);
		assertTrue(matcher.matches());
		assertEquals(tier, matcher.group(1));
		assertEquals(name, matcher.group(2));
	}
}

package thestonedturtle.mahoganyhomes;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class MahoganyHomesPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(MahoganyHomesPlugin.class);
		RuneLite.main(args);
	}
}
