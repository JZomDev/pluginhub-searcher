package com.github.jeromkiller.AttendanceCounter.Util;

import com.github.jeromkiller.AttendanceCounter.game.CaptureArea;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import joptsimple.internal.Strings;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import java.util.*;

public class AttendanceCounterSettings {

    public static final String CONFIG_GROUP = "AttendanceCounter";
    public static final String CAPTURE_AREA_KEY = "captureAreas";
    public static final String SHOW_RENDER_DIST = "AC_ShowRenderDist";
    public static final String HIDE_OVERLAY = "AC_HideOverlay";

    @Inject
    private ConfigManager configManager;
    @Inject
    private Gson gson;

    private void setValue(String key, Object value)
    {
        boolean isEmpty = false;
        if(value instanceof Collection)
        {
            isEmpty = ((Collection<?>) value).isEmpty();
        }
        else if (value instanceof Map)
        {
            isEmpty = ((Map<?, ?>) value).isEmpty();
        }

        if(isEmpty)
        {
            configManager.unsetConfiguration(CONFIG_GROUP, key);
            return;
        }

        final String json = gson.toJson(value);
        configManager.setConfiguration(CONFIG_GROUP, key, json);
    }

    public List<CaptureArea> getCaptureAreas() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, CAPTURE_AREA_KEY);
        if(Strings.isNullOrEmpty(json)){
            return new ArrayList<>();
        }
        return gson.fromJson(json, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
    }

    public void setCaptureAreas(List<CaptureArea> captureAreas) {
        setValue(CAPTURE_AREA_KEY, captureAreas);
    }

    public boolean getShowRenderDist() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, SHOW_RENDER_DIST);
        if(Strings.isNullOrEmpty(json)){
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

    public void setShowRenderDist(boolean show) {
        setValue(SHOW_RENDER_DIST, show);
    }

    public boolean getHideOverlay() {
        final String json = configManager.getConfiguration(CONFIG_GROUP, HIDE_OVERLAY);
        if(Strings.isNullOrEmpty(json)) {
            return false;
        }
        return gson.fromJson(json, new TypeToken<Boolean>(){}.getType());
    }

    public void setHideOverlay(boolean hide) {
        setValue(HIDE_OVERLAY, hide);
    }

}

package com.github.jeromkiller.AttendanceCounter.game;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.awt.*;
import java.time.Instant;
import java.util.Objects;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class CaptureArea {
    private static final int MAX_RENDER_DISTANCE = 50;

    private long id;
    private WorldPoint worldPoint;
    private int width;
    private int height;
    private String label;
    private Color color;
    private boolean areaVisible;
    private boolean areaActive;
    private boolean labelVisible;

    public CaptureArea(WorldPoint worldPoint, int width, int height, Color color, @Nullable String label, boolean labelVisible) {
        this.id = Instant.now().toEpochMilli();
        this.worldPoint = worldPoint;
        this.width = width;
        this.height = height;
        this.label = Objects.requireNonNullElse(label, "");
        this.color = color;
        this.areaVisible = true;
        this.areaActive = true;
        this.labelVisible = labelVisible;
    }

    public boolean notWorthChecking(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaActive;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean notWorthPainting(WorldPoint playerLoc)
    {
        boolean notWorth = false;
        notWorth |= !areaVisible;
        notWorth |= playerLoc.getPlane() != worldPoint.getPlane();
        notWorth |= playerLoc.distanceTo(worldPoint) > MAX_RENDER_DISTANCE;
        return notWorth;
    }

    public boolean playerInArea(WorldPoint playerLoc)
    {
        final int playerX = playerLoc.getX();
        final int playerY = playerLoc.getY();
        final int areaX = worldPoint.getX();
        final int areaY = worldPoint.getY();
        return ((playerX >= areaX) && (playerX < areaX + width))
                && ((playerY >= areaY) && (playerY < areaY + height));
    }
}

package com.github.jeromkiller.AttendanceCounter;

import com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea.CaptureCreationOptions;
import com.github.jeromkiller.AttendanceCounter.game.CaptureArea;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.Perspective;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.geom.Area;
import java.awt.geom.GeneralPath;
import java.awt.geom.Rectangle2D;


public class AttendanceCounterSceneOverlay extends Overlay
{
    private static final int LOCAL_TILE_SIZE = Perspective.LOCAL_TILE_SIZE;
    private static final int ENTITY_RENDER_LIMIT = 15;

    private final Client client;
    private final AttendanceCounterPlugin plugin;

    private boolean pointDrawn;

    @Inject
    private AttendanceCounterSceneOverlay(Client client, AttendanceCounterPlugin plugin)
    {
        this.client = client;
        this.plugin = plugin;
        setPosition(OverlayPosition.DYNAMIC);
        setPriority(PRIORITY_LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if(plugin.getSettings().getHideOverlay()) {
            return null;
        }

        WorldPoint playerLoc = client.getLocalPlayer().getWorldLocation();

        drawCreationArea(graphics, plugin.getCaptureCreationOptions(), playerLoc);

        if(plugin.getSettings().getShowRenderDist()) {
            drawRenderDist(graphics, playerLoc);
        }

        for(CaptureArea area : plugin.getCaptureAreas()) {
            if(area.notWorthPainting(playerLoc)) {
                continue;
            }
            drawBox(graphics, area, playerLoc);
        }

        return null;
    }

    private void drawRenderDist(Graphics2D graphics, WorldPoint PlayerLocation) {
        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        // draw the clipping area
        graphics.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5, 2}, 0));
        graphics.setColor(Color.blue);
        graphics.setClip(fullScreen);
        graphics.draw(clippingSquare);

    }

    private void drawCreationArea(Graphics2D graphics2D, CaptureCreationOptions options, WorldPoint PlayerLocation)
    {
        if(!options.isCurrentlyCreating())
            return;

        final int width = (options.getEast() + options.getWest() + 1);
        final int height = (options.getNorth() + options.getSouth() + 1);
        final int xOffset = -options.getWest();
        final int yOffset = -options.getSouth();

        WorldPoint swTile = PlayerLocation.dx(xOffset).dy(yOffset);
        CaptureArea setupArea = new CaptureArea(swTile, width, height, options.getColor(), options.getLabel(), options.isLabelVisible());
        drawBox(graphics2D, setupArea, PlayerLocation);
    }

    private void drawBox(Graphics2D graphics, CaptureArea captureArea, WorldPoint PlayerLocation)
    {
        //capture area tile
        GeneralPath outerSquare = createFloorBox(captureArea.getWorldPoint(), captureArea.getWidth(), captureArea.getHeight());
        WorldPoint entityRenderOrigin = PlayerLocation.dx(-ENTITY_RENDER_LIMIT).dy(-ENTITY_RENDER_LIMIT);
        GeneralPath clippingSquare = createFloorBox(entityRenderOrigin, ENTITY_RENDER_LIMIT * 2 + 1, ENTITY_RENDER_LIMIT * 2+ 1);  // simple clipping area

        Canvas screen = client.getCanvas();
        final Rectangle2D fullScreen = new Rectangle2D.Float(0, 0, screen.getWidth(), screen.getHeight());

        // draw inside square
        Stroke stroke = new BasicStroke(2);
        Color inside_border = captureArea.getColor();
        Color inside_fillColor = ColorUtil.colorWithAlpha(inside_border, 255);
        graphics.setClip(clippingSquare);
        graphics.setStroke(stroke);
        graphics.setColor(inside_border);
        graphics.fill(outerSquare);
        graphics.setColor(inside_fillColor);
        graphics.draw(outerSquare);

        //draw the outside square
        Area insideClip = new Area(fullScreen);
        Color outside_border = negateColor(captureArea.getColor());
        Color outside_fillColor = ColorUtil.colorWithAlpha(outside_border, 255);

        insideClip.subtract(new Area(clippingSquare));
        graphics.setClip(insideClip);
        graphics.setStroke(stroke);
        graphics.setColor(outside_border);
        graphics.fill(outerSquare);
        graphics.setColor(outside_fillColor);
        graphics.draw(outerSquare);

        graphics.setClip(fullScreen);
        paintText(graphics, captureArea, inside_border);
    }

    private GeneralPath createFloorBox(WorldPoint origin, int width, int height)
    {
        GeneralPath path = new GeneralPath();

        pointDrawn = false;
        drawWestLine(path, height, origin);
        drawNorthLine(path, width, origin.dy(height));
        drawEastLine(path, height, origin.dx(width).dy(height));
        drawSouthLine(path, width, origin.dx(width));

        if(pointDrawn) {
            path.closePath();
        }
        return path;
    }

    private void drawWestLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint( x, y + y_offset);
            if(startPoint == null) {
                continue;
            }
            LocalPoint endPoint = startPoint.dy(LOCAL_TILE_SIZE -1);
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawNorthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x + x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            LocalPoint endPoint = startPoint.dx(LOCAL_TILE_SIZE -1);
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawEastLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int y_offset = 0; y_offset < length; y_offset++) {
            LocalPoint startPoint = toLocalPoint(x, y - y_offset);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dy(-1);
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dy(-(LOCAL_TILE_SIZE -1));
            if(y_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void drawSouthLine(GeneralPath path, int length, WorldPoint worldPoint)
    {
        int x = worldPoint.getX();
        int y = worldPoint.getY();
        int z = worldPoint.getPlane();
        for (int x_offset = 0; x_offset < length; x_offset++) {
            LocalPoint startPoint = toLocalPoint(x - x_offset, y);
            if(startPoint == null) {
                continue;
            }
            startPoint = startPoint.dx(-1);
            LocalPoint endPoint = startPoint.dx(-(LOCAL_TILE_SIZE -1));
            if(x_offset != 0) {
                paintPoint(path, startPoint, z);
            }
            paintPoint(path, endPoint, z);
        }
    }

    private void paintText(Graphics2D graphics, CaptureArea captureArea, Color color) {
        if(captureArea.isLabelVisible()) {
            //draw the label in the middle of the capture area
            WorldPoint areaCenter = captureArea.getWorldPoint().dx(captureArea.getWidth() / 2).dy(captureArea.getHeight() / 2);
            LocalPoint localPoint = toLocalPoint(areaCenter.getX(), areaCenter.getY(), true);
            if (localPoint != null) {
                if (captureArea.getWidth() % 2 == 0) {
                    localPoint = localPoint.dx(-LOCAL_TILE_SIZE / 2);
                }
                if (captureArea.getHeight() % 2 == 0) {
                    localPoint = localPoint.dy(-LOCAL_TILE_SIZE / 2);
                }

                graphics.setColor(ColorUtil.colorWithAlpha(color, 255));
                graphics.setFont(FontManager.getRunescapeFont());
                Point textLoc = Perspective.getCanvasTextLocation(client, graphics, localPoint, captureArea.getLabel(), 0);
                if (textLoc != null) {
                    graphics.drawString(captureArea.getLabel(), textLoc.getX(), textLoc.getY());
                }
            }
        }
    }

    private void paintPoint(GeneralPath path, LocalPoint localPoint, int z){
        if (localPoint == null)
            return;

        Point canvasPoint = toCanvasPoint(localPoint, z);
        if(canvasPoint == null)
            return;

        if (pointDrawn) {
            path.lineTo(canvasPoint.getX(), canvasPoint.getY());
        } else {
            path.moveTo(canvasPoint.getX(), canvasPoint.getY());
            pointDrawn = true;
        }
    }

    private LocalPoint toLocalPoint(int x, int y)
    {
        return toLocalPoint(x, y, false);
    }

    private LocalPoint toLocalPoint(int x, int y, boolean getCenter)
    {
        LocalPoint localPointCenter = LocalPoint.fromWorld(client.getTopLevelWorldView(), x, y);
        if(localPointCenter == null) {
            return null;
        }
        if (getCenter) {
            return localPointCenter;
        }
        return localPointCenter.plus(- LOCAL_TILE_SIZE / 2, - LOCAL_TILE_SIZE / 2);
    }

    private Point toCanvasPoint(LocalPoint localPoint, int z) {
        return Perspective.localToCanvas(
                client,
                localPoint,
                //new LocalPoint(localPoint.getX() - LOCAL_TILE_SIZE / 2, localPoint.getY() - LOCAL_TILE_SIZE / 2),
                z);
    }

    private Color negateColor(Color color) {
        final int maxColor = ColorUtil.MAX_RGB_VALUE;
        return new Color(maxColor - color.getRed(),
                    maxColor - color.getGreen(),
                    maxColor - color.getBlue(),
                    color.getAlpha()
                );
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels;

import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import com.github.jeromkiller.AttendanceCounter.Panels.Widgets.BlinklessToggleButton;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.LinkedHashSet;

public class AttendancePanel extends JPanel {
    private final BlinklessToggleButton autoFillButton;
    private final JTextArea playerNames = new JTextArea();
    private final JLabel numPlayers;

    @Getter
    private final LinkedHashSet<String> playerNameList = new LinkedHashSet<>();

    private final AttendanceCounterPlugin plugin;

    public AttendancePanel(AttendanceCounterPlugin plugin)
    {
        this.plugin = plugin;

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);
        constraints.gridy = 0;
        constraints.weightx = 1;

        constraints.gridwidth = 1;
        constraints.anchor = GridBagConstraints.WEST;
        final JLabel autoFillLabel = new JLabel("Count Attendance");
        contents.add(autoFillLabel, constraints);

        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        constraints.fill = GridBagConstraints.NONE;
        autoFillButton = new BlinklessToggleButton("Automatically add players to the participant list");
        autoFillButton.addItemListener(this::changeAutoFill);
        contents.add(autoFillButton, constraints);
        constraints.gridy++;

        constraints.gridx = 0;
        constraints.anchor = GridBagConstraints.WEST;
        contents.add(new JLabel("Participants:"), constraints);

        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        numPlayers = new JLabel("0");
        contents.add(numPlayers, constraints);
        constraints.gridy++;

        constraints.gridwidth = 2;
        constraints.gridx = 0;
        constraints.gridy++;
        constraints.anchor = GridBagConstraints.WEST;

        final JLabel playerNameLabel = new JLabel("Participant Names:");
        contents.add(playerNameLabel, constraints);
        constraints.gridy++;

        constraints.fill = GridBagConstraints.BOTH;
        constraints.weighty = 1;
        playerNames.setRows(10);
        Border border = BorderFactory.createLineBorder(ColorScheme.BORDER_COLOR );
        playerNames.setBorder(BorderFactory.createCompoundBorder(border,
                BorderFactory.createEmptyBorder(3, 5, 3, 5)));

        contents.add(playerNames, constraints);
        playerNames.setEditable(false);
        constraints.gridy++;
        constraints.weighty = 0;
        constraints.fill = GridBagConstraints.HORIZONTAL;

        JButton resetButton = new JButton("Reset");
        resetButton.addActionListener(e -> {plugin.resetPlayers();});
        constraints.gridx = 1;
        contents.add(resetButton, constraints);

        add(contents, BorderLayout.NORTH);
    }

    private void changeAutoFill() {
        final boolean autofill = autoFillButton.isSelected();
        plugin.setStartCapturing(autofill);
    }

    public void setPlayerNames(LinkedHashSet<String> names)
    {
        playerNameList.clear();
        playerNameList.addAll(names);
        final String playerNameString = String.join(System.lineSeparator(), playerNameList);
        playerNames.setText(playerNameString);
    }

    public void setPlayerCount(int count){
        numPlayers.setText(String.valueOf(count));
    }

}

package com.github.jeromkiller.AttendanceCounter.Panels.Widgets;

import com.github.jeromkiller.AttendanceCounter.Panels.BasePanel;
import lombok.Getter;

import javax.swing.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class BlinklessToggleButton extends JLabel {
    final ImageIcon selectedIcon;
    final ImageIcon selectedIconHover;
    final ImageIcon deselectedIcon;
    final ImageIcon deselectedIconHover;
    final String selectedTooltipText;
    final String deselectedTooltipText;

    @Getter
    boolean selected = false;

    public BlinklessToggleButton(ImageIcon selectedIcon, ImageIcon selectedIconHover,
                                 ImageIcon deselectedIcon, ImageIcon deselectedIconHover,
                                 String selectedTooltipText, String deselectedTooltipText) {
        this.selectedIcon = selectedIcon;
        this.selectedIconHover = selectedIconHover;
        this.deselectedIcon = deselectedIcon;
        this.deselectedIconHover = deselectedIconHover;
        this.selectedTooltipText = selectedTooltipText;
        this.deselectedTooltipText = deselectedTooltipText;

        updateSelected();

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(selected ? selectedIconHover : deselectedIconHover);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(selected ? selectedIcon : deselectedIcon);
            }
        });
    }

    public BlinklessToggleButton(String selectedTooltipText) {
        this.selectedIcon = BasePanel.ON_SWITCHER;
        this.selectedIconHover = BasePanel.ON_SWITCHER_HOVER;
        this.deselectedIcon = BasePanel.OFF_SWITCHER;
        this.deselectedIconHover = BasePanel.OFF_SWITCHER_HOVER;
        this.selectedTooltipText = selectedTooltipText;
        this.deselectedTooltipText = selectedTooltipText;

        updateSelected();

        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setIcon(selected ? selectedIconHover : deselectedIconHover);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                setIcon(selected ? selectedIcon : deselectedIcon);
            }
        });
    }

    public void setSelected(boolean selected) {
        this.selected = selected;
        updateSelected();
    }

    public void addItemListener(Runnable runnable) {
        addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                selected = !selected;
                updateSelected();
                runnable.run();
            }
        });
    }

    private void updateSelected() {
        setIcon(selected ? selectedIcon : deselectedIcon);
        setToolTipText(selected ? selectedTooltipText : deselectedTooltipText);
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels;

import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import com.github.jeromkiller.AttendanceCounter.Panels.Widgets.BlinklessToggleButton;
import com.github.jeromkiller.AttendanceCounter.Util.AttendanceCounterSettings;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public class SettingsPanel extends BasePanel {
    private final JSpinner tickLeniency = new JSpinner(new SpinnerNumberModel(2, 0, 100, 1));
    private final BlinklessToggleButton showRenderDist;
    private final BlinklessToggleButton hideOverlay;

    private final AttendanceCounterPlugin plugin;
    private final AttendanceCounterSettings settings;

    public SettingsPanel(AttendanceCounterPlugin plugin)
    {
        this.plugin = plugin;
        this.settings = plugin.getSettings();

        setLayout(new BorderLayout());
        setBorder(new EmptyBorder(5, 0, 10, 0));

        JPanel contents = new JPanel();
        contents.setLayout(new GridBagLayout());
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.insets = new Insets(0, 2, 5, 2);

        constraints.gridx = 0;
        constraints.gridy = 0;
        constraints.weightx = 1;

        hideOverlay = new BlinklessToggleButton("Hide the in game overlay. \nCapture areas previously set to 'visible' are still enabled");
        hideOverlay.setSelected(settings.getHideOverlay());
        hideOverlay.addItemListener(() -> {
            settings.setHideOverlay(hideOverlay.isSelected());
            updateDisabledButtons();
        });
        addSettingRow("Hide Overlay", hideOverlay, contents, constraints);

        showRenderDist = new BlinklessToggleButton("Show Render Distance");
        showRenderDist.setSelected(settings.getShowRenderDist());
        showRenderDist.addItemListener(() -> settings.setShowRenderDist(showRenderDist.isSelected()));
        addSettingRow("Show Render Distance", showRenderDist, contents, constraints);

        add(contents, BorderLayout.NORTH);
        loadSettings();
    }

    private void addSettingRow(String text, JComponent component, JPanel container, GridBagConstraints constraints) {
        constraints.gridx = 0;
        constraints.anchor = GridBagConstraints.WEST;
        container.add(new JLabel(text), constraints);
        constraints.gridx = 1;
        constraints.anchor = GridBagConstraints.EAST;
        container.add(component, constraints);
        constraints.gridx = 0;
        constraints.gridy++;
    }

    public void loadSettings() {
        final boolean showRenderDistSetting = settings.getShowRenderDist();
        showRenderDist.setSelected(showRenderDistSetting);

        updateDisabledButtons();
    }

    public void updateDisabledButtons() {
        showRenderDist.setEnabled(!settings.getHideOverlay());
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea;

import lombok.Data;
import lombok.NoArgsConstructor;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

@Data
@NoArgsConstructor
public class CaptureCreationOptions {
    private static final String DEFAULT_AREA_NAME = "Capture Area";
    public static int MAX_AREA_SIZE = 15;

    private boolean currentlyCreating = false;
    private int north = 1;
    private int east = 1;
    private int south = 1;
    private int west = 1;
    private String label = DEFAULT_AREA_NAME;
    Color color = ColorUtil.colorWithAlpha(Color.GREEN, 50);
    private boolean labelVisible = true;

    public void resetOptions() {
        currentlyCreating = false;
        north = 1;
        east = 1;
        south = 1;
        west = 1;
        label = DEFAULT_AREA_NAME;
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea;

import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import com.github.jeromkiller.AttendanceCounter.Panels.BasePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class CaptureCreationPanel extends BasePanel {
    protected static final ImageIcon CREATE_ICON;
    protected static final ImageIcon CREATE_HOVER_ICON;
    protected static final ImageIcon CANCEL_ICON;
    protected static final ImageIcon CANCEL_HOVER_ICON;
    protected static final ImageIcon COMPASS_ICON;

    private final JLabel colorIndicator = new JLabel();
    private final JLabel labelIndicator = new JLabel();
    private final FlatTextField nameInput = new FlatTextField();
    private final JSpinner northSpinner = new JSpinner();
    private final JSpinner eastSpinner = new JSpinner();
    private final JSpinner southSpinner = new JSpinner();
    private final JSpinner westSpinner = new JSpinner();
    private final JLabel saveArea = new JLabel();
    private final JLabel cancelArea = new JLabel();
    private final JLabel warnLabel = new JLabel("⚠ Area can be skipped over");

    private final CaptureCreationOptions captureOptions;
    private final AttendanceCounterPlugin plugin;
    private boolean showLabel;

    static
    {
        final BufferedImage createImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "confirm_icon.png");
        final BufferedImage createImgHover = ImageUtil.alphaOffset(createImg, 0.5f);
        CREATE_ICON = new ImageIcon(createImg);
        CREATE_HOVER_ICON = new ImageIcon(createImgHover);

        final BufferedImage cancelImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "cancel_icon.png");
        final BufferedImage cancelImgHover = ImageUtil.alphaOffset(cancelImg, 0.5f);
        CANCEL_ICON = new ImageIcon(cancelImg);
        CANCEL_HOVER_ICON = new ImageIcon(cancelImgHover);

        final BufferedImage compassImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "compass.png");
        COMPASS_ICON = new ImageIcon(compassImg);
    }

    public CaptureCreationPanel(AttendanceCounterPlugin plugin)
    {
        this.plugin = plugin;
        this.captureOptions = plugin.getCaptureCreationOptions();
        this.showLabel = captureOptions.isLabelVisible();

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        nameInput.setText(captureOptions.getLabel());
        nameInput.setBorder(null);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel centerContainer = new JPanel(new BorderLayout());
        centerContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        centerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        centerContainer.setLayout(new GridBagLayout());
        GridBagConstraints centerConstraints = new GridBagConstraints();

        final int MAX_VALUE = CaptureCreationOptions.MAX_AREA_SIZE;
        final int MIN_VALUE = 0;
        northSpinner.setModel(new SpinnerNumberModel(captureOptions.getNorth(), MIN_VALUE, MAX_VALUE, 1));
        northSpinner.addChangeListener(e -> {
            final int val = (int) northSpinner.getValue();
            captureOptions.setNorth(val);
            validateArea();
        }
        );
        southSpinner.setModel(new SpinnerNumberModel(captureOptions.getSouth(), MIN_VALUE, MAX_VALUE, 1));
        southSpinner.addChangeListener(e -> {
                final int val = (int) southSpinner.getValue();
                captureOptions.setSouth(val);
                validateArea();
        });
        eastSpinner.setModel(new SpinnerNumberModel(captureOptions.getEast(), MIN_VALUE, MAX_VALUE, 1));
        eastSpinner.addChangeListener(e -> {
                final int val = (int) eastSpinner.getValue();
                captureOptions.setEast(val);
                validateArea();
        });
        westSpinner.setModel(new SpinnerNumberModel(captureOptions.getWest(), MIN_VALUE, MAX_VALUE, 1));
        westSpinner.addChangeListener(e -> {
                final int val = (int) westSpinner.getValue();
                captureOptions.setWest(val);
                validateArea();
        });
        JLabel compass = new JLabel();
        compass.setIcon(COMPASS_ICON);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 0;
        centerContainer.add(northSpinner, centerConstraints);
        centerConstraints.gridx = 0;
        centerConstraints.gridy = 1;
        centerContainer.add(westSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerContainer.add(compass, centerConstraints);
        centerConstraints.gridx = 2;
        centerContainer.add(eastSpinner, centerConstraints);
        centerConstraints.gridx = 1;
        centerConstraints.gridy = 2;
        centerContainer.add(southSpinner, centerConstraints);
        centerConstraints.gridy = 3;
        centerConstraints.gridx = 0;
        centerConstraints.gridwidth = 3;
        warnLabel.setVisible(false);
        centerContainer.add(warnLabel, centerConstraints);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupImageIcon(colorIndicator, "Edit area color", COLOR_ICON, COLOR_HOVER_ICON, this::openBorderColorPicker);


        labelIndicator.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                toggleLabelling(!showLabel);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_HOVER_ICON : NO_LABEL_HOVER_ICON);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
            }
        });

        leftActions.add(colorIndicator);
        leftActions.add(labelIndicator);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setupImageIcon(saveArea, "Save Area", CREATE_ICON, CREATE_HOVER_ICON, () -> {
            captureOptions.setLabel(nameInput.getText());
            plugin.finishCaptureAreaCreation();
        });

        setupImageIcon(cancelArea, "Cancel Area creation", CANCEL_ICON, CANCEL_HOVER_ICON, plugin::cancelCaptureAreaCreation);

        rightActions.add(saveArea);
        rightActions.add(cancelArea);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(centerContainer, BorderLayout.CENTER);
        add(bottomContainer, BorderLayout.SOUTH);

        updateBorder();
        updateLabelling();
    }

    private void toggleLabelling(boolean on)
    {
        showLabel = on;
        captureOptions.setLabelVisible(on);
        plugin.updateCaptureAreas();
        updateLabelling();
    }

    private void updateLabelling()
    {
        labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
        labelIndicator.setToolTipText(showLabel ? "Hide label" : "Show label");
    }

    private void updateBorder()
    {
        Color color = captureOptions.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureOptions.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureOptions.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureOptions.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void validateArea()
    {
        final int width = captureOptions.getWest() + captureOptions.getEast() + 1;
        final int height = captureOptions.getNorth() + captureOptions.getSouth() + 1;
        final boolean tooSmall = (width == 1 || height == 1);
        warnLabel.setVisible(tooSmall);
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea;

import com.github.jeromkiller.AttendanceCounter.game.CaptureArea;
import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import com.github.jeromkiller.AttendanceCounter.Panels.BasePanel;
import com.github.jeromkiller.AttendanceCounter.Panels.Widgets.BlinklessToggleButton;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

public class ExistingCaptureAreaPanel extends BasePanel {
    private final JLabel colorIndicator = new JLabel();
    private final JLabel statusLabel = new JLabel();
    private final JLabel shareLabel = new JLabel();
    private final JLabel deleteLabel = new JLabel();
    private final BlinklessToggleButton visibilityToggle;// = new JToggleButton(INVISIBLE_ICON);
    private final BlinklessToggleButton labelToggle;// = new JToggleButton(NO_LABEL_ICON);

    private final FlatTextField nameInput = new FlatTextField();
    private final JLabel save = new JLabel("Save");
    private final JLabel cancel = new JLabel("Cancel");
    private final JLabel rename = new JLabel("Rename");

    private final AttendanceCounterPlugin plugin;
    private final CaptureArea captureArea;

    public ExistingCaptureAreaPanel(AttendanceCounterPlugin plugin, CaptureArea captureArea)
    {
        this.plugin = plugin;
        this.captureArea = captureArea;

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel nameWrapper = new JPanel(new BorderLayout());
        nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameWrapper.setBorder(NAME_BOTTOM_BORDER);

        JPanel nameActions = new JPanel(new BorderLayout(3,0));
        nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
        nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        save.setVisible(false);
        save.setFont(FontManager.getRunescapeSmallFont());
        save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
        save.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                save();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
            }
        });

        cancel.setVisible(false);
        cancel.setFont(FontManager.getRunescapeSmallFont());
        cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
        cancel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                cancel();
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
            }
        });

        rename.setFont(FontManager.getRunescapeSmallFont());
        rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
        rename.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent mouseEvent)
            {
                nameInput.setEditable(true);
                updateNameActions(true);
            }

            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
            }
        });

        nameActions.add(save, BorderLayout.EAST);
        nameActions.add(cancel, BorderLayout.WEST);
        nameActions.add(rename, BorderLayout.CENTER);

        nameInput.setText(captureArea.getLabel());
        nameInput.setBorder(null);
        nameInput.setEditable(false);
        nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        nameInput.setPreferredSize(new Dimension(0, 24));
        nameInput.getTextField().setForeground(Color.WHITE);
        nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
        nameInput.addKeyListener(new KeyAdapter()
        {
            @Override
            public void keyPressed(KeyEvent e)
            {
                if (e.getKeyCode() == KeyEvent.VK_ENTER)
                {
                    save();
                }
                else if (e.getKeyCode() == KeyEvent.VK_ESCAPE)
                {
                    cancel();
                }
            }
        });
        nameInput.getTextField().addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent mouseEvent)
            {
                preview(true);
            }

            @Override
            public void mouseExited(MouseEvent mouseEvent)
            {
                preview(false);
            }
        });

        nameWrapper.add(nameInput, BorderLayout.CENTER);
        nameWrapper.add(nameActions, BorderLayout.EAST);

        JPanel bottomContainer = new JPanel(new BorderLayout());
        bottomContainer.setBorder(new EmptyBorder(8, 0, 8, 0));
        bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
        leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupImageIcon(colorIndicator, "Edit area color", COLOR_ICON, COLOR_HOVER_ICON, this::openBorderColorPicker);

        labelToggle = new BlinklessToggleButton(LABEL_ICON, LABEL_HOVER_ICON,
                NO_LABEL_ICON, NO_LABEL_HOVER_ICON,
                "Hide Area Label", "Show Area Label");
        labelToggle.setSelected(captureArea.isLabelVisible());
        labelToggle.addItemListener(this::toggleLabelling);

        leftActions.add(colorIndicator);
        leftActions.add(labelToggle);

        JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 8, 0));
        rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        statusLabel.setText("Copied!");
        statusLabel.setVisible(false);

        setupImageIcon(shareLabel, "Copy area to clipboard", COPY_ICON, COPY_ICON_HOVER, () -> {
            plugin.copyCaptureAreaToClip(captureArea);
            showCopiedStatus();
        });

        visibilityToggle = new BlinklessToggleButton(VISIBLE_ICON, VISIBLE_HOVER_ICON,
                INVISIBLE_ICON, INVISIBLE_HOVER_ICON, "Hide Area", "Show Area");
        visibilityToggle.setSelected(captureArea.isAreaActive());
        visibilityToggle.addItemListener(this::toggleVisibility);

        setupImageIcon(deleteLabel, "Delete capture area", DELETE_ICON, DELETE_HOVER_ICON, () -> {
            int confirm = JOptionPane.showConfirmDialog(ExistingCaptureAreaPanel.this,
                    "Are you sure you want to permanently delete this capture area?",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);

            if (confirm == 0)
            {
                plugin.deleteCaptureArea(captureArea);
            }
        });

        rightActions.add(statusLabel);
        rightActions.add(shareLabel);
        rightActions.add(visibilityToggle);
        rightActions.add(deleteLabel);

        bottomContainer.add(leftActions, BorderLayout.WEST);
        bottomContainer.add(rightActions, BorderLayout.EAST);
        bottomContainer.setPreferredSize(new Dimension(0, 37));

        add(nameWrapper, BorderLayout.NORTH);
        add(bottomContainer, BorderLayout.CENTER);

        updateBorder();
    }

    private void preview(boolean on)
    {
        if(visibilityToggle.isSelected()) {
            return;
        }
        captureArea.setAreaVisible(on);
    }

    private void toggleVisibility()
    {
        final boolean isVisible = visibilityToggle.isSelected();
        captureArea.setAreaVisible(isVisible);
        captureArea.setAreaActive(isVisible);
        plugin.updateCaptureAreas();
    }

    private void toggleLabelling()
    {
        final boolean showLabel = labelToggle.isSelected();
        captureArea.setLabelVisible(showLabel);
        plugin.updateCaptureAreas();
    }

    private void save()
    {
        captureArea.setLabel(nameInput.getText());
        plugin.updateCaptureAreas();

        nameInput.setEditable(false);
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void cancel()
    {
        nameInput.setEditable(false);
        nameInput.setText(captureArea.getLabel());
        updateNameActions(false);
        requestFocusInWindow();
    }

    private void updateNameActions(boolean saveAndCancel)
    {
        save.setVisible(saveAndCancel);
        cancel.setVisible(saveAndCancel);
        rename.setVisible(!saveAndCancel);

        if (saveAndCancel)
        {
            nameInput.getTextField().requestFocusInWindow();
            nameInput.getTextField().selectAll();
        }
    }

    private void updateBorder()
    {
        Color color = captureArea.getColor();
        colorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, ColorUtil.colorWithAlpha(color, MAX_ALPHA)));

        colorIndicator.setIcon(COLOR_ICON);
    }

    private void openBorderColorPicker()
    {
        final Color color = captureArea.getColor();
        RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
                SwingUtilities.windowForComponent(this),
                color,
                captureArea.getLabel() + " Border",
                false);
        colorPicker.setLocationRelativeTo(this);
        colorPicker.setOnColorChange(c ->
        {
            captureArea.setColor(c);
            updateBorder();
        });
        colorPicker.setOnClose(c -> plugin.updateCaptureAreas());
        colorPicker.setVisible(true);
    }

    private void showCopiedStatus()
    {
        statusLabel.setVisible(true);
        Timer hideTimer = new Timer(1000, e -> hideCopiedStatus());
        hideTimer.setRepeats(false);
        hideTimer.start();
    }

    private void hideCopiedStatus()
    {
        statusLabel.setVisible(false);
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea;

import com.github.jeromkiller.AttendanceCounter.game.CaptureArea;
import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import com.github.jeromkiller.AttendanceCounter.Panels.BasePanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.PluginErrorPanel;

import javax.swing.*;
import java.awt.*;

public class CaptureAreaManagementPanel extends BasePanel {

    private final PluginErrorPanel noAreasPanel = new PluginErrorPanel();
    private final JPanel areaView = new JPanel(new GridBagLayout());
    private final JButton newArea = new JButton("New Area");
    private final JButton importArea = new JButton("Import from clipboard");
    private final JButton exportVisibleAreas = new JButton("Export visible to clipboard");
    private final JLabel copyStatusLabel = new JLabel("Copied!");

    private final AttendanceCounterPlugin plugin;

    public CaptureAreaManagementPanel(AttendanceCounterPlugin plugin)
    {
        this.plugin = plugin;

        setLayout(new BorderLayout());

        areaView.setBackground(ColorScheme.DARK_GRAY_COLOR);

        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        noAreasPanel.setContent("No Capture areas set", "Add a capture area for people to finnish in");
        noAreasPanel.setVisible(false);

        newArea.addActionListener(e -> plugin.startCaptureAreaCreation());
        importArea.addActionListener(e -> plugin.importCaptureAreaFromClip());
        exportVisibleAreas.addActionListener(e -> exportVisibleAreas());

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        //centerPanel.add(areaView, BorderLayout.CENTER);
        add(areaView, BorderLayout.NORTH);
    }

    public void rebuild()
    {
        GridBagConstraints constraints = new GridBagConstraints();
        constraints.fill = GridBagConstraints.HORIZONTAL;
        constraints.weightx = 1;
        constraints.gridx = 0;
        constraints.gridy = 0;

        areaView.removeAll();

        for(final CaptureArea captureArea : plugin.getCaptureAreas())
        {
            areaView.add(new ExistingCaptureAreaPanel(plugin, captureArea), constraints);
            constraints.gridy++;

            addSpacer(constraints);
        }

        final boolean empty = constraints.gridy == 0;
        noAreasPanel.setVisible(empty);

        areaView.add(noAreasPanel, constraints);
        constraints.gridy++;

        if(plugin.getCaptureCreationOptions().isCurrentlyCreating())
        {
            areaView.add(new CaptureCreationPanel(plugin), constraints);
        }
        else
        {
            areaView.add(newArea, constraints);
        }
        constraints.gridy++;
        addSpacer(constraints);

        areaView.add(importArea, constraints);
        constraints.gridy++;

        addSpacer(constraints);

        areaView.add(exportVisibleAreas, constraints);
        constraints.gridy++;

        copyStatusLabel.setVisible(false);
        areaView.add(copyStatusLabel, constraints);
        constraints.gridy++;

        repaint();
        revalidate();
    }

    private void addSpacer(GridBagConstraints constraints)
    {
        areaView.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
        constraints.gridy++;
    }

    private void exportVisibleAreas()
    {
        plugin.copyVisibleCaptureAreasToClip();
        copyStatusLabel.setVisible(true);
        Timer hideStatusTimer = new Timer(1000, e -> copyStatusLabel.setVisible(false));
        hideStatusTimer.setRepeats(false);
        hideStatusTimer.start();
    }
}

package com.github.jeromkiller.AttendanceCounter.Panels;

import com.github.jeromkiller.AttendanceCounter.AttendanceCounterPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;

public class BasePanel extends JPanel {
    public static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
            BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
            BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));
    public static final int MAX_ALPHA = 255;

    public static final ImageIcon COLOR_ICON;
    public static final ImageIcon COLOR_HOVER_ICON;

    public static final ImageIcon LABEL_ICON;
    public static final ImageIcon LABEL_HOVER_ICON;
    public static final ImageIcon NO_LABEL_ICON;
    public static final ImageIcon NO_LABEL_HOVER_ICON;

    public static final ImageIcon VISIBLE_ICON;
    public static final ImageIcon VISIBLE_HOVER_ICON;
    public static final ImageIcon INVISIBLE_ICON;
    public static final ImageIcon INVISIBLE_HOVER_ICON;

    public static final ImageIcon DELETE_ICON;
    public static final ImageIcon DELETE_HOVER_ICON;

    public static final ImageIcon COPY_ICON;
    public static final ImageIcon COPY_ICON_HOVER;
    public static final ImageIcon IMPORT_ICON;
    public static final ImageIcon IMPORT_ICON_HOVER;
    public static final ImageIcon EXPORT_ICON;
    public static final ImageIcon EXPORT_ICON_HOVER;
    public static final ImageIcon NEW_ROUND_ICON;
    public static final ImageIcon NEW_ROUND_ICON_HOVER;
    public static final ImageIcon DELETE_ROUND_ICON;
    public static final ImageIcon DELETE_ROUND_ICON_HOVER;

    public static final ImageIcon ARROW_LEFT_ICON;
    public static final ImageIcon ARROW_LEFT_HOVER_ICON;
    public static final ImageIcon ARROW_RIGHT_ICON;
    public static final ImageIcon ARROW_RIGHT_HOVER_ICON;

    public static final ImageIcon MINUS_ICON;
    public static final ImageIcon MINUS_HOVER_ICON;

    public static final ImageIcon ON_SWITCHER;
    public static final ImageIcon ON_SWITCHER_HOVER;
    public static final ImageIcon OFF_SWITCHER;
    public static final ImageIcon OFF_SWITCHER_HOVER;

    static {
        final BufferedImage copyImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "copy_icon.png");
        final BufferedImage copyImgHover = ImageUtil.luminanceOffset(copyImg, -100);
        COPY_ICON = new ImageIcon(copyImg);
        COPY_ICON_HOVER = new ImageIcon(copyImgHover);

        final BufferedImage importImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "import_icon.png");
        final BufferedImage importImgHover = ImageUtil.luminanceOffset(importImg, -100);
        IMPORT_ICON = new ImageIcon(importImg);
        IMPORT_ICON_HOVER = new ImageIcon(importImgHover);

        final BufferedImage exportImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "export_icon.png");
        final BufferedImage exportImgHover = ImageUtil.luminanceOffset(exportImg, -100);
        EXPORT_ICON = new ImageIcon(exportImg);
        EXPORT_ICON_HOVER = new ImageIcon(exportImgHover);

        final BufferedImage newRoundImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "new_round.png");
        final BufferedImage newRoundImgHover = ImageUtil.luminanceOffset(newRoundImg, -100);
        NEW_ROUND_ICON = new ImageIcon(newRoundImg);
        NEW_ROUND_ICON_HOVER = new ImageIcon(newRoundImgHover);

        final BufferedImage deleteRoundImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "delete_round.png");
        final BufferedImage deleteRoundImgHover = ImageUtil.luminanceOffset(deleteRoundImg, -100);
        DELETE_ROUND_ICON = new ImageIcon(deleteRoundImg);
        DELETE_ROUND_ICON_HOVER = new ImageIcon(deleteRoundImgHover);

        final BufferedImage pencilImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "pencil_color_icon.png");
        final BufferedImage pencilImgHover = ImageUtil.luminanceOffset(pencilImg, -150);
        COLOR_ICON = new ImageIcon(pencilImg);
        COLOR_HOVER_ICON = new ImageIcon(pencilImgHover);

        final BufferedImage labelImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "label_icon.png");
        final BufferedImage labelImgHover = ImageUtil.luminanceOffset(labelImg, -150);
        LABEL_ICON = new ImageIcon(labelImg);
        LABEL_HOVER_ICON = new ImageIcon(labelImgHover);

        NO_LABEL_ICON = new ImageIcon(labelImgHover);
        NO_LABEL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(labelImgHover, -100));

        final BufferedImage visibleImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "visible_icon.png");
        VISIBLE_ICON = new ImageIcon(visibleImg);
        VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

        final BufferedImage invisibleImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "invisible_icon.png");
        INVISIBLE_ICON = new ImageIcon(invisibleImg);
        INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

        final BufferedImage deleteImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "delete_icon.png");
        DELETE_ICON = new ImageIcon(deleteImg);
        DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));

        final BufferedImage arrowLeftImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "config_back_icon.png");
        final BufferedImage arrowLeftImgHover = ImageUtil.luminanceOffset(arrowLeftImg, -150);
        ARROW_LEFT_ICON = new ImageIcon(arrowLeftImg);
        ARROW_LEFT_HOVER_ICON = new ImageIcon(arrowLeftImgHover);

        final BufferedImage arrowRightImg = ImageUtil.flipImage(arrowLeftImg, true, false);
        final BufferedImage arrowRightImgHover = ImageUtil.flipImage(arrowLeftImgHover, true, false);
        ARROW_RIGHT_ICON = new ImageIcon(arrowRightImg);
        ARROW_RIGHT_HOVER_ICON = new ImageIcon(arrowRightImgHover);

        final BufferedImage removeImg = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "minus_icon.png");
        MINUS_ICON = new ImageIcon(removeImg);
        MINUS_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(removeImg, -50));

        BufferedImage onSwitcher = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "switcher_on.png");
        ON_SWITCHER = new ImageIcon(onSwitcher);
        ON_SWITCHER_HOVER = new ImageIcon(ImageUtil.alphaOffset(onSwitcher, -50));
        BufferedImage offSwitcher = ImageUtil.flipImage(
                ImageUtil.luminanceScale(
                        ImageUtil.grayscaleImage(onSwitcher),
                        0.61f
                ),
                true,
                false
        );
        OFF_SWITCHER = new ImageIcon(offSwitcher);
        OFF_SWITCHER_HOVER = new ImageIcon(ImageUtil.alphaOffset(offSwitcher, -100));
    }

    protected void setupImageIcon(JLabel iconButton, String toolTip, ImageIcon icon, ImageIcon hover_icon, Runnable function) {
        iconButton.setIcon(icon);
        iconButton.setToolTipText(toolTip);
        iconButton.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                function.run();
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                iconButton.setIcon(hover_icon);
            }

            @Override
            public void mouseExited(MouseEvent e) {
                iconButton.setIcon(icon);
            }
        });
    }
}

package com.github.jeromkiller.AttendanceCounter;

import com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea.CaptureCreationOptions;
import com.github.jeromkiller.AttendanceCounter.Util.AttendanceCounterSettings;
import com.github.jeromkiller.AttendanceCounter.game.CaptureArea;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;

import javax.inject.Inject;
import javax.swing.*;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;

import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.*;
import java.util.List;

@Slf4j
@PluginDescriptor(
	name = "E.T. - Attendance Counter"
)
public class AttendanceCounterPlugin extends Plugin
{
	private static final String PLUGIN_NAME = "Event Tools - Attendance Counter";

	@Inject
	private Client client;

	@Inject
	private AttendanceCounterSceneOverlay sceneOverlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private Gson gson;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;

	@Getter
	@Inject
	private AttendanceCounterSettings settings;

	@Getter
	private AttendanceCounterPanel panel;
    private NavigationButton navButton;

	@Getter
	private LinkedHashSet<String> playerNames = new LinkedHashSet<>();

	@Getter
	private String localPlayerName = null;

	@Getter
	private final List<CaptureArea> captureAreas = new ArrayList<>();

	@Getter
	private final CaptureCreationOptions captureCreationOptions = new CaptureCreationOptions();

	@Getter
	@Setter
	public boolean startCapturing = false;

	@Override
	protected void startUp()
	{
		overlayManager.add(sceneOverlay);
        panel = new AttendanceCounterPanel(this);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
		navButton = NavigationButton.builder()
				.tooltip(PLUGIN_NAME)
				.priority(5)
				.panel(panel)
				.icon(icon)
				.build();
		clientToolbar.addNavigation(navButton);

		loadSettings();

		panel.getAreaPanel().rebuild();
	}

	@Override
	protected void shutDown()
	{
		overlayManager.remove(sceneOverlay);
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		checkPlayersInRange();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{

	}

	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged)
	{
		loadSettings();
		SwingUtilities.invokeLater(panel.getAreaPanel()::rebuild);
	}

	private void checkPlayersInRange()
	{
		List<? extends  Player> playersList = client.getPlayers();
		Player localPlayer = client.getLocalPlayer();
		if(localPlayer == null) {
			return;
		}

		for(CaptureArea area : captureAreas)
		{
			WorldPoint playerLoc = localPlayer.getWorldLocation();
			if(playerLoc == null) {
				return;
			}

			if(area.notWorthChecking(playerLoc)) {
				continue;
			}
			for(Player player : playersList)
			{
				if(player == localPlayer)
				{
					continue;
				}

				final String playerName = player.getName();

				if(area.playerInArea(player.getWorldLocation()))
				{
					if(startCapturing) {
						playerNames.add(playerName);
						updatePlayers();
					}
				}
			}
		}
	}

	public void resetPlayers() {
		playerNames.clear();
		updatePlayers();
	}
	
	public void updatePlayers() {
		final int playerCount = playerNames.size();
		panel.getSetupPanel().setPlayerNames(playerNames);
		panel.getSetupPanel().setPlayerCount(playerCount);
	}

	public void startCaptureAreaCreation()
	{
		captureCreationOptions.setCurrentlyCreating(true);
		panel.getAreaPanel().rebuild();
	}

	public void finishCaptureAreaCreation()
	{
		final int width = (captureCreationOptions.getEast() + captureCreationOptions.getWest() + 1);
		final int height = (captureCreationOptions.getNorth() + captureCreationOptions.getSouth() + 1);
		final int xOffset = -captureCreationOptions.getWest();
		final int yOffset = -captureCreationOptions.getSouth();

		Player localPlayer = client.getLocalPlayer();
		if(null == localPlayer)
			return;
		WorldPoint playerLocation = localPlayer.getWorldLocation();
		WorldPoint swTile = playerLocation.dx(xOffset).dy(yOffset);
		CaptureArea setupArea = new CaptureArea(swTile, width, height,
				captureCreationOptions.getColor(),
				captureCreationOptions.getLabel(),
				captureCreationOptions.isLabelVisible());
		captureCreationOptions.resetOptions();

		addCaptureArea(setupArea);
		panel.getAreaPanel().rebuild();
	}

	public void cancelCaptureAreaCreation()
	{
		captureCreationOptions.resetOptions();
		panel.getAreaPanel().rebuild();
	}

	public void addCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.add(captureArea);
		updateCaptureAreas();
	}

	public void deleteCaptureArea(final CaptureArea captureArea)
	{
		captureAreas.remove(captureArea);
		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	public void updateCaptureAreas()
	{
		settings.setCaptureAreas(captureAreas);
	}

	public void loadSettings()
	{
		List<CaptureArea> areas = settings.getCaptureAreas();
		captureAreas.clear();
		captureAreas.addAll(areas);
	}

	public void copyCaptureAreaToClip(CaptureArea area)
	{
		final ArrayList<CaptureArea> exportAreas = new ArrayList<>();
		exportAreas.add(area);
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void copyVisibleCaptureAreasToClip()
	{
		ArrayList<CaptureArea> exportAreas = new ArrayList<>(captureAreas);
		exportAreas.removeIf(area -> !area.isAreaVisible());
		final String json = gson.toJson(exportAreas);
		final StringSelection selection = new StringSelection(json);
		Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
		clipboard.setContents(selection, selection);
	}

	public void importCaptureAreaFromClip() {
		String clipboardText;
		try {
			clipboardText = Toolkit.getDefaultToolkit()
					.getSystemClipboard()
					.getData(DataFlavor.stringFlavor)
					.toString();
		} catch (IOException | UnsupportedFlavorException ex) {
			sendChatMessage("Unable to read system clipboard.");
			log.warn("error reading clipboard", ex);
			return;
		}

		if (clipboardText.isEmpty())
			return;

		ArrayList<CaptureArea> importAreas;
		try {
			importAreas = gson.fromJson(clipboardText, new TypeToken<ArrayList<CaptureArea>>(){}.getType());
		}
		catch (JsonSyntaxException e) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		if(importAreas.isEmpty()) {
			sendChatMessage("You do not have any capture areas saved to the clipboard");
			return;
		}

		importAreas.removeIf(captureAreas::contains);
		captureAreas.addAll(importAreas);
		sendChatMessage("Imported " + importAreas.size() + " area(s) from clipboard");

		panel.getAreaPanel().rebuild();
		updateCaptureAreas();
	}

	private void sendChatMessage(final String message)
	{
		chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(message)
				.build());
	}
}

package com.github.jeromkiller.AttendanceCounter;

import com.github.jeromkiller.AttendanceCounter.Panels.CaptureArea.CaptureAreaManagementPanel;
import com.github.jeromkiller.AttendanceCounter.Panels.AttendancePanel;
import com.github.jeromkiller.AttendanceCounter.Panels.SettingsPanel;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;

@Getter
public class AttendanceCounterPanel extends PluginPanel {

    private final CaptureAreaManagementPanel areaPanel;
    private final AttendancePanel setupPanel;
    private final SettingsPanel settingsPanel;

    private static final ImageIcon COG_ICON;

    static {
        BufferedImage cogIcon = ImageUtil.loadImageResource(AttendanceCounterPlugin.class, "config_edit_icon.png");
        COG_ICON = new ImageIcon(cogIcon);
    }

    public AttendanceCounterPanel(AttendanceCounterPlugin plugin)
    {
        super(false);

        final int borderWidth = PluginPanel.BORDER_OFFSET;
        setBorder(new EmptyBorder(0, borderWidth, borderWidth, borderWidth));
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JTabbedPane tabPane = new JTabbedPane(JTabbedPane.TOP, JTabbedPane.SCROLL_TAB_LAYOUT);

        areaPanel = new CaptureAreaManagementPanel(plugin);
        tabPane.addTab("Areas", new JScrollPane(areaPanel));


        setupPanel = new AttendancePanel(plugin);
        tabPane.addTab("Attendance", new JScrollPane(setupPanel));

        settingsPanel = new SettingsPanel(plugin);
        tabPane.addTab("Settings", COG_ICON, settingsPanel, "Change Plugin Settings");
        tabPane.setTabComponentAt(2, new JLabel(COG_ICON));

        add(tabPane);
    }
}

package com.github.jeromkiller.AttendanceCounter;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class AttendanceCounterPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(AttendanceCounterPlugin.class);
		RuneLite.main(args);
	}
}
