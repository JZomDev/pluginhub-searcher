package com.killsperhour;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class KillsPerHourTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(KphPlugin.class);
		RuneLite.main(args);
	}
}
package com.killsperhour;


import net.runelite.api.ItemID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.ui.components.ProgressBar;
import net.runelite.client.util.*;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

class KphPanel extends PluginPanel {

    private static final String HTML_LABEL_TEMPLATE = "<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

    private final JTextField searchField = new JTextField();

    private final JLabel historicalInfoLabel = new JLabel();
    private final JLabel totalTrackedTime = new JLabel();
    private final JLabel totalTrackedKills = new JLabel();
    private final JLabel actualTotalAverageKillTime = new JLabel();
    private final JLabel actualTotalKph = new JLabel();
    private final JLabel overallFastestKill = new JLabel();
    private final JLabel sessionTimeLabel = new JLabel(htmlLabel("Session Time: ","N/A"));
    private final JLabel totalBossKillsLabel = new JLabel(htmlLabel("Kills: ","N/A"));
    private final JLabel averageKillTimeLabel = new JLabel(htmlLabel("Average Kill: ", "N/A"));
    private final JLabel fastestKillTimeLabel = new JLabel(htmlLabel("Fastest Kill: ","N/A"));
    private final JLabel killsPerHourLabel = new JLabel(htmlLabel("KPH: ","N/A"));
    private final JLabel idleTimeLabel = new JLabel(htmlLabel("Idle Time: ","N/A"));
    private final JLabel fetchedBossName = new JLabel("Unknown Boss");
    private final JLabel fetchedTotalTimeActual = new JLabel(htmlLabel("Total Session Time: ",  "N/A"));
    private final JLabel fetchedTotalTimeVirtual = new JLabel(htmlLabel("Total Boss Time: ","N/A"));
    private final JLabel fetchedTotalTrackedKills = new JLabel(htmlLabel("Tracked Kills: ","N/A"));
    private final JLabel fetchedFastestKill = new JLabel(htmlLabel("Fastest Kill: ","N/A"));
    private final JLabel fetchedKillsPerHour = new JLabel(htmlLabel("KPH: ", "N/A"));
    private final JLabel fetchedTotalBossKc = new JLabel(htmlLabel("Total KC: ","N/A"));
    private final JLabel fetchedAverageKillTime = new JLabel(htmlLabel("Average Kill: ","N/A"));
    private final JLabel estimatedTimeSpentBossing = new JLabel(htmlLabel("EST Bossing Time: ", "N/A"));
    private final JLabel lookupHeaderTitle = new JLabel("Boss Info Lookup");
    private final JLabel searchIcon = new JLabel(SEARCH_ICON);
    private final JLabel picLabel = new JLabel();
    private final JLabel fetchedIconLabel = new JLabel();
    private final JLabel startKcLabel = new JLabel("Start KC:");
    private final JLabel endKcLabel = new JLabel("End KC:");
    private final JLabel bossGoalsKphLabel = new JLabel(htmlLabel("KPH: ","N/A"));
    private final JLabel killsDoneLabel = new JLabel(htmlLabel("Kills Done: ","N/A"));
    private final JLabel killsLeftLabel = new JLabel(htmlLabel("Kills Left: ", "N/A"));
    private final JLabel timeToGoalLabel = new JLabel(htmlLabel("TTG: ", "N/A"));
    private final JLabel bossGoalsIconLabel = new JLabel();
                  JLabel currentBossNameLabel = new JLabel("Unknown Boss Name");

    private final JPanel lookupPanelHeaderContents = new JPanel();
    private final JPanel historicalInfoSection = new JPanel(new GridBagLayout());
    private final JPanel buttonIconTab;
    private final JPanel icon;
    private final JPanel fetchedIcon;
    private final JPanel closeAndTrashButtonPanel;
    private final JPanel sidePanel;
    private final JPanel titlePanel;
            final JPanel fetchedInfoPanel;

    private final JPanel lootPanel;

    private final JPanel lootHeaderPanel;

    private final JPanel bossInfoPanel;
    private final JPanel historicalInfoPanel;
    private final JPanel lookupInfoPanelHeader;
    private final JPanel pauseAndResumeButtons;
    private final JPanel sessionEndButton;
    private final JPanel supportButtons;
    private final JPanel bossGoalsInputPanel = new JPanel();
    private final JPanel goalInfoPanel = new JPanel();
    private final JPanel goalInfoPanel2 = new JPanel();
    private final JPanel progressBarPanel = new JPanel(new BorderLayout());
            final JPanel bossGoalsPanel;

    private final JToggleButton dropdownButton = new JToggleButton();
    private final JButton closeButton = new JButton(CLOSE_ICON);
    private final JButton trashButton = new JButton(TRASH_ICON);
    private final JButton searchButton = new JButton();
                  JButton pauseResumeButton = new JButton();
                  JButton switchModeButton = new JButton();

    final SpinnerNumberModel startKcModel = new SpinnerNumberModel(0, 0, 10000000, 1);
    final SpinnerNumberModel endKcModel = new SpinnerNumberModel(0, 0, 10000000, 5); //change step size to 5

    private final JSpinner startKcSpinner = new JSpinner(startKcModel);
    private final JSpinner endKcSpinner = new JSpinner(endKcModel);

    final ProgressBar progressBar = new ProgressBar();

    private static final ImageIcon TRASH_ICON;
    private static final ImageIcon TRASH_ICON_HOVER;
    private static final ImageIcon CLOSE_ICON;
    private static final ImageIcon CLOSE_ICON_HOVER;
    private static final ImageIcon SEARCH_ICON;
    private static final ImageIcon SEARCH_ICON_HOVER;
    private static final ImageIcon DROPDOWN_ICON;
    private static final ImageIcon DROPDOWN_HOVER;
    private static final ImageIcon DROPDOWN_FLIPPED_ICON;
    private static final ImageIcon DROPDOWN_FLIPPED_HOVER;
    private static final ImageIcon DISCORD_ICON;
    private static final ImageIcon DISCORD_HOVER;
    private static final ImageIcon GITHUB_ICON;
    private static final ImageIcon GITHUB_HOVER;
    private static final ImageIcon VISIBLE_ICON;
    private static final ImageIcon INVISABLE_ICON;

    private AsyncBufferedImage fetchedBossSprite;

    private final KphConfig config;

    private final KphPlugin plugin;

    private final FileReadWriter fileRW;

    private KphBossGoalsOverlay goalsOverlay;

    @Inject
    private ItemManager itemManager;

    @Inject
    private ClientThread clientThread;


    @Inject
    KphPanel(KphPlugin plugin, KphConfig config, FileReadWriter fileRW)
    {
        this.fetchedIcon = new JPanel();
        this.fetchedInfoPanel = new JPanel();
        this.closeAndTrashButtonPanel = new JPanel();
        this.sessionEndButton = new JPanel();
        this.pauseAndResumeButtons = new JPanel();
        this.supportButtons = new JPanel();
        this.sidePanel = new JPanel();
        this.titlePanel = new JPanel();
        this.bossInfoPanel = new JPanel();
        this.historicalInfoPanel = new JPanel();
        this.lookupInfoPanelHeader = new JPanel();
        this.buttonIconTab = new JPanel();
        this.lootPanel = new JPanel();
        this.lootHeaderPanel = new JPanel();
        this.bossGoalsPanel = new JPanel();
        this.icon = new JPanel();
        this.plugin = plugin;
        this.config = config;
        this.fileRW = fileRW;
    }

    void sidePanelInitializer()
    {
        this.setLayout(new BorderLayout());
        this.setBorder(new EmptyBorder(10, 10, 10, 10));
        this.sidePanel.setLayout(new BoxLayout(this.sidePanel,BoxLayout.Y_AXIS));
        this.sidePanel.add(this.buildTitlePanel());
        this.sidePanel.add(Box.createRigidArea(new Dimension(0, 5)));
        this.sidePanel.add(this.buildBossInfoPanel());
        this.sidePanel.add(this.buildBossGoalsPanel());
        this.sidePanel.add(this.buildButtonIconTab());
        this.sidePanel.add(this.buildGridTest());
        this.sidePanel.add(this.buildLootPanel());
        this.sidePanel.add(this.buildPauseAndResumebuttons());
        this.sidePanel.add(this.buildSessionEndButton());
        this.sidePanel.add(this.buildSupportbuttons());

        //ensure to build all the panels on the initial load, do not build them everytime i add or remove.
        buildFetchedInfoPanel();
        buildlookupInfoPanelHeader();
        buildHistoricalInfoPanel();

        if(!config.displayBossGoalsPanel())
        {
            bossGoalsPanel.setVisible(false);
        }

        this.add(sidePanel, "North");
    }


    JToggleButton lootHeaderButtonPanel = new JToggleButton();
    JToggleButton hideItemButton = new JToggleButton();
    JLabel gpPerHourLabel = new JLabel(htmlLabel("Gp/Hr: ","N/A"));
    JLabel gpPerKill = new JLabel(htmlLabel("Gp/Kill: ","N/A"));
    JLabel totalGpLabel = new JLabel(htmlLabel("Total Gp: ","N/A"));
    JLabel killsTrackedLabel = new JLabel(htmlLabel("Kills: ","N/A"));
    JPanel masterPanel = new JPanel();


    private JPanel buildGridTest()
    {

        masterPanel.setLayout(new BorderLayout());

        lootHeaderPanel.setLayout(new BorderLayout());
        lootHeaderPanel.setBorder(new EmptyBorder(0,0,0,0));
        lootHeaderPanel.setBorder(new MatteBorder(1, 1, 1, 1, new Color(57, 57,57)));


        JPanel lootHeaderSubContainer = new JPanel();
        JPanel bottomInfo = new JPanel();
        JPanel topInfo = new JPanel();


        lootHeaderButtonPanel.setLayout(new GridLayout(2,0,0,0));
        lootHeaderSubContainer.setLayout(new BorderLayout());
        lootHeaderSubContainer.setBorder(new MatteBorder(1, 1, 1, 1, new Color(57, 57,57)));
        bottomInfo.setLayout(new GridLayout(0,2,0,0));
        topInfo.setLayout(new BorderLayout());


        lootHeaderSubContainer.setBorder(new EmptyBorder(5,0,0,0));

        lootHeaderButtonPanel.setPreferredSize(new Dimension(200,35));

        lootHeaderButtonPanel.setBorder(new EmptyBorder(4,5,0,5));

        hideItemButton.setIcon(INVISABLE_ICON);
        hideItemButton.setSelectedIcon(VISIBLE_ICON);



        gpPerHourLabel.setFont(FontManager.getRunescapeSmallFont());
        gpPerKill.setFont(FontManager.getRunescapeSmallFont());
        totalGpLabel.setFont(FontManager.getRunescapeSmallFont());
        killsTrackedLabel.setFont(FontManager.getRunescapeSmallFont());


        SwingUtil.removeButtonDecorations(hideItemButton);
        SwingUtil.removeButtonDecorations(lootHeaderButtonPanel);
        lootHeaderButtonPanel.setRolloverEnabled(false);

        hideItemButton.setPreferredSize(new Dimension(20,18));

        hideItemButton.addActionListener(e -> clientThread.invoke(() -> updateLootGrid(lootDisplayMap())));

        lootHeaderButtonPanel.addActionListener(e -> collapseLoot());

        gpPerKill.setForeground(Color.WHITE);

        topInfo.setBorder(new EmptyBorder(0,0,0,0));

        topInfo.add(gpPerKill,"West");
        topInfo.add(hideItemButton,"East");


        killsTrackedLabel.setBorder(new EmptyBorder(0,48,0,0));

        topInfo.add(killsTrackedLabel,"Center");
        bottomInfo.add(gpPerHourLabel);
        bottomInfo.add(totalGpLabel);
        topInfo.setBackground(new Color(30, 30, 30));
        bottomInfo.setBackground(new Color(30, 30, 30));

        lootHeaderButtonPanel.add(topInfo,"North");
        lootHeaderButtonPanel.add(bottomInfo,"South");
        lootHeaderButtonPanel.setBackground(new Color(30, 30, 30));
        lootHeaderPanel.setBackground(new Color(30, 30, 30));
        lootHeaderPanel.add(lootHeaderButtonPanel);

        masterPanel.add(lootHeaderSubContainer,"North");
        masterPanel.add(lootHeaderPanel,"South");

        return masterPanel;

    }



    public Map<Integer,Integer> lootDisplayMap()
    {
        if(plugin.getPanel().fetchedInfoPanel.isShowing())
        {
           return fileRW.fetchedAllItemDrops;
        }
        else if (fileRW.cachedItemDrops != null && plugin.sessionNpc == null)
        {
            return fileRW.cachedItemDrops;
        }
        else if((!plugin.getPanel().fetchedInfoPanel.isShowing()) && (config.lootDisplay() == KphConfig.LootDisplay.ALL_TIME) && plugin.sessionNpc != null)
        {
            return fileRW.allItemDrops;
        }
        else
        {
            return fileRW.sessionItemDrops;
        }

    }



    static String doubleFormatNumber(double num)
    {
        DecimalFormat twoP = new DecimalFormat("#.##");
        DecimalFormat oneP = new DecimalFormat("#.#");
        if (num >= 1000000000) { num = num / 1000000000; return twoP.format(num) + "B"; } //1B
        if (num >= 1000000) { num = num / 1000000; return twoP.format(num) + "M"; } //1M
        if (num >= 1000) { num = num / 1000; return oneP.format(num) + "K"; } //1K
        else { return oneP.format(num); }
    }

    public double convertToGpPerHour(int kills,double Kph)
    {
      return  ((fileRW.totalGp / kills) * Kph);
    }

    public double convertToGpPerKill(int kills)
    {
        return  (fileRW.totalGp / kills);
    }


    public void updateLootHeaderInfo(int kills, double Kph)
    {
        FontMetrics fontMetrics = getFontMetrics(FontManager.getRunescapeSmallFont());
        totalGpLabel.setText(htmlLabel("Total Gp: ",doubleFormatNumber(fileRW.totalGp)));
        gpPerHourLabel.setText(htmlLabel("GP/Hr: ",doubleFormatNumber(convertToGpPerHour(kills,Kph))));
        gpPerKill.setText(htmlLabel("GP/Kill: ",doubleFormatNumber(convertToGpPerKill(kills))));
        if (fileRW.totalGp == 0) { kills = 0; }
        killsTrackedLabel.setText(htmlLabel("Kills: ", String.valueOf(kills)));
        killsTrackedLabel.setBorder(new EmptyBorder(0,  535 - fontMetrics.stringWidth(gpPerKill.getText())  ,0,0));
    }


    public void collapseLoot()
    {
        lootPanel.setVisible(!lootHeaderButtonPanel.isSelected());
    }




    private static final int ITEMS_PER_ROW = 5;
    private static final Dimension ITEM_SIZE = new Dimension(40, 40);

    public void updateLootGrid(Map<Integer,Integer> lootMap)
    {
        for (Map.Entry<Integer, Integer> entry : lootMap.entrySet())
        {
            double itemPrice = itemManager.getItemPrice(entry.getKey());
            itemPrice = itemPrice * entry.getValue();
            fileRW.itemAndTotalPrice.put(entry.getKey(),itemPrice);
        }
        SwingUtilities.invokeLater(() -> lootGrid(lootMap));
    }

    JPanel containerPanel = new JPanel();


    public void lootGrid(Map<Integer,Integer> lootMap)
    {
        fileRW.loadIgnoredList(provideBossName());
        HashMap<Integer, Integer> sorted = new HashMap<>();
        if (!fileRW.itemAndTotalPrice.isEmpty())
        {
            sorted = fileRW.sortByValue(fileRW.itemAndTotalPrice,lootMap);
        }

        JPanel containerCurrent = new JPanel();

       // HashMap<Integer, Integer> sorted = fileRW.sortByValue(fileRW.itemAndTotalPrice,lootMap);

        int totalItems;

        if(hideItemButton.isSelected() || fileRW.ignored == null)
        {
            totalItems = sorted.keySet().size();
        }
        else
        {
            totalItems = sorted.keySet().size() - fileRW.ignored.size();
        }


        containerPanel.setBorder(new EmptyBorder(2, 2, 5, 2));
        containerCurrent.setBorder(new EmptyBorder(2, 2, 5, 2));


        // Calculates how many rows need to be display to fit all items
        final int rowSize = ((totalItems % ITEMS_PER_ROW == 0) ? 0 : 1) + totalItems / ITEMS_PER_ROW;
        containerPanel.setLayout(new GridLayout(rowSize, ITEMS_PER_ROW, 1, 1));
        containerCurrent.setLayout(new GridLayout(rowSize, ITEMS_PER_ROW, 1, 1));


       // Create stacked items from the item list, calculates total price and then displays all the items in the UI.
        for (Integer key : sorted.keySet())
        {
            final JPanel slot = new JPanel();
            slot.setLayout(new GridLayout(1, 1, 0, 0));
            slot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            slot.setPreferredSize(ITEM_SIZE);

            final JLabel itemLabel = new JLabel();

            clientThread.invoke(() -> itemLabel.setToolTipText(buildToolTip(key,lootMap)));
            itemLabel.setVerticalAlignment(SwingConstants.CENTER);
            itemLabel.setHorizontalAlignment(SwingConstants.CENTER);

            AsyncBufferedImage itemImage = itemManager.getImage( key,  sorted.get(key),  sorted.get(key) > 1);
            itemImage.addTo(itemLabel);


            final JPopupMenu popupMenu = new JPopupMenu();
            itemLabel.setComponentPopupMenu(popupMenu);

            final JMenuItem toggle = new JMenuItem("Toggle item");
            toggle.addActionListener(e ->
            {
                fileRW.loadIgnoredList(provideBossName());
                if(fileRW.ignored.contains(key))
                {
                    fileRW.ignored.remove(key);
                }
                else
                {
                    fileRW.ignored.add(key);
                }

                fileRW.writeIgnoredListToFile(provideBossName());
                clientThread.invoke(() -> updateLootGrid(lootMap));
            });


            fileRW.loadIgnoredList(provideBossName());
            if(!fileRW.ignored.contains(key) || hideItemButton.isSelected())
            {
                popupMenu.add(toggle);

                if(fileRW.ignored.contains(key))
                {
                    Runnable addTransparency = () ->
                    {
                        BufferedImage transparentImage = ImageUtil.alphaOffset(itemImage, .3f);
                        itemLabel.setIcon(new ImageIcon(transparentImage));
                    };
                    itemImage.onLoaded(addTransparency);
                    addTransparency.run();
                }
                slot.add(itemLabel);
                containerCurrent.add(slot);

            }

        }



        if(totalItems < 5 || totalItems % 5 != 0)
        {
            int extraBoxes;
            if(totalItems % 5 != 0 && totalItems >= 5)
            {
                int i = totalItems;
                while (i % 5 != 0)
                {
                    i++;
                }
                extraBoxes = i - totalItems;
            }
            else
            {
                extraBoxes = 5 - totalItems;
            }

            for (int i = 0; i < extraBoxes; i++)
            {
                final JPanel slot = new JPanel();
                slot.setLayout(new GridLayout(1, 1, 0, 0));
                slot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                slot.setPreferredSize(ITEM_SIZE);

                containerCurrent.add(slot);
            }
        }

        lootPanel.remove(containerPanel);
        this.containerPanel = containerCurrent;
        lootPanel.add(containerPanel);

        fileRW.getTotalPrice();






        //clean this up. make sure it does not trigger twice causes issues

        if(plugin.getPanel().fetchedInfoPanel.isShowing())
        {
            updateLootHeaderInfo(fileRW.lootKillsTracked,fileRW.fetchedKillsPerHour);
        }

        if((!plugin.getPanel().fetchedInfoPanel.isShowing()) && (config.lootDisplay() == KphConfig.LootDisplay.ALL_TIME))
        {
            fileRW.setFilename(plugin.currentBoss);
            fileRW.fetchLookupInfo();
            updateLootHeaderInfo(fileRW.lootKillsTracked,fileRW.fetchedKillsPerHour);
        }

        if((!plugin.getPanel().fetchedInfoPanel.isShowing()) && (config.lootDisplay() == KphConfig.LootDisplay.SESSION))
        {
            updateLootHeaderInfo(plugin.killsThisSession,Double.parseDouble(plugin.formatKPH()));
        }

        if (!plugin.getPanel().fetchedInfoPanel.isShowing() && plugin.sessionNpc == null && plugin.cacheHasInfo)
        {
            updateLootHeaderInfo(plugin.cachedSessionKills,Double.parseDouble(plugin.cachedKPH));
        }





        lootPanel.revalidate();
        lootPanel.repaint();
    }


    public String provideBossName()
    {
        if(plugin.getPanel().fetchedInfoPanel.isShowing())
        {
            return searchInput;
        }
        else
        {
            return plugin.currentBoss;
        }
    }

    private String buildToolTip(int key,Map<Integer,Integer> lootMap)
    {
        final String name = itemManager.getItemComposition(key).getName();
        final int quantity = lootMap.get(key);
        final long price = itemManager.getItemPrice(key);

        return "<html>" + name + " x " + QuantityFormatter.formatNumber(quantity)
                + "<br/>Price: " + QuantityFormatter.quantityToStackSize(price)
                + "<br/>Total: " + QuantityFormatter.quantityToStackSize(quantity * price) + "</html>";
    }




    private JPanel buildLootPanel()
    {
        lootPanel.setLayout(new BorderLayout());
        lootPanel.setBorder(new EmptyBorder(0, 0, 8, 0));
        lootPanel.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));
        return lootPanel;
    }







    int killsDone;
    int totalKillsToGet;
    int killsLeft;
    double TTG;
    double percentDone;

    //this empty label is needed to make sure the txt is centered on the progress bar *don't ask me how or why it works, its magic*
    //private final JLabel magicCenteringLabel = new JLabel();

    public void updateBossGoalsPanel()
    {
        if(plugin.sessionNpc == null)
        {
            return;
        }

        if(fileRW.startKc == 0 && fileRW.endKc == 0)
        {
            bossGoalsKphLabel.setText(htmlLabel("KPH: ","N/A"));
            killsDoneLabel.setText(htmlLabel("Kills Done: ","N/A"));
            killsLeftLabel.setText(htmlLabel("Kills Left: " ,"N/A"));
            timeToGoalLabel.setText(htmlLabel("TTG: ", "N/A"));
            KphBossInfo kphBossInfo = KphBossInfo.find(plugin.sessionNpc);
            itemManager.getImage(kphBossInfo.getIcon()).addTo(bossGoalsIconLabel);
            bossGoalsIconLabel.setVisible(true);
            goalInfoPanel.setBorder(new EmptyBorder(5, 0, 0, 17));
            progressBar.setLeftLabel("");
            progressBar.setRightLabel("");
            progressBar.setCenterLabel("Set a goal");
            progressBar.setValue(0);
            progressBar.setDimmed(false);
            return;

        }

        DecimalFormat df = new DecimalFormat("#.#");

        killsDone = plugin.killCount - fileRW.startKc;

        totalKillsToGet = fileRW.endKc - fileRW.startKc;

        killsLeft = totalKillsToGet - killsDone;

        TTG = killsLeft / plugin.killsPerHour;

        percentDone = 100 * ((double) killsDone / (double) totalKillsToGet);

        if(killsLeft <= 0)
        {
            bossGoalsKphLabel.setText(htmlLabel("KPH: ",plugin.formatKPH()));
            killsDoneLabel.setText(htmlLabel("Kills Done: ",String.valueOf(totalKillsToGet)));
            killsLeftLabel.setText(htmlLabel("Kills Left: ","0"));
            timeToGoalLabel.setText(htmlLabel("TTG: ","00:00:00"));
            progressBar.setCenterLabel("Completed");
            progressBar.setValue(100);

        }
        else
        {
            bossGoalsKphLabel.setText(htmlLabel("KPH: ",plugin.formatKPH()));
            killsDoneLabel.setText(htmlLabel("Kills Done: ",String.valueOf(killsDone)));
            killsLeftLabel.setText(htmlLabel("Kills Left: ",String.valueOf(killsLeft)));
            timeToGoalLabel.setText(htmlLabel("TTG: ",plugin.timeConverter((int)(TTG * 3600))));

            percentDone = Double.parseDouble(df.format(percentDone));
            progressBar.setCenterLabel(percentDone + "%");
            progressBar.setValue((int)percentDone);
        }


        if(config.displayRelativeKills())
        {
            progressBar.setLeftLabel(String.valueOf(0));
            progressBar.setRightLabel(String.valueOf(totalKillsToGet));
        }
        else
        {
            progressBar.setLeftLabel(String.valueOf(fileRW.startKc));
            progressBar.setRightLabel(String.valueOf(fileRW.endKc));
        }

        int length;

        FontMetrics fontMetrics = getFontMetrics(FontManager.getRunescapeSmallFont());
        boolean killsDoneIsLonger = (fontMetrics.stringWidth(killsLeftLabel.getText()) < fontMetrics.stringWidth(killsDoneLabel.getText()));

        if(killsDoneIsLonger){length = fontMetrics.stringWidth(killsDoneLabel.getText());}
        else {length = fontMetrics.stringWidth(killsLeftLabel.getText());}

        int offset;
        offset = 521 - length;
        goalInfoPanel.setBorder(new EmptyBorder(5, 0, 0, offset));


        KphBossInfo kphBossInfo = KphBossInfo.find(plugin.sessionNpc);
        itemManager.getImage(kphBossInfo.getIcon()).addTo(bossGoalsIconLabel);

        bossGoalsIconLabel.setVisible(true);
        progressBar.setForeground(new Color(91, 154, 47));
        progressBar.setDimmed(false);

        if(plugin.paused)
        {
            progressBar.setCenterLabel("Paused");
            progressBar.setForeground(new Color(167, 125, 38));
        }

        progressBar.repaint();

    }


    private JPanel buildBossGoalsPanel()
    {
        bossGoalsPanel.setLayout(new BorderLayout());

        bossGoalsPanel.setBorder(new EmptyBorder(0, 10, 0, 10));

        bossGoalsPanel.setBorder(new MatteBorder(1, 1, 1, 1, new Color(49, 49, 49)));


        progressBarPanel.setBorder(new EmptyBorder(5, 5, 7, 5));


        progressBar.setBackground(new Color(61, 56, 49));
        progressBar.setForeground(new Color(91, 154, 47));


        progressBar.setMaximumValue(100);
        progressBar.setCenterLabel(percentDone + "%");
        progressBar.setValue((int)percentDone);


        progressBarPanel.add(progressBar);
        progressBarPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        JMenuItem setBossGoalMenuItem = new JMenuItem("Set Boss Goal");
        setBossGoalMenuItem.addActionListener(e -> bossGoalsOptionPane());

        JMenuItem resetBossGoalMenuItem = new JMenuItem("Reset Boss Goal");
        resetBossGoalMenuItem.addActionListener(e -> fileRW.resetBossGoal());

        JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));

        popupMenu.add(setBossGoalMenuItem);
        popupMenu.add(resetBossGoalMenuItem);


        bossGoalsPanel.setComponentPopupMenu(popupMenu);



        JPanel iconPanel = new JPanel(new GridBagLayout());


        iconPanel.setLayout(new GridLayout(0, 1, 0, 0));
        //this controls the offset of the current boss name, useful for alinging the icon
        iconPanel.setBorder(new EmptyBorder(5, 5, 0, 0));



        bossGoalsKphLabel.setFont(FontManager.getRunescapeSmallFont());
        killsDoneLabel.setFont(FontManager.getRunescapeSmallFont());
        timeToGoalLabel.setFont(FontManager.getRunescapeSmallFont());
        killsLeftLabel.setFont(FontManager.getRunescapeSmallFont());



        goalInfoPanel.setLayout(new GridLayout(2, 0, 0, 0));
        goalInfoPanel.setBorder(new EmptyBorder(5, 0, 0, 17));

        goalInfoPanel2.setLayout(new GridLayout(2, 0, 0, 0));
        goalInfoPanel2.setBorder(new EmptyBorder(5, 3, 0, 3));

        //placeholder image used to keep spaceing consistnat
        bossGoalsIconLabel.setIcon(new ImageIcon(itemManager.getImage(ItemID.YOUNGLLEF)));
        bossGoalsIconLabel.setVisible(false);

        //sets the continer panel to opaque or not, false = transparent, this will only affect the assingned panel. it will not affect any other content or panel within said panel.
        iconPanel.setOpaque(false);
        goalInfoPanel.setOpaque(false);
        goalInfoPanel2.setOpaque(false);
        progressBarPanel.setOpaque(false);

        //adds the lables to the respective panel in the order they are added
        iconPanel.add(bossGoalsIconLabel);
        goalInfoPanel2.add(bossGoalsKphLabel);
        goalInfoPanel.add(killsDoneLabel);
        goalInfoPanel2.add(timeToGoalLabel);
        goalInfoPanel.add(killsLeftLabel);

        bossGoalsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        bossGoalsPanel.add(goalInfoPanel2);
        bossGoalsPanel.add(goalInfoPanel,"East");
        bossGoalsPanel.add(iconPanel, "West");
        bossGoalsPanel.add(progressBarPanel,"South");

        return bossGoalsPanel;
    }






    private JPanel buildlookupInfoPanelHeader()
    {


                //change vgap to move title
        lookupPanelHeaderContents.setLayout(new GridLayout(0, 1, 0, 5));
        lookupPanelHeaderContents.setBorder(new EmptyBorder(0, 0, 10, 20));

        searchField.setBackground(new Color(57, 57,57));
        searchField.setBorder(new MatteBorder(1, 1, 1, 1, new Color(30, 30, 30)));

        searchField.setMaximumSize(new Dimension(167,20));
        searchField.setMinimumSize(new Dimension(167,20));
        searchField.setPreferredSize(new Dimension(167,20));


        searchField.addActionListener(e -> fetchLookupInfo());


        lookupInfoPanelHeader.setLayout(new BorderLayout());
        lookupInfoPanelHeader.setBorder(new EmptyBorder(5, 0, 4, 0));
        lookupInfoPanelHeader.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));


        searchIcon.setBorder(new EmptyBorder(13, 10, 0, 0));

        //adds the lables to the respective panel in the order they are added
        lookupHeaderTitle.setFont(FontManager.getRunescapeBoldFont());
        lookupHeaderTitle.setBorder(new EmptyBorder(0, 20, 0, 0));

        lookupPanelHeaderContents.add(lookupHeaderTitle);
        lookupPanelHeaderContents.add(searchField);

        lookupInfoPanelHeader.add(searchIcon,"West");
        lookupInfoPanelHeader.add(lookupPanelHeaderContents,"East");
        return lookupInfoPanelHeader;
    }




    String searchInput;

    public void fetchLookupInfo()
    {
        searchInput = searchField.getText();

        if(KphBossInfo.bossByWords.containsKey(searchInput.toLowerCase()))
        {
           searchInput = KphBossInfo.bossByWords.get(searchInput.toLowerCase());
        }

        fileRW.setFilename(searchInput);
        fileRW.fetchLookupInfo();

        for (KphBossInfo bossIconFinder : KphBossInfo.values())
        {
            if (searchInput.toLowerCase().equals(bossIconFinder.getName().toLowerCase()))
            {
                KphBossInfo kphBossInfo =  KphBossInfo.find(bossIconFinder.getName());
                AsyncBufferedImage bossSprite = itemManager.getImage(kphBossInfo.getIcon());
                ImageIcon imageIcon = new ImageIcon(bossSprite);

                fetchedBossName.setText(kphBossInfo.getName());

                FontMetrics fontMetrics = getFontMetrics(FontManager.getRunescapeBoldFont());
                int offset = 150 - (fontMetrics.stringWidth(fetchedBossName.getText()));
                fetchedIconLabel.setBorder(new EmptyBorder(0, 0, 0,offset + 15));

                fetchedIconLabel.setIcon(imageIcon);
                fetchedIconLabel.setVisible(true);
                break;
            }
            else
            {
                fetchedBossName.setText("Unknown Boss");
                fetchedIconLabel.setVisible(false);
            }

        }

        updateLookupInfo();


    }

    public void updateLookupInfo()
    {
        if(fileRW.fetchedFile == null || !fileRW.fetchedFile.exists())
        {
            setLookupInfoToNull();
            getFetchedLoot();
            return;
        }

        fileRW.fetchedStatConverter();
        fetchedFastestKill.setText(htmlLabel("Fastest Kill: ",plugin.timeConverter(fileRW.fetchedFastestKill)));
        fetchedTotalTrackedKills.setText(htmlLabel("Tracked Kills: ",String.valueOf(fileRW.fetchedTotalTrackedKills)));
        fetchedTotalTimeActual.setText(htmlLabel("Total Session Time: ",plugin.timeConverter(fileRW.fetchedTotalTimeActual)));
        fetchedTotalTimeVirtual.setText(htmlLabel("Total Boss Time: ", plugin.timeConverter(fileRW.fetchedTotalTimeVirtual)));
        fetchedKillsPerHour.setText(htmlLabel("KPH: ",String.valueOf(fileRW.fetchedKillsPerHour)));
        fetchedTotalBossKc.setText(htmlLabel("Total KC: ",String.valueOf(fileRW.fetchedTotalBossKc)));
        fetchedAverageKillTime.setText(htmlLabel("Average Kill: ", plugin.timeConverter(fileRW.fetchedAverageKillTime)));
        estimatedTimeSpentBossing.setText(htmlLabel("EST Bossing Time: ", plugin.timeConverter(fileRW.estimatedTimeSpentBossing)));

        getFetchedLoot();

    }


    private Map<Integer,Integer> currentLootTable = new HashMap<>();

    public void getFetchedLoot()
    {
        fileRW.lootDirectory = new File(fileRW.file, "boss-loot");
        fileRW.subDirectory = new File(fileRW.lootDirectory, searchInput + ".json");
        fileRW.loadFetchedDropsFromMap();
       // fileRW.loadIgnoredList(searchInput);
        if(fileRW.fetchedFile == null || !fileRW.fetchedFile.exists())
        {
            fileRW.fetchedAllItemDrops = new HashMap<Integer, Integer>();
            fileRW.ignored = new ArrayList<Integer>();
        }
        fileRW.itemAndTotalPrice = new HashMap<Integer, Double>();

        fileRW.loadIgnoredList(provideBossName());

        clientThread.invoke(() -> updateLootGrid(lootDisplayMap()));

    }


    public void setLookupInfoToNull()
    {
        fetchedFastestKill.setText(htmlLabel("Fastest Kill: ","N/A"));
        fetchedTotalTrackedKills.setText(htmlLabel("Tracked Kills: ", "N/A"));
        fetchedTotalTimeActual.setText(htmlLabel("Total Session Time: ", "N/A"));
        fetchedTotalTimeVirtual.setText(htmlLabel("Total Boss Time: ", "N/A"));
        fetchedKillsPerHour.setText(htmlLabel("KPH: ", "N/A"));
        fetchedTotalBossKc.setText(htmlLabel("Total KC: ", "N/A"));
        fetchedAverageKillTime.setText(htmlLabel("Average Kill: ", "N/A"));
        estimatedTimeSpentBossing.setText(htmlLabel("EST Bossing Time: ", "N/A"));
    }

    

    private JPanel buildFetchedInfoPanel()
    {
        fetchedInfoPanel.setLayout(new BorderLayout());
        fetchedInfoPanel.setBorder(new EmptyBorder(0, 0, 0, 10));

        JPanel fetchedInfoSection = new JPanel();
        fetchedInfoSection.setLayout(new GridLayout(9, 0, 0, 10));
        fetchedInfoSection.setBorder(new EmptyBorder(15, 5, 3, 0));

        closeButton.setMaximumSize(new Dimension(30,25));
        closeButton.setPreferredSize(new Dimension(30,25));
        closeButton.setMinimumSize(new Dimension(30,25));
        closeButton.setBorder(new EmptyBorder(0, 0, 0, 7));
        closeButton.setRolloverIcon(CLOSE_ICON_HOVER);
        closeButton.setToolTipText("Exit to Main Panel");
        closeButton.addActionListener(e -> closeBossLookupPanels());
        SwingUtil.removeButtonDecorations(closeButton);

        closeAndTrashButtonPanel.setLayout(new BorderLayout());
        closeAndTrashButtonPanel.add(closeButton,"East");


        trashButton.setMaximumSize(new Dimension(30,25));
        trashButton.setPreferredSize(new Dimension(30,25));
        trashButton.setMinimumSize(new Dimension(30,25));
        trashButton.setBorder(new EmptyBorder(0, 0, 2, 0));
        trashButton.setRolloverIcon(TRASH_ICON_HOVER);
        trashButton.setToolTipText("Delete Boss Info");

        trashButton.addActionListener(e -> deleteFile());

        SwingUtil.removeButtonDecorations(trashButton);

        closeAndTrashButtonPanel.add(trashButton,"West");


        //adds the lables to the respective panel in the order they are added
        fetchedBossName.setFont(FontManager.getRunescapeBoldFont());
        fetchedBossName.setForeground(new Color(219, 219, 219));
        fetchedIcon.add(fetchedIconLabel);
        fetchedInfoSection.add(fetchedBossName);
        fetchedInfoSection.add(fetchedKillsPerHour);
        fetchedInfoSection.add(fetchedTotalTrackedKills);
        fetchedInfoSection.add(fetchedTotalBossKc);
        fetchedInfoSection.add(fetchedAverageKillTime);
        fetchedInfoSection.add(fetchedFastestKill);
        fetchedInfoSection.add(fetchedTotalTimeVirtual);
        fetchedInfoSection.add(fetchedTotalTimeActual);
        fetchedInfoSection.add(estimatedTimeSpentBossing);
        fetchedInfoPanel.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));

        fetchedIcon.setOpaque(false);
        fetchedInfoSection.setOpaque(false);


        fetchedInfoPanel.add(fetchedIcon,"East");
        fetchedInfoPanel.add(closeAndTrashButtonPanel,"South");
        fetchedInfoPanel.add(fetchedInfoSection, "West");

        return fetchedInfoPanel;
    }



    public static BufferedImage resizeImage(BufferedImage image, int newWidth, int newHeight)
    {
        BufferedImage scaledImage = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics g = scaledImage.createGraphics();
        g.drawImage(image, 0, 0, newWidth, newHeight, null);
        g.dispose();
        return scaledImage;
    }


    int startKC;
    int endKC;

    public void bossGoalsOptionPane()
    {

        fileRW.getCurrentBossKCGoal();

        startKcSpinner.setBounds(0,0,50,20);
        startKcSpinner.setMaximumSize(new Dimension(100,20));
        startKcSpinner.setPreferredSize(new Dimension(100,20));
        startKcSpinner.setMinimumSize(new Dimension(100,20));

        endKcSpinner.setMaximumSize(new Dimension(100,20));
        endKcSpinner.setPreferredSize(new Dimension(100,20));
        endKcSpinner.setMinimumSize(new Dimension(100,20));

        //endKcSpinner.setToolTipText("+/- 5");
        endKcSpinner.addChangeListener(e -> getRelativeGoal());

        bossGoalsInputPanel.setBorder(new EmptyBorder(0, 0, 5, 0));
        bossGoalsInputPanel.setLayout(new GridLayout(0,2,0,5));

        bossGoalsInputPanel.setMaximumSize(new Dimension(100,20));
        bossGoalsInputPanel.setPreferredSize(new Dimension(100,20));
        bossGoalsInputPanel.setMinimumSize(new Dimension(100,20));

        startKcLabel.setMaximumSize(new Dimension(120,20));
        startKcLabel.setPreferredSize(new Dimension(120,20));
        startKcLabel.setMinimumSize(new Dimension(120,20));

        endKcLabel.setMaximumSize(new Dimension(120,20));
        endKcLabel.setPreferredSize(new Dimension(120,20));
        endKcLabel.setMinimumSize(new Dimension(120,20));

        endKcLabel.setBorder(new EmptyBorder(0, 0, 0, 20));
        startKcLabel.setBorder(new EmptyBorder(0, 0, 0, 20));

        bossGoalsInputPanel.add(startKcLabel);
        bossGoalsInputPanel.add(startKcSpinner);
        bossGoalsInputPanel.add(endKcLabel);
        bossGoalsInputPanel.add(endKcSpinner);


        KphBossInfo kphBossInfo =  KphBossInfo.find(plugin.sessionNpc);
        AsyncBufferedImage bossSprite = itemManager.getImage(kphBossInfo.getIcon());
        ImageIcon imageIcon = new ImageIcon(resizeImage(bossSprite,50,44));

        UIManager.put("OptionPane.minimumSize",new Dimension(250,100));

        int option = JOptionPane.showOptionDialog(null, bossGoalsInputPanel, "Set Boss KC Goal", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE,imageIcon, null, null);

        if (option == JOptionPane.OK_OPTION)
        {

            startKC = (int) startKcSpinner.getValue();
            endKC = (int) endKcSpinner.getValue();
            fileRW.updateBossKCGoal();
            updateBossGoalsPanel();
        }

    }

    public void getRelativeGoal()
    {
        endKcSpinner.setToolTipText("+" + ((int) endKcSpinner.getValue() - (int) startKcSpinner.getValue()));
    }

    public void deleteFile()
    {
        if(fileRW.fetchedFile.exists())
        {
            int confirm = JOptionPane.showConfirmDialog(
                    KphPanel.this,
                    "Are you sure you want to permanently delete these files",
                    "Warning", JOptionPane.OK_CANCEL_OPTION);

            if (confirm == 0)
            {
               //SwingUtilities.invokeLater(this::deleteTest);
               deleteTest();
            }
        }
        else
        {

        }

    }


    public void deleteTest()
    {

        try
        {
            Files.delete(fileRW.lookupPath);
            fileRW.fetchedAllItemDrops = new HashMap<Integer, Integer>();
            fileRW.ignored = new ArrayList<Integer>();

                try
                {
                    Writer writer = new FileWriter(fileRW.subDirectory);
                    writer.write("[]");
                    writer.close();
                }
                catch (Exception ex)
                {
                    ex.printStackTrace();
                }


            try
            {
                Writer writer = new FileWriter(fileRW.ignoreDirectory);
                writer.write("[]");
                writer.close();
            }
            catch (Exception ex)
            {
                ex.printStackTrace();
            }

        }
        catch (Exception Io)
        {
            Io.printStackTrace();

        }

    }



    


    public void closeBossLookupPanels()
    {
        sidePanel.remove(fetchedInfoPanel);
        sidePanel.remove(lookupInfoPanelHeader);
        sidePanel.add(bossInfoPanel);
        sidePanel.add(buttonIconTab);
        sidePanel.add(bossGoalsPanel);
        sidePanel.setComponentZOrder(bossInfoPanel,2);
        sidePanel.setComponentZOrder(bossGoalsPanel,3);
        sidePanel.setComponentZOrder(buttonIconTab,4);
        sidePanel.setComponentZOrder(lootHeaderPanel,5);
        sidePanel.setComponentZOrder(lootPanel,6);
        sidePanel.revalidate();

        fileRW.loadIgnoredList(plugin.currentBoss);


        clientThread.invoke(() -> updateLootGrid(lootDisplayMap()));
    }

    public void openBossLookupPanels()
    {
        sidePanel.remove(buttonIconTab);
        sidePanel.remove(bossInfoPanel);
        sidePanel.remove(historicalInfoPanel);
        sidePanel.remove(bossGoalsPanel);
        sidePanel.add(lookupInfoPanelHeader);
        sidePanel.add(fetchedInfoPanel);
        sidePanel.setComponentZOrder(lookupInfoPanelHeader,2);
        sidePanel.setComponentZOrder(fetchedInfoPanel,3);
        sidePanel.setComponentZOrder(lootHeaderPanel,4);
        sidePanel.setComponentZOrder(lootPanel,5);
        sidePanel.setComponentZOrder(pauseAndResumeButtons,6);
        sidePanel.setComponentZOrder(sessionEndButton,7);
        dropdownButton.setSelected(false);
        sidePanel.revalidate();

        fetchLookupInfo();
    }


    public void openCurrentHistoricalData()
    {
        sidePanel.add(historicalInfoPanel);
        sidePanel.setComponentZOrder(buttonIconTab,4);
        sidePanel.setComponentZOrder(historicalInfoPanel,5);
        sidePanel.revalidate();
        fillHistoricalData();
    }

    public void fillHistoricalData()
    {
        historicalInfoLabel.setText("Historical Information");
        totalTrackedTime.setText(htmlLabel("Time Tracked: ",plugin.timeConverter(fileRW.overallTime)));
        totalTrackedKills.setText(htmlLabel("Kills Tracked: ",String.valueOf(fileRW.newTotalKills)));
        actualTotalAverageKillTime.setText(htmlLabel("Average Kill: ",plugin.timeConverter(fileRW.averageKillTime)));
        actualTotalKph.setText(htmlLabel("KPH: ",String.valueOf(fileRW.killsPerHour)));
        overallFastestKill.setText(htmlLabel("Fastest Kill: ",plugin.timeConverter(fileRW.newFastestKill)));
    }

    public void closeCurrentHistoricalData()
    {
        sidePanel.remove(historicalInfoPanel);
        sidePanel.revalidate();
    }


    private JPanel buildHistoricalInfoPanel()
    {
        historicalInfoPanel.setLayout(new BorderLayout());
        historicalInfoPanel.setBorder(new EmptyBorder(0, 10, 8, 10));
        historicalInfoPanel.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));

        historicalInfoSection.setLayout(new GridLayout(6, 0, 0, 10));
        historicalInfoSection.setBorder(new EmptyBorder(10, 5, 10, 0));

        historicalInfoLabel.setFont(FontManager.getRunescapeBoldFont());

        //sets the continer panel to opaque or not, false = transparent, this will only affect the assingned panel. it will not affect any other content or panel within said panel.
        historicalInfoSection.setOpaque(false);

        //adds the lables to the respective panel in the order they are added
        historicalInfoSection.add(historicalInfoLabel);
        historicalInfoSection.add(actualTotalKph);
        historicalInfoSection.add(totalTrackedKills);
        historicalInfoSection.add(actualTotalAverageKillTime);
        historicalInfoSection.add(totalTrackedTime);
        historicalInfoSection.add(overallFastestKill);

        historicalInfoPanel.add(historicalInfoSection, "West");

        return historicalInfoPanel;
    }

    public void setHistoricalInfo()
    {
        if(dropdownButton.isSelected())
        {
            fillHistoricalData();
        }
    }



    private JPanel buildTitlePanel()
    {
        titlePanel.setBorder(new CompoundBorder(new EmptyBorder(5, 0, 0, 0), new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141))));
        titlePanel.setLayout(new BorderLayout());
        PluginErrorPanel errorPanel = new PluginErrorPanel();
        errorPanel.setBorder(new EmptyBorder(2, 0, 3, 0));
        errorPanel.setContent("Bossing Info", "Provides various bossing statistics & utilities");
        titlePanel.add(errorPanel, "Center");
        return titlePanel;
    }




    private JPanel buildBossInfoPanel()
    {
        bossInfoPanel.setLayout(new BorderLayout());

        bossInfoPanel.setBorder(new EmptyBorder(0, 0, 4, 0));

        JPanel sessionInfoSection = new JPanel(new GridBagLayout());
        sessionInfoSection.setBackground(ColorScheme.DARKER_GRAY_COLOR);


        sessionInfoSection.setLayout(new GridLayout(7, 1, 0, 10));

        sessionInfoSection.setBorder(new EmptyBorder(10, 5, 3, 0));

        currentBossNameLabel.setFont(FontManager.getRunescapeBoldFont());

        icon.setLayout(new GridLayout(0, 2, 0, 0));
        icon.setBorder(new EmptyBorder(0, 0, 180, 150));


        //sets the continer panel to opaque or not, false = transparent, this will only affect the assingned panel. it will not affect any other content or panel within said panel.
        icon.setOpaque(false);
        sessionInfoSection.setOpaque(false);


        //adds the lables to the respective panel in the order they are added
        icon.add(picLabel);
        sessionInfoSection.add(currentBossNameLabel);
        sessionInfoSection.add(killsPerHourLabel);
        sessionInfoSection.add(totalBossKillsLabel);
        sessionInfoSection.add(averageKillTimeLabel);
        sessionInfoSection.add(fastestKillTimeLabel);
        sessionInfoSection.add(idleTimeLabel);
        sessionInfoSection.add(sessionTimeLabel);

        bossInfoPanel.add(picLabel,"East");
        bossInfoPanel.add(sessionInfoSection, "West");


        return bossInfoPanel;
    }


    public void setBossIcon(String bossName)
    {
        if(plugin.sessionNpc != null)
        {
            KphBossInfo kphBossInfo = KphBossInfo.find(bossName);
            AsyncBufferedImage bossSprite = itemManager.getImage(kphBossInfo.getIcon());
            ImageIcon imageIcon = new ImageIcon(bossSprite);

            FontMetrics fontMetrics = getFontMetrics(FontManager.getRunescapeBoldFont());
            int offset = 150 - (fontMetrics.stringWidth(plugin.sessionNpc) - 15);
            picLabel.setBorder(new EmptyBorder(0, 0, 153,offset ));
            picLabel.setIcon(imageIcon);
        }
    }


    private JPanel buildButtonIconTab()
    {
        searchButton.setIcon(SEARCH_ICON);
        searchButton.setRolloverIcon(SEARCH_ICON_HOVER);

        dropdownButton.setIcon(DROPDOWN_ICON);
        dropdownButton.setRolloverIcon(DROPDOWN_HOVER);
        dropdownButton.setSelectedIcon(DROPDOWN_FLIPPED_ICON);
        dropdownButton.setRolloverSelectedIcon(DROPDOWN_FLIPPED_HOVER);


        dropdownButton.setPreferredSize(new Dimension(35, 20));
        dropdownButton.setMaximumSize(new Dimension(35, 20));
        dropdownButton.setMinimumSize(new Dimension(35, 20));

        dropdownButton.setToolTipText("Opens Historical Info");

        //removes the box around the button
        SwingUtil.removeButtonDecorations(dropdownButton);
        SwingUtil.removeButtonDecorations(searchButton);

        //links button press to method call
        dropdownButton.addActionListener((e) -> {
            if (dropdownButton.isSelected())
            {
                openCurrentHistoricalData();
            }
            else if (!dropdownButton.isSelected())
            {
                closeCurrentHistoricalData();
            }

        });

        searchButton.addActionListener(e -> openBossLookupPanels());
        searchButton.setToolTipText("Open Boss Lookup");


        buttonIconTab.setLayout(new BorderLayout());
        buttonIconTab.setBorder(new EmptyBorder(0, 0, 0, 0));
        buttonIconTab.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));

        buttonIconTab.setOpaque(false);

        buttonIconTab.add(dropdownButton,"West");
        buttonIconTab.add(searchButton,"East");

        return buttonIconTab;
    }




    private JPanel buildPauseAndResumebuttons()
    {
        pauseAndResumeButtons.setLayout(new BorderLayout());

        pauseAndResumeButtons.setBorder(new EmptyBorder(4, 5, 0, 10));

        JPanel myButtons = new JPanel(new GridBagLayout());

        myButtons.setLayout(new GridLayout(1, 2, 5, 0));

        myButtons.setBorder(new EmptyBorder(5, 5, 0, 0));

        switchModeButton = new JButton("     Actual     ");

        switchModeButton.setToolTipText("Switches your information display mode");
        pauseResumeButton = new JButton("      Pause     ");


        pauseResumeButton.addActionListener((e) ->
        {
            if (plugin.paused)
            {
                plugin.sessionResume();
            }
            else
            {
                plugin.sessionPause();
            }
        });

        switchModeButton.addActionListener((e) ->
        {

            switch (plugin.getCalcMode())
            {
                case 0:
                    plugin.setCalcMode(1);
                    switchModeButton.setText("    Virtual     ");
                    plugin.calcKillsPerHour();
                    switchHistoricalInfo();
                    updateLookupInfo();
                    updateBossGoalsPanel();
                    break;
                case 1:
                    plugin.setCalcMode(0);
                    switchModeButton.setText("     Actual     ");
                    plugin.calcKillsPerHour();
                    switchHistoricalInfo();
                    updateLookupInfo();
                    updateBossGoalsPanel();
                    break;

            }

        });


        myButtons.add(pauseResumeButton);
        myButtons.add(switchModeButton);

        pauseAndResumeButtons.add(myButtons, "West");


        return pauseAndResumeButtons;
    }

    public void switchHistoricalInfo()
    {
        if(plugin.sessionNpc != null)
        {
            fileRW.statConverter();
            setHistoricalInfo();
        }

    }




    //uses the default browser on the machine to open the attached link (my discord for support & my github)
    public void discordLink()
    {
        try { Desktop.getDesktop().browse(new URI("https://discord.gg/ATXSsbbXQV")); }
        catch (IOException | URISyntaxException e1) { e1.printStackTrace(); }
    }

    public void githubLink()
    {
        try { Desktop.getDesktop().browse(new URI("https://github.com/Mrnice98/KillsPerHour")); }
        catch (IOException | URISyntaxException e1) { e1.printStackTrace(); }
    }



    private JPanel buildSessionEndButton()
    {
        this.sessionEndButton.setLayout(new BorderLayout());

        this.sessionEndButton.setBorder(new EmptyBorder(0, 5, 8, 10));

        //adds a matte border
        this.sessionEndButton.setBorder(new MatteBorder(0, 0, 1, 0, new Color(37, 125, 141)));

        JPanel myButton = new JPanel(new GridBagLayout());

        myButton.setLayout(new GridLayout(1, 2, 5, 5));

        myButton.setBorder(new EmptyBorder(3, 10, 8, 0));

        JButton endButton = new JButton("                 End Session                  ");

        endButton.addActionListener(e -> plugin.sessionEnd());

        myButton.add(endButton);

        this.sessionEndButton.add(myButton, "West");

        return this.sessionEndButton;
    }



    private JPanel buildSupportbuttons()
    {
        //sets the main panles layout
        supportButtons.setLayout(new BorderLayout());
        //sets the main panels border
        supportButtons.setBorder(new EmptyBorder(4, 5, 0, 10));

        //creates the sub panel which the buttons are contained in
        JPanel myButtons = new JPanel(new GridBagLayout());
        myButtons.setLayout(new GridLayout(1, 2, 8, 0));
        myButtons.setBorder(new EmptyBorder(10, 5, 0, 0));

        //creates the individual buttons and assings there text or icon ect...
        JButton discordButton = new JButton(DISCORD_ICON);
        JButton githubButton = new JButton(GITHUB_ICON);

        //sets what happens when the botton is hovered over
        discordButton.setRolloverIcon(DISCORD_HOVER);
        githubButton.setRolloverIcon(GITHUB_HOVER);

        //sets the buttons prefered size (can be finkiky)
        discordButton.setPreferredSize(new Dimension(23, 25));
        githubButton.setPreferredSize(new Dimension(20, 23));

        //removes the box around the button
        SwingUtil.removeButtonDecorations(githubButton);
        SwingUtil.removeButtonDecorations(discordButton);

        //links button press to method call
        githubButton.addActionListener(e -> githubLink());
        discordButton.addActionListener(e -> discordLink());

        //adds buttons to JPanel
        myButtons.add(githubButton);
        myButtons.add(discordButton);

        //adds Panel to master/main panel
        supportButtons.add(myButtons, "East");

        return supportButtons;
    }




    public void setSessionTimeLabel()
    {
        SwingUtilities.invokeLater(() -> sessionTimeLabel.setText(htmlLabel("Session time: ",plugin.timeConverter(plugin.totalSessionTime))));
    }

    public void setSessionInfo()
    {
        if(plugin.sessionNpc != null)
        {
            killsPerHourLabel.setText(htmlLabel("KPH: ",plugin.formatKPH()));
            averageKillTimeLabel.setText(htmlLabel("Average Kill: ",plugin.avgKillTimeConverter()));
            totalBossKillsLabel.setText(htmlLabel("Kills: ",String.valueOf(plugin.killsThisSession)));
            idleTimeLabel.setText(htmlLabel("Idle Time: ",plugin.timeConverter(plugin.timeSpentIdle)));
            currentBossNameLabel.setText(plugin.sessionNpc);
            fastestKillTimeLabel.setText(htmlLabel("Fastest Kill: ",plugin.timeConverter(plugin.fastestKill)));
            if(!plugin.paused)
            {
                currentBossNameLabel.setForeground(new Color(71, 226, 12));
            }

        }

        if(plugin.sessionNpc == null && plugin.cacheHasInfo)
        {
            killsPerHourLabel.setText(htmlLabel("KPH: ",plugin.cachedKPH));
            averageKillTimeLabel.setText(htmlLabel("Average Kill: ", plugin.cachedAvgKillTime));
            totalBossKillsLabel.setText(htmlLabel("Kills: ", String.valueOf(plugin.cachedSessionKills)));
            idleTimeLabel.setText(htmlLabel("Idle Time: ", plugin.cachedIdleTime));
            currentBossNameLabel.setText(plugin.cachedSessionNpc);
            fastestKillTimeLabel.setText(htmlLabel("Fastest Kill: ",plugin.cachedFastestKill));
            currentBossNameLabel.setForeground(new Color(187, 187, 187));
        }

    }


    public void updateKphMethod()
    {
        killsPerHourLabel.setText("KPH: " + plugin.formatKPH());
    }

    public void setBossNameColor()
    {
        currentBossNameLabel.setForeground(new Color(227, 160, 27));
    }

    static String htmlLabel(String key, String valueStr)
    {
        return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), key, valueStr);
    }

    static
    {
        BufferedImage trashPNG = ImageUtil.loadImageResource(KphPlugin.class, "/trash_icon.png");
        BufferedImage closePNG = ImageUtil.loadImageResource(KphPlugin.class, "/close_icon.png");
        BufferedImage searchPNG = ImageUtil.loadImageResource(KphPlugin.class, "/search_icon.png");
        BufferedImage dropdownFlippedPNG = ImageUtil.loadImageResource(KphPlugin.class, "/dropdown_flipped_icon.png");
        BufferedImage dropdownPNG = ImageUtil.loadImageResource(KphPlugin.class, "/dropdown_icon.png");
        BufferedImage discordPNG = ImageUtil.loadImageResource(KphPlugin.class, "/discord_icon.png");
        BufferedImage githubPNG = ImageUtil.loadImageResource(KphPlugin.class, "/github_icon.png");
        BufferedImage visiblePNG = ImageUtil.loadImageResource(KphPlugin.class, "/visible_icon.png");
        BufferedImage invisiblePNG = ImageUtil.loadImageResource(KphPlugin.class, "/invisible_icon.png");

        VISIBLE_ICON = new ImageIcon(visiblePNG);
        INVISABLE_ICON = new ImageIcon(invisiblePNG);

        TRASH_ICON = new ImageIcon(trashPNG);
        TRASH_ICON_HOVER = new ImageIcon(ImageUtil.luminanceOffset(trashPNG, -80));

        CLOSE_ICON = new ImageIcon(closePNG);
        CLOSE_ICON_HOVER = new ImageIcon(ImageUtil.luminanceOffset(closePNG, -80));

        SEARCH_ICON = new ImageIcon(searchPNG);
        SEARCH_ICON_HOVER = new ImageIcon(ImageUtil.luminanceOffset(searchPNG, -80));

        DROPDOWN_FLIPPED_ICON = new ImageIcon(dropdownFlippedPNG);
        DROPDOWN_FLIPPED_HOVER = new ImageIcon(ImageUtil.luminanceOffset(dropdownFlippedPNG, -80));

        DROPDOWN_ICON = new ImageIcon(dropdownPNG);
        DROPDOWN_HOVER = new ImageIcon(ImageUtil.luminanceOffset(dropdownPNG, -80));

        DISCORD_ICON = new ImageIcon(discordPNG);
        DISCORD_HOVER = new ImageIcon(ImageUtil.luminanceOffset(discordPNG, -80));

        GITHUB_ICON = new ImageIcon(githubPNG);
        GITHUB_HOVER = new ImageIcon(ImageUtil.luminanceOffset(githubPNG, -80));

    }

}

/*
 * Copyright (c) 2020, MrNice98
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.killsperhour;

import com.google.inject.Provides;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.client.game.LootManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.loottracker.LootReceived;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.loottracker.LootRecordType;
import org.apache.commons.lang3.time.DurationFormatUtils;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.text.DecimalFormat;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.List;

import static net.runelite.client.RuneLite.RUNELITE_DIR;


@PluginDescriptor(
        name = "Bossing Info",
        description = "Tracks statistics such as kills per hour and time bossed at various bosses.",
        tags = {"PVM", "kills per hour","kph","boss","info","boss utilities","boss util","util","utilities","kill times"}
)
public class KphPlugin extends Plugin
{
    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private InfoBoxManager infoBoxManager;

    @Inject
    private KphOverlay overlay;

    @Inject
    private KphConfig config;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private Client client;

    @Inject
    private KphSpecialMethods sMethods;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private FileReadWriter fileRW;

    @Inject
    private KphBossGoalsOverlay kphBossGoalsOverlay;

    @Getter
    private KphPanel panel;

    @Inject
    private LootManager lootManager;

    @Inject
    private ClientThread clientThread;


    private KphInfobox infobox;

    private NavigationButton navButton;

    private BufferedImage icon;

    private Instant startTime;
    private Instant totalSessionStart = Instant.now();
    private Instant timeoutStart;
    private Instant pauseStart;
    private Instant killTimerStart;


    final String supremeMessage = "Your Dagannoth Supreme kill count is:";
    final String rexMessage = "Your Dagannoth Rex kill count is:";
    final String primeMessage = "Your Dagannoth Prime kill count is:";


    private int delayTicks;
    private int timerOffset;
    private int pauseTime;
    private int firstKillTime;
    private int attkCount;

    private final int[] cmRegions = {13138, 13137, 13139, 13141, 13136, 13145, 13393, 13394, 13140, 13395, 13397};
    private final int[] regGauntletRegion = {7512};
    private final int[] cGauntletRegion = {7768};
    private final int[] gargBossRegion = {6727};
    private final int[] fightCaveRegion = {9551};
    private final int[] infernoRegion = {9043};


    boolean cacheHasInfo;

    private NPC lastAttackedBoss;
    private NPC currentNPC;

    NPC lastValidBoss;

    String message;
    String sessionNpc;
    String currentBoss;

    Instant primeStart;
    Instant rexStart;
    Instant supremeStart;
    Instant barrowsStart;
    Instant sireStart;
    Instant krakenStart;


    Collection<ItemStack> itemStacks;


    int lastKillTotalTime_0; //no-display bosses
    int lastKillTotalTime_1; //display bosses

    double killsPerHour;
    int totalTime;
    int averageKillTime;

    int killCount;
    int killsThisSession;
    int totalKillTime;
    int totalBossKillTime;
    int totalSessionTime;
    int timeSpentIdle;
    int primeAttkTimout = 21;
    int rexAttkTimout = 21;
    int supremeAttkTimout = 21;

    int lastAttkTimeout = 99999;

    int startKC;
    int endKC;



    // 0 = Take idle into account & 1 = Dont take idle into account
    @Getter
    @Setter
    int calcMode;
    boolean paused;


//                                                OPERATIONAL METHODS USED TO POWER THE PLUGIN
//######################################################################################################################################################


    String bossName;


    @Subscribe
    public void onLootReceived(final LootReceived event)
    {
        if (event.getType() != LootRecordType.NPC && event.getType() != LootRecordType.EVENT)
        {
            return;
        }

        if (killsThisSession == 1 && !fileRW.sessionItemDrops.isEmpty())
        {
            fileRW.sessionItemDrops.clear();
        }

        itemStacks = event.getItems();
        bossName = event.getName();
        fileRW.lootReceived();
    }





    //Does what it says
    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        switch (configChanged.getKey())
        {
            case "KPH Calc Method":
                panel.updateKphMethod();
                panel.updateBossGoalsPanel();
                break;

            case "Side Panel":
                if(config.showSidePanel())
                {
                    clientToolbar.addNavigation(navButton);
                }
                else
                {
                    clientToolbar.removeNavigation(navButton);
                }
                break;

            case "Side Panel Position":
                if(config.showSidePanel())
                {
                    clientToolbar.removeNavigation(navButton);
                    navButton = NavigationButton.builder()
                            .tooltip("Bossing Info")
                            .icon(icon)
                            .priority(config.sidePanelPosition())
                            .panel(panel)
                            .build();
                    clientToolbar.addNavigation(navButton);;
                }
                break;

            case "Dagannoth Selector":
                if(sessionNpc != null)
                {
                    if(sessionNpc.equals("Dagannoth Kings")
                      || sessionNpc.equals("Dagannoth Prime")
                      || sessionNpc.equals("Dagannoth Supreme")
                      || sessionNpc.equals("Dagannoth Rex"))
                    {
                        sessionEnd();
                    }
                }
                break;

            case "Infobox":
                if(config.renderInfobox())
                {
                    addInfoBox();
                }
                else
                {
                    infoBoxManager.removeInfoBox(infobox);
                }
                break;

            case "Display relative kills":
                if(sessionNpc != null)
                {
                    panel.updateBossGoalsPanel();
                }
                break;

            case "Display Boss Goals Panel":
                panel.bossGoalsPanel.setVisible(config.displayBossGoalsPanel());
                break;

            case "Loot Display":
                if(!panel.fetchedInfoPanel.isShowing())
                {
                    clientThread.invoke(() -> panel.updateLootGrid(panel.lootDisplayMap()));
                }
                break;

        }

    }

    //INTEGRITY MAINTAINER
    @Subscribe
    public void onGameStateChanged(GameStateChanged gameStateChanged)
    {
        if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
        {
            File mainFolder = new File(RUNELITE_DIR,"bossing-info");
            File file = new File(mainFolder, String.valueOf(client.getAccountHash()));
            if (client.getUsername() == null && !file.exists())
            {
                chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("<col=ff0000>[Bossing Info]<col=707070>Please do one boss kill on old Java client to migrate your info for Jagex Accounts<col=ffff00>").build());
            }

        }

       if(gameStateChanged.getGameState() == GameState.HOPPING || gameStateChanged.getGameState() == GameState.LOGGING_IN)
       {
           attkCount = 0;
           delayTicks = 0;
           nullStartTimesForSpecialBosses();
       }

        if(gameStateChanged.getGameState() == GameState.LOGIN_SCREEN)
       {
           sessionPause();
       }
    }


    @Subscribe
    public void onChatMessage(ChatMessage chatMessage)
    {

        Player player = client.getLocalPlayer();

        if(player == null || delayTicks < 5)
        {
            return;
        }

        if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE || chatMessage.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION || chatMessage.getType() == ChatMessageType.SPAM)
        {
            canRun = false;
            this.message = chatMessage.getMessage();
            chatMessageFilter();
            sMethods.sireTimeClac();
            if(paused)
            {
                return;
            }
            bossKc();
            bossKillTime();
            chatMessageQueue();
        }
    }

    String kcMessage;
    String timeMessage;
    public void chatMessageQueue()
    {
        if(kcMessage != null && timeMessage != null)
        {
            canRun = true;
            chatDisplayBossMethod(currentBossName);
            chatDisplayKillTimeGetter();
            calcKillsPerHour();

            kcMessage = null;
            timeMessage = null;

            //needs to be after nulling the msgs
            printCurrentKph();
        }

    }


    boolean autoResumed;

    public void chatMessageFilter()
    {
        if(paused)
        {
            for (KphBossInfo bossIdentifier : KphBossInfo.values())
            {
                if (message.contains(bossIdentifier.getKcIdentifier()))
                {
                    sessionResume();
                    autoResumed = true;
                    break;
                }

            }

            for (String message : KphBossInfo.timeMessages)
            {
                if (this.message.contains(message))
                {
                    sessionResume();
                    autoResumed = true;
                    break;
                }

            }

        }

    }

    //something like from when the first hit to last death animation ect and calculate using that.
    //count from in game drop messages matching booster or team-mates names

    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
    {
        if (hitsplatApplied.getActor() instanceof NPC)
        {
            NPC npc = (NPC)hitsplatApplied.getActor();

            if(hitsplatApplied.getHitsplat().isMine())
            {
                lastAttackedBoss = npc;

                KphBossInfo kphBossInfo = KphBossInfo.find(lastAttackedBoss.getName());

                if(kphBossInfo != null && kphBossInfo.getDisplayType() == 0)
                {
                    lastAttkTimeout = 0;
                    lastValidBoss = lastAttackedBoss;

                    sMethods.dagTimeClac();

                    attkCount++;
                    if (attkCount == 1)
                    {
                        currentNPC = lastValidBoss;

                        setAttkTimeout();

                        setKillTimeStart();
                    }


                    if (currentNPC.getName() != null && lastValidBoss.getName() != null)
                    {
                        if(!currentNPC.getName().equals(lastValidBoss.getName()) && lastValidBoss.getId() != NpcID.VETION_6612)
                        {
                            attkCount = 1;
                            setKillTimeStart();
                            currentNPC = lastValidBoss;
                            setAttkTimeout();
                        }
                    }
                }
            }
        }
    }



    public void setKillTimeStart()
    {
        if(sMethods.dagChecker())
        {
            killTimerStart = sMethods.dagTimeClac();
            return;
        }
        if(sMethods.barrowsChecker())
        {
            killTimerStart = sMethods.barrowsTimeClac();
            return;
        }
        if(sMethods.sireChecker() && sireStart != null)
        {
            killTimerStart = sireStart;
            return;
        }
        if(sMethods.krakenChecker())
        {
            killTimerStart = sMethods.krakenTimeClac();
            return;
        }
        else
        {
            killTimerStart = Instant.now();
        }
    }


    int stoper = 0;
    public void bossKilled()
    {
        if(lastValidBoss != null)
        {
            if(lastValidBoss.isDead() && stoper == 0)
            {
                if(lastValidBoss.getId() != NpcID.KALPHITE_QUEEN_963 && lastValidBoss.getId() != NpcID.VETION_6612)
                {
                    sMethods.dagTimeClearTwo();
                    attkCount = 0;
                }
                stoper = 1;
            }

            if(!lastValidBoss.isDead() && stoper == 1)
            {
                stoper = 0;
            }
        }
    }


    int attkTimeout;

    public void setAttkTimeout()
    {
        KphBossInfo kphBossInfo = KphBossInfo.find(currentNPC.getName());
        attkTimeout = kphBossInfo.getAttkTimeout();
    }



    //UPDATER / FETCHER
    private int ticks;

    @Subscribe
    public void onGameTick(GameTick gameTick)
    {
        primeAttkTimout++;
        rexAttkTimout++;
        supremeAttkTimout++;

        delayTicks++;
        ticks++;
        bossKilled();

        if(attkCount > 0 || timesAreNotNull())
        {
            lastAttkTimeout++;

            if(lastAttkTimeout == attkTimeout)
            {
                attkTimedOut();
            }

        }

        if(ticks == 2)
        {
            ticks = 0;
            if(killsThisSession > 0 && !paused && config.timeoutTime() != 0)
            {
              sessionTimeoutTimer();
            }
        }

    }




    public boolean timesAreNotNull()
    {
        return barrowsStart != null || sireStart != null;
    }



    public void attkTimedOut()
    {
        attkCount = 0;
        if(krakenStart != null)
        {
            sMethods.krakenTimeClear();
        }
        if(barrowsStart != null)
        {
            sMethods.barrowsTimeClear();
        }
        if(sireStart != null)
        {
            sMethods.sireTimeClear();
        }


    }



//END SECTION
//###############################################################################################################################################################



//                                                                  INITIALIZERS / BUILDERS
//##################################################################################################################################################################
    public void addInfoBox()
    {
        if(config.renderInfobox() && sessionNpc != null)
        {
            KphBossInfo kphBossInfo = KphBossInfo.find(sessionNpc);
            infoBoxManager.removeInfoBox(infobox);
            BufferedImage image = itemManager.getImage(kphBossInfo.getIcon());
            infobox = new KphInfobox(image, this,config, OverlayPosition.DETACHED);
            infoBoxManager.addInfoBox(infobox);
        }

    }

    private void buildSidePanel()
    {
        panel = injector.getInstance(KphPanel.class);
        panel.sidePanelInitializer();
        icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
        navButton = NavigationButton.builder().tooltip("Bossing Info").icon(icon).priority(config.sidePanelPosition()).panel(panel).build();
        if (config.showSidePanel())
        {
            clientToolbar.addNavigation(navButton);
        }
    }


//END SECTION
//###############################################################################################################################################################




//                               BOSS TIME KILL TIME IDENTIFIERS FOR BOSSES WHICH DISPLAY TIME
//##################################################################################################################################################################

    boolean canRun;

    //gets the killtime of the last kill as displayed in the chat and if selected calls for the banking time to be calculated
    public int bossKillTime()
    {
        //FIGHT DURATION CHAT IDENTIFIER, FOR BOSSESS WHO OUTPUT IN THAT FORMAT.
        if(message.contains("Fight duration:"))
        {
            message = message.substring(message.indexOf("Fight duration:"));
            timeMessage = message;
            return 0;
        }

        if(message.contains("Duration:"))
        {
            if(Arrays.equals(client.getMapRegions(), fightCaveRegion) || Arrays.equals(client.getMapRegions(), infernoRegion))
            {
                timeMessage = message;
                return 0;
            }
        }

        //Chambers identifier
        // all bossess who output with duration before kc message need to follow same example as chambers
        if(message.contains("Congratulations - your raid is complete!"))
        {
            message = message.substring(message.indexOf("Duration:</col>") + 15);

            timeMessage = message;
            return 0;
        }

        if(message.contains("Corrupted challenge duration:"))
        {

            timeMessage = message;
            return 0;
        }

        if(message.contains("Challenge duration:"))
        {
            timeMessage = message;
            return 0;
        }

        if(message.contains("Theatre of Blood total completion time: "))
        {
            message = message.substring(message.indexOf("time: ") + 5);

            timeMessage = message;
            return 0;
        }

        if (message.contains("Tombs of Amascut total completion time:")
        || message.contains("Tombs of Amascut: Expert Mode total completion time:"))
        {
            timeMessage = message;
            return 0;
        }


        else
            return 0;



    }


//END OF SECTION
//##########################################################################################################################################


    public void chatDisplayBossMethod(String bossName)
    {
        updateSessionInfoCache();

        canRun = true;
        killsThisSession++;

        if(killsThisSession == 1)
        {
            sessionNpc = bossName; //must make sure all boss identifiers set session npc before the session initalizer
            sessionInitializer();
        }
        currentBoss = bossName;
        sessionChecker();
        killCount = getKillCount();
    }

    public void nonChatDisplayBossMethod(String bossName)
    {
        updateSessionInfoCache();

        killsThisSession++;
        if(killsThisSession == 1)
        {
            sessionNpc = bossName;
            sessionInitializer();
            firstKillTime = generalTimer(killTimerStart);
        }

        currentBoss = bossName;
        //clears times for special bosses
        conditionalTimeClear();
        killCount = getKillCount();
        noDisplayKillTimeGetter();
        sessionChecker();
        canRun = true;

        timeMessage = null;
        kcMessage = null;
    }



//                                               BELOW IS THE BOSS IDENTIFICATION SECTION
//#########################################################################################################################################

    //CHAT DISPLAY BOSSES LISTED BELOW
    //keeps track of the kills done during the session and calls the session checker to make sure the session is still valid

    String currentBossName;

    public void bossKc()
    {


        for (KphBossInfo bossIdentifier : KphBossInfo.values())
        {
            if (message.contains(bossIdentifier.getKcIdentifier()))
            {
                if(bossIdentifier.getDisplayType() == 1)
                {
                    kcMessage = message;
                    currentBossName = bossIdentifier.getName();
                }
                else
                {
                    nonChatDisplayBossMethod(bossIdentifier.getName());
                    calcKillsPerHour();
                    printCurrentKph();
                }

                break;
            }

        }


//------------------------------------------------NON-DISPLAY BOSSES BELOW----------------------------------------------------------------------

        //Special case bosses

        //Daggonoth kings
        if((message.contains(rexMessage) || message.contains(primeMessage) || message.contains(supremeMessage)) && config.dksSelector() == KphConfig.DksSelector.Kings
        || (message.contains(rexMessage) && config.dksSelector() == KphConfig.DksSelector.Rex)
        || (message.contains(primeMessage) && config.dksSelector() == KphConfig.DksSelector.Prime)
        || (message.contains(supremeMessage) && config.dksSelector() == KphConfig.DksSelector.Supreme))
        {
            updateSessionInfoCache();
            killsThisSession++;

            if(killsThisSession == 1)
            {
                sessionNpc = "Dagannoth " + config.dksSelector().toString();
                sessionInitializer();
                firstKillTime = generalTimer(killTimerStart);
            }

            currentBoss = "Dagannoth " + config.dksSelector().toString();
            sMethods.dagTimeClear();
            killCount = getKillCount();
            noDisplayKillTimeGetter();
            sessionChecker();
            canRun = true;
        }

    }

    private void conditionalTimeClear()
    {
        switch (currentBoss)
        {
            case "Barrows":
                sMethods.barrowsTimeClear();
                break;

            case "Kraken":
                sMethods.krakenTimeClear();
                break;

            case "Abyssal Sire":
                sMethods.sireTimeClear();
                break;
        }
    }


    //sets the values at a start of a new session
    private void sessionInitializer()
    {
        totalSessionStart = Instant.now();
        startTime = Instant.now();

        if(sessionNpc != null)
        {
            addInfoBox();
            panel.setBossIcon(sessionNpc);
        }

    }


//END OF SECTION
//#############################################################################################################################################





//                                                         SETTERS AND CHECKERS
//##############################################################################################################################################


    //checks to make sure the boss you are killing has not changed
    public void sessionChecker()
    {
        timeoutStart = Instant.now();
        //session changed
        if (!sessionNpc.equals(currentBoss))
        {
            sessionReset();
        }
    }


    //resets the session when you change from one boss to another
    public void sessionReset()
    {
        if(config.outputOnChange())
        {
            sessionInfoOutputMessage();
        }

        reset();
        killsThisSession = 1;

        sessionNpc = currentBoss;

        KphBossInfo kphBossInfo = KphBossInfo.find(sessionNpc);
        if(kphBossInfo.getDisplayType() == 0)
        {
            firstKillTime = generalTimer(killTimerStart);

            totalTime = firstKillTime;
            totalKillTime = firstKillTime;
            lastKillTotalTime_0 = firstKillTime;

            fastestKill = firstKillTime;

            if(lastValidBoss.getName() == null)
            {
                killTimeMessage(currentBoss);
            }

        }

        if(kphBossInfo.getDisplayType() == 1)
        {
            fastestKill = 999999;
            totalTime = bossKillTime();
        }

        addInfoBox();
        panel.setBossIcon(sessionNpc);
        startTime = Instant.now();

    }





    //ends the session setting all values to null / zero or equivelant.
    public void sessionEnd()
    {
        if(sessionNpc != null)
        {
            //Displays end of session stats in chat
            updateSessionInfoCache();
            if(config.outputOnChange())
            {
                sessionInfoOutputMessage();
            }


            reset();
            killsThisSession = 0;
            sessionNpc = null;
            currentBoss = null;
            totalTime = 0;
            totalBossKillTime = 0;
            totalKillTime = 0;
            killCount = 0;
            fastestKill = 9999999;

            infoBoxManager.removeInfoBox(infobox);
            panel.setSessionInfo();
            panel.progressBar.setDimmed(true);
            panel.progressBar.setForeground(new Color(88, 88, 88));
            panel.progressBar.setDimmedText("No Session");
            panel.progressBar.repaint();


        }

    }

    public void reset()
    {

        paused = false;
        calcMode = 0;
        pauseTime = 0;
        timeSpentIdle = 0;
        timerOffset = 0;
        attkCount = 0;

        //teststuff
        lastkillnumber = -1;

        panel.switchModeButton.setText("     Actual     ");
        panel.pauseResumeButton.setText("      Pause     ");

        nullStartTimesForSpecialBosses();

        fileRW.resetStartAndEndKc();

        timeoutStart = Instant.now();
        totalBossKillTime = bossKillTime();
        totalSessionStart = Instant.now();
    }

    public void nullStartTimesForSpecialBosses()
    {
        sireStart = null;
        primeStart = null;
        rexStart = null;
        supremeStart = null;
        barrowsStart = null;
        krakenStart = null;
    }


    //these values are fetched before any other code is run when a kill happens, that means that if a session is siwtched these values will hold the info of the last session.
     int cachedSessionKills;
     String cachedAvgKillTime;
     String cachedKPH;
     String cachedIdleTime;
     String cachedSessionTime;
     String cachedSessionNpc;
     String cachedFastestKill;

    //this updates the cache variables used to store the info chatmessage output, when this is called it gets the inforation at time of run
    public void updateSessionInfoCache()
    {

        if (!fileRW.sessionItemDrops.isEmpty())
        {
            fileRW.cachedItemDrops = fileRW.sessionItemDrops;
        }

        cacheHasInfo = true;
        cachedKPH = formatKPH();
        cachedSessionKills = killsThisSession;
        cachedAvgKillTime = avgKillTimeConverter();
        cachedIdleTime = timeConverter(timeSpentIdle);
        cachedSessionTime = timeConverter(totalSessionTime);
        cachedFastestKill = timeConverter(fastestKill);
        cachedSessionNpc = sessionNpc;
    }


    //outputs the info from session info cache the chat when session is changed or info is called.
    public void sessionInfoOutputMessage()
    {
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Session Info").build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("-------------------------").build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("KPH: " + cachedKPH).build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Kills: " + cachedSessionKills).build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Avg Kill: " + cachedAvgKillTime).build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Idle Time: " + cachedIdleTime).build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Session Time: " + cachedSessionTime).build());
        chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("-------------------------").build());
    }

    public void printCurrentKph()
    {
        if(config.printKphInChat())
        {
            client.addChatMessage(ChatMessageType.GAMEMESSAGE,"","KPH: " + "<col=ff0000>"+ formatKPH()+"</col>","");
            //chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Kph: " + formatKPH()).build());

        }
    }

    //Command to output session info into chat if at least one kill has been done since plugin was turned on. commands added at bottem
    private void infoCommand(ChatMessage chatMessage, String message)
    {
        if(cacheHasInfo)
        {
            if(sessionNpc != null)
            {
                updateSessionInfoCache();
            }
            sessionInfoOutputMessage();
        }
    }

    //Command to end the session and if the option is selected will output session info.
    private void endCommand(ChatMessage chatMessage, String message)
    {
        sessionEnd();
    }

    //Command to pause the session
    private void pauseCommand(ChatMessage chatMessage, String message)
    {
       sessionPause();
    }

    //Command to resume the session
    private void resumeCommand(ChatMessage chatMessage, String message)
    {
        sessionResume();
    }

    public void sessionPause()
    {
        if(!paused && sessionNpc != null)
        {
            chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Session Paused").build());
            paused = true;

            panel.pauseResumeButton.setText("    Resume    ");

            pauseStart = Instant.now();
            panel.setBossNameColor();
            panel.progressBar.setForeground(new Color(167, 125, 38));
            panel.progressBar.setCenterLabel("Paused");
            panel.progressBar.repaint();

        }
    }

    public void sessionResume()
    {
        if(paused)
        {
            paused = false;

            panel.pauseResumeButton.setText("      Pause     ");

            pauseTime += generalTimer(pauseStart);
            timeoutStart = Instant.now();
            nullStartTimesForSpecialBosses();
            attkCount = 0;
            panel.currentBossNameLabel.setForeground(new Color(71, 226, 12));
            panel.progressBar.setForeground(new Color(91, 154, 47));
            panel.progressBar.setCenterLabel(panel.percentDone + "%");
            panel.updateBossGoalsPanel();
            panel.progressBar.repaint();
            chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage("Session Resumed").build());
        }
    }





//END SECTION
//###############################################################################################################################################################






//                                                        CALCULATORS AND GETTERS
//##################################################################################################################################################################


    int lastkillnumber;

    int totalTrackedTime;
    double overallKph;


    //calculates the kills per hour
    public void calcKillsPerHour()
    {
        //test stuff
        if (killsThisSession != 0)
        {
            KphBossInfo kphBossInfo = KphBossInfo.find(currentBoss);
            if(kphBossInfo == null)
            {
                return;
            }
            if(calcMode == 1)
            {
                switch (kphBossInfo.getDisplayType())
                {
                    case 0:
                        totalTime = totalKillTime;
                        break;
                    case 1:
                        totalTime = totalBossKillTime;
                        break;
                }
            }

            if(calcMode == 0)
            {
                switch (kphBossInfo.getDisplayType())
                {
                    case 0:
                        totalTime = lastKillTotalTime_0;
                        break;
                    case 1:
                        totalTime = lastKillTotalTime_1;
                        break;
                }
            }


            averageKillTime = totalTime / killsThisSession;
        }
        if(averageKillTime == 0)
        {
            killsPerHour = 0;
        }
        else
        {
            killsPerHour = 3600D / averageKillTime;
        }

        timeSpentIdle();

        panel.setSessionInfo();


        //set a boolen that is set when a kill is registered to allow this to run once.
        if(currentBoss != null)
        {
            if(canRun)
            {
                fileRW.createAndUpdate();
                panel.setHistoricalInfo();
                panel.updateBossGoalsPanel();
                canRun = false;
            }
        }
        lastkillnumber = killsThisSession;
    }


    public String formatKPH()
    {
        int kph;
        switch (config.kphMethod())
        {
            case PRECISE:
                DecimalFormat df = new DecimalFormat("#.#");
                killsPerHour = Double.parseDouble(df.format(killsPerHour));
                return String.valueOf(killsPerHour);

            case ROUNDED:
                kph = (int)(Math.round(killsPerHour));
                return String.valueOf(kph);

            case ROUND_UP:
                kph = (int)(Math.ceil(killsPerHour));
                return String.valueOf(kph);

            case TRADITIONAL:
                kph = (int)killsPerHour;
                return String.valueOf(kph);

            default:
                return String.valueOf(killsPerHour);

        }
    }


    //simply calcultes the time not spent killing a boss who DOES have a time display
    public void timeSpentIdle()
    {
        if(sessionNpc != null)
        {
            KphBossInfo kphBossInfo = KphBossInfo.find(sessionNpc);

            if(kphBossInfo.getDisplayType() == 0)
            {
                timeSpentIdle = totalTime - totalKillTime;
            }
            if(kphBossInfo.getDisplayType() == 1)
            {
                timeSpentIdle = totalTime - totalBossKillTime;
            }
        }
    }


    //gets the kill time as displayed in the chat
    public int getKillTime()
    {
        String minutes;
        String seconds;
        String hours = "0";

        String trimmedMessage = timeMessage.replaceFirst("<","");
        int startOfTime = trimmedMessage.indexOf(">");
        int lastOfTime = trimmedMessage.indexOf("<");
        String sub = trimmedMessage.substring(startOfTime + 1, lastOfTime);

        if(sub.contains("."))
        {
            int endOfUsefulTime = sub.indexOf(".");
            sub = sub.substring(0, endOfUsefulTime);
        }

        sub = sub.replace(":","");
        switch (sub.length())
        {
            case 4:
                minutes = sub.substring(0,2);
                seconds = sub.substring(2);
                break;

            case 5:
                hours = sub.substring(0,1);
                minutes = sub.substring(1,2);
                seconds = sub.substring(2);
                break;

            default:
                minutes = sub.substring(0,1);
                seconds = sub.substring(1);
                break;
        }
        return Integer.parseInt(seconds) + (Integer.parseInt(minutes) * 60) + (Integer.parseInt(hours) * 3600);
    }

    public int getKillCount()
    {
        KphBossInfo kphBossInfo = KphBossInfo.find(currentBoss);
        String message = this.message;

        if(kphBossInfo.getDisplayType() == 1)
        {
            message = kcMessage;
        }


        String trimmedMessage = message.replace("<col=ff0000>","");
        trimmedMessage =  trimmedMessage.replaceAll("[^0-9]", "");
        return Integer.parseInt(trimmedMessage);
    }

    int currentKill;
    int fastestKill = 99999999;

    public void fastestKill()
    {
        if(currentKill < fastestKill)
        {
            fastestKill = currentKill;
        }
    }

    //gets the kill time as displayed in chat and saves the value to totalBossKillTime, this method is called when banking is being taken into account
    //keeps a running total of kill times for bosses who display it.
    public int getTotalBossKillTime()
    {
        totalBossKillTime += getKillTime();
        return totalBossKillTime;
    }




    //gets the kill time from the chat for bossess who display it.
    public int chatDisplayKillTimeGetter()
    {
        getTotalBossKillTime();

        currentKill = getKillTime();
        fastestKill();

        if(killsThisSession == 1 || autoResumed)
        {
            timerOffset += getKillTime();
            autoResumed = false;
        }
        totalTime = (generalTimer(startTime) + timerOffset) - pauseTime;

        lastKillTotalTime_1 = totalTime;

        return totalTime;
    }



    public void noDisplayKillTimeGetter()
    {

        totalKillTime += generalTimer(killTimerStart);

        if(autoResumed && killsThisSession != 1)
        {
            firstKillTime += generalTimer(killTimerStart);
            autoResumed = false;
        }

        totalTime = (generalTimer(startTime) + firstKillTime) - pauseTime;

        lastKillTotalTime_0 = totalTime;

        attkCount = 0;

        if(lastValidBoss.getName() != null || sessionNpc.equals("Barrows"))
        {
            if(sMethods.dagKingsCheck())
            {
                killTimeMessage(currentNPC.getName());
            }
            else
            {
                killTimeMessage(currentBoss);
            }
        }

        currentKill = generalTimer(killTimerStart);
        fastestKill();

    }

    public void killTimeMessage(String boss)
    {
        if(config.displayKillTimes())
        {
            client.addChatMessage(ChatMessageType.GAMEMESSAGE,"", boss + " Fight Duration: <col=ff0000>" + timeConverter(generalTimer(killTimerStart)),"");
        }
    }


    public boolean isBossChatDisplay()
    {
        KphBossInfo kphBossInfo = KphBossInfo.find(currentBoss);
        return kphBossInfo.getDisplayType() == 1;
    }














//END OF SECTION
//#####################################################################################################################################






//                                                          TIMER'S SECTION
//############################################################################################################################################

    //times the entire session starting from when the first kill happens, used to track bossess with and without display
    public int generalTimer(Instant start)
    {
        String elapsedFormated;
        Duration elapsed = Duration.between(start, Instant.now());
        final String formatString = "ss";
        elapsedFormated = DurationFormatUtils.formatDuration(elapsed.toMillis(), formatString, true);
        return Integer.parseInt(elapsedFormated);
    }



    //Tracks the total time you have been in a given session
    public void totalSessionTimer()
    {
        String elapsedFormated;
        Duration elapsed = Duration.between(totalSessionStart, Instant.now());
        final String formatString = "ss";
        elapsedFormated = DurationFormatUtils.formatDuration(elapsed.toMillis(), formatString, true);

        KphBossInfo kphBossInfo = KphBossInfo.find(sessionNpc);
        if(kphBossInfo.getDisplayType() == 1)
        {
            totalSessionTime = Integer.parseInt(elapsedFormated) + timerOffset - pauseTime;
        }
        else
        {                                                          //changed from banking offset to test out new method
            totalSessionTime = Integer.parseInt(elapsedFormated) + firstKillTime - pauseTime;
        }

        panel.setSessionTimeLabel();

    }


    //this is ued to calculate and keep track of the session timeout time / time since last kill
    public void sessionTimeoutTimer()
    {
        Duration offsetTime = Duration.between(timeoutStart, Instant.now());
        String offsetTimeFormated;
        final String formatString = "mm";
        offsetTimeFormated = DurationFormatUtils.formatDuration(offsetTime.toMillis(), formatString, true);

        int timeoutCount = Integer.parseInt(offsetTimeFormated);
        int timeoutTime = config.timeoutTime();

        if(timeoutCount >= timeoutTime)
        {
            sessionEnd();
        }
    }



//SECTION END
//###################################################################################################################################







//                                               TIME CONVERSION SECTION
//###################################################################################################################################


    public String avgKillTimeConverter()
    {
        String seconds;
        String minutes;
        if(averageKillTime < 60)
        {
            seconds = String.format("%02d",averageKillTime);
            minutes = "00";
        }
        else
        {
            minutes = String.format("%02d",averageKillTime / 60);
            seconds = String.format("%02d",averageKillTime % 60);
        }
        return minutes + ":" + seconds;


    }

    public String timeConverter(int time)
    {
        String seconds;
        String minutes;
        String hours;

        if(time > 3600)
        {
            hours = String.format("%02d",time / 3600);
            minutes = String.format("%02d",(time % 3600) / 60);
            seconds = String.format("%02d",time % 60);
            return hours + ":" + minutes + ":" + seconds;

        }
        if(time < 60)
        {
            seconds = String.format("%02d",time);
            minutes = "00";
        }
        else
        {
            minutes = String.format("%02d",time / 60);
            seconds = String.format("%02d",time % 60);
        }
        return minutes + ":" + seconds;

    }


//SECTION END
//#######################################################################################################################################


    @Provides
    KphConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(KphConfig.class);
    }

    @Override
    protected void startUp() throws Exception
    {
        //if i want to add a chat command just register it like this, what comes after the :: is the method call.
        chatCommandManager.registerCommandAsync("!Info", this::infoCommand);
        chatCommandManager.registerCommandAsync("!End", this::endCommand);
        chatCommandManager.registerCommandAsync("!Pause", this::pauseCommand);
        chatCommandManager.registerCommandAsync("!Resume", this::resumeCommand);

        buildSidePanel();
        //take idle time into account
        calcMode = 0;
        paused = false;
        cacheHasInfo = false;
        overlayManager.add(overlay);
        overlayManager.add(kphBossGoalsOverlay);
    }

    @Override
    protected void shutDown() throws Exception
    {
        sessionEnd();

        chatCommandManager.unregisterCommand("!Info");
        chatCommandManager.unregisterCommand("!End");
        chatCommandManager.unregisterCommand("!Pause");
        chatCommandManager.unregisterCommand("!Resume");

        clientToolbar.removeNavigation(navButton);

        infoBoxManager.removeInfoBox(infobox);
        overlayManager.remove(overlay);
        overlayManager.remove(kphBossGoalsOverlay);
    }
}

package com.killsperhour;

import com.killsperhour.FileReadWriter;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.*;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

class KphBossGoalsOverlay extends OverlayPanel
{
    private final Client client;
    private final KphConfig config;
    private final KphPlugin plugin;
    private final FileReadWriter fileRW;

    private static final int BORDER_SIZE = 2;
    private static final int XP_AND_PROGRESS_BAR_GAP = 0;
    private static final int ICON_AND_INFO_GAP = 2;
    private static final Rectangle ICON_AND_INFO_COMPONENT_BORDER = new Rectangle(2, 1, 4, 0);
    private final PanelComponent iconAndInfoPanel = new PanelComponent();
    private final ItemManager itemManager;

    @Inject
    private KphBossGoalsOverlay(Client client, KphConfig config,KphPlugin plugin, ItemManager itemManager, FileReadWriter fileRW)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        this.client = client;
        this.config = config;
        this.plugin = plugin;
        this.itemManager = itemManager;
        this.fileRW = fileRW;
        panelComponent.setBorder(new Rectangle(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE));
        iconAndInfoPanel.setBorder(ICON_AND_INFO_COMPONENT_BORDER);
        iconAndInfoPanel.setBackgroundColor(null);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Bossing info overlay"));
        this.createPanels();
    }

    private LineComponent topLine;
    private LineComponent bottomLine;
    private SplitComponent splitLineComponent;
    private ImageComponent imageComponent;
    private SplitComponent iconComponentSplitter;
    private ProgressBarComponent progressBarComponent;

    public static BufferedImage resizeImage(BufferedImage image, int newWidth, int newHeight)
    {
        BufferedImage scaledImage = new BufferedImage(newWidth, newHeight, BufferedImage.TYPE_INT_ARGB);
        Graphics g = scaledImage.createGraphics();
        g.drawImage(image, 0, 0, newWidth, newHeight, null);
        g.dispose();
        return scaledImage;
    }

    int killsDone;
    int killsLeft;
    int totalKillsToGet;
    double percentDone;
    double TTG;
    String timeTillGoal;

    public void converter()
    {

        killsDone = plugin.killCount - fileRW.startKc;

        totalKillsToGet = fileRW.endKc - fileRW.startKc;

        killsLeft = totalKillsToGet - killsDone;

        TTG = killsLeft / plugin.killsPerHour;

        percentDone = 100 * ((double) killsDone / (double) totalKillsToGet);

        timeTillGoal = plugin.timeConverter((int)(TTG * 3600));
    }

    private void createPanels()
    {

        String leftStr;
        String rightNum;
        String bottomLeftStr;
        String bottomRightNum;

        converter();

        boolean goalComplete = killsLeft <= 0;

        switch (config.topGoalOverlay())
        {

            case TTG:
                leftStr = "TTG:";
                if(goalComplete){rightNum = "00:00:00";}
                else
                rightNum = timeTillGoal;
                break;

            case KILLS_DONE:
                leftStr = "Kills Done:";
                if(goalComplete){rightNum = String.valueOf(totalKillsToGet);}
                else
                rightNum = String.valueOf(killsDone);
                break;

            case KILLS_LEFT:
                leftStr = "Kills Left:";
                if(goalComplete){rightNum = "0";}
                else
                rightNum = String.valueOf(killsLeft);
                break;

            default:
                leftStr = "KPH:";
                rightNum = String.valueOf(plugin.formatKPH());
                break;

        }

        switch (config.bottomGoalOverlay())
        {
            case KPH:
                bottomLeftStr = "KPH:";
                bottomRightNum = String.valueOf(plugin.formatKPH());
                break;

            case TTG:
                bottomLeftStr = "TTG:";
                if(goalComplete){bottomRightNum = "00:00:00";}
                else
                bottomRightNum = timeTillGoal;
                break;

            case KILLS_DONE:
                bottomLeftStr = "Kills Done:";
                if(goalComplete){bottomRightNum = String.valueOf(totalKillsToGet);}
                else
                bottomRightNum = String.valueOf(killsDone);
                break;

            default:
                bottomLeftStr = "Kills Left:";
                if(goalComplete){bottomRightNum = "0";}
                else
                bottomRightNum = String.valueOf(killsLeft);
                break;

        }


        topLine = LineComponent.builder()
                .left(leftStr)
                .right(rightNum)
                .build();

        bottomLine = LineComponent.builder()
                .left(bottomLeftStr)
                .right(bottomRightNum)
                .build();

        splitLineComponent = SplitComponent.builder()
                .first(topLine)
                .second(bottomLine)
                .orientation(ComponentOrientation.VERTICAL)
                .build();


       KphBossInfo kphBossInfo =  KphBossInfo.find(plugin.sessionNpc);

        if(kphBossInfo != null)
        {
            imageComponent = new ImageComponent(resizeImage((itemManager.getImage(kphBossInfo.getIcon())), 32, 28));
        }
        else
        {
            //cant be asked to rearrange this right now so the cabbage will stay.... for now.
            imageComponent = new ImageComponent(resizeImage((itemManager.getImage(ItemID.CABBAGE)), 32, 28));
        }


        iconComponentSplitter = SplitComponent.builder()
                .first(imageComponent)
                .second(splitLineComponent)
                .orientation(ComponentOrientation.HORIZONTAL)
                .gap(new Point(ICON_AND_INFO_GAP, 0))
                .build();

        iconAndInfoPanel.getChildren().add(iconComponentSplitter);

        progressBarComponent = new ProgressBarComponent();

        progressBarComponent.setBackgroundColor(new Color(61, 56, 49));

        if(plugin.paused)
        {
            progressBarComponent.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.TEXT_ONLY);
            progressBarComponent.setCenterLabel("Paused");
            progressBarComponent.setForegroundColor(new Color(173, 128, 29));
        }
        else
        {
            progressBarComponent.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.PERCENTAGE);
            progressBarComponent.setForegroundColor(new Color(91, 154, 47));
        }



        if(config.displayRelativeKills())
        {
            progressBarComponent.setLeftLabel(String.valueOf(0));
            progressBarComponent.setRightLabel(String.valueOf(totalKillsToGet));
        }
        else
        {
            progressBarComponent.setLeftLabel(String.valueOf(fileRW.startKc));
            progressBarComponent.setRightLabel(String.valueOf(fileRW.endKc));
        }

        if(goalComplete)
        {
            progressBarComponent.setValue(100);
            progressBarComponent.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.TEXT_ONLY);
            if(plugin.paused)
            {
                progressBarComponent.setCenterLabel("Paused");
            }
            else
            {
                progressBarComponent.setCenterLabel("Completed");
            }

        }
        else
        {
            if(!plugin.paused)
            {
                progressBarComponent.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.PERCENTAGE);
            }
            progressBarComponent.setValue(percentDone);
        }


    }



    @Override
    public Dimension render(Graphics2D graphics)
    {

        if ((plugin.killsThisSession == 0) || (fileRW.startKc == 0 && fileRW.endKc == 0) || (!config.displayBossGoalsOverlay()))
        {
            return null;
        }

        iconAndInfoPanel.getChildren().clear();


        this.createPanels();

        graphics.setFont(FontManager.getRunescapeSmallFont());

        panelComponent.getChildren().add(iconAndInfoPanel);
        panelComponent.getChildren().add(progressBarComponent);

        return super.render(graphics);
    }

    // BufferedImage overlayIcon = ImageUtil.resizeImage(itemManager.getImage(ItemID.YOUNGLLEF), 36, 32);
    //
    //        final Image resized = overlayIcon.getScaledInstance(32, 28, Image.SCALE_SMOOTH);
    //        BufferedImage toPutInComponent = ImageUtil.bufferedImageFromImage(resized);


}


package com.killsperhour;

import com.killsperhour.KphConfig;
import com.killsperhour.KphPlugin;

import javax.inject.Inject;
import java.time.Instant;

public class KphSpecialMethods
{
    @Inject
    private KphPlugin plugin;

    @Inject
    private KphConfig config;





//                                                  KRAKEN SECTION
//##################################################################################################################################

    public boolean krakenChecker()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            return (plugin.lastValidBoss.getName().equals("Kraken") || plugin.lastValidBoss.getName().equals("Enormous Tentacle"));
        }
        else
        {
            return false;
        }
    }

    public Instant krakenTimeClac()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            if(krakenChecker())
            {
                if(plugin.krakenStart == null)
                {
                    plugin.krakenStart = Instant.now();
                }
                return plugin.krakenStart;
            }
        }
        return null;
    }

    public void krakenTimeClear()
    {
        plugin.krakenStart = null;
    }


//                                              SIRE SECTION
//###################################################################################################################

    public boolean sireChecker()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            return (plugin.lastValidBoss.getName().equals("Abyssal Sire"));
        }
        else
        {
            return false;
        }
    }

    public void sireTimeClac()
    {
        if(plugin.message.contains("The Sire has been disorientated temporarily."))
        {
            if(plugin.sireStart == null)
            {
                plugin.sireStart = Instant.now();
            }
            plugin.lastAttkTimeout = 0;
            plugin.attkTimeout = 300;
        }
    }

    public void sireTimeClear()
    {
        plugin.sireStart = null;
    }


//                                                    BARROWS SECTION
//##################################################################################################################################



    public Instant barrowsTimeClac()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            if(barrowsChecker())
            {
                if(plugin.barrowsStart == null)
                {
                    plugin.barrowsStart = Instant.now();
                }
                return plugin.barrowsStart;

            }

        }
        return null;
    }

    public boolean barrowsChecker()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            return (plugin.lastValidBoss.getName().equals("Ahrim the Blighted")
                 || plugin.lastValidBoss.getName().equals("Dharok the Wretched")
                 || plugin.lastValidBoss.getName().equals("Guthan the Infested")
                 || plugin.lastValidBoss.getName().equals("Karil the Tainted")
                 || plugin.lastValidBoss.getName().equals("Torag the Corrupted")
                 || plugin.lastValidBoss.getName().equals("Verac the Defiled"));
        }
        else
        {
            return false;
        }
    }

    public void barrowsTimeClear()
    {
        plugin.barrowsStart = null;
    }


//                                               DAGGANOTH SECTION
//##################################################################################################################################


    public Instant dagTimeClac()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            switch (plugin.lastValidBoss.getName())
            {
                case "Dagannoth Prime":
                    plugin.primeAttkTimout = 0;
                    if(plugin.primeStart == null)
                    {
                        plugin.primeStart = Instant.now();
                    }
                    return plugin.primeStart;

                case "Dagannoth Rex":
                    plugin.rexAttkTimout = 0;
                    if(plugin.rexStart == null)
                    {
                        plugin.rexStart = Instant.now();
                    }
                    return plugin.rexStart;

                case "Dagannoth Supreme":
                    plugin.supremeAttkTimout = 0;
                    if(plugin.supremeStart == null)
                    {
                        plugin.supremeStart = Instant.now();
                    }
                    return plugin.supremeStart;

                default:
                    return null;
            }
        }
        return null;
    }


    public boolean dagChecker()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            return (plugin.lastValidBoss.getName().equals("Dagannoth Prime") || plugin.lastValidBoss.getName().equals("Dagannoth Rex") || plugin.lastValidBoss.getName().equals("Dagannoth Supreme"));
        }
        else
        {
            return false;
        }
    }



    public void dagTimeClear()
    {

        if(plugin.message.contains(plugin.rexMessage) || plugin.rexAttkTimout == 10)
        {
            plugin.rexStart = null;
        }
        if(plugin.message.contains(plugin.primeMessage) || plugin.primeAttkTimout == 10)
        {
            plugin.primeStart = null;
        }
        if(plugin.message.contains(plugin.supremeMessage) || plugin.supremeAttkTimout == 10)
        {
            plugin.supremeStart = null;
        }
    }


    //should work but needs testing ********************************************
    public void dagTimeClearTwo()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            switch (plugin.lastValidBoss.getName())
            {
                case "Dagannoth Prime":
                    plugin.primeStart = null;
                    break;

                case "Dagannoth Rex":
                    plugin.rexStart = null;
                    break;

                case "Dagannoth Supreme":
                    plugin.supremeStart = null;
                    break;
            }
        }
    }


    public boolean dagKingsCheck()
    {
        if(plugin.lastValidBoss.getName() != null)
        {
            return (plugin.lastValidBoss.getName().equals("Dagannoth Prime") || plugin.lastValidBoss.getName().equals("Dagannoth Rex") || plugin.lastValidBoss.getName().equals("Dagannoth Supreme")) && (config.dksSelector() == KphConfig.DksSelector.Kings);
        }
        else
        {
            return false;
        }
    }


}

/*
 * Copyright (c) 2020, MrNice98
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.killsperhour;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("averagetime")
public interface KphConfig extends Config
{

    @ConfigSection(
            name = "Display Options",
            description = "All Display Options to Choose From",
            position = 0,
            closedByDefault = true
    )
    String displaySection = "Display Options";

    @ConfigSection(
            name = "Boss Goals Settings",
            description = "Boss Goals Settings",
            position = 1,
            closedByDefault = true
    )
    String bossGoalsSettings = "Boss Goals Settings";

    @ConfigSection(
            name = "General Settings",
            description = "General Settings",
            position = 2,
            closedByDefault = false
    )
    String generalSettings = "General Settings";





//                                    DISPLAY SECTION
//#########################################################################################################
    @ConfigItem(
            position = 0,
            keyName = "Overlay",
            name = "Enable Overlay",
            description = "Enables the overlay",
            section = displaySection

    )
    default boolean enableOverlay() { return false; }

    @ConfigItem(
            position = 1,
            keyName = "Infobox",
            name = "Display Infobox",
            description = "Enables the infobox",
            section = displaySection

    )
    default boolean renderInfobox() { return true; }

    enum InfoBoxContent
    {
        KPH,
        KILLS_THIS_SESSION,
        SESSION_TIME,
        AVG_KILL,
        FASTEST_KILL,
        IDLE_TIME,
    }

    @ConfigItem(
            position = 2,
            keyName = "Infobox Content",
            name = "Infobox Content",
            description = "What metric the infobox shows",
            section = displaySection
    )
    default InfoBoxContent infoBoxContent() { return InfoBoxContent.KPH; }

    @ConfigItem(
            position = 3,
            keyName = "Average Kill Time",
            name = "Average Kill Time",
            description = "Display Average Kill Time",
            section = displaySection
    )
    default boolean averageKillTime() { return true; }

    @ConfigItem(
            position = 4,
            keyName = "Fastest Kill",
            name = "Fastest Kill",
            description = "Display Fastest Kill",
            section = displaySection
    )
    default boolean fastestKill() { return true; }

    @ConfigItem(
            position = 5,
            keyName = "Kills This Session",
            name = "Kills This Session",
            description = "Display Kills This Session",
            section = displaySection
    )
    default boolean killsThisSession() { return true; }


    @ConfigItem(
            position = 6,
            keyName = "Display Session Time",
            name = "Session Time",
            description = "Displays a running count of the session time ",
            section = displaySection
    )
    default boolean displayTotalTime() { return true; }

    @ConfigItem(
            position = 7,
            keyName = "Display Idle Time",
            name = "Idle Time",
            description = "Toggles the display for Idle time, Only works if 'Account for Idle' is enabled ",
            section = displaySection
    )
    default boolean displayIdleTime() { return false; }



//#######################################################################################################################


//                                        BOSS GOALS SECTION
//#######################################################################################################################


    @ConfigItem(
            position = 5,
            keyName = "Display Boss Goals Panel",
            name = "Display Boss Goals Panel",
            description = "Display Boss Goals Panel",
            section = bossGoalsSettings
    )
    default boolean displayBossGoalsPanel() { return true; }

    @ConfigItem(
            position = 5,
            keyName = "Display Boss Goals Overlay",
            name = "Display Boss Goals Overlay",
            description = "Display Boss Goals Overlay",
            section = bossGoalsSettings
    )
    default boolean displayBossGoalsOverlay() { return true; }

    @ConfigItem(
            position = 6,
            keyName = "Display relative kills",
            name = "Display relative kills",
            description = "Displays your Boss Goals as relative kills",
            section = bossGoalsSettings
    )
    default boolean displayRelativeKills() { return true; }


    enum TopGoalOverlay
    {
        KILLS_DONE,
        KILLS_LEFT,
        KPH,
        TTG,
    }

    @ConfigItem(
            position = 7,
            keyName = "Boss Goals Top",
            name = "Boss Goals Top",
            description = "What the top row on overlay will show",
            section = bossGoalsSettings
    )
    default TopGoalOverlay topGoalOverlay() { return TopGoalOverlay.KPH; }


    enum BottomGoalOverlay
    {
        KILLS_DONE,
        KILLS_LEFT,
        KPH,
        TTG,
    }

    @ConfigItem(
            position = 8,
            keyName = "Boss Goals Bottom",
            name = "Boss Goals Bottom",
            description = "What the bottom row on overlay will show",
            section = bossGoalsSettings
    )
    default BottomGoalOverlay bottomGoalOverlay() { return BottomGoalOverlay.TTG; }

//#######################################################################################################################


//                                        GENERAL SECTION
//#######################################################################################################################


    @ConfigItem(
            position = 0,
            keyName = "Side Panel",
            name = "Side Panel",
            description = "Enables the side panel",
            section = generalSettings
    )
    default boolean showSidePanel() { return true; }

    @ConfigItem(
            position = 1,
            keyName = "Side Panel Position",
            name = "Side Panel Position",
            description = "Panel icon position, Lower # = higher pos, Higher # = lower pos ",
            section = generalSettings
    )
    default int sidePanelPosition() { return 6; }

    @ConfigItem(
            position = 2,
            keyName = "Display Kill Duration",
            name = "Kill Duration",
            description = "Upon a kill a chat message will be added with your kill time",
            section = generalSettings

    )
    default boolean displayKillTimes() { return true; }

    @ConfigItem(
            position = 3,
            keyName = "Output Info",
            name = "Output Info",
            description = "Outputs session info when session is ended or switched",
            section = generalSettings
    )
    default boolean outputOnChange() { return false; }

    @ConfigItem(
            position = 4,
            keyName = "Kph In Chat Box",
            name = "Kph In Chat Box",
            description = "Outputs current kph to the chat box every kill",
            section = generalSettings
    )
    default boolean printKphInChat() { return false; }


    @ConfigItem(
            position = 5,
            keyName = "Session Timeout",
            name = "Session Timeout",
            description = "Set the session timeout time in minutes (set to 0 for no timeout time)",
            section = generalSettings
    )
    default int timeoutTime() { return 0; }



    //traditional = integer math, same as round down
    enum KphMethod
    {
        PRECISE,
        ROUNDED,
        ROUND_UP,
        TRADITIONAL
    }

    @ConfigItem(
            position = 6,
            keyName = "KPH Calc Method",
            name = "KPH Calc",
            description = "Allows you to choose the method KPH calculated via",
            section = generalSettings
    )
    default KphMethod kphMethod() { return KphMethod.PRECISE; }

    enum LootDisplay
    {
        SESSION,
        ALL_TIME,
    }

    @ConfigItem(
            position = 7,
            keyName = "Loot Display",
            name = "Loot Display",
            description = "Allows you to choose the method KPH calculated via",
            section = generalSettings
    )
    default LootDisplay lootDisplay() { return LootDisplay.SESSION; }

    enum DksSelector
    {
        Rex,
        Prime,
        Supreme,
        Kings
    }

    @ConfigItem(
            position = 8,
            keyName = "Dagannoth Selector",
            name = "Dagannoth Selector",
            description = "Allows you to select which Dagannoth King the plugin will track",
            section = generalSettings
    )
    default DksSelector dksSelector() { return DksSelector.Kings; }




}

package com.killsperhour;


import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.*;
import java.lang.reflect.Type;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.DecimalFormat;
import java.util.*;
import java.util.stream.Collectors;

import static net.runelite.client.RuneLite.RUNELITE_DIR;

@Singleton
public class FileReadWriter
{

    KphPlugin plugin;

    Client client;

    KphBossGoalsOverlay goalsOverlay;

    @Inject
    ItemManager itemManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private Gson gson;


    @Inject
    private FileReadWriter(KphPlugin plugin, Client client)
    {
        this.plugin = plugin;
        this.client = client;
    }


    File file;
    String boss;
    String fileName;
    Path path;
    Path lookupPath;

    int oldTotalTime;
    int oldTotalKills;

    int timeOffset;
    int newTotalTimeActual;

    int virtualTimeOffset;
    int oldTotalVirtualTime;
    int newTotalVirtualTime;

    int oldFastestKill;
    int newFastestKill;



    int lastKillTimeActual;
    int lastKillTimeVirtual;


    int newTotalKills;



    public void createAndUpdate()
    {
        createDirectory();
        createFileForBoss();
        replaceAndUpdate();
        statConverter();
    }



    @Setter
    String filename;

    int fetchedTotalTimeActual;
    int fetchedTotalTimeVirtual;
    int fetchedTotalTrackedKills;
    int fetchedFastestKill;
    int fetchedTotalBossKc;
    double fetchedKillsPerHour;

    int fetchedAverageKillTime;
    int estimatedTimeSpentBossing;

    File fetchedFile;



    Map<Integer, Integer> drops = new HashMap<Integer, Integer>();
    Map<Integer, Integer> allItemDrops = new HashMap<Integer, Integer>();
    Map<Integer, Integer> fetchedAllItemDrops = new HashMap<Integer, Integer>();
    Map<Integer, Integer> sessionItemDrops = new HashMap<Integer, Integer>();

    Map<Integer, Integer> cachedItemDrops = new HashMap<Integer, Integer>();

    File lootDirectory;
    File subDirectory;
    File ignoreDirectory;


    public int idNormalizer(int itemId)
    {
        switch (itemManager.getItemComposition(itemId).getName())
        {
            case "Clue Scroll (beginner)":
                return 23182;

            case "Clue Scroll (easy)":
                return 2677;

            case "Clue scroll (medium)":
                return 2801;

            case "Clue scroll (hard)":
                return 2722;

            case "Clue scroll (elite)":
                return 12073;

            case "Clue scroll (master)":
                return 19835;

            default:
                return itemId;
        }
    }

    public void buildLootMaps(List<Integer> itemIds,  List<Integer> itemQuants, Map<Integer,Integer> lootMap)
    {
        int i;
        for(i = 0; i < itemIds.size(); i++)
        {
            int itemId = idNormalizer(itemIds.get(i));
            drops.put(itemId,itemQuants.get(i));
            if(lootMap.containsKey(itemId))
            {
                int quantity = lootMap.get(itemId);
                quantity = quantity + drops.get(itemId);
                lootMap.replace(itemId,quantity);
            }
            else
            {
                lootMap.putAll(drops);
            }
            drops.clear();
        }
    }

    boolean bossNameMatch;


    public void bossNameMatcher()
    {
        if(plugin.bossName.equals(plugin.currentBoss))
        {
            bossNameMatch = true;
        }
        else if(("Theatre of Blood HM").equals(plugin.currentBoss) && ("Theatre of Blood").equals(plugin.bossName))
        {
            bossNameMatch = true;
        }
        else if(("TOA Expert").equals(plugin.currentBoss) && ("Tombs of Amascut").equals(plugin.bossName))
        {
            bossNameMatch = true;
        }
        else if(("TOA Normal").equals(plugin.currentBoss) && ("Tombs of Amascut").equals(plugin.bossName))
        {
            bossNameMatch = true;
        }
        else if(("CM Chambers").equals(plugin.currentBoss) && ("Chambers of Xeric").equals(plugin.bossName))
        {
            bossNameMatch = true;
        }
        else if(("Corrupted Gauntlet").equals(plugin.currentBoss) && ("The Gauntlet").equals(plugin.bossName))
        {
            bossNameMatch = true;
        }
        else if(("Dagannoth Kings").equals(plugin.currentBoss) &&
               (("Dagannoth Rex").equals(plugin.bossName)
             || ("Dagannoth Prime").equals(plugin.bossName)
             || ("Dagannoth Supreme".equals(plugin.bossName))))
        {
            bossNameMatch = true;
        }
        else if(KphBossInfo.bossByWordsLoot.containsKey(plugin.bossName))
        {
            plugin.bossName = KphBossInfo.bossByWordsLoot.get(plugin.bossName);
            if(plugin.bossName.equals(plugin.currentBoss))
            {
               bossNameMatch = true;
            }
        }
        else
        {
            bossNameMatch = false;
        }

    }

    public void lootReceived()
    {
        lootDirectory = new File(file, "boss-loot");
        subDirectory = new File(lootDirectory,plugin.currentBoss + ".json");

        bossNameMatcher();

        if(!bossNameMatch)
        {
            return;
        }

        loadDropsFromMap();

        if(!plugin.getPanel().fetchedInfoPanel.isShowing())
        {
            loadIgnoredList(plugin.currentBoss);
        }

        List<Integer> id =  plugin.itemStacks.stream().map(itemStack -> itemStack.getId()).collect(Collectors.toList());
        List<Integer> quant =  plugin.itemStacks.stream().map(itemStack -> itemStack.getQuantity()).collect(Collectors.toList());

        buildLootMaps(id,quant,allItemDrops);
        buildLootMaps(id,quant,sessionItemDrops);

        writeDropsToMap();

        itemAndTotalPrice = new HashMap<Integer, Double>();

        if(plugin.getPanel().fetchedInfoPanel.isShowing())
        {
           return;
        }

        plugin.getPanel().updateLootGrid(plugin.getPanel().lootDisplayMap());
    }


    HashMap<Integer, Double> itemAndTotalPrice;
    double totalGp = 0;

    ArrayList<Integer> ignored;


    public void getTotalPrice()
    {
        double totalGpLast = totalGp;

        for (Integer entry : itemAndTotalPrice.keySet())
        {
            if(ignored != null && ignored.contains(entry) && !plugin.getPanel().hideItemButton.isSelected())
            {
                continue;
            }
            totalGp += itemAndTotalPrice.get(entry);
        }
        itemAndTotalPrice.clear();
        totalGp = totalGp - totalGpLast;
    }


    public void loadFetchedDropsFromMap()
    {
        try
        {
            Type IntegerMap = new TypeToken<Map<Integer, Integer>>(){}.getType();
            fetchedAllItemDrops = gson.fromJson(new FileReader(subDirectory), IntegerMap);
        }
        catch (FileNotFoundException e)
        {
            fetchedAllItemDrops = new HashMap<Integer, Integer>();
            if(!plugin.getPanel().fetchedInfoPanel.isShowing())
            {
                try
                {
                    lootDirectory.mkdirs();
                    subDirectory.createNewFile();
                }
                catch (IOException exception)
                {
                    exception.printStackTrace();
                }
            }
        }
    }



    public void loadDropsFromMap()
    {
        try
        {
            Type IntegerMap = new TypeToken<Map<Integer, Integer>>(){}.getType();
            allItemDrops = gson.fromJson(new FileReader(subDirectory), IntegerMap);
        }
        catch (FileNotFoundException e)
        {
            try
            {
                lootDirectory.mkdirs();
                subDirectory.createNewFile();
                allItemDrops = new HashMap<Integer, Integer>();
            }
            catch (IOException exception)
            {
                exception.printStackTrace();
            }
        }
    }


    public void loadIgnoredList(String bossName)
    {
        try
        {
            Type IntegerList = new TypeToken<ArrayList<Integer>>(){}.getType();
            ignoreDirectory = new File(lootDirectory,bossName + "-ignored.json");
            ignored = gson.fromJson(new FileReader(ignoreDirectory), IntegerList);
        }
        catch (FileNotFoundException e)
        {
            ignored = new ArrayList<Integer>();
            if(!plugin.getPanel().fetchedInfoPanel.isShowing())
            {
                try
                {
                    ignoreDirectory.createNewFile();
                    writeIgnoredListToFile(plugin.currentBoss);
                }
                catch (IOException exception)
                {
                    exception.printStackTrace();
                }
            }
        }
    }



    public void writeDropsToMap()
    {
        try
        {
            Writer writer = new FileWriter(subDirectory);
            gson.toJson(allItemDrops,writer);
            writer.close();
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
    }

    public void writeIgnoredListToFile(String bossName)
    {
        try
        {
            ignoreDirectory = new File(lootDirectory, bossName + "-ignored.json");
            Writer writer = new FileWriter(ignoreDirectory);
            gson.toJson(ignored,writer);
            writer.close();
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }

    }




    // function to sort hashmap by values
    public HashMap<Integer, Integer> sortByValue(HashMap<Integer,Double> hm, Map<Integer,Integer> lootMap)
    {
        // Create a list from elements of HashMap
        List<Map.Entry<Integer, Double> > list = new LinkedList<Map.Entry<Integer, Double> >(hm.entrySet());

        // Sort the list
        Collections.sort(list, new Comparator<Map.Entry<Integer, Double> >()
        {
            public int compare(Map.Entry<Integer, Double> o1, Map.Entry<Integer, Double> o2)
            {
                return (o2.getValue()).compareTo(o1.getValue());
            }
        });

        // put data from sorted list to hashmap
        HashMap<Integer, Integer> sorted = new LinkedHashMap<>();
        for (Map.Entry<Integer, Double> aa : list)
        {
            sorted.put(aa.getKey(), lootMap.get(aa.getKey()));
        }
        return sorted;
    }


    public void fetchLookupInfo()
    {
        File mainFolder = new File(RUNELITE_DIR,"bossing-info");
        file = new File(mainFolder,client.getUsername());

        if (file.exists() && client.getUsername() != null)
        {
            file.renameTo(new File(mainFolder, String.valueOf(client.getAccountHash())));
            file = new File(mainFolder, String.valueOf(client.getAccountHash()));
        }
        else
        {
            file = new File(mainFolder, String.valueOf(client.getAccountHash()));

            if(!file.exists())
            {
                file.mkdirs();
            }
        }


        filename = filename + ".txt";
        lookupPath = Paths.get(file.getPath(),filename);
        fetchedFile = new File(String.valueOf(lookupPath));
        if(!fetchedFile.exists())
        {
            return;
        }

        try
        {

            List<String> list = Files.readAllLines(lookupPath);
            list.forEach(line -> list.toArray());

            fetchedTotalTimeActual = Integer.parseInt(list.get(0).replaceAll("[^0-9]", ""));
            fetchedTotalTimeVirtual = Integer.parseInt(list.get(1).replaceAll("[^0-9]", ""));
            fetchedTotalTrackedKills = Integer.parseInt(list.get(2).replaceAll("[^0-9]", ""));
            fetchedFastestKill = Integer.parseInt(list.get(3).replaceAll("[^0-9]", ""));
            fetchedTotalBossKc = Integer.parseInt(list.get(4).replaceAll("[^0-9]", ""));
            if(list.size() == 8)
            {
                lootKillsTracked = Integer.parseInt(list.get(7).replaceAll("[^0-9]", ""));
            }

            fetchedStatConverter();
        }
        catch (IOException e)
        {
            e.getCause();
        }

    }



    public void getCurrentBossKCGoal()
    {
        int totalBossKc;
        try
        {
            List<String> list = Files.readAllLines(path);
            list.forEach(line -> list.toArray());

            totalBossKc = Integer.parseInt(list.get(4).replaceAll("[^0-9]", ""));
            startKc = Integer.parseInt(list.get(5).replaceAll("[^0-9]", ""));
            endKc = Integer.parseInt(list.get(6).replaceAll("[^0-9]", ""));

            plugin.getPanel().startKcModel.setMaximum(totalBossKc);
            plugin.getPanel().startKcModel.setValue(totalBossKc);

            plugin.getPanel().endKcModel.setMinimum(totalBossKc);
            plugin.getPanel().endKcModel.setValue(totalBossKc);
            plugin.getPanel().endKcModel.setStepSize(5);

        }
        catch (IOException e)
        {
            e.getCause();
        }

    }


    public void updateBossKCGoal()
    {
        try
        {

            List<String> list = Files.readAllLines(path);
            list.forEach(line -> list.toArray());

            startKc = plugin.getPanel().startKC;
            endKc = plugin.getPanel().endKC;

            list.set(5, plugin.getPanel().startKC + " Start Kc");
            list.set(6, plugin.getPanel().endKC + " End Kc");

            Files.delete(path);
            Files.write(path, list, StandardOpenOption.CREATE,StandardOpenOption.APPEND);

        }
        catch (IOException e)
        {
            e.getCause();
        }



    }

    public void resetBossGoal()
    {
        try
        {
            List<String> list = Files.readAllLines(path);
            list.forEach(line -> list.toArray());

            list.set(5, 0 + " Start Kc");
            list.set(6, 0 + " End Kc");

            startKc = 0;
            endKc = 0;

            Files.delete(path);
            Files.write(path, list, StandardOpenOption.CREATE,StandardOpenOption.APPEND);

            plugin.getPanel().updateBossGoalsPanel();

        }
        catch (IOException e)
        {
            e.getCause();
        }

    }







    public void createDirectory()
    {

        //should create a directoy for each login profile
        File mainFolder = new File(RUNELITE_DIR,"bossing-info");


        file = new File(mainFolder,client.getUsername());

        if (file.exists() && client.getUsername() != null)
        {
            file.renameTo(new File(mainFolder, String.valueOf(client.getAccountHash())));
            file = new File(mainFolder, String.valueOf(client.getAccountHash()));

        }
        else
        {
            file = new File(mainFolder, String.valueOf(client.getAccountHash()));

            if(!file.exists())
            {
                file.mkdirs();
            }
        }


    }


    int lootKillsTracked;

    int totalBossKc;
    int startKc;
    int endKc;

    public void resetStartAndEndKc()
    {
        startKc = 0;
        endKc = 0;
    }

    List<String> list;

    public void populateNewDataFields()
    {
        try
        {
            StringBuilder contentBuilder = new StringBuilder();
            if(list.size() < 7)
            {
                contentBuilder.append(0);
                contentBuilder.append(" Start Kc\n");
                contentBuilder.append(0);
                contentBuilder.append(" End Kc\n");
            }
            contentBuilder.append(0);
            contentBuilder.append(" Loot Kills Tracked\n");
            String content = contentBuilder.toString();
            Files.write(path, content.getBytes(), StandardOpenOption.APPEND);

            list = Files.readAllLines(path);
            list.forEach(line -> list.toArray());
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }


    public void createFileForBoss()
    {
        boss = plugin.currentBoss;
        fileName = boss + ".txt";

        //this finds the file at the directed path
        path = Paths.get(file.getPath(), fileName);

        try
        {
            list = Files.readAllLines(path);
            list.forEach(line -> list.toArray());

            if(list.size() < 8)
            {
                populateNewDataFields();
            }

            oldTotalTime = Integer.parseInt(list.get(0).replaceAll("[^0-9]", ""));
            oldTotalVirtualTime = Integer.parseInt(list.get(1).replaceAll("[^0-9]", ""));
            oldTotalKills = Integer.parseInt(list.get(2).replaceAll("[^0-9]", ""));
            oldFastestKill = Integer.parseInt(list.get(3).replaceAll("[^0-9]", ""));
            totalBossKc = Integer.parseInt(list.get(4).replaceAll("[^0-9]", ""));
            startKc = Integer.parseInt(list.get(5).replaceAll("[^0-9]", ""));
            endKc = Integer.parseInt(list.get(6).replaceAll("[^0-9]", ""));
            lootKillsTracked = Integer.parseInt(list.get(7).replaceAll("[^0-9]", ""));
        }

        catch (IOException e)
        {
            try
            {
                StringBuilder contentBuilder = new StringBuilder();
                contentBuilder.append(plugin.totalTime);
                contentBuilder.append(" Total Time Actual\n");
                contentBuilder.append(plugin.totalTime);
                contentBuilder.append(" Total Time Virtual\n");
                contentBuilder.append(plugin.killsThisSession);
                contentBuilder.append(" Kills Tracked\n");
                contentBuilder.append(plugin.fastestKill);
                contentBuilder.append(" Fastest Kill\n");
                contentBuilder.append(plugin.killCount);
                contentBuilder.append(" Total Kc\n");
                contentBuilder.append(0);
                contentBuilder.append(" Start Kc\n");
                contentBuilder.append(0);
                contentBuilder.append(" End Kc\n");
                contentBuilder.append(1);
                contentBuilder.append(" Loot Kills Tracked\n");

                String content = contentBuilder.toString();
                Files.write(path, content.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);

                nullValuesForFileCreation();

            }
            catch (IOException ioException)
            {

                ioException.getCause();
            }


        }

    }



    public void nullValuesForFileCreation()
    {
        boss = plugin.currentBoss;
        fileName = boss + ".txt";

        oldTotalTime = 0;
        oldTotalKills = 0;
        timeOffset = 0;
        newTotalTimeActual = 0;
        lastKillTimeActual = 0;

        virtualTimeOffset = 0;
        oldTotalVirtualTime = 0;
        newTotalVirtualTime = 0;

        virtualAverageKillTime = 0;
        virtualKillsPerHour = 0;

        oldFastestKill = 99999999;
        newFastestKill = 99999999;
        lastKillTimeVirtual = 0;
        lootKillsTracked = 0;
    }


    public void replaceAndUpdate()
    {

        if(plugin.isBossChatDisplay())
        {

            if(plugin.killsThisSession == 1)
            {
                newTotalVirtualTime = oldTotalVirtualTime + plugin.totalBossKillTime;
                newTotalTimeActual = oldTotalTime + plugin.lastKillTotalTime_1;
            }
            else
            {

                virtualTimeOffset = plugin.totalBossKillTime - lastKillTimeVirtual;
                timeOffset = plugin.lastKillTotalTime_1 - lastKillTimeActual;

                newTotalTimeActual = newTotalTimeActual + timeOffset;
                newTotalVirtualTime = newTotalVirtualTime + virtualTimeOffset;
            }

            newTotalKills = oldTotalKills + 1;

            lastKillTimeActual = plugin.lastKillTotalTime_1;
            lastKillTimeVirtual = plugin.totalBossKillTime;

        }
        else
        {
            if(plugin.killsThisSession == 1)
            {

                newTotalVirtualTime = oldTotalVirtualTime + plugin.totalKillTime;
                newTotalTimeActual = oldTotalTime + plugin.lastKillTotalTime_0;

            }
            else
            {
                virtualTimeOffset = plugin.totalKillTime - lastKillTimeVirtual;
                timeOffset = plugin.lastKillTotalTime_0 - lastKillTimeActual;

                newTotalTimeActual = newTotalTimeActual + timeOffset;
                newTotalVirtualTime = newTotalVirtualTime + virtualTimeOffset;

            }
            newTotalKills = oldTotalKills + 1;
            lastKillTimeActual = plugin.lastKillTotalTime_0;
            lastKillTimeVirtual = plugin.totalKillTime;
        }

        if(plugin.fastestKill < oldFastestKill && oldFastestKill != 0)
        {
            newFastestKill = plugin.fastestKill;
        }
        else
        {
            newFastestKill = oldFastestKill;
        }

        lootKillsTracked = lootKillsTracked + 1;

        try
        {
            Files.delete(path);

            StringBuilder contentBuilder = new StringBuilder();

            contentBuilder.append(newTotalTimeActual);
            contentBuilder.append(" Total Time Actual\n");
            contentBuilder.append(newTotalVirtualTime);
            contentBuilder.append(" Total Time Virtual\n");
            contentBuilder.append(newTotalKills);
            contentBuilder.append(" Kills Tracked\n");
            contentBuilder.append(newFastestKill);
            contentBuilder.append(" Fastest Kill\n");
            contentBuilder.append(plugin.killCount);
            contentBuilder.append(" Total Kc\n");
            contentBuilder.append(startKc);
            contentBuilder.append(" Start Kc\n");
            contentBuilder.append(endKc);
            contentBuilder.append(" End Kc\n");
            contentBuilder.append(lootKillsTracked);
            contentBuilder.append(" Loot Kills Tracked\n");

            String content = contentBuilder.toString();
            Files.write(path, content.getBytes(), StandardOpenOption.CREATE,StandardOpenOption.APPEND);

        }
        catch (IOException e)
        {
            e.printStackTrace();
        }



    }



    int averageKillTime;
    double killsPerHour;

    int virtualAverageKillTime;
    double virtualKillsPerHour;
    int overallTime;



    public void statConverter()
    {

        if(plugin.calcMode == 0)
        {
            overallTime = newTotalTimeActual;
        }
        else
        {
            overallTime = newTotalVirtualTime;
        }

        averageKillTime = overallTime / newTotalKills;

        if(averageKillTime == 0)
        {
            killsPerHour = 0;
        }
        else
        {
            virtualKillsPerHour = 3600D / virtualAverageKillTime;
            killsPerHour = 3600D / averageKillTime;
        }

        DecimalFormat df = new DecimalFormat("#.#");
        killsPerHour = Double.parseDouble(df.format(killsPerHour));
    }



    public void fetchedStatConverter()
    {

        int newTime;

        if(plugin.calcMode == 0)
        {
            newTime = fetchedTotalTimeActual;
        }
        else
        {
            newTime = fetchedTotalTimeVirtual;
        }

        fetchedAverageKillTime = newTime / fetchedTotalTrackedKills;

        if(fetchedAverageKillTime == 0)
        {
            fetchedKillsPerHour = 0;
        }
        else
        {
            fetchedKillsPerHour = 3600D / fetchedAverageKillTime;
        }

        DecimalFormat df = new DecimalFormat("#.#");
        fetchedKillsPerHour = Double.parseDouble(df.format(fetchedKillsPerHour));

        estimatedTimeSpentBossing = (int) (fetchedTotalBossKc / (fetchedKillsPerHour / 3600));


    }



}






/*
 * Copyright (c) 2020, MrNice98
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.killsperhour;

import com.killsperhour.KphConfig;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;


@ToString
class KphInfobox extends InfoBox
{

	private final KphConfig config;

	private final KphPlugin plugin;

	private final BufferedImage image;

	private final OverlayPosition position;

	//this creates a setter and getter method with lombook
	@Getter
	@Setter
	private String Kph;

	KphInfobox(BufferedImage image, KphPlugin plugin, KphConfig config, OverlayPosition position)
	{
		super(image,plugin);
		this.image = image;
		this.plugin = plugin;
		this.config = config;
		this.position = position;
	}

	@Override
	public String getText()
	{
		switch (config.infoBoxContent())
		{
			case SESSION_TIME:
				return plugin.timeConverter(plugin.totalSessionTime);

			case KILLS_THIS_SESSION:
				return String.valueOf(plugin.killsThisSession);

			case AVG_KILL:
				return plugin.avgKillTimeConverter();

			case FASTEST_KILL:
				return plugin.timeConverter(plugin.fastestKill);

			case IDLE_TIME:
				return plugin.timeConverter(plugin.timeSpentIdle);

			default:
				return plugin.formatKPH();
		}

	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}

	@Override
	public String getTooltip()
	{
		StringBuilder toolTip = new StringBuilder();

		toolTip.append(plugin.sessionNpc);

		toolTip.append("</br>KPH: ");
		toolTip.append(plugin.formatKPH());

		if(config.killsThisSession())
		{
			toolTip.append("</br>Kills: ");
			toolTip.append(plugin.killsThisSession);
		}

		if(config.averageKillTime())
		{
			toolTip.append("</br>Avg Kill: ");
			toolTip.append(plugin.timeConverter(plugin.averageKillTime));
		}

		if(config.fastestKill())
		{
			toolTip.append("</br>Fastest Kill: ");
			toolTip.append(plugin.timeConverter(plugin.fastestKill));
		}

		if(config.displayIdleTime())
		{
			toolTip.append("</br>Idle time: ");
			toolTip.append(plugin.timeConverter(plugin.timeSpentIdle));
		}

		if(config.displayTotalTime())
		{
			toolTip.append("</br>Session Time: ");
			toolTip.append(plugin.timeConverter(plugin.totalSessionTime));
		}

		return toolTip.toString();
	}



}
/*
 * Copyright (c) 2020, MrNice98
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.killsperhour;

import com.google.common.collect.ImmutableMap;
import net.runelite.api.ItemID;
import okhttp3.Challenge;


import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

enum KphBossInfo
{


    //display type 1 = yes , 0 = no
    PHANTOM_MUSPAH("Phantom Muspah", ItemID.MUPHIN,1,-1,0,"Your Phantom Muspah kill count is:"),
    ZULRAH("Zulrah", ItemID.PET_SNAKELING_12940,1,-1,0,"Your Zulrah kill count is:"),
    AMOXLIATL("Amoxliatl",ItemID.MOXI,1,-1,0,"Your Amoxliatl kill count is:"),
    HUEYCOATL("Hueycoatl",ItemID.HUBERTE,1,-1,0,"Your Hueycoatl kill count is:"),
    ARAXXOR("Araxxor",ItemID.NID,1,-1,0,"Your Araxxor kill count is:"),

    DUKE_SUCELLUS("Duke Sucellus",ItemID.BARON,1,-1,0,"Your Duke Sucellus kill count is:"),
    VARDORVIS("Vardorvis",ItemID.BUTCH,1,-1,0,"Your Vardorvis kill count is:"),
    THE_WHISPERER("The Whisperer",ItemID.WISP,1,-1,0,"Your Whisperer kill count is:"),
    THE_LEVIATHAN("The Leviathan",ItemID.LILVIATHAN,1,-1,0,"Your Leviathan kill count is:"),


    CHAMBERS("Chambers",ItemID.OLMLET,1,-1,1,"Your completed Chambers of Xeric count is:"),
    CM_CHAMBERS("CM Chambers",ItemID.TEKTINY,1,-1,1,"Your completed Chambers of Xeric Challenge Mode count is:"),

    TOA_NORMAL("TOA Normal",ItemID.TUMEKENS_GUARDIAN,1,-1,1,"Your completed Tombs of Amascut count is:"),
    TOA_EXPERT("TOA Expert",ItemID.AKKHITO,1,-1,1,"Your completed Tombs of Amascut: Expert Mode count is:"),


    COLOSSEUM("Colosseum",ItemID.SMOL_HEREDIT,1,-1,1,"Your Sol Heredit kill count is:"),


    GAUNTLET("Gauntlet",ItemID.YOUNGLLEF,1,-1,1,"Your Gauntlet completion count is:"),
    CORRUPTED_GAUNTLET("Corrupted Gauntlet",ItemID.CORRUPTED_YOUNGLLEF,1,-1,1,"Your Corrupted Gauntlet completion count is:"),
    THEATER_OF_BLOOD("Theatre of Blood",ItemID.LIL_ZIK,1,-1,1,"Your completed Theatre of Blood count is:"),

    THEATER_OF_BLOOD_HM("Theatre of Blood HM",ItemID.LIL_SOT,1,-1,1,"Your completed Theatre of Blood: Hard Mode count is:"),

    VORKATH("Vorkath",ItemID.VORKI,1,-1,0,"Your Vorkath kill count is:"),
    HYDRA("Alchemical Hydra",ItemID.IKKLE_HYDRA_22748,1,-1,0,"Your Alchemical Hydra kill count is:"),
    GROTESQUE_GUARDIANS("Grotesque Guardians",ItemID.NOON,1,-1,1,"Your Grotesque Guardians kill count is:"),

    NIGHTMARE("Nightmare",ItemID.LITTLE_NIGHTMARE,1,-1,0,"Your Nightmare kill count is:"),
    PHOSANIS_NIGHTMARE("Phosani's Nightmare",ItemID.PARASITIC_EGG,1,-1,0,"Your Phosani's Nightmare kill count is:"),

    TZTOK_JAD("TzTok-Jad",ItemID.TZREKJAD,1,-1,0,"Your TzTok-Jad kill count is:"),
    TZKAL_ZUK("TzKal-Zuk",ItemID.TZREKZUK,1,-1,0,"Your TzKal-Zuk kill count is:"),

    //times are in ticks, 120 = 1.2min , 500 = 5min, 200 = 2min, 300 = 3min ect... 100ticks = 1min

    //non-display below
    GIANT_MOLE("Giant Mole",ItemID.BABY_MOLE,0,220,-1,"Your Giant Mole kill count is:"),
    SARACHNIS("Sarachnis",ItemID.SRARACHA,0,220,-1,"Your Sarachnis kill count is:"),
    ABYSSAL_SIRE("Abyssal Sire",ItemID.ABYSSAL_ORPHAN,0,300,-1,"Your Abyssal Sire kill count is:"),
    COMMANDER_ZILYANA("Commander Zilyana",ItemID.PET_ZILYANA,0,120,-1,"Your Commander Zilyana kill count is:"),
    GENERAL_GRAARDOR("General Graardor",ItemID.PET_GENERAL_GRAARDOR,0,120,-1,"Your General Graardor kill count is:"),
    KREEARRA("Kree'arra",ItemID.PET_KREEARRA,0,120,-1,"Your Kree'arra kill count is:"),
    KRIL_TSUTSAROTH("K'ril Tsutsaroth",ItemID.PET_KRIL_TSUTSAROTH,0,120,-1,"Your K'ril Tsutsaroth kill count is:"),

    NEX("Nex",ItemID.NEXLING,1,-1,0,"Your Nex kill count is:"),

    KRAKEN("Kraken",ItemID.PET_KRAKEN,0,220,-1,"Your Kraken kill count is:"),
    ENORMOUS_TENTACLE("Enormous Tentacle",ItemID.PET_KRAKEN,0,220,-1,"not included"),
    THERMY("Thermy",ItemID.PET_SMOKE_DEVIL,0,220,-1,"Your Thermonuclear Smoke Devil kill count is:"),
    THERMONUCLEAR_SMOKE_DEVIL("Thermonuclear smoke devil",ItemID.PET_SMOKE_DEVIL,0,220,-1,"duplicate identifier"),
    CERBERUS("Cerberus",ItemID.HELLPUPPY,0,150,-1,"Your Cerberus kill count is:"),
    KING_BLACK_DRAGON("King Black Dragon",ItemID.PRINCE_BLACK_DRAGON,0,120,-1,"Your King Black Dragon kill count is:"),
    SCORPIA("Scorpia",ItemID.SCORPIAS_OFFSPRING,0,250,-1,"Your Scorpia kill count is:"),
    CHAOS_FANATIC("Chaos Fanatic",ItemID.ANCIENT_STAFF,0,250,-1,"Your Chaos Fanatic kill count is:"),

    CRAZY_ARCHAEOLOGIST("Crazy archaeologist",ItemID.FEDORA,0,250,-1,"Your Crazy Archaeologist kill count is:"),
    CHAOS_ELEMENTAL("Chaos Elemental",ItemID.PET_CHAOS_ELEMENTAL,0,250,-1,"Your Chaos Elemental kill count is:"),

    CALLISTO("Callisto",ItemID.CALLISTO_CUB,0,250,-1,"Your Callisto kill count is:"),
    ARTIO("Artio",ItemID.CALLISTO_CUB_27649,0,250,-1,"Your Artio kill count is:"),


    VETION("Vet'ion",ItemID.VETION_JR_13180,0,350,-1,"Your Vet'ion kill count is:"),
    VETION_REBORN("Vet'ion Reborn",ItemID.VETION_JR_13180,0,350,-1,"duplicate identifier"),

    CALVARION("Calvar'ion",ItemID.VETION_JR_27650,0,350,-1,"Your Calvar'ion kill count is:"),


    VENENATIS("Venenatis",ItemID.VENENATIS_SPIDERLING,0,250,-1,"Your Venenatis kill count is:"),
    SPINDEL("Spindel",ItemID.VENENATIS_SPIDERLING_27648,0,250,-1,"Your Spindel kill count is:"),

    SCURRIUS("Scurrius",ItemID.SCURRY,0,250,-1,"Your Scurrius kill count is:"),

    BARROWS("Barrows",ItemID.BARROWS_TELEPORT,0,1500,-1,"Your Barrows chest count is:"),
    VERAC_THE_DEFILED("Verac the Defiled",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    TORAG_THE_CORRUPTED("Torag the Corrupted",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    KARIL_THE_TAINTED("Karil the Tainted",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    GUTHAN_THE_INFESTED("Guthan the Infested",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    DHAROK_THE_WRETCHED("Dharok the Wretched",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    AHRIM_THE_BLIGHTED("Ahrim the Blighted",ItemID.BARROWS_TELEPORT,0,1500,-1,"not included"),
    DERANGED_ARCHAEOLOGIST("Deranged archaeologist",ItemID.UNIDENTIFIED_RARE_FOSSIL,0,120,-1,"Your Deranged Archaeologist kill count is:"),
    KALPHITE_QUEEN("Kalphite Queen",ItemID.KALPHITE_PRINCESS,0,400,-1,"Your Kalphite Queen kill count is:"),
    CORPOREAL_BEAST("Corporeal Beast", ItemID.PET_CORPOREAL_CRITTER,0,400,-1,"Your Corporeal Beast kill count is:"),
    DAGANNOTH_PRIME("Dagannoth Prime",ItemID.PET_DAGANNOTH_PRIME,0,15,-1,"not included"),
    DAGANNOTH_REX("Dagannoth Rex",ItemID.PET_DAGANNOTH_REX,0,15,-1,"not included"),
    DAGANNOTH_SUPREME("Dagannoth Supreme",ItemID.PET_DAGANNOTH_SUPREME,0,15,-1,"not included"),
    DAGANNOTH_KINGS("Dagannoth Kings",ItemID.DAGANNOTH,0,15,-1,"not included");


    private final int icon;
    private final String name;
    private final String kcIdentifier;
    private final int displayType;
    private final int attkTimeout;
    private final int displayFirst;


    KphBossInfo(String name, int icon, int displayType, int attkTimeout,int displayFirst, String kcIdentifier)
    {
        this.icon = icon;
        this.name = name;
        this.displayType = displayType;
        this.attkTimeout = attkTimeout;
        this.kcIdentifier = kcIdentifier;
        this.displayFirst = displayFirst;
    }



    static
    {
        ImmutableMap.Builder<String, KphBossInfo> builder = new ImmutableMap.Builder<>();

        for (KphBossInfo kphBossInfo : values())
        {
            builder.put(kphBossInfo.getName(), kphBossInfo);
        }
        bosses = builder.build();
    }


    public static final Map<String, KphBossInfo> bosses;

    public static final Map<String, String> bossByWords = new HashMap<String, String>();

    public static final Map<String, String> bossByWordsLoot = new HashMap<String, String>();

    public static final ArrayList<String> timeMessages = new ArrayList<String>();

    static
    {
        //duration is not necessary as duration will never come first, fight duration comes first for garg boss.
        timeMessages.add("Fight duration:");
        timeMessages.add("Congratulations - your raid is complete!");
        timeMessages.add("Corrupted challenge duration:");
        timeMessages.add("Challenge duration:");
        timeMessages.add("Theatre of Blood total completion time: ");
        timeMessages.add("Tombs of Amascut: Expert Mode total completion time:");
        timeMessages.add("Tombs of Amascut total completion time:");//normal mode
        timeMessages.add("Colosseum duration:");
    }

    static
    {
        bossByWordsLoot.putAll(bossByWords);
        bossByWordsLoot.put("Thermonuclear smoke devil","Thermy");
        bossByWordsLoot.put("Vet'ion Reborn","Vet'ion");
        bossByWordsLoot.put("Chambers of Xeric","Chambers");
        bossByWordsLoot.put("The Gauntlet","Gauntlet");
        bossByWordsLoot.put("The Nightmare","Nightmare");
    }

    static
    {

        //used for boss name check as-well as when searching for a record

        bossByWords.put("c gauntlet","Corrupted Gauntlet");
        bossByWords.put("vork","Vorkath");

        //GG's ByWords
        bossByWords.put("garg boss","Grotesque Guardians");

        bossByWords.put("Dusk","Grotesque Guardians");

        bossByWords.put("dawn","Grotesque Guardians");
        bossByWords.put("ggs","Grotesque Guardians");

        bossByWords.put("Fortis Colosseum","Colosseum");
        bossByWords.put("Colo","Colosseum");

        bossByWords.put("huey","Hueycoatl");

        bossByWords.put("amox","Amoxliatl");


        bossByWords.put("zuk","TzKal-Zuk");
        bossByWords.put("jad","TzTok-Jad");
        bossByWords.put("mole","Giant Mole");
        bossByWords.put("sire","Abyssal Sire");

        //Sara ByWords
        bossByWords.put("sara","Commander Zilyana");
        bossByWords.put("zilly","Commander Zilyana");
        bossByWords.put("zilyana","Commander Zilyana");

        //Bandos ByWords
        bossByWords.put("bandos","General Graardor");
        bossByWords.put("graardor","General Graardor");

        //Arma ByWords
        bossByWords.put("arma","Kree'arra");
        bossByWords.put("kree","Kree'arra");
        bossByWords.put("kreearra","Kree'arra");

        //Zammy ByWords
        bossByWords.put("zammy","K'ril Tsutsaroth");
        bossByWords.put("kril","K'ril Tsutsaroth");
        bossByWords.put("kril tsutsaroth","K'ril Tsutsaroth");

        bossByWords.put("Thermonuclear smoke devil","Thermy");
        bossByWords.put("thermonuclear smoke devil","Thermy");
        bossByWords.put("cerb","Cerberus");
        bossByWords.put("kbd","King Black Dragon");
        bossByWords.put("chaos elly","Chaos Elemental");

        bossByWords.put("pnm","Phosani's Nightmare");

        bossByWords.put("Vet'ion Reborn","Vet'ion");
        bossByWords.put("vetion","Vet'ion");

        bossByWords.put("kq","Kalphite Queen");
        bossByWords.put("corp","Corporeal Beast");


        bossByWords.put("phantom","Phantom Muspah");
        bossByWords.put("muspah","Phantom Muspah");
        bossByWords.put("grumbler","Phantom Muspah");

        //CM ByWords
        bossByWords.put("cm","CM Chambers");
        bossByWords.put("cm cox","CM Chambers");
        bossByWords.put("challange mode","CM Chambers");
        bossByWords.put("challange mode chambers of xeric","CM Chambers");

        //Chambers ByWords
        bossByWords.put("chambers of xeric","Chambers");
        bossByWords.put("cox","Chambers");

        //TOB ByWords
        bossByWords.put("theatre","Theatre of Blood");
        bossByWords.put("tob","Theatre of Blood");

        //TOB HM ByWords
        bossByWords.put("theatre hm","Theatre of Blood HM");
        bossByWords.put("tob hm","Theatre of Blood HM");
        bossByWords.put("hm","Theatre of Blood HM");

        //TOA byWords
        bossByWords.put("TOA","TOA Normal");


        bossByWords.put("hydra","Alchemical Hydra");
    }



    public String getName()
    {
        return name;
    }

    public String getKcIdentifier()
    {
        return kcIdentifier;
    }

    public int getDisplayFirst()
    {
        return displayFirst;
    }

    public int getDisplayType()
    {
        return displayType;
    }

    public int getAttkTimeout()
    {
        return attkTimeout;
    }

    public int getIcon()
    {
        return icon;
    }

    public static KphBossInfo find(String name)
    {
        return bosses.get(name);
    }



}

/*
 * Copyright (c) 2020, MrNice98
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.killsperhour;

import com.killsperhour.KphConfig;
import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import java.awt.*;

class KphOverlay extends Overlay
{
    private final Client client;
    private final KphConfig config;
    private final KphPlugin kphPlugin;
    private final PanelComponent panelComponent = new PanelComponent();


    @Inject
    private KphOverlay(Client client, KphConfig config, KphPlugin kphPlugin)
    {
        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);
        this.client = client;
        this.config = config;
        this.kphPlugin = kphPlugin;
    }


    @Override
    public Dimension render(Graphics2D graphics)
    {
            panelComponent.getChildren().clear();
            String overlayTitle = kphPlugin.currentBoss;

            if(!kphPlugin.paused)
            {
                panelComponent.getChildren().add(TitleComponent.builder()
                        .text(overlayTitle)
                        .color(Color.GREEN)
                        .build());
            }
            else
            {
                panelComponent.getChildren().add(TitleComponent.builder()
                        .text(overlayTitle)
                        .color(new Color(227, 160, 27))
                        .build());
            }

            panelComponent.setPreferredSize(new Dimension(
                    150,
                    0));


            panelComponent.getChildren().add(LineComponent.builder()
                    .left("KPH:")
                    .right(kphPlugin.formatKPH())
                    .build());


        if(config.killsThisSession())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Kills:")
                    .right(Integer.toString(kphPlugin.killsThisSession))
                    .build());

        }


        if (config.averageKillTime())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Average Kill:")
                    .right(kphPlugin.avgKillTimeConverter())
                    .build());

        }

        if (config.fastestKill())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Fastest Kill:")
                    .right(kphPlugin.timeConverter(kphPlugin.fastestKill))
                    .build());

        }


        if (config.displayIdleTime())
        {
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Idle Time:")
                    .right((kphPlugin.timeConverter(kphPlugin.timeSpentIdle)))
                    .build());

        }


        if (config.displayTotalTime())
        {
            if(!kphPlugin.paused && kphPlugin.sessionNpc != null)
            {
                kphPlugin.totalSessionTimer();
            }
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Session Time:")
                    .right((kphPlugin.timeConverter(kphPlugin.totalSessionTime)))
                    .build());
        }


        if(kphPlugin.killsThisSession >= 1 && config.enableOverlay() && kphPlugin.sessionNpc != null)
        {
            return panelComponent.render(graphics);
        }

        return null;
    }


}

