package com.royaltitans;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.WorldView;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
@PluginDescriptor(
	name = "Royal Titans Damage Tracker", 
	description = "Tracks damage contribution for Royal Titans (Branda and Eldric)", 
	tags = {"royal", "titans", "damage", "contribution", "branda", "eldric", "giants", 
	        "duo", "boss"}
)
public class RoyalTitansPlugin extends Plugin {

	private static final int BRANDA_ID = NpcID.RT_FIRE_QUEEN;
	private static final int ELDRIC_ID = NpcID.RT_ICE_KING;

	private static final int COMBINED_HP = 1200;
	private static final double BASE_DROP_RATE = 75.0;
	
	@Inject
	private Client client;

	@Inject
	private RoyalTitansConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RoyalTitansOverlay overlay;

	@Inject
	private ScheduledExecutorService executorService;

	private int brandaDamage = 0;
	private int eldricDamage = 0;
	private boolean encounterActive = false;
	private NPC branda = null;
	private NPC eldric = null;
	private ScheduledFuture<?> resetCounterDelay = null;
	private boolean resetScheduled = false;
	private boolean titansDefeated = false;
	private int ticksSinceLastTitanSeen = 0;

	@Override
	protected void startUp() throws Exception {
		overlayManager.add(overlay);
		resetDamageCounters();
	}

	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(overlay);
		cancelResetCounterDelay();
		resetDamageCounters();
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		String message = event.getMessage();

		// Reset damage tracker when titans respawn (this is the looting message)
		if (message.contains("The Royal Titans will reinvigorate themselves in 18 seconds.")) {
			scheduleReset();
		}
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned event) {
		NPC npc = event.getNpc();

		if (npc.getId() == BRANDA_ID) {
			branda = npc;
			// If we have damage tracked and titans were defeated, but now fresh titans spawned,
			// this means player left and returned to new spawns - reset the tracker
			if (getTotalDamage() > 0 && titansDefeated && !resetScheduled) {
				resetDamageCounters();
			}
			titansDefeated = false;
			ticksSinceLastTitanSeen = 0;
			checkEncounterStart();
		} else if (npc.getId() == ELDRIC_ID) {
			eldric = npc;
			// Same check for Eldric
			if (getTotalDamage() > 0 && titansDefeated && !resetScheduled) {
				resetDamageCounters();
			}
			titansDefeated = false;
			ticksSinceLastTitanSeen = 0;
			checkEncounterStart();
		}
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned event) {
		NPC npc = event.getNpc();

		if (npc.getId() == BRANDA_ID) {
			branda = null;
		} else if (npc.getId() == ELDRIC_ID) {
			eldric = null;
		}

		// If both titans are gone and player did damage, they were likely defeated
		if (branda == null && eldric == null && getTotalDamage() > 0) {
			titansDefeated = true;
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied event) {
		if (!encounterActive) {
			return;
		}

		Actor target = event.getActor();
		Hitsplat hitsplat = event.getHitsplat();

		// Only count damage from the local player
		if (!hitsplat.isMine()) {
			return;
		}

		// Only count damage to the Royal Titans
		if (target instanceof NPC) {
			NPC npc = (NPC) target;
			int damage = hitsplat.getAmount();

			if (npc.getId() == BRANDA_ID) {
				brandaDamage += damage;
			} else if (npc.getId() == ELDRIC_ID) {
				eldricDamage += damage;
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		// Validate NPC references and clean up if needed
		validateNpcReferences();

		// Check if player has left the encounter area
		checkAreaExit();
	}

	private void validateNpcReferences() {
		// Clean up invalid NPC references
		if (branda != null && !isNpcValid(branda)) {
			branda = null;
		}

		if (eldric != null && !isNpcValid(eldric)) {
			eldric = null;
		}
	}

	private void checkAreaExit() {
		// Check if there are any Royal Titan NPCs in the current world view
		boolean anyTitansPresent = false;
		WorldView worldView = client.getTopLevelWorldView();

		if (worldView != null) {
			for (NPC npc : worldView.npcs()) {
				if (npc.getId() == BRANDA_ID || npc.getId() == ELDRIC_ID) {
					anyTitansPresent = true;
					break;
				}
			}
		}

		if (anyTitansPresent) {
			// Titans are present, reset the exit counter
			ticksSinceLastTitanSeen = 0;
		} else if (encounterActive || getTotalDamage() > 0) {
			// No titans present but we have an active encounter or damage tracked
			ticksSinceLastTitanSeen++;
		}

		// Only reset if:
		// 1. No royal titans have been seen for 10 ticks (6 seconds) - player left the area
		// 2. No reset is already scheduled
		// 3. Titans were not defeated (player left during active fight)
		if (ticksSinceLastTitanSeen >= 10 && !resetScheduled && !titansDefeated) {
			resetDamageCounters();
		}
		
	}

	private boolean isNpcValid(NPC npc) {
		if (npc == null || npc.isDead()) {
			return false;
		}
		
		// Check if NPC exists in the current world view
		WorldView worldView = client.getTopLevelWorldView();
		if (worldView == null) {
			return false;
		}

		// Iterate through NPCs to find our reference
		for (NPC worldNpc : worldView.npcs()) {
			if (worldNpc == npc) {
				return true;
			}
		}

		return false;
	}

	private void scheduleReset() {
		// Cancel any existing reset delay
		cancelResetCounterDelay();

		// Set the flag to indicate a reset is scheduled
		resetScheduled = true;

		// Get delay from config and clamp between 0-18 seconds
		int delaySeconds = Math.max(0, Math.min(18, config.resetDelay()));

		if (delaySeconds == 0) {
			// Reset immediately if delay is 0
			resetDamageCounters();
			return;
		}

		// Schedule new reset task for specified delay
		resetCounterDelay = executorService.schedule(() -> {
			resetDamageCounters();
			resetCounterDelay = null;
		}, delaySeconds, TimeUnit.SECONDS);
	}

	private void cancelResetCounterDelay() {
		if (resetCounterDelay != null && !resetCounterDelay.isDone()) {
			resetCounterDelay.cancel(false);
		}
		resetCounterDelay = null;
		resetScheduled = false;
	}

	private void checkEncounterStart() {
		if (!encounterActive && (branda != null || eldric != null)) {
			// Cancel any existing reset delay since a new encounter is starting
			cancelResetCounterDelay();
			encounterActive = true;
			titansDefeated = false;
			ticksSinceLastTitanSeen = 0;
		}
	}

	private void resetDamageCounters() {
		brandaDamage = 0;
		eldricDamage = 0;
		encounterActive = false;
		branda = null;
		eldric = null;
		titansDefeated = false;
		ticksSinceLastTitanSeen = 0;
		cancelResetCounterDelay();
	}

	// Getters for overlay
	public int getBrandaDamage() {
		return brandaDamage;
	}

	public int getEldricDamage() {
		return eldricDamage;
	}

	public int getTotalDamage() {
		return brandaDamage + eldricDamage;
	}

	public double getContributionPercentage() {
		int totalDamage = getTotalDamage();
		if (totalDamage == 0) {
			return 0.0;
		}
		return Math.min(100.0, (totalDamage * 100.0) / COMBINED_HP);
	}

	public String getDropRate() {
		int totalDamage = getTotalDamage();
		if (totalDamage == 0) {
			return "N/A";
		}

		double contribution = Math.min(1.0, totalDamage / (double) COMBINED_HP);
		int adjustedRate = (int) Math.round(BASE_DROP_RATE / contribution);

		return "1/" + adjustedRate;
	}

	public boolean isEncounterActive() {
		return encounterActive;
	}

	@Provides
	RoyalTitansConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(RoyalTitansConfig.class);
	}
}

package com.royaltitans;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("royaltitans")
public interface RoyalTitansConfig extends Config {
	
	@ConfigSection(
		name = "Display Options",
		description = "Customize what information to show in the overlay",
		position = 0
	)
	String displaySection = "display";

	@ConfigItem(
		keyName = "showIndividualDamage",
		name = "Show Individual Titan Damage",
		description = "Display damage to each titan separately (Branda and Eldric lines)",
		section = displaySection,
		position = 0
	)
	default boolean showIndividualDamage() {
		return true;
	}

	@ConfigItem(
		keyName = "showDropRate",
		name = "Show Drop Rate",
		description = "Calculate and display drop rate based on current contribution",
		section = displaySection,
		position = 1
	)
	default boolean showDropRate() {
		return true;
	}

	@ConfigSection(
		name = "Overlay Settings",
		description = "Overlay appearance and positioning",
		position = 1
	)
	String overlaySection = "overlay";

	@ConfigItem(
		keyName = "showOnlyDuringEncounter",
		name = "Show Only During Encounter",
		description = "Only display the overlay when Royal Titans encounter is active",
		section = overlaySection,
		position = 0
	)
	default boolean showOnlyDuringEncounter() {
		return true;
	}

	@ConfigItem(
		keyName = "resetDelay",
		name = "Reset Delay (seconds)",
		description = "Delay in seconds before resetting damage counters after encounter ends. " +
			"(0-18 seconds) Set to 0 for immediate reset on looting.",
		section = overlaySection,
		position = 1
	)
	default int resetDelay() {
		return 15; // Default reset delay in seconds
	}

	@ConfigItem(
		keyName = "totalColor",
		name = "Total Damage Color",
		description = "Color of the total damage text",
		section = overlaySection,
		position = 2
	)
	default java.awt.Color totalColor() {
		return java.awt.Color.WHITE;
	}

	@ConfigItem(
		keyName = "brandaColor",
		name = "Branda Damage Color",
		description = "Color of Branda damage text",
		section = overlaySection,
		position = 3
	)
	default java.awt.Color brandaColor() {
		return java.awt.Color.PINK;
	}

	@ConfigItem(
		keyName = "eldricColor",
		name = "Eldric Damage Color",
		description = "Color of Eldric damage text",
		section = overlaySection,
		position = 4
	)
	default java.awt.Color eldricColor() {
		return java.awt.Color.CYAN;
	}

	@ConfigItem(
		keyName = "dropRateColor",
		name = "Drop Rate Color",
		description = "Color of the drop rate text",
		section = overlaySection,
		position = 5
	)
	default java.awt.Color dropRateColor() {
		return java.awt.Color.ORANGE;
	}
}

package com.royaltitans;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class RoyalTitansOverlay extends Overlay {

    private final RoyalTitansPlugin plugin;
    private final RoyalTitansConfig config;
    private final PanelComponent panelComponent = new PanelComponent();

    @Inject
    private RoyalTitansOverlay(RoyalTitansPlugin plugin, RoyalTitansConfig config) {
        this.plugin = plugin;
        this.config = config;

        setPosition(OverlayPosition.TOP_LEFT);
        setPriority(Overlay.PRIORITY_MED);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, 
            "Royal Titans overlay"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        // Don't render if encounter isn't active and config says to hide
        if (config.showOnlyDuringEncounter() && !plugin.isEncounterActive()) {
            return null;
        }

        // Don't render if no damage has been dealt yet
        if (plugin.getTotalDamage() == 0 && config.showOnlyDuringEncounter()) {
            return null;
        }

        panelComponent.getChildren().clear();

        Color totalColor = config.totalColor();
        Color brandaColor = config.brandaColor();
        Color eldricColor = config.eldricColor();
        Color dropRateColor = config.dropRateColor();

        // Line 1: Total damage with percentage
        int totalDamage = plugin.getTotalDamage();
        double percentage = plugin.getContributionPercentage();
        String totalLine = String.format("Total: %d  (%.1f%%)", totalDamage, percentage);

        panelComponent.getChildren().add(LineComponent.builder()
            .left(totalLine)
            .leftColor(totalColor)
            .build());

        // Line 2-3: Individual titan damage (if enabled)
        if (config.showIndividualDamage()) {
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Branda: " + plugin.getBrandaDamage())
                .leftColor(brandaColor)
                .build());

            panelComponent.getChildren().add(LineComponent.builder()
                .left("Eldric: " + plugin.getEldricDamage())
                .leftColor(eldricColor)
                .build());
        }

        // Line 4: Drop rate (if enabled)
        if (config.showDropRate()) {
            String dropRate = plugin.getDropRate();
            panelComponent.getChildren().add(LineComponent.builder()
                .left("Drop Rate: " + dropRate)
                .leftColor(dropRateColor)
                .build());
        }

        return panelComponent.render(graphics);
    }
    
}

package com.royaltitans;

import com.royaltitans.RoyalTitansPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RoyalTitansPluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RoyalTitansPlugin.class);
		RuneLite.main(args);
	}
}
