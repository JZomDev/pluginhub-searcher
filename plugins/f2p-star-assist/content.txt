package com.janboerman.f2pstarassist.common.lingo;

import com.janboerman.f2pstarassist.common.StarLocation;
import com.janboerman.f2pstarassist.common.StarTier;

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class InterpretationsTest {

    @Test
    public void testCorsairBank() {
        String text = "T2 corsair bank w308";

        assertEquals(StarLocation.CORSAIR_COVE_BANK, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_2, StarLingo.interpretTier(text));
        assertEquals(308, StarLingo.interpretWorld(text));
    }

    @Test
    public void testLumbridgeSwampEast() {
        String text = "Yea w335 tier 2 lumby east";

        assertEquals(StarLocation.LUMBRIDGE_SWAMP_SOUTH_EAST_MINE, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_2, StarLingo.interpretTier(text));
        assertEquals(335, StarLingo.interpretWorld(text));
    }

    @Test
    public void testVarrock() {
        String text = "T3 Varrock East W382";

        assertEquals(StarLocation.VARROCK_SOUTH_EAST_MINE, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_3, StarLingo.interpretTier(text));
        assertEquals(382, StarLingo.interpretWorld(text));
    }

    @Test
    public void testAlKharidBank(){
        String text = "t1 w453 al kharid bank";

        assertEquals(StarLocation.AL_KHARID_BANK, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_1, StarLingo.interpretTier(text));
        assertEquals(453, StarLingo.interpretWorld(text));
    }

    @Test
    public void testAubury(){
        String text = "316 aubury t7";

        assertEquals(StarLocation.VARROCK_AUBURY, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_7, StarLingo.interpretTier(text));
        assertEquals(316, StarLingo.interpretWorld(text));
    }

    @Test
    public void testDesertMine() {
        String text = "t6 w301 desert mine";

        assertEquals(StarLocation.AL_KHARID_MINE, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_6, StarLingo.interpretTier(text));
        assertEquals(301, StarLingo.interpretWorld(text));
    }

    @Test
    public void testVarrockEastBank() {
        String text = "T7 varrock east bank w425";

        assertEquals(StarLocation.VARROCK_AUBURY, StarLingo.interpretLocation(text));
        assertEquals(StarTier.SIZE_7, StarLingo.interpretTier(text));
        assertEquals(425, StarLingo.interpretWorld(text));
    }

    // sanity-check toString
    @Test
    public void testToStringRoundTrip() {
        for (StarLocation location : StarLocation.values()) {
            assertEquals(location, StarLingo.interpretLocation(location.toString()));
        }
    }

}

package com.janboerman.f2pstarassist.common.lingo;

import com.janboerman.f2pstarassist.common.*;
import com.janboerman.f2pstarassist.common.util.CollectionConvert;
import static com.janboerman.f2pstarassist.common.web.StarJson.*;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class JsonTest {

    private static final String[] GROUPS = {"ONE", "TWO", "THREE", "FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "TEN"};
    private static final StarLocation[] LOCATIONS = StarLocation.values();
    private static final StarTier[] TIERS = StarTier.values();
    private static final String[] USER_NAMES = {"Jannyboy11", "John Doe", "Alice", "Bob"};

    private final Random random = new Random();

    private Set<GroupKey> makeGroups() {
        int size = random.nextInt(3);

        Set<GroupKey> result = new HashSet<>();
        for (int i = 0; i < size; i++) {
            result.add(new GroupKey(GROUPS[i]));
        }
        return result;
    }

    private StarLocation makeStarLocation() {
        return LOCATIONS[random.nextInt(LOCATIONS.length)];
    }

    private int makeWorld() {
        int diff = 576 - 301;
        return random.nextInt(diff) + 301;
    }

    private StarTier makeTier() {
        return TIERS[random.nextInt(TIERS.length)];
    }

    private Instant makeDetectedAt() {
        return Instant.now().plus(random.nextInt(7200), ChronoUnit.SECONDS);
    }

    private User makeDetectedBy() {
        switch (random.nextInt(3)) {
            case 0:
                return User.unknown();
            case 1:
                return new RunescapeUser(USER_NAMES[random.nextInt(USER_NAMES.length)]);
            case 2:
                return new DiscordUser(USER_NAMES[random.nextInt(USER_NAMES.length)]);
        }
        throw new RuntimeException("Non-exhaustive switch!");
    }

    private StarKey makeStarKey() {
        return new StarKey(makeStarLocation(), makeWorld());
    }

    private StarUpdate makeStarUpdate() {
        return new StarUpdate(makeStarKey(), makeTier());
    }

    private StarRequest makeStarRequest() {
        return new StarRequest(Stream.generate(this::makeCrashedStar).limit(random.nextInt(10)).collect(Collectors.toSet()));
    }

    private CrashedStar makeCrashedStar() {
        return new CrashedStar(makeTier(), makeStarLocation(), makeWorld(), makeDetectedAt(), makeDetectedBy());
    }

    private StarPacket makeStarPacket() {
        Payload payload;
        switch (random.nextInt(4)) {
            case 0: payload = makeCrashedStar(); break;
            case 1: payload = makeStarKey(); break;
            case 2: payload = makeStarUpdate(); break;
            case 3: payload = makeStarRequest(); break;
            default: payload = null;
        }
        return new StarPacket(makeGroups(), payload);
    }

    private StarList makeStarList() {
        final Map<Set<CrashedStar>, Set<GroupKey>> fresh = new HashMap<>();
        final Set<StarUpdate> updates = new HashSet<>();
        final Set<StarKey> deleted = new HashSet<>();

        final int maxFresh = random.nextInt(4);
        final int maxUpdates = random.nextInt(4);
        final int maxDeleted = random.nextInt(4);

        for (int i = 0; i < maxFresh; i++) {
            Set<CrashedStar> starSet = Stream.generate(this::makeCrashedStar).limit(random.nextInt(4)).collect(Collectors.toSet());
            Set<GroupKey> groupSet = Arrays.stream(GROUPS).map(GroupKey::new).limit(random.nextInt(GROUPS.length)).collect(Collectors.toSet());
            fresh.put(starSet, groupSet);
        }
        for (int i = 0; i < maxUpdates; i++) {
            Set<StarUpdate> updateSet = Stream.generate(this::makeStarUpdate).limit(random.nextInt(4)).collect(Collectors.toSet());
            updates.addAll(updateSet);
        }
        for (int i = 0; i < maxDeleted; i++) {
            Set<StarKey> deleteSet = Stream.generate(this::makeStarKey).limit(random.nextInt(4)).collect(Collectors.toSet());
            deleted.addAll(deleteSet);
        }

        return new StarList(fresh, updates, deleted);
    }

    @Test
    public void testStarList() {
        final StarList starList = makeStarList();

        assertEquals(starList, starList(starListJson(starList)));
    }

    @Test
    public void testStarPacket() {
        final StarPacket starPacket = makeStarPacket();

        assertEquals(starPacket, starPacket(starPacketJson(starPacket)));
    }

    @Test
    public void testCrashedStar() {
        final CrashedStar crashedStar = makeCrashedStar();

        assertEquals(crashedStar, crashedStar(crashedStarJson(crashedStar)));
    }

    @Test
    public void testCrashedStars() {
        final Set<CrashedStar> stars = CollectionConvert.toSet(Arrays.asList(makeCrashedStar(), makeCrashedStar(), makeCrashedStar()));
        final Set<CrashedStar> noStars = Collections.emptySet();

        assertEquals(stars, crashedStars(crashedStarsJson(stars)));
        assertEquals(noStars, crashedStars(crashedStarsJson(noStars)));
    }

    @Test
    public void testStarUpdate() {
        final StarUpdate starUpdate = makeStarUpdate();

        assertEquals(starUpdate, starUpdate(starUpdateJson(starUpdate)));;
    }

    @Test
    public void testStarKey() {
        final StarKey starKey = makeStarKey();

        assertEquals(starKey, starKey(starKeyJson(starKey)));
    }

    @Test
    public void testGroupKeys() {
        final Set<GroupKey> groups = makeGroups();

        assertEquals(groups, groupKeys(groupKeysJson(groups)));
    }

}

package com.janboerman.f2pstarassist.plugin;

import com.janboerman.f2pstarassist.common.StarLocation;
import static com.janboerman.f2pstarassist.plugin.StarPoints.toLocation;
import static com.janboerman.f2pstarassist.plugin.StarPoints.fromLocation;

import net.runelite.api.coords.WorldPoint;
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

public class StarPointsTest {

    @Test
    public void testStarLocationRoundTrip() {
        for (StarLocation starLocation : StarLocation.values()) {
            assertEquals(starLocation, toLocation(fromLocation(starLocation)));
        }
    }

    @Test
    public void testWorldPointRoundTrip() throws IllegalAccessException {
        for (Field field : StarPoints.class.getDeclaredFields()) {
            if ((field.getModifiers() & Modifier.STATIC) == Modifier.STATIC && field.getType() == WorldPoint.class) {
                WorldPoint worldPoint = (WorldPoint) field.get(null);
                assertEquals(worldPoint, fromLocation(toLocation(worldPoint)));
            }
        }
    }

}

package com.janboerman.f2pstarassist.plugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class StarAssistPluginTest {

	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(StarAssistPlugin.class);
		RuneLite.main(args);
	}

}
package com.janboerman.f2pstarassist.common;

import java.util.Comparator;
import java.util.Objects;

public final class StarKey implements Comparable<StarKey>, Payload {

    private static final Comparator<StarKey> COMPARATOR = Comparator
            .comparing(StarKey::getLocation)
            .thenComparing(StarKey::getWorld);

    private final StarLocation location;
    private final int world;

    public StarKey(StarLocation location, int world) {
        this.location = Objects.requireNonNull(location);
        this.world = Objects.requireNonNull(world);
    }

    public StarLocation getLocation() {
        return location;
    }

    public int getWorld() {
        return world;
    }

    @Override
    public int hashCode() {
        return Objects.hash(location, world);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) return true;
        if (!(obj instanceof StarKey)) return false;

        StarKey that = (StarKey) obj;
        return this.location == that.location && this.world == that.world;
    }

    @Override
    public int compareTo(StarKey that) {
        return COMPARATOR.compare(this, that);
    }

    @Override
    public String toString() {
        return "StarKey{location=" + location + ",world=" + world + "}";
    }

}

package com.janboerman.f2pstarassist.common.util;

import java.util.*;

public class CollectionConvert {

    private CollectionConvert() {
    }

    public static <E> Set<E> toSet(Collection<E> coll) {
        if (coll instanceof Set) {
            return (Set<E>) coll;
        } else {
            return new LinkedHashSet<>(coll);
        }
    }

}

package com.janboerman.f2pstarassist.common;

import java.util.Objects;
import java.util.Set;

public class StarPacket {

    private final Set<GroupKey> groups;
    private final Payload payload;

    public StarPacket(Set<GroupKey> groups, Payload payload) {
        this.groups = Objects.requireNonNull(groups, "groups cannot be null");
        this.payload = Objects.requireNonNull(payload, "payload cannot be null");
    }

    public Set<GroupKey> getGroups() {
        return groups;
    }

    public Payload getPayload() {
        return payload;
    }

    @Override
    public String toString() {
        return "StarPacket" +
                "{groups=" + groups +
                ",payload=" + payload +
                "}";
    }

    @Override
    public int hashCode() {
        return Objects.hash(groups, payload);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof StarPacket)) return false;

        StarPacket that = (StarPacket) o;
        return Objects.equals(this.getGroups(), that.getGroups())
                && Objects.equals(this.getPayload(), that.getPayload());
    }

}

package com.janboerman.f2pstarassist.common;

import java.util.Collections;
import java.util.Objects;
import java.util.Set;

//what the client sends to the server to get a StarList
public final class StarRequest implements Payload {

    private Set<CrashedStar> knownStars;

    public StarRequest(Set<CrashedStar> knownStars) {
        this.knownStars = Objects.requireNonNull(knownStars);
    }

    public Set<CrashedStar> getKnownStars() {
        return Collections.unmodifiableSet(knownStars);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof StarRequest)) return false;

        StarRequest that = (StarRequest) o;
        return Objects.equals(this.getKnownStars(), that.getKnownStars());
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(getKnownStars());
    }

    @Override
    public String toString() {
        return "StarRequest"
                + "{knownStars=" + getKnownStars()
                + "}";
    }

}

package com.janboerman.f2pstarassist.common;

import java.util.Objects;

public final class RunescapeUser implements User {

    private final String name; //rsn

    public RunescapeUser(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof RunescapeUser)) return false;

        RunescapeUser that = (RunescapeUser) o;
        return Objects.equals(this.getName(), that.getName());
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(getName());
    }

    @Override
    public String toString() {
        return getName();
    }
}

package com.janboerman.f2pstarassist.common;

import java.util.Objects;

public final class GroupKey {

    private String key;

    public GroupKey(String key) {
        this.key = Objects.requireNonNull(key, "key cannot be null");
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof GroupKey)) return false;

        GroupKey that = (GroupKey) o;
        return Objects.equals(this.key, that.key);
    }

    @Override
    public int hashCode() {
        return key.hashCode();
    }

    @Override
    public String toString() {
        return key;
    }
}

package com.janboerman.f2pstarassist.common;

import com.google.common.cache.*;

import java.time.Duration;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.StringJoiner;
import java.util.concurrent.TimeUnit;

public class StarCache {

    private final Cache<StarKey, CrashedStar> cache;

    private static CacheBuilder<StarKey, CrashedStar> newCacheBuilder() {
        return (CacheBuilder<StarKey, CrashedStar>) (CacheBuilder) CacheBuilder.newBuilder();
    }

    private StarCache(CacheBuilder<StarKey, CrashedStar> cacheBuilder) {
        this.cache = cacheBuilder
                .expireAfterWrite(150, TimeUnit.MINUTES)    // 2 hours, 30 minutes
                .build();
    }

    public StarCache(RemovalListener<StarKey, CrashedStar> removalListener) {
        this(newCacheBuilder().removalListener(removalListener));
    }

    public StarCache() {
        this(newCacheBuilder());
    }

    //returns the old star
    public CrashedStar add(CrashedStar newStar) {
        StarKey key = newStar.getKey();
        CrashedStar oldStar = cache.getIfPresent(key);
        if (oldStar != null) {
            if (newStar.getTier().getSize() > oldStar.getTier().getSize()) {
                cache.put(key, newStar);
            } //else: old star had a higher tier already
        } else {
            cache.put(key, newStar);
        }
        return oldStar;
    }

    //returns true if a star was added, false otherwise
    public boolean addAll(Collection<CrashedStar> stars) {
        boolean result = false;
        for (CrashedStar star : stars) {
            result |= (add(star) == null);
        }
        return result;
    }

    public CrashedStar get(StarKey key) {
        CrashedStar crashedStar = cache.getIfPresent(key);
        if (crashedStar == null /*does not exist*/
                || crashedStar.getDetectedAt().isBefore(Instant.now().minus(2, ChronoUnit.HOURS))) /*more than two hours ago*/ {
            return null;
        } else {
            return crashedStar;
        }
    }

    //returns the old star
    public CrashedStar forceAdd(CrashedStar star) {
        return cache.asMap().put(star.getKey(), star);
    }

    //returns the old star
    public CrashedStar remove(StarKey starKey) {
        CrashedStar existing = get(starKey);
        cache.invalidate(starKey);
        return existing;
    }

    public boolean contains(StarKey starKey) {
        return get(starKey) != null;
    }

    public Set<CrashedStar> getStars() {
        return new HashSet<>(cache.asMap().values());
    }

    public void clear() {
        cache.invalidateAll();
    }

    @Override
    public String toString() {
        StringJoiner stringJoiner = new StringJoiner(", ", "StarCache{", "}");
        for (Map.Entry<StarKey, CrashedStar> entry : cache.asMap().entrySet()) {
            stringJoiner.add(entry.getKey() + "=" + entry.getValue().getTier());
        }
        return stringJoiner.toString();
    }
}

package com.janboerman.f2pstarassist.common;

import java.util.Objects;

public final class StarUpdate implements Payload {

    private final StarLocation location;
    private final int world;
    private final StarTier tier;

    public StarUpdate(StarTier tier, StarLocation location, int world) {
        this.tier = Objects.requireNonNull(tier);
        this.location = Objects.requireNonNull(location);
        this.world = world;
    }

    public StarUpdate(StarKey starKey, StarTier tier) {
        this(tier, starKey.getLocation(), starKey.getWorld());
    }

    public StarLocation getLocation() {
        return location;
    }

    public int getWorld() {
        return world;
    }

    public StarTier getTier() {
        return tier;
    }

    public StarKey getKey() {
        return new StarKey(getLocation(), getWorld());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getLocation(), getWorld(), getTier());
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof StarUpdate)) return false;

        StarUpdate that = (StarUpdate) o;
        return this.getLocation() == that.getLocation()
                && this.getWorld() == that.getWorld()
                && this.getTier() == that.getTier();
    }

    @Override
    public String toString() {
        return "StarUpdate{location=" + getLocation() + ",world=" + getWorld() + ",tier=" + getTier() + "}";
    }
}

package com.janboerman.f2pstarassist.common;

import java.util.Objects;

public final class DiscordUser implements User {

    private final String name; //display name
    //possibly: private final String tag;

    public DiscordUser(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof DiscordUser)) return false;

        DiscordUser that = (DiscordUser) o;
        return Objects.equals(this.getName(), that.getName());
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(getName());
    }

    @Override
    public String toString() {
        return getName();
    }
}

package com.janboerman.f2pstarassist.common.lingo;

import com.janboerman.f2pstarassist.common.StarLocation;
import com.janboerman.f2pstarassist.common.StarTier;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StarLingo {

    private static final Pattern TIER_PATTERN = Pattern.compile(".*?[t|T|s|S](ier|ize)?\\s*(?<tier>[1-9]).*");
    private static final Pattern WORLD_PATTERN = Pattern.compile(".*?([w|W](orld)?)?\\s*(?<world>\\d{3}).*");

    private StarLingo() {
    }

    /**
     * Try to get the world from a string of text. Note that the returned number may not be an existing world.
     * @param text the input
     * @return the world, or -1 if the text didn't contain a world
     */
    public static int interpretWorld(String text) {
        Matcher matcher = WORLD_PATTERN.matcher(text);
        if (matcher.matches()) {
            String world = matcher.group("world");
            return Integer.parseInt(world);
        }
        return -1;
    }

    /**
     * Try to get the tier of the star.
     * @param text the input
     * @return the star's tier, or null if the tier could not be recognised
     */
    public static StarTier interpretTier(String text) {
        Matcher matcher = TIER_PATTERN.matcher(text);
        if (matcher.matches()) {
            String tier = matcher.group("tier");
            switch (tier) {
                case "9": return StarTier.SIZE_9;
                case "8": return StarTier.SIZE_8;
                case "7": return StarTier.SIZE_7;
                case "6": return StarTier.SIZE_6;
                case "5": return StarTier.SIZE_5;
                case "4": return StarTier.SIZE_4;
                case "3": return StarTier.SIZE_3;
                case "2": return StarTier.SIZE_2;
                case "1": return StarTier.SIZE_1;
            }
        }
        return null;
    }

    /**
     * Try to get the location from a string of text.
     * @param text the input
     * @return the star's location, or null if the location couldn't be recognised
     */
    //TODO return a Set<StarLocation> instead? then it's possible to return multiple locations if it's ambiguous (e.g. just 'Crandor')
    public static StarLocation interpretLocation(String text) {
        //dwarven mine, falador, rimmington, crafting guild
        if (containsAnyIgnoreCase(text, "dwarf", "dwarven", "ice"))
            return StarLocation.DWARVEN_MINE;
        if (containsAnyIgnoreCase(text, "falador", "fally", "mining guild"))
            return StarLocation.MINING_GUILD;
        if (containsAnyIgnoreCase(text, "craft", "cg"))
            return StarLocation.CRAFTING_GUILD;
        if (containsIgnoreCase(text, "rim"))
            return StarLocation.RIMMINGTON_MINE;

        //draynor, lumbridge
        if (containsIgnoreCase(text, "dray"))
            return StarLocation.DRAYNOR_VILLAGE_BANK;
        if (containsAnyIgnoreCase(text, "lumbridge", "swamp", "lumby"))
            if (containsAnyIgnoreCase(text, "east", "se"))
                return StarLocation.LUMBRIDGE_SWAMP_SOUTH_EAST_MINE;
            else if (containsAnyIgnoreCase(text, "west", "sw")) //test this after lumbridge swamp east mine becase 'swamp' contains 'sw'
                return StarLocation.LUMBRIDGE_SWAMP_SOUTH_WEST_MINE;
        if (containsAnyIgnoreCase(text, "lsw", "lmw", "swl"))
            return StarLocation.LUMBRIDGE_SWAMP_SOUTH_WEST_MINE;
        if (containsAnyIgnoreCase(text, "lse", "lme", "sel"))
            return StarLocation.LUMBRIDGE_SWAMP_SOUTH_EAST_MINE;

        //varrock
        if (containsIgnoreCase(text, "varrock"))
            if (containsIgnoreCase(text, "bank"))
                return StarLocation.VARROCK_AUBURY;
            else if (containsAnyIgnoreCase(text, "west", "sw"))
                return StarLocation.VARROCK_SOUTH_WEST_MINE;
            else if (containsAnyIgnoreCase(text, "east", "se"))
                return StarLocation.VARROCK_SOUTH_EAST_MINE;
            else
                return StarLocation.VARROCK_AUBURY;
        if (containsIgnoreCase(text, "aubury"))
            return StarLocation.VARROCK_AUBURY;
        if (containsAnyIgnoreCase(text, "vsw", "vmw", "swv") || containsAllIgnoreCase(text, "champ", "guild"))
            return StarLocation.VARROCK_SOUTH_WEST_MINE;
        if (containsAnyIgnoreCase(text, "vse", "vme", "sev"))
            return StarLocation.VARROCK_SOUTH_EAST_MINE;
        if (containsAnyIgnoreCase(text, "veb", "vb"))
            return StarLocation.VARROCK_AUBURY;

        //al kharid, pvp arena
        if (containsAllIgnoreCase(text, "desert", "mine") || containsIgnoreCase(text, "akm"))
            return StarLocation.AL_KHARID_MINE;
        if (containsAllIgnoreCase(text, "al", "kharid") || containsAnyIgnoreCase(text, "alk", "ally", "ak"))
            if (containsIgnoreCase(text, "bank"))
                return StarLocation.AL_KHARID_BANK;
            else if (containsIgnoreCase(text, "mine"))
                return StarLocation.AL_KHARID_MINE;
        if (containsAnyIgnoreCase(text, "duel", "da", "arena", "pvp", "pa"))
            return StarLocation.PVP_ARENA;
        if (containsIgnoreCase(text, "akb"))
            return StarLocation.AL_KHARID_BANK;

        //crandor, corsair cove
        if (containsIgnoreCase(text, "crandor"))
            if (containsIgnoreCase(text, "north"))
                return StarLocation.CRANDOR_NORTH_MINE;
            else if (containsIgnoreCase(text, "south"))
                return StarLocation.CRANDOR_SOUTH_MINE;
        if (containsIgnoreCase(text, "nc"))
            return StarLocation.CRANDOR_NORTH_MINE;
        if (containsIgnoreCase(text, "sc"))
            return StarLocation.CRANDOR_SOUTH_MINE;
        if (containsIgnoreCase(text, "corsair"))
            if (containsIgnoreCase(text, "bank"))
                return StarLocation.CORSAIR_COVE_BANK;
            else
                return StarLocation.CORSAIR_COVE_RESOURCE_AREA;
        if (containsIgnoreCase(text, "ogress"))
            return StarLocation.CORSAIR_COVE_RESOURCE_AREA;
        if (containsIgnoreCase(text, "cra"))
            return StarLocation.CORSAIR_COVE_RESOURCE_AREA;
        if (containsIgnoreCase(text, "ccb"))
            return StarLocation.CORSAIR_COVE_BANK;

        //wildy
        if (containsAnyIgnoreCase(text, "wildy", "wilderness"))
            if (containsAnyIgnoreCase(text, "centre", "center", "bandit", "camp", "hobgoblins"))
                return StarLocation.WILDERNESS_CENTRE_MINE;
            else if (containsAnyIgnoreCase(text, "dark", "warrior", "fortress", "skeles", "skeletons")
                    || containsAllIgnoreCase(text, "south", "west"))
                return StarLocation.WILDERNESS_SOUTH_WEST_MINE;
            else if ((containsIgnoreCase(text, "south") && !containsIgnoreCase(text, "west"))
                    || containsAnyIgnoreCase(text, "mage", "zamorak", "zammy"))
                return StarLocation.WILDERNESS_SOUTH_MINE;
        if (containsAnyIgnoreCase(text, "rune", "runite", "lava", "maze", "rr"))
            return StarLocation.WILDERNESS_RUNITE_MINE;
        if (containsIgnoreCase(text, "hobgob"))
            return StarLocation.WILDERNESS_CENTRE_MINE;
        if (containsIgnoreCase(text, "skeleton"))
            return StarLocation.WILDERNESS_SOUTH_WEST_MINE;
        if (containsIgnoreCase(text,"abyss"))
            return StarLocation.WILDERNESS_SOUTH_MINE;

        //could not recognise location
        return null;
    }

    public static boolean containsAnyIgnoreCase(String string, String... lookups) {
        for (String lookup : lookups) if (containsIgnoreCase(string, lookup)) return true;
        return false;
    }

    public static boolean containsAllIgnoreCase(String string, String... lookups) {
        for (String lookup : lookups) if (!containsIgnoreCase(string, lookup)) return false;
        return true;
    }

    public static boolean containsIgnoreCase(String string, String lookup) {
        return string.toLowerCase().contains(lookup.toLowerCase());
    }

}

package com.janboerman.f2pstarassist.common;

public interface Payload /*permits CrashedStar, StarKey, StarUpdate, StarRequest*/ {
}

package com.janboerman.f2pstarassist.common;

public enum StarLocation {

    WILDERNESS_RUNITE_MINE("Wilderness runite mine"),
    WILDERNESS_CENTRE_MINE("Wilderness centre mine"),
    WILDERNESS_SOUTH_WEST_MINE("Wilderness south west mine"),
    WILDERNESS_SOUTH_MINE("Wilderness south mine"),

    DWARVEN_MINE("Dwarven Mine"),
    MINING_GUILD("Mining Guild"),
    CRAFTING_GUILD("Crafting Guild"),
    RIMMINGTON_MINE("Rimmington mine"),

    DRAYNOR_VILLAGE_BANK("Draynor Village bank"),
    LUMBRIDGE_SWAMP_SOUTH_WEST_MINE("Lumbridge Swamp west mine"),
    LUMBRIDGE_SWAMP_SOUTH_EAST_MINE("Lumbridge Swamp east mine"),

    VARROCK_SOUTH_WEST_MINE("Varrock south west mine"),
    VARROCK_SOUTH_EAST_MINE("Varrock south east mine"),
    VARROCK_AUBURY("Varrock east bank"),

    AL_KHARID_MINE("Al Kharid mine"),
    AL_KHARID_BANK("Al Kharid bank"),
    PVP_ARENA("PvP Arena"),

    CRANDOR_NORTH_MINE("Crandor north mine"),
    CRANDOR_SOUTH_MINE("Crandor south mine"),
    CORSAIR_COVE_BANK("Corsair Cove bank"),
    CORSAIR_COVE_RESOURCE_AREA("Corsair Cove resource area");

    private final String humanFriendlyName;

    private StarLocation(String name) {
        this.humanFriendlyName = name;
    }

    @Override
    public String toString() {
        return humanFriendlyName;
    }

    public boolean isInWilderness() {
        switch (this) {
            case WILDERNESS_RUNITE_MINE:
            case WILDERNESS_CENTRE_MINE:
            case WILDERNESS_SOUTH_WEST_MINE:
            case WILDERNESS_SOUTH_MINE:
                return true;
            default:
                return false;
        }
    }

}

package com.janboerman.f2pstarassist.common;

import java.time.Instant;
import java.util.Comparator;
import java.util.Objects;

public final class CrashedStar implements Comparable<CrashedStar>, Payload, Cloneable {

    private static final Comparator<CrashedStar> COMPARATOR = Comparator
            .comparing(CrashedStar::getTier)
            .thenComparing(CrashedStar::getWorld)
            .thenComparing(CrashedStar::getLocation);

    private final StarLocation location;
    private final int world;
    private StarTier tier;

    private final Instant detectedAt;
    private final User discoveredBy;

    public CrashedStar(StarTier tier, StarLocation location, int world, Instant detectedAt, User discoveredBy) {
        Objects.requireNonNull(tier,"tier cannot be null");
        Objects.requireNonNull(location, "location cannot be null");
        Objects.requireNonNull(detectedAt, "detection timestamp cannot be null");

        this.tier = tier;
        this.location = location;
        this.world = world;
        this.detectedAt = detectedAt;
        this.discoveredBy = discoveredBy;   //differentiate between a Discord user and a RuneScape user?
        //number of miners?
    }

    public CrashedStar(StarKey key, StarTier tier, Instant detectedAt, User discoveredBy) {
        this(tier, key.getLocation(), key.getWorld(), detectedAt, discoveredBy);
    }

    @Override
    public CrashedStar clone() {
        return new CrashedStar(tier, location, world, detectedAt, discoveredBy);
    }

    public synchronized StarTier getTier() {
        return tier;
    }

    public synchronized void setTier(StarTier lowerTier) {
        assert lowerTier != null : "tier cannot be null";
        tier = lowerTier;
    }

    public StarLocation getLocation() {
        return location;
    }

    public int getWorld() {
        return world;
    }

    public Instant getDetectedAt() {
        return detectedAt;
    }

    public User getDiscoveredBy() {
        return discoveredBy;
    }

    public StarKey getKey() {
        return new StarKey(getLocation(), getWorld());
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof CrashedStar)) return false;

        CrashedStar that = (CrashedStar) o;
        return this.getLocation() == that.getLocation()
                && this.getWorld() == that.getWorld()
                && this.getTier() == that.getTier();
    }

    @Override
    public int hashCode() {
        return Objects.hash(getLocation(), getWorld(), getTier());
    }

    @Override
    public int compareTo(CrashedStar that) {
        return COMPARATOR.compare(this, that);
    }

    @Override
    public String toString() {
        return "CrashedStar"
                + "{tier=" + getTier()
                + ",location=" + getLocation()
                + ",world=" + getWorld()
                + ",detected at=" + getDetectedAt()
                + ",discovered by=" + getDiscoveredBy()
                + "}";
    }

}

package com.janboerman.f2pstarassist.common;

public interface User /*permits RunescapeUser, DiscordUser, UnknownUser*/ {

    public static User unknown() {
        return UnknownUser.INSTANCE;
    }
}

class UnknownUser implements User {

    static final UnknownUser INSTANCE = new UnknownUser();

    private UnknownUser() {
    }

}

package com.janboerman.f2pstarassist.common;

public enum StarTier {

    SIZE_1,
    SIZE_2,
    SIZE_3,
    SIZE_4,
    SIZE_5,
    SIZE_6,
    SIZE_7,
    SIZE_8,
    SIZE_9;

    private static final StarTier[] VALUES = new StarTier[] {SIZE_1, SIZE_2, SIZE_3, SIZE_4, SIZE_5, SIZE_6, SIZE_7, SIZE_8, SIZE_9};

    public int getSize() {
        return ordinal() + 1;
    }

    @Override
    public String toString() {
        return "size-" + getSize();
    }

    public int getRequiredMiningLevel() {
        return getSize() * 10;
    }

    public StarTier oneLess() {
        switch (this) {
            case SIZE_1: return null;
            default: return VALUES[ordinal() - 1];
        }
    }

    public static StarTier bySize(int size) {
        if (size <= 0 || size > 9)
            throw new IllegalArgumentException("size must be in range [1-9]");

        return VALUES[size - 1];
    }
}

package com.janboerman.f2pstarassist.common;

import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

//what the server responds with when the client sends a StarRequest
public final class StarList {

    private Map<Set<CrashedStar>, Set<GroupKey>> freshStars;
    private Set<StarUpdate> starUpdates;
    private Set<StarKey> deletedStars;

    //the json representation of a Map<Set<CrashedStar>, Set<GroupKey>> could be something like [{ "stars" : [star1, star2, star3, ...], "owned by" : [group1, group2, group3, ...] }, ...]

    public StarList(Map<Set<CrashedStar>, Set<GroupKey>> freshStars,
                    Set<StarUpdate> starUpdates,
                    Set<StarKey> deletedStars) {
        this.freshStars = Objects.requireNonNull(freshStars);
        this.starUpdates = Objects.requireNonNull(starUpdates);
        this.deletedStars = Objects.requireNonNull(deletedStars);
    }

    public Map<Set<CrashedStar>, Set<GroupKey>> getFreshStars() {
        return Collections.unmodifiableMap(freshStars);
    }

    public Set<StarUpdate> getStarUpdates() {
        return Collections.unmodifiableSet(starUpdates);
    }

    public Set<StarKey> getDeletedStars() {
        return Collections.unmodifiableSet(deletedStars);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof StarList)) return false;

        StarList that = (StarList) o;
        return Objects.equals(this.getFreshStars(), that.getFreshStars())
                && Objects.equals(this.getStarUpdates(), that.getStarUpdates())
                && Objects.equals(this.getDeletedStars(), that.getDeletedStars());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getFreshStars(), getStarUpdates(), getDeletedStars());
    }

    @Override
    public String toString() {
        return "StarList"
                + "{freshStars=" + getFreshStars()
                + ",starUpdates=" + getStarUpdates()
                + ",deletedStars=" + getDeletedStars()
                + "}";
    }
}

package com.janboerman.f2pstarassist.common.web;

public class EndPoints {

    private EndPoints() {}

    public static final String ALL_STARS = "/stars";            //POST (GET is more suitable but okhttp3 is disallowing GET requests with a body)
    public static final String SEND_STAR = "/send_star";        //PUT
    public static final String UPDATE_STAR = "/update_star";    //PATCH
    public static final String DELETE_STAR = "/poofed_star";    //DELETE

}

package com.janboerman.f2pstarassist.common.web;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.janboerman.f2pstarassist.common.*;

import com.google.gson.JsonObject;

import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

public class StarJson {

    private StarJson() {
    }

    public static StarList starList(JsonObject starList) {
        Map<Set<CrashedStar>, Set<GroupKey>> freshStars = readFreshStars(starList);
        Set<StarUpdate> starUpdates = readStarUpdates(starList);
        Set<StarKey> deletedStars = readDeletedStars(starList);
        return new StarList(freshStars, starUpdates, deletedStars);
    }

    public static JsonObject starListJson(StarList starList) {
        JsonObject result = new JsonObject();
        writeFreshStars(result, starList.getFreshStars());
        writeStarUpdates(result, starList.getStarUpdates());
        writeDeletedStars(result, starList.getDeletedStars());
        return result;
    }

    public static StarRequest starRequest(JsonArray starRequest) {
        return new StarRequest(crashedStars(starRequest));
    }

    public static JsonArray starRequestJson(StarRequest starRequest) {
        return crashedStarsJson(starRequest.getKnownStars());
    }

    public static StarPacket starPacket(JsonObject starPacket) {
        Set<GroupKey> groups = readGroupKeys(starPacket);
        Payload payload = readPayload(starPacket);
        return new StarPacket(groups, payload);
    }

    public static JsonObject starPacketJson(StarPacket packet) {
        JsonObject result = new JsonObject();
        writeGroupKeys(result, packet.getGroups());
        writePayload(result, packet.getPayload());
        return result;
    }

    public static CrashedStar crashedStar(JsonObject crashedStar) {
        StarTier tier = readTier(crashedStar);
        StarLocation location = readLocation(crashedStar);
        int world = readWorld(crashedStar);
        Instant detectedAt = readDetectedAt(crashedStar);
        User discoveredBy = readDiscoveredBy(crashedStar);
        return new CrashedStar(tier, location, world, detectedAt, discoveredBy);
    }

    public static JsonObject crashedStarJson(CrashedStar crashedStar) {
        JsonObject result = new JsonObject();
        writeTier(result, crashedStar.getTier());
        writeLocation(result, crashedStar.getLocation());
        writeWorld(result, crashedStar.getWorld());
        writeDetectedAt(result, crashedStar.getDetectedAt());
        writeDiscoveredBy(result, crashedStar.getDiscoveredBy());
        return result;
    }

    public static Set<CrashedStar> crashedStars(JsonArray jsonArray) {
        Set<CrashedStar> result = new TreeSet<>();
        for (JsonElement element : jsonArray) {
            if (element instanceof JsonObject) {
                JsonObject jsonObject = (JsonObject) element;
                result.add(crashedStar(jsonObject));
            }
        }
        return result;
    }

    public static JsonArray crashedStarsJson(Set<CrashedStar> crashedStars) {
        JsonArray jsonArray = new JsonArray(crashedStars.size());
        for (CrashedStar star : crashedStars) {
            jsonArray.add(crashedStarJson(star));
        }
        return jsonArray;
    }

    public static StarUpdate starUpdate(JsonObject starUpdate) {
        StarTier tier = readTier(starUpdate);
        StarLocation location = readLocation(starUpdate);
        int world = readWorld(starUpdate);
        return new StarUpdate(tier, location, world);
    }

    public static JsonObject starUpdateJson(StarUpdate starUpdate) {
        JsonObject result = new JsonObject();
        writeTier(result, starUpdate.getTier());
        writeLocation(result, starUpdate.getLocation());
        writeWorld(result, starUpdate.getWorld());
        return result;
    }

    public static Set<StarUpdate> starUpdates(JsonArray jsonArray) {
        return StreamSupport.stream(jsonArray.spliterator(), false)
                .filter(jsonElement -> jsonElement instanceof JsonObject)
                .map(jsonElement -> starUpdate((JsonObject) jsonElement))
                .collect(Collectors.toSet());
    }

    public static JsonArray starUpdatesJson(Set<StarUpdate> starUpdates) {
        return starUpdates.stream()
                .map(StarJson::starUpdateJson)
                .collect(JsonArray::new, JsonArray::add, JsonArray::addAll);
    }

    public static StarKey starKey(JsonObject starKey) {
        StarLocation starLocation = readLocation(starKey);
        int world = readWorld(starKey);
        return new StarKey(starLocation, world);
    }

    public static JsonObject starKeyJson(StarKey starKey) {
        JsonObject result = new JsonObject();
        writeLocation(result, starKey.getLocation());
        writeWorld(result, starKey.getWorld());
        return result;
    }

    public static Set<StarKey> starKeys(JsonArray jsonArray){
        return StreamSupport.stream(jsonArray.spliterator(), false)
                .filter(jsonElement -> jsonElement instanceof JsonObject)
                .map(jsonElement -> starKey((JsonObject) jsonElement))
                .collect(Collectors.toSet());
    }


    public static JsonArray starKeysJson(Set<StarKey> deletedStars){
        return deletedStars.stream()
                .map(StarJson::starKeyJson)
                .collect(JsonArray::new, JsonArray::add, JsonArray::addAll);
    }

    public static Set<GroupKey> groupKeys(JsonArray groupKeys) {
        return StreamSupport.stream(groupKeys.spliterator(), false)
                .map(jsonElem -> new GroupKey(jsonElem.getAsString()))
                .collect(Collectors.toSet());
    }

    public static JsonArray groupKeysJson(Set<GroupKey> groupKeys) {
        return groupKeys.stream()
                .map(groupKey -> new JsonPrimitive(groupKey.toString()))
                .collect(JsonArray::new, JsonArray::add, JsonArray::addAll);
    }

    // ============================== helper methods ============================== \\

    private static StarTier readTier(JsonObject crashedStar) {
        return StarTier.bySize(crashedStar.get("tier").getAsInt());
    }

    private static void writeTier(JsonObject crashedStar, StarTier tier) {
        crashedStar.add("tier", new JsonPrimitive(tier.getSize()));
    }

    private static StarLocation readLocation(JsonObject crashedStar) {
        String locationString = crashedStar.get("location").getAsString();
        if ("DUEL_ARENA".equals(locationString)) {
            return StarLocation.PVP_ARENA;
        } else {
            return StarLocation.valueOf(locationString);
        }
    }

    private static void writeLocation(JsonObject crashedStar, StarLocation starLocation) {
        crashedStar.add("location", new JsonPrimitive(starLocation.name()));
    }

    private static int readWorld(JsonObject crashedStar) {
        return crashedStar.get("world").getAsInt();
    }

    private static void writeWorld(JsonObject crashedStar, int world) {
        crashedStar.add("world", new JsonPrimitive(world));
    }

    private static Instant readDetectedAt(JsonObject crashedStar) {
        return Instant.ofEpochMilli(crashedStar.get("detected at").getAsLong());
    }

    private static void writeDetectedAt(JsonObject crashedStar, Instant detectedAt) {
        crashedStar.add("detected at", new JsonPrimitive(detectedAt.toEpochMilli()));
    }

    private static User readDiscoveredBy(JsonObject crashedStar) {
        JsonElement jsonElement = crashedStar.get("discovered by");
        if (jsonElement == null) return User.unknown();

        JsonObject user = jsonElement.getAsJsonObject();
        String type = user.get("type").getAsString();
        switch (type) {
            case "RuneScape": return new RunescapeUser(user.get("name").getAsString());
            case "Discord": return new DiscordUser(user.get("name").getAsString());
            default: return User.unknown();
        }
    }

    private static void writeDiscoveredBy(JsonObject crashedStar, User discoveredBy) {
        if (discoveredBy instanceof RunescapeUser) {
            RunescapeUser user = (RunescapeUser) discoveredBy;
            JsonObject jsonUser = new JsonObject();
            jsonUser.add("type", new JsonPrimitive("RuneScape"));
            jsonUser.add("name", new JsonPrimitive(user.getName()));
            crashedStar.add("discovered by", jsonUser);
        } else if (discoveredBy instanceof DiscordUser) {
            DiscordUser user = (DiscordUser) discoveredBy;
            JsonObject jsonUser = new JsonObject();
            jsonUser.add("type", new JsonPrimitive("Discord"));
            jsonUser.add("name", new JsonPrimitive(user.getName()));
            crashedStar.add("discovered by", jsonUser);
        }
    }

    private static Set<GroupKey> readGroupKeys(JsonObject starPacket) {
        JsonArray jsonArray = starPacket.getAsJsonArray("groups");
        return groupKeys(jsonArray);
    }

    private static void writeGroupKeys(JsonObject starPacket, Set<GroupKey> groupKeys) {
        starPacket.add("groups", groupKeysJson(groupKeys));
    }

    private static Payload readPayload(JsonObject starPacket) {
        JsonElement payload = starPacket.get("payload");
        String type = starPacket.get("type").getAsString();
        switch (type) {
            case "star key":
                JsonObject starKeyPayload = (JsonObject) payload;
                return starKey(starKeyPayload);
            case "crashed star":
                JsonObject crashedStarPayload = (JsonObject) payload;
                return crashedStar(crashedStarPayload);
            case "star update":
                JsonObject starUpdatePayload = (JsonObject) payload;
                return starUpdate(starUpdatePayload);
            case "star request":
                JsonArray starRequestPayload = (JsonArray) payload;
                return starRequest(starRequestPayload);
            default:
                return null;
        }
    }

    private static void writePayload(JsonObject starPacket, Payload payload) {
        if (payload instanceof StarKey) {
            StarKey starKey = (StarKey) payload;
            starPacket.add("type", new JsonPrimitive("star key"));
            starPacket.add("payload", starKeyJson(starKey));
        } else if (payload instanceof CrashedStar) {
            CrashedStar crashedStar = (CrashedStar) payload;
            starPacket.add("type", new JsonPrimitive("crashed star"));
            starPacket.add("payload", crashedStarJson(crashedStar));
        } else if (payload instanceof StarUpdate) {
            StarUpdate starUpdate = (StarUpdate) payload;
            starPacket.add("type", new JsonPrimitive("star update"));
            starPacket.add("payload", starUpdateJson(starUpdate));
        } else if (payload instanceof StarRequest) {
            StarRequest starRequest = (StarRequest) payload;
            starPacket.add("type", new JsonPrimitive("star request"));
            starPacket.add("payload", starRequestJson(starRequest));
        }
    }

    private static void writeFreshStars(JsonObject starList, Map<Set<CrashedStar>, Set<GroupKey>> freshStars) {
        JsonArray fresh = new JsonArray();
        for (Map.Entry<Set<CrashedStar>, Set<GroupKey>> entry : freshStars.entrySet()) {
            JsonObject jsonEntry = new JsonObject();
            jsonEntry.add("stars", crashedStarsJson(entry.getKey()));
            jsonEntry.add("owned by", groupKeysJson(entry.getValue()));
            fresh.add(jsonEntry);
        }
        starList.add("fresh", fresh);
    }

    private static Map<Set<CrashedStar>, Set<GroupKey>> readFreshStars(JsonObject starList) {
        Map<Set<CrashedStar>, Set<GroupKey>> result = new LinkedHashMap<>();
        JsonArray fresh = starList.getAsJsonArray("fresh");
        for (JsonElement jsonEntry : fresh) {
            JsonObject entry = (JsonObject) jsonEntry;
            Set<CrashedStar> stars = crashedStars(entry.getAsJsonArray("stars"));
            Set<GroupKey> ownedBy = groupKeys(entry.getAsJsonArray("owned by"));
            result.put(stars, ownedBy);
        }
        return result;
    }

    private static void writeStarUpdates(JsonObject starList, Set<StarUpdate> starUpdates) {
        starList.add("updates", starUpdatesJson(starUpdates));
    }

    private static Set<StarUpdate> readStarUpdates(JsonObject starList) {
        return starUpdates(starList.getAsJsonArray("updates"));
    }

    private static void writeDeletedStars(JsonObject starList, Set<StarKey> deletedStars) {
        starList.add("deleted", starKeysJson(deletedStars));
    }

    public static Set<StarKey> readDeletedStars(JsonObject starList) {
        return starKeys(starList.getAsJsonArray("deleted"));
    }
}

package com.janboerman.f2pstarassist.plugin;

import com.google.gson.*;
import com.janboerman.f2pstarassist.common.*;
import com.janboerman.f2pstarassist.common.web.EndPoints;
import com.janboerman.f2pstarassist.common.web.StarJson;
import okhttp3.*;

import javax.inject.Inject;
import java.io.IOException;
import java.io.Reader;
import java.util.Collections;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CompletableFuture;

public class StarClient {

    private static final MediaType APPLICATION_JSON = MediaType.get("application/json");

    private final OkHttpClient httpClient;
    private final StarAssistConfig config;

    @Inject
    public StarClient(OkHttpClient httpClient, StarAssistConfig config) {
        this.httpClient = httpClient;
        this.config = config;
    }

    public CompletableFuture<StarList> requestStars(Set<GroupKey> groups, Set<CrashedStar> knownStars) {
        final String json = StarJson.starPacketJson(new StarPacket(groups, new StarRequest(knownStars))).toString();

        final String url = config.httpUrl() + EndPoints.ALL_STARS;
        final RequestBody requestBody = RequestBody.create(APPLICATION_JSON, json);
        final Request request = new Request.Builder().url(url).post(requestBody).build();

        final CompletableFuture<StarList> future = new CompletableFuture<>();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(new ResponseException(call, e));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                try {
                    if (!response.isSuccessful()) {
                        future.completeExceptionally(new ResponseException(call, "WebServer answered with response code: " + response.code()));
                        return;
                    }

                    ResponseBody body = response.body();
                    //assert content type json?
                    Reader reader = body.charStream();
                    JsonParser jsonParser = new JsonParser();

                    try {
                        JsonElement jsonElement = jsonParser.parse(reader);
                        if (jsonElement instanceof JsonArray) {
                            //legacy star list: json array of crashed stars
                            Set<CrashedStar> starSet = StarJson.crashedStars((JsonArray) jsonElement);
                            StarList starList = new StarList(Collections.singletonMap(starSet, Collections.emptySet()), Collections.emptySet(), Collections.emptySet());
                            future.complete(starList);
                        } else if (jsonElement instanceof JsonObject) {
                            //new star list: is using its own json representation
                            StarList starList = StarJson.starList((JsonObject) jsonElement);
                            future.complete(starList);
                        }

                        else {
                            future.completeExceptionally(new ResponseException(call, "Expected a json representation of a star list, but got: " + jsonElement));
                        }
                    } catch (RuntimeException e) {
                        future.completeExceptionally(new ResponseException(call, e));
                    }
                } finally {
                    response.close();
                }
            }
        });

        return future;
    }

    public CompletableFuture<Optional<CrashedStar>> sendStar(Set<GroupKey> groups, CrashedStar star) {
        final String json = StarJson.starPacketJson(new StarPacket(groups, star)).toString();

        final String url = config.httpUrl() + EndPoints.SEND_STAR;
        final RequestBody requestBody = RequestBody.create(APPLICATION_JSON, json);
        final Request request = new Request.Builder().url(url).put(requestBody).build();

        final CompletableFuture<Optional<CrashedStar>> future = new CompletableFuture<>();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(new ResponseException(call, e));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    future.completeExceptionally(new ResponseException(call, "WebServer answered with with response code: " + response.code()));
                    return;
                }

                switch (response.code()) {
                    case 200:
                        //assert content type json?
                        Reader reader = response.body().charStream();
                        JsonParser jsonParser = new JsonParser();

                        try {
                            JsonElement jsonElement = jsonParser.parse(reader);
                            if (jsonElement instanceof JsonObject) {
                                future.complete(Optional.of(StarJson.crashedStar((JsonObject) jsonElement)));
                            } else {
                                future.completeExceptionally(new ResponseException(call, "Expected a crashed star json object, but got: " + jsonElement));
                            }
                        } catch (RuntimeException e) {
                            future.completeExceptionally(new ResponseException(call, e));
                        }

                        break;
                    default:
                        future.complete(Optional.empty());
                        break;
                }
            }
        });

        return future;
    }

    public CompletableFuture<CrashedStar> updateStar(Set<GroupKey> groups, StarKey starKey, StarTier tier) {
        final String json = StarJson.starPacketJson(new StarPacket(groups, new StarUpdate(starKey, tier))).toString();

        final String url = config.httpUrl() + EndPoints.UPDATE_STAR;
        final RequestBody requestBody = RequestBody.create(APPLICATION_JSON, json);
        final Request request = new Request.Builder().url(url).patch(requestBody).build();

        final CompletableFuture<CrashedStar> future = new CompletableFuture<>();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(new ResponseException(call, e));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    future.completeExceptionally(new ResponseException(call, "WebServer answered with response code: " + response.code()));
                    return;
                }

                ResponseBody responseBody = response.body();
                //assert content type json?
                Reader reader = responseBody.charStream();
                JsonParser jsonParser = new JsonParser();

                try {
                    JsonElement jsonElement = jsonParser.parse(reader);
                    if (jsonElement instanceof JsonObject) {
                        future.complete(StarJson.crashedStar((JsonObject) jsonElement));
                    } else {
                        future.completeExceptionally(new ResponseException(call, "Expected a crashed star json object, but got: " + jsonElement));
                    }
                } catch (RuntimeException e) {
                    future.completeExceptionally(new ResponseException(call, e));
                }
            }
        });

        return future;
    }

    public CompletableFuture<Void> deleteStar(Set<GroupKey> groups, StarKey starKey) {
        final String json = StarJson.starPacketJson(new StarPacket(groups, starKey)).toString();

        final String url = config.httpUrl() + EndPoints.DELETE_STAR;
        final RequestBody requestBody = RequestBody.create(APPLICATION_JSON, json);
        final Request request = new Request.Builder().url(url).delete(requestBody).build();

        final CompletableFuture<Void> future = new CompletableFuture<>();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                future.completeExceptionally(new ResponseException(call, e));
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                if (!response.isSuccessful()) {
                    future.completeExceptionally(new ResponseException(call, "WebServer answered with response code: " + response.code()));
                    return;
                }

                future.complete(null);
            }
        });

        return future;
    }
}

package com.janboerman.f2pstarassist.plugin;

import okhttp3.Call;

public class ResponseException extends Exception {

    private final Call call;

    public ResponseException(Call call, String message) {
        super(message);
        this.call = call;
    }

    public ResponseException(Call call, Exception cause) {
        super(cause);
        this.call = call;
    }

    public Call getCall() {
        return call;
    }
}

package com.janboerman.f2pstarassist.plugin;

import net.runelite.api.Client;
import net.runelite.api.Perspective;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.*;

import java.awt.*;
import net.runelite.api.Point;

import javax.inject.Inject;

//adapted from GroundMarkerOverlay
public class DoubleHoppingTilesOverlay extends Overlay {

    private static final class DoubleHoppingTile {
        private WorldPoint worldPoint;
        private String label;
        private DoubleHoppingTile(String label, WorldPoint worldPoint) {
            this.worldPoint = worldPoint;
            this.label = label;
        }
    }

    private static final DoubleHoppingTile[] doubleHoppingTiles = {
            new DoubleHoppingTile("Crafting Guild / Rimmington hopping location", new WorldPoint(2958, 3265, 0)),
            new DoubleHoppingTile("Desert mine / PvP Arena hopping location", new WorldPoint(3323, 3289, 0)),
            new DoubleHoppingTile("Varrock west bank hopping location", new WorldPoint(3275, 3384, 0)),
            new DoubleHoppingTile("Varrock south east mine hopping location", new WorldPoint(3275, 3383, 0)),
            new DoubleHoppingTile("Al Kharid bank hopping location", new WorldPoint(3248, 3186, 0)),
            new DoubleHoppingTile("Lumbridge Swamp east mine hopping location", new WorldPoint(3246, 3183, 0)),
    };

    private static final int MAX_DRAW_DISTANCE = 32;

    private final Client client;
    private final StarAssistConfig config;

    @Inject
    public DoubleHoppingTilesOverlay(Client client, StarAssistConfig config) {
        this.client = client;
        this.config = config;

        setPosition(OverlayPosition.DYNAMIC);
        setPriority(OverlayPriority.LOW);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics) {

        if (!config.markDoubleHoppingTiles()) return null;

        Stroke stroke = new BasicStroke(2F);
        for (final DoubleHoppingTile tile : doubleHoppingTiles) {
            if (tile.worldPoint.getPlane() == client.getPlane()) {
                Color tileColour = new Color(0, 94, 53);
                drawTile(graphics, tile.worldPoint, tileColour, tile.label, stroke);
            }
        }

        return null;
    }

    private void drawTile(Graphics2D graphics, WorldPoint point, Color colour, String label, Stroke borderStroke) {
        final WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE) return;

        final LocalPoint localPoint = LocalPoint.fromWorld(client, point);
        if (localPoint == null) return;

        final Polygon polygon = Perspective.getCanvasTilePoly(client, localPoint);
        if (polygon != null) {
            OverlayUtil.renderPolygon(graphics, polygon, colour, new Color(0, 0, 0, /*fill opacity*/50), borderStroke);
        }

        final Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, localPoint, label, 0);
        if (canvasTextLocation != null) {
            OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, colour);
        }
    }

}

package com.janboerman.f2pstarassist.plugin;

import com.janboerman.f2pstarassist.common.StarLocation;

import net.runelite.api.coords.WorldPoint;

import java.util.HashMap;
import java.util.Map;

public class StarPoints {

    static final WorldPoint WILDERNESS_RUNITE_MINE = new WorldPoint(3057, 3887, 0);
    static final WorldPoint WILDERNESS_CENTRE_MINE = new WorldPoint(3093, 3756, 0);
    static final WorldPoint WILDERNESS_SOUTH_WEST_MINE = new WorldPoint(3018, 3593, 0);
    static final WorldPoint WILDERNESS_SOUTH_MINE = new WorldPoint(3108, 3569, 0);

    static final WorldPoint DWARVEN_MINE = new WorldPoint(3018, 3443, 0);
    static final WorldPoint MINING_GUILD = new WorldPoint(3030, 3348, 0);
    static final WorldPoint CRAFTING_GUILD = new WorldPoint(2940, 3280, 0);
    static final WorldPoint RIMMINGTON_MINE = new WorldPoint(2974, 3241, 0);

    static final WorldPoint DRAYNOR_VILLAGE_BANK = new WorldPoint(3094, 3235, 0);
    static final WorldPoint LUMBRIDGE_SWAMP_SOUTH_WEST_MINE = new WorldPoint(3153, 3150, 0);
    static final WorldPoint LUMBRIDGE_SWAMP_SOUTH_EAST_MINE = new WorldPoint(3230, 3155, 0);

    static final WorldPoint VARROCK_SOUTH_WEST_MINE = new WorldPoint(3175, 3362, 0);
    static final WorldPoint VARROCK_SOUTH_EAST_MINE = new WorldPoint(3290, 3353, 0);
    static final WorldPoint VARROCK_AUBURY = new WorldPoint(3258, 3408, 0);

    static final WorldPoint AL_KHARID_MINE = new WorldPoint(3296, 3298, 0);
    static final WorldPoint AL_KHARID_BANK = new WorldPoint(3276, 3164, 0);
    //static final WorldPoint DUEL_ARENA = new WorldPoint(3341, 3267, 0); //R.I.P. Duel Arena 2022-07-13
    static final WorldPoint PVP_ARENA = new WorldPoint(3351, 3281, 0);

    static final WorldPoint CRANDOR_NORTH_MINE = new WorldPoint(2835, 3296, 0);
    static final WorldPoint CRANDOR_SOUTH_MINE = new WorldPoint(2822, 3238, 0);
    static final WorldPoint CORSAIR_COVE_BANK = new WorldPoint(2567, 2858, 0);
    static final WorldPoint CORSAIR_COVE_RESOURCE_AREA = new WorldPoint(2483, 2886, 0);

    private static final Map<WorldPoint, StarLocation> LOCATIONS = new HashMap<>();
    static {
        LOCATIONS.put(WILDERNESS_RUNITE_MINE, StarLocation.WILDERNESS_RUNITE_MINE);
        LOCATIONS.put(WILDERNESS_CENTRE_MINE, StarLocation.WILDERNESS_CENTRE_MINE);
        LOCATIONS.put(WILDERNESS_SOUTH_WEST_MINE, StarLocation.WILDERNESS_SOUTH_WEST_MINE);
        LOCATIONS.put(WILDERNESS_SOUTH_MINE, StarLocation.WILDERNESS_SOUTH_MINE);

        LOCATIONS.put(DWARVEN_MINE, StarLocation.DWARVEN_MINE);
        LOCATIONS.put(MINING_GUILD, StarLocation.MINING_GUILD);
        LOCATIONS.put(CRAFTING_GUILD, StarLocation.CRAFTING_GUILD);
        LOCATIONS.put(RIMMINGTON_MINE, StarLocation.RIMMINGTON_MINE);

        LOCATIONS.put(DRAYNOR_VILLAGE_BANK, StarLocation.DRAYNOR_VILLAGE_BANK);
        LOCATIONS.put(LUMBRIDGE_SWAMP_SOUTH_WEST_MINE, StarLocation.LUMBRIDGE_SWAMP_SOUTH_WEST_MINE);
        LOCATIONS.put(LUMBRIDGE_SWAMP_SOUTH_EAST_MINE, StarLocation.LUMBRIDGE_SWAMP_SOUTH_EAST_MINE);

        LOCATIONS.put(VARROCK_SOUTH_WEST_MINE, StarLocation.VARROCK_SOUTH_WEST_MINE);
        LOCATIONS.put(VARROCK_SOUTH_EAST_MINE, StarLocation.VARROCK_SOUTH_EAST_MINE);
        LOCATIONS.put(VARROCK_AUBURY, StarLocation.VARROCK_AUBURY);

        LOCATIONS.put(AL_KHARID_MINE, StarLocation.AL_KHARID_MINE);
        LOCATIONS.put(AL_KHARID_BANK, StarLocation.AL_KHARID_BANK);
        LOCATIONS.put(PVP_ARENA, StarLocation.PVP_ARENA);

        LOCATIONS.put(CRANDOR_NORTH_MINE, StarLocation.CRANDOR_NORTH_MINE);
        LOCATIONS.put(CRANDOR_SOUTH_MINE, StarLocation.CRANDOR_SOUTH_MINE);
        LOCATIONS.put(CORSAIR_COVE_BANK, StarLocation.CORSAIR_COVE_BANK);
        LOCATIONS.put(CORSAIR_COVE_RESOURCE_AREA, StarLocation.CORSAIR_COVE_RESOURCE_AREA);
    }

    public static WorldPoint fromLocation(StarLocation location) {
        switch (location) {
            case WILDERNESS_RUNITE_MINE: return WILDERNESS_RUNITE_MINE;
            case WILDERNESS_CENTRE_MINE: return WILDERNESS_CENTRE_MINE;
            case WILDERNESS_SOUTH_WEST_MINE: return WILDERNESS_SOUTH_WEST_MINE;
            case WILDERNESS_SOUTH_MINE: return WILDERNESS_SOUTH_MINE;

            case DWARVEN_MINE: return DWARVEN_MINE;
            case MINING_GUILD: return MINING_GUILD;
            case CRAFTING_GUILD: return CRAFTING_GUILD;
            case RIMMINGTON_MINE: return RIMMINGTON_MINE;

            case DRAYNOR_VILLAGE_BANK: return DRAYNOR_VILLAGE_BANK;
            case LUMBRIDGE_SWAMP_SOUTH_WEST_MINE: return LUMBRIDGE_SWAMP_SOUTH_WEST_MINE;
            case LUMBRIDGE_SWAMP_SOUTH_EAST_MINE: return LUMBRIDGE_SWAMP_SOUTH_EAST_MINE;

            case VARROCK_SOUTH_WEST_MINE: return VARROCK_SOUTH_WEST_MINE;
            case VARROCK_SOUTH_EAST_MINE: return VARROCK_SOUTH_EAST_MINE;
            case VARROCK_AUBURY: return VARROCK_AUBURY;

            case AL_KHARID_MINE: return AL_KHARID_MINE;
            case AL_KHARID_BANK: return AL_KHARID_BANK;
            case PVP_ARENA: return PVP_ARENA;

            case CRANDOR_NORTH_MINE: return CRANDOR_NORTH_MINE;
            case CRANDOR_SOUTH_MINE: return CRANDOR_SOUTH_MINE;
            case CORSAIR_COVE_BANK: return CORSAIR_COVE_BANK;
            case CORSAIR_COVE_RESOURCE_AREA: return CORSAIR_COVE_RESOURCE_AREA;

            default: throw new RuntimeException("A new StarLocation was added which has no registered WorldPoint yet: " + location);
        }
    }

    public static StarLocation toLocation(WorldPoint starPoint) {
        if (starPoint == WILDERNESS_RUNITE_MINE) return StarLocation.WILDERNESS_RUNITE_MINE;
        if (starPoint == WILDERNESS_CENTRE_MINE) return StarLocation.WILDERNESS_CENTRE_MINE;
        if (starPoint == WILDERNESS_SOUTH_WEST_MINE) return StarLocation.WILDERNESS_SOUTH_WEST_MINE;
        if (starPoint == WILDERNESS_SOUTH_MINE) return StarLocation.WILDERNESS_SOUTH_MINE;

        if (starPoint == DWARVEN_MINE) return StarLocation.DWARVEN_MINE;
        if (starPoint == MINING_GUILD) return StarLocation.MINING_GUILD;
        if (starPoint == CRAFTING_GUILD) return StarLocation.CRAFTING_GUILD;
        if (starPoint == RIMMINGTON_MINE) return StarLocation.RIMMINGTON_MINE;

        if (starPoint == DRAYNOR_VILLAGE_BANK) return StarLocation.DRAYNOR_VILLAGE_BANK;
        if (starPoint == LUMBRIDGE_SWAMP_SOUTH_WEST_MINE) return StarLocation.LUMBRIDGE_SWAMP_SOUTH_WEST_MINE;
        if (starPoint == LUMBRIDGE_SWAMP_SOUTH_EAST_MINE) return StarLocation.LUMBRIDGE_SWAMP_SOUTH_EAST_MINE;

        if (starPoint == VARROCK_SOUTH_WEST_MINE) return StarLocation.VARROCK_SOUTH_WEST_MINE;
        if (starPoint == VARROCK_SOUTH_EAST_MINE) return StarLocation.VARROCK_SOUTH_EAST_MINE;
        if (starPoint == VARROCK_AUBURY) return StarLocation.VARROCK_AUBURY;

        if (starPoint == AL_KHARID_MINE) return StarLocation.AL_KHARID_MINE;
        if (starPoint == AL_KHARID_BANK) return StarLocation.AL_KHARID_BANK;
        if (starPoint == PVP_ARENA) return StarLocation.PVP_ARENA;

        if (starPoint == CRANDOR_NORTH_MINE) return StarLocation.CRANDOR_NORTH_MINE;
        if (starPoint == CRANDOR_SOUTH_MINE) return StarLocation.CRANDOR_SOUTH_MINE;
        if (starPoint == CORSAIR_COVE_BANK) return StarLocation.CORSAIR_COVE_BANK;
        if (starPoint == CORSAIR_COVE_RESOURCE_AREA) return StarLocation.CORSAIR_COVE_RESOURCE_AREA;

        return LOCATIONS.get(starPoint);
    }

}


package com.janboerman.f2pstarassist.plugin;

import com.janboerman.f2pstarassist.common.StarTier;

import net.runelite.api.ObjectID;

public final class StarIds {

    static final int TIER_9 = ObjectID.CRASHED_STAR;        //41020
    static final int TIER_8 = ObjectID.CRASHED_STAR_41021;  //41021
    static final int TIER_7 = ObjectID.CRASHED_STAR_41223;  //41223
    static final int TIER_6 = ObjectID.CRASHED_STAR_41224;  //41224
    static final int TIER_5 = ObjectID.CRASHED_STAR_41225;  //41225
    static final int TIER_4 = ObjectID.CRASHED_STAR_41226;  //41226
    static final int TIER_3 = ObjectID.CRASHED_STAR_41227;  //41227
    static final int TIER_2 = ObjectID.CRASHED_STAR_41228;  //41228
    static final int TIER_1 = ObjectID.CRASHED_STAR_41229;  //41229

    //rubble
    static final int FILLER_RUBBLE = 29733; //used in north-west, north-east, south-east corners

    private StarIds() {
    }

    public static StarTier getTier(int gameObjectId) {
        switch (gameObjectId) {
            case StarIds.TIER_1: return StarTier.SIZE_1;
            case StarIds.TIER_2: return StarTier.SIZE_2;
            case StarIds.TIER_3: return StarTier.SIZE_3;
            case StarIds.TIER_4: return StarTier.SIZE_4;
            case StarIds.TIER_5: return StarTier.SIZE_5;
            case StarIds.TIER_6: return StarTier.SIZE_6;
            case StarIds.TIER_7: return StarTier.SIZE_7;
            case StarIds.TIER_8: return StarTier.SIZE_8;
            case StarIds.TIER_9: return StarTier.SIZE_9;
            default: return null;
        }
    }

}


package com.janboerman.f2pstarassist.plugin;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("F2P Star Assist")
public interface StarAssistConfig extends Config {

	// ======================================== Groups ========================================	\\
	//																							\\

	@ConfigSection(
			name = "Groups Settings",
			description = "Settings for groups",
			position = 0,
			closedByDefault = true
	)
	public static final String GROUP_SETTINGS_SECTION = "Groups Settings";

	//																							\\
	//																							\\

	@ConfigItem(
			position = 0,
			keyName = "groups",
			name = "Groups",
			description = "Group names and group keys. Defined as a JSON Object where keys are group names, and values are group codes",
			section = GROUP_SETTINGS_SECTION
	)
	default String groups() {
		return "{\r\n" +
				"    \"My Clan\" : \"<clan_code_here>\",\r\n" +
				"    \"My fc\" : \"<fc_code_here>\"\r\n" +
				"}";
	}

	//																							\\
	// ======================================================================================== \\


	// ========================================= HTTP =========================================	\\
	//																							\\

	@ConfigSection(
			name = "Webserver Settings",
			description = "Settings for sending and receiving data from the webserver",
			position = 1,
			closedByDefault = true
	)
	public static final String HTTP_SETTINGS_SECTION = "HTTP Settings";

	//																							\\
	//																							\\

	@ConfigItem(
			position = 0,
			keyName = "http enabled",
			name = "Enable webserver communication",
			description = "Whether a connection with the webserver should be established",
			section = HTTP_SETTINGS_SECTION
	)
	default boolean httpConnectionEnabled() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "address",
			name = "Webserver URL",
			description = "The address of the webserver with which star locations are shared",
			section = HTTP_SETTINGS_SECTION
	)
	default String httpUrl() {
		return "http://localhost:8080";
	}

	//																							\\
	// ======================================================================================== \\


	// ======================================== Sharing ======================================= \\
	//  																						\\

	@ConfigSection(
			name = "Sharing Settings",
			description = "Settings for sharing with groups (only works when webserver communication is enabled)",
			position = 2,
			closedByDefault = false
	)
	public static final String SHARING_SETTINGS_SECTION = "Sharing Settings";

	//																							\\
	//																							\\

	@ConfigItem(
			position = 0,
			keyName = "share pvp-world stars",
			name = "Share PVP-world stars",
			description = "Whether to send stars in PVP-worlds",
			section = SHARING_SETTINGS_SECTION
	)
	default boolean sharePvpWorldStars() {
		return false;
	}

	@ConfigItem(
			position = 1,
			keyName = "share wilderness stars",
			name = "Share Wilderness stars",
			description = "Whether to send stars in the Wilderness",
			section = SHARING_SETTINGS_SECTION
	)
	default boolean shareWildernessStars() {
		return false;
	}

	@ConfigItem(
			position = 2,
			keyName = "share found stars",
			name = "Share found-by-me stars",
			description = "Whether to share stars that you encounter in the world",
			section = SHARING_SETTINGS_SECTION
	)
	default boolean shareFoundStars() {
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "share found stars with groups",
			name = "Share stars I find with groups:",
			description = "With which group should stars that you find yourself be shared? (semicolon-separated list)",
			section = SHARING_SETTINGS_SECTION
	)
	default String getGroupsToShareFoundStarsWith() {
		return "My Clan;my fc";
	}

	@ConfigItem(
			position = 4,
			keyName = "share private chat calls",
			name = "Share private chat calls with groups:",
			description = "Share private chat calls with your group",
			section = SHARING_SETTINGS_SECTION
	)
	default String shareCallsReceivedByPrivateChat() {
		return "";
	}

	@ConfigItem(
			position = 5,
			keyName = "share friends chat calls",
			name = "Share friends chat calls with groups:",
			description = "Share friends chat calls with your group",
			section = SHARING_SETTINGS_SECTION
	)
	default String shareCallsReceivedByFriendsChat() {
		return "My fc";
	}

	@ConfigItem(
			position = 6,
			keyName = "share clan chat calls",
			name = "Share clan chat calls with groups:",
			description = "Share clan chat calls with your group",
			section = SHARING_SETTINGS_SECTION
	)
	default String shareCallsReceivedByClanChat() {
		return "My Clan";
	}

	@ConfigItem(
			position = 7,
			keyName = "share public chat calls",
			name = "Share public chat calls with groups:",
			description = "Share public chat calls with your group",
			section = SHARING_SETTINGS_SECTION
	)
	default String shareCallsReceivedByPublicChat() {
		return "";
	}

	//																							\\
	// ======================================================================================== \\


	// ===================================== Chat Analysis ==================================== \\
	//																							\\

	@ConfigSection(
			name = "Chat Analysis Settings",
			description = "Settings for whether to interpret star calls from chat messages",
			position = 3,
			closedByDefault = false
	)
	public static final String CHAT_SETTINGS_SECTION = "Chat Settings";

	//																							\\
	//																							\\

	@ConfigItem(
			position = 1,
			keyName = "clan chat",
			name = "Interpret clan chat star calls",
			description = "Check whether clan chat messages contain star calls",
			section = CHAT_SETTINGS_SECTION
	)
	default boolean interpretClanChat() {
		return true;
	}

	@ConfigItem(
			position = 2,
			keyName = "friends chat",
			name = "Interpret friends chat star calls",
			description = "Check whether friends chat messages contain star calls",
			section = CHAT_SETTINGS_SECTION
	)
	default boolean interpretFriendsChat() {
		return true;
	}

	@ConfigItem(
			position = 3,
			keyName = "private chat",
			name = "Interpret private chat star calls",
			description = "Check whether private chat messages contain star calls",
			section = CHAT_SETTINGS_SECTION
	)
	default boolean interpretPrivateChat() {
		return true;
	}

	@ConfigItem(
			position = 4,
			keyName = "public chat",
			name = "Interpret public chat star calls",
			description = "Check whether public chat messages contain star calls",
			section = CHAT_SETTINGS_SECTION
	)
	default boolean interpretPublicChat() {
		return true;
	}

	//																							\\
	// ======================================================================================== \\


	// ====================================== Hint Arrow ====================================== \\
	//																							\\

	@ConfigSection(
			name = "Miscellaneous Settings",
			description = "Settings that don't belong in any other category",
			position = 4,
			closedByDefault = false
	)
	public static final String MISCELLANEOUS = "Miscellaneous Settings";

	//																							\\
	//																							\\

	@ConfigItem(
			position = 13,
			keyName = "hint enabled",
			name = "Enable arrow hints",
			description = "Whether to display an arrow that hints to the target location",
			section = MISCELLANEOUS
	)
	default boolean hintArrowEnabled() {
		return false;
	}

	@ConfigItem(
			position = 14,
			keyName = "double hopping locations",
			name = "Mark double hopping location tiles",
			description = "Enable tile markers for double hopping locations.<br>" +
					"F2P Double Hopping spots:<br>" +
					"- Between Crafting Guild and Rimmington mine<br>" +
					"- Between Desert mine and PvP Arena<br>" +
					"- Between Aubury and Varrock east mine (1 tile diff)<br>" +
					"- Between Lumbridge Swamp south east and Al Kharid bank (3 tile diff)",
			section = MISCELLANEOUS
	)
	default boolean markDoubleHoppingTiles() {
		return false;
	}

	//																							\\
	// ========================================================================================	\\

}

package com.janboerman.f2pstarassist.plugin;

import com.google.gson.*;
import com.google.inject.Provides;
import com.janboerman.f2pstarassist.common.*;

import com.janboerman.f2pstarassist.common.lingo.StarLingo;
import static com.janboerman.f2pstarassist.common.util.CollectionConvert.toSet;
import static com.janboerman.f2pstarassist.plugin.TextUtil.stripChatIcon;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.*;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.WorldResult;
import okhttp3.Call;
import okio.Buffer;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.SwingUtilities;

@Slf4j
@PluginDescriptor(name = "F2P Star Assist")
public class StarAssistPlugin extends Plugin {

	//populated at construction
	private final StarCache starCache;
	private final Map<StarKey, Set<GroupKey>> owningGroups = new HashMap<>();
	private final Map<String, GroupKey> groups = new HashMap<>();

	//populated right after construction
	@Inject private Client client;
	@Inject private ClientToolbar clientToolbar;
	@Inject private WorldService worldService;
	@Inject private ClientThread clientThread;
	@Inject private StarAssistConfig config;
	@Inject private OverlayManager overlayManager;

	//populated on start-up
	private StarClient starClient;
	private DoubleHoppingTilesOverlay doubleHoppingTilesOverlay;
	private ScheduledExecutorService fetcherTimer;
	private StarAssistPanel panel;
	private NavigationButton navButton;

	public StarAssistPlugin() {
		this.starCache = new StarCache(removalNotification -> {
			if (removalNotification.wasEvicted()) { //'evicted' meaning: not explicitly removed by a 'StarCache#remove' call.
				//remove from sidebar.
				clientThread.invokeLater(this::updatePanel);
			}

			clientThread.invoke(() -> {
				CrashedStar removedStar = removalNotification.getValue();

				//if a hint arrow pointing to the removed star exists, then clear it.
				if (removedStar.getWorld() == client.getWorld()) {
					WorldPoint starPoint = StarPoints.fromLocation(removedStar.getLocation());
					if (client.hasHintArrow() && client.getHintArrowPoint().equals(starPoint)) {
						client.clearHintArrow();
					}
				}

				//clear owning groups
				if (removalNotification.wasEvicted()) {
					owningGroups.remove(removedStar.getKey());
				}
			});
		});
	}

	@Provides
	StarAssistConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(StarAssistConfig.class);
	}

	@Override
	protected void startUp() throws Exception {
		this.starClient = injector.getInstance(StarClient.class);
		this.doubleHoppingTilesOverlay= injector.getInstance(DoubleHoppingTilesOverlay.class);
		overlayManager.add(doubleHoppingTilesOverlay);

		this.panel = new StarAssistPanel(this, config, client, clientThread);
		BufferedImage icon = ImageUtil.loadImageResource(StarAssistPlugin.class, "/icon.png");
		this.navButton = NavigationButton.builder()
				.tooltip("F2P Star Assist")
				.icon(icon)
				.priority(10)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);

		setGroups(loadGroups());

		fetcherTimer = Executors.newSingleThreadScheduledExecutor();
		fetcherTimer.scheduleAtFixedRate(() -> {
			clientThread.invoke(() -> fetchStarList(toSet(groups.values())));
		}, 0, 15, TimeUnit.MINUTES);

		clientThread.invoke(() -> updatePanel());

		log.info("F2P Star Assist started!");
	}

	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(doubleHoppingTilesOverlay);
		clientToolbar.removeNavigation(navButton);

		fetcherTimer.shutdownNow();
		fetcherTimer = null;

		starCache.clear();
		owningGroups.clear();
		groups.clear();

		log.info("F2P Star Assist stopped!");
	}

	public void fetchStarList(Set<GroupKey> sharingGroups) {
		if (config.httpConnectionEnabled()) {

			CompletableFuture<StarList> starFuture = starClient.requestStars(sharingGroups, starCache.getStars());
			starFuture.whenCompleteAsync((receivedStars, ex) -> {
				if (ex != null) {
					log.error("Error when receiving star data", ex);
				} else {
					log.debug("received stars from webserver: " + receivedStars);

					clientThread.invoke(() -> {
						receiveStars(receivedStars);
					});
				}
			});
		}
	}

	public void hopAndHint(CrashedStar star) {
		assert !client.isClientThread();

		int starWorld = star.getWorld();
		int currentWorld = client.getWorld();

		if (currentWorld != starWorld) {
			net.runelite.http.api.worlds.WorldResult worldResult = worldService.getWorlds();
			if (worldResult != null) {
				clientThread.invoke(() -> {
					World world = rsWorld(worldResult.findWorld(starWorld));
					if (world != null) {
						client.hopToWorld(world);
					}

					if (config.hintArrowEnabled()) {
						WorldPoint starPoint = StarPoints.fromLocation(star.getLocation());
						client.setHintArrow(starPoint);
					}
				});
			}
		}
	}

	public void showHintArrow(boolean whetherTo) {
		assert client.isClientThread();

		int playerWorld = client.getWorld();
		for (CrashedStar star : starCache.getStars()) {
			if (star.getWorld() == playerWorld) {
				WorldPoint starPoint = StarPoints.fromLocation(star.getLocation());
				if (whetherTo) {
					client.setHintArrow(starPoint);
				} else if (client.hasHintArrow() && client.getHintArrowPoint().equals(starPoint)) {
					client.clearHintArrow();
				}
				break;
			}
		}
	}

	@Nullable
	private World rsWorld(net.runelite.http.api.worlds.World world) {
		if (world == null) return null;
		assert client.isClientThread();

		World rsWorld = client.createWorld();
		rsWorld.setActivity(world.getActivity());
		rsWorld.setAddress(world.getAddress());
		rsWorld.setId(world.getId());
		rsWorld.setPlayerCount(world.getPlayers());
		rsWorld.setLocation(world.getLocation());
		rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));

		return rsWorld;
	}

	private Set<GroupKey> getOwningGroups(StarKey starKey) {
		Set<GroupKey> groups = owningGroups.get(starKey);
		if (groups == null) groups = Collections.emptySet();
		return groups;
	}

	private Map<String, GroupKey> getGroups() {
		return groups;
	}

	private void setGroups(Map<String, GroupKey> groups) {
		this.groups.clear();
		this.groups.putAll(groups);
	}

	private Map<String, GroupKey> loadGroups() {
		return loadGroups(config.groups());
	}

	private Map<String, GroupKey> loadGroups(String groupsJson) {
		JsonParser jsonParser = new JsonParser();
		try {
			JsonElement jsonElement = jsonParser.parse(groupsJson);
			if (jsonElement instanceof JsonObject) {
				JsonObject jsonObject = (JsonObject) jsonElement;

				Map<String, GroupKey> result = new HashMap<>();
				for (Map.Entry<String, JsonElement> entry : jsonObject.entrySet()) {
					String groupName = entry.getKey();
					JsonElement groupKeyString = entry.getValue();
					GroupKey groupKey = new GroupKey(groupKeyString.getAsString());
					result.put(groupName, groupKey);
				}

				return result;
			} else {
				log.error("groups must be defined as a json object!");
				return Collections.emptyMap();
			}
		} catch (RuntimeException e) {
			log.error("Invalid groups JSON in config", e);
			return Collections.emptyMap();
		}
	}

	private Set<GroupKey> getSharingGroups(String groupName) {
		if (groupName == null || groupName.isEmpty()) return Collections.emptySet();
		return Arrays.stream(groupName.split(";"))
				.flatMap(name -> {
					GroupKey key = getGroups().get(name);
					if (key == null) return Stream.empty();
					else return Stream.of(key);
				})
				.collect(Collectors.toSet());
	}

	private Set<GroupKey> getSharingGroupsOwnFoundStars() {
		return getSharingGroups(config.getGroupsToShareFoundStarsWith());
	}

	private Set<GroupKey> getSharingGroupsFriendsChat() {
		return getSharingGroups(config.shareCallsReceivedByFriendsChat());
	}

	private Set<GroupKey> getSharingGroupsClanChat() {
		return getSharingGroups(config.shareCallsReceivedByClanChat());
	}

	private Set<GroupKey> getSharingGroupsPrivateChat() {
		return getSharingGroups(config.shareCallsReceivedByPrivateChat());
	}

	private Set<GroupKey> getSharingGroupsPublicChat() {
		return getSharingGroups(config.shareCallsReceivedByPublicChat());
	}

	//
	// ======= Star Cache Bookkeeping =======
	//

	private boolean shouldBroadcastStar(StarKey starKey) {
		if (!config.httpConnectionEnabled()) return false;

		WorldResult worldResult = worldService.getWorlds();	//worldResult can be null when RuneLite's WorldService breaks after a game update
		boolean isPvP = worldResult != null && worldResult.findWorld(starKey.getWorld()).getTypes().contains(net.runelite.http.api.worlds.WorldType.PVP);
		boolean isWilderness = starKey.getLocation().isInWilderness();
		return (config.sharePvpWorldStars() || !isPvP) && (config.shareWildernessStars() || !isWilderness);
	}

	public void receiveStars(StarList starList) {
		Map<Set<CrashedStar>, Set<GroupKey>> fresh = starList.getFreshStars();
		Set<StarUpdate> updates = starList.getStarUpdates();
		Set<StarKey> deleted = starList.getDeletedStars();

		//apply 'new' updates
		for (Map.Entry<Set<CrashedStar>, Set<GroupKey>> entry : fresh.entrySet()) {
			Set<CrashedStar> freshStars = entry.getKey();
			Set<GroupKey> ownedBy = entry.getValue();
			starCache.addAll(freshStars);
			for (CrashedStar freshStar : freshStars) {
				owningGroups.computeIfAbsent(freshStar.getKey(), k -> new HashSet<>()).addAll(ownedBy);
			}
		}

		//apply 'update' updates
		for (StarUpdate starUpdate : updates) {
			StarKey starKey = starUpdate.getKey();
			CrashedStar star = starCache.get(starKey);
			if (star == null)
				//shouldn't really happen, but just in case.
				starCache.add(new CrashedStar(starKey, starUpdate.getTier(), Instant.now(), User.unknown()));
			else if (starUpdate.getTier().compareTo(star.getTier()) < 0)
				star.setTier(starUpdate.getTier());
		}

		//apply 'delete' updates
		for (StarKey deletedStar : deleted) {
			reportStarGone(deletedStar, false);
		}

		updatePanel();
	}


	public void reportStarNew(CrashedStar star, Set<GroupKey> groupsToShareTheStarWith) {
		log.debug("reporting new star: " + star);

		final StarKey starKey = star.getKey();
		final boolean isNew = starCache.add(star) == null;
		if (isNew) {
			updatePanel();
			owningGroups.put(starKey, groupsToShareTheStarWith);
		}

		if (config.shareFoundStars() && shouldBroadcastStar(starKey)) {
			CompletableFuture<Optional<CrashedStar>> upToDateStar = starClient.sendStar(groupsToShareTheStarWith, star);
			upToDateStar.whenCompleteAsync((optionalStar, ex) -> {
				if (ex != null) {
					logServerError(ex);
				} else if (optionalStar.isPresent()) {
					CrashedStar receivedStar = optionalStar.get();
					StarKey receivedStarKey = receivedStar.getKey();
					clientThread.invoke(() -> {
						CrashedStar existingStar = starCache.get(receivedStarKey);
						if (existingStar == null) { //this could theoretically happen if the client received a 'delete' from the server.
							starCache.forceAdd(receivedStar);
						}
						updatePanel();
					});
				}
			});
		}
	}

	public void reportStarUpdate(StarKey starKey, StarTier newTier, boolean broadcast) {
		log.debug("reporting star update: " + starKey + "->" + newTier);

		CrashedStar star = starCache.get(starKey);
		if (star.getTier() == newTier) return;

		star.setTier(newTier);
		updatePanel();

		if (broadcast && shouldBroadcastStar(starKey)) {
			Set<GroupKey> shareGroups = getOwningGroups(starKey);
			CompletableFuture<CrashedStar> upToDateStar = starClient.updateStar(shareGroups, starKey, newTier);
			upToDateStar.whenCompleteAsync((receivedStar, ex) -> {
				if (ex != null) {
					logServerError(ex);
				}
				else if (!receivedStar.equals(star)) {
					clientThread.invoke(() -> { starCache.forceAdd(receivedStar); updatePanel(); });
				}
			});
		}
	}

	public void reportStarGone(StarKey starKey, boolean broadcast) {
		log.debug("reporting star gone: " + starKey);

		Set<GroupKey> broadcastGroups = removeStar(starKey);
		updatePanel();

		if (broadcast && shouldBroadcastStar(starKey) && broadcastGroups != null) {
			CompletableFuture<Void> deleteAction = starClient.deleteStar(broadcastGroups, starKey);
			deleteAction.whenComplete((Void v, Throwable ex) -> {
				if (ex != null) {
					logServerError(ex);
				}
				else {
					log.debug("star " + starKey + " deleted from server");
				}
			});
		}
	}

	@Nullable
	Set<GroupKey> removeStar(StarKey starKey) {
		assert client.isClientThread();

		starCache.remove(starKey);
		return owningGroups.remove(starKey);
	}

	private void logServerError(Throwable ex) {
		log.warn("Unexpected result from web server", ex);
		if (ex instanceof ResponseException) {
			Call call = ((ResponseException) ex).getCall();
			log.debug("Request that caused it: " + call.request());
			Buffer buffer = new Buffer();
			try {
				call.request().body().writeTo(buffer);
				log.debug("Request body: " + buffer.readString(StandardCharsets.UTF_8));
			} catch (IOException e) {
				log.error("Error reading call request body", e);
			}
		}
	}

	@Nullable WorldPoint getLocalPlayerLocation() {
		assert client.isClientThread() : "getLocalPlayerLocation must be called from the client thread!";

		Player localPlayer = client.getLocalPlayer();
		return localPlayer == null ? null : localPlayer.getWorldLocation();
	}

	private void updatePanel() {
		log.debug("Panel repaint!");
		assert client.isClientThread() : "updatePanel must be called from the client thread!";

		Set<CrashedStar> stars = new HashSet<>(starCache.getStars());
		WorldPoint playerLocation = getLocalPlayerLocation();

		SwingUtilities.invokeLater(() -> panel.setStars(stars, playerLocation));
	}


	//
	// ======= Helper methods =======
	//

	private static final int DETECTION_DISTANCE = 25;

	private boolean playerInStarRange(WorldPoint starLocation) {
		return playerInRange(starLocation, DETECTION_DISTANCE);
	}

	private boolean playerInRange(WorldPoint worldPoint, int distance) {
		return inManhattanRange(client.getLocalPlayer().getWorldLocation(), worldPoint, distance);
	}

	private static boolean inManhattanRange(WorldPoint playerLoc, WorldPoint targetLoc, int distance) {
		int playerX = playerLoc.getX();
		int playerY = playerLoc.getY();
		int starX = targetLoc.getX();
		int starY = targetLoc.getY();
		return playerLoc.getPlane() == targetLoc.getPlane()
				&& starX - distance <= playerX && playerX <= starX + distance
				&& starY - distance <= playerY && playerY <= starY + distance;
	}

	private static StarTier getStar(Tile tile) {
		for (GameObject gameObject : tile.getGameObjects()) {
			if (gameObject != null) {
				StarTier starTier = StarIds.getTier(gameObject.getId());
				if (starTier != null) return starTier;
			}
		}
		return null;
	}

	//
	// ======= Event Listeners =======
	//

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if ("F2P Star Assist".equals(event.getGroup())) {
			if ("groups".equals(event.getKey())) {
				try {
					setGroups(loadGroups(event.getNewValue()));
				} catch (RuntimeException e) {
					log.error("Invalid groups JSON in config", e);
				}
			}

			else if ("hint enabled".equals(event.getKey())) {
				showHintArrow(Boolean.parseBoolean(event.getNewValue()));
			}
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGGED_IN) {
			showHintArrow(config.hintArrowEnabled());
		}
	}

	@Subscribe
	public void onWorldChanged(WorldChanged event) {
		showHintArrow(config.hintArrowEnabled());
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		for (CrashedStar star : starCache.getStars()) {
			if (client.getWorld() == star.getWorld()) {
				WorldPoint starPoint = StarPoints.fromLocation(star.getLocation());
				if (starPoint != null && playerInStarRange(starPoint)) {
					LocalPoint localPoint = LocalPoint.fromWorld(client, starPoint);
					Tile tile = client.getScene().getTiles()[starPoint.getPlane()][localPoint.getSceneX()][localPoint.getSceneY()];

					StarTier starTier = getStar(tile);
					if (starTier == null) {
						//a star that was in the cache is no longer there.
						clientThread.invokeLater(() -> {
							if (getStar(tile) == null) {
								//if in the next tick there is still no star, report it as gone.
								reportStarGone(star.getKey(), true);
								if (starPoint.equals(client.getHintArrowPoint())) {
									client.clearHintArrow();
								}
							}
						});
					}

					else if (playerInRange(starPoint, 4) && starPoint.equals(client.getHintArrowPoint())) {
						//if the player got withing a range of 4, clear the arrow.
						client.clearHintArrow();
					}
				}
			}
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event) {
		GameObject gameObject = event.getGameObject();
		StarTier starTier = StarIds.getTier(gameObject.getId());
		if (starTier == null) return;	//not a star

		WorldPoint worldPoint = gameObject.getWorldLocation();
		StarLocation starLocation = StarPoints.toLocation(worldPoint);
		if (starLocation == null) {
			log.error("Unrecognised star location at world point: " + worldPoint);
			return;
		}
		StarKey starKey = new StarKey(starLocation, client.getWorld());

		log.debug("A " + starTier + " star spawned at location: " + worldPoint + ".");

		CrashedStar knownStar = starCache.get(starKey);
		if (knownStar == null) {
			//we found a new star
			CrashedStar newStar = new CrashedStar(starKey, starTier, Instant.now(), new RunescapeUser(client.getLocalPlayer().getName()));
			reportStarNew(newStar, getSharingGroupsOwnFoundStars());
		} else {
			//the star already exists.
			StarTier upToDateTier = StarIds.getTier(gameObject.getId());
			if (upToDateTier != null) {
				reportStarUpdate(starKey, upToDateTier, true);
			}
		}

		//show hint arrow
		if (config.hintArrowEnabled() && !client.hasHintArrow()) {
			client.setHintArrow(worldPoint);
		}
	}

	// If stars degrade, they just de-spawn and spawn a new one at a lower tier. The GameObjectChanged event is never called.
	// We don't listen on GameObjectDespawned, because onGameTick already handles disintegrated stars.

	private boolean isWorld(int world) {
		net.runelite.http.api.worlds.WorldResult worldResult = worldService.getWorlds();
		if (worldResult == null) return false;
		return worldResult.findWorld(world) != null;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		final String message = event.getMessage();

		StarLocation location;
		int world;
		StarTier tier;

		switch (event.getType()) {
			case FRIENDSCHAT:
				if (config.interpretFriendsChat()) {
					if ((tier = StarLingo.interpretTier(message)) != null
							&& (location = StarLingo.interpretLocation(message)) != null
							&& (world = StarLingo.interpretWorld(message)) != -1
							&& isWorld(world)) {
						CrashedStar star = new CrashedStar(tier, location, world, Instant.now(), new RunescapeUser(stripChatIcon(event.getName())));
						reportStarNew(star, getSharingGroupsFriendsChat());
					}
				}
				break;
			case CLAN_CHAT:
				if (config.interpretClanChat()) {
					if ((tier = StarLingo.interpretTier(message)) != null
							&& (location = StarLingo.interpretLocation(message)) != null
							&& (world = StarLingo.interpretWorld(message)) != -1
							&& isWorld(world)) {
						CrashedStar star = new CrashedStar(tier, location, world, Instant.now(), new RunescapeUser(stripChatIcon(event.getName())));
						reportStarNew(star, getSharingGroupsClanChat());
					}
				}
				break;
			case PRIVATECHAT:
			case MODPRIVATECHAT:
				if (config.interpretPrivateChat()) {
					if ((tier = StarLingo.interpretTier(message)) != null
							&& (location = StarLingo.interpretLocation(message)) != null
							&& (world = StarLingo.interpretWorld(message)) != -1
							&& isWorld(world)) {
						CrashedStar star = new CrashedStar(tier, location, world, Instant.now(), new RunescapeUser(stripChatIcon(event.getName())));
						reportStarNew(star, getSharingGroupsPrivateChat());
					}
				}
				break;
			case PUBLICCHAT:
			case MODCHAT:
				if (config.interpretPublicChat()) {
					if ((tier = StarLingo.interpretTier(message)) != null
							&& (location = StarLingo.interpretLocation(message)) != null
							&& (world = StarLingo.interpretWorld(message)) != -1
							&& isWorld(world)) {
						CrashedStar star = new CrashedStar(tier, location, world, Instant.now(), new RunescapeUser(stripChatIcon(event.getName())));
						reportStarNew(star, getSharingGroupsPublicChat());
					}
				}
				break;
		}
	}
}

package com.janboerman.f2pstarassist.plugin;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class TextUtil {

    private static final Pattern CHAT_NAME_PATTERN = Pattern.compile("(<img=\\d+>)?(?<rsn>.*)");

    private TextUtil() {
    }

    /**
     * Strips the player's chat icon from the name.
     * Examples of 'chat icon's are pmod/jmod crowns, or iron man mode helmet.
     * @param chatName the player's name in chat
     * @return the player's name without the icon prefixed
     */
    public static String stripChatIcon(String chatName) {
        Matcher matcher = CHAT_NAME_PATTERN.matcher(chatName);
        if (matcher.find()) {
            return matcher.group("rsn");
        } else {
            return chatName;
        }
    }

}

package com.janboerman.f2pstarassist.plugin;

import com.google.common.html.HtmlEscapers;
import com.janboerman.f2pstarassist.common.CrashedStar;
import com.janboerman.f2pstarassist.common.DiscordUser;
import com.janboerman.f2pstarassist.common.RunescapeUser;
import com.janboerman.f2pstarassist.common.User;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.annotation.Nullable;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.StringJoiner;

public class StarAssistPanel extends PluginPanel {

    private static final JPanel NO_STARS_PANEL = new JPanel(); static {
        JLabel text = new JLabel("There are currently no known stars.");
        text.setFont(FontManager.getRunescapeSmallFont());
        NO_STARS_PANEL.add(text);
    }

    private final StarAssistPlugin plugin;
    private final StarAssistConfig config;
    private final Client client;
    private final ClientThread clientThread;
    private final List<CrashedStar> starList = new ArrayList<>(2);

    public StarAssistPanel(StarAssistPlugin plugin, StarAssistConfig config, Client client, ClientThread clientThread) {
        this.plugin = plugin;
        this.config = config;
        this.client = client;
        this.clientThread = clientThread;

        setLayout(new GridLayout(0, 1));

        //TODO a refresh button?
    }

    private static Comparator<CrashedStar> compareByLocation(@Nullable WorldPoint playerLocation) {
        if (playerLocation != null && playerLocation.getPlane() == 0) {
            return (star1, star2) -> {
                WorldPoint star1Point = StarPoints.fromLocation(star1.getLocation());
                WorldPoint star2Point = StarPoints.fromLocation(star2.getLocation());
                return Integer.compare(star1Point.distanceTo2D(playerLocation), star2Point.distanceTo2D(playerLocation));
            };
        } else {
            return Comparator.comparing(CrashedStar::getLocation);
        }
    }

    public void setStars(Collection<CrashedStar> starList, @Nullable WorldPoint playerLocation) {
        this.removeAll();

        this.starList.clear();

        if (starList.isEmpty()) {
            add(NO_STARS_PANEL);
        } else {
            this.starList.addAll(starList);
            this.starList.sort(compareByLocation(playerLocation).thenComparing(Comparator.comparing(CrashedStar::getTier).reversed()));

            //re-paint
            for (CrashedStar star : this.starList) {
                //TODO don't add to the root panel, use a separate panel instead, that itself is added to the root panel.
                add(new StarAssistPanelRow(star), BorderLayout.SOUTH);
            }
        }

        revalidate();
        repaint();
    }

    private class StarAssistPanelRow extends JPanel {

        private final JMenuItem removeMenuItem;
        private final JMenuItem copyToClipboardMenuItem;

        private final CrashedStar star;

        private Color lastBackGround;

        StarAssistPanelRow(CrashedStar star) {
            this.star = star;
            setBackground(ColorScheme.MEDIUM_GRAY_COLOR);

            setLayout(new BorderLayout());
            setBorder(new EmptyBorder(2, 2, 2, 2));

            String foundBy = null;
            final User finder = star.getDiscoveredBy();
            if (finder instanceof RunescapeUser) {
                foundBy = ((RunescapeUser) finder).getName();
            } else if (finder instanceof DiscordUser) {
                foundBy = ((DiscordUser) finder).getName();
            }

            if (foundBy != null) {
                foundBy = HtmlEscapers.htmlEscaper().escape(foundBy);
            }

            final Instant detectedAt = star.getDetectedAt();
            final LocalDateTime localDateTime = LocalDateTime.ofInstant(detectedAt, ZoneId.systemDefault());
            final String foundAt = localDateTime.format(DateTimeFormatter.ofPattern("HH:mm"));

            final StringJoiner tooltipText = new StringJoiner("<br>", "<html>", "</html>");
            if (foundBy != null)
                tooltipText.add("Found by: " + foundBy);
            tooltipText.add("Found at: " + foundAt);
            tooltipText.add("Double click to hop to this world.");

            setToolTipText(tooltipText.toString());

            final String text = "T" + star.getTier().getSize() + " W" + star.getWorld() + " " + star.getLocation();
            final JLabel textLabel = new JLabel(text);
            textLabel.setFont(FontManager.getRunescapeSmallFont());
            add(textLabel);

            //right-click menu:
            final JPopupMenu popupMenu = new JPopupMenu();
            popupMenu.setBorder(new EmptyBorder(2, 2, 2, 2));
            //right-click -> copy to clipboard option
            copyToClipboardMenuItem = new JMenuItem("Copy to clipboard"); //TODO icon?
            copyToClipboardMenuItem.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    StringSelection selection = new StringSelection(text);
                    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
                    clipboard.setContents(selection, selection);
                }
            });
            popupMenu.add(copyToClipboardMenuItem);
            //right click -> remove option
            removeMenuItem = new JMenuItem("Remove"); //TODO icon?
            removeMenuItem.addActionListener(new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    starList.remove(star);
                    clientThread.invoke(() -> {
                        //remove from local cache
                        plugin.removeStar(star.getKey());

                        //re-paint panel
                        WorldPoint playerLocation = plugin.getLocalPlayerLocation();
                        SwingUtilities.invokeLater(() -> setStars(new ArrayList<>(starList), playerLocation));
                    });
                }
            });
            popupMenu.add(removeMenuItem);

            setComponentPopupMenu(popupMenu);

            this.addMouseListener(new MouseAdapter() {
                @Override
                public void mouseClicked(MouseEvent event) {
                    //TODO this does not always seem to work reliably:
                    if (event.getClickCount() == 2) {
                        plugin.hopAndHint(star);
                    }
                }

                @Override
                public void mousePressed(MouseEvent event) {
                    if (event.getClickCount() == 2) {
                        setBackground(getBackground().brighter());
                    }
                }

                @Override
                public void mouseReleased(MouseEvent event) {
                    if (event.getClickCount() == 2) {
                        setBackground(getBackground().darker());
                    }
                }

                @Override
                public void mouseEntered(MouseEvent event) {
                    lastBackGround = getBackground();
                    setBackground(getBackground().brighter());
                }

                @Override
                public void mouseExited(MouseEvent event) {
                    setBackground(lastBackGround);
                }
            });
        }
    }

}


