package com.chatwidgets;

import net.runelite.api.ChatMessageType;

public class WidgetMessage {
    private final String message;
    private final long timestamp;
    private final ChatMessageType type;
    private final boolean bossKc;
    private final String sender;
    private final boolean outgoing;
    private final boolean isPrivate;
    private final int maxFadeSeconds;
    private int count = 1;

    public static WidgetMessage gameMessage(String message, long timestamp, ChatMessageType type, boolean bossKc) {
        return new WidgetMessage(message, timestamp, type, bossKc, null, false, false, 0);
    }

    public static WidgetMessage privateMessage(String sender, String message, long timestamp, boolean outgoing) {
        return new WidgetMessage(message, timestamp,
                outgoing ? ChatMessageType.PRIVATECHATOUT : ChatMessageType.PRIVATECHAT,
                false, sender, outgoing, true, 0);
    }

    public static WidgetMessage loginNotification(String sender, String message, long timestamp, int maxFadeSeconds) {
        return new WidgetMessage(message, timestamp, ChatMessageType.LOGINLOGOUTNOTIFICATION,
                false, sender, false, true, maxFadeSeconds);
    }

    private WidgetMessage(String message, long timestamp, ChatMessageType type, boolean bossKc,
            String sender, boolean outgoing, boolean isPrivate, int maxFadeSeconds) {
        this.message = message;
        this.timestamp = timestamp;
        this.type = type;
        this.bossKc = bossKc;
        this.sender = sender;
        this.outgoing = outgoing;
        this.isPrivate = isPrivate;
        this.maxFadeSeconds = maxFadeSeconds;
    }

    public WidgetMessage withMessage(String newMessage) {
        WidgetMessage merged = new WidgetMessage(newMessage, this.timestamp, this.type, this.bossKc,
                this.sender, this.outgoing, this.isPrivate, this.maxFadeSeconds);
        merged.count = this.count;
        return merged;
    }

    public String getMessage() {
        return message;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public ChatMessageType getType() {
        return type;
    }

    public boolean isBossKc() {
        return bossKc;
    }

    public String getSender() {
        return sender;
    }

    public boolean isOutgoing() {
        return outgoing;
    }

    public boolean isPrivate() {
        return isPrivate;
    }

    public int getCount() {
        return count;
    }

    public void incrementCount() {
        count++;
    }

    public int getMaxFadeSeconds() {
        return maxFadeSeconds;
    }
}

package com.chatwidgets;

public enum FontSize {
    REGULAR("Regular"),
    SMALL("Small");

    private final String name;

    FontSize(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

package com.chatwidgets;

public enum WidgetPosition {
    DEFAULT("Default"),
    BELOW_PLAYER("Below Player"),
    ABOVE_PLAYER("Above Player");

    private final String name;

    WidgetPosition(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return name;
    }
}

package com.chatwidgets;

import net.runelite.api.ChatMessageType;
import net.runelite.api.IndexedSprite;
import net.runelite.client.ui.FontManager;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class ChatRenderUtils {

    private ChatRenderUtils() {
    }

    public static FontMetrics setupGraphics(Graphics2D graphics, FontSize fontSize) {
        graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
        graphics.setRenderingHint(RenderingHints.KEY_INTERPOLATION,
                RenderingHints.VALUE_INTERPOLATION_NEAREST_NEIGHBOR);

        Font baseFont = fontSize == FontSize.SMALL
                ? FontManager.getRunescapeSmallFont()
                : FontManager.getRunescapeFont();
        graphics.setFont(baseFont);
        return graphics.getFontMetrics();
    }

    public static int drawIcon(Graphics2D graphics, BufferedImage img, FontSize fontSize,
            FontMetrics metrics, int x, int y) {
        if (img == null) {
            return 0;
        }
        boolean isSmallFont = fontSize == FontSize.SMALL;
        int iconWidth = img.getWidth();
        int iconHeight = img.getHeight();

        if (isSmallFont) {
            iconWidth = (int) (iconWidth * 0.75);
            iconHeight = (int) (iconHeight * 0.75);
        }

        int iconY = y - iconHeight + metrics.getDescent() - 4;
        if (isSmallFont) {
            iconY += 2;
        }

        if (iconY < 0) {
            return iconWidth + 2;
        }

        graphics.drawImage(img, x + 1, iconY, iconWidth, iconHeight, null);
        return iconWidth + 2;
    }

    public static int drawText(Graphics2D graphics, String text, Color color, int alpha, int x, int y,
            boolean drawShadow, FontMetrics metrics) {
        if (drawShadow) {
            graphics.setColor(withAlpha(Color.BLACK, alpha));
            graphics.drawString(text, x + 2, y + 1);
        }
        graphics.setColor(withAlpha(color, alpha));
        graphics.drawString(text, x + 1, y);
        return metrics.stringWidth(text);
    }

    public static int calculateAlpha(WidgetMessage msg, long currentTime, long fadeOutMs) {
        if (fadeOutMs <= 0) {
            return 255;
        }
        long age = currentTime - msg.getTimestamp();
        if (age <= fadeOutMs) {
            return 255;
        }
        double fadeProgress = Math.min(1.0, (age - fadeOutMs) / 1200.0);
        return (int) (255 * (1.0 - fadeProgress));
    }

    public static Color withAlpha(Color color, int alpha) {
        return new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(0, Math.min(255, alpha)));
    }

    public static String formatTimestamp(long timestamp, String format) {
        try {
            return new SimpleDateFormat(format).format(new Date(timestamp));
        } catch (IllegalArgumentException e) {
            return null;
        }
    }

    public static List<RenderLine> buildPrivateMessageLines(WidgetMessage msg, FontMetrics metrics,
            int widgetWidth, long currentTime, long fadeOutMs, boolean wrapText, Color textColor,
            FontSize fontSize, IndexedSprite[] modIcons, boolean showTimestamp, String timestampFormat,
            int maxMessageLength) {

        List<RenderLine> lines = new ArrayList<>();
        int alpha = calculateAlpha(msg, currentTime, fadeOutMs);

        List<TextSegment> headerSegments = new ArrayList<>();
        int headerWidth = 0;

        if (showTimestamp && timestampFormat != null && !timestampFormat.isEmpty()) {
            String ts = formatTimestamp(msg.getTimestamp(), timestampFormat + " ");
            if (ts != null) {
                int width = metrics.stringWidth(ts);
                headerSegments.add(new TextSegment(ts, -1, width, textColor));
                headerWidth += width;
            }
        }

        boolean isLoginNotification = msg.getType() == ChatMessageType.LOGINLOGOUTNOTIFICATION;

        if (!isLoginNotification) {
            String prefix = msg.isOutgoing() ? "To " : "From ";
            headerSegments.add(new TextSegment(prefix, -1, metrics.stringWidth(prefix), textColor));
            headerWidth += metrics.stringWidth(prefix);

            List<TextSegment> senderSegments = parseTextWithIcons(msg.getSender(), metrics, modIcons,
                    textColor, fontSize);
            for (TextSegment seg : senderSegments) {
                headerSegments.add(seg);
                headerWidth += seg.width;
            }

            headerSegments.add(new TextSegment(": ", -1, metrics.stringWidth(": "), textColor));
            headerWidth += metrics.stringWidth(": ");
        }

        String messageText = msg.getMessage();
        if (messageText != null && messageText.length() > maxMessageLength) {
            messageText = messageText.substring(0, maxMessageLength) + "...";
        }

        List<TextSegment> messageSegments = parseTextWithIcons(messageText, metrics, modIcons, textColor, fontSize);

        if (!wrapText) {
            List<TextSegment> singleLine = new ArrayList<>(headerSegments);
            singleLine.addAll(messageSegments);
            lines.add(new RenderLine(singleLine, alpha));
        } else {
            int firstLineRemaining = widgetWidth - headerWidth;
            List<List<TextSegment>> wrappedLines = wrapSegments(messageSegments, metrics, firstLineRemaining,
                    widgetWidth, textColor);

            addWrappedLines(lines, alpha, headerSegments, wrappedLines);
        }

        return lines;
    }

    public static void addWrappedLines(List<RenderLine> lines, int alpha, List<TextSegment> headerSegments,
            List<List<TextSegment>> wrappedLines) {
        if (wrappedLines.isEmpty()) {
            lines.add(new RenderLine(headerSegments, alpha));
        } else {
            List<TextSegment> firstLine = new ArrayList<>(headerSegments);
            firstLine.addAll(wrappedLines.get(0));
            lines.add(new RenderLine(firstLine, alpha));

            for (int i = 1; i < wrappedLines.size(); i++) {
                lines.add(new RenderLine(wrappedLines.get(i), alpha));
            }
        }
    }

    public static BufferedImage getCachedSprite(IndexedSprite[] modIcons, int iconId,
            Map<Integer, BufferedImage> spriteCache) {
        if (modIcons == null || iconId < 0 || iconId >= modIcons.length) {
            return null;
        }

        IndexedSprite sprite = modIcons[iconId];
        if (sprite == null) {
            return null;
        }

        BufferedImage cached = spriteCache.get(iconId);
        if (cached != null && cached.getWidth() == sprite.getWidth() && cached.getHeight() == sprite.getHeight()) {
            return cached;
        }

        BufferedImage img = spriteToBufferedImage(sprite);
        if (img != null) {
            spriteCache.put(iconId, img);
        }
        return img;
    }

    public static BufferedImage spriteToBufferedImage(IndexedSprite sprite) {
        if (sprite == null) {
            return null;
        }

        int width = sprite.getWidth();
        int height = sprite.getHeight();
        byte[] pixels = sprite.getPixels();
        int[] palette = sprite.getPalette();

        if (width <= 0 || height <= 0 || pixels == null || palette == null) {
            return null;
        }

        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        for (int py = 0; py < height; py++) {
            for (int px = 0; px < width; px++) {
                int idx = py * width + px;
                if (idx >= pixels.length) {
                    continue;
                }
                int paletteIdx = pixels[idx] & 0xFF;
                if (paletteIdx == 0) {
                    img.setRGB(px, py, 0x00000000);
                } else if (paletteIdx < palette.length) {
                    img.setRGB(px, py, 0xFF000000 | palette[paletteIdx]);
                }
            }
        }
        return img;
    }

    public static int calculateIconWidth(IndexedSprite[] modIcons, int iconId, FontSize fontSize) {
        int iconWidth = 13;
        if (modIcons != null && iconId >= 0 && iconId < modIcons.length && modIcons[iconId] != null) {
            iconWidth = modIcons[iconId].getWidth() + 1;
            if (fontSize == FontSize.SMALL) {
                iconWidth = (int) (iconWidth * 0.75);
            }
        }
        return iconWidth;
    }

    public static List<TextSegment> parseTextWithIcons(String text, FontMetrics metrics,
            IndexedSprite[] modIcons, Color textColor, FontSize fontSize) {
        List<TextSegment> segments = new ArrayList<>();
        if (text == null || text.isEmpty()) {
            return segments;
        }

        Pattern imgTagPattern = Pattern.compile("<img=(\\d+)>");
        Matcher matcher = imgTagPattern.matcher(text);
        int lastEnd = 0;

        while (matcher.find()) {
            if (matcher.start() > lastEnd) {
                String before = text.substring(lastEnd, matcher.start());
                segments.add(new TextSegment(before, -1, metrics.stringWidth(before), textColor));
            }

            try {
                int iconId = Integer.parseInt(matcher.group(1));
                int iconWidth = calculateIconWidth(modIcons, iconId, fontSize);
                segments.add(new TextSegment("", iconId, iconWidth, textColor));
            } catch (NumberFormatException e) {
                String raw = matcher.group(0);
                segments.add(new TextSegment(raw, -1, metrics.stringWidth(raw), textColor));
            }
            lastEnd = matcher.end();
        }

        if (lastEnd < text.length()) {
            String after = text.substring(lastEnd);
            segments.add(new TextSegment(after, -1, metrics.stringWidth(after), textColor));
        }

        return segments;
    }

    public static List<List<TextSegment>> wrapSegments(List<TextSegment> segments,
            FontMetrics metrics, int firstLineWidth, int subsequentLineWidth, Color textColor) {
        List<List<TextSegment>> lines = new ArrayList<>();
        List<TextSegment> currentLine = new ArrayList<>();
        int currentWidth = firstLineWidth;

        for (TextSegment segment : segments) {
            if (segment.iconId == TextSegment.LINE_BREAK) {
                if (!currentLine.isEmpty()) {
                    lines.add(currentLine);
                    currentLine = new ArrayList<>();
                }
                currentWidth = subsequentLineWidth;
            } else if (segment.iconId >= 0) {
                if (segment.width <= currentWidth) {
                    currentLine.add(segment);
                    currentWidth -= segment.width;
                } else {
                    if (!currentLine.isEmpty()) {
                        lines.add(currentLine);
                        currentLine = new ArrayList<>();
                        currentWidth = subsequentLineWidth;
                    }
                    currentLine.add(segment);
                    currentWidth -= segment.width;
                }
            } else {
                String[] words = segment.text.split(" ", -1);
                for (int wi = 0; wi < words.length; wi++) {
                    String word = words[wi];
                    if (word.isEmpty() && wi < words.length - 1) {
                        int spaceWidth = metrics.stringWidth(" ");
                        if (spaceWidth <= currentWidth) {
                            currentLine.add(new TextSegment(" ", -1, spaceWidth, segment.color));
                            currentWidth -= spaceWidth;
                        }
                        continue;
                    }

                    int wordWidth = metrics.stringWidth(word);
                    int spaceWidth = metrics.stringWidth(" ");
                    boolean needsSpace = !currentLine.isEmpty() && wi > 0;
                    int neededWidth = wordWidth + (needsSpace ? spaceWidth : 0);

                    if (neededWidth <= currentWidth) {
                        if (needsSpace) {
                            currentLine.add(new TextSegment(" ", -1, spaceWidth, segment.color));
                            currentWidth -= spaceWidth;
                        }
                        currentLine.add(new TextSegment(word, -1, wordWidth, segment.color));
                        currentWidth -= wordWidth;
                    } else {
                        if (!currentLine.isEmpty()) {
                            lines.add(currentLine);
                            currentLine = new ArrayList<>();
                            currentWidth = subsequentLineWidth;
                        }
                        currentLine.add(new TextSegment(word, -1, wordWidth, segment.color));
                        currentWidth -= wordWidth;
                    }
                }
            }
        }

        if (!currentLine.isEmpty()) {
            lines.add(currentLine);
        }
        return lines;
    }
}

package com.chatwidgets;

import com.google.inject.Provides;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Point;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ResizeableChanged;
import net.runelite.api.events.VarClientIntChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarClientID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;

@PluginDescriptor(name = "Chat Widgets", description = "Displays game and private chat messages in customizable overlay widgets.", tags = {
        "game", "private", "chat", "pm", "message", "widget", "overlay", "split", "move", "custom", "customize",
        "resizable", "transparent" })
public class ChatWidgetPlugin extends Plugin {

    private static final Pattern BOSS_KC_PATTERN = Pattern.compile("Your .+ count is:");

    private static final MessageMergeRule[] MESSAGE_MERGE_RULES = {
            new MessageMergeRule("You eat", "It heals some health.", true),
            new MessageMergeRule("You drink", "You have", false)
    };

    @Inject
    private Client client;

    @Inject
    private ChatWidgetConfig config;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private GameChatOverlay gameOverlay;

    @Inject
    private PrivateChatOverlay privateOverlay;

    private final CopyOnWriteArrayList<WidgetMessage> gameMessages = new CopyOnWriteArrayList<>();
    private final CopyOnWriteArrayList<WidgetMessage> privateMessages = new CopyOnWriteArrayList<>();

    @Override
    protected void startUp() {
        overlayManager.add(gameOverlay);
        overlayManager.add(privateOverlay);

        if (config.enablePrivateMessages()) {
            hidePmWidgets();
        }
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(gameOverlay);
        overlayManager.remove(privateOverlay);
        //keep history for now i think
        //clearGameMessages();
        //clearPrivateMessages();
        showPmWidgets();
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals("chatwidgets")) {
            return;
        }

        if (event.getKey().equals("enablePrivateMessages")) {
            if (config.enablePrivateMessages()) {
                hidePmWidgets();
            } else {
                showPmWidgets();
            }
        }

        if (event.getKey().equals("swapStackingOrder")) {
            overlayManager.remove(gameOverlay);
            overlayManager.remove(privateOverlay);
            overlayManager.add(gameOverlay);
            overlayManager.add(privateOverlay);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGIN_SCREEN) {
            //keep history for now i think
            // clearGameMessages();
        }
        if (event.getGameState() == GameState.LOGGED_IN && config.enablePrivateMessages()) {
            hidePmWidgets();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (event.getGroupId() == InterfaceID.PM_CHAT && config.enablePrivateMessages()) {
            hidePmWidgets();
        }
    }

    @Subscribe
    public void onVarClientIntChanged(VarClientIntChanged event) {
        if (event.getIndex() == VarClientID.CHAT_VIEW) {
            updateSmartPosition(gameOverlay);
            updateSmartPosition(privateOverlay);
        }
    }

    @Subscribe
    public void onResizeableChanged(ResizeableChanged event) {
        updateDefaultPosition(gameOverlay);
        updateDefaultPosition(privateOverlay);
        updateSmartPosition(gameOverlay);
        updateSmartPosition(privateOverlay);
    }

    private void updateDefaultPosition(net.runelite.client.ui.overlay.Overlay overlay) {
        OverlayPosition defaultPos = client.isResized()
                ? OverlayPosition.ABOVE_CHATBOX_RIGHT
                : OverlayPosition.BOTTOM_LEFT;
        overlay.setPosition(defaultPos);
    }

    private void updateSmartPosition(net.runelite.client.ui.overlay.Overlay overlay) {
        if (!config.smartPositioning()) {
            return;
        }

        OverlayPosition currentPos = overlay.getPreferredPosition() != null
                ? overlay.getPreferredPosition()
                : overlay.getPosition();

        if (isTopPosition(currentPos)) {
            return;
        }

        OverlayPosition targetPos;

        if (!client.isResized()) {
            targetPos = OverlayPosition.BOTTOM_LEFT;
        } else if (isChatboxHidden()) {
            targetPos = OverlayPosition.ABOVE_CHATBOX_RIGHT;
        } else {
            return;
        }

        if (currentPos != targetPos) {
            overlay.setPreferredPosition(targetPos);
        }
    }

    private boolean isTopPosition(OverlayPosition position) {
        return position == OverlayPosition.TOP_CENTER
                || position == OverlayPosition.TOP_RIGHT
                || position == OverlayPosition.TOP_LEFT
                || position == OverlayPosition.CANVAS_TOP_RIGHT;
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        String option = event.getMenuOption();
        String target = event.getMenuTarget();
        if (option == null) {
            return;
        }

        if (option.contains("Game:") && option.contains("Clear")) {
            clearGameMessages();
            return;
        }
        if (option.contains("Private:") && option.contains("Clear")) {
            clearPrivateMessages();
            return;
        }

        if (option.equals("Clear") && target != null) {
            switch (target) {
                case "Merged chat history":
                    clearGameMessages();
                    clearPrivateMessages();
                    break;
                case "Game chat history":
                    clearGameMessages();
                    break;
                case "Private chat history":
                    clearPrivateMessages();
                    break;
            }
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        ChatMessageType type = event.getType();

        switch (type) {
            case GAMEMESSAGE:
            case SPAM:
            case CONSOLE:
            case WELCOME:
            case BROADCAST:
            case DIDYOUKNOW:
            case ENGINE:
            case FRIENDNOTIFICATION:
            case FRIENDSCHATNOTIFICATION:
            case IGNORENOTIFICATION:
            case ITEM_EXAMINE:
            case NPC_EXAMINE:
            case OBJECT_EXAMINE:
            case PLAYERRELATED:
            case SNAPSHOTFEEDBACK:
            case TRADE:
            case TRADE_SENT:
            case TRADEREQ:
            case UNKNOWN: //combat achievements-related?
                handleGameMessage(event);
                break;

            case PRIVATECHAT:
            case PRIVATECHATOUT:
            case MODPRIVATECHAT:
                handlePrivateMessage(event);
                break;

            case LOGINLOGOUTNOTIFICATION:
                handleLoginLogoutNotification(event);
                break;

            default:
                break;
        }
    }

    private void handleGameMessage(ChatMessage event) {
        String message = event.getMessage();
        if (message == null || message.trim().isEmpty()) {
            return;
        }

        String cleanMessage = message.trim();
        for (MessageMergeRule rule : MESSAGE_MERGE_RULES) {
            if (rule.matchesPreviousPrefix(cleanMessage)) {
                cleanMessage = cleanMessage.replace("<br>", " ");
                break;
            }
        }
        boolean isBossKc = BOSS_KC_PATTERN.matcher(cleanMessage).find();

        if (!gameMessages.isEmpty()) {
            WidgetMessage lastMsg = gameMessages.get(gameMessages.size() - 1);
            String merged = tryMergeMessages(lastMsg.getMessage(), cleanMessage);
            if (merged != null) {
                String mergedStripped = stripTags(merged);
                int existingCount = 0;

                if (config.collapseGameChat()) {
                    for (int i = gameMessages.size() - 2; i >= 0; i--) {
                        WidgetMessage existing = gameMessages.get(i);
                        if (stripTags(existing.getMessage()).equals(mergedStripped)) {
                            existingCount = existing.getCount();
                            gameMessages.remove(i);
                            break;
                        }
                    }
                }

                WidgetMessage mergedMsg = WidgetMessage.gameMessage(
                        merged, System.currentTimeMillis(), lastMsg.getType(), lastMsg.isBossKc());
                for (int i = 0; i < existingCount; i++) {
                    mergedMsg.incrementCount();
                }
                gameMessages.set(gameMessages.size() - 1, mergedMsg);
                return;
            }
        }

        String currentStripped = stripTags(cleanMessage);
        int existingCount = 0;

        if (config.collapseGameChat()) {
            for (int i = gameMessages.size() - 1; i >= 0; i--) {
                WidgetMessage existing = gameMessages.get(i);
                if (stripTags(existing.getMessage()).equals(currentStripped)) {
                    existingCount = existing.getCount();
                    gameMessages.remove(i);
                    break;
                }
            }
        }

        WidgetMessage newMsg = WidgetMessage.gameMessage(
                cleanMessage, System.currentTimeMillis(), event.getType(), isBossKc);
        for (int i = 0; i < existingCount; i++) {
            newMsg.incrementCount();
        }
        gameMessages.add(newMsg);

        while (gameMessages.size() > 50) {
            gameMessages.remove(0);
        }
    }

    private String tryMergeMessages(String previousMessage, String newMessage) {
        for (MessageMergeRule rule : MESSAGE_MERGE_RULES) {
            if (rule.matches(previousMessage, newMessage)) {
                return rule.merge(previousMessage, newMessage);
            }
        }
        return null;
    }

    private String stripTags(String text) {
        if (text == null) {
            return "";
        }
        return text.replaceAll("<[^>]*>", "");
    }

    private void handlePrivateMessage(ChatMessage event) {
        boolean isOutgoing = event.getType() == ChatMessageType.PRIVATECHATOUT;

        String sender = event.getName();
        if (sender != null) {
            sender = sender.replace('\u00A0', ' ').trim();
        } else {
            sender = "Unknown";
        }

        String message = event.getMessage();
        if (message == null || message.trim().isEmpty()) {
            return;
        }

        privateMessages.add(WidgetMessage.privateMessage(
                sender, message.trim(), System.currentTimeMillis(), isOutgoing));

        while (privateMessages.size() > 50) {
            privateMessages.remove(0);
        }
    }

    private void handleLoginLogoutNotification(ChatMessage event) {
        String sender = event.getName();
        if (sender != null) {
            sender = sender.replace('\u00A0', ' ').trim();
        } else {
            sender = "System";
        }

        String message = event.getMessage();
        if (message == null || message.trim().isEmpty()) {
            return;
        }

        int maxFade = Math.min(5, config.privateFadeOutDuration());
        if (maxFade <= 0) {
            maxFade = 5;
        }

        privateMessages.add(WidgetMessage.loginNotification(
                sender, message.trim(), System.currentTimeMillis(), maxFade));

        while (privateMessages.size() > config.privateMaxMessages() * 2) {
            privateMessages.remove(0);
        }
    }

    public boolean shouldShowGameOverlay() {
        if (!config.enableGameMessages()) {
            return false;
        }
        if (client.getGameState() != GameState.LOGGED_IN) {
            return false;
        }
        return isChatboxHidden();
    }


    public boolean isChatboxHidden() {
        return isChatboxMinimized() || isChatboxWidgetHidden();
    }

    /**
     * Checks if the user manually minimized their chatbox by clicking on the active tab underneath the chatbox.<br>
     * Use {@link ChatWidgetPlugin#isChatboxHidden()}.
     */
    private boolean isChatboxMinimized() {
        return client.getVarcIntValue(VarClientID.CHAT_VIEW) == 1337;
    }

    /**
     * Checks if the chatbox widget itself is hidden from the game interface.
     * Use {@link ChatWidgetPlugin#isChatboxHidden()}.
     */
    private boolean isChatboxWidgetHidden() {
        Widget chatboxWidget = client.getWidget(InterfaceID.Chatbox.CHATAREA);
        return (chatboxWidget != null && chatboxWidget.isHidden());
    }

    public boolean shouldShowPrivateOverlay() {
        return config.enablePrivateMessages();
    }

    public boolean isWidgetsMerged() {
        return ((client.isResized() && isChatboxMinimized()) || !client.isResized() && isChatboxWidgetHidden())
                && config.mergeWithGameWidget()
                && config.enableGameMessages()
                && config.enablePrivateMessages()
                && config.gamePosition() == WidgetPosition.DEFAULT;
    }

    public boolean isGameFilterEnabled() {
        return client.getVarbitValue(VarbitID.GAME_FILTER) == 1;
    }

    public boolean isBossKcFilterEnabled() {
        return client.getVarbitValue(VarbitID.BOSS_KILLCOUNT_FILTERED) == 1;
    }

    public List<WidgetMessage> getGameMessages() {
        int size = gameMessages.size();
        if (size == 0) {
            return new ArrayList<>(0);
        }

        long currentTime = System.currentTimeMillis();
        int fadeOutDuration = config.gameFadeOutDuration();
        long fadeOutThreshold = fadeOutDuration > 0 ? (fadeOutDuration * 2000L) + 2000 : 0;
        boolean gameFilterEnabled = isGameFilterEnabled();
        boolean bossKcFilterEnabled = isBossKcFilterEnabled();

        int maxMessages = config.gameMaxMessages();
        List<WidgetMessage> filtered = new ArrayList<>(maxMessages);
        for (int i = size - 1; i >= 0 && filtered.size() < maxMessages; i--) {
            WidgetMessage msg = gameMessages.get(i);

            if (fadeOutThreshold > 0 && currentTime - msg.getTimestamp() >= fadeOutThreshold) {
                continue;
            }

            if (gameFilterEnabled && msg.getType() == ChatMessageType.SPAM) {
                continue;
            }

            if (bossKcFilterEnabled && msg.isBossKc()) {
                continue;
            }

            filtered.add(0, msg);
        }

        return filtered;
    }

    public List<WidgetMessage> getPrivateMessages() {
        int size = privateMessages.size();
        if (size == 0) {
            return new ArrayList<>(0);
        }

        long currentTime = System.currentTimeMillis();
        int fadeOutDuration = config.privateFadeOutDuration();
        long defaultFadeOutThreshold = fadeOutDuration > 0 ? (fadeOutDuration * 2000L) + 2000 : 0;

        int maxMessages = config.privateMaxMessages();
        List<WidgetMessage> filtered = new ArrayList<>(maxMessages);
        int pmCount = 0;
        for (int i = size - 1; i >= 0; i--) {
            WidgetMessage msg = privateMessages.get(i);

            int msgMaxFade = msg.getMaxFadeSeconds();
            long fadeOutThreshold;
            if (msgMaxFade > 0) {
                fadeOutThreshold = (msgMaxFade * 1000L) + 2000;
            } else {
                fadeOutThreshold = defaultFadeOutThreshold;
            }

            if (fadeOutThreshold > 0 && currentTime - msg.getTimestamp() >= fadeOutThreshold) {
                continue;
            }

            boolean isLoginNotification = msg.getType() == ChatMessageType.LOGINLOGOUTNOTIFICATION;
            if (!isLoginNotification && pmCount >= maxMessages) {
                continue;
            }

            filtered.add(0, msg);
            if (!isLoginNotification) {
                pmCount++;
            }
        }

        return filtered;
    }

    public void clearGameMessages() {
        gameMessages.clear();
    }

    public void clearPrivateMessages() {
        privateMessages.clear();
    }

    private void hidePmWidgets() {
        //hide all regardless idk if this will hide something unintentionally?
        hideGameframePmContainer(InterfaceID.TOPLEVEL, 36);
        hideGameframePmContainer(InterfaceID.TOPLEVEL_OSRS_STRETCH, 93);
        hideGameframePmContainer(InterfaceID.TOPLEVEL_PRE_EOC, 90);

        Widget pmContainer = client.getWidget(InterfaceID.PM_CHAT, 0);
        if (pmContainer != null) {
            pmContainer.setHidden(true);
            Widget[] dynamicChildren = pmContainer.getDynamicChildren();
            if (dynamicChildren != null) {
                for (Widget child : dynamicChildren) {
                    if (child != null) {
                        child.setHidden(true);
                    }
                }
            }
        }
    }

    private void showPmWidgets() {
        showGameframePmContainer(InterfaceID.TOPLEVEL, 36);
        showGameframePmContainer(InterfaceID.TOPLEVEL_OSRS_STRETCH, 93);
        showGameframePmContainer(InterfaceID.TOPLEVEL_PRE_EOC, 90);

        Widget pmContainer = client.getWidget(InterfaceID.PM_CHAT, 0);
        if (pmContainer != null) {
            pmContainer.setHidden(false);
            Widget[] dynamicChildren = pmContainer.getDynamicChildren();
            if (dynamicChildren != null) {
                for (Widget child : dynamicChildren) {
                    if (child != null) {
                        child.setHidden(false);
                    }
                }
            }
        }
    }

    private void hideGameframePmContainer(int group, int child) {
        Widget container = client.getWidget(group, child);
        if (container != null) {
            container.setHidden(true);
        }
    }

    private void showGameframePmContainer(int group, int child) {
        Widget container = client.getWidget(group, child);
        if (container != null) {
            container.setHidden(false);
        }
    }

    @Provides
    ChatWidgetConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ChatWidgetConfig.class);
    }

    /**
     * Validates whether any of the chat control widgets which display game messages is being
     * hovered. Currently, this yields true for the following widgets:
     * <ul>
     *     <li>CHAT_ALL</li>
     *     <li>CHAT_GAME</li>
     *     <li>CHAT_PUBLIC</li>
     * </ul>
     *
     * @return <i>true</i> if any of the aforementioned widgets are being hovered otherwise returns <i>false</i>.
     */
    boolean isHoveringGameChatControls() {
        final Point mouse = client.getMouseCanvasPosition();
        return isHoveringWidget(mouse, client.getWidget(InterfaceID.Chatbox.CHAT_ALL)) ||
                isHoveringWidget(mouse, client.getWidget(InterfaceID.Chatbox.CHAT_GAME)) ||
                isHoveringWidget(mouse, client.getWidget(InterfaceID.Chatbox.CHAT_PUBLIC));
    }

    /**
     * Helper function to determine if the target {@link Widget} passed in is being hovered.
     *
     * @param mouse  The current coordinates of the mouse within the game canvas.
     * @param target The widget
     * @return <i>true</i> if the mouse coordinates falls within the targeted widget boundary otherwise returns
     * <i>false</i>.
     */
    boolean isHoveringWidget(Point mouse, Widget target) {
        if (target == null || target.isHidden()) {
            return false;
        }

        final Point origin = target.getCanvasLocation();
        final int mouseX = mouse.getX();
        final int mouseY = mouse.getY();
        return mouseX >= origin.getX()
                && mouseX <= (origin.getX() + target.getWidth())
                && mouseY >= origin.getY()
                && mouseY <= (origin.getY() + target.getHeight());
    }
}

package com.chatwidgets;

import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

import java.awt.Color;

@ConfigGroup("chatwidgets")
public interface ChatWidgetConfig extends Config {

    @ConfigSection(name = "Game Messages", description = "Game message settings", position = 0, closedByDefault = false)
    String gameSection = "game";

    @ConfigSection(name = "Private Messages", description = "Private message settings", position = 1, closedByDefault = false)
    String privateSection = "private";

    @ConfigSection(name = "Appearance (Shared)", description = "Shared appearance settings", position = 2, closedByDefault = false)
    String appearanceSection = "appearance";

    @ConfigSection(name = "Game Messages (Adv.)", description = "Advanced game message settings", position = 3, closedByDefault = true)
    String gameAdvancedSection = "gameAdvanced";

    @ConfigSection(name = "Private Messages (Adv.)", description = "Advanced private message settings", position = 4, closedByDefault = true)
    String privateAdvancedSection = "privateAdvanced";

    // Game Messages Section
    @ConfigItem(keyName = "enableGameMessages", name = "Enable", description = "Enables the game messages widget. Only renders when the chatbox is minimized.", section = gameSection, position = 0)
    default boolean enableGameMessages() {
        return true;
    }

    @ConfigItem(keyName = "gamePosition", name = "Position", description = "Widget position. Player-relative options work best with fade and low max messages.", section = gameSection, position = 1)
    default WidgetPosition gamePosition() {
        return WidgetPosition.DEFAULT;
    }

    @ConfigItem(keyName = "gameMaxMessages", name = "Max Messages", description = "Maximum number of messages to display", section = gameSection, position = 2)
    @Range(min = 1, max = 20)
    default int gameMaxMessages() {
        return 5;
    }

    @Alpha
    @ConfigItem(keyName = "gameTextColor", name = "Text Colour", description = "Base colour for message text", section = gameSection, position = 3)
    default Color gameTextColor() {
        return Color.WHITE;
    }

    @Alpha
    @ConfigItem(keyName = "gameBackgroundColor", name = "Background", description = "Background colour of the widget", section = gameSection, position = 4)
    default Color gameBackgroundColor() {
        return new Color(0, 0, 0, 0);
    }

    // Private Messages Section
    @ConfigItem(keyName = "enablePrivateMessages", name = "Enable", description = "Enables the private messages widget and hides the client's split private chat widget", section = privateSection, position = 0)
    default boolean enablePrivateMessages() {
        return true;
    }

    @ConfigItem(keyName = "privateMaxMessages", name = "Max Messages", description = "Maximum number of messages to display", section = privateSection, position = 1)
    @Range(min = 1, max = 20)
    default int privateMaxMessages() {
        return 5;
    }

    @Alpha
    @ConfigItem(keyName = "privateTextColor", name = "Text Colour", description = "Colour for message text", section = privateSection, position = 2)
    default Color privateTextColor() {
        return new Color(0, 255, 255);
    }

    @Alpha
    @ConfigItem(keyName = "privateBackgroundColor", name = "Background", description = "Background colour of the widget (only when not merged)", section = privateSection, position = 3)
    default Color privateBackgroundColor() {
        return new Color(0, 0, 0, 0);
    }

    // Appearance Section (Shared)
    @ConfigItem(keyName = "fontSize", name = "Font Size", description = "Font size for all messages", section = appearanceSection, position = 0)
    default FontSize fontSize() {
        return FontSize.REGULAR;
    }

    @ConfigItem(keyName = "mergeWithGameWidget", name = "Merge Chat Widgets", description = "When enabled renders all chat widgets as a single widget. Disable if using fixed mode. This setting is ignored if game messages are disabled or are positioned relatively to the player.", section = appearanceSection, position = 1)
    default boolean mergeWithGameWidget() {
        return true;
    }

    @ConfigItem(keyName = "swapStackingOrder", name = "Swap Stacking Order", description = "Swap the stacking order of the chat widgets", section = appearanceSection, position = 2)
    default boolean swapStackingOrder() {
        return false;
    }

    @ConfigItem(keyName = "smartPositioning", name = "Smart Positioning", description = "Automatically reposition widgets based on client mode and chatbox state", section = appearanceSection, position = 3)
    default boolean smartPositioning() {
        return true;
    }

    @ConfigItem(keyName = "wrapText", name = "Wrap Text", description = "Wrap long messages to multiple lines", section = appearanceSection, position = 4)
    default boolean wrapText() {
        return true;
    }

    @ConfigItem(keyName = "textShadow", name = "Text Shadow", description = "Draw shadow behind text", section = appearanceSection, position = 5)
    default boolean textShadow() {
        return true;
    }

    @ConfigItem(keyName = "showTimestamp", name = "Show Timestamps", description = "Prefix messages with a timestamp", section = appearanceSection, position = 6)
    default boolean showTimestamp() {
        return false;
    }

    @ConfigItem(keyName = "timestampFormat", name = "Timestamp Format", description = "Format for timestamps (e.g. [HH:mm:ss], [HH:mm])", section = appearanceSection, position = 7)
    default String timestampFormat() {
        return "[HH:mm]";
    }

    // Game Messages Advanced Section
    @ConfigItem(keyName = "gameDynamicHeight", name = "Dynamic Height", description = "Widget height adjusts to message count", section = gameAdvancedSection, position = 0)
    default boolean gameDynamicHeight() {
        return false;
    }

    @ConfigItem(keyName = "retainContextualColours", name = "Contextual Colours", description = "Retain colour tags in game messages", section = gameAdvancedSection, position = 1)
    default boolean retainContextualColours() {
        return true;
    }

    @ConfigItem(keyName = "collapseGameChat", name = "Collapse Duplicates", description = "Collapse identical consecutive messages with a count", section = gameAdvancedSection, position = 2)
    default boolean collapseGameChat() {
        return false;
    }

    @ConfigItem(keyName = "hideDuplicateCount", name = "Hide Duplicate Count", description = "Hide the count badge when collapsing duplicates", section = gameAdvancedSection, position = 3)
    default boolean hideDuplicateCount() {
        return false;
    }

    @ConfigItem(keyName = "showGameMessagesWhenHovered", name = "Display on Tab Hover", description = "Hides game messages unless hovering over over the 'All', 'Game' or 'Public' chat tabs", section = gameAdvancedSection, position = 5)
    default boolean showGameMessageWhenHovered() {
        return false;
    }

    @ConfigItem(keyName = "gameFadeOutDuration", name = "Fade Out Duration", description = "Seconds before messages start fading (0 = never fade)", section = gameAdvancedSection, position = 6)
    @Range(min = 0, max = 300)
    default int gameFadeOutDuration() {
        return 0;
    }

    @ConfigItem(keyName = "gameWidgetWidth", name = "Widget Width", description = "Width of the widget in pixels. Overridden if the widget is manually resized.", section = gameAdvancedSection, position = 77)
    @Range(min = 150, max = 1024)
    default int gameWidgetWidth() {
        return 512;
    }

    @ConfigItem(keyName = "gameMarginTop", name = "Margin Top", description = "Extra space above the widget", section = gameAdvancedSection, position = 8)
    @Range(min = 0, max = 200)
    default int gameMarginTop() { return 0; }

    @ConfigItem(keyName = "gameMarginBottom", name = "Margin Bottom", description = "Extra space below the widget", section = gameAdvancedSection, position = 9)
    @Range(min = 0, max = 200)
    default int gameMarginBottom() {
        return 0;
    }

    // Private Messages Advanced Section
    @ConfigItem(keyName = "privateDynamicHeight", name = "Dynamic Height", description = "Widget height adjusts to message count (only when not merged)", section = privateAdvancedSection, position = 0)
    default boolean privateDynamicHeight() {
        return false;
    }

    @ConfigItem(keyName = "privateFadeOutDuration", name = "Fade Out Duration", description = "Seconds before messages start fading (0 = never fade)", section = privateAdvancedSection, position = 1)
    @Range(min = 0, max = 300)
    default int privateFadeOutDuration() {
        return 0;
    }

    @ConfigItem(keyName = "privateWidgetWidth", name = "Widget Width", description = "Width of the widget (only when not merged). Overridden if the widget is manually resized.", section = privateAdvancedSection, position = 2)
    @Range(min = 150, max = 1024)
    default int privateWidgetWidth() {
        return 512;
    }

    @ConfigItem(keyName = "privateMarginTop", name = "Margin Top", description = "Extra space above the widget (only when not merged)", section = privateAdvancedSection, position = 3)
    @Range(min = 0, max = 200)
    default int privateMarginTop() {
        return 0;
    }

    @ConfigItem(keyName = "privateMarginBottom", name = "Margin Bottom", description = "Extra space below the widget (only when not merged)", section = privateAdvancedSection, position = 4)
    @Range(min = 0, max = 200)
    default int privateMarginBottom() {
        return 0;
    }
}

package com.chatwidgets;

import java.util.List;

public class RenderLine {
    public final List<TextSegment> segments;
    public final int alpha;

    public RenderLine(List<TextSegment> segments, int alpha) {
        this.segments = segments;
        this.alpha = alpha;
    }
}

package com.chatwidgets;

import java.awt.Color;

public class TextSegment {
    public static final int LINE_BREAK = -2;

    public final String text;
    public final int iconId;
    public final int width;
    public final Color color;

    public TextSegment(String text, int iconId, int width, Color color) {
        this.text = text;
        this.iconId = iconId;
        this.width = width;
        this.color = color;
    }
}

package com.chatwidgets;

public class MessageMergeRule {
    private final String previousPrefix;
    private final String nextPattern;
    private final boolean exactMatch;

    public MessageMergeRule(String previousPrefix, String nextPattern, boolean exactMatch) {
        this.previousPrefix = previousPrefix;
        this.nextPattern = nextPattern;
        this.exactMatch = exactMatch;
    }

    public boolean matches(String previousMessage, String newMessage) {
        if (!previousMessage.startsWith(previousPrefix)) {
            return false;
        }
        return exactMatch ? newMessage.equals(nextPattern) : newMessage.startsWith(nextPattern);
    }

    public String merge(String previousMessage, String newMessage) {
        return previousMessage + " " + newMessage;
    }

    public boolean matchesPreviousPrefix(String message) {
        return message.startsWith(previousPrefix);
    }
}

package com.chatwidgets;

import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.MenuAction;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PrivateChatOverlay extends Overlay {

    private static final int MAX_MESSAGE_LENGTH = 500;

    private final ChatWidgetPlugin plugin;
    private final ChatWidgetConfig config;
    private final Client client;

    private final Map<Integer, BufferedImage> spriteCache = new HashMap<>();

    @Inject
    public PrivateChatOverlay(ChatWidgetPlugin plugin, ChatWidgetConfig config, Client client) {
        this.plugin = plugin;
        this.config = config;
        this.client = client;
        setPosition(client.isResized() ? OverlayPosition.ABOVE_CHATBOX_RIGHT : OverlayPosition.BOTTOM_LEFT);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setPriority(config.swapStackingOrder() ? 10f : 9f);
        setResizable(true);
        setMovable(true);
        setMinimumSize(150);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Clear", "Private chat history"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.shouldShowPrivateOverlay()) {
            return null;
        }

        if (config.swapStackingOrder()) {
            setPriority(10f);
        } else {
            setPriority(9f);
        }

        if (plugin.isWidgetsMerged()) {
            return null;
        }

        List<WidgetMessage> messages = plugin.getPrivateMessages();
        if (messages.isEmpty()) {
            return null;
        }

        FontSize fontSize = config.fontSize();
        FontMetrics metrics = ChatRenderUtils.setupGraphics(graphics, fontSize);

        Dimension preferredSize = getPreferredSize();
        int widgetWidth = (preferredSize != null && preferredSize.width > 0)
                ? preferredSize.width
                : config.privateWidgetWidth();
        int lineHeight = metrics.getHeight() - 2;
        long currentTime = System.currentTimeMillis();
        int fadeOutDuration = config.privateFadeOutDuration();
        long fadeOutMs = fadeOutDuration * 1000L;
        long fadeOutThreshold = fadeOutMs + 5000;
        Color textColor = config.privateTextColor();
        boolean drawShadow = config.textShadow();
        int maxMessages = config.privateMaxMessages();
        boolean wrapText = config.wrapText();
        boolean useDynamicHeight = config.privateDynamicHeight();

        int messageCount = messages.size();
        int startIndex = Math.max(0, messageCount - maxMessages);
        List<WidgetMessage> visibleMessages = new ArrayList<>(maxMessages);

        for (int i = startIndex; i < messageCount; i++) {
            WidgetMessage msg = messages.get(i);
            int msgMaxFade = msg.getMaxFadeSeconds();
            long msgFadeThreshold;
            if (msgMaxFade > 0) {
                msgFadeThreshold = msgMaxFade * 1000L + 5000;
            } else {
                msgFadeThreshold = fadeOutThreshold;
            }
            if ((fadeOutDuration == 0 && msgMaxFade == 0) || (currentTime - msg.getTimestamp()) < msgFadeThreshold) {
                visibleMessages.add(msg);
            }
        }

        if (visibleMessages.isEmpty()) {
            return null;
        }

        List<RenderLine> renderableLines = new ArrayList<>(visibleMessages.size() * 2);
        for (WidgetMessage msg : visibleMessages) {
            List<RenderLine> msgLines = ChatRenderUtils.buildPrivateMessageLines(msg, metrics, widgetWidth, currentTime, fadeOutMs,
                    wrapText, textColor, config.fontSize(), client.getModIcons(), config.showTimestamp(),
                    config.timestampFormat(), MAX_MESSAGE_LENGTH);

            boolean hasVisibleLine = false;
            for (RenderLine msgLine : msgLines) {
                if (msgLine.alpha > 0) {
                    hasVisibleLine = true;
                    break;
                }
            }
            if (hasVisibleLine) {
                renderableLines.addAll(msgLines);
            }
        }

        if (renderableLines.isEmpty()) {
            return null;
        }

        int widgetHeight;

        if (useDynamicHeight) {
            widgetHeight = renderableLines.size() * lineHeight;
        } else {
            widgetHeight = maxMessages * lineHeight;
        }

        Color bgColor = config.privateBackgroundColor();
        int bgPadding = bgColor.getAlpha() > 0 ? 3 : 0;
        int marginTop = config.privateMarginTop();
        int marginBottom = config.privateMarginBottom();

        int contentHeight = widgetHeight + bgPadding * 2;
        widgetHeight = contentHeight + marginTop + marginBottom;

        if (bgColor.getAlpha() > 0) {
            graphics.setColor(bgColor);
            graphics.fillRect(0, marginTop, widgetWidth, contentHeight);
        }

        Shape originalClip = graphics.getClip();
        graphics.setClip(0, 0, widgetWidth, widgetHeight + 4);

        int y = widgetHeight - bgPadding - marginBottom - metrics.getDescent();
        IndexedSprite[] modIcons = client.getModIcons();

        for (int i = renderableLines.size() - 1; i >= 0; i--) {
            RenderLine line = renderableLines.get(i);
            if (line.alpha <= 0) {
                continue;
            }

            int x = bgPadding;

            for (TextSegment segment : line.segments) {
                if (segment.iconId >= 0 && modIcons != null && segment.iconId < modIcons.length) {
                    BufferedImage img = ChatRenderUtils.getCachedSprite(modIcons, segment.iconId, spriteCache);
                    x += ChatRenderUtils.drawIcon(graphics, img, fontSize, metrics, x, y);
                } else {
                    x += ChatRenderUtils.drawText(graphics, segment.text, textColor, line.alpha, x, y,
                            drawShadow, metrics);
                }
            }
            y -= lineHeight;
        }

        graphics.setClip(originalClip);
        return new Dimension(widgetWidth, widgetHeight);
    }
}

package com.chatwidgets;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.IndexedSprite;
import net.runelite.api.MenuAction;
import net.runelite.api.Point;
import net.runelite.api.Player;
import net.runelite.client.config.ChatColorConfig;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Shape;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GameChatOverlay extends Overlay {

    private static final Pattern IMG_TAG_PATTERN = Pattern.compile("<img=(\\d+)>");
    private static final Pattern COL_TAG_PATTERN = Pattern.compile("<col=([0-9a-fA-F]{6})>");
    private static final Pattern COL_NAMED_PATTERN = Pattern.compile("<col(NORMAL|HIGHLIGHT)>");
    private static final Pattern COL_UNKNOWN_PATTERN = Pattern.compile("<col[^>]*>");
    private static final Pattern COL_END_PATTERN = Pattern.compile("</col>");
    private static final Pattern BR_TAG_PATTERN = Pattern.compile("<br>");
    private static final int MAX_MESSAGE_LENGTH = 500;

    private static final int MIN_ZOOM = -22;
    private static final int MAX_ZOOM = 1400;
    private static final int BELOW_OFFSET_MIN_ZOOM = 40;
    private static final int BELOW_OFFSET_MAX_ZOOM = 150;
    private static final int ABOVE_OFFSET_MIN_ZOOM = -40;
    private static final int ABOVE_OFFSET_MAX_ZOOM = -120;

    private final ChatWidgetPlugin plugin;
    private final ChatWidgetConfig config;
    private final Client client;
    private final ChatColorConfig chatColorConfig;

    private final Map<Integer, BufferedImage> spriteCache = new HashMap<>();

    @Inject
    public GameChatOverlay(ChatWidgetPlugin plugin, ChatWidgetConfig config, Client client,
            ChatColorConfig chatColorConfig) {
        this.plugin = plugin;
        this.config = config;
        this.client = client;
        this.chatColorConfig = chatColorConfig;
        setPosition(client.isResized() ? OverlayPosition.ABOVE_CHATBOX_RIGHT : OverlayPosition.BOTTOM_LEFT);
        setLayer(OverlayLayer.UNDER_WIDGETS);
        setPriority(config.swapStackingOrder() ? 9f : 10f);
        setResizable(true);
        setMovable(true);
        setMinimumSize(150);
        getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Clear", "Game chat history"));
    }

    private boolean lastMergedState = false;

    @Override
    public Dimension render(Graphics2D graphics) {
        if (!plugin.shouldShowGameOverlay()) {
            return null;
        }

        if (config.showGameMessageWhenHovered() && !plugin.isHoveringGameChatControls()) {
            return null;
        }

        if (config.swapStackingOrder()) {
            setPriority(9f);
        } else {
            setPriority(10f);
        }

        boolean isMerged = plugin.isWidgetsMerged();
        if (isMerged != lastMergedState) {
            lastMergedState = isMerged;
            getMenuEntries().clear();
            if (isMerged) {
                getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Clear", "Merged chat history"));
            } else {
                getMenuEntries().add(new OverlayMenuEntry(MenuAction.RUNELITE_OVERLAY, "Clear", "Game chat history"));
            }
        }

        List<WidgetMessage> gameMessages = plugin.getGameMessages();
        WidgetPosition positionMode = config.gamePosition();
        boolean followPlayer = positionMode != WidgetPosition.DEFAULT;
        List<WidgetMessage> privateMessages = isMerged ? plugin.getPrivateMessages() : new ArrayList<>();

        if (gameMessages.isEmpty() && privateMessages.isEmpty()) {
            return null;
        }

        FontSize fontSize = config.fontSize();
        FontMetrics metrics = ChatRenderUtils.setupGraphics(graphics, fontSize);

        Dimension preferredSize = getPreferredSize();
        int widgetWidth = (preferredSize != null && preferredSize.width > 0)
                ? preferredSize.width
                : config.gameWidgetWidth();
        int lineHeight = metrics.getHeight() - (fontSize == FontSize.SMALL ? 2 : 3) + 1;
        long currentTime = System.currentTimeMillis();
        boolean retainContextualColours = config.retainContextualColours();
        Color gameTextColor = config.gameTextColor();
        Color privateTextColor = config.privateTextColor();
        boolean drawShadow = config.textShadow();
        boolean wrapText = config.wrapText();
        boolean useDynamicHeight = followPlayer || config.gameDynamicHeight();

        List<RenderLine> renderableLines = new ArrayList<>();
        boolean swapOrder = config.swapStackingOrder();

        if (swapOrder) {
            addGameMessages(renderableLines, gameMessages, metrics, widgetWidth, currentTime, wrapText,
                    retainContextualColours, gameTextColor);
            if (isMerged) {
                addPrivateMessages(renderableLines, privateMessages, metrics, widgetWidth, currentTime, wrapText,
                        privateTextColor);
            }
        } else {
            if (isMerged) {
                addPrivateMessages(renderableLines, privateMessages, metrics, widgetWidth, currentTime, wrapText,
                        privateTextColor);
            }
            addGameMessages(renderableLines, gameMessages, metrics, widgetWidth, currentTime, wrapText,
                    retainContextualColours, gameTextColor);
        }

        if (renderableLines.isEmpty()) {
            return null;
        }

        int totalMaxMessages = config.gameMaxMessages() + (isMerged ? config.privateMaxMessages() : 0);
        int widgetHeight;

        if (useDynamicHeight) {
            widgetHeight = renderableLines.size() * lineHeight;
        } else {
            widgetHeight = totalMaxMessages * lineHeight;
        }

        boolean isPositionDefault = positionMode == WidgetPosition.DEFAULT;
        Color bgColor = config.gameBackgroundColor();
        int bgPadding = (bgColor.getAlpha() > 0 && isPositionDefault) ? 3 : 0;
        int marginTop = config.gameMarginTop();
        int marginBottom = config.gameMarginBottom();

        int contentHeight = widgetHeight + bgPadding * 2;
        widgetHeight = contentHeight + marginTop + marginBottom;

        if (followPlayer) {
            Player localPlayer = client.getLocalPlayer();
            if (localPlayer != null) {
                Point playerPoint;
                if (positionMode == WidgetPosition.BELOW_PLAYER) {
                    playerPoint = localPlayer.getCanvasTextLocation(graphics, "", 0);
                } else {
                    playerPoint = localPlayer.getCanvasTextLocation(graphics, "", localPlayer.getLogicalHeight());
                }
                if (playerPoint != null) {
                    int zoomOffset = calculateZoomOffset(positionMode);
                    int x = playerPoint.getX() - widgetWidth / 2;
                    int y = playerPoint.getY() + zoomOffset - widgetHeight / 2;
                    graphics.translate(x - getBounds().x, y - getBounds().y);
                }
            }
        }

        if (bgColor.getAlpha() > 0 && isPositionDefault) {
            graphics.setColor(bgColor);
            graphics.fillRect(0, marginTop, widgetWidth, contentHeight);
        }

        Shape originalClip = graphics.getClip();
        graphics.setClip(0, 0, widgetWidth, widgetHeight + 4);

        int y = widgetHeight - bgPadding - marginBottom - metrics.getDescent();
        IndexedSprite[] modIcons = client.getModIcons();

        for (int i = renderableLines.size() - 1; i >= 0; i--) {
            RenderLine line = renderableLines.get(i);
            if (line.alpha <= 0) {
                continue;
            }

            int lineWidth = calculateLineWidth(line.segments, metrics);
            int x = followPlayer ? bgPadding + (widgetWidth - bgPadding * 2 - lineWidth) / 2 : bgPadding;

            for (TextSegment segment : line.segments) {
                if (segment.iconId >= 0 && modIcons != null && segment.iconId < modIcons.length) {
                    BufferedImage img = ChatRenderUtils.getCachedSprite(modIcons, segment.iconId, spriteCache);
                    x += ChatRenderUtils.drawIcon(graphics, img, fontSize, metrics, x, y);
                } else {
                    Color segmentColor = segment.color != null ? segment.color : gameTextColor;
                    x += ChatRenderUtils.drawText(graphics, segment.text, segmentColor, line.alpha, x, y,
                            drawShadow, metrics);
                }
            }
            y -= lineHeight;
        }

        graphics.setClip(originalClip);

        if (followPlayer) {
            return null;
        }
        return new Dimension(widgetWidth, widgetHeight);
    }

    private int calculateZoomOffset(WidgetPosition positionMode) {
        int zoom = client.get3dZoom();
        double normalizedZoom = (double) (zoom - MIN_ZOOM) / (MAX_ZOOM - MIN_ZOOM);
        normalizedZoom = Math.max(0, Math.min(1, normalizedZoom));

        int minOffset, maxOffset;
        if (positionMode == WidgetPosition.BELOW_PLAYER) {
            minOffset = BELOW_OFFSET_MIN_ZOOM;
            maxOffset = BELOW_OFFSET_MAX_ZOOM;
        } else {
            minOffset = ABOVE_OFFSET_MIN_ZOOM;
            maxOffset = ABOVE_OFFSET_MAX_ZOOM;
        }

        return (int) (minOffset + normalizedZoom * (maxOffset - minOffset));
    }

    private int calculateLineWidth(List<TextSegment> segments, FontMetrics metrics) {
        int width = 0;
        for (TextSegment segment : segments) {
            if (segment.iconId >= 0) {
                width += segment.width;
            } else {
                width += metrics.stringWidth(segment.text);
            }
        }
        return width;
    }

    private Color getMessageTypeColor(ChatMessageType type, Color defaultColor) {
        switch (type) {
            case DIDYOUKNOW:
                return new Color(125, 255, 100);
            case BROADCAST:
                return new Color(255, 255, 0);
            case TRADEREQ:
                return new Color(126, 0, 128);
            default:
                return defaultColor;
        }
    }

    private int buildTimestampHeader(List<TextSegment> headerSegments, WidgetMessage msg,
            FontMetrics metrics, Color textColor) {
        if (!config.showTimestamp()) {
            return 0;
        }
        String format = config.timestampFormat();
        if (format == null || format.isEmpty()) {
            return 0;
        }
        String ts = ChatRenderUtils.formatTimestamp(msg.getTimestamp(), format + " ");
        if (ts == null) {
            return 0;
        }
        int width = metrics.stringWidth(ts);
        headerSegments.add(new TextSegment(ts, -1, width, textColor));
        return width;
    }

    private List<RenderLine> buildGameRenderLines(WidgetMessage msg, FontMetrics metrics, int widgetWidth,
            long currentTime, long fadeOutMs, boolean wrapText, boolean retainContextualColours, Color textColor) {
        List<RenderLine> lines = new ArrayList<>();
        int alpha = ChatRenderUtils.calculateAlpha(msg, currentTime, fadeOutMs);

        Color effectiveTextColor = retainContextualColours
                ? getMessageTypeColor(msg.getType(), textColor)
                : textColor;

        List<TextSegment> headerSegments = new ArrayList<>();
        int headerWidth = buildTimestampHeader(headerSegments, msg, metrics, textColor);

        String messageText = msg.getMessage();
        if (messageText != null && messageText.length() > MAX_MESSAGE_LENGTH) {
            messageText = messageText.substring(0, MAX_MESSAGE_LENGTH) + "...";
        }

        if (msg.getCount() > 1 && !config.hideDuplicateCount()) {
            messageText = messageText + " (" + msg.getCount() + ")";
        }

        List<TextSegment> messageSegments = parseTextWithColoursAndIcons(messageText, metrics,
                client.getModIcons(), retainContextualColours, effectiveTextColor);

        if (!wrapText) {
            List<TextSegment> singleLine = new ArrayList<>(headerSegments);
            singleLine.addAll(messageSegments);
            lines.add(new RenderLine(singleLine, alpha));
        } else {
            int firstLineRemaining = widgetWidth - headerWidth;
            List<List<TextSegment>> wrappedLines = ChatRenderUtils.wrapSegments(messageSegments, metrics,
                    firstLineRemaining,
                    widgetWidth, textColor);

            ChatRenderUtils.addWrappedLines(lines, alpha, headerSegments, wrappedLines);
        }

        return lines;
    }

    private void addGameMessages(List<RenderLine> renderableLines, List<WidgetMessage> gameMessages,
            FontMetrics metrics, int widgetWidth, long currentTime, boolean wrapText,
            boolean retainContextualColours, Color gameTextColor) {
        if (gameMessages.isEmpty()) {
            return;
        }

        int gameFadeOutDuration = config.gameFadeOutDuration();
        long gameFadeOutMs = gameFadeOutDuration * 1000L;
        long gameFadeOutThreshold = gameFadeOutMs + 5000;
        int gameMaxMessages = config.gameMaxMessages();

        int gameMessageCount = gameMessages.size();
        int gameStartIndex = Math.max(0, gameMessageCount - gameMaxMessages);

        for (int i = gameStartIndex; i < gameMessageCount; i++) {
            WidgetMessage msg = gameMessages.get(i);
            if (gameFadeOutDuration == 0 || (currentTime - msg.getTimestamp()) < gameFadeOutThreshold) {
                List<RenderLine> msgLines = buildGameRenderLines(msg, metrics, widgetWidth, currentTime,
                        gameFadeOutMs, wrapText, retainContextualColours, gameTextColor);

                for (RenderLine msgLine : msgLines) {
                    if (msgLine.alpha > 0) {
                        renderableLines.add(msgLine);
                    }
                }
            }
        }
    }

    private void addPrivateMessages(List<RenderLine> renderableLines, List<WidgetMessage> privateMessages,
            FontMetrics metrics, int widgetWidth, long currentTime, boolean wrapText, Color privateTextColor) {
        if (privateMessages.isEmpty()) {
            return;
        }

        int privateFadeOutDuration = config.privateFadeOutDuration();
        long privateFadeOutMs = privateFadeOutDuration * 1000L;
        long privateFadeOutThreshold = privateFadeOutMs + 5000;
        int privateMaxMessages = config.privateMaxMessages();

        int privateMessageCount = privateMessages.size();
        int privateStartIndex = Math.max(0, privateMessageCount - privateMaxMessages);

        for (int i = privateStartIndex; i < privateMessageCount; i++) {
            WidgetMessage msg = privateMessages.get(i);
            if (privateFadeOutDuration == 0 || (currentTime - msg.getTimestamp()) < privateFadeOutThreshold) {
                List<RenderLine> msgLines = ChatRenderUtils.buildPrivateMessageLines(msg, metrics, widgetWidth,
                        currentTime, privateFadeOutMs,
                        wrapText, privateTextColor, config.fontSize(), client.getModIcons(), config.showTimestamp(),
                        config.timestampFormat(), MAX_MESSAGE_LENGTH);

                for (RenderLine msgLine : msgLines) {
                    if (msgLine.alpha > 0) {
                        renderableLines.add(msgLine);
                    }
                }
            }
        }
    }

    private List<TextSegment> parseTextWithColoursAndIcons(String text, FontMetrics metrics,
            IndexedSprite[] modIcons, boolean retainContextualColours, Color textColor) {
        List<TextSegment> segments = new ArrayList<>();
        if (text == null || text.isEmpty()) {
            return segments;
        }

        Color currentColor = textColor;
        StringBuilder currentText = new StringBuilder();
        int i = 0;

        while (i < text.length()) {
            Matcher imgMatcher = IMG_TAG_PATTERN.matcher(text.substring(i));
            Matcher colMatcher = COL_TAG_PATTERN.matcher(text.substring(i));
            Matcher colNamedMatcher = COL_NAMED_PATTERN.matcher(text.substring(i));
            Matcher colEndMatcher = COL_END_PATTERN.matcher(text.substring(i));
            Matcher brMatcher = BR_TAG_PATTERN.matcher(text.substring(i));

            if (brMatcher.lookingAt()) {
                if (currentText.length() > 0) {
                    String str = currentText.toString();
                    segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
                    currentText = new StringBuilder();
                }
                segments.add(new TextSegment("", TextSegment.LINE_BREAK, 0, currentColor));
                i += brMatcher.end();
            } else if (imgMatcher.lookingAt()) {
                if (currentText.length() > 0) {
                    String str = currentText.toString();
                    segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
                    currentText = new StringBuilder();
                }
                try {
                    int iconId = Integer.parseInt(imgMatcher.group(1));
                    int iconWidth = ChatRenderUtils.calculateIconWidth(modIcons, iconId, config.fontSize());
                    segments.add(new TextSegment("", iconId, iconWidth, currentColor));
                } catch (NumberFormatException e) {
                    currentText.append(imgMatcher.group(0));
                }
                i += imgMatcher.end();
            } else if (colNamedMatcher.lookingAt()) {
                if (currentText.length() > 0) {
                    String str = currentText.toString();
                    segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
                    currentText = new StringBuilder();
                }
                String colorName = colNamedMatcher.group(1);
                if ("NORMAL".equals(colorName)) {
                    currentColor = textColor;
                } else if ("HIGHLIGHT".equals(colorName)) {
                    Color highlight = chatColorConfig.transparentExamineHighlight();
                    currentColor = highlight != null ? highlight : textColor;
                }
                i += colNamedMatcher.end();
            } else if (colMatcher.lookingAt() && retainContextualColours) {
                if (currentText.length() > 0) {
                    String str = currentText.toString();
                    segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
                    currentText = new StringBuilder();
                }
                try {
                    currentColor = Color.decode("#" + colMatcher.group(1));
                } catch (NumberFormatException e) {
                    currentColor = textColor;
                }
                i += colMatcher.end();
            } else if (colEndMatcher.lookingAt() && retainContextualColours) {
                if (currentText.length() > 0) {
                    String str = currentText.toString();
                    segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
                    currentText = new StringBuilder();
                }
                currentColor = textColor;
                i += colEndMatcher.end();
            } else if (colMatcher.lookingAt() && !retainContextualColours) {
                i += colMatcher.end();
            } else if (colEndMatcher.lookingAt() && !retainContextualColours) {
                i += colEndMatcher.end();
            } else {
                Matcher colUnknownMatcher = COL_UNKNOWN_PATTERN.matcher(text.substring(i));
                if (colUnknownMatcher.lookingAt()) {
                    i += colUnknownMatcher.end();
                } else {
                    currentText.append(text.charAt(i));
                    i++;
                }
            }
        }

        if (currentText.length() > 0) {
            String str = currentText.toString();
            segments.add(new TextSegment(str, -1, metrics.stringWidth(str), currentColor));
        }

        return segments;
    }
}

package com.chatwidgets;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ChatWidgetPluginTest {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ChatWidgetPlugin.class);
        RuneLite.main(args);
    }
}

