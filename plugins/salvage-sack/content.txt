package com.salvagesack;

import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Handles persistence of salvage tracking data between sessions
 */
@Slf4j
public class SalvageDataManager
{
	private static final String DATA_FILE = "salvage-data.json";
	private final Gson gson;
	private final File dataFile;

	public SalvageDataManager(File dataDirectory, Gson gson)
	{
		this.gson = gson;
		this.dataFile = new File(dataDirectory, DATA_FILE);
	}

	/**
	 * Save salvage data to disk
	 */
	public void saveData(Map<ShipwreckType, SalvageData> dataMap)
	{
		try (FileWriter writer = new FileWriter(dataFile))
		{
			SaveDataWrapper wrapper = new SaveDataWrapper();
			wrapper.shipwrecks = new HashMap<>();

			for (Map.Entry<ShipwreckType, SalvageData> entry : dataMap.entrySet())
			{
				wrapper.shipwrecks.put(entry.getKey().name(), SalvageDataDto.fromSalvageData(entry.getValue()));
			}
			
			gson.toJson(wrapper, writer);
			log.debug("Saved salvage data to {}", dataFile.getAbsolutePath());
		}
		catch (IOException e)
		{
			log.error("Failed to save salvage data", e);
		}
	}

	/**
	 * Load salvage data from disk
	 */
	public Map<ShipwreckType, SalvageData> loadData()
	{
		Map<ShipwreckType, SalvageData> dataMap = new HashMap<>();
		
		if (!dataFile.exists())
		{
			log.debug("No saved data file found, starting fresh");
			return dataMap;
		}

		try (FileReader reader = new FileReader(dataFile))
		{
			SaveDataWrapper wrapper = gson.fromJson(reader, SaveDataWrapper.class);

			if (wrapper != null && wrapper.shipwrecks != null)
			{
				for (Map.Entry<String, SalvageDataDto> entry : wrapper.shipwrecks.entrySet())
				{
					try
					{
						ShipwreckType type = ShipwreckType.valueOf(entry.getKey());
						SalvageData data = entry.getValue().toSalvageData(type);
						dataMap.put(type, data);
					}
					catch (IllegalArgumentException e)
					{
						log.warn("Unknown shipwreck type: {}", entry.getKey());
					}
				}
			}
			
			log.debug("Loaded salvage data from {}", dataFile.getAbsolutePath());
		}
		catch (IOException e)
		{
			log.error("Failed to load salvage data", e);
		}

		return dataMap;
	}

	/**
	 * Wrapper class for the root JSON object
	 */
	private static class SaveDataWrapper
	{
		Map<String, SalvageDataDto> shipwrecks;
	}

	/**
	 * Data Transfer Object for serialization
	 */
	private static class SalvageDataDto
	{
		int totalLoots;
		Map<String, SalvageItemDto> items;

		static SalvageDataDto fromSalvageData(SalvageData data)
		{
			SalvageDataDto dto = new SalvageDataDto();
			dto.totalLoots = data.getTotalLoots();
			dto.items = new HashMap<>();
			
			for (Map.Entry<Integer, SalvageItem> entry : data.getItems().entrySet())
			{
				dto.items.put(String.valueOf(entry.getKey()), SalvageItemDto.fromSalvageItem(entry.getValue()));
			}
			
			return dto;
		}

		SalvageData toSalvageData(ShipwreckType type)
		{
			Map<Integer, SalvageItem> itemsMap = new ConcurrentHashMap<>();
			
			if (items != null)
			{
				for (Map.Entry<String, SalvageItemDto> entry : items.entrySet())
				{
					try
					{
						int itemId = Integer.parseInt(entry.getKey());
						SalvageItem item = entry.getValue().toSalvageItem(itemId);
						itemsMap.put(itemId, item);
					}
					catch (NumberFormatException e)
					{
						log.warn("Invalid item ID format: {}", entry.getKey());
					}
				}
			}
			
			return new SalvageData(type, totalLoots, itemsMap);
		}
	}

	/**
	 * Data Transfer Object for SalvageItem
	 */
	private static class SalvageItemDto
	{
		String itemName;
		int dropCount;
		int totalQuantity;
		double expectedDropRate;

		static SalvageItemDto fromSalvageItem(SalvageItem item)
		{
			SalvageItemDto dto = new SalvageItemDto();
			dto.itemName = item.getItemName();
			dto.dropCount = item.getDropCount();
			dto.totalQuantity = item.getTotalQuantity();
			dto.expectedDropRate = item.getExpectedDropRate();
			return dto;
		}

		SalvageItem toSalvageItem(int itemId)
		{
			int qty = totalQuantity > 0 ? totalQuantity : dropCount;
			return new SalvageItem(itemId, itemName, dropCount, qty, expectedDropRate);
		}
	}
}

package com.salvagesack;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Panel that displays salvage tracking information
 * <p>
 * The panel includes sorting controls that allow users to organize items
 * by different criteria including alphabetical order, current drop rate,
 * expected drop rate, quantity, and luck (based on rate comparison).
 * Sort direction can be toggled between ascending and descending.
 * </p>
 * <p>
 * Luck sorting orders items by comparing current drop rate to expected rate:
 * <ul>
 *   <li>Green (lucky) - receiving items more often than expected (ratio ≥ 1.1)</li>
 *   <li>Yellow (neutral) - receiving items at expected rate (0.9 ≤ ratio < 1.1)</li>
 *   <li>Red (unlucky) - receiving items less often than expected (ratio < 0.9)</li>
 *   <li>Unknown - no expected rate data available</li>
 * </ul>
 * Descending order shows: Green → Yellow → Red → Unknown<br>
 * Ascending order shows: Red → Yellow → Green → Unknown
 * </p>
 */
@Slf4j
public class SalvageSackPanel extends PluginPanel
{
	private static final String CONFIG_GROUP = "salvagesack";
	private static final Color LUCK_GOOD = new Color(0, 200, 83);      // Green - lucky
	private static final Color LUCK_NEUTRAL = new Color(255, 214, 0); // Yellow - expected
	private static final Color LUCK_BAD = new Color(255, 68, 68);     // Red - unlucky
	private static final String ARROW_RIGHT = "▶";
	private static final String ARROW_DOWN = "▼";

	private final JPanel contentPanel;
	private final ItemIconManager iconManager;
	private final Map<ShipwreckType, Boolean> expandedState = new HashMap<>();
	private final JLabel totalOpensLabel;
	private Map<ShipwreckType, SalvageData> salvageDataMap;
	private SortOption currentSortOption;
	private boolean currentSortDescending;

	@lombok.Setter
	private DropRateManager dropRateManager;

	@lombok.Setter
	private Consumer<ShipwreckType> onResetShipwreck;

	@lombok.Setter
	private Runnable onResetAll;

	@lombok.Setter
	private ConfigManager configManager;

	public SalvageSackPanel(ItemIconManager iconManager, SalvageSackConfig config)
	{
		super(false);
		this.iconManager = iconManager;
		this.currentSortOption = config.sortOption();
		this.currentSortDescending = config.sortDescending();
		setBackground(ColorScheme.DARK_GRAY_COLOR);
		setLayout(new BorderLayout());

		JPanel titlePanel = new JPanel(new BorderLayout());
		titlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		titlePanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		// Main content panel that fills the space
		JPanel infoPanel = new JPanel(new GridBagLayout());
		infoPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.fill = GridBagConstraints.HORIZONTAL;
		gbc.weightx = 1.0;
		gbc.anchor = GridBagConstraints.CENTER;

		// Total salvage label - full width
		totalOpensLabel = new JLabel("0 Total Salvage Sorted", SwingConstants.CENTER);
		totalOpensLabel.setForeground(Color.WHITE);
		totalOpensLabel.setFont(new Font("Arial", Font.BOLD, 12));

		gbc.gridx = 0;
		gbc.gridy = 0;
		gbc.gridwidth = 2;
		gbc.insets = new Insets(0, 0, 8, 0);
		infoPanel.add(totalOpensLabel, gbc);
		
		// Sort dropdown - expands to fill available space
		JComboBox<SortOption> sortComboBox = new JComboBox<>(SortOption.values());
		sortComboBox.setSelectedItem(currentSortOption);
		sortComboBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		sortComboBox.setForeground(Color.WHITE);
		sortComboBox.setFont(new Font("Arial", Font.PLAIN, 11));
		sortComboBox.setFocusable(false);
		sortComboBox.setBorder(new CompoundBorder(
			new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1),
			new EmptyBorder(4, 8, 4, 8)
		));
		sortComboBox.addActionListener(e -> {
			SortOption selected = (SortOption) sortComboBox.getSelectedItem();
			if (selected != null)
			{
				currentSortOption = selected;
				if (configManager != null)
				{
					configManager.setConfiguration(CONFIG_GROUP, "sortOption", selected);
				}
				rebuild();
			}
		});
		
		gbc.gridx = 0;
		gbc.gridy = 1;
		gbc.gridwidth = 1;
		gbc.weightx = 1.0;
		gbc.insets = new Insets(0, 0, 0, 4);
		infoPanel.add(sortComboBox, gbc);
		
		// Sort direction button - fixed width
		JButton sortDirectionButton = new JButton(currentSortDescending ? "↓" : "↑");
		sortDirectionButton.setFont(new Font("Arial", Font.BOLD, 16));
		sortDirectionButton.setPreferredSize(new Dimension(40, 32));
		sortDirectionButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		sortDirectionButton.setForeground(Color.WHITE);
		sortDirectionButton.setFocusable(false);
		sortDirectionButton.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		sortDirectionButton.setToolTipText(currentSortDescending ? "Descending" : "Ascending");
		sortDirectionButton.addActionListener(e -> {
			currentSortDescending = !currentSortDescending;
			sortDirectionButton.setText(currentSortDescending ? "↓" : "↑");
			sortDirectionButton.setToolTipText(currentSortDescending ? "Descending" : "Ascending");
			if (configManager != null)
			{
				configManager.setConfiguration(CONFIG_GROUP, "sortDescending", currentSortDescending);
			}
			rebuild();
		});
		// Add hover effect
		sortDirectionButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent e) {
				sortDirectionButton.setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
			}
			
			@Override
			public void mouseExited(MouseEvent e) {
				sortDirectionButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});
		
		gbc.gridx = 1;
		gbc.gridy = 1;
		gbc.weightx = 0.0;
		gbc.insets = new Insets(0, 0, 0, 0);
		infoPanel.add(sortDirectionButton, gbc);
		
		titlePanel.add(infoPanel, BorderLayout.CENTER);

		add(titlePanel, BorderLayout.NORTH);

		contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentPanel.setBorder(new EmptyBorder(5, 5, 5, 5));

		JScrollPane scrollPane = new JScrollPane(contentPanel);
		scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);
		scrollPane.setBorder(null);
		scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);

		add(scrollPane, BorderLayout.CENTER);

		rebuild();
	}


	public void updateData(Map<ShipwreckType, SalvageData> dataMap)
	{
		this.salvageDataMap = dataMap;

		// Initialize expanded state for new shipwreck types (expanded if has data)
		if (dataMap != null)
		{
			for (ShipwreckType type : dataMap.keySet())
			{
				if (!expandedState.containsKey(type))
				{
					SalvageData data = dataMap.get(type);
					expandedState.put(type, data != null && data.getTotalLoots() > 0);
				}
			}
		}

		rebuild();
	}

	private void rebuild()
	{
		SwingUtilities.invokeLater(() -> {
			contentPanel.removeAll();

			// Calculate total opens across all shipwreck types
			int totalOpens = 0;
			if (salvageDataMap != null)
			{
				for (SalvageData data : salvageDataMap.values())
				{
					totalOpens += data.getTotalLoots();
				}
			}
			totalOpensLabel.setText(totalOpens + " Total Salvage Sorted");

			if (salvageDataMap == null || salvageDataMap.isEmpty())
			{
				JLabel emptyLabel = new JLabel("No salvage data yet");
				emptyLabel.setForeground(Color.GRAY);
				emptyLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
				emptyLabel.setBorder(new EmptyBorder(10, 5, 10, 5));
				contentPanel.add(emptyLabel);
			}
			else
			{
				// Collect all shipwrecks with data and sort by lastUpdated (most recent first)
				List<SalvageData> shipwrecksWithData = new ArrayList<>();
				for (ShipwreckType type : ShipwreckType.values())
				{
					SalvageData data = salvageDataMap.get(type);
					if (data != null && data.getTotalLoots() > 0)
					{
						shipwrecksWithData.add(data);
					}
				}

				// Sort by lastUpdated descending (most recently updated first)
				shipwrecksWithData.sort(Comparator.comparingLong(SalvageData::getLastUpdated).reversed());

				for (SalvageData data : shipwrecksWithData)
				{
					contentPanel.add(createShipwreckPanel(data));
					contentPanel.add(Box.createVerticalStrut(4));
				}
			}


			contentPanel.revalidate();
			contentPanel.repaint();
		});
	}

	private JPanel createShipwreckPanel(SalvageData data)
	{
		ShipwreckType type = data.getShipwreckType();
		boolean isExpanded = expandedState.getOrDefault(type, data.getTotalLoots() > 0);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
		panel.setAlignmentX(Component.LEFT_ALIGNMENT);

		// Header with arrow
		JPanel headerPanel = new JPanel(new BorderLayout(6, 0));
		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setBorder(new EmptyBorder(4, 6, 4, 6));
		headerPanel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
		headerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 28));

		JLabel arrowLabel = new JLabel(isExpanded ? ARROW_DOWN : ARROW_RIGHT);
		arrowLabel.setForeground(Color.LIGHT_GRAY);
		arrowLabel.setFont(new Font("Arial", Font.PLAIN, 10));

		JLabel typeLabel = new JLabel(data.getShipwreckType().getDisplayName());
		typeLabel.setForeground(Color.WHITE);
		typeLabel.setFont(new Font("Arial", Font.BOLD, 12));

		JLabel totalLabel = new JLabel("Sorts: " + data.getTotalLoots());
		totalLabel.setForeground(Color.LIGHT_GRAY);
		totalLabel.setFont(new Font("Arial", Font.PLAIN, 11));

		JPanel leftHeader = new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 0));
		leftHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		leftHeader.add(arrowLabel);
		leftHeader.add(typeLabel);

		headerPanel.add(leftHeader, BorderLayout.WEST);
		headerPanel.add(totalLabel, BorderLayout.EAST);

		// Items panel
		JPanel itemsPanel = new JPanel();
		itemsPanel.setLayout(new BoxLayout(itemsPanel, BoxLayout.Y_AXIS));
		itemsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		itemsPanel.setBorder(new EmptyBorder(2, 4, 4, 4));
		itemsPanel.setVisible(isExpanded);

		// Sort items based on config
		List<SalvageItem> sortedItems = getSortedItems(data);
		for (SalvageItem item : sortedItems)
		{
			itemsPanel.add(createItemPanel(item, data.getTotalLoots(), data.getShipwreckType()));
			itemsPanel.add(Box.createVerticalStrut(2));
		}

		// Click handler for accordion
		headerPanel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (SwingUtilities.isLeftMouseButton(e))
				{
					boolean newState = !expandedState.getOrDefault(type, true);
					expandedState.put(type, newState);
					arrowLabel.setText(newState ? ARROW_DOWN : ARROW_RIGHT);
					itemsPanel.setVisible(newState);

					// Revalidate the entire content panel to recalculate sizes
					contentPanel.revalidate();
					contentPanel.repaint();
				}
			}

			@Override
			public void mousePressed(MouseEvent e)
			{
				if (SwingUtilities.isRightMouseButton(e))
				{
					showContextMenu(e, type);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
				leftHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				leftHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		panel.add(headerPanel);
		panel.add(itemsPanel);

		return panel;
	}

	private JPanel createItemPanel(SalvageItem item, int totalLoots, ShipwreckType shipwreckType)
	{
		// Look up expected rate from DropRateManager (dynamically, not from stored value)
		double expectedRate = 0.0;
		if (dropRateManager != null)
		{
			expectedRate = dropRateManager.getExpectedDropRate(shipwreckType, item.getItemName());
		}

		JPanel panel = new JPanel(new BorderLayout(6, 0));
		panel.setBackground(new Color(40, 40, 40));
		panel.setBorder(new CompoundBorder(
			new LineBorder(new Color(60, 60, 60), 1),
			new EmptyBorder(4, 6, 4, 6)
		));
		// Height depends on whether we have expected rate (3 lines) or not (2 lines)
		int panelHeight = expectedRate > 0 ? 54 : 44;
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, panelHeight));
		panel.setPreferredSize(new Dimension(0, panelHeight));

		// Left: Icon - give it proper size for 32x32 icons
		BufferedImage icon = iconManager.getItemIcon(item.getItemId());
		JLabel iconLabel = new JLabel();
		if (icon != null)
		{
			iconLabel.setIcon(new ImageIcon(icon));
		}
		iconLabel.setPreferredSize(new Dimension(32, 32));
		iconLabel.setMinimumSize(new Dimension(32, 32));

		// Center: Name and rates
		JPanel infoPanel = new JPanel();
		infoPanel.setLayout(new BoxLayout(infoPanel, BoxLayout.Y_AXIS));
		infoPanel.setBackground(new Color(40, 40, 40));

		JLabel nameLabel = new JLabel(item.getItemName());
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(new Font("Arial", Font.PLAIN, 11));
		nameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

		// Calculate luck color
		double currentRate = item.getCurrentDropRate(totalLoots);
		Color luckColor = getLuckColor(currentRate, expectedRate);

		// Current rate with label
		double currentPct = currentRate * 100;
		JLabel currentLabel = new JLabel(String.format("Current: %.2f%%", currentPct));
		currentLabel.setForeground(luckColor);
		currentLabel.setFont(new Font("Arial", Font.BOLD, 9));
		currentLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

		infoPanel.add(nameLabel);
		infoPanel.add(currentLabel);

		// Expected rate with label (only if we have data)
		if (expectedRate > 0)
		{
			double expectedPct = expectedRate * 100;
			JLabel expectedLabel = new JLabel(String.format("Expected: %.2f%%", expectedPct));
			expectedLabel.setForeground(Color.LIGHT_GRAY);
			expectedLabel.setFont(new Font("Arial", Font.PLAIN, 9));
			expectedLabel.setAlignmentX(Component.LEFT_ALIGNMENT);
			infoPanel.add(expectedLabel);
		}

		// Right: Count (show total quantity received)
		JLabel countLabel = new JLabel("x" + item.getTotalQuantity());
		countLabel.setForeground(Color.WHITE);
		countLabel.setFont(new Font("Arial", Font.BOLD, 11));

		panel.add(iconLabel, BorderLayout.WEST);
		panel.add(infoPanel, BorderLayout.CENTER);
		panel.add(countLabel, BorderLayout.EAST);

		return panel;
	}

	/**
	 * Returns a sorted list of SalvageItems based on the current sort option and direction.
	 * <p>
	 * Sorting options:
	 * <ul>
	 *   <li>ALPHABETICAL - Sort by item name</li>
	 *   <li>CURRENT_RATE - Sort by actual drop rate from player's data</li>
	 *   <li>EXPECTED_RATE - Sort by wiki-sourced expected drop rate</li>
	 *   <li>QUANTITY - Sort by total quantity received</li>
	 *   <li>LUCK - Sort by luck ratio (current rate / expected rate), color-coded green/yellow/red</li>
	 * </ul>
	 * Sort direction (ascending/descending) is applied after the comparator is selected.
	 *
	 * @param data The salvage data containing items to sort
	 * @return Sorted list of SalvageItems
	 */
	private List<SalvageItem> getSortedItems(SalvageData data)
	{
		List<SalvageItem> items = new ArrayList<>(data.getItems().values());
		
		Comparator<SalvageItem> comparator;
		
		switch (currentSortOption)
		{
			case ALPHABETICAL:
				comparator = Comparator.comparing(SalvageItem::getItemName);
				break;
			
			case CURRENT_RATE:
				comparator = Comparator.comparingDouble(item -> item.getCurrentDropRate(data.getTotalLoots()));
				break;
			
			case EXPECTED_RATE:
				comparator = Comparator.comparingDouble(SalvageItem::getExpectedDropRate);
				break;
			
			case QUANTITY:
				comparator = Comparator.comparingInt(SalvageItem::getTotalQuantity);
				break;

			case LUCK:
				comparator = Comparator.comparingInt(item -> getLuckScore(item, data.getTotalLoots()));
				break;

			default:
				comparator = Comparator.comparing(SalvageItem::getItemName);
				break;
		}
		
		if (currentSortDescending)
		{
			comparator = comparator.reversed();
		}
		
		items.sort(comparator);
		return items;
	}

	/**
	 * Determines the luck color for an item based on its current vs expected drop rate.
	 * <p>
	 * Uses a gradient system to provide smooth color transitions:
	 * <ul>
	 *   <li>Pure Green (ratio ≥ 1.5): Maximum luck - getting items much more often</li>
	 *   <li>Green-Yellow Gradient (1.1 ≤ ratio < 1.5): Good luck - interpolated color</li>
	 *   <li>Pure Yellow (0.9 ≤ ratio < 1.1): Neutral - close to expected rate</li>
	 *   <li>Yellow-Red Gradient (0.5 ≤ ratio < 0.9): Bad luck - interpolated color</li>
	 *   <li>Pure Red (ratio < 0.5): Worst luck - getting items much less often</li>
	 *   <li>Gray: Unknown - no expected rate data available</li>
	 * </ul>
	 * </p>
	 *
	 * @param currentRate the player's actual drop rate
	 * @param expectedRate the wiki-sourced expected drop rate
	 * @return Color representing the luck level
	 */
	private Color getLuckColor(double currentRate, double expectedRate)
	{
		if (expectedRate <= 0)
		{
			return Color.LIGHT_GRAY;
		}

		double luckRatio = currentRate / expectedRate;

		if (luckRatio >= 1.5)
		{
			return LUCK_GOOD;
		}
		else if (luckRatio >= 1.1)
		{
			float t = (float) ((luckRatio - 1.1) / 0.4);
			return interpolateColor(LUCK_NEUTRAL, LUCK_GOOD, t);
		}
		else if (luckRatio >= 0.9)
		{
			return LUCK_NEUTRAL;
		}
		else if (luckRatio >= 0.5)
		{
			float t = (float) ((luckRatio - 0.5) / 0.4);
			return interpolateColor(LUCK_BAD, LUCK_NEUTRAL, t);
		}
		else
		{
			return LUCK_BAD;
		}
	}

	/**
	 * Get luck score for sorting items by luck (current rate vs expected rate).
	 * <p>
	 * Aligns with the color gradient logic from {@link #getLuckColor(double, double)}
	 * for consistent sorting and visual representation.
	 * </p>
	 * <p>
	 * Scoring system:
	 * <ul>
	 *   <li>Pure Green (ratio ≥ 1.5): Score 1000 - Best luck</li>
	 *   <li>Green-Yellow Gradient (1.1 ≤ ratio < 1.5): Scores 600-999 - Good luck</li>
	 *   <li>Pure Yellow (0.9 ≤ ratio < 1.1): Score 500 - Neutral/Expected</li>
	 *   <li>Yellow-Red Gradient (0.5 ≤ ratio < 0.9): Scores 100-499 - Bad luck</li>
	 *   <li>Pure Red (ratio < 0.5): Score 0 - Worst luck</li>
	 *   <li>Unknown (no expected rate): Score Integer.MIN_VALUE - Always last</li>
	 * </ul>
	 * </p>
	 * <p>
	 * Sort behavior:
	 * <ul>
	 *   <li>Descending: Green → Green-Yellow → Yellow → Yellow-Red → Red → Unknown</li>
	 *   <li>Ascending: Red → Yellow-Red → Yellow → Green-Yellow → Green → Unknown</li>
	 * </ul>
	 * </p>
	 *
	 * @param item the salvage item to score
	 * @param totalLoots total number of loots to calculate current drop rate
	 * @return score based on luck ratio (higher = better luck)
	 */
	private int getLuckScore(SalvageItem item, int totalLoots)
	{
		double currentRate = item.getCurrentDropRate(totalLoots);
		double expectedRate = item.getExpectedDropRate();

		if (expectedRate <= 0)
		{
			return Integer.MIN_VALUE; // Unknown items go last in both directions
		}

		double luckRatio = currentRate / expectedRate;

		// Pure green (best luck): ratio >= 1.5
		if (luckRatio >= 1.5)
		{
			return 1000;
		}
		// Green-yellow gradient: 1.1 <= ratio < 1.5
		else if (luckRatio >= 1.1)
		{
			// Map 1.1-1.5 to scores 600-999
			return 600 + (int)((luckRatio - 1.1) / 0.4 * 399);
		}
		// Pure yellow (neutral): 0.9 <= ratio < 1.1
		else if (luckRatio >= 0.9)
		{
			return 500;
		}
		// Yellow-red gradient: 0.5 <= ratio < 0.9
		else if (luckRatio >= 0.5)
		{
			// Map 0.5-0.9 to scores 100-499
			return 100 + (int)((luckRatio - 0.5) / 0.4 * 399);
		}
		// Pure red (worst luck): ratio < 0.5
		else
		{
			return 0;
		}
	}

	private Color interpolateColor(Color c1, Color c2, float t)
	{
		t = Math.max(0, Math.min(1, t));
		int r = (int) (c1.getRed() + t * (c2.getRed() - c1.getRed()));
		int g = (int) (c1.getGreen() + t * (c2.getGreen() - c1.getGreen()));
		int b = (int) (c1.getBlue() + t * (c2.getBlue() - c1.getBlue()));
		return new Color(r, g, b);
	}

	/**
	 * Show context menu for shipwreck section
	 */
	private void showContextMenu(MouseEvent e, ShipwreckType type)
	{
		JPopupMenu menu = new JPopupMenu();

		JMenuItem resetItem = new JMenuItem("Reset " + type.getDisplayName() + " Data");
		resetItem.addActionListener(ev -> {
			int confirm = JOptionPane.showConfirmDialog(
				this,
				"Are you sure you want to reset all data for " + type.getDisplayName() + "?",
				"Confirm Reset",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE
			);
			if (confirm == JOptionPane.YES_OPTION && onResetShipwreck != null)
			{
				onResetShipwreck.accept(type);
			}
		});
		menu.add(resetItem);

		menu.addSeparator();

		JMenuItem resetAllItem = new JMenuItem("Reset All Data");
		resetAllItem.addActionListener(ev -> {
			int confirm = JOptionPane.showConfirmDialog(
				this,
				"Are you sure you want to reset ALL salvage data?",
				"Confirm Reset All",
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE
			);
			if (confirm == JOptionPane.YES_OPTION && onResetAll != null)
			{
				onResetAll.run();
			}
		});
		menu.add(resetAllItem);

		menu.show(e.getComponent(), e.getX(), e.getY());
	}
}

package com.salvagesack;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("salvagesack")
public interface SalvageSackConfig extends Config
{
	@ConfigItem(
		keyName = "sortOption",
		name = "Sort Items By",
		description = "Choose how to sort items within each shipwreck type"
	)
	default SortOption sortOption()
	{
		return SortOption.ALPHABETICAL;
	}

	@ConfigItem(
		keyName = "sortDescending",
		name = "Sort Descending",
		description = "Sort items in descending order (highest to lowest)"
	)
	default boolean sortDescending()
	{
		return false;
	}
}

package com.salvagesack;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.AsyncBufferedImage;

import java.awt.image.BufferedImage;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Manages fetching and caching of item icons using RuneLite's ItemManager
 */
@Slf4j
public class ItemIconManager
{
	private static final int ICON_SIZE = 32;
	
	private final Map<Integer, BufferedImage> iconCache;
	private final BufferedImage placeholderIcon;

	@Setter
	private Runnable onIconLoaded;

	@Setter
	private ItemManager itemManager;

	public ItemIconManager()
	{
		this.iconCache = new ConcurrentHashMap<>();
		this.placeholderIcon = createPlaceholderIcon();
	}

	/**
	 * Get icon for an item by ID
	 * @param itemId ID of the item
	 * @return BufferedImage of the item icon, or placeholder if not found
	 */
	public BufferedImage getItemIcon(int itemId)
	{
		if (itemId <= 0)
		{
			return placeholderIcon;
		}

		// Check cache first
		BufferedImage cached = iconCache.get(itemId);
		if (cached != null)
		{
			return cached;
		}

		// Try to get from ItemManager
		if (itemManager != null)
		{
			try
			{
				AsyncBufferedImage asyncImage = itemManager.getImage(itemId);
				if (asyncImage != null)
				{
					// Cache when the image loads and trigger callback
					asyncImage.onLoaded(() -> {
						iconCache.put(itemId, asyncImage);
						log.debug("Cached icon for item {}", itemId);
						if (onIconLoaded != null)
						{
							onIconLoaded.run();
						}
					});
					// Return the async image (it extends BufferedImage)
					return asyncImage;
				}
			}
			catch (Exception e)
			{
				log.debug("Failed to get icon for item {}: {}", itemId, e.getMessage());
			}
		}

		// Return placeholder if fetch failed
		return placeholderIcon;
	}

	/**
	 * Create a simple placeholder icon
	 */
	private BufferedImage createPlaceholderIcon()
	{
		BufferedImage image = new BufferedImage(ICON_SIZE, ICON_SIZE, BufferedImage.TYPE_INT_ARGB);
		// Create a simple gray square
		for (int x = 0; x < ICON_SIZE; x++)
		{
			for (int y = 0; y < ICON_SIZE; y++)
			{
				if (x < 2 || x >= ICON_SIZE - 2 || y < 2 || y >= ICON_SIZE - 2)
				{
					image.setRGB(x, y, 0xFF666666); // Border
				}
				else
				{
					image.setRGB(x, y, 0xFF333333); // Fill
				}
			}
		}
		return image;
	}
}

package com.salvagesack;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Represents different types of shipwrecks in OSRS Sailing
 */
@Getter
@RequiredArgsConstructor
public enum ShipwreckType
{
	SMALL("Small shipwreck", "Small"),
	FISHERMANS("Fisherman's shipwreck", "Fishy"),
	BARRACUDA("Barracuda shipwreck", "Barracuda"),
	LARGE("Large shipwreck", "Large"),
	PIRATE("Pirate shipwreck", "Plundered"),
	MERCENARY("Mercenary shipwreck", "Martial"),
	FREMENNIK("Fremennik shipwreck", "Fremennik"),
	MERCHANT("Merchant shipwreck", "Opulent"),
	UNKNOWN("Unknown", "unknown");

	private final String displayName;
	private final String salvageType;

	public static ShipwreckType fromString(String text)
	{
		if (text == null)
		{
			return UNKNOWN;
		}

		String lowerText = text.toLowerCase().trim();
		for (ShipwreckType type : ShipwreckType.values())
		{
			if (type.salvageType.toLowerCase().equals(lowerText) ||
			    type.displayName.equalsIgnoreCase(text) ||
			    lowerText.contains(type.salvageType.toLowerCase()))
			{
				return type;
			}
		}
		return UNKNOWN;
	}
}

package com.salvagesack;

import lombok.Data;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Stores all salvage tracking data for a specific shipwreck type.
 * <p>
 * Each shipwreck type maintains its own loot statistics including total sorts,
 * individual item drop counts, and a timestamp for UI ordering.
 * </p>
 * <p>
 * The panel displays shipwreck sections sorted by {@link #lastUpdated} so that
 * the most recently active shipwreck always appears at the top, regardless of
 * whether it is expanded or collapsed.
 * </p>
 */
@Data
public class SalvageData
{
	private final ShipwreckType shipwreckType;
	private int totalLoots;
	private final Map<Integer, SalvageItem> items; // itemId -> SalvageItem

	/**
	 * Timestamp (milliseconds since epoch) of the last loot recorded for this shipwreck.
	 * Used to sort shipwreck panels in the UI with most recently updated at the top.
	 */
	private long lastUpdated;

	public SalvageData(ShipwreckType shipwreckType)
	{
		this.shipwreckType = shipwreckType;
		this.totalLoots = 0;
		this.items = new ConcurrentHashMap<>();
		this.lastUpdated = 0;
	}

	/**
	 * Constructor for deserialization
	 */
	public SalvageData(ShipwreckType shipwreckType, int totalLoots, Map<Integer, SalvageItem> items)
	{
		this.shipwreckType = shipwreckType;
		this.totalLoots = totalLoots;
		this.items = items;
		this.lastUpdated = 0;
	}

	/**
	 * Record a loot drop
	 * @param itemId The item ID that was looted
	 * @param itemName The item name
	 * @param expectedDropRate Expected drop rate for this item
	 */
	public void recordLoot(int itemId, String itemName, double expectedDropRate)
	{
		recordLoot(itemId, itemName, expectedDropRate, 1);
	}

	/**
	 * Record a loot drop with quantity
	 * Counts as 1 drop for rate calculation, but tracks full quantity
	 * @param itemId The item ID that was looted
	 * @param itemName The item name
	 * @param expectedDropRate Expected drop rate for this item
	 * @param quantity Number of items looted (for display, not rate calc)
	 */
	public void recordLoot(int itemId, String itemName, double expectedDropRate, int quantity)
	{
		SalvageItem item = items.computeIfAbsent(itemId,
			id -> new SalvageItem(id, itemName, expectedDropRate));
		item.recordDrop(quantity);  // 1 drop for rate, full quantity for display
	}

	/**
	 * Increment total loot count and update the last modified timestamp.
	 * <p>
	 * This method should be called once per salvage sort action. The timestamp
	 * update ensures this shipwreck type will be displayed at the top of the
	 * panel, as shipwrecks are sorted by most recently updated.
	 * </p>
	 */
	public void incrementTotalLoots()
	{
		this.totalLoots++;
		this.lastUpdated = System.currentTimeMillis();
	}
}

package com.salvagesack;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Sorting options for item display in the salvage panel.
 * <p>
 * Each option determines how items are ordered within each shipwreck section:
 * <ul>
 *   <li>ALPHABETICAL - Sort items by name (A-Z or Z-A)</li>
 *   <li>CURRENT_RATE - Sort by actual drop rate calculated from player's data</li>
 *   <li>EXPECTED_RATE - Sort by wiki-sourced expected drop rates</li>
 *   <li>QUANTITY - Sort by total quantity received</li>
 *   <li>LUCK - Sort by luck ratio (current/expected rate), grouping by color:
 *       <ul>
 *         <li>Green: ratio ≥ 1.1 (lucky - getting items more often)</li>
 *         <li>Yellow: 0.9 ≤ ratio < 1.1 (neutral - at expected rate)</li>
 *         <li>Red: ratio < 0.9 (unlucky - getting items less often)</li>
 *         <li>Unknown: no expected rate data available</li>
 *       </ul>
 *   </li>
 * </ul>
 * The sort direction (ascending/descending) can be toggled independently.
 * </p>
 */
@Getter
@RequiredArgsConstructor
public enum SortOption
{
	ALPHABETICAL("Alphabetical"),
	CURRENT_RATE("Current Rate"),
	EXPECTED_RATE("Expected Rate"),
	QUANTITY("Quantity"),
	LUCK("Luck");

	private final String displayName;

	@Override
	public String toString()
	{
		return displayName;
	}
}

package com.salvagesack;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * Manages loading and accessing expected drop rates from configuration
 */
@Slf4j
public class DropRateManager
{
	private final Map<ShipwreckType, Map<String, Double>> dropRates = new HashMap<>();
	private final Gson gson;
	private final File userConfigFile;

	public DropRateManager(File dataDirectory, Gson gson)
	{
		this.gson = gson;
		this.userConfigFile = new File(dataDirectory, "drop_rates.json");
		loadDropRates();
	}

	/**
	 * Load drop rates from bundled resource and user config
	 */
	private void loadDropRates()
	{
		// First load bundled defaults
		loadBundledRates();

		// Then override with user config if it exists
		if (userConfigFile.exists())
		{
			loadUserRates();
		}
		else
		{
			// Copy bundled config to user directory for editing
			copyBundledToUser();
		}
	}

	/**
	 * Load rates from bundled resource
	 */
	private void loadBundledRates()
	{
		try (InputStream is = getClass().getResourceAsStream("/drop_rates.json"))
		{
			if (is != null)
			{
				parseDropRates(new InputStreamReader(is, StandardCharsets.UTF_8));
				log.info("Loaded bundled drop rates");
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to load bundled drop rates: {}", e.getMessage());
		}
	}

	/**
	 * Load rates from user config file
	 */
	private void loadUserRates()
	{
		try (FileReader reader = new FileReader(userConfigFile))
		{
			parseDropRates(reader);
			log.info("Loaded user drop rates from {}", userConfigFile.getAbsolutePath());
		}
		catch (Exception e)
		{
			log.warn("Failed to load user drop rates: {}", e.getMessage());
		}
	}

	/**
	 * Copy bundled config to user directory
	 */
	private void copyBundledToUser()
	{
		try (InputStream is = getClass().getResourceAsStream("/drop_rates.json"))
		{
			if (is != null)
			{
				File parentDir = userConfigFile.getParentFile();
				if (parentDir != null && !parentDir.exists() && !parentDir.mkdirs())
				{
					log.warn("Failed to create directory: {}", parentDir.getAbsolutePath());
					return;
				}
				try (FileOutputStream fos = new FileOutputStream(userConfigFile))
				{
					byte[] buffer = new byte[1024];
					int bytesRead;
					while ((bytesRead = is.read(buffer)) != -1)
					{
						fos.write(buffer, 0, bytesRead);
					}
				}
				log.info("Copied drop rates config to {}", userConfigFile.getAbsolutePath());
			}
		}
		catch (Exception e)
		{
			log.warn("Failed to copy drop rates config: {}", e.getMessage());
		}
	}

	/**
	 * Parse drop rates from a reader
	 */
	private void parseDropRates(Reader reader)
	{
		JsonObject root = gson.fromJson(reader, JsonObject.class);
		JsonObject shipwrecks = root.getAsJsonObject("shipwrecks");

		if (shipwrecks == null)
		{
			return;
		}

		for (String shipwreckKey : shipwrecks.keySet())
		{
			try
			{
				ShipwreckType type = ShipwreckType.valueOf(shipwreckKey);
				JsonObject shipwreckData = shipwrecks.getAsJsonObject(shipwreckKey);
				JsonObject items = shipwreckData.getAsJsonObject("items");

				if (items != null)
				{
					Map<String, Double> itemRates = dropRates.computeIfAbsent(type, k -> new HashMap<>());

					for (String itemName : items.keySet())
					{
						JsonElement rateElement = items.get(itemName);
						if (rateElement != null && rateElement.isJsonPrimitive())
						{
							double rate = rateElement.getAsDouble();
							itemRates.put(itemName.toLowerCase(), rate);
						}
					}
				}
			}
			catch (IllegalArgumentException e)
			{
				log.debug("Unknown shipwreck type in config: {}", shipwreckKey);
			}
		}
	}

	/**
	 * Get the expected drop rate for an item from a specific shipwreck type
	 * @param shipwreckType The type of shipwreck
	 * @param itemName The name of the item
	 * @return The expected drop rate (0.0 to 1.0), or 0.0 if unknown
	 */
	public double getExpectedDropRate(ShipwreckType shipwreckType, String itemName)
	{
		Map<String, Double> itemRates = dropRates.get(shipwreckType);
		if (itemRates == null)
		{
			log.debug("No rates found for shipwreck type: {}", shipwreckType);
			return 0.0;
		}

		double rate = itemRates.getOrDefault(itemName.toLowerCase(), 0.0);
		log.info("Drop rate lookup: type={}, item='{}', rate={}", shipwreckType, itemName, rate);
		return rate;
	}
}


package com.salvagesack;

import lombok.Data;

/**
 * Represents a salvage item drop with tracking information
 */
@Data
public class SalvageItem
{
	private final int itemId;
	private final String itemName;
	private int dropCount;      // Number of times this item was dropped (for rate calculation)
	private int totalQuantity;  // Total quantity received (for display)
	private final double expectedDropRate; // Expected rate from wiki (e.g., 0.1 for 10%)

	public SalvageItem(int itemId, String itemName, double expectedDropRate)
	{
		this.itemId = itemId;
		this.itemName = itemName;
		this.dropCount = 0;
		this.totalQuantity = 0;
		this.expectedDropRate = expectedDropRate;
	}


	/**
	 * Full constructor for deserialization with quantity
	 */
	public SalvageItem(int itemId, String itemName, int dropCount, int totalQuantity, double expectedDropRate)
	{
		this.itemId = itemId;
		this.itemName = itemName;
		this.dropCount = dropCount;
		this.totalQuantity = totalQuantity;
		this.expectedDropRate = expectedDropRate;
	}

	/**
	 * Increment the drop count for this item (single drop)
	 */
	public void incrementDropCount()
	{
		this.dropCount++;
		this.totalQuantity++;
	}

	/**
	 * Record a drop with a specific quantity
	 * Counts as 1 drop for rate calculation, but adds full quantity to total
	 * @param quantity The quantity received in this drop
	 */
	public void recordDrop(int quantity)
	{
		this.dropCount++;           // Only 1 drop for rate calculation
		this.totalQuantity += quantity;  // Full quantity for display
	}

	/**
	 * Add to the drop count for this item (legacy method)
	 * @param amount Amount to add
	 * @deprecated Use recordDrop(quantity) instead
	 */
	@Deprecated
	public void addDropCount(int amount)
	{
		this.dropCount += amount;
		this.totalQuantity += amount;
	}

	/**
	 * Calculate current drop rate based on total loots
	 * @param totalLoots Total number of loots from this shipwreck type
	 * @return Current drop rate as a decimal (e.g., 0.15 for 15%)
	 */
	public double getCurrentDropRate(int totalLoots)
	{
		if (totalLoots == 0)
		{
			return 0.0;
		}
		return (double) dropCount / totalLoots;
	}
}

package com.salvagesack;

import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.RuneLite;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.item.ItemPrice;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
	name = "Salvage Sack",
	description = "Tracks salvage loot from the Sailing skill by shipwreck type",
	tags = {"sailing", "salvage", "tracking", "loot"}
)
@SuppressWarnings("unused") // Fields and methods are used by RuneLite's dependency injection and event system
public class SalvageSackPlugin extends Plugin
{
	// Pattern to match salvage loot messages
	// Salvage types: Small, Fishy, Barracuda, Large, Pirate, Martial, Fremennik, Opulent
	// Example: "You sort through the Martial salvage and find: 1 x Adamant 2h sword."
	private static final Pattern SALVAGE_PATTERN = Pattern.compile(
		"You sort through the (.+?) salvage and find: (\\d+) x (.+?)\\.",
		Pattern.CASE_INSENSITIVE
	);

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private ItemManager itemManager;

	@Inject
	private Gson gson;

	@Inject
	private SalvageSackConfig config;

	@Inject
	private ConfigManager configManager;

	private SalvageSackPanel panel;
	private NavigationButton navButton;
	private SalvageDataManager dataManager;
	private DropRateManager dropRateManager;
	private Map<ShipwreckType, SalvageData> salvageDataMap;

	@Override
	protected void startUp()
	{
		log.info("Salvage Sack started!");

		// Initialize data structures
		salvageDataMap = new HashMap<>();
		
		// Initialize icon manager
		ItemIconManager iconManager = new ItemIconManager();
		iconManager.setItemManager(itemManager);

		// Initialize data manager
		File runeliteDir = RuneLite.RUNELITE_DIR;
		if (runeliteDir == null)
		{
			runeliteDir = new File(System.getProperty("user.home"), ".runelite");
		}
		File dataDirectory = new File(runeliteDir, "salvagesack");
		if (!dataDirectory.exists())
		{
			boolean created = dataDirectory.mkdirs();
			if (!created)
			{
				log.warn("Failed to create data directory: {}", dataDirectory.getAbsolutePath());
			}
		}
		dataManager = new SalvageDataManager(dataDirectory, gson);

		// Initialize drop rate manager
		dropRateManager = new DropRateManager(dataDirectory, gson);

		// Load saved data
		Map<ShipwreckType, SalvageData> loadedData = dataManager.loadData();
		if (loadedData != null && !loadedData.isEmpty())
		{
			salvageDataMap.putAll(loadedData);
			log.info("Loaded {} shipwreck types from saved data", loadedData.size());
		}

		// Initialize panel
		panel = new SalvageSackPanel(iconManager, config);
		panel.setDropRateManager(dropRateManager);
		panel.setConfigManager(configManager);
		panel.setOnResetShipwreck(this::resetShipwreckData);
		panel.setOnResetAll(this::resetAllData);
		panel.updateData(salvageDataMap);

		// Set up icon loaded callback to repaint panel when async icons finish loading
		iconManager.setOnIconLoaded(() -> {
			if (panel != null)
			{
				panel.repaint();
			}
		});

		// Create navigation button
		BufferedImage icon;
		try
		{
			icon = ImageUtil.loadImageResource(getClass(), "/icon.png");
		}
		catch (Exception e)
		{
			log.warn("Failed to load icon, using fallback", e);
			// Create a visible fallback icon
			icon = new BufferedImage(16, 16, BufferedImage.TYPE_INT_ARGB);
			Graphics2D g = icon.createGraphics();
			g.setColor(new Color(66, 134, 244)); // Blue color
			g.fillRect(0, 0, 16, 16);
			g.setColor(Color.WHITE);
			g.setFont(new Font("Arial", Font.BOLD, 12));
			g.drawString("S", 4, 13);
			g.dispose();
		}

		navButton = NavigationButton.builder()
			.tooltip("Salvage Sack")
			.icon(icon)
			.priority(5)
			.panel(panel)
			.build();

		clientToolbar.addNavigation(navButton);
		log.info("Navigation button added to toolbar");
	}

	@Override
	protected void shutDown()
	{
		log.info("Salvage Sack stopped!");

		// Save data before shutdown
		if (dataManager != null && salvageDataMap != null)
		{
			dataManager.saveData(salvageDataMap);
			log.info("Saved salvage data");
		}

		// Clean up UI
		if (navButton != null)
		{
			clientToolbar.removeNavigation(navButton);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() != ChatMessageType.GAMEMESSAGE && 
		    event.getType() != ChatMessageType.SPAM)
		{
			return;
		}

		// Strip HTML tags from the message
		String message = event.getMessage()
			.replaceAll("<[^>]*>", "")
			.replaceAll("&lt;", "<")
			.replaceAll("&gt;", ">")
			.replaceAll("&amp;", "&");

		// Log all game messages for debugging (can be removed later)
		if (message.toLowerCase().contains("salvage"))
		{
			log.info("Salvage message detected: {}", message);
		}

		Matcher matcher = SALVAGE_PATTERN.matcher(message);

		if (matcher.find())
		{
			String salvageType = matcher.group(1).trim();  // e.g., "martial"
			int quantity = Integer.parseInt(matcher.group(2).trim());  // e.g., 1
			String itemName = matcher.group(3).trim();  // e.g., "Adamant 2h sword"

			log.info("Parsed salvage: type='{}' quantity={} item='{}'", salvageType, quantity, itemName);

			// Determine shipwreck type from salvage type
			ShipwreckType shipwreckType = ShipwreckType.fromString(salvageType);

			// Get or create salvage data for this shipwreck type
			SalvageData data = salvageDataMap.computeIfAbsent(
				shipwreckType, 
				SalvageData::new
			);

			// Increment total loots
			data.incrementTotalLoots();

			// Look up item ID using ItemManager
			int itemId = lookupItemId(itemName);

			// Get expected drop rate (default to 0 for unknown items)
			double expectedRate = getExpectedDropRate(shipwreckType, itemName);

			// Record the loot with quantity
			data.recordLoot(itemId, itemName, expectedRate, quantity);

			// Update the panel
			panel.updateData(salvageDataMap);

			// Save data
			dataManager.saveData(salvageDataMap);

			log.info("Recorded salvage: {}x {} (ID: {}) from {}", quantity, itemName, itemId, shipwreckType);
		}
	}

	/**
	 * Look up an item ID by name using the ItemManager
	 */
	private int lookupItemId(String itemName)
	{
		if (itemManager != null)
		{
			try
			{
				// Search for the item by name
				int itemId = itemManager.search(itemName).stream()
					.findFirst()
					.map(ItemPrice::getId)
					.orElse(-1);

				if (itemId != -1)
				{
					log.debug("Found item ID {} for '{}'", itemId, itemName);
					return itemId;
				}
			}
			catch (Exception e)
			{
				log.debug("Failed to look up item ID for '{}': {}", itemName, e.getMessage());
			}
		}

		// Fallback to hash-based ID if lookup fails
		return itemName.hashCode() & 0x7FFFFFFF;
	}

	/**
	 * Get expected drop rate for an item from a specific shipwreck type
	 * Loads rates from drop_rates.json configuration file
	 */
	private double getExpectedDropRate(ShipwreckType shipwreckType, String itemName)
	{
		if (dropRateManager != null)
		{
			return dropRateManager.getExpectedDropRate(shipwreckType, itemName);
		}
		return 0.0;
	}


	private void resetShipwreckData(ShipwreckType type)
	{
		salvageDataMap.remove(type);
		panel.updateData(salvageDataMap);
		dataManager.saveData(salvageDataMap);
		log.info("Reset data for {}", type.getDisplayName());
	}

	private void resetAllData()
	{
		salvageDataMap.clear();
		panel.updateData(salvageDataMap);
		dataManager.saveData(salvageDataMap);
		log.info("Reset all salvage data");
	}

	@Provides
	SalvageSackConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(SalvageSackConfig.class);
	}
}

package com.salvagesack;

import org.junit.Test;
import static org.junit.Assert.*;

public class SalvageDataTest
{
	@Test
	public void testSalvageItemTracking()
	{
		SalvageItem item = new SalvageItem(1, "Test Item", 0.25);
		assertEquals("Test Item", item.getItemName());
		assertEquals(1, item.getItemId());
		assertEquals(0, item.getDropCount());
		assertEquals(0.25, item.getExpectedDropRate(), 0.001);

		item.incrementDropCount();
		assertEquals(1, item.getDropCount());

		// Current drop rate should be 50% after 2 loots with 1 drop
		assertEquals(0.5, item.getCurrentDropRate(2), 0.001);
	}

	@Test
	public void testSalvageDataRecording()
	{
		SalvageData data = new SalvageData(ShipwreckType.SMALL);
		assertEquals(ShipwreckType.SMALL, data.getShipwreckType());
		assertEquals(0, data.getTotalLoots());
		assertTrue(data.getItems().isEmpty());

		data.incrementTotalLoots();
		data.recordLoot(1, "Item 1", 0.5);
		
		assertEquals(1, data.getTotalLoots());
		assertEquals(1, data.getItems().size());
		assertEquals(1, data.getItems().get(1).getDropCount());

		data.incrementTotalLoots();
		data.recordLoot(1, "Item 1", 0.5);
		data.recordLoot(2, "Item 2", 0.25);

		assertEquals(2, data.getTotalLoots());
		assertEquals(2, data.getItems().size());
		assertEquals(2, data.getItems().get(1).getDropCount());
		assertEquals(1, data.getItems().get(2).getDropCount());
	}

	@Test
	public void testShipwreckTypeFromString()
	{
		assertEquals(ShipwreckType.SMALL, ShipwreckType.fromString("Small"));
		assertEquals(ShipwreckType.LARGE, ShipwreckType.fromString("Large"));
		assertEquals(ShipwreckType.PIRATE, ShipwreckType.fromString("Plundered"));
		assertEquals(ShipwreckType.MERCENARY, ShipwreckType.fromString("Martial"));
		assertEquals(ShipwreckType.UNKNOWN, ShipwreckType.fromString("Random Text"));
	}

	@Test
	public void testDropRateCalculation()
	{
		SalvageItem item = new SalvageItem(1, "Test", 0.2);
		
		// No loots yet
		assertEquals(0.0, item.getCurrentDropRate(0), 0.001);
		
		// 1 drop in 5 loots = 20%
		item.incrementDropCount();
		assertEquals(0.2, item.getCurrentDropRate(5), 0.001);
		
		// 3 drops in 10 loots = 30%
		item.incrementDropCount();
		item.incrementDropCount();
		assertEquals(0.3, item.getCurrentDropRate(10), 0.001);
	}
}

package com.salvagesack;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class SalvageSackPluginTest
{
	@SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(SalvageSackPlugin.class);
		RuneLite.main(args);
	}
}
package com.salvagesack;

import org.junit.Test;
import static org.junit.Assert.*;

public class SortOptionTest
{
	@Test
	public void testSortOptionDisplayNames()
	{
		assertEquals("Alphabetical", SortOption.ALPHABETICAL.getDisplayName());
		assertEquals("Current Rate", SortOption.CURRENT_RATE.getDisplayName());
		assertEquals("Expected Rate", SortOption.EXPECTED_RATE.getDisplayName());
		assertEquals("Quantity", SortOption.QUANTITY.getDisplayName());
		assertEquals("Luck", SortOption.LUCK.getDisplayName());
	}

	@Test
	public void testSortOptionToString()
	{
		assertEquals("Alphabetical", SortOption.ALPHABETICAL.toString());
		assertEquals("Current Rate", SortOption.CURRENT_RATE.toString());
		assertEquals("Expected Rate", SortOption.EXPECTED_RATE.toString());
		assertEquals("Quantity", SortOption.QUANTITY.toString());
		assertEquals("Luck", SortOption.LUCK.toString());
	}

	@Test
	public void testSortOptionValues()
	{
		SortOption[] values = SortOption.values();
		assertEquals(5, values.length);
		assertEquals(SortOption.ALPHABETICAL, values[0]);
		assertEquals(SortOption.CURRENT_RATE, values[1]);
		assertEquals(SortOption.EXPECTED_RATE, values[2]);
		assertEquals(SortOption.QUANTITY, values[3]);
		assertEquals(SortOption.LUCK, values[4]);
	}
}

