package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import javax.inject.Inject;

@ToString
public class DefenceInfoBox extends InfoBox
{
    @Inject
    private final DefenceTrackerConfig config;

    @Getter
    private final long minimumDefence;

    @Getter
    @Setter
    private long currentDefence;

    public DefenceInfoBox(BufferedImage image, Plugin plugin, long minimumDefence, long currentDefence, DefenceTrackerConfig config)
    {
        super(image, plugin);
        this.currentDefence = currentDefence;
        this.minimumDefence = minimumDefence;
        this.config = config;
    }

    @Override
    public String getText()
    {
        long displayedDefence =
            config.displayFullDefenceLevel()
                ? currentDefence
                : currentDefence - minimumDefence;

        return Long.toString(displayedDefence);
    }

    @Override
    public Color getTextColor()
    {
		if (config.disableIBColor())
		{
			return Color.WHITE;
		}

        long relativeDefence = Math.max(currentDefence - minimumDefence, 0);

        if (relativeDefence == 0)
        {
            return config.cappedDefColor();
        }

        if (relativeDefence <= config.lowDef())
        {
            return config.lowDefColor();
        }

        return config.highDefColor();
    }
}
/*
 * Copyright (c) 2022, l2- <https://github.com/l2->
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.InstanceTemplates;
import net.runelite.api.NullObjectID;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.plugins.raids.Raid;
import net.runelite.client.plugins.raids.RaidRoom;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.Perspective.SCENE_SIZE;

// Mostly copied from the core RaidsPlugin
@Slf4j
@Singleton
public class CoXLayoutSolver
{
	static final int ROOM_MAX_SIZE = 32;
	private static final int LOBBY_PLANE = 3;
	private static final int SECOND_FLOOR_PLANE = 2;
	private static final int ROOMS_PER_PLANE = 8;
	private static final int AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE = 4;
	private static final WorldPoint TEMP_LOCATION = new WorldPoint(3360, 5152, 2);
	private static final String CM_RAID_CODE = "SPCFPC#Â¤CFP SPC#";

	private final Client client;
	boolean checkInRaid;
	private boolean loggedIn;
	private boolean inRaidChambers;
	private int raidPartyID;
	@Getter
	private Raid raid;

	@Inject
	public CoXLayoutSolver(Client client)
	{
		this.client = client;
	}

	public boolean isCM()
	{
		return raid != null && CM_RAID_CODE.equals(raid.toCode());
	}

	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayer.IN_RAID_PARTY)
		{
			boolean tempInRaid = client.getVarbitValue(Varbits.IN_RAID) == 1;
			if (loggedIn && !tempInRaid)
			{
				raid = null;
			}

			raidPartyID = event.getValue();
		}

		if (event.getVarbitId() == Varbits.IN_RAID)
		{
			boolean tempInRaid = event.getValue() == 1;
			if (tempInRaid && loggedIn)
			{
				checkRaidPresence();
			}

			inRaidChambers = tempInRaid;
		}
	}

	public void onGameTick(GameTick event)
	{
		if (checkInRaid)
		{
			loggedIn = true;
			checkInRaid = false;

			if (inRaidChambers)
			{
				checkRaidPresence();
			}
			else
			{
				if (raidPartyID == -1)
				{
					raid = null;
				}
			}
		}
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			if (client.getLocalPlayer() == null
				|| client.getLocalPlayer().getWorldLocation().equals(TEMP_LOCATION))
			{
				return;
			}

			checkInRaid = true;
		}
		else if (client.getGameState() == GameState.LOGIN_SCREEN
			|| client.getGameState() == GameState.CONNECTION_LOST)
		{
			loggedIn = false;
		}
		else if (client.getGameState() == GameState.HOPPING)
		{
			raid = null;
		}
	}

	private void checkRaidPresence()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		inRaidChambers = client.getVarbitValue(Varbits.IN_RAID) == 1;

		if (!inRaidChambers)
		{
			return;
		}

		raid = buildRaid(raid);
	}

	private Raid buildRaid(Raid from)
	{
		WorldView wv = client.getTopLevelWorldView();
		Raid raid = from;

		if (raid == null)
		{
			Point gridBase = findLobbyBase();

			if (gridBase == null)
			{
				return null;
			}

			Integer lobbyIndex = findLobbyIndex(gridBase);

			if (lobbyIndex == null)
			{
				return null;
			}

			raid = new Raid(
				new WorldPoint(wv.getBaseX() + gridBase.getX(), wv.getBaseY() + gridBase.getY(), LOBBY_PLANE),
				lobbyIndex
			);
		}

		int baseX = raid.getLobbyIndex() % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
		int baseY = raid.getLobbyIndex() % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;

		for (int i = 0; i < raid.getRooms().length; i++)
		{
			int x = i % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
			int y = i % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;
			int plane = i > (ROOMS_PER_PLANE - 1) ? SECOND_FLOOR_PLANE : LOBBY_PLANE;

			x = x - baseX;
			y = y - baseY;

			x = raid.getGridBase().getX() + x * ROOM_MAX_SIZE;
			y = raid.getGridBase().getY() - y * ROOM_MAX_SIZE;

			x = x - wv.getBaseX();
			y = y - wv.getBaseY();

			if (x < (1 - ROOM_MAX_SIZE) || x >= SCENE_SIZE)
			{
				continue;
			}
			else if (x < 1)
			{
				x = 1;
			}

			if (y < 1)
			{
				y = 1;
			}

			Tile tile = wv.getScene().getTiles()[plane][x][y];

			if (tile == null)
			{
				continue;
			}

			RaidRoom room = determineRoom(tile);
			raid.setRoom(room, i);
		}

		return raid;
	}

	private Point findLobbyBase()
	{
		Tile[][] tiles = client.getTopLevelWorldView().getScene().getTiles()[LOBBY_PLANE];

		for (int x = 0; x < SCENE_SIZE; x++)
		{
			for (int y = 0; y < SCENE_SIZE; y++)
			{
				if (tiles[x][y] == null || tiles[x][y].getWallObject() == null)
				{
					continue;
				}

				if (tiles[x][y].getWallObject().getId() == NullObjectID.NULL_12231)
				{
					return tiles[x][y].getSceneLocation();
				}
			}
		}

		return null;
	}

	private RaidRoom determineRoom(Tile base)
	{
		int chunkData = client.getTopLevelWorldView().getInstanceTemplateChunks()[base.getPlane()][(base.getSceneLocation().getX()) / 8][base.getSceneLocation().getY() / 8];
		InstanceTemplates template = InstanceTemplates.findMatch(chunkData);

		if (template == null)
		{
			return RaidRoom.EMPTY;
		}

		switch (template)
		{
			case RAIDS_LOBBY:
			case RAIDS_START:
				return RaidRoom.START;
			case RAIDS_END:
				return RaidRoom.END;
			case RAIDS_SCAVENGERS:
			case RAIDS_SCAVENGERS2:
				return RaidRoom.SCAVENGERS;
			case RAIDS_SHAMANS:
				return RaidRoom.SHAMANS;
			case RAIDS_VASA:
				return RaidRoom.VASA;
			case RAIDS_VANGUARDS:
				return RaidRoom.VANGUARDS;
			case RAIDS_ICE_DEMON:
				return RaidRoom.ICE_DEMON;
			case RAIDS_THIEVING:
				return RaidRoom.THIEVING;
			case RAIDS_FARMING:
			case RAIDS_FARMING2:
				return RaidRoom.FARMING;
			case RAIDS_MUTTADILES:
				return RaidRoom.MUTTADILES;
			case RAIDS_MYSTICS:
				return RaidRoom.MYSTICS;
			case RAIDS_TEKTON:
				return RaidRoom.TEKTON;
			case RAIDS_TIGHTROPE:
				return RaidRoom.TIGHTROPE;
			case RAIDS_GUARDIANS:
				return RaidRoom.GUARDIANS;
			case RAIDS_CRABS:
				return RaidRoom.CRABS;
			case RAIDS_VESPULA:
				return RaidRoom.VESPULA;
			default:
				return RaidRoom.EMPTY;
		}
	}

	private Integer findLobbyIndex(Point gridBase)
	{
		if (Constants.SCENE_SIZE <= gridBase.getX() + ROOM_MAX_SIZE
			|| Constants.SCENE_SIZE <= gridBase.getY() + ROOM_MAX_SIZE)
		{
			return null;
		}
		int x;
		int y;
		Tile[][] tiles = client.getTopLevelWorldView().getScene().getTiles()[LOBBY_PLANE];
		if (tiles[gridBase.getX()][gridBase.getY() + ROOM_MAX_SIZE] == null)
		{
			y = 0;
		}
		else
		{
			y = 1;
		}
		if (tiles[gridBase.getX() + ROOM_MAX_SIZE][gridBase.getY()] == null)
		{
			x = 3;
		}
		else
		{
			for (x = 0; x < 3; x++)
			{
				int sceneX = gridBase.getX() - 1 - ROOM_MAX_SIZE * x;
				if (sceneX < 0 || tiles[sceneX][gridBase.getY()] == null)
				{
					break;
				}
			}
		}

		return x + y * AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
	}
}

package com.partydefencetracker;

import net.runelite.client.ui.overlay.infobox.InfoBox;
import java.awt.*;
import java.awt.image.BufferedImage;

public class RedKerisInfoBox extends InfoBox
{
	private DefenceTrackerPlugin plugin;

	RedKerisInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
	{
		super(image, plugin);
		this.plugin = plugin;
	}

	@Override
	public String getText()
	{
		return String.valueOf(plugin.getRedKerisTicks());
	}

	@Override
	public Color getTextColor()
	{
		return plugin.getRedKerisTicks() <= 3 ? Color.RED : Color.WHITE;
	}
}

package com.partydefencetracker;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.plugins.specialcounter.SpecialWeapon;

import java.util.ArrayList;

@Getter(AccessLevel.PACKAGE)
public class QueuedNpc
{
	public int index;
	public ArrayList<QueuedSpec> queuedSpecs;

	QueuedNpc(int index)
	{
		this.index = index;
		this.queuedSpecs = new ArrayList<>();
	}

	public static class QueuedSpec
	{
		public SpecialWeapon weapon;
		public int hit;

		QueuedSpec(SpecialWeapon weapon, int hit)
		{
			this.weapon = weapon;
			this.hit = hit;
		}
	}
}
/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import com.google.inject.Provides;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.IndexDataBase;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.SpritePixels;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.party.PartyPlugin;
import net.runelite.client.plugins.specialcounter.SpecialCounterUpdate;
import net.runelite.client.plugins.specialcounter.SpecialWeapon;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ObjectUtils;

@PluginDescriptor(
	name = "Party Defence Tracker",
	description = "Calculates the defence based off party specs",
	tags = {"party", "defence", "tracker", "boosting", "special", "counter"}
)
@Slf4j
@PluginDependency(PartyPlugin.class)
public class DefenceTrackerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PartyService partyService;

	@Inject
	private WSClient wsClient;

	@Inject
	private DefenceTrackerConfig config;

	@Inject
	private SkillIconManager skillIconManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private CoXLayoutSolver layoutSolver;

	private static final int COX_SCALED_PARTY_SIZE_VARBIT = 9540;

	private String boss = "";
	private int bossIndex = 0;
	private double bossDef = -1;
	private DefenceInfoBox box = null;
	private VulnerabilityInfoBox vulnBox = null;
	private SpritePixels vuln = null;
	private ShadowBarrageInfoBox shadowBarrageBox = null;
	private SpritePixels shadowBarrage = null;
	private boolean shadowBarrageHit = false;

	private RedKerisInfoBox redKerisBox = null;
	@Getter
	private int redKerisTicks = 0;

	//Copied from special counter
	//Expected tick the hitsplat will happen on
	private int hitsplatTick;
	private Hitsplat lastSpecHitsplat;
	private NPC lastSpecTarget;
	private double lastSpecPercent = -1;

	private boolean hmXarpus = false;
	private boolean bloatDown = false;

	private boolean inCm;
	private boolean coxModeSet = false;

	private QueuedNpc queuedNpc = null;

	private final List<SpecialCounterUpdate> specialList = new ArrayList<>();

	Map<String, ArrayList<Integer>> bossRegions = new HashMap<>()
	{{
		put("The Maiden of Sugadinti", new ArrayList<>(Collections.singletonList(12613)));
		put("Pestilent Bloat", new ArrayList<>(Collections.singletonList(13125)));
		put("Nylocas Vasilias", new ArrayList<>(Collections.singletonList(13122)));
		put("Sotetseg", new ArrayList<>(Arrays.asList(13123, 13379)));
		put("Xarpus", new ArrayList<>(Collections.singletonList(12612)));
		put("Zebak", new ArrayList<>(Collections.singletonList(15700)));
		put("Kephri", new ArrayList<>(Collections.singletonList(14164)));
		put("Ba-Ba", new ArrayList<>(Collections.singletonList(15188)));
		put("Akkha", new ArrayList<>(Collections.singletonList(14676)));
		put("Akkha's Shadow", new ArrayList<>(Collections.singletonList(14676)));
		put("<col=00ffff>Obelisk</col>", new ArrayList<>(Collections.singletonList(15184)));
		put("Tumeken's Warden", new ArrayList<>(Collections.singletonList(15696)));
		put("Elidinis' Warden", new ArrayList<>(Collections.singletonList(15696)));
		put("<col=00ffff>Core</col>", new ArrayList<>(Arrays.asList(15184, 15696)));
		put("Alchemical Hydra", new ArrayList<>(Collections.singletonList(5536)));
		put("Nex", new ArrayList<>(Collections.singletonList(11601)));
		put("Phantom Muspah", new ArrayList<>(Collections.singletonList(11330)));
		put("Skotizo", new ArrayList<>(Collections.singletonList(9048)));
		put("TzKal-Zuk", new ArrayList<>(Collections.singletonList(9043)));
		put("TzTok-Jad", new ArrayList<>(Collections.singletonList(9551)));
		put("Vorkath", new ArrayList<>(Collections.singletonList(9023)));
		put("Yama", new ArrayList<>(Collections.singletonList(6045)));
		put("Zulrah", new ArrayList<>(Arrays.asList(9007, 9008)));
	}};

	private final Set<String> coxBosses = new HashSet<>(List.of("Abyssal portal", "Deathly mage", "Deathly ranger", "Great Olm", "Great Olm (Left claw)", "Great Olm (Right claw", "Ice demon", "Skeletal Mystic", "Tekton", "Vasa Nistirio", "Lizardman shaman"));
  	private final Set<String> coxBossesSpecialOffensiveScaling = new HashSet<>(List.of("Abyssal portal", "Deathly ranger"));

	@Provides
	DefenceTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DefenceTrackerConfig.class);
	}

	protected void startUp() throws Exception
	{
		reset();
		enableRequiredPlugins("Party");
		enableRequiredPlugins("Special Attack Counter");
		wsClient.registerMessage(DefenceTrackerUpdate.class);
	}

	protected void shutDown() throws Exception
	{
		reset();
		wsClient.unregisterMessage(DefenceTrackerUpdate.class);
	}

	protected void reset()
	{
		infoBoxManager.removeInfoBox(box);
		infoBoxManager.removeInfoBox(vulnBox);
		infoBoxManager.removeInfoBox(redKerisBox);
		infoBoxManager.removeInfoBox(shadowBarrageBox);
		boss = "";
		bossIndex = 0;
		bossDef = -1;
		box = null;
		vulnBox = null;
		vuln = null;
		redKerisBox = null;
		redKerisTicks = 0;
		shadowBarrageBox = null;
		shadowBarrage = null;
		shadowBarrageHit = false;
		bloatDown = false;
		queuedNpc = null;
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		int animation = e.getActor().getAnimation();

		if (e.getActor() instanceof Player && e.getActor() != null && client.getLocalPlayer() != null && e.getActor().getName() != null)
		{
			if (e.getActor().getName().equals(client.getLocalPlayer().getName()))
			{
				if (animation == 1816 && boss.equalsIgnoreCase("sotetseg") && inBossRegion())
				{
					infoBoxManager.removeInfoBox(box);
					bossDef = 200;
				}
			}
		}

		if (e.getActor() instanceof NPC && e.getActor().getName() != null)
		{
			if (e.getActor().getName().equalsIgnoreCase("pestilent bloat"))
			{
				bloatDown = animation == 8082;
			}
			//Enraged Wardens
			else if (animation == 9685 && (boss.equalsIgnoreCase("Tumeken's Warden") || boss.equalsIgnoreCase("Elidinis' Warden")))
			{
				infoBoxManager.removeInfoBox(box);
				bossDef = 60;
			}
		}
	}

	private void processSpecialAttack(SpecialCounterUpdate e)
	{
		int hit = e.getHit();
		int world = e.getWorld();
		SpecialWeapon weapon = e.getWeapon();
		int index = e.getNpcIndex();
		NPC npc = client.getTopLevelWorldView().npcs().byIndex(index);

		clientThread.invoke(() ->
		{
			if ((npc != null && npc.getName() != null && BossInfo.getBoss(npc.getName()) != null) || bossIndex == index)
			{
				if (bossIndex != index)
				{
					String bossName = npc.getName();

					if (!boss.equalsIgnoreCase(bossName) || (bossName.contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
					{
						baseDefence(bossName, index);
						calculateQueue(index);
					}
				}

				if (inBossRegion() && world == client.getWorld())
				{
					calculateDefence(weapon, hit);
					updateDefInfobox();
				}
			}
			else
			{
				if (queuedNpc == null || queuedNpc.index != index)
				{
					queuedNpc = new QueuedNpc(index);
				}
				queuedNpc.queuedSpecs.add(new QueuedNpc.QueuedSpec(weapon, hit));
			}
		});
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		for (SpecialCounterUpdate specialCounterUpdate : specialList)
		{
			processSpecialAttack(specialCounterUpdate);
		}
		specialList.clear();
		if (partyService.isInParty())
		{
			for (NPC n : client.getTopLevelWorldView().npcs())
			{
				if (n != null && n.getName() != null && (n.getName().equalsIgnoreCase(boss) || (n.getName().contains("Tekton") && boss.equalsIgnoreCase("Tekton")))
					&& (n.isDead() || n.getHealthRatio() == 0))
				{
					partyService.send(new DefenceTrackerUpdate(n.getName(), n.getIndex(), false, client.getWorld(), ""));
				}
			}
		}

		layoutSolver.onGameTick(e);

		if (!coxModeSet && client.getVarbitValue(Varbits.IN_RAID) == 1)
		{
			inCm = layoutSolver.isCM();
			coxModeSet = true;
		}

		if (redKerisTicks > 0)
		{
			redKerisTicks--;
			if (redKerisTicks == 0)
			{
				infoBoxManager.removeInfoBox(redKerisBox);
			}
		}

		//Copied from special counter
		if (lastSpecHitsplat != null && lastSpecTarget != null)
		{
			if (lastSpecHitsplat.getAmount() > 0 && partyService.isInParty())
			{
				partyService.send(new DefenceTrackerUpdate(lastSpecTarget.getName(), lastSpecTarget.getIndex(), true, client.getWorld(), "keris"));
			}
			lastSpecHitsplat = null;
			lastSpecTarget = null;
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e)
	{
		Actor target = e.getActor();
		Hitsplat hitsplat = e.getHitsplat();
		if (hitsplat.isMine() && target instanceof NPC && lastSpecTarget != null && hitsplatTick == client.getTickCount())
		{
			NPC npc = (NPC) target;
			String name = npc.getName();
			if (name != null && (BossInfo.getBoss(name) != null || bossIndex == npc.getIndex()))
			{
				// The weapon hitsplat is always last, after other hitsplats which occur on the same tick such as from venge or thralls.
				lastSpecHitsplat = hitsplat;
			}
		}
	}


	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		NPC npc = e.getNpc();
		if (npc.getName() != null && BossInfo.getBoss(npc.getName()) != null)
		{
			hmXarpus = npc.getId() >= 10770 && npc.getId() <= 10772;
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath e)
	{
		if (e.getActor() instanceof NPC && e.getActor().getName() != null && client.getLocalPlayer() != null && partyService.isInParty())
		{
			if (e.getActor().getName().equalsIgnoreCase(boss) || (e.getActor().getName().contains("Tekton") && boss.equalsIgnoreCase("Tekton")))
			{
				partyService.send(new DefenceTrackerUpdate(e.getActor().getName(), ((NPC) e.getActor()).getIndex(), false, client.getWorld(), ""));
			}
		}
	}

	@Subscribe
	public void onSpecialCounterUpdate(SpecialCounterUpdate e)
	{
		if (e.getWeapon() == SpecialWeapon.ELDER_MAUL)
		{
			specialList.add(0, e);
		}
		else
		{
			specialList.add(e);
		}
	}

	@Subscribe
	public void onDefenceTrackerUpdate(DefenceTrackerUpdate e)
	{
		int world = e.getWorld();
		clientThread.invoke(() ->
		{
			if (!e.isAlive())
			{
				reset();
			}
			else
			{
				if (inBossRegion() && world == client.getWorld())
				{
					if (e.getWeapon().equals("vuln"))
					{
						if (!boss.equalsIgnoreCase(e.getBoss()) || (e.getBoss().contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
						{
							baseDefence(e.getBoss(), e.getIndex());
							calculateQueue(e.getIndex());
						}

						if (config.vulnerability())
						{
							infoBoxManager.removeInfoBox(vulnBox);
							IndexDataBase sprite = client.getIndexSprites();
							vuln = Objects.requireNonNull(client.getSprites(sprite, 56, 0))[0];
							vulnBox = new VulnerabilityInfoBox(vuln.toBufferedImage(), this);
							vulnBox.setTooltip(ColorUtil.wrapWithColorTag(Text.removeTags(boss), Color.WHITE));
							infoBoxManager.addInfoBox(vulnBox);
						}
						bossDef -= bossDef * .1;

						updateDefInfobox();
					}
					else if (e.getWeapon().equals("keris"))
					{
						redKerisTicks = 9;
						if (config.redKeris())
						{
							infoBoxManager.removeInfoBox(redKerisBox);
							redKerisBox = new RedKerisInfoBox(itemManager.getImage(ItemID.KERIS_PARTISAN_OF_CORRUPTION), this);
							redKerisBox.setTooltip(ColorUtil.wrapWithColorTag(e.getBoss(), Color.WHITE));
							infoBoxManager.addInfoBox(redKerisBox);
						}
					} else if (e.getWeapon().equals("shadowBarrage") && !shadowBarrageHit)
					{
						if (!boss.equalsIgnoreCase(e.getBoss()) || (e.getBoss().contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
						{
							baseDefence(e.getBoss(), e.getIndex());
							calculateQueue(e.getIndex());
						}

						if (config.shadowBarrage())
						{
							infoBoxManager.removeInfoBox(shadowBarrageBox);
							shadowBarrageBox = new ShadowBarrageInfoBox(itemManager.getImage(ItemID.SHADOW_ANCIENT_SCEPTRE), this);
							shadowBarrageBox.setTooltip(ColorUtil.wrapWithColorTag(e.getBoss(), Color.WHITE));
							infoBoxManager.addInfoBox(shadowBarrageBox);
						}
						shadowBarrageHit = true; // non-stackable reduction
						bossDef -= bossDef * .15;

						updateDefInfobox();
					}
				}
			}
		});
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION)
		{
			if (Text.removeTags(event.getMessage()).equals("The raid has begun!") && client.getVarbitValue(Varbits.IN_RAID) == 1)
			{
				// Determine if in challege mode or regular
				inCm = layoutSolver.isCM();
				coxModeSet = true;
			}
		}
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged e)
	{
		if (!inBossRegion())
		{
			reset();
		}

		if (client.getVarbitValue(Varbits.IN_RAID) != 1 && isInCoxLobby())
		{
			inCm = false;
			coxModeSet = false;
		}

		layoutSolver.onVarbitChanged(e);

		//Copied from special counter plugin
		if (e.getVarpId() == VarPlayer.SPECIAL_ATTACK_PERCENT)
		{
			if (client.getLocalPlayer() != null && client.getLocalPlayer().getPlayerComposition() != null)
			{
				int weapon = client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON);
				if (weapon == ItemID.KERIS_PARTISAN_OF_CORRUPTION && (e.getValue() == lastSpecPercent - 750 || e.getValue() == lastSpecPercent - 375))
				{
					// This event runs prior to player and npc updating, making getInteracting() too early to call..
					// defer this with invokeLater(), but note that this will run after incrementing the server tick counter
					// so we capture the current server tick counter here for use in computing the final hitsplat tick
					final int serverTicks = client.getTickCount();
					clientThread.invokeLater(() ->
					{
						Actor target = client.getLocalPlayer().getInteracting();
						lastSpecTarget = target instanceof NPC ? (NPC) target : null;
						hitsplatTick = serverTicks + 1; //red keris has hit delay 1
					});
				}
			}
			lastSpecPercent = e.getValue();
		}
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged e)
	{
		if (!(e.getActor() instanceof NPC) || e.getActor().getName() == null || !partyService.isInParty())
		{
			return;
		}

		NPC npc = (NPC) e.getActor();

		BossInfo bossName = BossInfo.getBoss(npc.getName());
		if (bossName == null)
		{
			return;
		}

		final int VULNERABILITY_SPOT_ANIM = 169;
		final int SHADOW_SCEPTRE_SPOT_ANIM = 383;
		final int SHADOW_SCEPTRE_ID = ItemID.SHADOW_ANCIENT_SCEPTRE_28266;

		if (npc.hasSpotAnim(VULNERABILITY_SPOT_ANIM))
		{
			partyService.send(new DefenceTrackerUpdate(npc.getName(), npc.getIndex(), true, client.getWorld(), "vuln"));
		}
		else if (npc.hasSpotAnim(SHADOW_SCEPTRE_SPOT_ANIM))
		{
			int equippedWeapon = ObjectUtils.defaultIfNull(
					client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON), -1
			);
			if (equippedWeapon == SHADOW_SCEPTRE_ID)
			{
				partyService.send(new DefenceTrackerUpdate(npc.getName(), npc.getIndex(), true, client.getWorld(), "shadowBarrage"));
			}
		}
	}



	@Subscribe
	protected void onGameStateChanged(GameStateChanged e)
	{
		layoutSolver.onGameStateChanged(e);
	}

	private void baseDefence(String bossName, int index)
	{
		boss = bossName;
		bossIndex = index;
		bossDef = BossInfo.getBaseDefence(boss);

		if (boss.equalsIgnoreCase("Xarpus") && hmXarpus)
		{
			bossDef = 200;
		}
		else if (coxBosses.contains(boss))
		{
			bossDef = getCoxScaledDefenceLevel(bossName, (int) bossDef);
		}
	}

	private int getCoxScaledDefenceLevel(String bossName, int baseDef)
	{
		int partySize = getCoxPartySize();
		baseDef = (int) (baseDef * (((int) Math.sqrt(partySize - 1) + ((partySize - 1) * 7 / 10 + 100)) / 100.0));
		if (inCm)
		{
			baseDef = (int) (baseDef * (bossName.contains("Tekton") ? partySize > 3 ? 1.35 : 1.2 : 1.5));
		}
		return baseDef;
	}

	private int getScaledMagicLevel()
	{
		int scaledMagicLevel = (int) BossInfo.getBaseMagic(boss);
		if (coxBosses.contains(boss))
		{
			int partySize = getCoxPartySize();
			if (coxBossesSpecialOffensiveScaling.contains(boss))
			{
				scaledMagicLevel = (int) (scaledMagicLevel * (((int) Math.sqrt(partySize - 1) + ((partySize - 1) * 7 / 10 + 100)) / 100.0));
			}
			else
			{
				scaledMagicLevel = scaledMagicLevel * (((int) (Math.sqrt(partySize - 1))) * 7 + partySize + 99) / 100;
			}
			if (inCm)
			{
				scaledMagicLevel = (int) (1.5 * scaledMagicLevel);
			}
		}
		return scaledMagicLevel;
	}

	private void calculateDefence(SpecialWeapon weapon, int hit)
	{
		switch (weapon)
		{
			case DRAGON_WARHAMMER:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= bossDef * .05;
					}
				}
				else
				{
					bossDef -= bossDef * .30;
				}
				break;
			case ELDER_MAUL:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= bossDef * .05;
					}
				}
				else
				{
					bossDef -= bossDef * .35;
				}
				break;
			case BANDOS_GODSWORD:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= 10;
					}
				}
				else
				{
					if (boss.equalsIgnoreCase("Corporeal Beast") || (inBossRegion() && boss.equalsIgnoreCase("Pestilent Bloat") && !bloatDown))
					{
						bossDef -= hit * 2;
					}
					else
					{
						bossDef -= hit;
					}
				}
				break;
			case ARCLIGHT:
			case DARKLIGHT:
				if (hit > 0)
				{
					if (boss.equalsIgnoreCase("K'ril Tsutsaroth") || boss.equalsIgnoreCase("Abyssal Sire") || boss.equalsIgnoreCase("Yama"))
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .10;
					}
					else
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .05;
					}
				}
				break;
			case EMBERLIGHT:
				if (hit > 0)
				{
					if (boss.equalsIgnoreCase("K'ril Tsutsaroth") || boss.equalsIgnoreCase("Abyssal Sire") || boss.equalsIgnoreCase("Yama"))
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .15;
					}
					else
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .05;
					}
				}
				break;
			case BARRELCHEST_ANCHOR:
				bossDef -= hit * .10;
				break;
			case BONE_DAGGER:
			case DORGESHUUN_CROSSBOW:
				if (bossDef >= BossInfo.getBaseDefence(boss))
				{
					bossDef -= hit;
				}
				break;
			case ACCURSED_SCEPTRE:
				if (hit > 0)
				{
					if (bossDef > (BossInfo.getBaseDefence(boss) * .85))
					{
						bossDef = BossInfo.getBaseDefence(boss) * .85;
					}
				}
				break;
			case TONALZTICS_OF_RALOS:
				for (int i = 0; i < hit; i++)
				{
					bossDef -= (int) (getScaledMagicLevel() * .1);
				}
				break;
		}

		BossInfo bossInfo = BossInfo.getBoss(boss);

		bossDef = Math.max(bossDef, (bossInfo != null ? bossInfo.getMinDef() : 0));
	}

	private void calculateQueue(int index)
	{
        if (queuedNpc == null)
		{
            return;
        }

        if (queuedNpc.index != index)
		{
			queuedNpc = null;
			return;
		}

		for (QueuedNpc.QueuedSpec spec : queuedNpc.queuedSpecs)
		{
			calculateDefence(spec.weapon, spec.hit);
		}

        queuedNpc = null;
    }

	private void updateDefInfobox()
	{
		infoBoxManager.removeInfoBox(box);

		BossInfo bossInfo = BossInfo.getBoss(boss);

		box =
			new DefenceInfoBox(
				skillIconManager.getSkillImage(Skill.DEFENCE),
				this,
				(bossInfo != null ? Math.round(bossInfo.getMinDef()) : 0),
				Math.round(bossDef),
				config
			);

		box.setTooltip(ColorUtil.wrapWithColorTag(boss, Color.WHITE));
		infoBoxManager.addInfoBox(box);
	}

	private boolean inBossRegion()
	{
		if (client.getLocalPlayer() != null && bossRegions.containsKey(boss))
		{
			WorldPoint wp = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
			if (wp != null)
			{
				return bossRegions.get(boss).contains(wp.getRegionID());
			}
		}
		return client.getVarbitValue(Varbits.IN_RAID) == 1 || !coxBosses.contains(boss);
	}

	public boolean isInCoxLobby()
	{
		int[] regions = client.getTopLevelWorldView().getMapRegions();
		return regions != null && regions.length > 0 && Arrays.stream(regions).anyMatch((s) -> s == 4919);
	}

	private int getCoxPartySize()
	{
		return client.getVarbitValue(COX_SCALED_PARTY_SIZE_VARBIT);
	}

	public void enableRequiredPlugins(String pluginName)
	{
		try
		{
			final Optional<Plugin> plugin = pluginManager.getPlugins().stream().filter(p -> p.getName().equals(pluginName)).findFirst();
			if (plugin.isPresent() && !pluginManager.isPluginEnabled(plugin.get()))
			{
				pluginManager.setPluginEnabled(plugin.get(), true);
				pluginManager.startPlugin(plugin.get());
			}
		}
		catch (PluginInstantiationException ex)
		{
			log.error("error starting " + pluginName + " plugin", ex);
		}
	}
}

package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import net.runelite.client.ui.overlay.infobox.InfoBox;

public class ShadowBarrageInfoBox extends InfoBox
{
    private DefenceTrackerPlugin plugin;

    ShadowBarrageInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
    {
        super(image, plugin);
        this.plugin = plugin;
    }

    public String getText()
    {
        return null;
    }

    public Color getTextColor()
    {
        return Color.WHITE;
    }
}

package com.partydefencetracker;

import lombok.Getter;

enum BossInfo
{
	ABYSSAL_PORTAL("Abyssal portal", 176, 176, 0),
	ABYSSAL_SIRE("Abyssal Sire", 250, 200, 0),
	AKKHA("Akkha", 80, 100, 0),
	AKKHAS_SHADOW("Akkha's Shadow", 30, 100, 0),
	ALCHEMICAL_HYDRA("Alchemical Hydra", 100, 260, 0),
	ARTIO("Artio", 150, 90, 0),
	BA_BA("Ba-Ba", 80, 100, 60),
	CALLISTO("Callisto", 225, 140, 0),
	CALVARION("Calvar'ion", 225, 178, 0),
	CERBERUS("Cerberus", 110, 220, 0),
	CHAOS_ELEMENTAL("Chaos Elemental", 270, 270, 0),
	COMMANDER_ZILYANA("Commander Zilyana", 300, 300, 0),
	CORE("<col=00ffff>Core</col>", 0, 0, 0),
	CORPOREAL_BEAST("Corporeal Beast", 310, 350, 0),
	DAGANNOTH_PRIME("Dagannoth Prime", 255, 255, 0),
	DAGANNOTH_REX("Dagannoth Rex", 255, 0, 0),
	DAGANNOTH_SUPREME("Dagannoth Supreme", 128, 244, 0),
	DEATHLY_MAGE("Deathly mage", 155, 210, 0),
	DEATHLY_RANGER("Deathly ranger", 155, 155, 0),
	ELIDINIS_WARDEN("Elidinis' Warden", 150, 190, 120),
	GENERAL_GRAARDOR("General Graardor", 250, 150, 0),
	GIANT_MOLE("Giant Mole", 200, 200, 0),
	GREAT_OLM("Great Olm", 150, 250, 0),
	GREAT_OLM_LEFT_CLAW("Great Olm (Left claw)", 175, 175, 0),
	GREAT_OLM_RIGHT_CLAW("Great Olm (Right claw)", 175, 87, 0),
	ICE_DEMON("Ice Demon", 160, 390, 0),
	KALPHITE_QUEEN("Kalphite Queen", 300, 150, 0),
	KEPHRI("Kephri", 80, 125, 60),
	KING_BLACK_DRAGON("King Black Dragon", 240, 240, 0),
	KREE_ARRA("Kree'arra", 260, 200, 0),
	KRIL_TSUTSAROTH("K'ril Tsutsaroth", 270, 200, 0),
	LIZARDMAN_SHAMAN("Lizardman shaman", 210, 130, 0),
	NEX("Nex", 260, 230, 0),
	NYLOCAS_VASILIAS("Nylocas Vasilias", 50, 50, 0),
	OBELISK("<col=00ffff>Obelisk</col>", 100, 100, 60),
	PESTILENT_BLOAT("Pestilent Bloat", 100, 150, 0),
	PHANTOM_MUSPAH("Phantom Muspah", 200, 150, 0), //180 shielded
	SARACHNIS("Sarachnis", 150, 150, 0),
	SCORPIA("Scorpia", 180, 1, 0),
	SKELETAL_MYSTIC("Skeletal Mystic", 187, 140, 0),
	SKOTIZO("Skotizo", 200, 280, 0),
	SOTETSEG("Sotetseg", 200, 250, 100),
	SPINDEL("Spindel", 225, 235, 0),
	TEKTON("Tekton", 205, 205, 0),
	TEKTON_ENRAGED("Tekton (enraged)", 205, 205, 0),
	THE_MAIDEN_OF_SUGADINTI("The Maiden of Sugadinti", 200, 350, 0),
	TUMEKENS_WARDEN("Tumeken's Warden", 150, 190, 120),
	TZKAL_ZUK("TzKal-Zuk", 260, 150, 0),
	TZTOK_JAD("TzTok-Jad", 480, 480, 0),
	VASA("Vasa Nistirio", 175, 230, 0),
	VENENATIS("Venenatis", 321, 300, 0),
	VETION("Vet'ion", 395, 300, 0),
	VORKATH("Vorkath", 214, 150, 0),
	XARPUS("Xarpus", 250, 22, 0),
	YAMA("Yama", 225, 250, 145),
	ZEBAK("Zebak", 70, 100, 50),
	ZULRAH("Zulrah", 300, 30, 0);

	@Getter
	private final String name;
	@Getter
	private final double baseDef;
	@Getter
	private final double baseMagic;
	@Getter
	private final double minDef;

	BossInfo(String name, double baseDef, double baseMagic, double minDef)
	{
		this.name = name;
		this.baseDef = baseDef;
		this.baseMagic = baseMagic;
		this.minDef = minDef;
	}

	static BossInfo getBoss(String bossName)
	{
		for (BossInfo boss : values())
		{
			if (boss.name.contains(bossName))
			{
				return boss;
			}
		}
		return null;
	}

	static double getBaseDefence(String bossName)
	{
		BossInfo boss = getBoss(bossName);
		if (boss != null)
		{
			return boss.baseDef;
		}
		return 0;
	}

	static double getBaseMagic(String bossName)
	{
		BossInfo boss = getBoss(bossName);
		if(boss != null)
		{
			return boss.baseMagic;
		}
		return 0;
	}
}

package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import net.runelite.client.ui.overlay.infobox.InfoBox;

public class VulnerabilityInfoBox extends InfoBox
{
	private DefenceTrackerPlugin plugin;

	VulnerabilityInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
	{
		super(image, plugin);
		this.plugin = plugin;
	}

	public String getText()
	{
		return null;
	}

	public Color getTextColor()
	{
		return Color.WHITE;
	}
}

package com.partydefencetracker;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DefenceTrackerUpdate extends PartyMemberMessage
{
	String boss;
	int index;
	boolean alive;
	int world;
	String weapon;
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("defencetracker")
public interface DefenceTrackerConfig extends Config
{
	@ConfigItem(
			name = "Low Defence Threshold",
			keyName = "lowDef",
			description = "Sets when you want the defence to appear as low defence",
			position = 1
	)
	default int lowDef()
	{
		return 10;
	}

	@ConfigItem(
		name = "High Defence Color",
		keyName = "highDefColor",
		description = "Color of the infobox text when the defence is above the low defence threshold",
		position = 2
	)
	default Color highDefColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		name = "Low Defence Color",
		keyName = "lowDefColor",
		description = "Color of the infobox text when the defence is beneath the low defence threshold",
		position = 3
	)
	default Color lowDefColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		name = "Capped Defence Color",
		keyName = "cappedDefColor",
		description = "Color of the infobox text when the defence is at the lowest possible amount for that NPC",
		position = 4
	)
	default Color cappedDefColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "disableIBColor",
		name = "Disable Infobox Text Color",
		description = "Defence infobox text will always be set to White",
		position = 5
	)
	default boolean disableIBColor()
	{
		return false;
	}

	@ConfigItem(
			keyName = "vulnerability",
			name = "Show Vulnerability",
			description = "Displays an infobox when you successfully land vulnerability",
			position = 6
	)
	default boolean vulnerability()
	{
		return true;
	}

	@ConfigItem(
			keyName = "shadowBarrage",
			name = "Show Shadow Barrage",
			description = "Displays an infobox when you successfully land a shadow barrage whilst wearing the shadow ancient sceptre",
			position = 7
	)
	default boolean shadowBarrage() { return true; }

	@ConfigItem(
		keyName = "redKeris",
		name = "Show Red Keris",
		description = "Displays an infobox when you successfully land a Red Keris (Corruption) special attack",
		position = 8
	)
	default boolean redKeris()
	{
		return true;
	}

	@ConfigItem(
			name = "Display full defence level",
			keyName = "displayFullDefence",
			description = "For NPCs with a minimum defence, display their full defence level instead of the reduction relative to their minimum",
			position = 9
	)
	default boolean displayFullDefenceLevel() { return false; }
}

package com.partydefencetracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DefenceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
