package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import javax.inject.Inject;

@ToString
public class DefenceInfoBox extends InfoBox
{
    @Inject
    private final DefenceTrackerConfig config;

    @Getter
    @Setter
    private long count;

    public DefenceInfoBox(BufferedImage image, Plugin plugin, long count, DefenceTrackerConfig config)
    {
        super(image, plugin);
        this.count = count;
        this.config = config;
    }

    @Override
    public String getText()
    {
        return Long.toString(getCount());
    }

    @Override
    public Color getTextColor()
    {
		if (config.disableIBColor())
		{
			return Color.WHITE;
		}
		else
		{
			if (count == 0)
			{
				return config.cappedDefColor();
			}
			else if (count >= 1 && count <= config.lowDef())
			{
				return config.lowDefColor();
			}
			else
			{
				return config.highDefColor();
			}
		}
    }
}
/*
 * Copyright (c) 2022, l2- <https://github.com/l2->
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.InstanceTemplates;
import net.runelite.api.NullObjectID;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.plugins.raids.Raid;
import net.runelite.client.plugins.raids.RaidRoom;

import javax.inject.Inject;
import javax.inject.Singleton;

import static net.runelite.api.Perspective.SCENE_SIZE;

// Mostly copied from the core RaidsPlugin
@Slf4j
@Singleton
public class CoXLayoutSolver
{
	static final int ROOM_MAX_SIZE = 32;
	private static final int LOBBY_PLANE = 3;
	private static final int SECOND_FLOOR_PLANE = 2;
	private static final int ROOMS_PER_PLANE = 8;
	private static final int AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE = 4;
	private static final WorldPoint TEMP_LOCATION = new WorldPoint(3360, 5152, 2);
	private static final String CM_RAID_CODE = "SPCFPC#Â¤CFP SPC#";

	private final Client client;
	boolean checkInRaid;
	private boolean loggedIn;
	private boolean inRaidChambers;
	private int raidPartyID;
	@Getter
	private Raid raid;

	@Inject
	public CoXLayoutSolver(Client client)
	{
		this.client = client;
	}

	public boolean isCM()
	{
		return raid != null && CM_RAID_CODE.equals(raid.toCode());
	}

	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarpId() == VarPlayer.IN_RAID_PARTY)
		{
			boolean tempInRaid = client.getVarbitValue(Varbits.IN_RAID) == 1;
			if (loggedIn && !tempInRaid)
			{
				raid = null;
			}

			raidPartyID = event.getValue();
		}

		if (event.getVarbitId() == Varbits.IN_RAID)
		{
			boolean tempInRaid = event.getValue() == 1;
			if (tempInRaid && loggedIn)
			{
				checkRaidPresence();
			}

			inRaidChambers = tempInRaid;
		}
	}

	public void onGameTick(GameTick event)
	{
		if (checkInRaid)
		{
			loggedIn = true;
			checkInRaid = false;

			if (inRaidChambers)
			{
				checkRaidPresence();
			}
			else
			{
				if (raidPartyID == -1)
				{
					raid = null;
				}
			}
		}
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			if (client.getLocalPlayer() == null
				|| client.getLocalPlayer().getWorldLocation().equals(TEMP_LOCATION))
			{
				return;
			}

			checkInRaid = true;
		}
		else if (client.getGameState() == GameState.LOGIN_SCREEN
			|| client.getGameState() == GameState.CONNECTION_LOST)
		{
			loggedIn = false;
		}
		else if (client.getGameState() == GameState.HOPPING)
		{
			raid = null;
		}
	}

	private void checkRaidPresence()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		inRaidChambers = client.getVarbitValue(Varbits.IN_RAID) == 1;

		if (!inRaidChambers)
		{
			return;
		}

		raid = buildRaid(raid);
	}

	private Raid buildRaid(Raid from)
	{
		WorldView wv = client.getTopLevelWorldView();
		Raid raid = from;

		if (raid == null)
		{
			Point gridBase = findLobbyBase();

			if (gridBase == null)
			{
				return null;
			}

			Integer lobbyIndex = findLobbyIndex(gridBase);

			if (lobbyIndex == null)
			{
				return null;
			}

			raid = new Raid(
				new WorldPoint(wv.getBaseX() + gridBase.getX(), wv.getBaseY() + gridBase.getY(), LOBBY_PLANE),
				lobbyIndex
			);
		}

		int baseX = raid.getLobbyIndex() % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
		int baseY = raid.getLobbyIndex() % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;

		for (int i = 0; i < raid.getRooms().length; i++)
		{
			int x = i % AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
			int y = i % ROOMS_PER_PLANE > (AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE - 1) ? 1 : 0;
			int plane = i > (ROOMS_PER_PLANE - 1) ? SECOND_FLOOR_PLANE : LOBBY_PLANE;

			x = x - baseX;
			y = y - baseY;

			x = raid.getGridBase().getX() + x * ROOM_MAX_SIZE;
			y = raid.getGridBase().getY() - y * ROOM_MAX_SIZE;

			x = x - wv.getBaseX();
			y = y - wv.getBaseY();

			if (x < (1 - ROOM_MAX_SIZE) || x >= SCENE_SIZE)
			{
				continue;
			}
			else if (x < 1)
			{
				x = 1;
			}

			if (y < 1)
			{
				y = 1;
			}

			Tile tile = wv.getScene().getTiles()[plane][x][y];

			if (tile == null)
			{
				continue;
			}

			RaidRoom room = determineRoom(tile);
			raid.setRoom(room, i);
		}

		return raid;
	}

	private Point findLobbyBase()
	{
		Tile[][] tiles = client.getTopLevelWorldView().getScene().getTiles()[LOBBY_PLANE];

		for (int x = 0; x < SCENE_SIZE; x++)
		{
			for (int y = 0; y < SCENE_SIZE; y++)
			{
				if (tiles[x][y] == null || tiles[x][y].getWallObject() == null)
				{
					continue;
				}

				if (tiles[x][y].getWallObject().getId() == NullObjectID.NULL_12231)
				{
					return tiles[x][y].getSceneLocation();
				}
			}
		}

		return null;
	}

	private RaidRoom determineRoom(Tile base)
	{
		int chunkData = client.getTopLevelWorldView().getInstanceTemplateChunks()[base.getPlane()][(base.getSceneLocation().getX()) / 8][base.getSceneLocation().getY() / 8];
		InstanceTemplates template = InstanceTemplates.findMatch(chunkData);

		if (template == null)
		{
			return RaidRoom.EMPTY;
		}

		switch (template)
		{
			case RAIDS_LOBBY:
			case RAIDS_START:
				return RaidRoom.START;
			case RAIDS_END:
				return RaidRoom.END;
			case RAIDS_SCAVENGERS:
			case RAIDS_SCAVENGERS2:
				return RaidRoom.SCAVENGERS;
			case RAIDS_SHAMANS:
				return RaidRoom.SHAMANS;
			case RAIDS_VASA:
				return RaidRoom.VASA;
			case RAIDS_VANGUARDS:
				return RaidRoom.VANGUARDS;
			case RAIDS_ICE_DEMON:
				return RaidRoom.ICE_DEMON;
			case RAIDS_THIEVING:
				return RaidRoom.THIEVING;
			case RAIDS_FARMING:
			case RAIDS_FARMING2:
				return RaidRoom.FARMING;
			case RAIDS_MUTTADILES:
				return RaidRoom.MUTTADILES;
			case RAIDS_MYSTICS:
				return RaidRoom.MYSTICS;
			case RAIDS_TEKTON:
				return RaidRoom.TEKTON;
			case RAIDS_TIGHTROPE:
				return RaidRoom.TIGHTROPE;
			case RAIDS_GUARDIANS:
				return RaidRoom.GUARDIANS;
			case RAIDS_CRABS:
				return RaidRoom.CRABS;
			case RAIDS_VESPULA:
				return RaidRoom.VESPULA;
			default:
				return RaidRoom.EMPTY;
		}
	}

	private Integer findLobbyIndex(Point gridBase)
	{
		if (Constants.SCENE_SIZE <= gridBase.getX() + ROOM_MAX_SIZE
			|| Constants.SCENE_SIZE <= gridBase.getY() + ROOM_MAX_SIZE)
		{
			return null;
		}
		int x;
		int y;
		Tile[][] tiles = client.getTopLevelWorldView().getScene().getTiles()[LOBBY_PLANE];
		if (tiles[gridBase.getX()][gridBase.getY() + ROOM_MAX_SIZE] == null)
		{
			y = 0;
		}
		else
		{
			y = 1;
		}
		if (tiles[gridBase.getX() + ROOM_MAX_SIZE][gridBase.getY()] == null)
		{
			x = 3;
		}
		else
		{
			for (x = 0; x < 3; x++)
			{
				int sceneX = gridBase.getX() - 1 - ROOM_MAX_SIZE * x;
				if (sceneX < 0 || tiles[sceneX][gridBase.getY()] == null)
				{
					break;
				}
			}
		}

		return x + y * AMOUNT_OF_ROOMS_PER_X_AXIS_PER_PLANE;
	}
}

package com.partydefencetracker;

import net.runelite.client.ui.overlay.infobox.InfoBox;
import java.awt.*;
import java.awt.image.BufferedImage;

public class RedKerisInfoBox extends InfoBox
{
	private DefenceTrackerPlugin plugin;

	RedKerisInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
	{
		super(image, plugin);
		this.plugin = plugin;
	}

	@Override
	public String getText()
	{
		return String.valueOf(plugin.getRedKerisTicks());
	}

	@Override
	public Color getTextColor()
	{
		return plugin.getRedKerisTicks() <= 3 ? Color.RED : Color.WHITE;
	}
}

package com.partydefencetracker;

import lombok.AccessLevel;
import lombok.Getter;
import net.runelite.client.plugins.specialcounter.SpecialWeapon;

import java.util.ArrayList;

@Getter(AccessLevel.PACKAGE)
public class QueuedNpc
{
	public int index;
	public ArrayList<QueuedSpec> queuedSpecs;

	QueuedNpc(int index)
	{
		this.index = index;
		this.queuedSpecs = new ArrayList<>();
	}

	public static class QueuedSpec
	{
		public SpecialWeapon weapon;
		public int hit;

		QueuedSpec(SpecialWeapon weapon, int hit)
		{
			this.weapon = weapon;
			this.hit = hit;
		}
	}
}
/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import com.google.inject.Provides;
import java.awt.Color;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.IndexDataBase;
import net.runelite.api.ItemID;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.SpritePixels;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GraphicChanged;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SkillIconManager;
import net.runelite.client.party.PartyService;
import net.runelite.client.party.WSClient;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.plugins.party.PartyPlugin;
import net.runelite.client.plugins.specialcounter.SpecialCounterUpdate;
import net.runelite.client.plugins.specialcounter.SpecialWeapon;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.ObjectUtils;

@PluginDescriptor(
	name = "Party Defence Tracker",
	description = "Calculates the defence based off party specs",
	tags = {"party", "defence", "tracker", "boosting", "special", "counter"}
)
@Slf4j
@PluginDependency(PartyPlugin.class)
public class DefenceTrackerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private PartyService partyService;

	@Inject
	private WSClient wsClient;

	@Inject
	private DefenceTrackerConfig config;

	@Inject
	private SkillIconManager skillIconManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private PluginManager pluginManager;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private CoXLayoutSolver layoutSolver;

	private static final int COX_SCALED_PARTY_SIZE_VARBIT = 9540;

	private String boss = "";
	private int bossIndex = 0;
	private double bossDef = -1;
	private DefenceInfoBox box = null;
	private VulnerabilityInfoBox vulnBox = null;
	private SpritePixels vuln = null;
	private ShadowBarrageInfoBox shadowBarrageBox = null;
	private SpritePixels shadowBarrage = null;
	private boolean shadowBarrageHit = false;

	private RedKerisInfoBox redKerisBox = null;
	@Getter
	private int redKerisTicks = 0;

	//Copied from special counter
	//Expected tick the hitsplat will happen on
	private int hitsplatTick;
	private Hitsplat lastSpecHitsplat;
	private NPC lastSpecTarget;
	private double lastSpecPercent = -1;

	private boolean hmXarpus = false;
	private boolean bloatDown = false;

	private boolean inCm;
	private boolean coxModeSet = false;

	private QueuedNpc queuedNpc = null;

	private final List<SpecialCounterUpdate> specialList = new ArrayList<>();

	Map<String, ArrayList<Integer>> bossRegions = new HashMap<>()
	{{
		put("The Maiden of Sugadinti", new ArrayList<>(Collections.singletonList(12613)));
		put("Pestilent Bloat", new ArrayList<>(Collections.singletonList(13125)));
		put("Nylocas Vasilias", new ArrayList<>(Collections.singletonList(13122)));
		put("Sotetseg", new ArrayList<>(Arrays.asList(13123, 13379)));
		put("Xarpus", new ArrayList<>(Collections.singletonList(12612)));
		put("Zebak", new ArrayList<>(Collections.singletonList(15700)));
		put("Kephri", new ArrayList<>(Collections.singletonList(14164)));
		put("Ba-Ba", new ArrayList<>(Collections.singletonList(15188)));
		put("Akkha", new ArrayList<>(Collections.singletonList(14676)));
		put("Akkha's Shadow", new ArrayList<>(Collections.singletonList(14676)));
		put("<col=00ffff>Obelisk</col>", new ArrayList<>(Collections.singletonList(15184)));
		put("Tumeken's Warden", new ArrayList<>(Collections.singletonList(15696)));
		put("Elidinis' Warden", new ArrayList<>(Collections.singletonList(15696)));
		put("<col=00ffff>Core</col>", new ArrayList<>(Arrays.asList(15184, 15696)));
		put("Alchemical Hydra", new ArrayList<>(Collections.singletonList(5536)));
		put("Nex", new ArrayList<>(Collections.singletonList(11601)));
		put("Phantom Muspah", new ArrayList<>(Collections.singletonList(11330)));
		put("Skotizo", new ArrayList<>(Collections.singletonList(9048)));
		put("TzKal-Zuk", new ArrayList<>(Collections.singletonList(9043)));
		put("TzTok-Jad", new ArrayList<>(Collections.singletonList(9551)));
		put("Vorkath", new ArrayList<>(Collections.singletonList(9023)));
		put("Zulrah", new ArrayList<>(Arrays.asList(9007, 9008)));
	}};

	private final Set<String> coxBosses = new HashSet<>(List.of("Abyssal portal", "Deathly mage", "Deathly ranger", "Great Olm", "Great Olm (Left claw)", "Great Olm (Right claw", "Ice demon", "Skeletal Mystic", "Tekton", "Vasa Nistirio", "Lizardman shaman"));
  	private final Set<String> coxBossesSpecialOffensiveScaling = new HashSet<>(List.of("Abyssal portal", "Deathly ranger"));

	@Provides
	DefenceTrackerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(DefenceTrackerConfig.class);
	}

	protected void startUp() throws Exception
	{
		reset();
		enableRequiredPlugins("Party");
		enableRequiredPlugins("Special Attack Counter");
		wsClient.registerMessage(DefenceTrackerUpdate.class);
	}

	protected void shutDown() throws Exception
	{
		reset();
		wsClient.unregisterMessage(DefenceTrackerUpdate.class);
	}

	protected void reset()
	{
		infoBoxManager.removeInfoBox(box);
		infoBoxManager.removeInfoBox(vulnBox);
		infoBoxManager.removeInfoBox(redKerisBox);
		infoBoxManager.removeInfoBox(shadowBarrageBox);
		boss = "";
		bossIndex = 0;
		bossDef = -1;
		box = null;
		vulnBox = null;
		vuln = null;
		redKerisBox = null;
		redKerisTicks = 0;
		shadowBarrageBox = null;
		shadowBarrage = null;
		shadowBarrageHit = false;
		bloatDown = false;
		queuedNpc = null;
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged e)
	{
		int animation = e.getActor().getAnimation();

		if (e.getActor() instanceof Player && e.getActor() != null && client.getLocalPlayer() != null && e.getActor().getName() != null)
		{
			if (e.getActor().getName().equals(client.getLocalPlayer().getName()))
			{
				if (animation == 1816 && boss.equalsIgnoreCase("sotetseg") && inBossRegion())
				{
					infoBoxManager.removeInfoBox(box);
					bossDef = 200;
				}
			}
		}

		if (e.getActor() instanceof NPC && e.getActor().getName() != null)
		{
			if (e.getActor().getName().equalsIgnoreCase("pestilent bloat"))
			{
				bloatDown = animation == 8082;
			}
			//Enraged Wardens
			else if (animation == 9685 && (boss.equalsIgnoreCase("Tumeken's Warden") || boss.equalsIgnoreCase("Elidinis' Warden")))
			{
				infoBoxManager.removeInfoBox(box);
				bossDef = 60;
			}
		}
	}

	private void processSpecialAttack(SpecialCounterUpdate e)
	{
		int hit = e.getHit();
		int world = e.getWorld();
		SpecialWeapon weapon = e.getWeapon();
		int index = e.getNpcIndex();
		NPC npc = client.getTopLevelWorldView().npcs().byIndex(index);

		clientThread.invoke(() ->
		{
			if ((npc != null && npc.getName() != null && BossInfo.getBoss(npc.getName()) != null) || bossIndex == index)
			{
				if (bossIndex != index)
				{
					String bossName = npc.getName();

					if (!boss.equalsIgnoreCase(bossName) || (bossName.contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
					{
						baseDefence(bossName, index);
						calculateQueue(index);
					}
				}

				if (inBossRegion() && world == client.getWorld())
				{
					calculateDefence(weapon, hit);
					updateDefInfobox();
				}
			}
			else
			{
				if (queuedNpc == null || queuedNpc.index != index)
				{
					queuedNpc = new QueuedNpc(index);
				}
				queuedNpc.queuedSpecs.add(new QueuedNpc.QueuedSpec(weapon, hit));
			}
		});
	}

	@Subscribe
	public void onGameTick(GameTick e)
	{
		for (SpecialCounterUpdate specialCounterUpdate : specialList)
		{
			processSpecialAttack(specialCounterUpdate);
		}
		specialList.clear();
		if (partyService.isInParty())
		{
			for (NPC n : client.getTopLevelWorldView().npcs())
			{
				if (n != null && n.getName() != null && (n.getName().equalsIgnoreCase(boss) || (n.getName().contains("Tekton") && boss.equalsIgnoreCase("Tekton")))
					&& (n.isDead() || n.getHealthRatio() == 0))
				{
					partyService.send(new DefenceTrackerUpdate(n.getName(), n.getIndex(), false, client.getWorld(), ""));
				}
			}
		}

		layoutSolver.onGameTick(e);

		if (!coxModeSet && client.getVarbitValue(Varbits.IN_RAID) == 1)
		{
			inCm = layoutSolver.isCM();
			coxModeSet = true;
		}

		if (redKerisTicks > 0)
		{
			redKerisTicks--;
			if (redKerisTicks == 0)
			{
				infoBoxManager.removeInfoBox(redKerisBox);
			}
		}

		//Copied from special counter
		if (lastSpecHitsplat != null && lastSpecTarget != null)
		{
			if (lastSpecHitsplat.getAmount() > 0 && partyService.isInParty())
			{
				partyService.send(new DefenceTrackerUpdate(lastSpecTarget.getName(), lastSpecTarget.getIndex(), true, client.getWorld(), "keris"));
			}
			lastSpecHitsplat = null;
			lastSpecTarget = null;
		}
	}

	@Subscribe
	public void onHitsplatApplied(HitsplatApplied e)
	{
		Actor target = e.getActor();
		Hitsplat hitsplat = e.getHitsplat();
		if (hitsplat.isMine() && target instanceof NPC && lastSpecTarget != null && hitsplatTick == client.getTickCount())
		{
			NPC npc = (NPC) target;
			String name = npc.getName();
			if (name != null && (BossInfo.getBoss(name) != null || bossIndex == npc.getIndex()))
			{
				// The weapon hitsplat is always last, after other hitsplats which occur on the same tick such as from venge or thralls.
				lastSpecHitsplat = hitsplat;
			}
		}
	}


	@Subscribe
	public void onNpcSpawned(NpcSpawned e)
	{
		NPC npc = e.getNpc();
		if (npc.getName() != null && BossInfo.getBoss(npc.getName()) != null)
		{
			hmXarpus = npc.getId() >= 10770 && npc.getId() <= 10772;
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath e)
	{
		if (e.getActor() instanceof NPC && e.getActor().getName() != null && client.getLocalPlayer() != null && partyService.isInParty())
		{
			if (e.getActor().getName().equalsIgnoreCase(boss) || (e.getActor().getName().contains("Tekton") && boss.equalsIgnoreCase("Tekton")))
			{
				partyService.send(new DefenceTrackerUpdate(e.getActor().getName(), ((NPC) e.getActor()).getIndex(), false, client.getWorld(), ""));
			}
		}
	}

	@Subscribe
	public void onSpecialCounterUpdate(SpecialCounterUpdate e)
	{
		if (e.getWeapon() == SpecialWeapon.ELDER_MAUL)
		{
			specialList.add(0, e);
		}
		else
		{
			specialList.add(e);
		}
	}

	@Subscribe
	public void onDefenceTrackerUpdate(DefenceTrackerUpdate e)
	{
		int world = e.getWorld();
		clientThread.invoke(() ->
		{
			if (!e.isAlive())
			{
				reset();
			}
			else
			{
				if (inBossRegion() && world == client.getWorld())
				{
					if (e.getWeapon().equals("vuln"))
					{
						if (!boss.equalsIgnoreCase(e.getBoss()) || (e.getBoss().contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
						{
							baseDefence(e.getBoss(), e.getIndex());
							calculateQueue(e.getIndex());
						}

						if (config.vulnerability())
						{
							infoBoxManager.removeInfoBox(vulnBox);
							IndexDataBase sprite = client.getIndexSprites();
							vuln = Objects.requireNonNull(client.getSprites(sprite, 56, 0))[0];
							vulnBox = new VulnerabilityInfoBox(vuln.toBufferedImage(), this);
							vulnBox.setTooltip(ColorUtil.wrapWithColorTag(Text.removeTags(boss), Color.WHITE));
							infoBoxManager.addInfoBox(vulnBox);
						}
						bossDef -= bossDef * .1;

						updateDefInfobox();
					}
					else if (e.getWeapon().equals("keris"))
					{
						redKerisTicks = 9;
						if (config.redKeris())
						{
							infoBoxManager.removeInfoBox(redKerisBox);
							redKerisBox = new RedKerisInfoBox(itemManager.getImage(ItemID.KERIS_PARTISAN_OF_CORRUPTION), this);
							redKerisBox.setTooltip(ColorUtil.wrapWithColorTag(e.getBoss(), Color.WHITE));
							infoBoxManager.addInfoBox(redKerisBox);
						}
					} else if (e.getWeapon().equals("shadowBarrage") && !shadowBarrageHit)
					{
						if (!boss.equalsIgnoreCase(e.getBoss()) || (e.getBoss().contains("Tekton") && !boss.equalsIgnoreCase("Tekton")))
						{
							baseDefence(e.getBoss(), e.getIndex());
							calculateQueue(e.getIndex());
						}

						if (config.shadowBarrage())
						{
							infoBoxManager.removeInfoBox(shadowBarrageBox);
							shadowBarrageBox = new ShadowBarrageInfoBox(itemManager.getImage(ItemID.SHADOW_ANCIENT_SCEPTRE), this);
							shadowBarrageBox.setTooltip(ColorUtil.wrapWithColorTag(e.getBoss(), Color.WHITE));
							infoBoxManager.addInfoBox(shadowBarrageBox);
						}
						shadowBarrageHit = true; // non-stackable reduction
						bossDef -= bossDef * .15;

						updateDefInfobox();
					}
				}
			}
		});
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		if (event.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION)
		{
			if (Text.removeTags(event.getMessage()).equals("The raid has begun!") && client.getVarbitValue(Varbits.IN_RAID) == 1)
			{
				// Determine if in challege mode or regular
				inCm = layoutSolver.isCM();
				coxModeSet = true;
			}
		}
	}

	@Subscribe
	private void onVarbitChanged(VarbitChanged e)
	{
		if (!inBossRegion())
		{
			reset();
		}

		if (client.getVarbitValue(Varbits.IN_RAID) != 1 && isInCoxLobby())
		{
			inCm = false;
			coxModeSet = false;
		}

		layoutSolver.onVarbitChanged(e);

		//Copied from special counter plugin
		if (e.getVarpId() == VarPlayer.SPECIAL_ATTACK_PERCENT)
		{
			if (client.getLocalPlayer() != null && client.getLocalPlayer().getPlayerComposition() != null)
			{
				int weapon = client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON);
				if (weapon == ItemID.KERIS_PARTISAN_OF_CORRUPTION && (e.getValue() == lastSpecPercent - 750 || e.getValue() == lastSpecPercent - 375))
				{
					// This event runs prior to player and npc updating, making getInteracting() too early to call..
					// defer this with invokeLater(), but note that this will run after incrementing the server tick counter
					// so we capture the current server tick counter here for use in computing the final hitsplat tick
					final int serverTicks = client.getTickCount();
					clientThread.invokeLater(() ->
					{
						Actor target = client.getLocalPlayer().getInteracting();
						lastSpecTarget = target instanceof NPC ? (NPC) target : null;
						hitsplatTick = serverTicks + 1; //red keris has hit delay 1
					});
				}
			}
			lastSpecPercent = e.getValue();
		}
	}

	@Subscribe
	public void onGraphicChanged(GraphicChanged e)
	{
		if (!(e.getActor() instanceof NPC) || e.getActor().getName() == null || !partyService.isInParty())
		{
			return;
		}

		NPC npc = (NPC) e.getActor();

		BossInfo bossName = BossInfo.getBoss(npc.getName());
		if (bossName == null)
		{
			return;
		}

		final int VULNERABILITY_SPOT_ANIM = 169;
		final int SHADOW_SCEPTRE_SPOT_ANIM = 383;
		final int SHADOW_SCEPTRE_ID = ItemID.SHADOW_ANCIENT_SCEPTRE_28266;

		if (npc.hasSpotAnim(VULNERABILITY_SPOT_ANIM))
		{
			partyService.send(new DefenceTrackerUpdate(npc.getName(), npc.getIndex(), true, client.getWorld(), "vuln"));
		}
		else if (npc.hasSpotAnim(SHADOW_SCEPTRE_SPOT_ANIM))
		{
			int equippedWeapon = ObjectUtils.defaultIfNull(
					client.getLocalPlayer().getPlayerComposition().getEquipmentId(KitType.WEAPON), -1
			);
			if (equippedWeapon == SHADOW_SCEPTRE_ID)
			{
				partyService.send(new DefenceTrackerUpdate(npc.getName(), npc.getIndex(), true, client.getWorld(), "shadowBarrage"));
			}
		}
	}



	@Subscribe
	protected void onGameStateChanged(GameStateChanged e)
	{
		layoutSolver.onGameStateChanged(e);
	}

	private void baseDefence(String bossName, int index)
	{
		boss = bossName;
		bossIndex = index;
		bossDef = BossInfo.getBaseDefence(boss);

		if (boss.equalsIgnoreCase("Xarpus") && hmXarpus)
		{
			bossDef = 200;
		}
		else if (coxBosses.contains(boss))
		{
			bossDef = getCoxScaledDefenceLevel(bossName, (int) bossDef);
		}
	}

	private int getCoxScaledDefenceLevel(String bossName, int baseDef)
	{
		int partySize = getCoxPartySize();
		baseDef = (int) (baseDef * (((int) Math.sqrt(partySize - 1) + ((partySize - 1) * 7 / 10 + 100)) / 100.0));
		if (inCm)
		{
			baseDef = (int) (baseDef * (bossName.contains("Tekton") ? partySize > 3 ? 1.35 : 1.2 : 1.5));
		}
		return baseDef;
	}

	private int getScaledMagicLevel()
	{
		int scaledMagicLevel = (int) BossInfo.getBaseMagic(boss);
		if (coxBosses.contains(boss))
		{
			int partySize = getCoxPartySize();
			if (coxBossesSpecialOffensiveScaling.contains(boss))
			{
				scaledMagicLevel = (int) (scaledMagicLevel * (((int) Math.sqrt(partySize - 1) + ((partySize - 1) * 7 / 10 + 100)) / 100.0));
			}
			else
			{
				scaledMagicLevel = scaledMagicLevel * (((int) (Math.sqrt(partySize - 1))) * 7 + partySize + 99) / 100;
			}
			if (inCm)
			{
				scaledMagicLevel = (int) (1.5 * scaledMagicLevel);
			}
		}
		return scaledMagicLevel;
	}

	private void calculateDefence(SpecialWeapon weapon, int hit)
	{
		switch (weapon)
		{
			case DRAGON_WARHAMMER:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= bossDef * .05;
					}
				}
				else
				{
					bossDef -= bossDef * .30;
				}
				break;
			case ELDER_MAUL:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= bossDef * .05;
					}
				}
				else
				{
					bossDef -= bossDef * .35;
				}
				break;
			case BANDOS_GODSWORD:
				if (hit == 0)
				{
					if (client.getVarbitValue(Varbits.IN_RAID) == 1 && boss.equalsIgnoreCase("Tekton"))
					{
						bossDef -= 10;
					}
				}
				else
				{
					if (boss.equalsIgnoreCase("Corporeal Beast") || (inBossRegion() && boss.equalsIgnoreCase("Pestilent Bloat") && !bloatDown))
					{
						bossDef -= hit * 2;
					}
					else
					{
						bossDef -= hit;
					}
				}
				break;
			case ARCLIGHT:
			case DARKLIGHT:
				if (hit > 0)
				{
					if (boss.equalsIgnoreCase("K'ril Tsutsaroth") || boss.equalsIgnoreCase("Abyssal Sire"))
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .10;
					}
					else
					{
						bossDef -= BossInfo.getBaseDefence(boss) * .05;
					}
				}
				break;
			case BARRELCHEST_ANCHOR:
				bossDef -= hit * .10;
				break;
			case BONE_DAGGER:
			case DORGESHUUN_CROSSBOW:
				if (bossDef >= BossInfo.getBaseDefence(boss))
				{
					bossDef -= hit;
				}
				break;
			case ACCURSED_SCEPTRE:
				if (hit > 0)
				{
					if (bossDef > (BossInfo.getBaseDefence(boss) * .85))
					{
						bossDef = BossInfo.getBaseDefence(boss) * .85;
					}
				}
				break;
			case TONALZTICS_OF_RALOS:
				for (int i = 0; i < hit; i++)
				{
					bossDef -= (int) (getScaledMagicLevel() * .1);
				}
				break;
		}

		if (boss.equalsIgnoreCase("Sotetseg") && bossDef < 100)
		{
			bossDef = 100;
		}
		else if (bossDef < 0)
		{
			bossDef = 0;
		}
	}

	private void calculateQueue(int index)
	{
		if (queuedNpc != null)
		{
			if (queuedNpc.index == index)
			{
				for (QueuedNpc.QueuedSpec spec : queuedNpc.queuedSpecs)
				{
					calculateDefence(spec.weapon, spec.hit);
				}
			}
			queuedNpc = null;
		}
	}

	private void updateDefInfobox()
	{
		infoBoxManager.removeInfoBox(box);
		box = new DefenceInfoBox(skillIconManager.getSkillImage(Skill.DEFENCE), this, Math.round(bossDef), config);
		box.setTooltip(ColorUtil.wrapWithColorTag(boss, Color.WHITE));
		infoBoxManager.addInfoBox(box);
	}

	private boolean inBossRegion()
	{
		if (client.getLocalPlayer() != null && bossRegions.containsKey(boss))
		{
			WorldPoint wp = WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation());
			if (wp != null)
			{
				return bossRegions.get(boss).contains(wp.getRegionID());
			}
		}
		return client.getVarbitValue(Varbits.IN_RAID) == 1 || !coxBosses.contains(boss);
	}

	public boolean isInCoxLobby()
	{
		int[] regions = client.getTopLevelWorldView().getMapRegions();
		return regions != null && regions.length > 0 && Arrays.stream(regions).anyMatch((s) -> s == 4919);
	}

	private int getCoxPartySize()
	{
		return client.getVarbitValue(COX_SCALED_PARTY_SIZE_VARBIT);
	}

	public void enableRequiredPlugins(String pluginName)
	{
		try
		{
			final Optional<Plugin> plugin = pluginManager.getPlugins().stream().filter(p -> p.getName().equals(pluginName)).findFirst();
			if (plugin.isPresent() && !pluginManager.isPluginEnabled(plugin.get()))
			{
				pluginManager.setPluginEnabled(plugin.get(), true);
				pluginManager.startPlugin(plugin.get());
			}
		}
		catch (PluginInstantiationException ex)
		{
			log.error("error starting " + pluginName + " plugin", ex);
		}
	}
}

package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import net.runelite.client.ui.overlay.infobox.InfoBox;

public class ShadowBarrageInfoBox extends InfoBox
{
    private DefenceTrackerPlugin plugin;

    ShadowBarrageInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
    {
        super(image, plugin);
        this.plugin = plugin;
    }

    public String getText()
    {
        return null;
    }

    public Color getTextColor()
    {
        return Color.WHITE;
    }
}

package com.partydefencetracker;

import lombok.Getter;

enum BossInfo
{
	ABYSSAL_PORTAL("Abyssal portal", 176, 176),
	ABYSSAL_SIRE("Abyssal Sire", 250, 200),
	AKKHA("Akkha", 80, 100),
	AKKHAS_SHADOW("Akkha's Shadow", 30, 100),
	ALCHEMICAL_HYDRA("Alchemical Hydra", 100, 260),
	ARTIO("Artio", 150, 90),
	BA_BA("Ba-Ba", 20, 100),
	CALLISTO("Callisto", 225, 140),
	CALVARION("Calvar'ion", 225, 178),
	CERBERUS("Cerberus", 110, 220),
	CHAOS_ELEMENTAL("Chaos Elemental", 270, 270),
	COMMANDER_ZILYANA("Commander Zilyana", 300, 300),
	CORE("<col=00ffff>Core</col>", 0, 0),
	CORPOREAL_BEAST("Corporeal Beast", 310, 350),
	DAGANNOTH_PRIME("Dagannoth Prime", 255, 255),
	DAGANNOTH_REX("Dagannoth Rex", 255, 0),
	DAGANNOTH_SUPREME("Dagannoth Supreme", 128, 244),
	DEATHLY_MAGE("Deathly mage", 155, 210),
	DEATHLY_RANGER("Deathly ranger", 155, 155),
	ELIDINIS_WARDEN("Elidinis' Warden", 30, 190),
	GENERAL_GRAARDOR("General Graardor", 250, 150),
	GIANT_MOLE("Giant Mole", 200, 200),
	GREAT_OLM("Great Olm", 150, 250),
	GREAT_OLM_LEFT_CLAW("Great Olm (Left claw)", 175, 175),
	GREAT_OLM_RIGHT_CLAW("Great Olm (Right claw)", 175, 87),
	ICE_DEMON("Ice Demon", 160, 390),
	KALPHITE_QUEEN("Kalphite Queen", 300, 150),
	KEPHRI("Kephri", 20, 125),
	KING_BLACK_DRAGON("King Black Dragon", 240, 240),
	KREE_ARRA("Kree'arra", 260, 200),
	KRIL_TSUTSAROTH("K'ril Tsutsaroth", 270, 200),
	LIZARDMAN_SHAMAN("Lizardman shaman", 210, 130),
	NEX("Nex", 260, 230),
	NYLOCAS_VASILIAS("Nylocas Vasilias", 50, 50),
	OBELISK("<col=00ffff>Obelisk</col>", 40, 100),
	PESTILENT_BLOAT("Pestilent Bloat", 100, 150),
	PHANTOM_MUSPAH("Phantom Muspah", 200, 150), //180 shielded
	SARACHNIS("Sarachnis", 150, 150),
	SCORPIA("Scorpia", 180, 1),
	SKELETAL_MYSTIC("Skeletal Mystic", 187, 140),
	SKOTIZO("Skotizo", 200, 280),
	SOTETSEG("Sotetseg", 200, 250),
	SPINDEL("Spindel", 225, 235),
	TEKTON("Tekton", 205, 205),
	TEKTON_ENRAGED("Tekton (enraged)", 205, 205),
	THE_MAIDEN_OF_SUGADINTI("The Maiden of Sugadinti", 200, 350),
	TUMEKENS_WARDEN("Tumeken's Warden", 30, 190),
	TZKAL_ZUK("TzKal-Zuk", 260, 150),
	TZTOK_JAD("TzTok-Jad", 480, 480),
	VASA("Vasa Nistirio", 175, 230),
	VENENATIS("Venenatis", 321, 300),
	VETION("Vet'ion", 395, 300),
	VORKATH("Vorkath", 214, 150),
	XARPUS("Xarpus", 250, 220),
	ZEBAK("Zebak", 20, 100),
	ZULRAH("Zulrah", 300, 300);

	@Getter
	private final String name;
	@Getter
	private final double baseDef;
	@Getter
	private final double baseMagic;

	BossInfo(String name, double baseDef, double baseMagic)
	{
		this.name = name;
		this.baseDef = baseDef;
		this.baseMagic = baseMagic;
	}

	static BossInfo getBoss(String bossName)
	{
		for (BossInfo boss : values())
		{
			if (boss.name.contains(bossName))
			{
				return boss;
			}
		}
		return null;
	}

	static double getBaseDefence(String bossName)
	{
		BossInfo boss = getBoss(bossName);
		if (boss != null)
		{
			return boss.baseDef;
		}
		return 0;
	}

	static double getBaseMagic(String bossName)
	{
		BossInfo boss = getBoss(bossName);
		if(boss != null)
		{
			return boss.baseMagic;
		}
		return 0;
	}
}

package com.partydefencetracker;

import java.awt.Color;
import java.awt.image.BufferedImage;

import net.runelite.client.ui.overlay.infobox.InfoBox;

public class VulnerabilityInfoBox extends InfoBox
{
	private DefenceTrackerPlugin plugin;

	VulnerabilityInfoBox(BufferedImage image, DefenceTrackerPlugin plugin)
	{
		super(image, plugin);
		this.plugin = plugin;
	}

	public String getText()
	{
		return null;
	}

	public Color getTextColor()
	{
		return Color.WHITE;
	}
}

package com.partydefencetracker;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import net.runelite.client.party.messages.PartyMemberMessage;

@Value
@AllArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DefenceTrackerUpdate extends PartyMemberMessage
{
	String boss;
	int index;
	boolean alive;
	int world;
	String weapon;
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.partydefencetracker;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("defencetracker")
public interface DefenceTrackerConfig extends Config
{
	@ConfigItem(
			name = "Low Defence Threshold",
			keyName = "lowDef",
			description = "Sets when you want the defence to appear as low defence",
			position = 1
	)
	default int lowDef()
	{
		return 10;
	}

	@ConfigItem(
		name = "High Defence Color",
		keyName = "highDefColor",
		description = "Color of the infobox text when the defence is above the low defence threshold",
		position = 2
	)
	default Color highDefColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		name = "Low Defence Color",
		keyName = "lowDefColor",
		description = "Color of the infobox text when the defence is beneath the low defence threshold",
		position = 3
	)
	default Color lowDefColor()
	{
		return Color.YELLOW;
	}

	@ConfigItem(
		name = "Capped Defence Color",
		keyName = "cappedDefColor",
		description = "Color of the infobox text when the defence is at the lowest possible amount for that NPC",
		position = 4
	)
	default Color cappedDefColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "disableIBColor",
		name = "Disable Infobox Text Color",
		description = "Defence infobox text will always be set to White",
		position = 5
	)
	default boolean disableIBColor()
	{
		return false;
	}

	@ConfigItem(
			keyName = "vulnerability",
			name = "Show Vulnerability",
			description = "Displays an infobox when you successfully land vulnerability",
			position = 6
	)
	default boolean vulnerability()
	{
		return true;
	}

	@ConfigItem(
			keyName = "shadowBarrage",
			name = "Show Shadow Barrage",
			description = "Displays an infobox when you successfully land a shadow barrage whilst wearing the shadow ancient sceptre",
			position = 7
	)
	default boolean shadowBarrage() { return true; }

	@ConfigItem(
		keyName = "redKeris",
		name = "Show Red Keris",
		description = "Displays an infobox when you successfully land a Red Keris (Corruption) special attack",
		position = 8
	)
	default boolean redKeris()
	{
		return true;
	}
}

package com.partydefencetracker;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(DefenceTrackerPlugin.class);
		RuneLite.main(args);
	}
}
