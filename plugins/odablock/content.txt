package com.github.dappermickie.odablock;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.regex.Pattern;
import net.runelite.client.RuneLite;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

public class PlayerKillLineManager
{
	private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/dappermickie/odablock-sounds/playerkillpatterns");
	private static final String USERS_FILENAME = "pklines.txt";
	private static Pattern[] patterns = null;

	public static void Setup(final OkHttpClient okHttpClient)
	{
		HttpUrl usersUrl = RAW_GITHUB.newBuilder().addPathSegment(USERS_FILENAME).build();
		try (Response res = okHttpClient.newCall(new Request.Builder().url(usersUrl).build()).execute())
		{
			if (res.body() != null)
			{
				String[] lines = res.body().string().split("\n");
				patterns = new Pattern[lines.length];

				for (int i = 0; i < lines.length; i++)
				{
					patterns[i] = Pattern.compile(lines[i]);
				}
			}
		}
		catch (IOException e)
		{
			return;
		}
	}

	public static Pattern[] getPatterns()
	{
		return patterns;
	}
}

package com.github.dappermickie.odablock;

public enum SoundIds
{
	AGS_SPEC(3869),
	DDS_SPEC(2537),
	ACB_SPEC(3892),
	PRAYER_DOWN(2672),
	REDEMPTION_PROC(2681),
	BANK_PIN(1041),
	RUBY_BOLT_PROC(2911);

	public final int Id;

	SoundIds(int id)
	{
		Id = id;
	}
}

package com.github.dappermickie.odablock;

public enum DhAxeStyles
{
	CHOP,
	HACK,
	SMASH,
	BLOCK
}

package com.github.dappermickie.odablock;

public enum AnimationIds
{
	REDEMPTION_PROC(436),
	DDS_SPEC(252),
	AGS_SPEC(1211);

	public final int Id;

	AnimationIds(int id)
	{
		this.Id = id;
	}
}

package com.github.dappermickie.odablock;

import java.io.FileNotFoundException;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.UnsupportedAudioFileException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.audio.AudioPlayer;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.concurrent.Executor;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Singleton
@Slf4j
public class SoundEngine
{
	@Inject
	private OdablockConfig config;

	@Inject
	private AudioPlayer audioPlayer;

	public void playClip(Sound sound, Executor executor)
	{
		executor.execute(() -> playClip(sound));
	}

	public void playClip(Sound sound, ScheduledExecutorService executor, Duration initialDelay)
	{
		executor.schedule(() -> playClip(sound), initialDelay.toMillis(), TimeUnit.MILLISECONDS);
	}

	private void playClip(Sound sound)
	{
		if (SoundFileManager.getIsUpdating())
		{
			return;
		}

		float gain = 20f * (float) Math.log10(config.announcementVolume() / 100f);
		try
		{
			audioPlayer.play(SoundFileManager.getSoundStream(sound), gain);
		}
		catch (FileNotFoundException e)
		{
			log.warn("Sound file not found for " + sound, e);
		}
		catch (IOException e)
		{
			log.warn("Failed to play Odablock sound " + sound, e);
		}
		catch (UnsupportedAudioFileException e)
		{
			log.warn("Failed to play Odablock sound " + sound, e);
		}
		catch (LineUnavailableException e)
		{
			log.warn("Failed to play Odablock sound " + sound, e);
		}
	}

	public void close()
	{
		// No cleanup needed for AudioPlayer
	}
}
package com.github.dappermickie.odablock;

import java.util.Random;

public class RandomSoundUtility
{
	private static Random random = new Random();

	public static String getRandomSound(String[] sounds)
	{
		return sounds[random.nextInt(sounds.length)];
	}
}

package com.github.dappermickie.odablock;

public enum OdablockVarbits
{
	RUNNING(-1, 173),

	// Used for DH Axe style determination
	COMBAT_STYLE_43(-1, 43),
	COMBAT_STYLE_46(-1, 46),

	IS_WEARING_WEAPON(-1, 843);

	public final int Id;
	public final int VarpId;

	OdablockVarbits(int id, int varpId)
	{
		Id = id;
		VarpId = varpId;
	}
}

package com.github.dappermickie.odablock;

import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Slf4j
public abstract class SoundFileManager
{

	private static final File DOWNLOAD_DIR = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "odablock-sounds");
	private static final String DELETE_WARNING_FILENAME = "EXTRA_FILES_WILL_BE_DELETED_BUT_FOLDERS_WILL_REMAIN";
	private static final String SOUNDVERSION_FILENAME = "SOUNDVERSION";
	private static final File DELETE_WARNING_FILE = new File(DOWNLOAD_DIR, DELETE_WARNING_FILENAME);
	private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/dappermickie/odablock-sounds/sounds-v2");

	private static boolean isUpdating = false;

	private static Map<String, String[]> soundDirectoryMap = new HashMap<>();

	@SuppressWarnings("ResultOfMethodCallIgnored")
	public static void ensureDownloadDirectoryExists()
	{
		if (!DOWNLOAD_DIR.exists())
		{
			DOWNLOAD_DIR.mkdirs();
		}
		try
		{
			DELETE_WARNING_FILE.createNewFile();
		}
		catch (IOException ignored)
		{
		}
	}

	@SuppressWarnings("ResultOfMethodCallIgnored")
	public static void ensureSoundDirectoryExists(File soundDirectory)
	{
		if (!soundDirectory.exists())
		{
			soundDirectory.mkdirs();
		}
		File customDirectory = new File(soundDirectory, "custom");
		if (!customDirectory.exists())
		{
			customDirectory.mkdirs();
		}
		try
		{
			soundDirectory.createNewFile();
		}
		catch (IOException ignored)
		{
		}
	}

	public static void downloadAllMissingSounds(final OkHttpClient okHttpClient)
	{
		// Get set of existing files in our dir - existing sounds will be skipped, unexpected files (not dirs, some sounds depending on config) will be deleted
		assert RAW_GITHUB != null;
		HttpUrl versionUrl = RAW_GITHUB.newBuilder().addPathSegment(SOUNDVERSION_FILENAME).build();
		int latestVersion = getLatestVersion(okHttpClient, versionUrl);
		if (latestVersion == -1)
		{
			return;
		}

		int currentVersion = getCurrentVersion();

		if (latestVersion == currentVersion)
		{
			isUpdating = true;
			downloadMissingSounds(okHttpClient);
			isUpdating = false;
			return;
		}
		isUpdating = true;
		writeLatestVersion(latestVersion);

		for (String filename : getFilesPresent(DOWNLOAD_DIR))
		{
			File toDelete = new File(DOWNLOAD_DIR, filename);
			//noinspection ResultOfMethodCallIgnored
			toDelete.delete();
			log.warn("Odablock plugin deleted " + filename);
		}

		List<String> cleanedDirectories = new ArrayList<>();

		// Download any sounds that are not yet present but desired
		for (Sound sound : Sound.values())
		{
			String soundDirectory = sound.getDirectory();
			File soundDirectoryFile = new File(DOWNLOAD_DIR, soundDirectory);

			ensureSoundDirectoryExists(soundDirectoryFile);

			if (!cleanedDirectories.contains(soundDirectory))
			{
				Set<String> filesPresent = getFilesPresent(soundDirectoryFile);

				for (String filename : filesPresent)
				{
					File toDelete = new File(soundDirectoryFile, filename);
					//noinspection ResultOfMethodCallIgnored
					toDelete.delete();
					log.warn("Odablock plugin deleted " + filename);
				}

				cleanedDirectories.add(soundDirectory);
			}

			// End early if the sound couldn't be downloaded
			if (hasNotDownloadedSound(sound, okHttpClient))
			{
				return;
			}
		}

		isUpdating = false;
	}

	private static int getCurrentVersion()
	{
		int currentVersion = -1;
		try
		{
			currentVersion = getSoundVersion();
		}
		catch (IOException e)
		{
			// No current version available
			var soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
			try
			{
				//noinspection ResultOfMethodCallIgnored
				soundVersionFile.createNewFile();
			}
			catch (IOException e2)
			{
				log.error("Couldn't create soundversion file");
			}
		}
		return currentVersion;
	}

	private static int getLatestVersion(OkHttpClient okHttpClient, HttpUrl versionUrl)
	{
		int latestVersion = -1;
		try (Response res = okHttpClient.newCall(new Request.Builder().url(versionUrl).build()).execute())
		{
			if (res.body() != null)
			{
				latestVersion = Integer.parseInt(Text.standardize(res.body().string()));
			}
		}
		catch (IOException e)
		{
			log.error("Odablock Plugin could not download sound version", e);
		}
		return latestVersion;
	}

	private static boolean hasNotDownloadedSound(Sound sound, OkHttpClient okHttpClient)
	{
		String soundDirectory = sound.getDirectory();
		String soundResourceName = sound.getResourceName();
		File soundDirectoryFile = new File(DOWNLOAD_DIR.getPath(), sound.getDirectory());
		assert RAW_GITHUB != null;
		HttpUrl soundUrl = RAW_GITHUB.newBuilder().addPathSegment(soundDirectory).addPathSegment(soundResourceName).build();
		Path outputPath = Paths.get(soundDirectoryFile.getPath(), soundResourceName);
		ensureSoundDirectoryExists(soundDirectoryFile);
		try (Response res = okHttpClient.newCall(new Request.Builder().url(soundUrl).build()).execute())
		{
			if (res.body() != null)
			{
				Files.copy(new BufferedInputStream(res.body().byteStream()), outputPath, StandardCopyOption.REPLACE_EXISTING);
				log.warn("Odablock plugin downloaded " + sound.getResourceName());
				return false;
			}
			return true;
		}
		catch (IOException e)
		{
			log.error("Odablock Plugin could not download sounds", e);
			isUpdating = false;
			return true;
		}
	}

	private static void downloadMissingSounds(OkHttpClient okHttpClient)
	{
		for (Sound sound : Sound.values())
		{
			File soundFile = Paths.get(DOWNLOAD_DIR.getPath(), sound.getDirectory(), sound.getResourceName()).toFile();
			if (soundFile.exists())
			{
				continue;
			}
			// Download sound and if a sound couldn't get downloaded, return early.
			if (hasNotDownloadedSound(sound, okHttpClient))
			{
				return;
			}
		}
	}

	private static Set<String> getFilesPresent(File directory)
	{
		File[] downloadDirFiles = directory.listFiles();
		if (downloadDirFiles == null || downloadDirFiles.length == 0)
		{
			return new HashSet<>();
		}

		return Arrays.stream(downloadDirFiles)
			.filter(file -> !file.isDirectory())
			.map(File::getName)
			.filter(filename -> !DELETE_WARNING_FILENAME.equals(filename))
			.filter(filename -> !SOUNDVERSION_FILENAME.equals(filename))
			.collect(Collectors.toSet());
	}

	public static InputStream getSoundStream(Sound sound) throws FileNotFoundException
	{
		if (!soundDirectoryMap.containsKey(sound.getDirectory()))
		{
			File soundDirectoryPath = Paths.get(DOWNLOAD_DIR.getPath(), sound.getDirectory()).toFile();
			File customSoundDirectoryPath = Paths.get(soundDirectoryPath.getPath(), "custom").toFile();

			File[] files = customSoundDirectoryPath.listFiles();
			if (files == null || files.length == 0)
			{
				files = soundDirectoryPath.listFiles();
			}

			if (files == null || files.length == 0)
			{
				return null;
			}

			var soundFileArray = Arrays.stream(files)
				.filter(file -> !file.isDirectory())
				.map(File::getAbsolutePath).distinct().toArray(String[]::new);

			soundDirectoryMap.put(sound.getDirectory(), soundFileArray);
		}
		String soundFile = RandomSoundUtility.getRandomSound(soundDirectoryMap.get(sound.getDirectory()));
		return new FileInputStream(soundFile);
	}

	public static int getSoundVersion() throws IOException
	{
		File soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
		String soundVersionContent = Files.readString(soundVersionFile.toPath());
		return Integer.parseInt(soundVersionContent);
	}

	public static boolean getIsUpdating()
	{
		return isUpdating;
	}

	private static void writeLatestVersion(int version)
	{
		var soundVersionFile = new File(DOWNLOAD_DIR, SOUNDVERSION_FILENAME);
		try
		{
			FileWriter myWriter = new FileWriter(soundVersionFile);
			myWriter.write(String.valueOf(version));
			myWriter.close();
		}
		catch (IOException e)
		{
			log.error("Couldn't write latest soundversion");
		}
	}
}
package com.github.dappermickie.odablock;

public enum Sound
{
	REDEMPTION_PROC("redemption", "RedemptionProc_r1.wav"),//#1
	REDEMPTION_PROC_2("redemption", "RedemptionProc_r2.wav"),//#1
	REDEMPTION_PROC_3("redemption", "RedemptionProc_r3.wav"),//#1
	REDEMPTION_PROC_4("redemption", "RedemptionProc_r4.wav"),//#1

	DEATH("death", "DyingHCIMCompleted_r1.wav"),//#2
	COLLECTION_LOG_SLOT("collectionlog", "ColLogSlotCompleted_r1.wav"),//#3
	SMITED_NO_PRAYER("smited", "SmitedNoPrayer.wav"),//#4
	NEW_PET("newpet", "NewPet.wav"),//#5
	PETTING_DOG("pettingdog", "PettingDog.wav"),//#6
	DECLINE_TRADE("declinetrade", "DeclineTrade.wav"),//#7
	VENGEANCE("vengeance", "Vengeance.wav"),//#8

	KILLING_SOMEONE_1("playerkilling", "KillingSomeone_r1.wav"),//#9
	KILLING_SOMEONE_2("playerkilling", "KillingSomeone_r2.wav"),//#9
	KILLING_SOMEONE_3("playerkilling", "KillingSomeone_r3.wav"),//#9
	KILLING_SOMEONE_4("playerkilling", "KillingSomeone_r4.wav"),//#9

	REPORT_PLAYER_1("reportplayer", "ReportPlayer_r1.wav"),//#10
	REPORT_PLAYER_2("reportplayer", "ReportPlayer_r2.wav"),//#10
	REPORT_PLAYER_3("reportplayer", "ReportPlayer_r3.wav"),//#10

	ZEBAK_ROAR("zebakroar", "ZebakRoar.wav"),//#12
	RUBY_PROC("rubyproc", "RubyProc.wav"),//#13
	//HIT_BY_KEPHRI("holykephri", "HitByKephri.wav"),//#14

	COMBAT_TASK("combattask", "CombatTaskCompleted_r1.wav"),//#15
	COMBAT_TASK_2("combattask", "CombatTaskCompleted_r2.wav"),//#15
	COMBAT_TASK_3("combattask", "CombatTaskCompleted_r3.wav"),//#15
	COMBAT_TASK_4("combattask", "CombatTaskCompleted_r4.wav"),//#15

	DDS_SPEC("ddsspec", "DdsSpec_r1.wav"),//#16
	DDS_SPEC_2("ddsspec", "DdsSpec_r2.wav"),//#16
	DDS_SPEC_3("ddsspec", "DdsSpec_r3.wav"),//#16

	ACCEPTED_TRADE("accepttrade", "AcceptTrade.wav"),//#17

	GETTING_PURPLE_1("gettingpurple", "GettingPurple_r1.wav"),//#18
	GETTING_PURPLE_2("gettingpurple", "GettingPurple_r2.wav"),//#18


	KILLING_RAT_OR_SCURRIUS_1("killingrat", "KillingRatOrScurrius_r1.wav"),//#18
	KILLING_RAT_OR_SCURRIUS_2("killingrat", "KillingRatOrScurrius_r2.wav"),//#18

	DISMISSING_RANDOM_EVENT("dismissrandomevent", "DismissingRandomEvent.wav"),//#20
	TYPING_IN_BANKPIN("typingbankpin", "TypingInBankpin.wav"),//#21
	CLIENT_DISCONNECTS("clientdisconnects", "ClientDisconnects.wav"),//#22
	TOA_CHEST_OPENS("toachestopens", "ToaChestOpens.wav"),//#23
	WHITE_LIGHT_AFTER_RAID("whitelight", "WhiteLightAfterRaid.wav"),//#24
	TURNING_ON_RUN("turningonrun", "TurningOnRun.wav"),//#25
	CLICKING_PK_LOOT_CHEST("pkchest", "ClickingPkLootChest.wav"),//#26

	ACB_SPEC("acbspec", "AcbSpec_r1.wav"),//#27
	ACB_SPEC_2("acbspec", "AcbSpec_r2.wav"),//#27
	ACB_SPEC_3("acbspec", "AcbSpec_r3.wav"),

	AGS_SPEC("agsspec", "AgsSpec_r1.wav"),//#28
	AGS_SPEC_2("agsspec", "AgsSpec_r2.wav"),//#28
	AGS_SPEC_3("agsspec", "AgsSpec_r3.wav"),//#28

	DH_AXE_CHOP("dhchop", "DhAxe_chop_r1.wav"),//#29
	DH_AXE_CHOP_2("dhchop", "DhAxe_chop_r2.wav"),

	DH_AXE_HACK("dhhack", "DhAxe_hack_r1.wav"),//#29
	DH_AXE_HACK_2("dhhack", "DhAxe_hack_r2.wav"),//#29

	DH_AXE_BLOCK("dhblock", "DhAxe_block_r1.wav"),//#29
	DH_AXE_BLOCK_2("dhblock", "DhAxe_block_r2.wav"),//#29
	DH_AXE_BLOCK_3("dhblock", "DhAxe_block_r3.wav"),

	DH_AXE_SMASH("dhsmash", "DhAxe_smash_r1.wav"),//#29
	DH_AXE_SMASH_2("dhsmash", "DhAxe_smash_r2.wav"),//#29
	DH_AXE_SMASH_3("dhsmash", "DhAxe_smash_r3.wav"),//#29

	LEVEL_UP("levelup", "LevelUpCompleted_r1.wav"),
	QUEST("quest", "QuestCompleted_r1.wav"),
	ACHIEVEMENT_DIARY("achievementdiary", "AchievementDiary_r1.wav"),
	ACHIEVEMENT_DIARY_2("achievementdiary", "AchievementDiary_r2.wav"),
	EASTER_EGG_STRAYDOG_BONE("givebone", "GiveBone.wav"),

	HAIRDRESSER_SOUND_1("hairdresser", "Hairdresser_r1.wav"),
	HAIRDRESSER_SOUND_2("hairdresser", "Hairdresser_r2.wav"),
	HAIRDRESSER_SOUND_3("hairdresser", "Hairdresser_r3.wav"),

	SNOWBALL_1("snowball", "Snowball_r1.wav"),
	SNOWBALL_2("snowball", "Snowball_r2.wav"),

	WARRIOR("warriors", "odablock_warriors.wav");

	private final String resourceName;
	private final String directory;

	Sound(String directory, String resourceName)
	{
		this.directory = directory;
		this.resourceName = resourceName;
	}


	String getResourceName()
	{
		return resourceName;
	}

	String getDirectory()
	{
		return directory;
	}
}

package com.github.dappermickie.odablock;

import com.github.dappermickie.odablock.emotes.EmoteHandler;
import com.github.dappermickie.odablock.livestreams.LivestreamManager;
import com.github.dappermickie.odablock.notifications.NotificationManager;
import com.github.dappermickie.odablock.sounds.AcbSpec;
import com.github.dappermickie.odablock.sounds.AcceptTrade;
import com.github.dappermickie.odablock.sounds.AchievementDiaries;
import com.github.dappermickie.odablock.sounds.AgsSpec;
import com.github.dappermickie.odablock.sounds.CollectionLog;
import com.github.dappermickie.odablock.sounds.CombatAchievements;
import com.github.dappermickie.odablock.sounds.CoxSounds;
import com.github.dappermickie.odablock.sounds.DdsSpec;
import com.github.dappermickie.odablock.sounds.Death;
import com.github.dappermickie.odablock.sounds.DeclineTrade;
import com.github.dappermickie.odablock.sounds.DhAxe;
import com.github.dappermickie.odablock.sounds.DismissRandomEvent;
import com.github.dappermickie.odablock.sounds.EnteringBankPin;
import com.github.dappermickie.odablock.sounds.GiveBone;
import com.github.dappermickie.odablock.sounds.HairDresser;
import com.github.dappermickie.odablock.sounds.KillingPlayer;
import com.github.dappermickie.odablock.sounds.KillingRat;
import com.github.dappermickie.odablock.sounds.LevelUp;
import com.github.dappermickie.odablock.sounds.OdablockWarriors;
import com.github.dappermickie.odablock.sounds.Pet;
import com.github.dappermickie.odablock.sounds.PetDog;
import com.github.dappermickie.odablock.sounds.PkChest;
import com.github.dappermickie.odablock.sounds.PrayerDown;
import com.github.dappermickie.odablock.sounds.QuestCompleted;
import com.github.dappermickie.odablock.sounds.RedemptionProc;
import com.github.dappermickie.odablock.sounds.ReportPlayer;
import com.github.dappermickie.odablock.sounds.RubyBoltProc;
import com.github.dappermickie.odablock.sounds.SnowBalled;
import com.github.dappermickie.odablock.sounds.ToaChestLight;
import com.github.dappermickie.odablock.sounds.ToaChestOpens;
import com.github.dappermickie.odablock.sounds.TobChestLight;
import com.github.dappermickie.odablock.sounds.TurnOnRun;
import com.github.dappermickie.odablock.sounds.Vengeance;
import com.github.dappermickie.odablock.sounds.ZebakRoar;
import com.google.inject.Provides;
import com.google.inject.name.Named;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.AreaSoundEffectPlayed;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.events.PlayerSpawned;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import okhttp3.OkHttpClient;

@Slf4j
@PluginDescriptor(
	name = "Odablock Plugin",
	description = "Replace and add in-game sounds by Odablock",
	tags = {"odablock", "stats", "levels", "quests", "diary", "announce"}
)

public class OdablockPlugin extends Plugin
{
	@Inject
	private Client client;

	@Getter(AccessLevel.PACKAGE)
	@Inject
	private ClientThread clientThread;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private OdablockConfig config;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private OkHttpClient okHttpClient;


	// Start of sound injections
	@Inject
	private RedemptionProc redemptionProc;

	@Inject
	private LevelUp levelUp;

	@Inject
	private DdsSpec ddsSpec;

	@Inject
	private AgsSpec agsSpec;

	@Inject
	private Death death;

	@Inject
	private AcceptTrade acceptTrade;

	@Inject
	private PetDog petDog;

	@Inject
	private DebugScripts debugScripts;

	@Inject
	private PrayerDown prayerDown;

	@Inject
	private TurnOnRun turnOnRun;

	@Inject
	private ReportPlayer reportPlayer;

	@Inject
	private DeclineTrade declineTrade;

	@Inject
	private AcbSpec acbSpec;

	@Inject
	private DismissRandomEvent dismissRandomEvent;

	@Inject
	private RubyBoltProc rubyBoltProc;

	@Inject
	private EnteringBankPin enteringBankPin;

	@Inject
	private Pet pet;

	@Inject
	private DhAxe dhAxe;

	@Inject
	private KillingRat killingRat;

	@Inject
	private ToaChestLight toaChestLight;

	@Inject
	private ToaChestOpens toaChestOpens;

	@Inject
	private TobChestLight tobChestLight;

	@Inject
	private CollectionLog collectionLog;

	@Inject
	private QuestCompleted questCompleted;

	@Inject
	private CombatAchievements combatAchievements;

	@Inject
	private AchievementDiaries achievementDiaries;

	@Inject
	private GiveBone giveBone;

	@Inject
	private SnowBalled snowBalled;

	@Inject
	private HairDresser hairDresser;

	@Inject
	private PkChest pkChest;

	@Inject
	private Vengeance vengeance;

	@Inject
	private CoxSounds coxSounds;

	@Inject
	private ZebakRoar zebakRoar;

	@Inject
	private KillingPlayer killingPlayer;

	@Inject
	private OdablockWarriors odablockWarriors;
	// End of sound injections

	@Inject
	private LivestreamManager livestreamManager;

	@Inject
	private NotificationManager notificationManager;

	@Inject
	private ChatRightClickManager chatRightClickManager;

	@Inject
	private EmoteHandler emoteHandler;

	@Inject
	@Named("developerMode")
	private boolean developerMode;

	public static final String ODABLOCK = "Odablock";

	@Override
	protected void startUp() throws Exception
	{
		clientThread.invoke(this::setupOldMaps);
		achievementDiaries.setLastLoginTick(-1);
		prayerDown.setLastLoginTick(-1);
		emoteHandler.loadEmotes();
		executor.submit(() -> {
			PlayerKillLineManager.Setup(okHttpClient);
			SoundFileManager.ensureDownloadDirectoryExists();
			SoundFileManager.downloadAllMissingSounds(okHttpClient);
			SnowballUserManager.ensureDownloadDirectoryExists();
			SnowballUserManager.downloadSnowballUsers(okHttpClient);
		});
	}

	@Override
	protected void shutDown() throws Exception
	{
		levelUp.clear();
		achievementDiaries.clearOldAchievementDiaries();
		soundEngine.close();
	}

	private void setupOldMaps()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			levelUp.clear();
			achievementDiaries.clearOldAchievementDiaries();
		}
		else
		{
			levelUp.setOldExperience();
			achievementDiaries.setOldAchievementDiaries();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		collectionLog.onGameStateChanged(event);
		switch (event.getGameState())
		{
			case LOGIN_SCREEN:
			case HOPPING:
			case LOGGING_IN:
			case LOGIN_SCREEN_AUTHENTICATOR:
				levelUp.clear();
				achievementDiaries.clearOldAchievementDiaries();
			case CONNECTION_LOST:
				// set to -1 here in-case of race condition with varbits changing before this handler is called
				// when game state becomes LOGGED_IN
				//soundEngine.playClip(Sound.CLIENT_DISCONNECTS, executor);

				achievementDiaries.setLastLoginTick(-1);
				prayerDown.setLastLoginTick(-1);
				collectionLog.setlastColLogSettingWarning();
				break;
			case LOGGED_IN:
				final int currentTick = client.getTickCount();
				achievementDiaries.setLastLoginTick(currentTick);
				prayerDown.setLastLoginTick(currentTick);
				break;
		}
	}

	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		levelUp.onStatChanged(statChanged);
	}

	@Subscribe
	public void onActorDeath(ActorDeath actorDeath)
	{
		death.onActorDeath(actorDeath);
	}


	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		emoteHandler.onChatMessage(chatMessage);

		if (acceptTrade.onChatMessage(chatMessage))
		{
			return;
		}
		else if (petDog.onChatMessage(chatMessage))
		{
			return;
		}
		else if (pet.onChatMessage(chatMessage))
		{
			return;
		}
		else if (killingRat.onChatMessage(chatMessage))
		{
			return;
		}
		else if (chatMessage.getType() != ChatMessageType.GAMEMESSAGE && chatMessage.getType() != ChatMessageType.SPAM)
		{
			return;
		}
		else if (collectionLog.onChatMessage(chatMessage))
		{
			return;

		}
		else if (questCompleted.onChatMessage(chatMessage))
		{
			return;
		}
		else if (combatAchievements.onChatMessage(chatMessage))
		{
			return;
		}
		else if (giveBone.onChatMessage(chatMessage))
		{
			return;
		}
		else if (killingPlayer.onChatMessage(chatMessage))
		{
			return;
		}
		else if (coxSounds.onChatMessage(chatMessage))
		{
			return;
		}
	}

	@Subscribe
	private void onOverheadTextChanged(OverheadTextChanged event)
	{
		emoteHandler.onOverheadTextChanged(event);
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		if (developerMode && config.developerLogging())
		{
			debugScripts.onVarbitChanged(event);
		}

		vengeance.onVarbitChanged(event);
		turnOnRun.onVarbitChanged(event);
		dhAxe.onVarbitChanged(event);
		tobChestLight.onVarbitChanged(event);
		collectionLog.onVarbitChanged(event);
		achievementDiaries.onVarbitChanged(event);
		killingPlayer.onVarbitChanged(event);
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		if (developerMode && config.developerLogging())
		{
			debugScripts.onMenuOptionClicked(menuOptionClicked);
		}

		petDog.onMenuOptionClicked(menuOptionClicked);
		turnOnRun.onMenuOptionClicked(menuOptionClicked);
		reportPlayer.onMenuOptionClicked(menuOptionClicked);
		declineTrade.onMenuOptionClicked(menuOptionClicked);
		dismissRandomEvent.onMenuOptionClicked(menuOptionClicked);
		odablockWarriors.onMenuOptionClicked(menuOptionClicked);
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (developerMode && config.developerLogging())
		{
			debugScripts.onWidgetLoaded(event);
		}

		hairDresser.onWidgetLoaded(event);
		pkChest.onWidgetLoaded(event);
		odablockWarriors.onWidgetLoaded(event);
	}

	@Subscribe
	public void onPlayerSpawned(PlayerSpawned playerSpawned)
	{
		snowBalled.onPlayerSpawned(playerSpawned);
	}

	@Subscribe
	public void onPlayerDespawned(PlayerDespawned playerDespawned)
	{
		snowBalled.onPlayerDespawned(playerDespawned);
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		killingRat.onNpcDespawned(npcDespawned);
	}

	@Subscribe
	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		snowBalled.onProjectileMoved(projectileMoved);
	}

	@Provides
	OdablockConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(OdablockConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (OdablockConfig.CONFIG_GROUP.equals(event.getGroup()))
		{
			collectionLog.onConfigChanged(event);
		}
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		killingRat.onInteractingChanged(event);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}
		final Player local = client.getLocalPlayer();
		int currentTick = client.getTickCount();

		redemptionProc.onTick(currentTick, local);
		ddsSpec.onTick(currentTick, local);
		agsSpec.onTick(currentTick, local);
		prayerDown.onGameTick(event);
		tobChestLight.onGameTick(event);
		coxSounds.onGameTick(event);
		livestreamManager.onGameTick(event);
		notificationManager.onGameTick(event);
		chatRightClickManager.onGameTick(event);

		// Should always happen after all tick events
		cleanupTicks(currentTick);
	}

	private void cleanupTicks(final int currentTick)
	{
		agsSpec.cleanupTicks(currentTick);
		ddsSpec.cleanupTicks(currentTick);
		petDog.cleanupTicks(currentTick);
		redemptionProc.cleanupTicks(currentTick);
	}

	@Subscribe
	public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed event)
	{
		acbSpec.onAreaSoundEffectPlayed(event);
	}

	@Subscribe
	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		rubyBoltProc.onSoundEffectPlayed(event);
		enteringBankPin.onSoundEffectPlayed(event);
		redemptionProc.onSoundPlayed(event);
		agsSpec.onSoundEffectPlayed(event);
		ddsSpec.onSoundEffectPlayed(event);
		prayerDown.onSoundEffectPlayed(event);
		zebakRoar.onSoundEffectPlayed(event);
		acbSpec.onSoundEffectPlayed(event);
	}

	@Subscribe
	public void onWallObjectSpawned(final WallObjectSpawned event)
	{
		toaChestLight.onWallObjectSpawned(event);
	}

	@Subscribe
	private void onGameObjectSpawned(GameObjectSpawned event)
	{
		toaChestOpens.onGameObjectSpawned(event);
		tobChestLight.onGameObjectSpawned(event);
	}

	@Subscribe
	private void onGameObjectDespawned(GameObjectDespawned event)
	{
		tobChestLight.onGameObjectDespawned(event);
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent scriptCallbackEvent)
	{
		if (developerMode && config.developerLogging())
		{
			debugScripts.onScriptCallbackEvent(scriptCallbackEvent);
		}
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted event)
	{
		emoteHandler.onCommandExecuted(event);
		//if(event.getCommand().equals("loadwarrior")) {
		//	odablockWarriors.onWidgetLoaded(null);
		//}
	}

	public static int TO_GROUP(int id)
	{
		return id >>> 16;
	}
}

package com.github.dappermickie.odablock;

import com.github.dappermickie.odablock.notifications.Notification;
import com.google.gson.Gson;
import java.util.HashMap;
import java.util.Map;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptEvent;
import net.runelite.api.events.GameTick;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.JavaScriptCallback;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.Text;
import okhttp3.OkHttpClient;

@Slf4j
@Singleton
public class ChatRightClickManager
{
	private final Map<String, RightClickAction> rightClickable = new HashMap<>();

	@Inject
	private Client client;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Inject
	private ClientThread clientThread;

	public void onGameTick(GameTick event)
	{
		Widget chatWidget = client.getWidget(ComponentID.CHATBOX_MESSAGE_LINES);
		if (chatWidget != null)
		{
			for (Widget w : chatWidget.getDynamicChildren())
			{
				String untaggedText = Text.standardize(w.getText());

				if (rightClickable.containsKey(untaggedText))
				{
					RightClickAction rightClickAction = rightClickable.get(untaggedText);
					clientThread.invokeLater(() -> {
						w.setAction(5, rightClickAction.getAction());
						w.setOnOpListener((JavaScriptCallback) (ScriptEvent ev) -> {
							openLink(rightClickAction);
						});
						w.setHasListener(true);
						w.setNoClickThrough(false);
						w.revalidate();
					});
				}
				else
				{
					clientThread.invokeLater(() -> {
						w.setHasListener(false);
						w.setNoClickThrough(false);
						w.revalidate();
					});
				}
			}
		}
	}

	public void putInMap(String message, RightClickAction rightClickAction)
	{
		String key = Text.standardize(message);
		rightClickable.put(key, rightClickAction);
	}

	private void openLink(RightClickAction rightClickAction)
	{
		LinkBrowser.browse(rightClickAction.getLink());
		//log.info("Opened a link to Odablocks notification!");
	}
}

package com.github.dappermickie.odablock;

import lombok.Getter;

public class RightClickAction
{
	public RightClickAction(String action, String link)
	{
		this.action = action;
		this.link = link;
	}

	@Getter
	private final String action;
	@Getter
	private final String link;
}

package com.github.dappermickie.odablock;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(OdablockConfig.CONFIG_GROUP)
public interface OdablockConfig extends Config
{
	String CONFIG_GROUP = "odablockplugin";

	@ConfigItem(
		keyName = "rubyBoltProc",
		name = "Ruby Bolt SLAAA",
		description = "Should the ruby bolt proc be replaced with oda's SLAAA?",
		position = 0
	)
	default boolean rubyBoltProc()
	{
		return true;
	}

	@ConfigItem(
		keyName = "zebakRoar",
		name = "Zebak Roar",
		description = "Should the zebak roar be replaced with oda's SLAAA?",
		position = 1
	)
	default boolean zebakRoar()
	{
		return true;
	}

	@ConfigItem(
		keyName = "vengeance",
		name = "Vengeance",
		description = "Should oda's 'Invisivengene' play whenever you cast vengeance?",
		position = 2
	)
	default boolean vengeance()
	{
		return true;
	}

	@ConfigItem(
		keyName = "playerKilling",
		name = "Player Killing",
		description = "Should Odablock tell you something when you kill a player? (only works if you're still close to the player when he dies)",
		position = 3
	)
	default boolean playerKilling()
	{
		return true;
	}

	@ConfigItem(
		keyName = "onlyForOwnPlayer",
		name = "Only Own Player",
		description = "Should Odablock sounds play for your player only? (ags, dds spec ...)",
		position = 4
	)
	default boolean ownPlayerOnly()
	{
		return true;
	}

	@ConfigItem(
		keyName = "ddsSpec",
		name = "DDS Spec",
		description = "Should Odablock sounds play for your dds spec?",
		position = 5
	)
	default boolean ddsSpec()
	{
		return true;
	}

	@ConfigItem(
		keyName = "agsSpec",
		name = "AGS Spec",
		description = "Should Odablock sounds play for ags spec?",
		position = 6
	)
	default boolean agsSpec()
	{
		return true;
	}

	@ConfigItem(
		keyName = "acbSpec",
		name = "ACB Spec",
		description = "Should Odablock sounds play for acb spec? (only works with soudns on)",
		position = 7
	)
	default boolean acbSpec()
	{
		return true;
	}

	@ConfigItem(
		keyName = "bankPin",
		name = "Bank Pin",
		description = "Should Odablock make the 'ai ai ai ai' sound when you type in your bank pin?",
		position = 8
	)
	default boolean bankPin()
	{
		return true;
	}

	@ConfigItem(
		keyName = "turnOnRun",
		name = "Turn on run",
		description = "Should Odablock say 'FAST! I said FAST!' sound when you turn your run on?",
		position = 9
	)
	default boolean turnOnRun()
	{
		return true;
	}

	@ConfigItem(
		keyName = "petDog",
		name = "Pet the Dog",
		description = "Should Stella say 'Who's a good little zoggy!' when you pet the dog?",
		position = 10
	)
	default boolean petDog()
	{
		return true;
	}

	@ConfigItem(
		keyName = "dismissRandomEvent",
		name = "Dismiss random event",
		description = "Should Odablock say 'No sanks!' when you dismiss a random event?",
		position = 11
	)
	default boolean dismissRandomEvent()
	{
		return true;
	}

	@ConfigItem(
		keyName = "declineTrade",
		name = "Decline Trade",
		description = "Should Odablock say 'No Sanks!' when you decline a trade?",
		position = 12
	)
	default boolean declineTrade()
	{
		return true;
	}


	@ConfigItem(
		keyName = "acceptTrade",
		name = "Accept Trade",
		description = "Should Odablock say 'Oda the generous strikes again!' when you accept a trade?",
		position = 13
	)
	default boolean acceptTrade()
	{
		return true;
	}

	@ConfigItem(
		keyName = "sendReport",
		name = "Send Report",
		description = "Should Odablock say 'Reported for salutations!' when you report someone?",
		position = 14
	)
	default boolean sendReport()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceLevelUp",
		name = "Level ups",
		description = "Should Odablock announce when you gain a level in a skill?",
		position = 15
	)
	default boolean announceLevelUp()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceLevelUpIncludesVirtual",
		name = "Include virtual level ups",
		description = "Should Odablock announce when you gain a virtual (>99) level in a skill?",
		position = 16
	)
	default boolean announceLevelUpIncludesVirtual()
	{
		return false;
	}

	@ConfigItem(
		keyName = "announceQuestCompletion",
		name = "Quest completions",
		description = "Should Odablock announce when you complete a quest?",
		position = 17
	)
	default boolean announceQuestCompletion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "prayerMessage",
		name = "Prayer Message",
		description = "Should Odablock let you know when you run out of prayer?",
		position = 18
	)
	default boolean prayerMessage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "redemptionMessage",
		name = "Redemption Message",
		description = "Should Odablock let you know when you proc a redemption?",
		position = 19
	)
	default boolean redemptionMessage()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceCollectionLog",
		name = "New collection log entry",
		description = "Should Odablock announce when you fill in a new slot in your collection log? This one relies on you having chat messages (included with the popup option) enabled in game settings!",
		position = 20
	)
	default boolean announceCollectionLog()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceAchievementDiary",
		name = "Completed achievement diaries",
		description = "Should Odablock announce when you complete a new achievement diary?",
		position = 21
	)
	default boolean announceAchievementDiary()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceCombatAchievement",
		name = "Completed combat achievement tasks",
		description = "Should Odablock announce when you complete a new combat achievement task?",
		position = 22
	)
	default boolean announceCombatAchievement()
	{
		return true;
	}

	@ConfigItem(
		keyName = "announceDeath",
		name = "When you die",
		description = "Should Odablock say something when you die?",
		position = 23
	)
	default boolean announceDeath()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showChatMessages",
		name = "Show fake public chat message (only you will see it)",
		description = "Should Odablock announce your achievements in game chat as well as audibly?",
		position = 24
	)
	default boolean showChatMessages()
	{
		return true;
	}

	@Range(
		min = 0,
		max = 200
	)
	@ConfigItem(
		keyName = "announcementVolume",
		name = "Announcement volume",
		description = "Adjust how loud the audio announcements are played!",
		position = 25
	)
	default int announcementVolume()
	{
		return 100;
	}

	@ConfigItem(
		keyName = "dhAxe",
		name = "DH/Soulreaper Axe sounds",
		description = "Should Odablock say something whenever you switch styles on your DH or soulreaper axe?",
		position = 26
	)
	default boolean dhAxe()
	{
		return true;
	}

	@ConfigItem(
		keyName = "giveBone",
		name = "Give Bone",
		description = "Should stella say something whenever you give a bone to a dog?",
		position = 27
	)
	default boolean giveBone()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hairDresser",
		name = "Hairdresser",
		description = "Should Odablock say something whenever you open up the hairdresser interface in falador?",
		position = 28
	)
	default boolean hairDresser()
	{
		return true;
	}

	@ConfigItem(
		keyName = "killingRat",
		name = "Killing rat (or scurrius)",
		description = "Should Odablock say something whenever you kill a rat or Scurrius?",
		position = 29
	)
	default boolean killingRat()
	{
		return true;
	}

	@ConfigItem(
		keyName = "receivedPet",
		name = "Received pet",
		description = "Should Odablock say something whenever you receive a pet?",
		position = 29
	)
	default boolean receivedPet()
	{
		return true;
	}

	@ConfigItem(
		keyName = "pkChest",
		name = "PK Chest",
		description = "Should Odablock say something whenever you open the PK chest?",
		position = 30
	)
	default boolean pkChest()
	{
		return true;
	}

	@ConfigItem(
		keyName = "snowballed",
		name = "Snowballed",
		description = "Should Odablock say something whenever you get snowballed by Odablock or one of his mods?",
		position = 31
	)
	default boolean snowballed()
	{
		return true;
	}

	@ConfigItem(
		keyName = "emotes",
		name = "Emotes",
		description = "Configures whether or not some of the text in game gets replaced with Odablock's emotes.<br />type '::odaemotes' in chat to see a list of all available emotes.",
		position = 32
	)
	default boolean emotes()
	{
		return true;
	}

	@ConfigItem(
		keyName = "emoteIgnoreList",
		name = "Emote Ignore List",
		description = "A comma separated list of emotes to ignore for example: \":p, :)\".<br />type '::odaemotes' in chat to see a list of all available emotes.",
		position = 33
	)
	default String emoteIgnoreList()
	{
		return "";
	}

	@ConfigItem(
		keyName = "warriors",
		name = "Odablock Warriors",
		description = "Should the '7th Realm' in-game sound be replaced with the Odablock Warriors song?",
		position = 34,
		warning = "If you turn this off, you'll have to reload the client to be able to manually play '7th Realm' again."
	)
	default boolean warriors()

	{
		return true;
	}

	@ConfigSection(
		name = "Tombs of Amascut",
		description = "All the configurations regarding Tombs of Amascut.",
		position = 100
	)
	String TOA_SECTION = "toaSection";

	@ConfigItem(
		keyName = "toaWhiteChest",
		name = "TOA White Chest",
		description = "When enabled, Odablock will say something if you receive a white light.",
		section = TOA_SECTION,
		position = 101
	)
	default boolean toaWhiteChest()
	{
		return true;
	}

	@ConfigItem(
		keyName = "toaPurpleChest",
		name = "TOA Purple Chest",
		description = "When enabled, Odablock will say something if you receive a purple.",
		section = TOA_SECTION,
		position = 102
	)
	default boolean toaPurpleChest()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableToaPurpleChestOpens",
		name = "Opening The Chest",
		description = "When enabled, Odablock will say 'Please GAGECK' whenever someone in your party opens the purple chest at TOA.",
		section = TOA_SECTION,
		position = 103
	)
	default boolean toaPurpleChestOpens()
	{
		return true;
	}

	@ConfigSection(
		name = "Theatre of Blood",
		description = "All the configurations regarding Theatre of Blood.",
		position = 200
	)
	String TOB_SECTION = "tobSection";

	@ConfigItem(
		keyName = "tobWhiteChest",
		name = "TOB White chest",
		description = "Should Odablock say something whenever you receive a white chest at TOB?",
		section = TOB_SECTION,
		position = 201
	)
	default boolean tobWhiteChest()
	{
		return true;
	}

	@ConfigItem(
		keyName = "tobPurpleChest",
		name = "TOB Purple chest",
		description = "Should Odablock say something whenever you receive a purple chest at TOB?",
		section = TOB_SECTION,
		position = 202
	)
	default boolean tobPurpleChest()
	{
		return true;
	}

	@ConfigSection(
		name = "Chambers of Xeric",
		description = "All the configurations regarding Chambers of Xeric.",
		position = 300
	)
	String COX_SECTION = "coxSection";

	@ConfigItem(
		keyName = "coxWhiteChest",
		name = "COX White chest",
		description = "Should Odablock say something whenever you get a white light at COX?",
		section = COX_SECTION,
		position = 301
	)
	default boolean coxWhiteChest()
	{
		return true;
	}

	@ConfigItem(
		keyName = "coxPurpleChest",
		name = "COX Purple chest",
		description = "Should Odablock say something whenever you get a purple light at COX?",
		section = COX_SECTION,
		position = 302
	)
	default boolean coxPurpleChest()
	{
		return true;
	}

	@ConfigSection(
		name = "Livestream",
		description = "All livestream configurations.",
		position = 400
	)
	String LIVESTREAM_SECTION = "livestreamSection";

	@ConfigItem(
		keyName = "livestream",
		name = "Livestream Notification",
		description = "Should Odablock send a message whenever he is live?",
		section = LIVESTREAM_SECTION,
		position = 401
	)
	default boolean livestream()
	{
		return true;
	}

	@ConfigItem(
		keyName = "livestreamInterval",
		name = "Notification Interval",
		description = "Set the interval of the notification message for livestreams in minutes.",
		section = LIVESTREAM_SECTION,
		position = 402
	)
	default int livestreamInterval()
	{
		return 30;
	}

	@ConfigItem(
		keyName = "livestreamColor",
		name = "Notification Color",
		description = "Set the color of the notification message for livestreams.",
		section = LIVESTREAM_SECTION,
		position = 402
	)
	default Color livestreamColor()
	{
		return Color.RED;
	}

	@ConfigSection(
		name = "Notifications",
		description = "All notification configurations.",
		position = 500
	)
	String NOTIFICATION_SECTION = "notificationSection";

	@ConfigItem(
		keyName = "notification",
		name = "Odablock Notifications",
		description = "Should Odablock send out notifications?",
		section = NOTIFICATION_SECTION,
		position = 501
	)
	default boolean notifications()
	{
		return true;
	}

	@ConfigItem(
		keyName = "notificationColor",
		name = "Notification Color",
		description = "Set the color of the notification messages.",
		section = NOTIFICATION_SECTION,
		position = 502
	)
	default Color notificationColor()
	{
		return Color.RED;
	}

	@ConfigSection(
		name = "Developer",
		description = "Developer mode configurations.",
		position = 600
	)
	String DEVELOPER_SECTION = "developerSection";

	@ConfigItem(
		keyName = "developerLogging",
		name = "Developer Logging",
		description = "Enable developer logging when developer mode is active.",
		section = DEVELOPER_SECTION,
		position = 601
	)
	default boolean developerLogging()
	{
		return false;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameTick;
import net.runelite.client.util.Text;

@Singleton
@Slf4j
public class CoxSounds
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private Random random = new Random();

	// YOINK from https://github.com/AnkouOSRS/cox-light-colors/blob/master/src/main/java/com/coxlightcolors/CoxLightColorsPlugin.java#L82

	private static final Pattern SPECIAL_DROP_MESSAGE = Pattern.compile("(.+) - (.+)");
	private int endedRaidTick = -1;
	private boolean isWhiteLight = true;

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.coxWhiteChest() && !config.coxPurpleChest())
		{
			return false;
		}
		if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null)
		{
			return false;
		}

		if (chatMessage.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION)
		{
			String message = Text.removeTags(chatMessage.getMessage());

			if (message.contains("your raid is complete!"))
			{
				isWhiteLight = true;
				endedRaidTick = client.getTickCount();
				return true;
			}

			Matcher matcher = SPECIAL_DROP_MESSAGE.matcher(message);

			if (matcher.find())
			{
				final String dropReceiver = Text.sanitize(matcher.group(1)).trim();
				// Maybe we can play a different sound if it's a twisted bow?
				final String dropName = matcher.group(2).trim();

				// We might want to play a different sound if you're the one receiving the purple
				if (dropReceiver.equals(Text.sanitize(client.getLocalPlayer().getName())))
				{
					isWhiteLight = false;
				}
				else
				{
					isWhiteLight = false;
				}
				return true;
			}
		}

		return false;
	}

	public void onGameTick(GameTick event)
	{
		if (endedRaidTick != -1 && client.getTickCount() - endedRaidTick == 2)
		{
			if (isWhiteLight)
			{
				if (config.coxWhiteChest())
				{
					soundEngine.playClip(Sound.WHITE_LIGHT_AFTER_RAID, executor);
				}
			}
			else if (config.coxPurpleChest())
			{
				soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.SoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class RedemptionProc extends TimedSoundBase
{

	private boolean redemptionHasProcced = false;

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	RedemptionProc()
	{
		super(5);
	}

	public void onTick(int currentTick, Player local)
	{
		if (config.redemptionMessage() && !redemptionHasProcced)
		{

			boolean procced = local.hasSpotAnim(AnimationIds.REDEMPTION_PROC.Id);
			if (procced)
			{
				if (canPlaySound(currentTick))
				{
					redemptionHasProcced = true;
					setLastPlayedTickTick(currentTick);
					if (config.showChatMessages())
					{
						//TODO: Add different chat message
						client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "Your redemption has procced.", null);
					}
					soundEngine.playClip(Sound.REDEMPTION_PROC, executor);
					return;
				}
			}
		}
	}

	@Override
	public void cleanupTicks(int currentTick)
	{
		int lastRedemptionProcTick = getLastPlayedTick();
		if (redemptionHasProcced &&
			lastRedemptionProcTick != currentTick &&
			currentTick - lastRedemptionProcTick > getTickDelay())
		{
			setLastPlayedTickTick(-1);
			redemptionHasProcced = false;
		}
	}

	public void onSoundPlayed(SoundEffectPlayed event)
	{
		Player local = client.getLocalPlayer();
		int soundId = event.getSoundId();

		if (config.redemptionMessage())
		{
			if (local == event.getSource())
			{
				if (soundId == SoundIds.REDEMPTION_PROC.Id)
				{
					event.consume();
					return;
				}
			}
		}
	}

	public boolean HasRedemptionProcced()
	{
		return redemptionHasProcced;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Random;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.InteractingChanged;
import net.runelite.api.events.NpcDespawned;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Singleton
@Slf4j
public class KillingRat extends TimedSoundBase
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private NpcUtil npcUtil;

	private NPC currentlyInteractingWithRat;
	private int lastInteractedWithRatTick = -1;

	private static final Pattern KILLCOUNT_PATTERN = Pattern.compile("Your Scurrius kill count is:.*");

	private String[] ratNames = new String[]{
		"rat",
		"giant rat",
		"scurrius",
		"zombie rat",
		"brine rat",
		"hell-rat behemoth",
		"dungeon rat",
		"crypt rat",
		"giant crypt rat",
		"giant rat (scurrius)" // ?
	};

	KillingRat()
	{
		super(10);
	}

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.killingRat())
		{
			return false;
		}

		if (chatMessage.getName() != "")
		{
			return false;
		}

		int currentTick = client.getTickCount();
		if (!canPlaySound(currentTick))
		{
			return false;
		}

		if (!KILLCOUNT_PATTERN.matcher(chatMessage.getMessage()).matches())
		{
			return false;
		}

		setLastPlayedTickTick(currentTick);
		soundEngine.playClip(Sound.KILLING_RAT_OR_SCURRIUS_1, executor);
		return true;
	}

	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		if (!config.killingRat())
		{
			return;
		}
		int currentTick = client.getTickCount();
		if (!canPlaySound(currentTick))
		{
			return;
		}

		NPC npc = npcDespawned.getNpc();

		if (npc != currentlyInteractingWithRat)
		{
			return;
		}

		if (!npcUtil.isDying(npc))
		{
			return;
		}

		if (!isNpcRat(npc))
		{
			return;
		}

		if (currentTick - lastInteractedWithRatTick > 10)
		{
			// Someone else probably killed it
			return;
		}

		setLastPlayedTickTick(currentTick);
		soundEngine.playClip(Sound.KILLING_RAT_OR_SCURRIUS_1, executor);
	}


	public void onInteractingChanged(InteractingChanged event)
	{
		// Check if we don't have a player, return
		if (!(event.getSource() instanceof Player) && !(event.getTarget() instanceof Player))
		{
			return;
		}

		Player player;
		NPC npc;

		// Check if source is player
		if (event.getSource() instanceof Player)
		{
			// Check if target is npc, if not return
			if (!(event.getTarget() instanceof NPC))
			{
				return;
			}
			player = (Player) event.getSource();
			npc = (NPC) event.getTarget();
		}
		else
		{
			// Check if source is npc, if not return
			if (!(event.getSource() instanceof NPC))
			{
				return;
			}
			player = (Player) event.getTarget();
			npc = (NPC) event.getSource();
		}

		Player localPlayer = client.getLocalPlayer();
		// We must be interacting with the npc
		if (player != localPlayer)
		{
			return;
		}

		// Check if npc is rat
		if (!isNpcRat(npc))
		{
			return;
		}
		lastInteractedWithRatTick = client.getTickCount();
		currentlyInteractingWithRat = npc;
	}

	private boolean isNpcRat(NPC npc)
	{
		String name = Text.standardize(npc.getName());
		for (String ratName : ratNames)
		{
			if (ratName.equals(name))
			{
				return true;
			}
		}

		return false;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.client.util.Text;

@Singleton
@Slf4j
public class Pet
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private int receivedPetTick = -1;
	private final String normalPetMessage = "You have a funny feeling like you're being followed.";
	private final String backpackPetMessage = "You feel something weird sneaking into your backpack.";
	private final String wouldHavePetMessage = "You have a funny feeling like you would have been followed...";

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.receivedPet())
		{
			return false;
		}
		String message = Text.standardize(chatMessage.getMessage());
		// Make sure it's one of the pet messages and not sent by a user to troll
		if ((message.equals(normalPetMessage) || message.equals(backpackPetMessage) || message.equals(wouldHavePetMessage)) &&
			chatMessage.getType() == ChatMessageType.GAMEMESSAGE)
		{
			receivedPetTick = client.getTickCount();
			soundEngine.playClip(Sound.NEW_PET, executor);
			return true;
		}

		return false;
	}

	public int getReceivedPetTick()
	{
		return receivedPetTick;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class AcceptTrade
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		// Accepting a trade logic, only play sound when message is sent by game
		if (config.acceptTrade() &&
			Text.standardize(chatMessage.getMessage()).equals("accepted trade.") &&
			chatMessage.getName() == "")
		{
			soundEngine.playClip(Sound.ACCEPTED_TRADE, executor);
			return true;
		}
		return false;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import com.github.dappermickie.odablock.SoundIds;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Skill;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class PrayerDown
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	RedemptionProc redemptionProc;

	private int previousPrayerValue = -1;
	private boolean notifyPrayer = false;
	private int lastLoginTick = -1;

	public void setLastLoginTick(int tick)
	{
    	lastLoginTick = tick;
	}

	public void onGameTick(GameTick event)
	{
		if (config.prayerMessage() && checkLowPrayer() && client.getTickCount() - lastLoginTick > 2 && lastLoginTick != -1)
		{
			soundEngine.playClip(Sound.SMITED_NO_PRAYER, executor);
		}
	}

	private boolean checkLowPrayer()
	{
		int currentPrayerValue = client.getBoostedSkillLevel(Skill.PRAYER);
		if (previousPrayerValue != currentPrayerValue)
		{
			previousPrayerValue = currentPrayerValue;
		}
		else
		{
			return false;
		}
		if (currentPrayerValue <= 0)
		{
			if (!notifyPrayer &&
				!redemptionProc.HasRedemptionProcced())
			{
				notifyPrayer = true;
				return true;
			}
		}
		else
		{
			notifyPrayer = false;
		}
		return false;
	}

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();

		if (config.prayerMessage())
		{
			//if(!config.ownPlayerOnly() || (config.ownPlayerOnly() && local == event.getSource())) {
			if (soundId == SoundIds.PRAYER_DOWN.Id)
			{
				event.consume();
				return;
			}
			//}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ActorDeath;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class Death
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;


	public void onActorDeath(ActorDeath actorDeath)
	{
		if (config.announceDeath() && actorDeath.getActor() == client.getLocalPlayer())
		{
			if (config.showChatMessages())
			{
				client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "It must be a glitch?!?!", null);
			}
			soundEngine.playClip(Sound.DEATH, executor);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import com.github.dappermickie.odablock.SoundIds;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.SoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class RubyBoltProc
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		final Player local = client.getLocalPlayer();

		if (config.rubyBoltProc())
		{
			if (soundId == SoundIds.RUBY_BOLT_PROC.Id)
			{
				event.consume();
				soundEngine.playClip(Sound.RUBY_PROC, executor);
				return;
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import com.github.dappermickie.odablock.SoundIds;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.SoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class EnteringBankPin
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();

		if (config.bankPin())
		{
			if (soundId == SoundIds.BANK_PIN.Id)
			{
				event.consume();
				soundEngine.playClip(Sound.TYPING_IN_BANKPIN, executor);
				return;
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import com.github.dappermickie.odablock.SoundIds;
import java.util.Random;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.AreaSoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import net.runelite.api.events.SoundEffectPlayed;

@Singleton
@Slf4j
public class AcbSpec
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;
	private final String message = "ACB SPECCLE!";

	public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		if (config.acbSpec())
		{
			if (soundId == SoundIds.ACB_SPEC.Id)
			{
				event.consume();
				soundEngine.playClip(Sound.ACB_SPEC, executor);
				if (config.showChatMessages())
				{
					client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
				}
				return;
			}
		}
	}

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		final Player local = client.getLocalPlayer();

		if (config.acbSpec())
		{
			if (soundId == SoundIds.ACB_SPEC.Id)
			{
				event.consume();
				soundEngine.playClip(Sound.ACB_SPEC, executor);
				if (config.showChatMessages())
				{
					client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
				}
				return;
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

@Singleton
@Slf4j
public class QuestCompleted
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final Pattern QUEST_REGEX = Pattern.compile("Congratulations, you've completed a quest:.*");

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.announceQuestCompletion() || !QUEST_REGEX.matcher(chatMessage.getMessage()).matches())
		{
			return false;
		}
		if (config.showChatMessages())
		{
			client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "Quest: completed.", null);
		}
		soundEngine.playClip(Sound.QUEST, executor);
		return true;
	}
}

package com.github.dappermickie.odablock.sounds;


import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;

public class OdablockWarriors
{
	@Inject
	private Client client;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private OdablockConfig config;

	private Widget warriorWidget = null;

	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (!config.warriors())
		{
			return;
		}
		Widget musicWidget = client.getWidget(15663110);

		if (musicWidget == null)
		{
			return;
		}

		for (Widget w : musicWidget.getDynamicChildren())
		{
			if (w.getText().equals("7th Realm") || w.getText().equals("Odablock Warriors"))
			{
				w.setText("Odablock Warriors");
				w.setName("<col=ff9040>Odablock Warriors</col>");
				w.setTextColor(901389);
				w.revalidate();
				warriorWidget = w;
				return;
			}
		}
	}

	public void onMenuOptionClicked(MenuOptionClicked event)
	{
		if (warriorWidget == null)
		{
			return;
		}
		if (event.getWidget() != warriorWidget)
		{
			return;
		}

		event.consume();

		soundEngine.playClip(Sound.WARRIOR, executor);
	}
}

package com.github.dappermickie.odablock.sounds;


import com.github.dappermickie.odablock.DhAxeStyles;
import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.OdablockVarbitValues;
import com.github.dappermickie.odablock.OdablockVarbits;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.EquipmentInventorySlot;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;

@Singleton
@Slf4j
public class DhAxe extends TimedSoundBase
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;
	@Getter(AccessLevel.PACKAGE)
	@Inject
	private ClientThread clientThread;

	private static final Random random = new Random();

	private int current43 = -1;
	private int current46 = -1;
	private int current843 = 0;
	private DhAxeStyles dhAxeStyle;
	private final int[] dhAxeIds = new int[]{ItemID.DHAROKS_GREATAXE, ItemID.DHAROKS_GREATAXE_100, ItemID.DHAROKS_GREATAXE_75, ItemID.DHAROKS_GREATAXE_50, ItemID.DHAROKS_GREATAXE_25, ItemID.SOULREAPER_AXE, ItemID.SOULREAPER_AXE_28338, ItemID.DHAROKS_GREATAXE_25516};

	DhAxe()
	{
		super(5);
	}

	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		final int varpId = varbitChanged.getVarpId();
		final int value = varbitChanged.getValue();

		// Always set current values because if you switch weapons and the values stay the same, this method won't get triggered
		if (varpId == OdablockVarbits.COMBAT_STYLE_43.VarpId)
		{
			current43 = value;
		}
		else if (varpId == OdablockVarbits.COMBAT_STYLE_46.VarpId)
		{
			current46 = value;
		}
		else if (varpId == OdablockVarbits.IS_WEARING_WEAPON.VarpId)
		{
			current843 = value;
		}
		else
		{
			return;
		}

		if (!config.dhAxe())
		{
			return;
		}
		clientThread.invokeLater(this::playSound);
	}

	public void playSound()
	{
		// Only necessary to do any checks if we're wearing the dh axe
		// And if we're not depositing worn items to the bank
		if (!isUsingDhAxe())
		{
			return;
		}

		Sound sound = getSoundForDhAxeStyle();
		if (sound == null)
		{
			return;
		}
		final int currentTick = client.getTickCount();
		if (canPlaySound(currentTick))
		{
			soundEngine.playClip(sound, executor);

			setLastPlayedTickTick(currentTick);
		}
	}

	private boolean isUsingDhAxe()
	{
		if (current843 == 0)
		{
			return false;
		}

		final ItemContainer itemContainer = client.getItemContainer(InventoryID.EQUIPMENT);
		if (itemContainer == null)
		{
			return false;
		}
		final Item item = itemContainer.getItem(EquipmentInventorySlot.WEAPON.getSlotIdx());
		if (item == null)
		{
			return false;
		}
		final int itemId = item.getId();

		for (int id : dhAxeIds)
		{
			if (id == itemId)
			{
				return true;
			}
		}

		return false;
	}

	private Sound getSoundForDhAxeStyle()
	{
		Sound sound = null;
		if (current43 == OdablockVarbitValues.COMBAT_STYLE_43_0.Value &&
			current46 == OdablockVarbitValues.COMBAT_STYLE_46_1.Value)
		{
			sound = Sound.DH_AXE_CHOP;
		}
		else if (current43 == OdablockVarbitValues.COMBAT_STYLE_43_1.Value &&
			current46 == OdablockVarbitValues.COMBAT_STYLE_46_2.Value)
		{
			sound = Sound.DH_AXE_HACK;
		}
		else if (current43 == OdablockVarbitValues.COMBAT_STYLE_43_2.Value &&
			current46 == OdablockVarbitValues.COMBAT_STYLE_46_2.Value)
		{
			sound = Sound.DH_AXE_SMASH;
		}
		else if (current43 == OdablockVarbitValues.COMBAT_STYLE_43_3.Value &&
			current46 == OdablockVarbitValues.COMBAT_STYLE_46_3.Value)
		{
			sound = Sound.DH_AXE_BLOCK;
		}
		return sound;
	}
}

package com.github.dappermickie.odablock.sounds;

// Special thanks to https://github.com/Maurits825/tob-light-colors

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;

@Singleton
@Slf4j
public class TobChestLight
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private ClientThread clientThread;

	private static final int YOUR_TOB_CHEST_PURPLE_OBJ = 32993;
	private static final int YOUR_TOB_CHEST_NORMAL_OBJ = 32992;
	private static final int OTHER_TOB_CHEST_PURPLE_OBJ = 32991;

	private static final List<Integer> REWARD_CHEST_IDS = Arrays.asList(33086, 33087, 33088, 33089, 33090);

	private boolean isPurple = false;
	private boolean isMine = false;
	private boolean inRaid = false;
	private boolean loadedPlayers = false;
	private int playerCount = 0;
	private int loadedObjectCount = 0;


	public static final int THEATRE_RAIDERS_VARP = 330;
	public static final int MAX_RAIDERS = 5;

	public static final int STATE_NO_PARTY = 0;
	public static final int STATE_IN_PARTY = 1;

	int raidState;

	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		if (!config.tobPurpleChest() && !config.tobWhiteChest())
		{
			return;
		}

		int objId = event.getGameObject().getId();
		if (REWARD_CHEST_IDS.contains(objId))
		{
			int impostorId = client.getObjectDefinition(objId).getImpostor().getId();

			if (impostorId == YOUR_TOB_CHEST_PURPLE_OBJ)
			{
				isPurple = true;
				isMine = true;
			}
			else if (impostorId == OTHER_TOB_CHEST_PURPLE_OBJ)
			{
				isPurple = true;
				isMine = false;
			}
			else if (impostorId == YOUR_TOB_CHEST_NORMAL_OBJ)
			{
				isMine = false;
			}
			loadedObjectCount++;

			if (loadedObjectCount == playerCount)
			{
				if (isPurple)
				{
					if (config.tobPurpleChest())
					{
						// TODO: Maybe change sound if it's yours
						if (isMine)
						{
							soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
						}
						else
						{
							soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
						}
					}
				}
				else if (config.tobWhiteChest())
				{
					soundEngine.playClip(Sound.WHITE_LIGHT_AFTER_RAID, executor);
				}
			}
		}
	}

	public void onGameTick(GameTick event)
	{
		if (inRaid && !loadedPlayers)
		{
			Map<Integer, Object> varcmap = client.getVarcMap();
			for (int i = 0; i < MAX_RAIDERS; i++)
			{
				Integer playervarp = THEATRE_RAIDERS_VARP + i;
				if (varcmap.containsKey(playervarp) && !varcmap.get(playervarp).equals(""))
				{
					playerCount++;
				}
			}

			loadedPlayers = true;
		}
	}

	// Yoinked from https://github.com/Adam-/runelite-plugins/blob/tob-drop-chance/src/main/java/com/tobdropchance/TobDropChancePlugin.java
	public void onVarbitChanged(VarbitChanged event)
	{
		int nextState = client.getVarbitValue(Varbits.THEATRE_OF_BLOOD);
		if (raidState != nextState)
		{
			if (nextState == STATE_NO_PARTY || nextState == STATE_IN_PARTY)
			{ // Player is not in a raid.
				reset();
				raidState = nextState;
			}
			else
			{ // Player has entered the theatre.
				if (raidState == STATE_IN_PARTY)
				{ // Player was in a party. They are a raider.
					reset();
					inRaid = true;
				}

				raidState = nextState;
			}
		}
	}

	private void reset()
	{
		isPurple = false;
		isMine = false;
		inRaid = false;
		loadedPlayers = false;
		playerCount = 0;
		loadedObjectCount = 0;
	}

	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		int objId = event.getGameObject().getId();
		if (REWARD_CHEST_IDS.contains(objId))
		{
			isMine = false;
			isPurple = false;
			loadedObjectCount--;
		}
	}
}
package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.WidgetLoaded;

@Singleton
@Slf4j
public class HairDresser
{
	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final WorldArea FALADOR_HAIRDRESSER = new WorldArea(new WorldPoint(2942, 3377, 0), 8, 12);
	private static final int FALADOR_HAIRCUT_WIDGET_GROUP_ID = 516;

	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (!config.hairDresser())
		{
			return;
		}

		if (event.getGroupId() == FALADOR_HAIRCUT_WIDGET_GROUP_ID)
		{
			// getting the haircut widget via IDs etc seems overly difficult, so just check location
			WorldPoint currentLocation = client.getLocalPlayer().getWorldLocation();
			if (FALADOR_HAIRDRESSER.contains(currentLocation))
			{
				soundEngine.playClip(Sound.HAIRDRESSER_SOUND_1, executor);
			}
			return;
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.*;
import java.util.Random;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.SoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class DdsSpec extends TimedSoundBase
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private Random random = new Random();

	private static final String message = "ZEW ZEW.";

	DdsSpec()
	{
		super(2);
	}

	public void onTick(int currentTick, Player local)
	{
		if (config.ddsSpec())
		{
			boolean ddsSpecced = local.hasSpotAnim(AnimationIds.DDS_SPEC.Id);
			if (ddsSpecced)
			{
				if (canPlaySound(currentTick))
				{
					if (config.showChatMessages())
					{
						//TODO: Add different chat message
						client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
					}
					soundEngine.playClip(Sound.DDS_SPEC, executor);
					setLastPlayedTickTick(currentTick);
				}
			}
		}
	}

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		if (config.ddsSpec())
		{
			if (soundId == SoundIds.DDS_SPEC.Id)
			{
				event.consume();

				//TODO FIX for not you
				if (!config.ownPlayerOnly() && canPlaySound(client.getTickCount()))
				{
					soundEngine.playClip(Sound.DDS_SPEC, executor);
				}
				return;
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import com.github.dappermickie.odablock.SoundIds;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.SoundEffectPlayed;

@Singleton
@Slf4j
public class ZebakRoar extends TimedSoundBase
{
	ZebakRoar()
	{
		super(10);
	}

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		int currentTick = client.getTickCount();
		if (config.zebakRoar())
		{
			if (soundId == 5829)
			{
				event.consume();
				if (canPlaySound(currentTick))
				{
					setLastPlayedTickTick(currentTick);
					soundEngine.playClip(Sound.ZEBAK_ROAR, executor);
				}
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameObjectSpawned;

@Singleton
@Slf4j
public class ToaChestOpens
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	// Thank you https://github.com/LlemonDuck/tombs-of-amascut
	private static final int SARCOPHAGUS_ID = 44934;

	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		if (!config.toaPurpleChestOpens() || e.getGameObject().getId() != SARCOPHAGUS_ID)
		{
			return;
		}

		// The sarcophagus spawns as the player starts looting the chest
		soundEngine.playClip(Sound.TOA_CHEST_OPENS, executor);
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.SnowballUserManager;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.time.Duration;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.Projectile;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.PlayerDespawned;
import net.runelite.api.events.PlayerSpawned;
import net.runelite.api.events.ProjectileMoved;
import net.runelite.client.util.Text;

@Singleton
@Slf4j
public class SnowBalled
{
	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private int lastSnowballTriggerTick = -1;

	private Random random = new Random();

	private HashMap<String, Player> playerDictionary = new HashMap<>();


	public void onProjectileMoved(ProjectileMoved projectileMoved)
	{
		Projectile projectile = projectileMoved.getProjectile();
		if (projectile.getId() != /*snowball*/ 861)
		{
			return;
		}

		int currentTick = client.getTickCount();
		if (currentTick - lastSnowballTriggerTick < 50) // 30s cool down
		{
			return;
		}

		Actor myself = client.getLocalPlayer();
		if (myself == null)
		{
			return;
		}

		Actor projectileInteracting = projectile.getInteracting();
		if (!myself.equals(projectileInteracting))
		{
			return;
		}

		if (!config.snowballed())
		{
			return;
		}

		for (Player player : playerDictionary.values())
		{
			WorldPoint playerWp = player.getWorldLocation();
			WorldPoint projectileWP = WorldPoint.fromLocal(client, projectile.getX1(), projectile.getY1(), playerWp.getPlane()); // we don't care about plane

			// check snowball is *roughly* from the players tile, while allowing for drive-by/moving while the projectile spawns
			if (playerWp.distanceTo2D(projectileWP) <= 2)
			{
				lastSnowballTriggerTick = currentTick;
				soundEngine.playClip(Sound.SNOWBALL_1, executor);
				if (config.showChatMessages())
				{
					client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, player.getName() + " already kicked you!", null);
				}
			}
		}
	}

	public void onPlayerSpawned(PlayerSpawned playerSpawned)
	{
		Player player = playerSpawned.getPlayer();
		String[] users = SnowballUserManager.getUsers();
		for (String user : users)
		{
			if (user.equals(Text.standardize(player.getName())))
			{
				playerDictionary.put(user, player);
				return;
			}
		}
	}

	public void onPlayerDespawned(PlayerDespawned playerDespawned)
	{
		Player player = playerDespawned.getPlayer();
		String[] users = SnowballUserManager.getUsers();
		for (String user : users)
		{
			if (user.equals(Text.standardize(player.getName())))
			{
				playerDictionary.remove(user);
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class TurnOnRun extends TimedSoundBase
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private boolean isRunning = false;

	private final String message = "FAST! I said FAST!";
	private final String runOption = "Toggle Run";

	TurnOnRun()
	{
		super(10);
	}

	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		// Running varbit
		if (varbitChanged.getVarbitId() == OdablockVarbits.RUNNING.Id && varbitChanged.getVarpId() == OdablockVarbits.RUNNING.VarpId)
		{
			isRunning = varbitChanged.getValue() == OdablockVarbitValues.RUNNING_TRUE.Value;
		}
	}

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		String option = menuOptionClicked.getMenuOption();
		MenuAction action = menuOptionClicked.getMenuAction();

		// Turning on run
		if (config.turnOnRun() && option.equals(runOption))
		{
			int currentTick = client.getTickCount();
			if (!isRunning && canPlaySound(currentTick))
			{
				if (config.showChatMessages())
				{
					client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
				}
				soundEngine.playClip(Sound.TURNING_ON_RUN, executor);
				setLastPlayedTickTick(currentTick);
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Experience;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.EnumMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class LevelUp
{
	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final String message = "Level up: completed.";

	private final Map<Skill, Integer> oldExperience = new EnumMap<>(Skill.class);

	public void onStatChanged(StatChanged statChanged)
	{
		final Skill skill = statChanged.getSkill();

		// Modified from Nightfirecat's virtual level ups plugin as this info isn't (yet?) built in to statChanged event
		final int xpAfter = client.getSkillExperience(skill);
		final int levelAfter = Experience.getLevelForXp(xpAfter);
		final int xpBefore = oldExperience.getOrDefault(skill, -1);
		final int levelBefore = xpBefore == -1 ? -1 : Experience.getLevelForXp(xpBefore);

		oldExperience.put(skill, xpAfter);

		// Do not proceed if any of the following are true:
		//  * xpBefore == -1              (don't fire when first setting new known value)
		//  * xpAfter <= xpBefore         (do not allow 200m -> 200m exp drops)
		//  * levelBefore >= levelAfter   (stop if if we're not actually reaching a new level)
		//  * levelAfter > MAX_REAL_LEVEL && config says don't include virtual (level is virtual and config ignores virtual)
		if (xpBefore == -1 || xpAfter <= xpBefore || levelBefore >= levelAfter ||
			(levelAfter > Experience.MAX_REAL_LEVEL && !config.announceLevelUpIncludesVirtual()))
		{
			return;
		}

		// If we get here, 'skill' was leveled up!
		if (config.announceLevelUp())
		{
			if (config.showChatMessages())
			{
				client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
			}
			soundEngine.playClip(Sound.LEVEL_UP, executor);
		}
	}

	public void clear()
	{
		oldExperience.clear();
	}

	public void setOldExperience()
	{
		for (final Skill skill : Skill.values())
		{
			oldExperience.put(skill, client.getSkillExperience(skill));
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Varbits;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.events.ConfigChanged;

@Singleton
@Slf4j

public class CollectionLog
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Getter(AccessLevel.PACKAGE)
	@Inject
	private ClientThread clientThread;

	@Inject
	private Pet pet;
	private int lastColLogSettingWarning = -1;
	private boolean gameStateLoggedIn = false;

	private static final Set<Integer> badCollectionLogNotificationSettingValues = Set.of(0, 2);

	private static final Pattern COLLECTION_LOG_ITEM_REGEX = Pattern.compile("New item added to your collection log:.*");

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.announceCollectionLog() || !COLLECTION_LOG_ITEM_REGEX.matcher(chatMessage.getMessage()).matches())
		{
			return false;
		}

		int currentTick = client.getTickCount();
		if (currentTick - pet.getReceivedPetTick() <= 10)
		{
			return false;
		}

		if (config.showChatMessages())
		{
			client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "Collection log slot: completed.", null);
		}
		soundEngine.playClip(Sound.COLLECTION_LOG_SLOT, executor);
		return true;
	}

	private void checkAndWarnForCollectionLogNotificationSetting(int newVarbitValue)
	{
		if (!config.announceCollectionLog())
		{
			return;
		}

		if (!gameStateLoggedIn)
		{
			return;
		}

		if (badCollectionLogNotificationSettingValues.contains(newVarbitValue))
		{
			if (lastColLogSettingWarning == -1 || client.getTickCount() - lastColLogSettingWarning > 16)
			{
				lastColLogSettingWarning = client.getTickCount();
				sendHighlightedMessage("Please enable \"Collection log - New addition notification\" in your game settings for C Engineer to know when to announce it! (The chat message one, pop-up doesn't matter)");
			}
		}
	}

	public void onConfigChanged(ConfigChanged event)
	{
		if ("announceCollectionLog".equals(event.getKey()))
		{
			clientThread.invokeLater(() ->
				checkAndWarnForCollectionLogNotificationSetting(client.getVarbitValue(Varbits.COLLECTION_LOG_NOTIFICATION)));
		}
	}

	public void onGameStateChanged(GameStateChanged event)
	{
		gameStateLoggedIn = event.getGameState() == GameState.LOGGED_IN;
	}

	public void setlastColLogSettingWarning()
	{
		lastColLogSettingWarning = client.getTickCount(); // avoid warning during DC
	}

	public void onVarbitChanged(VarbitChanged event)
	{
		if (event.getVarbitId() == Varbits.COLLECTION_LOG_NOTIFICATION)
		{
			checkAndWarnForCollectionLogNotificationSetting(event.getValue());
		}
	}


	private void sendHighlightedMessage(String message)
	{
		String highlightedMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(message)
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(highlightedMessage)
			.build());
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.MenuOptionClicked;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;
import net.runelite.api.widgets.Widget;

@Singleton
@Slf4j
public class DismissRandomEvent
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final String optionText = "Dismiss";
	private static final int runePouchWidgetId = 983062;
	private static final int lootingBagWidgetId = 983048;

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		Widget widget = menuOptionClicked.getWidget();
		int widgetId = widget == null ? -1 : widget.getId();
		String option = menuOptionClicked.getMenuOption();
		// Dismiss random event
		if (config.dismissRandomEvent() && option.equals(optionText) && widgetId != runePouchWidgetId && widgetId != lootingBagWidgetId)
		{
			soundEngine.playClip(Sound.DISMISSING_RANDOM_EVENT, executor);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.VarbitChanged;

@Singleton
@Slf4j
public class Vengeance
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;


	public void onVarbitChanged(VarbitChanged event)
	{
		final int varbitId = event.getVarbitId();
		final int varpId = event.getVarpId();
		final int value = event.getValue();

		if (config.vengeance() && varbitId == 2450 && varpId == 439 && value == 1)
		{
			soundEngine.playClip(Sound.VENGEANCE, executor);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.Text;

@Singleton
@Slf4j
public class PkChest
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	@Getter(AccessLevel.PACKAGE)
	@Inject
	private ClientThread clientThread;

	private static final int GROUP_ID = 742;
	private static final int CHILD_ID = 6;

	public void onWidgetLoaded(WidgetLoaded event)
	{
		if (event.getGroupId() == GROUP_ID)
		{
			clientThread.invokeLater(this::checkWidgetAndPlaySound);
		}
	}

	private void checkWidgetAndPlaySound()
	{
		if (!config.pkChest())
		{
			return;
		}
		Widget widget = client.getWidget(GROUP_ID, CHILD_ID);
		if (widget != null)
		{
			if (Text.standardize(widget.getText()).startsWith("value in chest: "))
			{
				soundEngine.playClip(Sound.CLICKING_PK_LOOT_CHEST, executor);
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;


import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.PlayerKillLineManager;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class KillingPlayer
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private final String message = "Good shit ma brotha don't forget your key!";

	private int lmsKills = 0;

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		Player local = client.getLocalPlayer();
		String standardized = Text.standardize(chatMessage.getMessage());
		// Player Kill message checks
		if (config.playerKilling() &&
			chatMessage.getName().equals(""))
		{
			Pattern[] patterns = PlayerKillLineManager.getPatterns();
			for (Pattern pattern : patterns)
			{
				if (pattern.matcher(standardized).matches())
				{
					playSound(true);
					return true;
				}
			}

			if (standardized.equalsIgnoreCase(local.getName() + " has won!"))
			{
				playSound(false);
				return true;
			}
		}
		return false;
	}

	public void onVarbitChanged(VarbitChanged event)
	{
		final int id = event.getVarbitId();
		final int val = event.getValue();
		final int varpId = event.getVarpId();

		if (id == 5315 && varpId == 1377 && val != lmsKills)
		{
			lmsKills = val;

			if (lmsKills > 0)
			{
				playSound(true);
			}
		}
	}

	private void playSound(boolean sendMessage)
	{
		if (config.showChatMessages() && sendMessage)
		{
			client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
		}
		soundEngine.playClip(Sound.KILLING_SOMEONE_1, executor);
	}
}
package com.github.dappermickie.odablock.sounds;

// Special thanks to: https://github.com/while-loop/runelite-plugins/tree/runewatch

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.OdablockPlugin;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class DeclineTrade
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final int PLAYER_TRADE_OFFER_GROUP_ID = 335;
	private static final int PLAYER_TRADE_CONFIRMATION_GROUP_ID = 334;
	private static final String DECLINE_MSG = "Decline";
	private static final List<Integer> TRADE_SCREEN_GROUP_IDS = Arrays.asList(
		PLAYER_TRADE_OFFER_GROUP_ID,
		PLAYER_TRADE_CONFIRMATION_GROUP_ID
	);

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		int groupId = OdablockPlugin.TO_GROUP(menuOptionClicked.getParam1());
		String option = menuOptionClicked.getMenuOption();
		MenuAction action = menuOptionClicked.getMenuAction();

		if (config.declineTrade() && TRADE_SCREEN_GROUP_IDS.contains(groupId))
		{

			// Decline trade
			if (option.equals(DECLINE_MSG))
			{
				soundEngine.playClip(Sound.DECLINE_TRADE, executor);
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Varbits;
import static net.runelite.api.Varbits.DIARY_KARAMJA_EASY;
import static net.runelite.api.Varbits.DIARY_KARAMJA_HARD;
import static net.runelite.api.Varbits.DIARY_KARAMJA_MEDIUM;
import net.runelite.api.annotations.Varbit;
import net.runelite.api.events.VarbitChanged;

@Singleton
@Slf4j
public class AchievementDiaries
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;
	private static final Random random = new Random();

	private int lastLoginTick = -1;

	private final int[] varbitsAchievementDiaries = {
		Varbits.DIARY_ARDOUGNE_EASY, Varbits.DIARY_ARDOUGNE_MEDIUM, Varbits.DIARY_ARDOUGNE_HARD, Varbits.DIARY_ARDOUGNE_ELITE,
		Varbits.DIARY_DESERT_EASY, Varbits.DIARY_DESERT_MEDIUM, Varbits.DIARY_DESERT_HARD, Varbits.DIARY_DESERT_ELITE,
		Varbits.DIARY_FALADOR_EASY, Varbits.DIARY_FALADOR_MEDIUM, Varbits.DIARY_FALADOR_HARD, Varbits.DIARY_FALADOR_ELITE,
		Varbits.DIARY_KANDARIN_EASY, Varbits.DIARY_KANDARIN_MEDIUM, Varbits.DIARY_KANDARIN_HARD, Varbits.DIARY_KANDARIN_ELITE,
		DIARY_KARAMJA_EASY, DIARY_KARAMJA_MEDIUM, DIARY_KARAMJA_HARD, Varbits.DIARY_KARAMJA_ELITE,
		Varbits.DIARY_KOUREND_EASY, Varbits.DIARY_KOUREND_MEDIUM, Varbits.DIARY_KOUREND_HARD, Varbits.DIARY_KOUREND_ELITE,
		Varbits.DIARY_LUMBRIDGE_EASY, Varbits.DIARY_LUMBRIDGE_MEDIUM, Varbits.DIARY_LUMBRIDGE_HARD, Varbits.DIARY_LUMBRIDGE_ELITE,
		Varbits.DIARY_MORYTANIA_EASY, Varbits.DIARY_MORYTANIA_MEDIUM, Varbits.DIARY_MORYTANIA_HARD, Varbits.DIARY_MORYTANIA_ELITE,
		Varbits.DIARY_VARROCK_EASY, Varbits.DIARY_VARROCK_MEDIUM, Varbits.DIARY_VARROCK_HARD, Varbits.DIARY_VARROCK_ELITE,
		Varbits.DIARY_WESTERN_EASY, Varbits.DIARY_WESTERN_MEDIUM, Varbits.DIARY_WESTERN_HARD, Varbits.DIARY_WESTERN_ELITE,
		Varbits.DIARY_WILDERNESS_EASY, Varbits.DIARY_WILDERNESS_MEDIUM, Varbits.DIARY_WILDERNESS_HARD, Varbits.DIARY_WILDERNESS_ELITE
	};

	private final Map<Integer, Integer> oldAchievementDiaries = new HashMap<>();

	public void onVarbitChanged(VarbitChanged event)
	{
		// As we can't listen to specific varbits, we get a tonne of events BEFORE the game has even set the player's
		// diary varbits correctly, meaning it assumes every diary is on 0, then suddenly every diary that has been
		// completed gets updated to the true value and tricks the plugin into thinking they only just finished it.
		// To avoid this behaviour, we make sure the current tick count is sufficiently high that we've already passed
		// the initial wave of varbit changes from logging in.
		if (lastLoginTick == -1 || client.getTickCount() - lastLoginTick < 8)
		{
			return; // Ignoring varbit change as only just logged in
		}

		// Apparently I can't check if it's a particular varbit using the names from Varbits enum, so this is the way
		for (@Varbit int diary : varbitsAchievementDiaries)
		{
			int newValue = client.getVarbitValue(diary);
			int previousValue = oldAchievementDiaries.getOrDefault(diary, -1);
			oldAchievementDiaries.put(diary, newValue);
			if (config.announceAchievementDiary() && previousValue != -1 && previousValue != newValue && isAchievementDiaryCompleted(diary, newValue))
			{
				// value was not unknown (we know the previous value), value has changed, and value indicates diary is completed now
				if (config.showChatMessages())
				{
					client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "Achievement diary: completed.", null);
				}
				soundEngine.playClip(Sound.ACHIEVEMENT_DIARY, executor);
			}
		}
	}

	public void setLastLoginTick(int tick)
	{
		lastLoginTick = tick;
	}

	private boolean isAchievementDiaryCompleted(int diary, int value)
	{
		switch (diary)
		{
			case DIARY_KARAMJA_EASY:
			case DIARY_KARAMJA_MEDIUM:
			case DIARY_KARAMJA_HARD:
				return value == 2; // jagex, why?
			default:
				return value == 1;
		}
	}

	public void clearOldAchievementDiaries()
	{
		oldAchievementDiaries.clear();
	}

	public void setOldAchievementDiaries()
	{
		for (@Varbit int diary : varbitsAchievementDiaries)
		{
			int value = client.getVarbitValue(diary);
			oldAchievementDiaries.put(diary, value);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

@Singleton
@Slf4j
public class CombatAchievements
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final Pattern COMBAT_TASK_REGEX = Pattern.compile("CA_ID:\\d+\\|Congratulations, you've completed an? \\w+ combat task:.*");

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		if (!config.announceCombatAchievement() || !COMBAT_TASK_REGEX.matcher(chatMessage.getMessage()).matches())
		{
			return false;
		}
		if (config.showChatMessages())
		{
			client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, "Combat task: completed.", null);
		}
		soundEngine.playClip(Sound.COMBAT_TASK, executor);
		return true;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.OdablockPlugin;
import com.github.dappermickie.odablock.RandomSoundUtility;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.Random;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class ReportPlayer
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final int REPORT_SCREEN_GROUP_ID = 875;
	private static final String REPORT_FOR = "Report for";

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		// Thank you RuneWatch for groupId
		int groupId = OdablockPlugin.TO_GROUP(menuOptionClicked.getParam1());
		String option = menuOptionClicked.getMenuOption();
		MenuAction action = menuOptionClicked.getMenuAction();

		if (config.sendReport() && REPORT_SCREEN_GROUP_ID == groupId && option.equals(REPORT_FOR))
		{
			soundEngine.playClip(Sound.REPORT_PLAYER_1, executor);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.OdablockPlugin;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

@Singleton
@Slf4j
public class PetDog
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;
	private final String petOption = "Pet";
	private final String messageByClient = "who's a good doggy!";

	private int lastPetDogTick = -1;

	public boolean onChatMessage(ChatMessage chatMessage)
	{
		int currentTick = client.getTickCount();
		Player local = client.getLocalPlayer();
		// Petting the dog sound, only play sound when message is sent by local player within 15ticks of petting the dog
		if (config.petDog() &&
			// pet dog message
			Text.standardize(chatMessage.getMessage()).equals(messageByClient) &&
			// sent by current local user
			Text.standardize(chatMessage.getName()).equals(Text.standardize(local.getName())))
		{
			// Check if last pet dog click is within 15 ticks
			if (lastPetDogTick == -1 || currentTick - lastPetDogTick < 15)
			{
				soundEngine.playClip(Sound.PETTING_DOG, executor);
				return true;
			}
		}
		return false;
	}

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		int currentTick = client.getTickCount();

		String option = menuOptionClicked.getMenuOption();
		MenuAction action = menuOptionClicked.getMenuAction();


		// Petting the dog
		if (config.petDog() && menuOptionClicked.getId() == 23766 && option.equals(petOption))
		{
			lastPetDogTick = currentTick;
		}
	}

	public void cleanupTicks(int currentTick)
	{
		if (lastPetDogTick != currentTick &&
			currentTick - lastPetDogTick > 15)
		{
			lastPetDogTick = -1;
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import java.util.regex.Pattern;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.ChatMessage;

@Singleton
@Slf4j
public class GiveBone
{
	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final Pattern STRAY_DOG_GIVEN_BONES_REGEX = Pattern.compile("You give the dog some nice.*bones.*");

	public boolean onChatMessage(ChatMessage chatMessage){
		if (!config.giveBone() || !STRAY_DOG_GIVEN_BONES_REGEX.matcher(chatMessage.getMessage()).matches())
		{
			return false;
		}
		if (config.showChatMessages())
		{
			client.addChatMessage(ChatMessageType.PUBLICCHAT, "Stella", "Who's a good doggy?", null);
		}
		soundEngine.playClip(Sound.EASTER_EGG_STRAYDOG_BONE, executor);
		return true;
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.Sound;
import com.github.dappermickie.odablock.SoundEngine;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.WallObject;
import net.runelite.api.events.WallObjectSpawned;

@Singleton
@Slf4j
public class ToaChestLight
{
	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private static final int VARBIT_VALUE_CHEST_KEY = 2;
	private static final int VARBIT_ID_SARCOPHAGUS = 14373;
	private static final int WALL_OBJECT_ID_SARCOPHAGUS = 46221;

	private static final int[] VARBIT_MULTILOC_IDS_CHEST = new int[]{
		14356, 14357, 14358, 14359, 14360, 14370, 14371, 14372
	};

	private boolean sarcophagusIsPurple;
	private boolean purpleIsMine = true;

	public void onWallObjectSpawned(final WallObjectSpawned event)
	{
		final WallObject wallObject = event.getWallObject();

		if ((!config.toaPurpleChest() && !config.toaWhiteChest()) || wallObject.getId() != WALL_OBJECT_ID_SARCOPHAGUS)
		{
			return;
		}

		parseVarbits();

		if (sarcophagusIsPurple)
		{
			if (config.toaPurpleChest())
			{
				// TODO: Maybe change the sound if it's not your purple?
				if (purpleIsMine)
				{
					soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
				}
				else
				{
					soundEngine.playClip(Sound.GETTING_PURPLE_1, executor);
				}
			}
		}
		else if (config.toaWhiteChest())
		{
			soundEngine.playClip(Sound.WHITE_LIGHT_AFTER_RAID, executor);
		}
	}

	private void parseVarbits()
	{
		sarcophagusIsPurple = client.getVarbitValue(VARBIT_ID_SARCOPHAGUS) % 2 != 0;
		purpleIsMine = true;

		for (final int varbitId : VARBIT_MULTILOC_IDS_CHEST)
		{
			if (client.getVarbitValue(varbitId) == VARBIT_VALUE_CHEST_KEY)
			{
				purpleIsMine = false;
				break;
			}
		}
	}
}

package com.github.dappermickie.odablock.sounds;

public abstract class TimedSoundBase
{
	TimedSoundBase(int tickDelay)
	{
		this.tickDelay = tickDelay;
	}

	private final int tickDelay;
	private int lastPlayedTick;

	void setLastPlayedTickTick(int tick)
	{
		lastPlayedTick = tick;
	}

	boolean canPlaySound(int currentTick)
	{
		return currentTick - lastPlayedTick > tickDelay || lastPlayedTick == -1;
	}

	int getLastPlayedTick()
	{
		return lastPlayedTick;
	}

	int getTickDelay()
	{
		return tickDelay;
	}

	public void cleanupTicks(int currentTick)
	{
		if (currentTick - lastPlayedTick > tickDelay)
		{
			setLastPlayedTickTick(-1);
		}
	}
}

package com.github.dappermickie.odablock.sounds;

import com.github.dappermickie.odablock.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.api.events.SoundEffectPlayed;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.concurrent.ScheduledExecutorService;

import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;

@Singleton
@Slf4j
public class AgsSpec extends TimedSoundBase
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	private final String message = "OGS!";

	AgsSpec()
	{
		super(5);
	}

	public void onTick(int currentTick, Player local)
	{
		if (config.agsSpec())
		{
			boolean agsSpecced = local.hasSpotAnim(AnimationIds.AGS_SPEC.Id);
			if (agsSpecced)
			{
				if (canPlaySound(currentTick))
				{
					if (config.showChatMessages())
					{
						client.addChatMessage(ChatMessageType.PUBLICCHAT, ODABLOCK, message, null);
					}
					soundEngine.playClip(Sound.AGS_SPEC, executor);
					setLastPlayedTickTick(currentTick);
				}
			}
		}
	}

	public void onSoundEffectPlayed(SoundEffectPlayed event)
	{
		int soundId = event.getSoundId();
		final Player local = client.getLocalPlayer();

		if (config.agsSpec())
		{
			if (soundId == SoundIds.AGS_SPEC.Id)
			{
				event.consume();
				return;
			}
		}
	}
}

package com.github.dappermickie.odablock;

import com.google.errorprone.annotations.Var;

public enum OdablockVarbitValues
{

	// Running varbit values, FALSE is never used, but is in here as a reference
	RUNNING_FALSE(OdablockVarbits.RUNNING, 0),
	RUNNING_TRUE(OdablockVarbits.RUNNING, 1),

	/*
		Used for DH Axe style determination

		FORMAT:
		Id; Value; VarpId

		CHOP:
		-1; 0; 43
		-1; 1; 46

		HACK:
		-1; 1; 43
		-1; 2; 46

		SMASH:
		-1; 2; 43;
		-1; 2; 46;

		BLOCK:
		-1; 3; 43;
		-1; 3; 46;
	 */
	COMBAT_STYLE_43_0(OdablockVarbits.COMBAT_STYLE_43, 0),
	COMBAT_STYLE_43_1(OdablockVarbits.COMBAT_STYLE_43, 1),
	COMBAT_STYLE_43_2(OdablockVarbits.COMBAT_STYLE_43, 2),
	COMBAT_STYLE_43_3(OdablockVarbits.COMBAT_STYLE_43, 3),

	COMBAT_STYLE_46_1(OdablockVarbits.COMBAT_STYLE_46, 1),
	COMBAT_STYLE_46_2(OdablockVarbits.COMBAT_STYLE_46, 2),
	COMBAT_STYLE_46_3(OdablockVarbits.COMBAT_STYLE_46, 3);

	public final int Value;

	// Never actually used, only here to show and keep track of relations to varbits
	private final OdablockVarbits Varbit;

	OdablockVarbitValues(OdablockVarbits varbit, int value)
	{
		Varbit = varbit;
		Value = value;
	}
}

package com.github.dappermickie.odablock.livestreams;

import lombok.Getter;

public class Livestream
{
	@Getter
	private LivestreamEntry twitch;

	@Getter
	private LivestreamEntry kick;
}

package com.github.dappermickie.odablock.livestreams;

import com.github.dappermickie.odablock.ChatRightClickManager;
import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RightClickAction;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@Singleton
public class LivestreamManager
{
	private Livestream livestream = null;
	private int lastChecked = -1;
	private int lastSentMessage = -1;

	@Inject
	private Client client;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OdablockConfig config;

	@Inject
	private ChatRightClickManager chatRightClickManager;

	@Inject
	private ScheduledExecutorService executor;

	public void onGameTick(GameTick gameTick)
	{
		if (!config.livestream())
		{
			return;
		}

		sendLivestreamMessage(false);

		int currentTick = client.getTickCount();
		if (lastChecked == -1 || currentTick - lastChecked > 100)
		{
			executor.submit(() -> {
				sendRequest(currentTick);
			});

			lastChecked = currentTick;
		}
	}

	private void sendRequest(final int currentTick)
	{
		Request request = new Request.Builder()
			.url("https://raw.githubusercontent.com/DapperMickie/odablock-sounds-notifier/main/livestream.json")
			.build();
		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful() || response.body() == null)
			{
				return;
			}

			String jsonResponse = response.body().string();
			Livestream newLivestream = gson.fromJson(jsonResponse, Livestream.class);

			if (livestream != null &&
				newLivestream.getKick().isLive() == livestream.getKick().isLive() &&
				newLivestream.getTwitch().isLive() == livestream.getTwitch().isLive())
			{
				lastChecked = currentTick;
				return;
			}

			livestream = newLivestream;
			clientThread.invokeLater(() -> {
				sendLivestreamMessage(true);
			});
		}
		catch (IOException ignored)
		{
		}
	}

	private void sendLivestreamMessage(boolean force)
	{
		final int currentTick = client.getTickCount();

		// Only send once every x minutes, unless we force send (in case he goes live)
		if (!force && lastSentMessage != -1 && currentTick - lastSentMessage < config.livestreamInterval() * 100)
		{
			return;
		}

		// Only send if oda is live
		if (livestream == null || (!livestream.getTwitch().isLive() && !livestream.getKick().isLive()))
		{
			return;
		}

		lastSentMessage = currentTick;

		ChatMessageBuilder chatMessage = new ChatMessageBuilder();
		String hex = Integer.toHexString(config.livestreamColor().getRGB()).substring(2);
		String message;
		if (livestream.getKick().isLive())
		{
			final String title = livestream.getKick().getTitle().split("\\|")[0].trim();
			chatMessage
				.append(ChatColorType.NORMAL)
				.append("Odablock is live on ")
				.append(ChatColorType.HIGHLIGHT)
				.append("KICK")
				.append(ChatColorType.NORMAL)
				.append("! ")
				.append(ChatColorType.HIGHLIGHT)
				.append(title);
			message = chatMessage.build().replaceAll("colHIGHLIGHT", "col=" + hex);
			RightClickAction rightClickAction = new RightClickAction("Open Kick Stream", "https://kick.com/odablock");
			chatRightClickManager.putInMap(message, rightClickAction);
		}
		else if (livestream.getTwitch().isLive())
		{
			final String title = livestream.getTwitch().getTitle().split("\\|")[0].trim();
			chatMessage.append(ChatColorType.NORMAL)
				.append("Odablock is live on ")
				.append(ChatColorType.HIGHLIGHT)
				.append("TWITCH")
				.append(ChatColorType.NORMAL)
				.append("! ")
				.append(ChatColorType.HIGHLIGHT)
				.append(title);
			message = chatMessage.build().replaceAll("colHIGHLIGHT", "col=" + hex);
			RightClickAction rightClickAction = new RightClickAction("Open Twitch Stream", "https://twitch.tv/odablock");
			chatRightClickManager.putInMap(message, rightClickAction);
		}
		else
		{
			// return if not live on either kick or twitch
			return;
		}

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(message)
			.build());
	}
}

package com.github.dappermickie.odablock.livestreams;

import lombok.Getter;

public class LivestreamEntry
{
	@Getter
	private String title;

	@Getter
	private boolean isLive;
}

package com.github.dappermickie.odablock;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import net.runelite.client.util.Text;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
public abstract class SnowballUserManager
{

	private static final File DOWNLOAD_DIR = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "odablock-users");
	private static final HttpUrl RAW_GITHUB = HttpUrl.parse("https://raw.githubusercontent.com/dappermickie/odablock-sounds/snowball");
	private static final String USERVERSION_FILENAME = "USERVERSION";
	private static final String USERS_FILENAME = "users.txt";

	private static String[] users = null;

	public static void ensureDownloadDirectoryExists()
	{
		if (!DOWNLOAD_DIR.exists())
		{
			DOWNLOAD_DIR.mkdirs();
		}
	}

	public static void downloadSnowballUsers(final OkHttpClient okHttpClient)
	{
		HttpUrl versionUrl = RAW_GITHUB.newBuilder().addPathSegment(USERVERSION_FILENAME).build();
		int latestVersion = -1;
		try (Response res = okHttpClient.newCall(new Request.Builder().url(versionUrl).build()).execute())
		{
			if (res.body() != null)
			{
				latestVersion = Integer.parseInt(Text.standardize(res.body().string()));
			}
		}
		catch (IOException e)
		{
			log.error("Odablock Plugin could not download user version", e);
			return;
		}

		int currentVersion = -1;
		try
		{
			currentVersion = getUserVersion();
		}
		catch (IOException e)
		{
			// No current version available
			var soundVersionFile = new File(DOWNLOAD_DIR, USERVERSION_FILENAME);
			try
			{
				soundVersionFile.createNewFile();

			}
			catch (IOException e2)
			{
				log.error("Couldn't create userversion file");
			}
		}

		if (latestVersion == currentVersion)
		{
			return;
		}

		writeLatestVersion(latestVersion);

		HttpUrl usersUrl = RAW_GITHUB.newBuilder().addPathSegment(USERS_FILENAME).build();
		Path outputPath = Paths.get(DOWNLOAD_DIR.getPath(), USERS_FILENAME);
		try (Response res = okHttpClient.newCall(new Request.Builder().url(usersUrl).build()).execute())
		{
			if (res.body() != null)
			{
				Files.copy(new BufferedInputStream(res.body().byteStream()), outputPath, StandardCopyOption.REPLACE_EXISTING);
			}
		}
		catch (IOException e)
		{
			log.error("Odablock Plugin could not download snowball users", e);
			return;
		}
	}

	public static String[] getUsers()
	{
		if (SnowballUserManager.users != null)
		{
			return SnowballUserManager.users;
		}
		File userVersionFile = new File(DOWNLOAD_DIR, USERS_FILENAME);
		try
		{
			String userVersionFileContent = Files.readString(userVersionFile.toPath());
			String[] originalUsers = userVersionFileContent.split(",");
			String[] users = new String[originalUsers.length];

			for (int i = 0; i < originalUsers.length; i++)
			{
				users[i] = Text.standardize(originalUsers[i]);
			}

			SnowballUserManager.users = users;

			return users;
		}
		catch (IOException e)
		{
			return null;
		}
	}

	private static int getUserVersion() throws IOException
	{
		File userVersionFile = new File(DOWNLOAD_DIR, USERVERSION_FILENAME);
		String userVersionFileContent = Files.readString(userVersionFile.toPath());
		return Integer.parseInt(userVersionFileContent);
	}

	private static void writeLatestVersion(int version)
	{
		var soundVersionFile = new File(DOWNLOAD_DIR, USERVERSION_FILENAME);
		try
		{
			FileWriter myWriter = new FileWriter(soundVersionFile);
			myWriter.write(String.valueOf(version));
			myWriter.close();
		}
		catch (IOException e)
		{
			log.error("Couldn't write latest userversion");
		}
	}
}

package com.github.dappermickie.odablock.notifications;

import com.github.dappermickie.odablock.ChatRightClickManager;
import com.github.dappermickie.odablock.OdablockConfig;
import com.github.dappermickie.odablock.RightClickAction;
import com.google.gson.Gson;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ScheduledExecutorService;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.LinkBrowser;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
@Singleton
public class NotificationManager
{

	private Map<String, Notification> sentNotifications = new HashMap<>();
	private int lastChecked = -1;

	@Inject
	private Client client;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private Gson gson;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private OdablockConfig config;

	@Inject
	private ChatRightClickManager chatRightClickManager;

	@Inject
	private ScheduledExecutorService executor;

	public void onGameTick(GameTick gameTick)
	{
		if (!config.notifications())
		{
			return;
		}
		int currentTick = client.getTickCount();
		if (lastChecked == -1 || currentTick - lastChecked > 100)
		{
			executor.submit(this::sendRequest);
			lastChecked = currentTick;
		}
	}

	private void sendRequest()
	{
		Request request = new Request.Builder()
			.url("https://raw.githubusercontent.com/DapperMickie/odablock-sounds-notifier/main/notifications.json")
			.build();
		try (Response response = okHttpClient.newCall(request).execute())
		{
			if (!response.isSuccessful() || response.body() == null)
			{
				return;
			}

			String jsonResponse = response.body().string();
			Notification[] notifications = gson.fromJson(jsonResponse, Notification[].class);
			for (Notification notification : notifications)
			{
				if (sentNotifications.containsKey(notification.getUniqueIdentifier()))
				{
					continue;
				}

				String message = sendMessage(notification);
				sentNotifications.put(notification.getUniqueIdentifier(), notification);

				if (notification.getLink().equals(""))
				{
					continue;
				}

				RightClickAction rightClickAction = new RightClickAction("Open Notification", notification.getLink());
				chatRightClickManager.putInMap(message, rightClickAction);
			}
		}
		catch (IOException ignored)
		{
		}
	}

	private String sendMessage(Notification notification)
	{
		ChatMessageBuilder chatMessage = new ChatMessageBuilder();
		chatMessage
			.append(ChatColorType.HIGHLIGHT)
			.append("Odablock: ")
			.append(notification.getTitle())
			.append(" - ")
			.append(notification.getMessage());
		String hex = Integer.toHexString(config.notificationColor().getRGB()).substring(2);
		String message = chatMessage.build().replaceAll("colHIGHLIGHT", "col=" + hex);
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.GAMEMESSAGE)
			.runeLiteFormattedMessage(message)
			.build());
		return message;
	}

	protected void openNotification(Notification notification)
	{
		LinkBrowser.browse(notification.getLink());
		log.info("Opened a link to Odablocks notification!");
	}
}

package com.github.dappermickie.odablock.notifications;

import com.google.gson.annotations.SerializedName;
import lombok.Getter;

public class Notification
{
	@Getter
	private String title;

	@Getter
	private String message;

	@Getter
	private String link;

	@Getter
	@SerializedName("unique_identifier")
	private String uniqueIdentifier;
}

package com.github.dappermickie.odablock;

import java.util.concurrent.ScheduledExecutorService;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetLoaded;

@Singleton
@Slf4j
public class DebugScripts
{

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	@Inject
	private SoundEngine soundEngine;

	@Inject
	private ScheduledExecutorService executor;

	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked)
	{
		int currentTick = client.getTickCount();

		// Thank you RuneWatch for groupId
		int groupId = OdablockPlugin.TO_GROUP(menuOptionClicked.getParam1());
		String option = menuOptionClicked.getMenuOption();
		MenuAction action = menuOptionClicked.getMenuAction();

		StringBuilder builder = new StringBuilder();
		builder.append("MENU GID: ");
		builder.append(groupId);
		builder.append(" ; OPTION: ");
		builder.append(option);
		builder.append(" ; ACTIONID: ");
		builder.append(action.getId());
		builder.append(" ; TICK: ");
		builder.append(currentTick);
		builder.append("\n");

		Logger.getGlobal().log(Level.INFO, builder.toString());
	}

	public void onVarbitChanged(VarbitChanged varbitChanged)
	{
		StringBuilder builder = new StringBuilder();
		builder.append("BIT: ");
		builder.append(varbitChanged.getVarbitId());
		builder.append(" ; VALUE: ");
		builder.append(varbitChanged.getValue());
		builder.append(" ; VARPID: ");
		builder.append(varbitChanged.getVarpId());
		builder.append("\n");

		Logger.getGlobal().log(Level.INFO, builder.toString());
	}

	public void onWidgetLoaded(WidgetLoaded event)
	{
		StringBuilder builder = new StringBuilder();
		builder.append("WIDGET GROUP ID: ");
		builder.append(event.getGroupId());
		Logger.getGlobal().log(Level.INFO, builder.toString());

		var widget = client.getWidget(event.getGroupId());
	}

	public void onScriptCallbackEvent(ScriptCallbackEvent scriptCallbackEvent)
	{
		String ename = scriptCallbackEvent.getEventName();
		if (ename.equals("outerZoomLimit") ||
			ename.equals("innerZoomLimit") ||
			ename.equals("friendsChatSetPosition") ||
			ename.equals("friendsChatSetText") ||
			ename.equals("zoomExpToLin") ||
			ename.equals("scrollWheelZoom") ||
			ename.equals("scrollWheelZoomIncrement"))
		{
			return;
		}
		StringBuilder builder = new StringBuilder();
		builder.append("EID: ");
		builder.append(scriptCallbackEvent.hashCode());
		builder.append("; ENAME: ");
		builder.append(ename);
		Logger.getGlobal().log(Level.INFO, builder.toString());
	}
}

package com.github.dappermickie.odablock.emotes;

import com.google.common.collect.ImmutableMap;
import java.awt.image.BufferedImage;
import java.util.Map;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.client.util.ImageUtil;

@AllArgsConstructor
public enum Emote
{
	AIAIAI("aiaiai", EmoteType.GIF),
	AWKWARD("awkward", EmoteType.GIF),
	FUFU("fufu", EmoteType.GIF),
	GNEAH("gneah", EmoteType.PNG),
	HUH("huh", EmoteType.PNG),
	HYPERWANKGE("hyperwankge", EmoteType.GIF),
	JANITOR("janitor", EmoteType.PNG),
	KEK("kek", EmoteType.GIF),
	KISS("kiss", EmoteType.PNG),
	NOWAY("noway", EmoteType.PNG),
	PFACE(":p", EmoteType.GIF, new String[]{"pface"}),
	RLY("rly", EmoteType.GIF),
	SMILE(":)", EmoteType.GIF, new String[]{"smile"}),
	TUNE("tune", EmoteType.GIF),
	ODAWHAT("odawhat", EmoteType.PNG),
	DAP("dap", EmoteType.PNG),
	CAP("cap", EmoteType.PNG),
	CAPPP("cappp", EmoteType.PNG),
	WHENITREGISTERS("whenitregisters", EmoteType.GIF),
	WINK("wink", EmoteType.PNG);

	private enum EmoteType
	{
		PNG,
		GIF
	}

	private static final Map<String, Emote> emojiMap;

	@Getter
	private final String trigger;
	private final EmoteType emoteType;
	@Getter
	private final String[] altTriggers;

	Emote(final String trigger, EmoteType emoteType)
	{
		this(trigger, emoteType, new String[]{});
	}

	static
	{
		ImmutableMap.Builder<String, Emote> builder = new ImmutableMap.Builder<>();

		for (final Emote emoji : values())
		{
			builder.put(emoji.trigger, emoji);
			if (!emoji.trigger.startsWith("oda") && !emoji.trigger.startsWith(":"))
			{
				builder.put("oda" + emoji.trigger, emoji);
			}
			for (final String altTrigger : emoji.altTriggers)
			{
				builder.put(altTrigger, emoji);
				if (!altTrigger.startsWith("oda") && !altTrigger.startsWith(":"))
				{
					builder.put("oda" + altTrigger, emoji);
				}
			}
		}

		emojiMap = builder.build();
	}

	BufferedImage loadImage()
	{
		return ImageUtil.loadImageResource(getClass(), this.name().toLowerCase() + getEmoteTypeExtension());
	}

	private String getEmoteTypeExtension()
	{
		return emoteType == EmoteType.GIF ? ".gif" : ".png";
	}

	static Emote getEmoji(String trigger)
	{
		return emojiMap.get(trigger);
	}
}
package com.github.dappermickie.odablock.emotes;

import com.github.dappermickie.odablock.OdablockConfig;
import static com.github.dappermickie.odablock.OdablockPlugin.ODABLOCK;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Pattern;
import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.inject.Singleton;
import joptsimple.internal.Strings;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MessageNode;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class EmoteHandler
{
	private static final Pattern WHITESPACE_REGEXP = Pattern.compile("[\\s\\u00A0]");

	@Inject
	private ChatIconManager chatIconManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private Client client;

	@Inject
	private OdablockConfig config;

	private int[] iconIds;

	public void loadEmotes()
	{
		if (iconIds != null)
		{
			return;
		}

		Emote[] emotes = Emote.values();
		iconIds = new int[emotes.length];

		for (int i = 0; i < emotes.length; i++)
		{
			final Emote emoji = emotes[i];
			final BufferedImage image = emoji.loadImage();
			iconIds[i] = chatIconManager.registerChatIcon(image);
		}
	}

	public void onChatMessage(ChatMessage chatMessage)
	{
		if (!config.emotes())
		{
			return;
		}

		if (iconIds == null)
		{
			return;
		}

		switch (chatMessage.getType())
		{
			case PUBLICCHAT:
			case MODCHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
			case CLAN_GUEST_CHAT:
			case CLAN_GIM_CHAT:
			case PRIVATECHAT:
			case PRIVATECHATOUT:
			case MODPRIVATECHAT:
				break;
			default:
				return;
		}

		final MessageNode messageNode = chatMessage.getMessageNode();
		final String message = messageNode.getValue();
		final String updatedMessage = updateMessage(message);

		if (updatedMessage == null)
		{
			return;
		}

		messageNode.setValue(updatedMessage);
	}

	public void onOverheadTextChanged(final OverheadTextChanged event)
	{
		if (!config.emotes())
		{
			return;
		}

		if (!(event.getActor() instanceof Player))
		{
			return;
		}

		final String message = event.getOverheadText();
		final String updatedMessage = updateMessage(message);

		if (updatedMessage == null)
		{
			return;
		}

		event.getActor().setOverheadText(updatedMessage);
	}

	public void onCommandExecuted(CommandExecuted event)
	{
		if (event.getCommand().startsWith("odaemote") || event.getCommand().startsWith("odablockemote"))
		{
			clientThread.invoke(this::sendOdaEmotes);
		}
	}

	private void sendOdaEmotes()
	{
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, "Odablock emote list:", null);
		for (Emote emote : Emote.values())
		{
			final int emoteId = iconIds[emote.ordinal()];
			final String emoteImage = "<img=" + chatIconManager.chatIconIndex(emoteId) + ">";
			StringBuilder chatMessageSb = new StringBuilder();
			chatMessageSb.append(emote.getTrigger());
			chatMessageSb.append(" : ");
			chatMessageSb.append(emoteImage);
			List<String> altTriggerOriginal = Arrays.asList(emote.getAltTriggers());
			List<String> altTriggers = new ArrayList<>(altTriggerOriginal);
			if (!emote.getTrigger().startsWith("oda") && !emote.getTrigger().startsWith(":"))
			{
				altTriggers.add("oda" + emote.getTrigger());
			}
			for (int i = 0; i < altTriggers.size(); i++)
			{
				if (i == 0)
				{
					chatMessageSb.append(" (alt: ");
				}
				else
				{
					chatMessageSb.append(", ");
				}
				String altTrigger = altTriggers.get(i);
				chatMessageSb.append(altTrigger);
				if (!altTrigger.startsWith("oda") && !altTrigger.startsWith(":"))
				{
					chatMessageSb.append(", oda");
					chatMessageSb.append(altTrigger);
				}
				if (i == (altTriggers.size() - 1))
				{
					chatMessageSb.append(" )");
				}
			}
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, chatMessageSb.toString(), null);
		}
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, "Some emotes have an alternative trigger that will get translated into an emote.", null);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, "For example: both \"cap\" and \"odacap\" work.", null);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, "To disable an emote, you can add it to the \"Emote Ignore List\" in the plugin settings.", null);
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, ODABLOCK, "Add the emote and the alternative triggers to completely disable an emote.", null);
	}

	@Nullable
	String updateMessage(final String message)
	{
		final String[] messageWords = WHITESPACE_REGEXP.split(message);
		final String[] ignoredEmotes = config.emoteIgnoreList().split(",");

		boolean editedMessage = false;
		for (int i = 0; i < messageWords.length; i++)
		{
			// Remove tags except for <lt> and <gt>
			final String originalTrigger = Text.removeFormattingTags(messageWords[i]);
			final String trigger = originalTrigger.toLowerCase();
			final Emote emote = Emote.getEmoji(trigger);

			if (emote == null)
			{
				continue;
			}

			boolean shouldSkip = false;
			for (String ignored : ignoredEmotes)
			{
				if (ignored.strip().equalsIgnoreCase(trigger))
				{
					shouldSkip = true;
					break;
				}
			}

			if (shouldSkip)
			{
				break;
			}

			final int emoteId = iconIds[emote.ordinal()];
			messageWords[i] = messageWords[i].replace(originalTrigger, "<img=" + chatIconManager.chatIconIndex(emoteId) + ">");
			editedMessage = true;
		}

		// If we haven't edited the message any, don't update it.
		if (!editedMessage)
		{
			return null;
		}

		return Strings.join(messageWords, " ");
	}
}

package com.github.dappermickie.odablock;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class OdablockPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(OdablockPlugin.class);
		RuneLite.main(args);
	}
}
