/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
/**
 * Represents a screen marker object with its properties.
 * This class is used to store and manage individual screen markers,
 * including their visual attributes and state.
 */
public class ScreenMarker {
	/**
	 * Unique identifier for the screen marker.
	 */
	private long id;

	/**
	 * User-defined name for the screen marker.
	 */
	private String name;

	/**
	 * Thickness of the border around the marker, in pixels.
	 */
	private int borderThickness;

	/**
	 * Color of the border around the marker.
	 */
	private Color color;

	/**
	 * Fill color of the marker. Can be null or transparent for no fill.
	 */
	private Color fill;

	/**
	 * Current visibility state of the marker. If false, the marker is not rendered.
	 */
	private boolean visible;

	/**
	 * Whether the marker's name label should be displayed.
	 */
	private boolean labelled;

	/**
	 * The ID of the marker in the original RuneLite Screen Marker plugin,
	 * if this marker was imported. Used for potential future migration or
	 * reference.
	 * Can be null if the marker was created directly in this plugin.
	 */
	private Long importedId;
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Jasper <Jasper0781@gmail.com>
 * Copyright (c) 2020, melky <https://github.com/melkypie>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay responsible for highlighting widgets when the user is in
 * screen marker creation mode and hovers over a widget menu entry.
 * This helps the user create markers aligned with specific UI elements.
 */
class ScreenMarkerWidgetHighlightOverlay extends Overlay {
	private final ScreenMarkerGroupsPlugin plugin;
	private final Client client;

	/**
	 * Injects dependencies and sets up the overlay properties.
	 *
	 * @param plugin The main plugin instance.
	 * @param client The RuneLite client instance.
	 */
	@Inject
	private ScreenMarkerWidgetHighlightOverlay(final ScreenMarkerGroupsPlugin plugin, final Client client) {
		this.plugin = plugin;
		this.client = client;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(PRIORITY_HIGH);
		setMovable(true);
	}

	/**
	 * Renders the widget highlight overlay.
	 * Only draws if the user is in creation mode but not actively drawing a marker.
	 * Highlights the widget bounds corresponding to the last menu entry hovered.
	 *
	 * @param graphics Graphics2D context for drawing.
	 * @return null, as this overlay doesn't have specific dimensions.
	 */
	@Override
	public Dimension render(Graphics2D graphics) {
		if (!plugin.isCreatingScreenMarker() || plugin.isDrawingScreenMarker()) {
			return null;
		}

		final MenuEntry[] menuEntries = client.getMenuEntries();
		if (client.isMenuOpen() || menuEntries.length == 0) {
			plugin.setSelectedWidgetBounds(null);
			return null;
		}

		final MenuEntry menuEntry = menuEntries[menuEntries.length - 1];
		final int childIdx = menuEntry.getParam0();
		final int widgetId = menuEntry.getParam1();

		final Widget widget = client.getWidget(widgetId);
		if (widget == null) {
			plugin.setSelectedWidgetBounds(null);
			return null;
		}

		Rectangle bounds = null;
		if (childIdx > -1) {
			final Widget child = widget.getChild(childIdx);
			if (child != null) {
				bounds = child.getBounds();
			}
		} else {
			bounds = widget.getBounds();
		}

		if (bounds == null) {
			plugin.setSelectedWidgetBounds(null);
			return null;
		}

		drawHighlight(graphics, bounds);
		plugin.setSelectedWidgetBounds(bounds);

		return null;
	}

	/**
	 * Draws a green highlight rectangle around the given bounds.
	 *
	 * @param graphics The graphics context.
	 * @param bounds   The rectangle bounds to highlight.
	 */
	private static void drawHighlight(Graphics2D graphics, Rectangle bounds) {
		graphics.setColor(Color.GREEN);
		graphics.draw(bounds);
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

/**
 * Configuration interface for the Screen Marker Groups plugin.
 */
@ConfigGroup("screenmarkergroups")
public interface ScreenMarkerGroupsConfig extends Config {
    /**
     * Stores the screen marker groups and their associated markers as a JSON
     * string.
     * The structure is expected to be a Map<String, List<ScreenMarker>>,
     * where the key is the group name and the value is the list of markers in that
     * group.
     *
     * @return JSON string representing the marker groups.
     */
    @ConfigItem(keyName = "markerGroups", name = "Marker Groups Data", description = "Stores the configuration for screen marker groups and markers (internal).", hidden = true)
    default String markerGroups() {
        return "{}";
    }

    /**
     * Stores the display order of the groups as a JSON list of strings.
     *
     * @return JSON string representing the ordered list of group names.
     */
    @ConfigItem(keyName = "groupOrder", name = "Group Order Data", description = "Stores the display order for screen marker groups (internal).", hidden = true)
    default String groupOrder() {
        return "[]";
    }

    /**
     * A config item that acts like a button to trigger the import process.
     * It's a boolean checkbox, but added tooltip to suggest clicking.
     * The plugin listens for changes and resets it immediately.
     *
     * @return false, always.
     */
    @ConfigItem(position = 1, keyName = "importTrigger", name = "Import Screen Markers", description = "Click this to import markers from the original Screen Markers plugin into the 'Imported' group.")
    default boolean importTrigger() {
        return false;
    }

    /**
     * Determines the position of the label relative to the marker border.
     *
     * @return The selected label position.
     */
    @ConfigItem(position = 11, keyName = "labelPosition", name = "Label Position", description = "Position of the label relative to the marker")
    default LabelPosition labelPosition() {
        return LabelPosition.INSIDE;
    }
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
// Inject import removed as it's unused
import lombok.Getter;
import lombok.NonNull;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay responsible for rendering a single screen marker on the game screen.
 * Handles visibility based on both the marker's state and its group's state.
 */
public class ScreenMarkerOverlay extends Overlay {
	@Getter
	private final ScreenMarker marker;
	private final ScreenMarkerRenderable screenMarkerRenderable;
	private final ScreenMarkerGroupsPlugin plugin;

	/**
	 * Constructs the overlay for a given screen marker.
	 *
	 * @param marker The screen marker data object. Cannot be null.
	 * @param plugin The main plugin instance, used for checking group visibility.
	 */
	ScreenMarkerOverlay(@NonNull ScreenMarker marker, ScreenMarkerGroupsPlugin plugin) {
		this.marker = marker;
		this.plugin = plugin;
		this.screenMarkerRenderable = new ScreenMarkerRenderable();
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ALWAYS_ON_TOP);
		setPriority(PRIORITY_HIGH);
		setMovable(true);
		setResizable(true);
		setMinimumSize(16);
		setResettable(false);
	}

	/**
	 * Gets the unique name for this overlay, used for saving configuration.
	 *
	 * @return The overlay name string.
	 */
	@Override
	public String getName() {
		return "marker" + marker.getId();
	}

	/**
	 * Renders the screen marker overlay.
	 * Checks both the marker's visibility and its group's visibility before
	 * drawing.
	 *
	 * @param graphics Graphics2D context for drawing.
	 * @return The dimensions of the rendered overlay, or null if not rendered.
	 */
	@Override
	public Dimension render(Graphics2D graphics) {
		String groupName = plugin.findGroupForMarker(this);

		if (!marker.isVisible() || (groupName != null && !plugin.isGroupVisible(groupName))) {
			return null;
		}

		Dimension preferredSize = getPreferredSize();
		if (preferredSize == null) {
			return null;
		}

		screenMarkerRenderable.setBorderThickness(marker.getBorderThickness());
		screenMarkerRenderable.setColor(marker.getColor());
		screenMarkerRenderable.setFill(marker.getFill());
		screenMarkerRenderable.setStroke(new BasicStroke(marker.getBorderThickness()));
		screenMarkerRenderable.setSize(preferredSize);
		screenMarkerRenderable.setLabel(marker.isLabelled() ? marker.getName() : "");
		screenMarkerRenderable.setLabelPosition(plugin.getConfig().labelPosition());
		return screenMarkerRenderable.render(graphics);
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.BasicStroke;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;
import javax.inject.Inject;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

/**
 * Overlay responsible for rendering the visual representation of
 * a screen marker during its creation process (when the user is dragging).
 * It displays a striped rectangle matching the marker's intended bounds and
 * style.
 */
class ScreenMarkerCreationOverlay extends Overlay {
	private final ScreenMarkerGroupsPlugin plugin;

	/**
	 * Injects dependencies and sets up the overlay properties.
	 *
	 * @param plugin The main plugin instance, used to access the currently drawn
	 *               marker.
	 */
	@Inject
	private ScreenMarkerCreationOverlay(final ScreenMarkerGroupsPlugin plugin) {
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(PRIORITY_HIGH);
		setMovable(true);
	}

	/**
	 * Renders the creation overlay.
	 * Draws a striped rectangle based on the current marker being created.
	 *
	 * @param graphics Graphics2D context for drawing.
	 * @return The dimensions of the rendered overlay, or null if no marker is being
	 *         created.
	 */
	@Override
	public Dimension render(Graphics2D graphics) {
		ScreenMarker marker = plugin.getCurrentMarker();

		if (marker == null) {
			return null;
		}

		int thickness = marker.getBorderThickness();
		int offset = thickness / 2;
		int width = getBounds().width - thickness;
		int height = getBounds().height - thickness;

		graphics.setStroke(createStripedStroke(thickness));
		graphics.setColor(marker.getColor());
		graphics.drawRect(offset, offset, width, height);

		return getBounds().getSize();
	}

	/**
	 * Creates a dashed stroke style used for rendering the marker creation outline.
	 *
	 * @param thickness The desired thickness of the stroke.
	 * @return A Stroke object configured with a dashed pattern.
	 */
	private Stroke createStripedStroke(int thickness) {
		return new BasicStroke(thickness, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[] { 9 }, 0);
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import javax.swing.SwingUtilities;
import net.runelite.client.input.MouseAdapter;

/**
 * Mouse listener responsible for handling user interactions during the
 * screen marker creation process. It listens for clicks, presses, releases,
 * and drags to define the marker's bounds or cancel the creation.
 */
class ScreenMarkerMouseListener extends MouseAdapter {
	private final ScreenMarkerGroupsPlugin plugin;

	/**
	 * Constructs the mouse listener.
	 *
	 * @param plugin The main plugin instance.
	 */
	ScreenMarkerMouseListener(ScreenMarkerGroupsPlugin plugin) {
		this.plugin = plugin;
	}

	/**
	 * Consumes click events during marker creation to prevent unintended
	 * interactions.
	 *
	 * @param event The mouse event.
	 * @return The potentially consumed mouse event.
	 */
	@Override
	public MouseEvent mouseClicked(MouseEvent event) {
		if (SwingUtilities.isMiddleMouseButton(event)) {
			return event;
		}
		if (plugin.isCreatingScreenMarker()) {
			event.consume();
		}
		return event;
	}

	/**
	 * Handles the initial mouse press for marker creation.
	 * If left-clicking on a highlighted widget, creates a marker matching the
	 * widget bounds.
	 * If left-clicking elsewhere, starts the drag-to-create process.
	 * If right-clicking during creation, cancels the process.
	 *
	 * @param event The mouse event.
	 * @return The potentially consumed mouse event.
	 */
	@Override
	public MouseEvent mousePressed(MouseEvent event) {
		if (SwingUtilities.isMiddleMouseButton(event)) {
			return event;
		}

		if (SwingUtilities.isLeftMouseButton(event)) {
			if (plugin.isCreatingScreenMarker()) {
				final Rectangle bounds = plugin.getSelectedWidgetBounds();

				if (bounds != null) {
					plugin.startCreation(bounds.getLocation(), bounds.getSize());
					plugin.completeSelection();
				} else if (plugin.getStartLocation() == null) {
					plugin.startCreation(event.getPoint(), ScreenMarkerGroupsPlugin.DEFAULT_SIZE);
				}

				event.consume();
				return event;
			}
		} else if (plugin.isCreatingScreenMarker()) {
			plugin.finishCreation(true);
			event.consume();
		}
		return event;
	}

	/**
	 * Handles the mouse release event during marker creation.
	 * If the left button is released while drawing, it completes the marker
	 * selection.
	 *
	 * @param event The mouse event.
	 * @return The potentially consumed mouse event.
	 */
	@Override
	public MouseEvent mouseReleased(MouseEvent event) {
		if (SwingUtilities.isMiddleMouseButton(event)) {
			return event;
		}

		if (SwingUtilities.isLeftMouseButton(event) && plugin.isCreatingScreenMarker()
				&& plugin.isDrawingScreenMarker()) {
			plugin.setDrawingScreenMarker(false);
			plugin.completeSelection();
			event.consume();
		}
		return event;
	}

	/**
	 * Handles mouse drag events during marker creation.
	 * If dragging with the left button, it initializes creation if needed and
	 * resizes the marker based on the current mouse position.
	 *
	 * @param event The mouse event.
	 * @return The potentially consumed mouse event.
	 */
	@Override
	public MouseEvent mouseDragged(MouseEvent event) {
		if (!plugin.isCreatingScreenMarker() || SwingUtilities.isMiddleMouseButton(event)) {
			return event;
		}

		if (SwingUtilities.isLeftMouseButton(event)) {
			if (plugin.getStartLocation() == null) {
				plugin.startCreation(event.getPoint(), ScreenMarkerGroupsPlugin.DEFAULT_SIZE);
			}
			plugin.resizeMarker(event.getPoint());
			event.consume();
		}
		return event;
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups.ui;

import screenmarkergroups.ScreenMarkerOverlay;
import screenmarkergroups.ScreenMarkerGroupsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.Box;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.ImageUtil;

/**
 * The main plugin panel for the Screen Marker Groups plugin.
 * Displays groups and their markers, providing controls for adding groups
 * and managing the overall view.
 */
public class ScreenMarkerGroupsPluginPanel extends PluginPanel {
	@Getter
	private final Map<String, ScreenMarkerGroupsCreationPanel> creationPanelsMap = new HashMap<>();

	private static final ImageIcon ADD_GROUP_ICON;
	private static final ImageIcon ADD_GROUP_HOVER_ICON;
	public static final Color DEFAULT_BORDER_COLOR = Color.GREEN;
	public static final Color DEFAULT_FILL_COLOR = new Color(0, 255, 0, 0);
	public static final int DEFAULT_BORDER_THICKNESS = 3;

	public static final Color SELECTED_COLOR = DEFAULT_BORDER_COLOR;
	public static final Color SELECTED_FILL_COLOR = DEFAULT_FILL_COLOR;
	public static final int SELECTED_BORDER_THICKNESS = DEFAULT_BORDER_THICKNESS;

	private final JLabel addGroupButton = new JLabel(ADD_GROUP_ICON);
	private final JLabel title = new JLabel();
	private final PluginErrorPanel noMarkersPanel = new PluginErrorPanel();
	private final JPanel markerView = new JPanel(new GridBagLayout());

	private final ScreenMarkerGroupsPlugin plugin;

	static {
		final BufferedImage addIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "add_icon.png");

		ADD_GROUP_ICON = new ImageIcon(addIcon);
		ADD_GROUP_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));
	}

	/**
	 * Constructs the main plugin panel.
	 *
	 * @param screenMarkerPlugin The main plugin instance.
	 */
	public ScreenMarkerGroupsPluginPanel(ScreenMarkerGroupsPlugin screenMarkerPlugin) {
		this.plugin = screenMarkerPlugin;

		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));

		JPanel northPanel = new JPanel(new BorderLayout());
		northPanel.setBorder(new EmptyBorder(1, 0, 10, 0));

		title.setText("Screen Marker Groups");
		title.setForeground(Color.WHITE);

		addGroupButton.setToolTipText("Add new group");
		addGroupButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				String groupName = JOptionPane.showInputDialog(
						ScreenMarkerGroupsPluginPanel.this,
						"Enter name for the new group:",
						"Add New Group",
						JOptionPane.PLAIN_MESSAGE);

				if (!com.google.common.base.Strings.isNullOrEmpty(groupName)) {
					if (!plugin.addGroup(groupName)) {
						JOptionPane.showMessageDialog(
								ScreenMarkerGroupsPluginPanel.this,
								"Group '" + groupName + "' already exists or is invalid.",
								"Error Adding Group",
								JOptionPane.ERROR_MESSAGE);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				addGroupButton.setIcon(ADD_GROUP_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				addGroupButton.setIcon(ADD_GROUP_ICON);
			}
		});

		northPanel.add(title, BorderLayout.WEST);
		northPanel.add(addGroupButton, BorderLayout.EAST);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		markerView.setBackground(ColorScheme.DARK_GRAY_COLOR);

		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;

		noMarkersPanel.setContent("Screen Markers", "Highlight a region on your screen.");
		noMarkersPanel.setVisible(false);

		markerView.add(noMarkersPanel, constraints);
		constraints.gridy++;

		centerPanel.add(markerView, BorderLayout.CENTER);

		add(northPanel, BorderLayout.NORTH);
		add(centerPanel, BorderLayout.CENTER);
	}

	/**
	 * Rebuilds the entire panel display based on the current groups and markers
	 * stored in the plugin. Clears the existing view and reconstructs it with
	 * group headers and marker panels according to their order, visibility, and
	 * expansion state.
	 */
	public void rebuild() {
		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.weighty = 0;
		constraints.gridx = 0;
		constraints.gridy = 0;

		markerView.removeAll();
		creationPanelsMap.clear();
		int markerCount = 0;

		for (String groupName : plugin.getGroupOrderList()) {
			List<ScreenMarkerOverlay> markersInGroup = plugin.getMarkerGroups().get(groupName);

			if (markersInGroup == null) {
				continue;
			}

			// Don't show the 'Unassigned' group header if it's empty
			if (markersInGroup.isEmpty() && groupName.equals(ScreenMarkerGroupsPlugin.UNASSIGNED_GROUP)) {
				continue;
			}

			boolean initialVisibility = plugin.isGroupVisible(groupName);
			boolean initialExpansion = plugin.isGroupExpanded(groupName);

			GroupHeaderPanel headerPanel = new GroupHeaderPanel(
					plugin,
					groupName,
					initialVisibility,
					initialExpansion,
					(isVisible) -> plugin.setGroupVisibility(groupName, isVisible),
					(isExpanded) -> {
						plugin.setGroupExpansion(groupName, isExpanded);
						rebuild();
					});
			markerView.add(headerPanel, constraints);
			constraints.gridy++;

			ScreenMarkerGroupsCreationPanel currentCreationPanel = new ScreenMarkerGroupsCreationPanel(plugin);
			currentCreationPanel.setVisible(false);
			creationPanelsMap.put(groupName, currentCreationPanel);
			markerView.add(currentCreationPanel, constraints);
			constraints.gridy++;

			if (initialExpansion) {
				for (int i = 0; i < markersInGroup.size(); i++) {
					final ScreenMarkerOverlay marker = markersInGroup.get(i);
					markerView.add(new ScreenMarkerGroupsPanel(plugin, marker), constraints);
					constraints.gridy++;
					markerCount++;

					if (i < markersInGroup.size() - 1) {
						markerView.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
						constraints.gridy++;
					}
				}

				if (!markersInGroup.isEmpty()) {
					markerView.add(Box.createRigidArea(new Dimension(0, 5)), constraints);
					constraints.gridy++;
				}
			} else {
				markerCount += markersInGroup.size();
			}
		}

		constraints.weighty = 1;
		markerView.add(Box.createVerticalGlue(), constraints);
		constraints.gridy++;
		constraints.weighty = 0;

		boolean empty = markerCount == 0;
		noMarkersPanel.setVisible(empty);
		markerView.add(noMarkersPanel, constraints);
		constraints.gridy++;

		repaint();
		revalidate();
	}

	/**
	 * Sets the panel state for marker creation mode. Hides/shows the appropriate
	 * creation panel for the target group and disables controls on other panels.
	 *
	 * @param on True to enter creation mode, false to exit.
	 */
	public void setCreation(boolean on) {
		creationPanelsMap.values().forEach(panel -> panel.setVisible(false));

		if (on) {
			String targetGroup = plugin.getTargetGroupNameForCreation();
			ScreenMarkerGroupsCreationPanel targetCreationPanel = creationPanelsMap
					.get(targetGroup != null ? targetGroup : ScreenMarkerGroupsPlugin.UNASSIGNED_GROUP);

			if (targetCreationPanel != null) {
				targetCreationPanel.setVisible(true);
				targetCreationPanel.lockConfirm();
				noMarkersPanel.setVisible(false);
				title.setVisible(true);
			}
		} else {
			boolean empty = plugin.getMarkerGroups().values().stream().allMatch(List::isEmpty);
			noMarkersPanel.setVisible(empty);
		}

		addGroupButton.setVisible(!on);

		for (Component comp : markerView.getComponents()) {
			if (comp instanceof ScreenMarkerGroupsPanel) {
				((ScreenMarkerGroupsPanel) comp).setControlsEnabled(!on);
			} else if (comp instanceof GroupHeaderPanel) {
				((GroupHeaderPanel) comp).setControlsEnabled(!on);
			}
		}
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups.ui;

import screenmarkergroups.ScreenMarkerGroupsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.shadowlabel.JShadowedLabel;
import net.runelite.client.util.ImageUtil;

/**
 * Panel displayed at the bottom of a group's marker list when the user
 * enters marker creation mode for that specific group. Provides instructions
 * and confirm/cancel controls.
 */
public class ScreenMarkerGroupsCreationPanel extends JPanel {
	private static final ImageIcon CONFIRM_ICON;
	private static final ImageIcon CONFIRM_HOVER_ICON;
	private static final ImageIcon CONFIRM_LOCKED_ICON;
	private static final ImageIcon CANCEL_ICON;
	private static final ImageIcon CANCEL_HOVER_ICON;

	private final JShadowedLabel instructionsLabel = new JShadowedLabel();
	private final JLabel confirmLabel = new JLabel();
	private boolean lockedConfirm = true;

	static {
		CONFIRM_ICON = new ImageIcon(ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "confirm_icon.png"));
		CANCEL_ICON = new ImageIcon(ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "cancel_icon.png"));

		final BufferedImage confirmIcon = ImageUtil.bufferedImageFromImage(CONFIRM_ICON.getImage());
		CONFIRM_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(confirmIcon, 0.54f));
		CONFIRM_LOCKED_ICON = new ImageIcon(ImageUtil.grayscaleImage(confirmIcon));
		CANCEL_HOVER_ICON = new ImageIcon(
				ImageUtil.alphaOffset(ImageUtil.bufferedImageFromImage(CANCEL_ICON.getImage()), 0.6f));
	}

	/**
	 * Constructs the creation panel.
	 *
	 * @param plugin The main plugin instance.
	 */
	ScreenMarkerGroupsCreationPanel(ScreenMarkerGroupsPlugin plugin) {
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
		setBorder(new EmptyBorder(8, 8, 8, 8));
		setLayout(new BorderLayout());

		instructionsLabel.setFont(FontManager.getRunescapeSmallFont());
		instructionsLabel.setForeground(Color.WHITE);

		JPanel actionsContainer = new JPanel(new GridLayout(1, 2, 8, 0));
		actionsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		confirmLabel.setIcon(CONFIRM_LOCKED_ICON);
		confirmLabel.setToolTipText("Confirm and save");
		confirmLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				if (!lockedConfirm) {
					plugin.finishCreation(false);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				confirmLabel.setIcon(lockedConfirm ? CONFIRM_LOCKED_ICON : CONFIRM_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				confirmLabel.setIcon(lockedConfirm ? CONFIRM_LOCKED_ICON : CONFIRM_ICON);
			}
		});

		JLabel cancelLabel = new JLabel(CANCEL_ICON);
		cancelLabel.setToolTipText("Cancel");
		cancelLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				plugin.finishCreation(true);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				cancelLabel.setIcon(CANCEL_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				cancelLabel.setIcon(CANCEL_ICON);
			}
		});

		actionsContainer.add(confirmLabel);
		actionsContainer.add(cancelLabel);

		add(instructionsLabel, BorderLayout.CENTER);
		add(actionsContainer, BorderLayout.EAST);
	}

	/**
	 * Unlocks the confirm button, allowing the user to save the marker.
	 * Updates the button icon and instruction text.
	 */
	public void unlockConfirm() {
		this.confirmLabel.setIcon(CONFIRM_ICON);
		this.lockedConfirm = false;
		instructionsLabel.setText("Confirm or cancel to finish.");
	}

	/**
	 * Locks the confirm button, preventing saving until a marker area is defined.
	 * Updates the button icon and instruction text.
	 */
	public void lockConfirm() {
		this.confirmLabel.setIcon(CONFIRM_LOCKED_ICON);
		this.lockedConfirm = true;
		instructionsLabel.setText("Drag in-game to draw");
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups.ui;

import screenmarkergroups.ScreenMarkerOverlay;
import screenmarkergroups.ScreenMarkerGroupsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.List;
import java.util.stream.Collectors;
import javax.swing.BorderFactory;
import javax.swing.ImageIcon;
import javax.swing.JLabel;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JSpinner;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.ui.components.colorpicker.RuneliteColorPicker;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

/**
 * Represents a panel within the main plugin sidebar, displaying controls
 * for a single ScreenMarkerOverlay. Allows editing name, colors, thickness,
 * visibility, label display, and deletion.
 */
class ScreenMarkerGroupsPanel extends JPanel {
	private static final int DEFAULT_FILL_OPACITY = 75;

	private static final Border NAME_BOTTOM_BORDER = new CompoundBorder(
			BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR),
			BorderFactory.createLineBorder(ColorScheme.DARKER_GRAY_COLOR));

	private static final ImageIcon BORDER_COLOR_ICON;
	private static final ImageIcon BORDER_COLOR_HOVER_ICON;
	private static final ImageIcon NO_BORDER_COLOR_ICON;
	private static final ImageIcon NO_BORDER_COLOR_HOVER_ICON;

	private static final ImageIcon FILL_COLOR_ICON;
	private static final ImageIcon FILL_COLOR_HOVER_ICON;
	private static final ImageIcon NO_FILL_COLOR_ICON;
	private static final ImageIcon NO_FILL_COLOR_HOVER_ICON;

	private static final ImageIcon LABEL_ICON;
	private static final ImageIcon LABEL_HOVER_ICON;
	private static final ImageIcon NO_LABEL_ICON;
	private static final ImageIcon NO_LABEL_HOVER_ICON;

	private static final ImageIcon VISIBLE_ICON;
	private static final ImageIcon VISIBLE_HOVER_ICON;
	private static final ImageIcon INVISIBLE_ICON;
	private static final ImageIcon INVISIBLE_HOVER_ICON;

	private static final ImageIcon CONFIGURE_ICON;
	private static final ImageIcon CONFIGURE_HOVER_ICON;

	private static final ImageIcon DELETE_ICON;
	private static final ImageIcon DELETE_HOVER_ICON;

	private final ScreenMarkerGroupsPlugin plugin;
	private final ScreenMarkerOverlay marker;
	private final JPopupMenu contextMenu;

	private final JLabel borderColorIndicator = new JLabel();
	private final JLabel fillColorIndicator = new JLabel();
	private final JLabel labelIndicator = new JLabel();
	private final JLabel configureLabel = new JLabel();
	private final JLabel visibilityLabel = new JLabel();
	private final JLabel deleteLabel = new JLabel();

	private final FlatTextField nameInput = new FlatTextField();
	private final JLabel save = new JLabel("Save");
	private final JLabel cancel = new JLabel("Cancel");
	private final JLabel rename = new JLabel("Rename");

	private final SpinnerModel spinnerModel = new SpinnerNumberModel(5, 0, Integer.MAX_VALUE, 1);
	private final JSpinner thicknessSpinner = new JSpinner(spinnerModel);

	private boolean visible;
	private boolean showLabel;

	static {
		final BufferedImage borderImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"border_color_icon.png");
		final BufferedImage borderImgHover = ImageUtil.luminanceOffset(borderImg, -150);
		BORDER_COLOR_ICON = new ImageIcon(borderImg);
		BORDER_COLOR_HOVER_ICON = new ImageIcon(borderImgHover);

		NO_BORDER_COLOR_ICON = new ImageIcon(borderImgHover);
		NO_BORDER_COLOR_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(borderImgHover, -100));

		final BufferedImage fillImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"fill_color_icon.png");
		final BufferedImage fillImgHover = ImageUtil.luminanceOffset(fillImg, -150);
		FILL_COLOR_ICON = new ImageIcon(fillImg);
		FILL_COLOR_HOVER_ICON = new ImageIcon(fillImgHover);

		NO_FILL_COLOR_ICON = new ImageIcon(fillImgHover);
		NO_FILL_COLOR_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(fillImgHover, -100));

		final BufferedImage labelImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "label_icon.png");
		final BufferedImage labelImgHover = ImageUtil.luminanceOffset(labelImg, -150);
		LABEL_ICON = new ImageIcon(labelImg);
		LABEL_HOVER_ICON = new ImageIcon(labelImgHover);

		NO_LABEL_ICON = new ImageIcon(labelImgHover);
		NO_LABEL_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(labelImgHover, -100));

		final BufferedImage visibleImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleImg);
		VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleImg, -100));

		final BufferedImage invisibleImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleImg);
		INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleImg, -100));

		final BufferedImage configureImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "configure.png");
		CONFIGURE_ICON = new ImageIcon(configureImg);
		CONFIGURE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(configureImg, -100));

		final BufferedImage deleteImg = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "delete_icon.png");
		DELETE_ICON = new ImageIcon(deleteImg);
		DELETE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(deleteImg, -100));
	}

	/**
	 * Constructs the panel for a specific screen marker.
	 *
	 * @param plugin The main plugin instance.
	 * @param marker The screen marker overlay this panel represents.
	 */
	ScreenMarkerGroupsPanel(ScreenMarkerGroupsPlugin plugin, ScreenMarkerOverlay marker) {
		this.plugin = plugin;
		this.marker = marker;
		this.visible = marker.getMarker().isVisible();
		this.showLabel = marker.getMarker().isLabelled();

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel nameWrapper = new JPanel(new BorderLayout());
		nameWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameWrapper.setBorder(NAME_BOTTOM_BORDER);

		JPanel nameActions = new JPanel(new BorderLayout(3, 0));
		nameActions.setBorder(new EmptyBorder(0, 0, 0, 8));
		nameActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		save.setVisible(false);
		save.setFont(FontManager.getRunescapeSmallFont());
		save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
		save.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				save();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				save.setForeground(ColorScheme.PROGRESS_COMPLETE_COLOR);
			}
		});

		cancel.setVisible(false);
		cancel.setFont(FontManager.getRunescapeSmallFont());
		cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		cancel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				cancel();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR.darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				cancel.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
			}
		});

		rename.setFont(FontManager.getRunescapeSmallFont());
		rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
		rename.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				nameInput.setEditable(true);
				updateNameActions(true);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker().darker());
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				rename.setForeground(ColorScheme.LIGHT_GRAY_COLOR.darker());
			}
		});

		nameActions.add(save, BorderLayout.EAST);
		nameActions.add(cancel, BorderLayout.WEST);
		nameActions.add(rename, BorderLayout.CENTER);

		nameInput.setText(marker.getMarker().getName());
		nameInput.setBorder(null);
		nameInput.setEditable(false);
		nameInput.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		nameInput.setPreferredSize(new Dimension(0, 24));
		nameInput.getTextField().setForeground(Color.WHITE);
		nameInput.getTextField().setBorder(new EmptyBorder(0, 8, 0, 0));
		nameInput.addKeyListener(new KeyAdapter() {
			@Override
			public void keyPressed(KeyEvent e) {
				if (e.getKeyCode() == KeyEvent.VK_ENTER) {
					save();
				} else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {
					cancel();
				}
			}
		});
		nameInput.getTextField().addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				preview(true);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				preview(false);
			}
		});

		nameWrapper.add(nameInput, BorderLayout.CENTER);
		nameWrapper.add(nameActions, BorderLayout.EAST);

		JPanel bottomContainer = new JPanel(new BorderLayout());
		bottomContainer.setBorder(new EmptyBorder(2, 0, 0, 0));
		bottomContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel leftActions = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 8));
		leftActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		borderColorIndicator.setToolTipText("Edit border color");
		borderColorIndicator.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				openBorderColorPicker();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				borderColorIndicator.setIcon(marker.getMarker().getBorderThickness() == 0 ? NO_BORDER_COLOR_HOVER_ICON
						: BORDER_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				borderColorIndicator.setIcon(
						marker.getMarker().getBorderThickness() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
			}
		});

		fillColorIndicator.setToolTipText("Edit fill color");
		fillColorIndicator.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				openFillColorPicker();
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				fillColorIndicator.setIcon(marker.getMarker().getFill().getAlpha() == 0 ? NO_FILL_COLOR_HOVER_ICON
						: FILL_COLOR_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				fillColorIndicator
						.setIcon(marker.getMarker().getFill().getAlpha() == 0 ? NO_FILL_COLOR_ICON : FILL_COLOR_ICON);
			}
		});

		thicknessSpinner.setValue(marker.getMarker().getBorderThickness());
		thicknessSpinner.setPreferredSize(new Dimension(50, 20));
		thicknessSpinner.addChangeListener(ce -> updateThickness(true));
		thicknessSpinner.setToolTipText("Border thickness");

		labelIndicator.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				toggleLabelling(!showLabel);
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				labelIndicator.setIcon(showLabel ? LABEL_HOVER_ICON : NO_LABEL_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
			}
		});

		leftActions.add(borderColorIndicator);
		leftActions.add(fillColorIndicator);
		leftActions.add(labelIndicator);
		leftActions.add(thicknessSpinner);

		JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 4, 8));
		rightActions.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		this.contextMenu = setupContextMenu();

		configureLabel.setIcon(CONFIGURE_ICON);
		configureLabel.setToolTipText("Configure marker");
		configureLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				if (configureLabel.isEnabled() && SwingUtilities.isLeftMouseButton(mouseEvent)) {
					contextMenu.show(configureLabel, mouseEvent.getX(), mouseEvent.getY());
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				configureLabel.setIcon(CONFIGURE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				configureLabel.setIcon(CONFIGURE_ICON);
			}
		});

		visibilityLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				if (visibilityLabel.isEnabled()) {
					toggle(!visible);
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				visibilityLabel.setIcon(visible ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				updateVisibility();
			}
		});

		deleteLabel.setIcon(DELETE_ICON);
		deleteLabel.setToolTipText("Delete screen marker");
		deleteLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent mouseEvent) {
				if (deleteLabel.isEnabled()) {
					int confirm = JOptionPane.showConfirmDialog(ScreenMarkerGroupsPanel.this,
							"Are you sure you want to permanently delete this screen marker?",
							"Warning", JOptionPane.OK_CANCEL_OPTION);

					if (confirm == 0) {
						plugin.deleteMarker(marker);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				deleteLabel.setIcon(DELETE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				deleteLabel.setIcon(DELETE_ICON);
			}
		});

		rightActions.add(configureLabel);
		rightActions.add(visibilityLabel);
		rightActions.add(deleteLabel);

		bottomContainer.add(leftActions, BorderLayout.WEST);
		bottomContainer.add(rightActions, BorderLayout.EAST);

		add(nameWrapper, BorderLayout.NORTH);
		add(bottomContainer, BorderLayout.CENTER);

		updateVisibility();
		updateFill();
		updateBorder();
		updateLabelling();
	}

	/**
	 * Temporarily shows the marker overlay if it's currently hidden.
	 * Used for previewing during hover events.
	 *
	 * @param on True to show, false to revert to original visibility.
	 */
	private void preview(boolean on) {
		if (visible) {
			return;
		}
		marker.getMarker().setVisible(on);
	}

	/**
	 * Toggles the persistent visibility state of the marker.
	 * Updates the marker data, saves configuration, and updates the UI icon.
	 *
	 * @param on o make visible, false to hide.
	 */
	private void toggle(boolean on) {
		visible = on;
		marker.getMarker().setVisible(visible);
		plugin.updateGroupsConfig();
		updateVisibility();

		String groupName = plugin.findGroupForMarker(marker);
		if (groupName != null && plugin.isGroupVisible(groupName)) {
			net.runelite.client.ui.overlay.OverlayManager overlayManager = plugin.getOverlayManager();
			if (overlayManager != null) {
				if (visible) {
					overlayManager.add(marker);
				} else {
					overlayManager.remove(marker);
				}
			}
		}
	}

	/**
	 * Toggles the label display state for the marker.
	 * Updates the marker data, saves configuration, and updates the UI icon.
	 *
	 * @param on True to show the label, false to hide.
	 */
	private void toggleLabelling(boolean on) {
		showLabel = on;
		marker.getMarker().setLabelled(showLabel);
		plugin.updateGroupsConfig();
		updateLabelling();
	}

	/**
	 * Saves the currently entered name in the name input field to the marker data,
	 * updates configuration, and reverts the name field to a non-editable state.
	 */
	private void save() {
		marker.getMarker().setName(nameInput.getText());
		plugin.updateGroupsConfig();
		nameInput.setEditable(false);
		updateNameActions(false);
		requestFocusInWindow();
	}

	/**
	 * Cancels the renaming process, reverting the name input field to the marker's
	 * current name and making it non-editable.
	 */
	private void cancel() {
		nameInput.setEditable(false);
		nameInput.setText(marker.getMarker().getName());
		updateNameActions(false);
		requestFocusInWindow();
	}

	/**
	 * Updates the visibility of the save/cancel/rename actions based on whether
	 * the name field is currently being edited.
	 *
	 * @param saveAndCancel True if the name is being edited (show save/cancel),
	 *                      false otherwise (show rename).
	 */
	private void updateNameActions(boolean saveAndCancel) {
		save.setVisible(saveAndCancel);
		cancel.setVisible(saveAndCancel);
		rename.setVisible(!saveAndCancel);
		if (saveAndCancel) {
			nameInput.getTextField().requestFocusInWindow();
			nameInput.getTextField().selectAll();
		}
	}

	/**
	 * Updates the marker's border thickness based on the spinner value.
	 *
	 * @param save True to save the configuration change immediately, false
	 *             otherwise.
	 */
	private void updateThickness(boolean save) {
		marker.getMarker().setBorderThickness((Integer) thicknessSpinner.getValue());
		updateBorder();
		if (save) {
			plugin.updateGroupsConfig();
		}
	}

	/**
	 * Updates the visibility indicator icon and tooltip based on the current
	 * visibility state.
	 */
	private void updateVisibility() {
		visibilityLabel.setIcon(visible ? VISIBLE_ICON : INVISIBLE_ICON);
		visibilityLabel.setToolTipText(visible ? "Hide screen marker" : "Show screen marker");
	}

	/**
	 * Updates the label indicator icon and tooltip based on the current label
	 * display state.
	 */
	private void updateLabelling() {
		labelIndicator.setIcon(showLabel ? LABEL_ICON : NO_LABEL_ICON);
		labelIndicator.setToolTipText(showLabel ? "Hide label" : "Show label");
	}

	/**
	 * Updates the fill color indicator icon and border based on the marker's fill
	 * color and alpha.
	 */
	private void updateFill() {
		final boolean isFullyTransparent = marker.getMarker().getFill().getAlpha() == 0;
		if (isFullyTransparent) {
			fillColorIndicator.setBorder(null);
		} else {
			Color color = marker.getMarker().getFill();
			Color fullColor = new Color(color.getRed(), color.getGreen(), color.getBlue());
			fillColorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, fullColor));
		}
		fillColorIndicator.setIcon(isFullyTransparent ? NO_FILL_COLOR_ICON : FILL_COLOR_ICON);
	}

	/**
	 * Updates the border color indicator icon and border based on the marker's
	 * border color and thickness.
	 */
	private void updateBorder() {
		if (marker.getMarker().getBorderThickness() == 0) {
			borderColorIndicator.setBorder(null);
		} else {
			Color color = marker.getMarker().getColor();
			borderColorIndicator.setBorder(new MatteBorder(0, 0, 3, 0, color));
		}
		borderColorIndicator
				.setIcon(marker.getMarker().getBorderThickness() == 0 ? NO_BORDER_COLOR_ICON : BORDER_COLOR_ICON);
	}

	/**
	 * Opens the color picker for editing the marker's fill color.
	 * Updates the marker data and UI indicator upon color change.
	 * Saves configuration when the color picker is closed.
	 */
	private void openFillColorPicker() {
		final Color fillColor = marker.getMarker().getFill();
		RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
				this,
				fillColor.getAlpha() == 0 ? ColorUtil.colorWithAlpha(fillColor, DEFAULT_FILL_OPACITY) : fillColor,
				marker.getMarker().getName() + " Fill",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnColorChange(c -> {
			marker.getMarker().setFill(c);
			updateFill();
		});
		colorPicker.setOnClose(c -> plugin.updateGroupsConfig());
		colorPicker.setVisible(true);
	}

	/**
	 * Opens the color picker for editing the marker's border color.
	 * Updates the marker data and UI indicator upon color change.
	 * Saves configuration when the color picker is closed.
	 */
	private void openBorderColorPicker() {
		RuneliteColorPicker colorPicker = plugin.getColorPickerManager().create(
				this,
				marker.getMarker().getColor(),
				marker.getMarker().getName() + " Border",
				false);
		colorPicker.setLocationRelativeTo(this);
		colorPicker.setOnColorChange(c -> {
			marker.getMarker().setColor(c);
			updateBorder();
		});
		colorPicker.setOnClose(c -> plugin.updateGroupsConfig());
		colorPicker.setVisible(true);
	}

	/**
	 * Sets up the context menu for the marker panel. Includes options for moving
	 * the marker within or between groups.
	 *
	 * @return The configured JPopupMenu.
	 */
	private JPopupMenu setupContextMenu() {
		final JPopupMenu popupMenu = new JPopupMenu();

		final JMenuItem moveUpItem = new JMenuItem("Move Up");
		moveUpItem.addActionListener(e -> plugin.moveMarkerUp(marker));
		popupMenu.add(moveUpItem);

		final JMenuItem moveDownItem = new JMenuItem("Move Down");
		moveDownItem.addActionListener(e -> plugin.moveMarkerDown(marker));
		popupMenu.add(moveDownItem);

		final JMenu moveToGroupMenu = new JMenu("Move to Group");
		popupMenu.add(moveToGroupMenu);

		// Populate "Move to Group" submenu dynamically when shown
		popupMenu.addPopupMenuListener(new javax.swing.event.PopupMenuListener() {
			@Override
			public void popupMenuWillBecomeVisible(javax.swing.event.PopupMenuEvent e) {
				moveToGroupMenu.removeAll();
				String currentGroupName = plugin.findGroupForMarker(marker);

				List<String> otherGroupNames = plugin.getGroupOrderList().stream()
						.filter(name -> !name.equals(currentGroupName))
						.collect(Collectors.toList());

				if (otherGroupNames.isEmpty()) {
					JMenuItem noOtherGroups = new JMenuItem("No other groups");
					noOtherGroups.setEnabled(false);
					moveToGroupMenu.add(noOtherGroups);
				} else {
					for (String groupName : otherGroupNames) {
						JMenuItem groupItem = new JMenuItem(groupName);
						groupItem.addActionListener(ae -> plugin.moveMarkerToGroup(marker, groupName));
						moveToGroupMenu.add(groupItem);
					}
				}
				moveToGroupMenu.setEnabled(!otherGroupNames.isEmpty());
			}

			@Override
			public void popupMenuWillBecomeInvisible(javax.swing.event.PopupMenuEvent e) {
			}

			@Override
			public void popupMenuCanceled(javax.swing.event.PopupMenuEvent e) {
			}
		});

		return popupMenu;
	}

	/**
	 * Enables or disables the configuration controls for this marker panel.
	 * Used when entering/exiting marker creation mode for a group.
	 *
	 * @param enabled True to enable controls, false to disable.
	 */
	void setControlsEnabled(boolean enabled) {
		configureLabel.setEnabled(enabled);
		configureLabel.setToolTipText(enabled ? "Configure marker" : null);

		borderColorIndicator.setEnabled(enabled);
		fillColorIndicator.setEnabled(enabled);
		labelIndicator.setEnabled(enabled);
		thicknessSpinner.setEnabled(enabled);
		visibilityLabel.setEnabled(enabled);
		deleteLabel.setEnabled(enabled);
		rename.setEnabled(enabled);
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups.ui;

import screenmarkergroups.ScreenMarkerGroupsPlugin;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.function.Consumer;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.BorderFactory;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import javax.swing.border.Border;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
// SwingUtil import removed as unused
import net.runelite.client.util.ImageUtil;
import javax.swing.ImageIcon;
import java.awt.image.BufferedImage;

/**
 * A panel that represents the header for a screen marker group.
 * Displays the group name and includes controls for visibility, expansion,
 * configuration, and adding markers.
 */
class GroupHeaderPanel extends JPanel {
	private static final ImageIcon ADD_MARKER_ICON;
	private static final ImageIcon ADD_MARKER_HOVER_ICON;
	private static final ImageIcon CONFIGURE_ICON;
	private static final ImageIcon CONFIGURE_HOVER_ICON;
	private static final ImageIcon VISIBLE_ICON;
	private static final ImageIcon VISIBLE_HOVER_ICON;
	private static final ImageIcon INVISIBLE_ICON;
	private static final ImageIcon INVISIBLE_HOVER_ICON;
	private static final ImageIcon EXPANDED_ICON;
	private static final ImageIcon EXPANDED_HOVER_ICON;
	private static final ImageIcon COLLAPSED_ICON;
	private static final ImageIcon COLLAPSED_HOVER_ICON;

	private final JLabel nameLabel;
	private final String groupName;
	private boolean isVisible;
	private boolean isExpanded;
	private final ScreenMarkerGroupsPlugin plugin;
	private final JLabel expansionLabel = new JLabel();
	private final JLabel configureLabel = new JLabel();
	private final JLabel visibilityLabel = new JLabel();
	private final JLabel addMarkerButton = new JLabel();
	private final JPopupMenu contextMenu;

	static {
		final BufferedImage addIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "add_icon.png");
		ADD_MARKER_ICON = new ImageIcon(addIcon);
		ADD_MARKER_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(addIcon, -100));

		final BufferedImage configureIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"configure.png");
		CONFIGURE_ICON = new ImageIcon(configureIcon);
		CONFIGURE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(configureIcon, -100));

		final BufferedImage visibleIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"visible_icon.png");
		VISIBLE_ICON = new ImageIcon(visibleIcon);
		VISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(visibleIcon, -100));

		final BufferedImage invisibleIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"invisible_icon.png");
		INVISIBLE_ICON = new ImageIcon(invisibleIcon);
		INVISIBLE_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(invisibleIcon, -100));

		final BufferedImage expandedIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class, "expanded.png");
		EXPANDED_ICON = new ImageIcon(expandedIcon);
		EXPANDED_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(expandedIcon, -100));

		final BufferedImage collapsedIcon = ImageUtil.loadImageResource(ScreenMarkerGroupsPlugin.class,
				"collapsed.png");
		COLLAPSED_ICON = new ImageIcon(collapsedIcon);
		COLLAPSED_HOVER_ICON = new ImageIcon(ImageUtil.alphaOffset(collapsedIcon, -100));
	}

	/**
	 * Updates the enabled state of context menu items (Rename, Delete, Move Up,
	 * Move Down) based on whether the group is a special group ("Unassigned",
	 * "Imported") and the total number of groups.
	 */
	private void updateContextMenuItems() {
		JMenuItem renameItem = (JMenuItem) contextMenu.getComponent(0);
		JMenuItem deleteItem = (JMenuItem) contextMenu.getComponent(1);
		JMenuItem moveUpItem = (JMenuItem) contextMenu.getComponent(3);
		JMenuItem moveDownItem = (JMenuItem) contextMenu.getComponent(4);

		boolean isUnassignedGroup = groupName.equals(ScreenMarkerGroupsPlugin.UNASSIGNED_GROUP);
		boolean isImportedGroup = groupName.equals(ScreenMarkerGroupsPlugin.IMPORTED_GROUP);
		boolean isSpecialGroup = isUnassignedGroup || isImportedGroup;

		// Can only move non-special groups, and only if there's more than one group
		// total (implicitly > 2 if special groups exist)
		boolean canMove = !isSpecialGroup
				&& plugin.getMarkerGroups().size() > (isUnassignedGroup ? 1 : 0) + (isImportedGroup ? 1 : 0) + 1;

		renameItem.setEnabled(!isSpecialGroup);
		deleteItem.setEnabled(!isUnassignedGroup); // Allow deleting "Imported"
		moveUpItem.setEnabled(canMove);
		moveDownItem.setEnabled(canMove);
	}

	/**
	 * Creates and configures the right-click context menu for the group header.
	 * Includes options for renaming, deleting, and reordering the group.
	 *
	 * @return The configured JPopupMenu.
	 */
	private JPopupMenu setupContextMenu() {
		final JPopupMenu popupMenu = new JPopupMenu();

		final JMenuItem renameItem = new JMenuItem("Rename Group");
		renameItem.addActionListener(e -> {
			String newName = JOptionPane.showInputDialog(
					GroupHeaderPanel.this,
					"Enter new name for group '" + groupName + "':",
					"Rename Group",
					JOptionPane.PLAIN_MESSAGE);

			if (!com.google.common.base.Strings.isNullOrEmpty(newName)) {
				if (!plugin.renameGroup(groupName, newName)) {
					JOptionPane.showMessageDialog(
							GroupHeaderPanel.this,
							"Failed to rename group. New name may be invalid or already exist.",
							"Rename Group Error",
							JOptionPane.ERROR_MESSAGE);
				}
			}
		});

		final JMenuItem deleteItem = new JMenuItem("Delete Group");
		deleteItem.addActionListener(e -> plugin.deleteGroup(groupName));

		final JMenuItem moveUpItem = new JMenuItem("Move Up");
		moveUpItem.addActionListener(e -> plugin.moveGroupUp(groupName));

		final JMenuItem moveDownItem = new JMenuItem("Move Down");
		moveDownItem.addActionListener(e -> plugin.moveGroupDown(groupName));

		popupMenu.add(renameItem);
		popupMenu.add(deleteItem);
		popupMenu.addSeparator();
		popupMenu.add(moveUpItem);
		popupMenu.add(moveDownItem);

		return popupMenu;
	}

	/**
	 * Constructs a GroupHeaderPanel.
	 *
	 * @param plugin             The main plugin instance.
	 * @param groupName          The name of the group this header represents.
	 * @param initialVisibility  The initial visibility state of the group.
	 * @param initialExpansion   The initial expansion state of the group.
	 * @param onVisibilityChange Callback function invoked when visibility is
	 *                           toggled.
	 * @param onExpansionChange  Callback function invoked when expansion is
	 *                           toggled.
	 */
	GroupHeaderPanel(ScreenMarkerGroupsPlugin plugin, String groupName, boolean initialVisibility,
			boolean initialExpansion, Consumer<Boolean> onVisibilityChange, Consumer<Boolean> onExpansionChange) {
		this.plugin = plugin;
		this.groupName = groupName;
		this.isVisible = initialVisibility;
		this.isExpanded = initialExpansion;
		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARKER_GRAY_COLOR);

		Border padding = new EmptyBorder(4, 5, 4, 5);
		Border line = BorderFactory.createMatteBorder(0, 0, 1, 0, ColorScheme.DARK_GRAY_COLOR);
		setBorder(new CompoundBorder(padding, line));

		nameLabel = new JLabel(groupName);
		nameLabel.setFont(FontManager.getRunescapeBoldFont());
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setBorder(new EmptyBorder(0, 3, 0, 0));

		this.contextMenu = setupContextMenu();

		updateExpansionIcon();
		expansionLabel.setToolTipText(isExpanded ? "Collapse group" : "Expand group");
		expansionLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (SwingUtilities.isLeftMouseButton(e)) {
					isExpanded = !isExpanded;
					updateExpansionIcon();
					expansionLabel.setToolTipText(isExpanded ? "Collapse group" : "Expand group");
					if (onExpansionChange != null) {
						onExpansionChange.accept(isExpanded);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				expansionLabel.setIcon(isExpanded ? EXPANDED_HOVER_ICON : COLLAPSED_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				updateExpansionIcon();
			}
		});

		configureLabel.setIcon(CONFIGURE_ICON);
		configureLabel.setToolTipText("Configure group");
		configureLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (configureLabel.isEnabled() && SwingUtilities.isLeftMouseButton(e)) {
					updateContextMenuItems();
					contextMenu.show(configureLabel, e.getX(), e.getY());
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				configureLabel.setIcon(CONFIGURE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				configureLabel.setIcon(CONFIGURE_ICON);
			}
		});

		updateVisibilityIcon();
		visibilityLabel.setToolTipText(isVisible ? "Hide group markers" : "Show group markers");
		visibilityLabel.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (SwingUtilities.isLeftMouseButton(e)) {
					isVisible = !isVisible;
					updateVisibilityIcon();
					visibilityLabel.setToolTipText(isVisible ? "Hide group markers" : "Show group markers");
					if (onVisibilityChange != null) {
						onVisibilityChange.accept(isVisible);
					}
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				visibilityLabel.setIcon(isVisible ? VISIBLE_HOVER_ICON : INVISIBLE_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				updateVisibilityIcon();
			}
		});

		addMarkerButton.setIcon(ADD_MARKER_ICON);
		addMarkerButton.setToolTipText("Add new marker to this group");
		addMarkerButton.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
				if (SwingUtilities.isLeftMouseButton(e)) {
					plugin.enterCreationMode(groupName);
				}
			}

			@Override
			public void mouseEntered(MouseEvent e) {
				addMarkerButton.setIcon(ADD_MARKER_HOVER_ICON);
			}

			@Override
			public void mouseExited(MouseEvent e) {
				addMarkerButton.setIcon(ADD_MARKER_ICON);
			}
		});

		JPanel rightActions = new JPanel(new FlowLayout(FlowLayout.RIGHT, 3, 2));
		rightActions.setBackground(getBackground());
		rightActions.setBorder(new EmptyBorder(0, 0, 4, 2));
		rightActions.add(configureLabel);
		rightActions.add(visibilityLabel);
		rightActions.add(addMarkerButton);

		JPanel leftActions = new JPanel(new BorderLayout());
		leftActions.setBackground(getBackground());
		leftActions.setBorder(new EmptyBorder(2, 2, 4, 0));
		leftActions.add(expansionLabel, BorderLayout.WEST);
		leftActions.add(nameLabel, BorderLayout.CENTER);

		add(leftActions, BorderLayout.CENTER);
		add(rightActions, BorderLayout.EAST);
	}

	/**
	 * Enables or disables the interactive controls (expansion, configure,
	 * visibility, add) on the header panel. Updates icons to appear dimmed when
	 * disabled.
	 *
	 * @param enabled True to enable controls, false to disable.
	 */
	void setControlsEnabled(boolean enabled) {
		expansionLabel.setEnabled(enabled);
		configureLabel.setEnabled(enabled);
		visibilityLabel.setEnabled(enabled);
		addMarkerButton.setEnabled(enabled);

		if (enabled) {
			updateExpansionIcon();
			expansionLabel.setToolTipText(isExpanded ? "Collapse group" : "Expand group");
			configureLabel.setIcon(CONFIGURE_ICON);
			configureLabel.setToolTipText("Configure group");
			updateVisibilityIcon();
			visibilityLabel.setToolTipText(isVisible ? "Hide group markers" : "Show group markers");
			addMarkerButton.setIcon(ADD_MARKER_ICON);
			addMarkerButton.setToolTipText("Add new marker to this group");
		} else {
			expansionLabel.setIcon(isExpanded ? new ImageIcon(ImageUtil.alphaOffset(EXPANDED_ICON.getImage(), 0.5f))
					: new ImageIcon(ImageUtil.alphaOffset(COLLAPSED_ICON.getImage(), 0.5f)));
			expansionLabel.setToolTipText(null);
			configureLabel.setIcon(new ImageIcon(ImageUtil.alphaOffset(CONFIGURE_ICON.getImage(), 0.5f)));
			configureLabel.setToolTipText(null);
			visibilityLabel.setIcon(isVisible ? new ImageIcon(ImageUtil.alphaOffset(VISIBLE_ICON.getImage(), 0.5f))
					: new ImageIcon(ImageUtil.alphaOffset(INVISIBLE_ICON.getImage(), 0.5f)));
			visibilityLabel.setToolTipText(null);
			addMarkerButton.setIcon(new ImageIcon(ImageUtil.alphaOffset(ADD_MARKER_ICON.getImage(), 0.5f)));
			addMarkerButton.setToolTipText(null);
		}
	}

	/**
	 * Updates the visibility icon (eye open/closed) based on the current
	 * `isVisible` state.
	 */
	private void updateVisibilityIcon() {
		visibilityLabel.setIcon(isVisible ? VISIBLE_ICON : INVISIBLE_ICON);
	}

	/**
	 * Updates the expansion icon (arrow down/right) based on the current
	 * `isExpanded` state.
	 */
	private void updateExpansionIcon() {
		expansionLabel.setIcon(isExpanded ? EXPANDED_ICON : COLLAPSED_ICON);
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Stroke;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;

@Getter(AccessLevel.PACKAGE)
@Setter(AccessLevel.PACKAGE)
/**
 * Represents the renderable entity for a screen marker.
 * This class handles the actual drawing of the marker's border, fill, and label
 * based on the provided properties.
 */
class ScreenMarkerRenderable implements RenderableEntity {
	private Dimension size;
	private int borderThickness;
	private Color color;
	private Color fill;
	private Stroke stroke;
	private String label;
	private LabelPosition labelPosition; // Added field for label position

	/**
	 * Renders the screen marker onto the provided graphics context.
	 * Draws the fill, border, and label according to the set properties.
	 *
	 * @param graphics The graphics context to draw on.
	 * @return The dimensions of the rendered marker.
	 */
	@Override
	public Dimension render(Graphics2D graphics) {
		int thickness = borderThickness;
		int width = size.width;
		int height = size.height;

		graphics.setColor(fill);
		graphics.fillRect(thickness, thickness, width - thickness * 2, height - thickness * 2);

		int offset = thickness / 2;
		graphics.setColor(color);
		graphics.setStroke(stroke);
		graphics.drawRect(offset, offset, width - thickness, height - thickness);

		if (!label.isEmpty()) {
			if (labelPosition == LabelPosition.ABOVE) {
				graphics.drawString(label, 0, 0);
			} else {
				graphics.drawString(label, thickness, thickness + graphics.getFontMetrics().getAscent());
			}
		}

		return size;
	}
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * Copyright (c) 2018, Kamiel, <https://github.com/Kamielvf>
 * Copyright (c) 2018, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import com.google.common.base.Strings;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import javax.inject.Inject;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.components.colorpicker.ColorPickerManager;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import screenmarkergroups.ui.ScreenMarkerGroupsPluginPanel;
import screenmarkergroups.ui.ScreenMarkerGroupsCreationPanel;

@PluginDescriptor(name = "Screen Marker Groups", description = "Enable drawing of screen markers on top of the client, organized into groups", tags = {
		"boxes", "overlay", "panel", "group", "organize" })
public class ScreenMarkerGroupsPlugin extends Plugin {
	private static final String OVERLAY_CONFIG_GROUP = "runelite";

	/**
	 * Provides the configuration object for the plugin.
	 *
	 * @param configManager The RuneLite configuration manager.
	 * @return The configuration object.
	 */
	@Provides
	ScreenMarkerGroupsConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(ScreenMarkerGroupsConfig.class);
	}

	private static final String PLUGIN_NAME = "Screen Marker Groups";
	private static final String CONFIG_GROUP = "screenmarkergroups";
	private static final String CONFIG_KEY_MARKERS = "markerGroups";
	private static final String CONFIG_KEY_ORDER = "groupOrder";
	private static final String CONFIG_KEY_VISIBILITY = "groupVisibility";
	private static final String CONFIG_KEY_EXPANSION = "groupExpansion";
	private static final String ICON_FILE = "panel_icon.png";
	private static final String DEFAULT_MARKER_NAME = "Marker";
	public static final Dimension DEFAULT_SIZE = new Dimension(2, 2);
	public static final String UNASSIGNED_GROUP = "Unassigned";
	public static final String IMPORTED_GROUP = "Imported";

	@Getter
	private final Map<String, List<ScreenMarkerOverlay>> markerGroups = new ConcurrentHashMap<>();

	@Getter
	private final List<String> groupOrderList = new ArrayList<>();

	private final Map<String, Boolean> groupVisibilityStates = new ConcurrentHashMap<>();
	private final Map<String, Boolean> groupExpansionStates = new ConcurrentHashMap<>();

	@Inject
	private ConfigManager configManager;

	@Inject
	@Getter
	private ScreenMarkerGroupsConfig config;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	@Getter
	private OverlayManager overlayManager;

	@Inject
	@Getter
	private ScreenMarkerCreationOverlay overlay;

	@Inject
	private Gson gson;

	@Getter
	@Inject
	private ColorPickerManager colorPickerManager;

	@Inject
	private ScreenMarkerWidgetHighlightOverlay widgetHighlight;

	private ScreenMarkerMouseListener mouseListener;
	@Getter
	private ScreenMarkerGroupsPluginPanel pluginPanel;
	private NavigationButton navigationButton;

	@Getter(AccessLevel.PACKAGE)
	private ScreenMarker currentMarker;

	@Getter
	@Setter
	private boolean creatingScreenMarker = false;

	@Getter
	@Setter
	private boolean drawingScreenMarker = false;

	@Getter
	@Setter
	private Rectangle selectedWidgetBounds = null;
	@Getter(AccessLevel.PACKAGE)
	@Setter(AccessLevel.PACKAGE)
	private Point startLocation = null;
	@Getter
	private String targetGroupNameForCreation = null;

	/**
	 * Called when the plugin is started. Loads configuration, sets up UI,
	 * adds overlays, and registers listeners.
	 *
	 * @throws Exception If an error occurs during startup.
	 */
	@Override
	protected void startUp() throws Exception {
		overlayManager.add(overlay);
		overlayManager.add(widgetHighlight);
		loadGroupsConfig();
		// Add overlays respecting group visibility from loaded config
		markerGroups.forEach((groupName, overlays) -> {
			if (isGroupVisible(groupName)) {
				overlays.forEach(overlayManager::add);
			}
		});
		pluginPanel = new ScreenMarkerGroupsPluginPanel(this);
		pluginPanel.rebuild();
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/" + ICON_FILE);
		navigationButton = NavigationButton.builder()
				.tooltip(PLUGIN_NAME)
				.icon(icon)
				.priority(5)
				.panel(pluginPanel)
				.build();
		clientToolbar.addNavigation(navigationButton);
		mouseListener = new ScreenMarkerMouseListener(this);
	}

	/**
	 * Called when the plugin is shut down. Removes overlays, clears state,
	 * removes UI components, and unregisters listeners.
	 *
	 * @throws Exception If an error occurs during shutdown.
	 */
	@Override
	protected void shutDown() throws Exception {
		overlayManager.remove(overlay);
		overlayManager.remove(widgetHighlight);
		overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
		markerGroups.clear();
		groupOrderList.clear();
		groupVisibilityStates.clear();
		groupExpansionStates.clear();
		clientToolbar.removeNavigation(navigationButton);
		setMouseListenerEnabled(false);
		creatingScreenMarker = false;
		drawingScreenMarker = false;
		pluginPanel = null;
		currentMarker = null;
		mouseListener = null;
		navigationButton = null;
		selectedWidgetBounds = null;
	}

	/**
	 * Handles the RuneLite ProfileChanged event. Clears current state and reloads
	 * configuration for the new profile. Ensures overlays and UI reflect the
	 * profile's settings.
	 *
	 * @param profileChanged The event object associated with the profile change.
	 */
	@Subscribe
	public void onProfileChanged(ProfileChanged profileChanged) {
		overlayManager.removeIf(ScreenMarkerOverlay.class::isInstance);
		markerGroups.clear();
		groupOrderList.clear();
		groupVisibilityStates.clear();
		groupExpansionStates.clear();
		loadGroupsConfig();
		// Re-add overlays respecting group visibility
		markerGroups.forEach((groupName, overlays) -> {
			if (isGroupVisible(groupName)) {
				overlays.forEach(overlayManager::add);
			}
		});
		if (pluginPanel != null) {
			SwingUtilities.invokeLater(pluginPanel::rebuild);
		}
	}

	/**
	 * Registers or unregisters the mouse listener responsible for handling
	 * screen marker creation clicks and drags.
	 *
	 * @param enabled True to register the listener, false to unregister.
	 */
	public void setMouseListenerEnabled(boolean enabled) {
		if (enabled) {
			mouseManager.registerMouseListener(mouseListener);
		} else {
			mouseManager.unregisterMouseListener(mouseListener);
		}
	}

	/**
	 * Enters the marker creation mode, preparing the plugin and UI.
	 * Called from the UI (+ button).
	 *
	 * @param groupName The target group for the new marker.
	 */
	public void enterCreationMode(String groupName) {
		this.targetGroupNameForCreation = markerGroups.containsKey(groupName) ? groupName : UNASSIGNED_GROUP;
		this.creatingScreenMarker = true;
		this.setMouseListenerEnabled(true);
		this.currentMarker = null;
		this.startLocation = null;
		this.drawingScreenMarker = false;
		this.selectedWidgetBounds = null;

		overlay.setPreferredLocation(null);
		overlay.setPreferredSize(null);

		if (pluginPanel != null) {
			pluginPanel.setCreation(true);
		}
	}

	/**
	 * Prepares a new marker object and sets the initial bounds for the creation
	 * overlay.
	 * Called by the mouse listener on the first click/drag or when clicking a
	 * widget.
	 *
	 * @param location The initial location for the marker.
	 * @param size     The initial size for the marker.
	 */
	public void startCreation(Point location, Dimension size) {
		if (currentMarker != null || location == null) {
			return;
		}

		long nextMarkerId = findMaxMarkerId() + 1;

		// Determine the target group name, defaulting to UNASSIGNED_GROUP if null
		String targetGroup = targetGroupNameForCreation != null ? targetGroupNameForCreation : UNASSIGNED_GROUP;
		// Calculate the next marker number within the target group
		int nextMarkerNumberInGroup = markerGroups.getOrDefault(targetGroup, Collections.emptyList()).size() + 1;

		currentMarker = new ScreenMarker(
				nextMarkerId,
				DEFAULT_MARKER_NAME + " " + nextMarkerNumberInGroup, // Use group-specific count for default name
				ScreenMarkerGroupsPluginPanel.SELECTED_BORDER_THICKNESS,
				ScreenMarkerGroupsPluginPanel.SELECTED_COLOR,
				ScreenMarkerGroupsPluginPanel.SELECTED_FILL_COLOR,
				true,
				false,
				null);
		startLocation = location;
		overlay.setPreferredLocation(location);
		overlay.setPreferredSize(size != null ? size : DEFAULT_SIZE);
		drawingScreenMarker = true;
	}

	/**
	 * Finalizes the screen marker creation process. If not aborted, it creates
	 * the marker overlay, adds it to the target group, saves the configuration,
	 * and updates the UI. Resets the creation state regardless of outcome.
	 *
	 * @param aborted True if the creation process was cancelled, false otherwise.
	 */
	public void finishCreation(boolean aborted) {
		ScreenMarker marker = currentMarker;
		String targetGroup = targetGroupNameForCreation != null ? targetGroupNameForCreation : UNASSIGNED_GROUP;
		Rectangle overlayBounds = overlay.getBounds();

		if (!aborted && marker != null && overlayBounds != null && overlayBounds.width > 0
				&& overlayBounds.height > 0) {
			final ScreenMarkerOverlay screenMarkerOverlay = new ScreenMarkerOverlay(marker, this);
			screenMarkerOverlay.setPreferredLocation(overlayBounds.getLocation());
			screenMarkerOverlay.setPreferredSize(overlayBounds.getSize());

			List<ScreenMarkerOverlay> groupList = markerGroups.computeIfAbsent(targetGroup, k -> new ArrayList<>());
			groupList.add(screenMarkerOverlay);

			if (!groupOrderList.contains(targetGroup)) {
				int insertIndex = calculateGroupInsertIndex();
				if (!targetGroup.equals(UNASSIGNED_GROUP) && !targetGroup.equals(IMPORTED_GROUP)) {
					groupOrderList.add(insertIndex, targetGroup);
				} else if (!groupOrderList.contains(targetGroup)) { // Add Unassigned/Imported if not present at all
					groupOrderList.add(targetGroup); // Add to end if somehow missing
				}
				// Re-ensure Unassigned/Imported are at the end if they were just added
				ensureSpecialGroupsOrder();
			}
			overlayManager.saveOverlay(screenMarkerOverlay);
			if (isGroupVisible(targetGroup)) {
				overlayManager.add(screenMarkerOverlay);
			}
			updateGroupsConfig();
		} else {
			aborted = true;
		}

		creatingScreenMarker = false;
		drawingScreenMarker = false;
		selectedWidgetBounds = null;
		startLocation = null;
		currentMarker = null;
		targetGroupNameForCreation = null;
		setMouseListenerEnabled(false);

		if (pluginPanel != null) {
			pluginPanel.setCreation(false);
			if (!aborted) {
				SwingUtilities.invokeLater(pluginPanel::rebuild);
			}
		}
	}

	/**
	 * Called when the user confirms the marker creation settings in the UI panel.
	 * Currently unlocks the confirmation button in the specific group's creation
	 * panel.
	 */
	public void completeSelection() {
		if (pluginPanel != null && targetGroupNameForCreation != null) {
			ScreenMarkerGroupsCreationPanel creationPanel = pluginPanel.getCreationPanelsMap()
					.get(targetGroupNameForCreation);
			if (creationPanel != null) {
				creationPanel.unlockConfirm();
			}
		}
	}

	/**
	 * Deletes a specific screen marker overlay from its group, removes it from
	 * the overlay manager, resets its configuration, saves the changes, and
	 * updates the UI panel.
	 *
	 * @param markerToDelete The overlay instance to delete.
	 */
	public void deleteMarker(final ScreenMarkerOverlay markerToDelete) {
		boolean removed = false;
		for (List<ScreenMarkerOverlay> groupList : markerGroups.values()) {
			if (groupList.remove(markerToDelete)) {
				removed = true;
				break;
			}
		}
		if (removed) {
			overlayManager.remove(markerToDelete);
			overlayManager.resetOverlay(markerToDelete);
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
		}
	}

	/**
	 * Handles resizing of the marker currently being created based on mouse drag.
	 * If creation hasn't started, it initiates it. Otherwise, it updates the
	 * bounds of the creation overlay.
	 *
	 * @param point The current mouse cursor position.
	 */
	void resizeMarker(Point point) {
		if (startLocation == null) {
			startCreation(point, DEFAULT_SIZE);
			return;
		}
		drawingScreenMarker = true;
		Rectangle bounds = new Rectangle(startLocation);
		bounds.add(point);
		overlay.setPreferredLocation(bounds.getLocation());
		overlay.setPreferredSize(bounds.getSize());
	}

	/**
	 * Saves the current state of all marker groups, their order, visibility,
	 * and expansion states to the RuneLite configuration. Unsets configuration
	 * keys if the corresponding data structures are empty.
	 */
	public void updateGroupsConfig() {
		boolean shouldSaveMarkers = !markerGroups.isEmpty();
		boolean shouldSaveOrder = !groupOrderList.isEmpty();

		if (!shouldSaveMarkers) {
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_MARKERS);
		} else {
			Map<String, List<ScreenMarker>> groupsToSave = new HashMap<>();
			markerGroups.forEach((groupName, overlayList) -> {
				List<ScreenMarker> markerList = overlayList.stream()
						.map(ScreenMarkerOverlay::getMarker)
						.collect(Collectors.toList());
				groupsToSave.put(groupName, markerList);
			});
			final String markersJson = gson.toJson(groupsToSave);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_MARKERS, markersJson);
		}

		if (!shouldSaveOrder) {
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_ORDER);
		} else {
			// Filter order list to only contain existing groups before saving
			List<String> orderToSave = groupOrderList.stream()
					.filter(markerGroups::containsKey)
					.collect(Collectors.toList());
			if (orderToSave.isEmpty()) {
				configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_ORDER);
			} else {
				final String orderJson = gson.toJson(orderToSave);
				configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_ORDER, orderJson);
			}
		}

		updateVisibilityConfig();
		updateExpansionConfig();
	}

	/**
	 * Saves the current group visibility states to the config manager.
	 */
	private void updateVisibilityConfig() {
		// Clean up visibility states for groups that no longer exist
		groupVisibilityStates.keySet().retainAll(markerGroups.keySet());

		if (groupVisibilityStates.isEmpty()) {
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_VISIBILITY);
		} else {
			final String visibilityJson = gson.toJson(groupVisibilityStates);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_VISIBILITY, visibilityJson);
		}
	}

	/**
	 * Saves the current group expansion states to the config manager.
	 */
	private void updateExpansionConfig() {
		// Clean up expansion states for groups that no longer exist
		groupExpansionStates.keySet().retainAll(markerGroups.keySet());

		if (groupExpansionStates.isEmpty()) {
			configManager.unsetConfiguration(CONFIG_GROUP, CONFIG_KEY_EXPANSION);
		} else {
			final String expansionJson = gson.toJson(groupExpansionStates);
			configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_EXPANSION, expansionJson);
		}
	}

	private void loadGroupsConfig() {
		markerGroups.clear();
		groupOrderList.clear();
		groupVisibilityStates.clear();
		groupExpansionStates.clear();

		final String markersJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_MARKERS);
		if (!Strings.isNullOrEmpty(markersJson)) {
			try {
				final Map<String, List<ScreenMarker>> loadedGroups = gson.fromJson(markersJson,
						new TypeToken<HashMap<String, List<ScreenMarker>>>() {
						}.getType());

				if (loadedGroups != null) {
					loadedGroups.forEach((groupName, markerList) -> {
						List<ScreenMarkerOverlay> overlayList = markerList.stream()
								.filter(Objects::nonNull)
								.map(marker -> new ScreenMarkerOverlay(marker, this))
								.collect(Collectors.toList());
						markerGroups.put(groupName, new ArrayList<>(overlayList));
					});
				}
			} catch (Exception e) {
				markerGroups.clear();
			}
		}
		markerGroups.computeIfAbsent(UNASSIGNED_GROUP, k -> new ArrayList<>());

		final String orderJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_ORDER);
		List<String> loadedOrder = null;
		if (!Strings.isNullOrEmpty(orderJson)) {
			try {
				loadedOrder = gson.fromJson(orderJson, new TypeToken<ArrayList<String>>() {
				}.getType());
			} catch (Exception e) {
				loadedOrder = null;
			}
		}

		// Add loaded, valid groups to the order list
		if (loadedOrder != null) {
			groupOrderList.addAll(loadedOrder.stream()
					.filter(markerGroups::containsKey) // Only add groups that actually exist
					.collect(Collectors.toList()));
		}

		// Find groups present in data but missing from the loaded order
		List<String> groupsToAdd = markerGroups.keySet().stream()
				.filter(groupName -> !groupOrderList.contains(groupName))
				.filter(groupName -> !groupName.equals(UNASSIGNED_GROUP) && !groupName.equals(IMPORTED_GROUP))
				.sorted(String.CASE_INSENSITIVE_ORDER)
				.collect(Collectors.toList());

		// Add the missing normal groups at the calculated insertion point
		if (!groupsToAdd.isEmpty()) {
			int insertIndex = calculateGroupInsertIndex();
			groupOrderList.addAll(insertIndex, groupsToAdd);
		}

		// Ensure Unassigned and Imported groups are present and at the end, in the
		// correct order
		ensureSpecialGroupsOrder();

		// Clean up any potential stale entries in groupOrderList
		groupOrderList.retainAll(markerGroups.keySet());

		final String visibilityJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_VISIBILITY);
		if (!Strings.isNullOrEmpty(visibilityJson)) {
			try {
				final Map<String, Boolean> loadedVisibility = gson.fromJson(visibilityJson,
						new TypeToken<HashMap<String, Boolean>>() {
						}.getType());

				if (loadedVisibility != null) {
					// Only load states for groups that actually exist
					loadedVisibility.forEach((groupName, isVisible) -> {
						if (markerGroups.containsKey(groupName)) {
							groupVisibilityStates.put(groupName, isVisible);
						}
					});
				}
			} catch (Exception e) {
				groupVisibilityStates.clear();
			}
		}

		final String expansionJson = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_EXPANSION);
		if (!Strings.isNullOrEmpty(expansionJson)) {
			try {
				final Map<String, Boolean> loadedExpansion = gson.fromJson(expansionJson,
						new TypeToken<HashMap<String, Boolean>>() {
						}.getType());

				if (loadedExpansion != null) {
					// Only load states for groups that actually exist
					loadedExpansion.forEach((groupName, isExpanded) -> {
						if (markerGroups.containsKey(groupName)) {
							groupExpansionStates.put(groupName, isExpanded);
						}
					});
				}
			} catch (Exception e) {
				groupExpansionStates.clear();
			}
		}
	}

	/**
	 * Checks if a group is currently set to be visible.
	 * Defaults to true if the group has no specific state saved.
	 *
	 * @param groupName The name of the group.
	 * @return True if the group is visible, false otherwise.
	 */
	public boolean isGroupVisible(String groupName) {
		return groupVisibilityStates.getOrDefault(groupName, true);
	}

	/**
	 * Sets the visibility state for a specific group and saves the configuration.
	 * Also updates the OverlayManager to add/remove overlays accordingly.
	 *
	 * @param groupName The name of the group.
	 * @param isVisible The desired visibility state.
	 */
	public void setGroupVisibility(String groupName, boolean isVisible) {
		if (!markerGroups.containsKey(groupName)) {
			return;
		}

		boolean previousState = isGroupVisible(groupName);
		groupVisibilityStates.put(groupName, isVisible);
		updateVisibilityConfig();

		if (previousState != isVisible) {
			List<ScreenMarkerOverlay> groupOverlays = markerGroups.get(groupName);
			if (groupOverlays != null) {
				if (isVisible) {
					groupOverlays.stream()
							.filter(overlay -> overlay.getMarker().isVisible())
							.forEach(overlayManager::add);
				} else {
					groupOverlays.forEach(overlayManager::remove);
				}
			}
		}
	}

	/**
	 * Checks if a group is currently set to be expanded.
	 * Defaults to true if the group has no specific state saved.
	 *
	 * @param groupName The name of the group.
	 * @return True if the group is expanded, false otherwise.
	 */
	public boolean isGroupExpanded(String groupName) {
		return groupExpansionStates.getOrDefault(groupName, true);
	}

	/**
	 * Sets the expansion state for a specific group and saves the configuration.
	 *
	 * @param groupName  The name of the group.
	 * @param isExpanded The desired expansion state.
	 */
	public void setGroupExpansion(String groupName, boolean isExpanded) {
		if (!markerGroups.containsKey(groupName)) {
			return;
		}
		groupExpansionStates.put(groupName, isExpanded);
		updateExpansionConfig();
	}

	/**
	 * Adds a new, empty group with the given name. The group defaults to visible
	 * and expanded. Updates configuration and rebuilds the UI panel.
	 *
	 * @param name The name for the new group. Must not be null, empty, or already
	 *             exist.
	 * @return True if the group was added successfully, false otherwise.
	 */
	public boolean addGroup(String name) {
		if (Strings.isNullOrEmpty(name) || markerGroups.containsKey(name)) {
			return false;
		}
		markerGroups.put(name, new ArrayList<>());
		groupVisibilityStates.put(name, true);
		groupExpansionStates.put(name, true);

		// Add the new group name before Unassigned/Imported
		int insertIndex = calculateGroupInsertIndex();
		groupOrderList.add(insertIndex, name);

		updateGroupsConfig();
		SwingUtilities.invokeLater(pluginPanel::rebuild);
		return true;
	}

	/**
	 * Deletes a group and handles the markers within it based on user choice
	 * (delete markers, move to Unassigned). Cannot delete the "Unassigned" group.
	 * Updates configuration and rebuilds the UI panel.
	 *
	 * @param groupName The name of the group to delete.
	 */
	public void deleteGroup(String groupName) {
		if (groupName.equals(UNASSIGNED_GROUP)) {
			JOptionPane.showMessageDialog(pluginPanel,
					"Cannot delete the special '" + UNASSIGNED_GROUP + "' group.",
					"Delete Group Error", JOptionPane.ERROR_MESSAGE);
			return;
		}
		List<ScreenMarkerOverlay> markersInGroup = markerGroups.get(groupName);
		if (markersInGroup == null)
			return;

		String message = "Delete group '" + groupName + "'?";
		if (!markersInGroup.isEmpty()) {
			message += "\nWhat should happen to the " + markersInGroup.size() + " marker(s) inside?";
		}
		String[] options = markersInGroup.isEmpty() ? new String[] { "Delete Group", "Cancel" }
				: new String[] { "Delete Markers", "Move to Unassigned", "Cancel" };
		int choice = JOptionPane.showOptionDialog(pluginPanel, message, "Confirm Group Deletion",
				JOptionPane.YES_NO_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE, null, options,
				options[options.length - 1]);

		if (choice == JOptionPane.CANCEL_OPTION || choice == JOptionPane.CLOSED_OPTION)
			return;

		if (choice == 0) { // Delete Markers
			markersInGroup.forEach(overlayManager::remove);
			markersInGroup.forEach(overlayManager::resetOverlay);
		} else if (choice == 1) { // Move to Unassigned
			List<ScreenMarkerOverlay> unassignedList = markerGroups.computeIfAbsent(UNASSIGNED_GROUP,
					k -> new ArrayList<>());
			unassignedList.addAll(markersInGroup);
			if (!groupOrderList.contains(UNASSIGNED_GROUP)) {
				groupOrderList.add(UNASSIGNED_GROUP); // Add if not present
				ensureSpecialGroupsOrder(); // Ensure it's placed correctly
			}
		}

		markerGroups.remove(groupName);
		groupOrderList.remove(groupName);
		groupVisibilityStates.remove(groupName);
		groupExpansionStates.remove(groupName);
		updateGroupsConfig();
		SwingUtilities.invokeLater(pluginPanel::rebuild);
	}

	/**
	 * Renames an existing group. Cannot rename to "Unassigned", "Imported", or an
	 * already existing group name. Cannot rename the "Unassigned" or "Imported"
	 * groups themselves. Preserves the group's markers, visibility, and expansion
	 * state. Updates configuration and rebuilds the UI panel.
	 *
	 * @param oldName The current name of the group.
	 * @param newName The desired new name for the group.
	 * @return True if the group was renamed successfully, false otherwise.
	 */
	public boolean renameGroup(String oldName, String newName) {
		if (Strings.isNullOrEmpty(newName) || newName.equals(UNASSIGNED_GROUP) || newName.equals(IMPORTED_GROUP)
				|| markerGroups.containsKey(newName)) {
			return false;
		}
		if (oldName.equals(UNASSIGNED_GROUP) || oldName.equals(IMPORTED_GROUP) || !markerGroups.containsKey(oldName)) {
			return false;
		}

		List<ScreenMarkerOverlay> markers = markerGroups.remove(oldName);
		Boolean visibility = groupVisibilityStates.remove(oldName);
		Boolean expansion = groupExpansionStates.remove(oldName);

		if (markers != null) {
			markerGroups.put(newName, markers);
			groupVisibilityStates.put(newName, visibility != null ? visibility : true);
			groupExpansionStates.put(newName, expansion != null ? expansion : true);

			int index = groupOrderList.indexOf(oldName);
			if (index != -1) {
				groupOrderList.set(index, newName);
			} else {
				// If somehow not in order list, add it before special groups
				int insertIndex = calculateGroupInsertIndex();
				groupOrderList.add(insertIndex, newName);
			}
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
			return true;
		}
		return false;
	}

	/**
	 * Moves a group one position up in the display order, unless it's already
	 * at the top or is a special group ("Unassigned", "Imported"). Updates
	 * configuration and rebuilds the UI panel.
	 *
	 * @param groupName The name of the group to move up.
	 */
	public void moveGroupUp(String groupName) {
		int currentIndex = groupOrderList.indexOf(groupName);
		// Cannot move up if first, or if it's a special group
		if (currentIndex <= 0 || groupName.equals(UNASSIGNED_GROUP) || groupName.equals(IMPORTED_GROUP)) {
			return;
		}
		Collections.swap(groupOrderList, currentIndex, currentIndex - 1);
		updateGroupsConfig();
		SwingUtilities.invokeLater(pluginPanel::rebuild);
	}

	/**
	 * Moves a group one position down in the display order, unless it's already
	 * at the bottom of the regular groups or is a special group ("Unassigned",
	 * "Imported"). Updates configuration and rebuilds the UI panel.
	 *
	 * @param groupName The name of the group to move down.
	 */
	public void moveGroupDown(String groupName) {
		int currentIndex = groupOrderList.indexOf(groupName);

		// Calculate the last index allowed for a non-special group to move down
		int lastMovableIndex = calculateGroupInsertIndex() - 1; // Index before the first special group

		// Cannot move down if already at the last movable position, or if it's a
		// special group
		if (currentIndex < 0 || currentIndex >= lastMovableIndex || groupName.equals(UNASSIGNED_GROUP)
				|| groupName.equals(IMPORTED_GROUP)) {
			return;
		}

		Collections.swap(groupOrderList, currentIndex, currentIndex + 1);
		updateGroupsConfig();
		SwingUtilities.invokeLater(pluginPanel::rebuild);
	}

	/**
	 * Finds the name of the group that contains the given screen marker overlay.
	 *
	 * @param markerOverlay The overlay to find the group for.
	 * @return The name of the group containing the overlay, or null if not found.
	 */
	public String findGroupForMarker(ScreenMarkerOverlay markerOverlay) {
		for (Map.Entry<String, List<ScreenMarkerOverlay>> entry : markerGroups.entrySet()) {
			if (entry.getValue().contains(markerOverlay)) {
				return entry.getKey();
			}
		}
		return null;
	}

	/**
	 * Moves a marker one position up within its current group's list. Updates
	 * configuration and rebuilds the UI panel.
	 *
	 * @param markerOverlay The overlay of the marker to move up.
	 */
	public void moveMarkerUp(ScreenMarkerOverlay markerOverlay) {
		String groupName = findGroupForMarker(markerOverlay);
		if (groupName == null)
			return;
		List<ScreenMarkerOverlay> groupList = markerGroups.get(groupName);
		int currentIndex = groupList.indexOf(markerOverlay);
		if (currentIndex > 0) {
			Collections.swap(groupList, currentIndex, currentIndex - 1);
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
		}
	}

	/**
	 * Moves a marker one position down within its current group's list. Updates
	 * configuration and rebuilds the UI panel.
	 *
	 * @param markerOverlay The overlay of the marker to move down.
	 */
	public void moveMarkerDown(ScreenMarkerOverlay markerOverlay) {
		String groupName = findGroupForMarker(markerOverlay);
		if (groupName == null)
			return;
		List<ScreenMarkerOverlay> groupList = markerGroups.get(groupName);
		int currentIndex = groupList.indexOf(markerOverlay);
		if (currentIndex >= 0 && currentIndex < groupList.size() - 1) {
			Collections.swap(groupList, currentIndex, currentIndex + 1);
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
		}
	}

	/**
	 * Moves a marker from its current group to a different target group. Updates
	 * configuration, overlay visibility based on the target group, and rebuilds
	 * the UI panel.
	 *
	 * @param markerOverlay   The overlay of the marker to move.
	 * @param targetGroupName The name of the destination group.
	 */
	public void moveMarkerToGroup(ScreenMarkerOverlay markerOverlay, String targetGroupName) {
		String sourceGroupName = findGroupForMarker(markerOverlay);
		if (sourceGroupName == null || sourceGroupName.equals(targetGroupName)
				|| !markerGroups.containsKey(targetGroupName)) {
			return;
		}
		List<ScreenMarkerOverlay> sourceList = markerGroups.get(sourceGroupName);
		List<ScreenMarkerOverlay> targetList = markerGroups.computeIfAbsent(targetGroupName, k -> new ArrayList<>());
		if (sourceList.remove(markerOverlay)) {
			targetList.add(markerOverlay);
			// Update overlay manager based on target group visibility
			if (!isGroupVisible(targetGroupName)) {
				overlayManager.remove(markerOverlay);
			} else if (markerOverlay.getMarker().isVisible()) { // OverlayManager.add is idempotent
				overlayManager.add(markerOverlay);
			}
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
		}
	}

	/**
	 * Handles RuneLite ConfigChanged events specific to this plugin's group.
	 * Currently used to detect clicks on the "Import Screen Markers" trigger.
	 *
	 * @param event The configuration change event.
	 */
	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		if (event.getKey().equals("importTrigger")) {
			if (Boolean.parseBoolean(event.getNewValue())) {
				SwingUtilities.invokeLater(() -> {
					configManager.setConfiguration(CONFIG_GROUP, "importTrigger", false);
					importScreenMarkers();
				});
			}
		}
	}

	/**
	 * Imports screen markers from the original RuneLite Screen Markers plugin.
	 * Reads the configuration from the "screenmarkers" group and adds them
	 * to the "Imported" group in this plugin. Shows dialogs for success,
	 * failure, or if no markers were found/imported.
	 */
	public void importScreenMarkers() {
		String originalMarkersJson = configManager.getConfiguration("screenmarkers", "markers");
		if (Strings.isNullOrEmpty(originalMarkersJson)) {
			JOptionPane.showMessageDialog(pluginPanel,
					"No markers found in the original Screen Markers plugin configuration.",
					"Import Failed", JOptionPane.INFORMATION_MESSAGE);
			return;
		}
		List<ScreenMarker> loadedMarkers;
		try {
			loadedMarkers = gson.fromJson(originalMarkersJson, new TypeToken<ArrayList<ScreenMarker>>() {
			}.getType());
		} catch (Exception e) {
			// Error logged during development, removed for production cleanup
			JOptionPane.showMessageDialog(pluginPanel,
					"Failed to parse markers from the original plugin.",
					"Import Error", JOptionPane.ERROR_MESSAGE);
			return;
		}
		if (loadedMarkers == null || loadedMarkers.isEmpty()) {
			JOptionPane.showMessageDialog(pluginPanel,
					"No valid markers found to import.",
					"Import Failed", JOptionPane.INFORMATION_MESSAGE);
			return;
		}
		List<ScreenMarkerOverlay> importedGroupList = markerGroups.computeIfAbsent(IMPORTED_GROUP,
				k -> new ArrayList<>());
		if (!groupOrderList.contains(IMPORTED_GROUP)) {
			groupOrderList.add(IMPORTED_GROUP); // Add if not present
			ensureSpecialGroupsOrder(); // Ensure it's placed correctly
		}
		int importedCount = 0;
		long maxId = findMaxMarkerId();

		for (ScreenMarker markerData : loadedMarkers) {
			if (markerData == null) {
				continue;
			}

			final long originalMarkerId = markerData.getId();
			boolean alreadyImported = importedGroupList.stream()
					.map(ScreenMarkerOverlay::getMarker)
					.filter(m -> m.getImportedId() != null)
					.anyMatch(existingMarker -> originalMarkerId == existingMarker.getImportedId());

			if (alreadyImported) {
				continue;
			}

			// Apply defaults for potentially missing fields from older plugin versions
			if (markerData.getColor() == null) {
				markerData.setColor(ScreenMarkerGroupsPluginPanel.DEFAULT_BORDER_COLOR);
			}
			if (markerData.getFill() == null) {
				markerData.setFill(ScreenMarkerGroupsPluginPanel.DEFAULT_FILL_COLOR);
			}
			if (markerData.getBorderThickness() <= 0) {
				markerData.setBorderThickness(ScreenMarkerGroupsPluginPanel.DEFAULT_BORDER_THICKNESS);
			}

			// Generate a new unique ID
			long newId = Math.max(Instant.now().toEpochMilli(), maxId + 1);
			maxId = newId; // Update maxId for the next iteration

			// Create a new marker object with the new ID and copied properties
			ScreenMarker newMarker = new ScreenMarker(
					newId,
					markerData.getName(),
					markerData.getBorderThickness(),
					markerData.getColor(),
					markerData.getFill(),
					markerData.isVisible(),
					markerData.isLabelled(),
					null);
			newMarker.setImportedId(originalMarkerId); // Store the original ID

			// Create the overlay for the new marker
			ScreenMarkerOverlay newOverlay = new ScreenMarkerOverlay(newMarker, this);

			// Try to read original position and size using original ID
			Point originalLocation = parsePoint(
					configManager.getConfiguration(OVERLAY_CONFIG_GROUP,
							"marker" + originalMarkerId + "_preferredLocation"));
			Dimension originalSize = parseDimension(
					configManager.getConfiguration(OVERLAY_CONFIG_GROUP,
							"marker" + originalMarkerId + "_preferredSize"));

			// Set location/size on the overlay object
			if (originalLocation != null) {
				newOverlay.setPreferredLocation(originalLocation);
			}
			if (originalSize != null) {
				newOverlay.setPreferredSize(originalSize);
			}

			// Explicitly save the location and size config using the NEW ID
			String newLocationKey = "marker" + newId + "_preferredLocation";
			String newSizeKey = "marker" + newId + "_preferredSize";

			if (originalLocation != null) {
				configManager.setConfiguration(OVERLAY_CONFIG_GROUP, newLocationKey,
						originalLocation.x + ":" + originalLocation.y);
			} else {
				configManager.unsetConfiguration(OVERLAY_CONFIG_GROUP, newLocationKey);
			}

			if (originalSize != null) {
				configManager.setConfiguration(OVERLAY_CONFIG_GROUP, newSizeKey,
						originalSize.width + "x" + originalSize.height);
			} else {
				configManager.unsetConfiguration(OVERLAY_CONFIG_GROUP, newSizeKey);
			}

			// Add the new overlay to the internal group list
			importedGroupList.add(newOverlay);

			// Add to overlay manager IF the group is visible AND the marker is visible
			if (isGroupVisible(IMPORTED_GROUP) && newMarker.isVisible()) {
				overlayManager.add(newOverlay);
			}

			// Save the overlay's marker data (JSON blob) using the OverlayManager
			overlayManager.saveOverlay(newOverlay);

			importedCount++;
		}

		if (importedCount > 0) {
			updateGroupsConfig();
			SwingUtilities.invokeLater(pluginPanel::rebuild);
			JOptionPane.showMessageDialog(pluginPanel,
					"Successfully imported " + importedCount + " marker(s) into the '" + IMPORTED_GROUP + "' group.",
					"Import Successful", JOptionPane.INFORMATION_MESSAGE);
		} else {
			JOptionPane.showMessageDialog(pluginPanel,
					"No new markers were imported (they might already exist in the 'Imported' group).",
					"Import Information", JOptionPane.INFORMATION_MESSAGE);
		}
	}

	/**
	 * Finds the maximum marker ID currently used within this plugin.
	 * Used to help generate unique IDs during import.
	 *
	 * @return The maximum ID found, or 0 if no markers exist.
	 */
	private long findMaxMarkerId() {
		return markerGroups.values().stream()
				.flatMap(List::stream)
				.map(overlay -> overlay.getMarker().getId())
				.max(Long::compare)
				.orElse(0L);
	}

	/**
	 * Parses a Point object from a string representation "x:y".
	 *
	 * @param pointString The string to parse.
	 * @return The parsed Point, or null if parsing fails or input is null/empty.
	 */
	private Point parsePoint(String pointString) {
		if (Strings.isNullOrEmpty(pointString)) {
			return null;
		}
		String[] parts = pointString.split(":");
		if (parts.length != 2) {
			return null;
		}
		try {
			int x = Integer.parseInt(parts[0]);
			int y = Integer.parseInt(parts[1]);
			return new Point(x, y);
		} catch (NumberFormatException e) {
			return null;
		}
	}

	/**
	 * Parses a Dimension object from a string representation "widthxheight".
	 *
	 * @param dimensionString The string to parse.
	 * @return The parsed Dimension, or null if parsing fails or input is
	 *         null/empty.
	 */
	private Dimension parseDimension(String dimensionString) {
		if (Strings.isNullOrEmpty(dimensionString)) {
			return null;
		}
		String[] parts = dimensionString.split("x");
		if (parts.length != 2) {
			return null;
		}
		try {
			int width = Integer.parseInt(parts[0]);
			int height = Integer.parseInt(parts[1]);
			// Ensure minimum dimensions
			width = Math.max(width, 1);
			height = Math.max(height, 1);
			return new Dimension(width, height);
		} catch (NumberFormatException e) {
			return null;
		}
	}

	/**
	 * Calculates the correct insertion index for new groups in the groupOrderList.
	 * New groups should be inserted before "Unassigned" and "Imported".
	 *
	 * @return The index where a new non-special group should be inserted.
	 */
	private int calculateGroupInsertIndex() {
		int insertIndex = groupOrderList.size();
		if (groupOrderList.contains(IMPORTED_GROUP)) {
			insertIndex = groupOrderList.indexOf(IMPORTED_GROUP);
		}
		if (groupOrderList.contains(UNASSIGNED_GROUP)) {
			// Insert before Unassigned if it comes before Imported (or if Imported doesn't
			// exist)
			insertIndex = Math.min(insertIndex, groupOrderList.indexOf(UNASSIGNED_GROUP));
		}
		return insertIndex;
	}

	/**
	 * Ensures the "Unassigned" and "Imported" groups are present in the
	 * groupOrderList (if they exist in markerGroups) and are positioned at the end,
	 * with "Unassigned" before "Imported".
	 */
	private void ensureSpecialGroupsOrder() {
		boolean unassignedExists = markerGroups.containsKey(UNASSIGNED_GROUP);
		boolean importedExists = markerGroups.containsKey(IMPORTED_GROUP);

		// Remove existing instances to reposition them correctly
		groupOrderList.remove(UNASSIGNED_GROUP);
		groupOrderList.remove(IMPORTED_GROUP);

		// Add them back at the end in the correct order if they exist
		if (unassignedExists) {
			groupOrderList.add(UNASSIGNED_GROUP);
		}
		if (importedExists) {
			groupOrderList.add(IMPORTED_GROUP);
		}
	}
}

package screenmarkergroups;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

/**
 * Enum defining the possible positions for a screen marker's label.
 */
@Getter
@RequiredArgsConstructor
public enum LabelPosition {
    ABOVE("Above"), // Label is drawn above the marker border
    INSIDE("Inside"); // Label is drawn inside the marker border

    private final String name;

    @Override
    public String toString() {
        return name;
    }
}

/*
 * Copyright (c) 2025, Bloopser <https://github.com/Bloopser>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package screenmarkergroups;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ScreenMarkerGroupsPluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(ScreenMarkerGroupsPlugin.class);
        RuneLite.main(args);
    }
}

