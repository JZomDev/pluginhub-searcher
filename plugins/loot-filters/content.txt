package com.lootfilters;

import com.lootfilters.lang.CompileException;
import com.lootfilters.lang.Sources;
import lombok.SneakyThrows;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.util.ArrayList;

import static com.lootfilters.util.CollectionUtil.append;
import static com.lootfilters.util.FilterUtil.configToFilterSource;
import static com.lootfilters.util.TextUtil.quote;
import static javax.swing.JOptionPane.showConfirmDialog;
import static javax.swing.JOptionPane.showInputDialog;
import static javax.swing.SwingUtilities.invokeLater;
import static net.runelite.client.util.ImageUtil.loadImageResource;

public class LootFiltersPanel extends PluginPanel {
    private static final String NONE_ITEM = "<none>";
    private static final String NONE_TEXT = "Select a filter to display its source.";
    private static final String TUTORIAL_TEXT = "// Welcome to the loot filter\n" +
            "// For more information on \n" +
            "// usage, please check\n" +
            "// https://github.com/riktenx/loot-filters/blob/main/guides/loot-filters.md";
    private static final String EXAMPLE_TEXT = "// Here's an example:\nif (name:\"Herring\") {\n  color = RED;\n}";
    private static final Font TEXT_FONT_ACTIVE = new Font(Font.MONOSPACED, Font.PLAIN, 12);
    private static final Color TEXT_BG_ACTIVE = Color.decode("#1e1e1e");

    private final LootFiltersPlugin plugin;
    private final JComboBox<String> filterSelect;
    private final JTextArea filterText;
    private final JButton saveChanges;
    private final JPanel root;

    public LootFiltersPanel(LootFiltersPlugin plugin) throws Exception {
        this.plugin = plugin;

        filterSelect = new JComboBox<>();
        filterText = new JTextArea(23, 30);
        saveChanges = new JButton("Save");

        root = new JPanel();
        root.setLayout(new BoxLayout(root, BoxLayout.Y_AXIS));

        init();
        initControls();
    }

    private void init() {
        var top = new JPanel(new FlowLayout(FlowLayout.LEFT));
        var textButtons = new JPanel(new FlowLayout(FlowLayout.LEFT));
        var textPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));

        var label = new JLabel("Active filter:");
        var createNew = createIconButton("create_filter",
                "Create a new empty filter.",
                this::onCreateEmptyFilter);
        var importClipboard = createIconButton("paste_icon",
                "Import new filter from clipboard.",
                this::onImportClipboard);
        var importConfig = createIconButton("import_config",
                "Import item highlight and hide lists into a new filter. Doing this will also reset those lists.",
                this::onImportConfig);
        var deleteActive = createIconButton("delete_active",
                "Delete the currently active filter.",
                this::onDeleteActive);
        var deleteAll = new JButton("Delete all");
        deleteAll.addActionListener(it -> onDeleteAll());
        saveChanges.addActionListener(it -> onSaveChanges());

        top.add(label);
        top.add(createNew);
        top.add(importClipboard);
        top.add(importConfig);
        top.add(deleteActive);
        textButtons.add(deleteAll);
        textButtons.add(Box.createHorizontalStrut(50));
        textButtons.add(saveChanges);
        textPanel.add(new JScrollPane(filterText));

        root.add(top);
        root.add(filterSelect);
        root.add(textButtons);
        root.add(textPanel);

        add(root);
    }

    private void initControls() throws IOException {
        var filters = plugin.getUserFilters();
        filterSelect.addItem(NONE_ITEM);
        for (var filter : filters) {
            filterSelect.addItem(LootFilter.fromSource(filter).getName());
        }

        var index = plugin.getUserFilterIndex();
        if (index <= filters.size() - 1) {
            filterSelect.setSelectedIndex(index + 1);
        }

        filterSelect.addActionListener(this::onFilterSelect);

        filterText.setLineWrap(true);
        filterText.getDocument().addDocumentListener(new DocumentListener() {
            private void onChange() {
                var index = plugin.getUserFilterIndex();
                if (index == -1) {
                    saveChanges.setVisible(false);
                    return;
                }

                var existingSrc = plugin.getUserFilters().get(index);
                saveChanges.setVisible(!existingSrc.equals(filterText.getText()));
            }

            @Override public void insertUpdate(DocumentEvent e) { onChange(); }
            @Override public void removeUpdate(DocumentEvent e) { onChange(); }
            @Override public void changedUpdate(DocumentEvent e) { onChange(); }
        });
        updateFilterText(index);
    }

    @SneakyThrows
    private void onCreateEmptyFilter() {
        String[] templateOptions = {"blank script", "loot-filters/filterscape"};
        var template = JOptionPane.showInputDialog(this, "Choose a template:","Create new filter",
                JOptionPane.PLAIN_MESSAGE, null, templateOptions, "blank script");
        if (template == null) {
            return;
        }

        var newName = showInputDialog(this, "Please enter a name:");
        if (newName == null || newName.isBlank()) {
            return;
        }

        String newSrc;
        if (template.equals(templateOptions[0])) {
            newSrc = "meta { name = " + quote(newName) + "; }\n" +
                    String.join("\n","", TUTORIAL_TEXT, "", EXAMPLE_TEXT);
        } else { // loot-filters/filterscape
            newSrc = Sources.getReferenceSource()
                    .replace("    name = \"loot-filters/filterscape\";", "name = " + quote(newName) + ";");
        }

        if (tryUpdateExisting(newName, newSrc)) {
            return;
        }

        addNewFilter(newName, newSrc);
    }

    private void onImportClipboard() {
        var newSrc = getClipboard();
        if (newSrc == null) {
            plugin.addChatMessage("No text in clipboard.");
            return;
        }

        LootFilter newFilter;
        try {
            newFilter = LootFilter.fromSource(newSrc);
        } catch (CompileException e) {
            plugin.addChatMessage("Failed to load filter from clipboard: " + e.getMessage());
            return;
        }

        if (newFilter.getName() == null || newFilter.getName().isBlank()) {
            var newName = showInputDialog(this, "This filter does not have a name. Enter one:");
            if (newName == null || newName.isBlank()) {
                return;
            }
            newSrc = "meta { name = " + quote(newName) + "; }\n" + newSrc;
            newFilter.setName(newName);
        }

        if (tryUpdateExisting(newFilter.getName(), newSrc)) {
            return;
        }

        addNewFilter(newFilter.getName(), newSrc);
    }

    @SneakyThrows
    private void onImportConfig() {
        var initialName = plugin.getClient().getLocalPlayer() != null
                ? plugin.getClient().getLocalPlayer().getName() + "/"
                : "player/";
        var finalName = showInputDialog(this, "Enter a filter name:", initialName);
        if (finalName == null) {
            return;
        }

        var src = configToFilterSource(plugin.getConfig(), finalName, TUTORIAL_TEXT);
        if (tryUpdateExisting(finalName, src)) {
            return;
        }

        plugin.getConfig().setHighlightedItems("");
        plugin.getConfig().setHiddenItems("");
        addNewFilter(finalName, src);
    }

    private void onFilterSelect(ActionEvent event) {
        var realIndex = filterSelect.getSelectedIndex() - 1;
        plugin.setUserFilterIndex(realIndex);
        updateFilterText(realIndex);
    }

    private void onDeleteActive() {
        var toDelete = filterSelect.getSelectedIndex() - 1;
        if (plugin.getUserFilters().isEmpty() || toDelete == -1) {
            return;
        }
        if (!confirm("Delete the active loot filter?")) {
            return;
        }

        var newCfg = new ArrayList<>(plugin.getUserFilters());
        newCfg.remove(toDelete);

        filterSelect.removeItemAt(toDelete + 1);
        filterSelect.setSelectedIndex(0);
        plugin.setUserFilters(newCfg);
        plugin.setUserFilterIndex(-1);
        updateFilterText(-1);
    }

    private void onDeleteAll() {
        if (!confirm("Delete all loot filters?")) { return; }
        if (!confirm("Are you sure?")) { return; }

        filterSelect.removeActionListener(this::onFilterSelect);
        filterSelect.removeAllItems();
        filterSelect.addItem(NONE_ITEM);
        filterSelect.setSelectedIndex(0);
        plugin.setUserFilters(new ArrayList<>());
        plugin.setUserFilterIndex(-1);
        updateFilterText(-1);
        invokeLater(() -> filterSelect.addActionListener(this::onFilterSelect));
    }

    private void onSaveChanges() {
        var newSrc = filterText.getText();
        try {
            LootFilter.fromSource(newSrc);
        } catch (CompileException e) {
            plugin.addChatMessage("Cannot update active filter: " + e.getMessage());
            return;
        }

        if (!confirm("Save changes to the active filter?")) {
            return;
        }

        var filters = plugin.getUserFilters();
        filters.set(plugin.getUserFilterIndex(), newSrc);
        plugin.setUserFilters(filters);
        saveChanges.setVisible(false);
    }

    private boolean tryUpdateExisting(String newName, String newSrc) {
        var existing = plugin.getUserFilters();
        for (int i = 0; i < filterSelect.getItemCount(); ++i) {
            if (!filterSelect.getItemAt(i).equals(newName)) {
                continue;
            }
            if (!confirm("Filter " + quote(newName) + " already exists. Update it?")) {
                return true;
            }

            existing.set(i - 1, newSrc);
            plugin.setUserFilters(existing);
            return true;
        }
        return false;
    }

    private void updateFilterText(int index) {
        if (index > -1) {
            filterText.setText(plugin.getUserFilters().get(index));
            filterText.setEnabled(true);
            filterText.setFont(TEXT_FONT_ACTIVE);
        } else {
            filterText.setText(NONE_TEXT);
            filterText.setEnabled(false);
            filterText.setFont(FontManager.getRunescapeFont());
        }
        filterText.setCaretPosition(0);
    }

    private JButton createIconButton(String iconSource, String tooltip, Runnable onClick) {
        var button = new JButton("", icon(iconSource));
        button.setToolTipText(tooltip);
        button.setBackground(null);
        button.setBorder(null);
        button.addActionListener(it -> onClick.run());
        return button;
    }

    private boolean confirm(String confirmText) {
        var result = showConfirmDialog(this, confirmText, "Confirm", JOptionPane.YES_NO_OPTION);
        return result == JOptionPane.YES_OPTION;
    }

    private void addNewFilter(String name, String src) {
        filterSelect.addItem(name);
        plugin.setUserFilters(append(plugin.getUserFilters(), src));
        plugin.setUserFilterIndex(filterSelect.getItemCount() - 2);
        invokeLater(() -> filterSelect.setSelectedIndex(filterSelect.getItemCount() - 1));
    }

    private static String getClipboard() {
        try {
            return (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
        } catch (Exception e) {
            return null;
        }
    }

    private static ImageIcon icon(String name) {
        var img = loadImageResource(LootFiltersPanel.class, "/com/lootfilters/icons/" + name + ".png");
        return new ImageIcon(img);
    }
}

package com.lootfilters;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import com.lootfilters.model.PluginTileItem;
import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import javax.inject.Named;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static com.lootfilters.util.FilterUtil.withConfigMatchers;
import static com.lootfilters.util.TextUtil.quote;
import static net.runelite.client.util.ImageUtil.loadImageResource;

@Slf4j
@PluginDescriptor(
	name = "Loot Filters",
	description = "Alternative implementation of the ground items plugin with scriptable loot filters.",
	tags = {"loot", "filters", "improved", "ground", "items"},
	conflicts = {"Ground Items"}
)
@Getter
public class LootFiltersPlugin extends Plugin {
	public static final String CONFIG_GROUP = "loot-filters";
	public static final String USER_FILTERS_KEY = "user-filters";
	public static final String USER_FILTERS_INDEX_KEY = "user-filters-index";

	@Inject private Client client;
	@Inject private ClientThread clientThread;
	@Inject private ClientToolbar clientToolbar;

	@Inject private LootFiltersConfig config;
	@Inject private LootFiltersOverlay overlay;
	@Inject private LootFiltersMouseAdapter mouseAdapter;
	@Inject private LootFiltersHotkeyListener hotkeyListener;

	@Inject private Gson gson;
	@Inject private OverlayManager overlayManager;
	@Inject private KeyManager keyManager;
	@Inject private MouseManager mouseManager;
	@Inject private ConfigManager configManager;
	@Inject private ItemManager itemManager;
	@Inject private Notifier notifier;

	private LootFiltersPanel pluginPanel;
	private NavigationButton pluginPanelNav;

	private final TileItemIndex tileItemIndex = new TileItemIndex();
	private final LootbeamIndex lootbeamIndex = new LootbeamIndex(this);
	private final MenuEntryComposer menuEntryComposer = new MenuEntryComposer(this);

	private LootFilter activeFilter;
	private LootFilter currentAreaFilter;
	private List<LootFilter> parsedUserFilters;

	@Setter private int hoveredItem = -1;
	@Setter private int hoveredHide = -1;
	@Setter private int hoveredHighlight = -1;
	@Setter private boolean hotkeyActive = false;
	@Setter private boolean overlayEnabled = true;

	@Inject @Named("developerMode") boolean developerMode;

	@Getter private boolean debugEnabled = false;

	public LootFilter getActiveFilter() {
		return currentAreaFilter != null ? currentAreaFilter : activeFilter;
	}

	public List<String> getUserFilters() {
		var cfg = configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_KEY);
		if (cfg == null || cfg.isEmpty()) {
			return new ArrayList<>();
		}

		var type = new TypeToken<List<String>>(){}.getType();
        return gson.fromJson(configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_KEY), type);
	}

	@SneakyThrows // incoming user filters are vetted at this point, exceptions are a defect
    public void setUserFilters(List<String> filters) {
		parsedUserFilters = new ArrayList<>();
		for (var filter : filters) {
			parsedUserFilters.add(LootFilter.fromSource(filter));
		}

		var json = gson.toJson(filters);
		configManager.setConfiguration(CONFIG_GROUP, USER_FILTERS_KEY, json);
	}

	public int getUserFilterIndex() {
		var indexCfg = configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_INDEX_KEY);
        var index = indexCfg == null || indexCfg.isEmpty()
				? -1
				: Integer.parseInt(indexCfg);
		return Math.max(index, -1);
	}

	public void setUserFilterIndex(int index) {
		configManager.setConfiguration(CONFIG_GROUP, USER_FILTERS_INDEX_KEY, Integer.toString(index));
	}

	public String getUserActiveFilter() {
		var filters = getUserFilters();
		var index = getUserFilterIndex();
		return filters.isEmpty() || index == -1 || index > filters.size()-1
				? "" : filters.get(index);
	}

	public void addChatMessage(String msg) {
		clientThread.invoke(() -> {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "loot-filters", false);
		});
	}

	public String getItemName(int id) {
		return itemManager.getItemComposition(id).getName();
	}

	@Override
	protected void startUp() throws Exception {
		overlayManager.add(overlay);

		loadFilter();
		setUserFilters(getUserFilters()); // round-trip on startup to parse everything into memory

		pluginPanel = new LootFiltersPanel(this);
		pluginPanelNav = NavigationButton.builder()
				.tooltip("Loot Filters")
				.icon(loadImageResource(this.getClass(), "/com/lootfilters/icons/panel.png"))
				.panel(pluginPanel)
				.build();
		clientToolbar.addNavigation(pluginPanelNav);
		keyManager.registerKeyListener(hotkeyListener);
		mouseManager.registerMouseListener(mouseAdapter);
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(overlay);

		tileItemIndex.clear();
		lootbeamIndex.clear();

		clientToolbar.removeNavigation(pluginPanelNav);
		keyManager.unregisterKeyListener(hotkeyListener);
		mouseManager.unregisterMouseListener(mouseAdapter);
	}

	@Provides
	LootFiltersConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(LootFiltersConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) throws Exception {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		loadFilter();
		if (!config.autoToggleFilters()) {
			currentAreaFilter = null;
		} // if we're transitioning TO enabled, do nothing - onGameTick() will handle it
		clientThread.invoke(lootbeamIndex::reset);
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned event) {
		var tile = event.getTile();
		var item = new PluginTileItem(this, event.getItem());
		tileItemIndex.put(tile, item);

		var match = getActiveFilter().findMatch(this, item);
		if (match == null) {
			return;
		}

		if (match.isShowLootbeam()) {
			var beam = new Lootbeam(client, clientThread, tile.getWorldLocation(), match.getLootbeamColor(), Lootbeam.Style.MODERN);
			lootbeamIndex.put(tile, item, beam);
		}
		if (match.isNotify()) {
			notifier.notify(getItemName(item.getId()));
		}
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event) {
		var tile = event.getTile();
		var item = new PluginTileItem(this, event.getItem());
		tileItemIndex.remove(tile, item);
		lootbeamIndex.remove(tile, item); // idempotent, we don't care if there wasn't a beam
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOADING) {
			tileItemIndex.clear();
			lootbeamIndex.clear();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		scanAreaFilter();
	}

	@Subscribe
	private void onMenuEntryAdded(MenuEntryAdded event) {
		menuEntryComposer.onMenuEntryAdded(event.getMenuEntry());
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event) {
		menuEntryComposer.onMenuOpened();
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted event) {
		if (developerMode && event.getCommand().equals("lfDebug")) {
			debugEnabled = !debugEnabled;
		}
	}

	private void loadFilter() throws Exception {
		var userFilter = LootFilter.fromSource(getUserActiveFilter());
		activeFilter = withConfigMatchers(userFilter, config);
	}

	private void scanAreaFilter() {
		if (!config.autoToggleFilters()) {
			return;
		}

		var player = client.getLocalPlayer();
		if (player == null) {
			return;
		}

		var p = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		var match = parsedUserFilters.stream()
				.filter(it -> it.isInActivationArea(p))
				.findFirst().orElse(null);
		if (match != null && (currentAreaFilter == null || !Objects.equals(match.getName(), currentAreaFilter.getName()))) {
			addChatMessage("Entering area for filter " + quote(match.getName()));
			currentAreaFilter = withConfigMatchers(match, config);
		} else if (match == null && currentAreaFilter != null) {
			addChatMessage("Leaving area for filter " + quote(currentAreaFilter.getName()));
			currentAreaFilter = null;
		}
	}
}

package com.lootfilters.util;

import com.lootfilters.rule.TextAccent;
import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;

// simplified version of runelite's TextComponent API for our purposes, adding support for _no_ text accent as well as
// text accent color
@Setter
public class TextComponent implements RenderableEntity {
    private String text;
    private Color color = Color.WHITE;
    private Color accentColor = Color.BLACK;
    private TextAccent textAccent = TextAccent.SHADOW;
    private Point position;

    @Override
    public Dimension render(Graphics2D g) {
        var origColor = g.getColor();

        g.setColor(accentColor);
        if (textAccent == TextAccent.SHADOW) {
            g.drawString(text, position.x+1, position.y+1);
        } else if (textAccent == TextAccent.OUTLINE) {
            g.drawString(text, position.x+1, position.y);
            g.drawString(text, position.x, position.y+1);
            g.drawString(text, position.x-1, position.y);
            g.drawString(text, position.x, position.y-1);
        }
        g.setColor(color);
        g.drawString(text, position.x, position.y);

        g.setColor(origColor);
        return null;
    }
}

package com.lootfilters.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CollectionUtil {
    private CollectionUtil() {}

    public static <E> List<E> append(List<E> list, E... elements) {
        var newList = new ArrayList<>(list);
        newList.addAll(Arrays.asList(elements));
        return newList;
    }

    public static <E> List<E> without(List<E> list, E element) {
        var newList = new ArrayList<>(list);
        newList.remove(element);
        return newList;
    }
}

package com.lootfilters.util;

import java.io.IOException;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TextUtil {
    private TextUtil() {}

    public static String quote(String text) {
        return '"' + text + '"';
    }

    public static boolean isWhitespace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }

    public static boolean isNumeric(char c) {
        return c >= '0' && c <= '9';
    }

    public static boolean isAlpha(char c) {
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
    }

    public static boolean isLegalIdent(char c) {
        return c == '_' || isAlpha(c) || isNumeric(c);
    }

    public static String abbreviate(int value) {
        if (value >= 1e9) { // > 1b
            return String.format("%.2fB", (float)value / 1e9);
        } else if (value >= 1e8) { // > 100m
            return String.format("%.0fM", (float)value / 1e6);
        } else if (value >= 1e7) { // > 10m
            return String.format("%.1fM", (float)value / 1e6);
        } else if (value >= 1e6) { // > 1m
            return String.format("%.2fM", (float)value / 1e6);
        } else if (value >= 1e5) { // > 100k
            return String.format("%.0fK", (float)value / 1e3);
        } else if (value >= 1e4) { // > 10k
            return String.format("%.1fK", (float)value / 1e3);
        } else if (value >= 1e3) { // > 1k
            return String.format("%.2fK", (float)value / 1e3);
        }
        return Integer.toString(value);
    }

    public static String abbreviateValue(int value) {
        return value < 1000 ? value + "gp" : abbreviate(value);
    }

    public static String withParentheses(String value) {
        return "(" + value + ")";
    }

    public static String normalizeCrlf(String str) {
        return str
                .replaceAll("\r\n", "\n")
                .replaceAll("\r", "\n");
    }

    public static String loadFilterScript(String resource) throws IOException {
        try (var r = TextUtil.class.getResourceAsStream("/com/lootfilters/scripts/" + resource)) {
            assert r != null;
            return normalizeCrlf(new String(r.readAllBytes()));
        }
    }

    public static String setCsv(String csv, String value) {
        if (csv.isBlank()) {
            return value;
        }
        return Stream.concat(Arrays.stream(csv.split(",")), Stream.of(value))
                .distinct()
                .collect(Collectors.joining(","));
    }

    public static String unsetCsv(String csv, String value) {
        if (csv.isBlank()) {
            return "";
        }
        return Arrays.stream(csv.split(","))
                .filter(it -> !it.equals(value))
                .collect(Collectors.joining(","));
    }

    public static String toggleCsv(String csv, String item) {
        if (Arrays.stream(csv.split(",")).anyMatch(it -> it.trim().equalsIgnoreCase(item))) {
            return unsetCsv(csv, item);
        } else {
            return setCsv(csv, item);
        }
    }
}

package com.lootfilters.util;

import com.lootfilters.LootFilter;
import com.lootfilters.LootFiltersConfig;
import com.lootfilters.MatcherConfig;
import com.lootfilters.rule.TextAccent;
import com.lootfilters.rule.ValueTier;

import java.util.ArrayList;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.quote;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;
import static net.runelite.client.util.ColorUtil.colorToAlphaHexCode;

public class FilterUtil {
    private FilterUtil() {}

    /**
     * Wraps a user-defined loot filter with config defaults (highlight/hide, value tiers, etc.).
     */
    public static LootFilter withConfigMatchers(LootFilter filter, LootFiltersConfig config) {
        var matchersWithConfig = new ArrayList<MatcherConfig>();
        matchersWithConfig.add(MatcherConfig.showUnmatched(config.showUnmatchedItems()));

        matchersWithConfig.add(MatcherConfig.ownershipFilter(config.ownershipFilter()));
        matchersWithConfig.add(MatcherConfig.itemSpawnFilter(config.itemSpawnFilter()));

        matchersWithConfig.add(MatcherConfig.highlight(
                config.highlightedItems(), config.highlightColor(), config.highlightLootbeam(), config.highlightNotify()));
        matchersWithConfig.add(MatcherConfig.hide(config.hiddenItems()));

        matchersWithConfig.addAll(filter.getMatchers());

        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableInsaneItemValueTier(), config.insaneValue(), config.insaneValueColor(),
        config.lootbeamTier().ordinal() >= ValueTier.INSANE.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.INSANE.ordinal()));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableHighItemValueTier(), config.highValue(), config.highValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.HIGH.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.HIGH.ordinal()));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableMediumItemValueTier(), config.mediumValue(), config.mediumValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.MEDIUM.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.MEDIUM.ordinal()));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableLowItemValueTier(), config.lowValue(), config.lowValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.LOW.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.LOW.ordinal()));
        matchersWithConfig.add(MatcherConfig.hiddenTier(config.hideTierEnabled(), config.hideTierValue(), config.hideTierShowUntradeable()));

        if (config.alwaysShowValue()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(),
                            it.getDisplay().toBuilder().showValue(true).build(),
                            it.isTerminal()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        if (config.alwaysShowDespawn()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(),
                            it.getDisplay().toBuilder().showDespawn(true).build(),
                            it.isTerminal()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        if (config.textAccent().ordinal() > TextAccent.USE_FILTER.ordinal()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(),
                            it.getDisplay().toBuilder().textAccent(config.textAccent()).build(),
                            it.isTerminal()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }

        return new LootFilter(filter.getName(), filter.getDescription(), filter.getActivationArea(), matchersWithConfig);
    }

    /**
     * Captures the current config-based item matchers, exporting them to their own filter.
     */
    public static String configToFilterSource(LootFiltersConfig config, String name, String tutorialText) {
        var defines = "#define HCOLOR " + quote(colorToAlphaHexCode(config.highlightColor()));
        var meta = "meta {\n  name = " + quote(name) + ";\n}\n\n";
        var highlights = "";
        if (!config.highlightedItems().isBlank()) {
            highlights = stream(config.highlightedItems().split(","))
                    .map(it -> "HIGHLIGHT(" + quote(it) + ", HCOLOR)")
                    .collect(joining("\n"));
        }
        var hides = "";

        if (!config.hiddenItems().isBlank()) {
            hides = stream(config.hiddenItems().split(","))
                    .map(it -> "HIDE("+ quote(it) + ")")
                    .collect(joining("\n"));
        }

        return String.join("\n",
                defines,
                meta,
                tutorialText,
                highlights,
                hides);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.awt.Color;
import java.lang.reflect.Type;

public class ColorSerializer implements JsonSerializer<Color> {
    @Override
    public JsonElement serialize(Color color, Type type, JsonSerializationContext ctx) {
        var argb = String.format("%02x", color.getAlpha())
                + String.format("%02x", color.getRed())
                + String.format("%02x", color.getGreen())
                + String.format("%02x", color.getBlue());
        return new JsonPrimitive(argb);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;
import java.lang.reflect.Type;

public class ColorDeserializer implements JsonDeserializer<Color> {
    @Override
    public Color deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        return ColorUtil.fromHex(elem.getAsString());
    }
}

package com.lootfilters.serde;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import lombok.AllArgsConstructor;

import java.lang.reflect.Type;

@AllArgsConstructor
public class RuleDeserializer implements JsonDeserializer<Rule> {
    private final Gson gson;

    @Override
    public Rule deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        var object = elem.getAsJsonObject();
        var discriminator = object.get("discriminator").getAsString();
        switch (discriminator) {
            case "item_id":
                return gson.fromJson(object, ItemIdRule.class);
            case "item_name":
                return gson.fromJson(object, ItemNameRule.class);
            case "item_value":
                return gson.fromJson(object, ItemValueRule.class);
            case "item_quantity":
                return gson.fromJson(object, ItemQuantityRule.class);
            case "and":
                return deserializeInner(object, AndRule.class);
            case "or":
                return deserializeInner(object, OrRule.class);
            default:
                throw new JsonParseException("unknown rule type " + discriminator);
        }
    }

    private Rule deserializeInner(JsonElement elem, Type type) throws JsonParseException {
        return gson.newBuilder()
                .registerTypeAdapter(Rule.class, this)
                .create()
                .fromJson(elem, type);
    }
}

package com.lootfilters;

import com.lootfilters.model.DespawnTimerType;
import com.lootfilters.model.DualValueDisplayType;
import com.lootfilters.model.PluginTileItem;
import com.lootfilters.model.ValueDisplayType;
import com.lootfilters.util.TextComponent;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

import static com.lootfilters.util.TextUtil.abbreviate;
import static com.lootfilters.util.TextUtil.abbreviateValue;
import static com.lootfilters.util.TextUtil.withParentheses;
import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static net.runelite.api.Perspective.getCanvasTextLocation;

public class LootFiltersOverlay extends Overlay {
    private static final int Z_STACK_OFFSET = 16;
    private static final int BOX_PAD = 2;
    private static final int CLICKBOX_SIZE = 8;
    private static final Color COLOR_HIDDEN = Color.GRAY.brighter();

    private final Client client;
    private final LootFiltersPlugin plugin;
    private final LootFiltersConfig config;

    @Inject
    private ItemManager itemManager;

    @Inject
    public LootFiltersOverlay(Client client, LootFiltersPlugin plugin, LootFiltersConfig config) {
        setPosition(OverlayPosition.DYNAMIC);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D g) {
        if (plugin.isDebugEnabled()) {
            renderDebugOverlay(g);
        }

        if (!plugin.isOverlayEnabled()) {
            return null;
        }

        var activeFilter = plugin.getActiveFilter();
        var mouse = client.getMouseCanvasPosition();
        var hoveredItem = -1;
        var hoveredHide = new AtomicInteger(-1);
        var hoveredHighlight = new AtomicInteger(-1);

        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var items = entry.getValue();
            var itemCounts = items.stream()
                    .collect(groupingBy(TileItem::getId, counting()));

            var tile = entry.getKey();
            var currentOffset = 0;
            var rendered = new ArrayList<Integer>();
            for (var item : items) {
                if (rendered.contains(item.getId())) {
                    continue;
                }
                rendered.add(item.getId());

                var count = itemCounts.get(item.getId());

                var match = activeFilter.findMatch(plugin, item);
                if (match == null) {
                    continue;
                }

                var overrideHidden = plugin.isHotkeyActive() && config.hotkeyShowHiddenItems();
                if (match.isHidden() && !overrideHidden) {
                    continue;
                }

                var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
                if (loc == null) {
                    continue;
                }
                if (tile.getItemLayer() == null) {
                    continue;
                }

                g.setFont(match.getFont());

                var displayText = buildDisplayText(item, count, match);
                var textPoint = getCanvasTextLocation(client, g, loc, displayText, tile.getItemLayer().getHeight() + Z_STACK_OFFSET);
                if (textPoint == null) {
                    continue;
                }

                var fm = g.getFontMetrics(match.getFont());
                var textWidth = fm.stringWidth(displayText);
                var textHeight = fm.getHeight();

                var text = new TextComponent();
                text.setText(displayText);
                text.setColor(match.isHidden() ? COLOR_HIDDEN : match.getTextColor());
                text.setPosition(new Point(textPoint.getX(), textPoint.getY() - currentOffset));
                if (match.getTextAccentColor() != null) {
                    text.setAccentColor(match.getTextAccentColor());
                }
                if (match.getTextAccent() != null ) {
                    text.setTextAccent(match.getTextAccent());
                }

                var boundingBox = new Rectangle(
                        textPoint.getX() - BOX_PAD, textPoint.getY() - currentOffset - textHeight - BOX_PAD,
                        textWidth + 2 * BOX_PAD, textHeight + 2 * BOX_PAD
                );

                if (match.getBackgroundColor() != null) {
                    g.setColor(match.getBackgroundColor());
                    g.fillRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (match.getBorderColor() != null) {
                    g.setColor(match.getBorderColor());
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (plugin.isHotkeyActive() && boundingBox.contains(mouse.getX(), mouse.getY())) {
                    hoveredItem = item.getId();

                    g.setColor(match.isHidden() ? COLOR_HIDDEN : Color.WHITE);
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (config.hotkeyShowClickboxes() && plugin.isHotkeyActive()) {
                    renderClickboxes(g, boundingBox, item, match, hoveredHide::set, hoveredHighlight::set);
                }

                text.render(g);

                if (match.isShowDespawn() || plugin.isHotkeyActive()) {
                    var type = plugin.isHotkeyActive() ? DespawnTimerType.PIE : config.despawnTimerType();
                    renderDespawnTimer(g, type, item, textPoint, textWidth, fm.getHeight(), currentOffset);
                }

                currentOffset += textHeight + BOX_PAD + 3;
            }
        }

        plugin.setHoveredItem(hoveredItem);
        plugin.setHoveredHide(hoveredHide.get());
        plugin.setHoveredHighlight(hoveredHighlight.get());
        return null;
    }

    private Color getDespawnTextColor(PluginTileItem item) {
        if (item.getDespawnTime() - client.getTickCount() < 100) {
            return Color.RED;
        }
        if (!item.isPrivate() && item.getVisibleTime() <= client.getTickCount()) {
            return Color.YELLOW;
        }
        return Color.GREEN;
    }

    private String buildDisplayText(TileItem item, long unstackedCount, DisplayConfig display) {
        var text = itemManager.getItemComposition(item.getId()).getName();

        if (item.getQuantity() > 1) {
            text += " (" + abbreviate(item.getQuantity()) + ")";
        } else if (unstackedCount > 1) {
            text += " x" + unstackedCount; // we want these to be visually different
        }

        var isMoney = item.getId() == ItemID.COINS_995 || item.getId() == ItemID.PLATINUM_TOKEN; // value is redundant
        var showBecauseHotkey = config.hotkeyShowValues() && plugin.isHotkeyActive();
        if (isMoney || !(display.isShowValue() || showBecauseHotkey)) {
            return text;
        }

        var ge = itemManager.getItemPrice(item.getId()) * item.getQuantity();
        var ha = itemManager.getItemComposition(item.getId()).getHaPrice() * item.getQuantity();
        switch (showBecauseHotkey ? ValueDisplayType.BOTH : config.valueDisplayType()) {
            case HIGHEST:
                return ge == 0 && ha == 0 ? text
                        : text + " " + formatDualValueText(config.dualValueDisplay(), ge, ha, false);
            case GE:
                return ge == 0 ? text : String.format("%s (%s)", text, abbreviateValue(ge));
            case HA:
                return ha == 0 ? text : String.format("%s (%s)", text, abbreviateValue(ha));
            default: // BOTH
                return ge == 0 && ha == 0 ? text
                        : text + " " + formatDualValueText(config.dualValueDisplay(), ge, ha, true);
        }
    }

    private String formatDualValueText(DualValueDisplayType displayType, int geValue, int haValue, boolean showBoth) {
        var geFmt = abbreviateValue(geValue);
        var haFmt = abbreviateValue(haValue);
        var geFmtStr = displayType == DualValueDisplayType.COMPACT ? "%s" : "(GE: %s)";
        var haFmtStr = displayType == DualValueDisplayType.COMPACT ? "*%s" : "(HA: %s)";

        if (!showBoth) {
            var text = geValue >= haValue ? String.format(geFmtStr, geFmt) : String.format(haFmtStr, haFmt);
            return displayType == DualValueDisplayType.COMPACT ? withParentheses(text) : text;
        }

        var parts = new ArrayList<String>();
        if (geValue > 0) {
            parts.add(String.format(geFmtStr, geFmt));
        }
        if (haValue > 0) {
            parts.add(String.format(haFmtStr, haFmt));
        }
        var text = String.join(displayType == DualValueDisplayType.COMPACT ? "/" : " ", parts);
        return displayType == DualValueDisplayType.COMPACT ? withParentheses(text) : text;
    }

    private void renderDebugOverlay(Graphics2D g) {
        int itemCount = 0;
        int screenY = 64;
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            var items = entry.getValue();

            var errs = "";
            var errno = 0;
            var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
            if (loc == null) {
                ++errno;
                errs += "[LOC]";
            }
            if (tile.getItemLayer() == null) {
                ++errno;
                errs += "[IL]";
            }

            var coords = tile.getWorldLocation().getX() + ", " + tile.getWorldLocation().getY();
            var sz = items.size();
            g.setColor(errno > 0 ? Color.RED : Color.WHITE);
            g.drawString(coords+" "+sz+" "+errs, 0, screenY);

            itemCount += sz;
            screenY += 16;
        }
        g.setColor(Color.WHITE);
        g.drawString("items: " + itemCount + "," + plugin.getTileItemIndex().pointIndexSize(), 0, 32);
        g.drawString("lootbeams: " + plugin.getLootbeamIndex().size(), 0, 48);
    }

    private void renderDespawnTimer(Graphics2D g, DespawnTimerType type, PluginTileItem item, net.runelite.api.Point textPoint, int textWidth, int textHeight, int yOffset) {
        var ticksRemaining = item.getDespawnTime() - client.getTickCount();
        if (ticksRemaining < 0) { // doesn't despawn
            return;
        }
        if (config.despawnThreshold() > 0 && ticksRemaining > config.despawnThreshold()) {
            return;
        }

        if (type == DespawnTimerType.TICKS || type == DespawnTimerType.SECONDS) {
            var text = new TextComponent();
            text.setText(type == DespawnTimerType.TICKS
                    ? Integer.toString(ticksRemaining)
                    : String.format("%.1f", (Duration.between(Instant.now(), item.getDespawnInstant())).toMillis() / 1000f));
            text.setColor(getDespawnTextColor(item));
            text.setPosition(new Point(textPoint.getX() + textWidth + 2 + 1, textPoint.getY() - yOffset));
            text.render(g);
        } else {
            var timer = new ProgressPieComponent();
            var total = item.getDespawnTime() - item.getSpawnTime();
            var remaining = item.getDespawnTime() - plugin.getClient().getTickCount();
            var radius = textHeight / 2;
            timer.setPosition(new net.runelite.api.Point(textPoint.getX() - radius - BOX_PAD - 2,
                    textPoint.getY() - yOffset - radius));
            timer.setProgress(remaining / (double) total);
            timer.setDiameter(textHeight);
            timer.setFill(getDespawnTextColor(item));
            timer.setBorderColor(getDespawnTextColor(item));
            timer.render(g);
        }
    }

    private void renderClickboxes(Graphics2D g, Rectangle textBox, TileItem item, DisplayConfig display,
                                  Consumer<Integer> onHoverHide, Consumer<Integer> onHoverHighlight) {
        var y = textBox.y + (textBox.height - CLICKBOX_SIZE) / 2;
        var hide = new Rectangle(textBox.x + textBox.width + 2, y, CLICKBOX_SIZE, CLICKBOX_SIZE);
        var show = new Rectangle(textBox.x + textBox.width + 4 + CLICKBOX_SIZE, y, CLICKBOX_SIZE, CLICKBOX_SIZE);

        var mouse = client.getMouseCanvasPosition();
        if (hide.contains(mouse.getX(), mouse.getY())) {
            onHoverHide.accept(item.getId());
            g.setColor(Color.RED);
        } else {
            g.setColor(display.isHidden() ? COLOR_HIDDEN : display.getTextColor());
        }
        g.drawRect(hide.x, hide.y, hide.width, hide.height);
        g.setColor(Color.WHITE);
        g.drawLine(hide.x + 2, hide.y + hide.height / 2, hide.x + hide.width - 2, hide.y + hide.height / 2);

        if (show.contains(mouse.getX(), mouse.getY())) {
            onHoverHighlight.accept(item.getId());
            g.setColor(Color.GREEN);
        } else {
            g.setColor(display.isHidden() ? COLOR_HIDDEN : display.getTextColor());
        }
        g.drawRect(show.x, show.y, show.width, show.height);
        g.setColor(Color.WHITE);
        g.drawLine(show.x + 2, show.y + show.height / 2, show.x + show.width - 2, show.y + show.height / 2);
        g.drawLine(show.x + show.width / 2, show.y + 2, show.x + show.width / 2, show.y + show.height - 2);
    }
}

package com.lootfilters;

import com.google.inject.Inject;
import net.runelite.client.util.HotkeyListener;

import java.time.Duration;
import java.time.Instant;

public class LootFiltersHotkeyListener extends HotkeyListener {
    private final LootFiltersPlugin plugin;

    private Instant lastPressed = Instant.EPOCH;

    @Inject
    private LootFiltersHotkeyListener(LootFiltersPlugin plugin) {
        super(plugin.getConfig()::hotkey);

        this.plugin = plugin;
    }

    @Override
    public void hotkeyPressed() {
        plugin.setHotkeyActive(true);

        var now = Instant.now();
        if (shouldToggleOverlay(now)) {
            plugin.setOverlayEnabled(!plugin.isOverlayEnabled());
        }
        lastPressed = now;
    }

    @Override
    public void hotkeyReleased() {
        plugin.setHotkeyActive(false);
    }

    private boolean shouldToggleOverlay(Instant now) {
        return plugin.getConfig().hotkeyDoubleTapTogglesOverlay()
                && Duration.between(lastPressed, now).toMillis() < plugin.getConfig().hotkeyDoubleTapDelay();
    }
}
package com.lootfilters;

import com.lootfilters.rule.FontType;
import com.lootfilters.rule.TextAccent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import net.runelite.client.ui.FontManager;

import java.awt.Color;
import java.awt.Font;

@Getter
@Builder(toBuilder = true)
@AllArgsConstructor
@EqualsAndHashCode
@ToString
public class DisplayConfig {
    private static final Color DEFAULT_MENU_TEXT_COLOR = Color.decode("#ff9040");

    private final Color textColor;
    private final Color backgroundColor;
    private final Color borderColor;
    private final Boolean hidden;
    private final Boolean showLootbeam;
    private final Boolean showValue;
    private final Boolean showDespawn;
    private final Boolean notify;
    private final TextAccent textAccent;
    private final Color textAccentColor;
    private final Color lootbeamColor;
    private final FontType fontType;
    private final Color menuTextColor;

    public DisplayConfig(Color textColor) {
        this.textColor = textColor;
        backgroundColor = null;
        borderColor = null;
        hidden = false;
        showLootbeam = false;
        showValue = false;
        showDespawn = false;
        notify = false;
        textAccent = null;
        textAccentColor = null;
        lootbeamColor = null;
        fontType = null;
        menuTextColor = null;
    }

    public Color getLootbeamColor() {
        return lootbeamColor != null ? lootbeamColor : textColor;
    }

    public Color getTextColor() {
        return textColor != null ? textColor : Color.WHITE;
    }

    public Color getMenuTextColor() {
        if (isHidden()) {
            return DEFAULT_MENU_TEXT_COLOR;
        }
        if (menuTextColor != null) {
            return menuTextColor;
        }
        return textColor != null && !textColor.equals(Color.WHITE) ? textColor : DEFAULT_MENU_TEXT_COLOR;
    }

    public Font getFont() {
        if (fontType == null || fontType == FontType.NORMAL) {
            return FontManager.getRunescapeSmallFont();
        }
        return FontManager.getRunescapeFont();
    }

    public boolean isHidden() { return hidden != null && hidden; }
    public boolean isShowLootbeam() { return !isHidden() && showLootbeam != null && showLootbeam; }
    public boolean isShowValue() { return showValue != null && showValue; }
    public boolean isShowDespawn() { return showDespawn != null && showDespawn; }
    public boolean isNotify() { return !isHidden() && notify != null && notify; }

    public DisplayConfig merge(DisplayConfig other) {
        var b = toBuilder();
        if (other.textColor != null) { b.textColor(other.textColor); }
        if (other.backgroundColor != null) { b.backgroundColor(other.backgroundColor); }
        if (other.borderColor != null) { b.borderColor(other.borderColor); }
        if (other.hidden != null) { b.hidden(other.hidden); }
        if (other.showLootbeam != null) { b.showLootbeam(other.showLootbeam); }
        if (other.showValue != null) { b.showValue(other.showValue); }
        if (other.showDespawn != null) { b.showDespawn(other.showDespawn); }
        if (other.notify != null) { b.notify(other.notify); }
        if (other.textAccent != null) { b.textAccent(other.textAccent); }
        if (other.textAccentColor != null) { b.textAccentColor(other.textAccentColor); }
        if (other.lootbeamColor != null) { b.lootbeamColor(other.lootbeamColor); }
        if (other.fontType != null) { b.fontType(other.fontType); }
        if (other.menuTextColor != null) { b.menuTextColor(other.menuTextColor); }
        return b.build();
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString(callSuper = true)
public class ItemQuantityRule extends ComparatorRule {
    public ItemQuantityRule(int value, Comparator cmp) {
        super("item_quantity", value, cmp);
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, TileItem item) {
        return item.getQuantity();
    }
}

package com.lootfilters.rule;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ValueTier {
    NONE("none"),
    INSANE("insane"),
    HIGH("high"),
    MEDIUM("medium"),
    LOW("low");

    private final String name;

    @Override
    public String toString() {
        return name;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemNameRule extends Rule {
    private final List<String> names;

    public ItemNameRule(List<String> names) {
        super("item_name");
        this.names = names;
    }

    public ItemNameRule(String name) {
        super("item_name");
        this.names = List.of(name);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        var itemName = plugin.getItemName(item.getId());
        return names.stream().anyMatch(it -> test(itemName, it));
    }

    private boolean test(String name, String target) {
        if (target.startsWith("*")) {
            return name.toLowerCase().endsWith(target.toLowerCase().substring(1));
        } else if (target.endsWith("*")) {
            return name.toLowerCase().startsWith(target.toLowerCase().substring(0, target.length() - 1));
        }
        return name.equalsIgnoreCase(target);
    }
}

package com.lootfilters.rule;

import com.lootfilters.lang.ParseException;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TextAccent {
    USE_FILTER("use filter"),
    SHADOW("shadow"),
    OUTLINE("outline"),
    NONE("none");

    private final String value;

    public static TextAccent fromOrdinal(int o) {
        switch (o) {
            case 1: return SHADOW;
            case 2: return OUTLINE;
            case 3: return NONE;
            default: throw new ParseException("unrecognized TextAccent ordinal " + o);
        }
    }

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
@ToString
public class OrRule extends Rule {
    private final List<Rule> rules;

    public OrRule(List<Rule> rules) {
        super("or");
        this.rules = rules;
    }

    public OrRule(Rule left, Rule right) {
        super("or");
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return rules.stream().anyMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.rule;

import com.lootfilters.lang.ParseException;
import com.lootfilters.lang.Token;

public enum Comparator {
    GT, LT, EQ, GT_EQ, LT_EQ;

    public static Comparator fromToken(Token t) {
        switch (t.getType()) {
            case OP_GT: return GT;
            case OP_LT: return LT;
            case OP_EQ: return EQ;
            case OP_GTEQ: return GT_EQ;
            case OP_LTEQ: return LT_EQ;
            default:
                throw new ParseException("unrecognized token", t);
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import net.runelite.api.TileItem;

public abstract class Rule {
    protected final String discriminator; // serde discriminator

    protected Rule(String discriminator) {
        this.discriminator = discriminator;
    }

    public abstract boolean test(LootFiltersPlugin plugin, TileItem item);
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemNotedRule extends Rule {
    private final boolean target;

    public ItemNotedRule(boolean target) {
        super("item_noted");
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        var comp = plugin.getItemManager().getItemComposition(item.getId());

        boolean isNote = comp.getNote() != -1;
        return target == isNote;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.ItemID;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemStackableRule extends Rule {
    private final boolean target;

    public ItemStackableRule(boolean target) {
        super("item_stackable");
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        var comp = plugin.getItemManager().getItemComposition(item.getId());

        return target == comp.isStackable();
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.ToString;
import net.runelite.api.TileItem;

@ToString
public abstract class ComparatorRule extends Rule {
    private final int rhs;
    private final Comparator cmp;

    protected ComparatorRule(String discriminator, int rhs, Comparator cmp) {
        super(discriminator);
        this.rhs = rhs;
        this.cmp = cmp;
    }

    @Override
    public final boolean test(LootFiltersPlugin plugin, TileItem item) {
        var lhs = getLhs(plugin, item);
        switch (cmp) {
            case GT:
                return lhs > rhs;
            case LT:
                return lhs < rhs;
            case EQ:
                return lhs == rhs;
            case GT_EQ:
                return lhs >= rhs;
            case LT_EQ:
                return lhs <= rhs;
        }
        return false;
    }

    public abstract int getLhs(LootFiltersPlugin plugin, TileItem item);
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.ItemID;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString(callSuper = true)
public class ItemValueRule extends ComparatorRule {
    public ItemValueRule(int value, Comparator cmp) {
       super("item_value", value, cmp);
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, TileItem item) {
        switch (item.getId()) {
            case ItemID.COINS_995:
                return item.getQuantity();
            case ItemID.PLATINUM_TOKEN:
                return item.getQuantity() * 1000;
            default:
                return getValue(plugin, item) * item.getQuantity();
        }
    }

    private int getValue(LootFiltersPlugin plugin, TileItem item) {
        var ge = plugin.getItemManager().getItemPrice(item.getId());
        var ha = plugin.getItemManager().getItemComposition(item.getId()).getHaPrice();
        switch (plugin.getConfig().valueType()) {
            case HIGHEST: return Math.max(ge, ha);
            case GE: return ge;
            default: return ha;
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString
public class NotRule extends Rule {
    private final Rule inner;

    public NotRule(Rule inner) {
        super("not");

        this.inner = inner;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return !inner.test(plugin, item);
    }
}

package com.lootfilters.rule;

import com.lootfilters.lang.ParseException;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum FontType {
    USE_FILTER("use filter"),
    NORMAL("normal"),
    LARGER("larger");

    private final String value;

    public static FontType fromOrdinal(int o) {
        switch (o) {
            case 1: return NORMAL;
            case 2: return LARGER;
            default: throw new ParseException("unrecognized FontType ordinal " + o);
        }
    }

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import net.runelite.api.TileItem;

@Getter
@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemIdRule extends Rule {
    private final int id;

    public ItemIdRule(int id) {
        super("item_id");
        this.id = id;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return item.getId() == id;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.ItemID;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemTradeableRule extends Rule {
    private final boolean target;

    public ItemTradeableRule(boolean target) {
        super("item_tradeable");
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        if (item.getId() == ItemID.COINS_995 || item.getId() == ItemID.PLATINUM_TOKEN) {
            return target;
        }

        var comp = plugin.getItemManager().getItemComposition(item.getId());
        var linkedComp = plugin.getItemManager().getItemComposition(comp.getLinkedNoteId());
        return target
                ? comp.isTradeable() || linkedComp.isTradeable()
                : !comp.isTradeable() && !linkedComp.isTradeable();
    }
}

package com.lootfilters.rule;

public enum ValueType {
    HIGHEST, GE, HA;

    @Override
    public String toString() {
        switch (this) {
            case HIGHEST: return "highest";
            case GE: return "grand exchange";
            default: return "high alchemy";
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import net.runelite.api.TileItem;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
@ToString
public class AndRule extends Rule {
    private final List<Rule> rules;

    public AndRule(List<Rule> rules) {
        super("and");
        this.rules = rules;
    }

    public AndRule(Rule left, Rule right) {
        super("and");
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return rules.stream().allMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.lang;

public class TokenizeException extends CompileException {
    public TokenizeException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.Value;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;

@Value
@RequiredArgsConstructor
public class Token {
    public enum Type {
        WHITESPACE, NEWLINE,
        IF, APPLY,
        META,
        COLON, COMMA,
        TRUE, FALSE,
        IDENTIFIER,
        LITERAL_INT, LITERAL_STRING,
        ASSIGN,
        OP_EQ, OP_GT, OP_LT, OP_GTEQ, OP_LTEQ, OP_AND, OP_OR, OP_NOT,
        EXPR_START, EXPR_END,
        BLOCK_START, BLOCK_END,
        LIST_START, LIST_END,
        STMT_END,
        PREPROC_DEFINE,
        COMMENT,
    }

    public static Token intLiteral(String value) { return new Token(Type.LITERAL_INT, value); }
    public static Token stringLiteral(String value) { return new Token(Type.LITERAL_STRING, value); }
    public static Token identifier(String value) { return new Token(Type.IDENTIFIER, value); }

    Type type;
    String value;

    public boolean is(Type type) {
        return this.type == type;
    }

    public int expectInt() {
        if (type != Type.LITERAL_INT) {
            throw new ParseException("unexpected non-int token", this);
        }
        return Integer.parseInt(value.replace("_", ""));
    }

    public String expectString() {
        if (type != Type.LITERAL_STRING) {
            throw new ParseException("unexpected non-string token", this);
        }
        return value;
    }

    public Color expectColor() {
        if (type != Type.LITERAL_STRING) {
            throw new ParseException("unexpected non-string token", this);
        }

        var color = ColorUtil.fromHex(value);
        if (color == null) {
            throw new ParseException("unexpected non-color string", this);
        }
        return color;
    }

    public boolean expectBoolean() {
        switch (type) {
            case TRUE: return true;
            case FALSE: return false;
            default:
                throw new ParseException("unexpected non-boolean token", this);
        }
    }

    public boolean isWhitespace() {
        return type == Type.WHITESPACE || type == Type.NEWLINE;
    }

    public boolean isSemantic() {
        return type != Type.COMMENT && !isWhitespace();
    }

    @Override
    public String toString() {
        var str = "Token{type=" + type;
        return value != null && value.isEmpty()
                ? str + "}"
                : str + ",value=" + value + "}";
    }
}

package com.lootfilters.lang;

import lombok.Getter;

@Getter
public class ParseException extends CompileException {
    private final Token token;

    public ParseException(String message, Token token) {
        super(message + " (token=" + token + ")");
        this.token = token;
    }

    public ParseException(String message) {
        super(message);
        this.token = null;
    }
}

package com.lootfilters.lang;

public class PreprocessException extends CompileException {
    public PreprocessException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import com.lootfilters.LootFilter;
import lombok.Getter;

import java.io.IOException;
import java.io.InputStream;

import static com.lootfilters.util.TextUtil.normalizeCrlf;

public class Sources {
    @Getter private static String preamble;
    @Getter private static String referenceSource;

    @Getter private static LootFilter referenceFilter;

    private Sources() {}

    static {
        try (
            var preambleStream = Sources.class.getResourceAsStream("/com/lootfilters/scripts/preamble.rs2f");
            var referenceSourceStream = Sources.class.getResourceAsStream("/com/lootfilters/scripts/filterscape.rs2f");
        ) {
            preamble = loadScriptResource(preambleStream);
            referenceSource = loadScriptResource(referenceSourceStream);

            referenceFilter = LootFilter.fromSource(referenceSource);
        } catch (IOException e) {
            throw new RuntimeException("init static sources", e);
        } catch (CompileException e) {
            throw new RuntimeException("init static filters", e);
        }
    }

    private static String loadScriptResource(InputStream in) throws IOException {
        return normalizeCrlf(new String(in.readAllBytes()));
    }
}
package com.lootfilters.lang;

import com.lootfilters.DisplayConfig;
import com.lootfilters.LootFilter;
import com.lootfilters.MatcherConfig;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.FontType;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemNotedRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemStackableRule;
import com.lootfilters.rule.ItemTradeableRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.NotRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import com.lootfilters.rule.TextAccent;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import static com.lootfilters.lang.Token.Type.APPLY;
import static com.lootfilters.lang.Token.Type.ASSIGN;
import static com.lootfilters.lang.Token.Type.BLOCK_END;
import static com.lootfilters.lang.Token.Type.BLOCK_START;
import static com.lootfilters.lang.Token.Type.COLON;
import static com.lootfilters.lang.Token.Type.COMMA;
import static com.lootfilters.lang.Token.Type.EXPR_END;
import static com.lootfilters.lang.Token.Type.EXPR_START;
import static com.lootfilters.lang.Token.Type.IDENTIFIER;
import static com.lootfilters.lang.Token.Type.IF;
import static com.lootfilters.lang.Token.Type.LIST_END;
import static com.lootfilters.lang.Token.Type.LIST_START;
import static com.lootfilters.lang.Token.Type.LITERAL_INT;
import static com.lootfilters.lang.Token.Type.LITERAL_STRING;
import static com.lootfilters.lang.Token.Type.META;
import static com.lootfilters.lang.Token.Type.OP_AND;
import static com.lootfilters.lang.Token.Type.OP_NOT;
import static com.lootfilters.lang.Token.Type.OP_OR;
import static com.lootfilters.lang.Token.Type.STMT_END;

// Parser somewhat mixes canonical stages 2 (parse) and 3/4 (syntax/semantic analysis) but the filter language is
// restricted enough that it should be fine for now.
public class Parser {
    private final TokenStream tokens;
    private final List<MatcherConfig> matchers = new ArrayList<>();

    private String name;
    private String description;
    private int[] activationArea = null;

    public Parser(List<Token> tokens) {
        this.tokens = new TokenStream(tokens);
    }

    public LootFilter parse() throws ParseException {
        while (tokens.isNotEmpty()) {
            var tok = tokens.take();
            if (tok.is(META)) {
                parseMeta();
            } else if (tok.is(IF)) {
                parseMatcher(true);
            } else if (tok.is(APPLY)) {
                parseMatcher(false);
            } else {
                throw new ParseException("unexpected token", tok);
            }
        }
        return new LootFilter(name, description, activationArea, matchers);
    }

    private void parseMeta() {
        var block = tokens.take(BLOCK_START, BLOCK_END);
        while (block.isNotEmpty()) {
            var tok = block.takeExpect(IDENTIFIER);
            block.takeExpect(ASSIGN);
            switch (tok.getValue()) {
                case "name":
                    name = block.takeExpectLiteral().expectString();
                    block.takeExpect(STMT_END);
                    break;
                case "description":
                    description = block.takeExpectLiteral().expectString();
                    block.takeExpect(STMT_END);
                    break;
                case "area":
                    block.takeExpect(LIST_START);
                    int x0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int x1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z1 = block.takeExpectLiteral().expectInt(); block.takeOptional(COMMA);
                    block.takeExpect(LIST_END);
                    block.takeExpect(STMT_END);

                    activationArea = new int[]{x0,y0,z0,x1,y1,z1};
                    break;
                default:
                    throw new ParseException("unrecognized metavalue", tok);
            }
        }
    }

    private void parseMatcher(boolean isTerminal) {
        var operators = new Stack<Token>();
        var rulesPostfix = new ArrayList<Rule>();
        tokens.walkExpression(EXPR_START, EXPR_END, it -> {
            if (it.is(EXPR_START)) {
                operators.push(it);
            } else if (it.is(EXPR_END)) {
                while (!operators.isEmpty() && !operators.peek().is(EXPR_START)) {
                    var op = operators.pop();
                    if (op.is(OP_AND)) {
                        rulesPostfix.add(new AndRule(null));
                    } else if (op.is(OP_OR)) {
                        rulesPostfix.add(new OrRule(null));
                    } else if (op.is(OP_NOT)) {
                        rulesPostfix.add(new NotRule(null));
                    }
                }
            } else if (it.is(OP_AND)) {
                operators.push(it);
            } else if (it.is(OP_OR)) {
                while (!operators.isEmpty() && operators.peek().is(OP_AND)) {
                    operators.pop();
                    rulesPostfix.add(new AndRule(null));
                }
                operators.push(it);
            } else if (it.is(OP_NOT)) {
                operators.push(it);
            } else if (it.is(IDENTIFIER)) {
                rulesPostfix.add(parseRule(it));
            } else {
                throw new ParseException("unexpected token in expression", it);
            }
        });

        while (!operators.isEmpty()) { // is this necessary? since parenthesis around overall expr are guaranteed
            var op = operators.pop();
            if (op.is(OP_AND)) {
                rulesPostfix.add(new AndRule(null));
            } else if (op.is(OP_OR)) {
                rulesPostfix.add(new OrRule(null));
            } else if (op.is(OP_NOT)) {
                rulesPostfix.add(new NotRule(null));
            }
        }

        // rule expression MUST be followed by block w/ display config assignments
        tokens.takeExpect(BLOCK_START);
        var builder = DisplayConfig.builder();
        while (!tokens.peek().is(BLOCK_END)) { // TokenStream.traverseBlock?
            var assign = parseAssignment();
            switch (assign[0].getValue()) {
                case "textColor":
                case "color":
                    builder.textColor(assign[1].expectColor()); break;
                case "backgroundColor":
                    builder.backgroundColor(assign[1].expectColor()); break;
                case "borderColor":
                    builder.borderColor(assign[1].expectColor()); break;
                case "hidden":
                    builder.hidden(assign[1].expectBoolean()); break;
                case "showLootbeam":
                case "showLootBeam":
                    builder.showLootbeam(assign[1].expectBoolean()); break;
                case "showValue":
                    builder.showValue(assign[1].expectBoolean()); break;
                case "showDespawn":
                    builder.showDespawn(assign[1].expectBoolean()); break;
                case "notify":
                    builder.notify(assign[1].expectBoolean()); break;
                case "textAccent":
                    builder.textAccent(TextAccent.fromOrdinal(assign[1].expectInt())); break;
                case "textAccentColor":
                    builder.textAccentColor(assign[1].expectColor()); break;
                case "lootbeamColor":
                case "lootBeamColor":
                    builder.lootbeamColor(assign[1].expectColor()); break;
                case "fontType":
                    builder.fontType(FontType.fromOrdinal(assign[1].expectInt())); break;
                case "menuTextColor":
                    builder.menuTextColor(assign[1].expectColor()); break;
                default:
                    throw new ParseException("unexpected identifier in display config block", assign[0]);
            }
        }
        tokens.takeExpect(BLOCK_END);

        matchers.add(new MatcherConfig(buildRule(rulesPostfix), builder.build(), isTerminal));
    }

    private Rule parseRule(Token first) {
        tokens.takeExpect(COLON); // grammar is always <id><colon><...>
        switch (first.getValue()) {
            case "id":
                return parseItemIdRule();
            case "name":
                return parseItemNameRule();
            case "quantity":
                return parseItemQuantityRule();
            case "value":
                return parseItemValueRule();
            case "tradeable":
                return parseItemTradeableRule();
            case "stackable":
                return parseItemStackableRule();
            case "noted":
                return parseItemNotedRule();
            default:
                throw new ParseException("unknown rule identifier", first);
        }
    }

    private ItemIdRule parseItemIdRule() {
        var id = tokens.takeExpect(LITERAL_INT);
        return new ItemIdRule(id.expectInt());
    }

    private Rule parseItemNameRule() {
        if (tokens.peek().is(LITERAL_STRING)) {
            return new ItemNameRule(tokens.take().expectString());
        } else if (tokens.peek().is(LIST_START)) {
            var block = tokens.take(LIST_START, LIST_END, true);
            return new ItemNameRule(block.expectStringList());
        } else {
            throw new ParseException("parse item name: unexpected argument token", tokens.peek());
        }
    }

    private ItemQuantityRule parseItemQuantityRule() {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemQuantityRule(value.expectInt(), Comparator.fromToken(op));
    }

    private ItemValueRule parseItemValueRule() {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemValueRule(value.expectInt(), Comparator.fromToken(op));
    }

    private ItemTradeableRule parseItemTradeableRule() {
        var op = tokens.take();
        return new ItemTradeableRule((op.expectBoolean()));
    }

    private ItemStackableRule parseItemStackableRule() {
        var op = tokens.take();
        return new ItemStackableRule((op.expectBoolean()));
    }

    private ItemNotedRule parseItemNotedRule() {
        var op = tokens.take();
        return new ItemNotedRule((op.expectBoolean()));
    }

    private Rule buildRule(List<Rule> postfix) {
        var operands = new Stack<Rule>();
        for (var rule : postfix) {
            if (rule instanceof ItemIdRule
                    || rule instanceof ItemNameRule
                    || rule instanceof ItemQuantityRule
                    || rule instanceof ItemValueRule
                    || rule instanceof ItemTradeableRule
                    || rule instanceof ItemStackableRule
                    || rule instanceof ItemNotedRule) {
                operands.push(rule);
            } else if (rule instanceof AndRule) {
                operands.push(new AndRule(operands.pop(), operands.pop()));
            } else if (rule instanceof OrRule) {
                operands.push(new OrRule(operands.pop(), operands.pop()));
            } else if (rule instanceof NotRule) {
                operands.push(new NotRule(operands.pop()));
            }
        }

        if (operands.size() != 1) {
            throw new ParseException("invalid rule postfix");
        }
        return operands.pop();
    }

    private Token[] parseAssignment() { // assignments do not support nested expressions, making this trivial
        var ident = tokens.takeExpect(IDENTIFIER);
        tokens.takeExpect(ASSIGN);
        var value = tokens.takeExpectLiteral();
        tokens.takeExpect(STMT_END);
        return new Token[]{ident, value};
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.function.Consumer;

/**
 * TokenStream wraps a list of Tokens to expose retrieval APIs suitable for parsing.
 */
@AllArgsConstructor
public class TokenStream {
    private final List<Token> tokens;

    /**
     * Returns a shallow copy of the token stream.
     */
    public List<Token> getTokens() {
        return new ArrayList<>(tokens);
    }

    /**
     * Peek at the first token in the stream, ignoring whitespace, without consuming it.
     */
    public Token peek() {
        return tokens.stream()
                .filter(Token::isSemantic)
                .findFirst()
                .orElse(null);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace.
     */
    public Token take(boolean includeWhitespace) {
        while (isNotEmpty()) {
            var next = tokens.remove(0);
            if (next.isSemantic() || includeWhitespace && next.isWhitespace()) {
                return next;
            }
        }
        return null;
    }

    /**
     * Consume the first non-whitespace token in the stream.
     */
    public Token take() {
        return take(false);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace, while asserting that it is of the given
     * type.
     */
    public Token takeExpect(Token.Type expect, boolean includeWhitespace) {
        if (tokens.isEmpty()) {
            throw new ParseException("unexpected end of token stream");
        }

        var first = take(includeWhitespace);
        if (!first.is(expect)) {
            throw new ParseException("unexpected non-" + expect + " token", first);
        }
        return first;
    }

    /**
     * Consume the first non-whitespace token in the stream while asserting that it is of the given type.
     */
    public Token takeExpect(Token.Type expect) {
        return takeExpect(expect, false);
    }

    /**
     * Consumes the first non-whitespace token at the head of the stream, asserting that it is any one of the literal
     * types (int, string, boolean).
     */
    public Token takeExpectLiteral() {
        var first = take();
        if (!first.is(Token.Type.LITERAL_INT)
                && !first.is(Token.Type.LITERAL_STRING)
                && !first.is(Token.Type.TRUE)
                && !first.is(Token.Type.FALSE)) {
            throw new ParseException("unexpected non-literal token", first);
        }
        return first;
    }

    /**
     * Take a complete line from the stream, preserving whitespace, and EXCLUDING the newline at the end, which is
     * discarded.
     */
    public List<Token> takeLine() {
        var line = new ArrayList<Token>();
        while (!tokens.isEmpty()) {
            var next = tokens.remove(0);
            if (next.is(Token.Type.NEWLINE)) {
                return line;
            }
            line.add(next);
        }
        return line;
    }

    /**
     * Consumes a token of the expected type if it's at the head of the stream, doing nothing otherwise.
     */
    public void takeOptional(Token.Type type) {
        if (peek().is(type)) {
            take();
        }
    }

    /**
     * Traverse an expression enclosed by the given start and end tokens at the head of the stream.
     * The traversal will verify that the expression in the stream is balanced. The caller can and most likely will
     * still maintain their own operator stack, but it won't require balance checks.
     * Callers MAY consume any number of tokens from the front of the stream, as long as they do not remove enclosing
     * tokens in a manner that would disrupt the balance check.
     * The consumer will be invoked with both the starting and ending enclosing tokens.
     */
    public void walkExpression(Token.Type start, Token.Type end, Consumer<Token> consumer) {
        var state = new Stack<Token>();
        if (!peek().is(start)) {
            throw new ParseException("unexpected start of expression", peek());
        }

        while (isNotEmpty()) {
            var next = take();
            if (next.is(start)) {
                state.push(next);
            } else if (next.is(end)) {
                if (!state.isEmpty()) {
                    state.pop();
                } else {
                    throw new ParseException("unbalanced expression");
                }
            }

            consumer.accept(next);
            if (state.isEmpty()) { // balanced expression
                return;
            }
        }
        if (!state.isEmpty()) {
            throw new ParseException("unbalanced expression");
        }
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, optionally including those
     * enclosing tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end, boolean preserveEnclosing) {
        var inner = new ArrayList<Token>();
        walkExpression(start, end, inner::add);
        if (!preserveEnclosing) {
            inner.remove(0);
            inner.remove(inner.size() - 1);
        }
        return new TokenStream(inner);
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, IGNORING those enclosing
     * tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end) {
        return take(start, end, false);
    }

    /**
     * Consumes an argument list at the head of the stream matching the grammar ( expr0, expr1, <...> exprN [,] ).
     */
    public List<TokenStream> takeArgList() {
        var args = new ArrayList<TokenStream>();
        var current = new ArrayList<Token>();
        var expr = take(Token.Type.EXPR_START, Token.Type.EXPR_END);
        while (expr.isNotEmpty()) {
            var head = expr.peek();
            if (head.is(Token.Type.COMMA)) {
                if (current.isEmpty()) {
                    throw new ParseException("empty argument");
                } else {
                    args.add(new TokenStream(current));
                    current = new ArrayList<>();
                    expr.take();
                }
            } else if (head.is(Token.Type.EXPR_START)) {
                var nestedExpr = expr.take(Token.Type.EXPR_START, Token.Type.EXPR_END, true);
                current.addAll(nestedExpr.getTokens());
            } else {
                current.add(expr.take());
            }
        }

        if (!current.isEmpty()) {
            args.add(new TokenStream(current));
        }
        return args;
    }

    /**
     * Attempt to parse the entire token stream as a list of strings.
     */
    public List<String> expectStringList() {
        var strings = new ArrayList<String>();

        takeExpect(Token.Type.LIST_START);
        while (isNotEmpty()) {
            if (peek().is(Token.Type.LIST_END)) {
                return strings;
            }

            strings.add(take().expectString());
            if (peek().is(Token.Type.COMMA)) {
                take();
            } else if (peek().is(Token.Type.LIST_END)) {
                take();
                break;
            } else {
                throw new ParseException("unexpected token in list", peek());
            }
        }
        if (isNotEmpty()) {
            throw new ParseException("unterminated list");
        }

        return strings;
    }

    public boolean isNotEmpty() { // this doesn't _currently_ need a version that checks non-semantic
        return tokens.stream().anyMatch(Token::isSemantic);
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.lootfilters.util.CollectionUtil.append;
import static com.lootfilters.util.TextUtil.normalizeCrlf;
import static com.lootfilters.util.TextUtil.quote;

public class Preprocessor {
    private final TokenStream tokens;

    private final Map<String, Define> defines = new HashMap<>();
    private final List<Token> preproc = new ArrayList<>(); // pre-expansion w/ all preproc lines removed

    public Preprocessor(String input) {
        input = normalizeCrlf(input);
        this.tokens = new TokenStream(new Lexer(input).tokenize());
    }

    public String preprocess() throws PreprocessException {
        while (tokens.isNotEmpty()) {
            var next = tokens.take(true);
            if (next.is(Token.Type.PREPROC_DEFINE)) {
                parseDefine();
            } else {
                preproc.add(next);
                if (!next.is(Token.Type.NEWLINE)) {
                    preproc.addAll(tokens.takeLine());
                    preproc.add(new Token(Token.Type.NEWLINE, "\n"));
                }
            }
        }

        return expandDefines(new ArrayList<>(), new TokenStream(preproc)).stream()
                .map(it -> it.is(Token.Type.LITERAL_STRING) ? quote(it.getValue()) : it.getValue())
                .collect(Collectors.joining(""))
                .trim();
    }

    private void parseDefine() {
        var name = tokens.takeExpect(Token.Type.IDENTIFIER).getValue();
        var params = tokens.peek().is(Token.Type.EXPR_START)
                ? parseDefineParams() : null;
        if (params != null && params.isEmpty()) {
            throw new PreprocessException("#define " + quote(name) + " has empty param list");
        }
        tokens.takeExpect(Token.Type.WHITESPACE, true);
        defines.put(name, new Define(name, params, tokens.takeLine()));
    }

    private List<String> parseDefineParams() {
        var params = new ArrayList<String>();
        tokens.takeExpect(Token.Type.EXPR_START);
        while (tokens.isNotEmpty()) {
            var next = tokens.take();
            if (next.is(Token.Type.EXPR_END)) {
                return params;
            } else if (next.is(Token.Type.IDENTIFIER)) {
                params.add(next.getValue());
                tokens.takeOptional(Token.Type.COMMA);
            } else {
                throw new PreprocessException("unterminated define param list");
            }
        }
        throw new PreprocessException("unterminated define param list");
    }

    private List<Token> expandDefines(List<String> visited, TokenStream tokens) {
        var postproc = new ArrayList<Token>();
        while (tokens.isNotEmpty()) {
            var token = tokens.take(true);
            if (!visited.contains(token.getValue()) && token.is(Token.Type.IDENTIFIER) && defines.containsKey(token.getValue())) {
                var define = defines.get(token.getValue());
                if (define.isParameterized()) {
                    var args = tokens.takeArgList();
                    postproc.addAll(expandParameterizedDefine(append(visited, define.name), define, args));
                } else {
                    var defineTokens = new TokenStream(new ArrayList<>(define.value));
                    postproc.addAll(expandDefines(append(visited, define.name), defineTokens));
                }
            } else {
                postproc.add(token);
            }
        }
        return postproc;
    }

    private List<Token> expandParameterizedDefine(List<String> visited, Define define, List<TokenStream> args) {
        var expanded = new ArrayList<Token>();
        for (var token : define.value) {
            if (!token.is(Token.Type.IDENTIFIER) || token.getValue().equals(define.name)) {
                expanded.add(token);
                continue;
            }

            var paramIndex = -1;
            for (var i = 0; i < define.params.size(); ++i) {
                if (define.params.get(i).equals(token.getValue())) {
                    paramIndex = i;
                    break;
                }
            }
            if (paramIndex > -1) {
                var arg = args.get(paramIndex);
                expanded.addAll(arg.getTokens());
            } else {
                expanded.add(token);
            }
        }
        return expandDefines(visited, new TokenStream(expanded));
    }

    @AllArgsConstructor
    private static class Define {
       final String name;
       final List<String> params;
       final List<Token> value;

       boolean isParameterized() {
           return params != null;
       }
    }
}

package com.lootfilters.lang;

public class CompileException extends RuntimeException {
    public CompileException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.isLegalIdent;
import static com.lootfilters.util.TextUtil.isNumeric;
import static com.lootfilters.util.TextUtil.isWhitespace;

@RequiredArgsConstructor
public class Lexer {
    private static final LinkedHashMap<String, Token.Type> STATICS = new LinkedHashMap<>() {{
        put("\\\n", Token.Type.WHITESPACE);
        put("#define", Token.Type.PREPROC_DEFINE);
        put("apply", Token.Type.APPLY);
        put("false", Token.Type.FALSE);
        put("true", Token.Type.TRUE);
        put("meta", Token.Type.META);
        put("if", Token.Type.IF);
        put("&&", Token.Type.OP_AND);
        put("||", Token.Type.OP_OR);
        put(">=", Token.Type.OP_GTEQ);
        put("<=", Token.Type.OP_LTEQ);
        put("==", Token.Type.OP_EQ);
        put("!", Token.Type.OP_NOT);
        put(">", Token.Type.OP_GT);
        put("<", Token.Type.OP_LT);
        put(";", Token.Type.STMT_END);
        put(":", Token.Type.COLON);
        put("=", Token.Type.ASSIGN);
        put(",", Token.Type.COMMA);
        put("(", Token.Type.EXPR_START);
        put(")", Token.Type.EXPR_END);
        put("{", Token.Type.BLOCK_START);
        put("}", Token.Type.BLOCK_END);
        put("[", Token.Type.LIST_START);
        put("]", Token.Type.LIST_END);
        put("\n", Token.Type.NEWLINE);
        put("\r", Token.Type.NEWLINE);
    }};

    private final String input;
    private final List<Token> tokens = new ArrayList<>();
    private int offset = 0;

    public List<Token> tokenize() throws TokenizeException {
        while (offset < input.length()) {
            if (tokenizeStatic()) {
                continue;
            }
            if (tokenizeComment()) {
                continue;
            }

            var ch = input.charAt(offset);
            if (isWhitespace(ch)) {
                tokenizeWhitespace();
            } else if (isNumeric(ch)) {
                tokenizeLiteralInt();
            } else if (ch == '"') {
                tokenizeLiteralString();
            } else if (isLegalIdent(ch)) {
                tokenizeIdentifier();
            } else {
                throw new TokenizeException("unrecognized character '" + ch + "'");
            }
        }

        return tokens.stream() // un-map escaped newlines
                .map(it -> it.getValue().equals("\\\n") ? new Token(Token.Type.WHITESPACE, "") : it)
                .collect(Collectors.toList());
    }

    private boolean tokenizeStatic() {
        for (var entry : STATICS.entrySet()) {
            var value = entry.getKey();
            var type = entry.getValue();
            if (input.startsWith(value, offset)) {
                tokens.add(new Token(type, value));
                offset += value.length();
                return true;
            }
        }
        return false;
    }

    private boolean tokenizeComment() {
        if (!input.startsWith("//", offset)) {
            return false;
        }

        var lineEnd = input.indexOf('\n', offset);
        var text = lineEnd > -1
                ? input.substring(offset, lineEnd)
                : input.substring(offset);
        tokens.add(new Token(Token.Type.COMMENT, text));
        offset += text.length();
        return true;
    }

    private void tokenizeWhitespace() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isWhitespace(input.charAt(i))) {
                var ws = input.substring(offset, i);
                tokens.add(new Token(Token.Type.WHITESPACE, ws));
                offset += i - offset;
                return;
            }
        }
        tokens.add(new Token(Token.Type.WHITESPACE, input.substring(offset)));
        offset = input.length();
    }

    private void tokenizeLiteralInt() {
        for (int i = offset; i < input.length(); ++i) {
            if (input.charAt(i) == '_') {
                continue;
            }
            if (!isNumeric(input.charAt(i))) {
                var literal = input.substring(offset, i);
                tokens.add(Token.intLiteral(literal));
                offset += literal.length();
                return;
            }
        }
        tokens.add(Token.intLiteral(input.substring(offset)));
        offset = input.length();
    }

    private void tokenizeLiteralString() throws TokenizeException {
        for (int i = offset+1; i < input.length(); ++i) {
            if (input.charAt(i) == '"') {
                var literal = input.substring(offset+1, i);
                tokens.add(Token.stringLiteral(literal));
                offset += literal.length() + 2; // for quotes, which the captured literal omits
                return;
            }
        }
        throw new TokenizeException("unterminated string literal");
    }

    private void tokenizeIdentifier() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isLegalIdent(input.charAt(i))) {
                var ident = input.substring(offset, i);
                tokens.add(Token.identifier(ident));
                offset += ident.length();
                return;
            }
        }
        tokens.add(Token.identifier(input.substring(offset)));
        offset = input.length();
    }
}

package com.lootfilters.model;

import com.lootfilters.LootFiltersPlugin;
import lombok.Getter;
import net.runelite.api.Model;
import net.runelite.api.Node;
import net.runelite.api.TileItem;

import java.time.Instant;

public class PluginTileItem implements TileItem {
    private final TileItem item;
    @Getter private final int spawnTime;
    @Getter private final Instant despawnInstant;

    public PluginTileItem(LootFiltersPlugin plugin, TileItem item) {
        this.item = item;
        this.spawnTime = plugin.getClient().getTickCount();
        this.despawnInstant = Instant.now().plusMillis((getDespawnTime() - spawnTime) * 600L);
    }

    @Override
    public boolean equals(Object other) {
        return other instanceof PluginTileItem && ((PluginTileItem) other).item == item;
    }

    @Override
    public int hashCode() {
        return item.hashCode();
    }

    @Override public int getId() { return item.getId(); }
    @Override public int getQuantity() { return item.getQuantity(); }
    @Override public int getVisibleTime() { return item.getVisibleTime(); }
    @Override public int getDespawnTime() { return item.getDespawnTime(); }
    @Override public int getOwnership() { return item.getOwnership(); }
    @Override public boolean isPrivate() { return item.isPrivate(); }
    @Override public Model getModel() { return item.getModel(); }
    @Override public int getModelHeight() { return item.getModelHeight(); }
    @Override public void setModelHeight(int i) { item.setModelHeight(i); }
    @Override public Node getNext() { return item.getNext(); }
    @Override public Node getPrevious() { return item.getPrevious(); }
    @Override public long getHash() { return item.getHash(); }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum DespawnTimerType {
    TICKS("ticks"),
    SECONDS("seconds"),
    PIE("pie");

    private final String label;

    @Override
    public String toString() {
        return label;
    }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ValueDisplayType {
    HIGHEST("highest"),
    GE("grand exchange"),
    HA("high alchemy"),
    BOTH("both");

    private final String label;

    @Override public String toString() { return label; }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum DualValueDisplayType {
    COMPACT("compact"),
    VERBOSE("verbose");

    private final String label;

    @Override public String toString() { return label; }
}

package com.lootfilters;

import com.lootfilters.model.PluginTileItem;
import lombok.AllArgsConstructor;
import net.runelite.api.Tile;

import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public class LootbeamIndex {
    private final LootFiltersPlugin plugin;

    private final Map<Tile, Map<PluginTileItem, Lootbeam>> index = new HashMap<>();

    public int size() {
        return index.values().stream()
                .mapToInt(Map::size)
                .sum();
    }

    public void put(Tile tile, PluginTileItem item, Lootbeam beam) {
        if (!index.containsKey(tile)) {
            index.put(tile, new HashMap<>());
        }

        var beams = index.get(tile);
        beams.put(item, beam);
    }

    public void remove(Tile tile, PluginTileItem item) {
        if (!index.containsKey(tile)) {
            return; // what?
        }

        var beams = index.get(tile);
        if (!beams.containsKey(item)) {
            return; // what?
        }

        var beam = beams.get(item);
        beam.remove();
        beams.remove(item);
        if (beams.isEmpty()) {
            index.remove(tile);
        }
    }

    public void clear() {
        for (var beams : index.values()) {
            for (var beam : beams.values()) {
                beam.remove();
            }
        }
        index.clear();
    }

    public void reset() {
        clear();
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            for (var item : entry.getValue()) {
                var match = plugin.getActiveFilter().findMatch(plugin, item);
                if (match != null && match.isShowLootbeam()) {
                    put(tile, item, new Lootbeam(plugin.getClient(), plugin.getClientThread(), tile.getWorldLocation(),
                            match.getLootbeamColor(), Lootbeam.Style.MODERN));
                }
            }
        }
    }
}

package com.lootfilters;

import com.google.gson.Gson;
import com.lootfilters.lang.CompileException;
import com.lootfilters.lang.Lexer;
import com.lootfilters.lang.Parser;
import com.lootfilters.lang.Preprocessor;
import com.lootfilters.lang.Sources;
import com.lootfilters.rule.Rule;
import com.lootfilters.serde.ColorDeserializer;
import com.lootfilters.serde.ColorSerializer;
import com.lootfilters.serde.RuleDeserializer;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.awt.Color;
import java.util.List;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
@ToString
public class LootFilter {
    @Setter private String name; // anonymous filter can be imported, would need name

    private final String description;
    private final int[] activationArea;
    private final List<MatcherConfig> matchers;

    public static LootFilter fromJson(Gson gson, String json) {
        var ggson = gson.newBuilder()
                .registerTypeAdapter(Color.class, new ColorDeserializer())
                .registerTypeAdapter(Rule.class, new RuleDeserializer(gson))
                .create();
        return ggson.fromJson(json, LootFilter.class);
    }

    public static LootFilter fromSource(String source) throws CompileException {
        var postproc = new Preprocessor(Sources.getPreamble() + "\n" + source).preprocess();
        var tokens = new Lexer(postproc).tokenize();
        return new Parser(tokens).parse();
    }

    public String toJson(Gson gson) {
        var ggson = gson.newBuilder()
                .registerTypeAdapter(Color.class, new ColorSerializer())
                .create();
        return ggson.toJson(this);
    }

    public DisplayConfig findMatch(LootFiltersPlugin plugin, TileItem item) {
        DisplayConfig display = null;
        for (var matcher : matchers) {
            if (!matcher.getRule().test(plugin, item)) {
                continue;
            }

            if (matcher.isTerminal()) {
                return display == null
                        ? matcher.getDisplay()
                        : display.merge(matcher.getDisplay());
            } else {
                display = display == null
                        ? matcher.getDisplay()
                        : display.merge(matcher.getDisplay());
            }
        }
        return display;
    }

    public boolean isInActivationArea(WorldPoint p) {
        if (activationArea == null) {
            return false;
        }
        return p.getX() >= activationArea[0] && p.getY() >= activationArea[1] && p.getPlane() >= activationArea[2]
                && p.getX() <= activationArea[3] && p.getY() <= activationArea[4] && p.getPlane() <= activationArea[5];
    }
}

package com.lootfilters;

import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemTradeableRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import net.runelite.api.TileItem;
import net.runelite.api.Varbits;

import java.awt.Color;
import java.util.Arrays;
import java.util.stream.Collectors;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
@ToString
public class MatcherConfig {
    private final Rule rule;
    private final DisplayConfig display;
    private final boolean isTerminal;

    public MatcherConfig(Rule rule, DisplayConfig display) {
        this.rule = rule;
        this.display = display;
        this.isTerminal = true;
    }

    public static MatcherConfig ownershipFilter(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                var accountType = plugin.getClient().getVarbitValue(Varbits.ACCOUNT_TYPE);
                return enabled && accountType != 0 && item.getOwnership() == TileItem.OWNERSHIP_OTHER;
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig itemSpawnFilter(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && item.getOwnership() == TileItem.OWNERSHIP_NONE;
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig showUnmatched(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled;
            }
        };
        var display = DisplayConfig.builder()
                .textColor(Color.WHITE)
                .build();
        return new MatcherConfig(rule, display, false);
    }

    public static MatcherConfig valueTier(boolean enabled, int value, Color color, boolean showLootbeam, boolean notify) {
        var inner = new ItemValueRule(value, Comparator.GT_EQ);
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && inner.test(plugin, item);
            }
        };
        var display = DisplayConfig.builder()
                .textColor(color)
                .showLootbeam(showLootbeam)
                .notify(notify)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig hiddenTier(boolean enabled, int value, boolean showUntradeable) {
        var valueRule = new ItemValueRule(value, Comparator.LT);
        var inner = showUntradeable
                ? new AndRule(valueRule, new ItemTradeableRule(true))
                : valueRule;
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && inner.test(plugin, item);
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig highlight(String rawNames, Color color, boolean showLootbeam, boolean notify) {
        var rule = new OrRule(
                Arrays.stream(rawNames.split(","))
                        .map(ItemNameRule::new)
                        .collect(Collectors.toList())
        );
        var display = DisplayConfig.builder()
                .textColor(color)
                .showLootbeam(showLootbeam)
                .notify(notify)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig hide(String rawNames) {
        var rule = new OrRule(
                Arrays.stream(rawNames.split(","))
                        .map(ItemNameRule::new)
                        .collect(Collectors.toList())
        );
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }
}

package com.lootfilters;

import lombok.AllArgsConstructor;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.awt.Color;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.runelite.client.util.ColorUtil.colorTag;

@AllArgsConstructor
public class MenuEntryComposer {
    private final LootFiltersPlugin plugin;

    public void onMenuEntryAdded(MenuEntry entry) { // recolor/add quantity
        if (!isGroundItem(entry)) {
            return;
        }

        var item = getItemForEntry(entry);
        var match = plugin.getActiveFilter().findMatch(plugin, item);
        if (match == null) {
            return;
        }

        entry.setDeprioritized(match.isHidden());
        entry.setTarget(buildTargetText(item, match));
    }

    public void onMenuOpened() { // collapse
        var menu = plugin.getClient().getMenu();
        var entries = menu.getMenuEntries();

        var itemCounts = Stream.of(entries)
                .filter(MenuEntryComposer::isGroundItem)
                .collect(Collectors.groupingBy(MenuEntryComposer::entrySlug, Collectors.counting()));

        var newEntries = Arrays.stream(entries)
                .map(it -> isGroundItem(it)
                        ? withCount(it, itemCounts.getOrDefault(entrySlug(it), 1L))
                        : it)
                .distinct()
                .toArray(MenuEntry[]::new);
        menu.setMenuEntries(newEntries);
    }

    private MenuEntry withCount(MenuEntry entry, long count) {
        return count > 1
                ? entry.setTarget(entry.getTarget() + " x" + count)
                : entry;
    }

    private TileItem getItemForEntry(MenuEntry entry) {
        var wv = plugin.getClient().getTopLevelWorldView();
        var point = WorldPoint.fromScene(wv, entry.getParam0(), entry.getParam1(), wv.getPlane());
        return plugin.getTileItemIndex().findItem(point, entry.getIdentifier());
    }

    private String buildTargetText(TileItem item, DisplayConfig display) {
        var text = plugin.getItemName(item.getId());
        if (item.getQuantity() > 1) {
            text += " (" + item.getQuantity() + ")";
        }

        var colorTag = colorTag(display.getMenuTextColor());
        return colorTag + text;
    }

    private static boolean isGroundItem(MenuEntry entry) {
        var type = entry.getType();
        return type == MenuAction.GROUND_ITEM_FIRST_OPTION
                || type == MenuAction.GROUND_ITEM_SECOND_OPTION
                || type == MenuAction.GROUND_ITEM_THIRD_OPTION
                || type == MenuAction.GROUND_ITEM_FOURTH_OPTION
                || type == MenuAction.GROUND_ITEM_FIFTH_OPTION
                || type == MenuAction.EXAMINE_ITEM_GROUND;
    }

    private static String entrySlug(MenuEntry entry) {
        return entry.getType().toString() + entry.getIdentifier();
    }
}

package com.lootfilters;

import com.lootfilters.model.DespawnTimerType;
import com.lootfilters.model.DualValueDisplayType;
import com.lootfilters.model.ValueDisplayType;
import com.lootfilters.rule.TextAccent;
import com.lootfilters.rule.ValueTier;
import com.lootfilters.rule.ValueType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Units;

import java.awt.Color;

@ConfigGroup("loot-filters")
public interface LootFiltersConfig extends Config {
    @ConfigSection(
            name = "General",
            description = "Configure general options.",
            position = 0
    )
    String general = "general";
    @ConfigItem(
            keyName = "autoToggleFilter",
            name = "Auto-toggle active filter",
            description = "Filters can be annotated with area boundaries in which they are relevant. If enabled, filters will automatically become active when the player enters their corresponding area.",
            section = general,
            position = 0
    )
    default boolean autoToggleFilters() {
        return true;
    }
    @ConfigItem(
            keyName = "showUnmatchedItems",
            name = "Show unmatched items",
            description = "Give a default text overlay to items that don't match the active filter.",
            section = general,
            position = 1
    )
    default boolean showUnmatchedItems() { return true; }
    @ConfigItem(
            keyName = "ownershipFilter",
            name = "Ownership filter",
            description = "When enabled, filters out any items you cannot pick up. This filter overrides ALL other rules/config.",
            section = general,
            position = 3
    )
    default boolean ownershipFilter() { return false; }
    @ConfigItem(
            keyName = "itemSpawnFilter",
            name = "Item spawn filter",
            description = "When enabled, filters out item spawns (world spawns, ashes from fire, etc). This filter overrides ALL other rules/config.",
            section = general,
            position = 4
    )
    default boolean itemSpawnFilter() { return false; }
    @ConfigItem(
            keyName = "valueType",
            name = "Value type",
            description = "The type of item value to use for rules and text overlay.",
            section = general,
            position = 5
    )
    default ValueType valueType() { return ValueType.HIGHEST; }

    @ConfigSection(
            name = "Hotkey",
            description = "Configure hotkey options.",
            position = 1
    )
    String hotkey = "Hotkey";
    @ConfigItem(
            keyName = "hotkey",
            name = "Hotkey",
            description = "Hotkey used by this plugin.",
            section = hotkey,
            position = 0
    )
    default Keybind hotkey() { return Keybind.ALT; }
    @ConfigItem(
            keyName = "hotkeyShowHiddenItems",
            name = "Press: Show hidden items",
            description = "Show hidden items when hotkey is pressed.",
            section = hotkey,
            position = 1
    )
    default boolean hotkeyShowHiddenItems() { return true; }
    @ConfigItem(
            keyName = "hotkeyShowClickboxes",
            name = "Press: Show hide/highlight box",
            description = "Show hide/highlight boxes when hotkey is pressed.<p>You can still toggle hide/highlight when this is disabled with left/right/middle click over an item's overlay text.",
            section = hotkey,
            position = 2
    )
    default boolean hotkeyShowClickboxes() { return true; }
    @ConfigItem(
            keyName = "hotkeyShowValues",
            name = "Press: Show item values",
            description = "Show item values when the hotkey is pressed, even if they're otherwise disabled.",
            section = hotkey,
            position = 3
    )
    default boolean hotkeyShowValues() { return false; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapTogglesOverlay",
            name = "Double-tap: toggle overlay",
            description = "When enabled, double-tap the hotkey to toggle the entire ground items overlay.",
            section = hotkey,
            position = 12
    )
    default boolean hotkeyDoubleTapTogglesOverlay() { return true; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapDelay",
            name = "Double-tap delay",
            description = "Period within which to register a hotkey double-tap.",
            section = hotkey,
            position = 13
    )
    @Units(Units.MILLISECONDS)
    default int hotkeyDoubleTapDelay() { return 250; }

    @ConfigSection(
            name = "Display settings",
            description = "Configure global display settings/overrides.",
            position = 2
    )
    String displayOverrides = "displayOverrides";
    @ConfigItem(
            keyName = "alwaysShowValue",
            name = "Show value",
            description = "Always show item value.",
            section = displayOverrides,
            position = 0
    )
    default boolean alwaysShowValue() { return false; }
    @ConfigItem(
            keyName = "valueDisplayType",
            name = "Value display",
            description = "Which value(s) to show.",
            section = displayOverrides,
            position = 1
    )
    default ValueDisplayType valueDisplayType() { return ValueDisplayType.HIGHEST; }
    @ConfigItem(
            keyName = "dualValueDisplayType",
            name = "Dual-value display",
            description = "How to compose the display of values when display type is set to either 'highest' or 'both'.",
            section = displayOverrides,
            position = 2
    )
    default DualValueDisplayType dualValueDisplay() { return DualValueDisplayType.COMPACT; }
    @ConfigItem(
            keyName = "alwaysShowDespawn",
            name = "Show despawn",
            description = "Always show item despawn timers.",
            section = displayOverrides,
            position = 11
    )
    default boolean alwaysShowDespawn() { return false; }
    @ConfigItem(
            keyName = "despawnTimerType",
            name = "Despawn type",
            description = "Type of despawn timer to render.",
            section = displayOverrides,
            position = 12
    )
    default DespawnTimerType despawnTimerType() { return DespawnTimerType.TICKS; }
    @ConfigItem(
            keyName = "despawnThreshold",
            name = "Despawn threshold",
            description = "Number of remaining ticks until despawn at which to show the despawn timer (0 to always show).",
            section = displayOverrides,
            position = 13
    )
    @Units(Units.TICKS)
    default int despawnThreshold() { return 0; }
    @ConfigItem(
            keyName = "textAccent",
            name = "Text accent",
            description = "Text accent type.",
            section = displayOverrides,
            position = 14
    )
    default TextAccent textAccent() { return TextAccent.USE_FILTER; }

    @ConfigSection(
            name = "Item lists",
            description = "Configure default lists of highlighted and hidden items. Values are case-insensitive, separated by comma. These lists are checked BEFORE the active filter.",
            position = 8
    )
    String itemLists = "itemLists";
    @ConfigItem(
            keyName = "highlightedItems",
            name = "Highlighted items",
            description = "Configure a list of items to highlight.",
            section = itemLists,
            position = 0
    )
    default String highlightedItems() { return ""; }
    @ConfigItem(
            keyName = "hiddenItems",
            name = "Hidden items",
            description = "Configure a list of items to hide.",
            section = itemLists,
            position = 1
    )
    default String hiddenItems() { return ""; }
    @ConfigItem(keyName = "highlightedItems", name = "", description = "")
    void setHighlightedItems(String key);
    @ConfigItem(keyName = "hiddenItems", name = "", description = "")
    void setHiddenItems(String key);

    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight color",
            description = "Configures the color for highlighted items.",
            section = itemLists,
            position = 2
    )
    default Color highlightColor() { return Color.decode("#aa00ff"); }
    @ConfigItem(
            keyName = "highlightLootbeam",
            name = "Highlight lootbeam",
            description = "Configures whether highlighted items show a lootbeam.",
            section = itemLists,
            position = 3
    )
    default boolean highlightLootbeam() { return false; }
    @ConfigItem(
            keyName = "highlightNotify",
            name = "Highlight notification",
            description = "Configures whether highlighted items fire a system notification.",
            section = itemLists,
            position = 4
    )
    default boolean highlightNotify() { return false; }

    @ConfigSection(
            name = "Item value rules",
            description = "Configure default rules for showing based on item value. These rules are checked AFTER both the active filter and the global highlight/hide lists.",
            position = 9
    )
    String itemValueRules = "itemValueRules";
    @ConfigItem(
            keyName = "lootbeamTier",
            name = "Lootbeam tier",
            description = "Minimum tier at which to show a lootbeam.",
            section = itemValueRules,
            position = 0
    )
    default ValueTier lootbeamTier() { return ValueTier.HIGH; }
    @ConfigItem(
            keyName = "notifyTier",
            name = "Notification tier",
            description = "Minimum tier at which to fire a system notification.",
            section = itemValueRules,
            position = 0
    )
    default ValueTier notifyTier() { return ValueTier.HIGH; }
    @ConfigItem(
            keyName = "enableInsaneItemValueTier",
            name = "Insane tier",
            description = "Enable INSANE item value tier.",
            section = itemValueRules,
            position = 11
    )
    default boolean enableInsaneItemValueTier() { return true; }
    @ConfigItem(
            keyName = "insaneValue",
            name = "Insane value",
            description = "Configures the value for INSANE tier.",
            section = itemValueRules,
            position = 12
    )
    default int insaneValue() { return 10_000_000; }
    @ConfigItem(
            keyName = "insaneValueColor",
            name = "Insane color",
            description = "Configures the color for INSANE item values.",
            section = itemValueRules,
            position = 13
    )
    default Color insaneValueColor() { return Color.decode("#ff66b2"); }
    @ConfigItem(
            keyName = "enableHighItemValueTier",
            name = "High tier",
            description = "Enable high item value tier.",
            section = itemValueRules,
            position = 14
    )
    default boolean enableHighItemValueTier() { return true; }
    @ConfigItem(
            keyName = "highValue",
            name = "High value",
            description = "Configures the value for high tier.",
            section = itemValueRules,
            position = 15
    )
    default int highValue() { return 1_000_000; }
    @ConfigItem(
            keyName = "highValueColor",
            name = "High color",
            description = "Configures the color for high item values.",
            section = itemValueRules,
            position = 16
    )
    default Color highValueColor() { return Color.decode("#ff9600"); }
    @ConfigItem(
            keyName = "enableMediumItemValueTier",
            name = "Medium tier",
            description = "Enable medium item value tier.",
            section = itemValueRules,
            position = 17
    )
    default boolean enableMediumItemValueTier() { return true; }
    @ConfigItem(
            keyName = "mediumValue",
            name = "Medium value",
            description = "Configures the value for medium tier.",
            section = itemValueRules,
            position = 18
    )
    default int mediumValue() { return 100_000; }
    @ConfigItem(
            keyName = "mediumValueColor",
            name = "Medium color",
            description = "Configures the color for medium item values.",
            section = itemValueRules,
            position = 19
    )
    default Color mediumValueColor() { return Color.decode("#99ff99"); }
    @ConfigItem(
            keyName = "enableLowItemValueTier",
            name = "Low tier",
            description = "Enable low item value tier.",
            section = itemValueRules,
            position = 20
    )
    default boolean enableLowItemValueTier() { return true; }
    @ConfigItem(
            keyName = "lowValue",
            name = "Low value",
            description = "Configures the value for low tier.",
            section = itemValueRules,
            position = 21
    )
    default int lowValue() { return 10_000; }
    @ConfigItem(
            keyName = "lowValueColor",
            name = "Low color",
            description = "Configures the color for low item values.",
            section = itemValueRules,
            position = 22
    )
    default Color lowValueColor() { return Color.decode("#66b2ff"); }
    @ConfigItem(
            keyName = "hiddenTierEnabled",
            name = "Hide below value tier",
            description = "Hide items below a certain value.",
            section = itemValueRules,
            position = 23
    )
    default boolean hideTierEnabled() { return false; }
    @ConfigItem(
            keyName = "hiddenValue",
            name = "Hide below value",
            description = "Hide items below this value, if enabled.",
            section = itemValueRules,
            position = 24
    )
    default int hideTierValue() { return 0; }
    @ConfigItem(
            keyName = "hiddenNoHideUntradeables",
            name = "Don't hide untradeables",
            description = "Ignore untradeables for the hide-below-value tier.",
            section = itemValueRules,
            position = 25
    )
    default boolean hideTierShowUntradeable() { return true; }
}

package com.lootfilters;

import net.runelite.client.input.MouseAdapter;

import javax.inject.Inject;
import java.awt.event.MouseEvent;

import static com.lootfilters.util.TextUtil.unsetCsv;
import static com.lootfilters.util.TextUtil.toggleCsv;
import static javax.swing.SwingUtilities.isLeftMouseButton;
import static javax.swing.SwingUtilities.isMiddleMouseButton;
import static javax.swing.SwingUtilities.isRightMouseButton;

public class LootFiltersMouseAdapter extends MouseAdapter {
    @Inject private LootFiltersPlugin plugin;

    @Override
    public MouseEvent mousePressed(MouseEvent e) {
        if (!plugin.isHotkeyActive()) {
            return e;
        } else if (plugin.getHoveredHide() != -1) {
            return handleToggleHide(e);
        } else if (plugin.getHoveredHighlight() != -1) {
            return handleToggleHighlight(e);
        } // else, hovered over the bounding box itself

        var hover = plugin.getHoveredItem();
        if (hover == -1) {
            return e;
        }

        var highlights = plugin.getConfig().highlightedItems();
        var hides = plugin.getConfig().hiddenItems();

        if (isLeftMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();

                plugin.getConfig().setHighlightedItems(toggleCsv(highlights, item));
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
            });
            e.consume();
        } else if (isRightMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();

                plugin.getConfig().setHiddenItems(toggleCsv(hides, item));
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
            });
            e.consume();
        } else if (isMiddleMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
            });
            e.consume();
        }
        return e;
    }

    private MouseEvent handleToggleHide(MouseEvent e) {
        plugin.getClientThread().invoke(() -> {
            var item = plugin.getItemName(plugin.getHoveredHide()).toLowerCase();
            plugin.getConfig().setHiddenItems(toggleCsv(plugin.getConfig().hiddenItems(), item));
            plugin.getConfig().setHighlightedItems(unsetCsv(plugin.getConfig().highlightedItems(), item));
        });
        e.consume();
        return e;
    }

    private MouseEvent handleToggleHighlight(MouseEvent e) {
        plugin.getClientThread().invoke(() -> {
            var item = plugin.getItemName(plugin.getHoveredHighlight()).toLowerCase();
            plugin.getConfig().setHighlightedItems(toggleCsv(plugin.getConfig().highlightedItems(), item));
            plugin.getConfig().setHiddenItems(unsetCsv(plugin.getConfig().hiddenItems(), item));
        });
        e.consume();
        return e;
    }
}

package com.lootfilters;

import com.lootfilters.model.PluginTileItem;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class TileItemIndex {
    private final Map<Tile, List<PluginTileItem>> itemIndex = new HashMap<>();

    // Tile instances are not readily available in all contexts,
    private final Map<WorldPoint, Tile> pointIndex = new HashMap<>();

    public Set<Map.Entry<Tile, List<PluginTileItem>>> entrySet() {
        return itemIndex.entrySet();
    }

    public TileItem findItem(Tile tile, int id) {
        if (!itemIndex.containsKey(tile)) {
            return null;
        }

        return itemIndex.get(tile).stream()
                .filter(it -> it.getId() == id)
                .findFirst()
                .orElse(null);
    }

    public TileItem findItem(WorldPoint point, int id) {
        return pointIndex.containsKey(point)
                ? findItem(pointIndex.get(point), id)
                : null;
    }

    public void put(Tile tile, PluginTileItem item) {
        if (!itemIndex.containsKey(tile)) {
            itemIndex.put(tile, new ArrayList<>());
        }
        itemIndex.get(tile).add(item);
        pointIndex.put(tile.getWorldLocation(), tile);
    }

    public void remove(Tile tile, PluginTileItem item) {
        if (!itemIndex.containsKey(tile)) {
            return; // what?
        }

        var items = itemIndex.get(tile);
        items.remove(item);
        if (items.isEmpty()) {
            itemIndex.remove(tile);
            pointIndex.remove(tile.getWorldLocation());
        }
    }

    public int pointIndexSize() {
        return pointIndex.size();
    }

    public void clear() {
        itemIndex.clear();
        pointIndex.clear();
    }
}

/*
 * Copyright (c) 2021, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.lootfilters;

import lombok.RequiredArgsConstructor;
import net.runelite.api.Animation;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.Model;
import net.runelite.api.ModelData;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;

import java.awt.Color;
import java.util.function.Function;

// copied verbatim (including copyright notice & disclaimer) from
// https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/grounditems/Lootbeam.java
//
// local modifications:
// remove() - wrapped setActive() call in clientThread.invoke(), where setActive must be called (throws otherwise)
class Lootbeam
{
    private final RuneLiteObject runeLiteObject;
    private final Client client;
    private final ClientThread clientThread;
    private Color color;
    private Style style;

    @RequiredArgsConstructor
    public enum Style
    {
        LIGHT(l -> l.client.loadModel(
                5809,
                new short[]{6371},
                new short[]{JagexColor.rgbToHSL(l.color.getRGB(), 1.0d)}
        ), anim(AnimationID.RAID_LIGHT_ANIMATION)),
        MODERN(l ->
        {
            ModelData md = l.client.loadModelData(43330);
            if (md == null)
            {
                return null;
            }

            short hsl = JagexColor.rgbToHSL(l.color.getRGB(), 1.0d);
            int hue = JagexColor.unpackHue(hsl);
            int sat = JagexColor.unpackSaturation(hsl);
            int lum = JagexColor.unpackLuminance(hsl);
            int satDelta = sat > 2 ? 1 : 0;

            return md.cloneColors()
                    .recolor((short) 26432, JagexColor.packHSL(hue, sat - satDelta, lum))
                    .recolor((short) 26584, JagexColor.packHSL(hue, sat, Math.min(lum + 24, JagexColor.LUMINANCE_MAX)))
                    .light(75 + ModelData.DEFAULT_AMBIENT, 1875 + ModelData.DEFAULT_CONTRAST,
                            ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        }, anim(AnimationID.LOOTBEAM_ANIMATION)),
        ;

        private final Function<Lootbeam, Model> modelSupplier;
        private final Function<Lootbeam, Animation> animationSupplier;
    }

    private static Function<Lootbeam, Animation> anim(int id)
    {
        return b -> b.client.loadAnimation(id);
    }

    public Lootbeam(Client client, ClientThread clientThread, WorldPoint worldPoint, Color color, Style style)
    {
        this.client = client;
        this.clientThread = clientThread;
        runeLiteObject = client.createRuneLiteObject();

        this.color = color;
        this.style = style;
        update();
        runeLiteObject.setShouldLoop(true);

        LocalPoint lp = LocalPoint.fromWorld(client, worldPoint);
        runeLiteObject.setLocation(lp, client.getPlane());

        runeLiteObject.setActive(true);
    }

    public void setColor(Color color)
    {
        if (this.color != null && this.color.equals(color))
        {
            return;
        }

        this.color = color;
        update();
    }

    public void setStyle(Style style)
    {
        if (this.style == style)
        {
            return;
        }

        this.style = style;
        update();
    }

    private void update()
    {
        clientThread.invoke(() ->
        {
            Model model = style.modelSupplier.apply(this);
            if (model == null)
            {
                return false;
            }

            Animation anim = style.animationSupplier.apply(this);

            runeLiteObject.setAnimation(anim);
            runeLiteObject.setModel(model);
            return true;
        });
    }

    public void remove()
    {
        clientThread.invoke(() -> runeLiteObject.setActive(false));
    }

}
package com.lootfilters;

import com.google.gson.Gson;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import org.junit.Test;

import java.awt.Color;
import java.util.List;

import static org.junit.Assert.assertEquals;

public class LootFilterSerdeTest {
    @Test
    public void testSerde() {
        var filter = new LootFilter(
                "foo",
                "bar",
                null,
                List.of(
                        new MatcherConfig(new ItemIdRule(1), new DisplayConfig(Color.RED)),
                        new MatcherConfig(new ItemNameRule("bandos-crossbow"), new DisplayConfig(Color.GREEN)),
                        new MatcherConfig(new ItemValueRule(1_000, Comparator.LT), new DisplayConfig(Color.BLUE)),
                        new MatcherConfig(new ItemQuantityRule(1_000, Comparator.LT), new DisplayConfig(Color.WHITE)),
                        new MatcherConfig(
                                new AndRule(List.of(
                                        new ItemNameRule("Coins"),
                                        new ItemQuantityRule(5, Comparator.EQ)
                                )),
                                new DisplayConfig(Color.WHITE.darker())
                        ),
                        new MatcherConfig(
                                new OrRule(List.of(
                                        new ItemNameRule("Coins"),
                                        new ItemQuantityRule(9, Comparator.EQ)
                                )),
                                new DisplayConfig(Color.WHITE.darker())
                        )
                )
        );

        var gson = new Gson();
        var ser = filter.toJson(gson);
        var deser = LootFilter.fromJson(gson, ser);

        assertEquals(filter, deser);
    }
}

package com.lootfilters;

import java.io.IOException;

import static com.lootfilters.util.TextUtil.normalizeCrlf;

public class TestUtil {
    private TestUtil() {}

    public static String loadTestResource(String resource) throws IOException {
        try (var r = TestUtil.class.getResourceAsStream(resource)) {
            assert r != null;
            return normalizeCrlf(new String(r.readAllBytes()));
        }
    }
}

package com.lootfilters;

import com.lootfilters.lang.Preprocessor;
import org.junit.Test;

import static com.lootfilters.TestUtil.loadTestResource;
import static org.junit.Assert.assertEquals;

public class PreprocessorTest {
    @Test
    public void testPreprocess() throws Exception {
        var input = loadTestResource("preprocessor-test-input.rs2f");
        var expect = loadTestResource("preprocessor-test-expect.rs2f");

        var preprocessor = new Preprocessor(input);
        var actual = preprocessor.preprocess();
        assertEquals(expect, actual);
    }
}

package com.lootfilters;

import com.lootfilters.lang.Lexer;
import com.lootfilters.lang.Parser;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemNotedRule;
import com.lootfilters.rule.ItemStackableRule;
import com.lootfilters.rule.ItemTradeableRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.NotRule;
import com.lootfilters.rule.OrRule;
import org.junit.Test;

import java.awt.Color;
import java.util.List;

import static com.lootfilters.TestUtil.loadTestResource;
import static org.junit.Assert.assertEquals;

public class ParserTest {
    @Test
    public void testSingleRule() throws Exception {
        var input = loadTestResource("parser-test.rs2f");

        var expectName = "loot tiers";
        var expectDesc = "loot tiers like the ground items builtin";
        var expectArea = new int[]{1,2,3,4,5,6};
        var expectMatchers = List.of(
                new MatcherConfig(new ItemValueRule(10_000_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0xff,0x80,0x00, 0xff))
                                .showLootbeam(true)
                                .build()),
                new MatcherConfig(new ItemValueRule(1_000_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0xa3,0x35,0xee, 0xff))
                                .showLootbeam(true)
                                .build()),
                new MatcherConfig(new ItemValueRule(100_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0x00,0x70,0xdd, 0xff))
                                .build()),
                new MatcherConfig(new ItemValueRule(10_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0x1e,0xff,0x00, 0xff))
                                .build()),
                new MatcherConfig(new ItemTradeableRule(false),
                        DisplayConfig.builder()
                                .textColor(new Color(0xff,0x80,0x00, 0xff))
                                .build()),
                new MatcherConfig(new ItemStackableRule(false),
                        DisplayConfig.builder()
                                .textColor(new Color(0xff,0x90,0x00, 0xff))
                                .build()),
                new MatcherConfig(new ItemNotedRule(false),
                        DisplayConfig.builder()
                                .textColor(new Color(0xff,0x95,0x00, 0xff))
                                .build()),
                new MatcherConfig(new NotRule(new ItemNameRule("foo")),
                        DisplayConfig.builder().hidden(true).build()),
                new MatcherConfig(new NotRule(new ItemNameRule("foo")),
                        DisplayConfig.builder().hidden(true).build()),
                new MatcherConfig(new OrRule(new NotRule(new ItemNameRule("bar")), new ItemNameRule("foo")),
                        DisplayConfig.builder().hidden(true).build()),
                new MatcherConfig(
                        new AndRule(
                                new NotRule(
                                        new AndRule(
                                                new NotRule(new ItemNameRule("baz")),
                                                new ItemNameRule("bar")
                                        )
                                ),
                                new ItemNameRule("foo")
                        ),
                        DisplayConfig.builder().hidden(true).build())
        );
        var expect = new LootFilter(expectName, expectDesc, expectArea, expectMatchers);

        var tokens = new Lexer(input).tokenize();
        var parser = new Parser(tokens);
        var actual = parser.parse();
        assertEquals(expect, actual);
    }
}

package com.lootfilters;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootFiltersPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(LootFiltersPlugin.class);
		RuneLite.main(args);
	}
}
