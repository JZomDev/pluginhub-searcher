package com.lootfilters;

import com.lootfilters.lang.CompileException;
import lombok.SneakyThrows;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.ActionEvent;
import java.io.IOException;
import java.util.ArrayList;

import static com.lootfilters.util.CollectionUtil.append;
import static com.lootfilters.util.FilterUtil.configToFilterSource;
import static com.lootfilters.util.TextUtil.quote;
import static java.util.Collections.emptyList;
import static javax.swing.JOptionPane.showConfirmDialog;
import static javax.swing.JOptionPane.showInputDialog;
import static javax.swing.SwingUtilities.invokeLater;
import static net.runelite.client.util.ImageUtil.loadImageResource;

public class LootFiltersPanel extends PluginPanel {
    private static final String NONE_ITEM = "<none>";
    private static final String NONE_TEXT = "Select a filter to display its source.";
    private static final String TUTORIAL_TEXT = "// Welcome to the loot filter\n" +
            "// For more information on \n" +
            "// usage, please check\n" +
            "// https://github.com/riktenx/loot-filters/blob/main/guides/loot-filters.md";
    private static final String EXAMPLE_TEXT = "// Here's an example:\nif (name:\"Herring\") {\n  color = RED;\n}";
    private static final Font TEXT_FONT_ACTIVE = new Font(Font.MONOSPACED, Font.PLAIN, 12);
    private static final Color TEXT_BG_ACTIVE = Color.decode("#1e1e1e");

    private final LootFiltersPlugin plugin;
    private final JComboBox<String> filterSelect;
    private final JTextArea filterText;
    private final JButton saveChanges;
    private final JPanel root;

    public LootFiltersPanel(LootFiltersPlugin plugin) throws Exception {
        this.plugin = plugin;

        filterSelect = new JComboBox<>();
        filterText = new JTextArea(23, 30);
        saveChanges = new JButton("Save");

        root = new JPanel();
        root.setLayout(new BoxLayout(root, BoxLayout.Y_AXIS));

        init();
        initControls();
    }

    private void init() {
        var top = new JPanel(new FlowLayout(FlowLayout.LEFT));
        var textButtons = new JPanel(new FlowLayout(FlowLayout.LEFT));
        var textPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));

        var label = new JLabel("Active filter:");
        var createNew = createIconButton("create_filter",
                "Create a new empty filter.",
                this::onCreateEmptyFilter);
        var importClipboard = createIconButton("paste_icon",
                "Import new filter from clipboard.",
                this::onImportClipboard);
        var importConfig = createIconButton("import_config",
                "Import item highlight and hide lists into a new filter. Doing this will also reset those lists.",
                this::onImportConfig);
        var deleteActive = createIconButton("delete_active",
                "Delete the currently active filter.",
                this::onDeleteActive);
        var deleteAll = new JButton("Delete all");
        deleteAll.addActionListener(it -> onDeleteAll());
        saveChanges.addActionListener(it -> onSaveChanges());

        top.add(label);
        top.add(createNew);
        top.add(importClipboard);
        top.add(importConfig);
        top.add(deleteActive);
        textButtons.add(deleteAll);
        textButtons.add(Box.createHorizontalStrut(50));
        textButtons.add(saveChanges);
        textPanel.add(new JScrollPane(filterText));

        root.add(top);
        root.add(filterSelect);
        root.add(textButtons);
        root.add(textPanel);

        add(root);
    }

    private void initControls() throws IOException {
        var filters = plugin.getUserFilters();
        filterSelect.addItem(NONE_ITEM);
        for (var filter : filters) {
            filterSelect.addItem(LootFilter.fromSource(filter).getName());
        }

        var index = plugin.getUserFilterIndex();
        if (index <= filters.size() - 1) {
            filterSelect.setSelectedIndex(index + 1);
        }

        filterSelect.addActionListener(this::onFilterSelect);

        filterText.setLineWrap(true);
        filterText.getDocument().addDocumentListener(new DocumentListener() {
            private void onChange() {
                var index = plugin.getUserFilterIndex();
                if (index == -1) {
                    saveChanges.setVisible(false);
                    return;
                }

                var existingSrc = plugin.getUserFilters().get(index);
                saveChanges.setVisible(!existingSrc.equals(filterText.getText()));
            }

            @Override public void insertUpdate(DocumentEvent e) { onChange(); }
            @Override public void removeUpdate(DocumentEvent e) { onChange(); }
            @Override public void changedUpdate(DocumentEvent e) { onChange(); }
        });
        updateFilterText(index);
    }

    @SneakyThrows
    private void onCreateEmptyFilter(){
        var newSrc = String.join("\n","", TUTORIAL_TEXT,"", EXAMPLE_TEXT);
        LootFilter newFilter = LootFilter.fromSource(newSrc);
        var newName = showInputDialog(this, "Please enter a name:");
        if (newName == null || newName.isBlank()) {
            return;
        }
        newSrc = "meta { name = " + quote(newName) + "; }\n" + newSrc;
        newFilter.setName(newName);

        if (tryUpdateExisting(newFilter.getName(), newSrc)) {
            return;
        }

        filterSelect.addItem(newFilter.getName());
        plugin.setUserFilters(append(plugin.getUserFilters(), newSrc));
    }

    private void onImportClipboard() {
        var newSrc = getClipboard();
        if (newSrc == null) {
            plugin.addChatMessage("No text in clipboard.");
            return;
        }

        LootFilter newFilter;
        try {
            newFilter = LootFilter.fromSource(newSrc);
        } catch (CompileException | IOException e) {
            plugin.addChatMessage("Failed to load filter from clipboard: " + e.getMessage());
            return;
        }

        if (newFilter.getName() == null || newFilter.getName().isBlank()) {
            var newName = showInputDialog(this, "This filter does not have a name. Enter one:");
            if (newName == null || newName.isBlank()) {
                return;
            }
            newSrc = "meta { name = " + quote(newName) + "; }\n" + newSrc;
            newFilter.setName(newName);
        }

        if (tryUpdateExisting(newFilter.getName(), newSrc)) {
            return;
        }

        filterSelect.addItem(newFilter.getName());
        plugin.setUserFilters(append(plugin.getUserFilters(), newSrc));
    }

    @SneakyThrows
    private void onImportConfig() {
        var initialName = plugin.getClient().getLocalPlayer() != null
                ? plugin.getClient().getLocalPlayer().getName() + "/"
                : "player/";
        var finalName = showInputDialog(this, "Enter a filter name:", initialName);
        if (finalName == null) {
            return;
        }

        var src = configToFilterSource(plugin.getConfig(), finalName, TUTORIAL_TEXT);
        var newFilter = LootFilter.fromSource(src); // not catching here because src is generated by plugin
        if (tryUpdateExisting(finalName, src)) {
            return;
        }

        filterSelect.addItem(newFilter.getName());
        plugin.setUserFilters(append(plugin.getUserFilters(), src));
        plugin.getConfig().setHighlightedItems("");
        plugin.getConfig().setHiddenItems("");
    }

    private void onFilterSelect(ActionEvent event) {
        var realIndex = filterSelect.getSelectedIndex() - 1;
        plugin.setUserFilterIndex(realIndex);
        updateFilterText(realIndex);
    }

    private void onDeleteActive() {
        var toDelete = filterSelect.getSelectedIndex() - 1;
        if (plugin.getUserFilters().isEmpty() || toDelete == -1) {
            return;
        }
        if (!confirm("Delete the active loot filter?")) {
            return;
        }

        var newCfg = new ArrayList<>(plugin.getUserFilters());
        newCfg.remove(toDelete);

        filterSelect.removeItemAt(toDelete + 1);
        filterSelect.setSelectedIndex(0);
        plugin.setUserFilters(newCfg);
        plugin.setUserFilterIndex(-1);
        updateFilterText(-1);
    }

    private void onDeleteAll() {
        if (!confirm("Delete all loot filters?")) { return; }
        if (!confirm("Are you sure?")) { return; }

        filterSelect.removeActionListener(this::onFilterSelect);
        filterSelect.removeAllItems();
        filterSelect.addItem(NONE_ITEM);
        filterSelect.setSelectedIndex(0);
        plugin.setUserFilters(emptyList());
        plugin.setUserFilterIndex(-1);
        updateFilterText(-1);
        invokeLater(() -> filterSelect.addActionListener(this::onFilterSelect));
    }

    private void onSaveChanges() {
        var newSrc = filterText.getText();
        try {
            LootFilter.fromSource(newSrc);
        } catch (CompileException | IOException e) {
            plugin.addChatMessage("Cannot update active filter: " + e.getMessage());
            return;
        }

        if (!confirm("Save changes to the active filter?")) {
            return;
        }

        var filters = plugin.getUserFilters();
        filters.set(plugin.getUserFilterIndex(), newSrc);
        plugin.setUserFilters(filters);
    }

    private boolean tryUpdateExisting(String newName, String newSrc) {
        var existing = plugin.getUserFilters();
        for (int i = 0; i < filterSelect.getItemCount(); ++i) {
            if (!filterSelect.getItemAt(i).equals(newName)) {
                continue;
            }
            if (!confirm("Filter " + quote(newName) + " already exists. Update it?")) {
                return true;
            }

            existing.set(i - 1, newSrc);
            plugin.setUserFilters(existing);
            return true;
        }
        return false;
    }

    private void updateFilterText(int index) {
        if (index > -1) {
            filterText.setText(plugin.getUserFilters().get(index));
            filterText.setEnabled(true);
            filterText.setFont(TEXT_FONT_ACTIVE);
        } else {
            filterText.setText(NONE_TEXT);
            filterText.setEnabled(false);
            filterText.setFont(FontManager.getRunescapeFont());
        }
        filterText.setCaretPosition(0);
    }

    private JButton createIconButton(String iconSource, String tooltip, Runnable onClick) {
        var button = new JButton("", icon(iconSource));
        button.setToolTipText(tooltip);
        button.setBackground(null);
        button.setBorder(null);
        button.addActionListener(it -> onClick.run());
        return button;
    }

    private boolean confirm(String confirmText) {
        var result = showConfirmDialog(this, confirmText, "Confirm", JOptionPane.YES_NO_OPTION);
        return result == JOptionPane.YES_OPTION;
    }

    private static String getClipboard() {
        try {
            return (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
        } catch (Exception e) {
            return null;
        }
    }

    private static ImageIcon icon(String name) {
        var img = loadImageResource(LootFiltersPanel.class, "/com/lootfilters/icons/" + name + ".png");
        return new ImageIcon(img);
    }
}

package com.lootfilters;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.Setter;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import static com.lootfilters.util.FilterUtil.withConfigMatchers;
import static com.lootfilters.util.TextUtil.quote;
import static java.util.Collections.emptyList;
import static net.runelite.client.util.ImageUtil.loadImageResource;

@Slf4j
@PluginDescriptor(
	name = "Loot Filters"
)
@Getter
public class LootFiltersPlugin extends Plugin {
	public static final String CONFIG_GROUP = "loot-filters";
	public static final String USER_FILTERS_KEY = "user-filters";
	public static final String USER_FILTERS_INDEX_KEY = "user-filters-index";

	@Inject private Client client;
	@Inject private ClientThread clientThread;
	@Inject private ClientToolbar clientToolbar;

	@Inject private LootFiltersConfig config;
	@Inject private LootFiltersOverlay overlay;
	@Inject private LootFiltersMouseAdapter mouseAdapter;
	@Inject private LootFiltersHotkeyListener hotkeyListener;

	@Inject private Gson gson;
	@Inject private OverlayManager overlayManager;
	@Inject private KeyManager keyManager;
	@Inject private MouseManager mouseManager;
	@Inject private ConfigManager configManager;
	@Inject private ItemManager itemManager;
	@Inject private Notifier notifier;

	private LootFiltersPanel pluginPanel;
	private NavigationButton pluginPanelNav;

	private final TileItemIndex tileItemIndex = new TileItemIndex();
	private final LootbeamIndex lootbeamIndex = new LootbeamIndex(this);
	private final MenuEntryComposer menuEntryComposer = new MenuEntryComposer(this);

	private LootFilter activeFilter;
	private LootFilter currentAreaFilter;
	private List<LootFilter> parsedUserFilters;

	@Setter private int hoveredItem = -1;
	@Setter private boolean hotkeyActive = false;
	@Setter private boolean overlayEnabled = true;

	public LootFilter getActiveFilter() {
		return currentAreaFilter != null ? currentAreaFilter : activeFilter;
	}

	public List<String> getUserFilters() {
		var cfg = configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_KEY);
		if (cfg == null || cfg.isEmpty()) {
			return emptyList();
		}

		var type = new TypeToken<List<String>>(){}.getType();
        return gson.fromJson(configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_KEY), type);
	}

	@SneakyThrows // incoming user filters are vetted at this point, exceptions are a defect
    public void setUserFilters(List<String> filters) {
		parsedUserFilters = new ArrayList<>();
		for (var filter : filters) {
			parsedUserFilters.add(LootFilter.fromSource(filter));
		}

		var json = gson.toJson(filters);
		configManager.setConfiguration(CONFIG_GROUP, USER_FILTERS_KEY, json);
	}

	public int getUserFilterIndex() {
		var indexCfg = configManager.getConfiguration(CONFIG_GROUP, USER_FILTERS_INDEX_KEY);
        var index = indexCfg == null || indexCfg.isEmpty()
				? -1
				: Integer.parseInt(indexCfg);
		return Math.max(index, -1);
	}

	public void setUserFilterIndex(int index) {
		configManager.setConfiguration(CONFIG_GROUP, USER_FILTERS_INDEX_KEY, Integer.toString(index));
	}

	public String getUserActiveFilter() {
		var filters = getUserFilters();
		var index = getUserFilterIndex();
		return filters.isEmpty() || index == -1 || index > filters.size()-1
				? "" : filters.get(index);
	}

	public void addChatMessage(String msg) {
		clientThread.invoke(() -> {
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", msg, "loot-filters", false);
		});
	}

	public String getItemName(int id) {
		return itemManager.getItemComposition(id).getName();
	}

	@Override
	protected void startUp() throws Exception {
		overlayManager.add(overlay);

		loadFilter();
		setUserFilters(getUserFilters()); // round-trip on startup to parse everything into memory

		pluginPanel = new LootFiltersPanel(this);
		pluginPanelNav = NavigationButton.builder()
				.tooltip("Loot Filters")
				.icon(loadImageResource(this.getClass(), "/com/lootfilters/icons/panel.png"))
				.panel(pluginPanel)
				.build();
		clientToolbar.addNavigation(pluginPanelNav);
		keyManager.registerKeyListener(hotkeyListener);
		mouseManager.registerMouseListener(mouseAdapter);
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(overlay);

		tileItemIndex.clear();
		lootbeamIndex.clear();

		clientToolbar.removeNavigation(pluginPanelNav);
		keyManager.unregisterKeyListener(hotkeyListener);
		mouseManager.unregisterMouseListener(mouseAdapter);
	}

	@Provides
	LootFiltersConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(LootFiltersConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) throws Exception {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		loadFilter();
		if (!config.autoToggleFilters()) {
			currentAreaFilter = null;
		} // if we're transitioning TO enabled, do nothing - onGameTick() will handle it
		clientThread.invoke(lootbeamIndex::reset);
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned event) {
		var tile = event.getTile();
		var item = event.getItem();
		tileItemIndex.put(tile, item);

		var match = getActiveFilter().findMatch(this, item);
		if (match != null && match.isShowLootbeam()) {
			var beam = new Lootbeam(client, clientThread, tile.getWorldLocation(), match.getTextColor(), Lootbeam.Style.MODERN);
			lootbeamIndex.put(tile, item, beam);
		}
		if (match != null && match.isNotify()) {
			notifier.notify(getItemName(item.getId()));
		}
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event) {
		var tile = event.getTile();
		var item = event.getItem();
		tileItemIndex.remove(tile, item);
		lootbeamIndex.remove(tile, item); // idempotent, we don't care if there wasn't a beam
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOADING) {
			tileItemIndex.clear();
			lootbeamIndex.clear();
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		scanAreaFilter();
	}

	@Subscribe
	private void onMenuEntryAdded(MenuEntryAdded event) {
		menuEntryComposer.onMenuEntryAdded(event.getMenuEntry());
	}

	@Subscribe
	public void onMenuOpened(MenuOpened event) {
		menuEntryComposer.onMenuOpened();
	}

	private void loadFilter() throws Exception {
		var userFilter = LootFilter.fromSource(getUserActiveFilter());
		activeFilter = withConfigMatchers(userFilter, config);
	}

	private void scanAreaFilter() {
		if (!config.autoToggleFilters()) {
			return;
		}

		var player = client.getLocalPlayer();
		if (player == null) {
			return;
		}

		var p = WorldPoint.fromLocalInstance(client, player.getLocalLocation());
		var match = parsedUserFilters.stream()
				.filter(it -> it.isInActivationArea(p))
				.findFirst().orElse(null);
		if (match != null && (currentAreaFilter == null || !Objects.equals(match.getName(), currentAreaFilter.getName()))) {
			addChatMessage("Entering area for filter " + quote(match.getName()));
			currentAreaFilter = withConfigMatchers(match, config);
		} else if (match == null && currentAreaFilter != null) {
			addChatMessage("Leaving area for filter " + quote(currentAreaFilter.getName()));
			currentAreaFilter = null;
		}
	}
}

package com.lootfilters.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class CollectionUtil {
    private CollectionUtil() {}

    public static <E> List<E> append(List<E> list, E... elements) {
        var newList = new ArrayList<>(list);
        newList.addAll(Arrays.asList(elements));
        return newList;
    }

    public static <E> List<E> without(List<E> list, E element) {
        var newList = new ArrayList<>(list);
        newList.remove(element);
        return newList;
    }
}

package com.lootfilters.util;

import java.awt.Color;
import java.io.IOException;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TextUtil {
    private TextUtil() {}

    public static String quote(String text) {
        return '"' + text + '"';
    }

    public static boolean isWhitespace(char c) {
        return c == ' ' || c == '\t' || c == '\n' || c == '\r';
    }

    public static boolean isNumeric(char c) {
        return c >= '0' && c <= '9';
    }

    public static boolean isAlpha(char c) {
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
    }

    public static boolean isLegalIdent(char c) {
        return c == '_' || isAlpha(c) || isNumeric(c);
    }

    public static Color parseArgb(String argb) {
        return new Color(Long.decode("0x" + argb).intValue(), true);
    }

    public static String getValueText(int value) {
        if (value >= 1e9) { // > 1b
            return String.format("%.2fB", (float)value / 1e9);
        } else if (value >= 1e8) { // > 100m
            return String.format("%.0fM", (float)value / 1e6);
        } else if (value >= 1e7) { // > 10m
            return String.format("%.1fM", (float)value / 1e6);
        } else if (value >= 1e6) { // > 1m
            return String.format("%.2fM", (float)value / 1e6);
        } else if (value >= 1e5) { // > 100k
            return String.format("%.0fK", (float)value / 1e3);
        } else if (value >= 1e4) { // > 10k
            return String.format("%.1fK", (float)value / 1e3);
        } else if (value >= 1e3) { // > 1k
            return String.format("%.2fK", (float)value / 1e3);
        }
        return value + "gp";
    }

    public static String normalizeCrlf(String str) {
        return str
                .replaceAll("\r\n", "\n")
                .replaceAll("\r", "\n");
    }

    public static String loadFilterScript(String resource) throws IOException {
        try (var r = TextUtil.class.getResourceAsStream("/com/lootfilters/scripts/" + resource)) {
            assert r != null;
            return normalizeCrlf(new String(r.readAllBytes()));
        }
    }

    public static String setCsv(String csv, String value) {
        if (csv.isBlank()) {
            return value;
        }
        return Stream.concat(Arrays.stream(csv.split(",")), Stream.of(value))
                .distinct()
                .collect(Collectors.joining(","));
    }

    public static String unsetCsv(String csv, String value) {
        if (csv.isBlank()) {
            return "";
        }
        return Arrays.stream(csv.split(","))
                .filter(it -> !it.equals(value))
                .collect(Collectors.joining(","));
    }
}

package com.lootfilters.util;

import com.lootfilters.LootFilter;
import com.lootfilters.LootFiltersConfig;
import com.lootfilters.MatcherConfig;
import com.lootfilters.rule.TextAccent;
import com.lootfilters.rule.ValueTier;

import java.util.ArrayList;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.quote;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;
import static net.runelite.client.util.ColorUtil.colorToAlphaHexCode;

public class FilterUtil {
    private FilterUtil() {}

    /**
     * Wraps a user-defined loot filter with config defaults (highlight/hide, value tiers, etc.).
     */
    public static LootFilter withConfigMatchers(LootFilter filter, LootFiltersConfig config) {
        var matchersWithConfig = new ArrayList<MatcherConfig>();
        matchersWithConfig.add(MatcherConfig.ownershipFilter(config.ownershipFilter()));
        matchersWithConfig.add(MatcherConfig.itemSpawnFilter(config.itemSpawnFilter()));

        matchersWithConfig.addAll(filter.getMatchers());

        matchersWithConfig.add(MatcherConfig.highlight(
                config.highlightedItems(), config.highlightColor(), config.highlightLootbeam(), config.highlightNotify()));
        matchersWithConfig.add(MatcherConfig.hide(config.hiddenItems()));

        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableInsaneItemValueTier(), config.insaneValue(), config.insaneValueColor(),
                true, true));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableHighItemValueTier(), config.highValue(), config.highValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.HIGH.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.HIGH.ordinal()));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableMediumItemValueTier(), config.mediumValue(), config.mediumValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.MEDIUM.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.MEDIUM.ordinal()));
        matchersWithConfig.add(MatcherConfig.valueTier(
                config.enableLowItemValueTier(), config.lowValue(), config.lowValueColor(),
                config.lootbeamTier().ordinal() >= ValueTier.LOW.ordinal(),
                config.notifyTier().ordinal() >= ValueTier.LOW.ordinal()));
        matchersWithConfig.add(MatcherConfig.hiddenTier(config.hideTierEnabled(), config.hideTierValue()));

        matchersWithConfig.add(MatcherConfig.showUnmatched(config.showUnmatchedItems()));

        if (config.alwaysShowValue()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(), it.getDisplay().toBuilder()
                            .showValue(true)
                            .build()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        if (config.alwaysShowDespawn()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(), it.getDisplay().toBuilder()
                            .showDespawn(true)
                            .build()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }
        if (config.textAccent().ordinal() > TextAccent.USE_FILTER.ordinal()) {
            matchersWithConfig = matchersWithConfig.stream()
                    .map(it -> new MatcherConfig(it.getRule(), it.getDisplay().toBuilder()
                            .textAccent(config.textAccent())
                            .build()))
                    .collect(Collectors.toCollection(ArrayList::new));
        }

        return new LootFilter(filter.getName(), filter.getDescription(), filter.getActivationArea(), matchersWithConfig);
    }

    /**
     * Captures the current config-based item matchers, exporting them to their own filter.
     */
    public static String configToFilterSource(LootFiltersConfig config, String name, String tutorialText) {
        var defines = "#define HCOLOR " + quote(colorToAlphaHexCode(config.highlightColor()));
        var meta = "meta {\n  name = " + quote(name) + ";\n}\n\n";
        var highlights = "";
        if (!config.highlightedItems().isBlank()) {
            highlights = stream(config.highlightedItems().split(","))
                    .map(it -> "HIGHLIGHT(" + quote(it) + ", HCOLOR)")
                    .collect(joining("\n"));
        }
        var hides = "";

        if (!config.hiddenItems().isBlank()) {
            hides = stream(config.hiddenItems().split(","))
                    .map(it -> "HIDE("+ quote(it) + ")")
                    .collect(joining("\n"));
        }

        return String.join("\n",
                defines,
                meta,
                tutorialText,
                highlights,
                hides);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.awt.Color;
import java.lang.reflect.Type;

public class ColorSerializer implements JsonSerializer<Color> {
    @Override
    public JsonElement serialize(Color color, Type type, JsonSerializationContext ctx) {
        var argb = String.format("%02x", color.getAlpha())
                + String.format("%02x", color.getRed())
                + String.format("%02x", color.getGreen())
                + String.format("%02x", color.getBlue());
        return new JsonPrimitive(argb);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;

import java.awt.Color;
import java.lang.reflect.Type;

import static com.lootfilters.util.TextUtil.parseArgb;

public class ColorDeserializer implements JsonDeserializer<Color> {
    @Override
    public Color deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        return parseArgb(elem.getAsString());
    }
}

package com.lootfilters.serde;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import lombok.AllArgsConstructor;

import java.lang.reflect.Type;

@AllArgsConstructor
public class RuleDeserializer implements JsonDeserializer<Rule> {
    private final Gson gson;

    @Override
    public Rule deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        var object = elem.getAsJsonObject();
        var discriminator = object.get("discriminator").getAsString();
        switch (discriminator) {
            case "item_id":
                return gson.fromJson(object, ItemIdRule.class);
            case "item_name":
                return gson.fromJson(object, ItemNameRule.class);
            case "item_value":
                return gson.fromJson(object, ItemValueRule.class);
            case "item_quantity":
                return gson.fromJson(object, ItemQuantityRule.class);
            case "and":
                return deserializeInner(object, AndRule.class);
            case "or":
                return deserializeInner(object, OrRule.class);
            default:
                throw new JsonParseException("unknown rule type " + discriminator);
        }
    }

    private Rule deserializeInner(JsonElement elem, Type type) throws JsonParseException {
        return gson.newBuilder()
                .registerTypeAdapter(Rule.class, this)
                .create()
                .fromJson(elem, type);
    }
}

package com.lootfilters;

import com.lootfilters.rule.TextAccent;
import net.runelite.api.Client;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;

import static com.lootfilters.util.TextUtil.getValueText;
import static java.util.stream.Collectors.counting;
import static java.util.stream.Collectors.groupingBy;
import static net.runelite.api.Perspective.getCanvasTextLocation;
import static net.runelite.client.ui.FontManager.getRunescapeSmallFont;

public class LootFiltersOverlay extends Overlay {
    private static final int Z_STACK_OFFSET = 17; // for initial perspective and subsequent vertical stack
    private static final int BOX_PAD = 2;
    private static final Color COLOR_HIDDEN = Color.GRAY.brighter();

    private final Client client;
    private final LootFiltersPlugin plugin;
    private final LootFiltersConfig config;

    private final boolean debug = false;

    @Inject
    private ItemManager itemManager;

    @Inject
    public LootFiltersOverlay(Client client, LootFiltersPlugin plugin, LootFiltersConfig config) {
        setPosition(OverlayPosition.DYNAMIC);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D g) {
        if (debug) {
            renderDebugOverlay(g);
        }

        if (!plugin.isOverlayEnabled()) {
            return null;
        }

        var activeFilter = plugin.getActiveFilter();
        var mouse = client.getMouseCanvasPosition();
        var hoveredItem = -1;

        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var items = entry.getValue();
            var itemCounts = items.stream()
                    .collect(groupingBy(TileItem::getId, counting()));

            var tile = entry.getKey();
            var currentOffset = 0;
            for (var id : itemCounts.keySet()) {
                var count = itemCounts.get(id);
                var item = items.stream()
                        .filter(it -> it.getId() == id)
                        .findFirst().orElseThrow();

                var match = activeFilter.findMatch(plugin, item);
                if (match == null) {
                    continue;
                }

                var overrideHidden = plugin.isHotkeyActive() && config.hotkeyShowHiddenItems();
                if (match.isHidden() && !overrideHidden) {
                    continue;
                }

                var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
                if (loc == null) {
                    continue;
                }
                if (tile.getItemLayer() == null) {
                    continue;
                }

                var displayText = buildDisplayText(item, count, match);
                var textPoint = getCanvasTextLocation(client, g, loc, displayText, tile.getItemLayer().getHeight() + Z_STACK_OFFSET);
                if (textPoint == null) {
                    continue;
                }

                var fm = g.getFontMetrics(getRunescapeSmallFont());
                var textWidth = fm.stringWidth(displayText);
                var textHeight = fm.getHeight();

                var text = new TextComponent();
                text.setText(displayText);
                text.setFont(getRunescapeSmallFont());
                text.setColor(match.isHidden() ? COLOR_HIDDEN : match.getTextColor());
                text.setPosition(new Point(textPoint.getX(), textPoint.getY() - currentOffset));
                text.setOutline(match.getTextAccent() != null && match.getTextAccent() == TextAccent.OUTLINE);

                var boundingBox = new Rectangle(
                        textPoint.getX() - BOX_PAD, textPoint.getY() - currentOffset - textHeight - BOX_PAD,
                        textWidth + 2 * BOX_PAD, textHeight + 2 * BOX_PAD
                );

                if (match.getBackgroundColor() != null) {
                    g.setColor(match.getBackgroundColor());
                    g.fillRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (match.getBorderColor() != null) {
                    g.setColor(match.getBorderColor());
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (plugin.isHotkeyActive() && boundingBox.contains(mouse.getX(), mouse.getY())) {
                    hoveredItem = item.getId();

                    g.setColor(match.isHidden() ? COLOR_HIDDEN : Color.WHITE);
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }

                text.render(g);

                if (match.isShowDespawn()) {
                    var ticksRemaining = item.getDespawnTime() - client.getTickCount();
                    if (ticksRemaining < 0) { // doesn't despawn
                        continue;
                    }
                    text.setColor(getDespawnTextColor(item));
                    text.setText(Integer.toString(ticksRemaining));
                    text.setPosition(new Point(textPoint.getX() + textWidth + 2 + 1, textPoint.getY() - currentOffset));
                    text.render(g);
                }

                currentOffset += Z_STACK_OFFSET;
            }
        }

        plugin.setHoveredItem(hoveredItem);
        return null;
    }

    private Color getDespawnTextColor(TileItem item) {
        if (item.getDespawnTime() - client.getTickCount() < 100) {
            return Color.RED;
        }
        if (item.getVisibleTime() <= client.getTickCount()) {
            return Color.YELLOW;
        }
        return Color.GREEN;
    }

    private String buildDisplayText(TileItem item, long unstackedCount, DisplayConfig display) {
        var text = itemManager.getItemComposition(item.getId()).getName();

        if (item.getQuantity() > 1) {
            text += " (" + item.getQuantity() + ")";
        } else if (unstackedCount > 1) {
            text += " x" + unstackedCount; // we want these to be visually different
        }

        if (display.isShowValue()) {
            var ge = itemManager.getItemPrice(item.getId());
            var ha = itemManager.getItemComposition(item.getId()).getHaPrice();
            int value;
            boolean isAlch;
            switch (config.valueType()) {
                case HIGHEST:
                    value = Math.max(ge, ha);
                    isAlch = ha > ge;
                    break;
                case GE:
                    value = ge;
                    isAlch = false;
                    break;
                default:
                    value = ha;
                    isAlch = true;
                    break;
            }
            value *= item.getQuantity();
            if (value > 0) {
                text += " (";
                if (isAlch) {
                    text += "*";
                }
                text += getValueText(value) + ")";
            }
        }

        return text;
    }

    private void renderDebugOverlay(Graphics2D g) {
        int itemCount = 0;
        int screenY = 64;
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            var items = entry.getValue();

            var errs = "";
            var errno = 0;
            var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
            if (loc == null) {
                ++errno;
                errs += "[LOC]";
            }
            if (tile.getItemLayer() == null) {
                ++errno;
                errs += "[IL]";
            }

            var coords = tile.getWorldLocation().getX() + ", " + tile.getWorldLocation().getY();
            var sz = items.size();
            g.setColor(errno > 0 ? Color.RED : Color.WHITE);
            g.drawString(coords+" "+sz+" "+errs, 0, screenY);

            itemCount += sz;
            screenY += 16;
        }
        g.setColor(Color.WHITE);
        g.drawString("items: " + itemCount + "," + plugin.getTileItemIndex().pointIndexSize(), 0, 32);
        g.drawString("lootbeams: " + plugin.getLootbeamIndex().size(), 0, 48);
    }
}

package com.lootfilters;

import com.google.inject.Inject;
import net.runelite.client.util.HotkeyListener;

import java.time.Duration;
import java.time.Instant;

public class LootFiltersHotkeyListener extends HotkeyListener {
    private final LootFiltersPlugin plugin;

    private Instant lastPressed = Instant.EPOCH;

    @Inject
    private LootFiltersHotkeyListener(LootFiltersPlugin plugin) {
        super(plugin.getConfig()::hotkey);

        this.plugin = plugin;
    }

    @Override
    public void hotkeyPressed() {
        plugin.setHotkeyActive(true);

        var now = Instant.now();
        if (shouldToggleOverlay(now)) {
            plugin.setOverlayEnabled(!plugin.isOverlayEnabled());
        }
        lastPressed = now;
    }

    @Override
    public void hotkeyReleased() {
        plugin.setHotkeyActive(false);
    }

    private boolean shouldToggleOverlay(Instant now) {
        return plugin.getConfig().hotkeyDoubleTapTogglesOverlay()
                && Duration.between(lastPressed, now).toMillis() < plugin.getConfig().hotkeyDoubleTapDelay();
    }
}
package com.lootfilters;

import com.lootfilters.rule.TextAccent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;

import java.awt.Color;

@Getter
@Builder(toBuilder = true)
@AllArgsConstructor
@EqualsAndHashCode
public class DisplayConfig {
    @Builder.Default
    private final Color textColor = Color.WHITE;

    private final Color backgroundColor;
    private final Color borderColor;
    private final boolean hidden;
    private final boolean showLootbeam;
    private final boolean showValue;
    private final boolean showDespawn;
    private final boolean notify;
    private final TextAccent textAccent;

    public DisplayConfig(Color textColor) {
        this.textColor = textColor;
        backgroundColor = null;
        borderColor = null;
        hidden = false;
        showLootbeam = false;
        showValue = false;
        showDespawn = false;
        notify = false;
        textAccent = null;
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
public class ItemQuantityRule extends ComparatorRule {
    public ItemQuantityRule(int value, Comparator cmp) {
        super("item_quantity", value, cmp);
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, TileItem item) {
        return item.getQuantity();
    }
}

package com.lootfilters.rule;

public enum ValueTier {
    INSANE, HIGH, MEDIUM, LOW;

    @Override
    public String toString() {
        switch (this) {
            case INSANE: return "insane";
            case HIGH: return "high";
            case MEDIUM: return "medium";
            default: return "low";
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
public class ItemNameRule extends Rule {
    private final String name;

    public ItemNameRule(String name) {
        super("item_name");
        this.name = name;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        var itemName = plugin.getItemName(item.getId());
        if (name.startsWith("*")) {
            return itemName.toLowerCase().endsWith(name.toLowerCase().substring(1));
        } else if (name.endsWith("*")) {
            return itemName.toLowerCase().startsWith(name.toLowerCase().substring(0, name.length() - 1));
        }
        return itemName.equalsIgnoreCase(name);
    }
}

package com.lootfilters.rule;

import com.lootfilters.lang.ParseException;

public enum TextAccent {
    USE_FILTER, SHADOW, OUTLINE;

    public static TextAccent fromOrdinal(int o) {
        switch (o) {
            case 1: return SHADOW;
            case 2: return OUTLINE;
            default: throw new ParseException("unrecognized TextAccent ordinal " + o);
        }
    }

    @Override
    public String toString() {
        switch (this) {
            case USE_FILTER: return "use filter";
            case SHADOW: return "shadow";
            default: return "outline";
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import net.runelite.api.TileItem;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
public class OrRule extends Rule {
    private final List<Rule> rules;

    public OrRule(List<Rule> rules) {
        super("or");
        this.rules = rules;
    }

    public OrRule(Rule left, Rule right) {
        super("or");
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return rules.stream().anyMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.rule;

import com.lootfilters.lang.ParseException;
import com.lootfilters.lang.Token;

public enum Comparator {
    GT, LT, EQ, GT_EQ, LT_EQ;

    public static Comparator fromToken(Token t) {
        switch (t.getType()) {
            case OP_GT: return GT;
            case OP_LT: return LT;
            case OP_EQ: return EQ;
            case OP_GTEQ: return GT_EQ;
            case OP_LTEQ: return LT_EQ;
            default:
                throw new ParseException("unrecognized token", t);
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import net.runelite.api.TileItem;

public abstract class Rule {
    protected final String discriminator; // serde discriminator

    protected Rule(String discriminator) {
        this.discriminator = discriminator;
    }

    public abstract boolean test(LootFiltersPlugin plugin, TileItem item);
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import net.runelite.api.TileItem;

public abstract class ComparatorRule extends Rule {
    private final int rhs;
    private final Comparator cmp;

    protected ComparatorRule(String discriminator, int rhs, Comparator cmp) {
        super(discriminator);
        this.rhs = rhs;
        this.cmp = cmp;
    }

    @Override
    public final boolean test(LootFiltersPlugin plugin, TileItem item) {
        var lhs = getLhs(plugin, item);
        switch (cmp) {
            case GT:
                return lhs > rhs;
            case LT:
                return lhs < rhs;
            case EQ:
                return lhs == rhs;
            case GT_EQ:
                return lhs >= rhs;
            case LT_EQ:
                return lhs <= rhs;
        }
        return false;
    }

    public abstract int getLhs(LootFiltersPlugin plugin, TileItem item);
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import net.runelite.api.ItemID;
import net.runelite.api.TileItem;

@EqualsAndHashCode(callSuper = false)
public class ItemValueRule extends ComparatorRule {
    public ItemValueRule(int value, Comparator cmp) {
       super("item_value", value, cmp);
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, TileItem item) {
        switch (item.getId()) {
            case ItemID.COINS_995:
                return item.getQuantity();
            case ItemID.PLATINUM_TOKEN:
                return item.getQuantity() * 1000;
            default:
                return getValue(plugin, item) * item.getQuantity();
        }
    }

    private int getValue(LootFiltersPlugin plugin, TileItem item) {
        var ge = plugin.getItemManager().getItemPrice(item.getId());
        var ha = plugin.getItemManager().getItemComposition(item.getId()).getHaPrice();
        switch (plugin.getConfig().valueType()) {
            case HIGHEST: return Math.max(ge, ha);
            case GE: return ge;
            default: return ha;
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import net.runelite.api.TileItem;

@Getter
@EqualsAndHashCode(callSuper = false)
public class ItemIdRule extends Rule {
    private final int id;

    public ItemIdRule(int id) {
        super("item_id");
        this.id = id;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return item.getId() == id;
    }
}

package com.lootfilters.rule;

public enum ValueType {
    HIGHEST, GE, HA;

    @Override
    public String toString() {
        switch (this) {
            case HIGHEST: return "highest";
            case GE: return "grand exchange";
            default: return "high alchemy";
        }
    }
}

package com.lootfilters.rule;

import com.lootfilters.LootFiltersPlugin;
import lombok.EqualsAndHashCode;
import net.runelite.api.TileItem;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
public class AndRule extends Rule {
    private final List<Rule> rules;

    public AndRule(List<Rule> rules) {
        super("and");
        this.rules = rules;
    }

    public AndRule(Rule left, Rule right) {
        super("and");
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, TileItem item) {
        return rules.stream().allMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.lang;

public class TokenizeException extends CompileException {
    public TokenizeException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;
import lombok.Value;

@Value
@RequiredArgsConstructor
public class Token {
    public enum Type {
        WHITESPACE, NEWLINE,
        IF,
        META,
        COLON, COMMA,
        TRUE, FALSE,
        IDENTIFIER,
        LITERAL_INT, LITERAL_STRING,
        ASSIGN,
        OP_EQ, OP_GT, OP_LT, OP_GTEQ, OP_LTEQ, OP_AND, OP_OR,
        EXPR_START, EXPR_END,
        BLOCK_START, BLOCK_END,
        LIST_START, LIST_END,
        STMT_END,
        PREPROC_DEFINE,
        COMMENT,
    }

    public static Token intLiteral(String value) { return new Token(Type.LITERAL_INT, value); }
    public static Token stringLiteral(String value) { return new Token(Type.LITERAL_STRING, value); }
    public static Token identifier(String value) { return new Token(Type.IDENTIFIER, value); }

    Type type;
    String value;

    public boolean is(Type type) {
        return this.type == type;
    }

    public int expectInt() {
        if (type != Type.LITERAL_INT) {
            throw new ParseException("unexpected non-int token", this);
        }
        return Integer.parseInt(value);
    }

    public String expectString() {
        if (type != Type.LITERAL_STRING) {
            throw new ParseException("unexpected non-string token", this);
        }
        return value;
    }

    public boolean expectBoolean() {
        switch (type) {
            case TRUE: return true;
            case FALSE: return false;
            default:
                throw new ParseException("unexpected non-boolean token", this);
        }
    }

    public boolean isWhitespace() {
        return type == Type.WHITESPACE || type == Type.NEWLINE;
    }

    public boolean isSemantic() {
        return type != Type.COMMENT && !isWhitespace();
    }

    @Override
    public String toString() {
        var str = "Token{type=" + type;
        return value != null && value.isEmpty()
                ? str + "}"
                : str + ",value=" + value + "}";
    }
}

package com.lootfilters.lang;

import lombok.Getter;

@Getter
public class ParseException extends CompileException {
    private final Token token;

    public ParseException(String message, Token token) {
        super(message + " (token=" + token + ")");
        this.token = token;
    }

    public ParseException(String message) {
        super(message);
        this.token = null;
    }
}

package com.lootfilters.lang;

public class PreprocessException extends CompileException {
    public PreprocessException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import com.lootfilters.DisplayConfig;
import com.lootfilters.LootFilter;
import com.lootfilters.MatcherConfig;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import com.lootfilters.rule.TextAccent;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import static com.lootfilters.lang.Token.Type.ASSIGN;
import static com.lootfilters.lang.Token.Type.BLOCK_END;
import static com.lootfilters.lang.Token.Type.BLOCK_START;
import static com.lootfilters.lang.Token.Type.COLON;
import static com.lootfilters.lang.Token.Type.COMMA;
import static com.lootfilters.lang.Token.Type.EXPR_END;
import static com.lootfilters.lang.Token.Type.EXPR_START;
import static com.lootfilters.lang.Token.Type.IDENTIFIER;
import static com.lootfilters.lang.Token.Type.IF;
import static com.lootfilters.lang.Token.Type.LIST_END;
import static com.lootfilters.lang.Token.Type.LIST_START;
import static com.lootfilters.lang.Token.Type.LITERAL_INT;
import static com.lootfilters.lang.Token.Type.LITERAL_STRING;
import static com.lootfilters.lang.Token.Type.META;
import static com.lootfilters.lang.Token.Type.OP_AND;
import static com.lootfilters.lang.Token.Type.OP_OR;
import static com.lootfilters.lang.Token.Type.STMT_END;
import static com.lootfilters.util.TextUtil.parseArgb;

// Parser somewhat mixes canonical stages 2 (parse) and 3/4 (syntax/semantic analysis) but the filter language is
// restricted enough that it should be fine for now.
public class Parser {
    private final TokenStream tokens;
    private final List<MatcherConfig> matchers = new ArrayList<>();

    private String name;
    private String description;
    private int[] activationArea = null;

    public Parser(List<Token> tokens) {
        this.tokens = new TokenStream(tokens);
    }

    public LootFilter parse() throws ParseException {
        while (tokens.isNotEmpty()) {
            var tok = tokens.take();
            if (tok.is(META)) {
                parseMeta();
            } else if (tok.is(IF)) {
                parseMatcher();
            } else {
                throw new ParseException("unexpected token", tok);
            }
        }
        return new LootFilter(name, description, activationArea, matchers);
    }

    private void parseMeta() {
        var block = tokens.take(BLOCK_START, BLOCK_END);
        while (block.isNotEmpty()) {
            var tok = block.takeExpect(IDENTIFIER);
            block.takeExpect(ASSIGN);
            switch (tok.getValue()) {
                case "name":
                    name = block.takeExpectLiteral().expectString();
                    block.takeExpect(STMT_END);
                    break;
                case "description":
                    description = block.takeExpectLiteral().expectString();
                    block.takeExpect(STMT_END);
                    break;
                case "area":
                    block.takeExpect(LIST_START);
                    int x0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int x1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z1 = block.takeExpectLiteral().expectInt(); block.takeOptional(COMMA);
                    block.takeExpect(LIST_END);
                    block.takeExpect(STMT_END);

                    activationArea = new int[]{x0,y0,z0,x1,y1,z1};
                    break;
                default:
                    throw new ParseException("unrecognized metavalue", tok);
            }
        }
    }

    private void parseMatcher() {
        var operators = new Stack<Token>();
        var rulesPostfix = new ArrayList<Rule>();
        tokens.walkExpression(EXPR_START, EXPR_END, it -> {
            if (it.is(EXPR_START)) {
                operators.push(it);
            } else if (it.is(EXPR_END)) {
                while (!operators.isEmpty() && !operators.peek().is(EXPR_START)) {
                    var op = operators.pop();
                    if (op.is(OP_AND)) {
                        rulesPostfix.add(new AndRule(null));
                    } else if (op.is(OP_OR)) {
                        rulesPostfix.add(new OrRule(null));
                    }
                }
            } else if (it.is(OP_AND)) {
                operators.push(it);
            } else if (it.is(OP_OR)) {
                while (!operators.isEmpty() && operators.peek().is(OP_AND)) {
                    operators.pop();
                    rulesPostfix.add(new AndRule(null));
                }
                operators.push(it);
            } else if (it.is(IDENTIFIER)) {
                rulesPostfix.add(parseRule(it));
            } else {
                throw new ParseException("unexpected token in expression", it);
            }
        });

        while (!operators.isEmpty()) { // is this necessary? since parenthesis around overall expr are guaranteed
            var op = operators.pop();
            if (op.is(OP_AND)) {
                rulesPostfix.add(new AndRule(null));
            } else if (op.is(OP_OR)) {
                rulesPostfix.add(new OrRule(null));
            }
        }

        // rule expression MUST be followed by block w/ display config assignments
        tokens.takeExpect(BLOCK_START);
        var builder = DisplayConfig.builder();
        while (!tokens.peek().is(BLOCK_END)) { // TokenStream.traverseBlock?
            var assign = parseAssignment();
            switch (assign[0].getValue()) {
                case "textColor":
                case "color":
                    builder.textColor(parseArgb(assign[1].expectString())); break;
                case "backgroundColor":
                    builder.backgroundColor(parseArgb(assign[1].expectString())); break;
                case "borderColor":
                    builder.borderColor(parseArgb(assign[1].expectString())); break;
                case "hidden":
                    builder.hidden(assign[1].expectBoolean()); break;
                case "showLootbeam":
                    builder.showLootbeam(assign[1].expectBoolean()); break;
                case "showValue":
                    builder.showValue(assign[1].expectBoolean()); break;
                case "showDespawn":
                    builder.showDespawn(assign[1].expectBoolean()); break;
                case "notify":
                    builder.notify(assign[1].expectBoolean()); break;
                case "textAccent":
                    builder.textAccent(TextAccent.fromOrdinal(assign[1].expectInt())); break;
                default:
                    throw new ParseException("unexpected identifier in display config block", assign[0]);
            }
        }
        tokens.takeExpect(BLOCK_END);

        matchers.add(new MatcherConfig(buildRule(rulesPostfix), builder.build()));
    }

    private Rule parseRule(Token first) {
        tokens.takeExpect(COLON); // grammar is always <id><colon><...>
        switch (first.getValue()) {
            case "id":
                return parseItemIdRule();
            case "name":
                return parseItemNameRule();
            case "quantity":
                return parseItemQuantityRule();
            case "value":
                return parseItemValueRule();
            default:
                throw new ParseException("unknown rule identifier", first);
        }
    }

    private ItemIdRule parseItemIdRule() {
        var id = tokens.takeExpect(LITERAL_INT);
        return new ItemIdRule(Integer.parseInt(id.getValue()));
    }

    private ItemNameRule parseItemNameRule() {
        var name = tokens.takeExpect(LITERAL_STRING);
        return new ItemNameRule(name.getValue());
    }

    private ItemQuantityRule parseItemQuantityRule() {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemQuantityRule(Integer.parseInt(value.getValue()), Comparator.fromToken(op));
    }

    private ItemValueRule parseItemValueRule() {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemValueRule(Integer.parseInt(value.getValue()), Comparator.fromToken(op));
    }

    private Rule buildRule(List<Rule> postfix) {
        var operands = new Stack<Rule>();
        for (var rule : postfix) {
            if (rule instanceof ItemIdRule
                    || rule instanceof ItemNameRule
                    || rule instanceof ItemQuantityRule
                    || rule instanceof ItemValueRule) {
                operands.push(rule);
            } else if (rule instanceof AndRule) {
                operands.push(new AndRule(operands.pop(), operands.pop()));
            } else if (rule instanceof OrRule) {
                operands.push(new OrRule(operands.pop(), operands.pop()));
            }
        }

        if (operands.size() != 1) {
            throw new ParseException("invalid rule postfix");
        }
        return operands.pop();
    }

    private Token[] parseAssignment() { // assignments do not support nested expressions, making this trivial
        var ident = tokens.takeExpect(IDENTIFIER);
        tokens.takeExpect(ASSIGN);
        var value = tokens.takeExpectLiteral();
        tokens.takeExpect(STMT_END);
        return new Token[]{ident, value};
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.function.Consumer;

/**
 * TokenStream wraps a list of Tokens to expose retrieval APIs suitable for parsing.
 */
@AllArgsConstructor
public class TokenStream {
    private final List<Token> tokens;

    /**
     * Returns a shallow copy of the token stream.
     */
    public List<Token> getTokens() {
        return new ArrayList<>(tokens);
    }

    /**
     * Peek at the first token in the stream, ignoring whitespace, without consuming it.
     */
    public Token peek() {
        return tokens.stream()
                .filter(Token::isSemantic)
                .findFirst()
                .orElse(null);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace.
     */
    public Token take(boolean includeWhitespace) {
        while (isNotEmpty()) {
            var next = tokens.remove(0);
            if (next.isSemantic() || includeWhitespace && next.isWhitespace()) {
                return next;
            }
        }
        return null;
    }

    /**
     * Consume the first non-whitespace token in the stream.
     */
    public Token take() {
        return take(false);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace, while asserting that it is of the given
     * type.
     */
    public Token takeExpect(Token.Type expect, boolean includeWhitespace) {
        if (tokens.isEmpty()) {
            throw new ParseException("unexpected end of token stream");
        }

        var first = take(includeWhitespace);
        if (!first.is(expect)) {
            throw new ParseException("unexpected non-" + expect + " token", first);
        }
        return first;
    }

    /**
     * Consume the first non-whitespace token in the stream while asserting that it is of the given type.
     */
    public Token takeExpect(Token.Type expect) {
        return takeExpect(expect, false);
    }

    /**
     * Consumes the first non-whitespace token at the head of the stream, asserting that it is any one of the literal
     * types (int, string, boolean).
     */
    public Token takeExpectLiteral() {
        var first = take();
        if (!first.is(Token.Type.LITERAL_INT)
                && !first.is(Token.Type.LITERAL_STRING)
                && !first.is(Token.Type.TRUE)
                && !first.is(Token.Type.FALSE)) {
            throw new ParseException("unexpected non-literal token", first);
        }
        return first;
    }

    /**
     * Take a complete line from the stream, preserving whitespace, and EXCLUDING the newline at the end, which is
     * discarded.
     */
    public List<Token> takeLine() {
        var line = new ArrayList<Token>();
        while (!tokens.isEmpty()) {
            var next = tokens.remove(0);
            if (next.is(Token.Type.NEWLINE)) {
                return line;
            }
            line.add(next);
        }
        return line;
    }

    /**
     * Consumes a token of the expected type if it's at the head of the stream, doing nothing otherwise.
     */
    public void takeOptional(Token.Type type) {
        if (peek().is(type)) {
            take();
        }
    }

    /**
     * Traverse an expression enclosed by the given start and end tokens at the head of the stream.
     * The traversal will verify that the expression in the stream is balanced. The caller can and most likely will
     * still maintain their own operator stack, but it won't require balance checks.
     * Callers MAY consume any number of tokens from the front of the stream, as long as they do not remove enclosing
     * tokens in a manner that would disrupt the balance check.
     * The consumer will be invoked with both the starting and ending enclosing tokens.
     */
    public void walkExpression(Token.Type start, Token.Type end, Consumer<Token> consumer) {
        var state = new Stack<Token>();
        if (!peek().is(start)) {
            throw new ParseException("unexpected start of expression", peek());
        }

        while (isNotEmpty()) {
            var next = take();
            if (next.is(start)) {
                state.push(next);
            } else if (next.is(end)) {
                if (!state.isEmpty()) {
                    state.pop();
                } else {
                    throw new ParseException("unbalanced expression");
                }
            }

            consumer.accept(next);
            if (state.isEmpty()) { // balanced expression
                return;
            }
        }
        if (!state.isEmpty()) {
            throw new ParseException("unbalanced expression");
        }
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, optionally including those
     * enclosing tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end, boolean preserveEnclosing) {
        var inner = new ArrayList<Token>();
        walkExpression(start, end, inner::add);
        if (!preserveEnclosing) {
            inner.remove(0);
            inner.remove(inner.size() - 1);
        }
        return new TokenStream(inner);
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, IGNORING those enclosing
     * tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end) {
        return take(start, end, false);
    }

    /**
     * Consumes an argument list at the head of the stream matching the grammar ( expr0, expr1, <...> exprN [,] ).
     */
    public List<TokenStream> takeArgList() {
        var args = new ArrayList<TokenStream>();
        var current = new ArrayList<Token>();
        var expr = take(Token.Type.EXPR_START, Token.Type.EXPR_END);
        while (expr.isNotEmpty()) {
            var head = expr.peek();
            if (head.is(Token.Type.COMMA)) {
                if (current.isEmpty()) {
                    throw new ParseException("empty argument");
                } else {
                    args.add(new TokenStream(current));
                    current = new ArrayList<>();
                    expr.take();
                }
            } else if (head.is(Token.Type.EXPR_START)) {
                var nestedExpr = expr.take(Token.Type.EXPR_START, Token.Type.EXPR_END, true);
                current.addAll(nestedExpr.getTokens());
            } else {
                current.add(expr.take());
            }
        }

        if (!current.isEmpty()) {
            args.add(new TokenStream(current));
        }
        return args;
    }

    public boolean isNotEmpty() { // this doesn't _currently_ need a version that checks non-semantic
        return tokens.stream().anyMatch(Token::isSemantic);
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.lootfilters.util.CollectionUtil.append;
import static com.lootfilters.util.TextUtil.normalizeCrlf;
import static com.lootfilters.util.TextUtil.quote;
import static java.util.Collections.emptyList;

public class Preprocessor {
    private final TokenStream tokens;

    private final Map<String, Define> defines = new HashMap<>();
    private final List<Token> preproc = new ArrayList<>(); // pre-expansion w/ all preproc lines removed

    public Preprocessor(String input) {
        input = normalizeCrlf(input);
        this.tokens = new TokenStream(new Lexer(input).tokenize());
    }

    public String preprocess() throws PreprocessException {
        while (tokens.isNotEmpty()) {
            var next = tokens.take(true);
            if (next.is(Token.Type.PREPROC_DEFINE)) {
                parseDefine();
            } else {
                preproc.add(next);
                if (!next.is(Token.Type.NEWLINE)) {
                    preproc.addAll(tokens.takeLine());
                    preproc.add(new Token(Token.Type.NEWLINE, "\n"));
                }
            }
        }

        return expandDefines(emptyList(), new TokenStream(preproc)).stream()
                .map(it -> it.is(Token.Type.LITERAL_STRING) ? quote(it.getValue()) : it.getValue())
                .collect(Collectors.joining(""))
                .trim();
    }

    private void parseDefine() {
        var name = tokens.takeExpect(Token.Type.IDENTIFIER).getValue();
        var params = tokens.peek().is(Token.Type.EXPR_START)
                ? parseDefineParams() : null;
        if (params != null && params.isEmpty()) {
            throw new PreprocessException("#define " + quote(name) + " has empty param list");
        }
        tokens.takeExpect(Token.Type.WHITESPACE, true);
        defines.put(name, new Define(name, params, tokens.takeLine()));
    }

    private List<String> parseDefineParams() {
        var params = new ArrayList<String>();
        tokens.takeExpect(Token.Type.EXPR_START);
        while (tokens.isNotEmpty()) {
            var next = tokens.take();
            if (next.is(Token.Type.EXPR_END)) {
                return params;
            } else if (next.is(Token.Type.IDENTIFIER)) {
                params.add(next.getValue());
                tokens.takeOptional(Token.Type.COMMA);
            } else {
                throw new PreprocessException("unterminated define param list");
            }
        }
        throw new PreprocessException("unterminated define param list");
    }

    private List<Token> expandDefines(List<String> visited, TokenStream tokens) {
        var postproc = new ArrayList<Token>();
        while (tokens.isNotEmpty()) {
            var token = tokens.take(true);
            if (!visited.contains(token.getValue()) && token.is(Token.Type.IDENTIFIER) && defines.containsKey(token.getValue())) {
                var define = defines.get(token.getValue());
                if (define.isParameterized()) {
                    var args = tokens.takeArgList();
                    postproc.addAll(expandParameterizedDefine(append(visited, define.name), define, args));
                } else {
                    postproc.addAll(define.value);
                }
            } else {
                postproc.add(token);
            }
        }
        return postproc;
    }

    private List<Token> expandParameterizedDefine(List<String> visited, Define define, List<TokenStream> args) {
        var expanded = new ArrayList<Token>();
        for (var token : define.value) {
            if (!token.is(Token.Type.IDENTIFIER) || token.getValue().equals(define.name)) {
                expanded.add(token);
                continue;
            }

            var paramIndex = -1;
            for (var i = 0; i < define.params.size(); ++i) {
                if (define.params.get(i).equals(token.getValue())) {
                    paramIndex = i;
                    break;
                }
            }
            if (paramIndex > -1) {
                var arg = args.get(paramIndex);
                expanded.addAll(arg.getTokens());
            } else {
                expanded.add(token);
            }
        }
        return expandDefines(visited, new TokenStream(expanded));
    }

    @AllArgsConstructor
    private static class Define {
       final String name;
       final List<String> params;
       final List<Token> value;

       boolean isParameterized() {
           return params != null;
       }
    }
}

package com.lootfilters.lang;

public class CompileException extends RuntimeException {
    public CompileException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.isLegalIdent;
import static com.lootfilters.util.TextUtil.isNumeric;
import static com.lootfilters.util.TextUtil.isWhitespace;

@RequiredArgsConstructor
public class Lexer {
    private static final LinkedHashMap<String, Token.Type> STATICS = new LinkedHashMap<>() {{
        put("\\\n", Token.Type.WHITESPACE);
        put("#define", Token.Type.PREPROC_DEFINE);
        put("false", Token.Type.FALSE);
        put("true", Token.Type.TRUE);
        put("meta", Token.Type.META);
        put("if", Token.Type.IF);
        put("&&", Token.Type.OP_AND);
        put("||", Token.Type.OP_OR);
        put(">=", Token.Type.OP_GTEQ);
        put("<=", Token.Type.OP_LTEQ);
        put("==", Token.Type.OP_EQ);
        put(">", Token.Type.OP_GT);
        put("<", Token.Type.OP_LT);
        put(";", Token.Type.STMT_END);
        put(":", Token.Type.COLON);
        put("=", Token.Type.ASSIGN);
        put(",", Token.Type.COMMA);
        put("(", Token.Type.EXPR_START);
        put(")", Token.Type.EXPR_END);
        put("{", Token.Type.BLOCK_START);
        put("}", Token.Type.BLOCK_END);
        put("[", Token.Type.LIST_START);
        put("]", Token.Type.LIST_END);
        put("\n", Token.Type.NEWLINE);
        put("\r", Token.Type.NEWLINE);
    }};

    private final String input;
    private final List<Token> tokens = new ArrayList<>();
    private int offset = 0;

    public List<Token> tokenize() throws TokenizeException {
        while (offset < input.length()) {
            if (tokenizeStatic()) {
                continue;
            }
            if (tokenizeComment()) {
                continue;
            }

            var ch = input.charAt(offset);
            if (isWhitespace(ch)) {
                tokenizeWhitespace();
            } else if (isNumeric(ch)) {
                tokenizeLiteralInt();
            } else if (ch == '"') {
                tokenizeLiteralString();
            } else if (isLegalIdent(ch)) {
                tokenizeIdentifier();
            } else {
                throw new TokenizeException("unrecognized character '" + ch + "'");
            }
        }

        return tokens.stream() // un-map escaped newlines
                .map(it -> it.getValue().equals("\\\n") ? new Token(Token.Type.WHITESPACE, "") : it)
                .collect(Collectors.toList());
    }

    private boolean tokenizeStatic() {
        for (var entry : STATICS.entrySet()) {
            var value = entry.getKey();
            var type = entry.getValue();
            if (input.startsWith(value, offset)) {
                tokens.add(new Token(type, value));
                offset += value.length();
                return true;
            }
        }
        return false;
    }

    private boolean tokenizeComment() {
        if (!input.startsWith("//", offset)) {
            return false;
        }

        var lineEnd = input.indexOf('\n', offset);
        var text = lineEnd > -1
                ? input.substring(offset, lineEnd)
                : input.substring(offset);
        tokens.add(new Token(Token.Type.COMMENT, text));
        offset += text.length();
        return true;
    }

    private void tokenizeWhitespace() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isWhitespace(input.charAt(i))) {
                var ws = input.substring(offset, i);
                tokens.add(new Token(Token.Type.WHITESPACE, ws));
                offset += i - offset;
                return;
            }
        }
        tokens.add(new Token(Token.Type.WHITESPACE, input.substring(offset)));
        offset = input.length();
    }

    private void tokenizeLiteralInt() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isNumeric(input.charAt(i))) {
                var literal = input.substring(offset, i);
                tokens.add(Token.intLiteral(literal));
                offset += literal.length();
                return;
            }
        }
        tokens.add(Token.intLiteral(input.substring(offset)));
        offset = input.length();
    }

    private void tokenizeLiteralString() throws TokenizeException {
        for (int i = offset+1; i < input.length(); ++i) {
            if (input.charAt(i) == '"') {
                var literal = input.substring(offset+1, i);
                tokens.add(Token.stringLiteral(literal));
                offset += literal.length() + 2; // for quotes, which the captured literal omits
                return;
            }
        }
        throw new TokenizeException("unterminated string literal");
    }

    private void tokenizeIdentifier() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isLegalIdent(input.charAt(i))) {
                var ident = input.substring(offset, i);
                tokens.add(Token.identifier(ident));
                offset += ident.length();
                return;
            }
        }
        tokens.add(Token.identifier(input.substring(offset)));
        offset = input.length();
    }
}

package com.lootfilters;

import lombok.AllArgsConstructor;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;

import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public class LootbeamIndex {
    private final LootFiltersPlugin plugin;

    private final Map<Tile, Map<TileItem, Lootbeam>> index = new HashMap<>();

    public int size() {
        return index.values().stream()
                .mapToInt(Map::size)
                .sum();
    }

    public void put(Tile tile, TileItem item, Lootbeam beam) {
        if (!index.containsKey(tile)) {
            index.put(tile, new HashMap<>());
        }

        var beams = index.get(tile);
        beams.put(item, beam);
    }

    public void remove(Tile tile, TileItem item) {
        if (!index.containsKey(tile)) {
            return; // what?
        }

        var beams = index.get(tile);
        if (!beams.containsKey(item)) {
            return; // what?
        }

        var beam = beams.get(item);
        beam.remove();
        beams.remove(item);
        if (beams.isEmpty()) {
            index.remove(tile);
        }
    }

    public void clear() {
        for (var beams : index.values()) {
            for (var beam : beams.values()) {
                beam.remove();
            }
        }
        index.clear();
    }

    public void reset() {
        clear();
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            for (var item : entry.getValue()) {
                var match = plugin.getActiveFilter().findMatch(plugin, item);
                if (match != null && match.isShowLootbeam()) {
                    put(tile, item, new Lootbeam(plugin.getClient(), plugin.getClientThread(), tile.getWorldLocation(),
                            match.getTextColor(), Lootbeam.Style.MODERN));
                }
            }
        }
    }
}

package com.lootfilters;

import com.google.gson.Gson;
import com.lootfilters.lang.CompileException;
import com.lootfilters.lang.Lexer;
import com.lootfilters.lang.Parser;
import com.lootfilters.lang.Preprocessor;
import com.lootfilters.rule.Rule;
import com.lootfilters.serde.ColorDeserializer;
import com.lootfilters.serde.ColorSerializer;
import com.lootfilters.serde.RuleDeserializer;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.awt.Color;
import java.io.IOException;
import java.util.List;

import static com.lootfilters.util.TextUtil.loadFilterScript;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class LootFilter {
    @Setter private String name; // anonymous filter can be imported, would need name

    private final String description;
    private final int[] activationArea;
    private final List<MatcherConfig> matchers;

    public static LootFilter fromJson(Gson gson, String json) {
        var ggson = gson.newBuilder()
                .registerTypeAdapter(Color.class, new ColorDeserializer())
                .registerTypeAdapter(Rule.class, new RuleDeserializer(gson))
                .create();
        return ggson.fromJson(json, LootFilter.class);
    }

    public static LootFilter fromSource(String source) throws CompileException, IOException {
        source = loadFilterScript("preamble.rs2f") + "\n" + source;
        var postproc = new Preprocessor(source).preprocess();
        var tokens = new Lexer(postproc).tokenize();
        return new Parser(tokens).parse();
    }

    public String toJson(Gson gson) {
        var ggson = gson.newBuilder()
                .registerTypeAdapter(Color.class, new ColorSerializer())
                .create();
        return ggson.toJson(this);
    }

    public DisplayConfig findMatch(LootFiltersPlugin plugin, TileItem item) {
        var match = matchers.stream()
                .filter(it -> it.getRule().test(plugin, item))
                .findFirst()
                .orElse(null);
        return match != null ? match.getDisplay() : null;
    }

    public boolean isInActivationArea(WorldPoint p) {
        if (activationArea == null) {
            return false;
        }
        return p.getX() >= activationArea[0] && p.getY() >= activationArea[1] && p.getPlane() >= activationArea[2]
                && p.getX() <= activationArea[3] && p.getY() <= activationArea[4] && p.getPlane() <= activationArea[5];
    }
}

package com.lootfilters;

import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import com.lootfilters.rule.Rule;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import net.runelite.api.TileItem;
import net.runelite.api.Varbits;

import java.awt.Color;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
public class MatcherConfig {
    private final Rule rule;
    private final DisplayConfig display;

    public static DisplayConfig findMatch(List<MatcherConfig> filters, LootFiltersPlugin plugin, TileItem item) {
        var match = filters.stream()
                .filter(it -> it.rule.test(plugin, item))
                .findFirst()
                .orElse(null);
        return match != null ? match.display : null;
    }

    public static MatcherConfig ownershipFilter(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                var accountType = plugin.getClient().getVarbitValue(Varbits.ACCOUNT_TYPE);
                return enabled && accountType != 0 && item.getOwnership() == TileItem.OWNERSHIP_OTHER;
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig itemSpawnFilter(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && item.getOwnership() == TileItem.OWNERSHIP_NONE;
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig showUnmatched(boolean enabled) {
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled;
            }
        };
        var display = DisplayConfig.builder()
                .textColor(Color.WHITE)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig valueTier(boolean enabled, int value, Color color, boolean showLootbeam, boolean notify) {
        var inner = new ItemValueRule(value, Comparator.GT_EQ);
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && inner.test(plugin, item);
            }
        };
        var display = DisplayConfig.builder()
                .textColor(color)
                .showValue(true)
                .showLootbeam(showLootbeam)
                .notify(notify)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig hiddenTier(boolean enabled, int value) {
        var inner = new ItemValueRule(value, Comparator.LT);
        var rule = new Rule("") {
            @Override public boolean test(LootFiltersPlugin plugin, TileItem item) {
                return enabled && inner.test(plugin, item);
            }
        };
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig highlight(String rawNames, Color color, boolean showLootbeam, boolean notify) {
        var rule = new OrRule(
                Arrays.stream(rawNames.split(","))
                        .map(ItemNameRule::new)
                        .collect(Collectors.toList())
        );
        var display = DisplayConfig.builder()
                .textColor(color)
                .showLootbeam(showLootbeam)
                .notify(notify)
                .build();
        return new MatcherConfig(rule, display);
    }

    public static MatcherConfig hide(String rawNames) {
        var rule = new OrRule(
                Arrays.stream(rawNames.split(","))
                        .map(ItemNameRule::new)
                        .collect(Collectors.toList())
        );
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new MatcherConfig(rule, display);
    }
}

package com.lootfilters;

import lombok.AllArgsConstructor;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.awt.Color;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static net.runelite.client.util.ColorUtil.colorTag;

@AllArgsConstructor
public class MenuEntryComposer {
    private final LootFiltersPlugin plugin;

    public void onMenuEntryAdded(MenuEntry entry) { // recolor/add quantity
        if (!isGroundItem(entry)) {
            return;
        }

        var item = getItemForEntry(entry);
        var match = plugin.getActiveFilter().findMatch(plugin, item);
        if (match == null) {
            return;
        }

        entry.setDeprioritized(match.isHidden());
        entry.setTarget(buildTargetText(item, match));
    }

    public void onMenuOpened() { // collapse
        var menu = plugin.getClient().getMenu();
        var entries = menu.getMenuEntries();

        var itemCounts = Stream.of(entries)
                .filter(MenuEntryComposer::isGroundItem)
                .collect(Collectors.groupingBy(it -> it.getType()+it.getTarget(), Collectors.counting()));

        var newEntries = Arrays.stream(entries)
                .map(it -> isGroundItem(it)
                        ? withCount(it, itemCounts.getOrDefault(it.getType()+it.getTarget(), 1L))
                        : it)
                .distinct()
                .toArray(MenuEntry[]::new);
        menu.setMenuEntries(newEntries);
    }

    private MenuEntry withCount(MenuEntry entry, long count) {
        return count > 1
                ? entry.setTarget(entry.getTarget() + " x" + count)
                : entry;
    }

    private TileItem getItemForEntry(MenuEntry entry) {
        var wv = plugin.getClient().getTopLevelWorldView();
        var point = WorldPoint.fromScene(wv, entry.getParam0(), entry.getParam1(), wv.getPlane());
        return plugin.getTileItemIndex().findItem(point, entry.getIdentifier());
    }

    private String buildTargetText(TileItem item, DisplayConfig display) {
        var text = plugin.getItemName(item.getId());
        if (item.getQuantity() > 1) {
            text += " (" + item.getQuantity() + ")";
        }
        var colorTag = display.getTextColor().equals(Color.WHITE)
                ? colorTag(Color.decode("#ff9040"))
                : colorTag(display.getTextColor());
        return colorTag + text;
    }

    private static boolean isGroundItem(MenuEntry entry) {
        var type = entry.getType();
        return type == MenuAction.GROUND_ITEM_FIRST_OPTION
                || type == MenuAction.GROUND_ITEM_SECOND_OPTION
                || type == MenuAction.GROUND_ITEM_THIRD_OPTION
                || type == MenuAction.GROUND_ITEM_FOURTH_OPTION
                || type == MenuAction.GROUND_ITEM_FIFTH_OPTION
                || type == MenuAction.EXAMINE_ITEM_GROUND;
    }
}

package com.lootfilters;

import com.lootfilters.rule.TextAccent;
import com.lootfilters.rule.ValueTier;
import com.lootfilters.rule.ValueType;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Units;

import java.awt.Color;

@ConfigGroup("loot-filters")
public interface LootFiltersConfig extends Config {
    @ConfigSection(
            name = "General",
            description = "Configure general options.",
            position = 0
    )
    String general = "general";
    @ConfigItem(
            keyName = "autoToggleFilter",
            name = "Auto-toggle active filter",
            description = "Filters can be annotated with area boundaries in which they are relevant. If enabled, filters will automatically become active when the player enters their corresponding area.",
            section = general,
            position = 0
    )
    default boolean autoToggleFilters() {
        return true;
    }
    @ConfigItem(
            keyName = "showUnmatchedItems",
            name = "Show unmatched items",
            description = "Give a default text overlay to items that don't match the active filter.",
            section = general,
            position = 1
    )
    default boolean showUnmatchedItems() { return true; }
    @ConfigItem(
            keyName = "ownershipFilter",
            name = "Ownership filter",
            description = "When enabled, filters out any items you cannot pick up. This filter overrides ALL other rules/config.",
            section = general,
            position = 3
    )
    default boolean ownershipFilter() { return false; }
    @ConfigItem(
            keyName = "itemSpawnFilter",
            name = "Item spawn filter",
            description = "When enabled, filters out item spawns (world spawns, ashes from fire, etc). This filter overrides ALL other rules/config.",
            section = general,
            position = 4
    )
    default boolean itemSpawnFilter() { return false; }
    @ConfigItem(
            keyName = "valueType",
            name = "Value type",
            description = "The type of item value to use for rules and text overlay.",
            section = general,
            position = 5
    )
    default ValueType valueType() { return ValueType.HIGHEST; }

    @ConfigSection(
            name = "Hotkey",
            description = "Configure hotkey options.",
            position = 1
    )
    String hotkey = "Hotkey";
    @ConfigItem(
            keyName = "hotkey",
            name = "Hotkey",
            description = "Hotkey used by this plugin.",
            section = hotkey,
            position = 0
    )
    default Keybind hotkey() { return Keybind.ALT; }
    @ConfigItem(
            keyName = "hotkeyShowHiddenItems",
            name = "Press: Show hidden items",
            description = "Show hidden items when hotkey is pressed.",
            section = hotkey,
            position = 1
    )
    default boolean hotkeyShowHiddenItems() { return true; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapTogglesOverlay",
            name = "Double-tap: toggle overlay",
            description = "When enabled, double-tap the hotkey to toggle the entire ground items overlay.",
            section = hotkey,
            position = 2
    )
    default boolean hotkeyDoubleTapTogglesOverlay() { return true; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapDelay",
            name = "Double-tap delay",
            description = "Period within which to register a hotkey double-tap.",
            section = hotkey,
            position = 3
    )
    @Units(Units.MILLISECONDS)
    default int hotkeyDoubleTapDelay() { return 250; }

    @ConfigSection(
            name = "Display overrides",
            description = "Configure global display overrides.",
            position = 2
    )
    String displayOverrides = "displayOverrides";
    @ConfigItem(
            keyName = "alwaysShowValue",
            name = "Show value",
            description = "Always show item value.",
            section = displayOverrides,
            position = 0
    )
    default boolean alwaysShowValue() { return false; }
    @ConfigItem(
            keyName = "alwaysShowDespawn",
            name = "Show despawn",
            description = "Always show item despawn timers.",
            section = displayOverrides,
            position = 1
    )
    default boolean alwaysShowDespawn() { return false; }
    @ConfigItem(
            keyName = "textAccent",
            name = "Text accent",
            description = "Text accent type.",
            section = displayOverrides,
            position = 2
    )
    default TextAccent textAccent() { return TextAccent.USE_FILTER; }

    @ConfigSection(
            name = "Item lists",
            description = "Configure default lists of highlighted and hidden items. Values are case-insensitive, separated by comma. These lists are checked AFTER the active filter, but before item value rules.",
            position = 8
    )
    String itemLists = "itemLists";
    @ConfigItem(
            keyName = "highlightedItems",
            name = "Highlighted items",
            description = "Configure a list of items to highlight.",
            section = itemLists,
            position = 0
    )
    default String highlightedItems() { return ""; }
    @ConfigItem(
            keyName = "hiddenItems",
            name = "Hidden items",
            description = "Configure a list of items to hide.",
            section = itemLists,
            position = 1
    )
    default String hiddenItems() { return ""; }
    @ConfigItem(keyName = "highlightedItems", name = "", description = "")
    void setHighlightedItems(String key);
    @ConfigItem(keyName = "hiddenItems", name = "", description = "")
    void setHiddenItems(String key);

    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight color",
            description = "Configures the color for highlighted items.",
            section = itemLists,
            position = 2
    )
    default Color highlightColor() { return Color.decode("#aa00ff"); }
    @ConfigItem(
            keyName = "highlightLootbeam",
            name = "Highlight lootbeam",
            description = "Configures whether highlighted items show a lootbeam.",
            section = itemLists,
            position = 3
    )
    default boolean highlightLootbeam() { return false; }
    @ConfigItem(
            keyName = "highlightNotify",
            name = "Highlight notification",
            description = "Configures whether highlighted items fire a system notification.",
            section = itemLists,
            position = 4
    )
    default boolean highlightNotify() { return false; }

    @ConfigSection(
            name = "Item value rules",
            description = "Configure default rules for showing based on item value. These rules are checked AFTER both the active filter and the global hide list.",
            position = 9
    )
    String itemValueRules = "itemValueRules";
    @ConfigItem(
            keyName = "lootbeamTier",
            name = "Lootbeam tier",
            description = "Minimum tier at which to show a lootbeam.",
            section = itemValueRules,
            position = 0
    )
    default ValueTier lootbeamTier() { return ValueTier.HIGH; }
    @ConfigItem(
            keyName = "notifyTier",
            name = "Notification tier",
            description = "Minimum tier at which to fire a system notification.",
            section = itemValueRules,
            position = 0
    )
    default ValueTier notifyTier() { return ValueTier.HIGH; }
    @ConfigItem(
            keyName = "enableInsaneItemValueTier",
            name = "Insane tier",
            description = "Enable INSANE item value tier.",
            section = itemValueRules,
            position = 11
    )
    default boolean enableInsaneItemValueTier() { return true; }
    @ConfigItem(
            keyName = "insaneValue",
            name = "Insane value",
            description = "Configures the value for INSANE tier.",
            section = itemValueRules,
            position = 12
    )
    default int insaneValue() { return 10_000_000; }
    @ConfigItem(
            keyName = "insaneValueColor",
            name = "Insane color",
            description = "Configures the color for INSANE item values.",
            section = itemValueRules,
            position = 13
    )
    default Color insaneValueColor() { return Color.decode("#ff66b2"); }
    @ConfigItem(
            keyName = "enableHighItemValueTier",
            name = "High tier",
            description = "Enable high item value tier.",
            section = itemValueRules,
            position = 14
    )
    default boolean enableHighItemValueTier() { return true; }
    @ConfigItem(
            keyName = "highValue",
            name = "High value",
            description = "Configures the value for high tier.",
            section = itemValueRules,
            position = 15
    )
    default int highValue() { return 1_000_000; }
    @ConfigItem(
            keyName = "highValueColor",
            name = "High color",
            description = "Configures the color for high item values.",
            section = itemValueRules,
            position = 16
    )
    default Color highValueColor() { return Color.decode("#ff9600"); }
    @ConfigItem(
            keyName = "enableMediumItemValueTier",
            name = "Medium tier",
            description = "Enable medium item value tier.",
            section = itemValueRules,
            position = 17
    )
    default boolean enableMediumItemValueTier() { return true; }
    @ConfigItem(
            keyName = "mediumValue",
            name = "Medium value",
            description = "Configures the value for medium tier.",
            section = itemValueRules,
            position = 18
    )
    default int mediumValue() { return 100_000; }
    @ConfigItem(
            keyName = "mediumValueColor",
            name = "Medium color",
            description = "Configures the color for medium item values.",
            section = itemValueRules,
            position = 19
    )
    default Color mediumValueColor() { return Color.decode("#99ff99"); }
    @ConfigItem(
            keyName = "enableLowItemValueTier",
            name = "Low tier",
            description = "Enable low item value tier.",
            section = itemValueRules,
            position = 20
    )
    default boolean enableLowItemValueTier() { return true; }
    @ConfigItem(
            keyName = "lowValue",
            name = "Low value",
            description = "Configures the value for low tier.",
            section = itemValueRules,
            position = 21
    )
    default int lowValue() { return 10_000; }
    @ConfigItem(
            keyName = "lowValueColor",
            name = "Low color",
            description = "Configures the color for low item values.",
            section = itemValueRules,
            position = 22
    )
    default Color lowValueColor() { return Color.decode("#66b2ff"); }
    @ConfigItem(
            keyName = "hiddenTierEnabled",
            name = "Hide below value tier",
            description = "Hide items below a certain value.",
            section = itemValueRules,
            position = 23
    )
    default boolean hideTierEnabled() { return false; }
    @ConfigItem(
            keyName = "hiddenValue",
            name = "Hide below value",
            description = "Hide items below this value, if enabled.",
            section = itemValueRules,
            position = 24
    )
    default int hideTierValue() { return 0; }
}

package com.lootfilters;

import net.runelite.client.input.MouseAdapter;

import javax.inject.Inject;
import java.awt.event.MouseEvent;

import static com.lootfilters.util.TextUtil.setCsv;
import static com.lootfilters.util.TextUtil.unsetCsv;
import static javax.swing.SwingUtilities.isLeftMouseButton;
import static javax.swing.SwingUtilities.isMiddleMouseButton;
import static javax.swing.SwingUtilities.isRightMouseButton;

public class LootFiltersMouseAdapter extends MouseAdapter {
    @Inject private LootFiltersPlugin plugin;

    @Override
    public MouseEvent mousePressed(MouseEvent e) {
        var hover = plugin.getHoveredItem();
        if (hover == -1 || !plugin.isHotkeyActive()) {
            return e;
        }

        var highlights = plugin.getConfig().highlightedItems();
        var hides = plugin.getConfig().hiddenItems();
        if (isLeftMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
                plugin.getConfig().setHighlightedItems(setCsv(highlights, item));
            });
            e.consume();
        } else if (isRightMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
                plugin.getConfig().setHiddenItems(setCsv(hides, item));
            });
            e.consume();
        } else if (isMiddleMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
            });
            e.consume();
        }
        return e;
    }
}

package com.lootfilters;

import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class TileItemIndex {
    private final Map<Tile, List<TileItem>> itemIndex = new HashMap<>();

    // Tile instances are not readily available in all contexts,
    private final Map<WorldPoint, Tile> pointIndex = new HashMap<>();

    public Set<Map.Entry<Tile, List<TileItem>>> entrySet() {
        return itemIndex.entrySet();
    }

    public TileItem findItem(Tile tile, int id) {
        if (!itemIndex.containsKey(tile)) {
            return null;
        }

        return itemIndex.get(tile).stream()
                .filter(it -> it.getId() == id)
                .findFirst()
                .orElse(null);
    }

    public TileItem findItem(WorldPoint point, int id) {
        return pointIndex.containsKey(point)
                ? findItem(pointIndex.get(point), id)
                : null;
    }

    public void put(Tile tile, TileItem item) {
        if (!itemIndex.containsKey(tile)) {
            itemIndex.put(tile, new ArrayList<>());
        }
        itemIndex.get(tile).add(item);
        pointIndex.put(tile.getWorldLocation(), tile);
    }

    public void remove(Tile tile, TileItem item) {
        if (!itemIndex.containsKey(tile)) {
            return; // what?
        }

        var items = itemIndex.get(tile);
        items.remove(item);
        if (items.isEmpty()) {
            itemIndex.remove(tile);
            pointIndex.remove(tile.getWorldLocation());
        }
    }

    public int pointIndexSize() {
        return pointIndex.size();
    }

    public void clear() {
        itemIndex.clear();
        pointIndex.clear();
    }
}

/*
 * Copyright (c) 2021, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.lootfilters;

import lombok.RequiredArgsConstructor;
import net.runelite.api.Animation;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.Model;
import net.runelite.api.ModelData;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;

import java.awt.Color;
import java.util.function.Function;

// copied verbatim (including copyright notice & disclaimer) from
// https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/grounditems/Lootbeam.java
//
// local modifications:
// remove() - wrapped setActive() call in clientThread.invoke(), where setActive must be called (throws otherwise)
class Lootbeam
{
    private final RuneLiteObject runeLiteObject;
    private final Client client;
    private final ClientThread clientThread;
    private Color color;
    private Style style;

    @RequiredArgsConstructor
    public enum Style
    {
        LIGHT(l -> l.client.loadModel(
                5809,
                new short[]{6371},
                new short[]{JagexColor.rgbToHSL(l.color.getRGB(), 1.0d)}
        ), anim(AnimationID.RAID_LIGHT_ANIMATION)),
        MODERN(l ->
        {
            ModelData md = l.client.loadModelData(43330);
            if (md == null)
            {
                return null;
            }

            short hsl = JagexColor.rgbToHSL(l.color.getRGB(), 1.0d);
            int hue = JagexColor.unpackHue(hsl);
            int sat = JagexColor.unpackSaturation(hsl);
            int lum = JagexColor.unpackLuminance(hsl);
            int satDelta = sat > 2 ? 1 : 0;

            return md.cloneColors()
                    .recolor((short) 26432, JagexColor.packHSL(hue, sat - satDelta, lum))
                    .recolor((short) 26584, JagexColor.packHSL(hue, sat, Math.min(lum + 24, JagexColor.LUMINANCE_MAX)))
                    .light(75 + ModelData.DEFAULT_AMBIENT, 1875 + ModelData.DEFAULT_CONTRAST,
                            ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        }, anim(AnimationID.LOOTBEAM_ANIMATION)),
        ;

        private final Function<Lootbeam, Model> modelSupplier;
        private final Function<Lootbeam, Animation> animationSupplier;
    }

    private static Function<Lootbeam, Animation> anim(int id)
    {
        return b -> b.client.loadAnimation(id);
    }

    public Lootbeam(Client client, ClientThread clientThread, WorldPoint worldPoint, Color color, Style style)
    {
        this.client = client;
        this.clientThread = clientThread;
        runeLiteObject = client.createRuneLiteObject();

        this.color = color;
        this.style = style;
        update();
        runeLiteObject.setShouldLoop(true);

        LocalPoint lp = LocalPoint.fromWorld(client, worldPoint);
        runeLiteObject.setLocation(lp, client.getPlane());

        runeLiteObject.setActive(true);
    }

    public void setColor(Color color)
    {
        if (this.color != null && this.color.equals(color))
        {
            return;
        }

        this.color = color;
        update();
    }

    public void setStyle(Style style)
    {
        if (this.style == style)
        {
            return;
        }

        this.style = style;
        update();
    }

    private void update()
    {
        clientThread.invoke(() ->
        {
            Model model = style.modelSupplier.apply(this);
            if (model == null)
            {
                return false;
            }

            Animation anim = style.animationSupplier.apply(this);

            runeLiteObject.setAnimation(anim);
            runeLiteObject.setModel(model);
            return true;
        });
    }

    public void remove()
    {
        clientThread.invoke(() -> runeLiteObject.setActive(false));
    }

}
package com.lootfilters;

import com.google.gson.Gson;
import com.lootfilters.rule.AndRule;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemIdRule;
import com.lootfilters.rule.ItemNameRule;
import com.lootfilters.rule.ItemQuantityRule;
import com.lootfilters.rule.ItemValueRule;
import com.lootfilters.rule.OrRule;
import org.junit.Test;

import java.awt.Color;
import java.util.List;

import static org.junit.Assert.assertEquals;

public class LootFilterSerdeTest {
    @Test
    public void testSerde() {
        var filter = new LootFilter(
                "foo",
                "bar",
                null,
                List.of(
                        new MatcherConfig(new ItemIdRule(1), new DisplayConfig(Color.RED)),
                        new MatcherConfig(new ItemNameRule("bandos-crossbow"), new DisplayConfig(Color.GREEN)),
                        new MatcherConfig(new ItemValueRule(1_000, Comparator.LT), new DisplayConfig(Color.BLUE)),
                        new MatcherConfig(new ItemQuantityRule(1_000, Comparator.LT), new DisplayConfig(Color.WHITE)),
                        new MatcherConfig(
                                new AndRule(List.of(
                                        new ItemNameRule("Coins"),
                                        new ItemQuantityRule(5, Comparator.EQ)
                                )),
                                new DisplayConfig(Color.WHITE.darker())
                        ),
                        new MatcherConfig(
                                new OrRule(List.of(
                                        new ItemNameRule("Coins"),
                                        new ItemQuantityRule(9, Comparator.EQ)
                                )),
                                new DisplayConfig(Color.WHITE.darker())
                        )
                )
        );

        var gson = new Gson();
        var ser = filter.toJson(gson);
        var deser = LootFilter.fromJson(gson, ser);

        assertEquals(filter, deser);
    }
}

package com.lootfilters;

import java.io.IOException;

import static com.lootfilters.util.TextUtil.normalizeCrlf;

public class TestUtil {
    private TestUtil() {}

    public static String loadTestResource(String resource) throws IOException {
        try (var r = TestUtil.class.getResourceAsStream(resource)) {
            assert r != null;
            return normalizeCrlf(new String(r.readAllBytes()));
        }
    }
}

package com.lootfilters;

import com.lootfilters.lang.Preprocessor;
import org.junit.Test;

import static com.lootfilters.TestUtil.loadTestResource;
import static org.junit.Assert.assertEquals;

public class PreprocessorTest {
    @Test
    public void testPreprocess() throws Exception {
        var input = loadTestResource("preprocessor-test-input.rs2f");
        var expect = loadTestResource("preprocessor-test-expect.rs2f");

        var preprocessor = new Preprocessor(input);
        var actual = preprocessor.preprocess();
        assertEquals(expect, actual);
    }
}

package com.lootfilters;

import com.lootfilters.lang.Lexer;
import com.lootfilters.lang.Parser;
import com.lootfilters.rule.Comparator;
import com.lootfilters.rule.ItemValueRule;
import org.junit.Test;

import java.awt.Color;
import java.util.List;

import static com.lootfilters.TestUtil.loadTestResource;
import static org.junit.Assert.assertEquals;

public class ParserTest {
    @Test
    public void testSingleRule() throws Exception {
        var input = loadTestResource("parser-test.rs2f");

        var expectName = "loot tiers";
        var expectDesc = "loot tiers like the ground items builtin";
        var expectArea = new int[]{1,2,3,4,5,6};
        var expectMatchers = List.of(
                new MatcherConfig(new ItemValueRule(10_000_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0xff,0x80,0x00, 0xff))
                                .showLootbeam(true)
                                .build()),
                new MatcherConfig(new ItemValueRule(1_000_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0xa3,0x35,0xee, 0xff))
                                .showLootbeam(true)
                                .build()),
                new MatcherConfig(new ItemValueRule(100_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0x00,0x70,0xdd, 0xff))
                                .build()),
                new MatcherConfig(new ItemValueRule(10_000, Comparator.GT),
                        DisplayConfig.builder()
                                .textColor(new Color(0x1e,0xff,0x00, 0xff))
                                .build())
        );
        var expect = new LootFilter(expectName, expectDesc, expectArea, expectMatchers);

        var tokens = new Lexer(input).tokenize();
        var parser = new Parser(tokens);
        var actual = parser.parse();
        assertEquals(expect, actual);
    }
}

package com.lootfilters;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootFiltersPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(LootFiltersPlugin.class);
		RuneLite.main(args);
	}
}
