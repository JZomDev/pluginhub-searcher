package com.lootfilters;

import com.lootfilters.lang.CompileException;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.PluginPanel;

import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import java.awt.Color;
import java.awt.Desktop;
import java.awt.FlowLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.DataFlavor;
import java.awt.event.ActionEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.util.List;
import java.util.Map;

import static com.lootfilters.util.TextUtil.quote;
import static javax.swing.JOptionPane.showConfirmDialog;
import static javax.swing.JOptionPane.showInputDialog;
import static javax.swing.JOptionPane.showMessageDialog;

@Slf4j
public class LootFiltersPanel extends PluginPanel {
    private static final String NONE_ITEM = "<none>";
    private static final String NONE_DESCRIPTION = "Select a filter to show its description.";
    private static final String BLANK_DESCRIPTION = "<no description provided>";

    private final LootFiltersPlugin plugin;
    private final JComboBox<String> filterSelect;
    private final JPanel root;
    private final JTextArea filterDescription;

    public LootFiltersPanel(LootFiltersPlugin plugin) {
        this.plugin = plugin;

        filterSelect = new JComboBox<>();
        filterDescription = new JTextArea();
        filterDescription.setLineWrap(true);
        filterDescription.setEditable(false);

        root = new JPanel();
        root.setLayout(new BoxLayout(root, BoxLayout.Y_AXIS));

        init();
    }

    private void init() {
        var top = new JPanel();
        top.setLayout(new BoxLayout(top, BoxLayout.X_AXIS));
        var mid = new JPanel(new FlowLayout(FlowLayout.LEFT));
        var bottom = new JPanel(new FlowLayout(FlowLayout.LEFT));

        var label = new JLabel("Active filter:");
        var importClipboard = createIconButton(Icons.CLIPBOARD_PASTE,
                "Import filter from clipboard.",
                this::onImportClipboard);

        var reloadFilters = createIconButton(Icons.RELOAD,
                "Reload filters from disk.",
                this::onReloadFilters);
        var browseFolder = createIconButton(Icons.FOLDER,
                "View the plugin directory, where filters, sound files, and icon files should be placed, in the system file browser.",
                this::onBrowseFolder);

        var openFiltersite = new JLabel("<html><u>filterscape.xyz</u></html>");
        openFiltersite.setForeground(Color.decode("#00a0ff"));
        openFiltersite.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseClicked(MouseEvent e) {
                try {
                    Desktop.getDesktop().browse(URI.create("https://filterscape.xyz"));
                } catch (Exception ex) {
                    log.warn("open filterscape.xyz", ex);
                }
            }
        });

        top.add(Box.createHorizontalStrut(1));
        top.add(importClipboard);
        top.add(Box.createGlue());
        top.add(reloadFilters);
        top.add(browseFolder);

        mid.add(label);

        bottom.add(openFiltersite);

        root.add(top);
        root.add(mid);
        root.add(filterSelect);
        root.add(bottom);
        root.add(filterDescription);

        add(root);

        reflowFilterSelect(plugin.getLoadedFilters(), plugin.getSelectedFilterName());
        reflowFilterDescription();
    }

    private void onImportClipboard() {
        var newSrc = getClipboard();
        if (newSrc == null) {
            plugin.addChatMessage("Import failed: no text in clipboard.");
            return;
        }

        if (newSrc.startsWith("https://filterscape.xyz/import")) {
            plugin.addChatMessage("This is a link to import a filter on filterscape.xyz, taking you there now...");
            try {
                Desktop.getDesktop().browse(URI.create(newSrc + "&pluginRedirect=true"));
            } catch (Exception ex) {
                log.warn("open filterscape.xyz", ex);
            }
            return;
        }

        LootFilter newFilter;
        try {
            plugin.addChatMessage("Importing...");
            newFilter = LootFilter.fromSourcesWithPreamble(Map.of("clipboard", newSrc));
        } catch (CompileException e) {
            plugin.addChatMessage("Import failed: " + e.getMessage());
            return;
        }

        if (newFilter.getName() == null || newFilter.getName().isBlank()) {
            plugin.addChatMessage("Import failed: this filter does not have a name.");
            return;
        }

        var existing = plugin.getLoadedFilters();
        for (var filter : existing) {
            if (!filter.getName().equals(newFilter.getName())) {
                continue;
            }
            if (!confirm("Filter " + quote(filter.getName()) + " already exists. Update it?")) {
                return;
            }

            try {
                plugin.getFilterManager().updateFilter(filter.getFilename(), newSrc);
            } catch (Exception e) {
                plugin.addChatMessage("Import failed: " + e.getMessage());
                return;
            }

            plugin.setSelectedFilterName(newFilter.getName());
            onReloadFilters();
            return;
        }

        try {
            plugin.getFilterManager().saveNewFilter(newFilter.getName(), newSrc);
        } catch (Exception e) {
            plugin.addChatMessage("Import failed: " + e.getMessage());
            return;
        }

        plugin.setSelectedFilterName(newFilter.getName());
        onReloadFilters();
    }

    private void onFilterSelect(ActionEvent event) {
        var selected = (String) filterSelect.getSelectedItem();
        plugin.setSelectedFilterName(NONE_ITEM.equals(selected) ? null : selected);
    }

    private JButton createIconButton(BufferedImage icon, String tooltip, Runnable onClick) {
        var button = new JButton("", new ImageIcon(icon));
        button.setToolTipText(tooltip);
        button.setBackground(null);
        button.setBorder(null);
        button.addActionListener(it -> onClick.run());
        return button;
    }

    private boolean confirm(String confirmText) {
        var result = showConfirmDialog(this, confirmText, "Confirm", JOptionPane.YES_NO_OPTION);
        return result == JOptionPane.YES_OPTION;
    }

    private static String getClipboard() {
        try {
            return (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);
        } catch (Exception e) {
            return null;
        }
    }

    private void onReloadFilters() {
        plugin.reloadFilters();
        reflowFilterSelect(plugin.getLoadedFilters(), plugin.getSelectedFilterName());
        reflowFilterDescription();
    }

    private void onBrowseFolder() {
        try {
            Desktop.getDesktop().open(LootFiltersPlugin.PLUGIN_DIRECTORY);
        } catch (Exception e) {
            log.warn("browse filters", e);
        }
    }

    public void reflowFilterSelect(List<LootFilter> filters, String selected) {
        for (var l : filterSelect.getActionListeners()) {
            filterSelect.removeActionListener(l);
        }

        filterSelect.removeAllItems();
        filterSelect.addItem(NONE_ITEM);
        for (var filter : filters) {
            filterSelect.addItem(filter.getName());
        }

        if (plugin.hasFilter(selected)) { // selected filter could be gone
            filterSelect.setSelectedItem(selected);
        } else {
            plugin.setSelectedFilterName(null);
        }
        filterSelect.addActionListener(this::onFilterSelect);
    }

    public void reflowFilterDescription() {
        if (plugin.getSelectedFilterName() == null) {
            filterDescription.setText(NONE_DESCRIPTION);
            return;
        }

        var filter = plugin.getActiveFilter();
        var desc = filter.getDescription();
        if (desc == null || desc.isBlank()) {
            desc = BLANK_DESCRIPTION;
        }
        filterDescription.setText(desc.replaceAll("<br>", "\n"));
    }
}

package com.lootfilters;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.lootfilters.migration.Migrate_133_140;
import com.lootfilters.model.DisplayConfigIndex;
import com.lootfilters.model.IconIndex;
import com.lootfilters.model.PluginTileItem;
import com.lootfilters.model.SoundProvider;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Tile;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemQuantityChanged;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.client.Notifier;
import net.runelite.client.audio.AudioPlayer;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.inject.Named;
import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import static com.lootfilters.util.FilterUtil.withConfigRules;
import static net.runelite.client.RuneLite.RUNELITE_DIR;
import static net.runelite.client.util.ColorUtil.colorToHexCode;
import static net.runelite.client.util.ImageUtil.loadImageResource;

@Slf4j
@PluginDescriptor(
	name = "Loot Filters",
	description = "Improved ground items plugin with scriptable loot filters.",
	tags = {"loot", "filters", "improved", "ground", "items"},
	conflicts = {"Ground Items"}
)
@Getter
public class LootFiltersPlugin extends Plugin {
	public static final String CONFIG_GROUP = "loot-filters";
	public static final String SELECTED_FILTER_KEY = "selected-filter";

	public static final File PLUGIN_DIRECTORY = new File(RUNELITE_DIR, "loot-filters");
	public static final File FILTER_DIRECTORY = new File(PLUGIN_DIRECTORY, "filters");
	public static final File SOUND_DIRECTORY = new File(PLUGIN_DIRECTORY, "sounds");
	public static final File ICON_DIRECTORY = new File(PLUGIN_DIRECTORY, "icons");

	@Inject private Client client;
	@Inject private ClientThread clientThread;
	@Inject private ClientToolbar clientToolbar;

	@Inject private LootFiltersConfig config;
	@Inject private LootFiltersOverlay overlay;
	@Inject private LootFiltersMouseAdapter mouseAdapter;
	@Inject private LootFiltersHotkeyListener hotkeyListener;
	@Inject private OverlayStateIndicator overlayStateIndicator;

	@Inject private Gson gson;
	@Inject private OverlayManager overlayManager;
	@Inject private KeyManager keyManager;
	@Inject private MouseManager mouseManager;
	@Inject private ConfigManager configManager;
	@Inject private ItemManager itemManager;
	@Inject private Notifier notifier;
	@Inject private SpriteManager spriteManager;
	@Inject private OkHttpClient okHttpClient;
	@Inject private AudioPlayer audioPlayer;
	@Inject private InfoBoxManager infoBoxManager;

	private LootFiltersPanel pluginPanel;
	private NavigationButton pluginPanelNav;

	private final TileItemIndex tileItemIndex = new TileItemIndex();
	private final LootbeamIndex lootbeamIndex = new LootbeamIndex(this);
	private final DisplayConfigIndex displayIndex = new DisplayConfigIndex(this);
	private final IconIndex iconIndex = new IconIndex(this);

	private final MenuEntryComposer menuEntryComposer = new MenuEntryComposer(this);
	private final LootFilterManager filterManager = new LootFilterManager(this);
	private final ExecutorService audioDispatcher = Executors.newSingleThreadExecutor();
	private final Set<SoundProvider> queuedAudio = new HashSet<>();
	private final List<String> queuedChatMessages = new ArrayList<>();

	@Getter private LootFilter activeFilter;
	private List<LootFilter> parsedUserFilters;

	@Setter private int hoveredItem = -1;
	@Setter private int hoveredHide = -1;
	@Setter private int hoveredHighlight = -1;
	@Setter private boolean hotkeyActive = false;
	@Setter private boolean isOverlayEnabled = true;

	@Inject @Named("developerMode") boolean developerMode;

	@Getter private boolean debugEnabled = false;

	public boolean isDeveloperMode() {
		return developerMode && debugEnabled;
	}

	public String getSelectedFilterName() {
		return configManager.getConfiguration(CONFIG_GROUP, SELECTED_FILTER_KEY);
	}

	public void setSelectedFilterName(String name) {
		if (name != null) {
			configManager.setConfiguration(CONFIG_GROUP, SELECTED_FILTER_KEY, name);
			if (name.equals(DefaultFilter.FILTERSCAPE.getName()) || name.equals(DefaultFilter.JOESFILTER.getName())) {
				config.setPreferredDefault(name);
			}
		} else {
			configManager.unsetConfiguration(CONFIG_GROUP, SELECTED_FILTER_KEY);
		}
	}

	public List<LootFilter> getLoadedFilters() {
		var filters = new ArrayList<LootFilter>();
		filters.addAll(filterManager.getDefaultFilters());
		filters.addAll(parsedUserFilters);
		return filters;
	}

	public LootFilter getSelectedFilter() {
		return getLoadedFilters().stream()
				.filter(it -> it.getName().equals(getSelectedFilterName()))
				.findFirst().orElse(LootFilter.Nop);
	}

	public boolean hasFilter(String name) {
		return getLoadedFilters().stream().anyMatch(it -> it.getName().equals(name));
	}

	public void addChatMessage(String msg) {
		queuedChatMessages.add(msg);
	}

	public String getItemName(int id) {
		return itemManager.getItemComposition(id).getName();
	}

	@Override
	protected void startUp() {
		debugEnabled = !System.getProperty("com.lootfilters.debug", "").isBlank();

		initPluginDirectory();
		overlayManager.add(overlay);
		infoBoxManager.addInfoBox(overlayStateIndicator);

		parsedUserFilters = filterManager.loadFilters();
		loadSelectedFilter();

		pluginPanel = new LootFiltersPanel(this);
		pluginPanelNav = NavigationButton.builder()
				.tooltip("Loot Filters")
				.icon(Icons.PANEL_ICON)
				.panel(pluginPanel)
				.build();
		if (config.showPluginPanel()) {
			clientToolbar.addNavigation(pluginPanelNav);
		}
		keyManager.registerKeyListener(hotkeyListener);
		mouseManager.registerMouseListener(mouseAdapter);

		if (config.fetchDefaultFilters()) {
			filterManager.fetchDefaultFilters(this::onFetchDefaultFilters);
		}

		Migrate_133_140.run(this);
	}

	@Override
	protected void shutDown() {
		overlayManager.remove(overlay);
		infoBoxManager.removeInfoBox(overlayStateIndicator);

		filterManager.getDefaultFilters().clear();
		clearIndices();

		clientToolbar.removeNavigation(pluginPanelNav);
		keyManager.unregisterKeyListener(hotkeyListener);
		mouseManager.unregisterMouseListener(mouseAdapter);
	}

	private void initPluginDirectory() {
		PLUGIN_DIRECTORY.mkdir();
		FILTER_DIRECTORY.mkdir();
		SOUND_DIRECTORY.mkdir();
		ICON_DIRECTORY.mkdir();
	}

	@Provides
	LootFiltersConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(LootFiltersConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) {
			return;
		}

		if (event.getKey().equals(LootFiltersConfig.SHOW_PLUGIN_PANEL)) {
			if (config.showPluginPanel()) {
				clientToolbar.addNavigation(pluginPanelNav);
			} else {
				clientToolbar.removeNavigation(pluginPanelNav);
			}
		}

		if (event.getKey().equals(LootFiltersConfig.CONFIG_KEY_FETCH_DEFAULT_FILTERS)) {
			if (config.fetchDefaultFilters()) {
				filterManager.fetchDefaultFilters(this::onFetchDefaultFilters);
			} else {
				var selected = getSelectedFilterName();
				filterManager.getDefaultFilters().clear();
				if (selected != null && selected.equals(DefaultFilter.FILTERSCAPE.getName())) {
					selected = null;
					setSelectedFilterName(null);
				}
				pluginPanel.reflowFilterSelect(getLoadedFilters(), selected);
			}
		}

		if (event.getKey().equals(SELECTED_FILTER_KEY)) {
			var selected = getSelectedFilterName();
			if (DefaultFilter.all().stream().anyMatch(it -> it.getName().equals(selected))) {
				addChatMessage("Loaded " + selected + ". Visit filterscape.xyz to configure it.");
			}
		}

		loadSelectedFilter();
		resetDisplay();

		pluginPanel.reflowFilterDescription();
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned event) {
		var tile = event.getTile();
		var item = new PluginTileItem(this, tile, event.getItem());

		tileItemIndex.put(tile, item);
		addItem(tile, item);
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned event) {
		var tile = event.getTile();
		var item = tileItemIndex.findItem(event.getItem());

		tileItemIndex.remove(tile, item);
		removeItem(tile, item);
	}

	@Subscribe
	public void onItemQuantityChanged(ItemQuantityChanged event) {
		var tile = event.getTile();
		var item = tileItemIndex.findItem(event.getItem());

		item.setQuantityOverride(event.getNewQuantity());
		removeItem(tile, item);
		addItem(tile, item);
	}

	private void addItem(Tile tile, PluginTileItem item) {
		var match = getActiveFilter().findMatch(this, item);

		displayIndex.put(item, match);
		if (match.isShowLootbeam()) {
			var beam = new Lootbeam(client, clientThread, tile.getWorldLocation(), match.getLootbeamColor(), Lootbeam.Style.MODERN);
			lootbeamIndex.put(tile, item, beam);
		}
		if (match.isNotify()) {
			notifier.notify(item.getName());
		}
		if (match.getSound() != null && config.soundVolume() > 0) {
			queuedAudio.add(match.getSound());
		}
		if (match.getIcon() != null && !match.isCompact()) {
			iconIndex.inc(match.getIcon(), item);
		}
		if(match.isCompact()){
			iconIndex.inc(match.getIcon(), item,config.compactRenderSize());
		}
	}

	private void removeItem(Tile tile, PluginTileItem item) {
		var display = displayIndex.get(item);
		lootbeamIndex.remove(tile, item);
		displayIndex.remove(item);
		if (display != null && display.getIcon() != null) {
			iconIndex.dec(display.getIcon(), item, display.isCompact()? config.compactRenderSize() : 16);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOADING) {
			clearIndices();
		}
	}

	@Subscribe
	private void onMenuEntryAdded(MenuEntryAdded event) {
		menuEntryComposer.onMenuEntryAdded(event.getMenuEntry());
	}

	@Subscribe
	public void onClientTick(ClientTick event) {
		menuEntryComposer.onClientTick();

		if (!queuedAudio.isEmpty()) {
			flushAudio();
		}
		if (!queuedChatMessages.isEmpty()) {
			flushChatMessages();
		}
	}

	private void flushAudio() {
		for (var provider : queuedAudio) {
			audioDispatcher.execute(() -> provider.play(this));
		}
		queuedAudio.clear();
	}

	private void flushChatMessages() {
		for (var msg : queuedChatMessages) {
			// CA_ID:{id}|<msg> is used to embed CA information into a GAMEMESSAGE chat. A side effect of this is that
			// whenever you have |s in a chat message, everything before the first | gets cut off. So, we just throw one
			// at the front of everything as a prophylactic measure since we might show || tokens in parse errors.
			var chatMsg = String.format("|<col=%s>[Loot Filters]</col>: %s", colorToHexCode(config.chatPrefixColor()), msg);
			client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", chatMsg, "loot-filters", false);
		}
		queuedChatMessages.clear();
	}

	private void clearIndices() {
		tileItemIndex.clear();
		lootbeamIndex.clear();
		displayIndex.clear();
		iconIndex.clear();
	}

	public void reloadFilters() {
		parsedUserFilters = filterManager.loadFilters();
		loadSelectedFilter();
		resetDisplay();
	}

	private void loadSelectedFilter() {
		activeFilter = withConfigRules(getSelectedFilter(), config);
	}

	private void resetDisplay() {
		clientThread.invoke(() -> {
			displayIndex.reset();
			lootbeamIndex.reset();
			iconIndex.reset();
		});
	}

	private void onFetchDefaultFilters() {
		if (getSelectedFilterName() == null) {
			setSelectedFilterName(config.getPreferredDefault());
		}
		pluginPanel.reflowFilterSelect(getLoadedFilters(), getSelectedFilterName());
	}
}

package com.lootfilters.util;

import com.lootfilters.model.TextAccent;
import lombok.Setter;
import net.runelite.client.ui.overlay.RenderableEntity;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;

// simplified version of runelite's TextComponent API for our purposes, adding support for _no_ text accent as well as
// text accent color
@Setter
public class TextComponent implements RenderableEntity {
    private String text;
    private Color color = Color.WHITE;
    private Color accentColor = Color.BLACK;
    private TextAccent textAccent = TextAccent.SHADOW;
    private Point position;

    @Override
    public Dimension render(Graphics2D g) {
        var origColor = g.getColor();

        g.setColor(accentColor);

        switch (textAccent) {
            case SHADOW:
                g.drawString(text, position.x + 1, position.y + 1);
                break;
            case OUTLINE:
                g.drawString(text, position.x + 1, position.y);
                g.drawString(text, position.x, position.y + 1);
                g.drawString(text, position.x - 1, position.y);
                g.drawString(text, position.x, position.y - 1);
                break;
            case SHADOW_BOLD:
                g.drawString(text, position.x + 1, position.y);
                g.drawString(text, position.x - 1, position.y);

                g.drawString(text, position.x, position.y + 1);
                g.drawString(text, position.x, position.y - 1);

                g.drawString(text, position.x + 1, position.y + 1);
                g.drawString(text, position.x - 1, position.y - 1);

                g.drawString(text, position.x + 1, position.y - 1);
                g.drawString(text, position.x - 1, position.y + 1);

                g.drawString(text, position.x + 2, position.y);
                g.drawString(text, position.x, position.y + 2);

                g.drawString(text, position.x + 2, position.y + 1);
                g.drawString(text, position.x + 1, position.y + 2);
                break;
            default:
                break;
        }

        g.setColor(color);
        g.drawString(text, position.x, position.y);

        g.setColor(origColor);
        return null;
    }
}

package com.lootfilters.util;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class CollectionUtil {
    private CollectionUtil() {}

    public static <E> List<E> append(List<E> list, E... elements) {
        var newList = new ArrayList<>(list);
        newList.addAll(Arrays.asList(elements));
        return newList;
    }

    public static <E> int[] findBounds(List<E> list, Predicate<E> predicate) { // [start, end)
        var indices = new int[]{-1, -1};
        for (var i = 0; i < list.size(); ++i) {
            if (indices[0] == -1 && predicate.test(list.get(i))) {
                indices[0] = i;
            }
            if (indices[0] != -1 && !predicate.test(list.get(i))) {
                indices[1] = i;
                return indices;
            }
        }
        if (indices[0] != -1) {
            indices[1] = list.size();
        }
        return indices;
    }
}

package com.lootfilters.util;

import java.io.IOException;
import java.util.Arrays;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TextUtil {
    private TextUtil() {}

    public static String quote(String text) {
        return '"' + text + '"';
    }

    public static boolean isNumeric(char c) {
        return c >= '0' && c <= '9';
    }

    public static boolean isAlpha(char c) {
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
    }

    public static boolean isLegalIdent(char c) {
        return c == '_' || isAlpha(c) || isNumeric(c);
    }

    public static String abbreviate(int value) {
        if (value >= 1e9) { // > 1b
            return String.format("%.2fB", (float)value / 1e9);
        } else if (value >= 1e8) { // > 100m
            return String.format("%.0fM", (float)value / 1e6);
        } else if (value >= 1e7) { // > 10m
            return String.format("%.1fM", (float)value / 1e6);
        } else if (value >= 1e6) { // > 1m
            return String.format("%.2fM", (float)value / 1e6);
        } else if (value >= 1e5) { // > 100k
            return String.format("%.0fK", (float)value / 1e3);
        } else if (value >= 1e4) { // > 10k
            return String.format("%.1fK", (float)value / 1e3);
        } else if (value >= 1e3) { // > 1k
            return String.format("%.2fK", (float)value / 1e3);
        }
        return Integer.toString(value);
    }

    public static String abbreviateValue(int value) {
        return value < 1000 ? value + "gp" : abbreviate(value);
    }

    public static String withParentheses(String value) {
        return "(" + value + ")";
    }

    public static String normalizeCrlf(String str) {
        return str
                .replaceAll("\r\n", "\n")
                .replaceAll("\r", "\n");
    }

    public static String setCsv(String csv, String value) {
        if (csv.isBlank()) {
            return value;
        }
        return Stream.concat(Arrays.stream(csv.split(",")), Stream.of(value))
                .map(String::toLowerCase)
                .distinct()
                .collect(Collectors.joining(","));
    }

    public static String unsetCsv(String csv, String value) {
        if (csv.isBlank()) {
            return "";
        }
        return Arrays.stream(csv.split(","))
                .filter(it -> !it.equalsIgnoreCase(value))
                .collect(Collectors.joining(","));
    }

    public static String toggleCsv(String csv, String item) {
        if (Arrays.stream(csv.split(",")).anyMatch(it -> it.trim().equalsIgnoreCase(item))) {
            return unsetCsv(csv, item);
        } else {
            return setCsv(csv, item);
        }
    }

    public static boolean isInfixWildcard(String str) {
        var index = -1;
        for (var i = 0; i < str.length(); ++i) {
            if (str.charAt(i) == '*') {
                if (index != -1) {
                    return false;
                }
                index = i;
            }
        }
        return index != -1 && index < str.length() - 1;
    }
}

package com.lootfilters.util;

import com.lootfilters.LootFilter;
import com.lootfilters.LootFiltersConfig;
import com.lootfilters.FilterRule;
import com.lootfilters.model.TextAccent;

import java.util.ArrayList;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.quote;
import static java.util.Arrays.stream;
import static java.util.stream.Collectors.joining;
import static net.runelite.client.util.ColorUtil.colorToAlphaHexCode;

public class FilterUtil {
    private FilterUtil() {
    }

    /**
     * Wraps a user-defined loot filter with config defaults (highlight/hide, value tiers, etc.).
     */
    public static LootFilter withConfigRules(LootFilter filter, LootFiltersConfig config) {
        var withConfig = new ArrayList<FilterRule>();

        withConfig.add(FilterRule.highlight(config));
        withConfig.add(FilterRule.hide(config.hiddenItems()));

        withConfig.addAll(filter.getRules());

        withConfig = withConfig.stream()
                .map(it -> it.withDisplay(builder -> {
                    if (config.alwaysShowValue()) {
                        builder.showValue(true);
                    }
                    if (config.alwaysShowDespawn()) {
                        builder.showDespawn(true);
                    }
                    if (config.textAccent().ordinal() > TextAccent.USE_FILTER.ordinal()) {
                        builder.textAccent(config.textAccent());
                    }
                    if (config.highlightTiles()) {
                        builder.highlightTile(true);
                    }
                }))
                .collect(Collectors.toCollection(ArrayList::new));

        return filter.toBuilder()
                .setRules(withConfig)
                .build();
    }

    /**
     * Captures the current config-based item matchers, exporting them to their own filter.
     */
    public static String configToFilterSource(LootFiltersConfig config, String name, String tutorialText) {
        var defines = "#define HCOLOR " + quote(colorToAlphaHexCode(config.highlightColor()));
        var meta = "meta {\n  name = " + quote(name) + ";\n}\n\n";
        var highlights = "";
        if (!config.highlightedItems().isBlank()) {
            highlights = stream(config.highlightedItems().split(","))
                    .map(it -> "HIGHLIGHT(" + quote(it) + ", HCOLOR)")
                    .collect(joining("\n"));
        }
        var hides = "";

        if (!config.hiddenItems().isBlank()) {
            hides = stream(config.hiddenItems().split(","))
                    .map(it -> "HIDE(" + quote(it) + ")")
                    .collect(joining("\n"));
        }

        return String.join("\n",
                defines,
                meta,
                tutorialText,
                highlights,
                hides);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import java.awt.Color;
import java.lang.reflect.Type;

public class ColorSerializer implements JsonSerializer<Color> {
    @Override
    public JsonElement serialize(Color color, Type type, JsonSerializationContext ctx) {
        var argb = String.format("%02x", color.getAlpha())
                + String.format("%02x", color.getRed())
                + String.format("%02x", color.getGreen())
                + String.format("%02x", color.getBlue());
        return new JsonPrimitive(argb);
    }
}

package com.lootfilters.serde;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;
import java.lang.reflect.Type;

public class ColorDeserializer implements JsonDeserializer<Color> {
    @Override
    public Color deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        return ColorUtil.fromHex(elem.getAsString());
    }
}

package com.lootfilters.serde;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.lootfilters.ast.AndCondition;
import com.lootfilters.ast.leaf.ItemIdCondition;
import com.lootfilters.ast.leaf.ItemNameCondition;
import com.lootfilters.ast.leaf.ItemQuantityCondition;
import com.lootfilters.ast.leaf.ItemValueCondition;
import com.lootfilters.ast.OrCondition;
import com.lootfilters.ast.leaf.ItemOwnershipCondition;
import com.lootfilters.ast.Condition;
import lombok.AllArgsConstructor;

import java.lang.reflect.Type;

@AllArgsConstructor
public class RuleDeserializer implements JsonDeserializer<Condition> {
    private final Gson gson;

    @Override
    public Condition deserialize(JsonElement elem, Type type, JsonDeserializationContext ctx) throws JsonParseException {
        var object = elem.getAsJsonObject();
        var discriminator = object.get("discriminator").getAsString();
        switch (discriminator) {
            case "item_id":
                return gson.fromJson(object, ItemIdCondition.class);
            case "item_ownership":
                return gson.fromJson(object, ItemOwnershipCondition.class);
            case "item_name":
                return gson.fromJson(object, ItemNameCondition.class);
            case "item_value":
                return gson.fromJson(object, ItemValueCondition.class);
            case "item_quantity":
                return gson.fromJson(object, ItemQuantityCondition.class);
            case "and":
                return deserializeInner(object, AndCondition.class);
            case "or":
                return deserializeInner(object, OrCondition.class);
            default:
                throw new JsonParseException("unknown rule type " + discriminator);
        }
    }

    private Condition deserializeInner(JsonElement elem, Type type) throws JsonParseException {
        return gson.newBuilder()
                .registerTypeAdapter(Condition.class, this)
                .create()
                .fromJson(elem, type);
    }
}

package com.lootfilters;

import com.lootfilters.model.BufferedImageProvider;
import com.lootfilters.model.DespawnTimerType;
import com.lootfilters.model.DualValueDisplayType;
import com.lootfilters.model.FontMode;
import com.lootfilters.model.PluginTileItem;
import com.lootfilters.model.ValueDisplayType;
import com.lootfilters.util.TextComponent;
import lombok.Getter;
import lombok.Setter;
import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.Player;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;

import javax.inject.Inject;
import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.time.Duration;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

import static com.lootfilters.util.TextUtil.abbreviate;
import static com.lootfilters.util.TextUtil.abbreviateValue;
import static com.lootfilters.util.TextUtil.withParentheses;
import static net.runelite.api.Perspective.getCanvasImageLocation;
import static net.runelite.api.Perspective.getCanvasTextLocation;
import static net.runelite.api.Perspective.getCanvasTilePoly;
import static net.runelite.client.ui.FontManager.getRunescapeSmallFont;

public class LootFiltersOverlay extends Overlay {
    private static final int BOX_PAD = 2;
    private static final int CLICKBOX_SIZE = 8;
    private static final int TIMER_RADIUS = 5;
    private static final int DEFAULT_IMAGE_HEIGHT = 32;
    private static final int DEFAULT_IMAGE_WIDTH = 36;
    private static final int MAX_DISTANCE = 24 * 128; // in LocalPoint units
    private static final Color DEBUG_BG = new Color(0, 0, 0, 0x80);

    private final Client client;
    private final LootFiltersPlugin plugin;
    private final LootFiltersConfig config;

    @Inject
    public LootFiltersOverlay(Client client, LootFiltersPlugin plugin, LootFiltersConfig config) {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        // we want to explicitly draw above overlays of plugins on the ABOVE_SCENE layer that do the "clipping" logic
        //   - Improved Tile Indicators is explicitly set to 0.6f
        //   - Better NPC Highlight is defaulted at 0.25f
        setPriority(PRIORITY_HIGH);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D g) {
        if (plugin.isDeveloperMode()) {
            renderDebugOverlay(g);
        }

        if (!plugin.isOverlayEnabled()) {
            return null;
        }

        var mouse = client.getMouseCanvasPosition();
        var hoveredItem = new AtomicInteger(-1);
        var hoveredHide = new AtomicInteger(-1);
        var hoveredHighlight = new AtomicInteger(-1);

        var player = client.getLocalPlayer();

        for (var entry : plugin.getTileItemIndex().entrySet()) { // all tile draws have to go first so text is on top
            if (inRenderRange(player, entry.getKey())) {
                highlightTiles(g, entry.getKey(), entry.getValue());
            }
        }
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            if (!inRenderRange(player, tile)) {
                continue;
            }

            var items = createItemCollection(entry.getValue());
            var currentOffset = 0;
            var compactRowPosition = 0;


            var remainingCompactMatches = items.get(true).size();

            for (var item : items.get(true)) {
                var effectiveRowLength = config.compactRenderRowLength() > remainingCompactMatches ? remainingCompactMatches : config.compactRenderRowLength();
                var textHeight = renderCompact(item.getOverlayKey().getDisplayConfig(), g, item.getFirstItem(), tile,
                        item.getCounts().getCount(), item.getCounts().getQuantity(), currentOffset, mouse,
                        hoveredItem::set, compactRowPosition, effectiveRowLength);
                if (textHeight == -1) {
                    continue; // didn't render
                }

                if (compactRowPosition >= config.compactRenderRowLength() - 1) {
                    compactRowPosition = 0;
                    currentOffset += textHeight + BOX_PAD + 3;
                    remainingCompactMatches -= config.compactRenderRowLength();
                } else {
                    compactRowPosition++;
                }
            }

            if (!items.get(true).isEmpty()) {
                currentOffset += config.compactRenderSize() / 2;
                if (compactRowPosition > 0) {
                    currentOffset += config.compactRenderSize() + BOX_PAD + 2;
                }
            }

            // non-compact

            for (var item : items.get(false)) {
                var leftOffset = 0;
                var match = item.getOverlayKey().getDisplayConfig();

                var overrideHidden = plugin.isHotkeyActive() && config.hotkeyShowHiddenItems();
                if (match.isHideOverlay() && !overrideHidden) {
                    continue;
                }

                var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
                if (loc == null) {
                    continue;
                }
                if (tile.getItemLayer() == null) {
                    continue;
                }

                if (config.fontMode() == FontMode.PLUGIN) {
                    g.setFont(match.getFont());
                } // otherwise we don't have to do anything, the font is already set

                var displayText = buildDisplayText(item.getFirstItem(), item.getCounts().getCount(), item.getCounts().getQuantity(), match);
                var textPoint = getCanvasTextLocation(client, g, loc, displayText, tile.getItemLayer().getHeight() + config.overlayZOffset());
                if (textPoint == null) {
                    continue;
                }

                var fm = g.getFontMetrics(g.getFont());
                var textWidth = fm.stringWidth(displayText);
                var textHeight = fm.getHeight();

                var text = new TextComponent();
                text.setText(displayText);
                text.setColor(match.isHidden() ? config.hiddenColor() : match.getTextColor());
                text.setPosition(new Point(textPoint.getX(), textPoint.getY() - currentOffset));
                if (match.getTextAccentColor() != null) {
                    text.setAccentColor(match.getTextAccentColor());
                }
                if (match.getTextAccent() != null) {
                    text.setTextAccent(match.getTextAccent());
                }

                var boundingBox = new Rectangle(
                        textPoint.getX() - BOX_PAD, textPoint.getY() - currentOffset - textHeight - BOX_PAD,
                        textWidth + 2 * BOX_PAD, textHeight + 2 * BOX_PAD
                );

                if (match.getBackgroundColor() != null) {
                    g.setColor(match.getBackgroundColor());
                    g.fillRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (match.getBorderColor() != null) {
                    g.setColor(match.getBorderColor());
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (plugin.isHotkeyActive() && boundingBox.contains(mouse.getX(), mouse.getY())) {
                    hoveredItem.set(item.getOverlayKey().getId());
                    g.setColor(match.isHidden() ? config.hiddenColor() : Color.WHITE);
                    g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
                }
                if (config.hotkeyShowClickboxes() && plugin.isHotkeyActive()) {
                    renderClickboxes(g, boundingBox, item.getFirstItem(), match, hoveredHide::set, hoveredHighlight::set);
                }

                text.render(g);

                if (match.getIcon() != null) {
                    var cacheKey = match.getIcon().getCacheKey(item.getFirstItem());
                    var d = renderIcon(g, cacheKey, textPoint, currentOffset);
                    leftOffset += d.width;
                }
                if (match.isShowDespawn() || plugin.isHotkeyActive()) {
                    var type = plugin.isHotkeyActive() ? DespawnTimerType.PIE : config.despawnTimerType();
                    renderDespawnTimer(g, type, item.getFirstItem(), textPoint, textWidth, currentOffset, leftOffset, false);
                }

                currentOffset += textHeight + BOX_PAD + 3;
            }
        }

        plugin.setHoveredItem(hoveredItem.get());
        plugin.setHoveredHide(hoveredHide.get());
        plugin.setHoveredHighlight(hoveredHighlight.get());
        return null;
    }

    private int renderCompact(DisplayConfig display, Graphics2D g, PluginTileItem item, Tile tile, long count, long quantity,
                              int currentOffset, net.runelite.api.Point mouse, Consumer<Integer> onHoveredItem, int rowOffset,
                              int rowSize) {
        var overrideHidden = plugin.isHotkeyActive() && config.hotkeyShowHiddenItems();
        if (display.isHideOverlay() && !overrideHidden) {
            return -1;
        }

        var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
        if (loc == null) {
            return -1;
        }
        if (tile.getItemLayer() == null) {
            return -1;
        }

        g.setFont(getRunescapeSmallFont()); // force the small font in compact mode because it's small

        var fm = g.getFontMetrics(g.getFont());
        var boxHeight = config.compactRenderSize();
        var boxWidth = Math.round(DEFAULT_IMAGE_WIDTH * boxHeight / (float) DEFAULT_IMAGE_HEIGHT);

        var image = plugin.getIconIndex().get(display.getIcon().getCacheKey(item, config.compactRenderSize()));
        if (image == null) {
            return -1;
        }

        boxHeight = image.getHeight();
        boxWidth = image.getWidth();
        var fullBoxWidth = boxWidth + 4;
        var imagePoint = getCanvasImageLocation(client, loc, image, tile.getItemLayer().getHeight() + config.overlayZOffset());
        if (imagePoint == null) {
            return -1;
        }
        // item square size- 1 px padding outside the bounding box, 1 px inside, item width, 1 px, 1 px.
        var boundingBox = new Rectangle(
                imagePoint.getX() + (fullBoxWidth) * rowOffset - Math.round(fullBoxWidth * ((rowSize - 1) / 2f)), imagePoint.getY() - currentOffset - boxHeight,
                boxWidth + 2, boxHeight + 2
        );

        if (display.getBackgroundColor() != null) {
            g.setColor(display.getBackgroundColor());
            g.fillRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
        }
        if (display.getBorderColor() != null) {
            g.setColor(display.getBorderColor());
            g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
        }
        if (plugin.isHotkeyActive() && boundingBox.contains(mouse.getX(), mouse.getY())) {
            onHoveredItem.accept(item.getId());

            g.setColor(display.isHidden() ? config.hiddenColor() : Color.WHITE);
            g.drawRect(boundingBox.x, boundingBox.y, boundingBox.width, boundingBox.height);
        }
        var displayText = "";
        if (quantity > 1) {
            if (quantity < 1000) {
                displayText += quantity;
            } else if (quantity < 99500) {
                displayText += String.format("%.0fK", (float) quantity / 1e3);
            } else {
                displayText += "Lots!";
            }
        }

        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, display.getTextColor().getAlpha() / 255f));
        g.drawImage(image, boundingBox.x + BOX_PAD / 2, boundingBox.y + BOX_PAD / 2, null);
        if (display.isShowDespawn() || plugin.isHotkeyActive()) {
            var type = plugin.isHotkeyActive() ? DespawnTimerType.PIE : config.despawnTimerType();
            renderDespawnTimer(g, type, item, new net.runelite.api.Point(boundingBox.x + BOX_PAD / 2, boundingBox.y + boundingBox.height), boxWidth + 2, 0, 0, true);
        }
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1));
        if (count > 1) {
            displayText += "x" + count;
        }
        var text = new TextComponent();
        text.setText(displayText);
        text.setColor(display.isHidden() ? config.hiddenColor() : display.getTextColor());
        text.setPosition(new Point(boundingBox.x + BOX_PAD / 2, boundingBox.y + fm.getHeight() + BOX_PAD / 2));
        text.render(g);

        return image.getHeight();
    }

    private Color getDespawnTextColor(PluginTileItem item) {
        if (item.getDespawnTime() - client.getTickCount() < 100) {
            return Color.RED;
        }
        if (!item.isPrivate() && item.getVisibleTime() <= client.getTickCount()) {
            return Color.YELLOW;
        }
        return Color.GREEN;
    }

    private String buildDisplayText(PluginTileItem item, int unstackedCount, int quantity, DisplayConfig display) {
        var text = item.getName();

        // BOTH of these can be true, we want them to be visually different either way
        if (quantity > 1) {
            text += " (" + abbreviate(quantity) + ")";
        }
        if (unstackedCount > 1) {
            text += " x" + unstackedCount;
        }

        var isMoney = item.getId() == ItemID.COINS || item.getId() == ItemID.PLATINUM; // value is redundant
        var showBecauseHotkey = config.hotkeyShowValues() && plugin.isHotkeyActive();
        if (isMoney || !(display.isShowValue() || showBecauseHotkey)) {
            return text;
        }

        var ge = item.getGePrice() * quantity;
        var ha = item.getHaPrice() * quantity;
        switch (showBecauseHotkey ? ValueDisplayType.BOTH : config.valueDisplayType()) {
            case HIGHEST:
                return ge == 0 && ha == 0 ? text
                        : text + " " + formatDualValueText(config.dualValueDisplay(), ge, ha, false);
            case GE:
                return ge == 0 ? text : String.format("%s (%s)", text, abbreviateValue(ge));
            case HA:
                return ha == 0 ? text : String.format("%s (%s)", text, abbreviateValue(ha));
            default: // BOTH
                return ge == 0 && ha == 0 ? text
                        : text + " " + formatDualValueText(config.dualValueDisplay(), ge, ha, true);
        }
    }

    private String formatDualValueText(DualValueDisplayType displayType, int geValue, int haValue, boolean showBoth) {
        var geFmt = abbreviateValue(geValue);
        var haFmt = abbreviateValue(haValue);
        var geFmtStr = displayType == DualValueDisplayType.COMPACT ? "%s" : "(GE: %s)";
        var haFmtStr = displayType == DualValueDisplayType.COMPACT ? "*%s" : "(HA: %s)";

        if (!showBoth) {
            var text = geValue >= haValue ? String.format(geFmtStr, geFmt) : String.format(haFmtStr, haFmt);
            return displayType == DualValueDisplayType.COMPACT ? withParentheses(text) : text;
        }

        var parts = new ArrayList<String>();
        if (geValue > 0) {
            parts.add(String.format(geFmtStr, geFmt));
        }
        if (haValue > 0) {
            parts.add(String.format(haFmtStr, haFmt));
        }
        var text = String.join(displayType == DualValueDisplayType.COMPACT ? "/" : " ", parts);
        return displayType == DualValueDisplayType.COMPACT ? withParentheses(text) : text;
    }

    private void renderDebugOverlay(Graphics2D g) {
        int itemCount = 0;
        int screenY = 96;
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            var items = entry.getValue();

            var errs = "";
            var errno = 0;
            var loc = LocalPoint.fromWorld(client.getTopLevelWorldView(), tile.getWorldLocation());
            if (loc == null) {
                ++errno;
                errs += "[LOC]";
            }
            if (tile.getItemLayer() == null) {
                ++errno;
                errs += "[IL]";
            }

            var coords = tile.getWorldLocation().getX() + ", " + tile.getWorldLocation().getY();
            var sz = items.size();
            g.setColor(errno > 0 ? Color.RED : Color.WHITE);
            g.drawString(coords + " " + sz + " " + errs, 0, screenY);


            itemCount += sz;
            screenY += 16;
        }
        g.setColor(DEBUG_BG);
        g.fillRect(0, 18, 96, 64);
        g.setColor(Color.WHITE);
        g.drawString("items: " + itemCount + "," + plugin.getTileItemIndex().pointIndexSize(), 0, 32);
        g.drawString("lootbeams: " + plugin.getLootbeamIndex().size(), 0, 48);
        g.drawString("displays: " + plugin.getDisplayIndex().size(), 0, 64);
        g.drawString("audio: " + plugin.getQueuedAudio().size() + ", icon: " + plugin.getIconIndex().size(), 0, 80);
    }

    private void renderDespawnTimer(Graphics2D g, DespawnTimerType type, PluginTileItem
            item, net.runelite.api.Point textPoint, int textWidth, int yOffset, int leftOffset, boolean compact) {
        var ticksRemaining = item.getDespawnTime() - client.getTickCount();
        if (ticksRemaining < 0) { // doesn't despawn
            return;
        }
        if (config.despawnThreshold() > 0 && ticksRemaining > config.despawnThreshold()) {
            return;
        }

        if (compact) { // bar
            var total = item.getDespawnTime() - item.getSpawnTime();
            var remaining = item.getDespawnTime() - plugin.getClient().getTickCount();
            var bar = new Rectangle(textPoint.getX(), textPoint.getY() - 3, textWidth * remaining / total, 3);
            g.setColor(getDespawnTextColor(item));
            g.fillRect(bar.x, bar.y, bar.width, bar.height);
        } else if (type == DespawnTimerType.TICKS || type == DespawnTimerType.SECONDS) {
            var text = new TextComponent();
            var timeRounding = "%.1f";
            var displyString = type == DespawnTimerType.TICKS
                    ? Integer.toString(ticksRemaining)
                    : String.format(timeRounding, (Duration.between(Instant.now(), item.getDespawnInstant())).toMillis() / 1000f);
            text.setText(displyString);
            text.setColor(getDespawnTextColor(item));
            text.setPosition(new Point(textPoint.getX() + textWidth + 2 + 1, textPoint.getY() - yOffset));
            text.render(g);
        } else { // pie
            var timer = new ProgressPieComponent();
            var total = item.getDespawnTime() - item.getSpawnTime();
            var remaining = item.getDespawnTime() - plugin.getClient().getTickCount();
            timer.setPosition(new net.runelite.api.Point(textPoint.getX() - TIMER_RADIUS - BOX_PAD - 2 - leftOffset,
                    textPoint.getY() - yOffset - TIMER_RADIUS));
            timer.setProgress(remaining / (double) total);
            timer.setDiameter(TIMER_RADIUS * 2);
            timer.setFill(getDespawnTextColor(item));
            timer.setBorderColor(getDespawnTextColor(item));
            timer.render(g);
        }
    }

    private void renderClickboxes(Graphics2D g, Rectangle textBox, TileItem item, DisplayConfig display,
                                  Consumer<Integer> onHoverHide, Consumer<Integer> onHoverHighlight) {
        var y = textBox.y + (textBox.height - CLICKBOX_SIZE) / 2;
        var hide = new Rectangle(textBox.x + textBox.width + 2, y, CLICKBOX_SIZE, CLICKBOX_SIZE);
        var show = new Rectangle(textBox.x + textBox.width + 4 + CLICKBOX_SIZE, y, CLICKBOX_SIZE, CLICKBOX_SIZE);

        var mouse = client.getMouseCanvasPosition();
        if (hide.contains(mouse.getX(), mouse.getY())) {
            onHoverHide.accept(item.getId());
            g.setColor(Color.RED);
        } else {
            g.setColor(display.isHidden() ? config.hiddenColor() : display.getTextColor());
        }
        g.drawRect(hide.x, hide.y, hide.width, hide.height);
        g.setColor(Color.WHITE);
        g.drawLine(hide.x + 2, hide.y + hide.height / 2, hide.x + hide.width - 2, hide.y + hide.height / 2);

        if (show.contains(mouse.getX(), mouse.getY())) {
            onHoverHighlight.accept(item.getId());
            g.setColor(Color.GREEN);
        } else {
            g.setColor(display.isHidden() ? config.hiddenColor() : display.getTextColor());
        }
        g.drawRect(show.x, show.y, show.width, show.height);
        g.setColor(Color.WHITE);
        g.drawLine(show.x + 2, show.y + show.height / 2, show.x + show.width - 2, show.y + show.height / 2);
        g.drawLine(show.x + show.width / 2, show.y + 2, show.x + show.width / 2, show.y + show.height - 2);
    }

    private void highlightTiles(Graphics2D g, Tile tile, List<PluginTileItem> items) {
        if (tile.getLocalLocation() == null || tile.getPlane() != client.getTopLevelWorldView().getPlane()) {
            return;
        }

        for (var item : items) {
            var match = plugin.getDisplayIndex().get(item);
            if (match.isHighlightTile()) {
                highlightTile(g, tile, match);
            }
        }
    }

    private void highlightTile(Graphics2D g, Tile tile, DisplayConfig display) {
        var poly = getCanvasTilePoly(client, tile.getLocalLocation(), tile.getItemLayer().getHeight());
        if (poly == null) {
            return;
        }

        var origStroke = g.getStroke();
        g.setColor(display.getTileStrokeColor());
        g.setStroke(new BasicStroke(2));
        g.draw(poly);
        if (display.getTileFillColor() != null) {
            g.setColor(display.getTileFillColor());
            g.fill(poly);
        }
        g.setStroke(origStroke);
    }

    private Dimension renderIcon(Graphics2D g, BufferedImageProvider.CacheKey cacheKey, net.runelite.api.Point textPoint, int yOffset) {
        var image = plugin.getIconIndex().get(cacheKey);
        if (image == null) {
            return new Dimension(0, 0);
        }

        var fontHeight = g.getFontMetrics().getHeight();
        var x = textPoint.getX() - image.getWidth() - BOX_PAD - 1;
        var y = textPoint.getY() - fontHeight - yOffset + (fontHeight - image.getHeight()) / 2;
        g.drawImage(image, x, y, null);
        return new Dimension(image.getWidth() + BOX_PAD, image.getHeight());
    }

    private Map<Boolean, Deque<RenderItem>> createItemCollection(List<PluginTileItem> items) {
        Map<Boolean, Deque<RenderItem>> itemCollection = new HashMap<>();
        itemCollection.put(true, new ArrayDeque<>());
        itemCollection.put(false, new ArrayDeque<>());

        var countMap = new HashMap<OverlayKey, ItemCounts>();
        for (var item : items) {
            var match = plugin.getDisplayIndex().get(item);
            var key = new OverlayKey(item.getId(), match);
            var existingVal = countMap.get(key);
            if (existingVal == null) {
                var quant = new ItemCounts(1, item.getQuantity());
                countMap.put(key, quant);
                itemCollection.get(key.displayConfig.isCompact()).add(new RenderItem(item, key, quant));
            } else {
                if (item.isStackable()) {
                    existingVal.quantity += item.getQuantity();
                }
                existingVal.count++;
            }
        }
        return itemCollection;
    }

    @Value
    private static class OverlayKey {
        int id;
        DisplayConfig displayConfig;
    }

    @Value
    private static class RenderItem {
        PluginTileItem firstItem;
        OverlayKey overlayKey;
        ItemCounts counts;
    }

    @Getter
    @Setter
    private static class ItemCounts {
        //Number of individual items/stacks
        int count;
        //Total sum of all stacks combined
        int quantity;

        public ItemCounts(int count, int quantity) {
            this.count = count;
            this.quantity = quantity;
        }
    }

    private static boolean inRenderRange(Player player, Tile tile) {
        return player.getLocalLocation().distanceTo(tile.getLocalLocation()) <= MAX_DISTANCE;
    }
}


package com.lootfilters.ast;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString
public class NotCondition extends Condition {
    private final Condition inner;

    public NotCondition(Condition inner) {
        this.inner = inner;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return !inner.test(plugin, item);
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import net.runelite.api.coords.WorldPoint;

public class AreaCondition extends LeafCondition {
    private final WorldPoint p0, p1;

    public AreaCondition(WorldPoint p0, WorldPoint p1) {
        this.p0 = p0;
        this.p1 = p1;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        var p = item.getWorldPoint();
        return p.getX() >= p0.getX() && p.getY() >= p0.getY() && p.getPlane() >= p0.getPlane()
                && p.getX() <= p1.getX() && p.getY() <= p1.getY() && p.getPlane() <= p1.getPlane();
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemTradeableCondition extends LeafCondition {
    private final boolean target;

    public ItemTradeableCondition(boolean target) {
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return item.isMoney() ? target : item.isTradeable() == target;
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

import static com.lootfilters.util.TextUtil.isInfixWildcard;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemNameCondition extends LeafCondition {
    private final List<String> names;

    public ItemNameCondition(List<String> names) {
        this.names = names;
    }

    public ItemNameCondition(String name) {
        this.names = List.of(name);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return names.stream().anyMatch(it -> test(item.getName(), it));
    }

    private boolean test(String name, String target) {
        if (target.equals("*")) {
            return true;
        } else if (target.startsWith("*") && target.endsWith("*")) {
            return name.toLowerCase().contains(target.toLowerCase().substring(1, target.length() - 1));
        } else if (target.startsWith("*")) {
            return name.toLowerCase().endsWith(target.toLowerCase().substring(1));
        } else if (target.endsWith("*")) {
            return name.toLowerCase().startsWith(target.toLowerCase().substring(0, target.length() - 1));
        } else if (isInfixWildcard(target)) {
            var lowercase = name.toLowerCase();
            var index = target.indexOf('*');
            var before = target.substring(0, index).toLowerCase();
            var after = target.substring(index + 1).toLowerCase();
            return lowercase.startsWith(before) && lowercase.endsWith(after);
        }
        return name.equalsIgnoreCase(target);
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.Ownership;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Getter
@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemOwnershipCondition extends LeafCondition {
    private final Ownership ownership;

    public ItemOwnershipCondition(int ownership) {
        this.ownership = Ownership.fromOrdinal(ownership);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return item.getOwnership() == ownership.ordinal();
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.Comparator;
import com.lootfilters.model.ValueType;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString(callSuper = true)
public class ItemValueCondition extends ComparatorCondition {
    private final ValueType valueType;

    public ItemValueCondition(int value, Comparator cmp, ValueType valueType) {
       super(value, cmp);
       this.valueType = valueType;
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, PluginTileItem item) {
        return getValue(item) * item.getQuantity();
    }

    private int getValue(PluginTileItem item) {
        switch (valueType) {
            case HIGHEST: return Math.max(item.getGePrice(), item.getHaPrice());
            case GE: return item.getGePrice();
            default: return item.getHaPrice();
        }
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.Comparator;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString(callSuper = true)
public class ItemQuantityCondition extends ComparatorCondition {
    public ItemQuantityCondition(int value, Comparator cmp) {
        super(value, cmp);
    }

    @Override
    public int getLhs(LootFiltersPlugin plugin, PluginTileItem item) {
        return item.getQuantity();
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemNotedCondition extends LeafCondition {
    private final boolean target;

    public ItemNotedCondition(boolean target) {
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return item.isNoted() == target;
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.Comparator;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.ToString;

@ToString
public abstract class ComparatorCondition extends LeafCondition {
    private final int rhs;
    private final Comparator cmp;

    protected ComparatorCondition(int rhs, Comparator cmp) {
        this.rhs = rhs;
        this.cmp = cmp;
    }

    @Override
    public final boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        var lhs = getLhs(plugin, item);
        switch (cmp) {
            case GT:
                return lhs > rhs;
            case LT:
                return lhs < rhs;
            case EQ:
                return lhs == rhs;
            case GT_EQ:
                return lhs >= rhs;
            case LT_EQ:
                return lhs <= rhs;
        }
        return false;
    }

    public abstract int getLhs(LootFiltersPlugin plugin, PluginTileItem item);
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

@Getter
@EqualsAndHashCode(callSuper = false)
@ToString
public class ConstCondition extends LeafCondition {
    private final boolean target;

    public ConstCondition(boolean target) {
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return target;
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import net.runelite.api.gameval.VarbitID;

public class AccountTypeCondition extends LeafCondition {
    private final int type;

    public AccountTypeCondition(int type) {
        this.type = type;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return plugin.getClient().getVarbitValue(VarbitID.IRONMAN) == type;
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.util.List;

@Getter
@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemIdCondition extends LeafCondition {
    private final List<Integer> ids;

    public ItemIdCondition(List<Integer> ids) {
        this.ids = ids;
    }

    public ItemIdCondition(int id) {
        this.ids = List.of(id);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return ids.stream().anyMatch(it -> item.getId() == it);
    }
}

package com.lootfilters.ast.leaf;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

@EqualsAndHashCode(callSuper = false)
@ToString
public class ItemStackableCondition extends LeafCondition {
    private final boolean target;

    public ItemStackableCondition(boolean target) {
        this.target = target;
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return item.isStackable() == target;
    }
}

package com.lootfilters.ast;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
@ToString
public class AndCondition extends Condition {
    private final List<Condition> rules;

    public AndCondition(List<Condition> rules) {
        this.rules = rules;
    }

    public AndCondition(Condition left, Condition right) {
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return rules.stream().allMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.ast;

public abstract class LeafCondition extends Condition {
}

package com.lootfilters.ast;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@EqualsAndHashCode(callSuper = false)
@ToString
public class OrCondition extends Condition {
    private final List<Condition> rules;

    public OrCondition(List<Condition> rules) {
        this.rules = rules;
    }

    public OrCondition(Condition left, Condition right) {
        this.rules = List.of(left, right);
    }

    @Override
    public boolean test(LootFiltersPlugin plugin, PluginTileItem item) {
        return rules.stream().anyMatch(it -> it.test(plugin, item));
    }
}

package com.lootfilters.ast;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.model.PluginTileItem;

public abstract class Condition {
    public abstract boolean test(LootFiltersPlugin plugin, PluginTileItem item);
}

package com.lootfilters;

import com.google.inject.Inject;
import net.runelite.client.util.HotkeyListener;

import java.time.Duration;
import java.time.Instant;

public class LootFiltersHotkeyListener extends HotkeyListener {
    private final LootFiltersPlugin plugin;

    private Instant lastPressed = Instant.EPOCH;

    @Inject
    private LootFiltersHotkeyListener(LootFiltersPlugin plugin) {
        super(plugin.getConfig()::hotkey);

        this.plugin = plugin;
    }

    @Override
    public void hotkeyPressed() {
        plugin.setHotkeyActive(true);

        var now = Instant.now();
        if (shouldToggleOverlay(now)) {
            plugin.setOverlayEnabled(!plugin.isOverlayEnabled());
            lastPressed = Instant.EPOCH;
        } else {
            lastPressed = now;
        }
    }

    @Override
    public void hotkeyReleased() {
        plugin.setHotkeyActive(false);
    }

    private boolean shouldToggleOverlay(Instant now) {
        if (!plugin.getConfig().hotkeyDoubleTapTogglesOverlay()) {
            return false;
        }

        return !plugin.isOverlayEnabled() && plugin.isHotkeyActive()
                || Duration.between(lastPressed, now).toMillis() < plugin.getConfig().hotkeyDoubleTapDelay();
    }
}
package com.lootfilters;

import com.lootfilters.model.SoundProvider;
import com.lootfilters.model.BufferedImageProvider;
import com.lootfilters.model.FontType;
import com.lootfilters.model.TextAccent;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import net.runelite.client.ui.FontManager;

import java.awt.Color;
import java.awt.Font;
import java.util.ArrayList;
import java.util.List;

@Getter
@Builder(toBuilder = true)
@AllArgsConstructor
@EqualsAndHashCode
@ToString
public class DisplayConfig {
    public static final Color DEFAULT_MENU_TEXT_COLOR = Color.decode("#ff9040");

    private final Color textColor;
    private final Color backgroundColor;
    private final Color borderColor;
    private final Boolean hidden;
    private final Boolean showLootbeam;
    private final Boolean showValue;
    private final Boolean compact;
    private final Boolean showDespawn;
    private final Boolean notify;
    private final TextAccent textAccent;
    private final Color textAccentColor;
    private final Color lootbeamColor;
    private final FontType fontType;
    private final Color menuTextColor;
    private final Boolean hideOverlay;

    private final Boolean highlightTile;
    private final Color tileStrokeColor;
    private final Color tileFillColor;

    private final SoundProvider sound;
    private final Integer menuSort;
    private final BufferedImageProvider icon;

    // ideally this would be in EvalDisplayConfig which extends DisplayConfig but that's just more code tbh
    private final List<Integer> evalTrace;

    public DisplayConfig(Color textColor) {
        this.textColor = textColor;
        backgroundColor = null;
        borderColor = null;
        hidden = false;
        showLootbeam = false;
        showValue = false;
        compact = false; // compact is currently a config-only setting and not supported in rs2f
        showDespawn = false;
        notify = false;
        textAccent = null;
        textAccentColor = null;
        lootbeamColor = null;
        fontType = null;
        menuTextColor = null;
        highlightTile = null;
        tileStrokeColor = null;
        tileFillColor = null;
        hideOverlay = null;
        sound = null;
        menuSort = null;
        icon = null;
        evalTrace = new ArrayList<>();
    }

    public SoundProvider getSound() {
        return !isHidden() ? sound : null;
    }

    public Color getLootbeamColor() {
        return lootbeamColor != null ? lootbeamColor : textColor;
    }

    public Color getTextColor() {
        return textColor != null ? textColor : Color.WHITE;
    }

    public BufferedImageProvider getIcon() {
        return isCompact() ? new BufferedImageProvider.CurrentItem() : icon;
    }

    public Color getMenuTextColor() {
        if (isHidden()) {
            return DEFAULT_MENU_TEXT_COLOR;
        }
        if (menuTextColor != null) {
            return menuTextColor;
        }
        return textColor != null && !textColor.equals(Color.WHITE) ? textColor : DEFAULT_MENU_TEXT_COLOR;
    }

    public int getMenuSort() {
        return menuSort != null ? menuSort : 0;
    }

    public Font getFont() {
        if (fontType == null || fontType == FontType.NORMAL) {
            return FontManager.getRunescapeSmallFont();
        }
        if (fontType == FontType.LARGER) {
            return FontManager.getRunescapeFont();
        }
        return FontManager.getRunescapeBoldFont();
    }

    public Color getTileStrokeColor() {
        return tileStrokeColor != null ? tileStrokeColor : textColor;
    }

    public boolean isHidden() { return hidden != null && hidden; }
    public boolean isShowLootbeam() { return !isHidden() && showLootbeam != null && showLootbeam; }
    public boolean isShowValue() { return showValue != null && showValue; }
    public boolean isShowDespawn() { return showDespawn != null && showDespawn; }
    public boolean isNotify() { return !isHidden() && notify != null && notify; }
    public boolean isHighlightTile() { return !isHidden() && highlightTile != null && highlightTile; }
    public boolean isHideOverlay() { return isHidden() || (hideOverlay != null && hideOverlay); }

    public boolean isCompact() {
        return compact != null && compact;
    }

    public DisplayConfig merge(DisplayConfig other) {
        var b = toBuilder();
        if (other.textColor != null) { b.textColor(other.textColor); }
        if (other.backgroundColor != null) { b.backgroundColor(other.backgroundColor); }
        if (other.borderColor != null) { b.borderColor(other.borderColor); }
        if (other.hidden != null) { b.hidden(other.hidden); }
        if (other.showLootbeam != null) { b.showLootbeam(other.showLootbeam); }
        if (other.showValue != null) { b.showValue(other.showValue); }
        if (other.compact != null) { b.compact(other.compact); }
        if (other.showDespawn != null) { b.showDespawn(other.showDespawn); }
        if (other.notify != null) { b.notify(other.notify); }
        if (other.textAccent != null) { b.textAccent(other.textAccent); }
        if (other.textAccentColor != null) { b.textAccentColor(other.textAccentColor); }
        if (other.lootbeamColor != null) { b.lootbeamColor(other.lootbeamColor); }
        if (other.fontType != null) { b.fontType(other.fontType); }
        if (other.menuTextColor != null) { b.menuTextColor(other.menuTextColor); }
        if (other.highlightTile != null) { b.highlightTile(other.highlightTile); }
        if (other.tileStrokeColor != null) { b.tileStrokeColor(other.tileStrokeColor); }
        if (other.tileFillColor != null) { b.tileFillColor(other.tileFillColor); }
        if (other.hideOverlay != null) { b.hideOverlay(other.hideOverlay); }
        if (other.sound != null) { b.sound(other.sound); }
        if (other.menuSort != null) { b.menuSort(other.menuSort); }
        if (other.icon != null) { b.icon(other.icon); }
        return b.build();
    }
}

package com.lootfilters.lang;

public class TokenizeException extends CompileException {
    public TokenizeException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;
import lombok.Value;
import net.runelite.client.util.ColorUtil;

import java.awt.Color;

@Value
@RequiredArgsConstructor
public class Token {
    public enum Type {
        WHITESPACE, NEWLINE,
        IF, APPLY, RULE,
        META,
        COLON, COMMA,
        TRUE, FALSE,
        IDENTIFIER,
        LITERAL_INT, LITERAL_STRING,
        ASSIGN,
        OP_EQ, OP_GT, OP_LT, OP_GTEQ, OP_LTEQ, OP_AND, OP_OR, OP_NOT,
        EXPR_START, EXPR_END,
        BLOCK_START, BLOCK_END,
        LIST_START, LIST_END,
        STMT_END,
        PREPROC_DEFINE,
        COMMENT,
    }

    public static Token intLiteral(String value, Location location) { return new Token(Type.LITERAL_INT, value, location); }
    public static Token stringLiteral(String value, Location location) { return new Token(Type.LITERAL_STRING, value, location); }
    public static Token identifier(String value, Location location) { return new Token(Type.IDENTIFIER, value, location); }

    Type type;
    String value;
    Location location;

    public boolean is(Type type) {
        return this.type == type;
    }

    public int expectInt() {
        if (type != Type.LITERAL_INT) {
            throw new ParseException("unexpected non-int token", this);
        }
        return Integer.parseInt(value.replace("_", ""));
    }

    public String expectString() {
        if (type != Type.LITERAL_STRING) {
            throw new ParseException("unexpected non-string token", this);
        }
        return value;
    }

    public Color expectColor() {
        if (type != Type.LITERAL_STRING) {
            throw new ParseException("unexpected non-string token", this);
        }

        var color = ColorUtil.fromHex(value);
        if (color == null) {
            throw new ParseException("unexpected non-color string", this);
        }
        return color;
    }

    public boolean expectBoolean() {
        switch (type) {
            case TRUE: return true;
            case FALSE: return false;
            default:
                throw new ParseException("unexpected non-boolean token", this);
        }
    }

    public boolean isWhitespace() {
        return type == Type.WHITESPACE || type == Type.NEWLINE;
    }

    public boolean isSemantic() {
        return type != Type.COMMENT && !isWhitespace();
    }

    public Token withLocation(Location location) {
        return new Token(type, value, location);
    }

    @Override
    public String toString() {
        var str = "Token{type=" + type;
        return value != null && value.isEmpty()
                ? str + "}"
                : str + ",value=" + value + ", location=" + location.toString() + "}";
    }

    public String formatForException() {
        return String.format("%s at %s", value, location.toString());
    }
}

package com.lootfilters.lang;

import lombok.Getter;

import static com.lootfilters.lang.Location.UNKNOWN_SOURCE_NAME;

@Getter
public class ParseException extends CompileException {
    private final Token token;

    public ParseException(String message, Token token) {
        super(message + " " + formatToken(token));
        this.token = token;
    }

    public ParseException(String message) {
        super(message);
        this.token = null;
    }

    private static String formatToken(Token token) {
        // Format a message with source names only if available
        if (token.getLocation().getMacroSourceLocation() != null) {
            var tokenLocation = token.getLocation();
            var macroLocation = tokenLocation.getMacroSourceLocation();
            var expansionErrorAndLocation = String.format("'%s' after expanding macro %s on L%d, C%d%s.",
                    token.getValue(),
                    macroLocation.getMacroName(),
                    tokenLocation.getLineNumber(),
                    tokenLocation.getCharNumber(),
                    sourceNameFragment(tokenLocation.getSourceName()));

            var macroDefineAndMacroErrorLocation = "";
            if (!macroLocation.getSourceName().equals(UNKNOWN_SOURCE_NAME)) {
                macroDefineAndMacroErrorLocation = String.format(" %s is defined in '%s', error was on L%d, C%d.",
                        macroLocation.getMacroName(),
                        macroLocation.getSourceName(),
                        macroLocation.getLineNumber(),
                        macroLocation.getCharNumber()
                );
            }

            return expansionErrorAndLocation + macroDefineAndMacroErrorLocation;
        } else {
            return String.format("'%s' on L%s, C%s%s",
                    token.getValue(),
                    token.getLocation().getLineNumber(),
                    token.getLocation().getCharNumber(),
                    sourceNameFragment(token.getLocation().getSourceName())
            );
        }
    }

    private static String sourceNameFragment(String sourceName) {
        return sourceName.equals(UNKNOWN_SOURCE_NAME) ? "" : String.format(" in '%s'", sourceName);
    }
}

package com.lootfilters.lang;

public class PreprocessException extends CompileException {
    public PreprocessException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.Getter;

import java.io.IOException;
import java.io.InputStream;

import static com.lootfilters.util.TextUtil.normalizeCrlf;

public class Sources {
    @Getter private static String preamble;

    private Sources() {}

    static {
        try (
            var preambleStream = Sources.class.getResourceAsStream("/com/lootfilters/scripts/preamble.rs2f");
        ) {
            preamble = loadScriptResource(preambleStream);
        } catch (IOException e) {
            throw new RuntimeException("init static sources", e);
        } catch (CompileException e) {
            throw new RuntimeException("init static filters", e);
        }
    }

    private static String loadScriptResource(InputStream in) throws IOException {
        return normalizeCrlf(new String(in.readAllBytes()));
    }
}
package com.lootfilters.lang;

import com.lootfilters.DisplayConfig;
import com.lootfilters.LootFilter;
import com.lootfilters.FilterRule;
import com.lootfilters.model.SoundProvider;
import com.lootfilters.model.BufferedImageProvider;
import com.lootfilters.ast.leaf.AccountTypeCondition;
import com.lootfilters.ast.AndCondition;
import com.lootfilters.ast.leaf.AreaCondition;
import com.lootfilters.model.Comparator;
import com.lootfilters.ast.leaf.ConstCondition;
import com.lootfilters.model.FontType;
import com.lootfilters.ast.leaf.ItemIdCondition;
import com.lootfilters.ast.leaf.ItemNameCondition;
import com.lootfilters.ast.leaf.ItemNotedCondition;
import com.lootfilters.ast.leaf.ItemOwnershipCondition;
import com.lootfilters.ast.leaf.ItemQuantityCondition;
import com.lootfilters.ast.leaf.ItemStackableCondition;
import com.lootfilters.ast.leaf.ItemTradeableCondition;
import com.lootfilters.ast.leaf.ItemValueCondition;
import com.lootfilters.ast.LeafCondition;
import com.lootfilters.ast.NotCondition;
import com.lootfilters.ast.OrCondition;
import com.lootfilters.ast.Condition;
import com.lootfilters.model.TextAccent;
import com.lootfilters.model.ValueType;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import static com.lootfilters.lang.Token.Type.APPLY;
import static com.lootfilters.lang.Token.Type.ASSIGN;
import static com.lootfilters.lang.Token.Type.BLOCK_END;
import static com.lootfilters.lang.Token.Type.BLOCK_START;
import static com.lootfilters.lang.Token.Type.COLON;
import static com.lootfilters.lang.Token.Type.COMMA;
import static com.lootfilters.lang.Token.Type.EXPR_END;
import static com.lootfilters.lang.Token.Type.EXPR_START;
import static com.lootfilters.lang.Token.Type.FALSE;
import static com.lootfilters.lang.Token.Type.IDENTIFIER;
import static com.lootfilters.lang.Token.Type.IF;
import static com.lootfilters.lang.Token.Type.LIST_END;
import static com.lootfilters.lang.Token.Type.LIST_START;
import static com.lootfilters.lang.Token.Type.LITERAL_INT;
import static com.lootfilters.lang.Token.Type.LITERAL_STRING;
import static com.lootfilters.lang.Token.Type.META;
import static com.lootfilters.lang.Token.Type.OP_AND;
import static com.lootfilters.lang.Token.Type.OP_NOT;
import static com.lootfilters.lang.Token.Type.OP_OR;
import static com.lootfilters.lang.Token.Type.RULE;
import static com.lootfilters.lang.Token.Type.STMT_END;
import static com.lootfilters.lang.Token.Type.TRUE;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !! DO NOT add features to the RS2F language without consulting Rikten X first. !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// Parser somewhat mixes canonical stages 2 (parse) and 3/4 (syntax/semantic analysis) but the filter language is
// restricted enough that it should be fine for now.
@RequiredArgsConstructor
public class Parser {
    private final TokenStream tokens;

    private final LootFilter.Builder builder = LootFilter.builder();

    public LootFilter parse() throws ParseException {
        while (tokens.isNotEmpty()) {
            var tok = tokens.take();
            if (tok.is(META)) {
                parseMeta();
            } else if (tok.is(IF) || tok.is(RULE)) {
                parseRule(true, tok.getLocation().getLineNumber());
            } else if (tok.is(APPLY)) {
                parseRule(false, tok.getLocation().getLineNumber());
            } else {
                throw new ParseException("unexpected token", tok);
            }
        }
        return builder.build();
    }

    private void parseMeta() {
        var block = tokens.take(BLOCK_START, BLOCK_END);
        while (block.isNotEmpty()) {
            var tok = block.takeExpect(IDENTIFIER);
            block.takeExpect(ASSIGN);
            switch (tok.getValue()) {
                case "name":
                    builder.setName(block.takeExpectLiteral().expectString());
                    block.takeExpect(STMT_END);
                    break;
                case "description":
                    builder.setDescription(block.takeExpectLiteral().expectString());
                    block.takeExpect(STMT_END);
                    break;
                case "area":
                    block.takeExpect(LIST_START);
                    int x0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z0 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int x1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int y1 = block.takeExpectLiteral().expectInt(); block.takeExpect(COMMA);
                    int z1 = block.takeExpectLiteral().expectInt(); block.takeOptional(COMMA);
                    block.takeExpect(LIST_END);
                    block.takeExpect(STMT_END);
                    break;
                default:
                    throw new ParseException("unrecognized metavalue", tok);
            }
        }
    }

    private void parseRule(boolean isTerminal, int sourceLine) {
        var operators = new Stack<Token>();
        var rulesPostfix = new ArrayList<Condition>();
        tokens.walkExpression(EXPR_START, EXPR_END, it -> {
            if (it.is(EXPR_START)) {
                operators.push(it);
            } else if (it.is(EXPR_END)) {
                while (!operators.isEmpty() && !operators.peek().is(EXPR_START)) {
                    var op = operators.pop();
                    if (op.is(OP_AND)) {
                        rulesPostfix.add(new AndCondition(null));
                    } else if (op.is(OP_OR)) {
                        rulesPostfix.add(new OrCondition(null));
                    }
                }
                operators.pop(); // the (
                unwindUnary(operators, rulesPostfix);
            } else if (it.is(OP_AND)) {
                operators.push(it);
            } else if (it.is(OP_OR)) {
                while (!operators.isEmpty() && operators.peek().is(OP_AND)) {
                    operators.pop();
                    rulesPostfix.add(new AndCondition(null));
                }
                operators.push(it);
            } else if (it.is(OP_NOT)) {
                operators.push(it);
            } else if (it.is(TRUE) || it.is(FALSE)) {
                rulesPostfix.add(new ConstCondition(it.expectBoolean()));
                unwindUnary(operators, rulesPostfix);
            } else if (it.is(IDENTIFIER)) {
                rulesPostfix.add(parseRule(it));
                unwindUnary(operators, rulesPostfix);
            } else {
                throw new ParseException("unexpected token in expression", it);
            }
        });

        while (!operators.isEmpty()) { // is this necessary? since parenthesis around overall expr are guaranteed
            var op = operators.pop();
            if (op.is(OP_AND)) {
                rulesPostfix.add(new AndCondition(null));
            } else if (op.is(OP_OR)) {
                rulesPostfix.add(new OrCondition(null));
            } else if (op.is(OP_NOT)) {
                rulesPostfix.add(new NotCondition(null));
            }
        }

        // rule expression MUST be followed by block w/ display config assignments
        tokens.takeExpect(BLOCK_START);
        var builder = DisplayConfig.builder();
        while (!tokens.peek().is(BLOCK_END)) { // TokenStream.traverseBlock?
            var property = tokens.peek();
            if (property.getValue().equals("icon")) {
                parseIcon(builder);
                continue;
            }

            var assign = parseAssignment();
            switch (assign[0].getValue()) {
                case "textColor":
                case "color":
                    builder.textColor(assign[1].expectColor()); break;
                case "backgroundColor":
                    builder.backgroundColor(assign[1].expectColor()); break;
                case "borderColor":
                    builder.borderColor(assign[1].expectColor()); break;
                case "hidden":
                    builder.hidden(assign[1].expectBoolean()); break;
                case "showLootbeam":
                case "showLootBeam":
                    builder.showLootbeam(assign[1].expectBoolean()); break;
                case "showValue":
                    builder.showValue(assign[1].expectBoolean()); break;
                case "showDespawn":
                    builder.showDespawn(assign[1].expectBoolean()); break;
                case "notify":
                    builder.notify(assign[1].expectBoolean()); break;
                case "textAccent":
                    builder.textAccent(TextAccent.fromOrdinal(assign[1].expectInt())); break;
                case "textAccentColor":
                    builder.textAccentColor(assign[1].expectColor()); break;
                case "lootbeamColor":
                case "lootBeamColor":
                    builder.lootbeamColor(assign[1].expectColor()); break;
                case "fontType":
                    builder.fontType(FontType.fromOrdinal(assign[1].expectInt())); break;
                case "menuTextColor":
                    builder.menuTextColor(assign[1].expectColor()); break;
                case "highlightTile":
                    builder.highlightTile(assign[1].expectBoolean()); break;
                case "tileStrokeColor":
                    builder.tileStrokeColor(assign[1].expectColor()); break;
                case "tileFillColor":
                    builder.tileFillColor(assign[1].expectColor()); break;
                case "hideOverlay":
                    builder.hideOverlay(assign[1].expectBoolean()); break;
                case "sound":
                    builder.sound(SoundProvider.fromExpr(assign[1])); break;
                case "menuSort":
                    builder.menuSort(assign[1].expectInt()); break;
                default:
                    throw new ParseException("unexpected identifier in display config block", assign[0]);
            }
        }
        tokens.takeExpect(BLOCK_END);

        this.builder.addRule(new FilterRule(buildRule(rulesPostfix), builder.build(), isTerminal, sourceLine));
    }

    private void unwindUnary(Stack<Token> operators, ArrayList<Condition> postfix) {
        while (!operators.isEmpty() && operators.peek().is(OP_NOT)) {
            operators.pop();
            postfix.add(new NotCondition(null));
        }
    }

    private Condition parseRule(Token first) {
        tokens.takeExpect(COLON); // grammar is always <id><colon><...>
        switch (first.getValue()) {
            case "id":
                return parseItemIdRule();
            case "ownership":
                return parseItemOwnershipRule();
            case "name":
                return parseItemNameRule();
            case "quantity":
                return parseItemQuantityRule();
            case "value":
                return parseItemValueRule(ValueType.HIGHEST);
            case "gevalue":
                return parseItemValueRule(ValueType.GE);
            case "havalue":
                return parseItemValueRule(ValueType.HA);
            case "tradeable":
                return parseItemTradeableRule();
            case "stackable":
                return parseItemStackableRule();
            case "noted":
                return parseItemNotedRule();
            case "area":
                return parseAreaRule();
            case "accountType":
                return parseAccountTypeRule();
            default:
                throw new ParseException("unknown rule identifier", first);
        }
    }

    private ItemIdCondition parseItemIdRule() {
        if (tokens.peek().is(LITERAL_INT)) {
            return new ItemIdCondition(tokens.take().expectInt());
        } else if (tokens.peek().is(LIST_START)) {
            var block = tokens.take(LIST_START, LIST_END, true);
            return new ItemIdCondition(block.expectIntList());
        } else {
            throw new ParseException("parse item id: unexpected argument token", tokens.peek());
        }
    }

    private ItemOwnershipCondition parseItemOwnershipRule() {
        return new ItemOwnershipCondition(tokens.takeExpect(LITERAL_INT).expectInt());
    }

    private Condition parseItemNameRule() {
        if (tokens.peek().is(LITERAL_STRING)) {
            return new ItemNameCondition(tokens.take().expectString());
        } else if (tokens.peek().is(LIST_START)) {
            var block = tokens.take(LIST_START, LIST_END, true);
            return new ItemNameCondition(block.expectStringList());
        } else {
            throw new ParseException("parse item name: unexpected argument token", tokens.peek());
        }
    }

    private ItemQuantityCondition parseItemQuantityRule() {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemQuantityCondition(value.expectInt(), Comparator.fromToken(op));
    }

    private ItemValueCondition parseItemValueRule(ValueType valueType) {
        var op = tokens.take();
        var value = tokens.takeExpect(LITERAL_INT);
        return new ItemValueCondition(value.expectInt(), Comparator.fromToken(op), valueType);
    }

    private ItemTradeableCondition parseItemTradeableRule() {
        var op = tokens.take();
        return new ItemTradeableCondition((op.expectBoolean()));
    }

    private ItemStackableCondition parseItemStackableRule() {
        var op = tokens.take();
        return new ItemStackableCondition((op.expectBoolean()));
    }

    private ItemNotedCondition parseItemNotedRule() {
        var op = tokens.take();
        return new ItemNotedCondition((op.expectBoolean()));
    }

    private AreaCondition parseAreaRule() {
        var start = tokens.peek();
        var coords = tokens.take(LIST_START, LIST_END, true).expectIntList();
        if (coords.size() != 6) {
            throw new ParseException("incorrect list size for area argument", start);
        }
        return new AreaCondition(new WorldPoint(coords.get(0), coords.get(1), coords.get(2)),
                new WorldPoint(coords.get(3), coords.get(4), coords.get(5)));
    }

    private AccountTypeCondition parseAccountTypeRule() {
        var type = tokens.takeExpect(LITERAL_INT).expectInt();
        return new AccountTypeCondition(type);
    }

    private Condition buildRule(List<Condition> postfix) {
        var operands = new Stack<Condition>();
        for (var rule : postfix) {
            if (rule instanceof LeafCondition) {
                operands.push(rule);
            } else if (rule instanceof AndCondition) {
                operands.push(new AndCondition(operands.pop(), operands.pop()));
            } else if (rule instanceof OrCondition) {
                operands.push(new OrCondition(operands.pop(), operands.pop()));
            } else if (rule instanceof NotCondition) {
                operands.push(new NotCondition(operands.pop()));
            }
        }

        if (operands.size() != 1) {
            throw new ParseException("invalid rule postfix"); // did you add a new leaf rule that doesn't extend LeafRule?
        }
        return operands.pop();
    }

    private Token[] parseAssignment() { // assignments do not support nested expressions, making this trivial
        var ident = tokens.takeExpect(IDENTIFIER);
        tokens.takeExpect(ASSIGN);
        var value = tokens.takeExpectLiteral();
        tokens.takeExpect(STMT_END);
        return new Token[]{ident, value};
    }

    private void parseIcon(DisplayConfig.DisplayConfigBuilder builder) {
        tokens.takeExpect(IDENTIFIER);
        tokens.takeExpect(ASSIGN);
        var type = tokens.takeExpect(IDENTIFIER);
        var args = tokens.takeArgList();
        if (type.getValue().equals("Sprite")) {
            if (args.size() != 2) {
                throw new ParseException("incorrect arg length in icon Sprite() expr", type);
            }
            var spriteId = args.get(0).takeExpect(LITERAL_INT).expectInt();
            var index = args.get(1).takeExpect(LITERAL_INT).expectInt();
            builder.icon(new BufferedImageProvider.Sprite(spriteId, index));
        } else if (type.getValue().equals("Item")) {
            if (args.size() != 1) {
                throw new ParseException("incorrect arg length in icon Item() expr", type);
            }
            var itemId = args.get(0).takeExpect(LITERAL_INT).expectInt();
            builder.icon(new BufferedImageProvider.Item(itemId));
        } else if (type.getValue().equals("File")) {
            if (args.size() != 1) {
                throw new ParseException("incorrect arg length in icon File() expr", type);
            }
            var filename = args.get(0).take().expectString();
            builder.icon(new BufferedImageProvider.File(filename));
        } else if (type.getValue().equals("CurrentItem")) {
            if (!args.isEmpty()) {
                throw new ParseException("incorrect arg length in icon CurrentItem() expr", type);
            }
            builder.icon(new BufferedImageProvider.CurrentItem());
        } else {
            throw new ParseException("unrecognized icon type", type);
        }
        tokens.takeExpect(STMT_END);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;
import lombok.ToString;
import lombok.Value;
import lombok.experimental.NonFinal;

@Value
@RequiredArgsConstructor
public class Location {
    public static Location UNKNOWN = new Location("unknown", 0, 0);
    public static String UNKNOWN_SOURCE_NAME = "unknown";

    String sourceName;
    int lineNumber;
    int charNumber;
    @NonFinal
    Location macroSourceLocation = null;
    @NonFinal
    String macroName = null;

    public Location withMacroName(String name) {
        var loc = new Location(sourceName, lineNumber, charNumber);
        loc.macroName = name;
        return loc;
    }

    public Location withMacroSourceLocation(Location macroSourceLocation) {
        var loc = new Location(sourceName, lineNumber, charNumber);
        loc.macroSourceLocation = macroSourceLocation;
        return loc;
    }

    @Override
    public String toString() {
        var base = String.format("Location(sourceName=%s, lineNumber=%d, charNumber=%d", sourceName, lineNumber, charNumber);
        if (macroSourceLocation == null) {
            return base + ")";
        } else {
            return base + ", macroSourceLocation=" + macroSourceLocation + ")";
        }
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * TokenStream wraps a list of Tokens to expose retrieval APIs suitable for parsing.
 */
@AllArgsConstructor
public class TokenStream {
    private final List<Token> tokens;

    /**
     * Returns a shallow copy of the token stream.
     */
    public List<Token> getTokens() {
        return new ArrayList<>(tokens);
    }

    /**
     * Peek at the first token in the stream, ignoring whitespace, without consuming it.
     */
    public Token peek() {
        return tokens.stream()
                .filter(Token::isSemantic)
                .findFirst()
                .orElse(null);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace.
     */
    public Token take(boolean includeWhitespace) {
        while (isNotEmpty()) {
            var next = tokens.remove(0);
            if (next.isSemantic() || includeWhitespace && next.isWhitespace()) {
                return next;
            }
        }
        return null;
    }

    /**
     * Consume the first non-whitespace token in the stream.
     */
    public Token take() {
        return take(false);
    }

    /**
     * Consume the first token in the stream, optionally including whitespace, while asserting that it is of the given
     * type.
     */
    public Token takeExpect(Token.Type expect, boolean includeWhitespace) {
        if (tokens.isEmpty()) {
            throw new ParseException("unexpected end of token stream");
        }

        var first = take(includeWhitespace);
        if (!first.is(expect)) {
            throw new ParseException("unexpected non-" + expect + " token", first);
        }
        return first;
    }

    /**
     * Consume the first non-whitespace token in the stream while asserting that it is of the given type.
     */
    public Token takeExpect(Token.Type expect) {
        return takeExpect(expect, false);
    }

    /**
     * Consumes the first non-whitespace token at the head of the stream, asserting that it is any one of the literal
     * types (int, string, boolean).
     */
    public Token takeExpectLiteral() {
        var first = take();
        if (!first.is(Token.Type.LITERAL_INT)
                && !first.is(Token.Type.LITERAL_STRING)
                && !first.is(Token.Type.TRUE)
                && !first.is(Token.Type.FALSE)) {
            throw new ParseException("unexpected non-literal token", first);
        }
        return first;
    }

    /**
     * Take a complete line from the stream, preserving whitespace, and EXCLUDING the newline at the end, which is
     * discarded.
     */
    public List<Token> takeLine() {
        var line = new ArrayList<Token>();
        while (!tokens.isEmpty()) {
            var next = tokens.remove(0);
            if (next.is(Token.Type.NEWLINE)) {
                return line;
            }
            line.add(next);
        }
        return line;
    }

    /**
     * Consumes a token of the expected type if it's at the head of the stream, doing nothing otherwise.
     */
    public void takeOptional(Token.Type type) {
        if (peek().is(type)) {
            take();
        }
    }

    /**
     * Traverse an expression enclosed by the given start and end tokens at the head of the stream.
     * The traversal will verify that the expression in the stream is balanced. The caller can and most likely will
     * still maintain their own operator stack, but it won't require balance checks.
     * Callers MAY consume any number of tokens from the front of the stream, as long as they do not remove enclosing
     * tokens in a manner that would disrupt the balance check.
     * The consumer will be invoked with both the starting and ending enclosing tokens.
     */
    public void walkExpression(Token.Type start, Token.Type end, Consumer<Token> consumer) {
        var state = new Stack<Token>();
        if (!peek().is(start)) {
            throw new ParseException("unexpected start of expression", peek());
        }

        while (isNotEmpty()) {
            var next = take();
            if (next.is(start)) {
                state.push(next);
            } else if (next.is(end)) {
                if (!state.isEmpty()) {
                    state.pop();
                } else {
                    throw new ParseException("unbalanced expression");
                }
            }

            consumer.accept(next);
            if (state.isEmpty()) { // balanced expression
                return;
            }
        }
        if (!state.isEmpty()) {
            throw new ParseException("unbalanced expression");
        }
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, optionally including those
     * enclosing tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end, boolean preserveEnclosing) {
        var inner = new ArrayList<Token>();
        walkExpression(start, end, inner::add);
        if (!preserveEnclosing) {
            inner.remove(0);
            inner.remove(inner.size() - 1);
        }
        return new TokenStream(inner);
    }

    /**
     * Take an entire expression denoted by start and end tokens from the head of the stream, IGNORING those enclosing
     * tokens.
     */
    public TokenStream take(Token.Type start, Token.Type end) {
        return take(start, end, false);
    }

    /**
     * Consumes an argument list at the head of the stream matching the grammar ( expr0, expr1, <...> exprN [,] ).
     */
    public List<TokenStream> takeArgList() {
        var args = new ArrayList<TokenStream>();
        var current = new ArrayList<Token>();
        var expr = take(Token.Type.EXPR_START, Token.Type.EXPR_END);
        while (expr.isNotEmpty()) {
            var head = expr.peek();
            if (head.is(Token.Type.COMMA)) {
                if (current.isEmpty()) {
                    throw new ParseException("empty argument");
                } else {
                    args.add(new TokenStream(current));
                    current = new ArrayList<>();
                    expr.take();
                }
            } else if (head.is(Token.Type.EXPR_START)) {
                var nestedExpr = expr.take(Token.Type.EXPR_START, Token.Type.EXPR_END, true);
                current.addAll(nestedExpr.getTokens());
            } else if (head.is(Token.Type.LIST_START)) {
                var nestedExpr = expr.take(Token.Type.LIST_START, Token.Type.LIST_END, true);
                current.addAll(nestedExpr.getTokens());
            } else {
                current.add(expr.take());
            }
        }

        if (!current.isEmpty()) {
            args.add(new TokenStream(current));
        }
        return args;
    }

    /**
     * Attempt to parse the entire token stream as a list of strings.
     */
    public List<String> expectStringList() {
        return expectList().stream()
                .map(Token::expectString)
                .collect(Collectors.toList());
    }

    /**
     * Attempt to parse the entire token stream as a list of integers.
     */
    public List<Integer> expectIntList() {
        return expectList().stream()
                .map(Token::expectInt)
                .collect(Collectors.toList());
    }

    /**
     * Attempt to parse the entire token stream as a list of single, non-nested tokens.
     */
    public List<Token> expectList() {
        var tokens = new ArrayList<Token>();

        takeExpect(Token.Type.LIST_START);
        while (isNotEmpty()) {
            if (peek().is(Token.Type.LIST_END)) {
                return tokens;
            }

            tokens.add(take());
            if (peek().is(Token.Type.COMMA)) {
                take();
            } else if (peek().is(Token.Type.LIST_END)) {
                take();
                break;
            } else {
                throw new ParseException("unexpected token in list", peek());
            }
        }
        if (isNotEmpty()) {
            throw new ParseException("unterminated list");
        }

        return tokens;
    }

    public boolean isNotEmpty() { // this doesn't _currently_ need a version that checks non-semantic
        return tokens.stream().anyMatch(Token::isSemantic);
    }

    @Override
    public String toString() {
        return tokens.stream().map(Token::getValue).collect(Collectors.joining(""));
    }
}

package com.lootfilters.lang;

import lombok.AllArgsConstructor;
import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.lootfilters.util.CollectionUtil.append;
import static com.lootfilters.util.TextUtil.quote;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !! DO NOT add features to the RS2F language without consulting Rikten X first. !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@RequiredArgsConstructor
public class Preprocessor {
    private final TokenStream tokens;

    private final Map<String, Define> defines = new HashMap<>();
    private final List<Token> preproc = new ArrayList<>(); // pre-expansion w/ all preproc lines removed

    public TokenStream preprocess() throws PreprocessException {
        while (tokens.isNotEmpty()) {
            var next = tokens.take(true);
            if (next.is(Token.Type.PREPROC_DEFINE)) {
                parseDefine();
            } else {
                preproc.add(next);
                if (!next.is(Token.Type.NEWLINE)) {
                    preproc.addAll(tokens.takeLine());
                    preproc.add(new Token(Token.Type.NEWLINE, "\n", Location.UNKNOWN));
                }
            }
        }

        return new TokenStream(expandDefines(new ArrayList<>(), new TokenStream(preproc)));
    }

    private void parseDefine() {
        var nameToken = tokens.takeExpect(Token.Type.IDENTIFIER);
        var name = nameToken.getValue();
        var params = tokens.peek().is(Token.Type.EXPR_START)
                ? parseDefineParams() : null;
        if (params != null && params.isEmpty()) {
            throw new PreprocessException("#define " + quote(name) + " has empty param list found at " + nameToken.getLocation().toString());
        }
        var line = tokens.takeLine();
        if (!line.isEmpty() && line.get(0).isWhitespace()) {
            line.remove(0);
        }
        defines.put(name, new Define(name, params, line));
    }

    private List<String> parseDefineParams() {
        var params = new ArrayList<String>();
        tokens.takeExpect(Token.Type.EXPR_START);
        while (tokens.isNotEmpty()) {
            var next = tokens.take();
            if (next.is(Token.Type.EXPR_END)) {
                return params;
            } else if (next.is(Token.Type.IDENTIFIER)) {
                params.add(next.getValue());
                tokens.takeOptional(Token.Type.COMMA);
            } else {
                throw new PreprocessException("unterminated define param list");
            }
        }
        throw new PreprocessException("unterminated define param list");
    }

    private List<Token> expandDefines(List<String> visited, TokenStream tokens) {
        var postproc = new ArrayList<Token>();
        while (tokens.isNotEmpty()) {
            var token = tokens.take(true);
            if (!visited.contains(token.getValue()) && token.is(Token.Type.IDENTIFIER) && defines.containsKey(token.getValue())) {
                var define = defines.get(token.getValue());
                if (define.isParameterized()) {
                    var args = tokens.takeArgList();
                    if (args.size() != define.params.size()) {
                        throw new PreprocessException(String.format("invalid macro expansion of %s (wanted %d args, got %d)",
                                define.name, define.params.size(), args.size()));
                    }
                    postproc.addAll(expandParameterizedDefine(append(visited, define.name), define, args, token.getLocation()));
                } else {
                    var defineTokens = define.value.stream().map(
                                    macroToken -> {
                                        // the location data for this token is:
                                        // 1. the location of the original token that will be replaced
                                        // 2. with the macroSourceLocation for the replacementToken we'll be inserting
                                        var newLocation = token.getLocation().withMacroSourceLocation(macroToken.getLocation().withMacroName(define.name));
                                        // create a copy of the macro location with the updated location
                                        return macroToken.withLocation(newLocation);
                                    })
                            .collect(Collectors.toList());
                    postproc.addAll(expandDefines(append(visited, define.name), new TokenStream(defineTokens)));
                }
            } else {
                postproc.add(token);
            }
        }
        return postproc;
    }

    private List<Token> expandParameterizedDefine(List<String> visited, Define define, List<TokenStream> args, Location macroInvocation) {
        var expanded = new ArrayList<Token>();
        for (var defineToken : define.value) {
            var token = defineToken.withLocation(macroInvocation.withMacroSourceLocation(defineToken.getLocation().withMacroName(define.name)));
            if (!token.is(Token.Type.IDENTIFIER) || token.getValue().equals(define.name)) {
                expanded.add(token);
                continue;
            }

            var paramIndex = -1;
            for (var i = 0; i < define.params.size(); ++i) {
                if (define.params.get(i).equals(token.getValue())) {
                    paramIndex = i;
                    break;
                }
            }
            if (paramIndex > -1) {
                var arg = args.get(paramIndex);
                expanded.addAll(arg.getTokens());
            } else {
                expanded.add(token);
            }
        }
        return expandDefines(visited, new TokenStream(expanded));
    }

    @AllArgsConstructor
    private static class Define {
        final String name;
        final List<String> params;
        final List<Token> value;

        boolean isParameterized() {
            return params != null;
        }
    }
}

package com.lootfilters.lang;

public class CompileException extends RuntimeException {
    public CompileException(String message) {
        super(message);
    }
}

package com.lootfilters.lang;

import lombok.RequiredArgsConstructor;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.isLegalIdent;
import static com.lootfilters.util.TextUtil.isNumeric;

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// !! DO NOT add features to the RS2F language without consulting Rikten X first. !!
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@RequiredArgsConstructor
public class Lexer {
    private static final LinkedHashMap<String, Token.Type> STATICS = new LinkedHashMap<>() {{
        put("\\\n", Token.Type.WHITESPACE);
        put("#define", Token.Type.PREPROC_DEFINE);
        put("apply", Token.Type.APPLY);
        put("false", Token.Type.FALSE);
        put("true", Token.Type.TRUE);
        put("meta", Token.Type.META);
        put("rule", Token.Type.RULE);
        put("if", Token.Type.IF);
        put("&&", Token.Type.OP_AND);
        put("||", Token.Type.OP_OR);
        put(">=", Token.Type.OP_GTEQ);
        put("<=", Token.Type.OP_LTEQ);
        put("==", Token.Type.OP_EQ);
        put("!", Token.Type.OP_NOT);
        put(">", Token.Type.OP_GT);
        put("<", Token.Type.OP_LT);
        put(";", Token.Type.STMT_END);
        put(":", Token.Type.COLON);
        put("=", Token.Type.ASSIGN);
        put(",", Token.Type.COMMA);
        put("(", Token.Type.EXPR_START);
        put(")", Token.Type.EXPR_END);
        put("{", Token.Type.BLOCK_START);
        put("}", Token.Type.BLOCK_END);
        put("[", Token.Type.LIST_START);
        put("]", Token.Type.LIST_END);
        put("\n", Token.Type.NEWLINE);
        put("\r", Token.Type.NEWLINE);
    }};

    private final String inputName;
    private final String input;
    private final List<Token> tokens = new ArrayList<>();
    private int offset = 0;
    // 1 indexed cause editors start line and char counts at 1
    private int currentLineOffset = 1;
    private int currentLineNumber = 1;

    public TokenStream tokenize() throws TokenizeException {
        while (offset < input.length()) {
            if (tokenizeStatic()) {
                continue;
            }
            if (tokenizeComment()) {
                continue;
            }

            var ch = input.charAt(offset);
            if (isTokenWhitespace(ch)) {
                tokenizeWhitespace();
            } else if (isNumeric(ch) || ch == '-' && isNumeric(input.charAt(offset + 1))) {
                tokenizeLiteralInt();
            } else if (ch == '"') {
                tokenizeLiteralString();
            } else if (isLegalIdent(ch)) {
                tokenizeIdentifier();
            } else {
                throw new TokenizeException(String.format("unrecognized character '" + ch + "' line %s char %s", currentLineNumber, currentLineOffset));
            }
        }

        return tokens.stream() // un-map escaped newlines
                .map(it -> it.getValue().equals("\\\n") ? new Token(Token.Type.WHITESPACE, "", it.getLocation()) : it)
                .collect(Collectors.collectingAndThen(Collectors.toList(), TokenStream::new));
    }

    private boolean tokenizeStatic() {
        for (var entry : STATICS.entrySet()) {
            var value = entry.getKey();
            var type = entry.getValue();
            if (input.startsWith(value, offset)) {
                tokens.add(new Token(type, value, currentLocation()));
                currentLineOffset += value.length();
                offset += value.length();
                // Checking for \n here captures both escaped and unescaped newlines
                // allowing us to properly track position within newline-escaped macros
                if (value.endsWith("\n")) {
                    currentLineOffset = 1;
                    currentLineNumber += 1;
                }
                return true;
            }
        }
        return false;
    }

    private boolean tokenizeComment() {
        return tokenizeLineComment() || tokenizeBlockComment();
    }

    private boolean tokenizeLineComment() {
        if (!input.startsWith("//", offset)) {
            return false;
        }

        var lineEnd = input.indexOf('\n', offset);
        var text = lineEnd > -1
                ? input.substring(offset, lineEnd)
                : input.substring(offset);
        tokens.add(new Token(Token.Type.COMMENT, text, currentLocation()));
        currentLineOffset += text.length();
        offset += text.length();
        return true;
    }

    private boolean tokenizeBlockComment() {
        if (!input.startsWith("/*", offset)) {
            return false;
        }

        var startLine = currentLineNumber;
        var startOffset = currentLineOffset;
        for (var i = offset + 2; i < input.length(); ++i) {
            if (input.startsWith("*/", i)) {
                currentLineOffset += 2;
                var text = input.substring(offset, i + 2);
                tokens.add(new Token(Token.Type.COMMENT, text, currentLocation()));
                offset += text.length();
                return true;
            } else if (input.charAt(i) == '\n') {
                ++currentLineNumber;
                currentLineOffset = 1;
            } else {
                ++currentLineOffset;
            }
        }

        throw new TokenizeException(String.format("unterminated block comment at line %d, char %d", startLine, startOffset));
    }

    private void tokenizeWhitespace() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isTokenWhitespace(input.charAt(i))) {
                var ws = input.substring(offset, i);
                tokens.add(new Token(Token.Type.WHITESPACE, ws, currentLocation()));
                currentLineOffset += i - offset;
                offset += i - offset;
                return;
            }
        }
        var ws = input.substring(offset);
        tokens.add(new Token(Token.Type.WHITESPACE, ws, currentLocation()));
        currentLineOffset += ws.length();
        offset = input.length();
    }

    private void tokenizeLiteralInt() {
        var start = input.charAt(offset) == '-' ? offset + 1 : offset;
        for (int i = start; i < input.length(); ++i) {
            if (input.charAt(i) == '_') {
                continue;
            }
            if (!isNumeric(input.charAt(i))) {
                var literal = input.substring(offset, i);
                tokens.add(Token.intLiteral(literal, currentLocation()));
                currentLineOffset += literal.length();
                offset += literal.length();
                return;
            }
        }
        tokens.add(Token.intLiteral(input.substring(offset), currentLocation()));
        currentLineOffset += input.substring(offset).length();
        offset = input.length();
    }

    private void tokenizeLiteralString() throws TokenizeException {
        for (int i = offset + 1; i < input.length(); ++i) {
            if (input.charAt(i) == '"') {
                var literal = input.substring(offset + 1, i);
                // for quotes, which the captured literal omits
                tokens.add(Token.stringLiteral(literal, currentLocation()));
                currentLineOffset += literal.length() + 2;
                offset += literal.length() + 2;
                return;
            }
        }
        throw new TokenizeException("unterminated string literal");
    }

    private void tokenizeIdentifier() {
        for (int i = offset; i < input.length(); ++i) {
            if (!isLegalIdent(input.charAt(i))) {
                var ident = input.substring(offset, i);
                tokens.add(Token.identifier(ident, currentLocation()));
                currentLineOffset += ident.length();
                offset += ident.length();
                return;
            }
        }
        tokens.add(Token.identifier(input.substring(offset), currentLocation()));
        currentLineOffset += input.substring(offset).length();
        offset = input.length();
    }

    private Location currentLocation() {
        return new Location(inputName, currentLineNumber, currentLineOffset);
    }

    private static boolean isTokenWhitespace(char c) { // newlines are tokenized separately
        return c == ' ' || c == '\t';
    }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum FontMode {
    RUNELITE("runelite"),
    PLUGIN("plugin");

    private final String value;

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.model;

import com.lootfilters.LootFiltersPlugin;
import com.lootfilters.lang.ParseException;
import com.lootfilters.lang.Token;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class SoundProvider {
    public abstract void play(LootFiltersPlugin plugin);

    public static SoundProvider fromExpr(Token token) throws ParseException {
        switch (token.getType()) {
            case LITERAL_INT:
                return new SoundEffect(token.expectInt());
            case LITERAL_STRING:
                return new File(token.expectString());
            default:
                throw new ParseException("sound: unexpected token", token);
        }
    }

    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static final class SoundEffect extends SoundProvider {
        private final int id;

        @Override
        public void play(LootFiltersPlugin plugin) {
            plugin.getClientThread().invoke(() -> {
                var client = plugin.getClient();
                var userVolume = client.getPreferences().getSoundEffectVolume();
                var effectVolume = plugin.getConfig().soundVolume();

                client.getPreferences().setSoundEffectVolume(effectVolume);
                client.playSoundEffect(id, effectVolume);
                client.getPreferences().setSoundEffectVolume(userVolume);
            });
        }
    }

    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static final class File extends SoundProvider {
        private final String filename;

        @Override
        public void play(LootFiltersPlugin plugin) {
            try {
                var soundFile = new java.io.File(LootFiltersPlugin.SOUND_DIRECTORY, filename);
                var gain = 20f * (float) Math.log10(plugin.getConfig().soundVolume() / 100f);
                plugin.getAudioPlayer().play(soundFile, gain);
            } catch (Exception e) {
                log.warn("play audio {}", filename, e);
            }
        }
    }
}

package com.lootfilters.model;

import com.lootfilters.LootFiltersPlugin;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.util.ImageUtil;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;

import static com.lootfilters.LootFiltersPlugin.ICON_DIRECTORY;

@Slf4j
public abstract class BufferedImageProvider {
    //Height only applies to item icons
    public abstract BufferedImage getImage(LootFiltersPlugin plugin, PluginTileItem item, int... height);

    public abstract CacheKey getCacheKey(PluginTileItem item, int... height);

    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static final class Sprite extends BufferedImageProvider {
        private final int spriteId;
        private final int index;

        @Override
        public BufferedImage getImage(LootFiltersPlugin plugin, PluginTileItem item, int... height) {
            try {
                return plugin.getSpriteManager().getSprite(spriteId, index);
            } catch (ArrayIndexOutOfBoundsException e) {
                log.warn("sprite index out of bounds", e);
                return null;
            }
        }

        @Override
        public CacheKey getCacheKey(PluginTileItem item, int... height) {
            return new CacheKey(0, spriteId, index, "", 16);
        }
    }

    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static final class Item extends BufferedImageProvider {
        private final int itemId;

        @Override
        public BufferedImage getImage(LootFiltersPlugin plugin, PluginTileItem item, int... height) {
            var image = plugin.getItemManager().getImage(itemId);
            var imageHeight = height.length >= 1 ? height[0] : 16;
            return ImageUtil.resizeImage(image, image.getWidth() * imageHeight / image.getHeight(), imageHeight,true);
        }

        @Override
        public CacheKey getCacheKey(PluginTileItem item, int... height) {
            return new CacheKey(1, itemId, 0, "",height.length >= 1 ? height[0] : 16);
        }
    }

    @AllArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static final class File extends BufferedImageProvider {
        private final String filename;

        @Override
        public BufferedImage getImage(LootFiltersPlugin plugin, PluginTileItem item, int... height) {
            try {
                return ImageIO.read(new java.io.File(ICON_DIRECTORY, filename));
            } catch (Exception e) {
                log.warn("load image file {}", filename, e);
                return null;
            }
        }

        @Override
        public CacheKey getCacheKey(PluginTileItem item, int... height) {
            return new CacheKey(2, 0, 0, filename,16);
        }
    }

    @EqualsAndHashCode(callSuper = false)
    public static final class CurrentItem extends BufferedImageProvider {
        @Override
        public BufferedImage getImage(LootFiltersPlugin plugin, PluginTileItem item, int... height) {
            var image = plugin.getItemManager().getImage(item.getId(), item.getQuantity(), false);
            var imageHeight = height.length >= 1 ? height[0] : 16;
            return ImageUtil.resizeImage(image, image.getWidth() * imageHeight / image.getHeight(), imageHeight,true);
        }

        @Override
        public CacheKey getCacheKey(PluginTileItem item, int... height) {
            return new CacheKey(3, item.getId(), item.getQuantity(), "", height.length >= 1 ? height[0] : 16);
        }
    }

    @Value
    public static class CacheKey {
        int type;
        int param0, param1;
        String param2;
        int height;
    }
}

package com.lootfilters.model;

import com.lootfilters.lang.ParseException;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TextAccent {
    USE_FILTER("use filter"),
    SHADOW("shadow"),
    OUTLINE("outline"),
    NONE("none"),
    SHADOW_BOLD("shadow bold");

    private final String value;

    public static TextAccent fromOrdinal(int o) {
        switch (o) {
            case 1: return SHADOW;
            case 2: return OUTLINE;
            case 3: return NONE;
            case 4: return SHADOW_BOLD;
            default: throw new ParseException("unrecognized TextAccent ordinal " + o);
        }
    }

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.model;

import com.lootfilters.lang.ParseException;
import com.lootfilters.lang.Token;

public enum Comparator {
    GT, LT, EQ, GT_EQ, LT_EQ;

    public static Comparator fromToken(Token t) {
        switch (t.getType()) {
            case OP_GT: return GT;
            case OP_LT: return LT;
            case OP_EQ: return EQ;
            case OP_GTEQ: return GT_EQ;
            case OP_LTEQ: return LT_EQ;
            default:
                throw new ParseException("unrecognized token", t);
        }
    }

    public static Comparator fromString(String str) {
        switch (str) {
            case ">": return GT;
            case "<": return LT;
            case "==": return EQ;
            case ">=": return GT_EQ;
            case "<=": return LT_EQ;
            default:
                throw new IllegalArgumentException("unrecognized comparator string " + str);
        }
    }
}

package com.lootfilters.model;

import lombok.Value;

import static java.lang.Integer.parseInt;

@Value
public class NamedQuantity {
    String name;
    Comparator comparator;
    int quantity;

    public static NamedQuantity fromString(String str) {
        if (str.contains(">")) {
            return fromString(str, ">");
        } else if (str.contains("<")) {
            return fromString(str, "<");
        }
        return new NamedQuantity(str, Comparator.GT, 0);
    }

    private static NamedQuantity fromString(String str, String cmp) {
        var parts = str.split(cmp);
        if (parts.length != 2) {
            return new NamedQuantity(str, Comparator.GT, 0);
        }

        int quantity;
        try {
            quantity = parseInt(parts[1].trim());
        } catch (Exception ignored) {
            return new NamedQuantity(str, Comparator.GT, 0);
        }

        return new NamedQuantity(parts[0].trim(), Comparator.fromString(cmp), quantity);
    }
}

package com.lootfilters.model;

import com.lootfilters.LootFiltersPlugin;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.Model;
import net.runelite.api.Node;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.time.Instant;

public class PluginTileItem implements TileItem {
    private final TileItem item;
    @Getter private final String name;
    private final int gePrice;
    @Getter private final int haPrice;
    @Getter private final WorldPoint worldPoint;
    @Getter private final int spawnTime;
    @Getter private final Instant despawnInstant;
    @Getter private final boolean isStackable;
    @Getter private final boolean isNoted;
    @Getter private final boolean isTradeable;

    @Setter
    private int quantityOverride = -1;

    public PluginTileItem(LootFiltersPlugin plugin, Tile tile, TileItem item) {
        var composition = plugin.getItemManager().getItemComposition(item.getId());
        var linkedNoteComposition = plugin.getItemManager().getItemComposition(composition.getLinkedNoteId());

        this.item = item;
        this.name = composition.getName();
        this.gePrice = plugin.getItemManager().getItemPrice(item.getId());
        this.haPrice = composition.getHaPrice();
        this.worldPoint = WorldPoint.fromLocalInstance(plugin.getClient(), tile.getLocalLocation());
        this.spawnTime = plugin.getClient().getTickCount();
        this.despawnInstant = Instant.now().plusMillis((getDespawnTime() - spawnTime) * 600L);
        this.isStackable = composition.isStackable();
        this.isNoted = composition.getNote() != -1;
        this.isTradeable = composition.isTradeable() || linkedNoteComposition.isTradeable();
    }

    public int getGePrice() {
        switch (getId()) {
            case ItemID.COINS:
                return 1;
            case ItemID.PLATINUM:
                return 1000;
            default:
                return gePrice;
        }
    }

    public boolean isMoney() {
        return getId() == ItemID.COINS || getId() == ItemID.PLATINUM;
    }

    @Override
    public boolean equals(Object other) {
        return other instanceof PluginTileItem && ((PluginTileItem) other).item == item
                || other instanceof TileItem && other == item;
    }

    @Override
    public int hashCode() {
        return item.hashCode();
    }

    @Override
    public int getQuantity() {
        return quantityOverride > -1 ? quantityOverride : item.getQuantity();
    }

    @Override public int getId() { return item.getId(); }
    @Override public int getVisibleTime() { return item.getVisibleTime(); }
    @Override public int getDespawnTime() { return item.getDespawnTime(); }
    @Override public int getOwnership() { return item.getOwnership(); }
    @Override public boolean isPrivate() { return item.isPrivate(); }
    @Override public Model getModel() { return item.getModel(); }
    @Override public int getModelHeight() { return item.getModelHeight(); }
    @Override public void setModelHeight(int i) { item.setModelHeight(i); }
    @Override public Node getNext() { return item.getNext(); }
    @Override public Node getPrevious() { return item.getPrevious(); }
    @Override public long getHash() { return item.getHash(); }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum DespawnTimerType {
    TICKS("ticks"),
    SECONDS("seconds"),
    PIE("pie");
    private final String label;

    @Override
    public String toString() {
        return label;
    }
}

package com.lootfilters.model;

import com.lootfilters.lang.ParseException;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum FontType {
    USE_FILTER("use filter"),
    NORMAL("small"),
    LARGER("regular"),
    BOLD("bold");

    private final String value;

    public static FontType fromOrdinal(int o) {
        switch (o) {
            case 1: return NORMAL;
            case 2: return LARGER;
            case 3: return BOLD;
            default:
                throw new ParseException("unrecognized FontType ordinal " + o);
        }
    }

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.model;

import com.lootfilters.LootFiltersPlugin;
import lombok.RequiredArgsConstructor;

import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

@RequiredArgsConstructor
public class IconIndex {
    private final LootFiltersPlugin plugin;
    private final Map<BufferedImageProvider.CacheKey, CacheEntry> index = new HashMap<>();

    public BufferedImage get(BufferedImageProvider.CacheKey key) {
        return index.containsKey(key) ? index.get(key).image : null;
    }

    public void inc(BufferedImageProvider provider, PluginTileItem item, int... height) {
        index.compute(provider.getCacheKey(item, height), (k, entry) -> {
            if (entry == null) {
                return new CacheEntry(provider.getImage(plugin, item, height));
            }

            ++entry.refCount;
            return entry;
        });
    }

    public void dec(BufferedImageProvider provider, PluginTileItem item, int... height) {
        index.compute(provider.getCacheKey(item, height), (k, entry) -> {
            if (entry == null) {
                return null;
            }
            --entry.refCount;
            return entry.refCount == 0 ? null : entry;
        });
    }

    public int size() {
        return index.size();
    }

    public void clear() {
        index.clear();
    }

    public void reset() {
        clear();
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            for (var item : entry.getValue()) {
                var match = plugin.getActiveFilter().findMatch(plugin, item);
                if (match != null && match.getIcon() != null) {
                    inc(match.getIcon(), item, match.isCompact() ? plugin.getConfig().compactRenderSize() : 16);
                }
            }
        }
    }

    @RequiredArgsConstructor
    private static final class CacheEntry {
        final BufferedImage image;
        int refCount = 1;
    }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ValueDisplayType {
    HIGHEST("highest"),
    GE("grand exchange"),
    HA("high alchemy"),
    BOTH("both");

    private final String label;

    @Override public String toString() { return label; }
}

package com.lootfilters.model;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum DualValueDisplayType {
    COMPACT("compact"),
    VERBOSE("verbose");

    private final String label;

    @Override public String toString() { return label; }
}

package com.lootfilters.model;

public enum ValueType {
    HIGHEST, GE, HA;

    @Override
    public String toString() {
        switch (this) {
            case HIGHEST: return "highest";
            case GE: return "grand exchange";
            default: return "high alchemy";
        }
    }
}

package com.lootfilters.model;

import com.lootfilters.lang.ParseException;
import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Ownership {
    NONE("none"),
    SELF("self"),
    OTHER("other"),
    GROUP("group");

    private final String value;

    public static Ownership fromOrdinal(int o) {
        switch (o) {
            case 0: return NONE;
            case 1: return SELF;
            case 2: return OTHER;
            case 3: return GROUP;
            default: throw new ParseException("Ownership ordinal out of bounds [0-3]: " + o);
        }
    }

    @Override
    public String toString() {
        return value;
    }
}

package com.lootfilters.model;

import com.lootfilters.DisplayConfig;
import com.lootfilters.LootFiltersPlugin;
import lombok.AllArgsConstructor;
import lombok.NonNull;

import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public class DisplayConfigIndex {
    private final LootFiltersPlugin plugin;
    private final Map<PluginTileItem, DisplayConfig> index = new HashMap<>();

    public @NonNull DisplayConfig get(PluginTileItem item) {
        return index.get(item);
    }

    public void put(PluginTileItem item, @NonNull DisplayConfig display) {
        index.put(item, display);
    }

    public void remove(PluginTileItem item) {
        index.remove(item);
    }

    public int size() {
        return index.size();
    }

    public void clear() {
        index.clear();
    }

    public void reset() {
        clear();
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            for (var item : entry.getValue()) {
                var match = plugin.getActiveFilter().findMatch(plugin, item);
                index.put(item, match);
            }
        }
    }
}

package com.lootfilters;

import com.lootfilters.model.PluginTileItem;
import lombok.AllArgsConstructor;
import net.runelite.api.Tile;

import java.util.HashMap;
import java.util.Map;

@AllArgsConstructor
public class LootbeamIndex {
    private final LootFiltersPlugin plugin;

    private final Map<Tile, Map<PluginTileItem, Lootbeam>> index = new HashMap<>();

    public int size() {
        return index.values().stream()
                .mapToInt(Map::size)
                .sum();
    }

    public void put(Tile tile, PluginTileItem item, Lootbeam beam) {
        if (!index.containsKey(tile)) {
            index.put(tile, new HashMap<>());
        }

        var beams = index.get(tile);
        beams.put(item, beam);
    }

    public void remove(Tile tile, PluginTileItem item) {
        if (!index.containsKey(tile)) {
            return; // what?
        }

        var beams = index.get(tile);
        if (!beams.containsKey(item)) {
            return; // what?
        }

        var beam = beams.get(item);
        beam.remove();
        beams.remove(item);
        if (beams.isEmpty()) {
            index.remove(tile);
        }
    }

    public void clear() {
        for (var beams : index.values()) {
            for (var beam : beams.values()) {
                beam.remove();
            }
        }
        index.clear();
    }

    public void reset() {
        clear();
        for (var entry : plugin.getTileItemIndex().entrySet()) {
            var tile = entry.getKey();
            for (var item : entry.getValue()) {
                var match = plugin.getActiveFilter().findMatch(plugin, item);
                if (match != null && match.isShowLootbeam()) {
                    put(tile, item, new Lootbeam(plugin.getClient(), plugin.getClientThread(), tile.getWorldLocation(),
                            match.getLootbeamColor(), Lootbeam.Style.MODERN));
                }
            }
        }
    }
}

package com.lootfilters;

import com.lootfilters.lang.CompileException;
import com.lootfilters.lang.Lexer;
import com.lootfilters.lang.Parser;
import com.lootfilters.lang.Preprocessor;
import com.lootfilters.lang.Sources;
import com.lootfilters.lang.TokenStream;
import com.lootfilters.model.PluginTileItem;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

import java.awt.Color;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import static com.lootfilters.lang.Location.UNKNOWN_SOURCE_NAME;
import static com.lootfilters.util.TextUtil.normalizeCrlf;

@Getter
@EqualsAndHashCode
@ToString
public class LootFilter {
    public static final LootFilter Nop = LootFilter.builder().build();

    private final String name;
    private final String filename;
    private final String description;
    private final List<FilterRule> rules;

    private LootFilter(Builder builder) {
        name = builder.name;
        filename = builder.filename;
        description = builder.description;
        rules = builder.rules;
    }

    public static LootFilter fromSourcesWithPreamble(Map<String, String> sources) throws CompileException {
        if (!sources.containsKey("preamble")) {
            // LinkedHashMap preserves insertion order for iteration ensuring preamble is handled first
            var withPreamble = new LinkedHashMap<String, String>();
            withPreamble.put("preamble", Sources.getPreamble());
            // If iteration order of input map is unstable this may change ordering of input scripts
            withPreamble.putAll(sources);
            return fromSources(withPreamble);
        }
        return fromSources(new LinkedHashMap<>(sources));
    }

    public static LootFilter fromSources(LinkedHashMap<String, String> sources) throws CompileException {
        var combinedStream = sources
                .entrySet().stream()
                .map(source -> {
                    // Do this in 1 map iteration to ensure we preserve iteration order over our input
                    var sourceValue = source.getValue();
                    if (!sourceValue.endsWith("\n")) {
                        sourceValue += "\n";
                    }
                    return new Lexer(source.getKey(), normalizeCrlf(sourceValue));
                })
                .map(Lexer::tokenize)
                .flatMap(tokenStream -> tokenStream.getTokens().stream())
                .collect(Collectors.collectingAndThen(Collectors.toList(), TokenStream::new));

        var postproc = new Preprocessor(combinedStream).preprocess();
        return new Parser(postproc).parse();
    }

    public static LootFilter fromSource(String source) throws CompileException {
        return fromSourcesWithPreamble(Map.of(UNKNOWN_SOURCE_NAME, source));
    }

    public Builder toBuilder() {
        var builder = new Builder();
        builder.name = name;
        builder.filename = filename;
        builder.description = description;
        builder.rules = new ArrayList<>(rules);
        return builder;
    }

    public @NonNull DisplayConfig findMatch(LootFiltersPlugin plugin, PluginTileItem item) {
        var display = new DisplayConfig(Color.WHITE).toBuilder()
                .compact(plugin.getConfig().compactMode())
                .build();
        for (var rule : rules) {
            if (!rule.getCond().test(plugin, item)) {
                continue;
            }

            display = display.merge(rule.getDisplay());
            display.getEvalTrace().add(rule.getSourceLine());
            if (rule.isTerminal()) {
                return display;
            }
        }
        return display;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        private String name;
        private String filename;
        private String description;
        private List<FilterRule> rules = new ArrayList<>();

        private Builder() {
        }

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setFilename(String filename) {
            this.filename = filename;
            return this;
        }

        public Builder setDescription(String description) {
            this.description = description;
            return this;
        }

        public Builder setRules(List<FilterRule> rules) {
            this.rules = rules;
            return this;
        }

        public Builder addRule(FilterRule rule) {
            rules.add(rule);
            return this;
        }

        public LootFilter build() {
            return new LootFilter(this);
        }
    }
}

package com.lootfilters;

import com.lootfilters.model.PluginTileItem;
import lombok.AllArgsConstructor;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.coords.WorldPoint;

import java.awt.Color;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.lootfilters.util.CollectionUtil.findBounds;
import static com.lootfilters.util.TextUtil.abbreviate;
import static net.runelite.client.util.ColorUtil.colorTag;
import static net.runelite.client.util.ColorUtil.wrapWithColorTag;

@AllArgsConstructor
public class MenuEntryComposer {
    private final LootFiltersPlugin plugin;

    public void onMenuEntryAdded(MenuEntry entry) { // recolor/add quantity
        if (!isGroundItem(entry)) {
            return;
        }

        var items = getItemsForEntry(entry);
        if (isIndeterminate(items)) {
            var quantity = items.stream().mapToInt(PluginTileItem::getQuantity).sum();
            var deprioritized = plugin.getConfig().deprioritizeHidden() && items.stream().allMatch(this::isHidden);
            entry.setTarget(entry.getTarget() + " (" + quantity + ")");
            entry.setDeprioritized(deprioritized);
            return;
        }

        var item = items.get(0);
        var match = plugin.getDisplayIndex().get(item);

        entry.setDeprioritized(plugin.getConfig().deprioritizeHidden() && match.isHidden());
        var color = match.isHidden() && plugin.getConfig().recolorHidden()
                ? plugin.getConfig().hiddenColor()
                : match.getMenuTextColor();
        entry.setTarget(buildTargetText(item, entry.getTarget(), color));
    }

    public void onClientTick() { // sort -> collapse
        if (plugin.getClient().isMenuOpen()) {
            return;
        }

        var entries = sortEntries(plugin.getClient().getMenu().getMenuEntries());
        if (plugin.getConfig().collapseEntries()) {
            entries = collapseEntries(entries);
        }
        if (plugin.getConfig().showAnalyzer()) {
            entries = addAnalyzers(entries);
        }
        plugin.getClient().getMenu().setMenuEntries(entries);
    }

    private MenuEntry[] sortEntries(MenuEntry[] entries) {
        var bounds = findBounds(List.of(entries), MenuEntryComposer::isGroundItem);
        if (bounds[0] == -1) { // no items to sort
            return entries;
        }

        var items = Arrays.copyOfRange(entries, bounds[0], bounds[1]);
        var sortedItems = Arrays.stream(items).sorted((i, j) -> {
            var itemsI = getItemsForEntry(i);
            var itemsJ = getItemsForEntry(j);
            var displayI = isIndeterminate(itemsI) ? null : plugin.getDisplayIndex().get(itemsI.get(0));
            var displayJ = isIndeterminate(itemsJ) ? null : plugin.getDisplayIndex().get(itemsJ.get(0));
            var sortI = displayI != null ? displayI.getMenuSort() : 0;
            var sortJ = displayJ != null ? displayJ.getMenuSort() : 0;
            return sortI - sortJ;
        }).toArray(MenuEntry[]::new);

        var sorted = entries.clone();
        for (var i = bounds[0]; i < bounds[1]; ++i) {
            sorted[i] = sortedItems[i - bounds[0]];
        }
        return sorted;
    }

    private MenuEntry[] collapseEntries(MenuEntry[] entries) {
        var itemCounts = Stream.of(entries)
                .filter(MenuEntryComposer::isGroundItem)
                .collect(Collectors.groupingBy(MenuEntryComposer::entrySlug, Collectors.counting()));

        // the displayed list is built IN REVERSE of the actual array contents - so you have to collapse in reverse as
        // well, otherwise you will break the original order
        // this is accomplished trivially by reverse -> collapse -> reverse
        var reversed = Arrays.asList(entries);
        Collections.reverse(reversed);

        var collapsed = reversed.stream()
                .map(it -> isGroundItem(it)
                        ? withCount(it, itemCounts.getOrDefault(entrySlug(it), 1L))
                        : it)
                .distinct()
                .collect(Collectors.toList());
        Collections.reverse(collapsed);

        return collapsed.toArray(MenuEntry[]::new);
    }

    private MenuEntry[] addAnalyzers(MenuEntry[] entries) {
        return Arrays.stream(entries)
                .flatMap(it -> isGroundItem(it, false)
                        ? Stream.of(it, getAnalyzer(it))
                        : Stream.of(it))
                .toArray(MenuEntry[]::new);
    }

    private MenuEntry getAnalyzer(MenuEntry entry) {
        var item = getItemsForEntry(entry).get(0);
        var display = plugin.getDisplayIndex().get(item);
        Consumer<MenuEntry> onClick = (e) -> {
            var trace = display.getEvalTrace();
            if (trace.isEmpty()) {
                plugin.addChatMessage(item.getName() + " did not match any config list or filter rule.");
            } else if (trace.size() == 1 && trace.get(0) == -4) {
                plugin.addChatMessage(item.getName() + " is hidden by the 'Item lists' -> 'Hidden items' setting.");
            } else if (trace.size() == 1 && trace.get(0) == -3) {
                plugin.addChatMessage(item.getName() + " is highlighted by the 'Item lists' -> 'Highlighted items' setting.");
            } else if (trace.size() == 1 && trace.get(0) == -2) {
                plugin.addChatMessage(item.getName() + " is hidden by the 'General' -> 'Item spawn filter' setting.");
            } else if (trace.size() == 1 && trace.get(0) == -1) {
                plugin.addChatMessage(item.getName() + " is hidden by the 'General' -> 'Ownership filter' setting.");
            } else {
                plugin.addChatMessage(item.getName() + " matched lines " + trace);
            }
        };

        return plugin.getClient().getMenu().createMenuEntry(-1)
                .setOption("[Loot Filters]: Analyze")
                .setTarget(entry.getTarget())
                .setType(MenuAction.RUNELITE)
                .onClick(onClick);
    }

    private MenuEntry withCount(MenuEntry entry, long count) {
        return count > 1
                ? entry.setTarget(entry.getTarget() + " x" + count)
                : entry;
    }

    private List<PluginTileItem> getItemsForEntry(MenuEntry entry) {
        var wv = plugin.getClient().getTopLevelWorldView();
        var point = WorldPoint.fromScene(wv, entry.getParam0(), entry.getParam1(), wv.getPlane());
        return plugin.getTileItemIndex().findItem(point, entry.getIdentifier());
    }

    private String buildTargetText(PluginTileItem item, String baseTarget, Color color) {
        var start = baseTarget.lastIndexOf('>'); // check for WIDGET_TARGET_ON_GROUND_ITEM

        var text = baseTarget.substring(start > -1 ? start + 1 : 0);
        if (item.getQuantity() > 1) {
            text += " (" + abbreviate(item.getQuantity()) + ")";
        }

        var prefix = start > -1 ? baseTarget.substring(0, start + 1) : "";
        return prefix + wrapWithColorTag(text, color);
    }

    private static boolean isGroundItem(MenuEntry entry, boolean includeNonOptions) {
        var type = entry.getType();
        return type == MenuAction.GROUND_ITEM_FIRST_OPTION
                || type == MenuAction.GROUND_ITEM_SECOND_OPTION
                || type == MenuAction.GROUND_ITEM_THIRD_OPTION
                || type == MenuAction.GROUND_ITEM_FOURTH_OPTION
                || type == MenuAction.GROUND_ITEM_FIFTH_OPTION
                || includeNonOptions && type == MenuAction.WIDGET_TARGET_ON_GROUND_ITEM
                || includeNonOptions && type == MenuAction.EXAMINE_ITEM_GROUND;
    }

    private static boolean isGroundItem(MenuEntry entry) {
        return isGroundItem(entry, true);
    }

    // The results of a menu entry lookup are "indeterminate" if the item was stackable, and we found more than one.
    // This limits what we can do in menu entry ops because we do not know what each menu entry actually points to
    // when clicked (e.g. we cannot reliably display the quantity that will be taken).
    private static boolean isIndeterminate(List<PluginTileItem> items) {
        return items.isEmpty() || items.size() > 1 && items.get(0).isStackable();
    }

    private static String entrySlug(MenuEntry entry) {
        return entry.getType().toString() + entry.getIdentifier() + entry.getParam0() + entry.getParam1();
    }

    private boolean isHidden(PluginTileItem item) {
        var display = plugin.getDisplayIndex().get(item);
        return display != null && display.isHidden();
    }
}

package com.lootfilters.migration;

import com.google.gson.reflect.TypeToken;
import com.lootfilters.LootFiltersPlugin;
import lombok.AllArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import javax.swing.JOptionPane;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@Slf4j
@AllArgsConstructor
public class Migrate_133_140 {
    private final LootFiltersPlugin plugin;

    public static void run(LootFiltersPlugin plugin) {
        try {
            new Migrate_133_140(plugin).run();
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Loot filters plugin: FAILED to migrate" +
                    " config-based filters to disk. Please contact the plugin maintainers on Discord or GitHub. Your" +
                    " existing filter data has NOT been removed.");
            log.warn("migrate filters to disk: {}{}", e.getMessage(), Arrays.toString(e.getStackTrace()));
        }
    }

    public void run() throws Exception {
        var migrated = plugin.getConfigManager().getConfiguration(LootFiltersPlugin.CONFIG_GROUP, "Migrate_133_140");
        if (migrated != null) {
            return;
        }
        plugin.getConfigManager().setConfiguration(LootFiltersPlugin.CONFIG_GROUP, "Migrate_133_140", true);

        var toMigrate = getConfigUserFilters();
        if (toMigrate.isEmpty()) {
            return;
        }

        for (var i = 0; i < toMigrate.size(); ++i) {
            plugin.getFilterManager().saveNewFilter("migrated_filter_" + i, toMigrate.get(i));
        }
        plugin.reloadFilters();
        plugin.getPluginPanel().reflowFilterSelect(plugin.getLoadedFilters(), plugin.getSelectedFilterName());
    }

    private List<String> getConfigUserFilters() {
        var cfg = plugin.getConfigManager().getConfiguration(LootFiltersPlugin.CONFIG_GROUP, "user-filters");
        if (cfg == null || cfg.isEmpty()) {
            return new ArrayList<>();
        }

        var type = new TypeToken<List<String>>() {
        }.getType();
        return plugin.getGson().fromJson(cfg, type);
    }
}

package com.lootfilters;

import com.lootfilters.model.NamedQuantity;
import com.lootfilters.model.SoundProvider;
import com.lootfilters.ast.AndCondition;
import com.lootfilters.ast.leaf.ItemNameCondition;
import com.lootfilters.ast.leaf.ItemQuantityCondition;
import com.lootfilters.ast.OrCondition;
import com.lootfilters.ast.Condition;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

import java.util.Arrays;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Getter
@AllArgsConstructor
@EqualsAndHashCode
@ToString
public class FilterRule {
    private final Condition cond;
    private final DisplayConfig display;
    private final boolean isTerminal;
    private final int sourceLine;

    public FilterRule withDisplay(Consumer<DisplayConfig.DisplayConfigBuilder> consumer) {
        var builder = display.toBuilder();
        consumer.accept(builder);
        return new FilterRule(cond, builder.build(), isTerminal, sourceLine);
    }

    public static FilterRule highlight(LootFiltersConfig config) {
        var rawNames = config.highlightedItems();
        var rule = new OrCondition(
                Arrays.stream(rawNames.split(","))
                        .map(NamedQuantity::fromString)
                        .map(it -> new AndCondition(new ItemNameCondition(it.getName()), new ItemQuantityCondition(it.getQuantity(), it.getComparator())))
                        .collect(Collectors.toList())
        );

        SoundProvider sound = null;
        var configSound = config.highlightSound();
        try {
            var soundId = Integer.parseInt(configSound);
            sound = new SoundProvider.SoundEffect(soundId);
        } catch (NumberFormatException e) {
            if (!configSound.isBlank()) {
                sound = new SoundProvider.File(configSound);
            }
        }
        var display = DisplayConfig.builder()
                .textColor(config.highlightColor())
                .showLootbeam(config.highlightLootbeam())
                .notify(config.highlightNotify())
                .backgroundColor(config.higlightBackgroundColor())
                .borderColor(config.highlightBorderColor())
                .lootbeamColor(config.highlightLootbeamColor())
                .menuTextColor(config.highlightMenuTextColor())
                .menuSort(config.highlightMenuSort())
                .sound(sound)
                .build();
        return new FilterRule(rule, display, true, -3);
    }

    public static FilterRule hide(String rawNames) {
        var rule = new OrCondition(
                Arrays.stream(rawNames.split(","))
                        .map(NamedQuantity::fromString)
                        .map(it -> new AndCondition(new ItemNameCondition(it.getName()), new ItemQuantityCondition(it.getQuantity(), it.getComparator())))
                        .collect(Collectors.toList())
        );
        var display = DisplayConfig.builder()
                .hidden(true)
                .build();
        return new FilterRule(rule, display, true, -4);
    }
}

package com.lootfilters;

import com.lootfilters.model.DespawnTimerType;
import com.lootfilters.model.DualValueDisplayType;
import com.lootfilters.model.FontMode;
import com.lootfilters.model.ValueDisplayType;
import com.lootfilters.model.TextAccent;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

import java.awt.Color;

@ConfigGroup("loot-filters")
public interface LootFiltersConfig extends Config {
    @ConfigItem(keyName = "preferredDefaultFilter", hidden = true, name = "", description = "")
    default String getPreferredDefault() { return DefaultFilter.FILTERSCAPE.getName(); }
    @ConfigItem(keyName = "preferredDefaultFilter", hidden = true, name = "", description = "")
    void setPreferredDefault(String name);

    @ConfigSection(name = "Plugin panel", description = "", position = -2)
    String pluginPanel = "pluginPanel";
    String SHOW_PLUGIN_PANEL = "showPluginPanel";
    @ConfigItem(
            keyName = SHOW_PLUGIN_PANEL,
            name = "Enabled",
            description = "Show the plugin panel in the side nav. The entire plugin, including the active loot filter, will still operate if the panel is hidden.",
            section = pluginPanel
    )
    default boolean showPluginPanel() { return true; }

    @ConfigSection(
            name = "General",
            description = "Configure general options.",
            position = 0
    )
    String general = "general";
    @ConfigItem(
            keyName = "chatPrefixColor",
            name = "Chat prefix color",
            description = "Color of the chat prefix used to identify messages from this plugin.",
            section = general,
            position = -3
    )
    default Color chatPrefixColor() { return Color.decode("#00ffff"); }
    String CONFIG_KEY_FETCH_DEFAULT_FILTERS = "fetchDefaultFilters";
    @ConfigItem(
            keyName = CONFIG_KEY_FETCH_DEFAULT_FILTERS,
            name = "Fetch default filters",
            description = "Fetch the default filters and include them as options in the plugin panel.",
            section = general,
            position = -2
    )
    default boolean fetchDefaultFilters() { return true; }
    @ConfigItem(
            keyName = "fontMode",
            name = "Font mode",
            description = "<p>[runelite]: Respect the font type set in RuneLite -> Overlay settings -> Dynamic overlay font. Filter settings for font type will be ignored.</p><p>[plugin]: Respect the font type set by filter rules. Filter display defaults to the small font type.</p>",
            section = general,
            position = 6
    )
    default FontMode fontMode() { return FontMode.RUNELITE; }
    @ConfigItem(
            keyName = "soundVolume",
            name = "Sound volume",
            description = "Volume of sounds played by loot filter. Setting this to 0 will disable sound playback.",
            section = general,
            position = 6
    )
    @Range(max = 100)
    @Units(Units.PERCENT)
    default int soundVolume() { return 100; }

    @ConfigSection(
            name = "Hotkey",
            description = "Configure hotkey options.",
            position = 1
    )
    String hotkey = "Hotkey";
    @ConfigItem(
            keyName = "hotkey",
            name = "Hotkey",
            description = "Hotkey used by this plugin.",
            section = hotkey,
            position = 0
    )
    default Keybind hotkey() { return Keybind.ALT; }
    @ConfigItem(
            keyName = "hotkeyShowHiddenItems",
            name = "Press: Show hidden items",
            description = "Show hidden items when hotkey is pressed.",
            section = hotkey,
            position = 1
    )
    default boolean hotkeyShowHiddenItems() { return true; }
    @ConfigItem(
            keyName = "hotkeyShowClickboxes",
            name = "Press: Show hide/highlight box",
            description = "Show hide/highlight boxes when hotkey is pressed.<p>You can still toggle hide/highlight when this is disabled with left/right/middle click over an item's overlay text.",
            section = hotkey,
            position = 2
    )
    default boolean hotkeyShowClickboxes() { return true; }
    @ConfigItem(
            keyName = "hotkeyShowValues",
            name = "Press: Show item values",
            description = "Show item values when the hotkey is pressed, even if they're otherwise disabled.",
            section = hotkey,
            position = 3
    )
    default boolean hotkeyShowValues() { return false; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapTogglesOverlay",
            name = "Double-tap: toggle overlay",
            description = "When enabled, double-tap the hotkey to toggle the entire ground items overlay.",
            section = hotkey,
            position = 12
    )
    default boolean hotkeyDoubleTapTogglesOverlay() { return true; }
    @ConfigItem(
            keyName = "hotkeyDoubleTapDelay",
            name = "Double-tap delay",
            description = "Period within which to register a hotkey double-tap.",
            section = hotkey,
            position = 13
    )
    @Units(Units.MILLISECONDS)
    default int hotkeyDoubleTapDelay() { return 250; }
    @ConfigItem(
            keyName = "overlayStateIndicator",
            name = "Overlay state indicator",
            description = "Show a status icon when the overlay is disabled via hotkey.",
            section = hotkey,
            position = 20
    )
    default boolean hotkeyStateIndicator() { return true; }

    @ConfigSection(
            name = "Display settings",
            description = "Configure global display settings/overrides.",
            position = 2
    )
    String displayOverrides = "displayOverrides";
    @ConfigItem(
            keyName = "alwaysShowValue",
            name = "Show value",
            description = "Always show item value.",
            section = displayOverrides,
            position = 0
    )
    default boolean alwaysShowValue() { return false; }
    @ConfigItem(
            keyName = "valueDisplayType",
            name = "Value display",
            description = "Which value(s) to show.",
            section = displayOverrides,
            position = 1
    )
    default ValueDisplayType valueDisplayType() { return ValueDisplayType.HIGHEST; }
    @ConfigItem(
            keyName = "dualValueDisplayType",
            name = "Dual-value display",
            description = "How to compose the display of values when display type is set to either 'highest' or 'both'.",
            section = displayOverrides,
            position = 2
    )
    default DualValueDisplayType dualValueDisplay() { return DualValueDisplayType.COMPACT; }
    @ConfigItem(
            keyName = "alwaysShowDespawn",
            name = "Show despawn",
            description = "Always show item despawn timers.",
            section = displayOverrides,
            position = 11
    )
    default boolean alwaysShowDespawn() { return false; }
    @ConfigItem(
            keyName = "despawnTimerType",
            name = "Despawn type",
            description = "Type of despawn timer to render.",
            section = displayOverrides,
            position = 12
    )
    default DespawnTimerType despawnTimerType() { return DespawnTimerType.TICKS; }
    @ConfigItem(
            keyName = "despawnThreshold",
            name = "Despawn threshold",
            description = "Number of remaining ticks until despawn at which to show the despawn timer (0 to always show).",
            section = displayOverrides,
            position = 13
    )
    @Units(Units.TICKS)
    default int despawnThreshold() { return 0; }
    @ConfigItem(
            keyName = "textAccent",
            name = "Text accent",
            description = "Text accent type.",
            section = displayOverrides,
            position = 23
    )
    default TextAccent textAccent() { return TextAccent.USE_FILTER; }
    @ConfigItem(
            keyName = "highlightTiles",
            name = "Highlight tiles",
            description = "Always highlight tiles, regardless of filter config.",
            section = displayOverrides,
            position = 26
    )
    default boolean highlightTiles() { return false; }
    @ConfigItem(
            keyName = "collapseEntries",
            name = "Menu: collapse entries",
            description = "Collapse menu entries for multiples of unstacked items.",
            section = displayOverrides,
            position = 89
    )
    default boolean collapseEntries() { return true; }
    @ConfigItem(
            keyName = "deprioritizeHidden",
            name = "Menu: deprioritize hidden items",
            description = "Deprioritize menu entries for hidden items.",
            section = displayOverrides,
            position = 90
    )
    default boolean deprioritizeHidden() { return false; }
    @ConfigItem(
            keyName = "recolorHidden",
            name = "Menu: recolor hidden items",
            description = "Recolor menu entries for hidden items.",
            section = displayOverrides,
            position = 91
    )
    default boolean recolorHidden() { return false; }
    @ConfigItem(
            keyName = "hiddenColor",
            name = "Hidden color",
            description = "Color for hidden items in text overlay and menu entries.",
            section = displayOverrides,
            position = 92
    )
    default Color hiddenColor() { return Color.GRAY; }

    @ConfigItem(
            keyName = "overlayZOffset",
            name = "Overlay z-offset",
            description = "Adjusts the initial vertical offset of the text overlay.<br><br>" +
                    "This is the initial z-axis offset in 3D space. Each individual unit does not necessary correspond<br>" +
                    "to a full pixel, it will vary by camera perspective.",
            section = displayOverrides,
            position = 95
    )
    @Range(max = 32)
    default int overlayZOffset() { return 16; }
    @ConfigItem(
            keyName = "compactMode",
            name = "Compact mode",
            description = "Enable the \"compact\" overlay mode which renders icons instead of item names.<br>Certain display properties, such as the type of despawn timer, do not apply in compact mode.",
            section = displayOverrides,
            position = 100
    )
    default boolean compactMode() { return false; }
    @Range(min = 22, max = 32)
    @ConfigItem(
            keyName = "compactRenderSize",
            name = "Compact: icon height",
            description = "Icon size for compact item rendering. Specifically, height in pixels, although it will sometimes adjust it slightly to preserve aspect ratio.",
            section = displayOverrides,
            position = 101
    )
    default int compactRenderSize() { return 26; }
    @ConfigItem(
            keyName = "compactRenderRowLength",
            name = "Compact: row size",
            description = "How many items to render per row for compact items.",
            section = displayOverrides,
            position = 102
    )
    @Range(min = 1, max = 128)
    default int compactRenderRowLength() { return 4; }

    @ConfigSection(
            name = "Item lists",
            description = "Configure default lists of highlighted and hidden items. Values are case-insensitive, separated by comma. These lists are checked BEFORE the active filter.",
            position = 8
    )
    String itemLists = "itemLists";
    @ConfigItem(
            keyName = "_",
            name = "These lists take precedence over",
            description = "",
            section = itemLists,
            position = -3
    )
    void itemListsDisclaimer0();
    @ConfigItem(
            keyName = "_",
            name = "your selected loot filter.",
            description = "",
            section = itemLists,
            position = -2
    )
    void itemListsDisclaimer1();
    @ConfigItem(
            keyName = "highlightedItems",
            name = "Highlighted items",
            description = "Configure a list of items to highlight.",
            section = itemLists,
            position = 0
    )
    default String highlightedItems() { return ""; }
    @ConfigItem(
            keyName = "hiddenItems",
            name = "Hidden items",
            description = "Configure a list of items to hide.",
            section = itemLists,
            position = 1
    )
    default String hiddenItems() { return ""; }
    @ConfigItem(keyName = "highlightedItems", name = "", description = "")
    void setHighlightedItems(String key);
    @ConfigItem(keyName = "hiddenItems", name = "", description = "")
    void setHiddenItems(String key);

    @ConfigItem(
            keyName = "highlightColor",
            name = "Highlight color",
            description = "Configures the color for highlighted items.",
            section = itemLists,
            position = 2
    )
    @Alpha
    default Color highlightColor() { return Color.decode("#aa00ff"); }
    @ConfigItem(
            keyName = "highlightLootbeam",
            name = "Highlight lootbeam",
            description = "Configures whether highlighted items show a lootbeam.",
            section = itemLists,
            position = 3
    )
    default boolean highlightLootbeam() { return false; }
    @ConfigItem(
            keyName = "highlightNotify",
            name = "Highlight notification",
            description = "Configures whether highlighted items fire a system notification.",
            section = itemLists,
            position = 4
    )
    default boolean highlightNotify() { return false; }
    @ConfigItem(position = 5, section = itemLists,
            keyName = "hdBackgroundColor", name = "Background", description = "")
    @Alpha default Color higlightBackgroundColor() { return null; }
    @ConfigItem(position = 6, section = itemLists,
            keyName = "hdBorderColor", name = "Border", description = "")
    @Alpha default Color highlightBorderColor() { return Color.decode("#aa00ff"); }
    @ConfigItem(position = 7, section = itemLists,
            keyName = "hdLootbeamColor", name = "Lootbeam", description = "")
    @Alpha default Color highlightLootbeamColor() { return null; }
    @ConfigItem(position = 8, section = itemLists,
            keyName = "hdMenuTextColor", name = "Menu text", description = "")
    @Alpha default Color highlightMenuTextColor() { return null; }
    @ConfigItem(position = 9, section = itemLists, keyName = "hdMenuSort", name = "Menu sort priority", description = "")
    default int highlightMenuSort() { return 0; }
    @ConfigItem(position = 10, section = itemLists,
            keyName = "hdSound", name = "Sound", description = "Can be one of two types of values:<br><br>A number: play a game sound effect by ID<br>A string: play a custom audio file from .runelite/loot-filters/sounds, not all sound formats are supported")
    default String highlightSound() { return ""; }

    @ConfigSection(
            name = "Item value rules",
            description = "These have been removed. See the readme hover below.",
            position = 99
    )
    String itemValueRules = "itemValueRules";
    @ConfigItem(
            keyName = "itemValueRulesReadme",
            name = "README (hover)",
            description = "Unlike the ground items plugin, item value rules are managed by your active loot filter.<br>Both of the default filters shipped with the plugin - FilterScape and Joe's filter - include item value tiers with thresholds similar to that of the ground items plugin.<br>You can configure both the value thresholds and display settings for these on https://filterscape.xyz/.",
            section = itemValueRules,
            position = 0
    )
    void itemValueRulesReadme();

    @ConfigSection(
            name = "Advanced",
            description = "Don't use these unless you know what you're doing.",
            position = 999
    )
    String advanced = "advanced";
    @ConfigItem(
            keyName = "showAnalyzer",
            name = "Menu: add Analyzers",
            description = "Adds an \"Analyze\" right-click menu entry for each ground item that tells you how a given" +
                    " item was evaluated against your plugin config and loot filter. Useful for debugging.",
            section = advanced,
            position = 0
    )
    default boolean showAnalyzer() { return false; }
}

package com.lootfilters;

import net.runelite.client.input.MouseAdapter;

import javax.inject.Inject;
import java.awt.event.MouseEvent;

import static com.lootfilters.util.TextUtil.unsetCsv;
import static com.lootfilters.util.TextUtil.toggleCsv;
import static javax.swing.SwingUtilities.isLeftMouseButton;
import static javax.swing.SwingUtilities.isMiddleMouseButton;
import static javax.swing.SwingUtilities.isRightMouseButton;

public class LootFiltersMouseAdapter extends MouseAdapter {
    @Inject private LootFiltersPlugin plugin;

    @Override
    public MouseEvent mousePressed(MouseEvent e) {
        if (!plugin.isHotkeyActive()) {
            return e;
        } else if (plugin.getHoveredHide() != -1) {
            return handleToggleHide(e);
        } else if (plugin.getHoveredHighlight() != -1) {
            return handleToggleHighlight(e);
        } // else, hovered over the bounding box itself

        var hover = plugin.getHoveredItem();
        if (hover == -1) {
            return e;
        }

        var highlights = plugin.getConfig().highlightedItems();
        var hides = plugin.getConfig().hiddenItems();

        if (isLeftMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();

                plugin.getConfig().setHighlightedItems(toggleCsv(highlights, item));
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
            });
            e.consume();
        } else if (isRightMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();

                plugin.getConfig().setHiddenItems(toggleCsv(hides, item));
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
            });
            e.consume();
        } else if (isMiddleMouseButton(e)) {
            plugin.getClientThread().invoke(() -> {
                var item = plugin.getItemName(hover).toLowerCase();
                plugin.getConfig().setHighlightedItems(unsetCsv(highlights, item));
                plugin.getConfig().setHiddenItems(unsetCsv(hides, item));
            });
            e.consume();
        }
        return e;
    }

    private MouseEvent handleToggleHide(MouseEvent e) {
        plugin.getClientThread().invoke(() -> {
            var item = plugin.getItemName(plugin.getHoveredHide()).toLowerCase();
            plugin.getConfig().setHiddenItems(toggleCsv(plugin.getConfig().hiddenItems(), item));
            plugin.getConfig().setHighlightedItems(unsetCsv(plugin.getConfig().highlightedItems(), item));
        });
        e.consume();
        return e;
    }

    private MouseEvent handleToggleHighlight(MouseEvent e) {
        plugin.getClientThread().invoke(() -> {
            var item = plugin.getItemName(plugin.getHoveredHighlight()).toLowerCase();
            plugin.getConfig().setHighlightedItems(toggleCsv(plugin.getConfig().highlightedItems(), item));
            plugin.getConfig().setHiddenItems(unsetCsv(plugin.getConfig().hiddenItems(), item));
        });
        e.consume();
        return e;
    }
}

package com.lootfilters;

import com.lootfilters.model.PluginTileItem;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

public class TileItemIndex {
    private final Map<Tile, List<PluginTileItem>> itemIndex = new HashMap<>();
    private final Map<WorldPoint, Tile> pointIndex = new HashMap<>();

    public Set<Map.Entry<Tile, List<PluginTileItem>>> entrySet() {
        return itemIndex.entrySet();
    }

    public PluginTileItem findItem(TileItem item) {
        for (var entry : itemIndex.entrySet()) {
            for (var pItem : entry.getValue()) {
                if (pItem.equals(item)) {
                    return pItem;
                }
            }
        }
        return null;
    }

    public List<PluginTileItem> findItem(Tile tile, int id) {
        if (!itemIndex.containsKey(tile)) {
            return null;
        }

        return itemIndex.get(tile).stream()
                .filter(it -> it.getId() == id)
                .collect(Collectors.toList());
    }

    public List<PluginTileItem> findItem(WorldPoint point, int id) {
        return pointIndex.containsKey(point)
                ? findItem(pointIndex.get(point), id)
                : List.of();
    }

    public void put(Tile tile, PluginTileItem item) {
        if (!itemIndex.containsKey(tile)) {
            itemIndex.put(tile, new ArrayList<>());
        }
        itemIndex.get(tile).add(item);
        pointIndex.put(tile.getWorldLocation(), tile);
    }

    public void remove(Tile tile, PluginTileItem item) {
        if (!itemIndex.containsKey(tile)) {
            return; // what?
        }

        var items = itemIndex.get(tile);
        items.remove(item);
        if (items.isEmpty()) {
            itemIndex.remove(tile);
            pointIndex.remove(tile.getWorldLocation());
        }
    }

    public int pointIndexSize() {
        return pointIndex.size();
    }

    public void clear() {
        itemIndex.clear();
        pointIndex.clear();
    }
}

package com.lootfilters;

import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxPriority;

import javax.inject.Inject;
import java.awt.Color;

public class OverlayStateIndicator extends InfoBox {
    private final LootFiltersPlugin plugin;
    private final LootFiltersConfig config;

    @Inject
    public OverlayStateIndicator(LootFiltersPlugin plugin, LootFiltersConfig config) {
        super(Icons.OVERLAY_DISABLED, plugin);
        this.plugin = plugin;
        this.config = config;
        setPriority(InfoBoxPriority.LOW);
    }

    @Override
    public boolean render() {
        return config.hotkeyStateIndicator() && !plugin.isOverlayEnabled();
    }

    @Override
    public String getTooltip() {
        return "[Loot Filters]: The text overlay is currently <col=ff0000>disabled</col>.<br>" +
                "Tap <col=00ffff>" + config.hotkey() + "</col> once to re-enable it.<br><br>" +
                "<col=a0a0a0>You can disable this indicator in plugin config:<br>" +
                "Loot Filters -> Hotkey -> Overlay state indicator</col>";
    }

    @Override
    public String getText() {
        return "";
    }

    @Override
    public Color getTextColor() {
        return null;
    }
}

/*
 * Copyright (c) 2021, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.lootfilters;

import lombok.RequiredArgsConstructor;
import net.runelite.api.Animation;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.Model;
import net.runelite.api.ModelData;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;

import java.awt.Color;
import java.util.function.Function;

// copied verbatim (including copyright notice & disclaimer) from
// https://github.com/runelite/runelite/blob/master/runelite-client/src/main/java/net/runelite/client/plugins/grounditems/Lootbeam.java
//
// local modifications:
// remove() - wrapped setActive() call in clientThread.invoke(), where setActive must be called (throws otherwise)
class Lootbeam
{
    private final RuneLiteObject runeLiteObject;
    private final Client client;
    private final ClientThread clientThread;
    private Color color;
    private Style style;

    @RequiredArgsConstructor
    public enum Style
    {
        LIGHT(l -> l.client.loadModel(
                5809,
                new short[]{6371},
                new short[]{JagexColor.rgbToHSL(l.color.getRGB(), 1.0d)}
        ), anim(AnimationID.RAID_LIGHT_ANIMATION)),
        MODERN(l ->
        {
            ModelData md = l.client.loadModelData(43330);
            if (md == null)
            {
                return null;
            }

            short hsl = JagexColor.rgbToHSL(l.color.getRGB(), 1.0d);
            int hue = JagexColor.unpackHue(hsl);
            int sat = JagexColor.unpackSaturation(hsl);
            int lum = JagexColor.unpackLuminance(hsl);
            int satDelta = sat > 2 ? 1 : 0;

            return md.cloneColors()
                    .recolor((short) 26432, JagexColor.packHSL(hue, sat - satDelta, lum))
                    .recolor((short) 26584, JagexColor.packHSL(hue, sat, Math.min(lum + 24, JagexColor.LUMINANCE_MAX)))
                    .light(75 + ModelData.DEFAULT_AMBIENT, 1875 + ModelData.DEFAULT_CONTRAST,
                            ModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);
        }, anim(AnimationID.LOOTBEAM_ANIMATION)),
        ;

        private final Function<Lootbeam, Model> modelSupplier;
        private final Function<Lootbeam, Animation> animationSupplier;
    }

    private static Function<Lootbeam, Animation> anim(int id)
    {
        return b -> b.client.loadAnimation(id);
    }

    public Lootbeam(Client client, ClientThread clientThread, WorldPoint worldPoint, Color color, Style style)
    {
        this.client = client;
        this.clientThread = clientThread;
        runeLiteObject = client.createRuneLiteObject();

        this.color = color;
        this.style = style;
        update();
        runeLiteObject.setShouldLoop(true);

        LocalPoint lp = LocalPoint.fromWorld(client, worldPoint);
        runeLiteObject.setLocation(lp, client.getPlane());

        runeLiteObject.setActive(true);
    }

    public void setColor(Color color)
    {
        if (this.color != null && this.color.equals(color))
        {
            return;
        }

        this.color = color;
        update();
    }

    public void setStyle(Style style)
    {
        if (this.style == style)
        {
            return;
        }

        this.style = style;
        update();
    }

    private void update()
    {
        clientThread.invoke(() ->
        {
            Model model = style.modelSupplier.apply(this);
            if (model == null)
            {
                return false;
            }

            Animation anim = style.animationSupplier.apply(this);

            runeLiteObject.setAnimation(anim);
            runeLiteObject.setModel(model);
            return true;
        });
    }

    public void remove()
    {
        clientThread.invoke(() -> runeLiteObject.setActive(false));
    }

}
package com.lootfilters;

import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

public class Icons {
    public static final BufferedImage FOLDER;
    public static final BufferedImage OVERLAY_DISABLED;
    public static final BufferedImage PANEL_ICON;
    public static final BufferedImage CLIPBOARD_PASTE;
    public static final BufferedImage RELOAD;

    static {
        FOLDER = ImageUtil.loadImageResource(Icons.class, "/com/lootfilters/icons/folder_icon.png");
        OVERLAY_DISABLED = ImageUtil.loadImageResource(Icons.class, "/com/lootfilters/icons/overlay_disabled.png");
        PANEL_ICON = ImageUtil.loadImageResource(Icons.class, "/com/lootfilters/icons/panel.png");
        CLIPBOARD_PASTE = ImageUtil.loadImageResource(Icons.class, "/com/lootfilters/icons/paste_icon.png");
        RELOAD = ImageUtil.loadImageResource(Icons.class, "/com/lootfilters/icons/reload_icon.png");
    }

    private Icons() {
    }
}

package com.lootfilters;

import com.lootfilters.lang.CompileException;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameState;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Request;
import okhttp3.Response;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.MalformedInputException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

import static com.lootfilters.util.TextUtil.quote;

@Slf4j
@RequiredArgsConstructor
public class LootFilterManager {
    private final LootFiltersPlugin plugin;

    private final ExecutorService httpDispatcher = Executors.newSingleThreadExecutor();

    @Getter
    private final List<LootFilter> defaultFilters = new ArrayList<>();

    public List<LootFilter> loadFilters() {
        var filters = new ArrayList<LootFilter>();
        var files = Arrays.stream(LootFiltersPlugin.FILTER_DIRECTORY.listFiles())
                .filter(it -> !it.getName().startsWith("."))
                .collect(Collectors.toList());
        for (var file : files) {
            String src;
            try {
                src = Files.readString(file.toPath());
            } catch (MalformedInputException e) {
                plugin.addChatMessage("Failed to load filter from " + quote(file.getName()) + " because it is not a valid text file.");
                log.warn("read file {}", file.getName(), e);
                continue;
            } catch (Exception e) {
                plugin.addChatMessage("Failed to load filter from " + quote(file.getName()) + ": " + e.getMessage());
                log.warn("read file {}", file.getName(), e);
                continue;
            }

            LootFilter filter;
            try {
                var parsed = LootFilter.fromSourcesWithPreamble(Map.of(file.getName(), src))
                        .toBuilder()
                        .setFilename(file.getName())
                        .build();
                if (parsed.getName() == null || parsed.getName().isBlank()) {
                    parsed = parsed.toBuilder()
                            .setName(file.getName())
                            .build();
                }

                filter = parsed;
            } catch (Exception e) {
                plugin.addChatMessage("Failed to load filter from " + file.getName() + ": " + e.getMessage());
                log.warn("parse file {}", file.getName(), e);
                continue;
            }

            if (filters.stream().anyMatch(it -> it.getName().equals(filter.getName()))) {
                log.warn("Duplicate filters found with name {}. Only the first one was loaded.", quote(filter.getName()));
                continue;
            }

            filters.add(filter);
        }

        var hadErrors = filters.size() != files.size();
        if (plugin.getClient().getGameState() == GameState.LOGGED_IN || hadErrors) {
            plugin.addChatMessage(String.format("Loaded <col=%s>%d/%d</col> loot filters.",
                    hadErrors ? "FF0000" : "00FF00", filters.size(), files.size()));
        }
        return filters;
    }

    public void saveNewFilter(String name, String src) throws IOException {
        var sanitized = toFilename(name);
        var newFile = new File(LootFiltersPlugin.FILTER_DIRECTORY, toFilename(name));
        if (!newFile.createNewFile()) {
            throw new IOException("could not create file " + sanitized);
        }

        try (var writer = new FileWriter(newFile)) {
            writer.write(src);
        }
    }

    public void updateFilter(String filename, String src) throws IOException {
        var file = new File(LootFiltersPlugin.FILTER_DIRECTORY, filename);
        if (!file.exists()) {
            throw new IOException("attempt to update nonexistent file " + quote(filename));
        }

        try (var writer = new FileWriter(file)) {
            writer.write(src);
        }
    }

    public void fetchDefaultFilters(Runnable onComplete) {
        httpDispatcher.execute(() -> {
            for (var filter : DefaultFilter.all()) {
                fetchDefaultFilter(filter);
            }
            onComplete.run();
        });
    }

    public void fetchDefaultFilter(DefaultFilter filter) {
        var req = new Request.Builder()
                .get()
                .url(filter.getUrl())
                .addHeader("User-Agent", "github.com/riktenx/loot-filters")
                .build();
        try (var resp = plugin.getOkHttpClient().newCall(req).execute()) {
            var src = resp.body().string();
            var parsed = LootFilter.fromSource(src);
            defaultFilters.add(parsed);
        } catch (Exception e) { // there could be an issue w/ a filter, but just keep going and let other fetches complete
            log.warn("Failed to fetch default filter {}", filter.getName(), e);
        }
    }

    private static String toFilename(String filterName) {
        return filterName.replaceAll("[^a-zA-Z0-9._-]", "_") + ".rs2f";
    }
}
package com.lootfilters;

import lombok.Value;

import java.util.List;

@Value
public class DefaultFilter {
    String name, url;

    public static final DefaultFilter FILTERSCAPE = new DefaultFilter(
            "[default: FilterScape]",
            "https://raw.githubusercontent.com/riktenx/filterscape/refs/heads/main/filterscape.rs2f"
    );
    public static final DefaultFilter JOESFILTER = new DefaultFilter(
            "[default: Joe's filter]",
            "https://raw.githubusercontent.com/typical-whack/loot-filters-modules/refs/heads/main/default-filter.rs2f"
    );

    public static List<DefaultFilter> all() {
        return List.of(FILTERSCAPE, JOESFILTER);
    }
}

package com.lootfilters;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LootFiltersPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(LootFiltersPlugin.class);
		RuneLite.main(args);
	}
}
