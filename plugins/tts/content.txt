package com.ttsplugin.main;

import javax.inject.Inject;

import com.ttsplugin.enums.MessageType;

import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.Keybind;

public class KeyboardHandler {
    private static final int MENU_OPTION_HEIGHT = 15;
    private static final int MENU_EXTRA_TOP = 4;
    private static final int MENU_EXTRA_BOTTOM = 3;
    private static final int MENU_BORDERS_TOTAL = MENU_EXTRA_TOP + MENU_OPTION_HEIGHT + MENU_EXTRA_BOTTOM;

    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private TTSPlugin plugin;
    @Inject private TTSConfig config;

    public void handleHotkey(Keybind keybind) {
        // This solves an issue where sometimes client.getMenuEntries().last() was "Examine object-behind-widget" ¯\_(ツ)_/¯
        this.clientThread.invokeLater(() -> {
            MenuEntry[] entries = this.client.getMenuEntries();
            int idx = entries.length - 1;
            if (this.config.narrateQuantityHotkey() == keybind) {
                if (idx == -1)
                    return;
                MenuEntry hoveredEntry = entries[idx];
                Widget hoveredWidget = this.client.getWidget(hoveredEntry.getParam1());
                if (hoveredWidget != null) {
                    Widget childWidget = hoveredWidget.getChild(hoveredEntry.getParam0());
                    if (childWidget != null && childWidget.getItemId() != -1) {
                        plugin.processMessage(childWidget.getItemQuantity() + "", MessageType.ACCESSIBILITY);
                    } else if (hoveredWidget.getId() == ComponentID.INVENTORY_CONTAINER) {
                        int quantity = hoveredWidget.getItemQuantity();
                        plugin.processMessage(quantity + "", MessageType.ACCESSIBILITY);
                    }
                }
            } else if (this.config.narrateHotkey() == keybind) {
                if (this.client.isMenuOpen()) {
                    // Shamelessly stolen from contextual-cursor :)
                    final int menuTop;
                    final int menuHeight = (entries.length * MENU_OPTION_HEIGHT) + MENU_BORDERS_TOTAL;
                    if (menuHeight + this.plugin.getMenuOpenPoint().getY() > this.client.getCanvasHeight()) {
                        menuTop = this.client.getCanvasHeight() - menuHeight;
                    } else {
                        menuTop = this.plugin.getMenuOpenPoint().getY();
                    }

                    final int fromTop = Math.max((this.client.getMouseCanvasPosition().getY() - MENU_EXTRA_TOP) - menuTop, MENU_OPTION_HEIGHT);

                    idx = entries.length - (fromTop / MENU_OPTION_HEIGHT);
                }
                idx = Math.min(entries.length - 1, Math.max(0, idx));
                MenuEntry hoveredEntry = entries[idx];
                Widget hoveredWidget = this.client.getWidget(hoveredEntry.getParam1());
                if (hoveredWidget != null && hoveredWidget.getId() == WidgetUtil.packComponentId(553, 14)) { // Report reason
                    String msg = hoveredWidget.getChild(hoveredEntry.getParam0() + 1).getText() + " " + hoveredWidget.getChild(hoveredEntry.getParam0() + 2).getText();
                    plugin.processMessage(msg, MessageType.ACCESSIBILITY);
                } else if (hoveredWidget != null && hoveredWidget.getParent().getId() == WidgetUtil.packComponentId(553, 7)) { // Report add to ignore
                    plugin.processMessage(this.client.getWidget(553, 8).getText(), MessageType.ACCESSIBILITY);
                } else if (hoveredWidget != null && hoveredWidget.getParent() != null && hoveredWidget.getParent().getId() == ComponentID.BANK_PIN_CONTAINER) {
                    String number = hoveredWidget.getChild(1).getText();
                    plugin.processMessage(number, MessageType.ACCESSIBILITY);
                } else if (hoveredWidget != null && hoveredWidget.getId() == ComponentID.INVENTORY_CONTAINER) {
                    plugin.processMessage(hoveredEntry.getOption() + " " + hoveredEntry.getTarget(), MessageType.ACCESSIBILITY);
                } else {
                    if (this.client.isMenuOpen() || (hoveredEntry.getType() != MenuAction.WALK && hoveredEntry.getType() != MenuAction.CANCEL)) {
                        plugin.processMessage(hoveredEntry.getOption() + " " + hoveredEntry.getTarget(), MessageType.ACCESSIBILITY);
                    }
                }
            }
        });
    }
}

package com.ttsplugin.main;

import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.input.MouseListener;

import javax.inject.Inject;
import java.awt.event.MouseEvent;

public class MouseHandler implements MouseListener {
    @Inject private Client client;
    @Inject private ClientThread clientThread;
    @Inject private TTSPlugin plugin;

    @Override
    public MouseEvent mouseClicked(MouseEvent mouseEvent) {
        return mouseEvent;
    }

    @Override
    public MouseEvent mousePressed(MouseEvent mouseEvent) {
        return mouseEvent;
    }

    @Override
    public MouseEvent mouseReleased(MouseEvent mouseEvent) {
        return mouseEvent;
    }

    @Override
    public MouseEvent mouseEntered(MouseEvent mouseEvent) {
        return mouseEvent;
    }

    @Override
    public MouseEvent mouseExited(MouseEvent mouseEvent) {
        return mouseEvent;
    }

    @Override
    public MouseEvent mouseDragged(MouseEvent mouseEvent) {
        this.updateMousePoint();
        return mouseEvent;
    }

    @Override
    public MouseEvent mouseMoved(MouseEvent mouseEvent) {
        this.updateMousePoint();
        return mouseEvent;
    }

    private void updateMousePoint() {
        if (!client.isMenuOpen()) {
            // Invoke on client thread because this was the previous frames position
            clientThread.invokeLater(() -> {
                plugin.setMenuOpenPoint(client.getMouseCanvasPosition());
            });
        }
    }
}

package com.ttsplugin.main;

import lombok.Synchronized;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.Collection;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.stream.Collectors;

@Singleton
public class SettingsManager {
	private final Collection<String> specialPhrases = new CopyOnWriteArrayList<>();

	@Inject
	private TTSConfig config;

	void init() {
		setSpecialPhrases(config.denylistedWords());
	}

	void clear() {
		setSpecialPhrases("");
	}

	void onConfigChange(String key, String value) {
		if ("blacklistedWords".equals(key)) {
			setSpecialPhrases(value);
		}
	}

	public boolean passesAllowDenyList(String message) {
		final boolean mode = config.allowlist();
		for (String phrase : specialPhrases) {
			if (message.contains(phrase)) {
				return mode;
			}
		}
		return !mode;
	}

	@Synchronized
	private void setSpecialPhrases(String configValue) {
		specialPhrases.clear();
		specialPhrases.addAll(
				configValue.lines()
						.map(String::trim)
						.filter(s -> !s.isEmpty())
						.distinct()
						.collect(Collectors.toList())
		);
	}
}

package com.ttsplugin.main;

import com.ttsplugin.enums.Language;
import com.ttsplugin.enums.Voice;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;

@ConfigGroup("tts")
public interface TTSConfig extends Config {
	@ConfigSection(name = "General", description = "General settings", position = 20, closedByDefault = false)
	String generalSettings = "generalSettings";

	@ConfigItem(keyName = "ignoreSpam", name = "Ignore Spam", description = "Ignores messages that are sent multiple times by the same sender", position = 21, section = generalSettings)
	default boolean ignoreSpam() {
		return true;
	}

	@ConfigItem(keyName = "autoChat", name = "Autochat", description = "Speaks messages sent by auto chat", position = 22, section = generalSettings)
	default boolean autoChat() {
		return false;
	}

	@ConfigItem(keyName = "chatMessages", name = "Chat messages", description = "Speaks chat messages sent by players", position = 23, section = generalSettings)
	default boolean chatMessages() {
		return true;
	}

	@ConfigItem(keyName = "gameMessages", name = "Game messages", description = "Also speaks the game messages sent in chat <br> You can select the voice for this in the voice section", position = 24, section = generalSettings)
	default boolean gameMessages() {
		return false;
	}

	@ConfigItem(keyName = "notificationMessages", name = "Notification messages", description = "Speak notifications. \"RuneLite\" > \"Notification Settings\" > \"Game message notifications\" must be enabled.", position = 25, section = generalSettings)
	default boolean notificationMessages() {
		return false;
	}

	@ConfigItem(keyName = "dialogs", name = "Dialogs", description = "Applies text to speech for dialogs too <br> You can set the NPC voice by disabling random voice and setting the Dialog voice in voice settings", position = 26, section = generalSettings)
	default boolean dialogs() {
		return true;
	}

	@ConfigItem(keyName = "blacklistedWords", name = "Denylisted words", description = "Any message that contains these words will not be spoken <br> Write the word then press enter for new line <br> Each word needs to be longer than 1 character", position = 27, section = generalSettings)
	default String denylistedWords() {
		return "";
	}

	@ConfigItem(keyName = "whitelist", name = "Allowlist", description = "Invert denylist functionality to only speak messages that contain those words.", position = 28, section = generalSettings)
	default boolean allowlist() {
		return false;
	}

	@Range(min = 1, max = 60)
	@ConfigItem(keyName = "queueSeconds", name = "Queue seconds", description = "If a message is already playing how long to queue the next messages for in seconds <br> So it will play them after the current one finishes", position = 87, section = generalSettings)
	default double queueSeconds() {
		return 2.5;
	}

	@ConfigSection(name = "Voice", description = "Voice settings", position = 46, closedByDefault = false)
	String voiceSettings = "voiceSettings";

	@Range(min = -6, max = 10)
	@ConfigItem(keyName = "rate", name = "Speed", description = "How fast it speaks", position = 47, section = voiceSettings)
	default int rate() {
		return 1;
	}

	@Range(min = 1, max = 20)
	@ConfigItem(keyName = "volume", name = "Volume", description = "Volume for tts. Like how loud it speaks", position = 48, section = voiceSettings)
	default int volume() {
		return 15;
	}

	@ConfigItem(keyName = "distanceVolume", name = "Distance volume", description = "Chat messages sent by players further away will be quieter than people close to you <br> You can set how much the effect is in the advanced tab", position = 49, section = voiceSettings)
	default boolean distanceVolume() {
		return true;
	}

	@ConfigItem(keyName = "randomVoice", name = "Random voice", description = "Chooses a random voice from the selected language below for usernames. <br> The same username will always have the same voice for every message <br> Note: If you want to use one single voice then disable this and set the Voice setting", position = 50, section = voiceSettings)
	default boolean randomVoice() {
		return true;
	}

	@ConfigItem(keyName = "randomVoiceLanguage", name = "Random voice language", description = "The language for the above setting", position = 51, section = voiceSettings)
	default Language randomVoiceLanguage() {
		return Language.ENGLISH;
	}

	@ConfigItem(keyName = "gameMessageVoice", name = "Game message voice", description = "Voice for game messages if \"Game messages\" is enabled (in the general settings)", position = 52, section = voiceSettings)
	default Voice gameMessageVoice() {
		return Voice.ZIRA;
	}

	@ConfigItem(keyName = "notificationMessageVoice", name = "Notification message voice", description = "Voice for notification messages if \"Notification messages\" is enabled (in the general settings)", position = 53, section = voiceSettings)
	default Voice notificationMessageVoice() {
		return Voice.ZIRA;
	}

	@ConfigItem(keyName = "voice", name = "Voice", description = "Voice for tts <br> Note: This wont do anything if random voice is enabled", position = 54, section = voiceSettings)
	default Voice voice() {
		return Voice.HAZEL;
	}

	@ConfigItem(keyName = "dialogVoice", name = "Dialog voice", description = "Voice for dialogs if Random voice is disabled and Dialogs is enabled in general settings <br> This only applies to the NPC not you. The voice above applies to you", position = 55, section = voiceSettings)
	default Voice dialogVoice() {
		return Voice.GEORGE;
	}

	@ConfigItem(keyName = "useDialogVoiceWithRandom", name = "Use dialog voice with random voice on", description = "Speaks all dialogs with the dialog voice even if random voice is enabled", position = 56, section = voiceSettings)
	default boolean useDialogVoiceWithRandom() {
		return false;
	}

	@ConfigSection(name = "Accessibility", description = "Accessibility settings <br> These settings use the Game message voice set in the voice settings", position = 47, closedByDefault = true)
	String accessibilitySettings = "accessibilitySettings";

	@ConfigItem(keyName = "enableOnClick", name = "On Click", description = "Enables narrating on click", section = accessibilitySettings, position = 1)
	default boolean enableOnClick() {
		return false;
	}

	@ConfigItem(keyName = "narrateHotkey", name = "Narrate Hotkey", description = "The hotkey that triggers narration for what you're hovering over", section = accessibilitySettings, position = 2)
	default Keybind narrateHotkey() {
		return Keybind.NOT_SET;
	}

	@ConfigItem(keyName = "narrateQuantityHotkey", name = "Narrate Quantity Hotkey", description = "The hotkey that narrates the quantity of the hovered item", section = accessibilitySettings, position = 3)
	default Keybind narrateQuantityHotkey() {
		return Keybind.NOT_SET;
	}

	@ConfigSection(name = "Advanced", description = "Advanced settings", position = 85, closedByDefault = true)
	String advancedSettings = "advancedSettings";

	@Range(min = 5, max = 30)
	@ConfigItem(keyName = "distanceVolumeEffect", name = "Distance volume effect", description = "Controls how much more quiet the sound is when the sender is further away <br> Lower value = More quieter the further away the sender is", position = 86, section = advancedSettings)
	default int distanceVolumeEffect() {
		return 18;
	}

	@Range(min = 1, max = 15)
	@ConfigItem(keyName = "spamMessages", name = "Spam messages", description = "How many same messages from the same sender are allowed for the last 30 seconds <br> This applies for the Ignore Spam setting", position = 88, section = advancedSettings)
	default int spamMessages() {
		return 2;
	}

	@ConfigItem(keyName = "useVoiceForSelfWithRandom", name = "Use voice for self with random voice", description = "Uses the voice set in the Voice setting in voice section <br> As your voice even when random voice is enabled", position = 89, section = advancedSettings)
	default boolean useVoiceForSelfWithRandom() {
		return false;
	}
	
	@ConfigItem(keyName = "chatMessagesFriendsOnly", name = "Chat friends only", description = "Only speaks messages sent by your ingame friends if Chat messages setting is enabled", position = 90, section = advancedSettings)
	default boolean chatMessagesFriendsOnly() {
		return false;
	}

	@ConfigItem(keyName = "altTool", name = "AltTool", description = "", position = 91, section = advancedSettings)
	default String altTool() {
		return "";
	}
}

package com.ttsplugin.main;

import lombok.Value;
import net.runelite.api.Client;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.util.Text;

@Value
public class Dialog {
	String message;
	String sender;
	
	public Dialog(String message, String sender) {
		this.message = Text.sanitizeMultilineText(
			message
				// Replace hyphens with spaces. It has trouble processing utterances.
				.replace('-', ' ')
				// The synthesizer seems to treat an ellipsis as nothing. Replace it with a period.
				.replace("...", ". ")
		);

		this.sender = sender;
	}
	
	public static Dialog getCurrentDialog(Client client) {
		Widget playerText = client.getWidget(ComponentID.DIALOG_PLAYER_TEXT);
		if (isVisible(playerText)) {
			return new Dialog(playerText.getText(), client.getLocalPlayer().getName());
		}
		Widget npcText = client.getWidget(ComponentID.DIALOG_NPC_TEXT);
		if (isVisible(npcText)) {
			return new Dialog(npcText.getText(), client.getWidget(ComponentID.DIALOG_NPC_NAME).getText());
		}
		Widget dialogOptions = client.getWidget(ComponentID.DIALOG_OPTION_OPTIONS);
		if (isVisible(dialogOptions)) {
			return new Dialog(dialogOptions.getText(), "");
		}
		Widget levelSkill = client.getWidget(ComponentID.LEVEL_UP_SKILL);
		if (isVisible(levelSkill)) {
			return new Dialog(levelSkill.getText(), client.getWidget(ComponentID.LEVEL_UP_LEVEL).getText());
		}
		Widget catAge = client.getWidget(WidgetUtil.packComponentId(229, 1));
		if (isVisible(catAge)) {
			return new Dialog(catAge.getText(), "");
		}
		return null;
	}

	private static boolean isVisible(Widget widget) {
		return widget != null && !widget.isHidden();
	}
}

package com.ttsplugin.main;

import lombok.Value;

@Value
public class TTSMessage {
	String message;
	int voice, distance;
	long time;
}

package com.ttsplugin.main;

import java.util.ArrayList;
import java.util.List;

public class ConvertMessage {
	/**
	 * Changes the message, so it will be spelled better by the tts
	 * By changing shortens and stuff.
	 */
	public static String convert(String message) {
		String output = message;
		for (Convert convert : Convert.list) {
			output = convert.convert(output);
		}
		
		return output;
	}
	
	public static class Convert {
		public ConvertMode mode;
		public String target, replacement;
		public boolean caseSensitive;
		public static List<Convert> list = new ArrayList<>();
		
		static {
			new Convert(ConvertMode.REPLACE_WORD, "idk", "i don't know");
			new Convert(ConvertMode.REPLACE_WORD, "imo", "in my opinion");
			new Convert(ConvertMode.REPLACE_WORD, "afaik", "as far as i know");
			new Convert(ConvertMode.REPLACE_WORD, "rly", "really");
			new Convert(ConvertMode.REPLACE_WORD, "tbow", "twisted bow");
			new Convert(ConvertMode.REPLACE_WORD, "tbows", "twisted bows");
			new Convert(ConvertMode.REPLACE_WORD, "p2p", "pay to play");
			new Convert(ConvertMode.REPLACE_WORD, "f2p", "free to play");
			new Convert(ConvertMode.REPLACE_WORD, "p2p?", "pay to play?");
			new Convert(ConvertMode.REPLACE_WORD, "f2p?", "free to play?");
			new Convert(ConvertMode.REPLACE_WORD, "ty", "thank you");
			new Convert(ConvertMode.REPLACE_WORD, "tysm", "thank you so much");
			new Convert(ConvertMode.REPLACE_WORD, "tyvm", "thank you very much");
			new Convert(ConvertMode.REPLACE_WORD, "im", "i'm");
			new Convert(ConvertMode.REPLACE_WORD, "np", "no problem");
			new Convert(ConvertMode.REPLACE_WORD, "acc", "account");
			new Convert(ConvertMode.REPLACE_WORD, "irl", "in real life");
			new Convert(ConvertMode.REPLACE_WORD, "wtf", "what the fuck");
			new Convert(ConvertMode.REPLACE_WORD, "jk", "just kidding");
			new Convert(ConvertMode.REPLACE_WORD, "gl", "good luck");
			new Convert(ConvertMode.REPLACE_WORD, "pls", "please");
			new Convert(ConvertMode.REPLACE_WORD, "plz", "please");
			new Convert(ConvertMode.REPLACE_WORD, "osrs", "oldschool runescape");
			new Convert(ConvertMode.REPLACE_WORD, "rs3", "runescape 3");
			new Convert(ConvertMode.REPLACE_WORD, "lvl", "level");
			new Convert(ConvertMode.REPLACE_WORD, "lvl?", "level?");
			new Convert(ConvertMode.REPLACE_WORD, "ffs", "for fuck's sake");
			new Convert(ConvertMode.REPLACE_WORD, "af", "as fuck");
			new Convert(ConvertMode.REPLACE_WORD, "smh", "shake my head");
			new Convert(ConvertMode.REPLACE_WORD, "pls?", "please?");
			new Convert(ConvertMode.REPLACE_WORD, "plz?", "please?");
			new Convert(ConvertMode.REPLACE_WORD, "wby", "what about you");
			new Convert(ConvertMode.REPLACE_WORD, "brb", "be right back");
			new Convert(ConvertMode.REPLACE_WORD, "ik", "i know");
			new Convert(ConvertMode.REPLACE_WORD, "<lt>3", "heart");
			new Convert(ConvertMode.REPLACE_WORD, "fcape", "fire cape");
			new Convert(ConvertMode.REPLACE_WORD, "xp", "experience");
			new Convert(ConvertMode.REPLACE_WORD, "nty", "no thank you");
			
			new Convert(ConvertMode.REPLACE_TEXT, "dhide", "dragonhide");
			
			new Convert(ConvertMode.REPLACE_TEXT_AFTER_NUMBER_IN_WORD, "b", "billion");
			new Convert(ConvertMode.REPLACE_TEXT_AFTER_NUMBER_IN_WORD, "m", "million");
			new Convert(ConvertMode.REPLACE_TEXT_AFTER_NUMBER_IN_WORD, "b?", "billion?");
			new Convert(ConvertMode.REPLACE_TEXT_AFTER_NUMBER_IN_WORD, "m?", "million?");
		}
		
		public Convert(ConvertMode mode, String target, String replacement) {
			this.mode = mode;
			this.target = target;
			this.replacement = replacement;
			list.add(this);
		}

		public String convert(String input) {
			if (!this.caseSensitive) {
				input = input.toLowerCase();
			}
			
			switch(this.mode) {
				case REPLACE_TEXT:
					return input.replace(this.target, this.replacement);
				case REPLACE_WORD:
					input = input.replace(" " + this.target + " ", " " + this.replacement + " ");
					if (input.indexOf(this.target + " ") == 0) input = input.replace(this.target + " ", this.replacement + " ");
					if (input.indexOf(" " + this.target) + this.target.length() + 1 == input.length()) input = input.replace(" " + this.target, " " + this.replacement);
					if (input.equals(this.target)) input = input.replace(this.target, this.replacement);
					return input;
				case REPLACE_TEXT_AFTER_NUMBER_IN_WORD:
					String output = "";
					for (String word : input.split(" ")) {
						String test = word.replaceAll("\\d", "").replace(".", "");
						if (test.equals(this.target) && word.endsWith(this.target)) {
							word = word.replace(this.target, this.replacement);
						}
						
						output += word + " ";
					}
					
					if (!input.endsWith(" ")) output = output.substring(0, output.length() - 1);
					return output;
				default:
					return null;
			}
		}
	}
	
	public enum ConvertMode {
		REPLACE_TEXT,
		REPLACE_WORD,
		REPLACE_TEXT_AFTER_NUMBER_IN_WORD
	}
}

package com.ttsplugin.main;

import com.google.common.io.ByteStreams;
import com.google.inject.Provides;
import com.ttsplugin.enums.Gender;
import com.ttsplugin.enums.MessageType;
import com.ttsplugin.enums.Voice;
import com.ttsplugin.utils.Utils;
import jaco.mp3.player.MP3Player;
import lombok.Getter;
import lombok.Setter;
import lombok.Synchronized;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.NotificationFired;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.Text;
import org.apache.commons.text.StringEscapeUtils;

import javax.inject.Inject;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.Clip;
import javax.swing.*;
import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@PluginDescriptor(name = "Text to speech", description = "Text to speech for chat, dialog, menu options and notifications", tags = {"tts", "text", "voice", "chat", "dialog", "speak", "notification"})
public class TTSPlugin extends Plugin {	
	private final Map<String, List<Long>> spamHash = new HashMap<>();
	private final BlockingQueue<TTSMessage> queue = new LinkedBlockingQueue<>();
	private long lastProcess;
	private Dialog lastDialog;
	private final AtomicReference<Clip> currentClip = new AtomicReference<>();
	private final AtomicReference<Future<?>> queueTask = new AtomicReference<>();

	@Inject private Client client;
	@Inject private TTSConfig config;
	@Inject private ItemManager itemManager;
	@Inject private SettingsManager settingsManager;

	@Inject private ScheduledExecutorService executor;

	@Inject private KeyManager keyManager;
	@Inject private KeyboardHandler keyboardHandler;

	@Inject private MouseManager mouseManager;
	@Inject private MouseHandler mouseHandler;

	@Getter @Setter private Point menuOpenPoint;

	private volatile MP3Player jacoPlayer;

	private final HotkeyListener hotkeyListener = new HotkeyListener(() -> this.config.narrateHotkey()) {
		@Override
		public void hotkeyPressed() {
			keyboardHandler.handleHotkey(config.narrateHotkey());
		}
	};
	
	private final HotkeyListener quantityHotkeyListener = new HotkeyListener(() -> this.config.narrateQuantityHotkey()) {
		@Override
		public void hotkeyPressed() {
			keyboardHandler.handleHotkey(config.narrateQuantityHotkey());
		}
	};
	
	@Override
	protected void startUp() {
		settingsManager.init();

		// TODO: consolidate hotkey vs click message processing
		this.keyManager.registerKeyListener(this.hotkeyListener);
		this.keyManager.registerKeyListener(this.quantityHotkeyListener);
		this.mouseManager.registerMouseListener(this.mouseHandler);

		// New task for playing messages from queue. this will be terminated when the plugin is disabled
		Future<?> future = executor.scheduleWithFixedDelay(() -> {
			Clip clip = currentClip.get();
			if (clip != null) {
				if (clip.isRunning()) {
					return;
				} else {
					clip.close();
					if (!currentClip.compareAndSet(clip, null)) {
						return;
					}
				}
			}

			if (jacoPlayer != null) {
				if (jacoPlayer.isPlaying()) {
					return;
				} else {
					jacoPlayer.stop();
					jacoPlayer.getPlayList().clear();
				}
			}

			TTSMessage message;
			while ((message = queue.poll()) != null) {
				if ((double) Math.abs(message.getTime() - System.currentTimeMillis()) / (double) 1000 <= this.config.queueSeconds()) {
					play(message);
					break;
				}
			}
		}, 50, 50, TimeUnit.MILLISECONDS);
		queueTask.set(future);
	}

	@Override
	protected void shutDown() {
		settingsManager.clear();

		this.keyManager.unregisterKeyListener(this.hotkeyListener);
		this.keyManager.unregisterKeyListener(this.quantityHotkeyListener);
		this.mouseManager.unregisterMouseListener(this.mouseHandler);

		lastProcess = 0;
		lastDialog = null;
		menuOpenPoint = null;

		// Terminate queue task
		queue.clear();
		Future<?> task = queueTask.getAndSet(null);
		if (task != null)
			task.cancel(false);
		stopClip();
	}

	@Provides
	TTSConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(TTSConfig.class);
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if ("tts".equals(event.getGroup())) {
			settingsManager.onConfigChange(event.getKey(), event.getNewValue());
		}
	}

	@Subscribe
	public void onNotificationFired(NotificationFired event) {
		if (config.notificationMessages() && settingsManager.passesAllowDenyList(event.getMessage())) {
			processMessage(event.getMessage(), MessageType.NOTIFICATION);
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage event) {
		if (settingsManager.passesAllowDenyList(event.getMessage())) {
			processMessage(event.getMessage(), Text.sanitize(event.getName()), event.getType(), MessageType.CHAT);
		}
	}

	@Subscribe
	public void onGameTick(GameTick event) {
		if (config.dialogs()) {
			Dialog dialog = Dialog.getCurrentDialog(client);

			if (dialog != null && !dialog.equals(lastDialog) && settingsManager.passesAllowDenyList(dialog.getMessage())) {
				executor.execute(this::stopClip);
				processMessage(dialog.getMessage(), dialog.getSender(), MessageType.DIALOG);
			}
			
			lastDialog = dialog;
		}
	}

	@Subscribe
	public void onMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
		if (!this.config.enableOnClick())
			return;

		boolean blacklist = menuOptionClicked.getMenuAction() != MenuAction.WALK &&
			menuOptionClicked.getMenuAction() != MenuAction.CANCEL &&
			menuOptionClicked.getMenuAction() != MenuAction.WIDGET_CONTINUE;

		// If the menu is open, and you click on a menu option, say it
		// If the menu is not open (clicking on something), only say it if it is not Walk, Cancel, or a dialog option
		if (this.client.isMenuOpen() || blacklist) {
			this.sayMenuOptionClicked(menuOptionClicked);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event) {
		if (event.getGameState() == GameState.LOGIN_SCREEN) {
			queue.clear();
			executor.execute(this::stopClip);
		}
	}

	public void processMessage(String message, MessageType messageType) {
		processMessage(message, "", null, messageType);
	}
	
	public void processMessage(String message, String sender, MessageType messageType) {
		processMessage(message, sender, null, messageType);
	}

	//TODO: Fix this mess (more convenient way to check conditions)
	public void processMessage(String message, String sender, ChatMessageType type, MessageType messageType) {
		if (Math.abs(System.currentTimeMillis() - lastProcess) < 50) return;
		
		int voice = 0;
		int distance = 1;
		if (messageType == MessageType.CHAT) {
			if (type != ChatMessageType.PUBLICCHAT && type != ChatMessageType.AUTOTYPER && !config.gameMessages()) return;
			if (type == ChatMessageType.AUTOTYPER && !config.autoChat()) return;
			if (!sender.isEmpty() && ignoreSpam(message, sender) && config.ignoreSpam()) return;
			if (!config.chatMessages() && !sender.isEmpty()) return;
			Player player = getPlayerFromUsername(sender);
			if (config.chatMessagesFriendsOnly() && !player.isFriend()) return;

			voice = getVoice(sender, player == null ? Gender.UNKNOWN : Gender.get(player.getPlayerComposition().isFemale())).id;
			distance = player == null ? 0 : client.getLocalPlayer().getWorldLocation().distanceTo(player.getWorldLocation());
		} else if (messageType == MessageType.DIALOG) {
			if (sender.equals(client.getLocalPlayer().getName())) {
				voice = getVoice(sender, Gender.get(client.getLocalPlayer().getPlayerComposition().isFemale())).id;
			} else {
				if (config.randomVoice() && !config.useDialogVoiceWithRandom()) {
					voice = getVoice(sender, Gender.UNKNOWN).id;
				} else {
					voice = config.dialogVoice().id;
				}
			}
		} else if (messageType == MessageType.ACCESSIBILITY) {
			voice = config.gameMessageVoice().id;
		} else if (messageType == MessageType.NOTIFICATION) {
			voice = config.notificationMessageVoice().id;
		}
		
		lastProcess = System.currentTimeMillis();
		
		final int voice2 = voice;
		final int distance2 = distance;
		executor.execute(() -> {
			try {
				addToQueue(ConvertMessage.convert(message), voice2, distance2);
			} catch (Exception e) {
				log.warn("Failed to queue message", e);
			}
		});
	}
	
	/**
	 * Adds this message to the queue.
	 */
	public void addToQueue(String message, int voice, int distance) {
		this.queue.add(new TTSMessage(message, voice, distance, System.currentTimeMillis()));
	}
	
	/**
	 * Plays the text with the specified voice and distance
	 */
	private void play(TTSMessage message) {
		try {
			if (message.getVoice() == Voice.SUSAN.id && config.altTool().equals("Brian5")) {
				//Get tts code
				String text = Text.removeTags(message.getMessage());
				text = StringEscapeUtils.escapeHtml4(text);
				log.debug(text);

				String json = "[{\"voiceId\":\"Amazon British English (Brian)\",\"ssml\":\"<speak version=\\\"1.0\\\" xml:lang=\\\"en-GB\\\"><prosody volume='default' rate='medium' pitch='default'>" + text + "</prosody></speak>\"}]";
				URL url = new URL("https://support.readaloud.app/ttstool/createParts");

				HttpURLConnection connection = (HttpURLConnection) url.openConnection();
				connection.setRequestMethod("POST");
				connection.setRequestProperty("Content-Type", "application/json");
				connection.setDoOutput(true);

				try (OutputStream os = connection.getOutputStream()) {
					byte[] input = json.getBytes(StandardCharsets.UTF_8);
					os.write(input, 0, input.length);
				}

				BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
				String ttsCode = reader.readLine().replace("[\"", "").replace("\"]", "");
				reader.close();
				connection.disconnect();

				//Now get mp3 bytes
				byte[] bytes;
				try (InputStream stream = new URL("https://support.readaloud.app/ttstool/getParts?q=" + ttsCode).openConnection().getInputStream()) {
					bytes = ByteStreams.toByteArray(stream);
				}

				//Save mp3 to temp file, player can only play from file :(
				File file = new File(System.getProperty("java.io.tmpdir") + "/ttsbriantemp.mp3");
				file.delete();
				file.createNewFile();
				Files.write(file.toPath(), bytes);

				//Play mp3, file doesn't get deleted, but it gets overwritten every time so its no issue
				SwingUtilities.invokeLater(() -> {
					MP3Player mp3Player = getJacoPlayer();
					mp3Player.add(file);
					mp3Player.play();
				});

				return;
			}

			String request = "https://ttsplugin.com?m=" + URLEncoder.encode(message.getMessage(), "UTF-8") + "&r=" + config.rate() + "&v=" + message.getVoice();

			byte[] bytes;
			try (InputStream stream = new URL(request).openConnection().getInputStream()) {
				bytes = ByteStreams.toByteArray(stream);
			}

			try (AudioInputStream inputStream = AudioSystem.getAudioInputStream(new ByteArrayInputStream(bytes))) {
				Clip clip = AudioSystem.getClip();
				if (!currentClip.compareAndSet(null, clip)) {
					clip.close();
					return;
				}
				clip.open(inputStream);

				if (config.distanceVolume()) {
					Utils.setClipVolume((config.volume() / (float) 10) - ((float) message.getDistance() / (float) config.distanceVolumeEffect()), clip);
				} else {
					Utils.setClipVolume(config.volume() / (float) 10, clip);
				}

				clip.start();
			}
		} catch (Exception e) {
			stopClip();
			log.warn("Failed to play clip", e);
		}
	}

	private void stopClip() {
		Clip clip = currentClip.getAndSet(null);
		if (clip != null) {
			clip.stop();
			clip.close();
		}

		if (jacoPlayer != null && jacoPlayer.isPlaying()) {
			jacoPlayer.stop();
			jacoPlayer.getPlayList().clear();
		}
	}
	
	public Voice getVoice(String sender, Gender gender) {
		if (config.useVoiceForSelfWithRandom() && sender.equals(client.getLocalPlayer().getName())) {
			return config.voice();
		}
		
		if (config.gameMessages() && sender.isEmpty()) {
			return config.gameMessageVoice();
		}
		
		if (config.randomVoice()) {
			List<Voice> voices = new ArrayList<>();
			for (Voice voice : Voice.values()) {
				if (voice.language.equals(config.randomVoiceLanguage()) && (voice.gender == gender || gender == Gender.UNKNOWN)) {
					voices.add(voice);
				}
			}
			
			if (voices.isEmpty()) {
				return getVoice(sender, gender.reverse());
			}
			
			return voices.get(Math.abs(sender.hashCode()) % voices.size());
		}
		
		return config.voice();
	}
	
	@Synchronized
	public boolean ignoreSpam(String message, String sender) {
		long ms = System.currentTimeMillis();

		spamHash.values().removeIf(values -> {
			values.removeIf(value -> Math.abs(ms - value) > 30000);
			return values.isEmpty();
		});

		String key = message + sender;
		List<Long> list = spamHash.computeIfAbsent(key, k -> new ArrayList<>());
		list.add(ms);
		return list.size() > config.spamMessages();
	}
	
	private Player getPlayerFromUsername(String username) {
		for (Player player : client.getTopLevelWorldView().players()) {
			if (player != null && player.getName() != null && Text.sanitize(player.getName()).equals(username)) {
				return player;
			}
		}
		return null;
	}

	private void sayMenuOptionClicked(MenuOptionClicked menuOptionClicked) {
		String actionName = menuOptionClicked.getMenuOption();
		String itemName = menuOptionClicked.getMenuTarget();
		final Widget widget = this.client.getWidget(menuOptionClicked.getParam1());
		if (widget != null) {
			if (widget.getChildren() != null) {
				if (widget.getParent().getId() == ComponentID.BANK_PIN_CONTAINER) {
					actionName = widget.getChild(1).getText();
				} else if (widget.getId() == WidgetUtil.packComponentId(553, 14)) { // Report reason
					actionName = widget.getChild(menuOptionClicked.getParam0() + 1).getText() + " " +
						widget.getChild(menuOptionClicked.getParam0() + 2).getText();
					// In bank ui (maybe other things too like deposit boxes or things like that?)
				} else {
					Widget child = widget.getChild(menuOptionClicked.getParam0());
					if (child != null && child.getItemId() > -1) {
						itemName = this.itemManager.getItemComposition(child.getItemId()).getName();
					}
				}
			} else if (widget.getParent().getId() == WidgetUtil.packComponentId(553, 7)) { // Report add to ignore
				actionName = this.client.getWidget(553, 8).getText();
				// normal inventory
			} else if (widget.getId() == ComponentID.INVENTORY_CONTAINER) {
				int itemID = widget.getItemId();
				ItemComposition item = this.itemManager.getItemComposition(itemID);
				itemName = item.getName();
				// Fallback
			} else if (menuOptionClicked.getParam0() > -1) {
				itemName = widget.getChild(menuOptionClicked.getParam0()).getText();
			}
		}
		
		processMessage(actionName + " " + itemName, MessageType.ACCESSIBILITY);
	}

	private MP3Player getJacoPlayer() {
		MP3Player player = this.jacoPlayer;
		if (player == null) {
			synchronized (this) {
				player = this.jacoPlayer;
				if (player == null) {
					player = this.jacoPlayer = new MP3Player();
				}
			}
		}
		return player;
	}

}

package com.ttsplugin.utils;

import javax.sound.sampled.Clip;
import javax.sound.sampled.FloatControl;

public class Utils {
	public static String toLowerCaseWithFirstUppercase(String text) {
		String first = text.substring(0, 1).toUpperCase();
		return first + text.toLowerCase().substring(1);
	}
	
	public static void setClipVolume(float volume, Clip clip) {
	    FloatControl gainControl = (FloatControl)clip.getControl(FloatControl.Type.MASTER_GAIN);        
	    gainControl.setValue(20f * (float) Math.log10(volume));
	}
}

package com.ttsplugin.enums;

public enum MessageType {
	CHAT,
	DIALOG,
	ACCESSIBILITY,
	NOTIFICATION
}

package com.ttsplugin.enums;

public enum Language {
	ENGLISH,
	SPANISH,
	FINNISH,
	FRENCH,
	JAPANESE,
	SWEDISH,
	DUTCH,
	NORWEGIAN
}

package com.ttsplugin.enums;

import com.ttsplugin.utils.Utils;

public enum Voice {
	LUCAS(0, Language.ENGLISH, Gender.MALE),
	JAMES(1, Language.ENGLISH, Gender.MALE),
	LINDA(2, Language.ENGLISH, Gender.FEMALE),
	RICHARD(3, Language.ENGLISH, Gender.MALE),
	GEORGE(4, Language.ENGLISH, Gender.MALE),
	SUSAN(5, Language.ENGLISH, Gender.FEMALE),
	HEERA(6, Language.ENGLISH, Gender.FEMALE),
	RAVI(7, Language.ENGLISH, Gender.MALE),
	MARK(8, Language.ENGLISH, Gender.MALE),
	LAURA(9, Language.SPANISH, Gender.FEMALE),
	PABLO(10, Language.SPANISH, Gender.MALE),
	HEIDI(11, Language.FINNISH, Gender.FEMALE),
	JULIE(12, Language.FRENCH, Gender.FEMALE),
	PAUL(13, Language.FRENCH, Gender.MALE),
	AYUMI(14, Language.JAPANESE, Gender.FEMALE),
	ICHIRO(15, Language.JAPANESE, Gender.MALE),
	SAYAKA(16, Language.JAPANESE, Gender.FEMALE),
	JON(17, Language.NORWEGIAN, Gender.MALE),
	FRANK(18, Language.DUTCH, Gender.MALE),
	BENGT(19, Language.SWEDISH, Gender.MALE),
	HAZEL(20, Language.ENGLISH, Gender.FEMALE),
	EMMA(21, Language.ENGLISH, Gender.FEMALE),
	ZIRA(22, Language.ENGLISH, Gender.FEMALE),
	HELENA(23, Language.SPANISH, Gender.FEMALE),
	HORTENSE(24, Language.FRENCH, Gender.FEMALE),
	HARUKA(25, Language.JAPANESE, Gender.FEMALE);

	public int id;
	public Language language;
	public Gender gender;
	Voice(int id, Language language, Gender gender) {
		this.id = id;
		this.language = language;
		this.gender = gender;
	}
	
	@Override
	public String toString() {
		return Utils.toLowerCaseWithFirstUppercase(this.name()) + " " + Utils.toLowerCaseWithFirstUppercase(this.language.name()) + " " + Utils.toLowerCaseWithFirstUppercase(this.gender.name());
	}
}

package com.ttsplugin.enums;

public enum Gender {
	FEMALE,
	MALE,
	UNKNOWN;

	public Gender reverse() {
		return this == FEMALE ? MALE : FEMALE;
	}
	
	public static Gender get(boolean female) {
		return female ? FEMALE : MALE;
	}
}

package com.ttsplugin.main;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class PluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(TTSPlugin.class);
		RuneLite.main(args);
	}
}
