package com.LockedChunkOverlay;

public enum AllowedChunksSource
{
    REGION_LOCKER,
    MANUAL_INPUT,
    CHUNK_PICKER_SITE
}



package com.LockedChunkOverlay;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Font;
import java.awt.FontMetrics;
import net.runelite.client.ui.FontManager;

class BlackoutOverlay extends Overlay
{
	private final Client client;

	private int alpha = 0; // 0..255
	private boolean showText = false;

	@Inject
	BlackoutOverlay(Client client)
	{
		this.client = client;
		setPosition(OverlayPosition.DYNAMIC);
		// Draw beneath UI widgets but above the 3D scene and most overlays
		setLayer(OverlayLayer.UNDER_WIDGETS);
		setPriority(OverlayPriority.HIGHEST);
	}

	void setState(int alpha, boolean showText)
	{
		this.alpha = Math.max(0, Math.min(255, alpha));
		this.showText = showText;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		int x = client.getViewportXOffset();
		int y = client.getViewportYOffset();
		int w = client.getViewportWidth();
		int h = client.getViewportHeight();

		// Fallback in case viewport metrics are unavailable
		if (w <= 0 || h <= 0)
		{
			x = 0;
			y = 0;
			w = client.getCanvasWidth();
			h = client.getCanvasHeight();
		}
		Color prev = graphics.getColor();
		graphics.setColor(new Color(0, 0, 0, alpha));
		graphics.fillRect(x, y, w, h);

		if (showText)
		{
			// Draw centered yellow message with RuneScape font
			final String msg = "You have been eaten by a grue.";
			Font prevFont = graphics.getFont();
			Font base = FontManager.getRunescapeBoldFont().deriveFont(16f);
			graphics.setFont(base);
			FontMetrics fm0 = graphics.getFontMetrics();
			int w0 = Math.max(1, fm0.stringWidth(msg));
			int targetW = Math.max(1, (int)(w * 0.5));
			float size = 16f * ((float) targetW / (float) w0);
			Font rsFont = base.deriveFont(size);
			graphics.setFont(rsFont);
			graphics.setColor(Color.YELLOW);
			FontMetrics fm = graphics.getFontMetrics();
			int textW = fm.stringWidth(msg);
			int textH = fm.getAscent();
			int drawX = x + (w - textW) / 2;
			int drawY = y + (h + textH) / 2; // baseline-centered
			graphics.drawString(msg, drawX, drawY);

			graphics.setFont(prevFont);
		}

		graphics.setColor(prev);
		return null;
	}
}



package com.LockedChunkOverlay;

public enum DarknessLevel
{
	MODERATE,      // lighter tint
	DARK,          // medium
	VERY_DARK,     // current default (~71%)
	NEARLY_BLACK,  // very dark
	PITCH_BLACK;   // opaque
}



package com.LockedChunkOverlay;

import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.api.Perspective;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.BasicStroke;
import java.awt.geom.GeneralPath;
import java.awt.AlphaComposite;
import java.awt.Composite;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;

class ForbiddenTileOverlay extends Overlay
{
	private final Client client;
    private final LockedChunkOverlayConfig config;
	private final Set<WorldPoint> tiles = new HashSet<>();

	@Inject
    ForbiddenTileOverlay(Client client, LockedChunkOverlayConfig config)
	{
		this.client = client;
        this.config = config;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		setPriority(OverlayPriority.LOW);
	}

	void setTiles(Set<WorldPoint> worldPoints)
	{
		tiles.clear();
		if (worldPoints != null)
		{
			tiles.addAll(worldPoints);
		}
	}

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (tiles.isEmpty())
        {
            return null;
        }

        final int plane = client.getPlane();
        final Color prev = graphics.getColor();
        // Map config darkness level to alpha
        int alpha;
        DarknessLevel lvl = config.darknessLevel();
        switch (lvl)
        {
            case MODERATE: alpha = 110; break;      // ~43%
            case DARK: alpha = 140; break;          // ~55%
            case VERY_DARK: alpha = 180; break;     // ~71% (previous default)
            case NEARLY_BLACK: alpha = 220; break;  // ~86%
            case PITCH_BLACK: alpha = 255; break;   // 100%
            default: alpha = 180;
        }
        final Color fill = new Color(0, 0, 0, alpha);

        // Group tiles by region to build one path per region
        Map<Integer, List<WorldPoint>> byRegion = new HashMap<>();
        for (WorldPoint wp : tiles)
        {
            if (wp.getPlane() != plane)
            {
                continue;
            }
            byRegion.computeIfAbsent(wp.getRegionID(), k -> new ArrayList<>()).add(wp);
        }

        for (List<WorldPoint> group : byRegion.values())
        {
            GeneralPath fillPath = new GeneralPath();
            Map<String, int[]> borderEdges = new HashMap<>();
            boolean any = false;
            for (WorldPoint wp : group)
            {
                LocalPoint lp = LocalPoint.fromWorld(client, wp);
                if (lp == null)
                {
                    continue;
                }
                Polygon poly = Perspective.getCanvasTilePoly(client, lp);
                if (poly == null)
                {
                    continue;
                }
                // Append to region fill path
                fillPath.append(poly, false);
                any = true;

                // Count edges to find the outer border (edges seen once)
                for (int i = 0; i < poly.npoints; i++)
                {
                    int x1 = poly.xpoints[i];
                    int y1 = poly.ypoints[i];
                    int j = (i + 1) % poly.npoints;
                    int x2 = poly.xpoints[j];
                    int y2 = poly.ypoints[j];

                    // Normalize edge direction for key
                    String key;
                    if (x1 < x2 || (x1 == x2 && y1 <= y2))
                    {
                        key = x1 + "," + y1 + "|" + x2 + "," + y2;
                    }
                    else
                    {
                        key = x2 + "," + y2 + "|" + x1 + "," + y1;
                    }

                    int[] cnt = borderEdges.get(key);
                    if (cnt == null)
                    {
                        borderEdges.put(key, new int[]{1, x1, y1, x2, y2});
                    }
                    else
                    {
                        cnt[0]++;
                    }
                }
            }
            if (any)
            {
                if (((LockedChunkOverlayConfig)config).fillChunks())
                {
                    graphics.setColor(fill);
                    // Avoid a faint seam between adjacent forbidden regions by overwriting (no alpha blend)
                    Composite prevCompFill = graphics.getComposite();
                    Object prevAA = graphics.getRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING);
                    graphics.setComposite(AlphaComposite.Src);
                    graphics.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, java.awt.RenderingHints.VALUE_ANTIALIAS_OFF);
                    graphics.fill(fillPath);
                    graphics.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, prevAA);
                    graphics.setComposite(prevCompFill);
                }

                // Draw only edges that appear once (outer border), as simple line segments
                graphics.setColor(fill);
                BasicStroke prevStroke = (BasicStroke) graphics.getStroke();
                Composite prevComp = graphics.getComposite();
                graphics.setStroke(new BasicStroke(2f));
                // Avoid double-darkening by overwriting edge pixels instead of blending over the filled area
                graphics.setComposite(AlphaComposite.Src);
                for (int[] e : borderEdges.values())
                {
                    if (e[0] == 1)
                    {
                        graphics.drawLine(e[1], e[2], e[3], e[4]);
                    }
                }
                graphics.setStroke(prevStroke);
                graphics.setComposite(prevComp);
            }
        }

        graphics.setColor(prev);
        return null;
    }
}



package com.LockedChunkOverlay;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("LockedChunkOverlay")
public interface LockedChunkOverlayConfig extends Config
{
    @ConfigItem(
        keyName = "darknessLevel",
        name = "Overlay darkness",
        description = "How dark forbidden chunks are rendered",
        position = 0
    )
    default DarknessLevel darknessLevel()
    {
        return DarknessLevel.VERY_DARK;
    }

    @ConfigItem(
        keyName = "fillChunks",
        name = "Fill chunks",
        description = "Fill the interior of forbidden chunks (unchecked: borders only)",
        position = 1
    )
    default boolean fillChunks()
    {
        return true;
    }

    @ConfigItem(
        keyName = "screenFade",
        name = "Darken Screen",
        description = "Fade Screen to black when entering a locked chunk",
        position = 2
    )
    default boolean screenFade()
    {
        return false;
    }

	@ConfigItem(
		keyName = "opaqueAfterFive",
		name = "Completely cover screen",
        description = "Opaque overlay after 5 seconds in a locked chunk",
        position = 3
	)
	default boolean opaqueAfterFive()
	{
		return false;
	}

	@ConfigItem(
		keyName = "fadeWarningSound",
		name = "Warning Sound",
        description = "Play an awful warning sound while the screen is fading",
        position = 4
	)
	default boolean fadeWarningSound()
	{
		return false;
	}

	@ConfigItem(
		keyName = "debugText",
		name = "Debug Text",
        description = "Show debug text in chat/overlay",
        position = 5
	)
	default boolean debugText()
	{
		return false;
	}

    @ConfigItem(
        keyName = "allowedChunksSource",
        name = "Chunk Source",
        description = "Where to read allowed chunks from",
        position = 6
    )
    default AllowedChunksSource allowedChunksSource()
    {
        return AllowedChunksSource.MANUAL_INPUT;
    }

	@ConfigItem(
		keyName = "enableSiteAccess",
		name = "Enable site access",
		description = "Allow the plugin to make network requests to fetch chunk data from external servers",
		warning = "If you enable this, the plugin will make network requests and transmit your IP address to a 3rd-party server not controlled or verified by RuneLite developers.",
		position = 7
	)
	default boolean enableSiteAccess()
	{
		return false;
	}

	@ConfigItem(
		keyName = "manualChunksCsv",
		name = "Manual chunk IDs (comma separated)",
		description = "Manually specified allowed chunks",
		position = 8
	)
	default String manualChunksCsv()
	{
		return "";
	}

	@ConfigItem(
		keyName = "chunkpickerMapCode",
		name = "Chunk Picker map code",
		description = "Map code used by Chunk Picker",
		position = 9
	)
	default String chunkpickerMapCode()
	{
		return "";
	}

    // No toggle; fetching is controlled by dropdown selection
}

package com.LockedChunkOverlay;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.SoundEffectID;
import net.runelite.api.SoundEffectVolume;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.util.Text;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.callback.ClientThread;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.gameval.InterfaceID;

import okhttp3.Callback;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@PluginDescriptor(
	name = "Locked Chunk Overlay"
)
public class LockedChunkOverlayPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private LockedChunkOverlayConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private BlackoutOverlay blackoutOverlay;

	@Inject
	private ForbiddenTileOverlay forbiddenTileOverlay;

	@Inject
	private OkHttpClient okHttpClient;

	@Inject
	private ClientThread clientThread;

	private Integer lastRegionId;

	private boolean inLockedRegion;
	private long lockedEnterMs;
	private int lastRemainingSec = -1;
	private long lastGrueMs;
	private WorldPoint lastTile;
	private static final int RECT_WIDTH = 201; // tiles, perpendicular to direction
	private static final int RECT_LENGTH = 101; // tiles, along the direction
	private static final int WARNING_DISTANCE = 20; // tiles, warning distance from forbidden chunk border
    private long lastRegionsRefreshMs;
	private long lastChunkpickerFetchMs;
	private List<String> chunkpickerUnlocked = Collections.emptyList();

	@Override
	protected void startUp() throws Exception
	{
		log.info("Locked Chunk Overlay started!");
		overlayManager.add(forbiddenTileOverlay);
		overlayManager.add(blackoutOverlay);
		blackoutOverlay.setState(0, false);
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Locked Chunk Overlay stopped!");
		lastTile = null;
		overlayManager.remove(forbiddenTileOverlay);
		forbiddenTileOverlay.setTiles(Collections.emptySet());
		overlayManager.remove(blackoutOverlay);
		blackoutOverlay.setState(0, false);
	}

private void printForbidden(String dir, WorldPoint wp)
{
	int rid = wp.getRegionID();
    int baseX = (rid >> 8) << 6; // southwest corner x of 64x64 region
    int baseY = (rid & 255) << 6; // southwest corner y
    int maxX = baseX + 63;
    int maxY = baseY + 63;
    if (config.debugText())
    {
        client.addChatMessage(
            ChatMessageType.GAMEMESSAGE,
            "",
            dir + ": (" + wp.getX() + "," + wp.getY() + "," + wp.getPlane() + ") regionId=" + rid +
                " permitted=false border=(" + baseX + "," + baseY + ")-(" + maxX + "," + maxY + ")",
            null
        );
    }
}

@Subscribe
public void onWidgetClosed(WidgetClosed event)
{
    if (event.getGroupId() == InterfaceID.Worldmap.UNIVERSE) //not sure if this even does anything? but cant hurt
    {
        updateForbiddenRegionsFromLoadedRegions();
    }
}

@Subscribe
public void onConfigChanged(ConfigChanged event)
{
    if (!"LockedChunkOverlay".equals(event.getGroup()))
    {
        return;
    }
    if ("screenFade".equals(event.getKey()) && !config.screenFade())
    {
		// Make overlay transparent when darken screen is turned off
        blackoutOverlay.setState(0, false);
    }
		// Refresh when dropdown or manual CSV changes
		if ("allowedChunksSource".equals(event.getKey()) || "manualChunksCsv".equals(event.getKey()))
		{
			updateForbiddenRegionsFromLoadedRegions();
		}
		// Clear Chunk Picker cache and refresh when source/map code/site access changes
		if ("allowedChunksSource".equals(event.getKey()) || "chunkpickerMapCode".equals(event.getKey()) || "enableSiteAccess".equals(event.getKey()))
		{
			chunkpickerUnlocked = Collections.emptyList();
			updateForbiddenRegionsFromLoadedRegions();
		}
}

private void addLocalInstance(Set<WorldPoint> out, WorldPoint wp)
{
	var locals = WorldPoint.toLocalInstance(client, wp);
	if (locals == null || locals.isEmpty())
	{
		out.add(wp);
		return;
	}
	out.addAll(locals);
}

	private void fetchChunkpickerUnlocked(String mapCode)
	{
		String url = "https://chunkpicker.firebaseio.com/maps/" + mapCode + "/chunks/unlocked.json";
		Request request = new Request.Builder()
			.url(url)
			.get()
			.build();
		
		okHttpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(okhttp3.Call call, java.io.IOException e)
			{
				log.warn("Chunkpicker fetch failed", e);
			}

			@Override
			public void onResponse(okhttp3.Call call, Response response)
			{
				try
				{
					if (response.isSuccessful() && response.body() != null)
					{
						String body = response.body().string();
						if (body != null && !body.isEmpty())
						{
							// Update cache and refresh overlays on the client thread
							clientThread.invokeLater(() ->
							{
								chunkpickerUnlocked = parseChunkpickerKeys(body);
								updateForbiddenRegionsFromLoadedRegions();
							});
						}
					}
				}
				catch (Exception e)
				{
					log.warn("Chunkpicker response parsing failed", e);
				}
			}
		});
	}

    private static final Pattern JSON_KEY_PATTERN = Pattern.compile("\"(\\d{1,6})\"\\s*:\\s*\"\\d{1,6}\"");

	private static List<String> parseChunkpickerKeys(String json)
	{
		if (json == null || json.isEmpty())
		{
			return Collections.emptyList();
		}
		List<String> out = new ArrayList<>();
		Matcher m = JSON_KEY_PATTERN.matcher(json);
		while (m.find())
		{
			out.add(m.group(1));
		}
		return out;
	}

	private List<String> resolveUnlockedRegions()
	{
		AllowedChunksSource source = config.allowedChunksSource();
		switch (source)
		{
			case CHUNK_PICKER_SITE:
				// Only return cached data if site access is enabled
				if (!config.enableSiteAccess())
				{
					return Collections.emptyList();
				}
				return (chunkpickerUnlocked == null || chunkpickerUnlocked.isEmpty())
					? Collections.emptyList() : chunkpickerUnlocked;
			case MANUAL_INPUT:
			{
				String csv = config.manualChunksCsv();
				return (csv == null || csv.isEmpty()) ? Collections.emptyList() : Text.fromCSV(csv);
			}
			case REGION_LOCKER:
			default:
			{
				String csv = configManager.getConfiguration("regionlocker", "unlockedRegions");
				return (csv == null || csv.isEmpty()) ? Collections.emptyList() : Text.fromCSV(csv);
			}
		}
	}

private WorldPoint nearestForbiddenWithin5(int px, int py, int pl, int dx, int dy, boolean hasList, List<String> unlocked)
{
	for (int d = 0; d <= WARNING_DISTANCE; d++)
	{
		WorldPoint t = new WorldPoint(px + dx * d, py + dy * d, pl);
		// Tiles outside mainland are always permitted
		if (!isWithinMainland(t))
		{
			continue;
		}
		int rid = t.getRegionID();
		boolean permitted = !hasList || unlocked.contains(Integer.toString(rid));
		if (!permitted)
		{
			return t;
		}
	}
	return null;
}

private boolean isWithinMainland(WorldPoint wp)
{
    int x = wp.getX();
    int y = wp.getY();
    return x >= 1024 && x <= 3967 && y >= 2496 && y <= 4159;
}

private void updateForbiddenRegionsFromLoadedRegions()
{
	int[] regions = client.getMapRegions();
	if (regions == null)
	{
		forbiddenTileOverlay.setTiles(Collections.emptySet());
		return;
	}

	Player lp = client.getLocalPlayer();
	WorldPoint wp = lp != null ? lp.getWorldLocation() : null;
	if (wp == null)
	{
		forbiddenTileOverlay.setTiles(Collections.emptySet());
		return;
	}

	// Outside mainland: treat all permitted
	if (!isWithinMainland(wp))
	{
		forbiddenTileOverlay.setTiles(Collections.emptySet());
		return;
	}

	List<String> unlocked = resolveUnlockedRegions();
	// If Chunk Picker Site is selected but site access is disabled, treat all chunks as forbidden
	boolean hasList = !unlocked.isEmpty() || 
		(config.allowedChunksSource() == AllowedChunksSource.CHUNK_PICKER_SITE && !config.enableSiteAccess());

	Set<WorldPoint> tiles = new HashSet<>();
	int plane = client.getPlane();
	for (int rid : regions)
	{
		boolean permitted = !hasList || unlocked.contains(Integer.toString(rid));
		if (!permitted)
		{
			addRegionTiles(tiles, rid, plane);
		}
	}

	forbiddenTileOverlay.setTiles(tiles);
}

@Subscribe
public void onGameStateChanged(GameStateChanged gameStateChanged)
{
	if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
	{
		updateForbiddenRegionsFromLoadedRegions();
	}
}

private void addRectTiles(Set<WorldPoint> out, WorldPoint start, int dx, int dy, int length, int width)
{
	int halfW = Math.max(0, (width - 1) / 2);
	for (int i = 0; i < length; i++)
	{
		int baseX = start.getX() + dx * i;
		int baseY = start.getY() + dy * i;
		// Perpendicular vector
		int px = -dy;
		int py = dx;
		for (int j = -halfW; j <= halfW; j++)
		{
			WorldPoint p = new WorldPoint(baseX + px * j, baseY + py * j, start.getPlane());
			// Respect mainland rules: skip tiles outside mainland
			if (!isWithinMainland(p))
			{
				continue;
			}
			addLocalInstance(out, p);
		}
	}
}

private void addRectTilesOneSided(Set<WorldPoint> out, WorldPoint start, int dx, int dy, int length, int width, int sideX, int sideY)
{
    for (int i = 0; i < length; i++)
    {
        int baseX = start.getX() + dx * i;
        int baseY = start.getY() + dy * i;
        for (int j = 0; j < width; j++)
        {
            WorldPoint p = new WorldPoint(baseX + sideX * j, baseY + sideY * j, start.getPlane());
            if (!isWithinMainland(p))
            {
                continue;
            }
            addLocalInstance(out, p);
        }
    }
}

private void addRegionTiles(Set<WorldPoint> out, int regionId, int plane)
{
    int baseX = (regionId >> 8) << 6;
    int baseY = (regionId & 255) << 6;
    for (int rx = 0; rx < 64; rx++)
    {
        for (int ry = 0; ry < 64; ry++)
        {
            WorldPoint p = new WorldPoint(baseX + rx, baseY + ry, plane);
            if (!isWithinMainland(p))
            {
                continue;
            }
            addLocalInstance(out, p);
        }
    }
}

	@Subscribe
	public void onGameTick(GameTick tick)
	{
		int[] currentRegions = client.getMapRegions();
		if (currentRegions == null)
		{
			return;
		}

		Player localPlayer = client.getLocalPlayer();
		WorldPoint worldPoint = localPlayer != null ? localPlayer.getWorldLocation() : null;
		if (worldPoint == null)
		{
			return;
		}

        long now = System.currentTimeMillis();
        if (now - lastRegionsRefreshMs >= 10000L)
        {
            updateForbiddenRegionsFromLoadedRegions();
            lastRegionsRefreshMs = now;
        }

        // Fetch from Chunk Picker every 10s when selected, site access enabled, and map code present
        if (config.allowedChunksSource() == AllowedChunksSource.CHUNK_PICKER_SITE 
            && config.enableSiteAccess() 
            && now - lastChunkpickerFetchMs >= 10000L)
        {
            String code = config.chunkpickerMapCode();
            if (code != null && !code.isBlank())
            {
                fetchChunkpickerUnlocked(code.trim());
            }
            lastChunkpickerFetchMs = now;
        }

	int regionId = worldPoint.getRegionID();
	List<String> unlocked = resolveUnlockedRegions();
        // If Chunk Picker Site is selected but site access is disabled, treat all chunks as forbidden
        boolean hasList = (unlocked != null && !unlocked.isEmpty()) || 
		(config.allowedChunksSource() == AllowedChunksSource.CHUNK_PICKER_SITE && !config.enableSiteAccess());
        boolean isUnlocked = !hasList || unlocked.contains(Integer.toString(regionId));
        if (!isWithinMainland(worldPoint))
        {
            // Outside mainland bounds is always permitted
            isUnlocked = true;
        }

		// Movement-based shading removed; handled on GameStateChanged via loaded regions

		if (lastRegionId == null || !lastRegionId.equals(regionId))
		{
            if (config.debugText())
            {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "regionId=" + regionId + " unlocked=" + isUnlocked, null);
            }
			lastRegionId = regionId;
		}

		if (!isUnlocked)
		{
			if (!inLockedRegion)
			{
				inLockedRegion = true;
				lockedEnterMs = now;
				lastRemainingSec = -1;
				lastGrueMs = 0L;
			}

			long elapsedSec = Math.max(0L, (now - lockedEnterMs) / 1000L);
			int remainingSec = (int) Math.max(0L, 5L - elapsedSec);
			// Update blackout fade level each tick: 0s -> 255 alpha, 5s -> ~51 alpha
            int alpha = (int)Math.max(0, Math.min(255, (5 - remainingSec) * (255 / 5.0)));
            if (config.screenFade() && !config.opaqueAfterFive())
            {
                int cap = (int)(255 * 0.8);
                if (alpha > cap)
                {
                    alpha = cap;
                }
            }
            if (config.screenFade())
            {
                // Update overlay alpha based on countdown
                blackoutOverlay.setState(alpha, false);
            }
            else
            {
                // Keep overlay transparent if screenFade is disabled
                blackoutOverlay.setState(0, false);
            }
			if (remainingSec != lastRemainingSec)
			{
				int volume;
				switch (remainingSec)
				{
					case 5:
						volume = SoundEffectVolume.LOW;
						break;
					case 4:
						volume = SoundEffectVolume.MEDIUM_LOW;
						break;
					case 3:
						volume = SoundEffectVolume.MEDIUM_HIGH;
						break;
					default: // 2, 1, 0
						volume = SoundEffectVolume.HIGH;
				}
                if (remainingSec > 0 && config.fadeWarningSound())
                {
                    client.playSoundEffect(3482, volume);
                }
                if (config.screenFade() || config.fadeWarningSound())
                {
                    client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You arent supposed to be here, you will perish in " + remainingSec + " seconds.", null);
                }
				// Crossed a boundary; update last seen
				lastRemainingSec = remainingSec;
			}

            // While at 0 or below, handle overlay and grue warning
			if (remainingSec <= 0)
			{
                if (config.screenFade())
                {
                    int finalAlpha = config.opaqueAfterFive() ? 255 : (int)(255 * 0.8);
                    blackoutOverlay.setState(finalAlpha, config.opaqueAfterFive());
                }
                else
                {
                    // Keep overlay transparent if screenFade is disabled
                    blackoutOverlay.setState(0, false);
                }
                if (config.fadeWarningSound() && (now - lastGrueMs >= 200L))
				{
					client.playSoundEffect(3485, SoundEffectVolume.HIGH);
                    if (config.screenFade() || config.fadeWarningSound())
                    {
                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "You have been eaten by a grue.", null);
                    }
					lastGrueMs = now;
				}
                else if ((now - lastGrueMs >= 200L))
                {
                    // Keep lastGrueMs advancing to avoid rapid loop if sound disabled
                    lastGrueMs = now;
                }
			}
		}
		else if (inLockedRegion)
		{
			long durationSec = Math.max(0L, (now - lockedEnterMs) / 1000L);
            if (config.debugText())
            {
                client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", "Time in locked region: " + durationSec + "s", null);
            }
			inLockedRegion = false;
			lastRemainingSec = -1;
			// Make overlay transparent when leaving locked region
			blackoutOverlay.setState(0, false);
			lastGrueMs = 0L;
		}
		else
		{
			// Ensure overlay is transparent when not in locked region
			blackoutOverlay.setState(0, false);
		}
	}

	@Provides
    LockedChunkOverlayConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(LockedChunkOverlayConfig.class);
	}
}

package com.LockedChunkOverlay;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class LockedChunkOverlayPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(LockedChunkOverlayPlugin.class);
		RuneLite.main(args);
	}
}
