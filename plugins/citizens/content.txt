package com.magnaboy;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CitizensPluginTest {
	public static void main(String[] args) throws Exception {
		ExternalPluginManager.loadBuiltin(CitizensPlugin.class);
		RuneLite.main(args);
	}
}

package com.magnaboy;

public class StationaryCitizen extends Citizen<StationaryCitizen> {
	public StationaryCitizen(CitizensPlugin plugin) {
		super(plugin);
		entityType = EntityType.StationaryCitizen;
	}
}

package com.magnaboy;

public class Scenery extends Entity<Scenery> {

	public Scenery(CitizensPlugin plugin) {
		super(plugin);
		entityType = EntityType.Scenery;
	}
}

package com.magnaboy;

import static com.magnaboy.Util.getRandom;
import java.time.Instant;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

public class WanderingCitizen extends Citizen<WanderingCitizen> {
	public WorldArea boundingBox;
	public WorldPoint wanderRegionBL;
	public WorldPoint wanderRegionTR;
	private Instant lastWanderTime;

	public WanderingCitizen(CitizensPlugin plugin) {
		super(plugin);
		entityType = EntityType.WanderingCitizen;
		lastWanderTime = Instant.now().minusSeconds(6);
	}

	public WanderingCitizen setBoundingBox(WorldPoint bottomLeft, WorldPoint topRight) {
		this.boundingBox = Util.calculateBoundingBox(bottomLeft, topRight);
		setWorldLocation(getRandomInBoundingBox());
		return this;
	}

	public WanderingCitizen setWanderRegionBL(WorldPoint wp) {
		wanderRegionBL = wp;
		return this;
	}

	public WanderingCitizen setWanderRegionTR(WorldPoint wp) {
		wanderRegionTR = wp;
		return this;
	}

	private WorldPoint getRandomInBoundingBox() {
		WorldPoint randomPoint;
		do {
			final int x = getRandom(this.boundingBox.getX(), this.boundingBox.getX() + this.boundingBox.getWidth());
			final int y = getRandom(this.boundingBox.getY(), this.boundingBox.getY() + this.boundingBox.getHeight());
			randomPoint = new WorldPoint(x, y, getPlane());
		} while (randomPoint.equals(getWorldLocation()));

		return randomPoint;
	}

	public void wander() {
		if (getCurrentTarget() != null || Instant.now().isBefore(lastWanderTime.plusSeconds(6))) {
			return;
		}
		WorldPoint randomSpot = getRandomInBoundingBox();
		this.moveTo(randomSpot);
		lastWanderTime = Instant.now();
	}
}

package com.magnaboy;

import com.google.gson.Gson;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.Point;
import net.runelite.api.Tile;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.task.Schedule;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;

@Slf4j
@PluginDescriptor(name = "Citizens", description = "Adds citizens to help bring life to the world")
public class CitizensPlugin extends Plugin {
	public static HashMap<Integer, CitizenRegion> activeRegions = new HashMap<>();
	public static boolean shuttingDown;
	@Inject
	public Client client;
	@Inject
	public ClientThread clientThread;
	public CitizenPanel panel;

	public boolean IS_DEVELOPMENT = false;
	public boolean entitiesAreReady = false;
	@Inject
	public Gson gson;
	@Inject
	ChatMessageManager chatMessageManager;
	@Inject
	@Getter
	private CitizensConfig config;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private CitizensOverlay citizensOverlay;
	@Inject
	private ClientToolbar clientToolbar;
	private NavigationButton navButton;

	@Provides
	CitizensConfig getConfig(ConfigManager configManager) {
		return configManager.getConfig(CitizensConfig.class);
	}

	public boolean isReady() {
		return entitiesAreReady && client.getLocalPlayer() != null;
	}

	@Override
	protected void startUp() {
		CitizenRegion.init(this);

		panel = injector.getInstance(CitizenPanel.class);
		panel.init(this, citizensOverlay);
		overlayManager.add(citizensOverlay);

		// For now, the only thing in the panel is dev stuff
		if (IS_DEVELOPMENT) {
			// Add to sidebar
			final BufferedImage icon = ImageUtil.loadImageResource(CitizensPlugin.class, "/citizens_icon.png");
			navButton = NavigationButton.builder()
				.tooltip("Citizens")
				.icon(icon)
				.priority(7)
				.panel(panel)
				.build();
			clientToolbar.addNavigation(navButton);
		}

		if (isReady()) {
			checkRegions();
		}
		CitizenRegion.updateAllEntities();
		Util.initAnimationData(this);
	}

	@Override
	protected void shutDown() {
		cleanupAll();
		if (navButton != null) {
			clientToolbar.removeNavigation(navButton);
		}
	}

	void reload() {
		shutDown();
		startUp();
	}

	protected void despawnAll() {
		for (CitizenRegion r : activeRegions.values()) {
			CitizenRegion.forEachActiveEntity((Entity::despawn));
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		GameState newState = gameStateChanged.getGameState();

		if (newState == GameState.LOGGED_IN) {
			checkRegions();
		}

		if (newState == GameState.LOADING) {
			despawnAll();
			CitizenRegion.updateAllEntities();
		}
	}

	@Schedule(
		period = 3,
		unit = ChronoUnit.SECONDS,
		asynchronous = true
	)
	public void citizenBehaviourTick() {
		if (!isReady()) {
			return;
		}

		for (CitizenRegion r : activeRegions.values()) {
			r.runOncePerTimePeriod(10, 3, entity -> {
				if (entity instanceof WanderingCitizen) {
					((WanderingCitizen) entity).wander();
				}
			});

			r.runOncePerTimePeriod(60, 3, entity -> {
				if (entity.isCitizen() && entity.distanceToPlayer() < 15) {
					((Citizen) entity).sayRandomRemark();
				}
			});
		}

		panel.update();
	}

	@Subscribe
	public void onGameTick(GameTick tick) {
		CitizenRegion.updateAllEntities();
	}

	@Subscribe
	public void onClientTick(ClientTick ignored) {
		CitizenRegion.forEachActiveEntity((entity) -> {
			if (entity.isCitizen()) {
				((Citizen) entity).onClientTick();
			}
		});
	}

	@Subscribe
	public void onMenuOpened(MenuOpened ignored) {
		final int[] firstMenuIndex = {1};

		Point mousePos = client.getMouseCanvasPosition();
		final AtomicBoolean[] clickedCitizen = {new AtomicBoolean(false)};
		CitizenRegion.forEachActiveEntity(entity -> {
			if (entity.entityType == EntityType.Scenery && !IS_DEVELOPMENT) {
				return;
			}
			if ((entity.name != null && entity.examine != null) || IS_DEVELOPMENT) {
				SimplePolygon clickbox;
				try {
					clickbox = entity.getClickbox();
				} catch (IllegalStateException err) {
					return;
				}
				if (clickbox == null) {
					return;
				}
				boolean doesClickBoxContainMousePos = clickbox.contains(mousePos.getX(), mousePos.getY());
				if (doesClickBoxContainMousePos) {
					if (doesClickBoxContainMousePos) {
						client.createMenuEntry(firstMenuIndex[0])
							.setOption("Examine")
							.setTarget("<col=fffe00>" + entity.name + "</col>")
							.setType(MenuAction.RUNELITE)
							.setParam0(0)
							.setParam1(0)
							.setDeprioritized(true);
					}
				}

				// Select/Deselect
				if (IS_DEVELOPMENT && doesClickBoxContainMousePos) {
					String action = "Select";
					if (CitizenPanel.selectedEntity == entity) {
						action = "Deselect";
						clickedCitizen[0].set(true);
					}

					client.createMenuEntry(firstMenuIndex[0]++)
						.setOption(ColorUtil.wrapWithColorTag("Citizen Editor", Color.cyan))
						.setTarget(action + " <col=fffe00>" + entity.name + "</col>")
						.setType(MenuAction.RUNELITE)
						.setDeprioritized(true)
						.onClick(e -> {
							panel.setSelectedEntity(entity);
							panel.update();
						});
				}
			}
		});

		if (IS_DEVELOPMENT) {
			// Tile Selection
			final Tile selectedSceneTile = client.getSelectedSceneTile();
			final boolean same = CitizenPanel.selectedPosition != null && CitizenPanel.selectedPosition.equals(selectedSceneTile.getWorldLocation());
			final String action = same ? "Deselect" : "Select";
			client.createMenuEntry(firstMenuIndex[0]++)
				.setOption(ColorUtil.wrapWithColorTag("Citizen Editor", Color.cyan))
				.setTarget(action + " <col=fffe00>Tile</col>")
				.setType(MenuAction.RUNELITE)
				.setDeprioritized(true)
				.onClick(e -> {
					if (same) {
						CitizenPanel.selectedPosition = null;
					} else {
						CitizenPanel.selectedPosition = selectedSceneTile.getWorldLocation();
					}
					panel.update();
				});
			// Entity Deselect (from anywhere)
			if (CitizenPanel.selectedEntity != null && !clickedCitizen[0].get()) {
				String name = "Scenery Object";
				if (CitizenPanel.selectedEntity instanceof Citizen) {
					name = CitizenPanel.selectedEntity.name;
				}
				client.createMenuEntry(firstMenuIndex[0] - 1)
					.setOption(ColorUtil.wrapWithColorTag("Citizen Editor", Color.cyan))
					.setTarget("Deselect <col=fffe00>" + name + "</col>")
					.setType(MenuAction.RUNELITE)
					.setDeprioritized(true)
					.onClick(e -> {
						panel.setSelectedEntity(CitizenPanel.selectedEntity);
						panel.update();
					});
			}
		}
	}

	@Subscribe
	private void onMenuOptionClicked(MenuOptionClicked event) {
		if (!event.getMenuOption().equals("Examine")) {
			return;
		}
		CitizenRegion.forEachActiveEntity((entity) -> {
			if (event.getMenuTarget().equals("<col=fffe00>" + entity.name + "</col>")) {
				event.consume();
				String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.NORMAL)
					.append(entity.examine)
					.build();

				chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.NPC_EXAMINE)
					.runeLiteFormattedMessage(chatMessage)
					.timestamp((int) (System.currentTimeMillis() / 1000)).build());
			}
		});
	}

	private void checkRegions() {
		List<Integer> loaded = Arrays.stream(client.getMapRegions()).boxed().collect(Collectors.toList());
		// Check for newly loaded regions
		for (int i : loaded) {
			if (!activeRegions.containsKey(i)) {
				CitizenRegion region = CitizenRegion.loadRegion(i);
				if (region != null) {
					activeRegions.put(i, region);
				}
			}
		}
		entitiesAreReady = true;
	}

	private void cleanupAll() {
		shuttingDown = true;
		activeRegions.clear();
		despawnAll();
		overlayManager.remove(citizensOverlay);
		CitizenRegion.cleanUp();
		if (IS_DEVELOPMENT) {
			panel.cleanup();
			panel.update();
		}
		shuttingDown = false;
	}
}




package com.magnaboy;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;

@ConfigGroup("citizens")
public interface CitizensConfig extends Config {

}

package com.magnaboy;

import com.google.gson.reflect.TypeToken;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.Type;
import java.util.Map;
import java.util.Random;
import net.runelite.api.Perspective;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;

public final class Util {
	public final static int JAU_FULL_ROTATION = 2048;
	public final static int MAX_ENTITY_RENDER_DISTANCE = 25;
	private final static String animDataFilePath = "src/main/resources/animationData.json";
	public static Random rng = new Random();
	private static Map<String, AnimData> animData;

	public static void initAnimationData(CitizensPlugin plugin) {
		try (InputStream inputStream = plugin.getClass().getResourceAsStream("/animationData.json");
			 Reader reader = new BufferedReader(new InputStreamReader(inputStream))) {
			Type type = new TypeToken<Map<String, AnimData>>() {
			}.getType();
			animData = plugin.gson.fromJson(reader, type);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	public static int getRandom(int min, int max) {
		if (min == max) {
			return min;
		}
		return rng.nextInt((max - min) + 1) + min;
	}

	public static <T> T getRandomItem(T[] items) {
		int index = rng.nextInt(items.length);
		return items[index];
	}

	public static int getRandomItem(int[] items) {
		int index = rng.nextInt(items.length);
		return items[index];
	}

	public static int radToJau(double a) {
		int j = (int) Math.round(a / Perspective.UNIT);
		return j & 2047;
	}

	public static String worldPointToShortCoord(WorldPoint point) {
		return String.format("%d, %d, %d", point.getX(), point.getY(), point.getPlane());
	}

	public static String intArrayToString(int[] array) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < array.length; i++) {
			sb.append(array[i]);
			if (i < array.length - 1) {
				sb.append(",");
			}
		}
		return sb.toString().replaceAll("\\s+", "");
	}

	public static WorldArea calculateBoundingBox(WorldPoint bottomLeft, WorldPoint topRight) {
		int width = Math.abs(bottomLeft.getX() - topRight.getX());
		int height = Math.abs(bottomLeft.getY() - topRight.getY());
		String debugString = "BottomLeft[" + bottomLeft + "] TopRight[" + topRight + "] Width[" + width + "] Height["
			+ height + "]";

		if (bottomLeft.getX() > topRight.getX() || bottomLeft.getY() > topRight.getY()) {
			throw new IllegalArgumentException("BottomLeft must be to the bottom/left of topRight. " + debugString);
		}

		if (width <= 1 && height <= 1) {
			throw new IllegalArgumentException("The size of the bounding box must be greater than 1x1. " + debugString);
		}

		return new WorldArea(bottomLeft, width, height);
	}

	public static AnimData getAnimData(int id) {
		return animData.get(String.valueOf(id));
	}

	public static class AnimData {
		public int id;
		public int frameCount;
		public int clientTicks;
		public int realDurationMillis;
	}

}

package com.magnaboy;

import com.magnaboy.Util.AnimData;
import com.magnaboy.scripting.ActionType;
import com.magnaboy.scripting.ScriptAction;
import com.magnaboy.scripting.ScriptFile;
import com.magnaboy.scripting.ScriptLoader;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import net.runelite.api.coords.WorldPoint;

public class ScriptedCitizen extends Citizen<ScriptedCitizen> {
	public ScriptAction currentAction;
	public WorldPoint baseLocation;
	private ScriptFile script;
	private ExecutorService scriptExecutor;

	public ScriptedCitizen(CitizensPlugin plugin) {
		super(plugin);
		entityType = EntityType.ScriptedCitizen;
	}

	private void submitAction(ScriptAction action, Runnable task) {
		scriptExecutor.submit(() -> {
			this.currentAction = action;
			task.run();
		});
	}

	public ScriptedCitizen setScript(String scriptName) {
		if (scriptName == null || scriptName.isEmpty()) {
			return this;
		}
		this.script = ScriptLoader.loadScript(plugin, scriptName);
		return this;
	}

	@Override
	public boolean despawn() {
		if (scriptExecutor != null) {
			scriptExecutor.shutdownNow();
		}
		return super.despawn();
	}

	private void refreshExecutor() {
		if (!isActive()) {
			return;
		}
		if (scriptExecutor == null || scriptExecutor.isShutdown()) {
			scriptExecutor = Executors.newSingleThreadExecutor();
			// When script restarts, make them walk to start location?
			ScriptAction walkAction = new ScriptAction();
			walkAction.action = ActionType.WalkTo;
			walkAction.targetPosition = baseLocation;
			walkAction.secondsTilNextAction = 0f;
			addWalkAction(walkAction);
			buildRoutine();
		}
	}

	public boolean spawn() {
		boolean didSpawn = super.spawn();
		if (didSpawn) {
			refreshExecutor();
		}
		return didSpawn;
	}

	public void update() {
		refreshExecutor();
		super.update();
	}

	private void buildRoutine() {
		if (script == null) {
			return;
		}

		for (ScriptAction action : script.actions) {
			addAction(action);
		}
		scriptExecutor.submit(this::buildRoutine);
	}

	private void addAction(ScriptAction action) {
		if (action != null) {
			switch (action.action) {
				case Idle:
					submitAction(action, () -> {
						setWait(action.secondsTilNextAction);
					});
					break;
				case Say:
					addSayAction(action);
					break;
				case WalkTo:
					addWalkAction(action);
					break;
				case Animation:
					addAnimationAction(action);
					break;
				case FaceDirection:
					addRotateAction(action);
					break;
			}
		}
	}

	private void addSayAction(ScriptAction action) {
		submitAction(action, () -> {
			say(action.message);
			setWait(action.secondsTilNextAction);
		});
	}

	private void addWalkAction(ScriptAction action) {
		submitAction(action, () -> {
			int tilesToWalk = action.targetPosition.distanceTo2D(getWorldLocation()) + 1;
			sleep(tilesToWalk * 100);
			plugin.clientThread.invokeLater(() -> {
				moveTo(action.targetPosition, action.targetRotation == null ? null : action.targetRotation.getAngle(),
					false, false);
			});
			while (!getWorldLocation().equals(action.targetPosition) ||
				getAnimationID() != idleAnimationId.getId() ||
				WorldPoint.fromLocal(plugin.client, getLocalLocation()).distanceTo2D(getWorldLocation()) > 0) {
				sleep();
			}

			setWait(action.secondsTilNextAction);
		});
	}

	private void addRotateAction(ScriptAction action) {
		submitAction(action, () -> {
			rlObject.setOrientation(action.targetRotation.getAngle());
			sleep(50);
			while (rlObject.getOrientation() != action.targetRotation.getAngle()) {
				sleep();
				rlObject.setOrientation(action.targetRotation.getAngle());
			}
			setWait(action.secondsTilNextAction);
		});
	}

	private void sleep() {
		sleep(30);
	}

	private void sleep(int millis) {
		try {
			Thread.sleep(millis);
		} catch (InterruptedException e) {
			// Ignored, because this happens if the citizen despawns.
		}
	}

	private void addAnimationAction(ScriptAction action) {
		submitAction(action, () -> {
			AnimData animData = Util.getAnimData(action.animationId.getId());
			int loopCount = action.timesToLoop == null ? 1 : action.timesToLoop;
			for (int i = 0; i < loopCount; i++) {
				setAnimation(action.animationId.getId());
				try {
					Thread.sleep(animData.realDurationMillis);
				} catch (InterruptedException e) {
					// Ignored, because this happens if the citizen despawns.
				}
			}
			setAnimation(idleAnimationId.getId());
			setWait(action.secondsTilNextAction);
		});
	}

	private void setWait(Float seconds) {
		if (seconds == null) {
			return;
		}
		// We never want thread.sleep(0)
		seconds = Math.max(0.1f, seconds);
		try {
			Thread.sleep((long) (seconds * 1000L));
		} catch (InterruptedException e) {
			// Ignored, because this happens if the citizen despawns.
		}
	}
}

package com.magnaboy;

public enum EntityType {
	StationaryCitizen,
	WanderingCitizen,
	ScriptedCitizen,
	Scenery,
}

package com.magnaboy;

import static com.magnaboy.Util.getRandomItem;
import java.util.ArrayList;
import java.util.List;
import javax.annotation.Nullable;
import net.runelite.api.Client;
import net.runelite.api.CollisionDataFlag;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public class Citizen<T extends Citizen<T>> extends Entity<T> {
	private static final int[][] BLOCKING_DIRECTIONS_5x5 = {
		{CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST},
		{CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST},
		{CollisionDataFlag.BLOCK_MOVEMENT_EAST, CollisionDataFlag.BLOCK_MOVEMENT_EAST, 0, CollisionDataFlag.BLOCK_MOVEMENT_WEST, CollisionDataFlag.BLOCK_MOVEMENT_WEST},
		{CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST},
		{CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST}};
	private static final int[][] JAU_DIRECTIONS_5X5 = {
		{768, 768, 1024, 1280, 1280},
		{768, 768, 1024, 1280, 1280},
		{512, 512, 0, 1536, 1536},
		{256, 256, 0, 1792, 1792},
		{256, 256, 0, 1792, 1792}};
	private static final int CENTER_INDEX_5X5 = 2;
	public final CitizensPlugin plugin;
	private final Client client;
	private final List<Target> targetQueue = new ArrayList<>();
	@Nullable
	public String activeRemark = null;
	public String[] remarks;
	@Nullable
	public AnimationID movingAnimationId = AnimationID.HumanWalk;
	private int remarkTimer = 0;

	public Citizen(CitizensPlugin plugin) {
		super(plugin);
		this.plugin = plugin;
		this.client = plugin.client;
		this.rlObject = client.createRuneLiteObject();
	}

	public T setName(String name) {
		this.name = name;
		return (T) this;
	}

	public T setExamine(String examine) {
		this.examine = examine;
		return (T) this;
	}

	public T setRemarks(String[] remarks) {
		this.remarks = remarks;
		return (T) this;
	}

	public void validate() {
		super.validate();
		if (name == null) {
			throw new IllegalStateException(debugName() + " has no name.");
		}

		if (examine == null) {
			throw new IllegalStateException(debugName() + " has no examine.");
		}

		if (entityType == EntityType.WanderingCitizen) {
			WanderingCitizen casted = (WanderingCitizen) this;
			if (casted.boundingBox == null) {
				throw new IllegalStateException(debugName() + " has no boundingBox.");
			}
			if (casted.wanderRegionBL == null) {
				throw new IllegalStateException(debugName() + " has no wanderRegionBL.");
			}
			if (casted.wanderRegionTR == null) {
				throw new IllegalStateException(debugName() + " has no wanderRegionTR.");
			}
		}

		for (String remark : remarks) {
			if (remark.isEmpty()) {
				throw new IllegalStateException(debugName() + " has empty remark.");
			}
		}
	}

	public boolean despawn() {
		targetQueue.clear();
		this.activeRemark = null;
		this.remarkTimer = 0;
		return super.despawn();
	}

	public Target getCurrentTarget() {
		if (targetQueue.isEmpty()) {
			return null;
		}
		return targetQueue.get(0);
	}

	public WorldPoint getWorldLocation() {
		Target currentTarget = getCurrentTarget();
		if (currentTarget != null) {
			return currentTarget.worldDestinationPosition;
		}
		return super.getWorldLocation();
	}

	public void say(String message) {
		if (distanceToPlayer() > Util.MAX_ENTITY_RENDER_DISTANCE) {
			return;
		}
		this.activeRemark = message;
		this.remarkTimer = 120;
	}

	public void sayRandomRemark() {
		if (activeRemark == null && remarks != null && remarks.length > 0) {
			say(getRandomItem(remarks));
		}
	}

	public void moveTo(WorldPoint worldPosition) {
		moveTo(worldPosition, 0, false, false);
	}

	public void moveTo(WorldPoint worldPosition, Integer jauOrientation, boolean isInteracting, boolean isPoseAnimation) {
		if (entityType == EntityType.StationaryCitizen) {
			throw new IllegalStateException(debugName() + " is a stationary citizen and cannot move.");
		}

		LocalPoint localPosition = LocalPoint.fromWorld(client, worldPosition);

		if (localPosition == null) {
			return;
		}

		// use current position if nothing is in queue
		WorldPoint prevWorldPosition = getWorldLocation();

		int distance = prevWorldPosition.distanceTo(worldPosition);
		if (distance > 0 && distance <= 2) {
			int dx = worldPosition.getX() - prevWorldPosition.getX();
			int dy = worldPosition.getY() - prevWorldPosition.getY();

			if (distance == 1 && dx != 0 && dy != 0) // test for blockage along diagonal
			{
				// if blocked diagonally, go around in an L shape (2 options)
				int[][] colliders = client.getCollisionMaps()[worldPosition.getPlane()].getFlags();
				final int diagonalTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
				final int axisXTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 + dx] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 + dy][CENTER_INDEX_5X5] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				final int axisYTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 - dx] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;

				int diagonalFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY()];
				int axisXFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY() - dy];
				int axisYFlag = colliders[localPosition.getSceneX() - dx][localPosition.getSceneY()];

				if ((axisXFlag & axisXTest) != 0 || (axisYFlag & axisYTest) != 0 || (diagonalFlag & diagonalTest) != 0) {
					distance = 2;

					// if the priority East-West path is clear, we'll default to this direction
					if ((axisXFlag & axisXTest) == 0) {
						dy = 0;
					} else {
						dx = 0;
					}
				}
			} else if (distance == 2 && Math.abs(Math.abs(dy) - Math.abs(dx)) == 1) // test for blockage along knight-style moves
			{
				int[][] colliders = client.getCollisionMaps()[worldPosition.getPlane()].getFlags();
				final int diagonalTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
				final int axisXTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 + dx] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 + dy][CENTER_INDEX_5X5] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;
				final int axisYTest = BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5] | BLOCKING_DIRECTIONS_5x5[CENTER_INDEX_5X5][CENTER_INDEX_5X5 - dx] | CollisionDataFlag.BLOCK_MOVEMENT_FULL;

				int dxSign = Integer.signum(dx);
				int dySign = Integer.signum(dy);
				int diagonalFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY()];
				int axisXFlag = colliders[localPosition.getSceneX()][localPosition.getSceneY() - Integer.signum(dySign)];
				int axisYFlag = colliders[localPosition.getSceneX() - Integer.signum(dxSign)][localPosition.getSceneY()];

				// do we go straight or diagonal? test straight first and fall back to diagonal if it fails
				// priority is West > East > South > North > Southwest > Southeast > Northwest > Northeast
				if ((axisXFlag & axisXTest) == 0 && (axisYFlag & axisYTest) == 0 && (diagonalFlag & diagonalTest) == 0) {
					// the cardinal direction is clear (or we glitched), so let's go straight
					if (Math.abs(dx) == 2) {
						dx = dxSign;
						dy = 0;
					} else {
						dx = 0;
						dy = dySign;
					}
				} else {
					// we've established that the cardinal direction is blocked, so let's go along the diagonal
					if (Math.abs(dx) == 2) {
						dx = dxSign;
					} else {
						dy = dySign;
					}
				}
			}

			// handle rotation if we have no interacting target
			if (!isInteracting || jauOrientation == null) {
				// the actor needs to look in the direction being moved toward
				// the distance between these points may be up to 2
				dx = worldPosition.getX() - prevWorldPosition.getX();
				dy = worldPosition.getY() - prevWorldPosition.getY();
				jauOrientation = JAU_DIRECTIONS_5X5[CENTER_INDEX_5X5 - dy][CENTER_INDEX_5X5 + dx];
			}
		}

		Target newTarget = new Target();
		newTarget.worldDestinationPosition = worldPosition;
		newTarget.localDestinationPosition = localPosition;
		newTarget.jauDestinationOrientation = jauOrientation == null ? 0 : jauOrientation;
		newTarget.isInteracting = isInteracting;
		newTarget.isPoseAnimation = isPoseAnimation;
		targetQueue.add(newTarget);
	}

	public void onClientTick() {
		if (remarkTimer > 0) {
			remarkTimer--;
		}
		if (remarkTimer == 0) {
			this.activeRemark = null;
		}
		if (!rlObject.isActive()) {
			return;
		}

		if (entityType != EntityType.ScriptedCitizen && entityType != EntityType.WanderingCitizen) {
			return;
		}

		Target nextTarget = getCurrentTarget();
		if (nextTarget != null) {
			int targetPlane = nextTarget.worldDestinationPosition.getPlane();
			LocalPoint targetPosition = nextTarget.localDestinationPosition;
			int targetOrientation = nextTarget.jauDestinationOrientation;

			if (client.getPlane() != targetPlane || targetPosition == null || !targetPosition.isInScene() || targetOrientation < 0) {
				despawn();
				return;
			}

			LocalPoint currentPosition = getLocalLocation();
			int dx = targetPosition.getX() - currentPosition.getX();
			int dy = targetPosition.getY() - currentPosition.getY();

			if (dx != 0 || dy != 0) {
				if (rlObject.getAnimation().getId() != movingAnimationId.getId()) {
					setAnimation(movingAnimationId.getId());
				}

				int speed = 4;
				// only use the delta if it won't send up past the target
				if (Math.abs(dx) > speed) {
					dx = Integer.signum(dx) * speed;
				}
				if (Math.abs(dy) > speed) {
					dy = Integer.signum(dy) * speed;
				}

				LocalPoint newLocation = new LocalPoint(currentPosition.getX() + dx, currentPosition.getY() + dy);
				setLocation(newLocation);
			} else {
				targetQueue.remove(0);
			}

			LocalPoint localLoc = getLocalLocation();
			double intx = localLoc.getX() - targetPosition.getX();
			double inty = localLoc.getY() - targetPosition.getY();
			rotateObject(intx, inty);

			if (targetQueue.isEmpty()) {
				stopMoving();
			}
		}
	}

	public void stopMoving() {
		setAnimation(idleAnimationId.getId());
	}

	public static class Target {
		public WorldPoint worldDestinationPosition;
		public LocalPoint localDestinationPosition;
		public int jauDestinationOrientation;
		public boolean isPoseAnimation;
		public boolean isInteracting;

		@Override
		public String toString() {
			return "Target{" +
				"worldDestinationPosition=" + worldDestinationPosition +
				", localDestinationPosition=" + localDestinationPosition +
				", jauDestinationOrientation=" + jauDestinationOrientation +
				", isPoseAnimation=" + isPoseAnimation +
				", isInteracting=" + isInteracting +
				'}';
		}
	}
}

package com.magnaboy;

public class MergedObject {
	public int objectID;
	public int count90CCWRotations;
}

package com.magnaboy;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import static com.magnaboy.Util.getRandomItem;
import com.magnaboy.serialization.CitizenInfo;
import com.magnaboy.serialization.EntityInfo;
import com.magnaboy.serialization.SceneryInfo;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.Writer;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

public class CitizenRegion {

	public static final HashMap<Integer, CitizenRegion> regionCache = new HashMap<>();
	private static final float VALID_REGION_VERSION = 0.8f;
	private static final HashMap<Integer, CitizenRegion> dirtyRegions = new HashMap<>();
	private static final String REGIONDATA_DIRECTORY = new File("src/main/resources/RegionData/").getAbsolutePath();
	private static CitizensPlugin plugin;
	public transient HashMap<UUID, Entity> entities = new HashMap<>();

	public float version;
	public int regionId;
	public List<CitizenInfo> citizenRoster = new ArrayList<>();
	public List<SceneryInfo> sceneryRoster = new ArrayList<>();
	public transient ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);

	public static void init(CitizensPlugin p) {
		plugin = p;
	}

	public static CitizenRegion loadRegion(int regionId) {
		return loadRegion(regionId, false);
	}

	public static CitizenRegion loadRegion(int regionId, Boolean createIfNotExists) {
		if (regionCache.containsKey(regionId)) {
			return regionCache.get(regionId);
		}

		InputStream inputStream = plugin.getClass().getClassLoader().getResourceAsStream("RegionData/" + regionId + ".json");
		if (inputStream == null) {
			// No region file was found.
			// If in development, create one, save it and then try to load it.
			if (plugin.IS_DEVELOPMENT && createIfNotExists) {
				CitizenRegion region = new CitizenRegion();
				region.regionId = regionId;
				region.version = VALID_REGION_VERSION;
				try {
					region.saveRegion();
				} catch (IOException ex) {
					throw new RuntimeException(ex);
				}
				return loadRegion(regionId, false);
			}
			return null;
		}

		try (Reader reader = new BufferedReader(new InputStreamReader(inputStream))) {
			CitizenRegion region = plugin.gson.fromJson(reader, CitizenRegion.class);
			if (region == null) {
				return null;
			}
			if (region.version != VALID_REGION_VERSION) {
				return null;
			}
			for (CitizenInfo cInfo : region.citizenRoster) {
				Citizen citizen = loadCitizen(plugin, cInfo);
				if (citizen != null) {
					region.entities.put(citizen.uuid, citizen);
				}
			}
			for (SceneryInfo sInfo : region.sceneryRoster) {
				Scenery scenery = loadScenery(plugin, sInfo);
				region.entities.put(scenery.uuid, scenery);
			}
			if (plugin.IS_DEVELOPMENT) {
				region.entities.values().forEach(Entity::validate);
			}
			regionCache.put(regionId, region);
			return region;
		} catch (IOException e) {
			return null;
		}
	}

	public static void initCitizenInfo(Citizen citizen, CitizenInfo info) {
		// Citizen
		citizen.setName(info.name)
			.setExamine(info.examineText)
			.setRemarks(info.remarks);

		// Entity
		citizen.setModelIDs(info.modelIds)
			.setObjectToRemove(info.removedObject)
			.setModelRecolors(info.modelRecolorFind, info.modelRecolorReplace)
			.setIdleAnimation(info.idleAnimation)
			.setScale(info.scale)
			.setTranslate(info.translate)
			.setBaseOrientation(info.baseOrientation)
			.setUUID(info.uuid)
			.setWorldLocation(info.worldLocation)
			.setRegion(info.regionId);
	}

	public static Citizen loadCitizen(CitizensPlugin plugin, CitizenInfo info) {
		Citizen citizen;

		switch (info.entityType) {
			case WanderingCitizen:
				citizen = loadWanderingCitizen(plugin, info);
				break;
			case ScriptedCitizen:
				citizen = loadScriptedCitizen(plugin, info);
				break;
			default:
				citizen = loadStationaryCitizen(plugin, info);
				break;
		}

		if (info.mergedObjects != null) {
			info.mergedObjects.forEach(citizen::addMergedObject);
		}

		if (info.moveAnimation != null) {
			citizen.movingAnimationId = info.moveAnimation;
		}

		return citizen;
	}

	private static StationaryCitizen loadStationaryCitizen(CitizensPlugin plugin, CitizenInfo info) {
		info.entityType = EntityType.StationaryCitizen;
		StationaryCitizen citizen = new StationaryCitizen(plugin);
		initCitizenInfo(citizen, info);
		citizen.setWorldLocation(info.worldLocation);
		return citizen;
	}

	private static WanderingCitizen loadWanderingCitizen(CitizensPlugin plugin, CitizenInfo info) {
		info.entityType = EntityType.WanderingCitizen;
		WanderingCitizen citizen = new WanderingCitizen(plugin);
		initCitizenInfo(citizen, info);
		citizen.setWanderRegionBL(info.wanderBoxBL)
			.setWanderRegionTR(info.wanderBoxTR)
			.setWorldLocation(info.worldLocation)
			.setBoundingBox(info.wanderBoxBL, info.wanderBoxTR)
			.setBaseOrientation(getRandomItem(new CardinalDirection[]{CardinalDirection.North, CardinalDirection.South, CardinalDirection.East, CardinalDirection.West}));
		return citizen;
	}

	private static ScriptedCitizen loadScriptedCitizen(CitizensPlugin plugin, CitizenInfo info) {
		info.entityType = EntityType.ScriptedCitizen;
		ScriptedCitizen citizen = new ScriptedCitizen(plugin);
		initCitizenInfo(citizen, info);
		citizen.setWorldLocation(info.worldLocation)
			.setScript(info.startScript);

		citizen.baseLocation = info.worldLocation;
		return citizen;
	}

	public static Scenery loadScenery(CitizensPlugin plugin, SceneryInfo info) {
		Scenery scenery = new Scenery(plugin).setModelIDs(info.modelIds)
			.setModelRecolors(info.modelRecolorFind, info.modelRecolorReplace)
			.setIdleAnimation(info.idleAnimation)
			.setScale(info.scale)
			.setTranslate(info.translate)
			.setBaseOrientation(info.baseOrientation)
			.setUUID(info.uuid)
			.setWorldLocation(info.worldLocation)
			.setRegion(info.regionId);

		if (info.mergedObjects != null) {
			info.mergedObjects.forEach(scenery::addMergedObject);
		}

		return scenery;
	}

	public static void forEachActiveEntity(Consumer<Entity> function) {
		for (CitizenRegion r : regionCache.values()) {
			if (r != null) {
				for (Entity e : r.entities.values()) {
					if (e != null && e.distanceToPlayer() <= Util.MAX_ENTITY_RENDER_DISTANCE) {
						function.accept(e);
					}
				}
			}
		}
	}

	public static void forEachEntity(Consumer<Entity> function) {
		regionCache.forEach((regionId, r) -> {
			if (r != null) {
				r.entities.forEach((id, e) -> {
					if (e != null) {
						function.accept(e);
					}
				});
			}
		});
	}

	public static void cleanUp() {
		forEachEntity(Entity::despawn);

		for (CitizenRegion r : regionCache.values()) {
			r.citizenRoster.clear();
			r.sceneryRoster.clear();
			r.entities.clear();
		}
		regionCache.clear();
		dirtyRegions.clear();
	}

	// DEVELOPMENT SECTION
	public static Citizen spawnCitizenFromPanel(CitizenInfo info) {
		Citizen citizen = loadCitizen(plugin, info);
		CitizenRegion region = loadRegion(info.regionId, true);
		region.entities.put(info.uuid, citizen);
		region.citizenRoster.add(info);
		dirtyRegion(region);
		updateAllEntities();
		return citizen;
	}

	public static Scenery spawnSceneryFromPanel(SceneryInfo info) {
		Scenery scenery = loadScenery(plugin, info);
		CitizenRegion region = loadRegion(info.regionId, true);
		region.entities.put(info.uuid, scenery);
		region.sceneryRoster.add(info);
		dirtyRegion(region);
		updateAllEntities();
		return scenery;
	}

	public static void updateEntity(EntityInfo info) {
		if (info.entityType == EntityType.Scenery) {
			CitizenRegion region = regionCache.get(info.regionId);
			Entity e = region.entities.get(info.uuid);
			Scenery updated = loadScenery(plugin, (SceneryInfo) info);

			addEntityToRegion(updated, info);
			removeEntityFromRegion(e);
		} else {
			CitizenRegion region = regionCache.get(info.regionId);
			Entity e = region.entities.get(info.uuid);
			Citizen updated = loadCitizen(plugin, (CitizenInfo) info);

			addEntityToRegion(updated, info);
			removeEntityFromRegion(e);
		}
	}

	public static void dirtyRegion(CitizenRegion region) {
		dirtyRegions.put(region.regionId, region);
	}

	public static void clearDirtyRegions() {
		dirtyRegions.clear();
	}

	public static void addEntityToRegion(Entity e, EntityInfo info) {
		CitizenRegion region = regionCache.get(e.regionId);
		region.entities.put(e.uuid, e);
		if (info instanceof CitizenInfo) {
			region.citizenRoster.add((CitizenInfo) info);
		}
		if (info instanceof SceneryInfo) {
			region.sceneryRoster.add((SceneryInfo) info);
		}
	}

	private static void removeEntityFromRegion(Citizen citizen, CitizenRegion region) {
		CitizenInfo info = region.citizenRoster.stream()
			.filter(c -> c.uuid == citizen.uuid)
			.findFirst()
			.orElse(null);
		region.citizenRoster.remove(info);
	}

	private static void removeEntityFromRegion(Scenery scenery, CitizenRegion region) {
		SceneryInfo info = region.sceneryRoster.stream()
			.filter(c -> c.uuid == scenery.uuid)
			.findFirst()
			.orElse(null);
		region.sceneryRoster.remove(info);
	}

	public static void removeEntityFromRegion(Entity e) {
		CitizenRegion region = regionCache.get(e.regionId);
		if (e instanceof Citizen) {
			removeEntityFromRegion((Citizen) e, region);
		}
		if (e instanceof Scenery) {
			removeEntityFromRegion((Scenery) e, region);
		}

		region.entities.remove(e.uuid);
		e.despawn();
		dirtyRegion(region);
	}

	public static int dirtyRegionCount() {
		return dirtyRegions.size();
	}

	public static void saveDirtyRegions() {
		for (Map.Entry<Integer, CitizenRegion> region : dirtyRegions.entrySet()) {
			try {
				region.getValue().saveRegion();
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		}
		clearDirtyRegions();
	}

	public static void updateAllEntities() {
		for (CitizenRegion region : regionCache.values()) {
			region.updateEntities();
		}
		if (plugin.IS_DEVELOPMENT) {
			plugin.panel.update();
		}
	}

	public void saveRegion() throws IOException {
		try {
			Path path = Paths.get(REGIONDATA_DIRECTORY, regionId + ".json");
			Writer wr = new BufferedWriter(new FileWriter(path.toString()));
			GsonBuilder gb = plugin.gson.newBuilder();
			gb.setPrettyPrinting();
			Gson gson = gb.create();
			gson.toJson(this, wr);
			wr.flush();
			wr.close();
		} catch (IOException e) {
			throw new IOException(e);
		}
	}

	public void updateEntities() {
		plugin.clientThread.invokeLater(() -> {
			entities.values().forEach(Entity::update);
		});
	}

	public void runOncePerTimePeriod(int timePeriodSeconds, int callIntervalSeconds, Consumer<Entity> callback) {
		double chance = (double) callIntervalSeconds / timePeriodSeconds;

		List<Entity> entityList = new ArrayList<>(entities.values());

		for (Entity entity : entityList) {
			if (!entity.isActive()) {
				continue;
			}
			if (Math.random() < chance) {
				int delayMs = (Util.getRandom(0, (callIntervalSeconds / 2) * 1000));
				executorService.schedule(() -> callback.accept(entity), delayMs, TimeUnit.MILLISECONDS);
			}
		}
	}
}

package com.magnaboy.scripting;

import com.magnaboy.AnimationID;
import com.magnaboy.CardinalDirection;
import net.runelite.api.coords.WorldPoint;

public class ScriptAction {

	public ActionType action;
	public float secondsTilNextAction;

	// 'Parameters'
	public Integer timesToLoop;
	public WorldPoint targetPosition;
	public String message;
	public AnimationID animationId;
	public String scriptName;
	public CardinalDirection targetRotation;
}


package com.magnaboy.scripting;

public enum ActionType {
	Idle,
	WalkTo,
	Animation,
	Say,
	FaceDirection,
}

package com.magnaboy.scripting;

import java.util.Queue;

public class ScriptFile {
	public Queue<ScriptAction> actions;
	public String name;

	public ScriptAction nextAction() {
		ScriptAction action = actions.poll();
		if (action != null) {
			actions.add(action);
			return action;
		}
		return null;
	}

}

package com.magnaboy.scripting;

import com.google.gson.Gson;
import com.magnaboy.CitizensPlugin;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.HashMap;

public final class ScriptLoader {
	private final static HashMap<String, ScriptFile> scriptCache = new HashMap<>();

	private ScriptLoader() {
	}

	public static ScriptFile loadScript(CitizensPlugin plugin, String scriptName) {
		if (scriptCache.containsKey(scriptName)) {
			return scriptCache.get(scriptName);
		}

		InputStream inputStream = plugin.getClass().getResourceAsStream("/Scripts/" + scriptName + ".json");

		if (inputStream == null) {
			return null;
		}

		try (Reader reader = new BufferedReader(new InputStreamReader(inputStream))) {
			Gson gson = plugin.gson;
			ScriptFile script = gson.fromJson(reader, ScriptFile.class);
			scriptCache.put(scriptName, script);
			script.name = scriptName;
			return script;
		} catch (IOException e) {
			System.out.println("Script Loading Error: " + e.getMessage());
			return null;
		}
	}
}

package com.magnaboy.serialization;

import com.magnaboy.AnimationID;
import net.runelite.api.coords.WorldPoint;

public class CitizenInfo extends EntityInfo {
	public String name;
	public String examineText;
	public String[] remarks = {};
	public AnimationID moveAnimation;

	public WorldPoint wanderBoxBL;
	public WorldPoint wanderBoxTR;

	public String startScript;
}

package com.magnaboy.serialization;

import com.magnaboy.AnimationID;
import com.magnaboy.EntityType;
import com.magnaboy.MergedObject;
import java.util.List;
import java.util.UUID;
import net.runelite.api.coords.WorldPoint;

public class EntityInfo {
	public UUID uuid;
	public int regionId;
	public EntityType entityType;
	public WorldPoint worldLocation;
	public int[] modelIds = {};
	public Integer baseOrientation;
	public float[] scale;
	public float[] translate;
	public int[] modelRecolorFind = {};
	public int[] modelRecolorReplace = {};
	public AnimationID idleAnimation;
	public Integer removedObject;
	public List<MergedObject> mergedObjects;
}

package com.magnaboy.serialization;

public class SceneryInfo extends EntityInfo {

}

package com.magnaboy;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Polygon;
import javax.inject.Inject;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;

public class CitizensOverlay extends Overlay {
	private final CitizensPlugin plugin;
	private final ModelOutlineRenderer modelOutlineRenderer;

	Font overheadFont = FontManager.getRunescapeBoldFont();

	@Inject
	public CitizensOverlay(CitizensPlugin plugin, ModelOutlineRenderer modelOutlineRenderer) {
		this.modelOutlineRenderer = modelOutlineRenderer;
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
	}

	private void renderText(Graphics2D graphics, LocalPoint lp, String text) {
		if (!plugin.IS_DEVELOPMENT) {
			return;
		}
		renderText(graphics, lp, text, new Color(0, 255, 3));
	}

	private void renderText(Graphics2D graphics, LocalPoint lp, String text, Color color) {
		Font overheadFont = FontManager.getRunescapeSmallFont();
		graphics.setFont(overheadFont);

		Point p = Perspective.localToCanvas(plugin.client, lp, plugin
			.client
			.getPlane(), 0);
		if (p == null) {
			return;
		}
		FontMetrics metrics = graphics.getFontMetrics(overheadFont);
		Point shiftedP = new Point(p.getX() - (metrics.stringWidth(text) / 2), p.getY());
		OverlayUtil.renderTextLocation(graphics, shiftedP, text, color);
	}

	private void highlightTile(Graphics2D graphics, LocalPoint lp, Color color) {
		if (lp == null) {
			return;
		}
		if (!plugin.IS_DEVELOPMENT) {
			return;
		}
		final Polygon poly = Perspective.getCanvasTilePoly(plugin.client, lp);
		if (poly != null) {
			OverlayUtil.renderPolygon(graphics, poly, color);
		}
	}

	private void highlightTile(Graphics2D graphics, WorldPoint wp, Color color) {
		if (!plugin.IS_DEVELOPMENT) {
			return;
		}
		LocalPoint lp = LocalPoint.fromWorld(plugin.client, wp);
		if (lp == null) {
			return;
		}
		final Polygon poly = Perspective.getCanvasTilePoly(plugin.client, lp);
		if (poly != null) {
			OverlayUtil.renderPolygon(graphics, poly, color);
		}
	}

	private void highlightRegion(Graphics2D graphics, WorldPoint bottomLeft, WorldPoint topRight, int plane, Color color) {
		WorldArea boundingBox = Util.calculateBoundingBox(bottomLeft, topRight);
		highlightRegion(graphics, boundingBox, plane, color);
	}

	private void highlightRegion(Graphics2D graphics, WorldArea boundingBox, int plane, Color color) {
		int x = boundingBox.getX();
		int y = boundingBox.getY();
		for (int i = y; i <= y + boundingBox.getHeight(); i++) {
			for (int t = 0; t <= boundingBox.getWidth(); t++) {
				highlightTile(graphics, new WorldPoint(x + t, i, plane), color);
			}
		}
	}

	@Override
	public Dimension render(Graphics2D graphics) {
		if (CitizensPlugin.shuttingDown) {
			return null;
		}

		if (CitizenPanel.selectedPosition != null) {
			Color selectedColor = new Color(0, 255, 255, 200);
			highlightTile(graphics, CitizenPanel.selectedPosition, selectedColor);
			LocalPoint lp = LocalPoint.fromWorld(plugin.client, CitizenPanel.selectedPosition);
			if (plugin.IS_DEVELOPMENT && lp != null) {
				renderText(graphics, lp, "Selected Tile", selectedColor);
			}
		}

		if (CitizenPanel.selectedEntity != null) {
			final int outlineWidth = 4;
			modelOutlineRenderer.drawOutline(CitizenPanel.selectedEntity.rlObject, outlineWidth, Color.cyan, outlineWidth - 2);
		}

		CitizenRegion.forEachActiveEntity((entity) -> {
			if (!entity.isCitizen()) {
				return;
			}

			Citizen citizen = (Citizen) entity;
			LocalPoint localLocation = citizen.getLocalLocation();

			if (!citizen.shouldRender() || localLocation == null) {
				return;
			}

			// Render remarks
			if (citizen.activeRemark != null) {
				Point p = Perspective.localToCanvas(plugin.client, citizen.getLocalLocation(), plugin
					.client
					.getPlane(), citizen
					.rlObject.getModelHeight());
				if (p != null) {
					graphics.setFont(overheadFont);
					FontMetrics metrics = graphics.getFontMetrics(overheadFont);
					Point shiftedP = new Point(p.getX() - (metrics.stringWidth(citizen.activeRemark) / 2), p.getY());
					OverlayUtil.renderTextLocation(graphics, shiftedP, citizen.activeRemark,
						JagexColors.YELLOW_INTERFACE_TEXT);
				}
			}

			if (plugin.IS_DEVELOPMENT && citizen.distanceToPlayer() < 15) {
				String extraString = "";
				if (citizen.entityType == EntityType.ScriptedCitizen) {
					ScriptedCitizen scriptedCitizen = (ScriptedCitizen) citizen;
					if (scriptedCitizen.currentAction != null && scriptedCitizen.currentAction.action != null) {
						extraString = scriptedCitizen.currentAction.action + " ";
					}
				}
				String debugText = citizen.debugName() + " " + extraString + "H:" + citizen.rlObject.getModelHeight() + " ";
				renderText(graphics, localLocation, debugText, JagexColors.YELLOW_INTERFACE_TEXT);
				Citizen.Target target = citizen.getCurrentTarget();
				if (target != null) {
					highlightTile(graphics, target.localDestinationPosition, new Color(235, 150, 52));
				}
			}
		});

		return null;
	}
}

package com.magnaboy;

import java.util.HashMap;
import lombok.Getter;

@Getter
public enum CardinalDirection {
	SouthEast(1792),
	South(0),
	SouthWest(256),
	West(512),
	North(1024),
	NorthWest(768),
	East(1536);

	private static final HashMap<Integer, CardinalDirection> intToType = new HashMap<>();

	static {
		for (CardinalDirection type : CardinalDirection.values()) {
			intToType.put(type.getAngle(), type);
		}
	}

	private final int angle;

	CardinalDirection(int angle) {
		this.angle = angle;
	}

	public static CardinalDirection fromInteger(Integer i) {
		return i == null ? CardinalDirection.South : intToType.get(i);
	}

}

package com.magnaboy;

import lombok.Getter;

@Getter
public enum AnimationID {
	Flex(8917),
	Think(857),
	Yawn(2111),
	SlapHead(4275),
	HumanIdle(808),
	HumanWalk(819),
	Woodcutting(2117),
	HalfLayingDown(1147),
	Sitting(4114),
	ChurchSitting(3281),
	CurledUp(4712),

	HumanWithStickIdle(813),
	HumanWithStickWalk(1146),

	// Actions
	Grabbing(551),
	Eat(829),
	RangeCook(896),
	Alching(713),
	FireCook(897),
	FurnaceSmelt(899),
	HerbloreMix(363),
	Fletching(1248),
	AnvilBang(898),
	Crying(860),
	Mining(1728),
	BuryOrPickingUp(827),
	LayingDown(838),
	HumanLook(2713),
	WateringCanPour(2293),
	Fishing(622),

	ChildStarJump(218),
	ChildPlay1(6484),
	ChildPlay2(6485),
	ChildWalk(189),
	ChildIdle(195),

	SuzieIdle(10060),
	LectorIdle(5875),
	LectorWalk(5876),

	FallenManDead(6280),
	FallenManIdle(6282),

	// Non-human
	FireIdle(475),
	CatLunge(319),
	CatSit(2134),
	CatSleep(2159),
	RatIdle(2704),
	RatBanging(2706),
	BeeIdle(0),
	PuffinIdle(5873),
	PuffinWalk(5872),

	RiftGuardianIdle(7307),
	RiftGuardianWalk(7306),
	RiftGuardianSit(9397),

	CowIdle(180),
	CowWalk(229),

	TanglerootIdle(7312),
	TanglerootWalk(7313),

	TrollIdle(286),
	TrollWalk(283),

	DwarfLean(6206),
	DwarfWalk(98),
	DwarfMining(99),
	DwarfMining2(4021),
	DwarfIdle(101),
	DwarfSmith(4021),
	DwarfSit(2337),
	DwarfHandsBehindBack(2151),
	DrunkenDwarfIdle(900),
	DrunkenDwarfWalk(104),

	ChickenIdle(5386),
	ChickenWalk(5385),

	GoblinPull(3387),
	GoblinChill(6837),
	GoblinIdle(6203),
	GoblinIdl2(6835),
	GoblinIdle3(6834),
	GoblinWalk(6202),
	GoblinExcitedWalk(6193),

	PigeonIdle(4133),

	MagicBoxIdle(5221),
	StandingWithBook(1350),
	WalkingWithBook(10170),

	KittenSit(2694),
	KittenWalk(314),
	KittenLunge(315),
	KittenDip(316),
	KittenIdle(317),
	KittenSleep(2159),

	SheepDogIdle(2268),

	DogIdle(4777),
	DogWalk(4773),

	SquirrelIdle(3211),
	SquirrelWalk(3210),

	SwanIdle(3242),
	SwanWalk(3241),

	PigletWalk(2165),
	PigletIdle(2166),

	CrabIdle(3424),
	CrabWalk(3426),

	GoatIdle(5339),
	GoatWalk(5334),

	RaccoonIdle(3213),
	RaccoonWalk(3214),

	CrowIdle(6784),
	CrowWalk(6784),

	GoblinFishIdle(6061),
	GoblinFishWalk(6062),

	MonkeyIdle(222),
	MonkeyWalk(219),

	GhostIdle(5538),
	GhostWalk(5539),

	PenguinIdle(5668),
	PenguinWalk(5666),

	WerewolfIdle(6539),
	WerewolfWalk(6541),

	MoleIdle(3309),
	MoleWalk(3313),

	WheatFieldIdle(6627),

	// ???
	FrontalGrab(897),
	ChestRub(190),
	Swinging(3475);

	private final Integer id;

	AnimationID(Integer id) {
		this.id = id;
	}

}

package com.magnaboy;

import static com.magnaboy.Util.worldPointToShortCoord;
import com.magnaboy.serialization.CitizenInfo;
import com.magnaboy.serialization.SceneryInfo;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ItemEvent;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SwingConstants;
import javax.swing.border.EmptyBorder;
import net.runelite.api.GameState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;

class CitizenPanel extends PluginPanel {
	private final static String RELOAD_BUTTON_READY = "Reload All Entites";
	public static WorldPoint selectedPosition;
	public static Entity selectedEntity;
	public WorldPoint wanderRegionBL;
	public WorldPoint wanderRegionTR;
	public JLabel editingTargetLabel;
	public JButton updateButton;
	public JButton deleteButton;
	public JLabel reloadWarning;
	public JCheckBox manualFieldsToggle;
	private CitizensPlugin plugin;
	private JLabel label;
	private CitizensOverlay overlay;
	// Editor Panel Fields
	private HashSet<JComponent> allElements;
	private JButton reloadButton;
	private JButton saveChangesButton;
	private JButton spawnButton;
	private JLabel selectedPositionLbl;
	private JTextField entityNameField;
	private JComboBox<EntityType> entityTypeSelection;
	private JComboBox<AnimationID> animIdIdleSelect;
	private JComboBox<AnimationID> animIdMoveSelect;
	private JTextField modelIdsField;
	private JTextField recolorFindField;
	private JTextField recolorReplaceField;
	private JComboBox<CardinalDirection> orientationField;
	private JTextField examineTextField;
	private JTextField remarksField;
	private JTextField scaleFieldX;
	private JTextField scaleFieldY;
	private JTextField scaleFieldZ;
	private JTextField translateFieldX;
	private JTextField translateFieldY;
	private JTextField translateFieldZ;
	private JButton selectWanderBL;
	private JButton selectWanderTR;
	private JTextField manualAnimIdIdleSelect;
	private JTextField manualAnimIdMoveSelect;

	// End Editor Fields

	public void init(CitizensPlugin plugin, CitizensOverlay overlay) {
		this.plugin = plugin;
		this.overlay = overlay;
		final JPanel layoutPanel = new JPanel();
		layoutPanel.setLayout(new GridBagLayout());
		add(layoutPanel, BorderLayout.CENTER);

		label = new JLabel();
		label.setHorizontalAlignment(SwingConstants.CENTER);

		// DEV ONLY
		allElements = new HashSet<>();
		if (plugin.IS_DEVELOPMENT) {
			addEditorComponents(layoutPanel);
			entityTypeChanged();
		}
		update();
	}

	public void update() {
		if (!plugin.IS_DEVELOPMENT) {
			return;
		}
		UpdateEditorFields();

		AtomicInteger activeEntities = new AtomicInteger();
		AtomicInteger inactiveEntities = new AtomicInteger();

		CitizenRegion.forEachEntity((entity) -> {
			if (entity == null) {
				return;
			}
			if (entity.isActive()) {
				activeEntities.addAndGet(1);
			} else {
				inactiveEntities.addAndGet(1);
			}
		});

		int totalEntities = activeEntities.get() + inactiveEntities.get();
		label.setText(activeEntities + "/" + totalEntities + " entities are active");

		UpdateEditorFields();
	}

	private void UpdateEditorFields() {
		GameState state = plugin.client.getGameState();

		if (state == GameState.LOGIN_SCREEN || state == GameState.LOGIN_SCREEN_AUTHENTICATOR) {
			selectedPosition = null;
		}
		int dirtySize = CitizenRegion.dirtyRegionCount();

		reloadButton.setEnabled(state == GameState.LOGGED_IN);
		selectedPositionLbl.setText(selectedPosition == null ? "N/A" : worldPointToShortCoord(selectedPosition));

		String errorMessage = validateFields();
		boolean valid = errorMessage.isEmpty();
		boolean canSpawn = state == GameState.LOGGED_IN && valid;
		spawnButton.setEnabled(canSpawn);
		spawnButton.setText(canSpawn ? "Spawn Entity" : "Can't Spawn: " + errorMessage);

		saveChangesButton.setEnabled(true);
		saveChangesButton.setText("Save Changes");

		if (selectedEntity != null && !CitizenPanel.selectedEntity.isActive()) {
			selectedEntity = null;
		}

		updateButton.setVisible(selectedEntity != null);

		if (selectedEntity instanceof Citizen) {
			editingTargetLabel.setText("Editing: " + selectedEntity.name);
		} else {
			editingTargetLabel.setText("Editing: Scenery Object");
		}
		editingTargetLabel.setVisible(selectedEntity != null);
		deleteButton.setVisible(selectedEntity != null);

		reloadWarning.setVisible(dirtySize > 0);

		selectWanderBL.setText(wanderRegionBL == null ? "Select BL" : Util.worldPointToShortCoord(wanderRegionBL));
		selectWanderTR.setText(wanderRegionTR == null ? "Select TR" : Util.worldPointToShortCoord(wanderRegionTR));
	}

	private String validateFields() {
		if (selectedPosition == null) {
			return "No Position Selected";
		}

		EntityType selectedType = (EntityType) entityTypeSelection.getSelectedItem();

		if (fieldEmpty(entityNameField) && selectedType != EntityType.Scenery) {
			return "Empty Name";
		}

		if (fieldEmpty(modelIdsField)) {
			return "No Model IDs";
		}

		if (csvToIntArray(modelIdsField.getText()).length == 0) {
			return "Invalid Model Ids";
		}

		if (csvToIntArray(recolorFindField.getText()).length !=
			csvToIntArray(recolorReplaceField.getText()).length) {
			return "Model Color Mismatch";
		}

		if (selectedType == EntityType.WanderingCitizen) {
			if (wanderRegionBL == null || wanderRegionTR == null) {
				return "Incomplete Wander Region";
			}
		}
		return "";
	}

	private boolean fieldEmpty(JTextField f) {
		return f.getText() == null || f.getText().trim().isEmpty();
	}

	// DEV ONLY
	private void addEditorComponents(JPanel layoutPanel) {

		GridBagConstraints gbc = new GridBagConstraints();
		gbc.fill = GridBagConstraints.BOTH;
		gbc.insets = new Insets(0, 0, 7, 2);
		gbc.weightx = 0.5;
		gbc.gridwidth = GridBagConstraints.REMAINDER;

		// Active Entities
		{
			gbc.gridx = 0;
			gbc.gridy = 0;
			layoutPanel.add(label, gbc);
		}

		// Reload Entities
		{
			gbc.gridy++;

			gbc.gridx = 0;
			reloadButton = new JButton();
			reloadButton.setText(RELOAD_BUTTON_READY);
			reloadButton.setHorizontalAlignment(SwingConstants.CENTER);
			reloadButton.setFocusable(false);

			reloadButton.addActionListener(e -> {
				selectedEntity = null;
				plugin.reload();
				UpdateEditorFields();
			});
			layoutPanel.add(reloadButton, gbc);

			gbc.gridy++;
			reloadWarning = new JLabel("Unsaved Changes Will Be Lost");
			reloadWarning.setFont(FontManager.getRunescapeSmallFont());
			reloadWarning.setBorder(new EmptyBorder(0, 0, 0, 0));
			reloadWarning.setForeground(Color.ORANGE);
			reloadWarning.setVerticalAlignment(SwingConstants.NORTH);
			reloadWarning.setHorizontalAlignment(SwingConstants.CENTER);
			reloadWarning.setVisible(false);
			layoutPanel.add(reloadWarning, gbc);

		}

		// Editing Target
		{
			gbc.gridy++;
			editingTargetLabel = new JLabel();
			editingTargetLabel.setHorizontalAlignment(SwingConstants.CENTER);
			editingTargetLabel.setForeground(Color.orange);
			editingTargetLabel.setVisible(false);
			layoutPanel.add(editingTargetLabel, gbc);
		}

		// Selected Position Label
		{
			gbc.gridy++;

			gbc.gridx = 0;
			selectedPositionLbl = createLabeledComponent(new JLabel(), "Selected Position", layoutPanel, gbc);
		}

		// Name Field
		{
			gbc.gridy++;

			gbc.gridx = 0;
			entityNameField = createLabeledComponent(new JTextField(), "Entity Name", layoutPanel, gbc);
		}

		// Examine Text
		{
			gbc.gridy++;

			gbc.gridx = 0;
			examineTextField = createLabeledComponent(new JTextField(), "Examine Text", layoutPanel, gbc);
			examineTextField.setText("A Citizen of Gielinor");
		}

		// Entity Type
		{
			gbc.gridy++;

			gbc.gridx = 0;

			entityTypeSelection = createLabeledComponent(new JComboBox<>(EntityType.values()), "Entity Type", layoutPanel, gbc);
			entityTypeSelection.setFocusable(false);
			entityTypeSelection.addActionListener(e -> {
				entityTypeChanged();
			});
		}

		// Cardinal Direction
		{
			gbc.gridy++;

			gbc.gridx = 0;
			orientationField = createLabeledComponent(new JComboBox<>(CardinalDirection.values()), "Base Orientation", layoutPanel, gbc);
			orientationField.setSelectedItem(CardinalDirection.South);
			orientationField.setFocusable(false);
		}

		// Animations
		{
			gbc.gridy++;
			gbc.gridwidth = 2;

			gbc.insets = new Insets(15, 0, 0, 2);
			manualFieldsToggle = new JCheckBox("Manual Animation IDs");
			manualFieldsToggle.setFont(FontManager.getRunescapeSmallFont());
			manualFieldsToggle.setHorizontalAlignment(SwingConstants.RIGHT);
			layoutPanel.add(manualFieldsToggle, gbc);

			manualFieldsToggle.addItemListener(e -> {
				if (e.getStateChange() == ItemEvent.SELECTED || e.getStateChange() == ItemEvent.DESELECTED) {
					boolean checked = manualFieldsToggle.isSelected();

					animIdIdleSelect.getParent().setVisible(!checked);
					if (entityTypeSelection.getSelectedItem() != EntityType.Scenery) {
						animIdMoveSelect.getParent().setVisible(!checked);
					}

					manualAnimIdIdleSelect.getParent().setVisible(checked);
					if (entityTypeSelection.getSelectedItem() != EntityType.Scenery) {
						manualAnimIdMoveSelect.getParent().setVisible(checked);
					}
				}
			});

			AnimationID[] animIds = AnimationID.values();
			Arrays.sort(animIds, Comparator.comparing(Enum::name));

			gbc.gridy++;
			gbc.gridx = 0;
			gbc.gridwidth = 2;
			gbc.insets = new Insets(0, 0, 7, 2);
			animIdIdleSelect = createLabeledComponent(new JComboBox<>(animIds), "Idle Animation", layoutPanel, gbc);
			animIdIdleSelect.setSelectedItem(AnimationID.HumanIdle);
			animIdIdleSelect.setFocusable(false);

			gbc.gridy++;
			gbc.gridwidth = 2;
			animIdMoveSelect = createLabeledComponent(new JComboBox<>(animIds), "Move Animation", layoutPanel, gbc);
			animIdMoveSelect.setSelectedItem(AnimationID.HumanWalk);
			animIdMoveSelect.setFocusable(false);

			gbc.gridy++;
			gbc.gridwidth = 2;
			manualAnimIdIdleSelect = createLabeledComponent(new JTextField(), "Idle Animation", layoutPanel, gbc);
			manualAnimIdIdleSelect.setText("Not Yet Implemented");
			manualAnimIdIdleSelect.getParent().setVisible(false);

			gbc.gridy++;
			gbc.gridwidth = 2;
			manualAnimIdMoveSelect = createLabeledComponent(new JTextField(), "Move Animation", layoutPanel, gbc);
			manualAnimIdMoveSelect.setText("Not Yet Implemented");
			manualAnimIdMoveSelect.getParent().setVisible(false);
		}

		// Models
		{
			gbc.gridy++;
			gbc.gridx = 0;
			modelIdsField = createLabeledComponent(new JTextField(), "Model Ids", layoutPanel, gbc);
			modelIdsField.setToolTipText("Integers only, separated by commas");
		}

		// Remarks
		{
			gbc.gridy++;
			gbc.gridx = 0;
			gbc.gridwidth = 2;
			remarksField = createLabeledComponent(new JTextField(), "Remarks", layoutPanel, gbc);
			remarksField.setToolTipText("Phrases, separated by commas");
		}

		// Model Recolors
		{
			gbc.gridy++;
			gbc.gridwidth = 1;
			recolorFindField = createLabeledComponent(new JTextField(), "Find Model Colors", layoutPanel, gbc);
			recolorFindField.setToolTipText("Integers only, separated by commas");

			gbc.gridx = 1;
			recolorReplaceField = createLabeledComponent(new JTextField(), "Replace Model Colors", layoutPanel, gbc);
			recolorReplaceField.setToolTipText("Integers only, separated by commas");
		}

		// Scale
		{
			gbc.gridy++;
			gbc.gridwidth = 2;
			gbc.gridx = 0;
			scaleFieldX = new JTextField();
			scaleFieldY = new JTextField();
			scaleFieldZ = new JTextField();
			createLabeledMultiComponent("Scale", layoutPanel, gbc, scaleFieldX, scaleFieldY, scaleFieldZ);
		}

		// Translation
		{
			gbc.gridy++;
			gbc.gridwidth = 2;
			gbc.gridx = 0;
			translateFieldX = new JTextField();
			translateFieldY = new JTextField();
			translateFieldZ = new JTextField();
			createLabeledMultiComponent("Translation", layoutPanel, gbc, translateFieldX, translateFieldY, translateFieldZ);
		}

		// Wander Region
		{
			gbc.gridy++;
			gbc.gridwidth = 2;
			gbc.gridx = 0;

			selectWanderBL = new JButton();
			selectWanderBL.setText("Select BL");
			selectWanderBL.setFocusable(false);
			selectWanderBL.addActionListener(e -> {
				wanderRegionBL = selectedPosition;
				selectWanderBL.setText(Util.worldPointToShortCoord(selectedPosition));
			});

			selectWanderTR = new JButton();
			selectWanderTR.setText("Select TR");
			selectWanderTR.setFocusable(false);
			selectWanderTR.addActionListener(e -> {
				wanderRegionTR = selectedPosition;
				selectWanderTR.setText(Util.worldPointToShortCoord(selectedPosition));
			});

			createLabeledMultiComponent("Wander Region", layoutPanel, gbc, selectWanderBL, selectWanderTR);
		}

		// Spawn/Save Button
		{
			gbc.gridy++;
			gbc.gridx = 0;
			spawnButton = new JButton();
			spawnButton.setText("Spawn Entity");
			spawnButton.setFocusable(false);
			spawnButton.addActionListener(e -> {
				if (entityTypeSelection.getSelectedItem() == EntityType.Scenery) {
					SceneryInfo info = buildSceneryInfo();
					Scenery scenery = CitizenRegion.spawnSceneryFromPanel(info);
					selectedEntity = scenery;
				} else {
					CitizenInfo info = buildCitizenInfo(selectedPosition.getRegionID());
					Citizen citizen = CitizenRegion.spawnCitizenFromPanel(info);
					selectedEntity = citizen;
				}
				selectedPosition = null;
				update();
			});
			layoutPanel.add(spawnButton, gbc);

			gbc.gridy++;
			gbc.gridx = 0;
			updateButton = new JButton();
			updateButton.setText("Update Entity");
			updateButton.setFocusable(false);
			updateButton.addActionListener(e -> {
				if (selectedEntity.isCitizen()) {
					CitizenInfo info = buildCitizenInfo(selectedEntity.regionId);
					if (selectedEntity != null) {
						info.uuid = selectedEntity.uuid;
						CitizenRegion.updateEntity(info);
					}
				} else if (selectedEntity.entityType == EntityType.Scenery) {
					SceneryInfo info = buildSceneryInfo();
					if (selectedEntity != null) {

						info.uuid = selectedEntity.uuid;
						CitizenRegion.updateEntity(info);
					}
				}

				update();
				plugin.reload();
			});
			layoutPanel.add(updateButton, gbc);
		}

		// Delete Button
		{
			gbc.gridy++;
			gbc.gridx = 0;
			deleteButton = new JButton();
			deleteButton.setText("Delete Entity");
			deleteButton.setFocusable(false);
			deleteButton.setVisible(false);
			deleteButton.setBackground(new Color(135, 58, 58));
			deleteButton.addActionListener(e -> {
				CitizenRegion.removeEntityFromRegion(selectedEntity);
				selectedEntity.despawn();
			});
			layoutPanel.add(deleteButton, gbc);
		}

		// Save Changes
		{
			gbc.gridy++;

			saveChangesButton = new JButton();
			saveChangesButton.setText("Save Changes");
			saveChangesButton.setFocusable(false);
			saveChangesButton.addActionListener(e -> {
				CitizenRegion.saveDirtyRegions();
			});

			gbc.gridx = 0;
			layoutPanel.add(saveChangesButton, gbc);
		}
	}

	private int[] csvToIntArray(String csv) {
		String[] separated = csv.split(",", -1);
		int[] validInts = new int[separated.length];
		for (int i = 0; i < validInts.length; i++) {
			try {
				validInts[i] = Integer.parseInt(separated[i].trim());
			} catch (Exception e) {
				return new int[0];
			}
		}
		return validInts;
	}

	private float parseOrDefault(Object o, float defaultResult) {
		float result = defaultResult;
		String s = "";
		if (o instanceof JTextField) {
			s = ((JTextField) o).getText();
		}
		if (o instanceof String) {
			s = (String) o;
		}
		try {
			result = Float.parseFloat(s);
		} catch (Exception ignored) {
		}

		return result;
	}

	private CitizenInfo buildCitizenInfo(int regionId) {
		CitizenInfo info = new CitizenInfo();
		info.uuid = UUID.randomUUID();
		info.regionId = regionId;
		info.name = entityNameField.getText();
		info.examineText = examineTextField.getText();
		info.worldLocation = selectedPosition;
		info.entityType = (EntityType) entityTypeSelection.getSelectedItem();
		info.idleAnimation = (AnimationID) animIdIdleSelect.getSelectedItem();
		info.moveAnimation = (AnimationID) animIdMoveSelect.getSelectedItem();
		info.modelIds = csvToIntArray(modelIdsField.getText());
		info.modelRecolorFind = csvToIntArray(recolorFindField.getText());
		info.modelRecolorReplace = csvToIntArray(recolorReplaceField.getText());
		info.baseOrientation = ((CardinalDirection) orientationField.getSelectedItem()).getAngle();
		info.remarks = remarksField.getText().length() > 0 ? remarksField.getText().split(",", -1) : null;

		if (fieldEmpty(scaleFieldX) && fieldEmpty(scaleFieldY) && fieldEmpty(scaleFieldZ)) {
			info.scale = null;
		} else {
			info.scale = new float[]{
				parseOrDefault(scaleFieldX, 1),
				parseOrDefault(scaleFieldY, 1),
				parseOrDefault(scaleFieldZ, 1),
			};
		}
		if (fieldEmpty(translateFieldX) && fieldEmpty(translateFieldY) && fieldEmpty(translateFieldZ)) {
			info.translate = null;
		} else {
			info.translate = new float[]{
				parseOrDefault(translateFieldX, 0),
				parseOrDefault(translateFieldY, 0),
				parseOrDefault(translateFieldZ, 0),
			};
		}

		if (info.entityType == EntityType.WanderingCitizen) {
			info.wanderBoxTR = wanderRegionTR;
			info.wanderBoxBL = wanderRegionBL;
		}

		return info;
	}

	private SceneryInfo buildSceneryInfo() {
		SceneryInfo info = new SceneryInfo();
		info.uuid = UUID.randomUUID();
		info.regionId = selectedPosition.getRegionID();
		info.entityType = EntityType.Scenery;
		info.worldLocation = selectedPosition;
		info.modelIds = csvToIntArray(modelIdsField.getText());
		info.modelRecolorFind = csvToIntArray(recolorFindField.getText());
		info.modelRecolorReplace = csvToIntArray(recolorReplaceField.getText());
		info.baseOrientation = ((CardinalDirection) orientationField.getSelectedItem()).getAngle();
		info.idleAnimation = (AnimationID) animIdIdleSelect.getSelectedItem();

		if (fieldEmpty(scaleFieldX) && fieldEmpty(scaleFieldY) && fieldEmpty(scaleFieldZ)) {
			info.scale = null;
		} else {
			info.scale = new float[]{
				parseOrDefault(scaleFieldX, 1),
				parseOrDefault(scaleFieldY, 1),
				parseOrDefault(scaleFieldZ, 1),
			};
		}

		if (fieldEmpty(translateFieldX) && fieldEmpty(translateFieldY) && fieldEmpty(translateFieldZ)) {
			info.translate = null;
		} else {
			info.translate = new float[]{
				parseOrDefault(translateFieldX, 0),
				parseOrDefault(translateFieldY, 0),
				parseOrDefault(translateFieldZ, 0),
			};
		}
		return info;
	}

	private <T extends JComponent> T createLabeledComponent(JComponent component, String label, JPanel panel, GridBagConstraints constraints) {
		final JPanel container = new JPanel();
		container.setLayout(new BorderLayout());

		final JLabel uiLabel = new JLabel(label);

		uiLabel.setFont(FontManager.getRunescapeSmallFont());
		uiLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
		uiLabel.setForeground(Color.WHITE);

		container.add(uiLabel, BorderLayout.NORTH);
		container.add(component, BorderLayout.CENTER);

		panel.add(container, constraints);
		allElements.add(container);
		allElements.add(component);
		return (T) component;
	}

	//Creates multiple components under a single label
	private void createLabeledMultiComponent(String label, JPanel panel, GridBagConstraints constraints, JComponent... comps) {
		final JPanel container = new JPanel();
		container.setLayout(new GridBagLayout());

		GridBagConstraints containerGbc = new GridBagConstraints();
		containerGbc.fill = GridBagConstraints.HORIZONTAL;
		containerGbc.insets = new Insets(0, 0, 0, 2);
		containerGbc.weightx = 0.5;
		containerGbc.gridwidth = comps.length;
		final JLabel uiLabel = new JLabel(label);

		uiLabel.setFont(FontManager.getRunescapeSmallFont());
		uiLabel.setBorder(new EmptyBorder(0, 0, 0, 0));
		uiLabel.setForeground(Color.WHITE);

		containerGbc.gridx = 0;
		container.add(uiLabel, containerGbc);
		containerGbc.weightx = 0.5f;
		containerGbc.gridwidth = 1;
		int i = 0;
		for (JComponent comp : comps) {
			containerGbc.gridx = i++;
			container.add(comp, containerGbc);
			allElements.add(comp);
		}
		panel.add(container, constraints);
	}

	private void entityTypeChanged() {
		for (JComponent jc : allElements) {
			jc.setVisible(true);
			jc.getParent().setVisible(true);
		}

		EntityType type = (EntityType) entityTypeSelection.getSelectedItem();

		boolean checked = manualFieldsToggle.isSelected();
		// Turn off irrelevant components
		switch (type) {
			// We get the parents because they are each in individual containers with their labels
			case StationaryCitizen:
			case ScriptedCitizen:
				selectWanderTR.getParent().setVisible(false);
				selectWanderBL.getParent().setVisible(false);

				animIdIdleSelect.getParent().setVisible(!checked);
				animIdMoveSelect.getParent().setVisible(!checked);
				manualAnimIdIdleSelect.getParent().setVisible(checked);
				manualAnimIdMoveSelect.getParent().setVisible(checked);
				break;

			case Scenery:
				entityNameField.getParent().setVisible(false);
				examineTextField.getParent().setVisible(false);
				manualAnimIdMoveSelect.getParent().setVisible(false);
				animIdIdleSelect.getParent().setVisible(!checked);
				manualAnimIdIdleSelect.getParent().setVisible(checked);
				remarksField.getParent().setVisible(false);
				selectWanderTR.getParent().setVisible(false);
				selectWanderBL.getParent().setVisible(false);
				break;
		}

		if (type == EntityType.StationaryCitizen || type == EntityType.Scenery) {
			animIdMoveSelect.getParent().setVisible(false);
		}
	}

	public void setSelectedEntity(Entity e) {
		if (selectedEntity == e) {
			selectedEntity = null;
		} else {
			selectedEntity = e;
			selectedPosition = e.getWorldLocation();
		}

		entityTypeSelection.setSelectedItem(e.entityType);
		orientationField.setSelectedItem(CardinalDirection.fromInteger(e.baseOrientation));
		animIdIdleSelect.setSelectedItem(e.idleAnimationId);
		modelIdsField.setText(e.getModelIDsString());
		recolorFindField.setText(e.getRecolorFindString());
		recolorReplaceField.setText(e.getRecolorReplaceString());

		if (e.translate != null) {
			translateFieldX.setText(String.valueOf(e.translate[0]));
			translateFieldY.setText(String.valueOf(e.translate[1]));
			translateFieldZ.setText(String.valueOf(e.translate[2]));
		}

		if (e.scale != null) {
			scaleFieldX.setText(String.valueOf(e.scale[0]));
			scaleFieldY.setText(String.valueOf(e.scale[1]));
			scaleFieldZ.setText(String.valueOf(e.scale[2]));
		}

		if (e.isCitizen()) {
			Citizen c = (Citizen) e;
			entityNameField.setText(c.name);
			examineTextField.setText(c.examine);
			animIdMoveSelect.setSelectedItem(c.movingAnimationId);
			if (c.remarks != null) {
				remarksField.setText(String.join(",", c.remarks));
			}
		}

		if (e.entityType == EntityType.WanderingCitizen) {
			WanderingCitizen w = (WanderingCitizen) e;
			wanderRegionBL = w.wanderRegionBL;
			wanderRegionTR = w.wanderRegionTR;
		}

		update();
	}

	public void cleanup() {
		selectedPosition = null;
		selectedEntity = null;
	}
}

package com.magnaboy;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import lombok.Getter;
import net.runelite.api.AABB;
import net.runelite.api.Animation;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Model;
import net.runelite.api.ModelData;
import net.runelite.api.Perspective;
import static net.runelite.api.Perspective.COSINE;
import static net.runelite.api.Perspective.SINE;
import net.runelite.api.Player;
import net.runelite.api.RuneLiteObject;
import net.runelite.api.Scene;
import net.runelite.api.Tile;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.geometry.SimplePolygon;
import net.runelite.api.model.Jarvis;

public class Entity<T extends Entity<T>> {
	public Integer regionId;
	public String name;
	public String examine;
	public CitizensPlugin plugin;
	public AnimationID idleAnimationId;
	public float[] scale;
	public float[] translate;
	public List<MergedObject> mergedObjects = new ArrayList<>();
	protected RuneLiteObject rlObject;
	@Getter
	protected EntityType entityType;
	protected Integer baseOrientation;
	protected UUID uuid;
	@Getter
	private WorldPoint worldLocation;
	private int[] modelIDs;
	private int[] recolorsToFind;
	private int[] recolorsToReplace;
	private Integer objectToRemove;

	public Entity(CitizensPlugin plugin) {
		this.plugin = plugin;
		this.rlObject = plugin.client.createRuneLiteObject();
	}

	protected static SimplePolygon calculateAABB(Client client, Model m, Integer jauOrient, int x, int y, int z, int zOff) {
		if (m == null) {
			throw new IllegalStateException("model is null");
		}
		if (jauOrient == null) {
			throw new IllegalStateException("jauOrient is null");
		}
		AABB aabb = m.getAABB(jauOrient);

		int x1 = aabb.getCenterX();
		int y1 = aabb.getCenterZ();
		int z1 = aabb.getCenterY() + zOff;

		int ex = aabb.getExtremeX();
		int ey = aabb.getExtremeZ();
		int ez = aabb.getExtremeY();

		int x2 = x1 + ex;
		int y2 = y1 + ey;
		int z2 = z1 + ez;

		x1 -= ex;
		y1 -= ey;
		z1 -= ez;

		int[] xa = new int[]{x1, x2, x1, x2, x1, x2, x1, x2};
		int[] ya = new int[]{y1, y1, y2, y2, y1, y1, y2, y2};
		int[] za = new int[]{z1, z1, z1, z1, z2, z2, z2, z2};

		int[] x2d = new int[8];
		int[] y2d = new int[8];

		Entity.modelToCanvasCpu(client, 8, x, y, z, 0, xa, ya, za, x2d, y2d);

		return Jarvis.convexHull(x2d, y2d);
	}

	private static void modelToCanvasCpu(Client client, int end, int x3dCenter, int y3dCenter, int z3dCenter, int rotate, int[] x3d, int[] y3d, int[] z3d, int[] x2d, int[] y2d) {
		final int cameraPitch = client.getCameraPitch(), cameraYaw = client.getCameraYaw(),

			pitchSin = SINE[cameraPitch], pitchCos = COSINE[cameraPitch], yawSin = SINE[cameraYaw], yawCos = COSINE[cameraYaw], rotateSin = SINE[rotate], rotateCos = COSINE[rotate],

			cx = x3dCenter - client.getCameraX(), cy = y3dCenter - client.getCameraY(), cz = z3dCenter - client.getCameraZ(),

			viewportXMiddle = client.getViewportWidth() / 2, viewportYMiddle = client.getViewportHeight() / 2, viewportXOffset = client.getViewportXOffset(), viewportYOffset = client.getViewportYOffset(),

			zoom3d = client.getScale();

		for (int i = 0; i < end; i++) {
			int x = x3d[i];
			int y = y3d[i];
			int z = z3d[i];

			if (rotate != 0) {
				int x0 = x;
				x = x0 * rotateCos + y * rotateSin >> 16;
				y = y * rotateCos - x0 * rotateSin >> 16;
			}

			x += cx;
			y += cy;
			z += cz;

			final int x1 = x * yawCos + y * yawSin >> 16, y1 = y * yawCos - x * yawSin >> 16, y2 = z * pitchCos - y1 * pitchSin >> 16, z1 = y1 * pitchCos + z * pitchSin >> 16;

			int viewX, viewY;

			if (z1 < 50) {
				viewX = Integer.MIN_VALUE;
				viewY = Integer.MIN_VALUE;
			} else {
				viewX = (viewportXMiddle + x1 * zoom3d / z1) + viewportXOffset;
				viewY = (viewportYMiddle + y2 * zoom3d / z1) + viewportYOffset;
			}

			x2d[i] = viewX;
			y2d[i] = viewY;
		}
	}

	public int getAnimationID() {
		return rlObject.getAnimation().getId();
	}

	public boolean isCitizen() {
		return entityType == EntityType.StationaryCitizen || entityType == EntityType.WanderingCitizen || entityType == EntityType.ScriptedCitizen;
	}

	public SimplePolygon getClickbox() {
		LocalPoint location = getLocalLocation();
		int zOff = Perspective.getTileHeight(plugin.client, location, plugin.client.getPlane());
		return calculateAABB(plugin.client, rlObject.getModel(), rlObject.getOrientation(), location.getX(), location.getY(), plugin.client.getPlane(), zOff);
	}

	public LocalPoint getLocalLocation() {
		return rlObject.getLocation();
	}

	public int getOrientation() {
		return rlObject.getOrientation();
	}

	public void setModel(Model model) {
		rlObject.setModel(model);
	}

	public void setAnimation(int animationID) {
		plugin.clientThread.invokeLater(() -> {
			Animation anim = plugin.client.loadAnimation(animationID);
			rlObject.setAnimation(anim);
		});
	}

	public T setWorldLocation(WorldPoint location) {
		this.worldLocation = location;
		return (T) this;
	}

	public T setObjectToRemove(Integer objectToRemove) {
		this.objectToRemove = objectToRemove;
		return (T) this;
	}

	public T addMergedObject(MergedObject mergedObject) {
		this.mergedObjects.add(mergedObject);
		return (T) this;
	}

	public void update() {
		boolean inScene = shouldRender();

		if (inScene) {
			spawn();
		} else {
			despawn();
		}
	}

	public T setScale(float[] scale) {
		this.scale = scale;
		return (T) this;
	}

	public T setTranslate(float translateX, float translateY, float translateZ) {
		this.translate = new float[]{translateX, translateY, translateZ};
		return (T) this;
	}

	public T setTranslate(float[] translate) {
		this.translate = translate;
		return (T) this;
	}

	public T setBaseOrientation(CardinalDirection baseOrientation) {
		this.baseOrientation = baseOrientation.getAngle();
		return (T) this;
	}

	public T setBaseOrientation(Integer baseOrientation) {
		this.baseOrientation = baseOrientation;
		return (T) this;
	}

	public T setModelIDs(int[] modelIDs) {
		this.modelIDs = modelIDs;
		return (T) this;
	}

	public T setModelRecolors(int[] recolorsToFind, int[] recolorsToReplace) {
		this.recolorsToFind = recolorsToFind;
		this.recolorsToReplace = recolorsToReplace;
		return (T) this;
	}

	public T setLocation(LocalPoint location) {
		if (location == null) {
			throw new IllegalStateException("Tried to set null location");
		}
		rlObject.setLocation(location, getPlane());
		WorldPoint wp = WorldPoint.fromLocal(plugin.client, location);
		setWorldLocation(wp);
		return (T) this;
	}

	public int getPlane() {
		return this.worldLocation.getPlane();
	}

	public boolean shouldRender() {
		if (getPlane() != plugin.client.getPlane()) {
			return false;
		}

		float distanceFromPlayer = distanceToPlayer();

		if (distanceFromPlayer > Util.MAX_ENTITY_RENDER_DISTANCE) {
			return false;
		}

		LocalPoint lp = LocalPoint.fromWorld(plugin.client, worldLocation);
		return lp != null;
	}

	public float distanceToPlayer() {
		Player player = plugin.client.getLocalPlayer();
		WorldPoint playerWorldLoc = player.getWorldLocation();
		return playerWorldLoc.distanceTo(getWorldLocation());
	}

	public boolean despawn() {
		if (rlObject == null) {
			return false;
		}
		if (!rlObject.isActive()) {
			return false;
		}

		plugin.clientThread.invokeLater(() -> {
			rlObject.setActive(false);
		});

		if (plugin.IS_DEVELOPMENT) {
			plugin.panel.update();
		}

		return true;
	}

	private void initModel() {
		if (rlObject.getModel() == null) {
			ArrayList<ModelData> models = new ArrayList<ModelData>();
			for (int modelID : modelIDs) {
				ModelData data = plugin.client.loadModelData(modelID);
				models.add(data);
			}

			// Merge merged objects
			for (MergedObject obj : mergedObjects) {
				ModelData data = plugin.client.loadModelData(obj.objectID);
				for (int i = 0; i < obj.count90CCWRotations; i++) {
					data.cloneVertices();
					data.rotateY90Ccw();
				}
				models.add(data);
			}

			ModelData finalModel = plugin.client.mergeModels(models.toArray(new ModelData[models.size()]), models.size());
			if (recolorsToReplace != null && recolorsToReplace.length > 0) {
				for (int i = 0; i < recolorsToReplace.length; i++) {
					finalModel.recolor((short) recolorsToFind[i], (short) recolorsToReplace[i]);
				}
			}
			if (scale != null) {
				finalModel.cloneVertices();
				finalModel.scale(-(Math.round(scale[0] * 128)), -(Math.round(scale[1] * 128)), -(Math.round(scale[2] * 128)));
			}

			if (translate != null) {
				finalModel.cloneVertices();
				finalModel.translate(-(Math.round(translate[0] * 128)), -(Math.round(translate[1] * 128)), -(Math.round(translate[2] * 128)));
			}

			rlObject.setModel(finalModel.light(64, 850, -30, -50, -30));
		}

		if (baseOrientation != null && rlObject.getOrientation() == 0) {
			rlObject.setOrientation(baseOrientation);
		}

		if (this.idleAnimationId != null && rlObject.getAnimation() == null) {
			setAnimation((this.idleAnimationId).getId());
		}

		rlObject.setShouldLoop(true);
	}

	public String debugName() {
		float dist = distanceToPlayer();
		return "N:" + name + " T:" + entityType + " ID:" + uuid.toString().substring(0, 6) + " D:" + dist;
	}

	public void validate() {
		if (uuid == null) {
			throw new IllegalStateException(debugName() + " has no uuid.");
		}
		if (regionId == null) {
			throw new IllegalStateException(debugName() + " has no regionId.");
		}
	}

	private void initLocation() {
		LocalPoint initializedLocation = LocalPoint.fromWorld(plugin.client, worldLocation);
		if (initializedLocation == null) {
			throw new IllegalStateException("Tried to spawn entity with no initializedLocation: " + debugName());
		}
		setLocation(initializedLocation);
	}

	public boolean spawn() {
		if (this.isActive()) {
			return false;
		}

		initModel();
		initLocation();
		if (objectToRemove != null) {
			removeOtherObjects();
		}

		if (idleAnimationId != null) {
			setAnimation(idleAnimationId.getId());
		}

		plugin.clientThread.invokeLater(() -> {
			rlObject.setActive(true);
		});

		if (plugin.IS_DEVELOPMENT) {
			plugin.panel.update();
		}

		return true;
	}

	public boolean isActive() {
		return rlObject.isActive();
	}

	public boolean rotateObject(double intx, double inty) {
		if (intx == 0 && inty == 0) {
			return true;
		}
		int targetOrientation = Util.radToJau(Math.atan2(intx, inty));
		int currentOrientation = rlObject.getOrientation();

		int dJau = (targetOrientation - currentOrientation) % Util.JAU_FULL_ROTATION;
		if (dJau != 0) {
			final int JAU_HALF_ROTATION = 1024;
			final int JAU_TURN_SPEED = 32;
			int dJauCW = Math.abs(dJau);

			if (dJauCW > JAU_HALF_ROTATION) {
				dJau = (currentOrientation - targetOrientation) % Util.JAU_FULL_ROTATION;
			} else if (dJauCW == JAU_HALF_ROTATION) {
				dJau = dJauCW;
			}

			if (Math.abs(dJau) > JAU_TURN_SPEED) {
				dJau = Integer.signum(dJau) * JAU_TURN_SPEED;
			}

			int newOrientation = (Util.JAU_FULL_ROTATION + rlObject.getOrientation() + dJau) % Util.JAU_FULL_ROTATION;

			rlObject.setOrientation(newOrientation);
			dJau = (targetOrientation - newOrientation) % Util.JAU_FULL_ROTATION;
		}

		return dJau == 0;
	}

	public T setIdleAnimation(AnimationID idleAnimationId) {
		this.idleAnimationId = idleAnimationId;
		return (T) this;
	}

	public T setUUID(UUID uuid) {
		if (this.uuid == null) {
			this.uuid = uuid;
		}
		return (T) this;
	}

	public T setRegion(int regionId) {
		this.regionId = regionId;
		return (T) this;
	}

	@Override
	public boolean equals(Object o) {
		if (o == this) {
			return true;
		}

		if (!(o instanceof Entity)) {
			return false;
		}

		Entity compare = (Entity) o;
		return this.uuid == compare.uuid;
	}

	public String getModelIDsString() {
		return Util.intArrayToString(modelIDs);
	}

	public String getRecolorFindString() {
		return Util.intArrayToString(recolorsToFind);
	}

	public String getRecolorReplaceString() {
		return Util.intArrayToString(recolorsToReplace);
	}

	private void removeOtherObjects() {
		Scene scene = plugin.client.getScene();
		Tile[][] tiles = scene.getTiles()[plugin.client.getPlane()];

		LocalPoint lp = LocalPoint.fromWorld(plugin.client, worldLocation);
		if (lp == null) {
			return;
		}
		Tile tile = tiles[lp.getSceneX()][lp.getSceneY()];
		if (tile == null) {
			return;
		}

		for (GameObject gameObject : tile.getGameObjects()) {
			if (gameObject == null) {
				continue;
			}
			if (gameObject.getId() == objectToRemove) {
				// Currently it's not possible to re-add the Game Object outside of an area load
				scene.removeGameObject(gameObject);
			}
		}

	}
}

