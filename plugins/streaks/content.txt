package com.streaks;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import java.awt.*;
import java.util.Random;

public class CelebrationOverlay extends Overlay
{
    private static final long DURATION_MS = 5000L;
    private static final int CONFETTI_COUNT = 800;

    private final StreaksPlugin plugin;
    private final Client client;
    
    @Inject
    private StreaksConfig config;

    @Inject
    public CelebrationOverlay(StreaksPlugin plugin, Client client)
    {
        this.plugin = plugin;
        this.client = client;

        setPosition(OverlayPosition.DYNAMIC);
        setMovable(true);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (!plugin.isCelebrationActive() || !config.showCelebrationOverlay())
        {
            return null;
        }

        long start = plugin.getCelebrateStartMillis();
        long now = System.currentTimeMillis();
        long elapsed = now - start;

        if (elapsed >= DURATION_MS)
        {
            plugin.clearCelebration();
            return null;
        }

        double t = elapsed / (double) DURATION_MS;
        float alpha = (float) (1.0 - t);
        alpha = alpha > 0.5f ? 1.0f : alpha;
        alpha = Math.max(0.0f, Math.min(1.0f, alpha));

        Composite oldComposite = g.getComposite();
        g.setComposite(AlphaComposite.SrcOver.derive(alpha));

        int canvasWidth = client.getCanvas().getWidth();
        int canvasHeight = client.getCanvas().getHeight();

        String skillName = StringUtils.capitalize(plugin.getCelebrateSkill().name().toLowerCase());
        String target = plugin.getCelebrateTarget();
        int value = plugin.getCelebrateValue();

        String line1 = "NEW BEST!";
        String line2 = skillName + " - " + target;
        String line3 = "Streak: " + value;

        Font baseFont = g.getFont();
        Font big = baseFont.deriveFont(Font.BOLD, 24f);
        Font mid = baseFont.deriveFont(Font.BOLD, 16f);
        Font small = baseFont.deriveFont(Font.PLAIN, 14f);

        FontMetrics fmBig = g.getFontMetrics(big);
        FontMetrics fmMid = g.getFontMetrics(mid);
        FontMetrics fmSmall = g.getFontMetrics(small);

        int width1 = fmBig.stringWidth(line1);
        int width2 = fmMid.stringWidth(line2);
        int width3 = fmSmall.stringWidth(line3);
        int maxWidth = Math.max(width1, Math.max(width2, width3)) + 40;

        int boxHeight = fmBig.getHeight() + fmMid.getHeight() + fmSmall.getHeight() + 30;

        int x = (canvasWidth - maxWidth) / 2;
        int y = canvasHeight / 5;
        
        int cx = x + maxWidth / 2;
        int ty = y + 10;

        // Confetti burst around the popup
        drawConfetti(g, canvasWidth, canvasHeight, cx, y + boxHeight / 2, elapsed);

        // Background box
        g.setColor(new Color(0, 0, 0, 190));
        g.fillRoundRect(x, y, maxWidth, boxHeight, 20, 20);

        // Gold border
        g.setStroke(new BasicStroke(2f));
        g.setColor(new Color(255, 215, 0, 230));
        g.drawRoundRect(x, y, maxWidth, boxHeight, 20, 20);

        // Text
        g.setColor(Color.WHITE);

        g.setFont(big);
        g.drawString(line1, cx - width1 / 2, ty + fmBig.getAscent());
        ty += fmBig.getHeight();

        g.setFont(mid);
        g.drawString(line2, cx - width2 / 2, ty + fmMid.getAscent());
        ty += fmMid.getHeight();

        g.setFont(small);
        g.drawString(line3, cx - width3 / 2, ty + fmSmall.getAscent());

        g.setComposite(oldComposite);
        return null;
    }

    private void drawConfetti(Graphics2D g, int canvasWidth, int canvasHeight, int centerX, int centerY, long elapsed)
    {
        double raw = elapsed / (double) DURATION_MS;
        raw = Math.max(0.0, Math.min(1.0, raw));
        double t = 1 - Math.pow(1 - raw, 5);

        Color[] colors = new Color[]{
                new Color(255, 99, 132),
                new Color(54, 162, 235),
                new Color(255, 206, 86),
                new Color(75, 192, 192),
                new Color(153, 102, 255),
                new Color(255, 159, 64)
        };

        long baseSeed = plugin.getCelebrateStartMillis();

        for (int i = 0; i < CONFETTI_COUNT; i++)
        {
            Random r = new Random(baseSeed + i * 31L);

            double angle = r.nextDouble() * 2.0 * Math.PI;        // full 360Â°
            double maxRadius = 240.0;
            double radius = (20 + r.nextDouble() * (maxRadius - 20)) * t;

            double px = centerX + Math.cos(angle) * radius * t;
            double py = centerY + Math.sin(angle) * radius * t;

            int size = 3 + r.nextInt(4);
            Color c = colors[r.nextInt(colors.length)];

            int drawX = (int) px;
            int drawY = (int) py;

            if (drawX < 0 || drawX > canvasWidth || drawY < 0 || drawY > canvasHeight)
            {
                continue;
            }

            g.setColor(c);
            g.fillRect(drawX, drawY, size, size);
        }
    }
}

package com.streaks;

import javax.swing.*;
import javax.swing.plaf.basic.BasicScrollBarUI;
import java.awt.*;

public class CustomScrollBarUI extends BasicScrollBarUI
{
    @Override
    protected void configureScrollBarColors()
    {
        this.thumbColor = new Color(180, 180, 180);
        this.trackColor = new Color(50, 50, 50);
    }

    @Override
    protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds)
    {
        if (!c.isEnabled()) return;

        Graphics2D g2 = (Graphics2D) g.create();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2.setColor(thumbColor);

        int arc = thumbBounds.width;
        g2.fillRoundRect(thumbBounds.x, thumbBounds.y, thumbBounds.width, thumbBounds.height, arc, arc);

        g2.dispose();
    }

    @Override
    protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds)
    {
        // Do nothing, make track invisible for a cleaner look
    }

    @Override
    protected JButton createDecreaseButton(int orientation)
    {
        return createZeroButton();
    }

    @Override
    protected JButton createIncreaseButton(int orientation)
    {
        return createZeroButton();
    }

    private JButton createZeroButton()
    {
        JButton btn = new JButton();
        btn.setPreferredSize(new Dimension(0, 0));
        btn.setMinimumSize(new Dimension(0, 0));
        btn.setMaximumSize(new Dimension(0, 0));
        return btn;
    }
}

/*
 * Copyright (c) 2017, Robin Weymans <Robin.weymans@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.streaks.hunter;

import java.time.Instant;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import com.streaks.StreakContext;
import com.streaks.StreaksPlugin.SkillType;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Player;
import net.runelite.api.Tile;
import net.runelite.api.coords.Angle;
import net.runelite.api.coords.Direction;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.gameval.ObjectID;
import net.runelite.client.eventbus.Subscribe;

public class HunterStreaks {

	private static final Map<Integer, String> TRAP_CREATURE_NAME_MAP = new HashMap<>();

	static
	{
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA, "Grey chinchompa");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA_BIG, "Red chinchompa");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA_BLACK, "Black chinchompa");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_BOXTRAP_FULL_FERRET, "Ferret");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_BOXTRAP_FULL_JERBOA, "Embertailed jerboa");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_SAPLING_FULL_GREEN, "Swamp lizard");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_SAPLING_FULL_RED, "Red salamander");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_SAPLING_FULL_ORANGE, "Orange salamander");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_SAPLING_FULL_BLACK, "Black salamander");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_SAPLING_FULL_MOUNTAIN, "Tecu salamander");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_OJIBWAY_TRAP_FULL_JUNGLE, "Crimson swift");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_OJIBWAY_TRAP_FULL_POLAR, "Cerulean twitch");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_OJIBWAY_TRAP_FULL_DESERT, "Golden warbler");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_OJIBWAY_TRAP_FULL_WOODLAND, "Copper longtail");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_OJIBWAY_TRAP_FULL_COLOURED, "Tropical wagtail");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_IMPTRAP_FULL, "Imp");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_DEADFALL_FULL_SPIKE, "Prickly kebbit");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_DEADFALL_FULL_SABRE, "Sabre-tooth kebbit");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_DEADFALL_FULL_BARBED, "Barb-tailed kebbit");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_DEADFALL_FULL_CLAW, "Wild kebbit");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_DEADFALL_FULL_FENNEC, "Pyre fox");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_MONKEYTRAP_FULL_0, "Maniacal monkey");
		TRAP_CREATURE_NAME_MAP.put(ObjectID.HUNTING_MONKEYTRAP_FULL_1, "Maniacal monkey");
	}

    @Getter
	private final Map<WorldPoint, HunterTrap> traps = new HashMap<>();

	private final StreakContext streakContext;
	private final Client client;

    private WorldPoint lastTickLocalPlayerLocation;

	public HunterStreaks(Client client, StreakContext streakContext) {
		this.client = client;
		this.streakContext = streakContext;
	}

    @Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		final GameObject gameObject = event.getGameObject();
		final WorldPoint trapLocation = gameObject.getWorldLocation();
		final HunterTrap myTrap = traps.get(trapLocation);
		final Player localPlayer = client.getLocalPlayer();

		switch (gameObject.getId())
		{
			/*
			 * ------------------------------------------------------------------------------
			 * Placing traps
			 * ------------------------------------------------------------------------------
			 */
			case ObjectID.HUNTING_DEADFALL_TRAP: // Deadfall trap placed
			case ObjectID.HUNTING_MONKEYTRAP_SET: // Maniacal monkey trap placed
				// If player is right next to "object" trap assume that player placed the trap
				if (localPlayer.getWorldLocation().distanceTo(trapLocation) <= 2)
				{
					traps.put(trapLocation, new HunterTrap(gameObject));
				}
				break;

			case ObjectID.HUNTING_IMPTRAP_EMPTY: // Imp box placed
			case ObjectID.HUNTING_BOXTRAP_EMPTY: // Box trap placed
			case ObjectID.HUNTING_OJIBWAY_TRAP: // Bird snare placed
				// If the player is on that tile, assume he is the one that placed the trap
				// Note that a player can move and set up a trap in the same tick, and this
				// event runs after the player movement has been updated, so we need to
				// compare to the trap location to the last location of the player.
				if (lastTickLocalPlayerLocation != null
					&& trapLocation.distanceTo(lastTickLocalPlayerLocation) == 0)
				{
					traps.put(trapLocation, new HunterTrap(gameObject));
				}
				break;

			case ObjectID.HUNTING_SAPLING_NET_SET_SWAMP: // Net trap placed at Green salamanders
			case ObjectID.HUNTING_SAPLING_NET_SET_ORANGE: // Net trap placed at Orange salamanders
			case ObjectID.HUNTING_SAPLING_NET_SET_RED: // Net trap placed at Red salamanders
			case ObjectID.HUNTING_SAPLING_NET_SET_BLACK: // Net trap placed at Black salamanders
			case ObjectID.HUNTING_SAPLING_NET_SET_MOUNTAIN: // Net trap placed at Tecu salamanders
				if (lastTickLocalPlayerLocation != null
						&& trapLocation.distanceTo(lastTickLocalPlayerLocation) == 0)
				{
					// Net traps facing to the north and east must have their tile translated.
					// As otherwise, the wrong tile is stored.
					Direction trapOrientation = new Angle(gameObject.getOrientation()).getNearestDirection();
					WorldPoint translatedTrapLocation = trapLocation;

					switch (trapOrientation)
					{
						case SOUTH:
							translatedTrapLocation = trapLocation.dy(-1);
							break;
						case WEST:
							translatedTrapLocation = trapLocation.dx(-1);
							break;
					}

					traps.put(translatedTrapLocation, new HunterTrap(gameObject));
				}
				break;

			/*
			 * ------------------------------------------------------------------------------
			 * Catching stuff
			 * ------------------------------------------------------------------------------
			 */
			case ObjectID.HUNTING_IMPTRAP_FULL: // Imp caught
			case ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA_BLACK: // Black chinchompa caught
			case ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA: // Grey chinchompa caught
			case ObjectID.HUNTING_BOXTRAP_FULL_CHINCHOMPA_BIG: // Red chinchompa caught
			case ObjectID.HUNTING_BOXTRAP_FULL_FERRET: // Ferret caught
			case ObjectID.HUNTING_BOXTRAP_FULL_JERBOA: // Embertailed jerboa caught
			case ObjectID.HUNTING_DEADFALL_FULL_SPIKE: // Prickly kebbit caught
			case ObjectID.HUNTING_DEADFALL_FULL_SABRE: // Sabre-tooth kebbit caught
			case ObjectID.HUNTING_DEADFALL_FULL_BARBED: // Barb-tailed kebbit caught
			case ObjectID.HUNTING_DEADFALL_FULL_CLAW: // Wild kebbit caught
			case ObjectID.HUNTING_DEADFALL_FULL_FENNEC: // Pyre fox caught
			case ObjectID.HUNTING_OJIBWAY_TRAP_FULL_JUNGLE: // Crimson swift caught
			case ObjectID.HUNTING_OJIBWAY_TRAP_FULL_POLAR: // Cerulean twitch caught
			case ObjectID.HUNTING_OJIBWAY_TRAP_FULL_DESERT: // Golden warbler caught
			case ObjectID.HUNTING_OJIBWAY_TRAP_FULL_WOODLAND: // Copper longtail caught
			case ObjectID.HUNTING_OJIBWAY_TRAP_FULL_COLOURED: // Tropical wagtail caught
			case ObjectID.HUNTING_SAPLING_FULL_GREEN: // Green salamander caught
			case ObjectID.HUNTING_SAPLING_FULL_RED: // Red salamander caught
			case ObjectID.HUNTING_SAPLING_FULL_ORANGE: // Orange salamander caught
			case ObjectID.HUNTING_SAPLING_FULL_BLACK: // Black salamander caught
			case ObjectID.HUNTING_SAPLING_FULL_MOUNTAIN: // Tecu salamander caught
			case ObjectID.HUNTING_MONKEYTRAP_FULL_0: // Maniacal monkey tail obtained
			case ObjectID.HUNTING_MONKEYTRAP_FULL_1: // Maniacal monkey tail obtained
				if (myTrap != null)
				{
					myTrap.setState(HunterTrap.State.FULL);
					myTrap.resetTimer();
					String creatureName = TRAP_CREATURE_NAME_MAP.getOrDefault(gameObject.getId(), null);
					if (creatureName != null)
					{
						streakContext.handleSkillSuccess(SkillType.HUNTER, creatureName);
					}
				}

				break;
			/*
			 * ------------------------------------------------------------------------------
			 * Failed catch
			 * ------------------------------------------------------------------------------
			 */
			case ObjectID.HUNTING_IMPTRAP_FAILED: //Empty imp box
			case ObjectID.HUNTING_BOXTRAP_FAILED: //Empty box trap
			case ObjectID.HUNTING_OJIBWAY_TRAP_BROKEN: //Empty box trap
			case ObjectID.HUNTING_DEADFALL_BOULDER: //Empty deadfall trap
			case ObjectID.HUNTING_SAPLING_FAILED_SWAMP: //Empty net trap
			case ObjectID.HUNTING_SAPLING_FAILED_RED: //Empty net trap
			case ObjectID.HUNTING_SAPLING_FAILED_ORANGE: //Empty net trap
			case ObjectID.HUNTING_SAPLING_FAILED_BLACK: //Empty net trap
			case ObjectID.HUNTING_SAPLING_FAILED_MOUNTAIN: //Empty net trap
				if (myTrap != null)
				{
					myTrap.setState(HunterTrap.State.EMPTY);
					myTrap.resetTimer();
					streakContext.handleSkillFailure(SkillType.HUNTER);
				}

				break;
		}
	}

	/**
	 * Iterates over all the traps that were placed by the local player and
	 * checks if the trap is still there. If the trap is gone, it removes
	 * the trap from the local players trap collection.
	 */
	@Subscribe
	public void onGameTick(GameTick event)
	{
		// Check if all traps are still there, and remove the ones that are not.
		Iterator<Map.Entry<WorldPoint, HunterTrap>> it = traps.entrySet().iterator();
		Tile[][][] tiles = client.getScene().getTiles();

		Instant expire = Instant.now().minus(HunterTrap.TRAP_TIME.multipliedBy(2));

		while (it.hasNext())
		{
			Map.Entry<WorldPoint, HunterTrap> entry = it.next();
			HunterTrap trap = entry.getValue();
			WorldPoint world = entry.getKey();
			LocalPoint local = LocalPoint.fromWorld(client, world);

			// Not within the client's viewport
			if (local == null)
			{
				// Cull very old traps
				if (trap.getPlacedOn().isBefore(expire))
				{
					it.remove();
					continue;
				}
				continue;
			}

			Tile tile = tiles[world.getPlane()][local.getSceneX()][local.getSceneY()];
			GameObject[] objects = tile.getGameObjects();

			boolean containsBoulder = false;
			boolean containsAnything = false;
			boolean containsYoungTree = false;
			for (GameObject object : objects)
			{
				if (object != null)
				{
					containsAnything = true;
					if (object.getId() == ObjectID.HUNTING_DEADFALL_BOULDER || object.getId() == ObjectID.HUNTING_MONKEYTRAP_UNSET)
					{
						containsBoulder = true;
						break;
					}

					// Check for young trees (used while catching salamanders) in the tile.
					// Otherwise, hunter timers will never disappear after a trap is dismantled
					if (object.getId() == ObjectID.HUNTING_SAPLING_UP_ORANGE || object.getId() == ObjectID.HUNTING_SAPLING_UP_RED ||
						object.getId() == ObjectID.HUNTING_SAPLING_UP_BLACK || object.getId() == ObjectID.HUNTING_SAPLING_UP_SWAMP ||
						object.getId() == ObjectID.HUNTING_SAPLING_UP_MOUNTAIN || object.getId() == ObjectID.HUNTING_SAPLING_SETTING_MOUNTAIN)
					{
						containsYoungTree = true;
					}
				}
			}

			if (!containsAnything || containsYoungTree)
			{
				it.remove();
			}
			else if (containsBoulder) // For traps like deadfalls. This is different because when the trap is gone, there is still a GameObject (boulder)
			{
				it.remove();
			}
		}

		lastTickLocalPlayerLocation = client.getLocalPlayer().getWorldLocation();
	}
}

/*
 * Copyright (c) 2017, Robin Weymans <Robin.weymans@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.streaks.hunter;

import java.time.Duration;
import java.time.Instant;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GameObject;
import net.runelite.api.coords.WorldPoint;

/**
 * Wrapper class for a GameObject that represents a hunter trap.
 */
class HunterTrap
{
	/**
	 * A hunter trap stays up 1 minute before collapsing.
	 */
	static final Duration TRAP_TIME = Duration.ofMinutes(1);

	/**
	 * The time in milliseconds when the trap was placed.
	 */
	@Getter
	private Instant placedOn;

	/**
	 * The state of the trap.
	 */
	@Getter
	@Setter
	private State state;

	/**
	 * The ID of the game object this is representing
	 */
	@Getter
	private final int objectId;

	@Getter
	private final WorldPoint worldLocation;

	/**
	 * The states a trap can be in.
	 */
	enum State
	{
		/**
		 * A laid out trap.
		 */
		OPEN,
		/**
		 * A trap that is empty.
		 */
		EMPTY,
		/**
		 * A trap that caught something.
		 */
		FULL,
		/**
		 * A trap that is closing.
		 */
		TRANSITION
	}

	/**
	 * Constructor for a HunterTrap object
	 *
	 * @param gameObject The gameobject thats corresponds with this trap.
	 */
	HunterTrap(GameObject gameObject)
	{
		this.state = State.OPEN;
		this.placedOn = Instant.now();
		this.objectId = gameObject.getId();
		this.worldLocation = gameObject.getWorldLocation();
	}

	/**
	 * Calculates how much time is left before the trap is collapsing.
	 *
	 * @return Value between 0 and 1. 0 means the trap was laid moments ago.
	 * 1 is a trap that's about to collapse.
	 */
	public double getTrapTimeRelative()
	{
		Duration duration = Duration.between(placedOn, Instant.now());
		return duration.compareTo(TRAP_TIME) < 0 ? (double) duration.toMillis() / TRAP_TIME.toMillis() : 1;
	}

	/**
	 * Resets the time value when the trap was placed.
	 */
	public void resetTimer()
	{
		placedOn = Instant.now();
	}
}
package com.streaks;

import java.util.Arrays;
import java.util.List;

import net.runelite.api.gameval.ItemID;

public enum PatchType
{
    HERB(
        "Herb patch",
        Arrays.asList(
            ItemID.UNIDENTIFIED_GUAM, 
            ItemID.UNIDENTIFIED_MARENTILL, 
            ItemID.UNIDENTIFIED_TARROMIN,
            ItemID.UNIDENTIFIED_HARRALANDER,
            ItemID.EADGAR_GOUTWEED_HERB,
            ItemID.UNIDENTIFIED_RANARR,
            ItemID.UNIDENTIFIED_TOADFLAX,
            ItemID.UNIDENTIFIED_IRIT,
            ItemID.UNIDENTIFIED_AVANTOE,
            ItemID.UNIDENTIFIED_KWUARM,
            ItemID.UNIDENTIFIED_SNAPDRAGON,
            ItemID.UNIDENTIFIED_HUASCA,
            ItemID.UNIDENTIFIED_CADANTINE,
            ItemID.UNIDENTIFIED_LANTADYME,
            ItemID.UNIDENTIFIED_DWARF_WEED,
            ItemID.UNIDENTIFIED_TORSTOL
        )
    ),
    HOPS(
        "Hops patch",
       Arrays.asList(
            ItemID.BARLEY,
            ItemID.HAMMERSTONE_HOPS,
            ItemID.ASGARNIAN_HOPS,
            ItemID.JUTE_FIBRE,
            ItemID.YANILLIAN_HOPS,
            ItemID.FLAX,
            ItemID.KRANDORIAN_HOPS,
            ItemID.WILDBLOOD_HOPS,
            ItemID.HEMP,
            ItemID.COTTON_BOLL
        )
    ),
    ALLOTMENT(
        "Allotment",
        Arrays.asList(
            ItemID.POTATO,
            ItemID.ONION,
            ItemID.CABBAGE,
            ItemID.TOMATO,
            ItemID.SWEETCORN,
            ItemID.STRAWBERRY,
            ItemID.WATERMELON,
            ItemID.SNAPE_GRASS
    ));

    public final String label;
    public final List<Integer> possibleItemIds;

    private PatchType(String label, List<Integer> possibleItemIds)
    {
        this.label = label;
        this.possibleItemIds = possibleItemIds;
    }
}

package com.streaks;

import com.streaks.StreaksPlugin.SkillType;

public interface StreakContext
{
    void handleSkillSuccess(SkillType skill, String target);
    void handleSkillFailure(SkillType skill);
    void handleSkillFailure(SkillType skill, String target);
}
package com.streaks;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("streaks")
public interface StreaksConfig extends Config
{
    @ConfigItem(
            keyName = "bestThievingStreaks",
            name = "Best Thieving streaks",
            description = "Serialized best thieving streaks map",
            hidden = true
    )
    default String bestThievingStreaks()
    {
        return "";
    }

    @ConfigItem(
            keyName = "bestFarmingStreaks",
            name = "Best Farming streaks",
            description = "Serialized best farming streaks map",
            hidden = true
    )
    default String bestFarmingStreaks()
    {
        return "";
    }

    @ConfigItem(
            keyName = "bestHunterStreaks",
            name = "Best Hunter streaks",
            description = "Serialized best hunter streaks map",
            hidden = true
    )
    default String bestHunterStreaks()
    {
        return "";
    }

    
    @ConfigItem(
        keyName = "showStreakOverlay",
        name = "Show current streak overlay",
        description = "Show the current streak overlay on screen"
    )
    default boolean showStreakOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showCelebrationOverlay",
        name = "Show celebration overlay",
        description = "Show the celebration overlay when you set a new best"
    )
    default boolean showCelebrationOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "takeScreenshotOnNewBest",
        name = "Take screenshot on new best",
        description = "If selected, take a new screenshot and save it to .runelite/streaks"
    )
    default boolean takeScreenshotOnNewBest()
    {
        return true;
    }
}

package com.streaks;

import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import java.awt.*;

public class StreaksOverlay extends OverlayPanel
{
    private final StreaksPlugin plugin;

    @Inject
    private StreaksConfig config;

    @Inject
    private StreaksOverlay(StreaksPlugin plugin)
    {
        this.plugin = plugin;
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {   
        if (!config.showStreakOverlay())
        {
            return null;
        }

        panelComponent.getChildren().clear();

        StreaksPlugin.SkillType skill = plugin.getActiveSkill();
        String target = plugin.getActiveTarget();
        int streak = plugin.getCurrentStreak();

        if (skill == null || target == null || streak <= 0)
        {
            return null;
        }

        String title = "Streak Tracker";
        String skillName = StringUtils.capitalize(skill.name().toLowerCase());
        String mainLeftText = skillName + " - " + target;
        String mainRightText = Integer.toString(streak);

        int best = plugin.getBestStreakFor(skill, target);
        String bestLeft  = "Best streak:";
        String bestRight = Integer.toString(best);

        double secondsRemaining = plugin.getSecondsRemainingInStreak();
        String timeLeftText = "Time until streak is over: ";
        String timeRightText = String.format("%.1fs", secondsRemaining);

        panelComponent.getChildren().add(
            TitleComponent.builder()
                .text(title)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(mainLeftText)
                .right(mainRightText)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(bestLeft)
                .right(bestRight)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(timeLeftText)
                .right(timeRightText)
                .build()
        );

        // Set dynamic width
        FontMetrics fm = graphics.getFontMetrics();
        int maxWidth = 0;
        maxWidth = Math.max(maxWidth, fm.stringWidth(title));
        maxWidth = Math.max(maxWidth, fm.stringWidth(mainLeftText + " " + mainRightText));
        if (!timeRightText.isEmpty())
        {
            maxWidth = Math.max(maxWidth, fm.stringWidth(timeLeftText + " " + timeRightText));
        }

        maxWidth += 20; // padding

        panelComponent.setPreferredSize(new Dimension(maxWidth, 0));

        return super.render(graphics);
    }
}

package com.streaks;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;

import org.apache.commons.lang3.StringUtils;

import com.streaks.StreaksPlugin.SkillType;

import java.awt.*;
import java.util.LinkedHashMap;
import java.util.Map;

public class StreaksPanel extends PluginPanel
{
    private final StreaksPlugin plugin;

    private final JLabel currentTargetValue = new JLabel("---");
    private final JLabel currentStreakValue = new JLabel("---");

    private Map<SkillType, JPanel> skillContainers = new LinkedHashMap<>();

    @Inject
    public StreaksPanel(StreaksPlugin plugin)
    {
        this.plugin = plugin;

        getScrollPane().setBorder(null);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // TOP: current streak info
        JPanel statsPanel = new JPanel(new GridBagLayout());
        statsPanel.setOpaque(false);

        GridBagConstraints c = new GridBagConstraints();
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.anchor = GridBagConstraints.CENTER;
        c.fill = GridBagConstraints.NONE;
        c.insets = new Insets(0, 0, 4, 0);

        JLabel title = createTitleLabel("Streak Tracker");
        statsPanel.add(title, c);

        c.gridy++;
        c.insets = new Insets(0, 0, 8, 0);
        c.anchor = GridBagConstraints.NORTHWEST;
        c.fill = GridBagConstraints.HORIZONTAL;
        statsPanel.add(createSeparator(), c);

        c.gridy++;
        c.insets = new Insets(0, 0, 2, 0);
        statsPanel.add(createStatRow("Current:", currentTargetValue), c);

        c.gridy++;
        statsPanel.add(createStatRow("Current streak:", currentStreakValue), c);

        add(statsPanel, BorderLayout.NORTH);

        // CENTER: collapsible skill sections
        JPanel sections = new JPanel();
        sections.setLayout(new BoxLayout(sections, BoxLayout.Y_AXIS));
        sections.setOpaque(false);

        skillContainers.put(SkillType.FARMING, new JPanel());
        skillContainers.put(SkillType.HUNTER, new JPanel());
        skillContainers.put(SkillType.THIEVING, new JPanel());

        for (Map.Entry<SkillType, JPanel> entry : skillContainers.entrySet()) {
            SkillType skill = entry.getKey();
            JPanel skillContainer = entry.getValue();
            String skillPrettyName = StringUtils.capitalize(skill.name().toLowerCase());
            sections.add(createSkillSection(skillPrettyName, skill, skillContainer));
            sections.add(Box.createVerticalStrut(8));
        }

        add(sections, BorderLayout.CENTER);

        // BOTTOM: reset-all button
        JButton resetAllButton = createResetAllButton();

        JPanel bottom = new JPanel(new FlowLayout(FlowLayout.CENTER));
        bottom.setOpaque(false);
        bottom.setBorder(BorderFactory.createEmptyBorder(8, 0, 0, 0));
        bottom.add(resetAllButton);

        add(bottom, BorderLayout.SOUTH);
    }

    private JLabel createTitleLabel(String text)
    {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        label.setFont(label.getFont().deriveFont(Font.BOLD, 14f));
        return label;
    }

    private JSeparator createSeparator()
    {
        JSeparator separator = new JSeparator();
        separator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        return separator;
    }

    private JPanel createStatRow(String labelText, JLabel valueLabel)
    {
        JPanel row = new JPanel(new BorderLayout());
        row.setOpaque(false);

        JLabel label = new JLabel(labelText);
        label.setForeground(Color.LIGHT_GRAY);

        valueLabel.setForeground(Color.WHITE);
        valueLabel.setHorizontalAlignment(SwingConstants.RIGHT);

        row.add(label, BorderLayout.WEST);
        row.add(valueLabel, BorderLayout.EAST);

        return row;
    }

    private JPanel createSkillSection(String title,
                                      SkillType skill,
                                      JPanel contentPanel)
    {
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setOpaque(false);

        JButton headerButton = new JButton();
        headerButton.setFocusable(false);
        headerButton.setContentAreaFilled(false);
        headerButton.setBorder(BorderFactory.createEmptyBorder(2, 0, 2, 0));
        headerButton.setHorizontalAlignment(SwingConstants.LEFT);
        headerButton.setForeground(Color.WHITE);
        headerButton.setFont(headerButton.getFont().deriveFont(Font.BOLD));

        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setPreferredSize(new Dimension(0, 120));
        scrollPane.getVerticalScrollBar().setUI(new CustomScrollBarUI());
        scrollPane.getVerticalScrollBar().setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(4, 0));
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        setSectionExpanded(headerButton, scrollPane, title, true);

        headerButton.addActionListener(e ->
        {
            boolean expanded = !scrollPane.isVisible();
            setSectionExpanded(headerButton, scrollPane, title, expanded);
            revalidate();
        });

        JPanel section = new JPanel(new BorderLayout());
        section.setOpaque(false);
        section.add(headerButton, BorderLayout.NORTH);
        section.add(scrollPane, BorderLayout.CENTER);

        return section;
    }

    private void setSectionExpanded(JButton headerButton, JScrollPane content, String title, boolean expanded)
    {
        content.setVisible(expanded);
        headerButton.setText((expanded ? "â–¼ " : "â–º ") + title);
    }

    private JPanel createBestRow(SkillType skill, String key, int streak)
    {
        String prettyKey = StringUtils.capitalize(key);

        JPanel row = new JPanel(new BorderLayout());
        row.setOpaque(false);
        row.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));

        JLabel keyLabel = new JLabel(prettyKey + ":");
        keyLabel.setForeground(Color.LIGHT_GRAY);

        JLabel streakLabel = new JLabel(Integer.toString(streak));
        streakLabel.setForeground(Color.WHITE);
        streakLabel.setHorizontalAlignment(SwingConstants.RIGHT);

        JPanel textPanel = new JPanel(new BorderLayout());
        textPanel.setOpaque(false);
        textPanel.add(keyLabel, BorderLayout.WEST);
        textPanel.add(streakLabel, BorderLayout.EAST);

        JButton deleteButton = new JButton("ðŸ—‘");
        deleteButton.setMargin(new Insets(0, 4, 0, 4));
        deleteButton.setFocusable(false);
        deleteButton.setBorder(BorderFactory.createEmptyBorder());
        deleteButton.setContentAreaFilled(false);
        deleteButton.setOpaque(false);
        deleteButton.setToolTipText("Delete streak for " + prettyKey);

        Color normal = Color.LIGHT_GRAY;
        Color hover = Color.WHITE;
        deleteButton.setForeground(normal);

        deleteButton.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                deleteButton.setForeground(hover);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                deleteButton.setForeground(normal);
            }
        });

        deleteButton.addActionListener(e ->
        {
            int res = JOptionPane.showConfirmDialog(
                    this,
                    "Delete best streak for \"" + prettyKey + "\" (" +
                            StringUtils.capitalize(skill.name().toLowerCase()) + ")?",
                    "Confirm delete",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE
            );

            if (res == JOptionPane.YES_OPTION)
            {
                plugin.deleteStreak(skill, key);
            }
        });

        row.add(textPanel, BorderLayout.CENTER);
        row.add(deleteButton, BorderLayout.EAST);

        row.setMaximumSize(new Dimension(Integer.MAX_VALUE, row.getPreferredSize().height));

        return row;
    }

    private JButton createResetAllButton()
    {
        JButton resetAllButton = new JButton("Reset all");

        resetAllButton.setFocusable(false);
        resetAllButton.setToolTipText("Reset all saved best streaks");

        resetAllButton.setForeground(Color.WHITE);
        resetAllButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        resetAllButton.setOpaque(true);
        resetAllButton.setContentAreaFilled(true);
        resetAllButton.setBorder(BorderFactory.createEmptyBorder(4, 16, 4, 16));
        resetAllButton.setFocusPainted(false);

        resetAllButton.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                resetAllButton.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                resetAllButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });

        resetAllButton.addActionListener(e ->
        {
            int res = JOptionPane.showConfirmDialog(
                    this,
                    "Reset ALL saved best streaks for all skills?\nThis cannot be undone.",
                    "Confirm reset",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE
            );

            if (res == JOptionPane.YES_OPTION)
            {
                plugin.resetAllStreaks();
            }
        });

        return resetAllButton;
    }

    // Called by plugin

    public void updateCurrent(SkillType skill, String target, int streak)
    {
        if (skill == null || target == null || target.isEmpty() || streak <= 0)
        {
            currentTargetValue.setText("---");
            currentStreakValue.setText("---");
        }
        else
        {
            String skillName = StringUtils.capitalize(skill.name().toLowerCase());
            currentTargetValue.setText(skillName + " - " + target);
            currentStreakValue.setText(String.valueOf(streak));
        }
    }

    public void updateBest(SkillType skill, Map<String, Integer> best)
    {
        JPanel skillContainer = skillContainers.get(skill);
        updateSkillContainer(skill, skillContainer, best);
    }

    private void updateSkillContainer(SkillType skill,
                                      JPanel container,
                                      Map<String, Integer> best)
    {
        container.removeAll();

        if (best == null || best.isEmpty())
        {
            JLabel emptyLabel = new JLabel("No data yet");
            emptyLabel.setForeground(Color.GRAY);
            emptyLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JPanel wrapper = new JPanel(new BorderLayout());
            wrapper.setOpaque(false);
            wrapper.add(emptyLabel, BorderLayout.CENTER);

            wrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, wrapper.getPreferredSize().height));
            container.add(wrapper);
        }
        else
        {
            best.entrySet().stream()
                    .sorted((a, b) -> Integer.compare(b.getValue(), a.getValue()))
                    .forEach(e ->
                    {
                        JPanel row = createBestRow(skill, e.getKey(), e.getValue());
                        container.add(row);
                    });
        }

        container.revalidate();
        container.repaint();
    }
}

package com.streaks;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import com.streaks.hunter.HunterStreaks;

import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.DrawManager;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.api.ChatMessageType;
import net.runelite.client.util.Text;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.Item;
import net.runelite.client.game.ItemManager;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.GameTick;

import javax.imageio.ImageIO;
import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import java.awt.image.BufferedImage;
import java.io.File;
import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@PluginDescriptor(
        name = "Streak Tracker",
        description = "Tracks streaks for pickpocketing and farming harvests",
        tags = {"thieving", "farming", "hunter", "streak"}
)
public class StreaksPlugin extends Plugin implements StreakContext
{

    public enum SkillType
    {
        FARMING,
        HUNTER,
        THIEVING
    }

    private static final Pattern PICKPOCKET_SUCCESS =
        Pattern.compile("You pick the (.+?)'s pocket\\.");

    private static final Pattern PICKPOCKET_FAIL =
        Pattern.compile("You fail to pick the (.+?)'s pocket\\.");

    private static final Pattern FARMING_HARVEST =
        Pattern.compile("You (?:harvest|pick|carefully pick) (?:some |a )?(.+?)(?:\\.|$)");

    private static final Pattern FARMING_DEPLETED =
        Pattern.compile("The patch is now empty\\.|You have finished harvesting this patch\\.");

    private static final Pattern PATCH_START =
        Pattern.compile("You begin to harvest the ((herb|hops) patch|allotment)\\.", Pattern.CASE_INSENSITIVE);

    private static final Pattern PATCH_EMPTY =
        Pattern.compile("The ((herb|hops) patch|allotment) is now empty\\.", Pattern.CASE_INSENSITIVE);
    
    private static final Type MAP_TYPE = new TypeToken<Map<String, Integer>>() {}.getType();
    private static final int STREAK_TIMEOUT_TICKS = 50; // 30 seconds
    private static final File SCREENSHOT_DIR = new File(RuneLite.RUNELITE_DIR, "streaks");
    private static final DateTimeFormatter TIMESTAMP = DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm-ss");

    @Inject
    @Getter
    protected Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private Gson gson;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private StreaksOverlay streaksOverlay;

    @Inject
    private StreaksPanel panel;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private StreaksConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private CelebrationOverlay celebrationOverlay;

    @Inject
    private EventBus eventBus;

    @Inject
    private DrawManager drawManager;

    @Getter
    private SkillType activeSkill;

    @Getter
    private String activeTarget;

    @Getter
    private int currentStreak;

    @Getter
    private Map<SkillType, Map<String, Integer>> bestStreaks = new HashMap<>();

    @Getter
    private boolean celebrationActive = false;

    @Getter
    private long celebrateStartMillis;

    @Getter
    private SkillType celebrateSkill;

    @Getter
    private String celebrateTarget;

    @Getter
    private int celebrateValue;

    private HunterStreaks hunterStreaks;
    private NavigationButton navButton;
    private boolean patchHarvestActive = false;
    private PatchType currentPatchType = null;
    private int patchItemId = -1;
    private int lastFarmingXpTick = -1;
    private int streakTimeoutTick = -1;

    private final Map<Integer, Integer> lastInventory = new HashMap<>();

    public void clearCelebration()
    {
        celebrationActive = false;
    }

    @Provides
    StreaksConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(StreaksConfig.class);
    }

    @Override
    protected void startUp()
    {
        hunterStreaks = new HunterStreaks(client, this);
        eventBus.register(hunterStreaks);
        lastInventory.clear();
        patchHarvestActive = false;
        patchItemId = -1;
        lastFarmingXpTick = -1;
        currentPatchType = null;
        loadBestStreaks();
        overlayManager.add(streaksOverlay);
        overlayManager.add(celebrationOverlay);

        final BufferedImage icon = ImageUtil.loadImageResource(StreaksPlugin.class, "icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Streak Tracker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        panel.updateCurrent(null, "", 0);
        panel.updateBest(SkillType.THIEVING, bestStreaks.get(SkillType.THIEVING));
        panel.updateBest(SkillType.FARMING, bestStreaks.get(SkillType.FARMING));
        panel.updateBest(SkillType.HUNTER, bestStreaks.get(SkillType.HUNTER));
    }

    @Override
    protected void shutDown()
    {
        if (hunterStreaks != null)
        {
            eventBus.unregister(hunterStreaks);
            hunterStreaks = null;
        }
        finishCurrentStreak(); // commit current streak before shutdown
        overlayManager.remove(streaksOverlay);
        overlayManager.remove(celebrationOverlay);
        clearCelebration();

        if (navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        ChatMessageType type = event.getType();
        if (type != ChatMessageType.SPAM && type != ChatMessageType.GAMEMESSAGE)
        {
            return;
        }

        String message = Text.removeTags(event.getMessage());

        Matcher m;

        // Thieving
        m = PICKPOCKET_SUCCESS.matcher(message);
        if (m.matches())
        {
            String npc = m.group(1);
            handleSkillSuccess(SkillType.THIEVING, npc);
            return;
        }

        m = PICKPOCKET_FAIL.matcher(message);
        if (m.matches())
        {
            String npc = m.group(1);
            handleSkillFailure(SkillType.THIEVING, npc);
            return;
        }

        // Farming
        m = FARMING_HARVEST.matcher(message);
        if (m.matches())
        {
            String crop = m.group(1).trim();
            handleSkillSuccess(SkillType.FARMING, crop);
            return;
        }

        m = FARMING_DEPLETED.matcher(message);
        if (m.matches())
        {
            //TODO i think this is unused
            handleSkillFailure(SkillType.FARMING, activeTarget);
        }

        m = PATCH_START.matcher(message);
        if (m.matches())
        {
            String patchToken = m.group(1);
            startPatchHarvest(patchToken);
            return;
        }

        m = PATCH_EMPTY.matcher(message);
        if (m.matches())
        {
            // Invoke next tick so that we still count the final item obtained
            clientThread.invokeLater(this::endPatchHarvest);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        GameState state = event.getGameState();
        if (state == GameState.LOGIN_SCREEN || state == GameState.HOPPING || state == GameState.CONNECTION_LOST)
        {
            finishCurrentStreak();
            lastInventory.clear();
            patchHarvestActive = false;
            patchItemId = -1;
            lastFarmingXpTick = -1;
            currentPatchType = null;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!"streaks".equals(event.getGroup()))
        {
            return;
        }
    }

    @Override
    public void handleSkillSuccess(SkillType skill, String target)
    {
        if (activeSkill != skill || activeTarget == null || !activeTarget.equals(target))
        {
            finishCurrentStreak();
            activeSkill = skill;
            activeTarget = target;
            currentStreak = 0;
        }

        currentStreak++;
        resetStreakTimer();
        panel.updateCurrent(activeSkill, activeTarget, currentStreak);
    }

    @Override
    public void handleSkillFailure(SkillType skill)
    {
        handleSkillFailure(skill, activeTarget);
    }

    @Override
    public void handleSkillFailure(SkillType skill, String target)
    {
        if (activeSkill == skill && activeTarget != null && activeTarget.equals(target))
        {
            finishCurrentStreak();
        }
    }

    private void startPatchHarvest(String patchToken)
    {
        // If weâ€™re already harvesting herbs on this patch, do nothing
        if (patchHarvestActive && activeSkill == SkillType.FARMING)
        {
            return;
        }
        patchHarvestActive = true;

        finishCurrentStreak();

        activeSkill = SkillType.FARMING;
        activeTarget = null; // unknown until we see which item
        currentStreak = 0;

        patchItemId = -1;
        lastFarmingXpTick = -1;

        patchToken = patchToken.toLowerCase();
        if (patchToken.startsWith("herb"))
        {
            currentPatchType = PatchType.HERB;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
        else if (patchToken.startsWith("hops"))
        {
            currentPatchType = PatchType.HOPS;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
        else
        {
            currentPatchType = PatchType.ALLOTMENT;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
    }

    private void endPatchHarvest()
    {
        if (!patchHarvestActive)
        {
            return;
        }

        patchHarvestActive = false;
        patchItemId = -1;
        lastFarmingXpTick = -1;
        currentPatchType = null;
        finishCurrentStreak();
    }


    private void finishCurrentStreak()
    {
        if (activeSkill == null || activeTarget == null || currentStreak <= 0)
        {
            activeSkill = null;
            activeTarget = null;
            currentStreak = 0;
            panel.updateCurrent(null, "", 0);
            return;
        }

        int best = bestStreaks.get(activeSkill).getOrDefault(activeTarget, 0);
        if (currentStreak > best)
        {
            Map<String, Integer> bestStreaksForSkill = bestStreaks.get(activeSkill);
            bestStreaksForSkill.put(activeTarget, currentStreak);
            handleNewBestStreak(activeSkill, activeTarget, currentStreak);
            saveBestStreaks(activeSkill);
            panel.updateBest(activeSkill, bestStreaksForSkill);
        }

        activeSkill = null;
        activeTarget = null;
        currentStreak = 0;
        streakTimeoutTick = -1;
        panel.updateCurrent(null, "", 0);
    }

    private Map<String, Integer> loadMap(String json)
    {
        if (json == null || json.isEmpty())
        {
            return new HashMap<>();
    }

        try
        {
            Map<String, Integer> map = gson.fromJson(json, MAP_TYPE);
            return map != null ? map : new HashMap<>();
        }
        catch (Exception e)
        {
            return new HashMap<>();
        }
    }

    private void loadBestStreaks()
    {
        bestStreaks.put(SkillType.THIEVING, loadMap(config.bestThievingStreaks()));
        bestStreaks.put(SkillType.FARMING, loadMap(config.bestFarmingStreaks()));
        bestStreaks.put(SkillType.HUNTER, loadMap(config.bestHunterStreaks()));
    }

    private void saveBestStreaks(SkillType skill)
    {
        String json = gson.toJson(bestStreaks.get(skill));
        String prettySkillName = StringUtils.capitalize(skill.name().toLowerCase());
        String skillConfigKey = String.format("best%sStreaks", prettySkillName);
        configManager.setConfiguration("streaks", skillConfigKey, json);
    }

    public void deleteStreak(SkillType skill, String key)
    {
        if (skill == null || key == null)
        {
            return;
        }

        Map<String, Integer> bestStreakForSkill = bestStreaks.get(skill);
        if (bestStreakForSkill.remove(key) != null)
        {
            saveBestStreaks(skill);
            panel.updateBest(skill, bestStreakForSkill);
        }
    }

    public void resetAllStreaks()
    {
        bestStreaks.clear();
        saveBestStreaks(SkillType.THIEVING);
        saveBestStreaks(SkillType.FARMING);
        saveBestStreaks(SkillType.HUNTER);

        activeSkill = null;
        activeTarget = null;
        currentStreak = 0;

        panel.updateCurrent(null, "", 0);
        panel.updateBest(SkillType.THIEVING, bestStreaks.get(SkillType.THIEVING));
        panel.updateBest(SkillType.FARMING, bestStreaks.get(SkillType.FARMING));
        panel.updateBest(SkillType.HUNTER, bestStreaks.get(SkillType.HUNTER));
    }

    public int getBestStreakFor(SkillType skill, String target)
    {
        if (skill == null || target == null)
        {
            return 0;
        }

        return bestStreaks.get(skill).getOrDefault(target, 0);
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (event.getContainerId() != InventoryID.INVENTORY.getId())
        {
            return;
        }

        ItemContainer container = event.getItemContainer();
        if (container == null)
        {
            return;
        }

        // Build current inventory counts
        Map<Integer, Integer> current = new HashMap<>();
        for (Item item : container.getItems())
        {
            if (item == null || item.getId() <= 0)
            {
                continue;
            }
            current.merge(item.getId(), item.getQuantity(), Integer::sum);
        }

        // Handle gathering resources from patches
        if (patchHarvestActive
            && activeSkill == SkillType.FARMING
            && client.getTickCount() == lastFarmingXpTick
            && currentPatchType != null)
        {
            for (Map.Entry<Integer, Integer> entry : current.entrySet())
            {
                int id = entry.getKey();
                int newQty = entry.getValue();
                int oldQty = lastInventory.getOrDefault(id, 0);
                int delta = newQty - oldQty;

                if (delta <= 0)
                {
                    continue;
                }

                // If we don't yet know which item this patch is, try to identify it
                if (patchItemId == -1)
                {
                    String name = itemManager.getItemComposition(id).getName();

                    if (currentPatchType.possibleItemIds.contains(id))
                    {
                        patchItemId = id;
                        activeTarget = name;
                    }
                }

                // Count only the chosen item type
                if (id == patchItemId && patchItemId != -1)
                {
                    currentStreak += delta;
                    resetStreakTimer();
                    String label;
                    if (activeTarget != null && !activeTarget.isEmpty())
                    {
                        label = activeTarget;
                    }
                    else
                    {
                        label = currentPatchType.label;
                    }

                    panel.updateCurrent(activeSkill, label, currentStreak);
                }
            }
        }

        lastInventory.clear();
        lastInventory.putAll(current);
    }

    @Subscribe
    public void onStatChanged(StatChanged event)
    {
        if (event.getSkill() != Skill.FARMING)
        {
            return;
        }

        if (!patchHarvestActive || activeSkill != SkillType.FARMING)
        {
            return;
        }

        // Mark this tick as a "Farming XP tick" during an active herb harvest
        lastFarmingXpTick = client.getTickCount();
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (activeSkill == null)
        {
            return;
        }

        if (streakTimeoutTick > 0 && client.getTickCount() >= streakTimeoutTick)
        {
            // Timer expired â†’ streak ends
            finishCurrentStreak();
            streakTimeoutTick = -1;
        }
    }

    private void resetStreakTimer()
    {
        streakTimeoutTick = client.getTickCount() + STREAK_TIMEOUT_TICKS;
    }

    protected double getSecondsRemainingInStreak()
    {
        int tick = client.getTickCount();
        int until = streakTimeoutTick;
        double seconds = 0;
        if (until > 0)
        {
            int remainingTicks = until - tick;
            if (remainingTicks < 0)
            {
                remainingTicks = 0;
            }

            seconds = remainingTicks * 0.6; // 1 tick = 0.6s
        }

        return seconds;
    }

    private void triggerCelebration(SkillType skill, String target, int value)
    {
        celebrationActive = true;
        celebrateStartMillis = System.currentTimeMillis();
        celebrateSkill = skill;
        celebrateTarget = target;
        celebrateValue = value;
    }

    private void handleNewBestStreak(SkillType skill, String target, int newBest)
    {
        triggerCelebration(skill, target, newBest);

        String skillName = skill == null ? "Unknown" : skill.name();
        takeNewBestScreenshot(skillName, target, newBest);
    }

    private void takeNewBestScreenshot(String skillName, String targetName, int streak)
    {
        if (!config.takeScreenshotOnNewBest())
        {
            return;
        }

        if (!SCREENSHOT_DIR.exists() && !SCREENSHOT_DIR.mkdirs())
        {
            return;
        }

        final String timestamp  = LocalDateTime.now().format(TIMESTAMP);
        final String fileName   = String.format(
            "%s_%s_%d_%s.png",
            skillName, targetName, streak, timestamp
        );

        final File outFile = new File(SCREENSHOT_DIR, fileName);

        drawManager.requestNextFrameListener(image ->
        {
            try
            {
                BufferedImage buffered = (BufferedImage) image;
                ImageIO.write(buffered, "png", outFile);
                client.addChatMessage(
                    ChatMessageType.GAMEMESSAGE,
                    "",
                    "Streaks: Screenshot saved to .runelite/streaks/" + outFile.getName(),
                    null
                );
            }
            catch (Exception e)
            {
                client.addChatMessage(
                    ChatMessageType.GAMEMESSAGE,
                    "",
                    "Streaks: Failed to save screenshot",
                    null
                );
            }
        });
    }


}

package com.streaks;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class StreakPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(StreaksPlugin.class);
		RuneLite.main(args);
	}
}
