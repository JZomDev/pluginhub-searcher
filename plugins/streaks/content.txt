package com.streaks;

import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

import javax.inject.Inject;
import javax.swing.*;

import org.apache.commons.lang3.StringUtils;

import java.awt.*;
import java.util.Map;

public class StreaksPanel extends PluginPanel
{
    private final StreaksPlugin plugin;

    private final JLabel currentTargetValue = new JLabel("---");
    private final JLabel currentStreakValue = new JLabel("---");

    private final JPanel thievingContainer = new JPanel();
    private final JPanel farmingContainer = new JPanel();

    @Inject
    public StreaksPanel(StreaksPlugin plugin)
    {
        this.plugin = plugin;

        getScrollPane().setBorder(null);

        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));

        // TOP: current streak info
        JPanel statsPanel = new JPanel(new GridBagLayout());
        statsPanel.setOpaque(false);

        GridBagConstraints c = new GridBagConstraints();
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.anchor = GridBagConstraints.CENTER;
        c.fill = GridBagConstraints.NONE;
        c.insets = new Insets(0, 0, 4, 0);

        JLabel title = createTitleLabel("Streak Tracker");
        statsPanel.add(title, c);

        c.gridy++;
        c.insets = new Insets(0, 0, 8, 0);
        c.anchor = GridBagConstraints.NORTHWEST;
        c.fill = GridBagConstraints.HORIZONTAL;
        statsPanel.add(createSeparator(), c);

        c.gridy++;
        c.insets = new Insets(0, 0, 2, 0);
        statsPanel.add(createStatRow("Current:", currentTargetValue), c);

        c.gridy++;
        statsPanel.add(createStatRow("Current streak:", currentStreakValue), c);

        add(statsPanel, BorderLayout.NORTH);

        // CENTER: collapsible skill sections
        JPanel sections = new JPanel();
        sections.setLayout(new BoxLayout(sections, BoxLayout.Y_AXIS));
        sections.setOpaque(false);

        sections.add(createSkillSection("Thieving", StreaksPlugin.SkillType.THIEVING, thievingContainer));
        sections.add(Box.createVerticalStrut(8));
        sections.add(createSkillSection("Farming", StreaksPlugin.SkillType.FARMING, farmingContainer));

        add(sections, BorderLayout.CENTER);

        // BOTTOM: reset-all button
        JButton resetAllButton = createResetAllButton();

        JPanel bottom = new JPanel(new FlowLayout(FlowLayout.CENTER));
        bottom.setOpaque(false);
        bottom.setBorder(BorderFactory.createEmptyBorder(8, 0, 0, 0));
        bottom.add(resetAllButton);

        add(bottom, BorderLayout.SOUTH);
    }

    private JLabel createTitleLabel(String text)
    {
        JLabel label = new JLabel(text);
        label.setForeground(Color.WHITE);
        label.setFont(label.getFont().deriveFont(Font.BOLD, 14f));
        return label;
    }

    private JSeparator createSeparator()
    {
        JSeparator separator = new JSeparator();
        separator.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        return separator;
    }

    private JPanel createStatRow(String labelText, JLabel valueLabel)
    {
        JPanel row = new JPanel(new BorderLayout());
        row.setOpaque(false);

        JLabel label = new JLabel(labelText);
        label.setForeground(Color.LIGHT_GRAY);

        valueLabel.setForeground(Color.WHITE);
        valueLabel.setHorizontalAlignment(SwingConstants.RIGHT);

        row.add(label, BorderLayout.WEST);
        row.add(valueLabel, BorderLayout.EAST);

        return row;
    }

    private JPanel createSkillSection(String title,
                                      StreaksPlugin.SkillType skill,
                                      JPanel contentPanel)
    {
        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
        contentPanel.setOpaque(false);

        JButton headerButton = new JButton();
        headerButton.setFocusable(false);
        headerButton.setContentAreaFilled(false);
        headerButton.setBorder(BorderFactory.createEmptyBorder(2, 0, 2, 0));
        headerButton.setHorizontalAlignment(SwingConstants.LEFT);
        headerButton.setForeground(Color.WHITE);
        headerButton.setFont(headerButton.getFont().deriveFont(Font.BOLD));

        JScrollPane scrollPane = new JScrollPane(contentPanel);
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setPreferredSize(new Dimension(0, 120));
        scrollPane.getVerticalScrollBar().setUI(new CustomScrollBarUI());
        scrollPane.getVerticalScrollBar().setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(4, 0));
        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

        setSectionExpanded(headerButton, scrollPane, title, true);

        headerButton.addActionListener(e ->
        {
            boolean expanded = !scrollPane.isVisible();
            setSectionExpanded(headerButton, scrollPane, title, expanded);
            revalidate();
        });

        JPanel section = new JPanel(new BorderLayout());
        section.setOpaque(false);
        section.add(headerButton, BorderLayout.NORTH);
        section.add(scrollPane, BorderLayout.CENTER);

        return section;
    }

    private void setSectionExpanded(JButton headerButton, JScrollPane content, String title, boolean expanded)
    {
        content.setVisible(expanded);
        headerButton.setText((expanded ? "â–¼ " : "â–º ") + title);
    }

    private JPanel createBestRow(StreaksPlugin.SkillType skill, String key, int streak)
    {
        String prettyKey = StringUtils.capitalize(key);

        JPanel row = new JPanel(new BorderLayout());
        row.setOpaque(false);
        row.setBorder(BorderFactory.createEmptyBorder(0, 2, 0, 2));

        JLabel keyLabel = new JLabel(prettyKey + ":");
        keyLabel.setForeground(Color.LIGHT_GRAY);

        JLabel streakLabel = new JLabel(Integer.toString(streak));
        streakLabel.setForeground(Color.WHITE);
        streakLabel.setHorizontalAlignment(SwingConstants.RIGHT);

        JPanel textPanel = new JPanel(new BorderLayout());
        textPanel.setOpaque(false);
        textPanel.add(keyLabel, BorderLayout.WEST);
        textPanel.add(streakLabel, BorderLayout.EAST);

        JButton deleteButton = new JButton("ðŸ—‘");
        deleteButton.setMargin(new Insets(0, 4, 0, 4));
        deleteButton.setFocusable(false);
        deleteButton.setBorder(BorderFactory.createEmptyBorder());
        deleteButton.setContentAreaFilled(false);
        deleteButton.setOpaque(false);
        deleteButton.setToolTipText("Delete streak for " + prettyKey);

        Color normal = Color.LIGHT_GRAY;
        Color hover = Color.WHITE;
        deleteButton.setForeground(normal);

        deleteButton.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                deleteButton.setForeground(hover);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                deleteButton.setForeground(normal);
            }
        });

        deleteButton.addActionListener(e ->
        {
            int res = JOptionPane.showConfirmDialog(
                    this,
                    "Delete best streak for \"" + prettyKey + "\" (" +
                            StringUtils.capitalize(skill.name().toLowerCase()) + ")?",
                    "Confirm delete",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE
            );

            if (res == JOptionPane.YES_OPTION)
            {
                plugin.deleteStreak(skill, key);
            }
        });

        row.add(textPanel, BorderLayout.CENTER);
        row.add(deleteButton, BorderLayout.EAST);

        row.setMaximumSize(new Dimension(Integer.MAX_VALUE, row.getPreferredSize().height));

        return row;
    }

    private JButton createResetAllButton()
    {
        JButton resetAllButton = new JButton("Reset all");

        resetAllButton.setFocusable(false);
        resetAllButton.setToolTipText("Reset all saved best streaks");

        resetAllButton.setForeground(Color.WHITE);
        resetAllButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        resetAllButton.setOpaque(true);
        resetAllButton.setContentAreaFilled(true);
        resetAllButton.setBorder(BorderFactory.createEmptyBorder(4, 16, 4, 16));
        resetAllButton.setFocusPainted(false);

        resetAllButton.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                resetAllButton.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                resetAllButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });

        resetAllButton.addActionListener(e ->
        {
            int res = JOptionPane.showConfirmDialog(
                    this,
                    "Reset ALL saved best streaks for all skills?\nThis cannot be undone.",
                    "Confirm reset",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.WARNING_MESSAGE
            );

            if (res == JOptionPane.YES_OPTION)
            {
                plugin.resetAllStreaks();
            }
        });

        return resetAllButton;
    }

    // Called by plugin

    public void updateCurrent(StreaksPlugin.SkillType skill, String target, int streak)
    {
        if (skill == null || target == null || target.isEmpty() || streak <= 0)
        {
            currentTargetValue.setText("---");
            currentStreakValue.setText("---");
        }
        else
        {
            String skillName = StringUtils.capitalize(skill.name().toLowerCase());
            currentTargetValue.setText(skillName + " - " + target);
            currentStreakValue.setText(String.valueOf(streak));
        }
    }

    public void updateThievingBest(Map<String, Integer> best)
    {
        updateSkillContainer(StreaksPlugin.SkillType.THIEVING, thievingContainer, best);
    }

    public void updateFarmingBest(Map<String, Integer> best)
    {
        updateSkillContainer(StreaksPlugin.SkillType.FARMING, farmingContainer, best);
    }

    private void updateSkillContainer(StreaksPlugin.SkillType skill,
                                      JPanel container,
                                      Map<String, Integer> best)
    {
        container.removeAll();

        if (best == null || best.isEmpty())
        {
            JLabel emptyLabel = new JLabel("No data yet");
            emptyLabel.setForeground(Color.GRAY);
            emptyLabel.setHorizontalAlignment(SwingConstants.CENTER);

            JPanel wrapper = new JPanel(new BorderLayout());
            wrapper.setOpaque(false);
            wrapper.add(emptyLabel, BorderLayout.CENTER);

            wrapper.setMaximumSize(new Dimension(Integer.MAX_VALUE, wrapper.getPreferredSize().height));
            container.add(wrapper);
        }
        else
        {
            best.entrySet().stream()
                    .sorted((a, b) -> Integer.compare(b.getValue(), a.getValue()))
                    .forEach(e ->
                    {
                        JPanel row = createBestRow(skill, e.getKey(), e.getValue());
                        container.add(row);
                    });
        }

        container.revalidate();
        container.repaint();
    }
}

package com.streaks;

import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import java.awt.*;

public class StreaksOverlay extends OverlayPanel
{
    private final StreaksPlugin plugin;

    @Inject
    private StreaksOverlay(StreaksPlugin plugin)
    {
        this.plugin = plugin;
        setPosition(OverlayPosition.TOP_LEFT);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        panelComponent.getChildren().clear();

        StreaksPlugin.SkillType skill = plugin.getActiveSkill();
        String target = plugin.getActiveTarget();
        int streak = plugin.getCurrentStreak();

        if (skill == null || target == null || streak <= 0)
        {
            return null;
        }

        String title = "Streak Tracker";
        String skillName = StringUtils.capitalize(skill.name().toLowerCase());
        String mainLeftText = skillName + " - " + target;
        String mainRightText = Integer.toString(streak);

        int best = plugin.getBestStreakFor(skill, target);
        String bestLeft  = "Best streak:";
        String bestRight = Integer.toString(best);

        double secondsRemaining = plugin.getSecondsRemainingInStreak();
        String timeLeftText = "Time until streak is over: ";
        String timeRightText = String.format("%.1fs", secondsRemaining);

        panelComponent.getChildren().add(
            TitleComponent.builder()
                .text(title)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(mainLeftText)
                .right(mainRightText)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(bestLeft)
                .right(bestRight)
                .build()
        );

        panelComponent.getChildren().add(
            LineComponent.builder()
                .left(timeLeftText)
                .right(timeRightText)
                .build()
        );

        // Set dynamic width
        FontMetrics fm = graphics.getFontMetrics();
        int maxWidth = 0;
        maxWidth = Math.max(maxWidth, fm.stringWidth(title));
        maxWidth = Math.max(maxWidth, fm.stringWidth(mainLeftText + " " + mainRightText));
        if (!timeRightText.isEmpty())
        {
            maxWidth = Math.max(maxWidth, fm.stringWidth(timeLeftText + " " + timeRightText));
        }

        maxWidth += 20; // padding

        panelComponent.setPreferredSize(new Dimension(maxWidth, 0));

        return super.render(graphics);
    }
}

package com.streaks;

public enum PatchType
{
    HERB("Herb patch"),
    HOPS("Hops patch"),
    ALLOTMENT("Allotment");

    public final String label;

    private PatchType(String label)
    {
        this.label = label;
    }
}

package com.streaks;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.api.ChatMessageType;
import net.runelite.client.util.Text;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemContainer;
import net.runelite.api.Item;
import net.runelite.client.game.ItemManager;
import net.runelite.api.Skill;
import net.runelite.api.events.StatChanged;
import net.runelite.api.events.GameTick;

import javax.inject.Inject;
import java.awt.image.BufferedImage;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

@PluginDescriptor(
        name = "Streak Tracker",
        description = "Tracks streaks for pickpocketing and farming harvests",
        tags = {"thieving", "farming", "streak"}
)
public class StreaksPlugin extends Plugin
{

    public enum SkillType
    {
        THIEVING,
        FARMING
    }

    private static final Set<String> HOPS_ITEMS = new HashSet<>(Arrays.asList(
        "barley",
        "hammerstone hops",
        "asgarnian hops",
        "jute",
        "yanillian hops",
        "flax",
        "krandorian hops",
        "wildblood hops",
        "hemp",
        "cotton"
    ));

    private static final Set<String> ALLOTMENT_ITEMS = new HashSet<>(Arrays.asList(
        "potato",
        "onion",
        "cabbage",
        "tomato",
        "sweetcorn",
        "strawberry",
        "watermelon",
        "snape grass"
    ));

    private static final Pattern PICKPOCKET_SUCCESS =
            Pattern.compile("You pick the (.+?)'s pocket\\.");

    private static final Pattern PICKPOCKET_FAIL =
            Pattern.compile("You fail to pick the (.+?)'s pocket\\.");

    private static final Pattern FARMING_HARVEST =
            Pattern.compile("You (?:harvest|pick|carefully pick) (?:some |a )?(.+?)(?:\\.|$)");

    private static final Pattern FARMING_DEPLETED =
            Pattern.compile("The patch is now empty\\.|You have finished harvesting this patch\\.");

    private static final Pattern PATCH_START =
        Pattern.compile("You begin to harvest the ((herb|hops) patch|allotment)\\.", Pattern.CASE_INSENSITIVE);

    private static final Pattern PATCH_EMPTY =
        Pattern.compile("The ((herb|hops) patch|allotment) is now empty\\.", Pattern.CASE_INSENSITIVE);
    
    private static final Type MAP_TYPE = new TypeToken<Map<String, Integer>>() {}.getType();
    private static final int STREAK_TIMEOUT_TICKS = 50; // 30 seconds

    @Inject
    @Getter
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private Gson gson;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private StreaksOverlay streaksOverlay;

    @Inject
    private StreaksPanel panel;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private StreaksConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private ItemManager itemManager;

    @Inject
    private CelebrationOverlay celebrationOverlay;

    @Getter
    private SkillType activeSkill;

    @Getter
    private String activeTarget;

    @Getter
    private int currentStreak;

    @Getter
    private Map<String, Integer> bestThievingStreaks = new HashMap<>();

    @Getter
    private Map<String, Integer> bestFarmingStreaks = new HashMap<>();

    @Getter
    private boolean celebrationActive = false;

    @Getter
    private long celebrateStartMillis;

    @Getter
    private SkillType celebrateSkill;

    @Getter
    private String celebrateTarget;

    @Getter
    private int celebrateValue;

    private NavigationButton navButton;
    private boolean patchHarvestActive = false;
    private PatchType currentPatchType = null;
    private int patchItemId = -1;
    private int lastFarmingXpTick = -1;
    private int streakTimeoutTick = -1;

    private final Map<Integer, Integer> lastInventory = new HashMap<>();

    public void clearCelebration()
    {
        celebrationActive = false;
    }

    @Provides
    StreaksConfig provideConfig(ConfigManager configManager)
    {
        return configManager.getConfig(StreaksConfig.class);
    }

    @Override
    protected void startUp()
    {
        lastInventory.clear();
        patchHarvestActive = false;
        patchItemId = -1;
        lastFarmingXpTick = -1;
        currentPatchType = null;
        loadBestStreaks();

        if (config.showStreakOverlay())
        {
            overlayManager.add(streaksOverlay);
        }

        if (config.showCelebrationOverlay())
        {
            overlayManager.add(celebrationOverlay);
        }

        final BufferedImage icon = ImageUtil.loadImageResource(StreaksPlugin.class, "icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Streak Tracker")
                .icon(icon)
                .priority(5)
                .panel(panel)
                .build();

        clientToolbar.addNavigation(navButton);

        panel.updateCurrent(null, "", 0);
        panel.updateThievingBest(bestThievingStreaks);
        panel.updateFarmingBest(bestFarmingStreaks);
    }

    @Override
    protected void shutDown()
    {
        finishCurrentStreak(); // commit current streak before shutdown
        overlayManager.remove(streaksOverlay);
        overlayManager.remove(celebrationOverlay);
        clearCelebration();

        if (navButton != null)
        {
            clientToolbar.removeNavigation(navButton);
            navButton = null;
        }
    }

    @Subscribe
    public void onChatMessage(ChatMessage event)
    {
        ChatMessageType type = event.getType();
        if (type != ChatMessageType.SPAM && type != ChatMessageType.GAMEMESSAGE)
        {
            return;
        }

        String message = Text.removeTags(event.getMessage());

        Matcher m;

        // Thieving
        m = PICKPOCKET_SUCCESS.matcher(message);
        if (m.matches())
        {
            String npc = m.group(1);
            handleThievingSuccess(npc);
            return;
        }

        m = PICKPOCKET_FAIL.matcher(message);
        if (m.matches())
        {
            String npc = m.group(1);
            handleThievingFailure(npc);
            return;
        }

        // Farming
        m = FARMING_HARVEST.matcher(message);
        if (m.matches())
        {
            String crop = m.group(1).trim();
            handleFarmingHarvest(crop);
            return;
        }

        m = FARMING_DEPLETED.matcher(message);
        if (m.matches())
        {
            handleFarmingDepleted();
        }

        m = PATCH_START.matcher(message);
        if (m.matches())
        {
            String patchToken = m.group(1);
            startPatchHarvest(patchToken);
            return;
        }

        m = PATCH_EMPTY.matcher(message);
        if (m.matches())
        {
            // Invoke next tick so that we still count the final item obtained
            clientThread.invokeLater(this::endPatchHarvest);
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        GameState state = event.getGameState();
        if (state == GameState.LOGIN_SCREEN || state == GameState.HOPPING || state == GameState.CONNECTION_LOST)
        {
            finishCurrentStreak();
            lastInventory.clear();
            patchHarvestActive = false;
            patchItemId = -1;
            lastFarmingXpTick = -1;
            currentPatchType = null;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event)
    {
        if (!"streaks".equals(event.getGroup()))
        {
            return;
        }

        switch (event.getKey())
        {
            case "showStreakOverlay":
                if (config.showStreakOverlay())
                {
                    overlayManager.add(streaksOverlay);
                }
                else
                {
                    overlayManager.remove(streaksOverlay);
                }
                break;

            case "showCelebrationOverlay":
                if (config.showCelebrationOverlay())
                {
                    overlayManager.add(celebrationOverlay);
                }
                else
                {
                    overlayManager.remove(celebrationOverlay);
                }
                break;
        }
    }

    // TODO refactor with farming to make something generic
    private void handleThievingSuccess(String npc)
    {
        if (activeSkill != SkillType.THIEVING || activeTarget == null || !activeTarget.equals(npc))
        {
            finishCurrentStreak();
            activeSkill = SkillType.THIEVING;
            activeTarget = npc;
            currentStreak = 0;
        }

        currentStreak++;
        resetStreakTimer();
        panel.updateCurrent(activeSkill, activeTarget, currentStreak);
    }

    private void handleThievingFailure(String npc)
    {
        if (activeSkill == SkillType.THIEVING && activeTarget != null && activeTarget.equals(npc))
        {
            finishCurrentStreak();
        }
    }

    private void handleFarmingHarvest(String crop)
    {
        if (activeSkill != SkillType.FARMING || activeTarget == null || !activeTarget.equals(crop))
        {
            finishCurrentStreak();
            activeSkill = SkillType.FARMING;
            activeTarget = crop;
            currentStreak = 0;
        }

        currentStreak++;
        resetStreakTimer();
        panel.updateCurrent(activeSkill, activeTarget, currentStreak);
    }

    private void handleFarmingDepleted()
    {
        if (activeSkill == SkillType.FARMING)
        {
            finishCurrentStreak();
        }
    }

    private void startPatchHarvest(String patchToken)
    {
        // If weâ€™re already harvesting herbs on this patch, do nothing
        if (patchHarvestActive && activeSkill == SkillType.FARMING)
        {
            return;
        }

        finishCurrentStreak();

        activeSkill = SkillType.FARMING;
        activeTarget = null; // unknown until we see which item
        currentStreak = 0;

        patchHarvestActive = true;
        patchItemId = -1;
        lastFarmingXpTick = -1;

        patchToken = patchToken.toLowerCase();
        if (patchToken.startsWith("herb"))
        {
            currentPatchType = PatchType.HERB;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
        else if (patchToken.startsWith("hops"))
        {
            currentPatchType = PatchType.HOPS;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
        else
        {
            currentPatchType = PatchType.ALLOTMENT;
            panel.updateCurrent(activeSkill, currentPatchType.label, 0);
        }
    }

    private void endPatchHarvest()
    {
        if (!patchHarvestActive)
        {
            return;
        }

        patchHarvestActive = false;
        patchItemId = -1;
        lastFarmingXpTick = -1;
        currentPatchType = null;
        finishCurrentStreak();
    }


    private void finishCurrentStreak()
    {
        if (activeSkill == null || activeTarget == null || currentStreak <= 0)
        {
            activeSkill = null;
            activeTarget = null;
            currentStreak = 0;
            panel.updateCurrent(null, "", 0);
            return;
        }

        switch (activeSkill)
        {
            case THIEVING:
            {
                int best = bestThievingStreaks.getOrDefault(activeTarget, 0);
                if (currentStreak > best)
                {
                    bestThievingStreaks.put(activeTarget, currentStreak);
                    triggerCelebration(SkillType.THIEVING, activeTarget, currentStreak);
                    saveThievingBestStreaks();
                }
                panel.updateThievingBest(bestThievingStreaks);
                break;
            }
            case FARMING:
            {
                int best = bestFarmingStreaks.getOrDefault(activeTarget, 0);
                if (currentStreak > best)
                {
                    bestFarmingStreaks.put(activeTarget, currentStreak);
                    triggerCelebration(SkillType.FARMING, activeTarget, currentStreak);
                    saveFarmingBestStreaks();
                }
                panel.updateFarmingBest(bestFarmingStreaks);
                break;
            }
        }

        activeSkill = null;
        activeTarget = null;
        currentStreak = 0;
        streakTimeoutTick = -1;
        panel.updateCurrent(null, "", 0);
    }

    private Map<String, Integer> loadMap(String json)
    {
        if (json == null || json.isEmpty())
        {
            return new HashMap<>();
    }

        try
        {
            Map<String, Integer> map = gson.fromJson(json, MAP_TYPE);
            return map != null ? map : new HashMap<>();
        }
        catch (Exception e)
        {
            return new HashMap<>();
        }
    }

    private void loadBestStreaks()
    {
        bestThievingStreaks = loadMap(config.bestThievingStreaks());
        bestFarmingStreaks = loadMap(config.bestFarmingStreaks());
    }

    private void saveThievingBestStreaks()
    {
        String json = gson.toJson(bestThievingStreaks);
        configManager.setConfiguration("streaks", "bestThievingStreaks", json);
    }

    private void saveFarmingBestStreaks()
    {
        String json = gson.toJson(bestFarmingStreaks);
        configManager.setConfiguration("streaks", "bestFarmingStreaks", json);
    }

    public void deleteStreak(SkillType skill, String key)
    {
        if (skill == null || key == null)
        {
            return;
        }

        switch (skill)
        {
            case THIEVING:
                if (bestThievingStreaks.remove(key) != null)
                {
                    saveThievingBestStreaks();
                    panel.updateThievingBest(bestThievingStreaks);
                }
                break;
            case FARMING:
                if (bestFarmingStreaks.remove(key) != null)
                {
                    saveFarmingBestStreaks();
                    panel.updateFarmingBest(bestFarmingStreaks);
                }
                break;
        }
    }

    public void resetAllStreaks()
    {
        bestThievingStreaks.clear();
        bestFarmingStreaks.clear();
        saveThievingBestStreaks();
        saveFarmingBestStreaks();

        activeSkill = null;
        activeTarget = null;
        currentStreak = 0;

        panel.updateCurrent(null, "", 0);
        panel.updateThievingBest(bestThievingStreaks);
        panel.updateFarmingBest(bestFarmingStreaks);
    }

    public int getBestStreakFor(SkillType skill, String target)
    {
        if (skill == null || target == null)
        {
            return 0;
        }

        switch (skill)
        {
            case THIEVING:
                return bestThievingStreaks.getOrDefault(target, 0);
            case FARMING:
                return bestFarmingStreaks.getOrDefault(target, 0);
            default:
                return 0;
        }
    }

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (event.getContainerId() != InventoryID.INVENTORY.getId())
        {
            return;
        }

        ItemContainer container = event.getItemContainer();
        if (container == null)
        {
            return;
        }

        // Build current inventory counts
        Map<Integer, Integer> current = new HashMap<>();
        for (Item item : container.getItems())
        {
            if (item == null || item.getId() <= 0)
            {
                continue;
            }
            current.merge(item.getId(), item.getQuantity(), Integer::sum);
        }

        if (patchHarvestActive
            && activeSkill == SkillType.FARMING
            && client.getTickCount() == lastFarmingXpTick
            && currentPatchType != null)
        {
            for (Map.Entry<Integer, Integer> e : current.entrySet())
            {
                int id = e.getKey();
                int newQty = e.getValue();
                int oldQty = lastInventory.getOrDefault(id, 0);
                int delta = newQty - oldQty;

                if (delta <= 0)
                {
                    continue;
                }

                // If we don't yet know which iteme this patch is, try to identify it
                if (patchItemId == -1)
                {
                    String name = itemManager.getItemComposition(id).getName();
                    String lower = name.toLowerCase();

                    if (currentPatchType == PatchType.HERB)
                    {
                        if (lower.contains("grimy"))
                        {
                            patchItemId = id;
                            activeTarget = name;
                        }
                    }
                    else if (currentPatchType == PatchType.HOPS)
                    {
                        if (HOPS_ITEMS.contains(lower))
                        {
                            patchItemId = id;
                            activeTarget = name;
                        }
                    }
                    else if (currentPatchType == PatchType.ALLOTMENT)
                    {
                        if (ALLOTMENT_ITEMS.contains(lower))
                        {
                            patchItemId = id;
                            activeTarget = name;
                        }
                    }
                }

                // Count only the chosen herb type
                if (id == patchItemId && patchItemId != -1)
                {
                    currentStreak += delta;
                    resetStreakTimer();
                    String label;
                    if (activeTarget != null && !activeTarget.isEmpty())
                    {
                        label = activeTarget;
                    }
                    else
                    {
                        label = currentPatchType.label;
                    }

                    panel.updateCurrent(activeSkill, label, currentStreak);
                }
            }
        }

        lastInventory.clear();
        lastInventory.putAll(current);
    }

    @Subscribe
    public void onStatChanged(StatChanged event)
    {
        if (event.getSkill() != Skill.FARMING)
        {
            return;
        }

        if (!patchHarvestActive || activeSkill != SkillType.FARMING)
        {
            return;
        }

        // Mark this tick as a "Farming XP tick" during an active herb harvest
        lastFarmingXpTick = client.getTickCount();
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (activeSkill == null)
        {
            return;
        }

        if (streakTimeoutTick > 0 && client.getTickCount() >= streakTimeoutTick)
        {
            // Timer expired â†’ streak ends
            finishCurrentStreak();
            streakTimeoutTick = -1;
        }
    }

    private void resetStreakTimer()
    {
        streakTimeoutTick = client.getTickCount() + STREAK_TIMEOUT_TICKS;
    }

    protected double getSecondsRemainingInStreak()
    {
        int tick = client.getTickCount();
        int until = streakTimeoutTick;
        double seconds = 0;
        if (until > 0)
        {
            int remainingTicks = until - tick;
            if (remainingTicks < 0)
            {
                remainingTicks = 0;
            }

            seconds = remainingTicks * 0.6; // 1 tick = 0.6s
        }

        return seconds;
    }

    private void triggerCelebration(SkillType skill, String target, int value)
    {
        celebrationActive = true;
        celebrateStartMillis = System.currentTimeMillis();
        celebrateSkill = skill;
        celebrateTarget = target;
        celebrateValue = value;
    }


}

package com.streaks;

import net.runelite.api.Client;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;

import org.apache.commons.lang3.StringUtils;

import java.awt.*;
import java.util.Random;

public class CelebrationOverlay extends Overlay
{
    private static final long DURATION_MS = 5000L;
    private static final int CONFETTI_COUNT = 800;

    private final StreaksPlugin plugin;
    private final Client client;

    @Inject
    public CelebrationOverlay(StreaksPlugin plugin, Client client)
    {
        this.plugin = plugin;
        this.client = client;

        setPosition(OverlayPosition.DYNAMIC);
        setMovable(true);
        setLayer(OverlayLayer.ALWAYS_ON_TOP);
    }

    @Override
    public Dimension render(Graphics2D g)
    {
        if (!plugin.isCelebrationActive())
        {
            return null;
        }

        long start = plugin.getCelebrateStartMillis();
        long now = System.currentTimeMillis();
        long elapsed = now - start;

        if (elapsed >= DURATION_MS)
        {
            plugin.clearCelebration();
            return null;
        }

        double t = elapsed / (double) DURATION_MS;
        float alpha = (float) (1.0 - t);
        alpha = alpha > 0.5f ? 1.0f : alpha;
        alpha = Math.max(0.0f, Math.min(1.0f, alpha));

        Composite oldComposite = g.getComposite();
        g.setComposite(AlphaComposite.SrcOver.derive(alpha));

        int canvasWidth = client.getCanvas().getWidth();
        int canvasHeight = client.getCanvas().getHeight();

        String skillName = StringUtils.capitalize(plugin.getCelebrateSkill().name().toLowerCase());
        String target = plugin.getCelebrateTarget();
        int value = plugin.getCelebrateValue();

        String line1 = "NEW BEST!";
        String line2 = skillName + " - " + target;
        String line3 = "Streak: " + value;

        Font baseFont = g.getFont();
        Font big = baseFont.deriveFont(Font.BOLD, 24f);
        Font mid = baseFont.deriveFont(Font.BOLD, 16f);
        Font small = baseFont.deriveFont(Font.PLAIN, 14f);

        FontMetrics fmBig = g.getFontMetrics(big);
        FontMetrics fmMid = g.getFontMetrics(mid);
        FontMetrics fmSmall = g.getFontMetrics(small);

        int width1 = fmBig.stringWidth(line1);
        int width2 = fmMid.stringWidth(line2);
        int width3 = fmSmall.stringWidth(line3);
        int maxWidth = Math.max(width1, Math.max(width2, width3)) + 40;

        int boxHeight = fmBig.getHeight() + fmMid.getHeight() + fmSmall.getHeight() + 30;

        int x = (canvasWidth - maxWidth) / 2;
        int y = canvasHeight / 5;
        
        int cx = x + maxWidth / 2;
        int ty = y + 10;

        // Confetti burst around the popup
        drawConfetti(g, canvasWidth, canvasHeight, cx, y + boxHeight / 2, elapsed);

        // Background box
        g.setColor(new Color(0, 0, 0, 190));
        g.fillRoundRect(x, y, maxWidth, boxHeight, 20, 20);

        // Gold border
        g.setStroke(new BasicStroke(2f));
        g.setColor(new Color(255, 215, 0, 230));
        g.drawRoundRect(x, y, maxWidth, boxHeight, 20, 20);

        // Text
        g.setColor(Color.WHITE);

        g.setFont(big);
        g.drawString(line1, cx - width1 / 2, ty + fmBig.getAscent());
        ty += fmBig.getHeight();

        g.setFont(mid);
        g.drawString(line2, cx - width2 / 2, ty + fmMid.getAscent());
        ty += fmMid.getHeight();

        g.setFont(small);
        g.drawString(line3, cx - width3 / 2, ty + fmSmall.getAscent());

        g.setComposite(oldComposite);
        return null;
    }

    private void drawConfetti(Graphics2D g, int canvasWidth, int canvasHeight, int centerX, int centerY, long elapsed)
    {
        double raw = elapsed / (double) DURATION_MS;
        raw = Math.max(0.0, Math.min(1.0, raw));
        double t = 1 - Math.pow(1 - raw, 5);

        Color[] colors = new Color[]{
                new Color(255, 99, 132),
                new Color(54, 162, 235),
                new Color(255, 206, 86),
                new Color(75, 192, 192),
                new Color(153, 102, 255),
                new Color(255, 159, 64)
        };

        long baseSeed = plugin.getCelebrateStartMillis();

        for (int i = 0; i < CONFETTI_COUNT; i++)
        {
            Random r = new Random(baseSeed + i * 31L);

            double angle = r.nextDouble() * 2.0 * Math.PI;        // full 360Â°
            double maxRadius = 240.0;
            double radius = (20 + r.nextDouble() * (maxRadius - 20)) * t;

            double px = centerX + Math.cos(angle) * radius * t;
            double py = centerY + Math.sin(angle) * radius * t;

            int size = 3 + r.nextInt(4);
            Color c = colors[r.nextInt(colors.length)];

            int drawX = (int) px;
            int drawY = (int) py;

            if (drawX < 0 || drawX > canvasWidth || drawY < 0 || drawY > canvasHeight)
            {
                continue;
            }

            g.setColor(c);
            g.fillRect(drawX, drawY, size, size);
        }
    }
}

package com.streaks;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("streaks")
public interface StreaksConfig extends Config
{
    @ConfigItem(
            keyName = "bestThievingStreaks",
            name = "Best Thieving streaks",
            description = "Serialized best thieving streaks map",
            hidden = true
    )
    default String bestThievingStreaks()
    {
        return "";
    }

    @ConfigItem(
            keyName = "bestFarmingStreaks",
            name = "Best Farming streaks",
            description = "Serialized best farming streaks map",
            hidden = true
    )
    default String bestFarmingStreaks()
    {
        return "";
    }

    
    @ConfigItem(
        keyName = "showStreakOverlay",
        name = "Show current streak overlay",
        description = "Show the current streak overlay on screen"
    )
    default boolean showStreakOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = "showCelebrationOverlay",
        name = "Show celebration overlay",
        description = "Show the celebration overlay when you set a new best"
    )
    default boolean showCelebrationOverlay()
    {
        return true;
    }
}

package com.streaks;

import javax.swing.*;
import javax.swing.plaf.basic.BasicScrollBarUI;
import java.awt.*;

public class CustomScrollBarUI extends BasicScrollBarUI
{
    @Override
    protected void configureScrollBarColors()
    {
        this.thumbColor = new Color(180, 180, 180);
        this.trackColor = new Color(50, 50, 50);
    }

    @Override
    protected void paintThumb(Graphics g, JComponent c, Rectangle thumbBounds)
    {
        if (!c.isEnabled()) return;

        Graphics2D g2 = (Graphics2D) g.create();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2.setColor(thumbColor);

        int arc = thumbBounds.width;
        g2.fillRoundRect(thumbBounds.x, thumbBounds.y, thumbBounds.width, thumbBounds.height, arc, arc);

        g2.dispose();
    }

    @Override
    protected void paintTrack(Graphics g, JComponent c, Rectangle trackBounds)
    {
        // Do nothing, make track invisible for a cleaner look
    }

    @Override
    protected JButton createDecreaseButton(int orientation)
    {
        return createZeroButton();
    }

    @Override
    protected JButton createIncreaseButton(int orientation)
    {
        return createZeroButton();
    }

    private JButton createZeroButton()
    {
        JButton btn = new JButton();
        btn.setPreferredSize(new Dimension(0, 0));
        btn.setMinimumSize(new Dimension(0, 0));
        btn.setMaximumSize(new Dimension(0, 0));
        return btn;
    }
}

package com.streaks;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class StreakPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(StreaksPlugin.class);
		RuneLite.main(args);
	}
}
