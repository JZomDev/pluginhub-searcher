package mvdicarlo.crabmanmode;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

public class AzureTableApi {
    private final OkHttpClient httpClient;
    private final String sasUrl;
    private final Gson gson;
    private Integer pageSize;

    public AzureTableApi(String sasUrl, Gson gson, OkHttpClient httpClient) {
        this.httpClient = httpClient;
        this.sasUrl = sasUrl;
        this.gson = gson;
        this.pageSize = null; // No limit by default
    }

    /**
     * Sets the page size for list operations. Useful for testing pagination.
     * @param pageSize The maximum number of entities to return per page, or null for no limit
     */
    public void setPageSize(Integer pageSize) {
        this.pageSize = pageSize;
    }

    /**
     * Gets the current page size setting.
     * @return The page size, or null if no limit is set
     */
    public Integer getPageSize() {
        return pageSize;
    }

    private static class AzureTableResponse {
        List<Map<String, Object>> value;
    }

    private String buildUrl(String path, String queryParams) {
        String baseUrl = sasUrl.split("\\?")[0];
        String existingParams = sasUrl.split("\\?")[1];
        return baseUrl + path + "?" + existingParams + (queryParams.isEmpty() ? "" : "&" + queryParams);
    }

    private static class RequestResult {
        final String body;
        final String nextPartitionKey;
        final String nextRowKey;

        RequestResult(String body, String nextPartitionKey, String nextRowKey) {
            this.body = body;
            this.nextPartitionKey = nextPartitionKey;
            this.nextRowKey = nextRowKey;
        }

        boolean hasContinuation() {
            return nextPartitionKey != null && nextRowKey != null;
        }
    }

    private String sendRequest(Request request) throws Exception {
        return sendRequestWithContinuation(request).body;
    }

    private RequestResult sendRequestWithContinuation(Request request) throws Exception {
        try (Response response = httpClient.newCall(request).execute()) {
            if (response.isSuccessful()) {
                String body = response.body().string();
                String nextPartitionKey = response.header("x-ms-continuation-NextPartitionKey");
                String nextRowKey = response.header("x-ms-continuation-NextRowKey");
                return new RequestResult(body, nextPartitionKey, nextRowKey);
            } else {
                throw new Exception("Request failed: " + response.body().string());
            }
        }
    }

    private List<UnlockedItemEntity> parseJsonListResponse(String jsonResponse) {
        Type type = new TypeToken<AzureTableResponse>() {
        }.getType();
        AzureTableResponse response = gson.fromJson(jsonResponse, type);
        return response.value.stream()
                .map(UnlockedItemEntity::fromMap)
                .collect(Collectors.toList());
    }

    private UnlockedItemEntity parseJsonResponse(String jsonResponse) {
        Map<String, Object> map = gson.fromJson(jsonResponse, new TypeToken<Map<String, Object>>() {
        }.getType());
        return UnlockedItemEntity.fromMap(map);
    }

    public UnlockedItemEntity getEntity(String partitionKey, String rowKey) throws Exception {
        String url = buildUrl("(PartitionKey='" + partitionKey + "',RowKey='" + rowKey + "')", "");
        Request request = createRequestBuilder(url)
                .get()
                .build();
        String jsonResponse = sendRequest(request);
        UnlockedItemEntity entity = parseJsonResponse(jsonResponse);
        return entity;
    }

    public List<UnlockedItemEntity> listEntities(String query) throws Exception {
        List<UnlockedItemEntity> allEntities = new ArrayList<>();
        String nextPartitionKey = null;
        String nextRowKey = null;

        do {
            StringBuilder queryParams = new StringBuilder("$filter=" + query);
            if (pageSize != null) {
                queryParams.append("&$top=").append(pageSize);
            }
            if (nextPartitionKey != null && nextRowKey != null) {
                queryParams.append("&NextPartitionKey=").append(nextPartitionKey);
                queryParams.append("&NextRowKey=").append(nextRowKey);
            }

            String url = buildUrl("", queryParams.toString());
            Request request = createRequestBuilder(url)
                    .get()
                    .build();
            RequestResult result = sendRequestWithContinuation(request);
            allEntities.addAll(parseJsonListResponse(result.body));

            nextPartitionKey = result.nextPartitionKey;
            nextRowKey = result.nextRowKey;
        } while (nextPartitionKey != null && nextRowKey != null);

        return allEntities;
    }

    public List<UnlockedItemEntity> listEntities() throws Exception {
        List<UnlockedItemEntity> allEntities = new ArrayList<>();
        String nextPartitionKey = null;
        String nextRowKey = null;

        do {
            StringBuilder queryParams = new StringBuilder();
            if (pageSize != null) {
                queryParams.append("$top=").append(pageSize);
            }
            if (nextPartitionKey != null && nextRowKey != null) {
                if (queryParams.length() > 0) {
                    queryParams.append("&");
                }
                queryParams.append("NextPartitionKey=").append(nextPartitionKey);
                queryParams.append("&NextRowKey=").append(nextRowKey);
            }

            String url = buildUrl("", queryParams.toString());
            Request request = createRequestBuilder(url)
                    .get()
                    .build();
            RequestResult result = sendRequestWithContinuation(request);
            allEntities.addAll(parseJsonListResponse(result.body));

            nextPartitionKey = result.nextPartitionKey;
            nextRowKey = result.nextRowKey;
        } while (nextPartitionKey != null && nextRowKey != null);

        return allEntities;
    }

    public void deleteEntity(String partitionKey, String rowKey) throws Exception {
        String url = buildUrl("(PartitionKey='" + partitionKey + "',RowKey='" + rowKey + "')", "");
        Request request = createRequestBuilder(url)
                .delete()
                .header("If-Match", "*")
                .build();
        sendRequest(request);
    }

    public void insertEntity(UnlockedItemEntity entity) throws Exception {
        String url = buildUrl("", "");
        String jsonPayload = gson.toJson(entity.toMap());
        RequestBody body = RequestBody.create(MediaType.parse("application/json"), jsonPayload);
        Request request = createRequestBuilder(url)
                .post(body)
                .header("Content-Type", "application/json")
                .build();
        sendRequest(request);
    }

    private Request.Builder createRequestBuilder(String url) {
        return new Request.Builder()
                .url(url)
                .header("Accept", "application/json")
                .header("User-Agent", "CrabManModePlugin");
    }
}
package mvdicarlo.crabmanmode;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup(CrabmanModePlugin.CONFIG_GROUP)
public interface CrabmanModeConfig extends Config {
    @ConfigItem(keyName = "namesBronzeman", name = "Bronzeman Names", position = 1, description = "Configures names of bronzemen to highlight in chat. Format: (name), (name)")
    default String namesBronzeman() {
        return "";
    }

    @ConfigItem(keyName = "enableCrabman", name = "Enable group bronzeman for character name", position = 2, description = "Enables group bronzeman mode for provided character name.")
    default String enableCrabman() {
        return "";
    }

    @ConfigItem(secret = true, keyName = "databaseString", name = "Azure Storage Account SAS URL", position = 3, description = "The SAS Url string for your group storage account.")
    default String databaseString() {
        return "";
    }
}

/*
 * Copyright (c) 2019, CodePanter <https://github.com/codepanter>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package mvdicarlo.crabmanmode;

import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.ArrayList;
import java.util.List;

import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;

@Slf4j
public class CrabmanModeOverlay extends Overlay {

    private final Client client;
    private final CrabmanModePlugin plugin;

    private Integer currentUnlock;
    private long displayTime;
    private int displayY;

    private final List<Integer> itemUnlockList;

    @Inject
    private ItemManager itemManager;

    @Inject
    public CrabmanModeOverlay(Client client, CrabmanModePlugin plugin) {
        super(plugin);
        this.client = client;
        this.plugin = plugin;
        this.itemUnlockList = new ArrayList<>();
        setPosition(OverlayPosition.TOP_CENTER);
    }

    public void addItemUnlock(int itemId) {
        if (!itemUnlockList.contains(itemId))
            itemUnlockList.add(itemId);
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        if (client.getGameState() != GameState.LOGGED_IN || itemUnlockList.isEmpty()) {
            return null;
        }
        if (itemManager == null) {
            return null;
        }
        if (currentUnlock == null) {
            currentUnlock = itemUnlockList.get(0);
            displayTime = System.currentTimeMillis();
            displayY = -20;
            return null;
        }

        // Drawing unlock pop-up at the top of the screen.
        graphics.drawImage(plugin.getUnlockImage(), -62, displayY, null);
        graphics.drawImage(itemManager.getImage(currentUnlock, 1, false), -50, displayY + 7, null);
        if (displayY < 10) {
            displayY = displayY + 1;
        }

        if (System.currentTimeMillis() > displayTime + (5000)) {
            itemUnlockList.remove(currentUnlock);
            currentUnlock = null;
        }
        return null;
    }
}

package mvdicarlo.crabmanmode;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.game.chatbox.ChatboxPanelManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

@Singleton
@Slf4j
public class CrabmanModePanel extends PluginPanel {
    private static final int COLUMN_SIZE = 5;
    private static final int ICON_WIDTH = 36;
    private static final int ICON_HEIGHT = 32;

    @Inject
    CrabmanModePlugin plugin;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private ChatboxPanelManager chatboxPanelManager;

    JPanel itemsPanel;

    private List<ItemObject> allItems = new ArrayList<>();
    private String currentSearchText = "";
    private SortOption currentSortOption = SortOption.NEW_TO_OLD; // Default sort option

    CrabmanModePanel() {
        setLayout(new BorderLayout());
        setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel selectionPanel = new JPanel();
        selectionPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        selectionPanel.setBorder(new EmptyBorder(10, 0, 10, 0));
        selectionPanel.setLayout(new GridLayout(0, 1));

        // Sort label
        JLabel sortLabel = new JLabel();
        sortLabel.setText("Sort order: ");
        selectionPanel.add(sortLabel);

        // Sort dropdown field
        JComboBox sortDropDown = new JComboBox(SortOption.values());
        sortDropDown.setFocusable(false);
        sortDropDown.setRenderer(new SortOptionDropdownRenderer());
        sortDropDown.addActionListener(e -> {
            currentSortOption = (SortOption) sortDropDown.getSelectedItem();
            applyFiltersAndSort();
        });
        selectionPanel.add(sortDropDown);

        // Search label
        JLabel searchLabel = new JLabel();
        searchLabel.setText("Search filter: ");
        selectionPanel.add(searchLabel);

        // Search text field
        IconTextField searchBar = new IconTextField();
        searchBar.setIcon(IconTextField.Icon.SEARCH);
        searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);

        // Add document listener to filter as you type
        searchBar.getDocument().addDocumentListener(new DocumentListener() {
            @Override
            public void insertUpdate(DocumentEvent e) {
                filterItems(searchBar.getText());
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                filterItems(searchBar.getText());
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                filterItems(searchBar.getText());
            }
        });
        selectionPanel.add(searchBar);

        // Show untradeable items
        JCheckBox showUntradeableItems = new JCheckBox();
        showUntradeableItems.setFocusable(false);
        showUntradeableItems.setText("Show untradeable items");
        showUntradeableItems.setSelected(true);
        selectionPanel.add(showUntradeableItems);

        // Button to search bank
        JButton filterButton = new JButton();
        filterButton.addActionListener((actionEvent) -> {
            currentSearchText = searchBar.getText();
            clientThread.invokeLater(() -> plugin.unlockFilter(showUntradeableItems.isSelected(),
                    (SortOption) sortDropDown.getSelectedItem(), currentSearchText));
        });
        filterButton.setText("View Items");
        filterButton.setFocusable(false);
        selectionPanel.add(filterButton);

        add(selectionPanel, BorderLayout.NORTH);

        itemsPanel = new JPanel();
        itemsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemsPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
        itemsPanel.setLayout(new BoxLayout(itemsPanel, BoxLayout.Y_AXIS));

        add(itemsPanel);
    }

    public void displayItems(List<ItemObject> filteredItems) {
        this.allItems = new ArrayList<>(filteredItems);
        applyFiltersAndSort();
    }

    private void applyFiltersAndSort() {
        // Filter items based on search text
        List<ItemObject> filteredItems = allItems.stream()
                .filter(item -> currentSearchText.isEmpty() ||
                        item.getName().toLowerCase().contains(currentSearchText.toLowerCase()))
                .collect(Collectors.toList());

        // Sort items based on the selected sort option
        sortItems(filteredItems);

        // Update the display
        SwingUtilities.invokeLater(() -> updateItemsDisplay(filteredItems));
    }

    private void sortItems(List<ItemObject> items) {
        switch (currentSortOption) {
            case NEW_TO_OLD:
                // Sort by acquiredOn in descending order (newest first)
                items.sort((item1, item2) -> item2.getAcquiredOn().compareTo(item1.getAcquiredOn()));
                break;
            case OLD_TO_NEW:
                // Sort by acquiredOn in ascending order (oldest first)
                items.sort(Comparator.comparing(ItemObject::getAcquiredOn));
                break;
            case ALPHABETICAL_ASC:
                items.sort(Comparator.comparing(ItemObject::getName));
                break;
            case ALPHABETICAL_DESC:
                items.sort(Comparator.comparing(ItemObject::getName).reversed());
                break;
        }
    }

    private void filterItems(String searchText) {
        currentSearchText = searchText;
        applyFiltersAndSort();
    }

    private void updateItemsDisplay(List<ItemObject> items) {
        SwingUtil.fastRemoveAll(itemsPanel);

        if (!items.isEmpty()) {
            JPanel titlePanel = new JPanel();
            titlePanel.setLayout(new BorderLayout());

            JLabel titleLabel = new JLabel();
            titleLabel.setText("Group Bronzeman Unlocks: " + Integer.toString(items.size()));
            titleLabel.setHorizontalAlignment(SwingConstants.CENTER);

            titlePanel.add(titleLabel, BorderLayout.CENTER);
            itemsPanel.add(titlePanel);

            JPanel itemContainer = new JPanel();
            EmptyBorder itemBorder = new EmptyBorder(10, 10, 10, 10);

            itemContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);
            itemContainer.setBorder(itemBorder);
            itemContainer.setLayout(new GridLayout(0, COLUMN_SIZE, 1, 1));

            for (ItemObject item : items) {
                JPanel itemPanel = new JPanel();
                JLabel itemLabel = new JLabel();

                itemLabel.setHorizontalAlignment(SwingConstants.CENTER);
                itemLabel.setVerticalAlignment(SwingConstants.CENTER);
                item.getIcon().addTo(itemLabel);
                itemLabel.setSize(item.getIcon().getWidth(), item.getIcon().getHeight());
                itemLabel.setMaximumSize(new Dimension(ICON_WIDTH, ICON_HEIGHT));
                itemLabel.setToolTipText(item.getName());

                final JPopupMenu popupMenu = new JPopupMenu();
                popupMenu.setBorder(itemBorder);
                itemPanel.setComponentPopupMenu(popupMenu);

                final JMenuItem inspectButton = new JMenuItem("Inspect " + item.getName());
                inspectButton.addActionListener(e -> {
                    final ChatMessageBuilder examination = new ChatMessageBuilder()
                            .append(ChatColorType.NORMAL)
                            .append("This is an unlocked item called '" + item.getName() + "'.");

                    chatMessageManager.queue(QueuedMessage.builder()
                            .type(ChatMessageType.ITEM_EXAMINE)
                            .runeLiteFormattedMessage(examination.build())
                            .build());
                });
                popupMenu.add(inspectButton);

                final JMenuItem deleteButton = new JMenuItem("Remove " + item.getName());
                deleteButton.addActionListener(e -> {
                    if (plugin.isDeletionConfirmed("Do you want to re-lock: " + item.getName(), "Warning")) {
                        plugin.queueItemDelete(item.getId());
                        plugin.sendChatMessage("Item '" + item.getName() + "' is no longer unlocked.");
                        displayItems(new ArrayList<ItemObject>());
                    }
                });
                popupMenu.add(deleteButton);

                itemPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

                itemPanel.add(itemLabel);
                itemContainer.add(itemPanel);
            }
            if (items.size() % COLUMN_SIZE != 0) {
                for (int i = 0; i < COLUMN_SIZE - (items.size() % COLUMN_SIZE); i++) {
                    JPanel panel = new JPanel();
                    panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                    itemContainer.add(panel);
                }
            }

            itemsPanel.add(itemContainer);
        } else {
            displayMessage("No items found.");
        }

        repaint();
        revalidate();
    }

    public void displayMessage(final String message) {
        itemsPanel.removeAll();

        final JTextArea textArea = new JTextArea();
        textArea.setText(message);
        textArea.setLineWrap(true);
        textArea.setWrapStyleWord(true);
        textArea.setFocusable(false);
        textArea.setEditable(false);
        textArea.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemsPanel.add(textArea);

        repaint();
        revalidate();
    }

    /**
     * Display loading state message
     */
    public void displayLoadingState(mvdicarlo.crabmanmode.database.DatabaseState.State state) {
        String message;
        switch (state) {
            case NOT_INITIALIZED:
                message = "Database not initialized. Please configure your SAS Token.";
                break;
            case INITIALIZING:
                message = "Connecting to database...";
                break;
            case LOADING_DATA:
                message = "Loading unlocked items from database...";
                break;
            case READY:
                message = "Database ready! Use the 'View Items' button to see unlocked items.";
                break;
            case ERROR:
                message = "Failed to connect to database. Please check your SAS Token.";
                break;
            default:
                message = "Unknown database state.";
                break;
        }
        displayMessage(message);
    }

    private static class SortOptionDropdownRenderer extends DefaultListCellRenderer {
        public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected,
                boolean cellHasFocus) {
            value = ((SortOption) value).getDisplayName();
            return super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
        }
    }
}
/*
 * Original License
 * Copyright (c) 2019, CodePanter <https://github.com/codepanter>
 * Copyright (c) 2024, mvdicarlo <https://github.com/mvdicarlo>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package mvdicarlo.crabmanmode;

import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.inject.Inject;
import javax.swing.JOptionPane;

import com.google.common.collect.ImmutableSet;
import com.google.gson.Gson;
import com.google.inject.Provides;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import mvdicarlo.crabmanmode.database.DatabaseRepository;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ChatPlayer;
import net.runelite.api.Client;
import net.runelite.api.Friend;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.FriendsChatMember;
import net.runelite.api.GameState;
import net.runelite.api.IconID;
import net.runelite.api.IndexedSprite;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.MessageNode;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.NameableContainer;
import net.runelite.api.Player;
import net.runelite.api.WorldType;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.PlayerChanged;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatCommandManager;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import okhttp3.OkHttpClient;

@Slf4j
@PluginDescriptor(name = "Group Bronzeman Mode", description = "Modification of bronzeman mode plugin to support group bronzeman. Limits access to buying an item on the Grand Exchange until it is obtained otherwise.", tags = {
        "overlay", "bronzeman", "crabman", "group bronzeman" })
public class CrabmanModePlugin extends Plugin {
    static final String CONFIG_GROUP = "crabmanmode";
    private static final String GBM_UNLOCKS_STRING = "!gbmunlocks";
    private static final String GBM_COUNT_STRING = "!gbmcount";
    private static final String GBM_RECENT_STRING = "!gbmrecent";

    final int COLLECTION_LOG_GROUP_ID = 621;
    final int COMBAT_ACHIEVEMENT_BUTTON = 40697877;
    final int COLLECTION_VIEW_SCROLLBAR = 40697894;

    final int COLLECTION_VIEW_CATEGORIES_CONTAINER = 40697885;
    final int COLLECTION_VIEW_CATEGORIES_RECTANGLE = 40697890;
    final int COLLECTION_VIEW_CATEGORIES_TEXT = 40697891;
    final int COLLECTION_VIEW_CATEGORIES_SCROLLBAR = 40697886;

    final int MENU_INSPECT = 2;
    final int MENU_DELETE = 3;

    final int SELECTED_OPACITY = 200;
    final int UNSELECTED_OPACITY = 235;

    private static final int GE_SEARCH_BUILD_SCRIPT = 751;

    static final Set<Integer> OWNED_INVENTORY_IDS = ImmutableSet.of(
            0, // Reward from fishing trawler.
            93, // Standard player inventory.
            94, // Equipment inventory.
            95, // Bank inventory.
            141, // Barrows reward chest inventory.
            390, // Kingdom Of Miscellania reward inventory.
            581, // Chambers of Xeric chest inventory.
            612, // Theater of Blood reward chest inventory (Raids 2).
            626); // Seed vault located inside the Farming Guild.

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ItemManager itemManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private WorldService worldService;

    @Inject
    private ChatMessageManager chatMessageManager;

    @Inject
    private ChatCommandManager chatCommandManager;

    @Inject
    private CrabmanModeConfig config;

    @Inject
    private CrabmanModeOverlay CrabmanModeOverlay;

    @Inject
    private Gson gson;

    @Inject
    private OkHttpClient okHttpClient;

    @Getter
    private BufferedImage unlockImage = null;

    @Inject
    private ClientToolbar clientToolbar;

    private NavigationButton navButton;

    private static final String SCRIPT_EVENT_SET_CHATBOX_INPUT = "setChatboxInput";
    private List<String> namesBronzeman = new ArrayList<>();
    private String enabledCrabman = "";
    private int bronzemanIconOffset = -1; // offset for bronzeman icon
    private boolean onSeasonalWorld;

    private final DatabaseRepository databaseRepo = new DatabaseRepository();

    private CrabmanModePanel panel;

    @Provides
    CrabmanModeConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(CrabmanModeConfig.class);
    }

    @Override
    protected void startUp() throws Exception {
        super.startUp();
        onSeasonalWorld = false;
        databaseRepo.setGson(gson);
        databaseRepo.setHttpClient(okHttpClient);
        updateNamesBronzeman();
        updateAllowedCrabman();
        initializeDatabase();

        panel = injector.getInstance(CrabmanModePanel.class);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/bronzeman_icon.png");

        navButton = NavigationButton.builder()
                .tooltip("Group Bronzeman unlocks")
                .icon(icon)
                .panel(panel)
                .priority(6)
                .build();

        clientToolbar.addNavigation(navButton);
        loadResources();
        databaseRepo.addItemListener((items) -> onItemsUnlocked(items));

        // Add loading state listener to update UI when database state changes
        databaseRepo.addStateListener(this::onNewDatabaseStateChanged);

        overlayManager.add(CrabmanModeOverlay);
        chatCommandManager.registerCommand(GBM_UNLOCKS_STRING, this::OnUnlocksCountCommand);
        chatCommandManager.registerCommand(GBM_COUNT_STRING, this::OnUnlocksCountCommand);
        chatCommandManager.registerCommand(GBM_RECENT_STRING, this::OnRecentUnlocksCommand);

        clientThread.invoke(() -> {
            if (client.getGameState() == GameState.LOGGED_IN) {
                onSeasonalWorld = isSeasonalWorld(client.getWorld());
                // A player can not be a bronzeman on a seasonal world.
                if (!onSeasonalWorld) {
                    setChatboxName(getNameChatbox());
                }
            }
        });
    }

    @Override
    protected void shutDown() throws Exception {
        super.shutDown();
        databaseRepo.close();
        overlayManager.remove(CrabmanModeOverlay);
        chatCommandManager.unregisterCommand(GBM_UNLOCKS_STRING);
        chatCommandManager.unregisterCommand(GBM_COUNT_STRING);
        chatCommandManager.unregisterCommand(GBM_RECENT_STRING);
        clientToolbar.removeNavigation(navButton);
        clientThread.invoke(() -> {
            // Cleanup is not required after having played on a seasonal world.
            if (client.getGameState() == GameState.LOGGED_IN && !onSeasonalWorld) {
                setChatboxName(getNameDefault());
            }
        });
    }

    /** Loads players unlocks on login **/
    @Subscribe
    public void onGameStateChanged(GameStateChanged e) {
        if (e.getGameState() == GameState.LOGGED_IN) {
            unlockDefaultItems();
            loadResources();

            onSeasonalWorld = isSeasonalWorld(client.getWorld());
        }
        if (e.getGameState() == GameState.LOGIN_SCREEN) {
            databaseRepo.close();
        }
    }

    @Subscribe
    public void onPluginChanged(PluginChanged e) {
        if (e.getPlugin() == this && client.getGameState() == GameState.LOGGED_IN) {
            // setupUnlockHistory();
        }
    }

    /** Unlocks all new items that are currently not unlocked **/
    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged e) {
        if (OWNED_INVENTORY_IDS.contains(e.getContainerId())) {
            unlockItemContainerItems(e.getItemContainer());
        }
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event) {
        if (event.getScriptId() == GE_SEARCH_BUILD_SCRIPT) {
            killSearchResults();
        }
    }

    @Subscribe
    public void onScriptCallbackEvent(ScriptCallbackEvent scriptCallbackEvent) {
        if (scriptCallbackEvent.getEventName().equals(SCRIPT_EVENT_SET_CHATBOX_INPUT) && !onSeasonalWorld) {
            setChatboxName(getNameChatbox());
        }
    }

    @SuppressWarnings("incomplete-switch")
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        if (client.getGameState() != GameState.LOADING && client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        String name = Text.removeTags(chatMessage.getName());
        switch (chatMessage.getType()) {
            case PRIVATECHAT:
            case MODPRIVATECHAT:
                // Note this is unable to change icon on PMs if they are not a friend or in
                // friends chat
            case CLAN_CHAT:
            case CLAN_GUEST_CHAT:
            case FRIENDSCHAT:
                if (isChatPlayerOnNormalWorld(name) && isChatPlayerBronzeman(name)) {
                    addBronzemanIconToMessage(chatMessage);
                }
                break;
            case PUBLICCHAT:
            case MODCHAT:
                if (!onSeasonalWorld && isChatPlayerBronzeman(name)) {
                    addBronzemanIconToMessage(chatMessage);
                }
                break;
        }
    }

    @Subscribe
    public void onPlayerChanged(PlayerChanged event) {
        Player player = client.getLocalPlayer();
        if (player != null) {
            String username = player.getName();
            if (username == null || username.isEmpty()) {
                databaseRepo.close();
            } else if (!databaseRepo.getCurrentUser().equals(username) && username.equals(enabledCrabman)) {
                if (!databaseRepo.isReady()) {
                    log.info(username + " is a crabman. Initializing database.");
                    initializeDatabase();
                }
            } else if (!username.equals((enabledCrabman))) {
                log.debug("Username does not match crabman name");
                databaseRepo.close();
            }
        } else {
            databaseRepo.close();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (event.getGroup().equals(CONFIG_GROUP)) {
            if (event.getKey().equals("namesBronzeman")) {
                updateNamesBronzeman();
            } else if (event.getKey().equals("enableCrabman")) {
                updateAllowedCrabman();
            } else if (event.getKey().equals("databaseString") || event.getKey().equals("databaseTable")) {
                initializeDatabase();
            }
        }
    }

    private boolean isLoggedIntoCrabman() {
        Player player = client.getLocalPlayer();
        if (player == null) {
            return false;
        }

        String playerName = player.getName();
        if (playerName == null || playerName.isEmpty() || enabledCrabman == null || enabledCrabman.isEmpty()) {
            return false;
        }
        return playerName.equals(enabledCrabman);
    }

    public void unlockFilter(boolean showUntradeableItems, SortOption sortOption, String search) {
        List<ItemObject> filteredItems = new ArrayList<ItemObject>();

        Map<Integer, UnlockedItemEntity> unlockedItems = databaseRepo.getUnlockedItems();

        for (UnlockedItemEntity unlockedItem : unlockedItems.values()) {
            ItemComposition composition = client.getItemDefinition(unlockedItem.getItemId());

            boolean tradeable = composition.isTradeable();
            if (!showUntradeableItems && !tradeable)
                continue;

            String itemName = composition.getMembersName();
            if (!search.isEmpty() && !itemName.toLowerCase().contains(search))
                continue;

            AsyncBufferedImage icon = itemManager.getImage(unlockedItem.getItemId());

            ItemObject item = new ItemObject(unlockedItem.getItemId(), unlockedItem.getItemName(), tradeable,
                    unlockedItem.getAcquiredOn(), icon);
            filteredItems.add(item);
        }

        if (sortOption.name() == "NEW_TO_OLD") {
            Collections.reverse(filteredItems);
        }

        if (sortOption.name() == "ALPHABETICAL_ASC") {
            Collections.sort(filteredItems, new Comparator<ItemObject>() {
                @Override
                public int compare(ItemObject i1, ItemObject i2) {
                    return i1.getName().compareToIgnoreCase(i2.getName());
                }
            });
        }

        if (sortOption.name() == "ALPHABETICAL_DESC") {
            Collections.sort(filteredItems, new Comparator<ItemObject>() {
                @Override
                public int compare(ItemObject i1, ItemObject i2) {
                    return i2.getName().compareToIgnoreCase(i1.getName());
                }
            });
        }

        panel.displayItems(filteredItems); // Redraw the panel
    }

    /** Unlocks all items in the given item container. **/
    public void unlockItemContainerItems(ItemContainer itemContainer) {
        if (onSeasonalWorld) {
            return;
        }
        for (Item i : itemContainer.getItems()) {
            int itemId = i.getId();
            int realItemId = itemManager.canonicalize(itemId);
            ItemComposition itemComposition = itemManager.getItemComposition(itemId);
            int noteId = itemComposition.getNote();
            if (itemId != realItemId && noteId != 799)
                continue; // The 799 signifies that it is a noted item
            if (i.getId() <= 1)
                continue;
            if (i.getQuantity() <= 0)
                continue;

            // Let the repository handle duplicate checks - just attempt to unlock all items
            queueItemUnlock(realItemId, false);
        }
    }

    public void onItemsUnlocked(List<UnlockedItemEntity> unlockedItems) {
        if (!isLoggedIntoCrabman()) {
            return;
        }
        unlockedItems.forEach((unlockedItem) -> {
            CrabmanModeOverlay.addItemUnlock(unlockedItem.getItemId());
            sendChatMessage(unlockedItem.getAcquiredBy() + " has unlocked a new item: " + unlockedItem.getItemName()
                    + ".");
        });
    }

    /** Queues a new unlock to be properly displayed **/
    public void queueItemUnlock(int itemId, boolean skipChecks) {
        // Should only be used for Bonds and Gold
        if (!skipChecks) {
            if (!isLoggedIntoCrabman()) {
                return;
            }
            boolean tradeable = itemManager.getItemComposition(itemId).isTradeable();
            if (!tradeable) {
                log.info("Item is not tradeable: " + client.getItemDefinition(itemId).getName());
                return;
            }
        }

        if (databaseRepo.hasItem(itemId)) {
            return; // Item is already unlocked
        }

        UnlockedItemEntity unlockedItem = databaseRepo.createNewItem(itemId,
                client.getItemDefinition(itemId).getName());

        log.info("Unlocking item: " + unlockedItem.getItemName());

        databaseRepo.insertItem(unlockedItem)
                .whenComplete((result, throwable) -> {
                    if (throwable != null) {
                        log.error("Failed to unlock item: " + unlockedItem.getItemName(), throwable);
                        sendChatMessage(
                                "Failed to unlock item: " + unlockedItem.getItemName() + ". Check your SAS Token.");
                    } else {
                        log.debug("Successfully unlocked item: " + unlockedItem.getItemName());
                    }

                    // Update panel
                    if (panel != null) {
                        clientThread.invokeLater(() -> {
                            panel.displayItems(new ArrayList<ItemObject>());
                        });
                    }
                });
    }

    /** Unlocks default items like a bond to a newly made profile **/
    private void unlockDefaultItems() {
        queueItemUnlock(ItemID.COINS, true);
        queueItemUnlock(ItemID.OSRS_BOND, true);
    }

    public void sendChatMessage(String chatMessage) {
        final String message = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append(chatMessage)
                .build();

        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.CONSOLE)
                        .runeLiteFormattedMessage(message)
                        .build());
    }

    void killSearchResults() {
        Widget grandExchangeSearchResults = client.getWidget(InterfaceID.Chatbox.MES_LAYER_SCROLLCONTENTS);

        if (grandExchangeSearchResults == null) {
            return;
        }

        Widget[] children = grandExchangeSearchResults.getDynamicChildren();

        if (children == null || children.length < 2 || children.length % 3 != 0) {
            return;
        }
        for (int i = 0; i < children.length; i += 3) {
            Map<Integer, UnlockedItemEntity> unlockedItems = databaseRepo.getUnlockedItems();

            if (!unlockedItems.containsKey(children[i + 2].getItemId())) {
                children[i].setHidden(true);
                children[i + 1].setOpacity(70);
                children[i + 2].setOpacity(70);
            }
        }

        panel.displayItems(new ArrayList<ItemObject>()); // Redraw the panel
    }

    private void updateNamesBronzeman() {
        namesBronzeman = Text.fromCSV(config.namesBronzeman());
    }

    private void updateAllowedCrabman() {
        enabledCrabman = config.enableCrabman();
        // Note: Semi-unsafe to send null but since we don't use the event it should be
        // fine
        onPlayerChanged(null);
    }

    private void initializeDatabase() {
        if (config.databaseString().isEmpty()) {
            log.info("No SAS URL string provided.");
            databaseRepo.close();
            return;
        }
        log.info("Initializing connection");

        databaseRepo.setGson(gson);
        databaseRepo.setHttpClient(okHttpClient);

        if (client.getLocalPlayer() == null || client.getLocalPlayer().getName() == null) {
            log.error("Local player is not available, cannot initialize database repository");
            return;
        }

        databaseRepo.initialize(config.databaseString(), client.getLocalPlayer().getName())
                .whenComplete((result, throwable) -> {
                    if (throwable != null) {
                        log.error("Failed to initialize new database repository", throwable);
                        sendChatMessage("Failed to connect to database. Check your SAS Token.");
                    } else {
                        log.info("New database repository initialization completed successfully");
                    }

                    // Update panel regardless of success/failure
                    if (panel != null) {
                        clientThread.invokeLater(() -> {
                            panel.displayItems(new ArrayList<ItemObject>());
                        });
                    }
                });
    }

    /**
     * Called when new database state changes
     */
    private void onNewDatabaseStateChanged(mvdicarlo.crabmanmode.database.DatabaseState.State state) {
        log.debug("New database state changed to: {}", state);

        if (panel != null) {
            // Update panel based on loading state
            clientThread.invokeLater(() -> {
                panel.displayLoadingState(state);
            });

            if (state == mvdicarlo.crabmanmode.database.DatabaseState.State.ERROR) {
                sendChatMessage("Failed to connect to database. Check your SAS Token.");
            }
        }
    }

    /**
     * Adds the Bronzeman Icon in front of player names.
     *
     * @param chatMessage chat message to edit sender name on
     */
    private void addBronzemanIconToMessage(ChatMessage chatMessage) {
        String name = chatMessage.getName();
        if (!name.equals(Text.removeTags(name))) {
            // If the name has any tags, no bronzeman icon will be added.
            // This makes it so Iron men can't be flagged as bronzeman, but
            // currently also excludes mods.
            return;
        }

        final MessageNode messageNode = chatMessage.getMessageNode();
        messageNode.setName(getNameWithIcon(bronzemanIconOffset, name));

        client.refreshChat();
    }

    /**
     * Checks if the world is a Seasonal world (Like leagues and seasonal deadman).
     *
     * @param worldNumber number of the world to check.
     * @return boolean true/false if it is a seasonal world or not.
     */
    private boolean isSeasonalWorld(int worldNumber) {
        WorldResult worlds = worldService.getWorlds();
        if (worlds == null) {
            return false;
        }

        World world = worlds.findWorld(worldNumber);
        return world != null && world.getTypes().contains(WorldType.SEASONAL);
    }

    /**
     * Checks if the given message was sent by the player
     *
     * @param chatMessage number of the world to check.
     * @return boolean true/false if the message was sent by the player.
     */
    private boolean sentByPlayer(ChatMessage chatMessage) {
        MessageNode messageNode = chatMessage.getMessageNode();

        return Text.sanitize(messageNode.getName()).equals(Text.sanitize(client.getLocalPlayer().getName()));
    }

    /**
     * Update the player name in the chatbox input
     */
    private void setChatboxName(String name) {
        Widget chatboxInput = client.getWidget(InterfaceID.Chatbox.INPUT);
        if (chatboxInput != null) {
            String text = chatboxInput.getText();
            int idx = text.indexOf(':');
            if (idx != -1) {
                String newText = name + text.substring(idx);
                chatboxInput.setText(newText);
            }
        }
    }

    /**
     * Gets the bronzeman name, including possible icon, of the local player.
     *
     * @return String of icon + name
     */
    private String getNameChatbox() {
        Player player = client.getLocalPlayer();
        if (player != null) {
            Widget chatboxInput = client.getWidget(InterfaceID.Chatbox.INPUT);
            String namePlusChannel = player.getName();
            if (chatboxInput != null) {
                String text = chatboxInput.getText();
                int idx = text.indexOf(':');
                if (idx != -1) {
                    namePlusChannel = text.substring(0, idx);
                }
            }
            return getNameWithIcon(bronzemanIconOffset, namePlusChannel);
        }
        return null;
    }

    /**
     * Gets the default name, including possible icon, of the local player.
     *
     * @return String of icon + name
     */
    private String getNameDefault() {
        Player player = client.getLocalPlayer();
        if (player == null) {
            return null;
        }

        int iconIndex;
        int accountType = client.getVarbitValue(VarbitID.IRONMAN);
        switch (accountType) {
            case 1: // Ironman
                iconIndex = IconID.IRONMAN.getIndex();
                break;
            case 2: // Ultimate Ironman
                iconIndex = IconID.ULTIMATE_IRONMAN.getIndex();
                break;
            case 3: // Hardcore Ironman
                iconIndex = IconID.HARDCORE_IRONMAN.getIndex();
                break;
            default:
                return player.getName();
        }

        return getNameWithIcon(iconIndex, player.getName());
    }

    /**
     * Get a name formatted with icon
     *
     * @param iconIndex index of the icon
     * @param name      name of the player
     * @return String of icon + name
     */
    private static String getNameWithIcon(int iconIndex, String name) {
        String icon = "<img=" + iconIndex + ">";
        return icon + name;
    }

    /**
     * Gets a ChatPlayer object from a clean name by searching friends chat and
     * friends list.
     *
     * @param name name of player to find.
     * @return ChatPlayer if found, else null.
     */
    private ChatPlayer getChatPlayerFromName(String name) {
        // Search friends chat members first, because if a friend is in the friends chat
        // but their private
        // chat is 'off', then we won't know the world
        FriendsChatManager friendsChatManager = client.getFriendsChatManager();
        if (friendsChatManager != null) {
            FriendsChatMember friendsChatMember = friendsChatManager.findByName(name);
            if (friendsChatMember != null) {
                return friendsChatMember;
            }
        }

        NameableContainer<Friend> friendContainer = client.getFriendContainer();
        return friendContainer.findByName(name);
    }

    /**
     * Checks if a player name is a friend or friends chat member is a bronzeman.
     *
     * @param name name of player to check.
     * @return boolean true/false.
     */
    private boolean isChatPlayerBronzeman(String name) {
        return isChatPlayerOnNormalWorld(name)
                && (namesBronzeman.contains(name) || namesBronzeman.contains(name.replace('\u00A0', ' ')));
    }

    /**
     * Checks if a player name is a friend or friends chat member on a normal world.
     *
     * @param name name of player to check.
     * @return boolean true/false.
     */
    private boolean isChatPlayerOnNormalWorld(String name) {
        ChatPlayer player = getChatPlayerFromName(name);

        if (player == null) {
            return true;
        }

        int world = player.getWorld();
        return !isSeasonalWorld(world);
    }

    private void OnUnlocksCountCommand(ChatMessage chatMessage, String message) {
        if (!sentByPlayer(chatMessage) || !isLoggedIntoCrabman()) {
            return;
        }

        Map<Integer, UnlockedItemEntity> unlockedItems = databaseRepo.getUnlockedItems();

        Collection<UnlockedItemEntity> unlocked = unlockedItems.values();
        long unlockedByMe = unlocked.stream()
                .filter((item) -> item.getAcquiredBy().equals(client.getLocalPlayer().getName())).count();

        final ChatMessageBuilder builder = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Your group has unlocked ")
                .append(ChatColorType.NORMAL)
                .append(Integer.toString(unlocked.size()))
                .append("(" + unlockedByMe + " / " + unlocked.size() + ")")
                .append(ChatColorType.HIGHLIGHT)
                .append(" items.");

        String response = builder.build();

        MessageNode messageNode = chatMessage.getMessageNode();
        messageNode.setRuneLiteFormatMessage(response);
        client.refreshChat();
    }

    private void OnRecentUnlocksCommand(ChatMessage chatMessage, String message) {
        if (!sentByPlayer(chatMessage) || !isLoggedIntoCrabman()) {
            return;
        }

        Map<Integer, UnlockedItemEntity> unlockedItems = databaseRepo.getUnlockedItems();

        Collection<UnlockedItemEntity> unlocked = unlockedItems.values();

        final ChatMessageBuilder builder = new ChatMessageBuilder()
                .append(ChatColorType.HIGHLIGHT)
                .append("Your group has recently unlocked: ")
                .append(ChatColorType.NORMAL)
                .append(unlocked.stream()
                        .sorted(Comparator.comparing(UnlockedItemEntity::getAcquiredOn).reversed())
                        .limit(5)
                        .map(UnlockedItemEntity::getItemName)
                        .collect(Collectors.joining(", ")));

        String response = builder.build();

        MessageNode messageNode = chatMessage.getMessageNode();
        messageNode.setRuneLiteFormatMessage(response);
        client.refreshChat();
    }

    /**
     * Loads the bronzeman resources into the client.
     */
    private void loadResources() {
        final IndexedSprite[] modIcons = client.getModIcons();

        if (bronzemanIconOffset != -1 || modIcons == null) {
            return;
        }

        unlockImage = ImageUtil.loadImageResource(getClass(), "/item-unlocked.png");
        BufferedImage image = ImageUtil.loadImageResource(getClass(), "/bronzeman_icon.png");
        IndexedSprite indexedSprite = ImageUtil.getImageIndexedSprite(image, client);

        bronzemanIconOffset = modIcons.length;

        final IndexedSprite[] newModIcons = Arrays.copyOf(modIcons, modIcons.length + 1);
        newModIcons[newModIcons.length - 1] = indexedSprite;

        client.setModIcons(newModIcons);
    }

    public boolean isDeletionConfirmed(final String message, final String title) {
        int confirm = JOptionPane.showConfirmDialog(panel,
                message, title, JOptionPane.OK_CANCEL_OPTION);

        return confirm == JOptionPane.YES_OPTION;
    }

    public void queueItemDelete(int id) {
        if (!isLoggedIntoCrabman()) {
            return;
        }

        // Get item info for user feedback before deletion
        Map<Integer, UnlockedItemEntity> unlockedItems = databaseRepo.getUnlockedItems();
        UnlockedItemEntity unlockedItem = unlockedItems.get(id);
        String itemName = (unlockedItem != null) ? unlockedItem.getItemName() : "Unknown Item (ID: " + id + ")";
        String acquiredBy = (unlockedItem != null) ? unlockedItem.getAcquiredBy() : "Unknown";

        // Let repository handle existence checks - attempt deletion regardless
        databaseRepo.deleteItem(id)
                .whenComplete((result, throwable) -> {
                    if (throwable != null) {
                        log.error("Failed to delete item: " + id, throwable);
                        sendChatMessage("Failed to delete item: " + itemName + ".");
                    } else {
                        sendChatMessage(acquiredBy + " has re-locked item: " + itemName + ".");
                    }

                    // Update panel
                    if (panel != null) {
                        clientThread.invokeLater(() -> {
                            panel.displayItems(new ArrayList<ItemObject>());
                        });
                    }
                });
    }
}

package mvdicarlo.crabmanmode.database;

import java.util.Map;
import mvdicarlo.crabmanmode.AzureTableApi;
import mvdicarlo.crabmanmode.UnlockedItemEntity;

/**
 * Context provided to actions during execution.
 * Contains all the resources and state needed to execute database operations.
 */
public class ActionExecutionContext {

    private final AzureTableApi api;
    private final Map<Integer, UnlockedItemEntity> localCache;
    private final String currentUser;
    private final boolean ready;

    public ActionExecutionContext(AzureTableApi api,
            Map<Integer, UnlockedItemEntity> localCache,
            String currentUser,
            boolean ready) {
        this.api = api;
        this.localCache = localCache;
        this.currentUser = currentUser;
        this.ready = ready;
    }

    /**
     * Get the Azure Table API instance
     */
    public AzureTableApi getApi() {
        return api;
    }

    /**
     * Get the local cache of unlocked items (thread-safe access required)
     */
    public Map<Integer, UnlockedItemEntity> getLocalCache() {
        return localCache;
    }

    /**
     * Get the current user name
     */
    public String getCurrentUser() {
        return currentUser;
    }

    /**
     * Check if the system is ready for database operations
     */
    public boolean isReady() {
        return ready && api != null && currentUser != null && !currentUser.isEmpty();
    }
}

package mvdicarlo.crabmanmode.database;

import java.util.concurrent.CompletableFuture;
import lombok.extern.slf4j.Slf4j;

/**
 * Base implementation for database actions providing common functionality.
 * 
 * @param <T> The return type of the action
 */
@Slf4j
public abstract class BaseDatabaseAction<T> implements DatabaseAction<T> {

    protected final CompletableFuture<T> promise = new CompletableFuture<>();

    @Override
    public CompletableFuture<T> getPromise() {
        return promise;
    }

    @Override
    public void completeExceptionally(Throwable throwable) {
        log.warn("Action {} failed: {}", getActionType(), throwable.getMessage());
        promise.completeExceptionally(throwable);
    }

    /**
     * Complete the action's promise with a successful result
     */
    protected void complete(T result) {
        log.debug("Action {} completed successfully", getActionType());
        promise.complete(result);
    }

    /**
     * Template method that handles the execution and promise completion.
     * Subclasses should override executeInternal() instead of execute().
     */
    @Override
    public final T execute(ActionExecutionContext context) throws Exception {
        try {
            log.debug("Executing action: {}", getDescription());
            T result = executeInternal(context);
            complete(result);
            return result;
        } catch (Exception e) {
            log.error("Failed to execute action {}: {}", getActionType(), e.getMessage(), e);
            throw e; // Let the queue handler deal with promise completion
        }
    }

    /**
     * Subclasses implement this method to perform the actual work
     */
    protected abstract T executeInternal(ActionExecutionContext context) throws Exception;
}

package mvdicarlo.crabmanmode.database;

import java.util.concurrent.CompletableFuture;

/**
 * Interface for database actions that can be queued and executed
 * asynchronously.
 * Each action encapsulates a specific database operation and returns a promise
 * that completes when the action is processed.
 * 
 * @param <T> The return type of the action
 */
public interface DatabaseAction<T> {

    /**
     * Get a human-readable type identifier for this action
     */
    String getActionType();

    /**
     * Get a description of what this action does (for logging/debugging)
     */
    String getDescription();

    /**
     * Execute the action with the provided context
     * 
     * @param context The execution context containing API, cache, etc.
     * @return The result of the action
     * @throws Exception if the action fails
     */
    T execute(ActionExecutionContext context) throws Exception;

    /**
     * Get the promise that will be completed when this action is processed
     */
    CompletableFuture<T> getPromise();

    /**
     * Complete the action's promise exceptionally
     */
    void completeExceptionally(Throwable throwable);

    /**
     * Check if this action can be executed in the current state
     */
    default boolean canExecute(ActionExecutionContext context) {
        return context.isReady();
    }

    /**
     * Get the priority of this action (higher = more important)
     * Default priority is 0 (normal)
     */
    default int getPriority() {
        return 0;
    }
}

package mvdicarlo.crabmanmode.database;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.Comparator;
import java.util.List;
import java.util.ArrayList;

import lombok.extern.slf4j.Slf4j;

/**
 * Queue processor that executes database actions sequentially with proper
 * ordering.
 * Actions are queued and processed in priority order (higher priority first).
 * Each action returns a CompletableFuture that completes when the action is
 * processed.
 */
@Slf4j
public class DatabaseActionQueue {
    private final ConcurrentLinkedQueue<DatabaseAction<?>> actionQueue = new ConcurrentLinkedQueue<>();
    private final ScheduledExecutorService executor;
    private final AtomicBoolean isProcessing = new AtomicBoolean(false);

    private volatile ActionExecutionContext executionContext;

    public DatabaseActionQueue() {
        this.executor = Executors.newSingleThreadScheduledExecutor(r -> {
            Thread t = new Thread(r, "DatabaseActionQueue");
            t.setDaemon(true);
            return t;
        });

        // Start the processing loop
        startProcessing();
    }

    /**
     * Submit an action to be executed asynchronously
     */
    public <T> CompletableFuture<T> submit(DatabaseAction<T> action) {
        log.debug("Queuing action: {}", action.getDescription());
        actionQueue.offer(action);

        // Trigger processing if not already running
        triggerProcessing();

        return action.getPromise();
    }

    /**
     * Update the execution context (called when database state changes)
     */
    public void updateExecutionContext(ActionExecutionContext context) {
        log.debug("Updating execution context - ready: {}", context.isReady());
        this.executionContext = context;

        // Trigger processing in case there are queued actions waiting for the context
        triggerProcessing();
    }

    /**
     * Get the current queue size
     */
    public int getQueueSize() {
        return actionQueue.size();
    }

    /**
     * Clear all pending actions without shutting down the queue.
     * This allows the queue to be reused after clearing.
     */
    public void clear() {
        log.info("Clearing database action queue");

        // Cancel all pending actions
        DatabaseAction<?> action;
        while ((action = actionQueue.poll()) != null) {
            action.completeExceptionally(new IllegalStateException("Queue cleared"));
        }

        // Clear execution context
        this.executionContext = null;
    }

    private void startProcessing() {
        executor.scheduleWithFixedDelay(this::processActions, 100, 50, TimeUnit.MILLISECONDS);
    }

    private void triggerProcessing() {
        // The scheduled task will pick up new actions automatically
        // This method exists for future optimization if needed
    }

    private void processActions() {
        if (isProcessing.get()) {
            return;
        }

        if (actionQueue.isEmpty() || executionContext == null) {
            return;
        }

        if (!isProcessing.compareAndSet(false, true)) {
            return; // Another thread is already processing
        }

        try {
            // Process actions in batches, respecting priority
            List<DatabaseAction<?>> batch = collectBatch();

            for (DatabaseAction<?> action : batch) {
                try {
                    processAction(action);
                } catch (Exception e) {
                    log.error("Unexpected error processing action {}: {}", action.getActionType(), e.getMessage(), e);
                    action.completeExceptionally(e);
                }
            }

        } finally {
            isProcessing.set(false);
        }
    }

    private List<DatabaseAction<?>> collectBatch() {
        List<DatabaseAction<?>> batch = new ArrayList<>();

        // Collect all ready actions
        DatabaseAction<?> action;
        while ((action = actionQueue.poll()) != null) {
            if (action.canExecute(executionContext)) {
                batch.add(action);
            } else {
                // Put it back and break (will be retried later)
                actionQueue.offer(action);
                break;
            }

            // Limit batch size to prevent blocking too long
            if (batch.size() >= 10) {
                break;
            }
        }
        // Sort by priority (higher first)
        batch.sort(Comparator.<DatabaseAction<?>>comparingInt(DatabaseAction::getPriority).reversed());

        return batch;
    }

    private void processAction(DatabaseAction<?> action) {
        try {
            log.debug("Processing action: {}", action.getDescription());
            action.execute(executionContext);

        } catch (Exception e) {
            log.error("Action {} failed: {}", action.getActionType(), e.getMessage());
            action.completeExceptionally(e);
        }
    }
}

package mvdicarlo.crabmanmode.database;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import lombok.extern.slf4j.Slf4j;
import mvdicarlo.crabmanmode.UnlockedItemEntity;

/**
 * Concrete implementations of database actions.
 */
@Slf4j
public class DatabaseActions {

    /**
     * Action to insert a new unlocked item
     */
    public static class InsertItemAction extends BaseDatabaseAction<UnlockedItemEntity> {
        private final UnlockedItemEntity item;

        public InsertItemAction(UnlockedItemEntity item) {
            this.item = item;
        }

        @Override
        public String getActionType() {
            return "INSERT_ITEM";
        }

        @Override
        public String getDescription() {
            return String.format("Insert item '%s' (ID: %d)", item.getItemName(), item.getItemId());
        }

        @Override
        protected UnlockedItemEntity executeInternal(ActionExecutionContext context) throws Exception {
            // Check if item already exists in local cache
            synchronized (context.getLocalCache()) {
                if (context.getLocalCache().containsKey(item.getItemId())) {
                    log.debug("Item {} already exists, skipping insert", item.getItemName());
                    return context.getLocalCache().get(item.getItemId());
                }

                // Set user and add to local cache optimistically
                item.setAcquiredBy(context.getCurrentUser());
                context.getLocalCache().put(item.getItemId(), item);
            }

            try {
                // Send to remote database
                context.getApi().insertEntity(item);
                log.debug("Successfully inserted item '{}' to remote database", item.getItemName());
                return item;

            } catch (Exception e) {
                // Remove from local cache if remote insert failed
                synchronized (context.getLocalCache()) {
                    context.getLocalCache().remove(item.getItemId());
                }
                throw new RuntimeException("Failed to insert item to remote database", e);
            }
        }

        public UnlockedItemEntity getItem() {
            return item;
        }
    }

    /**
     * Action to delete an unlocked item
     */
    public static class DeleteItemAction extends BaseDatabaseAction<Void> {
        private final int itemId;

        public DeleteItemAction(int itemId) {
            this.itemId = itemId;
        }

        @Override
        public String getActionType() {
            return "DELETE_ITEM";
        }

        @Override
        public String getDescription() {
            return String.format("Delete item ID: %d", itemId);
        }

        @Override
        protected Void executeInternal(ActionExecutionContext context) throws Exception {
            UnlockedItemEntity removed = null;

            // Remove from local cache optimistically
            synchronized (context.getLocalCache()) {
                removed = context.getLocalCache().remove(itemId);
            }

            try {
                // Send delete to remote
                context.getApi().deleteEntity(UnlockedItemEntity.PartitionKey, Integer.toString(itemId));
                log.debug("Successfully deleted item ID {} from remote database", itemId);
                return null;

            } catch (Exception e) {
                // Restore to local cache if remote delete failed
                if (removed != null) {
                    synchronized (context.getLocalCache()) {
                        context.getLocalCache().put(itemId, removed);
                    }
                }
                throw new RuntimeException("Failed to delete item from remote database", e);
            }
        }

        public int getItemId() {
            return itemId;
        }
    }

    /**
     * Action to load all items from the database (used during initialization)
     */
    public static class LoadAllItemsAction extends BaseDatabaseAction<Map<Integer, UnlockedItemEntity>> {

        @Override
        public String getActionType() {
            return "LOAD_ALL_ITEMS";
        }

        @Override
        public String getDescription() {
            return "Load all unlocked items from database";
        }

        @Override
        public int getPriority() {
            return 100; // High priority for initialization
        }

        @Override
        protected Map<Integer, UnlockedItemEntity> executeInternal(ActionExecutionContext context) throws Exception {
            Map<Integer, UnlockedItemEntity> result = new HashMap<>();

            try {
                List<UnlockedItemEntity> items = context.getApi().listEntities();
                for (UnlockedItemEntity item : items) {
                    result.put(item.getItemId(), item);
                }
                log.info("Successfully loaded {} items from database", result.size());
                return result;

            } catch (Exception e) {
                throw new RuntimeException("Failed to load items from database", e);
            }
        }

        @Override
        public boolean canExecute(ActionExecutionContext context) {
            // Can execute even if not fully ready (used during initialization)
            return context.getApi() != null;
        }
    }

    /**
     * Action to sync with remote database (periodic background sync)
     */
    public static class SyncAction extends BaseDatabaseAction<List<UnlockedItemEntity>> {
        private final OffsetDateTime since;
        private final String currentUser;

        public SyncAction(OffsetDateTime since, String currentUser) {
            this.since = since;
            this.currentUser = currentUser;
        }

        @Override
        public String getActionType() {
            return "SYNC";
        }

        @Override
        public String getDescription() {
            return String.format("Sync items since %s", since);
        }

        @Override
        public int getPriority() {
            return -10; // Low priority for background sync
        }

        @Override
        protected List<UnlockedItemEntity> executeInternal(ActionExecutionContext context) throws Exception {
            try {
                String filter = "Timestamp%20gt%20datetime'" + since.toString() + "'";
                List<UnlockedItemEntity> newItems = context.getApi().listEntities(filter);

                // Filter out items from current user and update local cache
                List<UnlockedItemEntity> newItemsFromOthers = new ArrayList<>();

                synchronized (context.getLocalCache()) {
                    for (UnlockedItemEntity item : newItems) {
                        context.getLocalCache().put(item.getItemId(), item);

                        if (!item.getAcquiredBy().equals(currentUser)) {
                            newItemsFromOthers.add(item);
                        }
                    }
                }

                log.debug("Synced {} new items ({} from others)", newItems.size(), newItemsFromOthers.size());
                return newItemsFromOthers;

            } catch (Exception e) {
                log.warn("Failed to sync with remote database: {}", e.getMessage());
                // Don't throw for sync failures - just log and continue
                return new ArrayList<>();
            }
        }
    }
}

package mvdicarlo.crabmanmode.database;

import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

import com.google.gson.Gson;

import lombok.extern.slf4j.Slf4j;
import mvdicarlo.crabmanmode.AzureTableApi;
import mvdicarlo.crabmanmode.UnlockedItemEntity;
import okhttp3.OkHttpClient;

/**
 * New database repository implementation using the action queue pattern.
 * All database operations are queued as actions and executed asynchronously.
 * This eliminates blocking operations and race conditions.
 */
@Slf4j
public class DatabaseRepository {
    private final DatabaseActionQueue actionQueue;
    private final DatabaseState databaseState;
    private final Map<Integer, UnlockedItemEntity> unlockedItems = new HashMap<>();
    private final ScheduledExecutorService scheduler;

    // Pre-initialization queue for items inserted before database is ready
    private final List<PendingInsert> preInitInsertQueue = new java.util.concurrent.CopyOnWriteArrayList<>();

    // Track the periodic sync task so we can cancel it
    private java.util.concurrent.ScheduledFuture<?> syncTask;

    // Dependencies
    private AzureTableApi api;
    private String currentUser;
    private Gson gson;
    private OkHttpClient httpClient;

    // Listeners
    private final List<Consumer<List<UnlockedItemEntity>>> itemListeners = new java.util.concurrent.CopyOnWriteArrayList<>();

    // Helper class for pre-initialization inserts
    private static class PendingInsert {
        final UnlockedItemEntity item;
        final CompletableFuture<UnlockedItemEntity> future;

        PendingInsert(UnlockedItemEntity item, CompletableFuture<UnlockedItemEntity> future) {
            this.item = item;
            this.future = future;
        }
    }

    public DatabaseRepository() {
        this.actionQueue = new DatabaseActionQueue();
        this.databaseState = new DatabaseState();
        this.scheduler = Executors.newScheduledThreadPool(1, r -> {
            Thread t = new Thread(r, "DatabaseRepository-Scheduler");
            t.setDaemon(true);
            return t;
        });

        // Update action queue context when state changes
        databaseState.addStateListener(this::onStateChanged);
    }

    // === Public API ===

    /**
     * Initialize the database connection
     */
    public CompletableFuture<Void> initialize(String sasUrl, String user) {
        log.info("Initializing database connection for user: {}", user);
        databaseState.setState(DatabaseState.State.INITIALIZING);

        this.currentUser = user;
        this.api = new AzureTableApi(sasUrl, gson, httpClient);

        // Update action queue context
        updateActionQueueContext();

        // Load all data
        databaseState.setState(DatabaseState.State.LOADING_DATA);

        return actionQueue.submit(new DatabaseActions.LoadAllItemsAction())
                .thenAccept(items -> {
                    synchronized (unlockedItems) {
                        unlockedItems.clear();
                        unlockedItems.putAll(items);
                    }
                    databaseState.setState(DatabaseState.State.READY);
                    log.info("Database initialized successfully with {} items", items.size());

                    // Process any pre-initialization inserts
                    processPendingInserts();

                    // Start periodic sync
                    startPeriodicSync();
                })
                .exceptionally(throwable -> {
                    log.error("Failed to initialize database", throwable);
                    databaseState.setState(DatabaseState.State.ERROR, throwable);
                    return null;
                });
    }

    /**
     * Insert a new unlocked item
     */
    public CompletableFuture<UnlockedItemEntity> insertItem(UnlockedItemEntity item) {
        log.debug("Queuing insert for item: {}", item.getItemName());

        // If database is not ready, queue the insert for later processing
        if (!databaseState.isReady()) {
            log.debug("Database not ready, queuing insert for later: {}", item.getItemName());
            CompletableFuture<UnlockedItemEntity> future = new CompletableFuture<>();
            preInitInsertQueue.add(new PendingInsert(item, future));
            return future;
        }

        // Check if the item already exists in the cache
        synchronized (unlockedItems) {
            if (unlockedItems.containsKey(item.getItemId())) {
                log.debug("Item {} already exists, returning cached instance", item.getItemName());
                return CompletableFuture.completedFuture(unlockedItems.get(item.getItemId()));
            }
        }

        // Database is ready, process normally
        return actionQueue.submit(new DatabaseActions.InsertItemAction(item))
                .thenApply(insertedItem -> {
                    // Notify listeners of new item
                    notifyItemListeners(List.of(insertedItem));
                    return insertedItem;
                });
    }

    /**
     * Delete an unlocked item
     */
    public CompletableFuture<Void> deleteItem(int itemId) {
        log.debug("Queuing delete for item ID: {}", itemId);

        return actionQueue.submit(new DatabaseActions.DeleteItemAction(itemId));
    }

    /**
     * Get current unlocked items (thread-safe snapshot)
     */
    public Map<Integer, UnlockedItemEntity> getUnlockedItems() {
        synchronized (unlockedItems) {
            return new HashMap<>(unlockedItems);
        }
    }

    /**
     * Get current database state
     */
    public DatabaseState.State getState() {
        return databaseState.getCurrentState();
    }

    /**
     * Check if database is ready for operations
     */
    public boolean isReady() {
        return databaseState.isReady();
    }

    public boolean hasItem(int itemId) {
        synchronized (unlockedItems) {
            return unlockedItems.containsKey(itemId);
        }
    }

    /**
     * Add listener for new items
     */
    public void addItemListener(Consumer<List<UnlockedItemEntity>> listener) {
        itemListeners.add(listener);
    }

    /**
     * Add listener for state changes
     */
    public void addStateListener(Consumer<DatabaseState.State> listener) {
        databaseState.addStateListener(listener);
    }

    /**
     * Create a new unlocked item entity
     */
    public UnlockedItemEntity createNewItem(Integer itemId, String itemName) {
        return new UnlockedItemEntity(itemName, itemId, currentUser);
    }

    /**
     * Close the repository and clean up resources.
     * This clears the queue and cached data but keeps the repository reusable.
     */
    public void close() {
        log.info("Closing database repository");

        databaseState.reset();
        actionQueue.clear();

        // Cancel the periodic sync task if it exists
        if (syncTask != null && !syncTask.isCancelled()) {
            log.debug("Cancelling periodic sync task");
            syncTask.cancel(false); // Don't interrupt if currently running
            syncTask = null;
        }

        synchronized (unlockedItems) {
            unlockedItems.clear();
        }

        // Cancel any pending inserts
        for (PendingInsert pending : preInitInsertQueue) {
            pending.future.completeExceptionally(new IllegalStateException("Repository closed"));
        }
        preInitInsertQueue.clear();

        api = null;
        currentUser = null;
    }

    // === Configuration ===

    public void setGson(Gson gson) {
        this.gson = gson;
    }

    public void setHttpClient(OkHttpClient httpClient) {
        this.httpClient = httpClient;
    }

    public String getCurrentUser() {
        return currentUser != null ? currentUser : "";
    }

    // === Private Methods ===

    private void onStateChanged(DatabaseState.State newState) {
        updateActionQueueContext();
    }

    private void updateActionQueueContext() {
        ActionExecutionContext context = new ActionExecutionContext(
                api,
                unlockedItems,
                currentUser,
                databaseState.isReady());

        actionQueue.updateExecutionContext(context);
    }

    /**
     * Process any inserts that were queued before database initialization
     */
    private void processPendingInserts() {
        if (preInitInsertQueue.isEmpty()) {
            return;
        }

        log.info("Processing {} pending inserts from before initialization", preInitInsertQueue.size());

        // Process all pending inserts
        for (PendingInsert pending : preInitInsertQueue) {
            try {
                // Check if the item is already in the cache
                synchronized (unlockedItems) {
                    if (unlockedItems.containsKey(pending.item.getItemId())) {
                        log.debug("Item {} already exists, skipping insert", pending.item.getItemName());
                        pending.future.complete(unlockedItems.get(pending.item.getItemId()));
                        continue;
                    }
                }

                // Now submit to the action queue with the properly initialized cache
                actionQueue.submit(new DatabaseActions.InsertItemAction(pending.item))
                        .thenApply(insertedItem -> {
                            // Notify listeners of new item
                            notifyItemListeners(List.of(insertedItem));
                            return insertedItem;
                        })
                        .whenComplete((result, throwable) -> {
                            if (throwable != null) {
                                pending.future.completeExceptionally(throwable);
                            } else {
                                pending.future.complete(result);
                            }
                        });
            } catch (Exception e) {
                log.error("Failed to process pending insert for item: {}", pending.item.getItemName(), e);
                pending.future.completeExceptionally(e);
            }
        }

        // Clear the queue
        preInitInsertQueue.clear();
    }

    private void startPeriodicSync() {
        syncTask = scheduler.scheduleAtFixedRate(() -> {
            if (databaseState.isReady()) {
                performSync();
            }
        }, 5, 5, TimeUnit.MINUTES);
    }

    private void performSync() {
        OffsetDateTime lastSync = getLastSyncTime();

        actionQueue.submit(new DatabaseActions.SyncAction(lastSync, currentUser))
                .thenAccept(newItemsFromOthers -> {
                    if (!newItemsFromOthers.isEmpty()) {
                        log.debug("Synced {} new items from other users", newItemsFromOthers.size());
                        notifyItemListeners(newItemsFromOthers);
                    }
                })
                .exceptionally(throwable -> {
                    log.warn("Sync failed: {}", throwable.getMessage());
                    return null;
                });
    }

    private OffsetDateTime getLastSyncTime() {
        synchronized (unlockedItems) {
            return unlockedItems.values().stream()
                    .map(UnlockedItemEntity::getAcquiredOn)
                    .max(OffsetDateTime::compareTo)
                    .orElse(OffsetDateTime.now().minusMinutes(10));
        }
    }

    private void notifyItemListeners(List<UnlockedItemEntity> newItems) {
        for (Consumer<List<UnlockedItemEntity>> listener : itemListeners) {
            try {
                listener.accept(newItems);
            } catch (Exception e) {
                log.error("Error notifying item listener", e);
            }
        }
    }
}

package mvdicarlo.crabmanmode.database;

import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

import lombok.extern.slf4j.Slf4j;

/**
 * Manages the state of the database connection and loading process.
 * Provides thread-safe state transitions and notifications.
 */
@Slf4j
public class DatabaseState {

    public enum State {
        NOT_INITIALIZED("Not initialized"),
        INITIALIZING("Connecting to database..."),
        LOADING_DATA("Loading unlocked items..."),
        READY("Ready"),
        ERROR("Connection failed");

        private final String displayName;

        State(String displayName) {
            this.displayName = displayName;
        }

        public String getDisplayName() {
            return displayName;
        }

        public boolean isReady() {
            return this == READY;
        }

        public boolean canAcceptActions() {
            return this != NOT_INITIALIZED && this != ERROR;
        }
    }

    private final AtomicReference<State> currentState = new AtomicReference<>(State.NOT_INITIALIZED);
    private final List<Consumer<State>> stateListeners = new CopyOnWriteArrayList<>();
    private volatile Throwable lastError;

    /**
     * Get the current state
     */
    public State getCurrentState() {
        return currentState.get();
    }

    /**
     * Check if the database is ready for operations
     */
    public boolean isReady() {
        return currentState.get().isReady();
    }

    /**
     * Check if the database can accept new actions
     */
    public boolean canAcceptActions() {
        return currentState.get().canAcceptActions();
    }

    /**
     * Get the last error that occurred (if any)
     */
    public Throwable getLastError() {
        return lastError;
    }

    /**
     * Transition to a new state
     */
    public void setState(State newState) {
        setState(newState, null);
    }

    /**
     * Transition to a new state with an optional error
     */
    public void setState(State newState, Throwable error) {
        State oldState = currentState.getAndSet(newState);

        if (error != null) {
            this.lastError = error;
        } else if (newState != State.ERROR) {
            // Clear error on successful state transitions
            this.lastError = null;
        }

        if (oldState != newState) {
            log.debug("Database state changed: {} -> {}", oldState, newState);
            notifyListeners(newState);
        }
    }

    /**
     * Add a listener for state changes
     */
    public void addStateListener(Consumer<State> listener) {
        stateListeners.add(listener);
        // Immediately notify of current state
        listener.accept(currentState.get());
    }

    /**
     * Remove a state listener
     */
    public void removeStateListener(Consumer<State> listener) {
        stateListeners.remove(listener);
    }

    /**
     * Reset to initial state
     */
    public void reset() {
        setState(State.NOT_INITIALIZED);
        this.lastError = null;
    }

    private void notifyListeners(State newState) {
        for (Consumer<State> listener : stateListeners) {
            try {
                listener.accept(newState);
            } catch (Exception e) {
                log.error("Error notifying state listener", e);
            }
        }
    }
}

package mvdicarlo.crabmanmode;

import java.time.OffsetDateTime;
import net.runelite.client.util.AsyncBufferedImage;

public class ItemObject {
    int id;
    String name;
    boolean tradeable;
    OffsetDateTime acquiredOn;
    AsyncBufferedImage icon;

    public ItemObject(int id, String name, boolean tradeable, OffsetDateTime acquiredOn, AsyncBufferedImage icon) {
        this.id = id;
        this.name = name;
        this.tradeable = tradeable;
        this.acquiredOn = acquiredOn;
        this.icon = icon;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isTradeable() {
        return tradeable;
    }

    public OffsetDateTime getAcquiredOn() {
        return acquiredOn;
    }

    public AsyncBufferedImage getIcon() {
        return icon;
    }
}

package mvdicarlo.crabmanmode;

public enum SortOption {
    NEW_TO_OLD("New to Old"),
    OLD_TO_NEW("Old to New"),
    ALPHABETICAL_ASC("Alphabetical A-Z"),
    ALPHABETICAL_DESC("Alphabetical Z-A");

    SortOption(String displayName) {
        this.displayName = displayName;
    }

    private final String displayName;

    public String getDisplayName() {
        return displayName;
    }
}
package mvdicarlo.crabmanmode;

import java.time.OffsetDateTime;
import java.util.HashMap;
import java.util.Map;

public class UnlockedItemEntity {
    public final static String PartitionKey = "UnlockedItem";
    private String itemName;
    private Integer itemId;
    private String acquiredBy;
    private OffsetDateTime acquiredOn;

    public UnlockedItemEntity(String itemName, Integer itemId, String acquiredBy, OffsetDateTime acquiredOn) {
        this.itemName = itemName;
        this.itemId = itemId;
        this.acquiredBy = acquiredBy;
        this.acquiredOn = acquiredOn;
    }

    public UnlockedItemEntity(String itemName, Integer itemId, String acquiredBy) {
        this(itemName, itemId, acquiredBy, OffsetDateTime.now());
    }

    public Integer getItemId() {
        return itemId;
    }

    public String getAcquiredBy() {
        return acquiredBy;
    }

    public String setAcquiredBy(String acquiredBy) {
        return this.acquiredBy = acquiredBy;
    }

    public String getItemName() {
        return itemName;
    }

    public OffsetDateTime getAcquiredOn() {
        return acquiredOn;
    }

    public Map<String, Object> toMap() {
        Map<String, Object> map = new HashMap<>();
        map.put("PartitionKey", PartitionKey);
        map.put("RowKey", itemId.toString());
        map.put("ItemName", itemName);
        map.put("AcquiredBy", acquiredBy);
        // map.put("Timestamp", acquiredOn.toString()); // Fine to allow null
        return map;
    }

    public static UnlockedItemEntity fromMap(Map<String, Object> map) {
        String itemName = (String) map.get("ItemName");
        Integer itemId = Integer.parseInt((String) map.get("RowKey"));
        String acquiredBy = (String) map.get("AcquiredBy");
        OffsetDateTime acquiredOn = OffsetDateTime.parse((String) map.get("Timestamp"));
        return new UnlockedItemEntity(itemName, itemId, acquiredBy, acquiredOn);
    }
}
package mvdicarlo.crabmanmode;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CrabmanModePluginTest {
    public static void main(String[] args) throws Exception {
        ExternalPluginManager.loadBuiltin(CrabmanModePlugin.class);
        RuneLite.main(args);
    }
}

