package begosrs.barbarianassault;

import begosrs.barbarianassault.timer.TimeUnits;
import begosrs.barbarianassault.timer.Timer;

import java.util.regex.Pattern;

import net.runelite.api.Constants;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

public class Test {

	@org.junit.Test
    public void testRegex()
    {
        String text = "(50) Defender";
        text = text.replaceAll("\\(.*\\) ", "");
        assertEquals("Defender", text);

        text = "(5) 00:00";
        text = text.replaceAll("\\(.*\\) ", "");
        assertEquals("00:00", text);

        text = " , Red egg  ,     Green egg  ,  Blue egg  ,Yellow egg,";
        text = text.replaceAll("\\s*,*\\s*(?i)" + Pattern.quote("red egg") + "\\s*,*\\s*", ",");
        text = trimComma(text);
        assertEquals("Green egg  ,  Blue egg  ,Yellow egg", text);

        text = text.replaceAll("\\s*,*\\s*(?i)" + Pattern.quote("blue egg") + "\\s*,*\\s*", ",");
        text = trimComma(text);
        assertEquals("Green egg,Yellow egg", text);

        text = text.replaceAll("\\s*,*\\s*(?i)" + Pattern.quote("yellow egg") + "\\s*,*\\s*", ",");
        text = trimComma(text);
        assertEquals("Green egg", text);
    }

    private String trimComma(String text)
    {
        if (text.startsWith(","))
        {
            text = text.substring(1);
        }
        if (text.endsWith(","))
        {
            text = text.substring(0, text.length() - 1);
        }

        return text;
    }

    @org.junit.Test
    public void testTimer()
    {
		final Timer timer = new Timer();

		final Round round = new Round(1, timer);
		assertTrue(round.getTimer().getRoundTime().toMillis() <= 1000);

		// 1st wave starts
		Wave wave = new Wave(null, 1, new Role[5], timer);
		timer.onGameTick();
		assertTrue(wave.getTimeUntilCallChange() >= 29);
		assertTrue(wave.getTimer().getWaveTime().toMillis() <= 1000);
		assertEquals(0.0, wave.getTimeElapsed(true, TimeUnits.TENTHS_OF_SECOND), 0.05);
		assertEquals(0.0, wave.getTimeElapsed(true, TimeUnits.TICKS), 0.05);

		sleep(3000);
		for (int i = 0; i < 3000 / Constants.GAME_TICK_LENGTH; i++)
		{
			timer.onGameTick();
		}

		assertTrue(wave.getTimeUntilCallChange() <= 27);
		assertTrue(wave.getTimer().getWaveTime().toMillis() >= 3000);
		assertEquals(3.0, wave.getTimeElapsed(true, TimeUnits.TENTHS_OF_SECOND), 0.05);
		assertEquals(3.0, wave.getTimeElapsed(true, TimeUnits.TICKS), 0.05);

		// 2nd wave starts
		timer.setWaveStartTime();
		wave = new Wave(null, 2, new Role[5], timer);
		timer.onGameTick();
		assertTrue(wave.getTimeUntilCallChange() >= 29);
		assertTrue(wave.getTimer().getWaveTime().toMillis() <= 1000);
		assertEquals(0.0, wave.getTimeElapsed(true, TimeUnits.TENTHS_OF_SECOND), 0.05);
		assertEquals(0.0, wave.getTimeElapsed(true, TimeUnits.TICKS), 0.05);
	}

    private void sleep(long ms)
    {
        try
        {
            Thread.sleep(ms);
        }
        catch (InterruptedException ignored)
        {
        }
    }

}

package begosrs.barbarianassault;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BaMinigamePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BaMinigamePlugin.class);
		RuneLite.main(args);
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.deathtimes.DeathTimesMode;
import begosrs.barbarianassault.grounditems.GroundEggsMode;
import begosrs.barbarianassault.grounditems.MenuHighlightMode;
import begosrs.barbarianassault.inventory.InventoryHighlightMode;
import begosrs.barbarianassault.points.DisplayPointsLocationMode;
import begosrs.barbarianassault.points.DisplayPointsMode;
import begosrs.barbarianassault.points.KandarinDiaryBonusMode;
import begosrs.barbarianassault.points.PointsCounterMode;
import begosrs.barbarianassault.points.PointsMode;
import begosrs.barbarianassault.points.RewardsBreakdownMode;
import begosrs.barbarianassault.points.RolePointsTrackingMode;
import begosrs.barbarianassault.timer.DurationMode;
import begosrs.barbarianassault.timer.TimeUnits;
import java.awt.Color;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.config.Range;
import net.runelite.client.config.Units;

@ConfigGroup("baMinigame")
public interface BaMinigameConfig extends Config
{

	@ConfigSection(
		name = "In-game",
		description = "Configurations related to features inside a barbarian assault game",
		position = 50,
		closedByDefault = true
	)
	String inGameSection = "inGameSection";
	@ConfigSection(
		name = "Attacker",
		description = "Options associated to the Attacker role",
		position = 51,
		closedByDefault = true
	)
	String attackerSection = "attacker";
	@ConfigSection(
		name = "Defender",
		description = "Options associated to the Defender role",
		position = 52,
		closedByDefault = true
	)
	String defenderSection = "defender";
	@ConfigSection(
		name = "Collector",
		description = "Options associated to the Collector role",
		position = 53,
		closedByDefault = true
	)
	String collectorSection = "collector";
	@ConfigSection(
		name = "Healer",
		description = "Options associated to the Healer role",
		position = 54,
		closedByDefault = true
	)
	String healerSection = "healer";
	@ConfigSection(
		name = "Post-game",
		description = "Configurations related to features after a barbarian assault game",
		position = 55,
		closedByDefault = true
	)
	String postGameSection = "postGameSection";
	@ConfigSection(
		name = "Points",
		description = "Configurations related to role points",
		position = 66,
		closedByDefault = true
	)
	String pointsSection = "pointsSection";

	@ConfigItem(
		keyName = "enableGameChatColors",
		name = "Chat colors",
		description = "Enable game chat colors on messages announced by this plugin",
		position = 0
	)
	default boolean enableGameChatColors()
	{
		return true;
	}

	@ConfigItem(
		keyName = "swapQuickStart",
		name = "Swap lobby ladder",
		description = "Swap Climb-down with Quick-start on lobby ladders",
		position = 1
	)
	default boolean swapQuickStart()
	{
		return true;
	}

	@ConfigItem(
		keyName = "swapGetRewards",
		name = "Swap Commander Connad",
		description = "Swap Talk-to with Get-rewards for the Commander Connad",
		position = 2
	)
	default boolean swapGetRewards()
	{
		return true;
	}

	@ConfigItem(
		keyName = "scrollConnadRewards",
		name = "Scroll Connad's Rewards",
		description = "Auto scrolls to the bottom of Connad's rewards, useful for high gambles",
		position = 3
	)
	default boolean scrollConnadRewards()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showWaveCompleted",
		name = "Display wave completed icon",
		description = "Replaces the wave icon for a checkmark when role npcs are dead",
		section = inGameSection,
		position = 0
	)
	default boolean showWaveCompleted()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showWaveTimer",
		name = "Display wave timer",
		description = "Displays time elapsed inside wave",
		section = inGameSection,
		position = 1
	)
	default boolean showWaveTimer()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showCallChangeTimer",
		name = "Display call change timer",
		description = "Displays time to next call change",
		section = inGameSection,
		position = 2
	)
	default boolean showCallChangeTimer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "hideTeammateRole",
		name = "Hide teammate role",
		description = "Hide the teammate role on the wave information",
		section = inGameSection,
		position = 3
	)
	default boolean hideTeammateRole()
	{
		return false;
	}

	@ConfigItem(
		keyName = "timeUnits",
		name = "Time units",
		description = "Controls time precision for wave/round times and penance deaths",
		section = inGameSection,
		position = 4
	)
	default TimeUnits timeUnits()
	{
		return TimeUnits.SECONDS;
	}

	@Alpha
	@ConfigItem(
		keyName = "callChangeFlashColor",
		name = "Call change flash color",
		description = "Select the color to flash the call change",
		section = inGameSection,
		position = 5
	)
	default Color callChangeFlashColor()
	{
		return BaMinigamePlugin.DEFAULT_FLASH_COLOR;
	}

	@ConfigItem(
		keyName = "deathTimesMode",
		name = "Death times",
		description = "Shows the time all penance monsters of a certain type are killed in an info box, the chat, or both",
		section = inGameSection,
		position = 6
	)
	default DeathTimesMode deathTimesMode()
	{
		return DeathTimesMode.INFOBOX_CHAT;
	}

	@ConfigItem(
		keyName = "deathMessageColor",
		name = "Death messages color",
		description = "Recolors the penance death message relevant to the current role",
		section = inGameSection,
		position = 7
	)
	default Color deathMessageColor()
	{
		return null;
	}

	@ConfigItem(
		keyName = "showEggsOnHopper",
		name = "Display cannon eggs",
		description = "Displays the amount of loaded eggs on cannon hoppers",
		section = inGameSection,
		position = 8
	)
	default boolean showEggsOnHopper()
	{
		return true;
	}

	@ConfigItem(
		keyName = "onlyShowOmegaHopper",
		name = "Cannon eggs: omega only",
		description = "If cannon eggs are enabled, hides eggs other than omega",
		section = inGameSection,
		position = 9
	)
	default boolean onlyShowOmegaHopper()
	{
		return false;
	}

	@ConfigItem(
		keyName = "inventoryHighlightMode",
		name = "Inventory highlight",
		description = "Define the mode of all inventory highlights",
		section = inGameSection,
		position = 10
	)
	default InventoryHighlightMode inventoryHighlightMode()
	{
		return InventoryHighlightMode.OVERLAY;
	}

	@ConfigItem(
		keyName = "showGroundItemHighlights",
		name = "Ground items highlight",
		description = "Show ground item highlights",
		section = inGameSection,
		position = 11
	)
	default boolean showGroundItemHighlights()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightGroundTiles",
		name = "Ground tiles highlight",
		description = "Configures whether or not to highlight tiles containing ground items",
		section = inGameSection,
		position = 12
	)
	default boolean highlightGroundTiles()
	{
		return false;
	}

	@ConfigItem(
		keyName = "callCorrection",
		name = "Call correction",
		description = "Write a chat message if your teammate corrects their call",
		section = inGameSection,
		position = 13
	)
	default boolean announceCallCorrection()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightArrows",
		name = "Highlight arrows",
		description = "Highlights arrows called by your teammate",
		position = 0,
		section = attackerSection
	)
	default boolean highlightArrows()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightArrowColor",
		name = "Highlight arrow color",
		description = "Configures the color to highlight the called arrows",
		position = 1,
		section = attackerSection
	)
	default Color highlightArrowColor()
	{
		return new Color(0, 255, 0, 50);
	}

	@ConfigItem(
		keyName = "highlightAttackStyle",
		name = "Highlight attack style",
		description = "Highlights the attack style called by your teammate",
		position = 2,
		section = attackerSection
	)
	default boolean highlightAttackStyle()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightAttackStyleColor",
		name = "Highlight attack style color",
		description = "Configures the color to highlight the attack style",
		position = 3,
		section = attackerSection
	)
	default Color highlightAttackStyleColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "showRunnerTickTimerAttacker",
		name = "Show runner tick timer",
		description = "Shows the current cycle tick of runners when performing the attacker role",
		position = 4,
		section = attackerSection
	)
	default boolean showRunnerTickTimerAttacker()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightBait",
		name = "Highlight called bait",
		description = "Highlights bait called by your teammate",
		position = 0,
		section = defenderSection
	)
	default boolean highlightBait()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightBaitColor",
		name = "Called bait color",
		description = "Color to highlight the bait called by your teammate",
		position = 1,
		section = defenderSection
	)
	default Color highlightBaitColor()
	{
		return new Color(0, 255, 0, 50);
	}

	@ConfigItem(
		keyName = "highlightGroundBait",
		name = "Highlight ground bait",
		description = "Highlight bait dropped on the ground",
		position = 2,
		section = defenderSection
	)
	default boolean highlightGroundBait()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightGroundBaitColor",
		name = "Ground bait color",
		description = "Color to highlight the bait dropped on the ground",
		position = 3,
		section = defenderSection
	)
	default Color highlightGroundBaitColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		keyName = "highlightGroundLogsHammer",
		name = "Highlight ground logs/hammer",
		description = "Highlight logs and hammer on the ground",
		position = 4,
		section = defenderSection
	)
	default boolean highlightGroundLogsHammer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightGroundLogsHammerColor",
		name = "Ground logs/hammer color",
		description = "Color to highlight the logs and hammer on the ground",
		position = 5,
		section = defenderSection
	)
	default Color highlightGroundLogsHammerColor()
	{
		return Color.WHITE;
	}

	@ConfigItem(
		keyName = "showRunnerTickTimerDefender",
		name = "Show runner tick timer",
		description = "Shows the current cycle tick of runners when performing the defender role",
		position = 6,
		section = defenderSection
	)
	default boolean showRunnerTickTimerDefender()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightBrokenTraps",
		name = "Highlight broken traps",
		description = "Highlights broken traps when all penance runners are not dead",
		position = 7,
		section = defenderSection
	)
	default boolean highlightBrokenTraps()
	{
		return false;
	}

	@ConfigItem(
		keyName = "highlightBrokenTrapsColor",
		name = "Broken traps color",
		description = "Set color of the highlighted broken traps",
		position = 8,
		section = defenderSection
	)
	default Color highlightBrokenTrapsColor()
	{
		return Color.RED;
	}

	@ConfigItem(
		keyName = "highlightBrokenTrapsOpacity",
		name = "Broken traps opacity",
		description = "Set opacity of the highlighted broken traps",
		position = 9,
		section = defenderSection
	)
	default int highlightBrokenTrapsOpacity()
	{
		return 50;
	}

	@ConfigItem(
		keyName = "highlightBrokenTrapsBorderWidth",
		name = "Broken traps border",
		description = "Set width of the highlighted broken traps",
		position = 10,
		section = defenderSection
	)
	default double highlightBrokenTrapsBorderWidth()
	{
		return 2;
	}

	@ConfigItem(
		keyName = "hideAttOptionsDefender",
		name = "Hide attack options",
		description = "Hides attack options on penance monsters",
		position = 11,
		section = defenderSection
	)
	default boolean hideAttackOptionsDefender()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showEggCountOverlay",
		name = "Show number of eggs collected",
		description = "Displays current number of eggs collected",
		position = 0,
		section = collectorSection
	)
	default boolean showEggCountOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightGroundEggsMode",
		name = "Highlight eggs",
		description = "Highlight egg colors on the ground",
		position = 1,
		section = collectorSection
	)
	default GroundEggsMode highlightGroundEggsMode()
	{
		return GroundEggsMode.CALLED;
	}

	@ConfigItem(
		keyName = "menuHighlightMode",
		name = "Menu highlight mode",
		description = "Configures what to highlight in right-click menu",
		section = collectorSection,
		position = 2
	)
	default MenuHighlightMode menuHighlightMode()
	{
		return MenuHighlightMode.NAME;
	}

	@ConfigItem(
		keyName = "swapCollectionBag",
		name = "Swap collection bag",
		description = "Swap Look-in with Empty on the collection bag",
		position = 3,
		section = collectorSection
	)
	default boolean swapCollectionBag()
	{
		return true;
	}

	@ConfigItem(
		keyName = "swapCollectorHorn",
		name = "Swap collector horn",
		description = "Swap Use with Tell-defensive on the collector horn",
		position = 4,
		section = collectorSection
	)
	default boolean swapCollectorHorn()
	{
		return false;
	}

	@ConfigItem(
		keyName = "swapDestroyEggs",
		name = "Swap collector eggs",
		description = "Swap Use with Destroy on red/green/blue eggs",
		position = 5,
		section = collectorSection
	)
	default boolean swapDestroyEggs()
	{
		return false;
	}

	@ConfigItem(
		keyName = "showRunnerTickTimerCollector",
		name = "Show runner tick timer",
		description = "Shows the current cycle tick of runners when performing the collector role",
		position = 6,
		section = collectorSection
	)
	default boolean showRunnerTickTimerCollector()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideAttOptionsCollector",
		name = "Hide attack options",
		description = "Hides attack options on penance monsters",
		position = 7,
		section = collectorSection
	)
	default boolean hideAttackOptionsCollector()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightPoison",
		name = "Highlight called poison",
		description = "Highlights poison food called by your teammate",
		position = 0,
		section = healerSection
	)
	default boolean highlightPoison()
	{
		return true;
	}

	@Alpha
	@ConfigItem(
		keyName = "highlightPoisonColor",
		name = "Called poison color",
		description = "Configures the color to highlight the correct poison food",
		position = 1,
		section = healerSection
	)
	default Color highlightPoisonColor()
	{
		return new Color(0, 255, 0, 50);
	}

	@ConfigItem(
		keyName = "highlightNotification",
		name = "Highlight incorrect notification",
		description = "Highlights incorrect poison chat notification",
		position = 2,
		section = healerSection
	)
	default boolean highlightNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "highlightNotificationColor",
		name = "Notification color",
		description = "Configures the color to highlight the notification text",
		position = 3,
		section = healerSection
	)
	default Color highlightNotificationColor()
	{
		return new Color(228, 18, 31);
	}

	@ConfigItem(
		keyName = "showHpCountOverlay",
		name = "Show number of hitpoints healed",
		description = "Displays current number of hitpoints healed",
		position = 4,
		section = healerSection
	)
	default boolean showHpCountOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showTeammateHealthBars",
		name = "Show teammate health bars",
		description = "Displays a health bar where a teammate's remaining health is located",
		position = 5,
		section = healerSection
	)
	default boolean showTeammateHealthBars()
	{
		return true;
	}

	@Range(max = 255)
	@ConfigItem(
		keyName = "teammateHealthBarTransparency",
		name = "Health bars transparency",
		description = "Configures the amount of transparency on the teammate health bar",
		position = 6,
		section = healerSection
	)
	default int teammateHealthBarTransparency()
	{
		return 200;
	}

	@ConfigItem(
		keyName = "hideHealerTeammatesHealth",
		name = "Hide teammates health",
		description = "Hides teammates health information",
		position = 7,
		section = healerSection
	)
	default boolean hideHealerTeammatesHealth()
	{
		return false;
	}

	@ConfigItem(
		keyName = "healerTeammatesHealthHotkey",
		name = "Teammates health hotkey",
		description = "Hotkey to show teammates health information when hidden",
		position = 8,
		section = healerSection
	)
	default Keybind healerTeammatesHealthHotkey()
	{
		return Keybind.CTRL;
	}

	@ConfigItem(
		keyName = "showRunnerTickTimerHealer",
		name = "Show runner tick timer",
		description = "Shows the current cycle tick of runners when performing the healer role",
		position = 9,
		section = healerSection
	)
	default boolean showRunnerTickTimerHealer()
	{
		return false;
	}

	@ConfigItem(
		keyName = "swapHealerSpring",
		name = "Swap healer spring",
		description = "Swap Drink-from with Take-from on healer spring",
		position = 10,
		section = healerSection
	)
	default boolean swapHealerSpring()
	{
		return false;
	}

	@ConfigItem(
		keyName = "hideAttOptionsHealer",
		name = "Hide attack options",
		description = "Hides attack options on penance monsters",
		position = 11,
		section = healerSection
	)
	default boolean hideAttackOptionsHealer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showDurationMode",
		name = "Duration",
		description = "Displays duration after each wave and/or round",
		section = postGameSection,
		position = 0
	)
	default DurationMode showDurationMode()
	{
		return DurationMode.WAVE_ROUND;
	}

	@ConfigItem(
		keyName = "showRewardPointsMode",
		name = "Reward points",
		description = "Gives summary of reward points in the chat after each wave and/or round",
		section = postGameSection,
		position = 1
	)
	default PointsMode showRewardPointsMode()
	{
		return PointsMode.WAVE_ROUND;
	}

	@ConfigItem(
		keyName = "showRewardsBreakdownMode",
		name = "Rewards breakdown",
		description = "Gives summary of advanced points breakdown in the chat after each wave and/or round",
		section = postGameSection,
		position = 2
	)
	default RewardsBreakdownMode showRewardsBreakdownMode()
	{
		return RewardsBreakdownMode.ROUND;
	}

	@ConfigItem(
		keyName = "displayPointsLocationMode",
		name = "Display at",
		description = "Set when to display role points",
		section = pointsSection,
		position = 3
	)
	default DisplayPointsLocationMode displayPointsLocationMode()
	{
		return DisplayPointsLocationMode.OUTPOST;
	}

	@ConfigItem(
		keyName = "displayPointsMode",
		name = "Points mode",
		description = "Set how to display role points",
		section = pointsSection,
		position = 4
	)
	default DisplayPointsMode displayPointsMode()
	{
		return DisplayPointsMode.TEXT_BOX;
	}

	@ConfigItem(
		keyName = "pointsCounterMode",
		name = "Points counter",
		description = "Set which role points counter to display",
		section = pointsSection,
		position = 5
	)
	default PointsCounterMode pointsCounterMode()
	{
		return PointsCounterMode.CURRENT_POINTS;
	}

	@ConfigItem(
		keyName = "rolePointsTrackingMode",
		name = "Points tracking",
		description = "Define how points will be tracked for rounds and sessions",
		section = pointsSection,
		position = 6
	)
	default RolePointsTrackingMode rolePointsTrackingMode()
	{
		return RolePointsTrackingMode.MINE;
	}

	@ConfigItem(
		keyName = "resetPoints",
		name = "Reset round and session points",
		description = "Turn on/off to reset round and session points",
		section = pointsSection,
		position = 7
	)
	default boolean resetPoints()
	{
		return false;
	}

	@ConfigItem(
		keyName = "sessionResetTime",
		name = "Session reset time",
		description = "Set how long to wait from the last wave completed for the session to reset",
		section = pointsSection,
		position = 8
	)
	@Units(Units.MINUTES)
	default int sessionResetTime()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "kandarinHardDiaryPointsBoost",
		name = "Diary bonus",
		description = "Include Kandarin hard diary +10% point bonus when displaying role points",
		section = pointsSection,
		position = 9
	)
	default KandarinDiaryBonusMode kandarinHardDiaryPointsBonus()
	{
		return KandarinDiaryBonusMode.IF_COMPLETED;
	}

	@ConfigItem(
		keyName = "groundItemsPluginHighlightedList",
		name = "Ground items highlighted list",
		description = "Stores all the items automatically removed from the ground items plugin highlighted list",
		hidden = true
	)
	default String getGroundItemsPluginHighlightedList()
	{
		return "";
	}

	@ConfigItem(
		keyName = "groundItemsPluginHighlightedList",
		name = "",
		description = "",
		hidden = true
	)
	void setGroundItemsPluginHighlightedList(String list);

	@ConfigItem(
		keyName = "groundItemsPluginHiddenList",
		name = "Ground Items Hidden List",
		description = "Stores all the items automatically added to the ground items plugin hidden list",
		hidden = true
	)
	default String getGroundItemsPluginHiddenList()
	{
		return "";
	}

	@ConfigItem(
		keyName = "groundItemsPluginHiddenList",
		name = "",
		description = "",
		hidden = true
	)
	void setGroundItemsPluginHiddenList(String list);

	@ConfigItem(
		keyName = "barbarianAssaultConfigs",
		name = "Barbarian Assault Configs",
		description = "Stores all the configs previously set on the barbarian assault plugin",
		hidden = true
	)
	default String getBarbarianAssaultConfigs()
	{
		return "";
	}

	@ConfigItem(
		keyName = "barbarianAssaultConfigs",
		name = "",
		description = "",
		hidden = true
	)
	void setBarbarianAssaultConfigs(String configs);
}

/*
 * Copyright (c) 2019, 7ate9 <https://github.com/se7enAte9>
 * Copyright (c) 2020, BegOsrs <https://github.com/BegOsrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.menuentryswapper;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import begosrs.barbarianassault.Wave;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.LinkedHashMultimap;
import com.google.common.collect.Multimap;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;
import java.util.function.Supplier;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.client.util.Text;

@Slf4j
public class MenuEntrySwapper
{

	private final BaMinigameConfig config;
	private final Client client;
	private final BaMinigamePlugin plugin;

	private final Multimap<String, Swap> swaps;
	private final Set<Hide> hides;
	private final ArrayListMultimap<String, Integer> optionIndexes;

	@Inject
	MenuEntrySwapper(final BaMinigameConfig config, final Client client, BaMinigamePlugin plugin)
	{
		this.config = config;
		this.client = client;
		this.plugin = plugin;
		this.swaps = LinkedHashMultimap.create();
		this.hides = new HashSet<>();
		this.optionIndexes = ArrayListMultimap.create();
	}

	private static <T extends Comparable<? super T>> void sortedInsert(List<T> list, T value)
	{
		int idx = Collections.binarySearch(list, value);
		list.add(idx < 0 ? -idx - 1 : idx, value);
	}

	public void enableSwaps()
	{
		addSwap("talk-to", "get-rewards", config::swapGetRewards);

		addSwap("climb-down", "quick-start", config::swapQuickStart);

		addSwap("look-in", "empty", config::swapCollectionBag);
		addSwap("use", "tell-defensive", "collector horn", config::swapCollectorHorn);
		addSwap("use", "destroy", "red egg", config::swapDestroyEggs);
		addSwap("use", "destroy", "green egg", config::swapDestroyEggs);
		addSwap("use", "destroy", "blue egg", config::swapDestroyEggs);

		addSwap("drink-from", "take-from", config::swapHealerSpring);

		addHide("attack", "penance", () -> shouldHideAttOptions(Role.COLLECTOR));
		addHide("attack", "queen spawn", () -> shouldHideAttOptions(Role.COLLECTOR));
		addHide("attack", "penance", () -> shouldHideAttOptions(Role.DEFENDER));
		addHide("attack", "queen spawn", () -> shouldHideAttOptions(Role.DEFENDER));
		addHide("attack", "penance", () -> shouldHideAttOptions(Role.HEALER));
		addHide("attack", "queen spawn", () -> shouldHideAttOptions(Role.HEALER));
	}

	/**
	 * Determines whether to hide attack options for a specific role, based on config and in-game
	 */
	private boolean shouldHideAttOptions(Role role)
	{
		if (plugin.getInGameBit() != 1)
		{
			return false;
		}
		Wave wave = plugin.getWave();
		Role currentRole = null;
		if (wave != null)
		{
			currentRole = wave.getRole();
		}
		if (currentRole == null || !Objects.equals(currentRole, role))
		{
			return false;
		}
		switch (role)
		{
			case COLLECTOR:
				return config.hideAttackOptionsCollector();
			case DEFENDER:
				return config.hideAttackOptionsDefender();
			case HEALER:
				return config.hideAttackOptionsHealer();
		}
		return false;
	}

	public void disableSwaps()
	{
		swaps.clear();
	}

	public void performSwaps()
	{
		// The menu is not rebuilt when it is open, so don't swap or else it will
		// repeatedly swap entries
		if (client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
		{
			return;
		}

		MenuEntry[] menuEntries = client.getMenuEntries();

		// Build option map for quick lookup in findIndex
		int idx = 0;
		optionIndexes.clear();
		for (MenuEntry entry : menuEntries)
		{
			String option = Text.removeTags(entry.getOption()).toLowerCase();
			optionIndexes.put(option, idx++);
		}

		// Perform swaps
		idx = 0;
		for (MenuEntry entry : menuEntries)
		{
			swapMenuEntry(idx++, entry);
		}

		// Perform hiding
		MenuEntry[] filteredEntries = filterHidden(client.getMenuEntries());
		if (filteredEntries.length != menuEntries.length)
		{
			client.setMenuEntries(filteredEntries);
		}
	}

	/**
	 * Filters out menu entries that should be hidden.
	 *
	 * @return the filtered array of entries
	 */
	private MenuEntry[] filterHidden(MenuEntry[] menuEntries)
	{
		List<MenuEntry> filtered = new ArrayList<>();
		for (MenuEntry entry : menuEntries)
		{
			String option = Text.standardize(entry.getOption());
			String target = Text.standardize(entry.getTarget());
			boolean shouldAdd = hides.stream().noneMatch(h ->
				h.getEnabled().get() &&
					h.getOptionPredicate().test(option) &&
					h.getTargetPredicate().test(target));
			if (shouldAdd)
			{
				filtered.add(entry);
			}
		}
		return filtered.toArray(new MenuEntry[0]);
	}

	private void swapMenuEntry(int index, MenuEntry menuEntry)
	{
		final String option = Text.removeTags(menuEntry.getOption()).toLowerCase();
		final String target = Text.removeTags(menuEntry.getTarget()).toLowerCase();

		Collection<Swap> swaps = this.swaps.get(option);

		for (Swap swap : swaps)
		{
			if (swap.getTargetPredicate().test(target) && swap.getEnabled().get())
			{
				if (performSwap(swap.getSwappedOption(), target, index, swap.isStrict()))
				{
					break;
				}
			}
		}
	}

	private void addSwap(String option, String swappedOption, Supplier<Boolean> enabled)
	{
		addSwap(option, s -> true, swappedOption, enabled);
	}

	private void addSwap(String option, String swappedOption, String target, Supplier<Boolean> enabled)
	{
		addSwap(option, s -> Objects.equals(s, target), swappedOption, enabled);
	}

	private void addSwap(String option, Predicate<String> targetPredicate, String swappedOption, Supplier<Boolean> enabled)
	{
		swaps.put(option, new Swap(s -> true, targetPredicate, swappedOption, enabled, true));
	}

	private void addHide(String option, String targetContains, Supplier<Boolean> enabled)
	{
		hides.add(new Hide(s -> Objects.equals(s, option), s -> s.contains(targetContains), enabled, true));
	}

	private boolean performSwap(String option, String target, int index, boolean strict)
	{
		MenuEntry[] menuEntries = client.getMenuEntries();

		// find option to swap with
		int optionIdx = findIndex(menuEntries, index, option, target, strict);

		if (optionIdx >= 0)
		{
			performSwap(optionIndexes, menuEntries, optionIdx, index);
			return true;
		}

		return false;
	}

	private void performSwap(ArrayListMultimap<String, Integer> optionIndexes, MenuEntry[] entries, int index1, int index2)
	{
		MenuEntry entry1 = entries[index1],
			entry2 = entries[index2];

		entries[index1] = entry2;
		entries[index2] = entry1;

		if (entry1.isItemOp() && entry1.getType() == MenuAction.CC_OP_LOW_PRIORITY)
		{
			entry1.setType(MenuAction.CC_OP);
		}
		if (entry2.isItemOp() && entry2.getType() == MenuAction.CC_OP_LOW_PRIORITY)
		{
			entry2.setType(MenuAction.CC_OP);
		}

		client.setMenuEntries(entries);

		// Update optionIndexes
		String option1 = Text.removeTags(entry1.getOption()).toLowerCase(),
			option2 = Text.removeTags(entry2.getOption()).toLowerCase();

		List<Integer> list1 = optionIndexes.get(option1),
			list2 = optionIndexes.get(option2);

		// call remove(Object) instead of remove(int)
		list1.remove((Integer) index1);
		list2.remove((Integer) index2);

		sortedInsert(list1, index2);
		sortedInsert(list2, index1);
	}

	private int findIndex(MenuEntry[] entries, int limit, String option, String target, boolean strict)
	{
		if (strict)
		{
			List<Integer> indexes = optionIndexes.get(option);

			// We want the last index which matches the target, as that is what is top-most
			// on the menu
			for (int i = indexes.size() - 1; i >= 0; --i)
			{
				int idx = indexes.get(i);
				MenuEntry entry = entries[idx];
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

				// Limit to the last index which is prior to the current entry
				if (idx < limit && (target == null || entryTarget.equals(target)))
				{
					return idx;
				}
			}
		}
		else
		{
			// Without strict matching we have to iterate all entries up to the current limit...
			for (int i = limit - 1; i >= 0; i--)
			{
				MenuEntry entry = entries[i];
				String entryOption = Text.removeTags(entry.getOption()).toLowerCase();
				String entryTarget = Text.removeTags(entry.getTarget()).toLowerCase();

				if (entryOption.contains(option.toLowerCase()) && entryTarget.equals(target))
				{
					return i;
				}
			}

		}

		return -1;
	}
}

/*
 * Copyright (c) 2020, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.menuentryswapper;

import lombok.Value;

import java.util.function.Predicate;
import java.util.function.Supplier;

@Value
class Swap
{
	Predicate<String> optionPredicate;
	Predicate<String> targetPredicate;
	String swappedOption;
	Supplier<Boolean> enabled;
	boolean strict;
}
package begosrs.barbarianassault.menuentryswapper;

import java.util.function.Predicate;
import java.util.function.Supplier;
import lombok.Value;

@Value
class Hide
{
	Predicate<String> optionPredicate;
	Predicate<String> targetPredicate;
	Supplier<Boolean> enabled;
	boolean strict;
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.api.BaModelID;
import begosrs.barbarianassault.api.BaObjectID;
import begosrs.barbarianassault.api.widgets.BaWidgetID;
import begosrs.barbarianassault.api.widgets.BaWidgetInfo;
import begosrs.barbarianassault.attackstyle.AttackStyle;
import begosrs.barbarianassault.attackstyle.AttackStyleUtil;
import begosrs.barbarianassault.attackstyle.AttackStyleWidget;
import begosrs.barbarianassault.deathtimes.DeathTimeInfoBox;
import begosrs.barbarianassault.deathtimes.DeathTimesMode;
import begosrs.barbarianassault.grounditems.GroundItem;
import begosrs.barbarianassault.grounditems.GroundItemsOverlay;
import begosrs.barbarianassault.grounditems.MenuHighlightMode;
import begosrs.barbarianassault.groundmarkers.BrokenTrapsOverlay;
import begosrs.barbarianassault.hoppers.CollectorEgg;
import begosrs.barbarianassault.hoppers.HoppersOverlay;
import begosrs.barbarianassault.inventory.InventoryOverlay;
import begosrs.barbarianassault.menuentryswapper.MenuEntrySwapper;
import begosrs.barbarianassault.points.DisplayPointsLocationMode;
import begosrs.barbarianassault.points.DisplayPointsMode;
import begosrs.barbarianassault.points.KandarinDiaryBonusMode;
import begosrs.barbarianassault.points.PointsCounterMode;
import begosrs.barbarianassault.points.PointsMode;
import begosrs.barbarianassault.points.RewardsBreakdownMode;
import begosrs.barbarianassault.points.RolePointsInfoBox;
import begosrs.barbarianassault.points.RolePointsOverlay;
import begosrs.barbarianassault.points.RolePointsTrackingMode;
import begosrs.barbarianassault.teamhealthbar.TeamHealthBarOverlay;
import begosrs.barbarianassault.ticktimer.RunnerTickTimer;
import begosrs.barbarianassault.ticktimer.RunnerTickTimerOverlay;
import begosrs.barbarianassault.timer.DurationMode;
import begosrs.barbarianassault.timer.TimeUnits;
import begosrs.barbarianassault.timer.Timer;
import begosrs.barbarianassault.waveinfo.WaveInfoOverlay;
import com.google.inject.Provides;
import java.awt.Color;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.GroundObject;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.MessageNode;
import net.runelite.api.ObjectID;
import net.runelite.api.Player;
import net.runelite.api.ScriptID;
import net.runelite.api.SpriteID;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.GroundObjectDespawned;
import net.runelite.api.events.GroundObjectSpawned;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ItemDespawned;
import net.runelite.api.events.ItemSpawned;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.events.WidgetClosed;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetConfig;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBox;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.StringUtils;

@Slf4j
@PluginDescriptor(
	name = "Ba Minigame",
	description = "Includes many features to enhance the barbarian assault minigame gameplay experience",
	tags = {"overlay", "b.a.", "barbarian assault", "minigame", "attacker", "defender", "collector", "healer", "plugin hub"}
)
public class BaMinigamePlugin extends Plugin
{
	public static final Color RED = new Color(228, 18, 31);
	public static final Color DARK_GREEN = new Color(0, 153, 0);
	public static final Color LIGHT_BLUE = new Color(60, 124, 240);
	public static final Color LIGHT_RED = new Color(255, 35, 35);
	// also for rangers
	public static final Color FIGHTER_DEATH_COLOR = new Color(255, 48, 69);
	public static final Color HEALER_DEATH_COLOR = new Color(34, 150, 40);
	public static final Color RUNNER_DEATH_COLOR = new Color(51, 102, 255);
	public static final Color DEFAULT_FLASH_COLOR = new Color(255, 255, 255, 126);
	public static final int DEFAULT_ATTACK_STYLE_COLOR = 16750623;
	public static final int WAVE_CHECKMARK_ICON_WIDTH = 13;
	private static final int BA_WAVE_NUM_INDEX = 2;
	private static final String END_ROUND_REWARD_NEEDLE_TEXT = "<br>5";
	private static final int MENU_THIRD_OPTION = MenuAction.GROUND_ITEM_THIRD_OPTION.getId();
	private static final String BA_MINIGAME_CONFIG_GROUP = "baMinigame";
	private static final String GROUND_ITEMS_CONFIG_GROUP = "grounditems";
	private static final String GROUND_ITEMS_CONFIG_HIGHLIGHTED_ITENS = "highlightedItems";
	private static final String GROUND_ITEMS_CONFIG_HIDDEN_ITENS = "hiddenItems";
	private static final String[] GROUND_ITEMS_HIDDEN_LIST = {
		"Green egg", "Red egg", "Blue egg", "Hammer", "Logs", "Yellow egg", "Crackers", "Tofu", "Worms"
	};
	private static final String BARBARIAN_ASSAULT_CONFIG_GROUP = "barbarianAssault";
	private static final String[] BARBARIAN_ASSAULT_CONFIGS = {
		"showTimer", "showHealerBars", "waveTimes"
	};
	private static final int BA_UNDERGROUND_REGION_ID = 10322,
		BA_TILE_START_X = 2522,
		BA_TILE_END_X = 2538,
		BA_TILE_START_Y = 3560,
		BA_TILE_END_Y = 3579;
	private static final int WAVE_ICON_WIDTH = 17;
	private static final int WIDGET_CLICK_MASK = WidgetConfig.USE_GROUND_ITEM | WidgetConfig.USE_NPC
		| WidgetConfig.USE_OBJECT | WidgetConfig.USE_WIDGET;
	private static final BaWidgetInfo[] TEAM_PLAYERS_ROLES_WIDGETS = {
		BaWidgetInfo.BA_TEAM_PLAYER1_ROLE, BaWidgetInfo.BA_TEAM_PLAYER2_ROLE, BaWidgetInfo.BA_TEAM_PLAYER3_ROLE,
		BaWidgetInfo.BA_TEAM_PLAYER4_ROLE, BaWidgetInfo.BA_TEAM_PLAYER5_ROLE
	};
	@Getter
	private final List<GameObject> hoppers = new ArrayList<>(2);
	@Getter
	private final List<GroundObject> brokenTraps = new ArrayList<>(2);
	@Getter
	private final Map<CollectorEgg, Integer> cannonEggs = new HashMap<>(4);
	@Getter
	private final Map<GroundItem.Key, GroundItem> groundEggs = new LinkedHashMap<>();
	@Getter
	private final Map<GroundItem.Key, GroundItem> groundBait = new LinkedHashMap<>();
	@Getter
	private final Map<GroundItem.Key, GroundItem> groundLogsHammer = new LinkedHashMap<>(3);
	private final List<DeathTimeInfoBox> deathTimesInfoBoxes = new ArrayList<>();
	private final Map<String, BufferedImage> images = new HashMap<>(8);
	@Getter
	private final Map<Role, Integer> rolePoints = new EnumMap<>(Role.class);
	private final Map<Role, RolePointsInfoBox> rolePointsInfoBoxes = new EnumMap<>(Role.class);
	private final Role[] playerRoles = new Role[5];
	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private BaMinigameConfig config;
	@Inject
	private ChatMessageManager chatMessageManager;
	@Inject
	private OverlayManager overlayManager;
	@Inject
	private ItemManager itemManager;
	@Inject
	private InfoBoxManager infoBoxManager;
	@Inject
	private ConfigManager configManager;
	@Inject
	private KeyManager keyManager;
	@Inject
	private MenuEntrySwapper menuEntrySwapper;
	@Inject
	private AttackStyleUtil attackStyleUtil;
	@Inject
	private WaveInfoOverlay waveInfoOverlay;
	@Inject
	private InventoryOverlay inventoryOverlay;
	@Inject
	private GroundItemsOverlay groundItemsOverlay;
	@Inject
	private HoppersOverlay hoppersOverlay;
	@Inject
	private RunnerTickTimerOverlay runnerTickTimerOverlay;
	@Inject
	private TeamHealthBarOverlay teamHealthBarOverlay;
	@Inject
	private BaMinigameInputListener inputListener;
	@Inject
	private RolePointsOverlay rolePointsOverlay;
	@Inject
	private BrokenTrapsOverlay brokenTrapsOverlay;
	@Getter
	private RunnerTickTimer runnerTickTimer;
	@Getter
	private int inGameBit;
	@Getter(AccessLevel.PACKAGE)
	private Timer timer;
	@Getter
	private Session session;
	@Getter
	private Round round;
	@Getter
	private Wave wave;
	@Getter(AccessLevel.PACKAGE)
	private int currentWave;
	@Getter
	private String lastListen;
	@Getter
	private int lastListenItemId;
	private Integer attackStyleTextColor;
	@Getter
	private boolean teammatesHealthHotkeyPressed;
	@Setter
	@Getter
	private boolean teammatesHealthShifted;
	private WorldPoint worldPoint;
	private long lastWaveCompletedTimestamp;
	private int correctedCallCount;
	private boolean containsRoleHorn;
	private boolean loadingPlayerRoles;

	@Provides
	BaMinigameConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BaMinigameConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		images.put("fighters", ImageUtil.loadImageResource(getClass(), "/penance_fighter.png"));
		images.put("rangers", ImageUtil.loadImageResource(getClass(), "/penance_ranger.png"));
		images.put("healers", ImageUtil.loadImageResource(getClass(), "/penance_healer.png"));
		images.put("runners", ImageUtil.loadImageResource(getClass(), "/penance_runner.png"));
		images.put("attacker", ImageUtil.loadImageResource(getClass(), "/attacker.png"));
		images.put("defender", ImageUtil.loadImageResource(getClass(), "/defender.png"));
		images.put("collector", ImageUtil.loadImageResource(getClass(), "/collector.png"));
		images.put("healer", ImageUtil.loadImageResource(getClass(), "/healer.png"));

		overlayManager.add(waveInfoOverlay);
		overlayManager.add(inventoryOverlay);
		overlayManager.add(groundItemsOverlay);
		overlayManager.add(hoppersOverlay);
		overlayManager.add(runnerTickTimerOverlay);
		overlayManager.add(teamHealthBarOverlay);
		overlayManager.add(rolePointsOverlay);
		overlayManager.add(brokenTrapsOverlay);

		menuEntrySwapper.enableSwaps();

		clientThread.invokeLater(() -> updateAttackStyleText(lastListen));

		keyManager.registerKeyListener(inputListener);

		if (config.showGroundItemHighlights())
		{
			setGroundItemsPluginLists();
		}
		disableBarbarianAssaultPluginFeatures();
	}

	@Override
	protected void shutDown() throws Exception
	{
		overlayManager.remove(waveInfoOverlay);
		overlayManager.remove(inventoryOverlay);
		overlayManager.remove(groundItemsOverlay);
		overlayManager.remove(hoppersOverlay);
		overlayManager.remove(runnerTickTimerOverlay);
		overlayManager.remove(teamHealthBarOverlay);
		overlayManager.remove(rolePointsOverlay);
		overlayManager.remove(brokenTrapsOverlay);

		menuEntrySwapper.disableSwaps();

		keyManager.unregisterKeyListener(inputListener);

		hoppers.clear();
		brokenTraps.clear();
		cannonEggs.clear();
		groundEggs.clear();
		groundBait.clear();
		groundLogsHammer.clear();
		images.clear();
		rolePoints.clear();

		disableRunnerTickTimer(true);
		removeDeathTimesInfoBoxes();
		removeRolePointsInfoBoxes();
		clientThread.invokeLater(this::restoreHealerTeammatesHealth);
		clientThread.invokeLater(this::restoreAttackStyleText);
		if (wave != null)
		{
			clientThread.invokeLater(() ->
			{
				restoreWaveWidget(wave, true);
				setCallFlashColor(wave, DEFAULT_FLASH_COLOR);
				removeWaveWidgets(wave);
				wave = null;
			});
		}

		timer = null;
		round = null;
		session = null;
		currentWave = 0;

		lastListen = null;
		lastListenItemId = 0;

		restoreGroundItemsPluginLists();
		restoreBarbarianAssaultPluginFeatures();
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		final String group = event.getGroup();
		final String key = event.getKey();
		final String oldValue = event.getOldValue();
		final String newValue = event.getNewValue();
		switch (group)
		{
			case BARBARIAN_ASSAULT_CONFIG_GROUP:
			{
				config.setBarbarianAssaultConfigs("");
				break;
			}
			case BA_MINIGAME_CONFIG_GROUP:
				switch (key)
				{
					case "callChangeFlashColor":
					{
						if (inGameBit == 1)
						{
							setCallFlashColor(wave, config.callChangeFlashColor());
						}
						break;
					}
					case "showCallChangeTimer":
					case "hideTeammateRole":
					{
						if (wave != null)
						{
							clientThread.invokeLater(() ->
							{
								removeWaveWidgets(wave);
								setWaveWidgets(wave);
							});
						}
						break;
					}
					case "showWaveTimer":
					{
						if (!config.showWaveTimer())
						{
							clientThread.invokeLater(() -> restoreWaveWidget(wave, false));
						}
						break;
					}
					case "showHpCountOverlay":
					{
						if (wave != null && getRole() == Role.HEALER)
						{
							clientThread.invokeLater(() ->
							{
								removeWaveWidgets(wave);
								setWaveWidgets(wave);
							});
						}
						break;
					}
					case "showEggCountOverlay":
					{
						if (wave != null && getRole() == Role.COLLECTOR)
						{
							clientThread.invokeLater(() ->
							{
								removeWaveWidgets(wave);
								setWaveWidgets(wave);
							});
						}
						break;
					}
					case "showRunnerTickTimerAttacker":
					{
						final boolean display = config.showRunnerTickTimerAttacker() && inGameBit == 1 && getRole() == Role.ATTACKER;
						enableRunnerTickTimer(display);
						break;
					}
					case "showRunnerTickTimerDefender":
					{
						final boolean display = config.showRunnerTickTimerDefender() && inGameBit == 1 && getRole() == Role.DEFENDER;
						enableRunnerTickTimer(display);
						break;
					}
					case "showRunnerTickTimerCollector":
					{
						final boolean display = config.showRunnerTickTimerCollector() && inGameBit == 1 && getRole() == Role.COLLECTOR;
						enableRunnerTickTimer(display);
						break;
					}
					case "showRunnerTickTimerHealer":
					{
						final boolean display = config.showRunnerTickTimerHealer() && inGameBit == 1 && getRole() == Role.HEALER;
						enableRunnerTickTimer(display);
						break;
					}
					case "deathTimesMode":
					{
						final DeathTimesMode deathTimesMode = config.deathTimesMode();
						if (deathTimesMode == DeathTimesMode.INFO_BOX || deathTimesMode == DeathTimesMode.INFOBOX_CHAT)
						{
							showDeathTimes();
						}
						else
						{
							hideDeathTimesInfoBoxes();
						}
						break;
					}
					case "displayPointsMode":
					{
						final DisplayPointsMode pointsMode = config.displayPointsMode();
						if (pointsMode == DisplayPointsMode.INFO_BOX)
						{
							clientThread.invokeLater(() -> updateRolePoints(false));
						}
						else
						{
							hideRolePointsInfoBoxes();
						}
						break;
					}
					case "displayPointsLocationMode":
					{
						if (!shouldDisplayRolePoints())
						{
							hideRolePointsInfoBoxes();
						}
						else
						{
							clientThread.invokeLater(() -> updateRolePoints(true));
						}
						break;
					}
					case "highlightAttackStyle":
					case "highlightAttackStyleColor":
					{
						clientThread.invokeLater(() -> updateAttackStyleText(lastListen));
						break;
					}
					case "showGroundItemHighlights":
					{
						if (config.showGroundItemHighlights())
						{
							setGroundItemsPluginLists();
						}
						else
						{
							restoreGroundItemsPluginLists();
						}
						break;
					}
					case "groundItemsPluginHighlightedList":
					{
						if (!oldValue.isEmpty() && newValue.isEmpty())
						{
							config.setGroundItemsPluginHighlightedList(oldValue);
						}
						break;
					}
					case "groundItemsPluginHiddenList":
					{
						if (!oldValue.isEmpty() && newValue.isEmpty())
						{
							config.setGroundItemsPluginHiddenList(oldValue);
						}
						break;
					}
					case "barbarianAssaultConfigs":
					{
						if (!oldValue.isEmpty() && newValue.isEmpty())
						{
							config.setBarbarianAssaultConfigs(oldValue);
						}
						break;
					}
					case "hideHealerTeammatesHealth":
					{
						if (wave != null && wave.getRole() == Role.HEALER)
						{
							setHealerTeammatesHealthDisplay();
						}
						break;
					}
					case "showWaveCompleted":
					{
						if (!config.showWaveCompleted())
						{
							restoreWaveIcon(wave);
						}
						break;
					}
					case "pointsCounterMode":
					case "rolePointsTrackingMode":
					{
						clientThread.invokeLater(() -> updateRolePoints(false));
						break;
					}
					case "resetPoints":
					{
						resetRolePoints();
						break;
					}
					case "kandarinHardDiaryPointsBoost":
					{
						final PointsCounterMode pointsCounterMode = config.pointsCounterMode();
						if (pointsCounterMode != PointsCounterMode.CURRENT_POINTS)
						{
							clientThread.invokeLater(() -> updateRolePoints(false));
						}
					}
				}
				break;
		}
	}

	@Subscribe
	public void onWidgetLoaded(WidgetLoaded event)
	{
		switch (event.getGroupId())
		{
			case BaWidgetID.BA_REWARD_GROUP_ID:
			{
				Widget rewardWidget = client.getWidget(BaWidgetInfo.BA_REWARD_TEXT.getGroupId(), BaWidgetInfo.BA_REWARD_TEXT.getChildId());
				if (rewardWidget == null)
				{
					break;
				}

				if (!rewardWidget.getText().contains(END_ROUND_REWARD_NEEDLE_TEXT))
				{
					onWaveEnded(false);
				}
				else if (round != null)
				{
					announceRoundInfo();
				}
				break;
			}
			case BaWidgetID.BA_ATTACKER_GROUP_ID:
			{
				startWave(Role.ATTACKER, config.showRunnerTickTimerAttacker());
				break;
			}
			case BaWidgetID.BA_DEFENDER_GROUP_ID:
			{
				startWave(Role.DEFENDER, config.showRunnerTickTimerDefender());
				break;
			}
			case BaWidgetID.BA_COLLECTOR_GROUP_ID:
			{
				startWave(Role.COLLECTOR, config.showRunnerTickTimerCollector());
				break;
			}
			case BaWidgetID.BA_HEALER_GROUP_ID:
			{
				startWave(Role.HEALER, config.showRunnerTickTimerHealer());
				break;
			}
			case InterfaceID.BA_TEAM:
			{
				loadingPlayerRoles = true;
				break;
			}
			case BaWidgetID.CONNAD_REWARDS_GROUP_ID:
			{
				if (config.scrollConnadRewards())
				{
					scrollConnadRewards();
				}
			}
		}
	}

	private void scrollConnadRewards()
	{
		final Widget parent = client.getWidget(BaWidgetInfo.CONNAD_REWARDS_CONTENT.getGroupId(),
			BaWidgetInfo.CONNAD_REWARDS_CONTENT.getChildId());
		if (parent == null)
		{
			return;
		}
		client.runScript(ScriptID.UPDATE_SCROLLBAR, BaWidgetInfo.CONNAD_REWARDS_SCROLLBAR.getId(),
			BaWidgetInfo.CONNAD_REWARDS_CONTENT.getId(), parent.getScrollHeight());
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == InterfaceID.BA_TEAM)
		{
			loadingPlayerRoles = false;
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// varbit change and widget loading are not reliable enough to start the wave timer

		final ItemContainer container = event.getItemContainer();
		if (container == client.getItemContainer(InventoryID.INVENTORY))
		{
			final Item[] inventory = event.getItemContainer().getItems();
			boolean containsRoleHorn = Arrays.stream(inventory).map(Item::getId).anyMatch(id ->
				id == ItemID.ATTACKER_HORN
					|| id == ItemID.ATTACKER_HORN_10517
					|| id == ItemID.ATTACKER_HORN_10518
					|| id == ItemID.ATTACKER_HORN_10519
					|| id == ItemID.ATTACKER_HORN_10520
					|| id == ItemID.DEFENDER_HORN
					|| id == ItemID.COLLECTOR_HORN
					|| id == ItemID.HEALER_HORN
					|| id == ItemID.HEALER_HORN_10527
					|| id == ItemID.HEALER_HORN_10528
					|| id == ItemID.HEALER_HORN_10529
					|| id == ItemID.HEALER_HORN_10530
			);
			if (containsRoleHorn && !this.containsRoleHorn)
			{
				startWave(null, false);
			}
			this.containsRoleHorn = containsRoleHorn;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage chatMessage)
	{
		final ChatMessageType type = chatMessage.getType();
		// for some reason, the 'All of the Penance ... have been killed' are WELCOME messages for Healer/Collector/Defender roles
		if (type != ChatMessageType.GAMEMESSAGE && type != ChatMessageType.WELCOME)
		{
			return;
		}

		final String message = chatMessage.getMessage();
		if (message.startsWith("---- Wave:"))
		{
			currentWave = Integer.parseInt(message.split(" ")[BA_WAVE_NUM_INDEX]);

			if (round == null || currentWave == Round.STARTING_WAVE)
			{
				timer = new Timer();
				round = new Round(currentWave, timer);
			}

			// wave will be set on onWidgetLoaded which happens after onChatMessage.
			// Reset here in case we are restarting the same wave (no onWidgetLoaded happened).
			wave = null;
		}
		else
		{
			if (wave != null && message.contains("exploded"))
			{
				wave.setWrongEggsCount(wave.getWrongEggsCount() + 1);
				wave.setEggsCount(wave.getEggsCount() - 1);
			}
			else if (wave != null && wave.getNumber() != 10 && message.contains("You healed "))
			{
				final int health = Integer.parseInt(message.split(" ")[2]);
				wave.setHpHealed(wave.getHpHealed() + health);
			}
			else if (config.highlightNotification() && message.contains("the wrong type of poisoned food to use"))
			{
				final MessageNode messageNode = chatMessage.getMessageNode();
				final String nodeValue = Text.removeTags(messageNode.getValue());
				messageNode.setValue(ColorUtil.wrapWithColorTag(nodeValue, config.highlightNotificationColor()));
			}
			else if (wave != null && message.startsWith("All of the Penance "))
			{
				final MessageNode node = chatMessage.getMessageNode();
				String nodeValue = Text.removeTags(node.getValue());
				Color deathColor = FIGHTER_DEATH_COLOR;
				final String npc = nodeValue.split(" ")[4];

				Role role = wave.getRole();

				switch (npc)
				{
					case "Fighters":
						wave.setFightersKilled(true);
						break;
					case "Rangers":
						wave.setRangersKilled(true);
						break;
					case "Healers":
						wave.setHealersKilled(true);
						deathColor = HEALER_DEATH_COLOR;
						break;
					case "Runners":
						wave.setRunnersKilled(true);
						deathColor = RUNNER_DEATH_COLOR;
						break;
				}

				if (config.deathMessageColor() != null)
				{
					deathColor = config.deathMessageColor();
					if (role == Role.ATTACKER && (npc.equals("Fighters") || npc.equals("Rangers"))
						|| role == Role.HEALER && npc.equals("Healers")
						|| role == Role.DEFENDER && npc.equals("Runners"))
					{
						nodeValue = ColorUtil.wrapWithColorTag(nodeValue, config.deathMessageColor());
						node.setValue(nodeValue);
					}
				}
				else
				{
					// preserve original color tag on npc name
					nodeValue = node.getValue();
					node.setValue(nodeValue);
				}

				if (wave.getTimer() != null)
				{
					final TimeUnits units = config.timeUnits();
					final String timeFormat = units.getFormatString();
					final float time = wave.getTimeElapsed(false, units);
					addDeathTimesInfoBoxes(npc, time, timeFormat);

					final DeathTimesMode deathTimesMode = config.deathTimesMode();
					if (deathTimesMode == DeathTimesMode.CHAT || deathTimesMode == DeathTimesMode.INFOBOX_CHAT)
					{
						String timeElapsed = String.format(timeFormat, time) + "s";
						if (config.enableGameChatColors())
						{
							timeElapsed = ColorUtil.wrapWithColorTag(timeElapsed, deathColor);
						}

						node.setValue(nodeValue + " " + timeElapsed);
					}
				}
			}
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged event)
	{
		final int currentInGame = client.getVarbitValue(Varbits.IN_GAME_BA);

		if (inGameBit != currentInGame)
		{
			int previousInGameBit = inGameBit;
			inGameBit = currentInGame;
			if (previousInGameBit == 1)
			{
				// Use an instance check to determine if this is exiting a game or a tutorial
				// After exiting tutorials there is a small delay before changing IN_GAME_BA back to
				// 0 whereas when in a real wave it changes while still in the instance.
				final DurationMode durationMode = config.showDurationMode();
				if ((durationMode == DurationMode.WAVE || durationMode == DurationMode.WAVE_ROUND)
					&& wave != null && client.isInInstancedRegion())
				{
					announceWaveTime();
					if (currentWave == 10)
					{
						onRoundEnded();
					}
				}

				stopWave();
			}
			else
			{
				startWave(null, false);
			}
		}

		if (inGameBit == 1)
		{
			updateEggsCount();
		}

		updateRolePoints(false);
	}

	private void updateRolePoints(boolean forceDisplay)
	{
		final boolean shouldDisplayRolePoints = forceDisplay || shouldDisplayRolePoints();
		PointsCounterMode pointsCounterMode = config.pointsCounterMode();
		boolean diaryBonus = includeKandarinBonus();
		for (Role role : Role.values())
		{
			int points = 0;
			if (pointsCounterMode == PointsCounterMode.CURRENT_POINTS)
			{
				points = role.getPoints(client);
			}
			else if (round != null && pointsCounterMode == PointsCounterMode.ROUND_POINTS)
			{
				points = round.getRolePoints(role);
				if (diaryBonus)
				{
					points *= 1.1;
				}
			}
			else if (session != null && pointsCounterMode == PointsCounterMode.SESSION_POINTS)
			{
				points = session.getRolePoints(role);
				if (diaryBonus)
				{
					points *= 1.1;
				}
			}

			rolePoints.put(role, points);

			if (shouldDisplayRolePoints)
			{
				addOrUpdateRolePointsInfoBoxes(role, points);
			}
		}
	}

	private boolean includeKandarinBonus()
	{
		return config.kandarinHardDiaryPointsBonus() == KandarinDiaryBonusMode.YES
			|| config.kandarinHardDiaryPointsBonus() == KandarinDiaryBonusMode.IF_COMPLETED &&
			client.getVarbitValue(Varbits.DIARY_KANDARIN_HARD) == 1;
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired scriptPostFired)
	{
		if (scriptPostFired.getScriptId() == ScriptID.COMBAT_INTERFACE_SETUP)
		{
			clientThread.invokeLater(() -> updateAttackStyleText(lastListen));
		}
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		final DisplayPointsLocationMode pointsLocationMode = config.displayPointsLocationMode();
		if (pointsLocationMode == DisplayPointsLocationMode.OUTPOST ||
			pointsLocationMode == DisplayPointsLocationMode.OUTPOST_INGAME)
		{
			final Player player = client.getLocalPlayer();
			if (player != null)
			{
				final WorldPoint worldPoint = player.getWorldLocation();
				if (worldPoint != this.worldPoint)
				{
					this.worldPoint = worldPoint;
					if (!shouldDisplayRolePoints())
					{
						hideRolePointsInfoBoxes();
					}
				}
			}
		}

		if (timer != null)
		{
			timer.onGameTick();
		}

		if (inGameBit == 1)
		{
			if (wave != null)
			{
				final Role role = wave.getRole();
				if (role != null)
				{
					final String currentListen = role.getListenText(client);
					if (currentListen != null && !currentListen.equals(lastListen))
					{
						clientThread.invokeLater(() -> updateAttackStyleText(currentListen));

						if (config.announceCallCorrection())
						{
							checkCallCorrection(currentListen);
						}
					}

					lastListen = currentListen;
					lastListenItemId = role.getListenItemId(client);
				}
			}
			if (runnerTickTimer != null)
			{
				runnerTickTimer.incrementCount();
			}
		}
		else if (loadingPlayerRoles)
		{
			for (int i = 0; i < TEAM_PLAYERS_ROLES_WIDGETS.length; i++)
			{
				final Widget playerRole = client.getWidget(TEAM_PLAYERS_ROLES_WIDGETS[i].getGroupId(), TEAM_PLAYERS_ROLES_WIDGETS[i].getChildId());
				if (playerRole != null)
				{
					playerRoles[i] = getRoleForModelId(playerRole.getModelId());
				}
				else
				{
					playerRoles[i] = null;
				}
			}
		}

		if (session != null
			&& System.currentTimeMillis() >= lastWaveCompletedTimestamp + TimeUnit.MINUTES.toMillis(config.sessionResetTime()))
		{
			session.reset();
			updateRolePoints(false);
		}
	}

	private Role getRoleForModelId(int modelId)
	{
		for (Role role : Role.values())
		{
			if (role.getRoleModelId() == modelId)
			{
				return role;
			}
		}
		return null;
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned gameObjectSpawned)
	{
		final GameObject gameObject = gameObjectSpawned.getGameObject();
		if (isHopperGameObject(gameObject.getId()))
		{
			hoppers.add(gameObject);
		}
	}

	@Subscribe
	public void onGroundObjectSpawned(GroundObjectSpawned groundObjectSpawned)
	{
		final GroundObject groundObject = groundObjectSpawned.getGroundObject();
		if (groundObject.getId() == ObjectID.BROKEN_TRAP0)
		{
			brokenTraps.add(groundObject);
		}
	}

	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned gameObjectDespawned)
	{
		final GameObject gameObject = gameObjectDespawned.getGameObject();
		if (isHopperGameObject(gameObject.getId()))
		{
			hoppers.remove(gameObject);
		}
	}

	@Subscribe
	public void onGroundObjectDespawned(GroundObjectDespawned groundObjectDespawned)
	{
		final GroundObject groundObject = groundObjectDespawned.getGroundObject();
		if (groundObject.getId() == ObjectID.BROKEN_TRAP0)
		{
			brokenTraps.remove(groundObject);
		}
	}

	@Subscribe
	public void onItemSpawned(ItemSpawned itemSpawned)
	{
		final Role role = getRole();
		if (role == null)
		{
			return;
		}

		final TileItem item = itemSpawned.getItem();
		final Tile tile = itemSpawned.getTile();

		addItemSpawn(item, tile, role);
	}

	@Subscribe
	public void onItemDespawned(ItemDespawned itemDespawned)
	{
		final Role role = getRole();
		if (role == null)
		{
			return;
		}

		TileItem item = itemDespawned.getItem();
		Tile tile = itemDespawned.getTile();

		removeItemSpawn(item, tile, role);
	}

	@Subscribe
	public void onClientTick(ClientTick clientTick)
	{
		menuEntrySwapper.performSwaps();
	}

	public Role getRole()
	{
		return wave == null ? null : wave.getRole();
	}

	private void updateAttackStyleText(String listen)
	{
		restoreAttackStyleText();

		if (!config.highlightAttackStyle() || listen == null || getRole() != Role.ATTACKER)
		{
			return;
		}

		final int var = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
		final AttackStyle[] styles = attackStyleUtil.getWeaponTypeStyles(var);

		for (int i = 0; i < styles.length; i++)
		{
			final AttackStyle style = styles[i];

			if (style == null || !listen.startsWith(style.getName()))
			{
				continue;
			}

			final int color = Integer.decode(ColorUtil.toHexColor(config.highlightAttackStyleColor()));

			final AttackStyleWidget attackStyleWidget = AttackStyleWidget.getAttackStyles()[i];

			final BaWidgetInfo attackStyleTextBaWidgetInfo = attackStyleWidget.getTextWidget();
			final Widget attackStyleTextWidget = client.getWidget(attackStyleTextBaWidgetInfo.getGroupId(),
				attackStyleTextBaWidgetInfo.getChildId());
			if (attackStyleTextWidget != null)
			{
				if (attackStyleTextColor == null)
				{
					attackStyleTextColor = attackStyleTextWidget.getTextColor();
				}
				attackStyleTextWidget.setTextColor(color);
			}
		}
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		final Role role = getRole();
		if (role == null)
		{
			return;
		}

		final String listen = lastListen != null ? lastListen : "";

		MenuEntry[] menuEntries = client.getMenuEntries();
		final MenuEntry entry = menuEntries[menuEntries.length - 1];
		String entryOption = Text.removeTags(entry.getOption());
		String entryTarget = Text.removeTags(entry.getTarget());

		final MenuHighlightMode mode = config.menuHighlightMode();

		if (mode != MenuHighlightMode.DISABLED
			&& role == Role.COLLECTOR
			&& entryOption.equals("Take")
			&& event.getType() == MENU_THIRD_OPTION
			&& listen.startsWith(entryTarget))
		{
			Color color = getEggColorFromName(entryTarget.split(" ")[0]);
			if (color != null)
			{

				if (mode == MenuHighlightMode.OPTION_NAME || mode == MenuHighlightMode.OPTION)
				{
					entryOption = ColorUtil.prependColorTag("Take", color);
					entry.setOption(entryOption);
				}

				if (mode == MenuHighlightMode.OPTION_NAME || mode == MenuHighlightMode.NAME)
				{
					entryTarget = ColorUtil.prependColorTag(entryTarget.substring(entryTarget.indexOf('>') + 1), color);
					entry.setTarget(entryTarget);
				}
			}

		}

		client.setMenuEntries(menuEntries);
	}

	public Color getColorForInventoryItemId(int itemId)
	{
		switch (itemId)
		{
			case ItemID.BULLET_ARROW:
			case ItemID.FIELD_ARROW:
			case ItemID.BLUNT_ARROW:
			case ItemID.BARBED_ARROW:
				return config.highlightArrowColor();
			case ItemID.POISONED_TOFU:
			case ItemID.POISONED_WORMS:
			case ItemID.POISONED_MEAT:
				return config.highlightPoisonColor();
			case ItemID.CRACKERS:
			case ItemID.TOFU:
			case ItemID.WORMS:
				return config.highlightBaitColor();
		}

		return null;
	}

	public Color getColorForGroundItemId(int itemId)
	{
		switch (itemId)
		{
			case ItemID.GREEN_EGG:
				return Color.GREEN;
			case ItemID.RED_EGG:
				return BaMinigamePlugin.LIGHT_RED;
			case ItemID.BLUE_EGG:
				return BaMinigamePlugin.LIGHT_BLUE;
			case ItemID.YELLOW_EGG:
				return Color.YELLOW;
			case ItemID.CRACKERS:
			case ItemID.TOFU:
			case ItemID.WORMS:
				return config.highlightGroundBaitColor();
			case ItemID.LOGS:
			case ItemID.HAMMER:
				return config.highlightGroundLogsHammerColor();
		}
		return null;
	}

	private void restoreAttackStyleText()
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		final int color = attackStyleTextColor != null ? attackStyleTextColor : DEFAULT_ATTACK_STYLE_COLOR;

		final int var = client.getVarbitValue(Varbits.EQUIPPED_WEAPON_TYPE);
		final AttackStyle[] styles = attackStyleUtil.getWeaponTypeStyles(var);

		for (int i = 0; i < styles.length; i++)
		{
			AttackStyle style = styles[i];
			if (style == null)
			{
				continue;
			}

			if (style == AttackStyle.CASTING || style == AttackStyle.DEFENSIVE_CASTING)
			{
				// magic attack styles will never be highlighted
				continue;
			}

			final AttackStyleWidget attackStyleWidget = AttackStyleWidget.getAttackStyles()[i];
			final BaWidgetInfo attackStyleTextBaWidgetInfo = attackStyleWidget.getTextWidget();

			final Widget attackStyleTextWidget = client.getWidget(attackStyleTextBaWidgetInfo.getGroupId(),
				attackStyleTextBaWidgetInfo.getChildId());
			if (attackStyleTextWidget != null)
			{
				attackStyleTextWidget.setTextColor(color);
			}
		}

		attackStyleTextColor = null;
	}

	private void onWaveEnded(boolean roundEnded)
	{
		Wave wave = this.wave;
		if (wave == null)
		{
			wave = new Wave(client, currentWave);
		}

		wave.setPoints(roundEnded);
		if (!roundEnded)
		{
			wave.setAmounts();

			final BaWidgetInfo pointsBaWidgetInfo = BaWidgetInfo.BA_REWARD_TEXT;
			final Widget pointsWidget = client.getWidget(pointsBaWidgetInfo.getGroupId(), pointsBaWidgetInfo.getChildId());
			if (pointsWidget != null)
			{
				final boolean colorful = config.enableGameChatColors();

				final PointsMode pointsMode = config.showRewardPointsMode();
				if (pointsMode == PointsMode.WAVE || pointsMode == PointsMode.WAVE_ROUND)
				{
					ChatMessageBuilder wavePoints = wave.getWavePoints(colorful, includeKandarinBonus());
					announce(wavePoints);
				}

				final RewardsBreakdownMode rewardsBreakdownMode = config.showRewardsBreakdownMode();
				if (rewardsBreakdownMode == RewardsBreakdownMode.WAVE || rewardsBreakdownMode == RewardsBreakdownMode.WAVE_ROUND)
				{
					ChatMessageBuilder waveSummary = wave.getWaveSummary(colorful);
					announce(waveSummary);
				}
			}
		}

		if (round != null)
		{
			round.addWave(wave, config.rolePointsTrackingMode());
		}

		if (session == null)
		{
			session = new Session();
		}
		session.addWave(wave, config.rolePointsTrackingMode());

		PointsCounterMode pointsCounterMode = config.pointsCounterMode();
		if (pointsCounterMode == PointsCounterMode.ROUND_POINTS || pointsCounterMode == PointsCounterMode.SESSION_POINTS)
		{
			updateRolePoints(false);
		}

		this.wave = null;
		currentWave = 0;
		lastWaveCompletedTimestamp = System.currentTimeMillis();
	}

	private void onRoundEnded()
	{
		if (round == null)
		{
			return;
		}

		onWaveEnded(true);
		if (timer != null)
		{
			timer.setRoundEnded();
		}
	}

	// wave starts when ba ingamebit == 1 (without role set) or when ba widgets are loaded (with role set)
	private void startWave(Role role, boolean displayTickTimer)
	{
		// Prevent changing waves when a wave is already set, as widgets can be
		// loaded multiple times in game from eg. opening and closing the horn
		// of glory.
		if (wave != null)
		{
			if (wave.getRole() == null && role != null)
			{
				// wave has started at ba ingamebit == 1, but role is not set
				wave.setRole(role);
				setCallFlashColor(wave, config.callChangeFlashColor());
				if (role == Role.HEALER)
				{
					setHealerTeammatesHealthDisplay();
				}
				runnerTickTimer.setDisplaying(displayTickTimer);
				clientThread.invokeLater(() -> setWaveWidgets(wave));
			}
			return;
		}

		if (timer == null)
		{
			timer = new Timer();
		}

		log.debug("Starting wave {} with roles 1={} 2={} 3={} 4={} 5={} at {}", currentWave, playerRoles[0],
			playerRoles[1], playerRoles[2], playerRoles[3], playerRoles[4],
			timer.getRoundTimeFormatted(config.timeUnits()));

		timer.setWaveStartTime();
		wave = new Wave(client, currentWave, playerRoles, timer);
		wave.setRole(role);
		runnerTickTimer = new RunnerTickTimer();
		runnerTickTimer.setDisplaying(displayTickTimer);
		correctedCallCount = 0;

		if (role != null)
		{
			setCallFlashColor(wave, config.callChangeFlashColor());
			if (role == Role.HEALER)
			{
				setHealerTeammatesHealthDisplay();
			}
			clientThread.invokeLater(() -> setWaveWidgets(wave));
		}
	}

	private void setWaveWidgets(Wave wave)
	{
		if (wave == null)
		{
			return;
		}
		Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		Widget waveInfoWidget = client.getWidget(role.getWaveInfo().getGroupId(), role.getWaveInfo().getChildId());
		if (waveInfoWidget == null)
		{
			return;
		}
		Widget waveTextWidget = client.getWidget(role.getWaveText().getGroupId(), role.getWaveText().getChildId());
		if (waveTextWidget == null)
		{
			return;
		}

		waveInfoWidget.setOriginalHeight(130);
		waveInfoWidget.revalidate();

		boolean showingCounter = role == Role.HEALER && config.showHpCountOverlay()
			|| role == Role.COLLECTOR && config.showEggCountOverlay();
		if (showingCounter)
		{
			Widget roleCounter = waveInfoWidget.createChild(0, WidgetType.TEXT);
			roleCounter.setFontId(waveTextWidget.getFontId());
			roleCounter.setTextColor(waveTextWidget.getTextColor());
			roleCounter.setTextShadowed(true);
			roleCounter.setOriginalX(24);
			roleCounter.setOriginalY(config.hideTeammateRole() ? 57 : 78);
			roleCounter.setOriginalHeight(32);
			roleCounter.setOriginalWidth(75);
			roleCounter.setXTextAlignment(WidgetTextAlignment.RIGHT);
			roleCounter.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
			roleCounter.setYPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
			roleCounter.setClickMask(WIDGET_CLICK_MASK);
			roleCounter.setNoClickThrough(false);
			roleCounter.revalidate();

			Widget roleCounterIcon;
			if (role == Role.HEALER)
			{
				roleCounterIcon = waveInfoWidget.createChild(1, WidgetType.GRAPHIC);
				roleCounterIcon.setSpriteId(SpriteID.SPELL_CURE_ME);
				roleCounterIcon.setOriginalHeight(17);
				roleCounterIcon.setOriginalWidth(17);
			}
			else
			{
				roleCounterIcon = waveInfoWidget.createChild(1, WidgetType.MODEL);
				// yellow egg model, from team widget on ba lobby
				roleCounterIcon.setModelId(BaModelID.BA_COLLECTOR_ICON);
				roleCounterIcon.setModelType(1);
				roleCounterIcon.setModelZoom(4112);
				roleCounterIcon.setRotationX(510);
				roleCounterIcon.setRotationZ(2014);
				roleCounterIcon.setOriginalHeight(16);
				roleCounterIcon.setOriginalWidth(16);
			}
			roleCounterIcon.setOriginalX(380);
			roleCounterIcon.setOriginalY(config.hideTeammateRole() ? 64 : 87);
			roleCounterIcon.setClickMask(WIDGET_CLICK_MASK);
			roleCounterIcon.setNoClickThrough(false);
			roleCounterIcon.revalidate();
		}

		if (config.showCallChangeTimer())
		{
			if (showingCounter)
			{
				setCallTimerWidget(waveInfoWidget, waveTextWidget, config.hideTeammateRole() ? 80 : 100,
					config.hideTeammateRole() ? 89 : 109);
			}
			else if (role == Role.ATTACKER)
			{
				setCallTimerWidget(waveInfoWidget, waveTextWidget, config.hideTeammateRole() ? 67 : 87,
					config.hideTeammateRole() ? 76 : 96);
			}
			else
			{
				setCallTimerWidget(waveInfoWidget, waveTextWidget, config.hideTeammateRole() ? 58 : 78,
					config.hideTeammateRole() ? 67 : 87);
			}
		}

		final Widget roleText = client.getWidget(role.getRoleText().getGroupId(), role.getRoleText().getChildId());
		if (roleText != null)
		{
			roleText.setHidden(config.hideTeammateRole());
		}
		final Widget roleSprite = client.getWidget(role.getRoleSprite().getGroupId(), role.getRoleSprite().getChildId());
		if (roleSprite != null)
		{
			roleSprite.setHidden(config.hideTeammateRole());
		}
	}

	private void setCallTimerWidget(Widget waveInfoWidget, Widget waveTextWidget, int textOriginalY, int iconOriginalY)
	{
		Widget callTimer = waveInfoWidget.createChild(2, WidgetType.TEXT);
		callTimer.setFontId(waveTextWidget.getFontId());
		callTimer.setTextColor(waveTextWidget.getTextColor());
		callTimer.setTextShadowed(true);
		callTimer.setOriginalX(24);
		callTimer.setOriginalY(textOriginalY);
		callTimer.setOriginalHeight(32);
		callTimer.setOriginalWidth(75);
		callTimer.setXTextAlignment(WidgetTextAlignment.RIGHT);
		callTimer.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
		callTimer.setYPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
		callTimer.setText("- - -");
		callTimer.setClickMask(WIDGET_CLICK_MASK);
		callTimer.setNoClickThrough(false);
		callTimer.revalidate();

		Widget callTimerIcon = waveInfoWidget.createChild(3, WidgetType.GRAPHIC);
		callTimerIcon.setSpriteId(getRole().getHornSpriteId());
		callTimerIcon.setOriginalX(380);
		callTimerIcon.setOriginalY(iconOriginalY);
		callTimerIcon.setOriginalHeight(13);
		callTimerIcon.setOriginalWidth(17);
		callTimerIcon.setClickMask(WIDGET_CLICK_MASK);
		callTimerIcon.setNoClickThrough(false);
		callTimerIcon.revalidate();
	}

	private void removeWaveWidgets(Wave wave)
	{
		if (wave == null)
		{
			return;
		}
		Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		Widget waveInfoWidget = client.getWidget(role.getWaveInfo().getGroupId(), role.getWaveInfo().getChildId());
		if (waveInfoWidget == null)
		{
			return;
		}
		Widget[] children = waveInfoWidget.getChildren();
		if (children == null)
		{
			return;
		}
		if (children.length > 0 && children[0] != null)
		{
			children[0].setHidden(true);
			children[0] = null;
		}
		if (children.length > 1 && children[1] != null)
		{
			children[1].setHidden(true);
			children[1] = null;
		}
		if (children.length > 2 && children[2] != null)
		{
			children[2].setHidden(true);
			children[2] = null;
		}
		if (children.length > 3 && children[3] != null)
		{
			children[3].setHidden(true);
			children[3] = null;
		}
	}

	private void setCallFlashColor(Wave wave, Color flashColor)
	{
		if (wave == null)
		{
			return;
		}
		final Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		final Widget callFlashWidget = client.getWidget(role.getCallFlash().getGroupId(), role.getCallFlash().getChildId());
		if (callFlashWidget != null)
		{
			final int color = Integer.decode(ColorUtil.toHexColor(new Color(flashColor.getRed(), flashColor.getGreen(), flashColor.getBlue())));
			callFlashWidget.setTextColor(color);
			callFlashWidget.setOpacity(255 - flashColor.getAlpha());
		}
	}

	private void removeCallChangeTimer(Wave wave)
	{
		if (wave == null)
		{
			return;
		}
		Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		Widget waveInfoWidget = client.getWidget(role.getWaveInfo().getGroupId(), role.getWaveInfo().getChildId());
		if (waveInfoWidget == null)
		{
			return;
		}
		Widget[] children = waveInfoWidget.getChildren();
		if (children != null && children.length >= 4)
		{
			if (children[2] != null)
			{
				children[2].setHidden(true);
				children[2] = null;
			}
			if (children[3] != null)
			{
				children[3].setHidden(true);
				children[3] = null;
			}
		}
	}

	private void restoreWaveWidget(Wave wave, boolean restoreIcon)
	{
		if (wave == null)
		{
			return;
		}
		Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		final BaWidgetInfo waveInfo = role.getWaveText();
		final Widget waveText = client.getWidget(waveInfo.getGroupId(), waveInfo.getChildId());
		if (waveText != null)
		{
			waveText.setText("Wave " + wave.getNumber());
		}
		if (restoreIcon)
		{
			restoreWaveIcon(wave);
		}
	}

	private void restoreWaveIcon(Wave wave)
	{
		if (wave == null)
		{
			return;
		}
		Role role = wave.getRole();
		if (role == null)
		{
			return;
		}
		final Widget waveSprite = client.getWidget(role.getWaveSprite().getGroupId(), role.getWaveSprite().getChildId());
		if (waveSprite != null)
		{
			waveSprite.setSpriteId(SpriteID.BARBARIAN_ASSAULT_WAVE_ICON);
			waveSprite.setOriginalWidth(WAVE_ICON_WIDTH);
			waveSprite.setOriginalX(3);
		}
	}

	private void stopWave()
	{
		hoppers.clear();
		brokenTraps.clear();
		cannonEggs.clear();
		groundEggs.clear();
		groundBait.clear();
		groundLogsHammer.clear();
		disableRunnerTickTimer(true);
		removeDeathTimesInfoBoxes();
		lastListen = null;
		lastListenItemId = 0;
		clientThread.invokeLater(this::restoreAttackStyleText);
	}

	private void announceWaveTime()
	{
		if (wave == null || wave.getTimer() == null)
		{
			return;
		}

		final String time = wave.getTimer().getWaveTimeFormatted(config.timeUnits());
		final int number = wave.getNumber();

		final StringBuilder message = new StringBuilder();
		message.append("Wave ");
		if (number > 0)
		{
			message.append(number).append(" ");
		}
		message.append("duration: ");

		announceTime(message.toString(), time);
	}


	private void announceRoundInfo()
	{
		if (round == null)
		{
			return;
		}

		final DurationMode durationMode = config.showDurationMode();
		if (durationMode == DurationMode.ROUND || durationMode == DurationMode.WAVE_ROUND)
		{
			announceRoundTime();
		}

		if (round.isComplete())
		{
			final boolean colorful = config.enableGameChatColors();

			final PointsMode pointsMode = config.showRewardPointsMode();
			if (pointsMode == PointsMode.ROUND || pointsMode == PointsMode.WAVE_ROUND)
			{
				ChatMessageBuilder roundPoints = round.getRoundPointsMessage(colorful, includeKandarinBonus());
				announce(roundPoints);
			}

			final RewardsBreakdownMode rewardsBreakdownMode = config.showRewardsBreakdownMode();
			if (rewardsBreakdownMode == RewardsBreakdownMode.ROUND || rewardsBreakdownMode == RewardsBreakdownMode.WAVE_ROUND)
			{
				ChatMessageBuilder roundSummary = round.getRoundSummaryMessage(colorful);
				announce(roundSummary);
			}
		}

		timer = null;
	}

	private void announceRoundTime()
	{
		if (round == null || round.getTimer() == null)
		{
			return;
		}

		final String time = round.getTimer().getRoundTimeFormatted(config.timeUnits());
		final int fromWave = round.getStartingWave();
		final StringBuilder message = new StringBuilder();
		if (fromWave == 1)
		{
			message.append("Round duration: ");
		}
		else
		{
			message.append("Round duration from wave ").append(fromWave).append(": ");
		}
		announceTime(message.toString(), time);
	}

	private void announceTime(String preText, String time)
	{
		ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
			.append(ChatColorType.NORMAL)
			.append(preText);
		if (config.enableGameChatColors())
		{
			chatMessageBuilder.append(ChatColorType.HIGHLIGHT);
		}
		chatMessageBuilder = chatMessageBuilder.append(time);

		announce(chatMessageBuilder);
	}

	private void announce(final ChatMessageBuilder chatMessage)
	{
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(chatMessage.build())
			.build());
	}

	private Color getEggColorFromName(String eggName)
	{
		switch (eggName.toLowerCase())
		{
			case "green":
				return Color.GREEN;
			case "red":
				return BaMinigamePlugin.LIGHT_RED;
			case "blue":
				return BaMinigamePlugin.LIGHT_BLUE;
		}
		return null;
	}

	private void updateEggsCount()
	{
		for (CollectorEgg collectorEgg : CollectorEgg.values())
		{
			final int eggsCount = client.getVarbitValue(collectorEgg.getVarbits().getId());
			if (eggsCount < 1)
			{
				cannonEggs.remove(collectorEgg);
			}
			else
			{
				cannonEggs.put(collectorEgg, eggsCount);
			}
		}
	}

	private void addItemSpawn(TileItem item, Tile tile, Role role)
	{
		final GroundItem.Key Key = new GroundItem.Key(item.getId(), tile.getWorldLocation());
		final GroundItem groundItem = buildGroundItem(tile, item);

		switch (role)
		{
			case COLLECTOR:
			{
				if (isEggItem(item.getId()))
				{
					addEggSpawn(Key, groundItem);
				}
				break;
			}
			case DEFENDER:
			{
				if (isBaitItem(item.getId()))
				{
					addDefenderBaitSpawn(Key, groundItem);
				}
				else if (isLogsOrHammerItem(item.getId()))
				{
					addLogsHammerSpawn(Key, groundItem);
				}
				break;
			}
		}
	}

	private void removeItemSpawn(TileItem item, Tile tile, Role role)
	{
		switch (role)
		{
			case COLLECTOR:
			{
				if (isEggItem(item.getId()))
				{
					removeEggSpawn(item, tile);
				}
				break;
			}
			case DEFENDER:
			{
				if (isBaitItem(item.getId()))
				{
					removeBaitSpawn(item, tile);
				}
				else if (isLogsOrHammerItem(item.getId()))
				{
					removeLogsHammerSpawn(item, tile);
				}
				break;
			}
		}
	}

	private void addEggSpawn(GroundItem.Key Key, GroundItem groundItem)
	{
		addItemSpawn(Key, groundItem, groundEggs);
	}

	private void addDefenderBaitSpawn(GroundItem.Key Key, GroundItem groundItem)
	{
		addItemSpawn(Key, groundItem, groundBait);
	}

	private void addLogsHammerSpawn(GroundItem.Key Key, GroundItem groundItem)
	{
		addItemSpawn(Key, groundItem, groundLogsHammer);
	}

	private void addItemSpawn(GroundItem.Key Key, GroundItem groundItem, Map<GroundItem.Key, GroundItem> spawnItems)
	{
		GroundItem existing = spawnItems.putIfAbsent(Key, groundItem);
		if (existing != null)
		{
			existing.setQuantity(existing.getQuantity() + groundItem.getQuantity());
		}
	}

	private GroundItem buildGroundItem(final Tile tile, final TileItem item)
	{
		final int itemId = item.getId();
		final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		final int realItemId = itemComposition.getNote() != -1 ? itemComposition.getLinkedNoteId() : itemId;

		return GroundItem.builder()
			.id(itemId)
			.location(tile.getWorldLocation())
			.itemId(realItemId)
			.quantity(item.getQuantity())
			.name(itemComposition.getName())
			.height(tile.getItemLayer().getHeight())
			.spawnTime(Instant.now())
			.build();
	}

	private void removeEggSpawn(TileItem item, Tile tile)
	{
		GroundItem.Key Key = new GroundItem.Key(item.getId(), tile.getWorldLocation());
		GroundItem groundItem = removeItemSpawn(item, Key, groundEggs);
		if (groundItem == null)
		{
			return;
		}

		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return;
		}

		Instant spawnTime = groundItem.getSpawnTime();
		Instant now = Instant.now();
		if (wave != null
			&& wave.getNumber() != 10
			&& (spawnTime == null || now.isBefore(spawnTime.plus(Duration.ofMinutes(2))))
			&& groundItem.getLocation().equals(player.getWorldLocation()))
		{
			wave.setEggsCount(wave.getEggsCount() + 1);
		}
	}

	private void removeBaitSpawn(TileItem item, Tile tile)
	{
		GroundItem.Key Key = new GroundItem.Key(item.getId(), tile.getWorldLocation());
		removeItemSpawn(item, Key, groundBait);
	}

	private void removeLogsHammerSpawn(TileItem item, Tile tile)
	{
		GroundItem.Key Key = new GroundItem.Key(item.getId(), tile.getWorldLocation());
		removeItemSpawn(item, Key, groundLogsHammer);
	}

	private GroundItem removeItemSpawn(TileItem item, GroundItem.Key Key, Map<GroundItem.Key, GroundItem> spawnItems)
	{
		GroundItem groundItem = spawnItems.get(Key);
		if (groundItem == null)
		{
			return null;
		}

		if (groundItem.getQuantity() <= item.getQuantity())
		{
			spawnItems.remove(Key);
		}
		else
		{
			groundItem.setQuantity(groundItem.getQuantity() - item.getQuantity());
			// When picking up an item when multiple stacks appear on the ground,
			// it is not known which item is picked up, so we invalidate the spawn
			// time
			groundItem.setSpawnTime(null);
		}

		return groundItem;
	}


	private boolean isEggItem(int itemId)
	{
		return itemId == ItemID.RED_EGG
			|| itemId == ItemID.GREEN_EGG
			|| itemId == ItemID.BLUE_EGG
			|| itemId == ItemID.YELLOW_EGG;
	}

	private boolean isBaitItem(int itemId)
	{
		return itemId == ItemID.TOFU
			|| itemId == ItemID.WORMS
			|| itemId == ItemID.CRACKERS;
	}

	private boolean isLogsOrHammerItem(int itemId)
	{
		return itemId == ItemID.LOGS
			|| itemId == ItemID.HAMMER;
	}

	private boolean isHopperGameObject(int gameObjectId)
	{
		return gameObjectId == ObjectID.EGG_HOPPER
			|| gameObjectId == ObjectID.EGG_HOPPER_20265
			|| gameObjectId == ObjectID.EGG_HOPPER_20266
			|| gameObjectId == BaObjectID.EGG_HOPPER_20267;
	}

	private void enableRunnerTickTimer(boolean display)
	{
		if (runnerTickTimer == null)
		{
			runnerTickTimer = new RunnerTickTimer();
		}
		runnerTickTimer.setDisplaying(display);
	}

	private void disableRunnerTickTimer(boolean remove)
	{
		if (runnerTickTimer != null)
		{
			runnerTickTimer.setDisplaying(false);
		}
		if (remove)
		{
			runnerTickTimer = null;
		}
	}

	private void showDeathTimes()
	{
		List<InfoBox> infoBoxes = infoBoxManager.getInfoBoxes();

		for (InfoBox infoBox : deathTimesInfoBoxes)
		{
			if (!infoBoxes.contains(infoBox))
			{
				infoBoxManager.addInfoBox(infoBox);
			}
		}
	}

	private void showRolePoints()
	{
		List<InfoBox> infoBoxes = infoBoxManager.getInfoBoxes();

		for (InfoBox infoBox : rolePointsInfoBoxes.values())
		{
			if (!infoBoxes.contains(infoBox))
			{
				infoBoxManager.addInfoBox(infoBox);
			}
		}
	}

	private void hideDeathTimesInfoBoxes()
	{
		for (InfoBox infoBox : deathTimesInfoBoxes)
		{
			infoBoxManager.removeInfoBox(infoBox);
		}
	}

	private void hideRolePointsInfoBoxes()
	{
		for (InfoBox infoBox : rolePointsInfoBoxes.values())
		{
			infoBoxManager.removeInfoBox(infoBox);
		}
	}

	private void hideRolePointsInfoBox(Role role)
	{
		infoBoxManager.removeInfoBox(rolePointsInfoBoxes.get(role));
	}

	private void addDeathTimesInfoBoxes(String npc, float time, String format)
	{
		final BufferedImage image = images.get(npc.toLowerCase());
		final DeathTimeInfoBox infoBox = new DeathTimeInfoBox(image, this, time, format);

		deathTimesInfoBoxes.add(infoBox);

		final DeathTimesMode deathTimesMode = config.deathTimesMode();
		if (deathTimesMode == DeathTimesMode.INFO_BOX || deathTimesMode == DeathTimesMode.INFOBOX_CHAT)
		{
			infoBoxManager.addInfoBox(infoBox);
		}
	}

	private void addOrUpdateRolePointsInfoBoxes(Role role, int points)
	{
		final DisplayPointsMode displayPointsMode = config.displayPointsMode();
		final RolePointsTrackingMode rolePointsTrackingMode = config.rolePointsTrackingMode();
		if (displayPointsMode != DisplayPointsMode.INFO_BOX
			|| rolePointsTrackingMode == RolePointsTrackingMode.ATTACKER && role != Role.ATTACKER
			|| rolePointsTrackingMode == RolePointsTrackingMode.DEFENDER && role != Role.DEFENDER
			|| rolePointsTrackingMode == RolePointsTrackingMode.HEALER && role != Role.HEALER
			|| rolePointsTrackingMode == RolePointsTrackingMode.COLLECTOR && role != Role.COLLECTOR)
		{
			hideRolePointsInfoBox(role);
		}
		else
		{
			final RolePointsInfoBox previousInfoBox = rolePointsInfoBoxes.get(role);
			if (previousInfoBox != null)
			{
				previousInfoBox.setPoints(points);
				if (!infoBoxManager.getInfoBoxes().contains(previousInfoBox))
				{
					infoBoxManager.addInfoBox(previousInfoBox);
				}
			}
			else
			{
				final RolePointsInfoBox infoBox = new RolePointsInfoBox(images.get(role.getName().toLowerCase(Locale.ROOT)), this, points);
				rolePointsInfoBoxes.put(role, infoBox);
				infoBoxManager.addInfoBox(infoBox);
			}
		}
	}

	private void removeDeathTimesInfoBoxes()
	{
		hideDeathTimesInfoBoxes();
		deathTimesInfoBoxes.clear();
	}

	private void removeRolePointsInfoBoxes()
	{
		hideRolePointsInfoBoxes();
		rolePointsInfoBoxes.clear();
	}

	private void setGroundItemsPluginLists()
	{
		String highlightedItems = Optional
			.ofNullable(configManager.getConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIGHLIGHTED_ITENS))
			.orElse("");
		final List<String> highlightedItemsList = Arrays.stream(highlightedItems.split(","))
			.map(i -> i.trim().toLowerCase()).collect(Collectors.toList());

		final String hiddenItems = Optional
			.ofNullable(configManager.getConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIDDEN_ITENS))
			.orElse("");
		final List<String> hiddenItemsList = Arrays.stream(hiddenItems.split(","))
			.map(i -> i.trim().toLowerCase()).collect(Collectors.toList());

		final StringBuilder highlightedItemsListBuilder = new StringBuilder();
		final StringBuilder hiddenItemsListBuilder = new StringBuilder();
		for (String item : GROUND_ITEMS_HIDDEN_LIST)
		{
			if (highlightedItemsList.contains(item.toLowerCase()))
			{
				if (highlightedItemsListBuilder.length() > 0)
				{
					highlightedItemsListBuilder.append(",");
				}
				highlightedItemsListBuilder.append(item);

				// regex to replace any white spaces, followed by 0 or more commas, followed by any white spaces,
				// (?i) mode to match case insensitive, followed by any white spaces, followed by 0 or more commas,
				// and finally followed by any white spaces
				highlightedItems = highlightedItems.replaceAll("\\s*,*\\s*(?i)" + Pattern.quote(item) + "\\s*,*\\s*", ",");

				if (highlightedItems.startsWith(","))
				{
					highlightedItems = highlightedItems.substring(1);
				}
				if (highlightedItems.endsWith(","))
				{
					highlightedItems = highlightedItems.substring(0, highlightedItems.length() - 1);
				}
			}

			if (!hiddenItemsList.contains(item.toLowerCase()))
			{
				if (hiddenItemsListBuilder.length() > 0)
				{
					hiddenItemsListBuilder.append(",");
				}
				hiddenItemsListBuilder.append(item);
			}
		}

		final StringBuilder hiddenItemsBuilder = new StringBuilder(hiddenItems);
		if (hiddenItemsListBuilder.length() > 0 && !hiddenItems.endsWith(","))
		{
			hiddenItemsBuilder.append(",");
		}
		hiddenItemsBuilder.append(hiddenItemsListBuilder);

		config.setGroundItemsPluginHighlightedList(highlightedItemsListBuilder.toString());
		config.setGroundItemsPluginHiddenList(hiddenItemsListBuilder.toString());

		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIGHLIGHTED_ITENS, highlightedItems);
		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIDDEN_ITENS, hiddenItemsBuilder.toString());
	}

	private void restoreGroundItemsPluginLists()
	{
		String highlightedItems = Optional
			.ofNullable(configManager.getConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIGHLIGHTED_ITENS))
			.orElse("");
		StringBuilder highlightedItemsBuilder = new StringBuilder(highlightedItems);
		String[] highlightedItemsArray = config.getGroundItemsPluginHighlightedList().split(",");
		final List<String> highlightedItemsList = Arrays.stream(highlightedItems.split(","))
			.map(i -> i.trim().toLowerCase()).collect(Collectors.toList());

		for (String s : highlightedItemsArray)
		{
			String item = s.trim();
			if (!highlightedItemsList.contains(item.toLowerCase()))
			{
				if (!highlightedItems.isEmpty() && !highlightedItems.endsWith(","))
				{
					highlightedItemsBuilder.append(",");
				}
				highlightedItemsBuilder.append(item);
			}
		}

		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIGHLIGHTED_ITENS, highlightedItemsBuilder.toString());
		config.setGroundItemsPluginHighlightedList("");

		String hiddenItems = configManager.getConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIDDEN_ITENS);
		final String[] list = config.getGroundItemsPluginHiddenList().split(",");
		for (String item : list)
		{
			item = item.trim();
			if (!item.isEmpty() && StringUtils.containsIgnoreCase(hiddenItems, item))
			{
				// regex to replace any white spaces, followed by 0 or more commas, followed by any white spaces,
				// (?i) mode to match case insensitive, followed by any white spaces, followed by 0 or more commas,
				// and finally followed by any white spaces
				hiddenItems = hiddenItems.replaceAll("\\s*,*\\s*(?i)" + Pattern.quote(item) + "\\s*,*\\s*", ",");

				if (hiddenItems.startsWith(","))
				{
					hiddenItems = hiddenItems.substring(1);
				}
				if (hiddenItems.endsWith(","))
				{
					hiddenItems = hiddenItems.substring(0, hiddenItems.length() - 1);
				}
			}
		}
		configManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, GROUND_ITEMS_CONFIG_HIDDEN_ITENS, hiddenItems);
		config.setGroundItemsPluginHiddenList("");
	}

	private void disableBarbarianAssaultPluginFeatures()
	{
		StringBuilder configsBuilder = new StringBuilder();
		for (String config : BARBARIAN_ASSAULT_CONFIGS)
		{
			final String value = configManager.getConfiguration(BARBARIAN_ASSAULT_CONFIG_GROUP, config);
			if (configsBuilder.length() > 0)
			{
				configsBuilder.append(",");
			}
			configsBuilder.append(config).append("=").append(value);
			configManager.setConfiguration(BARBARIAN_ASSAULT_CONFIG_GROUP, config, false);
		}
		if (config.getBarbarianAssaultConfigs().isEmpty())
		{
			config.setBarbarianAssaultConfigs(configsBuilder.toString());
		}
	}

	private void restoreBarbarianAssaultPluginFeatures()
	{
		final String[] configs = config.getBarbarianAssaultConfigs().split(",");
		for (String config : configs)
		{
			final String[] keyValue = config.split("=");
			if (keyValue.length == 2)
			{
				final String key = keyValue[0];
				final String value = keyValue[1];
				configManager.setConfiguration(BARBARIAN_ASSAULT_CONFIG_GROUP, key, value);
			}
		}
		config.setBarbarianAssaultConfigs("");
	}

	public boolean isDisplayingHealerTeammatesHealth()
	{
		return !config.hideHealerTeammatesHealth() || teammatesHealthHotkeyPressed;
	}

	private void setHealerTeammatesHealthDisplay()
	{
		Widget teammatesHealth = client.getWidget(BaWidgetInfo.BA_HEAL_TEAMMATES.getGroupId(),
			BaWidgetInfo.BA_HEAL_TEAMMATES.getChildId());
		if (teammatesHealth == null)
		{
			return;
		}
		if (config.hideHealerTeammatesHealth())
		{
			teammatesHealth.setHidden(!teammatesHealthHotkeyPressed);
		}
		else
		{
			teammatesHealth.setHidden(false);
		}
	}

	private void restoreHealerTeammatesHealth()
	{
		Widget teammatesHealth = client.getWidget(BaWidgetInfo.BA_HEAL_TEAMMATES.getGroupId(),
			BaWidgetInfo.BA_HEAL_TEAMMATES.getChildId());
		if (teammatesHealth != null)
		{
			teammatesHealth.setHidden(false);
		}
	}

	void onTeammatesHealthHotkeyChanged(boolean pressed)
	{
		this.teammatesHealthHotkeyPressed = pressed;
		if (wave != null && wave.getRole() == Role.HEALER)
		{
			setHealerTeammatesHealthDisplay();
		}
	}

	public boolean shouldDisplayRolePoints()
	{
		DisplayPointsLocationMode locationMode = config.displayPointsLocationMode();
		if (locationMode == DisplayPointsLocationMode.ALWAYS)
		{
			return true;
		}
		if (locationMode == DisplayPointsLocationMode.NEVER)
		{
			return false;
		}
		if (locationMode == DisplayPointsLocationMode.OUTPOST ||
			locationMode == DisplayPointsLocationMode.OUTPOST_INGAME)
		{
			if (locationMode == DisplayPointsLocationMode.OUTPOST_INGAME && inGameBit == 1)
			{
				return true;
			}
			if (this.worldPoint == null)
			{
				return false;
			}
			final int regionId = this.worldPoint.getRegionID();
			final int x = this.worldPoint.getX();
			final int y = this.worldPoint.getY();
			return regionId == BA_UNDERGROUND_REGION_ID
				|| x >= BA_TILE_START_X && x <= BA_TILE_END_X && y >= BA_TILE_START_Y && y <= BA_TILE_END_Y;
		}
		return false;
	}

	private void checkCallCorrection(String currentListen)
	{
		final int maxCorrections = 3;

		if (lastListen == null || currentListen == null)
		{
			return;
		}

		if (currentListen.startsWith("-"))
		{
			correctedCallCount = 0;
		}
		else if (!lastListen.startsWith("-") && !currentListen.startsWith("-"))
		{
			// Limit spam in the case your teammate decides to play with their horn :-)
			if (++correctedCallCount > maxCorrections)
			{
				return;
			}

			if (lastListen.equalsIgnoreCase("Poison Worms") && currentListen.equalsIgnoreCase("Pois. Worms")
				|| lastListen.equalsIgnoreCase("Pois. Worms") && currentListen.equalsIgnoreCase("Poison Worms")
				|| lastListen.equalsIgnoreCase("Poison Tofu") && currentListen.equalsIgnoreCase("Pois. Tofu")
				|| lastListen.equalsIgnoreCase("Pois. Tofu") && currentListen.equalsIgnoreCase("Poison Tofu")
				|| lastListen.equalsIgnoreCase("Poison Meat") && currentListen.equalsIgnoreCase("Pois. Meat")
				|| lastListen.equalsIgnoreCase("Pois. Meat") && currentListen.equalsIgnoreCase("Poison Meat"))
			{
				// Ignore differences from players calls vs Horn of Glory calls
				return;
			}

			ChatMessageBuilder message = new ChatMessageBuilder().append("Call correction: ");
			if (config.enableGameChatColors())
			{
				message = message.append(ChatColorType.HIGHLIGHT);
			}
			message.append(currentListen);
			announce(message);
		}
	}

	private void resetRolePoints()
	{
		if (round != null)
		{
			round.resetRolePoints();
		}
		if (session != null)
		{
			session.resetRolePoints();
		}
		PointsCounterMode pointsCounterMode = config.pointsCounterMode();
		if (pointsCounterMode != PointsCounterMode.CURRENT_POINTS)
		{
			clientThread.invokeLater(() -> updateRolePoints(false));
		}
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.grounditems;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum GroundEggsMode
{
	CALLED("Called"),
	ALL("All"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.grounditems;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.QuantityFormatter;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

@Slf4j
@Singleton
public class GroundItemsOverlay extends OverlayPanel
{
	private static final int MAX_DISTANCE = 2500;
	// We must offset the text on the z-axis such that
	// it doesn't obscure the ground items below it.
	private static final int OFFSET_Z = 20;
	// The game won't send anything higher than this value to the plugin -
	// so we replace any item quantity higher with "Lots" instead.
	private static final int MAX_QUANTITY = 65535;
	// The 15 pixel gap between each drawn ground item.
	private static final int STRING_GAP = 15;

	private final StringBuilder itemStringBuilder = new StringBuilder();
	private final TextComponent textComponent = new TextComponent();
	private final Map<WorldPoint, Integer> offsetMap = new HashMap<>();

	private final Client client;

	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;

	@Inject
	public GroundItemsOverlay(final Client client, final BaMinigamePlugin plugin,
									  final BaMinigameConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showGroundItemHighlights())
		{
			return null;
		}

		final Role role = plugin.getRole();
		if (role == null)
		{
			return null;
		}

		switch (role)
		{
			case COLLECTOR:
			{
				renderEggs(graphics);
				break;
			}
			case DEFENDER:
			{
				if (config.highlightGroundBait())
				{
					renderBait(graphics);
				}
				if (config.highlightGroundLogsHammer())
				{
					renderLogsHammer(graphics);
				}
				break;
			}
		}

		return null;
	}

	private void renderEggs(Graphics2D graphics)
	{
		final Collection<GroundItem> eggsList = plugin.getGroundEggs().values();

		final String calledEgg = plugin.getLastListen();

		final GroundEggsMode groundEggsMode = config.highlightGroundEggsMode();

		final Predicate<GroundItem> filter = item ->
				  groundEggsMode == GroundEggsMode.ALL
							 || groundEggsMode == GroundEggsMode.CALLED &&
							 (item.getId() == ItemID.YELLOW_EGG || calledEgg != null && calledEgg.startsWith(item.getName()));

		renderGroundItems(graphics, eggsList, filter);
	}

	private void renderBait(Graphics2D graphics)
	{
		final Collection<GroundItem> bait = plugin.getGroundBait().values();

		renderGroundItems(graphics, bait);
	}

	private void renderLogsHammer(Graphics2D graphics)
	{
		final Collection<GroundItem> logsHammer = plugin.getGroundLogsHammer().values();

		renderGroundItems(graphics, logsHammer);
	}

	private void renderGroundItems(Graphics2D graphics, Collection<GroundItem> itemsList)
	{
		renderGroundItems(graphics, itemsList, null);
	}

	private void renderGroundItems(Graphics2D graphics, Collection<GroundItem> itemsList, Predicate<GroundItem> filter)
	{
		final Player player = client.getLocalPlayer();

		if (player == null)
		{
			return;
		}

		offsetMap.clear();
		final LocalPoint localLocation = player.getLocalLocation();

		for (GroundItem item : itemsList)
		{

			if (filter != null && !filter.test(item))
			{
				log.debug("item {} failed the filter test", item.getName());
				continue;
			}

			final LocalPoint groundPoint = LocalPoint.fromWorld(client, item.getLocation());

			if (groundPoint == null || localLocation.distanceTo(groundPoint) > MAX_DISTANCE)
			{
				continue;
			}

			final Color color = plugin.getColorForGroundItemId(item.getId());

			if (config.highlightGroundTiles())
			{
				final Polygon poly = Perspective.getCanvasTilePoly(client, groundPoint);

				if (poly != null)
				{
					OverlayUtil.renderPolygon(graphics, poly, color);
				}
			}

			itemStringBuilder.append(item.getName());

			if (item.getQuantity() > 1)
			{
				if (item.getQuantity() >= MAX_QUANTITY)
				{
					itemStringBuilder.append(" (Lots!)");
				}
				else
				{
					itemStringBuilder.append(" (")
							  .append(QuantityFormatter.quantityToStackSize(item.getQuantity()))
							  .append(")");
				}
			}

			final String itemString = itemStringBuilder.toString();
			itemStringBuilder.setLength(0);

			final Point textPoint = Perspective.getCanvasTextLocation(client,
					  graphics,
					  groundPoint,
					  itemString,
					  item.getHeight() + OFFSET_Z);

			if (textPoint == null)
			{
				continue;
			}

			final int offset = offsetMap.compute(item.getLocation(), (k, v) -> v != null ? v + 1 : 0);

			final int textX = textPoint.getX();
			final int textY = textPoint.getY() - (STRING_GAP * offset);

			textComponent.setText(itemString);
			textComponent.setColor(color);
			textComponent.setPosition(new java.awt.Point(textX, textY));
			textComponent.render(graphics);
		}
	}

}
/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.grounditems;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum MenuHighlightMode
{
	OPTION("Option"),
	NAME("Name"),
	OPTION_NAME("Option/Name"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Tomas Slusny <slusnucky@gmail.com>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.grounditems;

import lombok.Builder;
import lombok.Data;
import lombok.Value;
import net.runelite.api.coords.WorldPoint;

import javax.annotation.Nullable;
import java.time.Instant;

@Data
@Builder
public class GroundItem
{
	private int id;
	private int itemId;
	private String name;
	private int quantity;
	private WorldPoint location;
	private int height;
	private int offset;
	@Nullable
	private Instant spawnTime;

	@Value
	public static class Key
	{
		int itemId;
		WorldPoint location;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.points.RolePointsTrackingMode;
import java.util.EnumMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import lombok.Getter;

@Getter
public class Session
{
	private final List<Wave> waves;
	private final Map<Role, Integer> rolePoints;

	public Session()
	{
		this.waves = new LinkedList<>();
		this.rolePoints = new EnumMap<>(Role.class);
	}

	public void addWave(Wave wave, RolePointsTrackingMode trackingMode)
	{
		int[] points = wave.getRolesPoints();
		Role[] playerRoles = wave.getPlayerRoles();
		Role myRole = wave.getRole();
		for (Role role : Role.values())
		{
			int playerRoleIndex;
			switch (trackingMode)
			{
				case PLAYER_ONE:
					playerRoleIndex = 0;
					break;
				case PLAYER_TWO:
					playerRoleIndex = 1;
					break;
				case PLAYER_THREE:
					playerRoleIndex = 2;
					break;
				case PLAYER_FOUR:
					playerRoleIndex = 3;
					break;
				case PLAYER_FIVE:
					playerRoleIndex = 4;
					break;
				default:
					playerRoleIndex = -1;
					break;
			}
			boolean isPlayerTracking = playerRoleIndex >= 0
				&& playerRoles[playerRoleIndex] != null;
			if (trackingMode == RolePointsTrackingMode.ALL
				|| trackingMode == RolePointsTrackingMode.MINE && myRole == role
				|| trackingMode == RolePointsTrackingMode.ATTACKER && Role.ATTACKER == role
				|| trackingMode == RolePointsTrackingMode.DEFENDER && Role.DEFENDER == role
				|| trackingMode == RolePointsTrackingMode.HEALER && Role.HEALER == role
				|| trackingMode == RolePointsTrackingMode.COLLECTOR && Role.COLLECTOR == role
				|| isPlayerTracking && playerRoles[playerRoleIndex] == role)
			{
				rolePoints.merge(role, points[role.ordinal()], Integer::sum);
			}
			if (wave.getNumber() == Round.ENDING_WAVE)
			{
				if (trackingMode == RolePointsTrackingMode.MINE && role != myRole
					|| isPlayerTracking && playerRoles[playerRoleIndex] != role)
				{
					rolePoints.merge(role, 5, Integer::sum);
				}
			}

		}
		waves.add(wave);
	}

	public void reset()
	{
		waves.clear();
		rolePoints.clear();
	}

	public int getRolePoints(Role role)
	{
		return rolePoints.getOrDefault(role, 0);
	}

	public void resetRolePoints()
	{
		for (Role role : Role.values())
		{
			rolePoints.put(role, 0);
		}
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.attackstyle;

import begosrs.barbarianassault.api.widgets.BaWidgetInfo;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum AttackStyleWidget
{
	ONE(BaWidgetInfo.COMBAT_STYLE_ONE, BaWidgetInfo.COMBAT_STYLE_ONE_ICON, BaWidgetInfo.COMBAT_STYLE_ONE_TEXT),
	TWO(BaWidgetInfo.COMBAT_STYLE_TWO, BaWidgetInfo.COMBAT_STYLE_TWO_ICON, BaWidgetInfo.COMBAT_STYLE_TWO_TEXT),
	THREE(BaWidgetInfo.COMBAT_STYLE_THREE, BaWidgetInfo.COMBAT_STYLE_THREE_ICON, BaWidgetInfo.COMBAT_STYLE_THREE_TEXT),
	FOUR(BaWidgetInfo.COMBAT_STYLE_FOUR, BaWidgetInfo.COMBAT_STYLE_FOUR_ICON, BaWidgetInfo.COMBAT_STYLE_FOUR_TEXT);

	@Getter
	private static final AttackStyleWidget[] attackStyles;

	static
	{
		attackStyles = new AttackStyleWidget[values().length];
		int i = 0;
		for (AttackStyleWidget attackStyleWidget : values())
		{
			attackStyles[i] = attackStyleWidget;
			i++;
		}
	}

	private final BaWidgetInfo containerWidget;
	private final BaWidgetInfo iconWidget;
	private final BaWidgetInfo textWidget;
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.attackstyle;

import lombok.Getter;
import net.runelite.api.Skill;

@Getter
public enum AttackStyle
{
	ACCURATE("Accurate", Skill.ATTACK),
	AGGRESSIVE("Aggressive", Skill.STRENGTH),
	DEFENSIVE("Defensive", Skill.DEFENCE),
	CONTROLLED("Controlled", Skill.ATTACK, Skill.STRENGTH, Skill.DEFENCE),
	RANGING("Ranging", Skill.RANGED),
	LONGRANGE("Longrange", Skill.RANGED, Skill.DEFENCE),
	CASTING("Casting", Skill.MAGIC),
	DEFENSIVE_CASTING("Defensive Casting", Skill.MAGIC, Skill.DEFENCE),
	OTHER("Other");

	private final String name;
	private final Skill[] skills;

	AttackStyle(String name, Skill... skills)
	{
		this.name = name;
		this.skills = skills;
	}
}

/*
 * Copyright (c) 2017, honeyhoney <https://github.com/honeyhoney>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.attackstyle;

import static begosrs.barbarianassault.attackstyle.AttackStyle.CASTING;
import static begosrs.barbarianassault.attackstyle.AttackStyle.DEFENSIVE;
import static begosrs.barbarianassault.attackstyle.AttackStyle.DEFENSIVE_CASTING;
import static begosrs.barbarianassault.attackstyle.AttackStyle.OTHER;
import net.runelite.api.Client;
import net.runelite.api.EnumID;
import net.runelite.api.ParamID;
import net.runelite.api.StructComposition;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Contains logic copied from AttackStylePlugin#getWeaponTypeStyles
 */
@Singleton
public class AttackStyleUtil
{
	private final Client client;

	@Inject
	public AttackStyleUtil(Client client)
	{
		this.client = client;
	}

	public AttackStyle[] getWeaponTypeStyles(int weaponType)
	{
		// from script4525
		int weaponStyleEnum = client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);
		if (weaponStyleEnum == -1)
		{
			// Blue moon spear
			if (weaponType == 22)
			{
				return new AttackStyle[]{
						AttackStyle.ACCURATE, AttackStyle.AGGRESSIVE, null, DEFENSIVE, CASTING, DEFENSIVE_CASTING
				};
			}

			if (weaponType == 30)
			{
				// Partisan
				return new AttackStyle[]{
						AttackStyle.ACCURATE, AttackStyle.AGGRESSIVE, AttackStyle.AGGRESSIVE, DEFENSIVE
				};
			}
			return new AttackStyle[0];
		}
		int[] weaponStyleStructs = client.getEnum(weaponStyleEnum).getIntVals();

		AttackStyle[] styles = new AttackStyle[weaponStyleStructs.length];
		int i = 0;
		for (int style : weaponStyleStructs)
		{
			StructComposition attackStyleStruct = client.getStructComposition(style);
			String attackStyleName = attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);

			AttackStyle attackStyle = AttackStyle.valueOf(attackStyleName.toUpperCase());
			if (attackStyle == OTHER)
			{
				// "Other" is used for no style
				++i;
				continue;
			}

			// "Defensive" is used for Defensive and also Defensive casting
			if (i == 5 && attackStyle == DEFENSIVE)
			{
				attackStyle = DEFENSIVE_CASTING;
			}

			styles[i++] = attackStyle;
		}
		return styles;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.hoppers;

import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.api.BaVarbits;
import java.awt.Color;
import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum CollectorEgg
{
	OMEGA("Omega", Color.YELLOW, BaVarbits.BA_CANNON_OMEGA_EGGS),
	BLUE("Blue", BaMinigamePlugin.LIGHT_BLUE, BaVarbits.BA_CANNON_BLUE_EGGS),
	RED("Red", BaMinigamePlugin.LIGHT_RED, BaVarbits.BA_CANNON_RED_EGGS),
	GREEN("Green", Color.GREEN, BaVarbits.BA_CANNON_GREEN_EGGS);

	private final String name;
	private final Color color;
	private final BaVarbits varbits;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.hoppers;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TextComponent;
import net.runelite.client.util.QuantityFormatter;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@Singleton
public class HoppersOverlay extends Overlay
{
	// The 15 pixel gap between each drawn egg.
	private static final int STRING_GAP = 15;
	private static final int Z_OFFSET = 100;
	private static final int MAXIMUM_DISTANCE = 20;

	private final Client client;
	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;

	private final TextComponent textComponent;
	private final Map<WorldPoint, Integer> offsetMap;

	@Inject
	private HoppersOverlay(final Client client, final BaMinigamePlugin plugin, final BaMinigameConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.client = client;
		this.plugin = plugin;
		this.config = config;

		this.textComponent = new TextComponent();
		this.offsetMap = new HashMap<>();
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showEggsOnHopper() || plugin.getInGameBit() != 1)
		{
			return null;
		}

		final Player player = client.getLocalPlayer();
		if (player == null)
		{
			return null;
		}

		offsetMap.clear();

		for (GameObject hopper : plugin.getHoppers())
		{
			WorldPoint hopperPoint = hopper.getWorldLocation();
			if (hopperPoint.distanceTo(player.getWorldLocation()) >= MAXIMUM_DISTANCE)
			{
				continue;
			}

			final LocalPoint localPoint = LocalPoint.fromWorld(client, hopperPoint);
			if (localPoint == null)
			{
				continue;
			}

			for (Map.Entry<CollectorEgg, Integer> eggCount : plugin.getCannonEggs().entrySet())
			{
				final CollectorEgg collectorEgg = eggCount.getKey();
				if (collectorEgg != CollectorEgg.OMEGA && config.onlyShowOmegaHopper())
				{
					continue;
				}
				final int count = eggCount.getValue();

				String message = String.format("%s %s", QuantityFormatter.quantityToStackSize(count), collectorEgg.getName());

				Point textPoint = Perspective.getCanvasTextLocation(client, graphics, localPoint, message, Z_OFFSET);
				if (textPoint == null)
				{
					continue;
				}

				final int offset = offsetMap.compute(hopper.getWorldLocation(), (k, v) -> v != null ? v + 1 : 0);

				final int textX = textPoint.getX();
				final int textY = textPoint.getY() - (STRING_GAP * offset);

				textComponent.setText(message);
				textComponent.setColor(collectorEgg.getColor());
				textComponent.setPosition(new java.awt.Point(textX, textY));
				textComponent.render(graphics);
			}
		}

		return null;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.timer;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum DurationMode
{
	WAVE("Wave"),
	ROUND("Round"),
	WAVE_ROUND("Wave/Round"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.timer;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum TimeUnits
{
	SECONDS("Seconds", "%02.0f"),
	TICKS("Game ticks (0.6 s)", "%02.1f"),
	TENTHS_OF_SECOND("0.1 seconds", "%02.1f");

	private final String name;
	private final String formatString;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2018, Jacob M <https://github.com/jacoblairm>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.timer;

import java.time.Duration;
import java.time.Instant;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoField;
import java.time.temporal.ChronoUnit;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Constants;

@Slf4j
@Getter
public class Timer
{
	private final Instant roundStartTime;
	private int roundTicks;
	private Instant roundEndTime;
	private int roundEndTicks;

	private Instant waveStartTime;
	private int waveTickStart;

	public Timer()
	{
		this.roundStartTime = Instant.now();
		this.waveStartTime = roundStartTime;
	}

	private static LocalTime timeFromMillis(int millis)
	{
		return LocalTime.ofSecondOfDay(millis / 1000)
			.plus(millis % 1000, ChronoUnit.MILLIS);
	}

	private static LocalTime timeFromDuration(Duration duration)
	{
		return LocalTime.ofSecondOfDay(duration.getSeconds())
			.plusNanos(duration.getNano());
	}

	private static String formatTime(LocalTime time, TimeUnits units)
	{
		if (time.getHour() > 0)
		{
			return time.format(DateTimeFormatter.ofPattern("HH:mm"));
		}
		else
		{
			final String minsFormat = time.getMinute() > 9 ? "mm" : "m";
			final String fractional = units.equals(TimeUnits.SECONDS) ?
				"" :
				"." + time.get(ChronoField.MILLI_OF_SECOND) / 100;
			return time.format(DateTimeFormatter.ofPattern(minsFormat + ":ss")) + fractional;
		}
	}

	public Duration getRoundTime()
	{
		if (roundEndTime == null)
		{
			roundEndTime = Instant.now();
		}
		return Duration.between(roundStartTime, roundEndTime);
	}

	public Duration getWaveTime()
	{
		return Duration.between(waveStartTime, Instant.now());
	}

	// delayed is true for in-wave timer and false for end-time displays
	public int getCurrentWaveTick(boolean delayed)
	{
		return delayed ? roundTicks - waveTickStart - 1 : roundTicks - waveTickStart;
	}

	public String getRoundTimeFormatted(TimeUnits units)
	{
		final LocalTime time = units.equals(TimeUnits.TICKS) ?
			timeFromMillis(getRoundEndTicks() * Constants.GAME_TICK_LENGTH) :
			timeFromDuration(getRoundTime());
		return formatTime(time, units);
	}

	public String getWaveTimeFormatted(TimeUnits units)
	{
		final LocalTime time = units.equals(TimeUnits.TICKS) ?
			timeFromMillis(getCurrentWaveTick(false) * Constants.GAME_TICK_LENGTH) :
			timeFromDuration(getWaveTime());
		return formatTime(time, units);
	}

	public void setWaveStartTime()
	{
		waveStartTime = Instant.now();
		waveTickStart = roundTicks;
	}

	public void setRoundEnded()
	{
		roundEndTime = Instant.now();
		roundEndTicks = roundTicks;
	}

	public void onGameTick()
	{
		roundTicks++;
	}
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.waveinfo;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import begosrs.barbarianassault.Round;
import begosrs.barbarianassault.Wave;
import begosrs.barbarianassault.timer.TimeUnits;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;

@Slf4j
@Singleton
public class WaveInfoOverlay extends Overlay
{
	private static final int WAVE_CHECKMARK_ORIGINAL_X = 6;
	private static final int WAVE_ICON_ORIGINAL_X = 3;

	private final Client client;
	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;

	@Inject
	private WaveInfoOverlay(Client client, BaMinigamePlugin plugin, BaMinigameConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Wave wave = plugin.getWave();
		final Round round = plugin.getRound();
		if (wave == null || round == null)
		{
			return null;
		}
		final Role role = wave.getRole();
		if (role == null)
		{
			return null;
		}

		if (config.showWaveTimer())
		{
			final Widget waveText = client.getWidget(role.getWaveText().getGroupId(), role.getWaveText().getChildId());
			if (waveText != null)
			{
				final TimeUnits units = config.timeUnits();
				final String waveTime = String.format(units.getFormatString(), wave.getTimeElapsed(true, units));
				waveText.setText("Wave " + wave.getNumber() + " / " + waveTime);
			}
		}

		if (config.showWaveCompleted())
		{
			// icon is replaced back on call changes, so must be constantly set here
			final Widget waveSprite = client.getWidget(role.getWaveSprite().getGroupId(), role.getWaveSprite().getChildId());
			if (waveSprite != null)
			{
				waveSprite.setSpriteId(wave.isComplete() ? SpriteID.OPTIONS_ROUND_CHECK_BOX_CHECKED : SpriteID.OPTIONS_ROUND_CHECK_BOX);
				waveSprite.setOriginalWidth(BaMinigamePlugin.WAVE_CHECKMARK_ICON_WIDTH);
				waveSprite.setOriginalX(WAVE_CHECKMARK_ORIGINAL_X);
			}
		}

		final Widget waveInfo = client.getWidget(role.getWaveInfo().getGroupId(), role.getWaveInfo().getChildId());

		if (waveInfo != null)
		{
			final Widget roleCounter = waveInfo.getChild(0);
			if (roleCounter != null)
			{
				String counter = null;
				if (config.showEggCountOverlay() && role == Role.COLLECTOR)
				{
					final int currentWave = wave.getNumber();
					final int waveCollectedEggs = currentWave == 10 ? 0 : wave.getCollectedEggsCount();
					final int roundCollectedEggs = round.getCollectedEggsCount(waveCollectedEggs);
					if (wave.getNumber() != 10)
					{
						counter = waveCollectedEggs + " / " + roundCollectedEggs;
					}
					else
					{
						counter = String.valueOf(roundCollectedEggs);
					}
				}
				else if (config.showHpCountOverlay() && role == Role.HEALER)
				{
					final int currentWave = wave.getNumber();
					final int waveHpHealed = currentWave == 10 ? 0 : wave.getHpHealed();
					final int roundHpHealed = round.getHpHealed(waveHpHealed);
					if (wave.getNumber() != 10)
					{
						counter = waveHpHealed + " / " + roundHpHealed;
					}
					else
					{
						counter = String.valueOf(roundHpHealed);
					}
				}

				if (counter != null)
				{
					roleCounter.setText(counter);
				}
			}
		}

		if (config.showCallChangeTimer() && waveInfo != null)
		{
			final Widget waveTimer = waveInfo.getChild(2);
			if (waveTimer != null)
			{
				waveTimer.setText(String.format("00:%02d", wave.getTimeUntilCallChange()));
			}
		}

		return null;
	}
}

/*
 * Copyright (c) 2019, whartd <github.com/whartd>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.teamhealthbar;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import begosrs.barbarianassault.api.widgets.BaWidgetInfo;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;

public class TeamHealthBarOverlay extends Overlay
{
	private final Client client;
	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;
	@Inject
	private TeamHealthBarOverlay(Client client, BaMinigamePlugin plugin, BaMinigameConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.UNDER_WIDGETS);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Role role = plugin.getRole();

		if (config.showTeammateHealthBars() && plugin.isDisplayingHealerTeammatesHealth() && role == Role.HEALER)
		{
			for (HealerTeam teammate : HealerTeam.values())
			{
				Widget widget = client.getWidget(teammate.getTeammate().getGroupId(), teammate.getTeammate().getChildId());
				if (widget == null)
				{
					continue;
				}

				String[] teammateHealth = widget.getText().split(" / ");
				int curHealth = Integer.parseInt(teammateHealth[0]);
				int maxHealth = Integer.parseInt(teammateHealth[1]);

				int width = teammate.getWidth();
				double hpRatio = (double) curHealth / maxHealth;
				int filledWidth = getBarWidth(hpRatio, width);
				Color barColor = getBarColor(hpRatio);

				int offsetX = teammate.getOffsetX();
				int offsetY = teammate.getOffsetY();
				int x = widget.getCanvasLocation().getX() - offsetX;
				int y = widget.getCanvasLocation().getY() - offsetY;

				graphics.setColor(barColor);
				graphics.fillRect(x, y, filledWidth, 20);
			}
		}

		return null;
	}

	private int getBarWidth(double ratio, int size)
	{
		if (ratio >= 1)
		{
			return size;
		}

		return (int) Math.round(ratio * size);
	}

	private Color getBarColor(double ratio)
	{
		final int transparency = config.teammateHealthBarTransparency();

		if (ratio <= 0.33)
		{
			return new Color(225, 35, 0, 255 - transparency);
		}

		if (ratio <= 0.66)
		{
			return new Color(146, 146, 0, 255 - transparency);
		}

		return new Color(10, 146, 5, 255 - transparency);
	}

	@Getter
	@AllArgsConstructor
	private enum HealerTeam
	{
		TEAMMATE1(BaWidgetInfo.BA_HEAL_TEAMMATE1, 28, 2, 115),
		TEAMMATE2(BaWidgetInfo.BA_HEAL_TEAMMATE2, 26, 2, 115),
		TEAMMATE3(BaWidgetInfo.BA_HEAL_TEAMMATE3, 26, 2, 115),
		TEAMMATE4(BaWidgetInfo.BA_HEAL_TEAMMATE4, 25, 2, 115);

		private final BaWidgetInfo teammate;
		private final int offsetX;
		private final int offsetY;
		private final int width;
	}
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.api.widgets.BaWidgetInfo;
import begosrs.barbarianassault.timer.TimeUnits;
import begosrs.barbarianassault.timer.Timer;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.widgets.Widget;
import net.runelite.client.chat.ChatMessageBuilder;

import javax.annotation.Nullable;
import java.awt.Color;

@Slf4j
public class Wave
{
	static final int AMOUNT_EGGS_COLLECTED_INDEX = 2;
	static final int AMOUNT_HP_REPLENISHED_INDEX = 3;
	private static final String[] SUMMARY_DESCRIPTIONS = {
			  "Wrong att.",
			  "Runners passed",
			  "Eggs",
			  "Heal",
			  "Wrong pois.",
	};
	private static final BaWidgetInfo[] AMOUNTS_WIDGETS = {
			  BaWidgetInfo.BA_FAILED_ATTACKS,
			  BaWidgetInfo.BA_RUNNERS_PASSED,
			  BaWidgetInfo.BA_EGGS_COLLECTED,
			  BaWidgetInfo.BA_HITPOINTS_REPLENISHED,
			  BaWidgetInfo.BA_WRONG_POISON_PACKS,
	};
	private static final int FAILED_ATTACKS_INDEX = 0;
	private static final BaWidgetInfo[] ATTACKER_POINTS_WIDGETS = {
			  BaWidgetInfo.BA_FAILED_ATTACKS_POINTS,
			  BaWidgetInfo.BA_RANGERS_KILLED,
			  BaWidgetInfo.BA_FIGHTERS_KILLED,
	};
	private static final int RUNNERS_PASSED_INDEX = 0;
	private static final BaWidgetInfo[] DEFENDER_POINTS_WIDGETS = {
			  BaWidgetInfo.BA_RUNNERS_PASSED_POINTS,
			  BaWidgetInfo.BA_RUNNERS_KILLED,
	};
	private static final int EGGS_COLLECTED_INDEX = 0;
	private static final BaWidgetInfo[] COLLECTOR_POINTS_WIDGETS = {
			  BaWidgetInfo.BA_EGGS_COLLECTED_POINTS,
	};
	private static final int HITPOINTS_REPLENISHED_INDEX = 0;
	private static final int WRONG_POISON_PACKS_INDEX = 1;
	private static final BaWidgetInfo[] HEALER_POINTS_WIDGETS = {
			  BaWidgetInfo.BA_HITPOINTS_REPLENISHED_POINTS,
			  BaWidgetInfo.BA_WRONG_POISON_PACKS_POINTS,
			  BaWidgetInfo.BA_HEALERS_KILLED,
	};
	private static final int MAXIMUM_COLLECTED_EGGS = 60;
	private static final int MAXIMUM_HP_HEALED = 504;
	private final Client client;

	@Getter
	private final int number;
	@Nullable
	@Getter
	private final Timer timer;
	@Getter
	private final int[] rolesPoints;
	@Getter
	private final int[] amounts;
	@Getter
	private final int[] points;
	@Getter
	private final Role[] playerRoles;
	@Nullable
	@Getter
	@Setter
	private Role role;
	@Getter
	@Setter
	private int wrongEggsCount;
	@Getter
	@Setter
	private int eggsCount;
	@Setter
	private int hpHealed;
	@Setter
	private boolean fightersKilled, rangersKilled, healersKilled, runnersKilled;
	private boolean ended;

	Wave(Client client, int number)
	{
		this(client, number, new Role[5], null);
	}

	Wave(Client client, int number, Role[] playerRoles, Timer timer)
	{
		this.client = client;
		this.number = number;
		this.timer = timer;
		this.rolesPoints = new int[4];
		this.amounts = new int[5];
		this.points = new int[5];
		this.playerRoles = playerRoles;
	}

	public int getTimeUntilCallChange()
	{
		return 30 - getSecondsElapsed(true, TimeUnits.SECONDS) % 30;
	}

	public float getTimeElapsed(boolean delayTicks, TimeUnits units)
	{
		return getSecondsElapsed(delayTicks, units) + getMillisOfSecondElapsed(delayTicks, units) / 1000f;
	}

	public int getCollectedEggsCount()
	{
		if (ended)
		{
			return Math.max(0, amounts[AMOUNT_EGGS_COLLECTED_INDEX]);
		}
		// limit to 60, based off formula: y=x/4.35, X is capped at 60
		// https://oldschool.runescape.wiki/w/Barbarian_Assault/Rewards#Points_calculation
		return Math.min(eggsCount - wrongEggsCount, MAXIMUM_COLLECTED_EGGS);
	}

	public int getHpHealed()
	{
		if (ended)
		{
			return Math.max(0, amounts[AMOUNT_HP_REPLENISHED_INDEX]);
		}
		// upper bound 504, based off formula: y=x/18, Y is capped at 28
		// https://oldschool.runescape.wiki/w/Barbarian_Assault/Rewards#Points_calculation
		return Math.min(hpHealed, MAXIMUM_HP_HEALED);
	}

	void setAmounts()
	{
		for (int i = 0; i < AMOUNTS_WIDGETS.length; i++)
		{
			final int amountsCount = getBaWidgetValue(AMOUNTS_WIDGETS[i]);
			amounts[i] = amountsCount;
		}
	}

	void setPoints(boolean roundEnded)
	{
		if (roundEnded)
		{
			for (int i = 0; i < rolesPoints.length; i++)
			{
				rolesPoints[i] += 80;
			}
		}
		else
		{
			points[0] = getBaWidgetValue(ATTACKER_POINTS_WIDGETS[FAILED_ATTACKS_INDEX]);
			points[1] = getBaWidgetValue(DEFENDER_POINTS_WIDGETS[RUNNERS_PASSED_INDEX]);
			points[2] = getBaWidgetValue(COLLECTOR_POINTS_WIDGETS[EGGS_COLLECTED_INDEX]);
			points[3] = getBaWidgetValue(HEALER_POINTS_WIDGETS[HITPOINTS_REPLENISHED_INDEX]);
			points[4] = getBaWidgetValue(HEALER_POINTS_WIDGETS[WRONG_POISON_PACKS_INDEX]);

			final int basePoints = getBaWidgetValue(BaWidgetInfo.BA_BASE_POINTS);
			for (Role role : Role.values())
			{
				rolesPoints[role.ordinal()] += Math.max(0, basePoints);
			}
			for (BaWidgetInfo baWidgetInfo : ATTACKER_POINTS_WIDGETS)
			{
				final int points = getBaWidgetValue(baWidgetInfo);
				rolesPoints[Role.ATTACKER.ordinal()] += Math.max(0, points);
			}
			for (BaWidgetInfo baWidgetInfo : DEFENDER_POINTS_WIDGETS)
			{
				final int points = getBaWidgetValue(baWidgetInfo);
				rolesPoints[Role.DEFENDER.ordinal()] += Math.max(0, points);
			}
			for (BaWidgetInfo baWidgetInfo : COLLECTOR_POINTS_WIDGETS)
			{
				final int points = getBaWidgetValue(baWidgetInfo);
				rolesPoints[Role.COLLECTOR.ordinal()] += Math.max(0, points);
			}
			for (BaWidgetInfo baWidgetInfo : HEALER_POINTS_WIDGETS)
			{
				final int points = getBaWidgetValue(baWidgetInfo);
				rolesPoints[Role.HEALER.ordinal()] += Math.max(0, points);
			}
		}

		ended = true;
	}

	ChatMessageBuilder getWavePoints(boolean colorful, boolean bonus)
	{
		ChatMessageBuilder message = new ChatMessageBuilder();
		for (int i = 0; i < Role.values().length; i++)
		{
			if (i != 0)
			{
				message.append(" / ");
			}
			Role role = Role.values()[i];
			String roleName = role.getName();
			Color roleColor = role.getColor();
			int pts = Math.max(0, rolesPoints[i]);
			if (bonus)
			{
				pts *= 1.1;
			}
			String points = String.valueOf(pts);
			message.append(roleName + ": ");
			if (colorful)
			{
				message.append(roleColor, points);
			}
			else
			{
				message.append(points);
			}
		}
		return message;
	}

	ChatMessageBuilder getWaveSummary(boolean colorful)
	{
		ChatMessageBuilder message = new ChatMessageBuilder();
		for (int i = 0; i < SUMMARY_DESCRIPTIONS.length; i++)
		{
			if (i != 0)
			{
				message.append(" / ");
			}

			message.append(SUMMARY_DESCRIPTIONS[i]).append(": ").append(String.valueOf(amounts[i]));

			int pointsCount = points[i];
			if (pointsCount != 0)
			{
				message.append(" (");
				if (colorful)
				{
					Color color = pointsCount < 0 ? BaMinigamePlugin.RED : BaMinigamePlugin.DARK_GREEN;
					message.append(color, (pointsCount > 0 ? "+" : "") + pointsCount);
				}
				else
				{
					message.append((pointsCount > 0 ? "+" : "") + pointsCount);
				}
				message.append(")");
			}
		}
		return message;
	}

	private int getSecondsElapsed(boolean delayTicks, TimeUnits units)
	{
		if (units == TimeUnits.TICKS)
		{
			return getTicksInMillis(delayTicks) / 1000;
		}
		return timer == null ? 0 : (int) timer.getWaveTime().getSeconds();
	}

	private int getMillisOfSecondElapsed(boolean delayTicks, TimeUnits units)
	{
		if (units == TimeUnits.TICKS)
		{
			return getTicksInMillis(delayTicks) % 1000;
		}
		return timer == null ? 0 : timer.getWaveTime().getNano() / 1_000_000;
	}

	private int getTicksInMillis(boolean delayed)
	{
		return timer == null ? 0 : timer.getCurrentWaveTick(delayed) * Constants.GAME_TICK_LENGTH;
	}

	private int getBaWidgetValue(BaWidgetInfo baWidgetInfo)
	{
		final Widget widget = client.getWidget(baWidgetInfo.getGroupId(), baWidgetInfo.getChildId());
		return widget == null ? 0 : Integer.parseInt(widget.getText());
	}

	public boolean isComplete()
	{
		return (role == Role.ATTACKER || role == Role.COLLECTOR) && fightersKilled && rangersKilled
				  || role == Role.DEFENDER && runnersKilled
				  || role == Role.HEALER && healersKilled;
	}
}

/*
 * Copyright (c) 2018, Cameron <https://github.com/noremac201>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.api.BaModelID;
import begosrs.barbarianassault.api.BaSpriteID;
import begosrs.barbarianassault.api.BaVarbits;
import begosrs.barbarianassault.api.widgets.BaWidgetInfo;
import com.google.common.collect.ImmutableMap;
import java.awt.Color;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.ItemID;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.Widget;

@Getter
@AllArgsConstructor
public enum Role
{
	ATTACKER("Attacker", BaMinigamePlugin.RED,
		BaWidgetInfo.BA_ATTACKER_WAVE_INFO,
		BaWidgetInfo.BA_ATTACKER_WAVE_TEXT, BaWidgetInfo.BA_ATTACKER_WAVE_SPRITE,
		BaWidgetInfo.BA_ATTACKER_LISTEN_TOP_TEXT, BaWidgetInfo.BA_HORN_OF_GLORY_COLLECTOR_LISTEN_TEXT,
		BaWidgetInfo.BA_ATTACKER_CALL_TEXT, BaWidgetInfo.BA_ATTACKER_CALL_FLASH,
		BaWidgetInfo.BA_HORN_OF_GLORY_COLLECTOR_LISTEN_TEXT, BaWidgetInfo.BA_ATTACKER_ROLE_TEXT,
		BaWidgetInfo.BA_ATTACKER_ROLE_SPRITE, BaSpriteID.BA_COLLECTOR_HORN_ICON, "Collector",
		BaVarbits.BA_ATTACKER_ROLE_BASE_POINTS, BaVarbits.BA_ATTACKER_ROLE_MULTIPLIER,
		SpriteID.BARBARIAN_ASSAULT_HORN_FOR_ATTACKER_ICON,
		BaModelID.BA_ATTACKER_ICON),
	DEFENDER("Defender", BaMinigamePlugin.LIGHT_BLUE,
		BaWidgetInfo.BA_DEFENDER_WAVE_INFO,
		BaWidgetInfo.BA_DEFENDER_WAVE_TEXT, BaWidgetInfo.BA_DEFENDER_WAVE_SPRITE,
		BaWidgetInfo.BA_DEFENDER_LISTEN_TEXT, BaWidgetInfo.BA_HORN_OF_GLORY_HEALER_LISTEN_TEXT,
		BaWidgetInfo.BA_DEFENDER_CALL_TEXT, BaWidgetInfo.BA_DEFENDER_CALL_FLASH,
		BaWidgetInfo.BA_HORN_OF_GLORY_HEALER_LISTEN_TEXT, BaWidgetInfo.BA_DEFENDER_ROLE_TEXT,
		BaWidgetInfo.BA_DEFENDER_ROLE_SPRITE, BaSpriteID.BA_HEALER_HORN_ICON, "Healer",
		BaVarbits.BA_DEFENDER_ROLE_BASE_POINTS, BaVarbits.BA_DEFENDER_ROLE_MULTIPLIER,
		SpriteID.BARBARIAN_ASSAULT_HORN_FOR_DEFENDER_ICON,
		BaModelID.BA_DEFENDER_ICON),
	COLLECTOR("Collector", Color.YELLOW,
		BaWidgetInfo.BA_COLLECTOR_WAVE_INFO,
		BaWidgetInfo.BA_COLLECTOR_WAVE_TEXT, BaWidgetInfo.BA_COLLECTOR_WAVE_SPRITE,
		BaWidgetInfo.BA_COLLECTOR_LISTEN_TEXT, BaWidgetInfo.BA_HORN_OF_GLORY_ATTACKER_LISTEN_TEXT,
		BaWidgetInfo.BA_COLLECTOR_CALL_TEXT, BaWidgetInfo.BA_COLLECTOR_CALL_FLASH,
		BaWidgetInfo.BA_HORN_OF_GLORY_ATTACKER_LISTEN_TEXT, BaWidgetInfo.BA_COLLECTOR_ROLE_TEXT,
		BaWidgetInfo.BA_COLLECTOR_ROLE_SPRITE, BaSpriteID.BA_ATTACKER_HORN_ICON, "Attacker",
		BaVarbits.BA_COLLECTOR_ROLE_BASE_POINTS, BaVarbits.BA_COLLECTOR_ROLE_MULTIPLIER,
		SpriteID.BARBARIAN_ASSAULT_HORN_FOR_COLLECTOR_ICON,
		BaModelID.BA_COLLECTOR_ICON),
	HEALER("Healer", BaMinigamePlugin.DARK_GREEN,
		BaWidgetInfo.BA_HEALER_WAVE_INFO,
		BaWidgetInfo.BA_HEALER_WAVE_TEXT, BaWidgetInfo.BA_HEALER_WAVE_SPRITE,
		BaWidgetInfo.BA_HEALER_LISTEN_TEXT, BaWidgetInfo.BA_HORN_OF_GLORY_DEFENDER_LISTEN_TEXT,
		BaWidgetInfo.BA_HEALER_CALL_TEXT, BaWidgetInfo.BA_HEALER_CALL_FLASH,
		BaWidgetInfo.BA_HORN_OF_GLORY_DEFENDER_LISTEN_TEXT, BaWidgetInfo.BA_HEALER_ROLE_TEXT,
		BaWidgetInfo.BA_HEALER_ROLE_SPRITE, BaSpriteID.BA_DEFENDER_HORN_ICON, "Defender",
		BaVarbits.BA_HEALER_ROLE_POINTS, BaVarbits.BA_HEALER_ROLE_MULTIPLIER,
		SpriteID.BARBARIAN_ASSAULT_HORN_FOR_HEALER_ICON,
		BaModelID.BA_HEALER_ICON);

	private static final ImmutableMap<String, String> GLORY_CALLS = ImmutableMap.<String, String>builder()
		.put("Controlled/Bullet/Wind", "Controlled/Bullet/Wind")
		.put("Accurate/Field/Water", "Accurate/Field/Water")
		.put("Aggressive/Blunt/Earth", "Aggressive/Blunt/Earth")
		.put("Defensive/Barbed/Fire", "Defensive/Barbed/Fire")
		.put("Tofu", "Tofu")
		.put("Crackers", "Crackers")
		.put("Worms", "Worms")
		.put("Poison worms", "Pois. Worms")
		.put("Poison tofu", "Pois. Tofu")
		.put("Poison meat", "Pois. Meat")
		.put("Red egg", "Red egg")
		.put("Green egg", "Green egg")
		.put("Blue egg", "Blue egg")
		.build();
	private static final ImmutableMap<String, Integer> ITEMS = ImmutableMap.<String, Integer>builder()
		.put("Tofu", ItemID.TOFU)
		.put("Crackers", ItemID.CRACKERS)
		.put("Worms", ItemID.WORMS)
		.put("Poison Worms", ItemID.POISONED_WORMS)
		.put("Pois. Worms", ItemID.POISONED_WORMS)
		.put("Poison Tofu", ItemID.POISONED_TOFU)
		.put("Pois. Tofu", ItemID.POISONED_TOFU)
		.put("Poison Meat", ItemID.POISONED_MEAT)
		.put("Pois. Meat", ItemID.POISONED_MEAT)
		.put("Controlled/Bullet/Wind", ItemID.BULLET_ARROW)
		.put("Accurate/Field/Water", ItemID.FIELD_ARROW)
		.put("Aggressive/Blunt/Earth", ItemID.BLUNT_ARROW)
		.put("Defensive/Barbed/Fire", ItemID.BARBED_ARROW)
		.put("Red eggs", ItemID.RED_EGG)
		.put("Green eggs", ItemID.GREEN_EGG)
		.put("Blue eggs", ItemID.BLUE_EGG)
		.build();
	private final String name;
	private final Color color;
	private final BaWidgetInfo waveInfo;
	private final BaWidgetInfo waveText;
	private final BaWidgetInfo waveSprite;
	private final BaWidgetInfo listen;
	private final BaWidgetInfo hornOfGloryListen;
	private final BaWidgetInfo call;
	private final BaWidgetInfo callFlash;
	private final BaWidgetInfo hornOfGloryCall;
	private final BaWidgetInfo roleText;
	private final BaWidgetInfo roleSprite;
	private final int partnerHornSpriteId;
	private final String partnerRoleName;
	private final BaVarbits basePointsVarBit;
	private final BaVarbits pointsMultiplierVarBit;
	private final int hornSpriteId;
	private final int roleModelId;

	@Override
	public String toString()
	{
		return name();
	}

	int getListenItemId(Client client)
	{
		final String listen = getListenText(client);
		return ITEMS.getOrDefault(listen, -1);
	}

	String getListenText(Client client)
	{
		String listen = getWidgetText(client, hornOfGloryListen, this.listen);
		if (this == ATTACKER)
		{
			if ("Controlled/".equals(listen))
			{
				listen = "Controlled/Bullet/Wind";
			}
			else if ("Accurate/".equals(listen))
			{
				listen = "Accurate/Field/Water";
			}
			else if ("Aggressive/".equals(listen))
			{
				listen = "Aggressive/Blunt/Earth";
			}
			else if ("Defensive/".equals(listen))
			{
				listen = "Defensive/Barbed/Fire";
			}
		}
		return listen;
	}

	private String getWidgetText(Client client, BaWidgetInfo hornOfGlory, BaWidgetInfo baWidgetInfo)
	{
		Widget widget = client.getWidget(hornOfGlory.getGroupId(), hornOfGlory.getChildId());
		if (widget != null)
		{
			return GLORY_CALLS.get(widget.getText());
		}

		widget = client.getWidget(baWidgetInfo.getGroupId(), baWidgetInfo.getChildId());
		if (widget != null)
		{
			return widget.getText();
		}

		return null;
	}

	public int getPoints(Client client)
	{
		final int constant = 512;
		int multiplier = client.getVarbitValue(pointsMultiplierVarBit.getId());
		return client.getVarbitValue(basePointsVarBit.getId()) + constant * multiplier;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.inventory;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import net.runelite.api.ItemComposition;
import net.runelite.api.widgets.WidgetItem;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.WidgetItemOverlay;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.AlphaComposite;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.image.BufferedImage;

@Singleton
public class InventoryOverlay extends WidgetItemOverlay
{
	private final ItemManager itemManager;
	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;

	@Inject
	private InventoryOverlay(ItemManager itemManager, BaMinigamePlugin plugin, BaMinigameConfig config)
	{
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.config = config;
		showOnInventory();
		showOnEquipment();
	}

	@Override
	public void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem itemWidget)
	{
		final Role role = plugin.getRole();
		if (role == null)
		{
			return;
		}

		final int listenItemId = plugin.getLastListenItemId();
		if (listenItemId != itemId)
		{
			return;
		}

		final Color color = plugin.getColorForInventoryItemId(itemId);
		switch (role)
		{
			case ATTACKER:
				if (config.highlightArrows())
				{
					highlightItem(graphics, itemId, itemWidget, color);
				}
				break;
			case DEFENDER:
				if (config.highlightBait())
				{
					highlightItem(graphics, itemId, itemWidget, color);
				}
				break;
			case HEALER:
				if (config.highlightPoison())
				{
					highlightItem(graphics, itemId, itemWidget, color);
				}
				break;
		}
	}

	private void highlightItem(Graphics2D graphics, int itemId, WidgetItem itemWidget, Color color)
	{
		final Rectangle bounds = itemWidget.getCanvasBounds();

		final InventoryHighlightMode inventoryHighlightMode = config.inventoryHighlightMode();
		if (inventoryHighlightMode == InventoryHighlightMode.OVERLAY)
		{
			ItemComposition item = itemManager.getItemComposition(itemId);
			final BufferedImage image = itemManager.getImage(itemId, itemWidget.getQuantity(), item.isStackable());
			final BufferedImage overlayedImage = overlay(image, color);
			graphics.drawImage(overlayedImage, (int) bounds.getX(), (int) bounds.getY(), null);
		}
		else if (inventoryHighlightMode == InventoryHighlightMode.OUTLINE)
		{
			final BufferedImage outline = itemManager.getItemOutline(itemId, itemWidget.getQuantity(), color);
			graphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);
		}
	}

	private BufferedImage overlay(BufferedImage image, Color color)
	{
		int w = image.getWidth();
		int h = image.getHeight();
		BufferedImage overlayed = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
		Graphics2D g = overlayed.createGraphics();
		g.drawImage(image, 0, 0, null);
		g.setComposite(AlphaComposite.SrcAtop);
		g.setColor(color);
		g.fillRect(0, 0, w, h);
		g.dispose();
		return overlayed;
	}
}
/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.inventory;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum InventoryHighlightMode
{
	OVERLAY("Overlay"),
	OUTLINE("Outline"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.ticktimer;

import lombok.Data;

import java.awt.Color;

@Data
public class RunnerTickTimer
{
	private static final int MOVE_TICK = 2;
	private static final int MULTIKILL_TICK = 4;

	private int count;
	private boolean displaying;

	public RunnerTickTimer()
	{
		this.count = 0;
		this.displaying = true;
	}

	public void incrementCount()
	{
		count = (count + 1) % 10;
	}

	public Color getColor()
	{
		if (count == MOVE_TICK)
		{
			return Color.YELLOW;
		}
		else if (count == MULTIKILL_TICK)
		{
			return Color.GREEN;
		}
		else
		{
			return Color.WHITE;
		}
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.ticktimer;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.TitleComponent;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.Dimension;
import java.awt.Graphics2D;

@Slf4j
@Singleton
public class RunnerTickTimerOverlay extends OverlayPanel
{
	private static final int DEFAULT_WIDTH = 20;

	private final BaMinigamePlugin plugin;
	private final BaMinigameConfig config;

	@Inject
	private RunnerTickTimerOverlay(BaMinigamePlugin plugin, BaMinigameConfig config)
	{
		super(plugin);
		setPosition(OverlayPosition.TOP_CENTER);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.plugin = plugin;
		this.config = config;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		final Role role = plugin.getRole();
		if (role == Role.ATTACKER && config.showRunnerTickTimerAttacker()
				  || role == Role.DEFENDER && config.showRunnerTickTimerDefender()
				  || role == Role.COLLECTOR && config.showRunnerTickTimerCollector()
				  || role == Role.HEALER && config.showRunnerTickTimerHealer())
		{
			final RunnerTickTimer runnerTickTimer = plugin.getRunnerTickTimer();
			if (runnerTickTimer != null && runnerTickTimer.isDisplaying())
			{
				final int tickCount = runnerTickTimer.getCount();
				TitleComponent titleComponent = TitleComponent.builder()
						  .text(String.valueOf(tickCount))
						  .color(runnerTickTimer.getColor())
						  .build();
				panelComponent.getChildren().add(titleComponent);
				panelComponent.setPreferredSize(new Dimension(DEFAULT_WIDTH, 0));

				return super.render(graphics);
			}
		}

		return null;
	}

}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum RewardsBreakdownMode
{
	WAVE("Wave"),
	ROUND("Round"),
	WAVE_ROUND("Wave/Round"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum DisplayPointsLocationMode
{
	ALWAYS("Always"),
	OUTPOST("Outpost only"),
	OUTPOST_INGAME("Outpost/in-game"),
	NEVER("Never");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

public enum KandarinDiaryBonusMode
{
	IF_COMPLETED,
	YES,
	NO
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

public enum DisplayPointsMode
{
	TEXT_BOX,
	INFO_BOX
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum PointsMode
{
	WAVE("Wave"),
	ROUND("Round"),
	WAVE_ROUND("Wave/Round"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum PointsCounterMode
{
	CURRENT_POINTS("Current"),
	ROUND_POINTS("Round"),
	SESSION_POINTS("Session");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import java.awt.Color;
import java.awt.image.BufferedImage;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

@Setter
@Getter
@ToString
public class RolePointsInfoBox extends InfoBox
{

	private int points;

	public RolePointsInfoBox(BufferedImage image, Plugin plugin, int points)
	{
		super(image, plugin);
		this.points = points;
	}

	@Override
	public String getText()
	{
		return String.valueOf(points);
	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}
}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.Map;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;


public class RolePointsOverlay extends OverlayPanel
{
	private final BaMinigameConfig config;
	private final BaMinigamePlugin plugin;

	@Inject
	private RolePointsOverlay(BaMinigameConfig config, BaMinigamePlugin plugin)
	{
		super(plugin);
		this.plugin = plugin;
		this.config = config;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(0.5f);
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Ba role points overlay"));
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (config.displayPointsMode() != DisplayPointsMode.TEXT_BOX || !plugin.shouldDisplayRolePoints())
		{
			return null;
		}

		RolePointsTrackingMode rolePointsTrackingMode = config.rolePointsTrackingMode();
		for (Map.Entry<Role, Integer> rolePoints : plugin.getRolePoints().entrySet())
		{
			final Role role = rolePoints.getKey();
			if (rolePointsTrackingMode == RolePointsTrackingMode.ATTACKER && role != Role.ATTACKER
					  || rolePointsTrackingMode == RolePointsTrackingMode.DEFENDER && role != Role.DEFENDER
					  || rolePointsTrackingMode == RolePointsTrackingMode.HEALER && role != Role.HEALER
					  || rolePointsTrackingMode == RolePointsTrackingMode.COLLECTOR && role != Role.COLLECTOR)
			{
				continue;
			}
			final Integer points = rolePoints.getValue();
			addPanelComponentPoints(role, points);
		}

		return super.render(graphics);
	}

	private void addPanelComponentPoints(Role role, Integer points)
	{
		final String pts = points == null ? "-" : Integer.toString(points);
		final Color strColor = role.getColor();
		final String str = ColorUtil.prependColorTag(pts, strColor);

		panelComponent.getChildren().add(LineComponent.builder()
				  .left(role.getName())
				  .right(str)
				  .rightColor(strColor)
				  .build());
	}

}

/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.points;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum RolePointsTrackingMode
{
	MINE("Mine"),
	ALL("All"),
	PLAYER_ONE("Player 1"),
	PLAYER_TWO("Player 2"),
	PLAYER_THREE("Player 3"),
	PLAYER_FOUR("Player 4"),
	PLAYER_FIVE("Player 5"),
	ATTACKER("Attacker"),
	DEFENDER("Defender"),
	COLLECTOR("Collector"),
	HEALER("Healer");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

package begosrs.barbarianassault;

import net.runelite.client.input.KeyListener;

import javax.inject.Inject;
import java.awt.event.KeyEvent;

public class BaMinigameInputListener implements KeyListener
{

	@Inject
	private BaMinigamePlugin plugin;

	@Inject
	private BaMinigameConfig config;

	@Override
	public void keyTyped(KeyEvent e)
	{
	}

	@Override
	public void keyPressed(KeyEvent e)
	{
		if (config.healerTeammatesHealthHotkey().matches(e))
		{
			plugin.onTeammatesHealthHotkeyChanged(true);
		}
	}

	@Override
	public void keyReleased(KeyEvent e)
	{
		if (config.healerTeammatesHealthHotkey().matches(e))
		{
			plugin.onTeammatesHealthHotkeyChanged(false);
		}
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault;

import begosrs.barbarianassault.points.RolePointsTrackingMode;
import begosrs.barbarianassault.timer.Timer;
import lombok.Getter;
import net.runelite.client.chat.ChatMessageBuilder;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

public class Round
{
	static final int STARTING_WAVE = 1;
	public static final int ENDING_WAVE = 10;

	private static final String[] SUMMARY_DESCRIPTIONS = {
			  "Wrong att.",
			  "Runners passed",
			  "Eggs",
			  "Heal",
			  "Wrong pois.",
	};

	@Getter
	private final int startingWave;
	@Getter
	private final Timer timer;
	@Getter
	private final List<Wave> waves;

	// sum of all 4 role points
	private final int[] rolesPoints;

	// sum of amounts and points for each of the events happening during the game:
	// wrong attacks, runners passed, eggs collected, hp healed, wrong poisons used
	private final int[] summaryAmounts;
	private final int[] summaryPoints;

	Round(int startingWave, Timer timer)
	{
		this.startingWave = startingWave;
		this.timer = timer;
		this.waves = new ArrayList<>();
		this.rolesPoints = new int[4];
		this.summaryPoints = new int[5];
		this.summaryAmounts = new int[5];
	}

	void addWave(Wave wave, RolePointsTrackingMode trackingMode)
	{
		int[] waveRolesPoints = wave.getRolesPoints();
		Role[] playerRoles = wave.getPlayerRoles();
		Role myRole = wave.getRole();
		for (int i = 0; i < rolesPoints.length; i++)
		{
			int playerRoleIndex;
			switch (trackingMode)
			{
				case PLAYER_ONE:
					playerRoleIndex = 0;
					break;
				case PLAYER_TWO:
					playerRoleIndex = 1;
					break;
				case PLAYER_THREE:
					playerRoleIndex = 2;
					break;
				case PLAYER_FOUR:
					playerRoleIndex = 3;
					break;
				case PLAYER_FIVE:
					playerRoleIndex = 4;
					break;
				default:
					playerRoleIndex = -1;
					break;
			}
			boolean isPlayerTracking = playerRoleIndex >= 0
					  && playerRoles[playerRoleIndex] != null;
			if (trackingMode == RolePointsTrackingMode.ALL
					  || trackingMode == RolePointsTrackingMode.MINE && myRole != null && myRole.ordinal() == i
					  || trackingMode == RolePointsTrackingMode.ATTACKER && Role.ATTACKER.ordinal() == i
					  || trackingMode == RolePointsTrackingMode.DEFENDER && Role.DEFENDER.ordinal() == i
					  || trackingMode == RolePointsTrackingMode.HEALER && Role.HEALER.ordinal() == i
					  || trackingMode == RolePointsTrackingMode.COLLECTOR && Role.COLLECTOR.ordinal() == i
					  || isPlayerTracking && playerRoles[playerRoleIndex].ordinal() == i)
			{
				rolesPoints[i] += waveRolesPoints[i];
			}
			if (wave.getNumber() == Round.ENDING_WAVE)
			{
				if (trackingMode == RolePointsTrackingMode.MINE && myRole != null && myRole.ordinal() != i
						  || isPlayerTracking && playerRoles[playerRoleIndex].ordinal() != i)
				{
					rolesPoints[i] += 5;
				}
			}
		}
		int[] waveAmounts = wave.getAmounts();
		for (int i = 0; i < summaryAmounts.length; i++)
		{
			summaryAmounts[i] += waveAmounts[i];
		}
		int[] wavePoints = wave.getPoints();
		for (int i = 0; i < summaryPoints.length; i++)
		{
			summaryPoints[i] += wavePoints[i];
		}
		waves.add(wave);
	}

	public int getCollectedEggsCount(int currentWaveCollectedEggs)
	{
		return currentWaveCollectedEggs + waves.stream().map(Wave::getCollectedEggsCount).reduce(0, Integer::sum);
	}

	public int getHpHealed(int currentWaveHpHealed)
	{
		return currentWaveHpHealed + waves.stream().map(Wave::getHpHealed).reduce(0, Integer::sum);
	}

	int getNumberOfWaves()
	{
		return waves.size();
	}

	boolean isComplete()
	{
		return startingWave - 1 + getNumberOfWaves() == Round.ENDING_WAVE;
	}

	ChatMessageBuilder getRoundPointsMessage(boolean colorful, boolean bonus)
	{
		ChatMessageBuilder message = new ChatMessageBuilder();
		for (int i = 0; i < Role.values().length; i++)
		{

			if (i != 0)
			{
				message.append(" / ");
			}

			Role role = Role.values()[i];
			String roleName = role.getName();
			Color roleColor = role.getColor();
			int pts = Math.max(0, rolesPoints[i]);
			if (bonus)
			{
				pts *= 1.1;
			}
			String points = String.valueOf(pts);
			message.append(roleName + ": ");
			if (colorful)
			{
				message.append(roleColor, points);
			}
			else
			{
				message.append(points);
			}
		}
		return message;
	}

	ChatMessageBuilder getRoundSummaryMessage(boolean colorful)
	{
		ChatMessageBuilder message = new ChatMessageBuilder();
		for (int i = 0; i < SUMMARY_DESCRIPTIONS.length; i++)
		{
			if (i != 0)
			{
				message.append(" / ");
			}
			message.append(SUMMARY_DESCRIPTIONS[i]).append(": ").append(String.valueOf(summaryAmounts[i]));
			int pointsCount = summaryPoints[i];
			if (pointsCount != 0)
			{
				message.append(" (");
				if (colorful)
				{
					Color color = pointsCount < 0 ? BaMinigamePlugin.RED : BaMinigamePlugin.DARK_GREEN;
					message.append(color, (pointsCount > 0 ? "+" : "") + pointsCount);
				}
				else
				{
					message.append((pointsCount > 0 ? "+" : "") + pointsCount);
				}
				message.append(")");
			}
		}
		return message;
	}

	public int getRolePoints(Role role)
	{
		return rolesPoints[role.ordinal()];
	}

	public void resetRolePoints()
	{
		for (int i = 0; i < Role.values().length; i++)
		{
			rolesPoints[i] = 0;
		}
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.api;

public class BaObjectID
{
	public static final int EGG_HOPPER_20267 = 20267;
}

package begosrs.barbarianassault.api;

public class BaModelID
{
	public static final int BA_ATTACKER_ICON = 20561;
	public static final int BA_DEFENDER_ICON = 20566;
	public static final int BA_COLLECTOR_ICON = 20563;
	public static final int BA_HEALER_ICON = 20569;
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.api.widgets;

/**
 * Utility class mapping widget IDs to global constants.
 * <p>
 * The constants defined directly under the {@link BaWidgetID} class are
 * Widget group IDs. All child IDs are defined in sub-classes relating
 * to their group.
 * <p>
 * For a more direct group-child widget mapping, use the
 * {@link BaWidgetInfo} enum class.
 */
public class BaWidgetID
{
	public static final int BA_HORN_OF_GLORY = 484;
	public static final int BA_ATTACKER_GROUP_ID = 485;
	public static final int BA_COLLECTOR_GROUP_ID = 486;
	public static final int BA_DEFENDER_GROUP_ID = 487;
	public static final int BA_HEALER_GROUP_ID = 488;
	public static final int BA_REWARD_GROUP_ID = 497;

	public static final int COMBAT_GROUP_ID = 593;

	public static final int CONNAD_REWARDS_GROUP_ID = 491;

	static class BarbarianAssault
	{
		static final int WAVE_INFO = 2;
		static final int CALL_FLASH = 3;
		static final int WAVE_SPRITE = 4;
		static final int CURRENT_WAVE = 5;
		static final int LISTEN = 7;
		static final int TO_CALL = 9;
		static final int ROLE_SPRITE = 10;
		static final int ROLE = 11;
		static final int REWARD_TEXT = 57;

		static class Attacker
		{
			static final int LISTEN_TOP = 7;
			static final int LISTEN_BOTTOM = 8;
			static final int TO_CALL = 10;
			static final int ROLE_SPRITE = 11;
			static final int ROLE = 12;
		}

		static class Healer
		{
			static final int TEAMMATES = 13;
			static final int TEAMMATE1 = 18;
			static final int TEAMMATE2 = 22;
			static final int TEAMMATE3 = 26;
			static final int TEAMMATE4 = 30;
		}

		static class HornOfGlory
		{
			static final int ATTACKER = 5;
			static final int DEFENDER = 6;
			static final int COLLECTOR = 7;
			static final int HEALER = 8;
		}

		static class RewardValues
		{
			static final int RUNNERS_PASSED = 14;
			static final int HITPOINTS_REPLENISHED = 19;
			static final int WRONG_POISON_PACKS_USED = 20;
			static final int EGGS_COLLECTED = 21;
			static final int FAILED_ATTACKS = 22;
			static final int RUNNERS_PASSED_POINTS = 24;
			static final int RANGERS_KILLED = 25;
			static final int FIGHTERS_KILLED = 26;
			static final int HEALERS_KILLED = 27;
			static final int RUNNERS_KILLED = 28;
			static final int HITPOINTS_REPLENISHED_POINTS = 29;
			static final int WRONG_POISON_PACKS_USED_POINTS = 30;
			static final int EGGS_COLLECTED_POINTS = 31;
			static final int FAILED_ATTACKS_POINTS = 32;
			static final int BASE_POINTS = 33;
		}

		static class Team
		{
			static final int PLAYER1_ROLE = 18;
			static final int PLAYER2_ROLE = 19;
			static final int PLAYER3_ROLE = 20;
			static final int PLAYER4_ROLE = 21;
			static final int PLAYER5_ROLE = 22;
		}
	}

	static class Combat
	{
		static final int STYLE_ONE = 5;
		static final int STYLE_ONE_ICON = 7;
		static final int STYLE_ONE_TEXT = 8;
		static final int STYLE_TWO = 9;
		static final int STYLE_TWO_ICON = 11;
		static final int STYLE_TWO_TEXT = 12;
		static final int STYLE_THREE = 13;
		static final int STYLE_THREE_ICON = 15;
		static final int STYLE_THREE_TEXT = 16;
		static final int STYLE_FOUR = 17;
		static final int STYLE_FOUR_ICON = 19;
		static final int STYLE_FOUR_TEXT = 20;
	}

	static class Connad
	{
		static final int CONTENT = 2;
		static final int SCROLLBAR = 4;
	}

}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.api.widgets;

import lombok.Getter;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;

/**
 * Represents a group-child {@link Widget} relationship.
 * <p>
 * For getting a specific widget from the client, see {@link net.runelite.api.Client#getWidget(int, int)}.
 */
@Getter
public enum BaWidgetInfo
{
	BA_TEAM_PLAYER1_ROLE(InterfaceID.BA_TEAM, BaWidgetID.BarbarianAssault.Team.PLAYER1_ROLE),
	BA_TEAM_PLAYER2_ROLE(InterfaceID.BA_TEAM, BaWidgetID.BarbarianAssault.Team.PLAYER2_ROLE),
	BA_TEAM_PLAYER3_ROLE(InterfaceID.BA_TEAM, BaWidgetID.BarbarianAssault.Team.PLAYER3_ROLE),
	BA_TEAM_PLAYER4_ROLE(InterfaceID.BA_TEAM, BaWidgetID.BarbarianAssault.Team.PLAYER4_ROLE),
	BA_TEAM_PLAYER5_ROLE(InterfaceID.BA_TEAM, BaWidgetID.BarbarianAssault.Team.PLAYER5_ROLE),

	BA_ATTACKER_WAVE_INFO(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_INFO),
	BA_ATTACKER_CALL_FLASH(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.CALL_FLASH),
	BA_ATTACKER_WAVE_TEXT(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.CURRENT_WAVE),
	BA_ATTACKER_WAVE_SPRITE(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_SPRITE),
	BA_ATTACKER_CALL_TEXT(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.Attacker.TO_CALL),
	BA_ATTACKER_LISTEN_TOP_TEXT(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.Attacker.LISTEN_TOP),
	BA_ATTACKER_ROLE_TEXT(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.Attacker.ROLE),
	BA_ATTACKER_ROLE_SPRITE(BaWidgetID.BA_ATTACKER_GROUP_ID, BaWidgetID.BarbarianAssault.Attacker.ROLE_SPRITE),

	BA_COLLECTOR_WAVE_INFO(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_INFO),
	BA_COLLECTOR_CALL_FLASH(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.CALL_FLASH),
	BA_COLLECTOR_WAVE_TEXT(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.CURRENT_WAVE),
	BA_COLLECTOR_WAVE_SPRITE(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_SPRITE),
	BA_COLLECTOR_CALL_TEXT(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.TO_CALL),
	BA_COLLECTOR_LISTEN_TEXT(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.LISTEN),
	BA_COLLECTOR_ROLE_TEXT(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE),
	BA_COLLECTOR_ROLE_SPRITE(BaWidgetID.BA_COLLECTOR_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE_SPRITE),

	BA_DEFENDER_WAVE_INFO(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_INFO),
	BA_DEFENDER_CALL_FLASH(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.CALL_FLASH),
	BA_DEFENDER_WAVE_TEXT(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.CURRENT_WAVE),
	BA_DEFENDER_WAVE_SPRITE(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_SPRITE),
	BA_DEFENDER_CALL_TEXT(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.TO_CALL),
	BA_DEFENDER_LISTEN_TEXT(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.LISTEN),
	BA_DEFENDER_ROLE_TEXT(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE),
	BA_DEFENDER_ROLE_SPRITE(BaWidgetID.BA_DEFENDER_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE_SPRITE),

	BA_HEALER_WAVE_INFO(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_INFO),
	BA_HEALER_CALL_FLASH(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.CALL_FLASH),
	BA_HEALER_WAVE_TEXT(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.CURRENT_WAVE),
	BA_HEALER_WAVE_SPRITE(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.WAVE_SPRITE),
	BA_HEALER_CALL_TEXT(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.TO_CALL),
	BA_HEALER_LISTEN_TEXT(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.LISTEN),
	BA_HEALER_ROLE_TEXT(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE),
	BA_HEALER_ROLE_SPRITE(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.ROLE_SPRITE),

	BA_HEAL_TEAMMATES(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.Healer.TEAMMATES),
	BA_HEAL_TEAMMATE1(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.Healer.TEAMMATE1),
	BA_HEAL_TEAMMATE2(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.Healer.TEAMMATE2),
	BA_HEAL_TEAMMATE3(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.Healer.TEAMMATE3),
	BA_HEAL_TEAMMATE4(BaWidgetID.BA_HEALER_GROUP_ID, BaWidgetID.BarbarianAssault.Healer.TEAMMATE4),

	BA_HORN_OF_GLORY_ATTACKER_LISTEN_TEXT(BaWidgetID.BA_HORN_OF_GLORY, BaWidgetID.BarbarianAssault.HornOfGlory.ATTACKER),
	BA_HORN_OF_GLORY_COLLECTOR_LISTEN_TEXT(BaWidgetID.BA_HORN_OF_GLORY, BaWidgetID.BarbarianAssault.HornOfGlory.COLLECTOR),
	BA_HORN_OF_GLORY_DEFENDER_LISTEN_TEXT(BaWidgetID.BA_HORN_OF_GLORY, BaWidgetID.BarbarianAssault.HornOfGlory.DEFENDER),
	BA_HORN_OF_GLORY_HEALER_LISTEN_TEXT(BaWidgetID.BA_HORN_OF_GLORY, BaWidgetID.BarbarianAssault.HornOfGlory.HEALER),

	BA_REWARD_TEXT(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.REWARD_TEXT),
	BA_RUNNERS_PASSED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.RUNNERS_PASSED),
	BA_HITPOINTS_REPLENISHED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.HITPOINTS_REPLENISHED),
	BA_WRONG_POISON_PACKS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.WRONG_POISON_PACKS_USED),
	BA_EGGS_COLLECTED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.EGGS_COLLECTED),
	BA_FAILED_ATTACKS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.FAILED_ATTACKS),
	BA_RUNNERS_PASSED_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.RUNNERS_PASSED_POINTS),
	BA_RANGERS_KILLED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.RANGERS_KILLED),
	BA_FIGHTERS_KILLED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.FIGHTERS_KILLED),
	BA_HEALERS_KILLED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.HEALERS_KILLED),
	BA_RUNNERS_KILLED(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.RUNNERS_KILLED),
	BA_HITPOINTS_REPLENISHED_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.HITPOINTS_REPLENISHED_POINTS),
	BA_WRONG_POISON_PACKS_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.WRONG_POISON_PACKS_USED_POINTS),
	BA_EGGS_COLLECTED_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.EGGS_COLLECTED_POINTS),
	BA_FAILED_ATTACKS_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.FAILED_ATTACKS_POINTS),
	BA_BASE_POINTS(BaWidgetID.BA_REWARD_GROUP_ID, BaWidgetID.BarbarianAssault.RewardValues.BASE_POINTS),

	COMBAT_STYLE_ONE(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_ONE),
	COMBAT_STYLE_ONE_ICON(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_ONE_ICON),
	COMBAT_STYLE_ONE_TEXT(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_ONE_TEXT),
	COMBAT_STYLE_TWO(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_TWO),
	COMBAT_STYLE_TWO_ICON(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_TWO_ICON),
	COMBAT_STYLE_TWO_TEXT(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_TWO_TEXT),
	COMBAT_STYLE_THREE(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_THREE),
	COMBAT_STYLE_THREE_ICON(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_THREE_ICON),
	COMBAT_STYLE_THREE_TEXT(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_THREE_TEXT),
	COMBAT_STYLE_FOUR(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_FOUR),
	COMBAT_STYLE_FOUR_ICON(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_FOUR_ICON),
	COMBAT_STYLE_FOUR_TEXT(BaWidgetID.COMBAT_GROUP_ID, BaWidgetID.Combat.STYLE_FOUR_TEXT),

	CONNAD_REWARDS_CONTENT(BaWidgetID.CONNAD_REWARDS_GROUP_ID, BaWidgetID.Connad.CONTENT),
	CONNAD_REWARDS_SCROLLBAR(BaWidgetID.CONNAD_REWARDS_GROUP_ID, BaWidgetID.Connad.SCROLLBAR);

	private final int groupId;
	private final int childId;

	BaWidgetInfo(int groupId, int childId)
	{
		this.groupId = groupId;
		this.childId = childId;
	}

	/**
	 * Gets the ID of the group-child pairing.
	 *
	 * @return the ID
	 */
	public int getId()
	{
		return groupId << 16 | childId;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.api;

public class BaSpriteID
{

	public static final int BA_ATTACKER_HORN_ICON = 768;
	public static final int BA_DEFENDER_HORN_ICON = 769;
	public static final int BA_COLLECTOR_HORN_ICON = 770;
	public static final int BA_HEALER_HORN_ICON = 771;

}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.api;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.VarPlayer;

/**
 * Server controlled "content-developer" integers.
 *
 * @see VarPlayer
 * <p>
 * These differ from a {@link VarPlayer} in that VarBits can be
 * less than 32 bits. One or more VarBits can be assigned to a
 * backing VarPlayer, each with a static range of bits that it is
 * allowed to access. This allows a more compact representation
 * of small values, like booleans
 */
@AllArgsConstructor
@Getter
public enum BaVarbits
{

	BA_CANNON_GREEN_EGGS(3257),
	BA_CANNON_RED_EGGS(3258),
	BA_CANNON_BLUE_EGGS(3259),
	BA_CANNON_OMEGA_EGGS(3266),
	BA_ATTACKER_ROLE_BASE_POINTS(4759),
	BA_COLLECTOR_ROLE_BASE_POINTS(4760),
	BA_HEALER_ROLE_POINTS(4761),
	BA_DEFENDER_ROLE_BASE_POINTS(4762),
	BA_ATTACKER_ROLE_MULTIPLIER(4763),
	BA_COLLECTOR_ROLE_MULTIPLIER(4764),
	BA_HEALER_ROLE_MULTIPLIER(4765),
	BA_DEFENDER_ROLE_MULTIPLIER(4766),
	;

	/**
	 * The raw varbit ID.
	 */
	private final int id;
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.deathtimes;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.Color;
import java.awt.image.BufferedImage;

@Setter
@Getter
@ToString
public class DeathTimeInfoBox extends InfoBox
{
	private float deathTime;

	private String format;

	public DeathTimeInfoBox(BufferedImage image, Plugin plugin, float deathTime, String format)
	{
		super(image, plugin);
		this.deathTime = deathTime;
		this.format = format;
	}

	@Override
	public String getText()
	{
		return String.format(getFormat(), getDeathTime());
	}

	@Override
	public Color getTextColor()
	{
		return Color.WHITE;
	}
}

/*
 * Copyright (c) 2020, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.deathtimes;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum DeathTimesMode
{
	INFO_BOX("Info Box"),
	CHAT("Chat"),
	INFOBOX_CHAT("Info Box/Chat"),
	DISABLED("Disable");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}
/*
 * Copyright (c) 2022, BegOsrs <https://github.com/begosrs>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package begosrs.barbarianassault.groundmarkers;

import begosrs.barbarianassault.BaMinigameConfig;
import begosrs.barbarianassault.BaMinigamePlugin;
import begosrs.barbarianassault.Role;
import begosrs.barbarianassault.Wave;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GroundObject;
import net.runelite.api.Perspective;
import net.runelite.api.Player;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.util.List;

@Slf4j
public class BrokenTrapsOverlay extends Overlay
{
	private static final int MAX_DRAW_DISTANCE = 32;

	private final Client client;
	private final BaMinigameConfig config;
	private final BaMinigamePlugin plugin;

	@Inject
	private BrokenTrapsOverlay(Client client, BaMinigameConfig config, BaMinigamePlugin plugin)
	{
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(0f);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.highlightBrokenTraps())
		{
			return null;
		}
		if (plugin.getRole() != Role.DEFENDER)
		{
			return null;
		}
		final Wave wave = plugin.getWave();
		if (wave == null || wave.isComplete())
		{
			return null;
		}

		final List<GroundObject> traps = plugin.getBrokenTraps();
		if (traps.isEmpty())
		{
			return null;
		}

		Player player = client.getLocalPlayer();
		if (player == null)
		{
			return null;
		}

		final Color color = config.highlightBrokenTrapsColor();
		final int opacity = config.highlightBrokenTrapsOpacity();
		final Stroke stroke = new BasicStroke((float) config.highlightBrokenTrapsBorderWidth());
		for (final GroundObject trap : traps)
		{
			WorldPoint worldPoint = trap.getWorldLocation();
			WorldPoint playerLocation = player.getWorldLocation();

			if (worldPoint.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
			{
				continue;
			}

			LocalPoint lp = LocalPoint.fromWorld(client, worldPoint);
			if (lp == null)
			{
				continue;
			}

			Polygon poly = Perspective.getCanvasTilePoly(client, lp);
			if (poly != null)
			{
				OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, opacity), stroke);
			}
		}

		return null;
	}

}

