package com.gimserenity;

import java.awt.Color;

import javax.inject.Inject;

import com.google.inject.Singleton;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.config.ConfigManager;

@Slf4j
@Singleton
public class GemstoneCrabUtil {
    @Inject
    private ConfigManager configManager;

    @Inject
    private Client client;

    public int loadConfigValue(String configGroup, String key){
        Integer savedValue = configManager.getRSProfileConfiguration(configGroup, key, Integer.class);
        int count = 0;
        if (savedValue != null)
        {
            try
            {
                count = savedValue;
            }
            catch (NumberFormatException e)
            {
                log.warn("Failed to parse saved value with key {}", key);
            }
        }
        return count;
    }

    /*
	 * Send a chat message with the specified color and message
	 * Only sends if the feature is enabled in the config
	 */
	public void sendChatMessage(Color color, String message, boolean isEnabled) {
		if (!isEnabled) {
			return;
		}
		String formattedMessage = new ChatMessageBuilder()
			.append(color, String.format( "[Gemstone Crab] %s", message))
			.build();
		client.addChatMessage(ChatMessageType.GAMEMESSAGE, "", formattedMessage, "");
	}
}

package com.gimserenity;

import java.awt.Color;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Notification;
import net.runelite.client.config.Range;

@ConfigGroup("gemstonecrab")
public interface GemstoneCrabTimerConfig extends Config
{
	@ConfigSection(
		name = "Notifications",
		description = "Notifications",
		position = 0
	)
	String notificationList = "notificationList";

	@ConfigItem(
		keyName = "hpThresholdNotification",
		name = "HP Threshold Notification",
		description = "Show a notification when the Gemstone Crab reaches the HP threshold",
		section = notificationList,
		position = 0
	)
	default Notification hpThresholdNotification()
	{
		return Notification.ON;
	}

	@Range(
		min = 0,
		max = 100
	)
	@ConfigItem(
		keyName = "hpThreshold",
		name = "HP Threshold %",
		description = "Send notification when Gemstone Crab HP reaches this percentage",
		section = notificationList,
		position = 1
	)
	default int hpThreshold()
	{
		return 2;
	}
	
	@ConfigItem(
		keyName = "notificationMessage",
		name = "Notification Message",
		description = "Message to show in the notification",
		section = notificationList,
		position = 2
	)
	default String notificationMessage()
	{
		return "Gemstone Crab HP threshold reached!";
	}
		
	@ConfigSection(
		name = "Highlights",
		description = "Highlight settings",
		position = 2
	)
	String highlights = "highlights";
	
	@ConfigItem(
		keyName = "highlightTunnel",
		name = "Highlight Tunnel",
		description = "Highlight the nearest tunnel after boss death",
		section = highlights
	)
	default boolean highlightTunnel()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = "tunnelHighlightColor",
		name = "Tunnel Highlight Color",
		description = "Color to highlight the tunnel with",
		section = highlights
	)
	default Color tunnelHighlightColor()
	{
		return Color.GREEN;
	}

	@ConfigItem(
		keyName = "highlightShell",
		name = "Highlight Shell",
		description = "Highlight the shell after boss death",
		section = highlights
	)
	default boolean highlightShell()
	{
		return true;
	}

	@ConfigItem(
		keyName = "tunnelTimeLeft",
		name = "Display Time Left",
		description = "Display time left until fight end over the tunnel",
		section = highlights,
		position = 3
	)
	default boolean tunnelTimeLeft()
	{
		return true;
	}

	@ConfigSection(
		name = "Current Fight Tracking",
		description = "Current Fight Information",
		position = 3
	)
	String currentFightTracking = "currentFightTracking";
	
	@ConfigItem(
		keyName = Constants.SHOW_MAIN_STATS,
		name = "Show overlay",
		description = "Display damage, DPS, XP gained, duration and time left in the stats overlay",
		section = currentFightTracking,
		position = 0
	)
	default boolean showMainStats()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_PLAYER_COUNT,
		name = "Display player count",
		description = "Display player count in the current fight",
		section = currentFightTracking,
		position = 1
	)
	default boolean displayPlayerCount()
	{
		return false;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_TOTAL_DAMAGE,
		name = "Display total damage",
		description = "Display total damage dealt in the current fight",
		section = currentFightTracking,
		position = 2
	)
	default boolean displayTotalDamage()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_DPS,
		name = "Display DPS",
		description = "Display damage per second in the current fight",
		section = currentFightTracking,
		position = 3
	)
	default boolean displayDps()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_XP_GAINED,
		name = "Display XP gained",
		description = "Display XP gained in the current fight",
		section = currentFightTracking,
		position = 4
	)
	default boolean displayXpGained()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_DURATION,
		name = "Display duration",
		description = "Display duration of the current fight",
		section = currentFightTracking,
		position = 5
	)
	default boolean displayDuration()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_TIME_LEFT,
		name = "Display time left",
		description = "Display estimated time left in the current fight",
		section = currentFightTracking,
		position = 6
	)
	default boolean displayTimeLeft()
	{
		return true;
	}

	@ConfigSection(
		name = "Stat Tracking",
		description = "Stat Tracking",
		position = 4
	)
	String statTracking = "statTracking";

    @ConfigItem(
        keyName = Constants.SHOW_STAT_TRACKING,
        name = "Show overlay",
        description = "Show the gemstone crab count overlay",
		section = statTracking,
		position = 0
    )
    default boolean showOverlay()
    {
        return true;
    }

    @ConfigItem(
        keyName = Constants.DISPLAY_KILL_COUNT,
        name = "Display kill count",
        description = "Display total Gemstone Crab kill count in overlay",
		section = statTracking,
		position = 1
    )
    default boolean displayKillCount()
    {
        return true;
    }

	@ConfigItem(
        keyName = "killMessage",
        name = "Display kill message",
        description = "Enable to recieve a kill count message in chat when boss is killed",
		section = statTracking,
		position = 2
    )
    default boolean displayKillMessage()
    {
        return true;
    }

	@ConfigItem(
        keyName = Constants.DISPLAY_MINING_ATTEMPTS,
        name = "Display total mining attempts",
        description = "Display total Gemstone Crabs attempts at mining in overlay",
		section = statTracking,
		position = 3
    )
    default boolean displayMiningAttempts()
    {
        return false;
    }

	@ConfigItem(
        keyName = Constants.DISPLAY_MINED_COUNT,
        name = "Display total successful",
        description = "Display total successful mining attempts at Gemstone Crabs in overlay",
		section = statTracking,
		position = 4
    )
    default boolean displayMinedCount()
    {
        return false;
    }

	@ConfigItem(
        keyName = Constants.DISPLAY_FAILED_MINING_COUNT,
        name = "Display total failed",
        description = "Display total failed mining attempts at Gemstone Crabs in the overlay",
		section = statTracking,
		position = 5
    )
    default boolean displayFailedMiningCount()
    {
        return false;
    }

	@ConfigItem(
        keyName = Constants.DISPLAY_GEM_COUNT,
        name = "Display total gems mined",
        description = "Display total gems mined at Gemstone Crabs in the overlay",
		section = statTracking,
		position = 6
    )
    default boolean displayGemCount()
    {
        return false;
    }
	
	@ConfigItem(
        keyName = Constants.DISPLAY_TOP3_COUNT,
        name = "Display top 3 count",
        description = "Display number of times you've been in the top 3 crab crushers",
		section = statTracking,
		position = 7
    )
    default boolean displayTop3Count()
    {
        return false;
    }
	
	@ConfigSection(
		name = "Gem Tracking",
		description = "Gem Tracking",
		position = 5
	)
	String gemTracking = "gemTracking";

	@ConfigItem(
		keyName = Constants.SHOW_GEM_TRACKING,
		name = "Show overlay",
		description = "Display gem tracking section in the overlay",
		section = gemTracking,
		position = 0
	)
	default boolean showGemTracking()
	{
		return true;
	}
	@ConfigItem(
		keyName = Constants.DISPLAY_OPALS,
		name = "Display opals",
		description = "Display opal count and percentage in the overlay",
		section = gemTracking,
		position = 1
	)
	default boolean displayOpals()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_JADES,
		name = "Display jades",
		description = "Display jade count and percentage in the overlay",
		section = gemTracking,
		position = 2
	)
	default boolean displayJades()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_RED_TOPAZ,
		name = "Display red topaz",
		description = "Display red topaz count and percentage in the overlay",
		section = gemTracking,
		position = 3
	)
	default boolean displayRedTopaz()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_SAPPHIRES,
		name = "Display sapphires",
		description = "Display sapphire count and percentage in the overlay",
		section = gemTracking,
		position = 4
	)
	default boolean displaySapphires()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_EMERALDS,
		name = "Display emeralds",
		description = "Display emerald count and percentage in the overlay",
		section = gemTracking,
		position = 5
	)
	default boolean displayEmeralds()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_RUBIES,
		name = "Display rubies",
		description = "Display ruby count and percentage in the overlay",
		section = gemTracking,
		position = 6
	)
	default boolean displayRubies()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_DIAMONDS,
		name = "Display diamonds",
		description = "Display diamond count and percentage in the overlay",
		section = gemTracking,
		position = 7
	)
	default boolean displayDiamonds()
	{
		return true;
	}
	
	@ConfigItem(
		keyName = Constants.DISPLAY_DRAGONSTONES,
		name = "Display dragonstones",
		description = "Display dragonstone count and percentage in the overlay",
		section = gemTracking,
		position = 8
	)
	default boolean displayDragonstones()
	{
		return true;
	}
}

package com.gimserenity;

import java.util.HashMap;

public class GemstoneCrabConfigStore {
    private HashMap<String, Boolean> configStore = new HashMap<>();

    public void load(GemstoneCrabTimerConfig config) {
        configStore = new HashMap<>();
        configStore.put(Constants.SHOW_MAIN_STATS, config.showMainStats());
        configStore.put(Constants.DISPLAY_TOTAL_DAMAGE, config.displayTotalDamage());
        configStore.put(Constants.DISPLAY_DPS, config.displayDps());
        configStore.put(Constants.DISPLAY_XP_GAINED, config.displayXpGained());
        configStore.put(Constants.DISPLAY_DURATION, config.displayDuration());
        configStore.put(Constants.DISPLAY_PLAYER_COUNT, config.displayPlayerCount());
        configStore.put(Constants.DISPLAY_TIME_LEFT, config.displayTimeLeft());
        configStore.put(Constants.SHOW_STAT_TRACKING, config.showOverlay());
        configStore.put(Constants.SHOW_GEM_TRACKING, config.showGemTracking());
        configStore.put(Constants.DISPLAY_KILL_COUNT, config.displayKillCount());
        configStore.put(Constants.DISPLAY_MINING_ATTEMPTS, config.displayMiningAttempts());
        configStore.put(Constants.DISPLAY_MINED_COUNT, config.displayMinedCount());
        configStore.put(Constants.DISPLAY_FAILED_MINING_COUNT, config.displayFailedMiningCount());
        configStore.put(Constants.DISPLAY_GEM_COUNT, config.displayGemCount());
        configStore.put(Constants.DISPLAY_TOP3_COUNT, config.displayTop3Count());
        configStore.put(Constants.DISPLAY_OPALS, config.displayOpals());
        configStore.put(Constants.DISPLAY_JADES, config.displayJades());
        configStore.put(Constants.DISPLAY_RED_TOPAZ, config.displayRedTopaz());
        configStore.put(Constants.DISPLAY_SAPPHIRES, config.displaySapphires());
        configStore.put(Constants.DISPLAY_EMERALDS, config.displayEmeralds());
        configStore.put(Constants.DISPLAY_RUBIES, config.displayRubies());
        configStore.put(Constants.DISPLAY_DIAMONDS, config.displayDiamonds());
        configStore.put(Constants.DISPLAY_DRAGONSTONES, config.displayDragonstones());
    }   

    public void updateValue(String key, String value) {
        if (configStore.containsKey(key)){
            boolean newValue = Boolean.parseBoolean(value);
            configStore.put(key, newValue);
        }
    }

    public boolean getValue(String key) {
        return configStore.get(key);
    }
}

package com.gimserenity;


import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.NPC;
import net.runelite.api.Point;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Shape;

public class GemstoneCrabTimerOverlay extends Overlay
{
    private final GemstoneCrabTimerPlugin plugin;
    private final GemstoneCrabTimerConfig config;
    private final Client client;
    
    @Inject
    public GemstoneCrabTimerOverlay(GemstoneCrabTimerPlugin plugin, GemstoneCrabTimerConfig config, Client client)
    {
        this.plugin = plugin;
        this.config = config;
        this.client = client;
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        boolean renderTunnel = config.highlightTunnel() && plugin.getNearestTunnel() != null && plugin.shouldHighlightTunnel();
        boolean showTimeLeft = config.tunnelTimeLeft() && plugin.getNearestTunnel() != null && plugin.getEstimatedTimeRemainingMillis() > 0;
        boolean renderShell = config.highlightShell() && plugin.getCrabShell() != null && plugin.shouldHighlightShell();
        
        // Render the crab shell if needed
        if (renderShell)
        {
            NPC shell = plugin.getCrabShell();
            if (shell != null)
            {
                // Use green color if top 16 damager, red otherwise
                Color shellColor = plugin.isTop16Damager() ? Color.GREEN : Color.RED;
                
                String shellText = plugin.isTop16Damager() ? "CAN MINE" : "CAN'T MINE";

                Color textColor = plugin.isTop16Damager() ? Color.BLUE : Color.WHITE;
                
                if (shell.getCanvasTextLocation(graphics, shellText, 20) != null)
                {
                    Point textLocation = shell.getCanvasTextLocation(graphics, shellText, 0);
                    if (textLocation != null)
                    {
                        OverlayUtil.renderTextLocation(graphics, textLocation, shellText, textColor);
                    }
                }
                
                Shape objectClickbox = shell.getConvexHull();
                if (objectClickbox != null)
                {
                    graphics.setColor(new Color(shellColor.getRed(), shellColor.getGreen(), shellColor.getBlue(), 50));
                    graphics.fill(objectClickbox);
                    
                    graphics.setColor(shellColor);
                    graphics.setStroke(new BasicStroke(1));
                    graphics.draw(objectClickbox);
                }
            }
        }
        
        GameObject tunnel = plugin.getNearestTunnel();
        if (tunnel != null)
        {
            Color color = config.tunnelHighlightColor();
            if (tunnel.getCanvasTextLocation(graphics, "Tunnel", 0) != null)
            {
                Point textLocation = tunnel.getCanvasTextLocation(graphics, "Tunnel", 0);
                if (textLocation != null)
                {
                    // Only render "Tunnel" text if we should highlight the tunnel
                    if (renderTunnel)
                    {
                        OverlayUtil.renderTextLocation(graphics, textLocation, "Tunnel", color);
                    }
                    
                    // Always show countdown timer overlay above tunnel when in area
                    if (showTimeLeft)
                    {
                        long timeLeftMillis = plugin.getEstimatedTimeRemainingMillis();
                        long secondsLeft = timeLeftMillis / 1000;
                        long minutes = secondsLeft / 60;
                        long seconds = secondsLeft % 60;
                        String countdownText = String.format("%d:%02d", minutes, seconds);
                        Point countdownLocation = new Point(textLocation.getX(), textLocation.getY() - 15);
                        OverlayUtil.renderTextLocation(graphics, countdownLocation, countdownText, Color.WHITE);
                    }
                }
            
            // Only highlight the tunnel if we should
            if (renderTunnel)
            {
                Shape objectClickbox = tunnel.getConvexHull();
                if (objectClickbox != null)
                {
                    // Semi-transparent fill with the configured color
                    graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), 50));
                    graphics.fill(objectClickbox);
                    
                    // Solid yellow outline
                    graphics.setColor(Color.YELLOW);
                    graphics.draw(objectClickbox);
                }
            }
        }
        }

        return null;
    }
}

package com.gimserenity.Helpers;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class GemstoneCrabFunctionTimingHelper {
    public static double renders = 0;
    public static double runningTotal = 0;
    public static double highestRenderTime = 0;
    public static double lowestRenderTime = Double.MAX_VALUE;

    public void addRender(long timing) {
        renders++;
        runningTotal += timing;
        if (timing > highestRenderTime) {
            highestRenderTime = timing;
        }
        if (timing < lowestRenderTime) {
            lowestRenderTime = timing;
        }
        if (renders % 1000 == 0) {
            double averageRender = runningTotal / renders;
            log.info("Average render time: {} over a total of {} renders. Running total {}. Highest render time: {} Lowest render time: {}", averageRender, renders, runningTotal, highestRenderTime, lowestRenderTime);
        }
    }
}

package com.gimserenity;

public class Constants {
    // Configuration Store Keys
    public final static String SHOW_MAIN_STATS = "showMainStats";
    public final static String SHOW_STAT_TRACKING = "showStatTracking";
    public final static String SHOW_GEM_TRACKING = "showGemTracking";
    public final static String DISPLAY_TOTAL_DAMAGE = "displayTotalDamage";
    public final static String DISPLAY_DPS = "displayDps";
    public final static String DISPLAY_XP_GAINED = "displayXpGained";
    public final static String DISPLAY_DURATION = "displayDuration";
    public final static String DISPLAY_PLAYER_COUNT = "displayPlayerCount";
    public final static String DISPLAY_TIME_LEFT = "displayTimeLeft";
    public final static String DISPLAY_KILL_COUNT = "displayKillCount";
    public final static String DISPLAY_MINING_ATTEMPTS = "displayMiningAttempts";
    public final static String DISPLAY_MINED_COUNT = "displayMinedCount";
    public final static String DISPLAY_FAILED_MINING_COUNT = "displayFailedMiningCount";
    public final static String DISPLAY_GEM_COUNT = "displayGemCount";
    public final static String DISPLAY_TOP3_COUNT = "displayTop3Count";
    public final static String CONFIG_KEY_TOP3_COUNT = "top3Count";
    public final static String DISPLAY_OPALS = "displayOpals";
    public final static String DISPLAY_JADES = "displayJades";
    public final static String DISPLAY_RED_TOPAZ = "displayRedTopaz";
    public final static String DISPLAY_SAPPHIRES = "displaySapphires";
    public final static String DISPLAY_EMERALDS = "displayEmeralds";
    public final static String DISPLAY_RUBIES = "displayRubies";
    public final static String DISPLAY_DIAMONDS = "displayDiamonds";
    public final static String DISPLAY_DRAGONSTONES = "displayDragonstones";
}

package com.gimserenity;

import java.awt.Color;

import com.google.inject.Provides;
import javax.inject.Inject;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameObject;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.Skill;
import net.runelite.api.WorldView;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameObjectDespawned;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.NpcDespawned;
import net.runelite.api.events.NpcSpawned;
import net.runelite.api.events.StatChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import java.util.Arrays;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Gemstone Crab",
	description = "All-in-one Gemstone Crab plugin for a better afk and informational experience.",
	tags = {"boss", "hp", "notification", "gemstone", "crab", "afk", "info", "tracker", "dps"}
)
public class GemstoneCrabTimerPlugin extends Plugin
{
	// Gemstone Crab boss NPC ID
	private static final int GEMSTONE_CRAB_ID = 14779;

	// Gemstone Crab shell NPC ID
	private static final int GEMSTONE_CRAB_SHELL_ID = 14780;
	
	// Tunnel game object ID
	private static final int TUNNEL_OBJECT_ID = 57631;
	
	// HP widget ID constants
	private static final int BOSS_HP_BAR_WIDGET_ID = 19857428;
	
	// Maximum distance to highlight tunnel (in tiles)
	private static final int MAX_TUNNEL_DISTANCE = 20;

	// Distance from the crab to considered in the area
	private static final int DISTANCE_THRESHOLD = 13; 

	// Minutes at the boss required to count as a kill
	// Also, used as a cooldown for mining so its not counted multiple times
	private static final long KILL_THRESHOLD_MILLISECONDS = 5*60*1000; // 5 minutes

	// Location of each crab from its center
	private static final WorldPoint EAST_CRAB = new WorldPoint(1353, 3112, 0);
	private static final WorldPoint SOUTH_CRAB = new WorldPoint(1239,3043, 0);
	private static final WorldPoint NORTH_CRAB = new WorldPoint(1273,3173, 0);

	// Crab Chat messages
	private static final String GEMSTONE_CRAB_DEATH_MESSAGE = "The gemstone crab burrows away, leaving a piece of its shell behind.";
	private static final String GEMSTONE_CRAB_MINE_SUCCESS_MESSAGE = "You swing your pick at the crab shell.";
	private static final String GEMSTONE_CRAB_MINE_FAIL_MESSAGE = "Your understanding of the gemstone crab is not great enough to mine its shell.";
	private static final String GEMSTONE_CRAB_GEM_MINE_MESSAGE = "You mine an uncut ";
	private static final String GEMSTONE_CRAB_TOP16_MESSAGE = "You gained enough understanding of the crab to mine from its remains.";
	private static final String GEMSTONE_CRAB_TOP3_MESSAGE = "The top three crab crushers were ";


	// Configuration keys
	private static final String CONFIG_GROUP = "gemstonecrab";
    private static final String CONFIG_KEY_COUNT = "crabCount";
	private static final String CONFIG_KEY_MINING_ATTEMPTS = "miningAttemptsCount";
	private static final String CONFIG_KEY_MINED = "minedCount";
	private static final String CONFIG_KEY_FAILED = "failedMiningCount";
	private static final String CONFIG_KEY_GEMS_MINED = "gemsMined";
	
	// Gem tracking keys
	private static final String CONFIG_KEY_OPALS = "opals";
	private static final String CONFIG_KEY_JADES = "jades";
	private static final String CONFIG_KEY_RED_TOPAZ = "redTopaz";
	private static final String CONFIG_KEY_SAPPHIRES = "sapphires";
	private static final String CONFIG_KEY_EMERALDS = "emeralds";
	private static final String CONFIG_KEY_RUBIES = "rubies";
	private static final String CONFIG_KEY_DIAMONDS = "diamonds";
	private static final String CONFIG_KEY_DRAGONSTONES = "dragonstones";
	
	@Inject
	private Client client;

	@Inject
	private GemstoneCrabTimerConfig config;

	@Inject
	private GemstoneCrabConfigStore configStore;
	
	@Inject
	private Notifier notifier;
	
	@Inject
    private ConfigManager configManager;

	@Inject
	private OverlayManager overlayManager;

	@Inject
    private GemstoneCrabUtil util;
	
	// Track if we've already sent a notification for this boss fight
	private boolean notificationSent = false;
	
	// Track if the boss is present
	private boolean bossPresent = false;

	private double hpPercent;

	// Track if we should highlight the tunnel
	private boolean shouldHighlightTunnel = false;
	
	// Track the nearest tunnel to highlight
	private GameObject nearestTunnel = null;
	
	// Track all tunnels in the scene
	private final Map<WorldPoint, GameObject> tunnels = new HashMap<>();
	
	// Track the crab shell NPC to highlight
	private NPC crabShell = null;
	
	// Track if we should highlight the crab shell
	private boolean shouldHighlightShell = false;
	
	// Track if player is a top 16 damager (for shell color)
	private boolean isTop16Damager = false;
	
	// Track all crab shells in the scene
	private final Map<WorldPoint, NPC> shells = new HashMap<>();
		
	// Smooth time left tracking
	private int lastHpPercent = 100;
	private long lastHpUpdateTime = 0;
	private static final long HP_UPDATE_INTERVAL = 6000; // HP bar updates every 6 seconds
	
	// DPS tracking variables
	private int totalDamage = 0;
	private long fightStartTime = 0;
	private long fightDuration = 0;
	private double currentDps = 0;
	private boolean fightInProgress = false;
	
	// XP tracking for DPS calculation
	private int totalXpGained = 0; // Total XP gained during the fight
	private int pendingCombatXp = 0;
	// Tracks last XP value per skill
	private final Map<Skill, Integer> lastXp = new EnumMap<>(Skill.class);

	// Kill tracking variables
	private int crabCount;
	private long lastMiningAttempt;
	private long lastKillTime;

	// Mining stats tracking variables
	private int minedCount;
	private int miningAttempts;
	private int miningFailedCount;
	private int gemsMined;
	
	// Gem tracking
	private int opals = 0;
	private int jades = 0;
	private int redTopaz = 0;
	private int sapphires = 0;
	private int emeralds = 0;
	private int rubies = 0;
	private int diamonds = 0;
	private int dragonstones = 0;
	private int mineCountShell = 0;
	
	// Track players interacting with the crab
	private int playersInteractingWithCrab = 0;
	
	// Track times player has been in top 3
	private int top3Count = 0;

	// Overlay for highlighting tunnels
	@Inject
	private GemstoneCrabTimerOverlay overlay;
	
	@Inject
	private GemstoneCrabTimerDpsOverlay dpsOverlay;

	@Inject
    private ClientThread clientThread;
	
	@Override
	protected void startUp() throws Exception
	{
		log.info("Gemstone Crab Plugin started!");
		notificationSent = false;
		shouldHighlightTunnel = false;
		shouldHighlightShell = false;
		nearestTunnel = null;
		crabShell = null;
		tunnels.clear();
		shells.clear();
		resetDpsTracking();
		configStore.load(config);
		overlayManager.add(overlay);
		overlayManager.add(dpsOverlay);
	}

	public GemstoneCrabConfigStore getConfigStore() {
		return configStore;
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Gemstone Crab Timer stopped!");
		notificationSent = false;
		bossPresent = false;
		shouldHighlightTunnel = false;
		shouldHighlightShell = false;
		nearestTunnel = null;
		crabShell = null;
		tunnels.clear();
		shells.clear();
		resetDpsTracking();
		overlayManager.remove(overlay);
		overlayManager.remove(dpsOverlay);
	}
	
	// Getter methods for the overlay
	public GameObject getNearestTunnel()
	{
		return nearestTunnel;
	}
	
	public NPC getCrabShell()
	{
		return crabShell;
	}
	
	public boolean shouldHighlightShell()
	{
		return shouldHighlightShell;
	}
	
	public boolean isTop16Damager()
	{
		return isTop16Damager;
	}
	
	public int getPlayersInteractingWithCrab() {
		return playersInteractingWithCrab;
	}
	
	/*
	 * Get the number of times the player has been in the top 3 crab crushers
	 */
	public int getTop3Count() {
		return top3Count;
	}
	
	public boolean shouldHighlightTunnel()
	{
		return shouldHighlightTunnel;
	}
	
	// DPS tracking getter methods
	public int getTotalDamage()
	{
		return totalDamage;
	}
	
	public double getCurrentDps()
	{
		return currentDps;
	}
	
	/**
	 * Get the total XP gained during the current fight
	 * @return Total XP gained
	 */
	public int getTotalXpGained()
	{
		return totalXpGained;
	}
	
	public long getFightDuration()
	{
		if (fightInProgress)
		{
			return (System.currentTimeMillis() - fightStartTime);
		}
		return fightDuration;
	}
	
	public long getEstimatedTimeRemainingMillis()
	{
		if (!bossPresent || !fightInProgress)
		{
			return 0;
		}
		
		// Get the boss NPC
		NPC boss = null;
		WorldView view = client.getWorldView(-1);
		for (NPC npc : view.npcs())
		{
			if (npc != null && npc.getId() == GEMSTONE_CRAB_ID)
			{
				boss = npc;
				break;
			}
		}
		
		if (boss == null)
		{
			return 0;
		}
		
		try
		{
			// Get health ratio and scale from the NPC
			int healthRatio = boss.getHealthRatio();
			int healthScale = boss.getHealthScale();
			
			// If either value is -1, the health info is not available
			if (healthRatio == -1 || healthScale == -1)
			{
				log.debug("Health ratio or scale not available: {} / {}", healthRatio, healthScale);
				return 0;
			}
			
			// Calculate current HP percentage
			int currentHpPercent = (int) (((double) healthRatio / (double) healthScale) * 100);
			currentHpPercent = Math.max(0, Math.min(currentHpPercent, 100));
			
			// Update our tracking variables when HP changes
			if (currentHpPercent != lastHpPercent)
			{
				lastHpPercent = currentHpPercent;
				lastHpUpdateTime = System.currentTimeMillis();
			}
			
			// Calculate interpolated HP percentage based on time since last update
			long timeSinceUpdate = System.currentTimeMillis() - lastHpUpdateTime;
			// HP decreases at a rate of 1% every 6 seconds
			double interpolatedHpPercent = Math.max(0, lastHpPercent - (timeSinceUpdate / (double) HP_UPDATE_INTERVAL));
			
			// Calculate time left based on interpolated HP
			double timeLeftSeconds = (interpolatedHpPercent / 100.0) * 600;
			return (long) (timeLeftSeconds * 1000);
		}
		catch (Exception e)
		{
			log.debug("Failed to calculate time remaining: {}", e.getMessage());
			return 0;
		}
	}
	
	public boolean isFightInProgress() {
		return fightInProgress;
	}

	public int getCrabCount() {
        return crabCount;
    }

	public int getMinedCount() {
        return minedCount;
    }

	public int getMiningAttemptsCount() {
        return miningAttempts;
    }

	public int getMiningFailedCount() {
        return miningFailedCount;
    }

	public int getGemsCount() {
        return gemsMined;
    }
	
	// Gem tracking getter methods
	public int getOpalsCount()
	{
		return opals;
	}
	
	public int getJadesCount()
	{
		return jades;
	}
	
	public int getRedTopazCount()
	{
		return redTopaz;
	}
	
	public int getSapphiresCount()
	{
		return sapphires;
	}
	
	public int getEmeraldsCount()
	{
		return emeralds;
	}
	
	public int getRubiesCount()
	{
		return rubies;
	}
	
	public int getDiamondsCount()
	{
		return diamonds;
	}
	
	public int getDragonstonesCount()
	{
		return dragonstones;
	}
	
	//Reset all DPS tracking variables
	private void resetDpsTracking()
	{
		totalDamage = 0;
		fightStartTime = 0;
		fightDuration = 0; // Reset fight duration
		currentDps = 0;
		fightInProgress = false;
		totalXpGained = 0; // Reset total XP gained
		pendingCombatXp = 0;
		lastXp.clear();
		
		log.debug("DPS tracking reset, fight duration: {}", fightDuration);
	}

	private void resetTunnel()
	{
		if(!tunnels.isEmpty())
		{
			shouldHighlightTunnel = false;
		}
	}
	
	/*
	 * Load any saved configuration values
	 */
	private void loadSavedConfiguration(){
        crabCount = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_COUNT);
		miningAttempts = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_MINING_ATTEMPTS);
		minedCount = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_MINED);
		miningFailedCount = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_FAILED);
		gemsMined = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_GEMS_MINED);
		
		// Load individual gem counts
		opals = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_OPALS);
		jades = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_JADES);
		redTopaz = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_RED_TOPAZ);
		sapphires = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_SAPPHIRES);
		emeralds = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_EMERALDS);
		rubies = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_RUBIES);
		diamonds = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_DIAMONDS);
		dragonstones = util.loadConfigValue(CONFIG_GROUP, CONFIG_KEY_DRAGONSTONES);
		
		// Load top 3 count
		top3Count = util.loadConfigValue(CONFIG_GROUP, Constants.CONFIG_KEY_TOP3_COUNT);
	}

	
	@Subscribe
	public void onStatChanged(StatChanged statChanged)
	{
		if (!bossPresent)
		{
			return;
		}

		Skill skill = statChanged.getSkill();
		int newXp = statChanged.getXp();

		// Get the previous XP value (default to current XP if missing)
		int previousXp = lastXp.getOrDefault(skill, newXp);
		int delta = newXp - previousXp;

		// Update the stored XP value
		lastXp.put(skill, newXp);

		// Ignore non-combat skills entirely
		switch (skill)
		{
			case ATTACK:
			case STRENGTH:
			case DEFENCE:
			case RANGED:
			case MAGIC:
				if (delta > 0)
				{
					pendingCombatXp += delta;
				}
				break;

			case HITPOINTS:
				log.debug("Hitpoints XP gained: {}", delta);
				break;

			default:
				break;
		}
	}
	
	private int estimateDamageFromXp(int xpGained)
	{
		// XP is roughly 3.5x the damage dealt for Gemstone Crabs
		return Math.max(1, Math.round(xpGained / 3.5f));
	}
	
	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		NPC npc = npcSpawned.getNpc();
		
		if (npc.getId() == GEMSTONE_CRAB_ID)
		{
			log.debug("Gemstone Crab boss spawned");
			bossPresent = true;
			notificationSent = false;

				
			resetTunnel();
			// Start a new DPS tracking session
			// This is where we reset stats - when a new boss spawns
			resetDpsTracking();
			isTop16Damager = false;
			fightInProgress = true;
			fightStartTime = System.currentTimeMillis();
			setLastMiningAttempt();
			log.debug("New boss spawned, resetting DPS stats");
		}
		// Track crab shells in the scene
		else if (npc.getId() == GEMSTONE_CRAB_SHELL_ID)
		{
			WorldPoint location = npc.getWorldLocation();
			shells.put(location, npc);
			log.debug("Crab shell NPC spawned at {}", location);

		}
	}
	
	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		NPC npc = npcDespawned.getNpc();
		
		if (npc.getId() == GEMSTONE_CRAB_ID)
		{
			log.debug("Gemstone Crab boss despawned");
			bossPresent = false;
			
			// When the boss dies, highlight the nearest tunnel
			if (config.highlightTunnel())
			{
				findNearestTunnel();
				shouldHighlightTunnel = true;
				log.debug("Boss died, highlighting nearest tunnel");
			}
			
			// Also find and highlight the shell in red by default
			updateCrabShell();
			// Set to true but not top 16 yet (will be red)
			shouldHighlightShell = true;
			
			log.debug("Boss died, highlighting shell in red");
			
		}
		else if (npc.getId() == GEMSTONE_CRAB_SHELL_ID)
		{
			// If the despawned NPC is our tracked shell, clear it
			if (crabShell != null && npc.equals(crabShell))
			{
				crabShell = null;
			}
			// Also remove from our shell map
			shells.remove(npc.getWorldLocation());
			mineCountShell = 0;
		}
	}
	
	@Subscribe
	public void onGameTick(GameTick event)
	{
		// Check if player is in any of the Gemstone Crab areas
		boolean playerInArea = isPlayerInGemstoneArea();
		
		// Always find the nearest tunnel when in the area, even during the fight
		if (playerInArea) {
			findNearestTunnel();
			// Update the crab shell reference
			updateCrabShell();
		}

		if(!playerInArea)
		{
			shouldHighlightShell = false;
		}
		else
		{
			shouldHighlightShell = true;
		}
		
		// If player left the area, reset tracking
		if (!playerInArea && (bossPresent || fightInProgress))
		{
			// Player left the area
			bossPresent = false;
			
			// Reset tunnel highlighting
			shouldHighlightTunnel = false;
			nearestTunnel = null;
			
			// If we were tracking a fight, stop tracking
			if (fightInProgress)
			{
				fightInProgress = false;
				resetDpsTracking();
			}
			
			log.debug("Player left Gemstone Crab area, resetting tracking");
			return;
		}
		
		// If we mined 3 gems, reset top 16 to stop shell highlight
		if (mineCountShell >= 3)
		{	
			isTop16Damager = false;
		}

		// Count players interacting with the crab
		if (playerInArea && bossPresent) {
			countPlayersInteractingWithCrab();
		}
		
		// Check for boss HP bar to detect boss presence when re-entering the area
		if (playerInArea && !bossPresent)
		{
			Widget bossHpBar = client.getWidget(BOSS_HP_BAR_WIDGET_ID);
			if (bossHpBar != null && !bossHpBar.isHidden())
			{
				// Boss is present but we weren't tracking it (player just entered area)
				bossPresent = true;
				
				// Only track if there's an actual NPC (not just HP bar)
				log.debug("Re-entered area with boss HP bar visible");
			}
		}

		// Check boss HP for notification
		if (bossPresent && config.hpThresholdNotification().isEnabled() && !notificationSent)
		{
			checkBossHpAndNotify();
		}

		// --- XP-based damage processing ---
		if (bossPresent && pendingCombatXp > 0)
		{
			// Convert combat XP (summed across skills in onStatChanged) to damage
			int estimatedDamage = estimateDamageFromXp(pendingCombatXp);
			totalXpGained += pendingCombatXp;
			pendingCombatXp = 0;

			long currentTime = System.currentTimeMillis();
			if (!fightInProgress)
			{
				fightInProgress = true;
				fightStartTime = currentTime;
			}

			totalDamage += estimatedDamage;

			long duration = currentTime - fightStartTime;
			if (duration > 0)
			{
				currentDps = totalDamage / (duration / 1000.0);
				// Update fight duration for valid kill tracking
				fightDuration = duration;
			}

			log.debug("XP-based damage this tick: {} (total damage: {}, DPS: {})",
				estimatedDamage, totalDamage, currentDps);
		}
	}



	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGGED_IN)
		{
			// Reset notification state when logging in
			notificationSent = false;
            clientThread.invoke(this::loadSavedConfiguration);
		}
		else if (gameStateChanged.getGameState() == GameState.LOADING)
		{
			// Reset tunnel highlighting when changing areas
			shouldHighlightTunnel = false;
			nearestTunnel = null;
			tunnels.clear();
			shells.clear();
			crabShell = null;
			mineCountShell = 0;
			// Reset DPS tracking when changing areas
			if (fightInProgress)
			{
				log.debug("Area change detected, resetting DPS tracking");
				resetDpsTracking();
			}
		}
	}
	


	/*
	 * Handles Gemstone Crab Mining Events
	 * Mining Attempt, Success, and Failure
	 */
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        // Check for all relevant message types, including colored messages
        if (chatMessage.getType() == ChatMessageType.GAMEMESSAGE || 
			chatMessage.getType() == ChatMessageType.SPAM) {  	
			// Log all message types for debugging
			log.debug("Chat message received: type={}, message={}", chatMessage.getType(), chatMessage.getMessage());
			String message = chatMessage.getMessage();
			
			if (message.equalsIgnoreCase(GEMSTONE_CRAB_MINE_SUCCESS_MESSAGE)) {
				if (!isMiningBeforeCooldown()) {
					log.debug("Gemstone Crab successfully mined!");
					miningAttempts++;
					minedCount++;
					setLastMiningAttempt();
				}
			} else if (message.equalsIgnoreCase(GEMSTONE_CRAB_MINE_FAIL_MESSAGE)) {
				if (!isMiningBeforeCooldown()) {
					log.debug("Failed to mine Gemstone Crab!");
					miningAttempts++;
					miningFailedCount++;
					setLastMiningAttempt();
				}
			} else if (message.equalsIgnoreCase(GEMSTONE_CRAB_DEATH_MESSAGE)) {
				if (!isKillBeforeCooldown()) {
					log.debug("Gemstone Crab death detected, updating kill stats");
					updateKillStats();
					setLastKillTime();
				} else {
					log.debug("Gemstone Crab death detected, but within cooldown period - ignoring");
				}	
			} else if (message.contains(GEMSTONE_CRAB_TOP16_MESSAGE)) {
				log.debug("You are a top 16 damager on the Gemstone Crab!");
				shouldHighlightShell = true;
				isTop16Damager = true;
				updateCrabShell();
				log.debug("Shell highlighting enabled (green) - isTop16Damager: {}, shell: {}", isTop16Damager, crabShell != null ? crabShell.getId() : "null");
			} else if (message.startsWith(GEMSTONE_CRAB_TOP3_MESSAGE)) {				
				if (isTop3Player(message)) {
					top3Count++;
					saveCrabCounts();
				}
			}
			else if (message.contains(GEMSTONE_CRAB_GEM_MINE_MESSAGE)) {
				log.debug("Gem mined");
				gemsMined++;
				mineCountShell++;
				// Track specific gem types
				if (message.contains("opal")) {
					opals++;
					log.debug("Opal mined");
				} else if (message.contains("jade")) {
					jades++;
					log.debug("Jade mined");
				} else if (message.contains("red topaz")) {
					redTopaz++;
					log.debug("Red topaz mined");
				} else if (message.contains("sapphire")) {
					sapphires++;
					log.debug("Sapphire mined");
				} else if (message.contains("emerald")) {
					emeralds++;
					log.debug("Emerald mined");
				} else if (message.contains("ruby")) {
					rubies++;
					log.debug("Ruby mined");
				} else if (message.contains("diamond")) {
					diamonds++;
					log.debug("Diamond mined");
				} else if (message.contains("dragonstone")) {
					dragonstones++;
					log.debug("Dragonstone mined");
				}
			}
			saveCrabCounts();
        }
		// Handle chat commands
		else if (chatMessage.getType() == ChatMessageType.PUBLICCHAT || 
			chatMessage.getType() == ChatMessageType.PRIVATECHAT || 
			chatMessage.getType() == ChatMessageType.FRIENDSCHAT || 
			chatMessage.getType() == ChatMessageType.CLAN_CHAT || 
			chatMessage.getType() == ChatMessageType.CLAN_GUEST_CHAT ||
			chatMessage.getType() == ChatMessageType.CLAN_GIM_CHAT) {
			
			String message = chatMessage.getMessage();
			
			// Check for the reset stats command
			if (message.equalsIgnoreCase("!Resetgemcrab")) {
				log.debug("Reset stats command received");
				resetStats();
			}
		}
	}

	
	/**
	 * Check if the player is within any of the three Gemstone Crab areas
	 * @return true if player is in any of the three areas
	 */
	public boolean isPlayerInGemstoneArea()
	{
		if (client == null || client.getLocalPlayer() == null)
		{
			return false;
		}
		
		// Get player's world location
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		if (playerLocation == null)
		{
			return false;
		}
		
		// Checks if player is close enough to any of the crabs
		return playerLocation.distanceTo2D(EAST_CRAB) <= DISTANCE_THRESHOLD 
			|| playerLocation.distanceTo2D(SOUTH_CRAB) <= DISTANCE_THRESHOLD 
			|| playerLocation.distanceTo2D(NORTH_CRAB) <= DISTANCE_THRESHOLD;
	}
	
	private void checkBossHpAndNotify()
	{
		// Get the boss NPC
		NPC boss = null;
		WorldView view = client.getWorldView(-1);
		for (NPC npc : view.npcs())
		{
			if (npc != null && npc.getId() == GEMSTONE_CRAB_ID)
			{
				boss = npc;
				break;
			}
		}
		
		if (boss == null)
		{
			return;
		}
		
		try
		{
			// Get health ratio and scale from the NPC
			int healthRatio = boss.getHealthRatio();
			int healthScale = boss.getHealthScale();
			
			// If either value is -1, the health info is not available
			if (healthRatio == -1 || healthScale == -1)
			{
				return;
			}
			
			// Calculate current HP percentage (0-100)
			hpPercent = (((double) healthRatio / (double) healthScale) * 100);
			
			// Check if HP is at or below the threshold
			if (hpPercent <= (config.hpThreshold()) && !notificationSent)
			{
				notificationSent = true;
				notifier.notify(config.hpThresholdNotification(), config.notificationMessage() + " (" + config.hpThreshold() + "% HP)");
				log.debug("Sent notification for Gemstone Crab at {}% HP", hpPercent);
			}
		}
		catch (Exception e)
		{
			log.debug("Failed to calculate HP percentage for notification: {}", e.getMessage());
		}
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned event)
	{
		final GameObject gameObject = event.getGameObject();
		
		// Track tunnels in the scene
		if (gameObject.getId() == TUNNEL_OBJECT_ID)
		{
			WorldPoint location = gameObject.getWorldLocation();
			tunnels.put(location, gameObject);
		}
	}
	
	@Subscribe
	public void onGameObjectDespawned(GameObjectDespawned event)
	{
		GameObject gameObject = event.getGameObject();
		
		// If the despawned object is our tracked tunnel, clear it
		if (nearestTunnel != null && gameObject.getId() == TUNNEL_OBJECT_ID && gameObject.equals(nearestTunnel))
		{
			nearestTunnel = null;
		}
	}

	/*
	 * Updates configuration store if value is updated
	 */
	@Subscribe
	public void onConfigChanged​(ConfigChanged event) {
		if (event.getGroup().equalsIgnoreCase(CONFIG_GROUP)) {
			log.debug("event in group. Kay: {}", event.getKey());
			configStore.updateValue(event.getKey(), event.getNewValue());
		}
	}

	// Find the nearest tunnel to the player
	private void findNearestTunnel()
	{
		if (client.getLocalPlayer() == null || tunnels.isEmpty())
		{
			return;
		}
		
		WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
		GameObject closest = null;
		int closestDistance = Integer.MAX_VALUE;
		
		for (GameObject tunnel : tunnels.values())
		{
			int distance = tunnel.getWorldLocation().distanceTo(playerLocation);
			
			// Only consider tunnels within the maximum distance
			if (distance <= MAX_TUNNEL_DISTANCE && distance < closestDistance)
			{
				closest = tunnel;
				closestDistance = distance;
			}
		}
		
		nearestTunnel = closest;
		log.debug("Found nearest tunnel at distance: {}", closestDistance);
	}
	
	// Update the crab shell reference from the shells map
	private void updateCrabShell()
	{
		if (shells.isEmpty())
		{
			crabShell = null;
			return;
		}
		
		// Since there will only ever be one shell NPC around the player,
		// we can just use the first one in the map
		crabShell = shells.values().iterator().next();
		log.debug("Updated crab shell NPC reference: {}", crabShell != null ? crabShell.getWorldLocation() : "null");
	}

	/*
	 * Save all the kill and mining stats
	 */
	private void saveCrabCounts() {
		log.debug("saving crab counts {}", crabCount);
		// Save counts
        configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_COUNT, crabCount);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_MINING_ATTEMPTS, miningAttempts);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_MINED, minedCount);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_FAILED, miningFailedCount);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_GEMS_MINED, gemsMined);
		
		// Save gem tracking
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_OPALS, opals);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_JADES, jades);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_RED_TOPAZ, redTopaz);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_SAPPHIRES, sapphires);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_EMERALDS, emeralds);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_RUBIES, rubies);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_DIAMONDS, diamonds);
		configManager.setRSProfileConfiguration(CONFIG_GROUP, CONFIG_KEY_DRAGONSTONES, dragonstones);
		
		// Save top 3 count
		configManager.setRSProfileConfiguration(CONFIG_GROUP, Constants.CONFIG_KEY_TOP3_COUNT, top3Count);
	}
	
	/*
	 * Reset all mining and gem statistics
	 */
	public void resetStats() {
		// Reset all stats variables
		crabCount = 0;
		miningAttempts = 0;
		minedCount = 0;
		miningFailedCount = 0;
		gemsMined = 0;
		
		// Reset gem tracking variables
		opals = 0;
		jades = 0;
		redTopaz = 0;
		sapphires = 0;
		emeralds = 0;
		rubies = 0;
		diamonds = 0;
		dragonstones = 0;
		
		// Save the reset values to config
		saveCrabCounts();
		
		// Notify the user
		if (client != null) {
			util.sendChatMessage(Color.BLUE, "All Gemstone Crab statistics have been reset.", true);
			log.debug("All Gemstone Crab statistics have been reset");
		}
	}

	/*
	 * Set the last mining attempt time
	 */
	private void setLastMiningAttempt() {
		lastMiningAttempt = System.currentTimeMillis();
	}

	/*
	 * Used to stop mining from counting multiple times
	 */
	private boolean isMiningBeforeCooldown() {
		return isValidKill() && (System.currentTimeMillis() < lastMiningAttempt + KILL_THRESHOLD_MILLISECONDS);
	}

	/*
	 * Used to stop kill stats from updating multiple times
	 */
	private boolean isKillBeforeCooldown() {
		return (System.currentTimeMillis() < lastKillTime + KILL_THRESHOLD_MILLISECONDS);
	}

	/*
	 * Set the last kill time
	 */
	private void setLastKillTime() {
		lastKillTime = System.currentTimeMillis();
	}

	/*
	 * Count players in the area who are interacting with the crab
	 */
	private void countPlayersInteractingWithCrab() {
		// Reset counter
		playersInteractingWithCrab = 0;
		
		// Get all players in the area
		for (net.runelite.api.Player player : client.getWorldView(-1).players()) {
			// Check if the player is interacting with the crab
			net.runelite.api.Actor interacting = player.getInteracting();
			if (interacting instanceof net.runelite.api.NPC) {
				net.runelite.api.NPC npc = (net.runelite.api.NPC) interacting;
				if (npc.getId() == GEMSTONE_CRAB_ID) {
					playersInteractingWithCrab++;
				}
			}
		}
		
		// Debug log
		log.debug("Players interacting with crab: {}", playersInteractingWithCrab);
	}

	/*
	 * Crab was alive at least 5mins and player was attacking it at least once
	 */
	private boolean isValidKill() {
		return fightDuration > KILL_THRESHOLD_MILLISECONDS;
	}

	/*
	 * Update kill stats and send client messages
	 */
	private void updateKillStats() {
		if (isValidKill()) {
			crabCount++;
			saveCrabCounts();
			util.sendChatMessage(Color.RED, String.format("Gemstone Crab Killed! KC: %d", crabCount), config.displayKillMessage());
			log.debug("Gemstone crab killed! KC: {}", crabCount);
		}
		else {
			util.sendChatMessage(Color.MAGENTA, "Gemstone Crab not fought long enough for kill count.", config.displayKillMessage());
			log.debug("Gemstone crab kill did not count!");
		}
		
	}

	public boolean isTop3Player(String message) {
		log.debug("Top 3 crab crushers message detected: {}", message);
		String playerName = client.getLocalPlayer().getName();
		String namesSection = message.substring(GEMSTONE_CRAB_TOP3_MESSAGE.length());
		
		boolean isTop3Player = Arrays.asList(namesSection.split("[,&!]"))
			.stream()
			.map(String::trim)
            .filter(name -> !name.isEmpty())
            .collect(Collectors.toList())
			.contains(playerName);
		
		return isTop3Player;
	}

	@Provides
	GemstoneCrabTimerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(GemstoneCrabTimerConfig.class);
	}
}

package com.gimserenity;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Point;
import java.text.DecimalFormat;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.PanelComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;

public class GemstoneCrabTimerDpsOverlay extends Overlay
{
    private final GemstoneCrabTimerPlugin plugin;
    private final PanelComponent panelComponent = new PanelComponent();
    private static final DecimalFormat DPS_FORMAT = new DecimalFormat("#,##0.0");
    
    // Gem item IDs for icons
    private static final int UNCUT_OPAL_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_OPAL;
    private static final int UNCUT_JADE_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_JADE;
    private static final int UNCUT_RED_TOPAZ_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_RED_TOPAZ;
    private static final int UNCUT_SAPPHIRE_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_SAPPHIRE;
    private static final int UNCUT_EMERALD_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_EMERALD;
    private static final int UNCUT_RUBY_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_RUBY;
    private static final int UNCUT_DIAMOND_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_DIAMOND;
    private static final int UNCUT_DRAGONSTONE_ITEM_ID = net.runelite.api.gameval.ItemID.UNCUT_DRAGONSTONE;
    
    @Inject
    private ItemManager itemManager;

    // Uncomment if you want to use the timing helper for testing render times
    // @Inject
    // private GemstoneCrabFunctionTimingHelper timing;

    private GemstoneCrabConfigStore configStore;
    
    @Inject
    private GemstoneCrabTimerDpsOverlay(GemstoneCrabTimerPlugin plugin)
    {
        this.plugin = plugin;
        this.configStore = plugin.getConfigStore();
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_WIDGETS);
    }
    
    @Override
    public Dimension render(Graphics2D graphics)
    {
        // Used for Testing Render Timing
        // var startTime = System.nanoTime();

        // Don't render if player is not in a Gemstone Crab area
        if (!plugin.isPlayerInGemstoneArea())
        {
            return null;
        }
        
        // Set panel properties for proper sizing
        panelComponent.setPreferredSize(new Dimension(165, 0));
        // Ensure proper spacing between components
        panelComponent.setGap(new Point(0, 4));
        
        // Set up the panel
        panelComponent.getChildren().clear();
        panelComponent.setBackgroundColor(new Color(18, 18, 18, 180)); // Dark background
        
        // Show main stats section if enabled
        if (configStore.getValue(Constants.SHOW_MAIN_STATS))
        {
            // Add title
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Current Fight")
                .color(Color.GREEN)
                .build());
                
            // Add players interacting with crab
            if (configStore.getValue(Constants.DISPLAY_PLAYER_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Players Fighting:")
                    .right(String.valueOf(plugin.getPlayersInteractingWithCrab()))
                    .build());
            }
            
            // Add total damage if enabled
            if (configStore.getValue(Constants.DISPLAY_TOTAL_DAMAGE)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Total Damage:")
                    .right(String.format("%,d", plugin.getTotalDamage()))
                    .build());
            }
            
            // Add DPS if enabled
            if (configStore.getValue(Constants.DISPLAY_DPS)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("DPS:")
                    .right(DPS_FORMAT.format(plugin.getCurrentDps()))
                    .build());
            }
            
            // Add XP gained if enabled
            if (configStore.getValue(Constants.DISPLAY_XP_GAINED)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("XP Gained:")
                    .right(String.format("%,d", plugin.getTotalXpGained()))
                    .build());
            }
            
            // Add fight duration if enabled
            if (configStore.getValue(Constants.DISPLAY_DURATION)) {
                long seconds = plugin.getFightDuration() / 1000;
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Duration:")
                    .right(String.format("%d:%02d", seconds / 60, seconds % 60))
                    .build());
            }
            
            // Add estimated time left if enabled
            if (configStore.getValue(Constants.DISPLAY_TIME_LEFT) && plugin.isFightInProgress()) {
                long timeLeftMillis = plugin.getEstimatedTimeRemainingMillis();
                if (timeLeftMillis > 0) {
                    long secondsLeft = timeLeftMillis / 1000;
                    panelComponent.getChildren().add(LineComponent.builder()
                        .left("Time Left:")
                        .right(String.format("%d:%02d", secondsLeft / 60, secondsLeft % 60))
                        .build());
                }
            }
        }

        if (configStore.getValue(Constants.SHOW_STAT_TRACKING)) {
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Kill Stats")
                .color(Color.GREEN)
                .build());

            if (configStore.getValue(Constants.DISPLAY_KILL_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Crabs Killed:")
                    .right(String.valueOf(plugin.getCrabCount()))
                    .build());
            }

            if (configStore.getValue(Constants.DISPLAY_MINING_ATTEMPTS)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Mining Attempts:")
                    .right(String.valueOf(plugin.getMiningAttemptsCount()))
                    .build());
            }


            if (configStore.getValue(Constants.DISPLAY_MINED_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Successful:")
                    .right(String.valueOf(plugin.getMinedCount()))
                    .build());
            }

            if (configStore.getValue(Constants.DISPLAY_FAILED_MINING_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Failed:")
                    .right(String.valueOf(plugin.getMiningFailedCount()))
                    .build());
            }

            if (configStore.getValue(Constants.DISPLAY_GEM_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Gems Mined:")
                    .right(String.valueOf(plugin.getGemsCount()))
                    .build());
            }
            
            if (configStore.getValue(Constants.DISPLAY_TOP3_COUNT)) {
                panelComponent.getChildren().add(LineComponent.builder()
                    .left("Top 3:")
                    .right(String.valueOf(plugin.getTop3Count()))
                    .build());
            }
        }
        
        // Show gem tracking section if enabled
        if (configStore.getValue(Constants.SHOW_GEM_TRACKING)) {
            
            panelComponent.getChildren().add(TitleComponent.builder()
                .text("Gem Tracking")
                .color(Color.GREEN)
                .build());
            
            // First row panel for first 4 gems
            PanelComponent firstRowPanel = new PanelComponent();
            firstRowPanel.setOrientation(ComponentOrientation.HORIZONTAL);
            // Set width but let height adjust automatically
            firstRowPanel.setPreferredSize(new Dimension(175, 0));
            // Small gap between gems in the row
            firstRowPanel.setGap(new Point(4, 0));
            
            // First row gems (opal, jade, topaz, sapphire)
            if (configStore.getValue(Constants.DISPLAY_OPALS)) {
                firstRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_OPAL_ITEM_ID, plugin.getOpalsCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_JADES)) {
                firstRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_JADE_ITEM_ID, plugin.getJadesCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_RED_TOPAZ)) {
                firstRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_RED_TOPAZ_ITEM_ID, plugin.getRedTopazCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_SAPPHIRES)) {
                firstRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_SAPPHIRE_ITEM_ID, plugin.getSapphiresCount(), true)));
            }
            
            // Only add the first row panel if it has gems to display
            if (!firstRowPanel.getChildren().isEmpty()) {
                panelComponent.getChildren().add(firstRowPanel);
                
                // Add a small spacer before the second row if both rows will be shown
                if (configStore.getValue(Constants.DISPLAY_DIAMONDS) || 
                    configStore.getValue(Constants.DISPLAY_RUBIES) || 
                    configStore.getValue(Constants.DISPLAY_DIAMONDS) || 
                    configStore.getValue(Constants.DISPLAY_DRAGONSTONES)) {
                    panelComponent.getChildren().add(LineComponent.builder().build());
                }
            }
            
            // Second row 
            PanelComponent secondRowPanel = new PanelComponent();
            secondRowPanel.setOrientation(ComponentOrientation.HORIZONTAL);
            // Set width but let height adjust automatically
            secondRowPanel.setPreferredSize(new Dimension(175, 0));
            // Small gap between gems in the row
            secondRowPanel.setGap(new Point(4, 0));
            
            // Second row gems (emerald, ruby, diamond, dragonstone) - always show all gems
            if (configStore.getValue(Constants.DISPLAY_EMERALDS)) {
                secondRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_EMERALD_ITEM_ID, plugin.getEmeraldsCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_RUBIES) ) {
                secondRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_RUBY_ITEM_ID, plugin.getRubiesCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_DIAMONDS)) {
                secondRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_DIAMOND_ITEM_ID, plugin.getDiamondsCount(), true)));
            }
            
            if (configStore.getValue(Constants.DISPLAY_DRAGONSTONES)) {
                secondRowPanel.getChildren().add(new ImageComponent(
                    itemManager.getImage(UNCUT_DRAGONSTONE_ITEM_ID, plugin.getDragonstonesCount(), true)));
            }
            
            // Only add the second row if it has gems to display
            if (!secondRowPanel.getChildren().isEmpty()) {
                panelComponent.getChildren().add(secondRowPanel);
            }
            
            // Padding
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                .left(" ")
                .build());
            
            // Keep main panel in vertical orientation for the rest of the overlay
            panelComponent.setOrientation(ComponentOrientation.VERTICAL);
        }

        // Used for Testing Render Timing
        // var endTime = System.nanoTime();
        // long totalTimeNanos = endTime - startTime;
        // timing.addRender(totalTimeNanos);
        return panelComponent.render(graphics);
    }
}

package com.gimserenity.launcher;

import com.gimserenity.GemstoneCrabTimerPlugin;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class GemstoneCrabPluginDebug
{

	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(GemstoneCrabTimerPlugin.class);
		RuneLite.main(args);
	}
}

package com.gimserenity;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.awt.Color;

import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
public class GemstoneCrabUtilTest
{
	@Mock
	Client mockClient;

	@Mock
	ConfigManager configManager;

	@InjectMocks
	GemstoneCrabUtil util;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

	@Test
	public void testSendChatMessge()
	{
		var testMessage = "Test message";
		var expectedMessage = "[Gemstone Crab] Test message";

		util.sendChatMessage(Color.GREEN, testMessage, true);

		verify(mockClient).addChatMessage(eq(ChatMessageType.GAMEMESSAGE), anyString(), contains(expectedMessage), anyString());
	}

	@Test
	public void testDoesNotSendChatMessage()
	{
		util.sendChatMessage(null, "", false);

		verify(mockClient, times(0)).addChatMessage(ChatMessageType.GAMEMESSAGE, "", "", "");
	}
}

package com.gimserenity;

import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.mockito.junit.jupiter.MockitoExtension;

import net.runelite.api.Client;
import net.runelite.api.Player;
import net.runelite.client.config.ConfigManager;

@ExtendWith(MockitoExtension.class)
public class GemstoneCrabPluginTest {

    @Mock
	Client mockClient;

	@Mock
	ConfigManager configManager;

	@InjectMocks
	GemstoneCrabTimerPlugin plugin;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testPlayerInTop3PlayerNamesSuccess() {
        var mockPlayer = mock(Player.class);
        when(mockPlayer.getName()).thenReturn("Pi no");
        when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);

        boolean result = plugin.isTop3Player("The top three crab crushers were Pi no, Mod Ash, & GIM Serenity!");

        assertTrue(result);

        result = plugin.isTop3Player("The top three crab crushers were GIM Serenity, Pi no, & Mod Ash!");

        assertTrue(result);

        result = plugin.isTop3Player("The top three crab crushers were Mod Ash, GIM Serenity, & Pi no!");
        
        assertTrue(result);
    }

    @Test
    public void testPlayerInTop3PlayerNamesFailsWhenNameIsSimilar() {
        var mockPlayer = mock(Player.class);
        when(mockPlayer.getName()).thenReturn("Pino");
        when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);

        boolean result = plugin.isTop3Player("The top three crab crushers were PinoIron, GIM Serenity, & Mod Ash!");

        assertFalse(result);
    }

    @Test
    public void testPlayerInTop3PlayerNamesFailsWhenNameIsNotIncluded() {
        var mockPlayer = mock(Player.class);
        when(mockPlayer.getName()).thenReturn("GIM Serenity");
        when(mockClient.getLocalPlayer()).thenReturn(mockPlayer);

        boolean result = plugin.isTop3Player("The top three crab crushers were Pi no, PinoIron, & Serenity!");

        assertFalse(result);
    }
}

