package com.coxanalytics;

import com.coxanalytics.config.CustomOverlayInfo;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.ui.overlay.components.ComponentConstants;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;

import javax.inject.Inject;
import java.awt.*;
import java.text.DecimalFormat;

public class CoxAnalyticsOverlay extends OverlayPanel
{
	private static final DecimalFormat POINTS_FORMAT = new DecimalFormat("#,###");

	private final Client client;
	private final CoxAnalyticsPlugin plugin;
	private final CoxAnalyticsConfig config;
	private final TooltipManager tooltipManager;

	@Inject
	private CoxAnalyticsOverlay(Client client, CoxAnalyticsPlugin plugin, CoxAnalyticsConfig config, TooltipManager tooltipManager)
	{
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.tooltipManager = tooltipManager;
		setPosition(OverlayPosition.TOP_LEFT);
		setPriority(OverlayPriority.HIGH);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (plugin.isInCox() && config.replaceWidget())
		{
			int totalPoints = client.getVarbitValue(Varbits.TOTAL_POINTS);
			int personalPoints = client.getVarpValue(VarPlayer.RAIDS_PERSONAL_POINTS);

			switch (config.fontType())
			{
				case SMALL:
					graphics.setFont(FontManager.getRunescapeSmallFont());
					break;
				case REGULAR:
					graphics.setFont(FontManager.getRunescapeFont());
					break;
				case BOLD:
					graphics.setFont(FontManager.getRunescapeBoldFont());
					break;
				case CUSTOM:
					if (!config.fontName().equals(""))
					{
						graphics.setFont(new Font(config.fontName(), config.fontWeight().getWeight(), config.fontSize()));
					}
					break;
			}

			if (!config.overlayInfo().isEmpty())
			{
				if (config.overlayInfo().contains(CustomOverlayInfo.TOTAL))
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left("Total:")
						.right(POINTS_FORMAT.format(totalPoints))
						.build());
				}

				if (config.overlayInfo().contains(CustomOverlayInfo.PERSONAL))
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left(client.getLocalPlayer().getName() + ":")
						.right(POINTS_FORMAT.format(personalPoints))
						.build());
				}

				if (config.overlayInfo().contains(CustomOverlayInfo.ELAPSED))
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left("Time:")
						.rightColor(!plugin.getOlmTime().equals("") ? Color.GREEN : Color.WHITE)
						.right(plugin.raidTime(plugin.coxTimeVar()))
						.build());
				}

				if (config.overlayInfo().contains(CustomOverlayInfo.FLOOR))
				{
					if (plugin.getUpperTicks() != -1)
					{
						panelComponent.getChildren().add(LineComponent.builder()
							.left("Floor 1: ")
							.right(plugin.getUpperFloorTime())
							.build());
					}

					if (plugin.getMiddleTicks() != -1)
					{
						panelComponent.getChildren().add(LineComponent.builder()
							.left("Floor 2: ")
							.right(plugin.getMiddleFloorTime())
							.build());
					}

					if (plugin.getLowerTicks() != -1)
					{
						if (plugin.getMiddleTicks() != -1)
						{
							panelComponent.getChildren().add(LineComponent.builder()
								.left("Floor 3: ")
								.right(plugin.getLowerFloorTime())
								.build());
						}
						else
						{
							panelComponent.getChildren().add(LineComponent.builder()
								.left("Floor 2: ")
								.right(plugin.getLowerFloorTime())
								.build());
						}
					}

					if (!plugin.getOlmTime().equals(""))
					{
						panelComponent.getChildren().add(LineComponent.builder()
							.left("Olm: ")
							.right(plugin.getOlmTime())
							.build());
					}
				}

				if (config.overlayInfo().contains(CustomOverlayInfo.CURRENT) && plugin.getOlmTime().equals(""))
				{
					panelComponent.getChildren().add(LineComponent.builder()
						.left("Current Split:")
						.rightColor(Color.WHITE)
						.right(plugin.raidTime(plugin.coxTimeVar() - plugin.getSplitTicks()))
						.build());
				}
			}

			final Rectangle bounds = getBounds();
			if (bounds.getX() > 0)
			{
				final Point mousePosition = client.getMouseCanvasPosition();

				if (bounds.contains(mousePosition.getX(), mousePosition.getY()))
				{
					//Does not add the tooltip if upper floor has not been completed
					if (config.splitsTooltip() && plugin.getUpperTicks() != -1)
					{
						tooltipManager.add(new Tooltip(plugin.getFloorTimes()));
					}
				}
			}
		}

		switch (config.backgroundStyle())
		{
			case HIDE:
				panelComponent.setBackgroundColor(null);
				break;
			case STANDARD:
				panelComponent.setBackgroundColor(ComponentConstants.STANDARD_BACKGROUND_COLOR);
				break;
			case CUSTOM:
				panelComponent.setBackgroundColor(config.backgroundColor());
				break;
		}
		return super.render(graphics);
	}
}
/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxanalytics;

import com.coxanalytics.config.BackgroundMode;
import com.coxanalytics.config.FontType;
import com.coxanalytics.config.FontWeight;
import com.coxanalytics.config.CustomOverlayInfo;
import com.coxanalytics.config.TimeStyle;
import java.awt.Color;
import java.util.Collections;
import java.util.Set;
import net.runelite.client.config.Alpha;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("CoxAnalytics")
public interface CoxAnalyticsConfig extends Config
{
	@ConfigSection(
		name = "Timer",
		description = "Timer Options",
		position = 0
	)
	String timerSection = "timer";

	@ConfigSection(
		name = "Overlay",
		description = "Overlay Options",
		position = 1
	)
	String overlaySection = "overlay";

	@ConfigSection(
		name = "Points Panel",
		description = "Panel Options",
		position = 2
	)
	String panelSection = "panel";

	//Timer Section
	@ConfigItem(
		keyName = "replaceWidget",
		name = "Replace Widget",
		description = "Replaces the CoX point widget with a custom overlay",
		position = 0,
		section = timerSection
	)
	default boolean replaceWidget()
	{
		return true;
	}

	@ConfigItem(
		keyName = "timerStyle",
		name = "Timer Style",
		description = "Changes how the time is displayed",
		position = 1,
		section = timerSection
	)
	default TimeStyle timerStyle()
	{
		return TimeStyle.VARBIT;
	}

	@ConfigItem(
		keyName = "overlayInfo",
		name = "Display Options",
		description = "Options that can be displayed in the custom overlay",
		position = 2,
		section = timerSection
	)
	default Set<CustomOverlayInfo> overlayInfo()
	{
		return Collections.emptySet();
	}

	@ConfigItem(
		keyName = "splitsTooltip",
		name = "Splits Tooltip",
		description = "Displays the floor splits when hovering the overlay or widget",
		position = 3,
		section = timerSection
	)
	default boolean splitsTooltip()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showOlmMageHand",
		name = "Olm Mage Hand Message",
		description = "Prints a chat message displaying how long the mage hand took to kill <br> De0's CoX Timers must be installed and enabled",
		position = 4,
		section = timerSection
	)
	default boolean showOlmMageHand()
	{
		return true;
	}

	@ConfigItem(
		keyName = "ptsHr",
		name = "Points Per Hour Message",
		description = "Displays a pts/hr chat message after the raid has ended",
		position = 5,
		section = timerSection
	)
	default boolean ptsHr()
	{
		return true;
	}

	@ConfigItem(
		keyName = "exportTimes",
		name = "Export Times",
		description = "Exports times to a file in the 'cox-analytics' folder in .runelite",
		position = 6,
		section = timerSection
	)
	default boolean exportTimes()
	{
		return true;
	}

	//Font Section
	@ConfigItem(
		name = "Font Type",
		keyName = "fontType",
		description = "",
		position = 0,
		section = overlaySection
	)
	default FontType fontType()
	{
		return FontType.REGULAR;
	}

	@ConfigItem(
		name = "Custom Font Name",
		keyName = "fontName",
		description = "Custom font override",
		position = 1,
		section = overlaySection
	)
	default String fontName()
	{
		return "";
	}

	@ConfigItem(
		name = "Custom Font Size",
		keyName = "fontsSize",
		description = "",
		position = 2,
		section = overlaySection
	)
	default int fontSize()
	{
		return 11;
	}

	@ConfigItem(
		name = "Custom Weight",
		keyName = "fontWeight",
		description = "Sets the custom font weight",
		position = 3,
		section = overlaySection
	)
	default FontWeight fontWeight()
	{
		return FontWeight.PLAIN;
	}

	@ConfigItem(
		name = "Background Style",
		keyName = "backgroundStyle",
		description = "Sets the background to the style you select",
		position = 4,
		section = overlaySection
	)
	default BackgroundMode backgroundStyle()
	{
		return BackgroundMode.STANDARD;
	}

	@Alpha
	@ConfigItem(
		name = "Background Color",
		keyName = "backgroundColor",
		description = "Sets the overlay color on the custom setting",
		position = 5,
		section = overlaySection
	)
	default Color backgroundColor()
	{
		return new Color(23, 23, 23, 156);
	}

	//Points Panel Section
	@ConfigItem(
		name = "Enable Points Panel",
		keyName = "ptsPanel",
		description = "Enable the panel",
		position = 1,
		section = panelSection
	)
	default boolean ptsPanel()
	{
		return true;
	}

	@ConfigItem(
		name = "Panel Priority",
		keyName = "panelPriority",
		description = "Determines where the points panel is on the side",
		position = 2,
		section = panelSection
	)
	default int panelPriority()
	{
		return 9;
	}
}

package com.coxanalytics;

public class CoxAnalyticsVarbits
{
	public static final int RAID_PARTY_SIZE = 5424;
}

package com.coxanalytics.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public enum CustomOverlayInfo
{
	TOTAL("Total Points"),
	PERSONAL("Personal Points"),
	ELAPSED("Elapsed Time"),
	FLOOR("Floor Splits"),
	CURRENT("Current Split");

	@Getter
	private final String info;

	@Override
	public String toString()
	{
		return info;
	}
}

package com.coxanalytics.config;

import lombok.Getter;

public enum FontWeight
{
	PLAIN(0),
	BOLD(1),
	ITALIC(2);

	@Getter
	private final int weight;

	FontWeight(int i)
	{
		weight = i;
	}
}

package com.coxanalytics.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum FontType
{
	SMALL("RS Small"),
	REGULAR("RS Regular"),
	BOLD("RS Bold"),
	CUSTOM("Custom");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

package com.coxanalytics.config;

public enum TimeStyle
{
	SECONDS("Seconds"),
	TICKS("Precise"),
	VARBIT("In Game Setting");

	private final String name;

	public String toString()
	{
		return name;
	}

	TimeStyle(String name)
	{
		this.name = name;
	}
}

package com.coxanalytics.config;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum BackgroundMode
{
	STANDARD("Default"),
	CUSTOM("Custom"),
	HIDE("None");

	private final String name;

	@Override
	public String toString()
	{
		return name;
	}
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxanalytics;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.GridLayout;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.StringSelection;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.text.DecimalFormat;
import javax.inject.Inject;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTabbedPane;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import net.runelite.client.util.SwingUtil;
import net.runelite.client.util.Text;

@Slf4j
public class CoxPointsPanel extends PluginPanel
{
	private final CoxAnalyticsPlugin plugin;

	private static final DecimalFormat POINTS_FORMAT = new DecimalFormat("#,###");

	private final JPanel panelContainer = new JPanel();
	private final JPanel titleContainer = new JPanel();

	//Points
	private final JPanel pointsContainer = new JPanel();
	private final JLabel pointsPanelTitleLabel = new JLabel("CoX Points");

	private final JLabel teamPointsLabel = new JLabel("Team Points: 0");
	private final JLabel teamVirtualPointsHourLabel = new JLabel("Virtual Per Hour: 0");
	private final JLabel teamPointsHourLabel = new JLabel("Per Hour: 0");
	private final JLabel avgTeamPointsLabel = new JLabel("Avg. Points: 0");

	private final JLabel soloPointsLabel = new JLabel("Personal Points: 0");
	private final JLabel soloVirtualPointsHourLabel = new JLabel("Virtual Per Hour: 0");
	private final JLabel soloPointsHourLabel = new JLabel("Per Hour: 0");
	private final JLabel avgSoloPointsLabel = new JLabel("Avg. Points: 0");

	private final JLabel raidsCompletedLabel = new JLabel("Total: 0");
	private final JLabel avgTimeLabel = new JLabel("Avg. Time: 00:00.0");
	private final JLabel fastestTimeLabel = new JLabel("Fastest Time: 00:00.0");
	private final JLabel lastTimeLabel = new JLabel("Last Time: 00:00.0");
	private final JLabel timeDifLabel = new JLabel("Difference: ");

	//Splits
	private final JPanel splitsContainer = new JPanel();
	private final JLabel splitsPanelTitleLabel = new JLabel("CoX Splits");
	private final JLabel splitsLabel = new JLabel("");

	private final JLabel blankline = new JLabel("<html><br></html>");
	private final JLabel blankline1 = new JLabel("<html><br></html>");

	//Panel buttons
	private final JButton pointsResetButton = new JButton(RESET);
	private final JButton splitsResetButton = new JButton(RESET);
	private static final ImageIcon RESET;
	private static final ImageIcon RESET_HOVER;

	private final JButton pointsClipboardButton = new JButton(CLIPBOARD);
	private final JButton splitsClipboardButton = new JButton(CLIPBOARD);
	private static final ImageIcon CLIPBOARD;
	private static final ImageIcon CLIPBOARD_HOVER;

	//Support
	private final JPanel supportButtons = new JPanel();

	private final JButton discordButton = new JButton(DISCORD);
	private static final ImageIcon DISCORD;
	private static final ImageIcon DISCORD_HOVER;

	private final JButton githubButton = new JButton(GITHUB);
	private static final ImageIcon GITHUB;
	private static final ImageIcon GITHUB_HOVER;

	private final JButton folderButton = new JButton(FOLDER);
	private static final ImageIcon FOLDER;
	private static final ImageIcon FOLDER_HOVER;

	private final Color color = new Color(37, 197, 79);

	private static final String HTML_LABEL_TEMPLATE = "<html><body style='color:%s'><span style='color:white'>%s</span></body></html>";
	private static final String DIFFERENCE_TEMPLATE = "<html><body style=>Difference: <span style=%s>%s</span></body></html>";

	static
	{
		BufferedImage resetImg = ImageUtil.loadImageResource(CoxAnalyticsPlugin.class, "reset_icon.png");
		RESET = new ImageIcon(resetImg);
		RESET_HOVER = new ImageIcon(ImageUtil.luminanceOffset(resetImg, -80));

		BufferedImage clipboardImg = ImageUtil.loadImageResource(CoxAnalyticsPlugin.class, "clipboard.png");
		CLIPBOARD = new ImageIcon(clipboardImg);
		CLIPBOARD_HOVER = new ImageIcon(ImageUtil.luminanceOffset(clipboardImg, -80));

		BufferedImage discordImg = ImageUtil.loadImageResource(CoxAnalyticsPlugin.class, "discord_icon.png");
		DISCORD = new ImageIcon(discordImg);
		DISCORD_HOVER = new ImageIcon(ImageUtil.luminanceOffset(discordImg, -80));

		BufferedImage githubImg = ImageUtil.loadImageResource(CoxAnalyticsPlugin.class, "github_icon.png");
		GITHUB = new ImageIcon(githubImg);
		GITHUB_HOVER = new ImageIcon(ImageUtil.luminanceOffset(githubImg, -80));

		BufferedImage folderImg = ImageUtil.loadImageResource(CoxAnalyticsPlugin.class, "folder.png");
		FOLDER = new ImageIcon(folderImg);
		FOLDER_HOVER = new ImageIcon(ImageUtil.luminanceOffset(folderImg, -80));
	}

	@Inject
	CoxPointsPanel(CoxAnalyticsPlugin plugin)
	{
		this.plugin = plugin;
	}

	void init()
	{
		setLayout(new BorderLayout());
		setBorder(new EmptyBorder(10, 10, 10, 10));
		GridBagConstraints constraints = new GridBagConstraints();
		constraints.fill = GridBagConstraints.HORIZONTAL;
		constraints.weightx = 1;
		constraints.gridx = 0;
		constraints.gridy = 0;
		panelContainer.setLayout(new BoxLayout(panelContainer, BoxLayout.Y_AXIS));
		panelContainer.add(buildTitleContainer());
		panelContainer.add(buildSupportContainer());
		add(panelContainer, BorderLayout.NORTH);
		add(tabbedPane(), BorderLayout.CENTER);
	}

	//Add title and banner
	private JPanel buildTitleContainer()
	{
		titleContainer.setBorder(new CompoundBorder(new EmptyBorder(5, 0, 8, 0), new MatteBorder(0, 0, 1, 0, color)));
		titleContainer.setLayout(new BorderLayout());
		BufferedImage image = ImageUtil.loadImageResource(getClass(), "banner.png");
		ImageIcon i = new ImageIcon(image);
		JLabel overallIcon = new JLabel(i);
		titleContainer.add(overallIcon, BorderLayout.NORTH);
		return titleContainer;
	}

	//Add panel tabs
	private JTabbedPane tabbedPane()
	{
		JTabbedPane tabPanel = new JTabbedPane();

		JScrollPane pointPanel = wrapContainer(buildPointsPanel());
		JScrollPane splitPanel = wrapContainer(buildSplitsPanel());

		tabPanel.add("Points", pointPanel);
		tabPanel.add("Splits", splitPanel);

		return tabPanel;
	}

	static JScrollPane wrapContainer(final JPanel container)
	{
		final JPanel wrapped = new JPanel(new BorderLayout());
		wrapped.add(container, BorderLayout.NORTH);

		final JScrollPane scroller = new JScrollPane(wrapped);
		scroller.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		scroller.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));

		return scroller;
	}

	//Points Container
	private JPanel buildPointsPanel()
	{
		//Title
		JPanel pointsInfoTitlePanel = new JPanel();
		pointsInfoTitlePanel.setLayout(new BorderLayout());
		pointsInfoTitlePanel.setBorder(new CompoundBorder(new EmptyBorder(4, 0, 4, 0), new MatteBorder(0, 0, 1, 0, Color.GRAY)));
		pointsInfoTitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel pointsInfoFirst = new JPanel();
		pointsInfoFirst.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		pointsPanelTitleLabel.setFont(FontManager.getRunescapeBoldFont());
		pointsPanelTitleLabel.setForeground(color);
		JPanel pointsInfoSecond = new JPanel(new GridLayout(1, 2, 10, 0));
		pointsInfoSecond.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		pointsClipboardButton.setRolloverIcon(CLIPBOARD_HOVER);
		SwingUtil.removeButtonDecorations(pointsClipboardButton);
		pointsClipboardButton.setPreferredSize(new Dimension(16, 14));
		pointsClipboardButton.setToolTipText("Copy to Clipboard");
		pointsClipboardButton.addActionListener(e -> {
			StringSelection selection = new StringSelection(copyPointsToClipboard());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(selection, selection);
		});

		pointsResetButton.setRolloverIcon(RESET_HOVER);
		SwingUtil.removeButtonDecorations(pointsResetButton);
		pointsResetButton.setPreferredSize(new Dimension(16, 14));
		pointsResetButton.setToolTipText("Reset");
		pointsResetButton.addActionListener(e -> plugin.resetPointsPanel());
		pointsInfoFirst.add(pointsPanelTitleLabel);
		pointsInfoSecond.add(pointsClipboardButton);
		pointsInfoSecond.add(pointsResetButton);
		pointsInfoTitlePanel.add(pointsInfoFirst, BorderLayout.WEST);
		pointsInfoTitlePanel.add(pointsInfoSecond, BorderLayout.EAST);

		//Content
		pointsContainer.setLayout(new BorderLayout());
		pointsContainer.setBorder(new EmptyBorder(4, 10, 4, 10));
		pointsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		JPanel pointsInfobox = new JPanel(new GridBagLayout());
		pointsInfobox.setLayout(new GridLayout(15, 1, 0, 10));
		pointsInfobox.setBorder(new EmptyBorder(4, 0, 4, 0));
		pointsInfobox.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		teamPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		teamVirtualPointsHourLabel.setFont(FontManager.getRunescapeSmallFont());
		teamPointsHourLabel.setFont(FontManager.getRunescapeSmallFont());
		avgTeamPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		blankline.setFont(FontManager.getRunescapeSmallFont());

		soloPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		soloVirtualPointsHourLabel.setFont(FontManager.getRunescapeSmallFont());
		soloPointsHourLabel.setFont(FontManager.getRunescapeSmallFont());
		avgSoloPointsLabel.setFont(FontManager.getRunescapeSmallFont());
		blankline1.setFont(FontManager.getRunescapeSmallFont());

		raidsCompletedLabel.setFont(FontManager.getRunescapeSmallFont());
		avgTimeLabel.setFont(FontManager.getRunescapeSmallFont());
		fastestTimeLabel.setFont(FontManager.getRunescapeSmallFont());
		lastTimeLabel.setFont(FontManager.getRunescapeSmallFont());
		timeDifLabel.setFont(FontManager.getRunescapeSmallFont());

		pointsInfobox.add(teamPointsLabel);
		pointsInfobox.add(teamVirtualPointsHourLabel);
		pointsInfobox.add(teamPointsHourLabel);
		pointsInfobox.add(avgTeamPointsLabel);
		pointsInfobox.add(blankline);

		pointsInfobox.add(soloPointsLabel);
		pointsInfobox.add(soloVirtualPointsHourLabel);
		pointsInfobox.add(soloPointsHourLabel);
		pointsInfobox.add(avgSoloPointsLabel);
		pointsInfobox.add(blankline1);

		pointsInfobox.add(raidsCompletedLabel);
		pointsInfobox.add(avgTimeLabel);
		pointsInfobox.add(fastestTimeLabel);
		pointsInfobox.add(lastTimeLabel);
		pointsInfobox.add(timeDifLabel);

		pointsContainer.add(pointsInfoTitlePanel, BorderLayout.NORTH);
		pointsContainer.add(pointsInfobox, BorderLayout.WEST);

		return pointsContainer;
	}

	//Splits Container
	private JPanel buildSplitsPanel()
	{
		//Title
		JPanel splitsInfoTitlePanel = new JPanel();
		splitsInfoTitlePanel.setLayout(new BorderLayout());
		splitsInfoTitlePanel.setBorder(new CompoundBorder(new EmptyBorder(4, 0, 4, 0), new MatteBorder(0, 0, 1, 0, Color.GRAY)));
		splitsInfoTitlePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel splitsInfoFirst = new JPanel();
		splitsInfoFirst.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		splitsPanelTitleLabel.setFont(FontManager.getRunescapeBoldFont());
		splitsPanelTitleLabel.setForeground(color);

		JPanel splitsInfoSecond = new JPanel(new GridLayout(1, 2, 10, 0));
		splitsInfoSecond.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		splitsClipboardButton.setRolloverIcon(CLIPBOARD_HOVER);
		SwingUtil.removeButtonDecorations(splitsClipboardButton);
		splitsClipboardButton.setPreferredSize(new Dimension(16, 14));
		splitsClipboardButton.setToolTipText("Copy to Clipboard");
		splitsClipboardButton.addActionListener(e -> {
			StringSelection selection = new StringSelection(copySplitsToClipboard());
			Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
			clipboard.setContents(selection, selection);
		});

		splitsResetButton.setRolloverIcon(RESET_HOVER);
		SwingUtil.removeButtonDecorations(splitsResetButton);
		splitsResetButton.setPreferredSize(new Dimension(16, 14));
		splitsResetButton.setToolTipText("Reset");
		splitsResetButton.addActionListener(e -> plugin.resetSplitsPanel());

		splitsInfoFirst.add(splitsPanelTitleLabel);
		splitsInfoSecond.add(splitsClipboardButton);
		splitsInfoSecond.add(splitsResetButton);

		splitsInfoTitlePanel.add(splitsInfoFirst, BorderLayout.WEST);
		splitsInfoTitlePanel.add(splitsInfoSecond, BorderLayout.EAST);

		//Content
		splitsContainer.setLayout(new BorderLayout());
		splitsContainer.setBorder(new EmptyBorder(4, 10, 4, 10));
		splitsContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel splitsInfobox = new JPanel(new GridBagLayout());
		splitsInfobox.setLayout(new GridLayout(1, 1, 0, 10));
		splitsInfobox.setBorder(new EmptyBorder(4, 0, 4, 0));
		splitsInfobox.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		splitsLabel.setFont(FontManager.getRunescapeSmallFont());

		splitsInfobox.add(splitsLabel);

		splitsContainer.add(splitsInfoTitlePanel, BorderLayout.NORTH);
		splitsContainer.add(splitsInfobox, BorderLayout.WEST);

		return splitsContainer;
	}

	//Support
	private JPanel buildSupportContainer()
	{
		supportButtons.setLayout(new BorderLayout());
		supportButtons.setBorder(new EmptyBorder(4, 5, 0, 10));
		JPanel supportInfobox = new JPanel(new GridBagLayout());
		supportInfobox.setLayout(new GridLayout(1, 2, 3, 0));
		supportInfobox.setBorder(new EmptyBorder(5, 5, 5, 5));
		supportInfobox.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		folderButton.setRolloverIcon(FOLDER_HOVER);
		folderButton.setToolTipText("Open Times Folder");
		folderButton.setPreferredSize(new Dimension(24, 24));

		discordButton.setRolloverIcon(DISCORD_HOVER);
		discordButton.setToolTipText("Discord");
		discordButton.setPreferredSize(new Dimension(23, 25));

		githubButton.setRolloverIcon(GITHUB_HOVER);
		githubButton.setToolTipText("Github");
		githubButton.setPreferredSize(new Dimension(20, 23));

		SwingUtil.removeButtonDecorations(folderButton);
		SwingUtil.removeButtonDecorations(githubButton);
		SwingUtil.removeButtonDecorations(discordButton);

		folderButton.addActionListener(e -> {
			try
			{
				Desktop.getDesktop().open(CoxAnalyticsPlugin.getTIMES_DIR());
			}
			catch (IOException ex)
			{
				ex.printStackTrace();
			}
		});
		githubButton.addActionListener(e -> LinkBrowser.browse("https://github.com/MoreBuchus/buchus-plugins"));
		discordButton.addActionListener(e -> LinkBrowser.browse("https://discord.gg/mfw63tG9js"));

		supportInfobox.add(folderButton);
		supportInfobox.add(githubButton);
		supportInfobox.add(discordButton);

		supportButtons.add(supportInfobox, BorderLayout.CENTER);

		return supportButtons;
	}

	private String copyPointsToClipboard()
	{
		String timeDifString = Text.removeTags(timeDifLabel.getText());
		return teamPointsLabel.getText() + "\r\n" + teamVirtualPointsHourLabel.getText() + "\r\n" + teamPointsHourLabel.getText() + "\r\n" +
			avgTeamPointsLabel.getText() + "\r\n" + soloPointsLabel.getText() + "\r\n" + soloVirtualPointsHourLabel.getText() + "\r\n" +
			soloPointsHourLabel.getText() + "\r\n" + avgSoloPointsLabel.getText() + "\r\n" + raidsCompletedLabel.getText() + "\r\n" +
			avgTimeLabel.getText() + "\r\n" + fastestTimeLabel.getText() + "\r\n" + lastTimeLabel.getText() + "\r\n" + timeDifString;
	}

	private String copySplitsToClipboard()
	{
		return plugin.getSplits().replace("<br>", "\r\n");
	}

	void setTeamPoints(int points)
	{
		teamPointsLabel.setText(toPoints("Team Points: ", points));
	}

	void setTeamVirtualPointsHour(int points, int ticks)
	{
		teamVirtualPointsHourLabel.setText(toPointsPerHour("Virtual Per Hour: ", points, ticks));
	}

	void setTeamPointsHour(int points, int ticks)
	{
		teamPointsHourLabel.setText(toPointsPerHour("Per Hour: ", points, ticks));
	}

	void setAvgTeamPoints(int points, int kc)
	{
		avgTeamPointsLabel.setText(toAvgPoints(points, kc));
	}

	void setSoloPoints(int points)
	{
		soloPointsLabel.setText(toPoints("Personal Points: ", points));
	}

	void setSoloVirtualPointsHour(int points, int ticks)
	{
		soloVirtualPointsHourLabel.setText(toPointsPerHour("Virtual Per Hour: ", points, ticks));
	}

	void setSoloPointsHour(int points, int ticks)
	{
		soloPointsHourLabel.setText(toPointsPerHour("Per Hour: ", points, ticks));
	}

	void setAvgSoloPoints(int points, int kc)
	{
		avgSoloPointsLabel.setText(toAvgPoints(points, kc));
	}

	void setCompletions(int regKC, int cmKC)
	{
		raidsCompletedLabel.setText(toCompletions(regKC, cmKC));
	}

	void setAvgTime(String time)
	{
		avgTimeLabel.setText("Avg. Time: " + time);
	}

	void setFastestTime(String time)
	{
		fastestTimeLabel.setText("Fastest Time: " + time);
	}

	void setLastTime(String time)
	{
		lastTimeLabel.setText("Last Time: " + time);
	}

	void setTimeDif(int difference)
	{
		String hexColor = "";
		String time = "";
		if (difference > 0)
		{
			hexColor = "'color:#25c54f'";
			time = "-" + plugin.raidTime(difference);
		}
		else if (difference < 0)
		{
			hexColor = "'color:#e03c31'";
			time = "+" + plugin.raidTime(difference - (difference * 2));
		}
		String timeDif = String.format(DIFFERENCE_TEMPLATE, hexColor, time);
		timeDifLabel.setText(timeDif);
	}

	void setSplits(String splits)
	{
		splitsLabel.setText(toSplits(splits));
	}

	private static String toCompletions(int regKC, int cmKC)
	{
		return regKC + cmKC == 0 ? "Total: 0" : "Total: " + (regKC + cmKC) + "   |   CoX: " + regKC + "   |   CM: " + cmKC;
	}

	private static String toSplits(String splits)
	{
		return String.format(HTML_LABEL_TEMPLATE, ColorUtil.toHexColor(ColorScheme.LIGHT_GRAY_COLOR), splits);
	}

	private static String toPoints(String key, int value)
	{
		String points = POINTS_FORMAT.format(value);
		return key + points;
	}

	private static String toPointsPerHour(String key, int points, int ticks)
	{
		String pph = ticks == 0 ? "0" : POINTS_FORMAT.format((float) (points / ticks) * 6000);
		return key + pph;
	}

	private static String toAvgPoints(int points, int kc)
	{
		String avgPts = kc == 0 ? "0" : POINTS_FORMAT.format((float) (points / kc));
		return "Avg. Points: " + avgPts;
	}
}

/*
 * Copyright (c) 2022, Buchus <http://github.com/MoreBuchus>
 * Copyright (c) 2021, dey0 <http://github.com/dey0> - Math to convert times
 * Copyright (c) 2020, Trevor <https://github.com/Trevor159> - Cox time script
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.coxanalytics;

import com.coxanalytics.config.TimeStyle;
import com.google.inject.Provides;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.Optional;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.NPC;
import net.runelite.api.NpcID;
import net.runelite.api.Point;
import net.runelite.api.VarPlayer;
import net.runelite.api.Varbits;
import net.runelite.api.events.ActorDeath;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameObjectSpawned;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.PluginManager;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import javax.inject.Inject;

@Slf4j
@PluginDescriptor(
	name = "CoX Analytics",
	description = "Additional information for CoX sessions.",
	tags = {"cox", "floor", "splits", "olm", "time", "analytics", "session", "raid"}
)
public class CoxAnalyticsPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private CoxAnalyticsConfig config;

	@Inject
	private CoxAnalyticsOverlay overlay;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private ClientThread clientThread;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private TooltipManager tooltipManager;

	@Inject
	private PluginManager pluginManager;

	private CoxPointsPanel pointsPanel;

	private NavigationButton button;

	private static final int COX_TIME_VAR = 6386;
	private static final int COX_POINT_WIDGET_SCRIPT = 1510;
	private static final DecimalFormat POINTS_FORMAT = new DecimalFormat("#,###");
	private static final String RAID_START_MESSAGE = "The raid has begun!";
	private static final String KC_MESSAGE = "Your completed Chambers of Xeric count is:";
	private static final String KC_MESSAGE_CM = "Your completed Chambers of Xeric Challenge Mode count is:";
	private static final String RAID_COMPLETE_MESSAGE = "Congratulations - your raid is complete!";
	private static final String COMBAT_ROOM_COMPLETE_MESSAGE = "Combat room ";
	private static final String PUZZLE_ROOM_COMPLETE_MESSAGE = "Puzzle ";

	@Getter
	private boolean inCox;
	@Getter
	private int regKC = 0;
	@Getter
	private int cmKC = 0;

	@Getter
	private int fastestTicks = -1;
	@Getter
	private int splitTicks = 0;
	@Getter
	private String splits = "";

	@Getter
	private int totalTeamPoints = 0;
	@Getter
	private int totalSoloPoints = 0;
	@Getter
	private int totalEndTicks = 0;
	@Getter
	private int realEndTicks = 0;
	@Getter
	private boolean realTicksFlag = false;

	@Getter
	private int upperTicks = -1;
	@Getter
	private int middleTicks = -1;
	@Getter
	private int lowerTicks = -1;
	@Getter
	private int olmStart = -1;
	@Getter
	private int endTicks = -1;

	@Getter
	private String upperFloorTime = "";
	@Getter
	private String middleFloorTime = "";
	@Getter
	private String lowerFloorTime = "";
	@Getter
	private String olmTime = "";

	public int olmPhase = 0;
	public int mageStart = -1;

	@Getter
	private static final File TIMES_DIR = new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + "cox-analytics");

	@Provides
	CoxAnalyticsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CoxAnalyticsConfig.class);
	}

	@Override
	protected void startUp() throws Exception
	{
		buildPanel();
		overlayManager.add(overlay);
		clientThread.invoke(() -> hideWidget(config.replaceWidget()));
		if (!TIMES_DIR.exists())
		{
			TIMES_DIR.mkdirs();
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		clientToolbar.removeNavigation(button);
		overlayManager.remove(overlay);
		clientThread.invoke(() -> hideWidget(false));
		reset();
		resetTimes();
	}

	public void reset()
	{
		inCox = false;
		upperTicks = -1;
		middleTicks = -1;
		lowerTicks = -1;
		endTicks = -1;
		upperFloorTime = "";
		middleFloorTime = "";
		lowerFloorTime = "";
		olmTime = "";
		olmPhase = 0;
		splitTicks = 0;
		mageStart = -1;
	}

	public void resetTimes()
	{
		upperTicks = -1;
		middleTicks = -1;
		lowerTicks = -1;
		endTicks = -1;
		upperFloorTime = "";
		middleFloorTime = "";
		lowerFloorTime = "";
		olmTime = "";
		splits = "";
		splitTicks = 0;
		mageStart = -1;
	}

	private void buildPanel()
	{
		clientToolbar.removeNavigation(button);
		pointsPanel = injector.getInstance(CoxPointsPanel.class);
		pointsPanel.init();
		BufferedImage icon = ImageUtil.loadImageResource(getClass(), "cox.png");
		button = NavigationButton.builder()
			.tooltip("CoX Analytics")
			.icon(icon)
			.priority(config.panelPriority())
			.panel(pointsPanel)
			.build();
		if (config.ptsPanel())
		{
			clientToolbar.addNavigation(button);
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged e)
	{
		if (e.getGroup().equals("CoxAnalytics"))
		{
			if (e.getKey().equals("ptsPanel"))
			{
				if (config.ptsPanel())
				{
					clientToolbar.addNavigation(button);
					pointsPanel.revalidate();
				}
				else if (!config.ptsPanel())
				{
					clientToolbar.removeNavigation(button);
				}
			}
			else if (e.getKey().equals("panelPriority"))
			{
				buildPanel();
			}
			else if (e.getKey().equals("replaceWidget"))
			{
				hideWidget(config.replaceWidget());
			}
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		if (inCox && client.getVarbitValue(Varbits.IN_RAID) != 1)
		{
			reset();
		}
		else
		{
			inCox = client.getVarbitValue(Varbits.IN_RAID) == 1;
		}
	}

	@Subscribe
	private void onGameStateChanged(GameStateChanged e)
	{
		if (e.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null && !inCox)
		{
			reset();
		}
	}

	@Subscribe
	private void onGameTick(GameTick e)
	{
		if (client.getGameState() == GameState.LOGGED_IN && client.getLocalPlayer() != null && realTicksFlag)
		{
			realEndTicks++;
		}
	}

	@Subscribe
	public void onChatMessage(ChatMessage e) throws Exception
	{
		if (inCox)
		{
			String msg = Text.removeTags(e.getMessage());

			if (e.getType() == ChatMessageType.GAMEMESSAGE)
			{
				if (msg.startsWith(KC_MESSAGE) || msg.startsWith(KC_MESSAGE_CM))
				{
					String trimKcMsg = msg.substring(msg.indexOf(":")).replace(".", "");
					if (msg.startsWith(KC_MESSAGE))
					{
						regKC++;
						splits += "CoX KC" + trimKcMsg;
						pointsPanel.setSplits(splits);
						if (config.exportTimes())
						{
							exportTimes(false);
						}
					}
					else if (msg.startsWith(KC_MESSAGE_CM))
					{
						cmKC++;
						splits += "CoX CM KC" + trimKcMsg;
						pointsPanel.setSplits(splits);
						if (config.exportTimes())
						{
							exportTimes(true);
						}
					}

					updatePanel();
				}
			}
			else if (e.getType() == ChatMessageType.FRIENDSCHATNOTIFICATION)
			{
				if (msg.startsWith(COMBAT_ROOM_COMPLETE_MESSAGE) || msg.startsWith(PUZZLE_ROOM_COMPLETE_MESSAGE))
				{
					String room = msg.split("`")[1];
					int roomTicks = coxTimeVar() - splitTicks;
					if (splitTicks != coxTimeVar())
					{
						splitTicks = coxTimeVar();
					}

					splits += room + ": " + raidTime(roomTicks) + "<br>";
					pointsPanel.setSplits(splits);
				}
				else if (msg.contains("Olm phase") || msg.contains("Olm head"))
				{
					if (msg.contains("Total"))
					{
						splits += msg.substring(0, msg.indexOf("Total")).replace(" duration", "").trim() + "<br>";
					}
					else
					{
						splits += msg.replace(" duration", "").trim() + "<br>";
					}

					pointsPanel.setSplits(splits);
				}
				else if (msg.contains("level complete! Duration: "))
				{
					if (msg.contains("Upper"))
					{
						upperTicks = coxTimeVar();
						getFloorTimes();
						splits += "Floor 1: " + upperFloorTime + "<br>";
					}
					else if (msg.contains("Middle"))
					{
						middleTicks = coxTimeVar();
						getFloorTimes();
						splits += "Floor 2: " + middleFloorTime + "<br>";
					}
					else if (msg.contains("Lower"))
					{
						lowerTicks = coxTimeVar();
						olmStart = coxTimeVar();
						getFloorTimes();
						splits += middleTicks != -1 ? "Floor 3: " + lowerFloorTime + "<br>" : "Floor 2: " + lowerFloorTime + "<br>";
					}
					if (splitTicks != coxTimeVar())
					{
						splitTicks = coxTimeVar();
					}
					pointsPanel.setSplits(splits);
				}
				else if (msg.startsWith(RAID_START_MESSAGE))
				{
					resetTimes();
					if (!realTicksFlag)
					{
						realTicksFlag = true;
					}
				}
				else if (msg.startsWith(RAID_COMPLETE_MESSAGE))
				{
					int totalPoints = client.getVarbitValue(Varbits.TOTAL_POINTS);
					int personalPoints = client.getVarpValue(VarPlayer.RAIDS_PERSONAL_POINTS);
					int scale = client.getVarbitValue(CoxAnalyticsVarbits.RAID_PARTY_SIZE);

					endTicks = coxTimeVar();
					getFloorTimes();
					splits += "Olm: " + olmTime + "<br>Raid Completed: " + raidTime(endTicks) + " | Team Size: " + scale + "<br>";
					pointsPanel.setSplits(splits);

					totalEndTicks += endTicks;
					totalTeamPoints += totalPoints;
					totalSoloPoints += personalPoints;

					if (config.ptsHr())
					{
						String chatMessage = new ChatMessageBuilder()
							.append(ChatColorType.NORMAL)
							.append("Solo pts/hr: ")
							.append(ChatColorType.HIGHLIGHT)
							.append(getPointsPerHour(personalPoints))
							.append(ChatColorType.NORMAL)
							.append(", Team pts/hr: ")
							.append(ChatColorType.HIGHLIGHT)
							.append(getPointsPerHour(totalPoints))
							.build();

						chatMessageManager.queue(QueuedMessage.builder()
							.type(ChatMessageType.FRIENDSCHATNOTIFICATION)
							.runeLiteFormattedMessage(chatMessage)
							.build());
					}
				}
			}
		}
	}

	@Subscribe
	public void onActorDeath(ActorDeath e)
	{
		final Optional<Plugin> deoTimers = pluginManager.getPlugins().stream().filter(p -> p.getName().equals("CoX Timers")).findFirst();
		if (deoTimers.isPresent() && pluginManager.isPluginEnabled(deoTimers.get()) && config.showOlmMageHand())
		{
			if (e.getActor() instanceof NPC)
			{
				NPC npc = (NPC) e.getActor();
				if (npc.getId() == NpcID.GREAT_OLM_RIGHT_CLAW || npc.getId() == NpcID.GREAT_OLM_RIGHT_CLAW_7553)
				{
					if ((olmPhase + 1) < getOlmPhases())
					{
						if (mageStart != -1)
						{
							//Keep the colors and message consistent with de0's CoX Timers
							olmPhase++;
							String chatMessage = "Olm mage hand phase " + olmPhase + " duration: <col=ff0000>" + raidTime(coxTimeVar() - mageStart);
							client.addChatMessage(ChatMessageType.FRIENDSCHATNOTIFICATION, "", chatMessage, null);

							splits += "Olm mage hand phase " + olmPhase + ": " + raidTime(coxTimeVar() - mageStart) + "<br>";
							pointsPanel.setSplits(splits);
							mageStart = -1;
						}
					}
				}
			}
		}
	}

	private int getOlmPhases()
	{
		int scale = client.getVarbitValue(CoxAnalyticsVarbits.RAID_PARTY_SIZE);
		return 3 + (scale / 8);
	}

	@Subscribe
	public void onGameObjectSpawned(GameObjectSpawned e)
	{
		//Olm spawned
		if (e.getGameObject().getId() == 29881)
		{
			mageStart = coxTimeVar();
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (coxTimeVar() > 0 && client.getVarbitValue(Varbits.RAID_STATE) < 5)
		{
			//Needs to run the script, otherwise it only updates the time every ~4 seconds
			client.runScript(2289, 0, 0, 0);

			Widget widget = client.getWidget(ComponentID.RAIDS_POINTS_INFOBOX);
			Point mousePosition = client.getMouseCanvasPosition();

			if (widget != null && !widget.isHidden() && widget.getBounds().contains(mousePosition.getX(), mousePosition.getY()))
			{
				if (config.splitsTooltip() && upperTicks != -1)
				{
					tooltipManager.add(new Tooltip(getFloorTimes()));
				}
			}
		}
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		if (event.getScriptId() == COX_POINT_WIDGET_SCRIPT && inCox)
		{
			Widget widget = client.getWidget(ComponentID.RAIDS_POINTS_INFOBOX);

			if (widget != null && !widget.isHidden())
			{
				widget.setHidden(config.replaceWidget());
			}
		}
	}

	private void hideWidget(boolean hidden)
	{
		if (client.getGameState() == GameState.LOGGED_IN && inCox)
		{
			final Widget widget = client.getWidget(ComponentID.RAIDS_POINTS_INFOBOX);
			if (widget != null)
			{
				widget.setHidden(hidden);
			}
		}
	}

	public String getFloorTimes()
	{
		String time = "";
		if (upperTicks != -1)
		{
			upperFloorTime = raidTime(upperTicks);
			time += "Floor 1: " + upperFloorTime;

			if (middleTicks == -1)
			{
				if (lowerTicks != -1)
				{
					lowerFloorTime = raidTime(lowerTicks - upperTicks);
					time += "</br>Floor 2: " + lowerFloorTime;
				}
			}
			else
			{
				middleFloorTime = raidTime(middleTicks - upperTicks);
				time += "</br>Floor 2: " + middleFloorTime;

				if (lowerTicks != -1)
				{
					lowerFloorTime = raidTime(lowerTicks - middleTicks);
					time += "</br>Floor 3: " + lowerFloorTime;
				}
			}

			if (endTicks != -1)
			{
				olmTime = raidTime(endTicks - olmStart);
				time += "</br>Olm: " + olmTime;
			}
		}
		return time;
	}

	public int coxTimeVar()
	{
		return client.getVarbitValue(COX_TIME_VAR);
	}

	public String raidTime(int ticks)
	{
		TimeStyle setting = config.timerStyle();
		boolean ingame_setting = client.getVarbitValue(11866) == 1;
		if (setting == TimeStyle.TICKS || (setting == TimeStyle.VARBIT && ingame_setting))
		{
			return to_mmss_precise(ticks);
		}

		return to_mmss(ticks);
	}

	public static String to_mmss(int ticks)
	{
		int m = ticks / 100;
		int s = (ticks - m * 100) * 6 / 10;
		return m + (s < 10 ? ":0" : ":") + s;
	}

	public static String to_mmss_precise(int ticks)
	{
		int min = ticks / 100;
		int tmp = (ticks - min * 100) * 6;
		int sec = tmp / 10;
		int sec_tenth = tmp - sec * 10;
		return min + (sec < 10 ? ":0" : ":") + sec + "." + sec_tenth;
	}

	public String getPointsPerHour(int points)
	{
		return POINTS_FORMAT.format((float) (points / endTicks) * 6000);
	}

	private void updatePanel()
	{
		int totalKC = regKC + cmKC;

		if (endTicks != -1)
		{
			pointsPanel.setTeamPoints(totalTeamPoints);
			pointsPanel.setTeamVirtualPointsHour(totalTeamPoints, totalEndTicks);
			pointsPanel.setTeamPointsHour(totalTeamPoints, realEndTicks);
			pointsPanel.setAvgTeamPoints(totalTeamPoints, totalKC);

			pointsPanel.setSoloPoints(totalSoloPoints);
			pointsPanel.setSoloVirtualPointsHour(totalSoloPoints, totalEndTicks);
			pointsPanel.setSoloPointsHour(totalSoloPoints, realEndTicks);
			pointsPanel.setAvgSoloPoints(totalSoloPoints, totalKC);

			pointsPanel.setCompletions(regKC, cmKC);
			pointsPanel.setAvgTime(raidTime(totalEndTicks / totalKC));
			pointsPanel.setLastTime(raidTime(endTicks));
			pointsPanel.setTimeDif(fastestTicks != -1 ? fastestTicks - endTicks : 0);
		}

		if (fastestTicks == -1 || endTicks < fastestTicks)
		{
			fastestTicks = endTicks;
			pointsPanel.setFastestTime(raidTime(fastestTicks));
		}
	}

	public void resetPointsPanel()
	{
		regKC = 0;
		cmKC = 0;
		totalTeamPoints = 0;
		totalSoloPoints = 0;
		totalEndTicks = 0;
		fastestTicks = -1;
		realTicksFlag = false;
		realEndTicks = 0;

		pointsPanel.setTeamPoints(totalTeamPoints);
		pointsPanel.setTeamVirtualPointsHour(totalTeamPoints, totalEndTicks);
		pointsPanel.setTeamPointsHour(totalTeamPoints, realEndTicks);
		pointsPanel.setAvgTeamPoints(totalTeamPoints, regKC + cmKC);

		pointsPanel.setSoloPoints(totalSoloPoints);
		pointsPanel.setSoloVirtualPointsHour(totalSoloPoints, totalEndTicks);
		pointsPanel.setSoloPointsHour(totalSoloPoints, realEndTicks);
		pointsPanel.setAvgSoloPoints(totalSoloPoints, regKC + cmKC);

		pointsPanel.setCompletions(regKC, cmKC);
		pointsPanel.setFastestTime("00:00.0");
		pointsPanel.setLastTime("00:00.0");
		pointsPanel.setTimeDif(0);
	}

	public void resetSplitsPanel()
	{
		splits = "";
		pointsPanel.setSplits(splits);
	}

	private void exportTimes(boolean cm) throws Exception
	{
		String fileName = "";
		if (cm)
		{
			fileName = TIMES_DIR + "\\" + client.getLocalPlayer().getName() + "_CmTimes.txt";
		}
		else
		{
			fileName = TIMES_DIR + "\\" + client.getLocalPlayer().getName() + "_CoxTimes.txt";
		}
		FileWriter writer = new FileWriter(fileName, true);
		try
		{
			writer.write(splits.replace("<br>", "\r\n") + "\r\n" +
				"------------------------------------------------------------------------------------------------\r\n" +
				"------------------------------------------------------------------------------------------------\r\n");
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
		writer.close();
	}
}
package com.coxanalytics;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CoxAnalyticsPlugin.class);
		RuneLite.main(args);
	}
}
