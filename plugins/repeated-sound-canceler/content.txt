package repeatedsoundcanceler;

import net.runelite.api.events.AreaSoundEffectPlayed;

public class FilterableAreaSoundEffectPlayed implements FilterableSoundEffect{
    
    private final AreaSoundEffectPlayed sfx;

    public FilterableAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        this.sfx = areaSoundEffectPlayed;
    }

    @Override
    public void consume() {
        this.sfx.consume();
    }

    @Override
    public int getSoundId() {
        return this.sfx.getSoundId();
    }
}

package repeatedsoundcanceler;

interface FilterableSoundEffect {
    void consume();
    int getSoundId();
}

package repeatedsoundcanceler;

import net.runelite.api.events.SoundEffectPlayed;

public class FilterableSoundEffectPlayed implements FilterableSoundEffect {

    private final SoundEffectPlayed sfx;

    public FilterableSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        this.sfx = soundEffectPlayed;
    }

    @Override
    public void consume() {
        this.sfx.consume();
    }

    @Override
    public int getSoundId() {
        return this.sfx.getSoundId();
    }
}

package repeatedsoundcanceler;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("repeatedsoundcanceler")
public interface RepeatedSoundCancelerConfig extends Config
{
    @ConfigSection(
        position = 1,
        name = "General Settings",
        description = "General settings"
    )
    String generalSettingsSection = "General Settings";

	@ConfigItem(
        position = 2,
		keyName = "mode",
		name = "Filtering Mode",
		description = "How to cancel repeated sounds.\nWhitelist mode: All sounds are filtered except those" +
                "in the whitelist.\nBlacklist mode: Only sounds in the blacklist are filtered, all other sounds" +
                "are treated normally.",
        section = generalSettingsSection
	)
	default RepeatedSoundCancelerMode getMode() { return RepeatedSoundCancelerMode.WHITELIST_MODE; }

    @ConfigSection(
        position = 3,
        name = "Whitelist",
        description = "Whitelist settings"
    )
    String whitelistSettings = "Whitelist Settings";

    @ConfigItem(
        position = 4,
        keyName = "whitelistList",
        name = "Sound ID Whitelist",
        description = "List of area sound IDs separated by commas to be used when in whitelist mode.",
        section = whitelistSettings
    )
    default String getWhitelist() { return ""; }

    @ConfigSection(
        position = 5,
        name = "Blacklist",
        description = "Blacklist settings"
    )
    String blacklistSettings = "Blacklist Settings";

    @ConfigItem(
        position = 6,
        keyName = "blacklistList",
        name = "Sound ID Blacklist",
        description = "List of area sound IDs separated by commas to be used when in blacklist mode. By default" +
                "ancient spell barrage hit noises are included",
        section = blacklistSettings
    )
    default String getBlacklist() { return "102,168,175,180"; }
}

package repeatedsoundcanceler;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum RepeatedSoundCancelerMode {

    WHITELIST_MODE("Whitelist"),
    BLACKLIST_MODE("Blacklist");

    private final String option;

    @Override
    public String toString() {
        return option;
    }
}

package repeatedsoundcanceler;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.AreaSoundEffectPlayed;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import org.apache.commons.lang3.math.NumberUtils;

import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Repeated Sound Canceler"
)
public class RepeatedSoundCancelerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private RepeatedSoundCancelerConfig config;

    private int tickToCheck;
    private Set<Integer> blacklistIDs, whitelistIDs, idsSeenThisTick;

	@Override
	protected void startUp() throws Exception
	{
        tickToCheck = 0;
        idsSeenThisTick = new HashSet<Integer>();
        blacklistIDs = configListToSet(config.getBlacklist());
        whitelistIDs = configListToSet(config.getWhitelist());
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        blacklistIDs = configListToSet(config.getBlacklist());
        whitelistIDs = configListToSet(config.getWhitelist());
    }

    @Subscribe
    public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        // Wrap it in an interfaced class for function reuse
        FilterableSoundEffect played = new FilterableAreaSoundEffectPlayed(areaSoundEffectPlayed);
        filterDupeSounds(played);
    }

    @Subscribe
    public void onSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        // Wrap in interfaced class for function reuse
        FilterableSoundEffect played = new FilterableSoundEffectPlayed(soundEffectPlayed);
        filterDupeSounds(played);
    }

	@Provides
    RepeatedSoundCancelerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RepeatedSoundCancelerConfig.class);
	}

    private static Set<Integer> configListToSet(String configList) {
        return Arrays.stream(configList.split(","))
                .map(String::trim)
                .filter(NumberUtils::isParsable)
                .map(Integer::parseInt)
                .collect(Collectors.toSet());
    }

    private void filterDupeSounds(FilterableSoundEffect sound) {
        int currTickCount = client.getTickCount();
        // Or condition is if someone somehow leaves their client on for maxint ticks I guess.
        // Reset sounds seen if we start a new tick.
        if (currTickCount > tickToCheck || currTickCount == 0) {
            tickToCheck = currTickCount;
            idsSeenThisTick.clear();
        }

        boolean filter = false;
        if (config.getMode().equals(RepeatedSoundCancelerMode.BLACKLIST_MODE)) {
            filter = blacklistIDs.contains(sound.getSoundId());
        } else if (config.getMode().equals(RepeatedSoundCancelerMode.WHITELIST_MODE)) {
            filter = !whitelistIDs.contains(sound.getSoundId());
        }

        if (filter) {
            // add returns false if item is already in the set.
            if (!idsSeenThisTick.add(sound.getSoundId())) {
                sound.consume();
            }
        }
    }
}

package repeatedsoundcanceler;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RepeatedSoundCancelerTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RepeatedSoundCancelerPlugin.class);
		RuneLite.main(args);
	}
}
