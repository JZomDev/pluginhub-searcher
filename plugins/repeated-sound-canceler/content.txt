package repeatedsoundcanceler;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("repeatedsoundcanceler")
public interface RepeatedSoundCancelerConfig extends Config
{
    @ConfigSection(
        position = 1,
        name = "General Settings",
        description = "General settings"
    )
    String generalSettingsSection = "General Settings";

	@ConfigItem(
        position = 2,
		keyName = "mode",
		name = "Filtering Mode",
		description = "How to cancel repeated sounds.\nWhitelist mode: All area sounds are filtered except those" +
                "in the whitelist.\nBlacklist mode: Only area sounds in the blacklist are filtered, all other sounds" +
                "are treated normally.",
        section = generalSettingsSection
	)
	default RepeatedSoundCancelerMode getMode() { return RepeatedSoundCancelerMode.WHITELIST_MODE; }

    @ConfigSection(
        position = 3,
        name = "Whitelist",
        description = "Whitelist settings"
    )
    String whitelistSettings = "Whitelist Settings";

    @ConfigItem(
        position = 4,
        keyName = "whitelistList",
        name = "Sound ID Whitelist",
        description = "List of area sound IDs separated by commas to be used when in whitelist mode.",
        section = whitelistSettings
    )
    default String getWhitelist() { return ""; }

    @ConfigSection(
        position = 5,
        name = "Blacklist",
        description = "Blacklist settings"
    )
    String blacklistSettings = "Blacklist Settings";

    @ConfigItem(
        position = 6,
        keyName = "blacklistList",
        name = "Sound ID Blacklist",
        description = "List of area sound IDs separated by commas to be used when in blacklist mode. By default" +
                "ancient spell barrage hit noises are included",
        section = blacklistSettings
    )
    default String getBlacklist() { return "102,168,175,180"; }
}

package repeatedsoundcanceler;

interface FilterableSoundEffect {
    void consume();
    int getSoundId();
}

package repeatedsoundcanceler;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.AreaSoundEffectPlayed;
import net.runelite.api.events.SoundEffectPlayed;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import org.apache.commons.lang3.math.NumberUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.logging.Filter;
import java.util.stream.Collectors;

@Slf4j
@PluginDescriptor(
	name = "Repeated Sound Canceler"
)
public class RepeatedSoundCancelerPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private RepeatedSoundCancelerConfig config;

    private int tickToCheck;
    private List<Integer> idsSeenThisTick;
    private Set<Integer> blacklistIDs, whitelistIDs;

	@Override
	protected void startUp() throws Exception
	{
        tickToCheck = 0;
        idsSeenThisTick = new ArrayList<Integer>();
        blacklistIDs = configListToSet(config.getBlacklist());
        whitelistIDs = configListToSet(config.getWhitelist());
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged) {
        blacklistIDs = configListToSet(config.getBlacklist());
        whitelistIDs = configListToSet(config.getWhitelist());
    }

    @Subscribe
    public void onAreaSoundEffectPlayed(AreaSoundEffectPlayed areaSoundEffectPlayed) {
        // Wrap it in an interface for function reuse
        FilterableSoundEffect played = new FilterableSoundEffect() {
            @Override
            public void consume() {
                areaSoundEffectPlayed.consume();
            }

            @Override
            public int getSoundId() {
                return areaSoundEffectPlayed.getSoundId();
            }
        };

        filterDupeSounds(played);
    }

    @Subscribe
    public void onSoundEffectPlayed(SoundEffectPlayed soundEffectPlayed) {
        // Wrap in interface for function reuse
        FilterableSoundEffect played = new FilterableSoundEffect() {
            @Override
            public void consume() {
                soundEffectPlayed.consume();
            }

            @Override
            public int getSoundId() {
                return soundEffectPlayed.getSoundId();
            }
        };

        filterDupeSounds(played);
    }

	@Provides
    RepeatedSoundCancelerConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RepeatedSoundCancelerConfig.class);
	}

    private static Set<Integer> configListToSet(String configList) {
        return Arrays.stream(configList.split(","))
                .map(String::trim)
                .filter(NumberUtils::isParsable)
                .map(Integer::parseInt)
                .collect(Collectors.toSet());
    }

    private void filterDupeSounds(FilterableSoundEffect sound) {
        int currTickCount = client.getTickCount();
        // Or condition is if someone somehow leaves their client on for maxint ticks I guess.
        // Reset sounds seen if we start a new tick.
        if (currTickCount > tickToCheck || currTickCount == 0) {
            tickToCheck = currTickCount;
            idsSeenThisTick.clear();
        }

        boolean filter = false;
        if (config.getMode().equals(RepeatedSoundCancelerMode.BLACKLIST_MODE)) {
            filter = blacklistIDs.contains(sound.getSoundId());
        } else if (config.getMode().equals(RepeatedSoundCancelerMode.WHITELIST_MODE)) {
            filter = !whitelistIDs.contains(sound.getSoundId());
        }

        if (filter) {
            if (!idsSeenThisTick.contains(sound.getSoundId())) {
                idsSeenThisTick.add(sound.getSoundId());
            } else {
                sound.consume();
            }
        }
    }
}

package repeatedsoundcanceler;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum RepeatedSoundCancelerMode {

    WHITELIST_MODE("Whitelist"),
    BLACKLIST_MODE("Blacklist");

    private final String option;

    @Override
    public String toString() {
        return option;
    }
}

package repeatedsoundcanceler;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RepeatedSoundCancelerTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RepeatedSoundCancelerPlugin.class);
		RuneLite.main(args);
	}
}
