package com.salverrs.RemainingCasts;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Remaining Casts",
	description = "Displays the number of casts remaining for your spells.",
	tags = {"remaining","casts","magic","spell","rune","tracker"}
)
public class RemainingCastsPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "RemainingCasts";

	@Inject
	private RemainingCastsConfig config;
	@Inject
	private EventBus eventBus;
	@Inject
	private CastSuppliesTracker castSuppliesTracker;
	@Inject
	private RemainingCastTracker castTracker;
	@Inject
	private TooltipCastUpdater tooltipUpdater;

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(castSuppliesTracker);
		eventBus.register(castTracker);
		eventBus.register(tooltipUpdater);

		castSuppliesTracker.start();
		castTracker.start(this);
		tooltipUpdater.start();
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(castSuppliesTracker);
		eventBus.unregister(castTracker);
		eventBus.unregister(tooltipUpdater);

		castSuppliesTracker.stop();
		castTracker.stop();
		tooltipUpdater.stop();
	}


	@Provides
	RemainingCastsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RemainingCastsConfig.class);
	}
}

package com.salverrs.RemainingCasts.Util;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Model.SpellProduct;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.SpriteID;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SpellIds {

    private static final List<SpellInfo> Spells = new ArrayList<>();
    private static final Map<SpellProduct, SpellInfo> SpellProductMap = new HashMap<>();
    private static final Map<String, SpellInfo> SpellNameMap = new HashMap<>();
    private static final Map<Integer, SpellInfo> SpellSpriteMap = new HashMap<>();

    public static List<SpellInfo> getAllSpells()
    {
        return Spells;
    }
    public static SpellInfo getSpellBySpriteId(int spriteId)
    {
        return SpellSpriteMap.getOrDefault(spriteId, null);
    }
    public static SpellInfo getSpellByName(String spellName)
    {
        return SpellNameMap.getOrDefault(spellName.toLowerCase(), null);
    }
    public static SpellInfo getSpellByProduct(int itemId, int quantity)
    {
        return SpellProductMap.getOrDefault(new SpellProduct(itemId, quantity), null);
    }

    static
    {
        // Standard Spellbook

        // Lumbridge Home Teleport
        Spells.add(new SpellInfo("Wind Strike", SpriteID.Magicon.WIND_STRIKE, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.AIRRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Confuse", SpriteID.Magicon.CONFUSE, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 3, 2})));

        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Opal)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.AIRRUNE, ItemID.COSMICRUNE, ItemID.OPAL_BOLT}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_BRONZE_TIPPED_OPAL_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_OPAL, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Sapphire)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.WATERRUNE, ItemID.COSMICRUNE, ItemID.MINDRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE}, new int[] {1, 1, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_SAPPHIRE, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Jade)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTHRUNE, ItemID.COSMICRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_JADE, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Pearl)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.WATERRUNE, ItemID.COSMICRUNE, ItemID.PEARL_BOLT}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_IRON_TIPPED_PEARL_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_PEARL, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Emerald)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.AIRRUNE, ItemID.COSMICRUNE, ItemID.NATURERUNE, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD}, new int[] {3, 1, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_EMERALD, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Red Topaz)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRERUNE, ItemID.COSMICRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_TOPAZ, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Ruby)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRERUNE, ItemID.BLOODRUNE, ItemID.COSMICRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY}, new int[] {5, 1, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_RUBY, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Diamond)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTHRUNE, ItemID.COSMICRUNE, ItemID.LAWRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND}, new int[] {10, 1, 2, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_DIAMOND, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Dragonstone)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTHRUNE, ItemID.COSMICRUNE, ItemID.SOULRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE}, new int[] {15, 1, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_DRAGONSTONE, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Onyx)", SpriteID.Magicon2.ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRERUNE, ItemID.COSMICRUNE, ItemID.DEATHRUNE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX}, new int[] {20, 1, 1, 10}),
                new SpellProduct(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX_ENCHANTED, 10), new SpellProduct(ItemID.DRAGON_BOLTS_ENCHANTED_ONYX, 10)));

        Spells.add(new SpellInfo("Water Strike", SpriteID.Magicon.WATER_STRIKE, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.WATERRUNE, ItemID.AIRRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Lvl-1 Enchant", SpriteID.Magicon.LVL_1_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.WATERRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Earth Strike", SpriteID.Magicon.EARTH_STRIKE, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 2, 1})));
        Spells.add(new SpellInfo("Weaken", SpriteID.Magicon.WEAKEN, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Fire Strike", SpriteID.Magicon.FIRE_STRIKE, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Bones to Bananas", SpriteID.Magicon.BONES_TO_BANANAS, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Wind Bolt", SpriteID.Magicon.WIND_BOLT, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.AIRRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Curse", SpriteID.Magicon.CURSE, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 2, 3})));
        Spells.add(new SpellInfo("Bind", SpriteID.Magicon2.BIND, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {2, 3, 3})));
        Spells.add(new SpellInfo("Low Level Alchemy", SpriteID.Magicon.LOW_LEVEL_ALCHEMY, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.FIRERUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Water Bolt", SpriteID.Magicon.WATER_BOLT, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.WATERRUNE, ItemID.AIRRUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Varrock Teleport", SpriteID.Magicon.VARROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Lvl-2 Enchant", SpriteID.Magicon.LVL_2_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.AIRRUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Earth Bolt", SpriteID.Magicon.EARTH_BOLT, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Lumbridge Teleport", SpriteID.Magicon.LUMBRIDGE_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.EARTHRUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Telekinetic Grab", SpriteID.Magicon.TELEKINETIC_GRAB, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Fire Bolt", SpriteID.Magicon.FIRE_BOLT, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {1, 4, 3})));
        Spells.add(new SpellInfo("Falador Teleport", SpriteID.Magicon.FALADOR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.WATERRUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Crumble Undead", SpriteID.Magicon.CRUMBLE_UNDEAD, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Teleport to House", SpriteID.Magicon2.TELEPORT_TO_HOUSE, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.EARTHRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Wind Blast", SpriteID.Magicon.WIND_BLAST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.AIRRUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Monster Inspect", SpriteID.Magicon2._49, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.MINDRUNE}, new int[] {2, 2}))); // Monster Inspect sprite is not named yet
        Spells.add(new SpellInfo("Superheat Item", SpriteID.Magicon.SUPERHEAT_ITEM, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.FIRERUNE}, new int[] {1, 4})));
        Spells.add(new SpellInfo("Camelot Teleport", SpriteID.Magicon.CAMELOT_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Water Blast", SpriteID.Magicon.WATER_BLAST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.WATERRUNE, ItemID.AIRRUNE}, new int[] {1, 3, 3})));
        Spells.add(new SpellInfo("Lvl-3 Enchant", SpriteID.Magicon.LVL_3_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.FIRERUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Iban Blast", SpriteID.Magicon.IBAN_BLAST, new SpellCost(new int[] {ItemID.IBANSTAFF, ItemID.DEATHRUNE, ItemID.FIRERUNE}, new int[] {1, 1, 5})));
        Spells.add(new SpellInfo("Snare", SpriteID.Magicon2.SNARE, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {3, 4, 4})));
        Spells.add(new SpellInfo("Magic Dart", SpriteID.Magicon2.MAGIC_DART, new SpellCost(new int[] {ItemID.SLAYER_STAFF, ItemID.DEATHRUNE, ItemID.MINDRUNE}, new int[] {1, 1, 4})));
        Spells.add(new SpellInfo("Ardougne Teleport", SpriteID.Magicon.ARDOUGNE_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Earth Blast", SpriteID.Magicon.EARTH_BLAST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 4, 3})));
        Spells.add(new SpellInfo("Civitas illa Fortis Teleport", SpriteID.Magicon2.CIVITAS_ILLA_FORTIS_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE, ItemID.FIRERUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("High Level Alchemy", SpriteID.Magicon.HIGH_LEVEL_ALCHEMY, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.FIRERUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Charge Water Orb", SpriteID.Magicon.CHARGE_WATER_ORB, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.WATERRUNE, ItemID.STAFFORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Summon Boat", SpriteID.Magicon._51, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE, ItemID.WATERRUNE}, new int[] {2, 1, 1}))); // Summon Boat sprite is not named yet
        Spells.add(new SpellInfo("Lvl-4 Enchant", SpriteID.Magicon.LVL_4_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.EARTHRUNE}, new int[] {1, 10})));
        Spells.add(new SpellInfo("Watchtower Teleport", SpriteID.Magicon.WATCHTOWER_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Fire Blast", SpriteID.Magicon.FIRE_BLAST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {1, 5, 4})));
        Spells.add(new SpellInfo("Charge Earth Orb", SpriteID.Magicon.CHARGE_EARTH_ORB, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.EARTHRUNE, ItemID.STAFFORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Bones to Peaches", SpriteID.Magicon2.BONES_TO_PEACHES, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Saradomin Strike", SpriteID.Magicon.SARADOMIN_STRIKE, new SpellCost(new int[] {ItemID.SARADOMIN_STAFF, ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {1, 2, 4, 2})));
        Spells.add(new SpellInfo("Claws of Guthix", SpriteID.Magicon.CLAWS_OF_GUTHIX, new SpellCost(new int[] {ItemID.GUTHIX_STAFF, ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {1, 2, 4, 1})));
        Spells.add(new SpellInfo("Flames of Zamorak", SpriteID.Magicon.FLAMES_OF_ZAMORAK, new SpellCost(new int[] {ItemID.ZAMORAK_STAFF, ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {1, 2, 1, 4})));
        Spells.add(new SpellInfo("Trollheim Teleport", SpriteID.Magicon2.TROLLHEIM_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.FIRERUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Wind Wave", SpriteID.Magicon.WIND_WAVE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.AIRRUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Charge Fire Orb", SpriteID.Magicon.CHARGE_FIRE_ORB, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.FIRERUNE, ItemID.STAFFORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Ape Atoll Teleport", SpriteID.MagicNecroOn.APE_ATOLL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE, ItemID.FIRERUNE, ItemID.BANANA}, new int[] {2, 2, 2, 1})));
        Spells.add(new SpellInfo("Water Wave", SpriteID.Magicon.WATER_WAVE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.WATERRUNE, ItemID.AIRRUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Charge Air Orb", SpriteID.Magicon.CHARGE_AIR_ORB, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.AIRRUNE, ItemID.STAFFORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Vulnerability", SpriteID.Magicon.VULNERABILITY, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 5, 5})));
        Spells.add(new SpellInfo("Teleport to Boat", SpriteID.Magicon._50, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE, ItemID.WATERRUNE}, new int[] {2, 2, 2}))); // Teleport to Boat sprite is not named yet
        Spells.add(new SpellInfo("Lvl-5 Enchant", SpriteID.Magicon.LVL_5_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 15, 15})));
        Spells.add(new SpellInfo("Kourend Castle Teleport", SpriteID.Magicon2.TELEPORT_TO_KOUREND, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE, ItemID.FIRERUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("Earth Wave", SpriteID.Magicon.EARTH_WAVE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Enfeeble", SpriteID.Magicon.ENFEEBLE, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 8, 8})));
        Spells.add(new SpellInfo("Teleother Lumbridge", SpriteID.Magicon2.TELEOTHER_LUMBRIDGE, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.EARTHRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Fire Wave", SpriteID.Magicon.FIRE_WAVE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Entangle", SpriteID.Magicon2.ENTANGLE, new SpellCost(new int[] {ItemID.NATURERUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {4, 5, 5})));
        Spells.add(new SpellInfo("Stun", SpriteID.Magicon.STUN, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 12, 12})));
        Spells.add(new SpellInfo("Charge", SpriteID.Magicon2.CHARGE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {3, 3, 3})));
        Spells.add(new SpellInfo("Wind Surge", SpriteID.Magicon2.WIND_SURGE, new SpellCost(new int[] {ItemID.WRATHRUNE, ItemID.AIRRUNE}, new int[] {1, 7})));
        Spells.add(new SpellInfo("Teleother Falador", SpriteID.Magicon2.TELEOTHER_FALADOR, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.WATERRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Water Surge", SpriteID.Magicon2.WATER_SURGE, new SpellCost(new int[] {ItemID.WRATHRUNE, ItemID.WATERRUNE, ItemID.AIRRUNE}, new int[] {1, 10, 7})));
        Spells.add(new SpellInfo("Tele Block", SpriteID.Magicon2.TELE_BLOCK, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.DEATHRUNE, ItemID.CHAOSRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.Magicon2.TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.DEATHRUNE, ItemID.CHAOSRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Lvl-6 Enchant", SpriteID.Magicon2.LVL_6_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.EARTHRUNE, ItemID.FIRERUNE}, new int[] {1, 20, 20})));
        Spells.add(new SpellInfo("Teleother Camelot", SpriteID.Magicon2.TELEOTHER_CAMELOT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Earth Surge", SpriteID.Magicon2.EARTH_SURGE, new SpellCost(new int[] {ItemID.WRATHRUNE, ItemID.EARTHRUNE, ItemID.AIRRUNE}, new int[] {1, 10, 7})));
        Spells.add(new SpellInfo("Lvl-7 Enchant", SpriteID.Magicon2.LVL_7_ENCHANT, new SpellCost(new int[] {ItemID.COSMICRUNE, ItemID.SOULRUNE, ItemID.BLOODRUNE}, new int[] {1, 20, 20})));
        Spells.add(new SpellInfo("Fire Surge", SpriteID.Magicon2.FIRE_SURGE, new SpellCost(new int[] {ItemID.WRATHRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {1, 10, 7})));

        // Ancients Spellbook

        // Edgeville Home Teleport
        Spells.add(new SpellInfo("Smoke Rush", SpriteID.Magicon2.SMOKE_RUSH, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 1, 1})));
        Spells.add(new SpellInfo("Shadow Rush", SpriteID.Magicon2.SHADOW_RUSH, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.SOULRUNE, ItemID.AIRRUNE}, new int[] {2, 2, 1, 1})));
        Spells.add(new SpellInfo("Paddewwa Teleport", SpriteID.Magicon2.PADDEWWA_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("Blood Rush", SpriteID.Magicon2.BLOOD_RUSH, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.BLOODRUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Ice Rush", SpriteID.Magicon2.ICE_RUSH, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.WATERRUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Senntisten Teleport", SpriteID.Magicon2.SENNTISTEN_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Smoke Burst", SpriteID.Magicon2.SMOKE_BURST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 4, 2, 2})));
        Spells.add(new SpellInfo("Shadow Burst", SpriteID.Magicon2.SHADOW_BURST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.SOULRUNE, ItemID.AIRRUNE}, new int[] {2, 4, 2, 1})));
        Spells.add(new SpellInfo("Kharyrll Teleport", SpriteID.Magicon2.KHARYRLL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Blood Burst", SpriteID.Magicon2.BLOOD_BURST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.BLOODRUNE}, new int[] {2, 4, 2})));
        Spells.add(new SpellInfo("Ice Burst", SpriteID.Magicon2.ICE_BURST, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.CHAOSRUNE, ItemID.WATERRUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Lassar Teleport", SpriteID.Magicon2.LASSAR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Smoke Blitz", SpriteID.Magicon2.SMOKE_BLITZ, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 2, 2})));
        Spells.add(new SpellInfo("Shadow Blitz", SpriteID.Magicon2.SHADOW_BLITZ, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.SOULRUNE, ItemID.AIRRUNE}, new int[] {2, 2, 2, 2})));
        Spells.add(new SpellInfo("Dareeyak Teleport", SpriteID.Magicon2.DAREEYAK_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Blood Blitz", SpriteID.Magicon2.BLOOD_BLITZ, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Ice Blitz", SpriteID.Magicon2.ICE_BLITZ, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.WATERRUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Carrallanger Teleport", SpriteID.Magicon2.CARRALLANGAR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.Magicon2.TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.DEATHRUNE, ItemID.CHAOSRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Smoke Barrage", SpriteID.Magicon2.SMOKE_BARRAGE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {4, 2, 4, 4})));
        Spells.add(new SpellInfo("Shadow Barrage", SpriteID.Magicon2.SHADOW_BARRAGE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.SOULRUNE, ItemID.AIRRUNE}, new int[] {4, 2, 3, 4})));
        Spells.add(new SpellInfo("Annakarl Teleport", SpriteID.Magicon2.ANNAKARL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Blood Barrage", SpriteID.Magicon2.BLOOD_BARRAGE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.SOULRUNE}, new int[] {4, 4, 1})));
        Spells.add(new SpellInfo("Ice Barrage", SpriteID.Magicon2.ICE_BARRAGE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.WATERRUNE}, new int[] {4, 2, 6})));
        Spells.add(new SpellInfo("Ghorrock Teleport", SpriteID.Magicon2.GHORROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE}, new int[] {2, 8})));

        //Normal Ancient Teleports compatibility (name map only)
        Spells.add(new SpellInfo("Edgeville Teleport", SpriteID.Magicon2.PADDEWWA_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("Digsite Teleport", SpriteID.Magicon2.SENNTISTEN_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Canifis Teleport", SpriteID.Magicon2.KHARYRLL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Ice Mountain Teleport", SpriteID.Magicon2.LASSAR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Forgotten Cemetery Teleport", SpriteID.Magicon2.DAREEYAK_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.AIRRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Graveyard of Shadows Teleport", SpriteID.Magicon2.CARRALLANGAR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Demonic Ruins Teleport", SpriteID.Magicon2.ANNAKARL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Frozen Waste Plateau Teleport", SpriteID.Magicon2.GHORROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE}, new int[] {2, 8})));

        // Lunar Spellbook

        // Lunar Home Teleport
        Spells.add(new SpellInfo("Bake Pie", SpriteID.LunarMagicOn.BAKE_PIE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.FIRERUNE}, new int[] {1, 4, 5})));
        Spells.add(new SpellInfo("Geomancy", SpriteID.LunarMagicOn.GEOMANCY, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.NATURERUNE, ItemID.EARTHRUNE}, new int[] {3, 3, 8})));
        Spells.add(new SpellInfo("Cure Plant", SpriteID.LunarMagicOn.CURE_PLANT, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.EARTHRUNE}, new int[] {1, 8})));
        Spells.add(new SpellInfo("Monster Examine", SpriteID.LunarMagicOn.MONSTER_EXAMINE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.MINDRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("NPC Contact", SpriteID.LunarMagicOn.NPC_CONTACT, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.AIRRUNE}, new int[] {1, 1, 2})));
        Spells.add(new SpellInfo("Cure Other", SpriteID.LunarMagicOn.CURE_OTHER, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.LAWRUNE, ItemID.EARTHRUNE}, new int[] {1, 1, 10})));
        Spells.add(new SpellInfo("Humidify", SpriteID.LunarMagicOn.HUMIDIFY, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.FIRERUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Moonclan Teleport", SpriteID.LunarMagicOn.MOONCLAN_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.EARTHRUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Tele Group Moonclan", SpriteID.LunarMagicOn.TELE_GROUP_MOONCLAN, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.EARTHRUNE}, new int[] {1, 2, 4})));
        Spells.add(new SpellInfo("Cure Me", SpriteID.LunarMagicOn.CURE_ME, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.LAWRUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Ourania Teleport", SpriteID.LunarMagicOn.OURANIA_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.EARTHRUNE}, new int[] {1, 2, 6})));
        Spells.add(new SpellInfo("Hunter Kit", SpriteID.LunarMagicOn.HUNTER_KIT, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.EARTHRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Waterbirth Teleport", SpriteID.LunarMagicOn.WATERBIRTH_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {1, 2, 1})));
        Spells.add(new SpellInfo("Tele Group Waterbirth", SpriteID.LunarMagicOn.TELE_GROUP_WATERBIRTH, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {1, 2, 5})));
        Spells.add(new SpellInfo("Cure Group", SpriteID.LunarMagicOn.CURE_GROUP, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.LAWRUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Stat Spy", SpriteID.LunarMagicOn.STAT_SPY, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.BODYRUNE}, new int[] {2, 2, 5})));
        Spells.add(new SpellInfo("Barbarian Teleport", SpriteID.LunarMagicOn.BARBARIAN_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Tele Group Barbarian", SpriteID.LunarMagicOn.TELE_GROUP_BARBARIAN, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.FIRERUNE}, new int[] {2, 2, 6})));
        Spells.add(new SpellInfo("Spin Flax", SpriteID.LunarMagicOn.SPIN_FLAX, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.NATURERUNE, ItemID.AIRRUNE}, new int[] {1, 2, 5})));
        Spells.add(new SpellInfo("Superglass Make", SpriteID.LunarMagicOn.SUPERGLASS_MAKE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.FIRERUNE, ItemID.AIRRUNE}, new int[] {2, 6, 10})));
        Spells.add(new SpellInfo("Tan Leather", SpriteID.LunarMagicOn.TAN_LEATHER, new SpellCost(new int[] {ItemID.FIRERUNE, ItemID.ASTRALRUNE, ItemID.NATURERUNE}, new int[] {5, 2, 1})));
        Spells.add(new SpellInfo("Khazard Teleport", SpriteID.LunarMagicOn.KHAZARD_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {2, 2, 4})));
        Spells.add(new SpellInfo("Tele Group Khazard", SpriteID.LunarMagicOn.TELE_GROUP_KHAZARD, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {2, 2, 8})));
        Spells.add(new SpellInfo("Dream", SpriteID.LunarMagicOn.DREAM, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.BODYRUNE}, new int[] {2, 1, 5})));
        Spells.add(new SpellInfo("String Jewellery", SpriteID.LunarMagicOn.STRING_JEWELLERY, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {2, 5, 10})));
        Spells.add(new SpellInfo("Stat Restore Pot Share", SpriteID.LunarMagicOn.STAT_RESTORE_POT_SHARE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {2, 10, 10})));
        Spells.add(new SpellInfo("Magic Imbue", SpriteID.LunarMagicOn.MAGIC_IMBUE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.FIRERUNE}, new int[] {2, 7, 7})));
        Spells.add(new SpellInfo("Fertile Soil", SpriteID.LunarMagicOn.FERTILE_SOIL, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.NATURERUNE, ItemID.EARTHRUNE}, new int[] {3, 2, 15})));
        Spells.add(new SpellInfo("Boost Potion Share", SpriteID.LunarMagicOn.BOOST_POTION_SHARE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {3, 10, 12})));
        Spells.add(new SpellInfo("Fishing Guild Teleport", SpriteID.LunarMagicOn.FISHING_GUILD_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 10})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.Magicon2.TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.DEATHRUNE, ItemID.CHAOSRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Tele Group Fishing Guild", SpriteID.LunarMagicOn.TELE_GROUP_FISHING_GUILD, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 14})));
        Spells.add(new SpellInfo("Plank Make", SpriteID.LunarMagicOn.PLANK_MAKE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.NATURERUNE, ItemID.EARTHRUNE}, new int[] {2, 1, 15})));
        Spells.add(new SpellInfo("Catherby Teleport", SpriteID.LunarMagicOn.CATHERBY_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 10})));
        Spells.add(new SpellInfo("Tele Group Catherby", SpriteID.LunarMagicOn.TELE_GROUP_CATHERBY, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 15})));
        Spells.add(new SpellInfo("Recharge Dragonstone", SpriteID.LunarMagicOn.RECHARGE_DRAGONSTONE, new SpellCost(new int[] {ItemID.WATERRUNE, ItemID.ASTRALRUNE, ItemID.SOULRUNE}, new int[] {4, 1, 1})));
        Spells.add(new SpellInfo("Ice Plateau Teleport", SpriteID.LunarMagicOn.ICE_PLATEAU_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 8})));
        Spells.add(new SpellInfo("Tele Group Ice Plateau", SpriteID.LunarMagicOn.TELE_GROUP_ICE_PLATEAU, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.ASTRALRUNE, ItemID.WATERRUNE}, new int[] {3, 3, 16})));
        Spells.add(new SpellInfo("Energy Transfer", SpriteID.LunarMagicOn.ENERGY_TRANSFER, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.LAWRUNE, ItemID.NATURERUNE}, new int[] {3, 2, 1})));
        Spells.add(new SpellInfo("Heal Other", SpriteID.LunarMagicOn.HEAL_OTHER, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {3, 3, 1})));
        Spells.add(new SpellInfo("Vengeance Other", SpriteID.LunarMagicOn.VENGEANCE_OTHER, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.DEATHRUNE, ItemID.EARTHRUNE}, new int[] {3, 2, 10})));
        Spells.add(new SpellInfo("Vengeance", SpriteID.LunarMagicOn.VENGEANCE, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.DEATHRUNE, ItemID.EARTHRUNE}, new int[] {4, 2, 10})));
        Spells.add(new SpellInfo("Heal Group", SpriteID.LunarMagicOn.HEAL_GROUP, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.LAWRUNE, ItemID.BLOODRUNE}, new int[] {4, 6, 3})));
        Spells.add(new SpellInfo("Spellbook Swap", SpriteID.LunarMagicOn.SPELLBOOK_SWAP, new SpellCost(new int[] {ItemID.ASTRALRUNE, ItemID.COSMICRUNE, ItemID.LAWRUNE}, new int[] {3, 2, 1})));

        // Arceuus spellbook

        // Arceuus Home Teleport
        Spells.add(new SpellInfo("Arceuus Library Teleport", SpriteID.MagicNecroOn.ARCEUUS_LIBRARY_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Basic Reanimation", SpriteID.MagicNecroOn.BASIC_REANIMATION, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.NATURERUNE}, new int[] {4, 2})));
        Spells.add(new SpellInfo("Draynor Manor Teleport", SpriteID.MagicNecroOn.DRAYNOR_MANOR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.WATERRUNE, ItemID.EARTHRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Battlefront Teleport", 1255, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.EARTHRUNE, ItemID.FIRERUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Mind Altar Teleport", SpriteID.MagicNecroOn.MIND_ALTAR_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.MINDRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Respawn Teleport", SpriteID.MagicNecroOn.RESPAWN_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Ghostly Grasp", SpriteID.MagicNecroOn.GHOSTLY_GRASP, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.AIRRUNE}, new int[] {1, 4})));
        Spells.add(new SpellInfo("Resurrect Lesser Ghost", SpriteID.MagicNecroOn.RESURRECT_LESSER_GHOST, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.AIRRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Lesser Skeleton", 1271, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.AIRRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Lesser Zombie", 1300, new SpellCost(new int[] {ItemID.MINDRUNE, ItemID.AIRRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Salve Graveyard Teleport", SpriteID.MagicNecroOn.SALVE_GRAVEYARD_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Adept Reanimation", SpriteID.MagicNecroOn.ADEPT_REANIMATION, new SpellCost(new int[] {ItemID.BODYRUNE, ItemID.NATURERUNE, ItemID.SOULRUNE}, new int[] {4, 3, 1})));
        Spells.add(new SpellInfo("Inferior Demonbane", SpriteID.MagicNecroOn.INFERIOR_DEMONBANE, new SpellCost(new int[] {ItemID.CHAOSRUNE, ItemID.FIRERUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Shadow Veil", SpriteID.MagicNecroOn.SHADOW_VEIL, new SpellCost(new int[] {ItemID.EARTHRUNE, ItemID.FIRERUNE, ItemID.COSMICRUNE}, new int[] {5, 5, 5})));
        Spells.add(new SpellInfo("Fenkenstrain's Castle Teleport", SpriteID.MagicNecroOn.FENKENSTRAINS_CASTLE_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.EARTHRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Dark Lure", SpriteID.MagicNecroOn.DARK_LURE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.NATURERUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Skeletal Grasp", SpriteID.MagicNecroOn.SKELETAL_GRASP, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.EARTHRUNE}, new int[] {1, 8})));
        Spells.add(new SpellInfo("Resurrect Superior Ghost", 2979, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.EARTHRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Superior Skeleton", SpriteID.MagicNecroOn.RESURRECT_SUPERIOR_SKELETON, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.EARTHRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Superior Zombie", 2983, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.EARTHRUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Mark of Darkness", SpriteID.MagicNecroOn.MARK_OF_DARKNESS, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.COSMICRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("West Ardougne Teleport", SpriteID.MagicNecroOn.WEST_ARDOUGNE_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Superior Demonbane", SpriteID.MagicNecroOn.SUPERIOR_DEMONBANE, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.FIRERUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Lesser Corruption", SpriteID.MagicNecroOn.LESSER_CORRUPTION, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.SOULRUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Harmony Island Teleport", SpriteID.MagicNecroOn.HARMONY_ISLAND_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.NATURERUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Vile Vigour", SpriteID.MagicNecroOn.VILE_VIGOUR, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.AIRRUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Degrime", SpriteID.MagicNecroOn.DEGRIME, new SpellCost(new int[] {ItemID.EARTHRUNE, ItemID.NATURERUNE}, new int[] {4, 2})));
        Spells.add(new SpellInfo("Cemetery Teleport", SpriteID.MagicNecroOn.CEMETERY_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.BLOODRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Expert Reanimation", SpriteID.MagicNecroOn.EXPERT_REANIMATION, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.NATURERUNE, ItemID.SOULRUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Ward of Arceuus", SpriteID.MagicNecroOn.WARD_OF_ARCEUUS, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.NATURERUNE, ItemID.COSMICRUNE}, new int[] {4, 2, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Ghost", 2980, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.FIRERUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Skeleton", 2982, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.FIRERUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Zombie", SpriteID.MagicNecroOn.RESURRECT_GREATER_ZOMBIE, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.FIRERUNE, ItemID.COSMICRUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Crops", SpriteID.MagicNecroOn.RESURRECT_CROPS, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.NATURERUNE, ItemID.BLOODRUNE, ItemID.EARTHRUNE}, new int[] {8, 12, 8, 25})));
        Spells.add(new SpellInfo("Undead Grasp", SpriteID.MagicNecroOn.UNDEAD_GRASP, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.FIRERUNE}, new int[] {1, 12})));
        Spells.add(new SpellInfo("Death Charge", SpriteID.MagicNecroOn.DEATH_CHARGE, new SpellCost(new int[] {ItemID.DEATHRUNE, ItemID.BLOODRUNE, ItemID.SOULRUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Dark Demonbane", SpriteID.MagicNecroOn.DARK_DEMONBANE, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.FIRERUNE}, new int[] {2, 7})));
        Spells.add(new SpellInfo("Barrows Teleport", SpriteID.MagicNecroOn.BARROWS_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.BLOODRUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Demonic Offering", SpriteID.MagicNecroOn.DEMONIC_OFFERING, new SpellCost(new int[] {ItemID.SOULRUNE, ItemID.WRATHRUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Greater Corruption", SpriteID.MagicNecroOn.GREATER_CORRUPTION, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.SOULRUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Master Reanimation", SpriteID.MagicNecroOn.MASTER_REANIMATION, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.NATURERUNE, ItemID.SOULRUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Ape Atoll Teleport", SpriteID.MagicNecroOn.APE_ATOLL_TELEPORT, new SpellCost(new int[] {ItemID.LAWRUNE, ItemID.SOULRUNE, ItemID.BLOODRUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Sinister Offering", SpriteID.MagicNecroOn.SINISTER_OFFERING, new SpellCost(new int[] {ItemID.BLOODRUNE, ItemID.WRATHRUNE}, new int[] {1, 1})));

        // Some keys do collide (some spells name/sprite) - no longer bothering to map through cost because unlimited rune supply complicates things.
        // We remove existing sprite keys and ignore them because we don't want the first occurrence mapped if it's not unique.
        // Don't need to remove/ignore keys from name map, because we only use that for tooltips and the rune costs are the same regardless (as of writing, only Teleport to Target is shared).

        // SpellProductMap currently only used for detecting Enchant crossbow bolts.

        final List<Integer> spriteIgnore = new ArrayList<Integer>();

        Spells.forEach(s -> {
            final SpellCost cost = s.getSpellCost();
            final int spriteId = s.getSpriteId();
            final String name = s.getName();

            if (s.getSpellProducts() != null)
            {
                final SpellProduct[] products = s.getSpellProducts();
                for (SpellProduct p : products)
                    SpellProductMap.put(p, s);
            }

            if (!spriteIgnore.contains(spriteId))
            {
                if (!SpellSpriteMap.containsKey(spriteId))
                {
                    SpellSpriteMap.put(spriteId, s);
                }
                else
                {
                    SpellSpriteMap.remove(spriteId);
                    spriteIgnore.add(spriteId);
                }
            }

            if (!SpellNameMap.containsKey(name))
                SpellNameMap.put(name.toLowerCase(), s);
        });
    }
}

package com.salverrs.RemainingCasts.Util;

public class CastUtils {

    public static String getShortenedAmount(double amount)
    {
        if (amount == Integer.MAX_VALUE)
        {
            return "*";
        }
        else if (amount > 1000000000)
        {
            return String.format("%.1f", amount / 1000000000) + "b";
        }
        else if (amount > 1000000)
        {
            return String.format("%.1f", amount / 1000000) + "m";
        }
        else if (amount > 1000)
        {
            return String.format("%.1f", amount / 1000) + "k";
        }
        else
        {
            return Integer.toString((int)amount);
        }
    }

    public static String formatCastAmount(int amount)
    {
        return amount == Integer.MAX_VALUE ? "*" : Integer.toString(amount);
    }
}




package com.salverrs.RemainingCasts.Util;

import net.runelite.api.gameval.ItemID;

import java.util.*;

public class RuneIds {

    private static final Map<Integer, Integer[]> RuneMap = new HashMap<>();
    private static final Map<Integer, Integer[]> ReqStaffMap = new HashMap<>();
    private static final Map<Integer, Integer> StaffMap = new HashMap<>();
    private static final Map<Integer, Integer> TomeMap = new HashMap<>();
    private static final Map<Integer, Integer> IngredientMap = new HashMap<>();
    private static final List<Integer> EnchantProducts = new ArrayList<>();

    public static Set<Integer> getAllRuneIds()
    {
        return RuneMap.keySet();
    }

    public static Integer[] getRuneIds(int runeId)
    {
        return RuneMap.getOrDefault(runeId, null);
    }

    public static int getIngredientId(int itemId)
    {
        return IngredientMap.getOrDefault(itemId, -1);
    }

    public static boolean isEnchantProduct(int itemId)
    {
        return EnchantProducts.contains(itemId);
    }

    public static boolean isReqStaff(int itemId)
    {
        return ReqStaffMap.containsKey(itemId);
    }

    public static Integer[] getRuneIdsFromEquipment(int equipmentId)
    {
        if (StaffMap.containsKey(equipmentId))
        {
            return RuneMap.getOrDefault(StaffMap.get(equipmentId), new Integer[] {StaffMap.get(equipmentId)});
        }
        else if (TomeMap.containsKey(equipmentId))
        {
            return RuneMap.getOrDefault(TomeMap.get(equipmentId), null);
        }
        return null;
    }

    public static Integer[] getItemIdsFromEquipment(int equipmentId)
    {
        return ReqStaffMap.getOrDefault(equipmentId, null);
    }

    static
    {
        // Regular runes
        RuneMap.put(ItemID.AIRRUNE, new Integer[] {ItemID.AIRRUNE});
        RuneMap.put(ItemID.WATERRUNE, new Integer[] {ItemID.WATERRUNE});
        RuneMap.put(ItemID.EARTHRUNE, new Integer[] {ItemID.EARTHRUNE});
        RuneMap.put(ItemID.FIRERUNE, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID.MINDRUNE, new Integer[] {ItemID.MINDRUNE});
        RuneMap.put(ItemID.BODYRUNE, new Integer[] {ItemID.BODYRUNE});
        RuneMap.put(ItemID.COSMICRUNE, new Integer[] {ItemID.COSMICRUNE});
        RuneMap.put(ItemID.CHAOSRUNE, new Integer[] {ItemID.CHAOSRUNE});
        RuneMap.put(ItemID.NATURERUNE, new Integer[] {ItemID.NATURERUNE});
        RuneMap.put(ItemID.LAWRUNE, new Integer[] {ItemID.LAWRUNE});
        RuneMap.put(ItemID.DEATHRUNE, new Integer[] {ItemID.DEATHRUNE});
        RuneMap.put(ItemID.ASTRALRUNE, new Integer[] {ItemID.ASTRALRUNE});
        RuneMap.put(ItemID.BLOODRUNE, new Integer[] {ItemID.BLOODRUNE});
        RuneMap.put(ItemID.SOULRUNE, new Integer[] {ItemID.SOULRUNE});
        RuneMap.put(ItemID.WRATHRUNE, new Integer[] {ItemID.WRATHRUNE});

        // Regular runes (variations)
        RuneMap.put(ItemID.ROGUETRADER_AIRRUNE, new Integer[] {ItemID.AIRRUNE});
        RuneMap.put(ItemID._100GUIDE_AIRRUNE_DUM, new Integer[] {ItemID.AIRRUNE});
        RuneMap.put(ItemID.SLUG2_RUNE_AIR, new Integer[] {ItemID.AIRRUNE});
        RuneMap.put(ItemID.FAKE_AIRRUNE, new Integer[] {ItemID.AIRRUNE});
        RuneMap.put(ItemID.NZONE_AIRRUNE, new Integer[] {ItemID.AIRRUNE});

        RuneMap.put(ItemID.ROGUETRADER_WATERRUNE, new Integer[] {ItemID.WATERRUNE});
        RuneMap.put(ItemID._100GUIDE_WATERRUNE_DUM, new Integer[] {ItemID.WATERRUNE});
        RuneMap.put(ItemID.SLUG2_RUNE_WATER, new Integer[] {ItemID.WATERRUNE});
        RuneMap.put(ItemID.FAKE_WATERRUNE, new Integer[] {ItemID.WATERRUNE});
        RuneMap.put(ItemID.NZONE_WATERRUNE, new Integer[] {ItemID.WATERRUNE});

        RuneMap.put(ItemID.ROGUETRADER_EARTHRUNE, new Integer[] {ItemID.EARTHRUNE});
        RuneMap.put(ItemID.SLUG2_RUNE_EARTH, new Integer[] {ItemID.EARTHRUNE});
        RuneMap.put(ItemID.FAKE_EARTHRUNE, new Integer[] {ItemID.EARTHRUNE});
        RuneMap.put(ItemID.NZONE_EARTHRUNE, new Integer[] {ItemID.EARTHRUNE});

        RuneMap.put(ItemID.ROGUETRADER_FIRERUNE, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID._100GUIDE_FIRERUNE_DUM, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID.SLUG2_RUNE_FIRE, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID.FAKE_FIRERUNE, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID.NZONE_FIRERUNE, new Integer[] {ItemID.FIRERUNE});
        RuneMap.put(ItemID.SUNFIRERUNE, new Integer[] {ItemID.FIRERUNE});

        RuneMap.put(ItemID.ROGUETRADER_MINDRUNE, new Integer[] {ItemID.MINDRUNE});
        RuneMap.put(ItemID.SLUG2_RUNE_MIND, new Integer[] {ItemID.MINDRUNE});
        RuneMap.put(ItemID.FAKE_MINDRUNE, new Integer[] {ItemID.MINDRUNE});

        RuneMap.put(ItemID.ROGUETRADER_BODYRUNE, new Integer[] {ItemID.BODYRUNE});
        RuneMap.put(ItemID.FAKE_BODYRUNE, new Integer[] {ItemID.BODYRUNE});

        RuneMap.put(ItemID.FAKE_COSMICRUNE, new Integer[] {ItemID.COSMICRUNE});

        RuneMap.put(ItemID.ROGUETRADER_CHAOSRUNE, new Integer[] {ItemID.CHAOSRUNE});
        RuneMap.put(ItemID._100GUIDE_CHAOSRUNE_DUM, new Integer[] {ItemID.CHAOSRUNE});
        RuneMap.put(ItemID.FAKE_CHAOSRUNE, new Integer[] {ItemID.CHAOSRUNE});
        RuneMap.put(ItemID.NZONE_CHAOSRUNE, new Integer[] {ItemID.CHAOSRUNE});

        RuneMap.put(ItemID.FAKE_NATURERUNE, new Integer[] {ItemID.NATURERUNE});

        RuneMap.put(ItemID.ROGUETRADER_LAWRUNE, new Integer[] {ItemID.LAWRUNE});
        RuneMap.put(ItemID.FAKE_LAWRUNE, new Integer[] {ItemID.LAWRUNE});

        RuneMap.put(ItemID.ROGUETRADER_DEATHRUNE, new Integer[] {ItemID.DEATHRUNE});
        RuneMap.put(ItemID.FAKE_DEATHRUNE, new Integer[] {ItemID.DEATHRUNE});
        RuneMap.put(ItemID.NZONE_DEATHRUNE, new Integer[] {ItemID.DEATHRUNE});

        RuneMap.put(ItemID.FAKE_ASTRALRUNE, new Integer[] {ItemID.ASTRALRUNE});

        RuneMap.put(ItemID.FAKE_BLOODRUNE, new Integer[] {ItemID.BLOODRUNE});
        RuneMap.put(ItemID.NZONE_BLOODRUNE, new Integer[] {ItemID.BLOODRUNE});

        RuneMap.put(ItemID.FAKE_SOULRUNE, new Integer[] {ItemID.SOULRUNE});

        RuneMap.put(ItemID.FAKE_WRATHRUNE, new Integer[] {ItemID.WRATHRUNE});

        // Combo runes
        RuneMap.put(ItemID.MISTRUNE, new Integer[] {ItemID.AIRRUNE, ItemID.WATERRUNE});
        RuneMap.put(ItemID.DUSTRUNE, new Integer[] {ItemID.AIRRUNE, ItemID.EARTHRUNE});
        RuneMap.put(ItemID.MUDRUNE, new Integer[] {ItemID.WATERRUNE, ItemID.EARTHRUNE});
        RuneMap.put(ItemID.SMOKERUNE, new Integer[] {ItemID.AIRRUNE, ItemID.FIRERUNE});
        RuneMap.put(ItemID.STEAMRUNE, new Integer[] {ItemID.WATERRUNE, ItemID.FIRERUNE});
        RuneMap.put(ItemID.LAVARUNE, new Integer[] {ItemID.EARTHRUNE, ItemID.FIRERUNE});
        RuneMap.put(ItemID.AETHERRUNE, new Integer[] {ItemID.COSMICRUNE, ItemID.SOULRUNE});

        // Staffs
        StaffMap.put(ItemID.STAFF_OF_AIR, ItemID.AIRRUNE);
        StaffMap.put(ItemID.STAFF_OF_WATER, ItemID.WATERRUNE);
        StaffMap.put(ItemID.STAFF_OF_EARTH, ItemID.EARTHRUNE);
        StaffMap.put(ItemID.STAFF_OF_FIRE, ItemID.FIRERUNE);

        StaffMap.put(ItemID.AIR_BATTLESTAFF, ItemID.AIRRUNE);
        StaffMap.put(ItemID.WATER_BATTLESTAFF, ItemID.WATERRUNE);
        StaffMap.put(ItemID.EARTH_BATTLESTAFF, ItemID.EARTHRUNE);
        StaffMap.put(ItemID.FIRE_BATTLESTAFF, ItemID.FIRERUNE);

        StaffMap.put(ItemID.MYSTIC_AIR_STAFF, ItemID.AIRRUNE);
        StaffMap.put(ItemID.MYSTIC_WATER_STAFF, ItemID.WATERRUNE);
        StaffMap.put(ItemID.MYSTIC_EARTH_STAFF, ItemID.EARTHRUNE);
        StaffMap.put(ItemID.MYSTIC_FIRE_STAFF, ItemID.FIRERUNE);

        StaffMap.put(ItemID.MIST_BATTLESTAFF, ItemID.MISTRUNE);
        StaffMap.put(ItemID.DUST_BATTLESTAFF, ItemID.DUSTRUNE);
        StaffMap.put(ItemID.MUD_BATTLESTAFF, ItemID.MUDRUNE);
        StaffMap.put(ItemID.SMOKE_BATTLESTAFF, ItemID.SMOKERUNE);
        StaffMap.put(ItemID.STEAM_BATTLESTAFF, ItemID.STEAMRUNE);
        StaffMap.put(ItemID.LAVA_BATTLESTAFF, ItemID.LAVARUNE);

        StaffMap.put(ItemID.MYSTIC_MIST_BATTLESTAFF, ItemID.MISTRUNE);
        StaffMap.put(ItemID.MYSTIC_DUST_BATTLESTAFF, ItemID.DUSTRUNE);
        StaffMap.put(ItemID.MYSTIC_MUD_STAFF, ItemID.MUDRUNE);
        StaffMap.put(ItemID.MYSTIC_SMOKE_BATTLESTAFF, ItemID.SMOKERUNE);
        StaffMap.put(ItemID.MYSTIC_STEAM_BATTLESTAFF, ItemID.STEAMRUNE);
        StaffMap.put(ItemID.MYSTIC_LAVA_STAFF, ItemID.LAVARUNE);

        StaffMap.put(ItemID.NATURE_STAFF_CHARGED, ItemID.NATURERUNE);

        StaffMap.put(ItemID.KODAI_WAND, ItemID.WATERRUNE);
        StaffMap.put(ItemID.BR_KODAI_WAND, ItemID.WATERRUNE);

        // Required staffs
        ReqStaffMap.put(ItemID.IBANSTAFF, new Integer[] {ItemID.IBANSTAFF});
        ReqStaffMap.put(ItemID.IBANSTAFF_UPGRADED, new Integer[] {ItemID.IBANSTAFF});
        ReqStaffMap.put(ItemID.SLAYER_STAFF, new Integer[] {ItemID.SLAYER_STAFF});
        ReqStaffMap.put(ItemID.SLAYER_STAFF_ENCHANTED, new Integer[] {ItemID.SLAYER_STAFF});
        ReqStaffMap.put(ItemID.SARADOMIN_STAFF, new Integer[] {ItemID.SARADOMIN_STAFF});
        ReqStaffMap.put(ItemID.GUTHIX_STAFF, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.PEST_VOID_KNIGHT_MACE, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.PEST_VOID_KNIGHT_MACE_TROUVER, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.ZAMORAK_STAFF, new Integer[] {ItemID.ZAMORAK_STAFF});

        ReqStaffMap.put(ItemID.SOTD, new Integer[] {ItemID.SLAYER_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.BR_SOTD, new Integer[] {ItemID.SLAYER_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.TOXIC_SOTD_CHARGED, new Integer[] {ItemID.SLAYER_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.TOXIC_SOTD, new Integer[] {ItemID.SLAYER_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.STAFF_OF_LIGHT, new Integer[] {ItemID.SLAYER_STAFF, ItemID.SARADOMIN_STAFF});
        ReqStaffMap.put(ItemID.STAFF_OF_BALANCE, new Integer[] {ItemID.SLAYER_STAFF, ItemID.GUTHIX_STAFF});

        // Tomes
        TomeMap.put(ItemID.TOME_OF_WATER, ItemID.WATERRUNE);
        TomeMap.put(ItemID.TOME_OF_FIRE, ItemID.FIRERUNE);
        TomeMap.put(ItemID.TOME_OF_EARTH, ItemID.EARTHRUNE);

        // Ingredients
        IngredientMap.put(ItemID.STAFFORB, ItemID.STAFFORB);
        IngredientMap.put(ItemID.OPAL_BOLT, ItemID.OPAL_BOLT);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE, ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE);
        IngredientMap.put(ItemID.PEARL_BOLT, ItemID.PEARL_BOLT);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE);
        IngredientMap.put(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_OPAL, ItemID.OPAL_BOLT);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_JADE, ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_PEARL, ItemID.PEARL_BOLT);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_TOPAZ, ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_SAPPHIRE, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_EMERALD, ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_RUBY, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_DIAMOND, ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_DRAGONSTONE, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE);
        IngredientMap.put(ItemID.DRAGON_BOLTS_UNENCHANTED_ONYX, ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX);

        // Products (Enchant Crossbow only)
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_BRONZE_TIPPED_OPAL_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_BLURITE_TIPPED_JADE_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_IRON_TIPPED_PEARL_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_STEEL_TIPPED_REDTOPAZ_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_SAPPHIRE_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_MITHRIL_TIPPED_EMERALD_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_RUBY_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_ADAMANTITE_TIPPED_DIAMOND_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_DRAGONSTONE_ENCHANTED);
        EnchantProducts.add(ItemID.XBOWS_CROSSBOW_BOLTS_RUNITE_TIPPED_ONYX_ENCHANTED);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_OPAL);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_JADE);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_PEARL);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_TOPAZ);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_SAPPHIRE);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_EMERALD);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_RUBY);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_DIAMOND);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_DRAGONSTONE);
        EnchantProducts.add(ItemID.DRAGON_BOLTS_ENCHANTED_ONYX);

    }

}
package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Events.BoltsEnchanted;
import com.salverrs.RemainingCasts.Events.RunesChanged;
import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Util.RuneIds;
import com.salverrs.RemainingCasts.Util.SpellIds;
import net.runelite.api.Client;
import net.runelite.api.EnumComposition;
import net.runelite.api.EnumID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.PostClientTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.gameval.InventoryID;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class CastSuppliesTracker {

    private static final int[] RUNE_POUCH_RUNE_VARBITS = {
        VarbitID.RUNE_POUCH_TYPE_1, VarbitID.RUNE_POUCH_TYPE_2, VarbitID.RUNE_POUCH_TYPE_3, VarbitID.RUNE_POUCH_TYPE_4
    };

    private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
        VarbitID.RUNE_POUCH_QUANTITY_1, VarbitID.RUNE_POUCH_QUANTITY_2, VarbitID.RUNE_POUCH_QUANTITY_3, VarbitID.RUNE_POUCH_QUANTITY_4
    };

    final private Map<Integer, Integer> runeCount = new HashMap<>();
    final private Set<Integer> unlimitedRunes = new HashSet<>();
    private RuneChanges lastChanges;
    private boolean active = false;
    private boolean requiresPostUpdate = false;

    @Inject
    private Client client;
    @Inject
    private EventBus eventBus;

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!active || !isRelevantItemContainer(event.getItemContainer()))
            return;

        updateRuneCount();
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (!active || requiresPostUpdate || !isRelevantVarbit(event.getVarbitId()))
            return;

        requiresPostUpdate = true;
    }

    @Subscribe
    public void onPostClientTick(PostClientTick event)
    {
        if (!requiresPostUpdate)
            return;

        updateRuneCount();
        requiresPostUpdate = false;
    }

    public void start()
    {
        active = true;
        requiresPostUpdate = true;
    }

    public void stop()
    {
        requiresPostUpdate = false;
        active = false;
    }

    public Map<Integer, Integer> forceUpdateRuneCount()
    {
        updateRuneCount();
        return runeCount;
    }

    public Map<Integer, Integer> getLastRuneCount()
    {
        return runeCount;
    }

    private void updateRuneCount()
    {
        final Map<Integer, Integer> lastCount, changes;
        lastCount = new HashMap<>(runeCount);

        updateCurrentRuneCount();
        changes = calculateRuneChangesMap(lastCount, runeCount);

        if (changes.size() != 0)
        {
            lastChanges = new RuneChanges(changes, runeCount, unlimitedRunes);
            eventBus.post(new RunesChanged(lastChanges));

            final SpellInfo enchant = getEnchantSpellCast(changes);
            if (enchant != null)
                eventBus.post(new BoltsEnchanted(enchant, lastChanges));
        }
    }

    public void updateCurrentRuneCount()
    {
        resetRuneCount();
        updateContainerItems();
        checkGlobalVarbits();
    }

    private void updateContainerItems()
    {
        unlimitedRunes.clear();

        final ItemContainer inventory = client.getItemContainer(InventoryID.INV);
        final ItemContainer equipment = client.getItemContainer(InventoryID.WORN);

        final Item[] inventoryItems = inventory != null ? inventory.getItems() : new Item[] {};
        final Item[] equipmentItems = equipment != null ? equipment.getItems() : new Item[] {};

        Arrays.stream(inventoryItems).forEach(i -> updateInventoryItem(i.getId(), i.getQuantity()));
        Arrays.stream(equipmentItems).forEach(i -> updateEquipmentItems(i.getId(), i.getQuantity()));
    }

    private void updateInventoryItem(int itemId, int quantity)
    {
        if (itemId == ItemID.BH_RUNE_POUCH || itemId == ItemID.BH_RUNE_POUCH_TROUVER)
        {
            updateRunePouchItems(false);
            return;
        }
        else if (itemId == ItemID.DIVINE_RUNE_POUCH || itemId == ItemID.DIVINE_RUNE_POUCH_TROUVER)
        {
            updateRunePouchItems(true);
            return;
        }
        else if (itemId == ItemID.BR_RUNE_REPLACEMENT) // LMS Rune pouch
        {
            addLMSRunePouch();
            return;
        }
        else if (itemId == ItemID.PVPA_RUNE_REPLACEMENT) // Emir's Arena Rune pouch (assumed to contain all, unable to get specific runes yet)
        {
            addUnlimitedRunes();
            return;
        }

        final Integer[] runes = RuneIds.getRuneIds(itemId);
        if (runes != null)
            Arrays.stream(runes).forEach(r -> updateRuneCount(r, quantity));

        final int ingredient = RuneIds.getIngredientId(itemId);
        if (ingredient != -1)
            updateRuneCount(ingredient, quantity);

        if (RuneIds.isEnchantProduct(itemId))
            updateRuneCount(itemId, quantity);

    }

    private void updateEquipmentItems(int itemId, int quantity)
    {
        if (RuneIds.isEnchantProduct(itemId))
            updateRuneCount(itemId, quantity);

        final Integer[] runes = RuneIds.getRuneIdsFromEquipment(itemId);
        if (runes != null)
        {
            Arrays.stream(runes).forEach(r -> {
                unlimitedRunes.add(r);
                updateRuneCount(r, Integer.MAX_VALUE);
            });
        }

        final Integer[] items = RuneIds.getItemIdsFromEquipment(itemId);
        if (items != null)
        {
            Arrays.stream(items).forEach(i -> {
                unlimitedRunes.add(i);
                updateRuneCount(i, quantity);
            });
        }
    }

    private void checkGlobalVarbits()
    {
        final boolean nearFountain = client.getVarbitValue(VarbitID.FOUNTAIN_OF_RUNE_ACTIVE) == 1;

        if (nearFountain)
            addUnlimitedRunes();
    }

    private void updateRunePouchItems(boolean isDivine)
    {
        final EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
        final int pouchSize = isDivine ? 4 : 3;

        for (int i = 0; i < pouchSize; i++)
        {
            final int id = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]);
            final int quantity = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);

            if (id == 0 || quantity <= 0)
                continue;

            final int runeId = runepouchEnum.getIntValue(id);
            final Integer[] runes = RuneIds.getRuneIds(runeId);
            if (runes != null)
                Arrays.stream(runes).forEach(r -> updateRuneCount(r, quantity));
        }
    }

    private void addLMSRunePouch()
    {
        runeCount.put(ItemID.WATERRUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.DEATHRUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.BLOODRUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.SOULRUNE, Integer.MAX_VALUE);
    }

    private void addUnlimitedRunes()
    {
        final Set<Integer> allRuneIds = RuneIds.getAllRuneIds();
        allRuneIds.forEach(id -> runeCount.put(id, Integer.MAX_VALUE));
    }

    private void updateRuneCount(int runeId, int quantity)
    {
        final Integer currentValue = runeCount.getOrDefault(runeId, null);
        final long expectedValue = currentValue != null ? (long)currentValue + (long)quantity : (long)quantity;

        if (expectedValue >= Integer.MAX_VALUE)
        {
            runeCount.put(runeId, Integer.MAX_VALUE);
        }
        else
        {
            runeCount.put(runeId, (int)expectedValue);
        }
    }

    private Map<Integer, Integer> calculateRuneChangesMap(Map<Integer, Integer> oldRunes, Map<Integer, Integer> newRunes)
    {
        final Map<Integer, Integer> changeMap = new HashMap<>();
        final Set<Integer> runeKeys = new HashSet<>(oldRunes.keySet());
        runeKeys.addAll(newRunes.keySet());

        for (Integer runeId : runeKeys)
        {
            final int oldQuantity = oldRunes.getOrDefault(runeId, 0);
            final int newQuantity = newRunes.getOrDefault(runeId, 0);
            final int change = newQuantity - oldQuantity;

            if (change != 0)
                changeMap.put(runeId, change);
        }

        return changeMap;
    }

    private SpellInfo getEnchantSpellCast(Map<Integer, Integer> changes)
    {
        for (int itemId : changes.keySet())
        {
            final int change = changes.get(itemId);
            final SpellInfo enchant = SpellIds.getSpellByProduct(itemId, change);

            if (enchant != null)
                return enchant;
        }

        return null;
    }

    private void resetRuneCount()
    {
        runeCount.clear();
    }

    private boolean isRelevantItemContainer(ItemContainer container)
    {
        return container == client.getItemContainer(InventoryID.INV)
            || container == client.getItemContainer(InventoryID.WORN);
    }

    private boolean isRelevantVarbit(int varbitId)
    {
        return varbitId == VarbitID.FOUNTAIN_OF_RUNE_ACTIVE ||
            Arrays.stream(RUNE_POUCH_RUNE_VARBITS).anyMatch(v -> v == varbitId) ||
            Arrays.stream(RUNE_POUCH_AMOUNT_VARBITS).anyMatch(v -> v == varbitId);
    }
}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Model.SpellFilterOption;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(RemainingCastsPlugin.CONFIG_GROUP)
public interface RemainingCastsConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "Enable/disable Remaining Casts features",
			position = 0
	)
	String generalSection = "general";

	@ConfigSection(
			name = "Infoboxes",
			description = "Options relating to remaining casts infoboxes",
			position = 1
	)
	String infoboxSection = "infoboxes";

	@ConfigSection(
			name = "Chat warnings",
			description = "Options relating to remaining casts chat warnings",
			position = 2
	)
	String warningsSection = "warnings";

	@ConfigItem(
			keyName = "enableInfoboxes",
			name = "Show infoboxes",
			description = "Show remaining casts as individual info boxes",
			section = generalSection,
			position = 0
	)
	default boolean enableInfoboxes()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableMenuTooltip",
		name = "Show on menu tooltip",
		description = "Show remaining casts on the menu action tooltip",
		section = generalSection,
		position = 1
	)
	default boolean enableMenuTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableSpellTooltip",
			name = "Show on spell tooltip",
			description = "Show remaining casts on the detailed spell tooltip",
			section = generalSection,
			position = 2
	)
	default boolean enableSpellTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableChatWarnings",
			name = "Show chat warnings",
			description = "Show chat warnings when remaining casts reach a predefined amount",
			section = generalSection,
			position = 3
	)
	default boolean useChatWarnings() { return true;}

	@ConfigItem(
			keyName = "shortenCastAmounts",
			name = "Shorten cast amounts",
			description = "Shorten remaining cast amounts (e.g. 2512 -> 2.5k)",
			section = generalSection,
			position = 4
	)
	default boolean shortenCastAmounts()
	{
		return true;
	}

	@Units(Units.SECONDS)
	@ConfigItem(
			keyName = "infoBoxExpirySeconds",
			name = "Infobox expiry",
			description = "The number of seconds until an infobox will expire - 0 represents no expiry",
			section = infoboxSection,
			position = 5
	)
	default int infoBoxExpirySeconds()
	{
		return 15;
	}


	@ConfigItem(
			keyName = "infoBoxSpellLimit",
			name = "Maximum spells",
			description = "The maximum number of spells to track remaining casts for - 0 represents no limit",
			section = infoboxSection,
			position = 6
	)
	default int infoBoxSpellLimit()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "infoBoxThreshold",
			name = "Cast threshold",
			description = "Only show when casts remaining is less than the threshold - 0 represents no threshold",
			section = infoboxSection,
			position = 7
	)
	default int infoBoxThreshold()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "showDetailedTooltip",
			name = "Show cost in tooltip",
			description = "Show the spell's rune cost within the infobox tooltip",
			section = infoboxSection,
			position = 8
	)
	default boolean showDetailedTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showInfoBoxSprites",
			name = "Show spell sprites",
			description = "Show the sprite image for the spell on the infobox",
			section = infoboxSection,
			position = 9
	)
	default boolean showInfoBoxSprites()
	{
		return true;
	}

	@ConfigItem(
			keyName = "spellFilterOption",
			name = "Spell filter",
			description = "Enable or disable whitelist/blacklist for spells",
			section = infoboxSection,
			position = 10
	)
	default SpellFilterOption spellFilterOption()
	{
		return SpellFilterOption.DISABLED;
	}

	@ConfigItem(
			keyName = "filterList",
			name = "Filter list",
			description = "The names of the spells you wish to whitelist/blacklist as comma separated values",
			section = infoboxSection,
			position = 11
	)
	default String filterList()
	{
		return "";
	}

	@ConfigItem(
			keyName = "pinnedSpells",
			name = "Pinned spells",
			description = "The names of the spells that should always display an infobox which never expires",
			section = infoboxSection,
			position = 12
	)
	default String pinnedSpells()
	{
		return "";
	}

	@ConfigItem(
			keyName = "pinnedSpells",
			name = "",
			description = ""
	)
	void setPinnedSpells(String playerName);

	@ConfigItem(
			keyName = "infoBoxTextColor",
			name = "Text color",
			description = "The color of the text displayed in the infobox",
			section = infoboxSection,
			position = 13
	)
	default Color infoBoxTextColor()
	{
		return Color.white;
	}

	@ConfigItem(
			keyName = "chatWarningNotification",
			name = "Enable notifications",
			description = "Enable Runelite notification alongside the chat warning",
			section = warningsSection,
			position = 14
	)
	default boolean useChatWarningNotifications()
	{
		return true;
	}

	@ConfigItem(
			keyName = "chatWarningThresholds",
			name = "Chat warning thresholds",
			description = "The cast amounts at which a chat warning will be triggered",
			section = warningsSection,
			position = 15
	)
	default String chatWarningThresholds()
	{
		return "0, 10, 50, 100, 500";
	}

	@ConfigItem(
			keyName = "chatWarningColor",
			name = "Text color",
			description = "The color of the text displayed in the chat warning",
			section = warningsSection,
			position = 16
	)
	default Color chatWarningColor()
	{
		return Color.orange;
	}

}

package com.salverrs.RemainingCasts.Events;

import com.salverrs.RemainingCasts.Model.RuneChanges;
import lombok.Getter;

@Getter
public class RunesChanged {
    private RuneChanges changes;

    public RunesChanged(RuneChanges changes)
    {
        this.changes = changes;
    }
}

package com.salverrs.RemainingCasts.Events;

import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import lombok.Getter;

@Getter
public class BoltsEnchanted {
    private SpellInfo enchantSpell;

    private RuneChanges changes;

    public BoltsEnchanted(SpellInfo enchantSpell, RuneChanges changes)
    {
        this.enchantSpell = enchantSpell;
        this.changes = changes;
    }
}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class TooltipDetails {
    private String spellName;
    private String spellLevel;

    public TooltipDetails(String name, String level)
    {
        this.spellName = name;
        this.spellLevel = level;
    }

}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class SpellProduct {
    public int itemId;
    public int quantity;

    public SpellProduct(int id, int quantity)
    {
        this.itemId = id;
        this.quantity = quantity;
    }

    @Override
    public int hashCode()
    {
        return itemId * quantity * 31;
    }

    @Override
    public boolean equals(Object o)
    {
        if (o == this)
            return true;

        if (!(o instanceof SpellProduct))
            return false;

        return this.hashCode() == o.hashCode();
    }
}

package com.salverrs.RemainingCasts.Model;

public enum SpellFilterOption {
    DISABLED,
    BLACKLIST,
    WHITELIST
}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@Getter
public class RuneChanges {

    private Map<Integer, Integer> changes;
    private Map<Integer, Integer> currentRunes;
    private Set<Integer> unlimitedRunes;

    public RuneChanges(Map<Integer, Integer> changes, Map<Integer, Integer> currentRunes, Set<Integer> unlimitedRunes)
    {
        this.changes = changes;
        this.currentRunes = currentRunes;
        this.unlimitedRunes = unlimitedRunes;
    }

    public Map<Integer, Integer> getInvertedChanges()
    {
        Map<Integer, Integer> costMap = new HashMap<>(changes);
        costMap.replaceAll((k,v) -> v * -1);
        return costMap;
    }

}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class SpellInfo {
    private String name;
    private int spriteId;
    private SpellCost spellCost;
    private SpellProduct[] spellProducts;

    public SpellInfo(String name, int spriteId, SpellCost spellCost, SpellProduct... products)
    {
        this(name, spriteId, spellCost);
        this.spellProducts = products;
    }

    public SpellInfo(String name, int spriteId, SpellCost spellCost)
    {
        this.name = name;
        this.spriteId = spriteId;
        this.spellCost = spellCost;
    }

}

package com.salverrs.RemainingCasts.Model;

import com.salverrs.RemainingCasts.Util.RuneIds;
import lombok.Getter;

import java.util.*;

@Getter
public class SpellCost {
    private final int[] runes;
    private final int[] quantities;

    public SpellCost(int[] runeIds, int[] quantities)
    {
        if (runeIds.length != quantities.length)
            throw new IndexOutOfBoundsException();

        this.runes = runeIds;
        this.quantities = quantities;
    }

    public boolean matchesCost(Map<Integer, Integer> runeCount, Set<Integer> unlimitedRunes)
    {
        for (int i = 0; i < runes.length; i++)
        {
            final int targetRuneId = runes[i];
            if (!unlimitedRunes.contains(targetRuneId) && (!runeCount.containsKey(targetRuneId) || runeCount.get(targetRuneId) < quantities[i]))
                return false;
        }

        return true;
    }

    public int getRemainingCasts(Map<Integer, Integer> runeCount)
    {
        final List<Integer> castsPerRune = new ArrayList<Integer>();
        for (int i = 0; i < runes.length; i++)
        {
            final int targetRuneId = runes[i];
            if (runeCount.containsKey(targetRuneId))
            {
                final int available = runeCount.get(targetRuneId);
                final int cost = quantities[i];
                final boolean isReqStaff = available >= 1 && RuneIds.isReqStaff(targetRuneId);

                if (available == Integer.MAX_VALUE || isReqStaff)
                {
                    castsPerRune.add(Integer.MAX_VALUE);
                }
                else
                {
                    castsPerRune.add(Math.floorDiv(available, cost));
                }
            }
            else
            {
                return 0;
            }
        }

        return Collections.min(castsPerRune);
    }

}


package com.salverrs.RemainingCasts.Infobox;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.RemainingCastsConfig;
import com.salverrs.RemainingCasts.Util.CastUtils;
import com.salverrs.RemainingCasts.Util.RuneIds;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.Map;

@Getter
public class RemainingCastsInfoBox extends InfoBox
{
    private final SpellInfo spellInfo;
    private final SpellCost spellCost;
    private final RemainingCastsConfig config;
    private final String[] runeNames;
    private String tooltip = "";
    private Map<Integer, Integer> runeCount;
    private int remainingCasts;
    private long lastUpdated;
    private boolean advTooltipDisabled = false;
    @Setter
    private boolean isPinned;

    public RemainingCastsInfoBox(SpellInfo spellInfo, Map<Integer, Integer> runeCount, BufferedImage image, Plugin plugin, RemainingCastsConfig config, ItemManager itemManager)
    {
        super(image, plugin);
        this.spellInfo = spellInfo;
        this.spellCost = spellInfo.getSpellCost();
        this.lastUpdated = Instant.now().getEpochSecond();
        this.runeCount = runeCount;
        this.remainingCasts = this.spellCost.getRemainingCasts(runeCount);
        this.config = config;

        final int[] runes = spellCost.getRunes();
        this.runeNames = new String[runes.length];
        for (int i = 0; i < runes.length; i++)
        {
            this.runeNames[i] = itemManager.getItemComposition(runes[i]).getName();
            if (this.runeNames[i] == null || this.runeNames[i].equals(""))
            {
                advTooltipDisabled = true;
                break;
            }
        }

        buildTooltip();
    }

    @Override
    public String getText()
    {
        return getRemainingCastsString();
    }

    @Override
    public String getTooltip()
    {
        return tooltip;
    }

    @Override
    public Color getTextColor()
    {
        return config.infoBoxTextColor();
    }

    public void update(Map<Integer, Integer> runeCount)
    {
        update(runeCount, false);
    }

    public void update(Map<Integer, Integer> runeCount, boolean wasCast)
    {
        this.runeCount = runeCount;
        remainingCasts = spellCost.getRemainingCasts(runeCount);
        buildTooltip();

        if (wasCast)
            lastUpdated = Instant.now().getEpochSecond();
    }

    public long getActiveTime()
    {
        return (Instant.now().getEpochSecond() - lastUpdated);
    }

    public void resetActiveTime()
    {
        this.lastUpdated = 0;
    }

    private String getRemainingCastsString()
    {
        if (remainingCasts == -1)
            return "N/A";

        return config.shortenCastAmounts() ? CastUtils.getShortenedAmount(remainingCasts) : CastUtils.formatCastAmount(remainingCasts);
    }

    private void buildTooltip()
    {
        String base = spellInfo.getName() + " - " + (remainingCasts != Integer.MAX_VALUE ? remainingCasts : "Unlimited");
        base += (remainingCasts != 1 ? " casts " : " cast ") + "remaining";

        if (!config.showDetailedTooltip() || advTooltipDisabled)
        {
            tooltip = base;
            return;
        }

        StringBuilder advTooltip = new StringBuilder(base + "</br>");
        final int[] runes = spellCost.getRunes();
        final int[] quantities = spellCost.getQuantities();
        for (int i = 0; i < runes.length; i++)
        {
            final int runeId = runes[i];
            final int quantity = quantities[i];
            final int available = runeCount.getOrDefault(runeId, 0);
            final int floorDiv = getCostDivision(runeId, quantity, available);
            final String runeName = runeNames[i];
            if (runeName == null || runeName.equals(""))
            {
                tooltip = base;
                return;
            }

            advTooltip.append("</br>")
                    .append(runeName)
                    .append(": ")
                    .append(available != Integer.MAX_VALUE ? available : "*")
                    .append("/")
                    .append(quantity);

            if (available != Integer.MAX_VALUE && floorDiv != Integer.MAX_VALUE)
            {
                advTooltip.append(" (")
                    .append(floorDiv)
                    .append(")");
            }
        }

        tooltip = advTooltip.toString();
    }

    private int getCostDivision(int itemId, int cost, int available)
    {
        if (available == Integer.MAX_VALUE || (available >= 1 && RuneIds.isReqStaff(itemId)))
            return Integer.MAX_VALUE;

        return cost != 0 && available != 0 ? Math.floorDiv(available, cost) : 0;
    }

}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Events.BoltsEnchanted;
import com.salverrs.RemainingCasts.Events.RunesChanged;
import com.salverrs.RemainingCasts.Infobox.RemainingCastsInfoBox;
import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellFilterOption;
import com.salverrs.RemainingCasts.Util.SpellIds;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.*;

@Singleton
public class RemainingCastTracker {

    private Map<SpellInfo, RemainingCastsInfoBox> castBoxes = new HashMap<>();
    private Queue<SpellInfo> spellQueue = new LinkedList<>();
    private Map<Integer, Integer> runeCount = new HashMap<>();
    private boolean active = false;
    private boolean otherItemContainerOpen = false;
    private int lastCastSpriteId = -1;
    private String lastCastSpellName;
    private Plugin plugin;

    private long lastSpellCastTime = 0;
    private long lastManualCastSpellTime = 0;
    private long lastManualAttackTime = 0;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private Notifier notifier;
    @Inject
    private ChatMessageManager chatManager;
    @Inject
    private CastSuppliesTracker suppliesTracker;
    @Inject
    private SpriteManager spriteManager;
    @Inject
    private InfoBoxManager infoBoxManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private RemainingCastsConfig config;

    @Subscribe
    public void onClientTick(ClientTick tick)
    {
        if (!active)
            return;

        checkCastBoxExpiry();
    }

    @Subscribe
    public void onRunesChanged(RunesChanged event)
    {
        if (!active || (!config.enableInfoboxes() && !config.useChatWarnings()))
            return;

        final RuneChanges changes = event.getChanges();
        SpellInfo spellInfo = getLastSpellCasted(changes);

        if (otherItemContainerOpen || client.getGameState() != GameState.LOGGED_IN) // Ignore all item deposits
            spellInfo = null;

        runeCount = changes.getCurrentRunes();
        lastSpellCastTime = Instant.now().getEpochSecond();

        if (config.enableInfoboxes())
            updateCastBoxes(spellInfo);

        if (config.useChatWarnings())
            updateWarnings(spellInfo);

        if (!config.enableInfoboxes() || spellInfo == null || isFiltered(spellInfo))
            return;

        processCast(spellInfo);
    }

    @Subscribe
    public void onBoltsEnchanted(BoltsEnchanted event)
    {
        if (!active || (!config.enableInfoboxes() && !config.useChatWarnings()) || client.getGameState() != GameState.LOGGED_IN)
            return;

        final RuneChanges changes = event.getChanges();
        SpellInfo enchant = event.getEnchantSpell();

        if (!matchesSpellInfo(enchant, changes) || otherItemContainerOpen)
            enchant = null;

        runeCount = changes.getCurrentRunes();

        if (config.enableInfoboxes())
            updateCastBoxes(enchant);

        if (config.useChatWarnings())
            updateWarnings(enchant);

        if (!config.enableInfoboxes() || enchant == null || isFiltered(enchant))
            return;

        processCast(enchant);
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (!active)
            return;

        final MenuEntry entry = event.getMenuEntry();
        final String option = entry.getOption();
        final String target = entry.getTarget();

        if (option.equals("Attack"))
        {
            lastManualAttackTime = Instant.now().getEpochSecond(); // Autocast attack option
            return;
        }

        if (!option.equals("Cast") && !target.contains("Teleport"))
            return;

        final Widget widget = entry.getWidget();
        final String spellName = widget != null ?  Text.removeFormattingTags(widget.getName())
                : Text.removeFormattingTags(target).replaceAll(" ->.*", "");

        if (SpellIds.getSpellByName(spellName) != null)
            lastCastSpellName = spellName;

        if (widget == null || widget.getTargetVerb().isEmpty()) // Spell actually cast, not just selected
            lastManualCastSpellTime = Instant.now().getEpochSecond();

        if (widget == null)
            return;

        final int spriteId = widget.getSpriteId();
        if (SpellIds.getSpellBySpriteId(spriteId) != null)
            lastCastSpriteId = spriteId;
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (isOtherItemContainerWidget(event.getGroupId()))
        {
            otherItemContainerOpen = true;
            lastCastSpriteId = -1;
            lastCastSpellName = null;
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        if (isOtherItemContainerWidget(event.getGroupId()))
        {
            otherItemContainerOpen = false;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        if (!configChanged.getGroup().equals(RemainingCastsPlugin.CONFIG_GROUP))
            return;

        if (configChanged.getKey().equals("enableInfoboxes"))
        {
            stop();
            start(plugin);
        }
        else
        {
            if (config.enableInfoboxes())
                updatePinnedSpells();
        }
    }

    public void start(Plugin plugin)
    {
        active = true;
        this.plugin = plugin;

        if (config.enableInfoboxes())
            updatePinnedSpells();
    }

    public void stop()
    {
        active = false;
        lastCastSpriteId = -1;
        lastCastSpellName = null;
        removeAllCastBoxes();
    }

    private SpellInfo getLastSpellCasted(RuneChanges changes)
    {
        final boolean autoCastFirst = wasLastCastAutocast();

        if (autoCastFirst) // There is probably a cleaner way to do this
        {
            SpellInfo spellInfo = getSpellFromAutocast(changes);
            if (spellInfo != null)
                return spellInfo;

            spellInfo = getSpellFromManualCast(changes);
            if (spellInfo != null)
                return spellInfo;
        }
        else
        {
            SpellInfo spellInfo = getSpellFromManualCast(changes);
            if (spellInfo != null)
                return spellInfo;

            spellInfo = getSpellFromAutocast(changes);
            if (spellInfo != null)
                return spellInfo;
        }

        return null;
    }

    private boolean matchesSpellInfo(SpellInfo info, RuneChanges changes)
    {
        final Map<Integer, Integer> cost = changes.getInvertedChanges();
        return info != null && info.getSpellCost().matchesCost(cost, changes.getUnlimitedRunes());
    }

    private SpellInfo getSpellFromManualCast(RuneChanges changes) // Name lookup now default since resizable sprite changes
    {
        SpellInfo spellInfo = lastCastSpellName != null ? SpellIds.getSpellByName(lastCastSpellName) : null;
        if (matchesSpellInfo(spellInfo, changes))
            return spellInfo;

        spellInfo = lastCastSpriteId != -1 ? SpellIds.getSpellBySpriteId(lastCastSpriteId) : null;
        if (matchesSpellInfo(spellInfo, changes))
            return spellInfo;

        return null;
    }

    private SpellInfo getSpellFromAutocast(RuneChanges changes)
    {
        final Widget w = client.getWidget(InterfaceID.CombatInterface.NORMAL_CONTAINER_GRAPHIC0);
        if (w == null)
            return null;

        final int spriteId = w.getSpriteId();
        final SpellInfo spellInfo = SpellIds.getSpellBySpriteId(spriteId);

        return matchesSpellInfo(spellInfo, changes) ? spellInfo : null;
    }

    private boolean wasLastCastAutocast()
    {
        if (lastManualAttackTime > lastManualCastSpellTime)
            return true;

        return lastManualCastSpellTime < lastSpellCastTime;
    }

    private void updateWarnings(SpellInfo recentCast)
    {
        if (recentCast == null)
            return;

        final List<Integer> thresholds = new ArrayList<>();
        final List<String> thresholdStrings = Text.fromCSV(config.chatWarningThresholds());
        thresholdStrings.forEach(ts -> thresholds.add(tryParseInt(ts, -1)));
        Collections.sort(thresholds);

        if (thresholds.size() == 0)
            return;

        final int remaining = recentCast.getSpellCost().getRemainingCasts(runeCount);

        for (int val : thresholds)
        {
            if (remaining == val)
            {
                final String msgContent = getWarningMessage(recentCast.getName(), val);

                final String msg = new ChatMessageBuilder()
                        .append(ChatColorType.NORMAL)
                        .append(config.chatWarningColor(), msgContent)
                        .build();

                chatManager.queue(QueuedMessage.builder()
                        .type(ChatMessageType.GAMEMESSAGE)
                        .name(RemainingCastsPlugin.CONFIG_GROUP)
                        .runeLiteFormattedMessage(msg)
                        .build());

                if (config.useChatWarningNotifications())
                    notifier.notify(msgContent);

                break;
            }

        }
    }

    private String getWarningMessage(String spellName, int casts)
    {
        String message = spellName + " has " + (casts == 0 ? "no" : casts);
        message += (casts == 1 ? " cast " : " casts ") + "remaining.";

        return message;
    }

    private void updateCastBoxes(SpellInfo recentCast)
    {
        final int threshold = config.infoBoxThreshold();
        final List<SpellInfo> toRemove = new ArrayList<>();

        if (recentCast != null && castBoxes.containsKey(recentCast))
        {
            final RemainingCastsInfoBox infoBox = castBoxes.get(recentCast);
            infoBox.update(runeCount, true);
        }

        castBoxes.values().forEach(c ->
        {
            if (threshold != 0 && c.getRemainingCasts() > threshold)
                toRemove.add(c.getSpellInfo());
            else
                c.update(runeCount);
        });

        toRemove.forEach(this::removeCastBox);
    }

    private void processCast(SpellInfo spellInfo)
    {
        if (!castBoxes.containsKey(spellInfo))
            createRemainingCastsBox(spellInfo, false);
    }

    private RemainingCastsInfoBox createRemainingCastsBox(SpellInfo spellInfo, boolean isPinned)
    {
        final BufferedImage sprite = config.showInfoBoxSprites()
                ? spriteManager.getSprite(spellInfo.getSpriteId(), 0)
                : getSpellBookSprite();

        final int threshold = config.infoBoxThreshold();
        final int remainingCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
        if (!isPinned && threshold != 0 && remainingCasts > threshold)
            return null;

        final RemainingCastsInfoBox infoBox = new RemainingCastsInfoBox(spellInfo, runeCount, sprite, plugin, config, itemManager);
        infoBox.setPinned(isPinned);
        infoBoxManager.addInfoBox(infoBox);
        castBoxes.put(spellInfo, infoBox);

        if (isPinned)
        {
            infoBox.resetActiveTime();
        }
        else
        {
            spellQueue.add(spellInfo);
        }

        checkCastBoxLimit();
        return infoBox;
    }

    private void checkCastBoxLimit()
    {
        if (spellQueue.size() == 0 || config.infoBoxSpellLimit() <= 0)
            return;

        if (spellQueue.size() > config.infoBoxSpellLimit())
        {
            final SpellInfo oldest = spellQueue.peek();
            removeCastBox(oldest);
        }
    }

    private void checkCastBoxExpiry()
    {
        final int expirySeconds = config.infoBoxExpirySeconds();
        if (expirySeconds == 0)
            return;

        final List<SpellInfo> expired = new ArrayList<>();
        for (final SpellInfo spellInfo : castBoxes.keySet())
        {
            final RemainingCastsInfoBox box = castBoxes.get(spellInfo);
            if (!box.isPinned() && box.getActiveTime() > expirySeconds)
                expired.add(spellInfo);
        }

        expired.forEach(this::removeCastBox);
    }

    private void updatePinnedSpells()
    {
        final String pinned = config.pinnedSpells();
        final List<String> spellNames = Text.fromCSV(pinned);

        clientThread.invoke(() ->
        {
            castBoxes.values().forEach(cb -> cb.setPinned(false));

            if (spellNames.size() == 0)
                return;

            spellNames.forEach(name ->
            {
                final SpellInfo info = SpellIds.getSpellByName(name);
                if (info == null)
                    return;

                RemainingCastsInfoBox box = castBoxes.getOrDefault(info, null);
                if (box != null)
                {
                    box.setPinned(true);
                }
                else
                {
                    box = createRemainingCastsBox(info, true);
                    if (box != null)
                        box.setPinned(true);
                }
            });
        });
    }

    private void removeCastBox(SpellInfo spellInfo)
    {
        if (!castBoxes.containsKey(spellInfo))
            return;

        final RemainingCastsInfoBox box = castBoxes.get(spellInfo);
        infoBoxManager.removeInfoBox(box);
        castBoxes.remove(spellInfo);
        spellQueue.remove(spellInfo);
    }

    private void removeAllCastBoxes()
    {
        infoBoxManager.removeIf(i -> i instanceof RemainingCastsInfoBox);
        castBoxes.clear();
        spellQueue.clear();
    }

    private boolean isFiltered(SpellInfo spellInfo)
    {
        if (config.spellFilterOption() == SpellFilterOption.DISABLED)
            return false;

        final String filterList = config.filterList();
        final List<String> spellNames = Text.fromCSV(filterList);

        if (config.spellFilterOption() == SpellFilterOption.BLACKLIST)
        {
            return spellNames.stream().anyMatch(s -> spellInfo.getName().equalsIgnoreCase(s));
        }
        else if (config.spellFilterOption() == SpellFilterOption.WHITELIST)
        {
            return spellNames.stream().noneMatch(s -> spellInfo.getName().equalsIgnoreCase(s));
        }

        return false;
    }

    private BufferedImage getSpellBookSprite()
    {
        final Widget spellBook = client.getWidget(InterfaceID.ToplevelOsrsStretch.ICON6);
        return spellBook != null ? spriteManager.getSprite(spellBook.getSpriteId(), 0)
                : spriteManager.getSprite(SpriteID.SideiconsInterface.MAGIC, 0);
    }

    private boolean isOtherItemContainerWidget(int groupId)
    {
        switch (groupId)
        {
			case InterfaceID.BANKMAIN:
			case InterfaceID.BANK_DEPOSITBOX:
			case InterfaceID.TRADEMAIN:
			case InterfaceID.SHARED_BANK:
                return true;
            default:
                return false;
        }
    }

    public int tryParseInt(String value, int defaultVal) {
        try
        {
            return Integer.parseInt(value);
        }
        catch (NumberFormatException e)
        {
            return defaultVal;
        }
    }


}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Model.TooltipDetails;
import com.salverrs.RemainingCasts.Util.CastUtils;
import com.salverrs.RemainingCasts.Util.SpellIds;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.ScriptEvent;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.function.Consumer;

@Singleton
public class TooltipCastUpdater {

    private int mageBookTooltipWidgetId = -1;
    private int autocastTooltipWidgetId = -1;
    private boolean active = false;
    private ArrayList<String> pinnedSpellNames;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private CastSuppliesTracker castSuppliesTracker;
    @Inject RemainingCastsConfig config;

    public void start()
    {
        active = true;
        pinnedSpellNames = new ArrayList<>(Text.fromCSV(config.pinnedSpells()));
    }

    public void stop()
    {
        active = false;
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (!active || (!config.enableMenuTooltip() && !config.enableInfoboxes()) || client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
            return;

        final List<MenuEntry> entries = new ArrayList<>(Arrays.asList(client.getMenu().getMenuEntries()));
        boolean appendToOption = false;
        SpellInfo spellInfoFound = null;
        String formattedSpellInfoName = null;

        if (entries.stream().anyMatch(e -> e.getOption().equals("Examine")))
            return;

        for (MenuEntry entry : entries)
        {
            final Widget widget = entry.getWidget();
            if (widget == null)
                continue;

            // Autocast 'Choose spell' menu replacement
            if (entry.getOption().equals("Choose spell"))
            {
                final Widget spellIcon = client.getWidget(InterfaceID.CombatInterface.NORMAL_CONTAINER_GRAPHIC0);

                if (spellIcon == null)
                    continue;

                final int spriteId = spellIcon.getSpriteId();
                final SpellInfo spellInfo = SpellIds.getSpellBySpriteId(spriteId);

                if (spellInfo == null)
                    continue;

                spellInfoFound = spellInfo;
                formattedSpellInfoName = spellInfo.getName();

                if (config.enableMenuTooltip())
                {
                    final Map<Integer, Integer> runeCount = castSuppliesTracker.getLastRuneCount();
                    final int numCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
                    final String casts = "(" + getRemainingCastsString(numCasts) + ")";
                    entry.setOption(spellInfo.getName() + " " + casts);
                }

                continue;
            }

            // Spell book and autocast spell select menu replacement
            String spellName = Text.removeFormattingTags(widget.getName()); // Standard spell book interface
            SpellInfo spellInfo = SpellIds.getSpellByName(spellName);

            if (spellInfo == null) // Autocast fallback
            {
                spellName = Text.removeFormattingTags(entry.getOption()); // Autocast menu uses option only
                spellInfo = SpellIds.getSpellByName(spellName);
                formattedSpellInfoName = entry.getOption();
                appendToOption = true;
            }
            else
            {
                formattedSpellInfoName = entry.getTarget();
            }

            if (spellInfo == null)
                continue;

            spellInfoFound = spellInfo;

            if (!config.enableMenuTooltip()) // Continue if only using pin functionality
                continue;

            if (entry.getOption().equals("Configure") || entry.getOption().equals("Warnings")) // Ignore entries other than cast entries
                continue;

            final Map<Integer, Integer> runeCount = castSuppliesTracker.getLastRuneCount();
            final int numCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
            final String casts = "(" + getRemainingCastsString(numCasts) + ")";

            if (appendToOption)
            {
                final String option = entry.getOption();
                if (option.endsWith(casts))
                    continue;

                entry.setOption(option + " " + casts);
            }
            else
            {
                final String target = entry.getTarget();
                if (target.endsWith(casts))
                    continue;

                entry.setTarget(target + " " + casts);
            }
        }

        // Pin/Unpin infobox menu functionality
        if (spellInfoFound == null || !config.enableInfoboxes())
            return;

        final SpellInfo target = spellInfoFound;
        boolean isPinned = Text.fromCSV(config.pinnedSpells()).stream().anyMatch(s -> s.equalsIgnoreCase(target.getName()));

        client.getMenu().createMenuEntry(-1)
                .setOption(isPinned ? "Unpin" : "Pin")
                .setTarget(formattedSpellInfoName)
                .setType(MenuAction.RUNELITE)
                .onClick(isPinned ? unpinSpell(target) : pinSpell(target));
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event)
    {
        if (!active || !config.enableSpellTooltip())
            return;

        final boolean isMageBookTooltip = event.getScriptId() == 2622; // main spell tool tip
        final boolean isAutocastTooltip = event.getScriptId() == 238; // auto cast tooltip

        if (!isMageBookTooltip && !isAutocastTooltip)
            return;

        final ScriptEvent scriptEvent = event.getScriptEvent();
        final Object[] args = scriptEvent.getArguments();
        final int tooltipWidgetArgIndex = isMageBookTooltip ? 5 : 1;

        if (isMageBookTooltip)
            mageBookTooltipWidgetId = (int)args[tooltipWidgetArgIndex];
        else if (isAutocastTooltip)
            autocastTooltipWidgetId = (int)args[tooltipWidgetArgIndex];
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (!active || !config.enableSpellTooltip())
            return;

        final int scriptId = event.getScriptId();
        if (scriptId != 2622 && scriptId != 238)
            return;

        final int widgetId = scriptId == 2622 ? mageBookTooltipWidgetId : autocastTooltipWidgetId;

        clientThread.invoke(() ->
        {
            Widget widget = client.getWidget(widgetId);
            if (widget == null)
                return;

            Widget[] children = widget.getChildren();
            if (children == null || children.length == 0)
                return;

            final Widget spellTitle = getTitleWidget(children);
            if (spellTitle == null)
                return;

            final TooltipDetails details = getSpellTooltipDetails(spellTitle);
            if (details == null)
                return;

            if (details.getSpellName().contains("Home Teleport")) // For consistency
            {
                final String newText = "[" + details.getSpellLevel() + "] " + details.getSpellName();
                spellTitle.setText(newText);
                return;
            }

            SpellInfo spellInfo = SpellIds.getSpellByName(details.getSpellName());

            if (spellInfo == null)
                spellInfo = SpellIds.getSpellByName(details.getSpellName().concat(" Teleport")); // Normal Ancients compatibility ('Teleport' is not included in new spell tooltip)

            if (spellInfo == null)
                return;

            final SpellCost spellCost = spellInfo.getSpellCost();
            final int numCasts = spellCost.getRemainingCasts(castSuppliesTracker.getLastRuneCount());

            String newText = "[" + details.getSpellLevel() + "] " + details.getSpellName();
            newText += " (" + getRemainingCastsString(numCasts) + ")" ;

            spellTitle.setText(newText);
        });

    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        if (!configChanged.getGroup().equals(RemainingCastsPlugin.CONFIG_GROUP))
            return;

        pinnedSpellNames = new ArrayList<>(Text.fromCSV(config.pinnedSpells()));
    }

    private Widget getTitleWidget(Widget[] tooltipChildren)
    {
        return Arrays.stream(tooltipChildren)
                .filter(c -> c.getText().contains("Level"))
                .findFirst()
                .orElse(null);
    }

    private TooltipDetails getSpellTooltipDetails(Widget titleWidget)
    {
        final String titleText = titleWidget.getText();
        final String[] split = titleText.split(": ");
        if (split.length < 2)
            return null;

        final String name = split[1];
        final String[] levelSplit = split[0].split("Level ");
        if (levelSplit.length < 2)
            return null;

        final String level = levelSplit[1];
        return new TooltipDetails(name, level);
    }

    private String getRemainingCastsString(int numCasts)
    {
        if (numCasts == -1)
            return "N/A";

        return config.shortenCastAmounts() ? CastUtils.getShortenedAmount(numCasts) : CastUtils.formatCastAmount(numCasts);
    }

    private Consumer<MenuEntry> pinSpell(SpellInfo spellInfo)
    {
        return e ->
        {
            pinnedSpellNames.add(spellInfo.getName());
            config.setPinnedSpells(Text.toCSV(pinnedSpellNames));
        };
    }

    private Consumer<MenuEntry> unpinSpell(SpellInfo spellInfo)
    {
        return e ->
        {
            pinnedSpellNames.removeIf(s -> s.equalsIgnoreCase(spellInfo.getName()));
            config.setPinnedSpells(Text.toCSV(pinnedSpellNames));
        };
    }

}

package com.salverrs.RemainingCasts;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RemainingCastsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RemainingCastsPlugin.class);
		RuneLite.main(args);
	}
}
