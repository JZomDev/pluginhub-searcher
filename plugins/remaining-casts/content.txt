package com.salverrs.RemainingCasts;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RemainingCastsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RemainingCastsPlugin.class);
		RuneLite.main(args);
	}
}
package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Events.BoltsEnchanted;
import com.salverrs.RemainingCasts.Events.RunesChanged;
import com.salverrs.RemainingCasts.Infobox.RemainingCastsInfoBox;
import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellFilterOption;
import com.salverrs.RemainingCasts.Util.SpellIds;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import net.runelite.api.*;
import net.runelite.api.events.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetID;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.*;

@Singleton
public class RemainingCastTracker {

    private Map<SpellInfo, RemainingCastsInfoBox> castBoxes = new HashMap<>();
    private Queue<SpellInfo> spellQueue = new LinkedList<>();
    private Map<Integer, Integer> runeCount = new HashMap<>();
    private boolean active = false;
    private boolean otherItemContainerOpen = false;
    private int lastCastSpriteId = -1;
    private String lastCastSpellName;
    private Plugin plugin;

    private long lastSpellCastTime = 0;
    private long lastManualCastSpellTime = 0;
    private long lastManualAttackTime = 0;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private Notifier notifier;
    @Inject
    private ChatMessageManager chatManager;
    @Inject
    private CastSuppliesTracker suppliesTracker;
    @Inject
    private SpriteManager spriteManager;
    @Inject
    private InfoBoxManager infoBoxManager;
    @Inject
    private ItemManager itemManager;
    @Inject
    private RemainingCastsConfig config;

    @Subscribe
    public void onClientTick(ClientTick tick)
    {
        if (!active)
            return;

        checkCastBoxExpiry();
    }

    @Subscribe
    public void onRunesChanged(RunesChanged event)
    {
        if (!active || (!config.enableInfoboxes() && !config.useChatWarnings()))
            return;

        final RuneChanges changes = event.getChanges();
        SpellInfo spellInfo = getLastSpellCasted(changes);

        if (otherItemContainerOpen || client.getGameState() != GameState.LOGGED_IN) // Ignore all item deposits
            spellInfo = null;

        runeCount = changes.getCurrentRunes();
        lastSpellCastTime = Instant.now().getEpochSecond();

        if (config.enableInfoboxes())
            updateCastBoxes(spellInfo);

        if (config.useChatWarnings())
            updateWarnings(spellInfo);

        if (!config.enableInfoboxes() || spellInfo == null || isFiltered(spellInfo))
            return;

        processCast(spellInfo);
    }

    @Subscribe
    public void onBoltsEnchanted(BoltsEnchanted event)
    {
        if (!active || (!config.enableInfoboxes() && !config.useChatWarnings()) || client.getGameState() != GameState.LOGGED_IN)
            return;

        final RuneChanges changes = event.getChanges();
        SpellInfo enchant = event.getEnchantSpell();

        if (!matchesSpellInfo(enchant, changes) || otherItemContainerOpen)
            enchant = null;

        runeCount = changes.getCurrentRunes();

        if (config.enableInfoboxes())
            updateCastBoxes(enchant);

        if (config.useChatWarnings())
            updateWarnings(enchant);

        if (!config.enableInfoboxes() || enchant == null || isFiltered(enchant))
            return;

        processCast(enchant);
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event)
    {
        if (!active)
            return;

        final MenuEntry entry = event.getMenuEntry();
        final String option = entry.getOption();
        final String target = entry.getTarget();

        if (option.equals("Attack"))
        {
            lastManualAttackTime = Instant.now().getEpochSecond(); // Autocast attack option
            return;
        }

        if (!option.equals("Cast") && !target.contains("Teleport"))
            return;

        final Widget widget = entry.getWidget();
        final String spellName = widget != null ?  Text.removeFormattingTags(widget.getName())
                : Text.removeFormattingTags(target).replaceAll(" ->.*", "");

        if (SpellIds.getSpellByName(spellName) != null)
            lastCastSpellName = spellName;

        if (widget == null || widget.getTargetVerb().isEmpty()) // Spell actually cast, not just selected
            lastManualCastSpellTime = Instant.now().getEpochSecond();

        if (widget == null)
            return;

        final int spriteId = widget.getSpriteId();
        if (SpellIds.getSpellBySpriteId(spriteId) != null)
            lastCastSpriteId = spriteId;
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event)
    {
        if (isOtherItemContainerWidget(event.getGroupId()))
        {
            otherItemContainerOpen = true;
            lastCastSpriteId = -1;
            lastCastSpellName = null;
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event)
    {
        if (isOtherItemContainerWidget(event.getGroupId()))
        {
            otherItemContainerOpen = false;
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        if (!configChanged.getGroup().equals(RemainingCastsPlugin.CONFIG_GROUP))
            return;

        if (configChanged.getKey().equals("enableInfoboxes"))
        {
            stop();
            start(plugin);
        }
        else
        {
            if (config.enableInfoboxes())
                updatePinnedSpells();
        }
    }

    public void start(Plugin plugin)
    {
        active = true;
        this.plugin = plugin;

        if (config.enableInfoboxes())
            updatePinnedSpells();
    }

    public void stop()
    {
        active = false;
        lastCastSpriteId = -1;
        lastCastSpellName = null;
        removeAllCastBoxes();
    }

    private SpellInfo getLastSpellCasted(RuneChanges changes)
    {
        final boolean autoCastFirst = wasLastCastAutocast();

        if (autoCastFirst) // There is probably a cleaner way to do this
        {
            SpellInfo spellInfo = getSpellFromAutocast(changes);
            if (spellInfo != null)
                return spellInfo;

            spellInfo = getSpellFromManualCast(changes);
            if (spellInfo != null)
                return spellInfo;
        }
        else
        {
            SpellInfo spellInfo = getSpellFromManualCast(changes);
            if (spellInfo != null)
                return spellInfo;

            spellInfo = getSpellFromAutocast(changes);
            if (spellInfo != null)
                return spellInfo;
        }

        return null;
    }

    private boolean matchesSpellInfo(SpellInfo info, RuneChanges changes)
    {
        final Map<Integer, Integer> cost = changes.getInvertedChanges();
        return info != null && info.getSpellCost().matchesCost(cost, changes.getUnlimitedRunes());
    }

    private SpellInfo getSpellFromManualCast(RuneChanges changes) // Name lookup now default since resizable sprite changes
    {
        SpellInfo spellInfo = lastCastSpellName != null ? SpellIds.getSpellByName(lastCastSpellName) : null;
        if (matchesSpellInfo(spellInfo, changes))
            return spellInfo;

        spellInfo = lastCastSpriteId != -1 ? SpellIds.getSpellBySpriteId(lastCastSpriteId) : null;
        if (matchesSpellInfo(spellInfo, changes))
            return spellInfo;

        return null;
    }

    private SpellInfo getSpellFromAutocast(RuneChanges changes)
    {
        final Widget w = client.getWidget(WidgetInfo.COMBAT_SPELL_ICON);
        if (w == null)
            return null;

        final int spriteId = w.getSpriteId();
        final SpellInfo spellInfo = SpellIds.getSpellBySpriteId(spriteId);

        return matchesSpellInfo(spellInfo, changes) ? spellInfo : null;
    }

    private boolean wasLastCastAutocast()
    {
        if (lastManualAttackTime > lastManualCastSpellTime)
            return true;

        return lastManualCastSpellTime < lastSpellCastTime;
    }

    private void updateWarnings(SpellInfo recentCast)
    {
        if (recentCast == null)
            return;

        final List<Integer> thresholds = new ArrayList<>();
        final List<String> thresholdStrings = Text.fromCSV(config.chatWarningThresholds());
        thresholdStrings.forEach(ts -> thresholds.add(tryParseInt(ts, -1)));
        Collections.sort(thresholds);

        if (thresholds.size() == 0)
            return;

        final int remaining = recentCast.getSpellCost().getRemainingCasts(runeCount);

        for (int val : thresholds)
        {
            if (remaining == val)
            {
                final String msgContent = getWarningMessage(recentCast.getName(), val);

                final String msg = new ChatMessageBuilder()
                        .append(ChatColorType.NORMAL)
                        .append(config.chatWarningColor(), msgContent)
                        .build();

                chatManager.queue(QueuedMessage.builder()
                        .type(ChatMessageType.GAMEMESSAGE)
                        .name(RemainingCastsPlugin.CONFIG_GROUP)
                        .runeLiteFormattedMessage(msg)
                        .build());

                if (config.useChatWarningNotifications())
                    notifier.notify(msgContent);

                break;
            }

        }
    }

    private String getWarningMessage(String spellName, int casts)
    {
        String message = spellName + " has " + (casts == 0 ? "no" : casts);
        message += (casts == 1 ? " cast " : " casts ") + "remaining.";

        return message;
    }

    private void updateCastBoxes(SpellInfo recentCast)
    {
        final int threshold = config.infoBoxThreshold();
        final List<SpellInfo> toRemove = new ArrayList<>();

        if (recentCast != null && castBoxes.containsKey(recentCast))
        {
            final RemainingCastsInfoBox infoBox = castBoxes.get(recentCast);
            infoBox.update(runeCount, true);
        }

        castBoxes.values().forEach(c ->
        {
            if (threshold != 0 && c.getRemainingCasts() > threshold)
                toRemove.add(c.getSpellInfo());
            else
                c.update(runeCount);
        });

        toRemove.forEach(this::removeCastBox);
    }

    private void processCast(SpellInfo spellInfo)
    {
        if (!castBoxes.containsKey(spellInfo))
            createRemainingCastsBox(spellInfo, false);
    }

    private RemainingCastsInfoBox createRemainingCastsBox(SpellInfo spellInfo, boolean isPinned)
    {
        final BufferedImage sprite = config.showInfoBoxSprites()
                ? spriteManager.getSprite(spellInfo.getSpriteId(), 0)
                : getSpellBookSprite();

        final int threshold = config.infoBoxThreshold();
        final int remainingCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
        if (!isPinned && threshold != 0 && remainingCasts > threshold)
            return null;

        final RemainingCastsInfoBox infoBox = new RemainingCastsInfoBox(spellInfo, runeCount, sprite, plugin, config, itemManager);
        infoBox.setPinned(isPinned);
        infoBoxManager.addInfoBox(infoBox);
        castBoxes.put(spellInfo, infoBox);

        if (isPinned)
        {
            infoBox.resetActiveTime();
        }
        else
        {
            spellQueue.add(spellInfo);
        }

        checkCastBoxLimit();
        return infoBox;
    }

    private void checkCastBoxLimit()
    {
        if (spellQueue.size() == 0 || config.infoBoxSpellLimit() <= 0)
            return;

        if (spellQueue.size() > config.infoBoxSpellLimit())
        {
            final SpellInfo oldest = spellQueue.peek();
            removeCastBox(oldest);
        }
    }

    private void checkCastBoxExpiry()
    {
        final int expirySeconds = config.infoBoxExpirySeconds();
        if (expirySeconds == 0)
            return;

        final List<SpellInfo> expired = new ArrayList<>();
        for (final SpellInfo spellInfo : castBoxes.keySet())
        {
            final RemainingCastsInfoBox box = castBoxes.get(spellInfo);
            if (!box.isPinned() && box.getActiveTime() > expirySeconds)
                expired.add(spellInfo);
        }

        expired.forEach(this::removeCastBox);
    }

    private void updatePinnedSpells()
    {
        final String pinned = config.pinnedSpells();
        final List<String> spellNames = Text.fromCSV(pinned);

        clientThread.invoke(() ->
        {
            castBoxes.values().forEach(cb -> cb.setPinned(false));

            if (spellNames.size() == 0)
                return;

            spellNames.forEach(name ->
            {
                final SpellInfo info = SpellIds.getSpellByName(name);
                if (info == null)
                    return;

                RemainingCastsInfoBox box = castBoxes.getOrDefault(info, null);
                if (box != null)
                {
                    box.setPinned(true);
                }
                else
                {
                    box = createRemainingCastsBox(info, true);
                    if (box != null)
                        box.setPinned(true);
                }
            });
        });
    }

    private void removeCastBox(SpellInfo spellInfo)
    {
        if (!castBoxes.containsKey(spellInfo))
            return;

        final RemainingCastsInfoBox box = castBoxes.get(spellInfo);
        infoBoxManager.removeInfoBox(box);
        castBoxes.remove(spellInfo);
        spellQueue.remove(spellInfo);
    }

    private void removeAllCastBoxes()
    {
        infoBoxManager.removeIf(i -> i instanceof RemainingCastsInfoBox);
        castBoxes.clear();
        spellQueue.clear();
    }

    private boolean isFiltered(SpellInfo spellInfo)
    {
        if (config.spellFilterOption() == SpellFilterOption.DISABLED)
            return false;

        final String filterList = config.filterList();
        final List<String> spellNames = Text.fromCSV(filterList);

        if (config.spellFilterOption() == SpellFilterOption.BLACKLIST)
        {
            return spellNames.stream().anyMatch(s -> spellInfo.getName().equalsIgnoreCase(s));
        }
        else if (config.spellFilterOption() == SpellFilterOption.WHITELIST)
        {
            return spellNames.stream().noneMatch(s -> spellInfo.getName().equalsIgnoreCase(s));
        }

        return false;
    }

    private BufferedImage getSpellBookSprite()
    {
        final Widget spellBook = client.getWidget(WidgetInfo.RESIZABLE_VIEWPORT_MAGIC_ICON);
        return spellBook != null ? spriteManager.getSprite(spellBook.getSpriteId(), 0)
                : spriteManager.getSprite(SpriteID.TAB_MAGIC, 0);
    }

    private boolean isOtherItemContainerWidget(int groupId)
    {
        switch (groupId)
        {
            case WidgetID.BANK_GROUP_ID:
            case WidgetID.DEPOSIT_BOX_GROUP_ID:
            case WidgetID.TRADE_WINDOW_GROUP_ID:
            case WidgetID.GROUP_STORAGE_GROUP_ID:
                return true;
            default:
                return false;
        }
    }

    public int tryParseInt(String value, int defaultVal) {
        try
        {
            return Integer.parseInt(value);
        }
        catch (NumberFormatException e)
        {
            return defaultVal;
        }
    }


}

package com.salverrs.RemainingCasts.Infobox;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.RemainingCastsConfig;
import com.salverrs.RemainingCasts.Util.CastUtils;
import com.salverrs.RemainingCasts.Util.RuneIds;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.InfoBox;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Instant;
import java.util.HashMap;
import java.util.Map;

@Getter
public class RemainingCastsInfoBox extends InfoBox
{
    private final SpellInfo spellInfo;
    private final SpellCost spellCost;
    private final RemainingCastsConfig config;
    private final String[] runeNames;
    private String tooltip = "";
    private Map<Integer, Integer> runeCount;
    private int remainingCasts;
    private long lastUpdated;
    private boolean advTooltipDisabled = false;
    @Setter
    private boolean isPinned;

    public RemainingCastsInfoBox(SpellInfo spellInfo, Map<Integer, Integer> runeCount, BufferedImage image, Plugin plugin, RemainingCastsConfig config, ItemManager itemManager)
    {
        super(image, plugin);
        this.spellInfo = spellInfo;
        this.spellCost = spellInfo.getSpellCost();
        this.lastUpdated = Instant.now().getEpochSecond();
        this.runeCount = runeCount;
        this.remainingCasts = this.spellCost.getRemainingCasts(runeCount);
        this.config = config;

        final int[] runes = spellCost.getRunes();
        this.runeNames = new String[runes.length];
        for (int i = 0; i < runes.length; i++)
        {
            this.runeNames[i] = itemManager.getItemComposition(runes[i]).getName();
            if (this.runeNames[i] == null || this.runeNames[i].equals(""))
            {
                advTooltipDisabled = true;
                break;
            }
        }

        buildTooltip();
    }

    @Override
    public String getText()
    {
        return getRemainingCastsString();
    }

    @Override
    public String getTooltip()
    {
        return tooltip;
    }

    @Override
    public Color getTextColor()
    {
        return config.infoBoxTextColor();
    }

    public void update(Map<Integer, Integer> runeCount)
    {
        update(runeCount, false);
    }

    public void update(Map<Integer, Integer> runeCount, boolean wasCast)
    {
        this.runeCount = runeCount;
        remainingCasts = spellCost.getRemainingCasts(runeCount);
        buildTooltip();

        if (wasCast)
            lastUpdated = Instant.now().getEpochSecond();
    }

    public long getActiveTime()
    {
        return (Instant.now().getEpochSecond() - lastUpdated);
    }

    public void resetActiveTime()
    {
        this.lastUpdated = 0;
    }

    private String getRemainingCastsString()
    {
        if (remainingCasts == -1)
            return "N/A";

        return config.shortenCastAmounts() ? CastUtils.getShortenedAmount(remainingCasts) : CastUtils.formatCastAmount(remainingCasts);
    }

    private void buildTooltip()
    {
        String base = spellInfo.getName() + " - " + (remainingCasts != Integer.MAX_VALUE ? remainingCasts : "Unlimited");
        base += (remainingCasts != 1 ? " casts " : " cast ") + "remaining";

        if (!config.showDetailedTooltip() || advTooltipDisabled)
        {
            tooltip = base;
            return;
        }

        StringBuilder advTooltip = new StringBuilder(base + "</br>");
        final int[] runes = spellCost.getRunes();
        final int[] quantities = spellCost.getQuantities();
        for (int i = 0; i < runes.length; i++)
        {
            final int runeId = runes[i];
            final int quantity = quantities[i];
            final int available = runeCount.getOrDefault(runeId, 0);
            final int floorDiv = getCostDivision(runeId, quantity, available);
            final String runeName = runeNames[i];
            if (runeName == null || runeName.equals(""))
            {
                tooltip = base;
                return;
            }

            advTooltip.append("</br>")
                    .append(runeName)
                    .append(": ")
                    .append(available != Integer.MAX_VALUE ? available : "*")
                    .append("/")
                    .append(quantity);

            if (available != Integer.MAX_VALUE && floorDiv != Integer.MAX_VALUE)
            {
                advTooltip.append(" (")
                    .append(floorDiv)
                    .append(")");
            }
        }

        tooltip = advTooltip.toString();
    }

    private int getCostDivision(int itemId, int cost, int available)
    {
        if (available == Integer.MAX_VALUE || (available >= 1 && RuneIds.isReqStaff(itemId)))
            return Integer.MAX_VALUE;

        return cost != 0 && available != 0 ? Math.floorDiv(available, cost) : 0;
    }

}

package com.salverrs.RemainingCasts;

import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;

@Slf4j
@PluginDescriptor(
	name = "Remaining Casts",
	description = "Displays the number of casts remaining for your spells.",
	tags = {"remaining","casts","magic","spell","rune","tracker"}
)
public class RemainingCastsPlugin extends Plugin
{
	public static final String CONFIG_GROUP = "RemainingCasts";

	@Inject
	private RemainingCastsConfig config;
	@Inject
	private EventBus eventBus;
	@Inject
	private CastSuppliesTracker castSuppliesTracker;
	@Inject
	private RemainingCastTracker castTracker;
	@Inject
	private TooltipCastUpdater tooltipUpdater;

	@Override
	protected void startUp() throws Exception
	{
		eventBus.register(castSuppliesTracker);
		eventBus.register(castTracker);
		eventBus.register(tooltipUpdater);

		castSuppliesTracker.start();
		castTracker.start(this);
		tooltipUpdater.start();
	}

	@Override
	protected void shutDown() throws Exception
	{
		eventBus.unregister(castSuppliesTracker);
		eventBus.unregister(castTracker);
		eventBus.unregister(tooltipUpdater);

		castSuppliesTracker.stop();
		castTracker.stop();
		tooltipUpdater.stop();
	}


	@Provides
	RemainingCastsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RemainingCastsConfig.class);
	}
}

package com.salverrs.RemainingCasts.Util;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Model.SpellProduct;
import net.runelite.api.ItemID;
import net.runelite.api.SpriteID;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SpellIds {

    private static final List<SpellInfo> Spells = new ArrayList<>();
    private static final Map<SpellProduct, SpellInfo> SpellProductMap = new HashMap<>();
    private static final Map<String, SpellInfo> SpellNameMap = new HashMap<>();
    private static final Map<Integer, SpellInfo> SpellSpriteMap = new HashMap<>();

    public static List<SpellInfo> getAllSpells()
    {
        return Spells;
    }
    public static SpellInfo getSpellBySpriteId(int spriteId)
    {
        return SpellSpriteMap.getOrDefault(spriteId, null);
    }
    public static SpellInfo getSpellByName(String spellName)
    {
        return SpellNameMap.getOrDefault(spellName.toLowerCase(), null);
    }
    public static SpellInfo getSpellByProduct(int itemId, int quantity)
    {
        return SpellProductMap.getOrDefault(new SpellProduct(itemId, quantity), null);
    }

    static
    {
        // Standard Spellbook

        // Lumbridge Home Teleport
        Spells.add(new SpellInfo("Wind Strike", SpriteID.SPELL_WIND_STRIKE, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.AIR_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Confuse", SpriteID.SPELL_CONFUSE, new SpellCost(new int[] {ItemID.BODY_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 3, 2})));

        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Opal)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.AIR_RUNE, ItemID.COSMIC_RUNE, ItemID.OPAL_BOLTS}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.OPAL_BOLTS_E, 10), new SpellProduct(ItemID.OPAL_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Sapphire)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.WATER_RUNE, ItemID.COSMIC_RUNE, ItemID.MIND_RUNE, ItemID.SAPPHIRE_BOLTS}, new int[] {1, 1, 1, 10}),
                new SpellProduct(ItemID.SAPPHIRE_BOLTS_E, 10), new SpellProduct(ItemID.SAPPHIRE_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Jade)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE, ItemID.JADE_BOLTS}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.JADE_BOLTS_E, 10), new SpellProduct(ItemID.JADE_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Pearl)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.WATER_RUNE, ItemID.COSMIC_RUNE, ItemID.PEARL_BOLTS}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.PEARL_BOLTS_E, 10), new SpellProduct(ItemID.PEARL_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Emerald)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.AIR_RUNE, ItemID.COSMIC_RUNE, ItemID.NATURE_RUNE, ItemID.EMERALD_BOLTS}, new int[] {3, 1, 1, 10}),
                new SpellProduct(ItemID.EMERALD_BOLTS_E, 10), new SpellProduct(ItemID.EMERALD_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Red Topaz)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE, ItemID.TOPAZ_BOLTS}, new int[] {2, 1, 10}),
                new SpellProduct(ItemID.TOPAZ_BOLTS_E, 10), new SpellProduct(ItemID.TOPAZ_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Ruby)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRE_RUNE, ItemID.BLOOD_RUNE, ItemID.COSMIC_RUNE, ItemID.RUBY_BOLTS}, new int[] {5, 1, 1, 10}),
                new SpellProduct(ItemID.RUBY_BOLTS_E, 10), new SpellProduct(ItemID.RUBY_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Diamond)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE, ItemID.LAW_RUNE, ItemID.DIAMOND_BOLTS}, new int[] {10, 1, 2, 10}),
                new SpellProduct(ItemID.DIAMOND_BOLTS_E, 10), new SpellProduct(ItemID.DIAMOND_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Dragonstone)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE, ItemID.SOUL_RUNE, ItemID.DRAGONSTONE_BOLTS}, new int[] {15, 1, 1, 10}),
                new SpellProduct(ItemID.DRAGONSTONE_BOLTS_E, 10), new SpellProduct(ItemID.DRAGONSTONE_DRAGON_BOLTS_E, 10)));
        Spells.add(new SpellInfo("Enchant Crossbow Bolt (Onyx)", SpriteID.SPELL_ENCHANT_CROSSBOW_BOLT, new SpellCost(new int[] {ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE, ItemID.DEATH_RUNE, ItemID.ONYX_BOLTS}, new int[] {20, 1, 1, 10}),
                new SpellProduct(ItemID.ONYX_BOLTS_E, 10), new SpellProduct(ItemID.ONYX_DRAGON_BOLTS_E, 10)));

        Spells.add(new SpellInfo("Water Strike", SpriteID.SPELL_WATER_STRIKE, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.WATER_RUNE, ItemID.AIR_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Lvl-1 Enchant", SpriteID.SPELL_LVL_1_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.WATER_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Earth Strike", SpriteID.SPELL_EARTH_STRIKE, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 2, 1})));
        Spells.add(new SpellInfo("Weaken", SpriteID.SPELL_WEAKEN, new SpellCost(new int[] {ItemID.BODY_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Fire Strike", SpriteID.SPELL_FIRE_STRIKE, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Bones to Bananas", SpriteID.SPELL_BONES_TO_BANANAS, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Wind Bolt", SpriteID.SPELL_WIND_BOLT, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.AIR_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Curse", SpriteID.SPELL_CURSE, new SpellCost(new int[] {ItemID.BODY_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2, 3})));
        Spells.add(new SpellInfo("Bind", SpriteID.SPELL_BIND, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 3, 3})));
        Spells.add(new SpellInfo("Low Level Alchemy", SpriteID.SPELL_LOW_LEVEL_ALCHEMY, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Water Bolt", SpriteID.SPELL_WATER_BOLT, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.WATER_RUNE, ItemID.AIR_RUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Varrock Teleport", SpriteID.SPELL_VARROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Lvl-2 Enchant", SpriteID.SPELL_LVL_2_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Earth Bolt", SpriteID.SPELL_EARTH_BOLT, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Lumbridge Teleport", SpriteID.SPELL_LUMBRIDGE_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Telekinetic Grab", SpriteID.SPELL_TELEKINETIC_GRAB, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Fire Bolt", SpriteID.SPELL_FIRE_BOLT, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 4, 3})));
        Spells.add(new SpellInfo("Falador Teleport", SpriteID.SPELL_FALADOR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.WATER_RUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Crumble Undead", SpriteID.SPELL_CRUMBLE_UNDEAD, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Teleport to House", SpriteID.SPELL_TELEPORT_TO_HOUSE, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Wind Blast", SpriteID.SPELL_WIND_BLAST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Superheat Item", SpriteID.SPELL_SUPERHEAT_ITEM, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 4})));
        Spells.add(new SpellInfo("Camelot Teleport", SpriteID.SPELL_CAMELOT_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Water Blast", SpriteID.SPELL_WATER_BLAST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.WATER_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3, 3})));
        Spells.add(new SpellInfo("Lvl-3 Enchant", SpriteID.SPELL_LVL_3_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Iban Blast", SpriteID.SPELL_IBAN_BLAST, new SpellCost(new int[] {ItemID.IBANS_STAFF, ItemID.DEATH_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 1, 5})));
        Spells.add(new SpellInfo("Snare", SpriteID.SPELL_SNARE, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {3, 4, 4})));
        Spells.add(new SpellInfo("Magic Dart", SpriteID.SPELL_MAGIC_DART, new SpellCost(new int[] {ItemID.SLAYERS_STAFF, ItemID.DEATH_RUNE, ItemID.MIND_RUNE}, new int[] {1, 1, 4})));
        Spells.add(new SpellInfo("Ardougne Teleport", SpriteID.SPELL_ARDOUGNE_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Earth Blast", SpriteID.SPELL_EARTH_BLAST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 4, 3})));
        Spells.add(new SpellInfo("High Level Alchemy", SpriteID.SPELL_HIGH_LEVEL_ALCHEMY, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Charge Water Orb", SpriteID.SPELL_CHARGE_WATER_ORB, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.WATER_RUNE, ItemID.UNPOWERED_ORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Lvl-4 Enchant", SpriteID.SPELL_LVL_4_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 10})));
        Spells.add(new SpellInfo("Watchtower Teleport", SpriteID.SPELL_WATCHTOWER_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Fire Blast", SpriteID.SPELL_FIRE_BLAST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 5, 4})));
        Spells.add(new SpellInfo("Charge Earth Orb", SpriteID.SPELL_CHARGE_EARTH_ORB, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.EARTH_RUNE, ItemID.UNPOWERED_ORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Bones to Peaches", SpriteID.SPELL_BONES_TO_PEACHES, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Saradomin Strike", SpriteID.SPELL_SARADOMIN_STRIKE, new SpellCost(new int[] {ItemID.SARADOMIN_STAFF, ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 2, 4, 2})));
        Spells.add(new SpellInfo("Claws of Guthix", SpriteID.SPELL_CLAWS_OF_GUTHIX, new SpellCost(new int[] {ItemID.GUTHIX_STAFF, ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 2, 4, 1})));
        Spells.add(new SpellInfo("Flames of Zamorak", SpriteID.SPELL_FLAMES_OF_ZAMORAK, new SpellCost(new int[] {ItemID.ZAMORAK_STAFF, ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 2, 1, 4})));
        Spells.add(new SpellInfo("Trollheim Teleport", SpriteID.SPELL_TROLLHEIM_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Wind Wave", SpriteID.SPELL_WIND_WAVE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.AIR_RUNE}, new int[] {1, 5})));
        Spells.add(new SpellInfo("Charge Fire Orb", SpriteID.SPELL_CHARGE_FIRE_ORB, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.FIRE_RUNE, ItemID.UNPOWERED_ORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Ape Atoll Teleport", SpriteID.SPELL_APE_ATOLL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE, ItemID.FIRE_RUNE, ItemID.BANANA}, new int[] {2, 2, 2, 1})));
        Spells.add(new SpellInfo("Water Wave", SpriteID.SPELL_WATER_WAVE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.WATER_RUNE, ItemID.AIR_RUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Charge Air Orb", SpriteID.SPELL_CHARGE_AIR_ORB, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.AIR_RUNE, ItemID.UNPOWERED_ORB}, new int[] {3, 30, 1})));
        Spells.add(new SpellInfo("Vulnerability", SpriteID.SPELL_VULNERABILITY, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 5, 5})));
        Spells.add(new SpellInfo("Lvl-5 Enchant", SpriteID.SPELL_LVL_5_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 15, 15})));
        Spells.add(new SpellInfo("Kourend Castle Teleport", SpriteID.SPELL_TELEPORT_TO_KOUREND, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.WATER_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 4, 5})));
        Spells.add(new SpellInfo("Earth Wave", SpriteID.SPELL_EARTH_WAVE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Enfeeble", SpriteID.SPELL_ENFEEBLE, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 8, 8})));
        Spells.add(new SpellInfo("Teleother Lumbridge", SpriteID.SPELL_TELEOTHER_LUMBRIDGE, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Fire Wave", SpriteID.SPELL_FIRE_WAVE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 7, 5})));
        Spells.add(new SpellInfo("Entangle", SpriteID.SPELL_ENTANGLE, new SpellCost(new int[] {ItemID.NATURE_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {4, 5, 5})));
        Spells.add(new SpellInfo("Stun", SpriteID.SPELL_STUN, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 12, 12})));
        Spells.add(new SpellInfo("Charge", SpriteID.SPELL_CHARGE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {3, 3, 3})));
        Spells.add(new SpellInfo("Wind Surge", SpriteID.SPELL_WIND_SURGE, new SpellCost(new int[] {ItemID.WRATH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 7})));
        Spells.add(new SpellInfo("Teleother Falador", SpriteID.SPELL_TELEOTHER_FALADOR, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.WATER_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Water Surge", SpriteID.SPELL_WATER_SURGE, new SpellCost(new int[] {ItemID.WRATH_RUNE, ItemID.WATER_RUNE, ItemID.AIR_RUNE}, new int[] {1, 10, 7})));
        Spells.add(new SpellInfo("Tele Block", SpriteID.SPELL_TELE_BLOCK, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.SPELL_TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Lvl-6 Enchant", SpriteID.SPELL_LVL_6_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.EARTH_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 20, 20})));
        Spells.add(new SpellInfo("Teleother Camelot", SpriteID.SPELL_TELEOTHER_CAMELOT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Earth Surge", SpriteID.SPELL_EARTH_SURGE, new SpellCost(new int[] {ItemID.WRATH_RUNE, ItemID.EARTH_RUNE, ItemID.AIR_RUNE}, new int[] {1, 10, 7})));
        Spells.add(new SpellInfo("Lvl-7 Enchant", SpriteID.SPELL_LVL_7_ENCHANT, new SpellCost(new int[] {ItemID.COSMIC_RUNE, ItemID.SOUL_RUNE, ItemID.BLOOD_RUNE}, new int[] {1, 20, 20})));
        Spells.add(new SpellInfo("Fire Surge", SpriteID.SPELL_FIRE_SURGE, new SpellCost(new int[] {ItemID.WRATH_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 10, 7})));

        // Ancients Spellbook

        // Edgeville Home Teleport
        Spells.add(new SpellInfo("Smoke Rush", SpriteID.SPELL_SMOKE_RUSH, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 1, 1})));
        Spells.add(new SpellInfo("Shadow Rush", SpriteID.SPELL_SHADOW_RUSH, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.SOUL_RUNE, ItemID.AIR_RUNE}, new int[] {2, 2, 1, 1})));
        Spells.add(new SpellInfo("Paddewwa Teleport", SpriteID.SPELL_PADDEWWA_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("Blood Rush", SpriteID.SPELL_BLOOD_RUSH, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Ice Rush", SpriteID.SPELL_ICE_RUSH, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.WATER_RUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Senntisten Teleport", SpriteID.SPELL_SENNTISTEN_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Smoke Burst", SpriteID.SPELL_SMOKE_BURST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 4, 2, 2})));
        Spells.add(new SpellInfo("Shadow Burst", SpriteID.SPELL_SHADOW_BURST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.SOUL_RUNE, ItemID.AIR_RUNE}, new int[] {2, 4, 2, 1})));
        Spells.add(new SpellInfo("Kharyrll Teleport", SpriteID.SPELL_KHARYRLL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Blood Burst", SpriteID.SPELL_BLOOD_BURST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 4, 2})));
        Spells.add(new SpellInfo("Ice Burst", SpriteID.SPELL_ICE_BURST, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE, ItemID.WATER_RUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Lassar Teleport", SpriteID.SPELL_LASSAR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Smoke Blitz", SpriteID.SPELL_SMOKE_BLITZ, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 2, 2})));
        Spells.add(new SpellInfo("Shadow Blitz", SpriteID.SPELL_SHADOW_BLITZ, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.SOUL_RUNE, ItemID.AIR_RUNE}, new int[] {2, 2, 2, 2})));
        Spells.add(new SpellInfo("Dareeyak Teleport", SpriteID.SPELL_DAREEYAK_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Blood Blitz", SpriteID.SPELL_BLOOD_BLITZ, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Ice Blitz", SpriteID.SPELL_ICE_BLITZ, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.WATER_RUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Carrallangar Teleport", SpriteID.SPELL_CARRALLANGAR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.SPELL_TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Smoke Barrage", SpriteID.SPELL_SMOKE_BARRAGE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {4, 2, 4, 4})));
        Spells.add(new SpellInfo("Shadow Barrage", SpriteID.SPELL_SHADOW_BARRAGE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.SOUL_RUNE, ItemID.AIR_RUNE}, new int[] {4, 2, 3, 4})));
        Spells.add(new SpellInfo("Annakarl Teleport", SpriteID.SPELL_ANNAKARL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Blood Barrage", SpriteID.SPELL_BLOOD_BARRAGE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.SOUL_RUNE}, new int[] {4, 4, 1})));
        Spells.add(new SpellInfo("Ice Barrage", SpriteID.SPELL_ICE_BARRAGE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.WATER_RUNE}, new int[] {4, 2, 6})));
        Spells.add(new SpellInfo("Ghorrock Teleport", SpriteID.SPELL_GHORROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE}, new int[] {2, 8})));

        //Normal Ancient Teleports compatibility (name map only)
        Spells.add(new SpellInfo("Edgeville Teleport", SpriteID.SPELL_PADDEWWA_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 1, 1})));
        Spells.add(new SpellInfo("Digsite Teleport", SpriteID.SPELL_SENNTISTEN_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Canifis Teleport", SpriteID.SPELL_KHARYRLL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 1})));
        Spells.add(new SpellInfo("Ice Mountain Teleport", SpriteID.SPELL_LASSAR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE}, new int[] {2, 4})));
        Spells.add(new SpellInfo("Forgotten Cemetery Teleport", SpriteID.SPELL_DAREEYAK_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.AIR_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Graveyard of Shadows Teleport", SpriteID.SPELL_CARRALLANGAR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Demonic Ruins Teleport", SpriteID.SPELL_ANNAKARL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Frozen Waste Plateau Teleport", SpriteID.SPELL_GHORROCK_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE}, new int[] {2, 8})));

        // Lunar Spellbook

        // Lunar Home Teleport
        Spells.add(new SpellInfo("Bake Pie", SpriteID.SPELL_BAKE_PIE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 4, 5})));
        Spells.add(new SpellInfo("Geomancy", SpriteID.SPELL_GEOMANCY, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.NATURE_RUNE, ItemID.EARTH_RUNE}, new int[] {3, 3, 8})));
        Spells.add(new SpellInfo("Cure Plant", SpriteID.SPELL_CURE_PLANT, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 8})));
        Spells.add(new SpellInfo("Monster Examine", SpriteID.SPELL_MONSTER_EXAMINE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.MIND_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("NPC Contact", SpriteID.SPELL_NPC_CONTACT, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.AIR_RUNE}, new int[] {1, 1, 2})));
        Spells.add(new SpellInfo("Cure Other", SpriteID.SPELL_CURE_OTHER, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.LAW_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 1, 10})));
        Spells.add(new SpellInfo("Humidify", SpriteID.SPELL_HUMIDIFY, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 3, 1})));
        Spells.add(new SpellInfo("Moonclan Teleport", SpriteID.SPELL_MOONCLAN_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2, 2})));
        Spells.add(new SpellInfo("Tele Group Moonclan", SpriteID.SPELL_TELE_GROUP_MOONCLAN, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2, 4})));
        Spells.add(new SpellInfo("Cure Me", SpriteID.SPELL_CURE_ME, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.LAW_RUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Ourania Teleport", SpriteID.SPELL_OURANIA_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2, 6})));
        Spells.add(new SpellInfo("Hunter Kit", SpriteID.SPELL_HUNTER_KIT, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Waterbirth Teleport", SpriteID.SPELL_WATERBIRTH_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {1, 2, 1})));
        Spells.add(new SpellInfo("Tele Group Waterbirth", SpriteID.SPELL_TELE_GROUP_WATERBIRTH, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {1, 2, 5})));
        Spells.add(new SpellInfo("Cure Group", SpriteID.SPELL_CURE_GROUP, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.LAW_RUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Stat Spy", SpriteID.SPELL_STAT_SPY, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.BODY_RUNE}, new int[] {2, 2, 5})));
        Spells.add(new SpellInfo("Barbarian Teleport", SpriteID.SPELL_BARBARIAN_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 3})));
        Spells.add(new SpellInfo("Tele Group Barbarian", SpriteID.SPELL_TELE_GROUP_BARBARIAN, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 2, 6})));
        Spells.add(new SpellInfo("Spin Flax", SpriteID.SPELL_SPIN_FLAX, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.NATURE_RUNE, ItemID.AIR_RUNE}, new int[] {1, 2, 5})));
        Spells.add(new SpellInfo("Superglass Make", SpriteID.SPELL_SUPERGLASS_MAKE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.FIRE_RUNE, ItemID.AIR_RUNE}, new int[] {2, 6, 10})));
        Spells.add(new SpellInfo("Tan Leather", SpriteID.SPELL_TAN_LEATHER, new SpellCost(new int[] {ItemID.FIRE_RUNE, ItemID.ASTRAL_RUNE, ItemID.NATURE_RUNE}, new int[] {5, 2, 1})));
        Spells.add(new SpellInfo("Khazard Teleport", SpriteID.SPELL_KHAZARD_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {2, 2, 4})));
        Spells.add(new SpellInfo("Tele Group Khazard", SpriteID.SPELL_TELE_GROUP_KHAZARD, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {2, 2, 8})));
        Spells.add(new SpellInfo("Dream", SpriteID.SPELL_DREAM, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.BODY_RUNE}, new int[] {2, 1, 5})));
        Spells.add(new SpellInfo("String Jewellery", SpriteID.SPELL_STRING_JEWELLERY, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 5, 10})));
        Spells.add(new SpellInfo("Stat Restore Pot Share", SpriteID.SPELL_STAT_RESTORE_POT_SHARE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 10, 10})));
        Spells.add(new SpellInfo("Magic Imbue", SpriteID.SPELL_MAGIC_IMBUE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 7, 7})));
        Spells.add(new SpellInfo("Fertile Soil", SpriteID.SPELL_FERTILE_SOIL, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.NATURE_RUNE, ItemID.EARTH_RUNE}, new int[] {3, 2, 15})));
        Spells.add(new SpellInfo("Boost Potion Share", SpriteID.SPELL_BOOST_POTION_SHARE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {3, 10, 12})));
        Spells.add(new SpellInfo("Fishing Guild Teleport", SpriteID.SPELL_FISHING_GUILD_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 10})));
        Spells.add(new SpellInfo("Teleport to Target", SpriteID.SPELL_TELEPORT_TO_BOUNTY_TARGET, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.DEATH_RUNE, ItemID.CHAOS_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Tele Group Fishing Guild", SpriteID.SPELL_TELE_GROUP_FISHING_GUILD, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 14})));
        Spells.add(new SpellInfo("Plank Make", SpriteID.SPELL_PLANK_MAKE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.NATURE_RUNE, ItemID.EARTH_RUNE}, new int[] {2, 1, 15})));
        Spells.add(new SpellInfo("Catherby Teleport", SpriteID.SPELL_CATHERBY_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 10})));
        Spells.add(new SpellInfo("Tele Group Catherby", SpriteID.SPELL_TELE_GROUP_CATHERBY, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 15})));
        Spells.add(new SpellInfo("Recharge Dragonstone", SpriteID.SPELL_RECHARGE_DRAGONSTONE, new SpellCost(new int[] {ItemID.WATER_RUNE, ItemID.ASTRAL_RUNE, ItemID.SOUL_RUNE}, new int[] {4, 1, 1})));
        Spells.add(new SpellInfo("Ice Plateau Teleport", SpriteID.SPELL_ICE_PLATEAU_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 8})));
        Spells.add(new SpellInfo("Tele Group Ice Plateau", SpriteID.SPELL_TELE_GROUP_ICE_PLATEAU, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.ASTRAL_RUNE, ItemID.WATER_RUNE}, new int[] {3, 3, 16})));
        Spells.add(new SpellInfo("Energy Transfer", SpriteID.SPELL_ENERGY_TRANSFER, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.LAW_RUNE, ItemID.NATURE_RUNE}, new int[] {3, 2, 1})));
        Spells.add(new SpellInfo("Heal Other", SpriteID.SPELL_HEAL_OTHER, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {3, 3, 1})));
        Spells.add(new SpellInfo("Vengeance Other", SpriteID.SPELL_VENGEANCE_OTHER, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.DEATH_RUNE, ItemID.EARTH_RUNE}, new int[] {3, 2, 10})));
        Spells.add(new SpellInfo("Vengeance", SpriteID.SPELL_VENGEANCE, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.DEATH_RUNE, ItemID.EARTH_RUNE}, new int[] {4, 2, 10})));
        Spells.add(new SpellInfo("Heal Group", SpriteID.SPELL_HEAL_GROUP, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.LAW_RUNE, ItemID.BLOOD_RUNE}, new int[] {4, 6, 3})));
        Spells.add(new SpellInfo("Spellbook Swap", SpriteID.SPELL_SPELLBOOK_SWAP, new SpellCost(new int[] {ItemID.ASTRAL_RUNE, ItemID.COSMIC_RUNE, ItemID.LAW_RUNE}, new int[] {3, 2, 1})));

        // Arceuus spellbook

        // Arceuus Home Teleport
        Spells.add(new SpellInfo("Arceuus Library Teleport", SpriteID.SPELL_ARCEUUS_LIBRARY_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Basic Reanimation", SpriteID.SPELL_BASIC_REANIMATION, new SpellCost(new int[] {ItemID.BODY_RUNE, ItemID.NATURE_RUNE}, new int[] {4, 2})));
        Spells.add(new SpellInfo("Draynor Manor Teleport", SpriteID.SPELL_DRAYNOR_MANOR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.WATER_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Battlefront Teleport", 1255, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.EARTH_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Mind Altar Teleport", SpriteID.SPELL_MIND_ALTAR_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.MIND_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Respawn Teleport", SpriteID.SPELL_RESPAWN_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Ghostly Grasp", SpriteID.SPELL_GHOSTLY_GRASP, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.AIR_RUNE}, new int[] {1, 4})));
        Spells.add(new SpellInfo("Resurrect Lesser Ghost", SpriteID.SPELL_RESURRECT_LESSER_GHOST, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.AIR_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Lesser Skeleton", 1271, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.AIR_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Lesser Zombie", 1300, new SpellCost(new int[] {ItemID.MIND_RUNE, ItemID.AIR_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Salve Graveyard Teleport", SpriteID.SPELL_SALVE_GRAVEYARD_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Adept Reanimation", SpriteID.SPELL_ADEPT_REANIMATION, new SpellCost(new int[] {ItemID.BODY_RUNE, ItemID.NATURE_RUNE, ItemID.SOUL_RUNE}, new int[] {4, 3, 1})));
        Spells.add(new SpellInfo("Inferior Demonbane", SpriteID.SPELL_INFERIOR_DEMONBANE, new SpellCost(new int[] {ItemID.CHAOS_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 4})));
        Spells.add(new SpellInfo("Shadow Veil", SpriteID.SPELL_SHADOW_VEIL, new SpellCost(new int[] {ItemID.EARTH_RUNE, ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 5, 5})));
        Spells.add(new SpellInfo("Fenkenstrain's Castle Teleport", SpriteID.SPELL_FENKENSTRAINS_CASTLE_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Dark Lure", SpriteID.SPELL_DARK_LURE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.NATURE_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Skeletal Grasp", SpriteID.SPELL_SKELETAL_GRASP, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.EARTH_RUNE}, new int[] {1, 8})));
        Spells.add(new SpellInfo("Resurrect Superior Ghost", 2979, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Superior Skeleton", SpriteID.SPELL_RESURRECT_SUPERIOR_SKELETON, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Superior Zombie", 2983, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.EARTH_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Mark of Darkness", SpriteID.SPELL_MARK_OF_DARKNESS, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.COSMIC_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("West Ardougne Teleport", SpriteID.SPELL_WEST_ARDOUGNE_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 2})));
        Spells.add(new SpellInfo("Superior Demonbane", SpriteID.SPELL_SUPERIOR_DEMONBANE, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 8})));
        Spells.add(new SpellInfo("Lesser Corruption", SpriteID.SPELL_LESSER_CORRUPTION, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 2})));
        Spells.add(new SpellInfo("Harmony Island Teleport", SpriteID.SPELL_HARMONY_ISLAND_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.NATURE_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Vile Vigour", SpriteID.SPELL_VILE_VIGOUR, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.AIR_RUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Degrime", SpriteID.SPELL_DEGRIME, new SpellCost(new int[] {ItemID.EARTH_RUNE, ItemID.NATURE_RUNE}, new int[] {4, 2})));
        Spells.add(new SpellInfo("Cemetery Teleport", SpriteID.SPELL_CEMETERY_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.BLOOD_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Expert Reanimation", SpriteID.SPELL_EXPERT_REANIMATION, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.NATURE_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 3, 2})));
        Spells.add(new SpellInfo("Ward of Arceuus", SpriteID.SPELL_WARD_OF_ARCEUUS, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.NATURE_RUNE, ItemID.COSMIC_RUNE}, new int[] {4, 2, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Ghost", 2980, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Skeleton", 2982, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Greater Zombie", SpriteID.SPELL_RESURRECT_GREATER_ZOMBIE, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.FIRE_RUNE, ItemID.COSMIC_RUNE}, new int[] {5, 10, 1})));
        Spells.add(new SpellInfo("Resurrect Crops", SpriteID.SPELL_RESURRECT_CROPS, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.NATURE_RUNE, ItemID.BLOOD_RUNE, ItemID.EARTH_RUNE}, new int[] {8, 12, 8, 25})));
        Spells.add(new SpellInfo("Undead Grasp", SpriteID.SPELL_UNDEAD_GRASP, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.FIRE_RUNE}, new int[] {1, 12})));
        Spells.add(new SpellInfo("Death Charge", SpriteID.SPELL_DEATH_CHARGE, new SpellCost(new int[] {ItemID.DEATH_RUNE, ItemID.BLOOD_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 1, 1})));
        Spells.add(new SpellInfo("Dark Demonbane", SpriteID.SPELL_DARK_DEMONBANE, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.FIRE_RUNE}, new int[] {2, 12})));
        Spells.add(new SpellInfo("Barrows Teleport", SpriteID.SPELL_BARROWS_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 2, 1})));
        Spells.add(new SpellInfo("Demonic Offering", SpriteID.SPELL_DEMONIC_OFFERING, new SpellCost(new int[] {ItemID.SOUL_RUNE, ItemID.WRATH_RUNE}, new int[] {1, 1})));
        Spells.add(new SpellInfo("Greater Corruption", SpriteID.SPELL_GREATER_CORRUPTION, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.SOUL_RUNE}, new int[] {1, 3})));
        Spells.add(new SpellInfo("Master Reanimation", SpriteID.SPELL_MASTER_REANIMATION, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.NATURE_RUNE, ItemID.SOUL_RUNE}, new int[] {2, 4, 4})));
        Spells.add(new SpellInfo("Ape Atoll Teleport", SpriteID.SPELL_APE_ATOLL_TELEPORT, new SpellCost(new int[] {ItemID.LAW_RUNE, ItemID.SOUL_RUNE, ItemID.BLOOD_RUNE}, new int[] {2, 2, 2})));
        Spells.add(new SpellInfo("Sinister Offering", SpriteID.SPELL_SINISTER_OFFERING, new SpellCost(new int[] {ItemID.BLOOD_RUNE, ItemID.WRATH_RUNE}, new int[] {1, 1})));

        // Some keys do collide (some spells name/sprite) - no longer bothering to map through cost because unlimited rune supply complicates things.
        // We remove existing sprite keys and ignore them because we don't want the first occurrence mapped if it's not unique.
        // Don't need to remove/ignore keys from name map, because we only use that for tooltips and the rune costs are the same regardless (as of writing, only Teleport to Target is shared).

        // SpellProductMap currently only used for detecting Enchant crossbow bolts.

        final List<Integer> spriteIgnore = new ArrayList<Integer>();

        Spells.forEach(s -> {
            final SpellCost cost = s.getSpellCost();
            final int spriteId = s.getSpriteId();
            final String name = s.getName();

            if (s.getSpellProducts() != null)
            {
                final SpellProduct[] products = s.getSpellProducts();
                for (SpellProduct p : products)
                    SpellProductMap.put(p, s);
            }

            if (!spriteIgnore.contains(spriteId))
            {
                if (!SpellSpriteMap.containsKey(spriteId))
                {
                    SpellSpriteMap.put(spriteId, s);
                }
                else
                {
                    SpellSpriteMap.remove(spriteId);
                    spriteIgnore.add(spriteId);
                }
            }

            if (!SpellNameMap.containsKey(name))
                SpellNameMap.put(name.toLowerCase(), s);
        });
    }
}

package com.salverrs.RemainingCasts.Util;

public class CastUtils {

    public static String getShortenedAmount(double amount)
    {
        if (amount == Integer.MAX_VALUE)
        {
            return "*";
        }
        else if (amount > 1000000000)
        {
            return String.format("%.1f", amount / 1000000000) + "b";
        }
        else if (amount > 1000000)
        {
            return String.format("%.1f", amount / 1000000) + "m";
        }
        else if (amount > 1000)
        {
            return String.format("%.1f", amount / 1000) + "k";
        }
        else
        {
            return Integer.toString((int)amount);
        }
    }

    public static String formatCastAmount(int amount)
    {
        return amount == Integer.MAX_VALUE ? "*" : Integer.toString(amount);
    }
}




package com.salverrs.RemainingCasts.Util;

import net.runelite.api.ItemID;

import java.util.*;

public class RuneIds {

    private static final Map<Integer, Integer[]> RuneMap = new HashMap<>();
    private static final Map<Integer, Integer[]> ReqStaffMap = new HashMap<>();
    private static final Map<Integer, Integer> StaffMap = new HashMap<>();
    private static final Map<Integer, Integer> TomeMap = new HashMap<>();
    private static final Map<Integer, Integer> IngredientMap = new HashMap<>();
    private static final List<Integer> EnchantProducts = new ArrayList<>();

    public static Set<Integer> getAllRuneIds()
    {
        return RuneMap.keySet();
    }

    public static Integer[] getRuneIds(int runeId)
    {
        return RuneMap.getOrDefault(runeId, null);
    }

    public static int getIngredientId(int itemId)
    {
        return IngredientMap.getOrDefault(itemId, -1);
    }

    public static boolean isEnchantProduct(int itemId)
    {
        return EnchantProducts.contains(itemId);
    }

    public static boolean isReqStaff(int itemId)
    {
        return ReqStaffMap.containsKey(itemId);
    }

    public static Integer[] getRuneIdsFromEquipment(int equipmentId)
    {
        if (StaffMap.containsKey(equipmentId))
        {
            return RuneMap.getOrDefault(StaffMap.get(equipmentId), new Integer[] {StaffMap.get(equipmentId)});
        }
        else if (TomeMap.containsKey(equipmentId))
        {
            return RuneMap.getOrDefault(TomeMap.get(equipmentId), null);
        }
        return null;
    }

    public static Integer[] getItemIdsFromEquipment(int equipmentId)
    {
        return ReqStaffMap.getOrDefault(equipmentId, null);
    }

    static
    {
        // Regular runes
        RuneMap.put(ItemID.AIR_RUNE, new Integer[] {ItemID.AIR_RUNE});
        RuneMap.put(ItemID.WATER_RUNE, new Integer[] {ItemID.WATER_RUNE});
        RuneMap.put(ItemID.EARTH_RUNE, new Integer[] {ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.FIRE_RUNE, new Integer[] {ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.MIND_RUNE, new Integer[] {ItemID.MIND_RUNE});
        RuneMap.put(ItemID.BODY_RUNE, new Integer[] {ItemID.BODY_RUNE});
        RuneMap.put(ItemID.COSMIC_RUNE, new Integer[] {ItemID.COSMIC_RUNE});
        RuneMap.put(ItemID.CHAOS_RUNE, new Integer[] {ItemID.CHAOS_RUNE});
        RuneMap.put(ItemID.NATURE_RUNE, new Integer[] {ItemID.NATURE_RUNE});
        RuneMap.put(ItemID.LAW_RUNE, new Integer[] {ItemID.LAW_RUNE});
        RuneMap.put(ItemID.DEATH_RUNE, new Integer[] {ItemID.DEATH_RUNE});
        RuneMap.put(ItemID.ASTRAL_RUNE, new Integer[] {ItemID.ASTRAL_RUNE});
        RuneMap.put(ItemID.BLOOD_RUNE, new Integer[] {ItemID.BLOOD_RUNE});
        RuneMap.put(ItemID.SOUL_RUNE, new Integer[] {ItemID.SOUL_RUNE});
        RuneMap.put(ItemID.WRATH_RUNE, new Integer[] {ItemID.WRATH_RUNE});

        // Regular runes (variations)
        RuneMap.put(ItemID.AIR_RUNE_6422, new Integer[] {ItemID.AIR_RUNE});
        RuneMap.put(ItemID.AIR_RUNE_7558, new Integer[] {ItemID.AIR_RUNE});
        RuneMap.put(ItemID.AIR_RUNE_9693, new Integer[] {ItemID.AIR_RUNE});
        RuneMap.put(ItemID.AIR_RUNE_11688, new Integer[] {ItemID.AIR_RUNE});
        RuneMap.put(ItemID.AIR_RUNE_NZ, new Integer[] {ItemID.AIR_RUNE});

        RuneMap.put(ItemID.WATER_RUNE_6424, new Integer[] {ItemID.WATER_RUNE});
        RuneMap.put(ItemID.WATER_RUNE_7556, new Integer[] {ItemID.WATER_RUNE});
        RuneMap.put(ItemID.WATER_RUNE_9691, new Integer[] {ItemID.WATER_RUNE});
        RuneMap.put(ItemID.WATER_RUNE_11687, new Integer[] {ItemID.WATER_RUNE});
        RuneMap.put(ItemID.WATER_RUNE_NZ, new Integer[] {ItemID.WATER_RUNE});

        RuneMap.put(ItemID.EARTH_RUNE_6426, new Integer[] {ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.EARTH_RUNE_9695, new Integer[] {ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.EARTH_RUNE_11689, new Integer[] {ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.EARTH_RUNE_NZ, new Integer[] {ItemID.EARTH_RUNE});

        RuneMap.put(ItemID.FIRE_RUNE_6428, new Integer[] {ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.FIRE_RUNE_7554, new Integer[] {ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.FIRE_RUNE_9699, new Integer[] {ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.FIRE_RUNE_11686, new Integer[] {ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.FIRE_RUNE_NZ, new Integer[] {ItemID.FIRE_RUNE});

        RuneMap.put(ItemID.MIND_RUNE_6436, new Integer[] {ItemID.MIND_RUNE});
        RuneMap.put(ItemID.MIND_RUNE_9697, new Integer[] {ItemID.MIND_RUNE});
        RuneMap.put(ItemID.MIND_RUNE_11690, new Integer[] {ItemID.MIND_RUNE});

        RuneMap.put(ItemID.BODY_RUNE_6438, new Integer[] {ItemID.BODY_RUNE});
        RuneMap.put(ItemID.BODY_RUNE_11691, new Integer[] {ItemID.BODY_RUNE});

        RuneMap.put(ItemID.COSMIC_RUNE_11696, new Integer[] {ItemID.COSMIC_RUNE});

        RuneMap.put(ItemID.CHAOS_RUNE_6430, new Integer[] {ItemID.CHAOS_RUNE});
        RuneMap.put(ItemID.CHAOS_RUNE_7560, new Integer[] {ItemID.CHAOS_RUNE});
        RuneMap.put(ItemID.CHAOS_RUNE_11694, new Integer[] {ItemID.CHAOS_RUNE});
        RuneMap.put(ItemID.CHAOS_RUNE_NZ, new Integer[] {ItemID.CHAOS_RUNE});

        RuneMap.put(ItemID.NATURE_RUNE_11693, new Integer[] {ItemID.NATURE_RUNE});

        RuneMap.put(ItemID.LAW_RUNE_6434, new Integer[] {ItemID.LAW_RUNE});
        RuneMap.put(ItemID.LAW_RUNE_11695, new Integer[] {ItemID.LAW_RUNE});

        RuneMap.put(ItemID.DEATH_RUNE_6432, new Integer[] {ItemID.DEATH_RUNE});
        RuneMap.put(ItemID.DEATH_RUNE_11692, new Integer[] {ItemID.DEATH_RUNE});
        RuneMap.put(ItemID.DEATH_RUNE_NZ, new Integer[] {ItemID.DEATH_RUNE});

        RuneMap.put(ItemID.ASTRAL_RUNE_11699, new Integer[] {ItemID.ASTRAL_RUNE});

        RuneMap.put(ItemID.BLOOD_RUNE_11697, new Integer[] {ItemID.BLOOD_RUNE});
        RuneMap.put(ItemID.BLOOD_RUNE_NZ, new Integer[] {ItemID.BLOOD_RUNE});

        RuneMap.put(ItemID.SOUL_RUNE_11698, new Integer[] {ItemID.SOUL_RUNE});

        RuneMap.put(ItemID.WRATH_RUNE_22208, new Integer[] {ItemID.WRATH_RUNE});

        // Combo runes
        RuneMap.put(ItemID.MIST_RUNE, new Integer[] {ItemID.AIR_RUNE, ItemID.WATER_RUNE});
        RuneMap.put(ItemID.DUST_RUNE, new Integer[] {ItemID.AIR_RUNE, ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.MUD_RUNE, new Integer[] {ItemID.WATER_RUNE, ItemID.EARTH_RUNE});
        RuneMap.put(ItemID.SMOKE_RUNE, new Integer[] {ItemID.AIR_RUNE, ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.STEAM_RUNE, new Integer[] {ItemID.WATER_RUNE, ItemID.FIRE_RUNE});
        RuneMap.put(ItemID.LAVA_RUNE, new Integer[] {ItemID.EARTH_RUNE, ItemID.FIRE_RUNE});

        // Staffs
        StaffMap.put(ItemID.STAFF_OF_AIR, ItemID.AIR_RUNE);
        StaffMap.put(ItemID.STAFF_OF_WATER, ItemID.WATER_RUNE);
        StaffMap.put(ItemID.STAFF_OF_EARTH, ItemID.EARTH_RUNE);
        StaffMap.put(ItemID.STAFF_OF_FIRE, ItemID.FIRE_RUNE);

        StaffMap.put(ItemID.AIR_BATTLESTAFF, ItemID.AIR_RUNE);
        StaffMap.put(ItemID.WATER_BATTLESTAFF, ItemID.WATER_RUNE);
        StaffMap.put(ItemID.EARTH_BATTLESTAFF, ItemID.EARTH_RUNE);
        StaffMap.put(ItemID.FIRE_BATTLESTAFF, ItemID.FIRE_RUNE);

        StaffMap.put(ItemID.MYSTIC_AIR_STAFF, ItemID.AIR_RUNE);
        StaffMap.put(ItemID.MYSTIC_WATER_STAFF, ItemID.WATER_RUNE);
        StaffMap.put(ItemID.MYSTIC_EARTH_STAFF, ItemID.EARTH_RUNE);
        StaffMap.put(ItemID.MYSTIC_FIRE_STAFF, ItemID.FIRE_RUNE);

        StaffMap.put(ItemID.MIST_BATTLESTAFF, ItemID.MIST_RUNE);
        StaffMap.put(ItemID.DUST_BATTLESTAFF, ItemID.DUST_RUNE);
        StaffMap.put(ItemID.MUD_BATTLESTAFF, ItemID.MUD_RUNE);
        StaffMap.put(ItemID.SMOKE_BATTLESTAFF, ItemID.SMOKE_RUNE);
        StaffMap.put(ItemID.STEAM_BATTLESTAFF, ItemID.STEAM_RUNE);
        StaffMap.put(ItemID.LAVA_BATTLESTAFF, ItemID.LAVA_RUNE);

        StaffMap.put(ItemID.MYSTIC_MIST_STAFF, ItemID.MIST_RUNE);
        StaffMap.put(ItemID.MYSTIC_DUST_STAFF, ItemID.DUST_RUNE);
        StaffMap.put(ItemID.MYSTIC_MUD_STAFF, ItemID.MUD_RUNE);
        StaffMap.put(ItemID.MYSTIC_SMOKE_STAFF, ItemID.SMOKE_RUNE);
        StaffMap.put(ItemID.MYSTIC_STEAM_STAFF, ItemID.STEAM_RUNE);
        StaffMap.put(ItemID.MYSTIC_LAVA_STAFF, ItemID.LAVA_RUNE);

        StaffMap.put(ItemID.BRYOPHYTAS_STAFF, ItemID.NATURE_RUNE);

        StaffMap.put(ItemID.KODAI_WAND, ItemID.WATER_RUNE);
        StaffMap.put(ItemID.KODAI_WAND_23626, ItemID.WATER_RUNE);

        // Required staffs
        ReqStaffMap.put(ItemID.IBANS_STAFF, new Integer[] {ItemID.IBANS_STAFF});
        ReqStaffMap.put(ItemID.IBANS_STAFF_U, new Integer[] {ItemID.IBANS_STAFF});
        ReqStaffMap.put(ItemID.SLAYERS_STAFF, new Integer[] {ItemID.SLAYERS_STAFF});
        ReqStaffMap.put(ItemID.SLAYERS_STAFF_E, new Integer[] {ItemID.SLAYERS_STAFF});
        ReqStaffMap.put(ItemID.SARADOMIN_STAFF, new Integer[] {ItemID.SARADOMIN_STAFF});
        ReqStaffMap.put(ItemID.GUTHIX_STAFF, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.VOID_KNIGHT_MACE, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.VOID_KNIGHT_MACE_L, new Integer[] {ItemID.GUTHIX_STAFF});
        ReqStaffMap.put(ItemID.ZAMORAK_STAFF, new Integer[] {ItemID.ZAMORAK_STAFF});

        ReqStaffMap.put(ItemID.STAFF_OF_THE_DEAD, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.STAFF_OF_THE_DEAD_23613, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.TOXIC_STAFF_OF_THE_DEAD, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.TOXIC_STAFF_UNCHARGED, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.ZAMORAK_STAFF});
        ReqStaffMap.put(ItemID.STAFF_OF_LIGHT, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.SARADOMIN_STAFF});
        ReqStaffMap.put(ItemID.STAFF_OF_BALANCE, new Integer[] {ItemID.SLAYERS_STAFF, ItemID.GUTHIX_STAFF});

        // Tomes
        TomeMap.put(ItemID.TOME_OF_WATER, ItemID.WATER_RUNE);
        TomeMap.put(ItemID.TOME_OF_FIRE, ItemID.FIRE_RUNE);

        // Ingredients
        IngredientMap.put(ItemID.UNPOWERED_ORB, ItemID.UNPOWERED_ORB);
        IngredientMap.put(ItemID.OPAL_BOLTS, ItemID.OPAL_BOLTS);
        IngredientMap.put(ItemID.JADE_BOLTS, ItemID.JADE_BOLTS);
        IngredientMap.put(ItemID.PEARL_BOLTS, ItemID.PEARL_BOLTS);
        IngredientMap.put(ItemID.TOPAZ_BOLTS, ItemID.TOPAZ_BOLTS);
        IngredientMap.put(ItemID.SAPPHIRE_BOLTS, ItemID.SAPPHIRE_BOLTS);
        IngredientMap.put(ItemID.EMERALD_BOLTS, ItemID.EMERALD_BOLTS);
        IngredientMap.put(ItemID.RUBY_BOLTS, ItemID.RUBY_BOLTS);
        IngredientMap.put(ItemID.DIAMOND_BOLTS, ItemID.DIAMOND_BOLTS);
        IngredientMap.put(ItemID.DRAGONSTONE_BOLTS, ItemID.DRAGONSTONE_BOLTS);
        IngredientMap.put(ItemID.ONYX_BOLTS, ItemID.ONYX_BOLTS);
        IngredientMap.put(ItemID.OPAL_DRAGON_BOLTS, ItemID.OPAL_BOLTS);
        IngredientMap.put(ItemID.JADE_DRAGON_BOLTS, ItemID.JADE_BOLTS);
        IngredientMap.put(ItemID.PEARL_DRAGON_BOLTS, ItemID.PEARL_BOLTS);
        IngredientMap.put(ItemID.TOPAZ_DRAGON_BOLTS, ItemID.TOPAZ_BOLTS);
        IngredientMap.put(ItemID.SAPPHIRE_DRAGON_BOLTS, ItemID.SAPPHIRE_BOLTS);
        IngredientMap.put(ItemID.EMERALD_DRAGON_BOLTS, ItemID.EMERALD_BOLTS);
        IngredientMap.put(ItemID.RUBY_DRAGON_BOLTS, ItemID.RUBY_BOLTS);
        IngredientMap.put(ItemID.DIAMOND_DRAGON_BOLTS, ItemID.DIAMOND_BOLTS);
        IngredientMap.put(ItemID.DRAGONSTONE_DRAGON_BOLTS, ItemID.DRAGONSTONE_BOLTS);
        IngredientMap.put(ItemID.ONYX_DRAGON_BOLTS, ItemID.ONYX_BOLTS);

        // Products (Enchant Crossbow only)
        EnchantProducts.add(ItemID.OPAL_BOLTS_E);
        EnchantProducts.add(ItemID.JADE_BOLTS_E);
        EnchantProducts.add(ItemID.PEARL_BOLTS_E);
        EnchantProducts.add(ItemID.TOPAZ_BOLTS_E);
        EnchantProducts.add(ItemID.SAPPHIRE_BOLTS_E);
        EnchantProducts.add(ItemID.EMERALD_BOLTS_E);
        EnchantProducts.add(ItemID.RUBY_BOLTS_E);
        EnchantProducts.add(ItemID.DIAMOND_BOLTS_E);
        EnchantProducts.add(ItemID.DRAGONSTONE_BOLTS_E);
        EnchantProducts.add(ItemID.ONYX_BOLTS_E);
        EnchantProducts.add(ItemID.OPAL_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.JADE_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.PEARL_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.TOPAZ_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.SAPPHIRE_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.EMERALD_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.RUBY_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.DIAMOND_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.DRAGONSTONE_DRAGON_BOLTS_E);
        EnchantProducts.add(ItemID.ONYX_DRAGON_BOLTS_E);

    }

}
package com.salverrs.RemainingCasts.Events;

import com.salverrs.RemainingCasts.Model.RuneChanges;
import lombok.Getter;
import lombok.Setter;

@Getter
public class RunesChanged {
    private RuneChanges changes;

    public RunesChanged(RuneChanges changes)
    {
        this.changes = changes;
    }
}

package com.salverrs.RemainingCasts.Events;

import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import lombok.Getter;

import java.util.Map;

@Getter
public class BoltsEnchanted {
    private SpellInfo enchantSpell;

    private RuneChanges changes;

    public BoltsEnchanted(SpellInfo enchantSpell, RuneChanges changes)
    {
        this.enchantSpell = enchantSpell;
        this.changes = changes;
    }
}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Model.SpellFilterOption;
import net.runelite.client.config.*;

import java.awt.*;

@ConfigGroup(RemainingCastsPlugin.CONFIG_GROUP)
public interface RemainingCastsConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "Enable/disable Remaining Casts features",
			position = 0
	)
	String generalSection = "general";

	@ConfigSection(
			name = "Infoboxes",
			description = "Options relating to remaining casts infoboxes",
			position = 1
	)
	String infoboxSection = "infoboxes";

	@ConfigSection(
			name = "Chat warnings",
			description = "Options relating to remaining casts chat warnings",
			position = 2
	)
	String warningsSection = "warnings";

	@ConfigItem(
			keyName = "enableInfoboxes",
			name = "Show infoboxes",
			description = "Show remaining casts as individual info boxes",
			section = generalSection,
			position = 0
	)
	default boolean enableInfoboxes()
	{
		return true;
	}

	@ConfigItem(
		keyName = "enableMenuTooltip",
		name = "Show on menu tooltip",
		description = "Show remaining casts on the menu action tooltip",
		section = generalSection,
		position = 1
	)
	default boolean enableMenuTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableSpellTooltip",
			name = "Show on spell tooltip",
			description = "Show remaining casts on the detailed spell tooltip",
			section = generalSection,
			position = 2
	)
	default boolean enableSpellTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableChatWarnings",
			name = "Show chat warnings",
			description = "Show chat warnings when remaining casts reach a predefined amount",
			section = generalSection,
			position = 3
	)
	default boolean useChatWarnings() { return true;}

	@ConfigItem(
			keyName = "shortenCastAmounts",
			name = "Shorten cast amounts",
			description = "Shorten remaining cast amounts (e.g. 2512 -> 2.5k)",
			section = generalSection,
			position = 4
	)
	default boolean shortenCastAmounts()
	{
		return true;
	}

	@Units(Units.SECONDS)
	@ConfigItem(
			keyName = "infoBoxExpirySeconds",
			name = "Infobox expiry",
			description = "The number of seconds until an infobox will expire - 0 represents no expiry",
			section = infoboxSection,
			position = 5
	)
	default int infoBoxExpirySeconds()
	{
		return 15;
	}


	@ConfigItem(
			keyName = "infoBoxSpellLimit",
			name = "Maximum spells",
			description = "The maximum number of spells to track remaining casts for - 0 represents no limit",
			section = infoboxSection,
			position = 6
	)
	default int infoBoxSpellLimit()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "infoBoxThreshold",
			name = "Cast threshold",
			description = "Only show when casts remaining is less than the threshold - 0 represents no threshold",
			section = infoboxSection,
			position = 7
	)
	default int infoBoxThreshold()
	{
		return 0;
	}

	@ConfigItem(
			keyName = "showDetailedTooltip",
			name = "Show cost in tooltip",
			description = "Show the spell's rune cost within the infobox tooltip",
			section = infoboxSection,
			position = 8
	)
	default boolean showDetailedTooltip()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showInfoBoxSprites",
			name = "Show spell sprites",
			description = "Show the sprite image for the spell on the infobox",
			section = infoboxSection,
			position = 9
	)
	default boolean showInfoBoxSprites()
	{
		return true;
	}

	@ConfigItem(
			keyName = "spellFilterOption",
			name = "Spell filter",
			description = "Enable or disable whitelist/blacklist for spells",
			section = infoboxSection,
			position = 10
	)
	default SpellFilterOption spellFilterOption()
	{
		return SpellFilterOption.DISABLED;
	}

	@ConfigItem(
			keyName = "filterList",
			name = "Filter list",
			description = "The names of the spells you wish to whitelist/blacklist as comma separated values",
			section = infoboxSection,
			position = 11
	)
	default String filterList()
	{
		return "";
	}

	@ConfigItem(
			keyName = "pinnedSpells",
			name = "Pinned spells",
			description = "The names of the spells that should always display an infobox which never expires",
			section = infoboxSection,
			position = 12
	)
	default String pinnedSpells()
	{
		return "";
	}

	@ConfigItem(
			keyName = "pinnedSpells",
			name = "",
			description = ""
	)
	void setPinnedSpells(String playerName);

	@ConfigItem(
			keyName = "infoBoxTextColor",
			name = "Text color",
			description = "The color of the text displayed in the infobox",
			section = infoboxSection,
			position = 13
	)
	default Color infoBoxTextColor()
	{
		return Color.white;
	}

	@ConfigItem(
			keyName = "chatWarningNotification",
			name = "Enable notifications",
			description = "Enable Runelite notification alongside the chat warning",
			section = warningsSection,
			position = 14
	)
	default boolean useChatWarningNotifications()
	{
		return true;
	}

	@ConfigItem(
			keyName = "chatWarningThresholds",
			name = "Chat warning thresholds",
			description = "The cast amounts at which a chat warning will be triggered",
			section = warningsSection,
			position = 15
	)
	default String chatWarningThresholds()
	{
		return "0, 10, 50, 100, 500";
	}

	@ConfigItem(
			keyName = "chatWarningColor",
			name = "Text color",
			description = "The color of the text displayed in the chat warning",
			section = warningsSection,
			position = 16
	)
	default Color chatWarningColor()
	{
		return Color.orange;
	}

}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Events.BoltsEnchanted;
import com.salverrs.RemainingCasts.Events.RunesChanged;
import com.salverrs.RemainingCasts.Model.RuneChanges;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Util.RuneIds;
import com.salverrs.RemainingCasts.Util.SpellIds;
import net.runelite.api.*;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.PostClientTick;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;

@Singleton
public class CastSuppliesTracker {

    private static final int[] RUNE_POUCH_RUNE_VARBITS = {
            Varbits.RUNE_POUCH_RUNE1, Varbits.RUNE_POUCH_RUNE2, Varbits.RUNE_POUCH_RUNE3, Varbits.RUNE_POUCH_RUNE4
    };

    private static final int[] RUNE_POUCH_AMOUNT_VARBITS = {
            Varbits.RUNE_POUCH_AMOUNT1, Varbits.RUNE_POUCH_AMOUNT2, Varbits.RUNE_POUCH_AMOUNT3, Varbits.RUNE_POUCH_AMOUNT4
    };
    private static final int FOUNTAIN_OF_RUNES_VARBIT = 4145;

    final private Map<Integer, Integer> runeCount = new HashMap<>();
    final private Set<Integer> unlimitedRunes = new HashSet<>();
    private RuneChanges lastChanges;
    private boolean active = false;
    private boolean requiresPostUpdate = false;

    @Inject
    private Client client;
    @Inject
    private EventBus eventBus;

    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged event)
    {
        if (!active || !isRelevantItemContainer(event.getItemContainer()))
            return;

        updateRuneCount();
    }

    @Subscribe
    public void onVarbitChanged(VarbitChanged event)
    {
        if (!active || requiresPostUpdate || !isRelevantVarbit(event.getVarbitId()))
            return;

        requiresPostUpdate = true;
    }

    @Subscribe
    public void onPostClientTick(PostClientTick event)
    {
        if (!requiresPostUpdate)
            return;

        updateRuneCount();
        requiresPostUpdate = false;
    }

    public void start()
    {
        active = true;
        requiresPostUpdate = true;
    }

    public void stop()
    {
        requiresPostUpdate = false;
        active = false;
    }

    public Map<Integer, Integer> forceUpdateRuneCount()
    {
        updateRuneCount();
        return runeCount;
    }

    public Map<Integer, Integer> getLastRuneCount()
    {
        return runeCount;
    }

    private void updateRuneCount()
    {
        final Map<Integer, Integer> lastCount, changes;
        lastCount = new HashMap<>(runeCount);

        updateCurrentRuneCount();
        changes = calculateRuneChangesMap(lastCount, runeCount);

        if (changes.size() != 0)
        {
            lastChanges = new RuneChanges(changes, runeCount, unlimitedRunes);
            eventBus.post(new RunesChanged(lastChanges));

            final SpellInfo enchant = getEnchantSpellCast(changes);
            if (enchant != null)
                eventBus.post(new BoltsEnchanted(enchant, lastChanges));
        }
    }

    public void updateCurrentRuneCount()
    {
        resetRuneCount();
        updateContainerItems();
        checkGlobalVarbits();
    }

    private void updateContainerItems()
    {
        unlimitedRunes.clear();

        final ItemContainer inventory = client.getItemContainer(InventoryID.INVENTORY);
        final ItemContainer equipment = client.getItemContainer(InventoryID.EQUIPMENT);

        final Item[] inventoryItems = inventory != null ? inventory.getItems() : new Item[] {};
        final Item[] equipmentItems = equipment != null ? equipment.getItems() : new Item[] {};

        Arrays.stream(inventoryItems).forEach(i -> updateInventoryItem(i.getId(), i.getQuantity()));
        Arrays.stream(equipmentItems).forEach(i -> updateEquipmentItems(i.getId(), i.getQuantity()));
    }

    private void updateInventoryItem(int itemId, int quantity)
    {
        if (itemId == ItemID.RUNE_POUCH || itemId == ItemID.RUNE_POUCH_L)
        {
            updateRunePouchItems(false);
            return;
        }
        else if (itemId == ItemID.DIVINE_RUNE_POUCH || itemId == ItemID.DIVINE_RUNE_POUCH_L)
        {
            updateRunePouchItems(true);
            return;
        }
        else if (itemId == ItemID.RUNE_POUCH_23650) // LMS Rune pouch
        {
            addLMSRunePouch();
            return;
        }
        else if (itemId == ItemID.RUNE_POUCH_27086) // Emir's Arena Rune pouch (assumed to contain all, unable to get specific runes yet)
        {
            addUnlimitedRunes();
            return;
        }

        final Integer[] runes = RuneIds.getRuneIds(itemId);
        if (runes != null)
            Arrays.stream(runes).forEach(r -> updateRuneCount(r, quantity));

        final int ingredient = RuneIds.getIngredientId(itemId);
        if (ingredient != -1)
            updateRuneCount(ingredient, quantity);

        if (RuneIds.isEnchantProduct(itemId))
            updateRuneCount(itemId, quantity);

    }

    private void updateEquipmentItems(int itemId, int quantity)
    {
        if (RuneIds.isEnchantProduct(itemId))
            updateRuneCount(itemId, quantity);

        final Integer[] runes = RuneIds.getRuneIdsFromEquipment(itemId);
        if (runes != null)
        {
            Arrays.stream(runes).forEach(r -> {
                unlimitedRunes.add(r);
                updateRuneCount(r, Integer.MAX_VALUE);
            });
        }

        final Integer[] items = RuneIds.getItemIdsFromEquipment(itemId);
        if (items != null)
        {
            Arrays.stream(items).forEach(i -> {
                unlimitedRunes.add(i);
                updateRuneCount(i, quantity);
            });
        }
    }

    private void checkGlobalVarbits()
    {
        final boolean nearFountain = client.getVarbitValue(FOUNTAIN_OF_RUNES_VARBIT) == 1;

        if (nearFountain)
            addUnlimitedRunes();
    }

    private void updateRunePouchItems(boolean isDivine)
    {
        final EnumComposition runepouchEnum = client.getEnum(EnumID.RUNEPOUCH_RUNE);
        final int pouchSize = isDivine ? 4 : 3;

        for (int i = 0; i < pouchSize; i++)
        {
            final int id = client.getVarbitValue(RUNE_POUCH_RUNE_VARBITS[i]);
            final int quantity = client.getVarbitValue(RUNE_POUCH_AMOUNT_VARBITS[i]);

            if (id == 0 || quantity <= 0)
                continue;

            final int runeId = runepouchEnum.getIntValue(id);
            final Integer[] runes = RuneIds.getRuneIds(runeId);
            if (runes != null)
                Arrays.stream(runes).forEach(r -> updateRuneCount(r, quantity));
        }
    }

    private void addLMSRunePouch()
    {
        runeCount.put(ItemID.WATER_RUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.DEATH_RUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.BLOOD_RUNE, Integer.MAX_VALUE);
        runeCount.put(ItemID.SOUL_RUNE, Integer.MAX_VALUE);
    }

    private void addUnlimitedRunes()
    {
        final Set<Integer> allRuneIds = RuneIds.getAllRuneIds();
        allRuneIds.forEach(id -> runeCount.put(id, Integer.MAX_VALUE));
    }

    private void updateRuneCount(int runeId, int quantity)
    {
        final Integer currentValue = runeCount.getOrDefault(runeId, null);
        final long expectedValue = currentValue != null ? (long)currentValue + (long)quantity : (long)quantity;

        if (expectedValue >= Integer.MAX_VALUE)
        {
            runeCount.put(runeId, Integer.MAX_VALUE);
        }
        else
        {
            runeCount.put(runeId, (int)expectedValue);
        }
    }

    private Map<Integer, Integer> calculateRuneChangesMap(Map<Integer, Integer> oldRunes, Map<Integer, Integer> newRunes)
    {
        final Map<Integer, Integer> changeMap = new HashMap<>();
        final Set<Integer> runeKeys = new HashSet<>(oldRunes.keySet());
        runeKeys.addAll(newRunes.keySet());

        for (Integer runeId : runeKeys)
        {
            final int oldQuantity = oldRunes.getOrDefault(runeId, 0);
            final int newQuantity = newRunes.getOrDefault(runeId, 0);
            final int change = newQuantity - oldQuantity;

            if (change != 0)
                changeMap.put(runeId, change);
        }

        return changeMap;
    }

    private SpellInfo getEnchantSpellCast(Map<Integer, Integer> changes)
    {
        for (int itemId : changes.keySet())
        {
            final int change = changes.get(itemId);
            final SpellInfo enchant = SpellIds.getSpellByProduct(itemId, change);

            if (enchant != null)
                return enchant;
        }

        return null;
    }

    private void resetRuneCount()
    {
        runeCount.clear();
    }

    private boolean isRelevantItemContainer(ItemContainer container)
    {
        return container == client.getItemContainer(InventoryID.INVENTORY)
            || container == client.getItemContainer(InventoryID.EQUIPMENT);
    }

    private boolean isRelevantVarbit(int varbitId)
    {
        return varbitId == FOUNTAIN_OF_RUNES_VARBIT ||
            Arrays.stream(RUNE_POUCH_RUNE_VARBITS).anyMatch(v -> v == varbitId) ||
            Arrays.stream(RUNE_POUCH_AMOUNT_VARBITS).anyMatch(v -> v == varbitId);
    }
}

package com.salverrs.RemainingCasts;

import com.salverrs.RemainingCasts.Model.SpellCost;
import com.salverrs.RemainingCasts.Model.SpellInfo;
import com.salverrs.RemainingCasts.Model.TooltipDetails;
import com.salverrs.RemainingCasts.Util.CastUtils;
import com.salverrs.RemainingCasts.Util.SpellIds;
import net.runelite.api.*;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.events.ScriptPreFired;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.util.Text;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.*;
import java.util.function.Consumer;

@Singleton
public class TooltipCastUpdater {

    private int mageBookTooltipWidgetId = -1;
    private int autocastTooltipWidgetId = -1;
    private boolean active = false;
    private ArrayList<String> pinnedSpellNames;

    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private CastSuppliesTracker castSuppliesTracker;
    @Inject RemainingCastsConfig config;

    public void start()
    {
        active = true;
        pinnedSpellNames = new ArrayList<>(Text.fromCSV(config.pinnedSpells()));
    }

    public void stop()
    {
        active = false;
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (!active || (!config.enableMenuTooltip() && !config.enableInfoboxes()) || client.getGameState() != GameState.LOGGED_IN || client.isMenuOpen())
            return;

        final List<MenuEntry> entries = new ArrayList<>(Arrays.asList(client.getMenuEntries()));
        boolean appendToOption = false;
        SpellInfo spellInfoFound = null;
        String formattedSpellInfoName = null;

        if (entries.stream().anyMatch(e -> e.getOption().equals("Examine")))
            return;

        for (MenuEntry entry : entries)
        {
            final Widget widget = entry.getWidget();
            if (widget == null)
                continue;

            // Autocast 'Choose spell' menu replacement
            if (entry.getOption().equals("Choose spell"))
            {
                final Widget spellIcon = client.getWidget(WidgetInfo.COMBAT_SPELL_ICON);

                if (spellIcon == null)
                    continue;

                final int spriteId = spellIcon.getSpriteId();
                final SpellInfo spellInfo = SpellIds.getSpellBySpriteId(spriteId);

                if (spellInfo == null)
                    continue;

                spellInfoFound = spellInfo;
                formattedSpellInfoName = spellInfo.getName();

                if (config.enableMenuTooltip())
                {
                    final Map<Integer, Integer> runeCount = castSuppliesTracker.getLastRuneCount();
                    final int numCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
                    final String casts = "(" + getRemainingCastsString(numCasts) + ")";
                    entry.setOption(spellInfo.getName() + " " + casts);
                }

                continue;
            }

            // Spell book and autocast spell select menu replacement
            String spellName = Text.removeFormattingTags(widget.getName()); // Standard spell book interface
            SpellInfo spellInfo = SpellIds.getSpellByName(spellName);

            if (spellInfo == null) // Autocast fallback
            {
                spellName = Text.removeFormattingTags(entry.getOption()); // Autocast menu uses option only
                spellInfo = SpellIds.getSpellByName(spellName);
                formattedSpellInfoName = entry.getOption();
                appendToOption = true;
            }
            else
            {
                formattedSpellInfoName = entry.getTarget();
            }

            if (spellInfo == null)
                continue;

            spellInfoFound = spellInfo;

            if (!config.enableMenuTooltip()) // Continue if only using pin functionality
                continue;

            if (entry.getOption().equals("Configure") || entry.getOption().equals("Warnings")) // Ignore entries other than cast entries
                continue;

            final Map<Integer, Integer> runeCount = castSuppliesTracker.getLastRuneCount();
            final int numCasts = spellInfo.getSpellCost().getRemainingCasts(runeCount);
            final String casts = "(" + getRemainingCastsString(numCasts) + ")";

            if (appendToOption)
            {
                final String option = entry.getOption();
                if (option.endsWith(casts))
                    continue;

                entry.setOption(option + " " + casts);
            }
            else
            {
                final String target = entry.getTarget();
                if (target.endsWith(casts))
                    continue;

                entry.setTarget(target + " " + casts);
            }
        }

        // Pin/Unpin infobox menu functionality
        if (spellInfoFound == null || !config.enableInfoboxes())
            return;

        final SpellInfo target = spellInfoFound;
        boolean isPinned = Text.fromCSV(config.pinnedSpells()).stream().anyMatch(s -> s.equalsIgnoreCase(target.getName()));

        client.createMenuEntry(-1)
                .setOption(isPinned ? "Unpin" : "Pin")
                .setTarget(formattedSpellInfoName)
                .setType(MenuAction.RUNELITE)
                .onClick(isPinned ? unpinSpell(target) : pinSpell(target));
    }

    @Subscribe
    public void onScriptPreFired(ScriptPreFired event)
    {
        if (!active || !config.enableSpellTooltip())
            return;

        final boolean isMageBookTooltip = event.getScriptId() == 2622; // main spell tool tip
        final boolean isAutocastTooltip = event.getScriptId() == 238; // auto cast tooltip

        if (!isMageBookTooltip && !isAutocastTooltip)
            return;

        final ScriptEvent scriptEvent = event.getScriptEvent();
        final Object[] args = scriptEvent.getArguments();
        final int tooltipWidgetArgIndex = isMageBookTooltip ? 5 : 1;

        if (isMageBookTooltip)
            mageBookTooltipWidgetId = (int)args[tooltipWidgetArgIndex];
        else if (isAutocastTooltip)
            autocastTooltipWidgetId = (int)args[tooltipWidgetArgIndex];
    }

    @Subscribe
    public void onScriptPostFired(ScriptPostFired event)
    {
        if (!active || !config.enableSpellTooltip())
            return;

        final int scriptId = event.getScriptId();
        if (scriptId != 2622 && scriptId != 238)
            return;

        final int widgetId = scriptId == 2622 ? mageBookTooltipWidgetId : autocastTooltipWidgetId;

        clientThread.invoke(() ->
        {
            Widget widget = client.getWidget(widgetId);
            if (widget == null)
                return;

            Widget[] children = widget.getChildren();
            if (children == null || children.length == 0)
                return;

            final Widget spellTitle = getTitleWidget(children);
            if (spellTitle == null)
                return;

            final TooltipDetails details = getSpellTooltipDetails(spellTitle);
            if (details == null)
                return;

            if (details.getSpellName().contains("Home Teleport")) // For consistency
            {
                final String newText = "[" + details.getSpellLevel() + "] " + details.getSpellName();
                spellTitle.setText(newText);
                return;
            }

            SpellInfo spellInfo = SpellIds.getSpellByName(details.getSpellName());

            if (spellInfo == null)
                spellInfo = SpellIds.getSpellByName(details.getSpellName().concat(" Teleport")); // Normal Ancients compatibility ('Teleport' is not included in new spell tooltip)

            if (spellInfo == null)
                return;

            final SpellCost spellCost = spellInfo.getSpellCost();
            final int numCasts = spellCost.getRemainingCasts(castSuppliesTracker.getLastRuneCount());

            String newText = "[" + details.getSpellLevel() + "] " + details.getSpellName();
            newText += " (" + getRemainingCastsString(numCasts) + ")" ;

            spellTitle.setText(newText);
        });

    }

    @Subscribe
    public void onConfigChanged(ConfigChanged configChanged)
    {
        if (!configChanged.getGroup().equals(RemainingCastsPlugin.CONFIG_GROUP))
            return;

        pinnedSpellNames = new ArrayList<>(Text.fromCSV(config.pinnedSpells()));
    }

    private Widget getTitleWidget(Widget[] tooltipChildren)
    {
        return Arrays.stream(tooltipChildren)
                .filter(c -> c.getText().contains("Level"))
                .findFirst()
                .orElse(null);
    }

    private TooltipDetails getSpellTooltipDetails(Widget titleWidget)
    {
        final String titleText = titleWidget.getText();
        final String[] split = titleText.split(": ");
        if (split.length < 2)
            return null;

        final String name = split[1];
        final String[] levelSplit = split[0].split("Level ");
        if (levelSplit.length < 2)
            return null;

        final String level = levelSplit[1];
        return new TooltipDetails(name, level);
    }

    private String getRemainingCastsString(int numCasts)
    {
        if (numCasts == -1)
            return "N/A";

        return config.shortenCastAmounts() ? CastUtils.getShortenedAmount(numCasts) : CastUtils.formatCastAmount(numCasts);
    }

    private Consumer<MenuEntry> pinSpell(SpellInfo spellInfo)
    {
        return e ->
        {
            pinnedSpellNames.add(spellInfo.getName());
            config.setPinnedSpells(Text.toCSV(pinnedSpellNames));
        };
    }

    private Consumer<MenuEntry> unpinSpell(SpellInfo spellInfo)
    {
        return e ->
        {
            pinnedSpellNames.removeIf(s -> s.equalsIgnoreCase(spellInfo.getName()));
            config.setPinnedSpells(Text.toCSV(pinnedSpellNames));
        };
    }

}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class SpellInfo {
    private String name;
    private int spriteId;
    private SpellCost spellCost;
    private SpellProduct[] spellProducts;

    public SpellInfo(String name, int spriteId, SpellCost spellCost, SpellProduct... products)
    {
        this(name, spriteId, spellCost);
        this.spellProducts = products;
    }

    public SpellInfo(String name, int spriteId, SpellCost spellCost)
    {
        this.name = name;
        this.spriteId = spriteId;
        this.spellCost = spellCost;
    }

}

package com.salverrs.RemainingCasts.Model;

import com.google.common.primitives.Ints;
import lombok.Getter;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Getter
public class RuneChanges {

    private Map<Integer, Integer> changes;
    private Map<Integer, Integer> currentRunes;
    private Set<Integer> unlimitedRunes;

    public RuneChanges(Map<Integer, Integer> changes, Map<Integer, Integer> currentRunes, Set<Integer> unlimitedRunes)
    {
        this.changes = changes;
        this.currentRunes = currentRunes;
        this.unlimitedRunes = unlimitedRunes;
    }

    public Map<Integer, Integer> getInvertedChanges()
    {
        Map<Integer, Integer> costMap = new HashMap<>(changes);
        costMap.replaceAll((k,v) -> v * -1);
        return costMap;
    }

}

package com.salverrs.RemainingCasts.Model;

import com.salverrs.RemainingCasts.Util.RuneIds;
import lombok.Getter;
import net.runelite.api.ItemID;

import java.util.*;

@Getter
public class SpellCost {
    private final int[] runes;
    private final int[] quantities;

    public SpellCost(int[] runeIds, int[] quantities)
    {
        if (runeIds.length != quantities.length)
            throw new IndexOutOfBoundsException();

        this.runes = runeIds;
        this.quantities = quantities;
    }

    public boolean matchesCost(Map<Integer, Integer> runeCount, Set<Integer> unlimitedRunes)
    {
        for (int i = 0; i < runes.length; i++)
        {
            final int targetRuneId = runes[i];
            if (!unlimitedRunes.contains(targetRuneId) && (!runeCount.containsKey(targetRuneId) || runeCount.get(targetRuneId) < quantities[i]))
                return false;
        }

        return true;
    }

    public int getRemainingCasts(Map<Integer, Integer> runeCount)
    {
        final List<Integer> castsPerRune = new ArrayList<Integer>();
        for (int i = 0; i < runes.length; i++)
        {
            final int targetRuneId = runes[i];
            if (runeCount.containsKey(targetRuneId))
            {
                final int available = runeCount.get(targetRuneId);
                final int cost = quantities[i];
                final boolean isReqStaff = available >= 1 && RuneIds.isReqStaff(targetRuneId);

                if (available == Integer.MAX_VALUE || isReqStaff)
                {
                    castsPerRune.add(Integer.MAX_VALUE);
                }
                else
                {
                    castsPerRune.add(Math.floorDiv(available, cost));
                }
            }
            else
            {
                return 0;
            }
        }

        return Collections.min(castsPerRune);
    }

}


package com.salverrs.RemainingCasts.Model;

public enum SpellFilterOption {
    DISABLED,
    BLACKLIST,
    WHITELIST
}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class TooltipDetails {
    private String spellName;
    private String spellLevel;

    public TooltipDetails(String name, String level)
    {
        this.spellName = name;
        this.spellLevel = level;
    }

}

package com.salverrs.RemainingCasts.Model;

import lombok.Getter;

@Getter
public class SpellProduct {
    public int itemId;
    public int quantity;

    public SpellProduct(int id, int quantity)
    {
        this.itemId = id;
        this.quantity = quantity;
    }

    @Override
    public int hashCode()
    {
        return itemId * quantity * 31;
    }

    @Override
    public boolean equals(Object o)
    {
        if (o == this)
            return true;

        if (!(o instanceof SpellProduct))
            return false;

        return this.hashCode() == o.hashCode();
    }
}

