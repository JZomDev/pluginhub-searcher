package com.flux;

import com.flux.services.ClanRankMonitor;
import com.flux.services.CompetitionScheduler;
import com.flux.services.GoogleSheetParser;
import com.flux.services.LoginMessageSender;
import com.flux.services.wom.CompetitionConfigUpdater;
import com.flux.services.wom.CompetitionDataParser;
import com.flux.services.wom.CompetitionFinder;
import com.flux.services.wom.WiseOldManApiClient;
import com.google.inject.Provides;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;

import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;

import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
        name = "Flux",
        description = "A plugin used to keep track of clan events.",
        tags = {"flux", "cc", "hunt", "pass", "event", "clan"}
)
public class FluxPlugin extends Plugin {
    public static final String CONFIG_GROUP = "flux";

    @Inject private Client client;
    @Inject private ChatMessageManager chatMessageManager;
    @Inject private FluxConfig config;
    @Inject private ConfigManager configManager;
    @Inject private OverlayManager overlayManager;
    @Inject private FluxOverlay overlay;
    @Inject private ClientToolbar clientToolbar;
    @Inject private OkHttpClient okHttpClient;

    private FluxPanel panel;
    private NavigationButton uiNavigationButton;
    private CompetitionScheduler competitionScheduler;
    private GoogleSheetParser configParser;
    private ClanRankMonitor clanRankMonitor;
    private LoginMessageSender loginMessageSender;

    @Override
    protected void startUp() {
        overlayManager.add(overlay);
        initializeServices();
        initializePanel();
        configParser.start();
        refreshAllCards();
    }

    @Override
    protected void shutDown() {
        overlayManager.remove(overlay);
        clientToolbar.removeNavigation(uiNavigationButton);
        panel.shutdown();
        configParser.shutdown();
        clanRankMonitor.shutdown();
    }

    private void initializePanel() {
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/flux-icon-tiny.png");

        panel = new FluxPanel(competitionScheduler, config, configManager);

        uiNavigationButton = NavigationButton.builder()
                .tooltip("Flux")
                .icon(icon)
                .priority(config.menuPriority())
                .panel(panel)
                .build();

        clientToolbar.addNavigation(uiNavigationButton);
    }

    private void initializeServices() {
        WiseOldManApiClient apiClient = new WiseOldManApiClient(okHttpClient);
        CompetitionDataParser dataParser = new CompetitionDataParser();
        CompetitionFinder finder = new CompetitionFinder(apiClient, dataParser);
        CompetitionConfigUpdater configUpdater = new CompetitionConfigUpdater(configManager);

        competitionScheduler = new CompetitionScheduler(
                configManager,
                apiClient,
                finder,
                configUpdater
        );

        configParser = new GoogleSheetParser(
                configManager,
                GoogleSheetParser.SheetType.CONFIG,
                this::handleConfigUpdate,
                true,
                okHttpClient
        );

        clanRankMonitor = new ClanRankMonitor(client, this::handleRankChange);
        loginMessageSender = new LoginMessageSender(chatMessageManager, configManager);
    }

    private void refreshAllCards() {
        if (panel != null) {
            if (panel.getSotwCard() != null) {
                panel.getSotwCard().checkEventStateChanged();
            }
            if (panel.getBotmCard() != null) {
                panel.getBotmCard().checkEventStateChanged();
            }
            if (panel.getHuntCard() != null) {
                panel.getHuntCard().checkEventStateChanged();
            }
        }
    }

    private void handleRankChange(boolean isAdmiralOrHigher) {
        if (panel != null) {
            panel.updateClanRankStatus(isAdmiralOrHigher);
        }
    }

    private void handleConfigUpdate(java.util.Map<String, String> configValues) {
        log.debug("Received config updates from Google Sheets");

        updateLoginMessage(configValues);
        updateAnnouncementMessage(configValues);
        updateRollCallStatus(configValues);
        updateHuntTeamColors(configValues);
        updateBotmPass(configValues);
    }

    private void updateLoginMessage(java.util.Map<String, String> configValues) {
        String loginMsg = configValues.get("LOGIN_MESSAGE");
        if (loginMsg != null && !loginMsg.isEmpty()) {
            String currentValue = configManager.getConfiguration(CONFIG_GROUP, "clan_login_message");
            if (!loginMsg.equals(currentValue)) {
                configManager.setConfiguration(CONFIG_GROUP, "clan_login_message", loginMsg);
                log.debug("Updated LOGIN_MESSAGE: {}", loginMsg);
            }
        }
    }

    private void updateAnnouncementMessage(java.util.Map<String, String> configValues) {
        String announcement = configValues.get("ANNOUNCEMENT_MESSAGE");
        if (announcement != null && !announcement.isEmpty()) {
            String currentAnnouncement = configManager.getConfiguration(CONFIG_GROUP, "plugin_announcement_message");

            if (!announcement.equals(currentAnnouncement)) {
                log.debug("Updating ANNOUNCEMENT_MESSAGE: {}", announcement);
                configManager.setConfiguration(CONFIG_GROUP, "plugin_announcement_message", announcement);

                if (panel != null && panel.getHomeCard() != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        panel.getHomeCard().refreshPluginAnnouncement();
                        panel.getHomeCard().refreshButtonLinks();
                    });
                }
            }
        }
    }

    private void updateRollCallStatus(java.util.Map<String, String> configValues) {
        String rollCallActive = configValues.get("ROLL_CALL_ACTIVE");
        if (rollCallActive != null && !rollCallActive.isEmpty()) {
            boolean isActive = rollCallActive.equalsIgnoreCase("TRUE");
            String currentStatus = configManager.getConfiguration(CONFIG_GROUP, "rollCallActive");
            boolean currentActive = currentStatus != null && Boolean.parseBoolean(currentStatus);

            if (isActive != currentActive) {
                log.debug("Updating ROLL_CALL_ACTIVE: {}", isActive);
                configManager.setConfiguration(CONFIG_GROUP, "rollCallActive", String.valueOf(isActive));

                if (panel != null) {
                    javax.swing.SwingUtilities.invokeLater(() -> {
                        if (panel.getHomeCard() != null) {
                            panel.getHomeCard().isRollCallActive();
                        }
                        if (panel.getAdminHubCard() != null) {
                            panel.getAdminHubCard().refresh();
                        }
                    });
                }
            }
        }
    }

    private void updateHuntTeamColors(java.util.Map<String, String> configValues) {
        // TEAM 1 COLOR
        String team1Color = configValues.get("TEAM_1_COLOR");
        if (team1Color != null && !team1Color.isEmpty()) {
            String currentTeam1Color = configManager.getConfiguration(CONFIG_GROUP, "hunt_team_1_color");
            if (!team1Color.equals(currentTeam1Color)) {
                configManager.setConfiguration(CONFIG_GROUP, "hunt_team_1_color", team1Color);
                log.debug("Updated TEAM_1_COLOR: {}", team1Color);
            }
        }

        // TEAM 2 COLOR
        String team2Color = configValues.get("TEAM_2_COLOR");
        if (team2Color != null && !team2Color.isEmpty()) {
            String currentTeam2Color = configManager.getConfiguration(CONFIG_GROUP, "hunt_team_2_color");
            if (!team2Color.equals(currentTeam2Color)) {
                configManager.setConfiguration(CONFIG_GROUP, "hunt_team_2_color", team2Color);
                log.debug("Updated TEAM_2_COLOR: {}", team2Color);
            }
        }

        // refresh the Hunt card UI if it existsto apply color change
        if (panel != null && panel.getHuntCard() != null) {
            javax.swing.SwingUtilities.invokeLater(() -> panel.getHuntCard().updateTeamLabels());
        }
    }

    private void updateBotmPass(java.util.Map<String, String> configValues) {
        String botmPass = configValues.get("BOTM_PASS");
        if (botmPass != null && !botmPass.isEmpty()) {
            String currentValue = configManager.getConfiguration(CONFIG_GROUP, "botm_password");
            if (!botmPass.equals(currentValue)) {
                configManager.setConfiguration(CONFIG_GROUP, "botm_password", botmPass);
                log.debug("Updated BOTM_PASS: {}", botmPass);
            }
        } else {
            log.warn("BOTM_PASS is missing or empty in the Google Sheet values.");
        }
    }


    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        GameState state = event.getGameState();

        if (state == GameState.LOGGED_IN) {
            loginMessageSender.sendLoginMessage();
            clanRankMonitor.startMonitoring();
        } else if (state == GameState.LOGIN_SCREEN) {
            loginMessageSender.reset();
            clanRankMonitor.stopMonitoring();
        }
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged event) {
        if (!event.getGroup().equals(CONFIG_GROUP)) {
            return;
        }

        String key = event.getKey();
        log.debug("CONFIG CHANGE EVENT KEY: {}", key);

        if (key.equals("plugin_announcement_message")) {
            if (panel != null && panel.getHomeCard() != null) {
                panel.getHomeCard().refreshPluginAnnouncement();
                panel.getHomeCard().refreshButtonLinks();
            }
        }

        if (key.equals("rollCallActive")) {
            log.debug("Roll Call Status Changed");
            if (panel != null && panel.getHomeCard() != null) {
                panel.getHomeCard().isRollCallActive();
            }
            if (panel != null && panel.getAdminHubCard() != null) {
                panel.getAdminHubCard().refresh();
            }
        }

        if (key.equals("botmActive") || key.equals("botm_active")) {
            if (panel != null && panel.getBotmCard() != null) {
                panel.getBotmCard().checkEventStateChanged();
            }
        }

        if (key.equals("sotw_active") || key.equals("sotwActive")) {
            if (panel != null) {
                panel.refreshAllCards();
                if (panel.getSotwCard() != null) {
                    panel.getSotwCard().checkEventStateChanged();
                }
            }
        }

        if (key.equals("sotw_wom_link") || key.equals("sotwWomLink")) {
            if (panel != null && panel.getSotwCard() != null) {
                panel.getSotwCard().refreshButtonLinks();
            }
        }

        if (key.equals("sotw_leaderboard") || key.equals("sotwLeaderboard")) {
            if (panel != null) {
                panel.refreshAllCards();
            }
        }

        if (key.equals("huntActive")) {
            if (panel != null) {
                if (panel.getHuntCard() != null) {
                    panel.getHuntCard().checkEventStateChanged();
                }
                if (panel.getHomeCard() != null) {
                    panel.getHomeCard().refreshHuntStatus();
                }
            }
        }

        if (key.equals("huntTitle")) {
            if (panel != null && panel.getHuntCard() != null) {
                panel.getHuntCard().updateEventTitle();
            }
        }

        if (key.equals("hunt_team_1_name") || key.equals("hunt_team_2_name") ||
                key.equals("hunt_team_1_color") || key.equals("hunt_team_2_color")) {
            if (panel != null && panel.getHuntCard() != null) {
                panel.getHuntCard().updateTeamLabels();
            }
        }

        if (key.equals("hunt_team_1_leaderboard") || key.equals("hunt_team_2_leaderboard")) {
            if (panel != null && panel.getHuntCard() != null) {
                panel.getHuntCard().refreshLeaderboard();
            }
        }

        if (key.equals("hunt_team_1_score") || key.equals("hunt_team_2_score")) {
            if (panel != null && panel.getHuntCard() != null) {
                panel.getHuntCard().updateTeamScores();
            }
        }

        if (key.equals("hunt_wom_url") || key.equals("hunt_gdoc_url")) {
            if (panel != null && panel.getHuntCard() != null) {
                panel.getHuntCard().refreshButtonLinks();
            }
        }
    }

    @Provides
    FluxConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(FluxConfig.class);
    }
}
package com.flux;

import java.awt.*;
import java.util.*;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.Timer;

import com.flux.components.InverseCornerButton;
import com.flux.components.combobox.ComboBoxIconEntry;
import com.flux.components.combobox.ComboBoxIconListRenderer;
import com.flux.constants.EntrySelect;
import com.flux.services.CompetitionScheduler;
import net.runelite.client.config.ConfigManager;
import com.flux.cards.*;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;
import okhttp3.*;

public class FluxPanel extends PluginPanel {
    private static final int GLOW_CHECK_INTERVAL = 500;
    private static final int SCROLL_UNIT_INCREMENT = 16;

    private final FluxConfig config;
    private final ConfigManager configManager;
    private final CompetitionScheduler competitionScheduler;

    private final JPanel headerPanel = new JPanel();
    private final JPanel centerPanel = new JPanel();
    private final JPanel footerPanel = new JPanel();
    private final CardLayout cardLayout = new CardLayout();

    private final JComboBox<ComboBoxIconEntry> dropdown = new JComboBox<>();
    private final ComboBoxIconListRenderer renderer = new ComboBoxIconListRenderer();
    private final java.util.List<InverseCornerButton> footerButtons = new ArrayList<>();

    private final Map<EntrySelect, JPanel> cards = new EnumMap<>(EntrySelect.class);
    private HomeCard homeCard;
    private SotwCard sotwCard;
    private BotmCard botmCard;
    private AdminHubCard adminHubCard;
    private HuntCard huntCard;

    private InverseCornerButton activeFooterButton;
    private boolean isAdminOrHigher = false;
    private boolean adminHubInitialized = false;

    @Inject
    private OkHttpClient okHttpClient;

    private final Timer glowTimer = new Timer(GLOW_CHECK_INTERVAL, e -> updateEventGlows());

    public FluxPanel(CompetitionScheduler competitionScheduler, FluxConfig config, ConfigManager configManager) {
        super(false);
        this.competitionScheduler = competitionScheduler;
        this.config = config;
        this.configManager = configManager;

        setupLayout();
        glowTimer.start();
        initializeCards();
        setupHeader();
        setupFooter();
        selectFirstEntry();
    }

    @Override
    public void onActivate()
    {
        competitionScheduler.start();
    }

    @Override
    public void onDeactivate()
    {
        competitionScheduler.stop();
    }

    private void setupLayout() {
        setLayout(new BorderLayout());

        centerPanel.setLayout(cardLayout);
        centerPanel.setOpaque(false);

        add(headerPanel, BorderLayout.NORTH);
        add(centerPanel, BorderLayout.CENTER);
        add(footerPanel, BorderLayout.SOUTH);
    }

    private void initializeCards() {
        addEntry(config.entry_1());
        addEntry(config.entry_3());
        addEntry(config.entry_4());
        addEntry(config.entry_5());
        addEntry(config.entry_6());
        addEntry(config.entry_7());
        addEntry(config.entry_8());
    }

    private void setupHeader() {
        headerPanel.removeAll();
        headerPanel.setLayout(new FlowLayout(FlowLayout.CENTER));

        configureDropdown();
        headerPanel.add(dropdown);

        headerPanel.revalidate();
        headerPanel.repaint();
    }

    private void configureDropdown() {
        dropdown.setFocusable(false);
        dropdown.setForeground(Color.WHITE);
        dropdown.setRenderer(renderer);
        dropdown.addActionListener(e -> handleDropdownSelection());
    }

    private void handleDropdownSelection() {
        ComboBoxIconEntry selectedItem = (ComboBoxIconEntry) dropdown.getSelectedItem();
        if (selectedItem == null || !selectedItem.getId().isPresent()) {
            return;
        }

        String cardId = selectedItem.getId().get();
        String selectedText = selectedItem.getText().trim();

        activateButtonByLabel(selectedText);
        cardLayout.show(centerPanel, cardId);
    }

    private void setupFooter() {
        footerPanel.removeAll();
        footerPanel.setLayout(new GridBagLayout());
        footerPanel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));

        GridBagConstraints gbc = createFooterConstraints();

        for (int i = 0; i < footerButtons.size(); i++) {
            configureButtonPosition(gbc, i);
            footerPanel.add(footerButtons.get(i), gbc);
        }

        footerPanel.revalidate();
        footerPanel.repaint();

        activateFirstButton();
    }

    private GridBagConstraints createFooterConstraints() {
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        return gbc;
    }

    private void configureButtonPosition(GridBagConstraints gbc, int index) {
        gbc.gridx = index % 2;
        gbc.gridy = index / 2;
        gbc.gridwidth = 1;

        if (index == footerButtons.size() - 1 && footerButtons.size() % 2 != 0) {
            gbc.gridx = 0;
            gbc.gridwidth = 2;
        }
    }

    private void addEntry(EntrySelect entry) {
        EntryConfig entryConfig = createEntryConfig(entry);
        if (entryConfig == null) {
            return;
        }

        addToDropdown(entryConfig);
        InverseCornerButton button = createFooterButton(entryConfig, entry);
        footerButtons.add(button);

        centerPanel.add(makeScrollable(entryConfig.card), entry.name().toLowerCase());
        cards.put(entry, entryConfig.card);
    }

    private EntryConfig createEntryConfig(EntrySelect entry) {
        switch (entry) {
            case HOME:
                homeCard = new HomeCard(config, configManager);
                return new EntryConfig(" Home", "/home.png", homeCard, entry);

            case SOTW:
                sotwCard = new SotwCard(configManager);
                return new EntryConfig(" SOTW", "/sotw.png", sotwCard, entry);

            case BOTM:
                botmCard = new BotmCard(configManager, okHttpClient);
                return new EntryConfig(" BOTM", "/botm.png", botmCard, entry);

            case HUB:
                adminHubCard = new AdminHubCard(config, configManager);
                return new EntryConfig(" Admin Hub", "/hub.png", adminHubCard, entry);

            case HUNT:
                huntCard = new HuntCard(configManager, okHttpClient);
                return new EntryConfig(" The Hunt", "/hunt.png", huntCard, entry);

            default:
                return null;
        }
    }

    private void addToDropdown(EntryConfig config) {
        dropdown.addItem(new ComboBoxIconEntry(
                new ImageIcon(ImageUtil.loadImageResource(getClass(), config.iconPath)),
                config.label,
                Optional.of(config.entry.name().toLowerCase())
        ));
    }

    private InverseCornerButton createFooterButton(EntryConfig config, EntrySelect entry) {
        InverseCornerButton button = InverseCornerButton.withImage(config.label, config.iconPath);
        button.addActionListener(e -> {
            activateFooterButton(button);
            cardLayout.show(centerPanel, entry.name().toLowerCase());
        });
        return button;
    }

    public void updateClanRankStatus(boolean isAdminOrHigher) {
        if (this.isAdminOrHigher == isAdminOrHigher && adminHubInitialized) {
            return;
        }

        this.isAdminOrHigher = isAdminOrHigher;

        if (isAdminOrHigher && !adminHubInitialized) {
            addEntry(config.entry_2());
            setupFooter();
            dropdown.repaint();
            centerPanel.revalidate();
            centerPanel.repaint();
            adminHubInitialized = true;
        }
    }

    private void activateFooterButton(InverseCornerButton button) {
        if (activeFooterButton != null) {
            activeFooterButton.setActive(false);
        }

        activeFooterButton = button;
        activeFooterButton.setActive(true);

        syncDropdownWithButton(button.getText().trim());
    }

    private void activateButtonByLabel(String label) {
        footerButtons.stream()
                .filter(btn -> btn.getText().trim().equals(label))
                .findFirst()
                .ifPresent(this::activateFooterButton);
    }

    private void syncDropdownWithButton(String buttonLabel) {
        for (int i = 0; i < dropdown.getItemCount(); i++) {
            ComboBoxIconEntry item = dropdown.getItemAt(i);
            if (item.getText().trim().equals(buttonLabel) && dropdown.getSelectedIndex() != i) {
                dropdown.setSelectedIndex(i);
                break;
            }
        }
    }

    private void setButtonGlow(String label, boolean glow) {
        footerButtons.stream()
                .filter(btn -> btn.getText().trim().equalsIgnoreCase(label.trim()))
                .findFirst()
                .ifPresent(btn -> {
                    btn.setGlowing(glow);
                    if (!glow) {
                        btn.repaint();
                        footerPanel.repaint();
                    }
                });
    }

    private void updateEventGlows() {
        updateCardGlow(sotwCard, " SOTW", card -> card.isEventActive());
        updateCardGlow(botmCard, " BOTM", card -> card.isEventActive());
        updateCardGlow(huntCard, " The Hunt", card -> card.isEventActive());

        if (homeCard != null) {
            homeCard.isRollCallActive();
        }
    }

    private <T extends JPanel> void updateCardGlow(T card, String label, EventActiveChecker<T> checker) {
        if (card != null) {
            boolean active = checker.isActive(card);
            setButtonGlow(label, active);

            if (homeCard != null) {
                updateHomeCardEventStatus(label, active);
            }
        }
    }

    private void updateHomeCardEventStatus(String label, boolean active) {
        switch (label.trim()) {
            case "SOTW":
                homeCard.updateSotwStatus(active);
                break;
            case "BOTM":
                homeCard.updateBotmStatus(active);
                break;
            case "The Hunt":
                homeCard.updateHuntStatus(active);
                break;
        }
    }

    private void selectFirstEntry() {
        if (dropdown.getItemCount() > 0) {
            dropdown.setSelectedIndex(0);
        }
    }

    private void activateFirstButton() {
        if (!footerButtons.isEmpty()) {
            footerButtons.get(0).doClick();
        }
    }

    private JScrollPane makeScrollable(JPanel card) {
        JScrollPane scroll = new JScrollPane(card);
        scroll.setBorder(null);
        scroll.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        scroll.getVerticalScrollBar().setUnitIncrement(SCROLL_UNIT_INCREMENT);
        scroll.setOpaque(false);
        scroll.getViewport().setOpaque(false);
        return scroll;
    }

    public HomeCard getHomeCard() { return homeCard; }
    public BotmCard getBotmCard() { return botmCard; }
    public SotwCard getSotwCard() { return sotwCard; }
    public HuntCard getHuntCard() { return huntCard; }
    public AdminHubCard getAdminHubCard() { return adminHubCard; }

    public void refreshAllCards() {
        refreshHomeCard();
        refreshSotwCard();
        updateEventGlows();
    }

    private void refreshHomeCard() {
        if (homeCard != null) {
            homeCard.refreshSotwStatus();
            homeCard.refreshBotmStatus();
            homeCard.refreshHuntStatus();
            homeCard.refreshPluginAnnouncement();
            homeCard.refreshButtonLinks();
        }
    }

    private void refreshSotwCard() {
        if (sotwCard != null) {
            sotwCard.refreshLeaderboard();
        }
    }

    public void shutdown() {
        glowTimer.stop();
        botmCard.shutdown();
        sotwCard.shutdown();
        huntCard.shutdown();
        competitionScheduler.stop();
    }

    private static class EntryConfig {
        final String label;
        final String iconPath;
        final JPanel card;
        final EntrySelect entry;

        EntryConfig(String label, String iconPath, JPanel card, EntrySelect entry) {
            this.label = label;
            this.iconPath = iconPath;
            this.card = card;
            this.entry = entry;
        }
    }

    @FunctionalInterface
    private interface EventActiveChecker<T> {
        boolean isActive(T card);
    }
}
package com.flux.cards;

import net.runelite.client.config.ConfigManager;
import com.flux.services.GoogleSheetParser;
import com.flux.components.LeaderboardCellRenderer;

import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import okhttp3.OkHttpClient;

public class HuntCard extends FluxCard {
    private final ConfigManager configManager;
    private LeaderboardCellRenderer leaderboardCellRenderer;
    private JLabel eventTitle;
    private JLabel countdownLabel;
    private JLabel scoreTitleLabel;
    private JLabel scoreLabel;
    private DefaultTableModel combinedTableModel;
    private Timer countdownTimer;
    private GoogleSheetParser sheetParser;
    private boolean wasEventActive = false;
    private static final Logger logger = LoggerFactory.getLogger(HuntCard.class);
    private final OkHttpClient httpClient;

    public HuntCard(ConfigManager configManager, OkHttpClient httpClient) {
        super();
        this.configManager = configManager;
        this.httpClient = httpClient;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        buildUI();
        startCountdownTimer();

        SwingUtilities.invokeLater(() -> {
            refreshLeaderboard();
            updateTeamScores();
        });
    }

    private void buildUI() {
        add(createVerticalStrut(SPACING_MEDIUM));
        add(createCenteredLabel("The Hunt", FONT_TITLE, COLOR_YELLOW));
        addVerticalSpace(SPACING_MEDIUM);

        eventTitle = createWrappedLabelWithUnderline(
                getConfigValue("huntTitle", "No active hunt event", configManager),
                FONT_SECTION,
                COLOR_YELLOW
        );
        setupDynamicResize(eventTitle);
        add(eventTitle);
        addVerticalSpace(SPACING_SMALL);

        countdownLabel = createWrappedLabel("Loading...", FONT_NORMAL, COLOR_LIGHT_GRAY);
        setupDynamicResize(countdownLabel);
        add(countdownLabel);
        updateCountdownLabel();
        addVerticalSpace(SPACING_SMALL);

        addScoreSection();
        addVerticalSpace(SPACING_MEDIUM);
        addCombinedLeaderboard();
        addVerticalSpace(SPACING_MEDIUM);
        addButtons();
    }

    private void addScoreSection() {
        scoreTitleLabel = createWrappedLabelWithUnderline("Current Score", FONT_SECTION, COLOR_YELLOW);
        setupDynamicResize(scoreTitleLabel);
        add(scoreTitleLabel);
        addVerticalSpace(SPACING_SMALL);

        String scoreText = buildScoreText();
        scoreLabel = createWrappedLabel(scoreText, FONT_NORMAL, COLOR_LIGHT_GRAY);
        setupDynamicResize(scoreLabel);
        add(scoreLabel);
    }

    private String buildScoreText() {
        String team1Name = getConfigValue("hunt_team_1_name", "Team 1", configManager);
        String team2Name = getConfigValue("hunt_team_2_name", "Team 2", configManager);
        int team1Score = getConfigInt("hunt_team_1_score", 0, configManager);
        int team2Score = getConfigInt("hunt_team_2_score", 0, configManager);

        Color team1Color = parseColor(getConfigValue("hunt_team_1_color", "#FF0000", configManager));
        Color team2Color = parseColor(getConfigValue("hunt_team_2_color", "#0000FF", configManager));

        String team1ColorHex = String.format("#%02x%02x%02x", team1Color.getRed(), team1Color.getGreen(), team1Color.getBlue());
        String team2ColorHex = String.format("#%02x%02x%02x", team2Color.getRed(), team2Color.getGreen(), team2Color.getBlue());

        return String.format("<span style='color: %s;'>%s: %,d</span><br><span style='color: %s;'>%s: %,d</span>",
                team1ColorHex, team1Name, team1Score,
                team2ColorHex, team2Name, team2Score);
    }

    private void addCombinedLeaderboard() {
        add(createSectionTitle("Top 10 Players"));
        addVerticalSpace(SPACING_SMALL);

        combinedTableModel = new DefaultTableModel(new Object[]{"Player", "EHB"}, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        JTable table = new JTable(combinedTableModel);
        configureTable(table);

        int scrollHeight = (TABLE_ROW_HEIGHT + TABLE_ROW_SPACING) * 5 +
                table.getTableHeader().getPreferredSize().height + 4;

        JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setPreferredSize(new Dimension(300, scrollHeight));
        scrollPane.setMaximumSize(new Dimension(Integer.MAX_VALUE, scrollHeight));
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        scrollPane.setAlignmentX(Component.CENTER_ALIGNMENT);
        add(scrollPane);
    }

    private void configureTable(JTable table) {
        table.setFillsViewportHeight(true);
        table.setRowSelectionAllowed(false);
        table.setShowGrid(false);
        table.setFont(FONT_NORMAL);
        table.setRowHeight(TABLE_ROW_HEIGHT);
        table.setIntercellSpacing(new Dimension(0, TABLE_ROW_SPACING));

        TeamColoredLeaderboardRenderer renderer = new TeamColoredLeaderboardRenderer();
        renderer.setTable(table);
        table.getColumnModel().getColumn(0).setCellRenderer(renderer);
        table.getColumnModel().getColumn(1).setCellRenderer(renderer);
    }

    private void addButtons() {
        String gdocUrl = getConfigValue("hunt_gdoc_url", "https://docs.google.com/spreadsheets/d/e/2PACX-1vSLCxscAVFZY9wuDqmeBPu4UZio2I39DHDGy_8DXrvHqYKmZc8NgsC4DWv_olXOTjGQktcBnU88Fmf4/pubhtml?gid=0&single=true", configManager);
        String womUrl = getConfigValue("hunt_wom_url", "https://wiseoldman.net/competitions", configManager);

        addLinkButtons(new LinkButton[] {
                new LinkButton("Hunt Signup", "/discord.png", "discord://discord.com/channels/414435426007384075/414458243499425792"),
                new LinkButton("The Hunt GDoc", "/hunt.png", gdocUrl),
                new LinkButton("Hunt WOM", "/wom.png", womUrl)
        });
    }

    public boolean isEventActive() {
        return getConfigBoolean("huntActive", configManager);
    }

    public void refreshLeaderboard() {
        String team1Name = getConfigValue("hunt_team_1_name", "Team 1", configManager);
        String team2Name = getConfigValue("hunt_team_2_name", "Team 2", configManager);

        Map<String, Double> team1Data = loadLeaderboardFromConfig("hunt_team_1_leaderboard");
        Map<String, Double> team2Data = loadLeaderboardFromConfig("hunt_team_2_leaderboard");

        List<PlayerEntry> allPlayers = new ArrayList<>();

        for (Map.Entry<String, Double> entry : team1Data.entrySet()) {
            allPlayers.add(new PlayerEntry(entry.getKey(), team1Name, entry.getValue()));
        }

        for (Map.Entry<String, Double> entry : team2Data.entrySet()) {
            allPlayers.add(new PlayerEntry(entry.getKey(), team2Name, entry.getValue()));
        }

        allPlayers.sort((a, b) -> Double.compare(b.ehb, a.ehb));

        List<PlayerEntry> top10 = allPlayers.size() > 10 ? allPlayers.subList(0, 10) : allPlayers;

        combinedTableModel.setRowCount(0);
        for (PlayerEntry player : top10) {
            combinedTableModel.addRow(new Object[]{
                    player.username,
                    String.format("%.2f", player.ehb)
            });
        }

        combinedTableModel.fireTableDataChanged();
    }

    private Map<String, Double> loadLeaderboardFromConfig(String configKey) {
        Map<String, Double> leaderboard = new LinkedHashMap<>();
        String raw = configManager.getConfiguration("flux", configKey);

        if (raw == null || raw.isEmpty()) return leaderboard;

        try {
            JsonParser jsonParser = new JsonParser();
            JsonArray array = jsonParser.parse(raw).getAsJsonArray();
            for (int i = 0; i < array.size(); i++) {
                JsonObject obj = array.get(i).getAsJsonObject();
                leaderboard.put(obj.get("username").getAsString(), obj.get("ehb").getAsDouble());
            }
        } catch (Exception e) {
            handleAsyncError(e);
        }

        return leaderboard;
    }

    public void updateEventTitle() {
        String titleText = getConfigValue("huntTitle", "No active hunt event", configManager);
        updateWrappedLabelText(eventTitle, titleText, true);
        eventTitle.setMaximumSize(new Dimension(getWidth() - CONTENT_PADDING, Integer.MAX_VALUE));
        eventTitle.revalidate();
        eventTitle.repaint();
    }

    public void updateTeamLabels() {
        updateTeamScores();
        refreshLeaderboard();
    }

    public void updateTeamScores() {
        updateWrappedLabelText(scoreLabel, buildScoreText(), false);
        scoreLabel.revalidate();
        scoreLabel.repaint();
    }

    public void refreshButtonLinks() {
        updateButtonUrl("The Hunt GDoc", "hunt_gdoc_url");
        updateButtonUrl("Hunt WOM", "hunt_wom_url");
    }

    private void updateButtonUrl(String buttonLabel, String configKey) {
        String url = getConfigValue(configKey, "", configManager);
        if (buttons.containsKey(buttonLabel) && !url.isEmpty()) {
            buttons.get(buttonLabel).setUrl(url);
        }
    }

    public void checkEventStateChanged() {
        updateCountdownLabel();
        updateEventTitle();
        updateTeamLabels();
        refreshButtonLinks();
        refreshLeaderboard();

        if (isEventActive()) {
            startSheetPolling();
        } else {
            stopSheetPolling();
        }
    }

    private void startSheetPolling() {
        if (sheetParser == null) {
            sheetParser = new GoogleSheetParser(configManager, GoogleSheetParser.SheetType.HUNT, this::handleSheetScoreUpdate, httpClient);
        }
        sheetParser.start();
    }

    private void stopSheetPolling() {
        if (sheetParser != null) {
            sheetParser.stop();
        }
    }

    private void handleSheetScoreUpdate(Map<String, Integer> scores) {
        String team1Name = getConfigValue("hunt_team_1_name", "Team 1", configManager);
        String team2Name = getConfigValue("hunt_team_2_name", "Team 2", configManager);

        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            String teamName = entry.getKey();
            int score = entry.getValue();

            if (teamName.equalsIgnoreCase(team1Name) || teamName.contains(team1Name)) {
                configManager.setConfiguration("flux", "hunt_team_1_score", String.valueOf(score));
            } else if (teamName.equalsIgnoreCase(team2Name) || teamName.contains(team2Name)) {
                configManager.setConfiguration("flux", "hunt_team_2_score", String.valueOf(score));
            }
        }

        SwingUtilities.invokeLater(this::updateTeamScores);
    }

    @Override
    public void refresh() {
        checkEventStateChanged();
    }

    private void startCountdownTimer() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        wasEventActive = isEventActive();
        countdownTimer = createCountdownTimer(this::handleTimerTick);
        countdownTimer.start();
    }

    private void handleTimerTick() {
        boolean isActiveNow = isEventActive();
        updateCountdownLabel();

        if (isActiveNow && hasEventEnded("hunt_end_time", configManager)) {
            countdownTimer.stop();
        }

        if (wasEventActive != isActiveNow) {
            wasEventActive = isActiveNow;
            checkEventStateChanged();
        }
    }

    private void updateCountdownLabel() {
        if (!isEventActive()) {
            updateWrappedLabelText(countdownLabel, getEventEndedMessage(), false);
            return;
        }

        String message = formatCountdownMessage("hunt_start_time", "hunt_end_time", configManager);
        updateWrappedLabelText(countdownLabel, message, false);
    }

    private String getEventEndedMessage() {
        String winner = getWinnerFromGoogleSheetScores();

        if (winner != null && !winner.isEmpty()) {
            return "The Hunt has ended!<br>Winning team: " + winner;
        }

        return "No active Hunt event.";
    }

    private String getWinnerFromGoogleSheetScores() {
        int team1Score = getConfigInt("hunt_team_1_score", 0, configManager);
        int team2Score = getConfigInt("hunt_team_2_score", 0, configManager);

        if (team1Score == 0 && team2Score == 0) {
            return null;
        }

        String team1Name = getConfigValue("hunt_team_1_name", "Team 1", configManager);
        String team2Name = getConfigValue("hunt_team_2_name", "Team 2", configManager);

        if (team1Score > team2Score) {
            return team1Name;
        } else if (team2Score > team1Score) {
            return team2Name;
        } else {
            return team1Name + " and " + team2Name + " (Tie)";
        }
    }

    @Override
    public void shutdown() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        if (leaderboardCellRenderer != null) {
            leaderboardCellRenderer.shutdown(); // stop table timers
        }

        stopSheetPolling();
        super.shutdown();
    }

    private static class PlayerEntry {
        final String username;
        final String teamName;
        final double ehb;

        PlayerEntry(String username, String teamName, double ehb) {
            this.username = username;
            this.teamName = teamName;
            this.ehb = ehb;
        }
    }

    private class TeamColoredLeaderboardRenderer extends LeaderboardCellRenderer {
        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                                                       boolean isSelected, boolean hasFocus, int row, int column) {

            Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            String playerName = "";
            if (row < table.getRowCount() && table.getColumnCount() > 0) {
                Object nameValue = table.getValueAt(row, 0);
                if (nameValue != null) {
                    playerName = nameValue.toString();
                }
            }

            Map<String, Double> team1Data = loadLeaderboardFromConfig("hunt_team_1_leaderboard");
            Map<String, Double> team2Data = loadLeaderboardFromConfig("hunt_team_2_leaderboard");

            Color team1Color = parseColor(getConfigValue("hunt_team_1_color", "#FF0000", configManager));
            Color team2Color = parseColor(getConfigValue("hunt_team_2_color", "#0000FF", configManager));

            if (team1Data.containsKey(playerName)) {
                c.setForeground(team1Color);
            } else if (team2Data.containsKey(playerName)) {
                c.setForeground(team2Color);
            } else {
                c.setForeground(COLOR_WHITE);
            }

            if (column == 1) {
                setHorizontalAlignment(SwingConstants.CENTER);
            } else {
                setHorizontalAlignment(SwingConstants.LEFT);
            }

            return c;
        }
    }
}

package com.flux.cards;

import net.runelite.client.config.ConfigManager;
import com.flux.FluxConfig;
import com.flux.components.InverseCornerButton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;
import java.awt.*;

public class HomeCard extends FluxCard {
    private static final Logger logger = LoggerFactory.getLogger(HomeCard.class);
    private static final Font HEADER_FONT = new Font("SansSerif", Font.BOLD, 14);
    private static final Color TABLE_BG = new Color(30, 30, 30);
    private static final Color HEADER_BG = new Color(50, 50, 50);
    private static final Color GRID_COLOR = new Color(70, 70, 70);
    private static final int BOTM_ROW = 0;
    private static final int SOTW_ROW = 1;
    private static final int HUNT_ROW = 2;
    private final FluxConfig config;
    private final ConfigManager configManager;
    private DefaultTableModel tableModel;
    private JTextPane announcementsPane;

    public HomeCard(FluxConfig config, ConfigManager configManager) {
        super();
        this.config = config;
        this.configManager = configManager;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        buildUI();
        refreshAllStatuses();
    }

    private void buildUI() {
        add(createVerticalStrut(SPACING_MEDIUM));
        add(createCenteredLabel("Welcome to Flux!", FONT_TITLE, COLOR_YELLOW));
        addVerticalSpace(SPACING_MEDIUM);
        addAnnouncementsSection();
        addVerticalSpace(SPACING_MEDIUM);
        addEventsSection();
        addVerticalSpace(SPACING_MEDIUM);
        addLinksSection();
        add(Box.createVerticalGlue());
    }

    private void addAnnouncementsSection() {
        add(createSectionTitle("Announcements"));
        addVerticalSpace(SPACING_SMALL);

        String announcement = configManager.getConfiguration("flux", "plugin_announcement_message");
        if (announcement == null || announcement.trim().isEmpty()) {
            announcement = "No Announcements.";
        }

        announcementsPane = new JTextPane();
        announcementsPane.setText(announcement);
        announcementsPane.setEditable(false);
        announcementsPane.setOpaque(false);
        announcementsPane.setFocusable(false);
        announcementsPane.setBorder(null);
        announcementsPane.setForeground(COLOR_LIGHT_GRAY);

        // Center-align text
        StyledDocument doc = announcementsPane.getStyledDocument();
        SimpleAttributeSet center = new SimpleAttributeSet();
        StyleConstants.setAlignment(center, StyleConstants.ALIGN_CENTER);
        doc.setParagraphAttributes(0, doc.getLength(), center, false);

        // text wrapping constraint
        announcementsPane.setMaximumSize(
                new Dimension(Integer.MAX_VALUE, announcementsPane.getPreferredSize().height)
        );

        add(announcementsPane);
    }


    private void addEventsSection() {
        add(createSectionTitle("Events"));
        addVerticalSpace(SPACING_SMALL);

        JScrollPane eventsTable = createEventsTable();
        add(eventsTable);
    }

    private void addLinksSection() {
        add(createSectionTitle("Links"));
        addVerticalSpace(SPACING_SMALL);

        LinkButton[] linkButtons = {
                new LinkButton("Flux Clan Server", "/discord.png", "https://discord.gg/pTxsfJMNRJ"),
                new LinkButton("Roll Call", "/discord.png", "discord://discord.com/channels/414435426007384075/636902420403847168"),
                new LinkButton("Name Changes", "/discord.png", "discord://discord.com/channels/414435426007384075/415499145017557032"),
                new LinkButton("Announcements", "/discord.png", "discord://discord.com/channels/414435426007384075/1349697176183246868"),
                new LinkButton("Events", "/discord.png", "discord://discord.com/channels/414435426007384075/414458243499425792"),
                new LinkButton("Wise Old Man", "/wom.png", "https://wiseoldman.net/groups/141")
        };
        addLinkButtons(linkButtons);
    }

    private JScrollPane createEventsTable() {
        String[] columnNames = {"Event", "Status"};
        Object[][] rowData = {
                {"BOTM", "Idle"},
                {"SOTW", "Idle"},
                {"The Hunt", "Idle"}
        };

        tableModel = new DefaultTableModel(rowData, columnNames) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        JTable table = new JTable(tableModel);
        configureTable(table);

        JScrollPane scrollPane = new JScrollPane(table);
        configureScrollPane(scrollPane, table);

        return scrollPane;
    }

    private void configureTable(JTable table) {
        table.setFillsViewportHeight(true);
        table.setRowHeight(24);
        table.setForeground(COLOR_WHITE);
        table.setBackground(TABLE_BG);
        table.setGridColor(GRID_COLOR);
        table.setShowGrid(true);
        table.setIntercellSpacing(new Dimension(10, 8));

        configureTableHeader(table.getTableHeader());
        configureTableRenderers(table);
    }

    private void configureTableHeader(JTableHeader header) {
        header.setFont(HEADER_FONT);
        header.setReorderingAllowed(false);
        header.setResizingAllowed(false);
        header.setForeground(COLOR_YELLOW);
        header.setBackground(HEADER_BG);
        header.setBorder(BorderFactory.createEmptyBorder(5, 0, 5, 0));
    }

    private void configureTableRenderers(JTable table) {
        DefaultTableCellRenderer centerRenderer = new DefaultTableCellRenderer();
        centerRenderer.setHorizontalAlignment(SwingConstants.CENTER);
        table.getColumnModel().getColumn(0).setCellRenderer(centerRenderer);
        table.getColumnModel().getColumn(1).setCellRenderer(new StatusColorRenderer());
    }

    private void configureScrollPane(JScrollPane scrollPane, JTable table) {
        int totalHeight = calculateTableHeight(table, scrollPane);

        scrollPane.setPreferredSize(new Dimension(400, totalHeight));
        scrollPane.setAlignmentX(Component.CENTER_ALIGNMENT);
        scrollPane.setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createLineBorder(GRID_COLOR, 1, true),
                BorderFactory.createEmptyBorder(10, 10, 10, 10)
        ));
    }

    private int calculateTableHeight(JTable table, JScrollPane scrollPane) {
        int rowHeight = table.getRowHeight();
        int intercellSpacing = table.getIntercellSpacing().height;
        int headerHeight = table.getTableHeader().getPreferredSize().height;
        int rowCount = table.getRowCount();

        int totalHeight = headerHeight + (rowHeight + intercellSpacing) * rowCount;
        totalHeight += scrollPane.getInsets().top + scrollPane.getInsets().bottom + 2;

        return totalHeight;
    }

    public void updateSotwStatus(boolean isActive) {
        updateEventStatus(SOTW_ROW, isActive);
    }

    public void updateBotmStatus(boolean isActive) {
        updateEventStatus(BOTM_ROW, isActive);
    }

    public void updateHuntStatus(boolean isActive) {
        updateEventStatus(HUNT_ROW, isActive);
    }

    private void updateEventStatus(int rowIndex, boolean isActive) {
        if (tableModel != null && rowIndex >= 0 && rowIndex < tableModel.getRowCount()) {
            String status = isActive ? "Ongoing" : "Idle";
            tableModel.setValueAt(status, rowIndex, 1);
        }
    }

    public void refreshPluginAnnouncement() {
        String announcement = configManager.getConfiguration("flux", "plugin_announcement_message");
        if (announcement == null || announcement.trim().isEmpty()) {
            announcement = "No Announcements.";
        }

        if (announcementsPane != null) {
            String finalAnnouncement = announcement;
            SwingUtilities.invokeLater(() -> {
                announcementsPane.setText(finalAnnouncement);

                StyledDocument doc = announcementsPane.getStyledDocument();
                SimpleAttributeSet center = new SimpleAttributeSet();
                StyleConstants.setAlignment(center, StyleConstants.ALIGN_CENTER);
                doc.setParagraphAttributes(0, doc.getLength(), center, false);

                announcementsPane.revalidate();
                announcementsPane.repaint();
            });
        }
    }


    public void refreshButtonLinks() {
        updateButtonUrl("Wise Old Man", "wom_url", configManager);
    }

    public void refreshHuntStatus() {
        boolean isActive = getConfigBoolean("HuntActive");
        updateHuntStatus(isActive);
    }

    public void refreshSotwStatus() {
        boolean isActive = getConfigBoolean("sotwActive");
        updateSotwStatus(isActive);
    }

    public void refreshBotmStatus() {
        boolean isActive = getConfigBoolean("botmActive");
        updateBotmStatus(isActive);
    }

    public void isRollCallActive() {
        boolean active = getConfigBoolean("rollCallActive");

        InverseCornerButton rollCallButton = buttons.get("Roll Call");

        if (rollCallButton != null) {
            rollCallButton.setGlowing(active);
            rollCallButton.repaint();
        }
    }

    @Override
    public void refresh() {
        refreshAllStatuses();
    }

    private void refreshAllStatuses() {
        refreshSotwStatus();
        refreshBotmStatus();
        refreshHuntStatus();
        isRollCallActive();
    }

    @Override
    protected boolean getConfigBoolean(String key) {
        return getConfigBoolean(key, configManager);
    }

    @Override
    protected String getConfigValue(String key, String defaultValue) {
        return getConfigValue(key, defaultValue, configManager);
    }

    private static class StatusColorRenderer extends DefaultTableCellRenderer {
        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected,
                boolean hasFocus, int row, int column) {
            Component c = super.getTableCellRendererComponent(
                    table, value, isSelected, hasFocus, row, column
            );

            if (column == 1) {
                String status = value.toString();
                c.setForeground("Ongoing".equalsIgnoreCase(status) ? COLOR_GREEN : COLOR_RED);
            } else {
                c.setForeground(COLOR_WHITE);
            }

            setBackground(TABLE_BG);
            return c;
        }
    }
}
package com.flux.cards;

import com.flux.components.InverseCornerButton;
import net.runelite.client.config.ConfigManager;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import javax.swing.*;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public abstract class FluxCard extends JPanel implements Scrollable {
    private static final Logger logger = LoggerFactory.getLogger(FluxCard.class);

    protected static final int SCROLL_UNIT_INCREMENT = 16;
    protected static final int SCROLL_BLOCK_INCREMENT = 64;
    protected static final int SIDE_PADDING = 10;
    protected static final int CONTENT_PADDING = 40;
    protected static final int TIMER_INTERVAL = 1000;

    protected static final int SPACING_SMALL = 10;
    protected static final int SPACING_MEDIUM = 20;
    protected static final int SPACING_LARGE = 25;

    protected static final int BUTTON_WIDTH = 200;
    protected static final int BUTTON_HEIGHT = 25;

    protected static final int TABLE_ROW_HEIGHT = 26;
    protected static final int TABLE_ROW_SPACING = 3;

    protected static final Color COLOR_YELLOW = Color.YELLOW;
    protected static final Color COLOR_LIGHT_GRAY = Color.LIGHT_GRAY;
    protected static final Color COLOR_WHITE = Color.WHITE;
    protected static final Color COLOR_GREEN = Color.GREEN;
    protected static final Color COLOR_RED = Color.RED;

    protected static final Font FONT_TITLE = new Font("SansSerif", Font.BOLD, 20);
    protected static final Font FONT_SECTION = new Font("SansSerif", Font.BOLD, 16);
    protected static final Font FONT_NORMAL = new Font("SansSerif", Font.PLAIN, 14);

    private final ExecutorService executor = Executors.newCachedThreadPool();
    protected final Map<String, InverseCornerButton> buttons = new HashMap<>();

    protected FluxCard() {
        setOpaque(false);
        setAlignmentX(Component.CENTER_ALIGNMENT);
        setBorder(BorderFactory.createEmptyBorder(0, SIDE_PADDING, 0, SIDE_PADDING));
    }

    @Override
    public boolean getScrollableTracksViewportWidth() {
        return true;
    }

    @Override
    public boolean getScrollableTracksViewportHeight() {
        return false;
    }

    @Override
    public Dimension getPreferredScrollableViewportSize() {
        return getPreferredSize();
    }

    @Override
    public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation, int direction) {
        return SCROLL_UNIT_INCREMENT;
    }

    @Override
    public int getScrollableBlockIncrement(Rectangle visibleRect, int orientation, int direction) {
        return SCROLL_BLOCK_INCREMENT;
    }

    protected void runAsync(Runnable task) {
        executor.submit(task);
    }

    protected void runAsyncWithCallback(Runnable backgroundTask, Runnable edtCallback) {
        executor.submit(() -> {
            try {
                backgroundTask.run();
                SwingUtilities.invokeLater(edtCallback);
            } catch (Exception e) {
                handleAsyncError(e);
            }
        });
    }

    protected void handleAsyncError(Exception e) {
        logger.error("Async error in {}", getClass().getSimpleName(), e);
    }

    protected JLabel createCenteredLabel(String text, Font font, Color color) {
        JLabel label = new JLabel(text);
        if (font != null) {
            label.setFont(font);
        }
        label.setForeground(color);
        label.setAlignmentX(Component.CENTER_ALIGNMENT);
        label.setHorizontalAlignment(SwingConstants.CENTER);
        return label;
    }

    protected JLabel createWrappedLabel(String text, Font font, Color color) {
        String html = String.format(
                "<html><div style='text-align: center; word-wrap: break-word;'>%s</div></html>",
                text
        );
        return createCenteredLabel(html, font, color);
    }

    protected JLabel createWrappedLabelWithUnderline(String text, Font font, Color color) {
        String htmlText = String.format(
                "<html><div style='text-align: center; word-wrap: break-word;'><u>%s</u></div></html>",
                text
        );

        JLabel label = new JLabel(htmlText);
        label.setFont(font);
        label.setForeground(color);
        label.setAlignmentX(Component.CENTER_ALIGNMENT);
        label.setHorizontalAlignment(SwingConstants.CENTER);

        return label;
    }

    protected JLabel createSectionTitle(String text) {
        String html = String.format("<html><u>%s</u></html>", text);
        return createCenteredLabel(html, FONT_SECTION, COLOR_YELLOW);
    }

    protected void updateWrappedLabelText(JLabel label, String text, boolean underline) {
        String format = underline
                ? "<html><div style='text-align: center; word-wrap: break-word;'><u>%s</u></div></html>"
                : "<html><div style='text-align: center; word-wrap: break-word;'>%s</div></html>";

        label.setText(String.format(format, text));
    }

    protected void addVerticalSpace(int height) {
        add(Box.createRigidArea(new Dimension(0, height)));
    }

    protected Component createVerticalStrut(int height) {
        return Box.createVerticalStrut(height);
    }

    protected void setupDynamicResize(JLabel label) {
        addComponentListener(new java.awt.event.ComponentAdapter() {
            @Override
            public void componentResized(java.awt.event.ComponentEvent evt) {
                int maxWidth = getWidth() > CONTENT_PADDING ? getWidth() - CONTENT_PADDING : 180;
                label.setMaximumSize(new Dimension(maxWidth, Integer.MAX_VALUE));
                label.revalidate();
                label.repaint();
            }
        });
    }

    protected Color parseColor(String hexColor) {
        try {
            if (hexColor != null && hexColor.startsWith("#") && hexColor.length() == 7) {
                return Color.decode(hexColor);
            }
        } catch (Exception e) {
            logger.warn("Failed to parse color: {}", hexColor);
        }
        return COLOR_YELLOW;
    }

    protected InverseCornerButton createLinkButton(LinkButton linkButton) {
        InverseCornerButton button = InverseCornerButton.withLabelImageAndUrl(
                linkButton.label,
                linkButton.iconPath,
                linkButton.url
        );

        button.setAlignmentX(Component.CENTER_ALIGNMENT);
        Dimension size = new Dimension(BUTTON_WIDTH, BUTTON_HEIGHT);
        button.setPreferredSize(size);
        button.setMaximumSize(size);
        button.setMinimumSize(size);

        return button;
    }

    protected void addLinkButtons(LinkButton[] linkButtons) {
        for (LinkButton linkButton : linkButtons) {
            InverseCornerButton button = createLinkButton(linkButton);
            buttons.put(linkButton.label, button);
            add(button);
            addVerticalSpace(SPACING_SMALL);
        }
    }

    protected void updateButtonUrl(String buttonLabel, String configKey, ConfigManager configManager) {
        String url = getConfigValue(configKey, "", configManager);
        if (buttons.containsKey(buttonLabel) && !url.isEmpty()) {
            buttons.get(buttonLabel).setUrl(url);
        }
    }

    protected Timer createCountdownTimer(Runnable tickHandler) {
        return new Timer(TIMER_INTERVAL, e -> tickHandler.run());
    }

    protected String formatDuration(Duration duration) {
        long days = duration.toDays();
        long hours = duration.toHours() % 24;
        long minutes = duration.toMinutes() % 60;
        return String.format("%d days, %d hours, %d minutes", days, hours, minutes);
    }

    protected String formatCountdownMessage(String startTimeKey, String endTimeKey, ConfigManager configManager) {
        try {
            String startRaw = configManager.getConfiguration("flux", startTimeKey);
            String endRaw = configManager.getConfiguration("flux", endTimeKey);

            if (startRaw == null || startRaw.isEmpty() || endRaw == null || endRaw.isEmpty()) {
                return "Timing unavailable.";
            }

            Instant now = Instant.now();
            Instant start = Instant.parse(startRaw);
            Instant end = Instant.parse(endRaw);

            if (now.isBefore(start)) {
                Duration untilStart = Duration.between(now, start);
                return "Starts in:<br>" + formatDuration(untilStart);
            } else if (now.isBefore(end)) {
                Duration remaining = Duration.between(now, end);
                return "Ends in:<br>" + formatDuration(remaining);
            } else {
                return "Event has ended.";
            }
        } catch (Exception ex) {
            return "Timing error.";
        }
    }

    protected boolean hasEventEnded(String endTimeKey, ConfigManager configManager) {
        try {
            String endRaw = configManager.getConfiguration("flux", endTimeKey);
            if (endRaw != null && !endRaw.isEmpty()) {
                Instant now = Instant.now();
                Instant end = Instant.parse(endRaw);
                return now.isAfter(end);
            }
        } catch (Exception ex) {
            // Ignore parsing errors
        }
        return false;
    }

    protected boolean getConfigBoolean(String key, ConfigManager configManager) {
        return "true".equals(configManager.getConfiguration("flux", key));
    }

    protected String getConfigValue(String key, String defaultValue, ConfigManager configManager) {
        String value = configManager.getConfiguration("flux", key);
        return (value != null && !value.isEmpty()) ? value : defaultValue;
    }

    protected int getConfigInt(String key, int defaultValue, ConfigManager configManager) {
        String value = configManager.getConfiguration("flux", key);
        if (value != null && !value.isEmpty()) {
            try {
                return Integer.parseInt(value);
            } catch (NumberFormatException e) {
                return defaultValue;
            }
        }
        return defaultValue;
    }

    protected boolean getConfigBoolean(String key) {
        throw new UnsupportedOperationException("Subclass must override getConfigBoolean(String) or use getConfigBoolean(String, ConfigManager)");
    }

    protected String getConfigValue(String key, String defaultValue) {
        throw new UnsupportedOperationException("Subclass must override getConfigValue(String, String) or use getConfigValue(String, String, ConfigManager)");
    }

    protected int getConfigInt(String key, int defaultValue) {
        throw new UnsupportedOperationException("Subclass must override getConfigInt(String, int) or use getConfigInt(String, int, ConfigManager)");
    }

    protected LinkedHashMap<String, Integer> parseLeaderboardJson(String configKey, String scoreField, ConfigManager configManager) {
        LinkedHashMap<String, Integer> leaderboard = new LinkedHashMap<>();
        String raw = configManager.getConfiguration("flux", configKey);

        if (raw == null || raw.isEmpty()) {
            return leaderboard;
        }

        try {
            JsonParser jsonParser = new JsonParser();
            JsonArray array = jsonParser.parse(raw).getAsJsonArray();
            for (int i = 0; i < array.size(); i++) {
                JsonObject obj = array.get(i).getAsJsonObject();
                String username = obj.get("username").getAsString();
                int score = obj.get(scoreField).getAsInt();
                leaderboard.put(username, score);
            }
        } catch (Exception e) {
            handleAsyncError(e);
            logger.error("Failed to parse leaderboard from config key: {}", configKey);
        }

        return leaderboard;
    }

    public void refresh() {
    }

    public void cleanup() {
            // stop all button timers
            for (InverseCornerButton button : buttons.values()) {
                button.cleanup();
            }
        }

    public void shutdown() {
        cleanup();
        executor.shutdownNow();
    }

    protected static class LinkButton {
        public final String label;
        public final String iconPath;
        public final String url;

        public LinkButton(String label, String iconPath, String url) {
            this.label = label;
            this.iconPath = iconPath;
            this.url = url;
        }
    }
}
package com.flux.cards;

import net.runelite.client.config.ConfigManager;
import com.flux.components.LeaderboardCellRenderer;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.LinkedHashMap;
import java.util.Map;

public class SotwCard extends FluxCard {
    private final ConfigManager configManager;
    private LeaderboardCellRenderer leaderboardCellRenderer;
    private DefaultTableModel tableModel;
    private JLabel eventTitle;
    private JLabel countdownLabel;
    private Timer countdownTimer;
    private boolean wasEventActive = false;
    private static final Logger logger = LoggerFactory.getLogger(SotwCard.class);

    public SotwCard(ConfigManager configManager) {
        super();
        this.configManager = configManager;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        buildUI();
        startCountdownTimer();
    }

    private void buildUI() {
        add(createVerticalStrut(SPACING_MEDIUM));
        add(createCenteredLabel("Skill of the Week", FONT_TITLE, COLOR_YELLOW));
        addVerticalSpace(SPACING_MEDIUM);
        addEventTitle();
        addVerticalSpace(SPACING_SMALL);
        addCountdownLabel();
        addVerticalSpace(SPACING_SMALL);
        addLeaderboardTable();
        addVerticalSpace(SPACING_LARGE);
        addButtons();
    }

    private void addEventTitle() {
        String titleText = getConfigValue("sotwTitle", "No active competition");
        eventTitle = createWrappedLabelWithUnderline(titleText, FONT_SECTION, COLOR_YELLOW);
        setupDynamicResize(eventTitle);
        add(eventTitle);
    }

    private void addCountdownLabel() {
        countdownLabel = createWrappedLabel("Loading...", FONT_NORMAL, COLOR_LIGHT_GRAY);
        setupDynamicResize(countdownLabel);
        add(countdownLabel);
        updateCountdownLabel();
    }

    private void addLeaderboardTable() {
        tableModel = new DefaultTableModel(new Object[]{"Username", "XP Gained"}, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        JTable table = new JTable(tableModel);
        configureTable(table);

        JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setPreferredSize(new Dimension(300, 300));
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        add(scrollPane);

        refreshLeaderboard();
    }

    private void configureTable(JTable table) {
        table.setFillsViewportHeight(true);
        table.setRowSelectionAllowed(false);
        table.setShowGrid(false);
        table.setFont(FONT_NORMAL);
        table.setRowHeight(TABLE_ROW_HEIGHT);
        table.setIntercellSpacing(new Dimension(0, TABLE_ROW_SPACING));

        LeaderboardCellRenderer renderer = new LeaderboardCellRenderer();
        renderer.setTable(table);
        table.getColumnModel().getColumn(0).setCellRenderer(renderer);
        table.getColumnModel().getColumn(1).setCellRenderer(renderer);
    }

    private void addButtons() {
        LinkButton[] linkButtons = {
                new LinkButton("SOTW", "/discord.png", "discord://discord.com/channels/414435426007384075/416998364601909288"),
                new LinkButton("SOTW Wise Old Man", "/wom.png", getConfigValue("sotw_wom_link", "https://wiseoldman.net/groups/141/competitions"))
        };
        addLinkButtons(linkButtons);
    }

    public void refreshLeaderboard() {
        if (tableModel == null) return;

        tableModel.setRowCount(0);
        LinkedHashMap<String, Integer> leaderboard = new LinkedHashMap<>();
        try {
            leaderboard = parseLeaderboardJson("sotwLeaderboard", "xp", configManager);
        } catch (Exception e) {
            logger.warn("Failed to parse leaderboard JSON", e);
        }

        for (Map.Entry<String, Integer> entry : leaderboard.entrySet()) {
            String username = entry.getKey();
            String xpString = String.format("%,d XP", entry.getValue());
            tableModel.addRow(new Object[]{username, xpString});
        }
    }

    public boolean isEventActive() {
        return getConfigBoolean("sotwActive");
    }

    public void refreshButtonLinks() {
        updateButtonUrl("SOTW Wise Old Man", "sotw_wom_link", configManager);
    }

    public void updateEventTitle() {
        String titleText = getConfigValue("sotwTitle", "No active competition");
        updateWrappedLabelText(eventTitle, titleText, true);
        eventTitle.revalidate();
        eventTitle.repaint();
    }

    public void checkEventStateChanged() {
        updateEventTitle();
        refreshLeaderboard();
        refreshButtonLinks();
    }

    @Override
    public void refresh() {
        checkEventStateChanged();
        updateCountdownLabel();
    }

    @Override
    protected boolean getConfigBoolean(String key) {
        return getConfigBoolean(key, configManager);
    }

    @Override
    protected String getConfigValue(String key, String defaultValue) {
        return getConfigValue(key, defaultValue, configManager);
    }

    private void startCountdownTimer() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        countdownTimer = createCountdownTimer(this::handleTimerTick);
        countdownTimer.start();
    }

    private void handleTimerTick() {
        boolean isActiveNow = isEventActive();
        updateCountdownLabel();

        if (isActiveNow && hasEventEnded("sotw_end_time", configManager)) {
            countdownTimer.stop();
        }

        if (wasEventActive != isActiveNow) {
            wasEventActive = isActiveNow;
            checkEventStateChanged();
        }
    }

    private void updateCountdownLabel() {
        if (countdownLabel == null) return;

        if (!isEventActive()) {
            updateWrappedLabelText(countdownLabel, getEventEndedMessage(), false);
            return;
        }

        String message = "Event status unavailable.";
        try {
            if (configManager != null) {
                message = formatCountdownMessage("sotw_start_time", "sotw_end_time", configManager);
            }
        } catch (Exception e) {
            logger.warn("Failed to format countdown message", e);
        }

        if ("Event has ended.".equals(message)) {
            message = getEventEndedMessageWithWinner();
        }

        updateWrappedLabelText(countdownLabel, message, false);
    }

    private String getEventEndedMessage() {
        LinkedHashMap<String, Integer> leaderboard = parseLeaderboardJson("sotwLeaderboard", "xp", configManager);

        if (leaderboard.isEmpty()) {
            return "The event has ended.";
        }

        String winner = leaderboard.keySet().iterator().next();
        return "The SOTW Event has ended! Congratulations to the winner: " + winner;
    }

    private String getEventEndedMessageWithWinner() {
        if (configManager == null) return "The event has ended.";

        String winner = "";
        try {
            winner = configManager.getConfiguration("flux", "sotw_winner");
        } catch (Exception e) {
            logger.warn("Failed to get sotw_winner from config", e);
        }

        // fallback to tableModel
        if ((winner == null || winner.isEmpty()) && tableModel != null && tableModel.getRowCount() > 0) {
            Object winnerObj = tableModel.getValueAt(0, 0);
            if (winnerObj != null) {
                winner = winnerObj.toString();
                try {
                    configManager.setConfiguration("flux", "sotw_winner", winner);
                } catch (Exception e) {
                    logger.warn("Failed to save sotw_winner to config", e);
                }
            }
        }

        if (winner == null || winner.isEmpty()) {
            return "The event has ended.";
        }

        return "Event has ended.<br>Congratulations to the winner: " + winner;
    }

    @Override
    public void shutdown() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        if (leaderboardCellRenderer != null) {
            leaderboardCellRenderer.shutdown();
        }
        
        super.shutdown();
    }
}
package com.flux.cards;

import net.runelite.client.config.ConfigManager;
import com.flux.services.GoogleSheetParser;
import com.flux.components.LeaderboardCellRenderer;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import okhttp3.OkHttpClient;
import org.slf4j.Logger; import org.slf4j.LoggerFactory;
import javax.swing.*;
import javax.swing.table.DefaultTableModel;
import java.awt.*;
import java.util.concurrent.atomic.AtomicReference;

public class BotmCard extends FluxCard {
    private final ConfigManager configManager;
    private final AtomicReference<String> lastLeaderboardJson = new AtomicReference<>("");
    private LeaderboardCellRenderer leaderboardCellRenderer;

    private DefaultTableModel tableModel;
    private JLabel eventTitle;
    private JLabel countdownLabel;
    private Timer countdownTimer;
    private GoogleSheetParser sheetParser;
    private boolean wasEventActive = false;
    private static final Logger logger = LoggerFactory.getLogger(BotmCard.class);
    private final OkHttpClient httpClient;

    public BotmCard(ConfigManager configManager, OkHttpClient httpClient) {
        super();
        this.configManager = configManager;
        this.httpClient = httpClient;

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        buildUI();
        startCountdownTimer();
    }

    private void buildUI() {
        add(createVerticalStrut(SPACING_MEDIUM));
        add(createCenteredLabel("Boss of the Month", FONT_TITLE, COLOR_YELLOW));
        addVerticalSpace(SPACING_MEDIUM);
        addEventTitle();
        addCountdownLabel();
        addVerticalSpace(SPACING_SMALL);
        addLeaderboardTable();
        addVerticalSpace(SPACING_LARGE);
        addButtons();

        checkEventStateChanged();
    }

    private void addEventTitle() {
        String titleText = getConfigValue("botmTitle", "No active competition");
        eventTitle = createWrappedLabelWithUnderline(titleText, FONT_SECTION, COLOR_YELLOW);

        // Center using FlowLayout panel
        JPanel eventTitlePanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        eventTitlePanel.setOpaque(false);
        eventTitlePanel.add(eventTitle);
        add(eventTitlePanel);
    }

    private void addCountdownLabel() {
        countdownLabel = createWrappedLabel("Loading...", FONT_NORMAL, COLOR_LIGHT_GRAY);

        // Center using FlowLayout panel
        JPanel countdownPanel = new JPanel(new FlowLayout(FlowLayout.CENTER));
        countdownPanel.setOpaque(false);
        countdownPanel.add(countdownLabel);
        add(countdownPanel);

        updateCountdownLabel();
    }

    private void addLeaderboardTable() {
        tableModel = new DefaultTableModel(new Object[]{"Username", "Score"}, 0) {
            @Override
            public boolean isCellEditable(int row, int column) {
                return false;
            }
        };

        JTable table = new JTable(tableModel);
        configureTable(table);

        JScrollPane scrollPane = new JScrollPane(table);
        scrollPane.setPreferredSize(new Dimension(300, 300));
        scrollPane.setBorder(BorderFactory.createEmptyBorder());
        add(scrollPane);

        refreshLeaderboard();
    }

    private void configureTable(JTable table) {
        table.setFillsViewportHeight(true);
        table.setRowSelectionAllowed(false);
        table.setShowGrid(false);
        table.setFont(FONT_NORMAL);
        table.setRowHeight(TABLE_ROW_HEIGHT);
        table.setIntercellSpacing(new Dimension(0, TABLE_ROW_SPACING));

        LeaderboardCellRenderer renderer = new LeaderboardCellRenderer();
        renderer.setTable(table);
        table.getColumnModel().getColumn(0).setCellRenderer(renderer);
        table.getColumnModel().getColumn(1).setCellRenderer(renderer);
    }

    private void addButtons() {
        LinkButton[] linkButtons = {
                new LinkButton("BOTM", "/discord.png", "discord://discord.com/channels/414435426007384075/1014523362711715860"),
                new LinkButton("BOTM Drops", "/discord.png", "discord://discord.com/channels/414435426007384075/1047792122914406420"),
                new LinkButton("BOTM Wise Old Man", "/wom.png", getConfigValue("botmWomUrl", "https://wiseoldman.net/groups/141/competitions"))
        };
        addLinkButtons(linkButtons);
    }

    // Public API
    public boolean isEventActive() {
        return getConfigBoolean("botmActive");
    }

    public void refreshLeaderboard() {
        String leaderboardJson = configManager.getConfiguration("flux", "botmLeaderboard");
        if (leaderboardJson == null || leaderboardJson.isEmpty()) {
            return;
        }

        try {
            JsonParser jsonParser = new JsonParser();
            JsonArray leaderboard = jsonParser.parse(leaderboardJson).getAsJsonArray();
            tableModel.setRowCount(0);

            for (int i = 0; i < leaderboard.size(); i++) {
                JsonObject entry = leaderboard.get(i).getAsJsonObject();
                String username = entry.get("username").getAsString();
                int score = entry.get("score").getAsInt();
                tableModel.addRow(new Object[]{username, score});
            }
        } catch (Exception e) {
            handleAsyncError(e);
            logger.error("Failed to parse BOTM leaderboard", e);
        }
    }

    public void updateEventTitle() {
        String titleText = getConfigValue("botmTitle", "No active competition");
        updateWrappedLabelText(eventTitle, titleText, true);
        eventTitle.revalidate();
        eventTitle.repaint();
    }

    public void refreshButtonLinks() {
        updateButtonUrl("BOTM Wise Old Man", "botmWomUrl", configManager);
    }

    public void checkEventStateChanged() {
        updateCountdownLabel();
        updateEventTitle();
        refreshButtonLinks();

        if (isEventActive()) {
            startSheetPolling();
        } else {
            stopSheetPolling();
        }
    }

    @Override
    public void refresh() {
        checkEventStateChanged();
        refreshLeaderboard();
    }

    @Override
    protected boolean getConfigBoolean(String key) {
        return getConfigBoolean(key, configManager);
    }

    @Override
    protected String getConfigValue(String key, String defaultValue) {
        return getConfigValue(key, defaultValue, configManager);
    }

    // Private helpers
    private void startSheetPolling() {
        if (sheetParser == null) {
            sheetParser = new GoogleSheetParser(configManager, leaderboardJsonArray -> {
                String newJson = leaderboardJsonArray.toString();
                if (!newJson.equals(lastLeaderboardJson.get())) {
                    lastLeaderboardJson.set(newJson);
                    configManager.setConfiguration("flux", "botmLeaderboard", newJson);
                    SwingUtilities.invokeLater(this::refreshLeaderboard);
                }
            }, httpClient);
        }
        sheetParser.start();
    }

    private void stopSheetPolling() {
        if (sheetParser != null) {
            sheetParser.stop();
        }
    }

    private void startCountdownTimer() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        wasEventActive = isEventActive();
        countdownTimer = createCountdownTimer(this::handleTimerTick);
        countdownTimer.start();
    }

    private void handleTimerTick() {
        boolean isActiveNow = isEventActive();
        updateCountdownLabel();

        if (isActiveNow && hasEventEnded("botm_end_time", configManager)) {
            countdownTimer.stop();
        }

        if (wasEventActive != isActiveNow) {
            wasEventActive = isActiveNow;
            checkEventStateChanged();
        }
    }

    private void updateCountdownLabel() {
        if (!isEventActive()) {
            updateWrappedLabelText(countdownLabel, "No active BOTM event.", false);
            return;
        }

        String message = formatCountdownMessage("botm_start_time", "botm_end_time", configManager);

        // Override end message with winner info if available
        if (message.equals("Event has ended.")) {
            String winner = configManager.getConfiguration("flux", "botmWinner");
            message = (winner != null && !winner.isEmpty())
                    ? "BOTM has ended.<br>Winner: " + winner
                    : "The event has ended.";
        } else if (message.equals("Timing unavailable.")) {
            message = "BOTM timing unavailable.";
        } else if (message.equals("Timing error.")) {
            message = "BOTM timing error.";
        }

        updateWrappedLabelText(countdownLabel, message, false);
    }

    @Override
    public void shutdown() {
        if (countdownTimer != null) {
            countdownTimer.stop();
        }

        if (leaderboardCellRenderer != null) {
            leaderboardCellRenderer.shutdown(); // stop table timers
        }

        stopSheetPolling();
        super.shutdown();
    }
}
package com.flux.cards;

import javax.swing.*;
import net.runelite.client.config.ConfigManager;
import com.flux.FluxConfig;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.util.*;

@Slf4j
public class AdminHubCard extends FluxCard {
    private static final int TEXT_FIELD_COLUMNS = 30;
    private static final int SPACING_VERTICAL = 5;
    private static final int SPACING_HORIZONTAL = 10;

    private final FluxConfig config;
    private final ConfigManager configManager;
    private final Map<String, JTextField> textFields = new LinkedHashMap<>();
    private JCheckBox rollCallActiveCheckbox;

    public AdminHubCard(FluxConfig config, ConfigManager configManager) {
        super();
        this.config = config;
        this.configManager = configManager;

        setLayout(new GridBagLayout());
        buildUI();
    }

    private void buildUI() {
        GridBagConstraints gbc = createBaseConstraints();

        ConfigField[] configFields = {
                new ConfigField("Roll Call Active", "rollCallActive", true),
                new ConfigField("BOTM Password", "botm_password", false),
                new ConfigField("BOTM GDoc URL", "botmGdocUrl", false),
                new ConfigField("Clan Login Message", "clan_login_message", false),
                new ConfigField("Plugin Announcement", "plugin_announcement_message", false),
                new ConfigField("Hunt GDoc URL", "hunt_gdoc_url", false),
                new ConfigField("Hunt Passwords", "hunt_passwords", false)
        };

        int row = 0;
        for (ConfigField field : configFields) {
            gbc.gridy = row++;
            addFieldLabel(field.label, gbc);

            gbc.gridy = row++;
            if (field.isCheckbox) {
                addCheckboxField(field.configKey, gbc);
            } else {
                addTextField(field.label, field.configKey, gbc);
            }
        }

        gbc.gridy = row;
        gbc.weighty = 1.0;
        add(Box.createVerticalGlue(), gbc);
    }

    private GridBagConstraints createBaseConstraints() {
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(SPACING_VERTICAL, SPACING_HORIZONTAL, 0, SPACING_HORIZONTAL);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1.0;
        gbc.gridx = 0;
        return gbc;
    }

    private void addFieldLabel(String labelText, GridBagConstraints gbc) {
        JLabel label = new JLabel(labelText + ":");
        label.setForeground(COLOR_YELLOW);
        label.setFont(FONT_NORMAL);
        add(label, gbc);
    }

    private void addCheckboxField(String configKey, GridBagConstraints gbc) {
        rollCallActiveCheckbox = new JCheckBox("Active");

        boolean isActive = getConfigBoolean(configKey);
        rollCallActiveCheckbox.setSelected(isActive);

        rollCallActiveCheckbox.addActionListener(e -> {
            boolean selected = rollCallActiveCheckbox.isSelected();
            configManager.setConfiguration("flux", configKey, String.valueOf(selected));
        });

        add(rollCallActiveCheckbox, gbc);
    }

    private void addTextField(String fieldKey, String configKey, GridBagConstraints gbc) {
        JTextField textField = new JTextField(TEXT_FIELD_COLUMNS);

        String value = configManager.getConfiguration("flux", configKey);
        textField.setText(value != null ? value : "");

        textField.putClientProperty("originalValue", textField.getText());

        textField.addActionListener(e -> saveTextField(textField, configKey));

        textField.addFocusListener(new java.awt.event.FocusAdapter() {
            @Override
            public void focusLost(java.awt.event.FocusEvent e) {
                saveTextField(textField, configKey);
            }
        });

        textFields.put(fieldKey, textField);
        add(textField, gbc);
    }

    private void saveTextField(JTextField textField, String configKey) {
        String oldValue = (String) textField.getClientProperty("originalValue");
        String newValue = textField.getText();

        if (!Objects.equals(oldValue, newValue)) {
            configManager.setConfiguration("flux", configKey, newValue);
            textField.putClientProperty("originalValue", newValue);
        }
    }

    public void setValue(String fieldLabel, String value) {
        JTextField textField = textFields.get(fieldLabel);
        if (textField != null) {
            textField.setText(value);
            textField.putClientProperty("originalValue", value);
        }
    }

    public String getFieldValue(String fieldLabel) {
        JTextField textField = textFields.get(fieldLabel);
        return textField != null ? textField.getText() : null;
    }

    @Override
    public void refresh() {
        for (Map.Entry<String, JTextField> entry : textFields.entrySet()) {
            String fieldLabel = entry.getKey();
            JTextField textField = entry.getValue();

            String configKey = convertLabelToConfigKey(fieldLabel);
            String value = configManager.getConfiguration("flux", configKey);

            textField.setText(value != null ? value : "");
            textField.putClientProperty("originalValue", textField.getText());
        }

        if (rollCallActiveCheckbox != null) {
            boolean isActive = getConfigBoolean("rollCallActive");
            rollCallActiveCheckbox.setSelected(isActive);
        }
    }

    @Override
    protected boolean getConfigBoolean(String key) {
        return getConfigBoolean(key, configManager);
    }

    @Override
    protected String getConfigValue(String key, String defaultValue) {
        return getConfigValue(key, defaultValue, configManager);
    }

    private String convertLabelToConfigKey(String label) {
        Map<String, String> labelToKey = new LinkedHashMap<>();
        labelToKey.put("BOTM Password", "botm_password");
        labelToKey.put("BOTM GDoc URL", "botmGdocUrl");
        labelToKey.put("Clan Login Message", "clan_login_message");
        labelToKey.put("Plugin Announcement", "plugin_announcement_message");
        labelToKey.put("Hunt GDoc URL", "hunt_gdoc_url");
        labelToKey.put("Hunt Team 1 Color", "hunt_team_1_color");
        labelToKey.put("Hunt Team 2 Color", "hunt_team_2_color");
        labelToKey.put("Hunt Passwords", "hunt_passwords");

        return labelToKey.getOrDefault(label, label.toLowerCase().replace(" ", "_"));
    }

    private static class ConfigField {
        final String label;
        final String configKey;
        final boolean isCheckbox;

        ConfigField(String label, String configKey, boolean isCheckbox) {
            this.label = label;
            this.configKey = configKey;
            this.isCheckbox = isCheckbox;
        }
    }
}
package com.flux;

import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import javax.inject.Inject;
import java.awt.*;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

public class FluxOverlay extends OverlayPanel {
    private final ConfigManager configManager;
    private final FluxConfig config;

    @Inject
    private FluxOverlay(ConfigManager configManager, FluxConfig config) {
        this.configManager = configManager;
        this.config = config;

        setPosition(OverlayPosition.TOP_CENTER);
        getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "Clan Events overlay"));
    }

    @Override
    public Dimension render(Graphics2D graphics) {
        panelComponent.getChildren().clear();

        boolean overlayEnabled = config.overlay();
        if (!overlayEnabled) {
            return null;
        }

        boolean botmActive = getBooleanConfig("botmActive", false);
        boolean huntActive = getBooleanConfig("huntActive", false);

        String eventPass = config.eventPass();
        String botmPass = config.botmPass();
        String huntPasswords = getStringConfig("hunt_passwords", "");

        StringBuilder textBuilder = new StringBuilder();

        if (eventPass != null && !eventPass.isEmpty()) {
            textBuilder.append(eventPass);
        }

        if (botmActive && botmPass != null && !botmPass.isEmpty()) {
            if (textBuilder.length() > 0) {
                textBuilder.append(" | ");
            }
            textBuilder.append("BOTM: ").append(botmPass);
        }

        if (huntActive && huntPasswords != null && !huntPasswords.isEmpty()) {
            if (textBuilder.length() > 0) {
                textBuilder.append(" | ");
            }
            textBuilder.append("Hunt: ").append(huntPasswords);
        }

        String text = textBuilder.toString().trim();

        if (text.isEmpty()) {
            return null;
        }

        Color passColor = config.passColor();
        Color timeColor = config.timeColor();

        if (passColor.equals(timeColor)) {
            passColor = Color.GREEN;
            timeColor = Color.WHITE;
        }

        panelComponent.getChildren().add(LineComponent.builder()
                .left(text)
                .leftColor(passColor)
                .build());

        if (config.dtm()) {
            String time = localToGMT();
            LineComponent line = (LineComponent) panelComponent.getChildren().get(0);
            line.setRight(time);
            line.setRightColor(timeColor);

            int widthLeft = graphics.getFontMetrics().stringWidth(text);
            int widthRight = graphics.getFontMetrics().stringWidth(time);
            panelComponent.setPreferredSize(new Dimension(widthLeft + widthRight + 20, 0));
        } else {
            int widthLeft = graphics.getFontMetrics().stringWidth(text);
            panelComponent.setPreferredSize(new Dimension(widthLeft + 10, 0));
        }

        return super.render(graphics);
    }

    private boolean getBooleanConfig(String key, boolean defaultValue) {
        String value = configManager.getConfiguration("flux", key);
        if (value == null || value.isEmpty()) {
            return defaultValue;
        }
        return Boolean.parseBoolean(value);
    }

    private String getStringConfig(String key, String defaultValue) {
        String value = configManager.getConfiguration("flux", key);
        return (value != null && !value.isEmpty()) ? value : defaultValue;
    }

    public static String localToGMT() {
        Date date = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy HH:mm");
        sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
        return sdf.format(date) + " UTC";
    }
}
package com.flux;

import com.flux.constants.EntrySelect;
import net.runelite.client.config.*;

import java.awt.*;
import java.awt.event.KeyEvent;

@ConfigGroup(FluxPlugin.CONFIG_GROUP)
public interface FluxConfig extends Config {
    @ConfigSection(name = "Overlay", description = "Overlay configuration.", position = 0)
    String overlaySection = "Overlay section";

    // ========== OVERLAY SECTION - VISIBLE ==========
    @ConfigItem(keyName = "menuPriority", name = "Sidebar Priority", description = "Adjust the runelite sidebar priority. Lower priority => higher on sidebar. Restart the client to take effect")
    default int menuPriority() {
        return 5;
    }

    @ConfigItem(position = 1, keyName = "overlay", name = "Display Overlay", description = "Displays the overlay on your game screen.", section = overlaySection)
    default boolean overlay() {
        return false;
    }

    @ConfigItem(position = 2, keyName = "dtm", name = "Date & Time", description = "Adds the date and time to the overlay.", section = overlaySection)
    default boolean dtm() {
        return true;
    }

    @ConfigItem(position = 3, keyName = "eventPass", name = "Event Password:", description = "Adds the event password to the overlay.", section = overlaySection)
    default String eventPass() {
        return "";
    }

    @ConfigItem(position = 4, keyName = "disclaimer", name = "Colors below must be different", description = "The Password Color and the Date & Time Color must be different.", section = overlaySection)
    default void disclaimer() {}

    @ConfigItem(position = 5, keyName = "passColor", name = "Password Color", description = "The color of the Event Password.", section = overlaySection)
    default Color passColor() {
        return Color.GREEN;
    }

    @ConfigItem(position = 6, keyName = "timeColor", name = "Date & Time Color", description = "The color of the Date & Time.", section = overlaySection)
    default Color timeColor() {
        return Color.WHITE;
    }

    // ========== OVERLAY SECTION - HIDDEN ==========

    @ConfigItem(position = 7, keyName = "botm_password", name = "BOTM Password", description = "Adds the BOTM event password to the overlay.", section = overlaySection, hidden = true)
    default String botmPass() {
        return "";
    }

    @ConfigItem(position = 10, keyName = "entryKeybind", name = "Entry Select Keybind", description = "Sets the keybind used for opening the entry menu in the Clan Events panel.", section = overlaySection, hidden = true)
    default Keybind entryKeybind() {
        return new Keybind(KeyEvent.VK_SPACE, 0);
    }

    @ConfigItem(position = 11, keyName = "entry_1", name = "Entry 1", description = "Selects what to show for entry 1 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_1() {
        return EntrySelect.HOME;
    }

    @ConfigItem(position = 12, keyName = "entry_2", name = "Entry 2", description = "Selects what to show for entry 2 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_2() {
        return EntrySelect.HUB;
    }

    @ConfigItem(position = 13, keyName = "entry_3", name = "Entry 3", description = "Selects what to show for entry 3 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_3() {
        return EntrySelect.SOTW;
    }

    @ConfigItem(position = 14, keyName = "entry_4", name = "Entry 4", description = "Selects what to show for entry 4 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_4() {
        return EntrySelect.BOTM;
    }

    @ConfigItem(position = 15, keyName = "entry_5", name = "Entry 5", description = "Selects what to show for entry 5 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_5() {
        return EntrySelect.HOF_OVERALL;
    }

    @ConfigItem(position = 16, keyName = "entry_6", name = "Entry 6", description = "Selects what to show for entry 6 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_6() {
        return EntrySelect.HOF_KC;
    }

    @ConfigItem(position = 17, keyName = "entry_7", name = "Entry 7", description = "Selects what to show for entry 7 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_7() {
        return EntrySelect.HOF_PB;
    }

    @ConfigItem(position = 18, keyName = "entry_8", name = "Entry 8", description = "Selects what to show for entry 8 of the Clan Events panel.", section = overlaySection, hidden = true)
    default EntrySelect entry_8() {
        return EntrySelect.HUNT;
    }

    @ConfigItem(position = 19, keyName = "clan_login_message", name = "Login Message", description = "Message to broadcast to clan members upon login.", section = overlaySection, hidden = true)
    default String clanLoginMessage() {
        return "Check out the Flux Plugin Panel!";
    }

    @ConfigItem(position = 20, keyName = "plugin_announcement_message", name = "Announcement Message", description = "Announcement message in the home card of the plugin panel.", section = overlaySection, hidden = true)
    default String pluginAnnouncementMessage() {
        return "The Flux plugin is available for download from the plugin hub!";
    }

    @ConfigItem(position = 21, keyName = "rollCallActive", name = "Roll Call Active", description = "Is roll call active?", section = overlaySection, hidden = true)
    default Boolean rollCallActive() {
        return false;
    }

    @ConfigItem(position = 22, keyName = "wom_url", name = "WOM URL", description = "Configures the WOM button URL", section = overlaySection, hidden = true)
    default String womurl() {
        return "https://wiseoldman.net/groups/141";
    }

    @ConfigItem(position = 23, keyName = "wom_comps_url", name = "WOM Competitions URL", description = "URL to the Flux WOM Competitions page.", section = overlaySection, hidden = true)
    default String womCompsUrl() {
        return "https://wiseoldman.net/groups/141/competitions";
    }

    // ========== SOTW EVENT CONFIGURATION ==========

    @ConfigItem(position = 30, keyName = "sotwActive", name = "SOTW Active", description = "Is SOTW Active?", section = overlaySection, hidden = true)
    default Boolean sotwActive() {
        return false;
    }

    @ConfigItem(position = 31, keyName = "sotwTitle", name = "SOTW Title", description = "Title for the SOTW Event in WOM.", section = overlaySection, hidden = true)
    default String sotwTitle() {
        return "No Active SOTW Event.";
    }

    @ConfigItem(position = 32, keyName = "sotwLeaderboard", name = "SOTW Leaderboard", description = "Current SOTW Leaderboard", section = overlaySection, hidden = true)
    default String sotwLeaderboard() {
        return "[]";
    }

    @ConfigItem(position = 33, keyName = "sotw_wom_link", name = "SOTW WOM Link", description = "SOTW wise old man link.", section = overlaySection, hidden = true)
    default String sotwWomLink() {
        return "https://wiseoldman.net/groups/141/competitions";
    }

    @ConfigItem(position = 34, keyName = "sotw_start_time", name = "SOTW Start Time", description = "Start time for the SOTW Event.", section = overlaySection, hidden = true)
    default String sotwStartTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 35, keyName = "sotw_end_time", name = "SOTW End Time", description = "End time for the SOTW Event.", section = overlaySection, hidden = true)
    default String sotwEndTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 36, keyName = "sotw_winner", name = "SOTW Winner", description = "Winner of the last active SOTW Event.", section = overlaySection, hidden = true)
    default String sotwWinner() {
        return "";
    }

    // ========== BOTM EVENT CONFIGURATION ==========

    @ConfigItem(position = 40, keyName = "botmActive", name = "BOTM Active", description = "Is BOTM Active?", section = overlaySection, hidden = true)
    default Boolean botmActive() {
        return false;
    }

    @ConfigItem(position = 41, keyName = "botmTitle", name = "BOTM Title", description = "Title for the BOTM Event in WOM.", section = overlaySection, hidden = true)
    default String botmTitle() {
        return "No Active BOTM Event.";
    }

    @ConfigItem(position = 42, keyName = "botmLeaderboard", name = "BOTM Leaderboard", description = "Current BOTM Leaderboard", section = overlaySection, hidden = true)
    default String botmLeaderboard() {
        return "[]";
    }

    @ConfigItem(position = 43, keyName = "botmWomUrl", name = "BOTM WOM URL", description = "BOTM wise old man URL.", section = overlaySection, hidden = true)
    default String botmWomUrl() {
        return "https://wiseoldman.net/groups/141/competitions";
    }

    @ConfigItem(position = 44, keyName = "botm_start_time", name = "BOTM Start Time", description = "Start time for the BOTM Event.", section = overlaySection, hidden = true)
    default String botmStartTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 45, keyName = "botm_end_time", name = "BOTM End Time", description = "End time for the BOTM Event.", section = overlaySection, hidden = true)
    default String botmEndTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 46, keyName = "botm_winner", name = "BOTM Winner", description = "Winner of the last active BOTM Event.", section = overlaySection, hidden = true)
    default String botmWinner() {
        return "";
    }

    @ConfigItem(position = 47, keyName = "botmGdocUrl", name = "BOTM GDoc URL", description = "URL to the GDoc for BOTM Score", section = overlaySection, hidden = true)
    default String botmGdocUrl() {
        return "https://docs.google.com/spreadsheets/d/e/2PACX-1vQXOtUM0Y3OMvnZKVw7PRwM9HmkGrbXha2K75Ev2bf_9Ev_EliUHT18BpJ5Djyp1ebdeWSrEoPnF064/pubhtml?gid=0&single=true";
    }

    // ========== HUNT EVENT CONFIGURATION ==========

    @ConfigItem(position = 50, keyName = "huntActive", name = "Hunt Active", description = "Is The Hunt Active?", section = overlaySection, hidden = true)
    default Boolean huntActive() {
        return false;
    }

    @ConfigItem(position = 51, keyName = "huntTitle", name = "Hunt Title", description = "Title for the Hunt Event.", section = overlaySection, hidden = true)
    default String huntTitle() {
        return "No Active Hunt Event.";
    }

    @ConfigItem(position = 52, keyName = "hunt_competition_id", name = "Hunt Competition ID", description = "WiseOldMan competition ID for The Hunt event.", section = overlaySection, hidden = true)
    default String huntCompetitionId() {
        return "100262";
    }

    @ConfigItem(position = 53, keyName = "hunt_start_time", name = "Hunt Start Time", description = "Start time for the Hunt Event.", section = overlaySection, hidden = true)
    default String huntStartTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 54, keyName = "hunt_end_time", name = "Hunt End Time", description = "End time for the Hunt Event.", section = overlaySection, hidden = true)
    default String huntEndTime() {
        return "1970-01-01T00:00:00Z";
    }

    @ConfigItem(position = 55, keyName = "hunt_wom_url", name = "Hunt WOM URL", description = "Hunt Wise Old Man competition URL.", section = overlaySection, hidden = true)
    default String huntWomUrl() {
        return "https://wiseoldman.net/competitions/100262";
    }

    @ConfigItem(position = 56, keyName = "hunt_gdoc_url", name = "The Hunt GDoc", description = "The Hunt GDoc URL.", section = overlaySection, hidden = true)
    default String huntGdocUrl() {
        return "https://docs.google.com/spreadsheets/d/e/2PACX-1vSLCxscAVFZY9wuDqmeBPu4UZio2I39DHDGy_8DXrvHqYKmZc8NgsC4DWv_olXOTjGQktcBnU88Fmf4/pubhtml?gid=0&single=true";
    }

    @ConfigItem(position = 57, keyName = "hunt_team_1_name", name = "Hunt Team 1 Name", description = "Name of Hunt Team 1.", section = overlaySection, hidden = true)
    default String huntTeam1Name() {
        return "Team 1";
    }

    @ConfigItem(position = 58, keyName = "hunt_team_1_color", name = "Hunt Team 1 Color", description = "Hex color for Hunt Team 1 (e.g., #FF0000).", section = overlaySection, hidden = true)
    default String huntTeamOneColor() {
        return "#FF0000";
    }

    @ConfigItem(position = 59, keyName = "hunt_team_1_leaderboard", name = "Hunt Team 1 Leaderboard", description = "Top 10 EHB leaderboard for Team 1.", section = overlaySection, hidden = true)
    default String huntTeam1Leaderboard() {
        return "[]";
    }

    @ConfigItem(position = 60, keyName = "hunt_team_2_name", name = "Hunt Team 2 Name", description = "Name of Hunt Team 2.", section = overlaySection, hidden = true)
    default String huntTeam2Name() {
        return "Team 2";
    }

    @ConfigItem(position = 61, keyName = "hunt_team_2_color", name = "Hunt Team 2 Color", description = "Hex color for Hunt Team 2 (e.g., #0000FF).", section = overlaySection, hidden = true)
    default String huntTeamTwoColor() {
        return "#0000FF";
    }

    @ConfigItem(position = 62, keyName = "hunt_team_2_leaderboard", name = "Hunt Team 2 Leaderboard", description = "Top 10 EHB leaderboard for Team 2.", section = overlaySection, hidden = true)
    default String huntTeam2Leaderboard() {
        return "[]";
    }

    @ConfigItem(position = 63, keyName = "hunt_team_1_score", name = "Hunt Team 1 Score", description = "Current total score of Hunt Team 1.", section = overlaySection, hidden = true)
    default int huntTeamOneScore() {
        return 0;
    }

    @ConfigItem(position = 64, keyName = "hunt_team_2_score", name = "Hunt Team 2 Score", description = "Current total score of Hunt Team 2.", section = overlaySection, hidden = true)
    default int huntTeamTwoScore() {
        return 0;
    }

    @ConfigItem(position = 65, keyName = "hunt_passwords", name = "Hunt Passwords", description = "Hunt Passwords", section = overlaySection, hidden = true)
    default String huntPasswords() {
        return "";
    }
}
package com.flux.components;

import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.table.DefaultTableCellRenderer;

import java.awt.*;

public class LeaderboardCellRenderer extends DefaultTableCellRenderer {
    private final AnimatedShinyBorder goldBorder = new AnimatedShinyBorder(new Color(212, 175, 55), 3);
    private final AnimatedShinyBorder silverBorder = new AnimatedShinyBorder(new Color(192, 192, 192), 3);
    private final AnimatedShinyBorder bronzeBorder = new AnimatedShinyBorder(new Color(205, 127, 50), 3);
    private final Border emptyBorder = BorderFactory.createEmptyBorder(3, 3, 3, 3);

    private final Color darkGray = new Color(30, 30, 30);
    private final Color darkerGray = new Color(45, 45, 45);

    private float shinePos = 0f;
    private Timer timer;

    public LeaderboardCellRenderer() {
        timer = new Timer(50, e -> {
            shinePos += 0.01f;
            if (shinePos > 1f)
                shinePos = 0f;

            goldBorder.setShinePosition(shinePos);
            silverBorder.setShinePosition(shinePos);
            bronzeBorder.setShinePosition(shinePos);

            SwingUtilities.invokeLater(() -> {
                if (leaderboardTable != null)
                    leaderboardTable.repaint();
            });
        });
        timer.start();
    }

    private JTable leaderboardTable;

    public void setTable(JTable table) {
        this.leaderboardTable = table;
    }

    @Override
    public Component getTableCellRendererComponent(JTable table, Object value,
                                                   boolean isSelected, boolean hasFocus,
                                                   int row, int column) {
        leaderboardTable = table;

        Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        JComponent comp = (JComponent) c;

        if (!isSelected) {
            comp.setBackground((row % 2 == 0) ? darkGray : darkerGray);
        }

        if (row == 0)
            comp.setBorder(goldBorder);
        else if (row == 1)
            comp.setBorder(silverBorder);
        else if (row == 2)
            comp.setBorder(bronzeBorder);
        else
            comp.setBorder(emptyBorder);

        setHorizontalAlignment(column == 1 ? SwingConstants.CENTER : SwingConstants.LEFT);

        return comp;
    }

    public void shutdown() {
        if (timer != null) {
            timer.stop();
        }
        
        if (leaderboardTable != null) {
            leaderboardTable = null;
        }
    }
}
package com.flux.constants;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum EntrySelect
{
    NONE("None", 0),
    HOME("Home", 1),
    HUB("Admin Hub", 2),
    SOTW("Skill of the Week", 3),
    BOTM("Boss of the Month", 4),
    HOF_OVERALL("Hall of Fame - Overall", 5),
    HOF_KC("Hall of Fame - KC", 6),
    HOF_PB("Hall of Fame - PB", 7),
    HUNT("The Hunt", 8);

    private final String name;
    private final int value;

    @Override
    public String toString()
    {
        return name;
    }
}

/*
 * Copyright (c) 2022, cmsu224 <https://github.com/cmsu224>
 * Copyright (c) 2022, Brianmm94 <https://github.com/Brianmm94>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.flux.components.combobox;
import java.awt.Color;
import java.awt.Component;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.ListCellRenderer;
import javax.swing.border.EmptyBorder;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.components.TitleCaseListCellRenderer;
import net.runelite.client.util.Text;

/**
 * Based off the {@link TitleCaseListCellRenderer} but supports icons and default text value
 */
public final class ComboBoxIconListRenderer extends JLabel implements ListCellRenderer<Object>
{
    @Setter
    private String defaultText = "Select an option...";

    @Override
    public Component getListCellRendererComponent(JList list, Object o, int index, boolean isSelected, boolean cellHasFocus)
    {
        if (isSelected)
        {
            setBackground(ColorScheme.DARK_GRAY_COLOR);
            setForeground(Color.WHITE);
        }
        else
        {
            setBackground(list.getBackground());
            setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        }

        setBorder(new EmptyBorder(5, 5, 5, 0));

        String text;
        setIcon(null);
        // If using setSelectedItem(null) or setSelectedIndex(-1) show default text until a selection is made
        if (index == -1 && o == null)
        {
            text = defaultText;
        }
        else if (o instanceof Enum)
        {
            text = Text.titleCase((Enum<?>) o);
        }
        else if (o instanceof ComboBoxIconEntry)
        {
            final ComboBoxIconEntry e = (ComboBoxIconEntry) o;
            text = e.getText();
            setIcon(e.getIcon());
        }
        else
        {
            text = o.toString();
        }

        setText(text);

        return this;
    }
}
/*
 * Copyright (c) 2022, cmsu224 <https://github.com/cmsu224>
 * Copyright (c) 2022, Brianmm94 <https://github.com/Brianmm94>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.flux.components.combobox;
import javax.swing.Icon;
import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.Optional;

/**
 * Used with ComboBoxListRenderer to render an icon next to the text of the list entry.
 * Also supports adding a data object to be used for more complex selection logic
 */
@AllArgsConstructor
@Getter
public class ComboBoxIconEntry
{
    private Icon icon;
    private String text;
    private Optional<String> id;  // rename from data to id
}


package com.flux.components;

import javax.swing.border.AbstractBorder;
import java.awt.*;

public class AnimatedShinyBorder extends AbstractBorder {
    private final Color baseColor;
    private final int thickness;
    private float shinePosition = 0f;

    public AnimatedShinyBorder(Color baseColor, int thickness) {
        this.baseColor = baseColor;
        this.thickness = thickness;
    }

    public void setShinePosition(float pos) {
        shinePosition = pos % 1f;
    }

    @Override
    public void paintBorder(Component c, Graphics g, int x, int y, int width, int height) {
        Graphics2D g2 = (Graphics2D) g.create();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g2.setColor(baseColor);
        for (int i = 0; i < thickness; i++) {
            g2.drawRect(x + i, y + i, width - 1 - i * 2, height - 1 - i * 2);
        }

        Color shineColor = lightenColor(baseColor, 0.5f);

        g2.setColor(new Color(shineColor.getRed(), shineColor.getGreen(), shineColor.getBlue(), 180));

        int perimeter = 2 * (width + height - 4 * thickness);
        int shineLength = 8;
        int shinePosPixel = (int) (shinePosition * perimeter);

        for (int i = 0; i < shineLength; i++) {
            int pos = (shinePosPixel + i) % perimeter;
            Point p = pointOnOuterPerimeter(x, y, width, height, pos);
            int size = 3;
            g2.fillOval(p.x - size / 2, p.y - size / 2, size, size);
        }

        g2.dispose();
    }

    private Point pointOnOuterPerimeter(int x, int y, int width, int height, int pos) {
        int w = width - 1;
        int h = height - 1;

        if (pos < w)
            return new Point(x + pos, y);
        pos -= w;

        if (pos < h)
            return new Point(x + w, y + pos);
        pos -= h;

        if (pos < w)
            return new Point(x + w - pos, y + h);
        pos -= w;

        return new Point(x, y + h - pos);
    }

    private Color lightenColor(Color color, float factor) {
        int r = Math.min(255, (int) (color.getRed() + (255 - color.getRed()) * factor));
        int g = Math.min(255, (int) (color.getGreen() + (255 - color.getGreen()) * factor));
        int b = Math.min(255, (int) (color.getBlue() + (255 - color.getBlue()) * factor));
        return new Color(r, g, b);
    }

    @Override
    public Insets getBorderInsets(Component c) {
        return new Insets(thickness, thickness, thickness, thickness);
    }

    @Override
    public Insets getBorderInsets(Component c, Insets insets) {
        insets.left = insets.top = insets.right = insets.bottom = thickness;
        return insets;
    }
}
package com.flux.components;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import java.awt.*;
import java.awt.geom.Path2D;
import net.runelite.client.util.LinkBrowser;


public class InverseCornerButton extends JButton {
    private static final Logger logger = LoggerFactory.getLogger(InverseCornerButton.class);

    private static final int CONCAVE_DEPTH = 10;
    private static final Color ACTIVE_COLOR = Color.decode("#811F1D");
    private static final Color DEFAULT_COLOR = Color.BLACK;
    private static final Color GLOW_COLOR = Color.YELLOW;
    private static final Color BORDER_COLOR = Color.WHITE;

    private static final int GLOW_UPDATE_DELAY_MS = 50;
    private static final float GLOW_STEP = 0.05f;
    private static final int GLOW_SIZE = 5;

    private static final float BORDER_STROKE_WIDTH = 1.5f;

    private static final int DEFAULT_HEIGHT = 40;

    private String url;
    private boolean isActive = false;
    private boolean glowing = false;
    private float glowAlpha = 0f;
    private boolean glowIncreasing = true;
    private Timer glowTimer;

    private InverseCornerButton(String label, String url, ImageIcon icon) {
        super(label);
        this.url = url;

        if (icon != null) {
            setIcon(icon);
            setHorizontalTextPosition(label != null && !label.isEmpty()
                    ? SwingConstants.RIGHT
                    : SwingConstants.CENTER);
        }

        setupButtonStyle();
        setupListeners();
    }

    public static InverseCornerButton withUrl(String label, String url) {
        return new InverseCornerButton(label, url, null);
    }

    public static InverseCornerButton withImage(String label, String imagePath) {
        ImageIcon icon = loadIcon(imagePath);
        return new InverseCornerButton(label, null, icon);
    }

    public static InverseCornerButton iconOnly(String imagePath) {
        ImageIcon icon = loadIcon(imagePath);
        return new InverseCornerButton(null, null, icon);
    }

    public static InverseCornerButton withLabelImageAndUrl(String label, String imagePath, String url) {
        ImageIcon icon = loadIcon(imagePath);
        return new InverseCornerButton(label, url, icon);
    }

    private void setupButtonStyle() {
        setFocusPainted(false);
        setBackground(DEFAULT_COLOR);
        setForeground(Color.WHITE);
        setBorder(BorderFactory.createEmptyBorder(1, 1, 1, 1));
        setHorizontalAlignment(SwingConstants.CENTER);
        setPreferredSize(new Dimension(0, DEFAULT_HEIGHT));
        setContentAreaFilled(false);
    }

    private void setupListeners() {
        addMouseListener(new java.awt.event.MouseAdapter() {
            @Override
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                if (!isActive) {
                    setBackground(ACTIVE_COLOR);
                    repaint();
                }
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent evt) {
                if (!isActive) {
                    setBackground(DEFAULT_COLOR);
                    repaint();
                }
            }
        });

        addActionListener(e -> openLink());
    }

    public void setActive(boolean active) {
        this.isActive = active;
        setBackground(active ? ACTIVE_COLOR : DEFAULT_COLOR);
        repaint();
    }

    public boolean isActive() {
        return isActive;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getUrl() {
        return url;
    }

    public void setGlowing(boolean glowing) {
        this.glowing = glowing;

        if (glowing) {
            startGlowAnimation();
        } else {
            stopGlowAnimation();
        }

        repaint();
    }

    public boolean isGlowing() {
        return glowing;
    }

    private void startGlowAnimation() {
        if (glowTimer == null) {
            glowTimer = new Timer(GLOW_UPDATE_DELAY_MS, e -> updateGlow());
        }

        if (!glowTimer.isRunning()) {
            glowTimer.start();
        }
    }

    private void stopGlowAnimation() {
        if (glowTimer != null && glowTimer.isRunning()) {
            glowTimer.stop();
        }
        glowAlpha = 0f;
        glowIncreasing = true;
        repaint();
    }

    private void updateGlow() {
        if (glowIncreasing) {
            glowAlpha += GLOW_STEP;
            if (glowAlpha >= 1f) {
                glowAlpha = 1f;
                glowIncreasing = false;
            }
        } else {
            glowAlpha -= GLOW_STEP;
            if (glowAlpha <= 0f) {
                glowAlpha = 0f;
                glowIncreasing = true;
            }
        }
        repaint();
    }

    private void openLink() {
        if (url == null || url.isEmpty()) {
            return;
        }

        LinkBrowser.browse(url);
    }

    @Override
    protected void paintComponent(Graphics g) {
        Graphics2D g2 = (Graphics2D) g.create();
        try {
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            paintBackground(g2);

            if (glowing && glowAlpha > 0) {
                paintGlow(g2);
            }
        } finally {
            g2.dispose();
        }

        super.paintComponent(g);
    }

    private void paintBackground(Graphics2D g2) {
        g2.setColor(getBackground());
        Shape shape = createConcaveShape(getWidth(), getHeight());
        g2.fill(shape);
    }

    private void paintGlow(Graphics2D g2) {
        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, glowAlpha));
        g2.setColor(GLOW_COLOR);

        Shape glowShape = createConcaveShape(getWidth(), getHeight());

        for (int i = 1; i <= GLOW_SIZE; i++) {
            g2.setStroke(new BasicStroke(i));
            g2.draw(glowShape);
        }
    }

    @Override
    protected void paintBorder(Graphics g) {
        Graphics2D g2 = (Graphics2D) g.create();
        try {
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            Shape borderShape = createConcaveShape(getWidth() - 1, getHeight() - 1);
            g2.setColor(BORDER_COLOR);
            g2.setStroke(new BasicStroke(BORDER_STROKE_WIDTH));
            g2.draw(borderShape);
        } finally {
            g2.dispose();
        }
    }

    private Shape createConcaveShape(int width, int height) {
        Path2D.Float path = new Path2D.Float();
        int d = CONCAVE_DEPTH;

        path.moveTo(d, 0);
        path.lineTo(width - d, 0);
        path.lineTo(width, d);
        path.lineTo(width, height - d);
        path.lineTo(width - d, height);
        path.lineTo(d, height);
        path.lineTo(0, height - d);
        path.lineTo(0, d);
        path.closePath();

        return path;
    }

    private static ImageIcon loadIcon(String path) {
        if (path == null || path.isEmpty()) {
            logger.warn("Image path is null or empty");
            return null;
        }

        java.net.URL imgURL = InverseCornerButton.class.getResource(path);
        if (imgURL == null) {
            logger.warn("Could not find image resource: {}", path);
            return null;
        }

        return new ImageIcon(imgURL);
    }

    public void cleanup() {
        stopGlowAnimation();
        if (glowTimer != null) {
            glowTimer = null;
        }
    }
}
package com.flux.services;

import net.runelite.api.Client;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.clan.ClanChannelMember;
import net.runelite.api.clan.ClanRank;
import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

// periodically check users clan rank for Flux to authorize the admin card rednering
@Slf4j
public class ClanRankMonitor {
    private static final String TARGET_CLAN_NAME = "Flux";
    private static final int CHECK_DELAY_SECONDS = 7;
    private static final int CHECK_INTERVAL_SECONDS = 5;

    private final Client client;
    private final ScheduledExecutorService scheduler;
    private final Consumer<Boolean> rankChangeCallback;

    private ScheduledFuture<?> updateTask;
    private boolean isAdminOrHigher = false;

    public ClanRankMonitor(Client client, Consumer<Boolean> rankChangeCallback) {
        this.client = client;
        this.rankChangeCallback = rankChangeCallback;
        this.scheduler = Executors.newSingleThreadScheduledExecutor();
    }

    public void startMonitoring() {
        if (updateTask != null && !updateTask.isCancelled()) {
            updateTask.cancel(false);
        }

        updateTask = scheduler.scheduleAtFixedRate(
                this::checkAndUpdateRank,
                CHECK_DELAY_SECONDS,
                CHECK_INTERVAL_SECONDS,
                TimeUnit.SECONDS
        );
    }

    public void stopMonitoring() {
        if (updateTask != null) {
            updateTask.cancel(false);
            updateTask = null;
        }
    }

    public void shutdown() {
        stopMonitoring();
        scheduler.shutdownNow();
    }

    private void checkAndUpdateRank() {
        boolean wasAdminOrHigher = isAdminOrHigher;
        isAdminOrHigher = false;

        ClanChannel clanChannel = client.getClanChannel();
        if (clanChannel == null || clanChannel.getName() == null) {
            return;
        }

        String clanName = clanChannel.getName().trim();
        if (!clanName.equalsIgnoreCase(TARGET_CLAN_NAME)) {
            return;
        }

        ClanRank rank = getLocalPlayerClanRank();
        if (rank == null) {
            return;
        }

        int myRankValue = rank.getRank();
        int adminThreshold = ClanRank.ADMINISTRATOR.getRank();
        isAdminOrHigher = myRankValue >= adminThreshold;

        // Notify if rank changed
        if (wasAdminOrHigher != isAdminOrHigher) {
            rankChangeCallback.accept(isAdminOrHigher);
        }

        // Stop monitoring if admin or higher (no need to keep checking)
        if (isAdminOrHigher) {
            stopMonitoring();
        }
    }

    private ClanRank getLocalPlayerClanRank() {
        ClanChannel clanChannel = client.getClanChannel();
        if (clanChannel == null) {
            return null;
        }

        String localPlayerName = client.getLocalPlayer() != null
                ? client.getLocalPlayer().getName()
                : null;

        if (localPlayerName == null) {
            return null;
        }

        for (ClanChannelMember member : clanChannel.getMembers()) {
            if (localPlayerName.equalsIgnoreCase(member.getName())) {
                return member.getRank();
            }
        }

        return null;
    }

    public boolean isAdminOrHigher() {
        return isAdminOrHigher;
    }
}
package com.flux.services;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.runelite.client.config.ConfigManager;
import lombok.extern.slf4j.Slf4j;
import java.io.IOException;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;
import okhttp3.OkHttpClient;
import okhttp3.HttpUrl;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;

@Slf4j
public class GoogleSheetParser {
    private static final String API_KEY = "AIzaSyBu-qDCAFvD_z00uohkfD_ub0sZj-H8s1E";
    private static final String SPREADSHEET_ID = "1qqkjx4YjuQ9FIBDgAGzSpmoKcDow3yEa9lYFmc-JeDA";
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
    private final ConfigManager configManager;
    private Consumer<JsonArray> leaderboardCallback;
    private Consumer<Map<String, Integer>> huntScoreCallback;
    private Consumer<Map<String, String>> configCallback;
    private final AtomicBoolean isRunning = new AtomicBoolean(false);
    private final SheetType sheetType;
    private Thread leaderboardThread;
    private Thread huntScoreThread;
    private Thread configThread;
    private final OkHttpClient httpClient;

    public enum SheetType {
        BOTM,
        HUNT,
        CONFIG
    }

    public GoogleSheetParser(ConfigManager configManager, Consumer<JsonArray> leaderboardCallback, OkHttpClient httpClient) {
        this.configManager = configManager;
        this.leaderboardCallback = leaderboardCallback;
        this.sheetType = SheetType.BOTM;
        this.httpClient = httpClient;
    }

    public GoogleSheetParser(ConfigManager configManager, SheetType type, Consumer<Map<String, Integer>> huntScoreCallback, OkHttpClient httpClient) {
        this.configManager = configManager;
        this.huntScoreCallback = huntScoreCallback;
        this.sheetType = type;
        this.httpClient = httpClient;
    }

    public GoogleSheetParser(ConfigManager configManager, SheetType type, Consumer<Map<String, String>> configCallback, boolean isConfigSheet, OkHttpClient httpClient) {
        this.configManager = configManager;
        this.configCallback = configCallback;
        this.sheetType = type;
        this.httpClient = httpClient;
    }

    private String makeSheetsApiRequest(String range) throws IOException {
        HttpUrl url = HttpUrl.parse("https://sheets.googleapis.com/v4/spreadsheets/"
                        + SPREADSHEET_ID
                        + "/values/"
                        + range)
                .newBuilder()
                .addQueryParameter("key", API_KEY)
                .build();

        Request request = new Request.Builder()
                .url(url)
                .get()
                .build();

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                log.error("Request failed with status code: {}", response.code());
                throw new IOException("Unexpected code " + response);
            }

            ResponseBody body = response.body();
            if (body == null) {
                throw new IOException("Empty response body");
            }

            return body.string();
        }
    }

    public JsonArray getValues(String range) throws IOException {
        String jsonResponse = makeSheetsApiRequest(range);

        JsonObject jsonObject = new JsonParser()
                .parse(jsonResponse)
                .getAsJsonObject();

        if (!jsonObject.has("values")) {
            log.warn("[Sheets] No 'values' field found for range {}", range);
            return new JsonArray();
        }

        return jsonObject.getAsJsonArray("values");
    }


    public JsonArray parseTop10Leaderboard() {
        JsonArray leaderboard = new JsonArray();

        try {
            JsonArray jsonArray = getValues("BOTM");

            List<List<Object>> values = new ArrayList<>();
            for (int i = 0; i < jsonArray.size(); i++) {
                JsonArray row = jsonArray.get(i).getAsJsonArray();
                List<Object> rowValues = new ArrayList<>();
                for (int j = 0; j < row.size(); j++) {
                    rowValues.add(row.get(j));
                }
                values.add(rowValues);
            }

            if (!values.isEmpty()) {
                int startRow = findLeaderboardStartRow(values);
                if (startRow >= 0) {
                    List<Object> headers = values.get(startRow - 1);
                    Map<String, Integer> headerIndexMap = mapHeaders(headers);

                    for (int i = startRow; i < values.size(); i++) {
                        List<Object> row = values.get(i);
                        if (row.size() >= headerIndexMap.size()) {
                            JsonObject playerData = new JsonObject();
                            if (headerIndexMap.containsKey("Rank") && row.size() > headerIndexMap.get("Rank"))
                                playerData.addProperty("rank", String.valueOf(row.get(headerIndexMap.get("Rank"))));
                            if (headerIndexMap.containsKey("Players") && row.size() > headerIndexMap.get("Players"))
                                playerData.addProperty("username", String.valueOf(row.get(headerIndexMap.get("Players"))));
                            if (headerIndexMap.containsKey("Points") && row.size() > headerIndexMap.get("Points"))
                                playerData.addProperty("score", Integer.parseInt(String.valueOf(row.get(headerIndexMap.get("Points")))));
                            if (headerIndexMap.containsKey("KC") && row.size() > headerIndexMap.get("KC"))
                                playerData.addProperty("kc", Integer.parseInt(String.valueOf(row.get(headerIndexMap.get("KC")))));

                            leaderboard.add(playerData);
                        }
                    }
                }
            }
        } catch (IOException e) {
            log.error("Error fetching Google Sheets data", e);
        }

        if (leaderboard.size() > 10) {
            JsonArray top10 = new JsonArray();
            for (int i = 0; i < 10; i++) {
                top10.add(leaderboard.get(i));
            }
            leaderboard = top10;
        }

        return leaderboard;
    }

    public Map<String, Integer> parseHuntScores() {
        Map<String, Integer> scores = new HashMap<>();

        try {
            JsonArray jsonArray = getValues("Hunt");
            List<List<Object>> values = new ArrayList<>();
            for (int i = 0; i < jsonArray.size(); i++) {
                JsonArray row = jsonArray.get(i).getAsJsonArray();
                List<Object> rowValues = new ArrayList<>();
                for (int j = 0; j < row.size(); j++) {
                    rowValues.add(row.get(j));
                }
                values.add(rowValues);
            }

            if (!values.isEmpty()) {
                int scoreStartRow = findCurrentScoreSection(values);

                if (scoreStartRow >= 0) {
                    int dataStartRow = scoreStartRow + 2;

                    for (int i = dataStartRow; i < values.size() && i < dataStartRow + 10; i++) {
                        List<Object> row = values.get(i);

                        if (row.size() >= 2) {
                            String teamName = String.valueOf(row.get(0)).trim();
                            String pointsStr = String.valueOf(row.get(1)).trim();

                            if (teamName.isEmpty() || pointsStr.isEmpty()) {
                                break;
                            }

                            try {
                                int points = Integer.parseInt(pointsStr);
                                scores.put(teamName, points);
                            } catch (NumberFormatException e) {
                                log.warn("Failed to parse points for team: {}, value: {}", teamName, pointsStr);
                            }
                        }
                    }
                } else {
                    log.warn("Could not find 'Current Score' section in Hunt sheet");
                }
            }
        } catch (IOException e) {
            log.error("Error fetching Hunt scores from Google Sheets", e);
        }

        return scores;
    }

    public Map<String, String> parseConfigValues() {
        Map<String, String> configValues = new HashMap<>();

        try {
            JsonArray jsonArray = getValues("Config");
            log.info("[Config] Raw rows count: {}", jsonArray.size());

            for (int i = 0; i < jsonArray.size(); i++) {
                JsonArray row = jsonArray.get(i).getAsJsonArray();

                if (row.size() < 2) {
                    log.debug("[Config] Skipping row {} (less than 2 columns)", i);
                    continue;
                }

                String key = row.get(0).getAsString().trim();
                String value = row.get(1).getAsString().trim();

                if (key.isEmpty() || key.equalsIgnoreCase("key") || key.equalsIgnoreCase("config")) {
                    log.debug("[Config] Skipping header/empty key: {}", key);
                    continue;
                }

                configValues.put(key.toUpperCase(), value);
            }

        } catch (IOException e) {
            log.error("Error fetching Config values from Google Sheets", e);
        }

        return configValues;
    }


    private static int findCurrentScoreSection(List<List<Object>> values) {
        for (int i = 0; i < values.size(); i++) {
            List<Object> row = values.get(i);
            if (!row.isEmpty()) {
                String cellValue = String.valueOf(row.get(0)).trim().toLowerCase();
                if (cellValue.contains("current score")) {
                    return i;
                }
            }
        }
        return -1;
    }

    private static int findLeaderboardStartRow(List<List<Object>> values) {
        for (int i = 0; i < values.size(); i++) {
            List<Object> row = values.get(i);
            if (row.size() >= 4) {
                if (row.stream().anyMatch(cell -> cell.toString().equalsIgnoreCase("Rank")) &&
                        row.stream().anyMatch(cell -> cell.toString().equalsIgnoreCase("Points")) &&
                        row.stream().anyMatch(cell -> cell.toString().equalsIgnoreCase("Players")) &&
                        row.stream().anyMatch(cell -> cell.toString().equalsIgnoreCase("KC"))) {
                    return i + 1;
                }
            }
        }
        return -1;
    }

    private static Map<String, Integer> mapHeaders(List<Object> headers) {
        Map<String, Integer> headerIndexMap = new HashMap<>();
        for (int i = 0; i < headers.size(); i++) {
            String header = headers.get(i).toString().trim();
            if (header.equalsIgnoreCase("Rank")) {
                headerIndexMap.put("Rank", i);
            } else if (header.equalsIgnoreCase("Players")) {
                headerIndexMap.put("Players", i);
            } else if (header.equalsIgnoreCase("Points")) {
                headerIndexMap.put("Points", i);
            } else if (header.equalsIgnoreCase("KC")) {
                headerIndexMap.put("KC", i);
            }
        }
        return headerIndexMap;
    }

    public void start() {
        if (isRunning.compareAndSet(false, true)) {
            if (sheetType == SheetType.HUNT) {
                huntScoreThread = new Thread(this::pollHuntScores);
                huntScoreThread.start();
            } else if (sheetType == SheetType.CONFIG) {
                configThread = new Thread(this::pollConfigValues);
                configThread.start();
            } else {
                leaderboardThread = new Thread(this::pollLeaderboard);
                leaderboardThread.start();
            }
        }
    }

    private void pollLeaderboard() {
        Runnable leaderboardTask = () -> {
            if (!isRunning.get()) {
                return;
            }

            JsonArray leaderboard = parseTop10Leaderboard();
            if (leaderboardCallback != null) {
                leaderboardCallback.accept(leaderboard);
            }
        };

        scheduler.scheduleAtFixedRate(leaderboardTask, 0, 7, TimeUnit.MINUTES);
    }

    private void pollHuntScores() {
        Runnable huntScoresTask = () -> {
            if (!isRunning.get()) {
                return;
            }

            Map<String, Integer> scores = parseHuntScores();
            if (huntScoreCallback != null && !scores.isEmpty()) {
                huntScoreCallback.accept(scores);
            }
        };

        scheduler.scheduleAtFixedRate(huntScoresTask, 0, 7, TimeUnit.MINUTES);
    }

    private void pollConfigValues() {
        Runnable configValuesTask = () -> {
            if (!isRunning.get()) {
                log.debug("[Config] Poll skipped (not running)");
                return;
            }

            Map<String, String> configValues = parseConfigValues();

            if (configCallback == null) {
                log.warn("[Config] configCallback is NULL");
                return;
            }

            if (configValues.isEmpty()) {
                log.warn("[Config] No config values parsed");
                return;
            }

            configCallback.accept(configValues);
        };

        scheduler.scheduleAtFixedRate(configValuesTask, 0, 2, TimeUnit.MINUTES);
    }

    public void stop() {
        isRunning.set(false);
    }

    public void shutdown() {
        stop();
        scheduler.shutdownNow();

        if (leaderboardThread != null) {
            leaderboardThread.interrupt();
        }
        if (huntScoreThread != null) {
            huntScoreThread.interrupt();
        }
        if (configThread != null) {
            configThread.interrupt();
        }
    }
}

package com.flux.services;

import com.flux.services.wom.*;
import com.flux.services.wom.CompetitionModels.CompetitionData;
import com.flux.services.wom.CompetitionModels.EventType;
import net.runelite.client.config.ConfigManager;
import lombok.extern.slf4j.Slf4j;

import java.time.Instant;
import java.util.Map;
import java.util.concurrent.*;


//Scheduler made for checking and updating comp data from wom API.
@Slf4j
public class CompetitionScheduler {
    // TODO in future release make configurable, next hunt is 8 months away
    private static final String DEFAULT_HUNT_COMPETITION_ID = "100262";
    private volatile boolean active = false;
    long initialDelaySeconds = 3;
    long periodMinutes = 7;

    private final ConfigManager configManager;
    private volatile ScheduledExecutorService schedulerService;
    private final WiseOldManApiClient apiClient;
    private final CompetitionFinder finder;
    private final CompetitionConfigUpdater configUpdater;

    public CompetitionScheduler(ConfigManager configManager,
                                WiseOldManApiClient apiClient,
                                CompetitionFinder finder,
                                CompetitionConfigUpdater configUpdater) {
        this.configManager = configManager;
        this.apiClient = apiClient;
        this.finder = finder;
        this.configUpdater = configUpdater;
    }

    // Starts the periodic wom comp check scheduler.
    public synchronized void start() {
        if (schedulerService != null && !schedulerService.isShutdown()) return;

        active = true;
        schedulerService = Executors.newSingleThreadScheduledExecutor();
        schedulerService.scheduleAtFixedRate(() -> {
            if (!active) return;
            checkAndUpdateCompetitions();
        }, initialDelaySeconds, periodMinutes * 60, TimeUnit.SECONDS);
    }

    public synchronized void stop() {
        active = false;
        if (schedulerService != null) {
            schedulerService.shutdown();
            schedulerService = null;
        }
    }

    private void checkAndUpdateCompetitions() {
        log.debug("Checking competitions...");

        try {
            checkSotwAndBotm();
            checkHunt();
        } catch (Exception e) {
            log.error("Error during scheduled check", e);
        }
    }

    private void checkSotwAndBotm() {
        Map<EventType, CompetitionData> activeCompetitions = finder.findActiveCompetitions();

        for (Map.Entry<EventType, CompetitionData> entry : activeCompetitions.entrySet()) {
            EventType type = entry.getKey();
            CompetitionData data = entry.getValue();

            if (data != null) {
                updateEvent(type, data, true);
            } else {
                CompetitionData lastCompleted = finder.findLastCompletedCompetition(type);
                if (lastCompleted != null) {
                    updateEvent(type, lastCompleted, false);
                } else {
                    configUpdater.setEventInactive(type);
                }
            }
        }
    }

    private void checkHunt() {
        try {
            int huntCompId = getHuntCompetitionId();
            CompetitionData huntData = finder.findHuntCompetition(huntCompId);
            if (huntData == null) {
                log.error("Failed to fetch Hunt competition details");
                return;
            }

            Instant now = Instant.now();
            boolean isActive = huntData.isActive(now);

            // Always update config with Hunt data, even if not active
            updateEvent(EventType.HUNT, huntData, isActive);
        } catch (Exception e) {
            log.error("Error checking Hunt competition", e);
            e.printStackTrace();
        }
    }

    private void updateEvent(EventType type, CompetitionData data, boolean isActive) {
        String womUrl = apiClient.getCompetitionUrl(data.competitionId);
        configUpdater.updateEventConfig(type, data, isActive, womUrl);
    }

    private int getHuntCompetitionId() {
        String huntCompIdStr = configUpdater.getConfig("hunt_competition_id", DEFAULT_HUNT_COMPETITION_ID);

        // Save default if not set
        if (huntCompIdStr.equals(DEFAULT_HUNT_COMPETITION_ID)) {
            configManager.setConfiguration("flux", "hunt_competition_id", DEFAULT_HUNT_COMPETITION_ID);
        }

        return Integer.parseInt(huntCompIdStr);
    }
}
package com.flux.services;

import net.runelite.api.ChatMessageType;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class LoginMessageSender {
    private static final String CONFIG_GROUP = "flux";
    private static final String CONFIG_KEY = "clan_login_message";
    private static final String MESSAGE_COLOR = "ff9600";

    private final ChatMessageManager chatMessageManager;
    private final ConfigManager configManager;
    private boolean hasSentMessage = false;

    public LoginMessageSender(ChatMessageManager chatMessageManager, ConfigManager configManager) {
        this.chatMessageManager = chatMessageManager;
        this.configManager = configManager;
    }

    public void sendLoginMessage() {
        if (hasSentMessage) {
            return;
        }

        String loginMessage = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY);
        if (loginMessage == null || loginMessage.isEmpty()) {
            hasSentMessage = true;
            return;
        }

        chatMessageManager.queue(
                QueuedMessage.builder()
                        .type(ChatMessageType.GAMEMESSAGE)
                        .runeLiteFormattedMessage("<col=" + MESSAGE_COLOR + ">" + loginMessage + "</col>")
                        .build()
        );

        hasSentMessage = true;
    }

    public void reset() {
        hasSentMessage = false;
    }

    public boolean hasSentMessage() {
        return hasSentMessage;
    }
}
package com.flux.services.wom;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.IOException;


@Slf4j
public class WiseOldManApiClient {
    private static final String BASE_API_URL = "https://api.wiseoldman.net/v2";
    private static final String GROUP_ID = "141";
    private static final JsonParser jsonParser = new JsonParser();
    private final OkHttpClient httpClient;

    public WiseOldManApiClient(OkHttpClient httpClient) {
        this.httpClient = httpClient;
    }

    public JsonArray fetchGroupCompetitions() throws Exception {
        String urlString = BASE_API_URL + "/groups/" + GROUP_ID + "/competitions";
        String response = makeHttpRequest(urlString);
        return jsonParser.parse(response).getAsJsonArray();
    }

    public JsonObject fetchCompetitionDetails(int competitionId) throws Exception {
        String urlString = BASE_API_URL + "/competitions/" + competitionId;
        String response = makeHttpRequest(urlString);
        return jsonParser.parse(response).getAsJsonObject();
    }

    public String getCompetitionUrl(int competitionId) {
        return "https://wiseoldman.net/competitions/" + competitionId;
    }

    private String makeHttpRequest(String urlString) throws Exception {
        Request request = new Request.Builder()
                .url(urlString)
                .build();

        try (Response response = httpClient.newCall(request).execute()) {
            if (!response.isSuccessful()) {
                log.error("Request failed with status code: {}", response.code());
                throw new IOException("Unexpected code " + response);
            }

            return response.body().string();
        }
    }
}

package com.flux.services.wom;

import net.runelite.client.config.ConfigManager;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.flux.services.wom.CompetitionModels.CompetitionData;
import com.flux.services.wom.CompetitionModels.EventType;
import com.flux.services.wom.CompetitionModels.HuntTeamData;
import lombok.extern.slf4j.Slf4j;
import java.util.LinkedHashMap;

@Slf4j
public class CompetitionConfigUpdater {
    private final ConfigManager configManager;

    public CompetitionConfigUpdater(ConfigManager configManager) {
        this.configManager = configManager;
    }

    public void updateEventConfig(EventType type, CompetitionData data, boolean isActive, String womUrl) {
        String prefix = type.getConfigPrefix();

        setConfigIfChanged(prefix + "Title", data.title);
        setConfigIfChanged(prefix + "Active", String.valueOf(isActive));

        if (data.startTime != null) {
            setConfigIfChanged(prefix + "_start_time", data.startTime.toString());
        }
        if (data.endTime != null) {
            setConfigIfChanged(prefix + "_end_time", data.endTime.toString());
        }

        setConfigIfChanged(prefix + "_wom_link", womUrl);

        switch (type) {
            case BOTM:
                setConfigIfChanged("botmWomUrl", womUrl);
                break;

            case SOTW:
                if (data.sotwLeaderboard != null) {
                    saveSotwLeaderboard(data.sotwLeaderboard);
                    if (!isActive && !data.sotwLeaderboard.isEmpty()) {
                        String winner = data.sotwLeaderboard.keySet().iterator().next();
                        setConfigIfChanged(prefix + "_winner", winner);
                    }
                }
                break;

            case HUNT:
                setConfigIfChanged("hunt_wom_url", womUrl);
                if (data.huntTeamData != null) {
                    saveHuntTeamData(data.huntTeamData);
                }
                break;
        }
    }

    public void setEventInactive(EventType type) {
        String prefix = type.getConfigPrefix();
        setConfigIfChanged(prefix + "Active", "false");
    }

    public String getConfig(String key, String defaultValue) {
        String value = configManager.getConfiguration("flux", key);
        return (value != null && !value.isEmpty()) ? value : defaultValue;
    }

    private void saveSotwLeaderboard(LinkedHashMap<String, Integer> leaderboard) {
        JsonArray json = new JsonArray();
        leaderboard.forEach((username, xp) -> {
            JsonObject obj = new JsonObject();
            obj.addProperty("username", username);
            obj.addProperty("xp", xp);
            json.add(obj);
        });
        setConfigIfChanged("sotwLeaderboard", json.toString());
    }

    private void saveHuntTeamData(HuntTeamData huntData) {
        setConfigIfChanged("hunt_team_1_name", huntData.team1Name);
        setConfigIfChanged("hunt_team_2_name", huntData.team2Name);

        JsonArray team1Json = new JsonArray();
        huntData.team1Leaderboard.forEach((username, ehb) -> {
            JsonObject obj = new JsonObject();
            obj.addProperty("username", username);
            obj.addProperty("ehb", ehb);
            team1Json.add(obj);
        });
        setConfigIfChanged("hunt_team_1_leaderboard", team1Json.toString());

        JsonArray team2Json = new JsonArray();
        huntData.team2Leaderboard.forEach((username, ehb) -> {
            JsonObject obj = new JsonObject();
            obj.addProperty("username", username);
            obj.addProperty("ehb", ehb);
            team2Json.add(obj);
        });
        setConfigIfChanged("hunt_team_2_leaderboard", team2Json.toString());

        setConfigIfChanged("hunt_team_1_score", String.valueOf(huntData.team1TotalScore));
        setConfigIfChanged("hunt_team_2_score", String.valueOf(huntData.team2TotalScore));
    }

    private void setConfigIfChanged(String key, String value) {
        String currentValue = configManager.getConfiguration("flux", key);
        if (!value.equals(currentValue)) {
            configManager.setConfiguration("flux", key, value);
        }
    }
}

package com.flux.services.wom;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonElement;
import lombok.extern.slf4j.Slf4j;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;

import static com.flux.services.wom.CompetitionModels.*;

@Slf4j
public class CompetitionFinder {
    private final WiseOldManApiClient apiClient;
    private final CompetitionDataParser dataParser;

    public CompetitionFinder(WiseOldManApiClient apiClient, CompetitionDataParser dataParser) {
        this.apiClient = apiClient;
        this.dataParser = dataParser;
    }

    public Map<EventType, CompetitionData> findActiveCompetitions() {
        Map<EventType, CompetitionData> results = new EnumMap<>(EventType.class);
        results.put(EventType.SOTW, null);
        results.put(EventType.BOTM, null);

        try {
            JsonArray competitions = apiClient.fetchGroupCompetitions();
            Instant now = Instant.now();

            for (JsonElement element : competitions) {
                JsonObject comp = element.getAsJsonObject();

                Instant startsAt = Instant.parse(comp.get("startsAt").getAsString());
                Instant endsAt = Instant.parse(comp.get("endsAt").getAsString());

                // Skip if not currently active
                if (now.isBefore(startsAt) || !now.isBefore(endsAt)) {
                    continue;
                }

                String title = comp.get("title").getAsString().toLowerCase();
                int competitionId = comp.get("id").getAsInt();

                // Check for SOTW and BOTM
                for (EventType type : new EventType[]{EventType.SOTW, EventType.BOTM}) {
                    if (type.matchesTitle(title) && results.get(type) == null) {
                        CompetitionData data = fetchCompetitionData(competitionId, type, startsAt, endsAt);
                        if (data != null) {
                            results.put(type, data);
                        }
                    }
                }
            }
        } catch (Exception e) {
            log.error("Error finding active competitions: ", e);
        }

        return results;
    }


    public CompetitionData findLastCompletedCompetition(EventType type) {
        // Hunt is handled differently
        if (type == EventType.HUNT) {
            return null;
        }

        try {
            JsonArray competitions = apiClient.fetchGroupCompetitions();
            Instant now = Instant.now();

            JsonObject mostRecentCompleted = null;
            Instant mostRecentEndTime = null;

            for (JsonElement element : competitions) {
                JsonObject comp = element.getAsJsonObject();
                String title = comp.get("title").getAsString().toLowerCase();

                if (!type.matchesTitle(title)) {
                    continue;
                }

                Instant endsAt = Instant.parse(comp.get("endsAt").getAsString());

                // Skip if not yet ended
                if (now.isBefore(endsAt)) {
                    continue;
                }

                // Check if more recent
                if (mostRecentEndTime == null || endsAt.isAfter(mostRecentEndTime)) {
                    mostRecentCompleted = comp;
                    mostRecentEndTime = endsAt;
                }
            }

            if (mostRecentCompleted != null) {
                int competitionId = mostRecentCompleted.get("id").getAsInt();
                Instant startsAt = Instant.parse(mostRecentCompleted.get("startsAt").getAsString());
                Instant endsAt = Instant.parse(mostRecentCompleted.get("endsAt").getAsString());

                return fetchCompetitionData(competitionId, type, startsAt, endsAt);
            }
        } catch (Exception e) {
            log.error("Error finding last completed " + type.name() + ": ", e);
        }

        return null;
    }


    // Get Hunt competition data by ID
    public CompetitionData findHuntCompetition(int competitionId) {
        try {
            JsonObject details = apiClient.fetchCompetitionDetails(competitionId);
            if (details == null) {
                return null;
            }

            Instant startsAt = Instant.parse(details.get("startsAt").getAsString());
            Instant endsAt = Instant.parse(details.get("endsAt").getAsString());

            HuntTeamData huntData = dataParser.parseHuntTeamData(details);

            return new CompetitionData(
                    competitionId,
                    details.get("title").getAsString(),
                    startsAt,
                    endsAt,
                    null,
                    huntData
            );
        } catch (Exception e) {
            log.error("Error finding Hunt competition: ", e);
        }

        return null;
    }


    private CompetitionData fetchCompetitionData(int competitionId, EventType type,
                                                 Instant startsAt, Instant endsAt) {
        try {
            JsonObject details = apiClient.fetchCompetitionDetails(competitionId);
            return new CompetitionData(
                    competitionId,
                    details.get("title").getAsString(),
                    startsAt,
                    endsAt,
                    type == EventType.SOTW ? dataParser.parseSotwLeaderboard(details) : null,
                    null
            );
        } catch (Exception e) {
            log.error("Error fetching competition " + competitionId + ": ", e);
        }

        return null;
    }
}
package com.flux.services.wom;

import java.time.Instant;
import java.util.LinkedHashMap;

// Data models for wom comp objects.
public class CompetitionModels {

    public static class CompetitionData {
        public final int competitionId;
        public final String title;
        public final Instant startTime;
        public final Instant endTime;
        public final LinkedHashMap<String, Integer> sotwLeaderboard;
        public final HuntTeamData huntTeamData;

        public CompetitionData(int competitionId, String title, Instant startTime, Instant endTime,
                               LinkedHashMap<String, Integer> sotwLeaderboard, HuntTeamData huntTeamData) {
            this.competitionId = competitionId;
            this.title = title;
            this.startTime = startTime;
            this.endTime = endTime;
            this.sotwLeaderboard = sotwLeaderboard;
            this.huntTeamData = huntTeamData;
        }

        public boolean isActive(Instant now) {
            return !now.isBefore(startTime) && now.isBefore(endTime);
        }

        public boolean hasEnded(Instant now) {
            return !now.isBefore(endTime);
        }
    }

    public static class HuntTeamData {
        public final String team1Name;
        public final String team2Name;
        public final LinkedHashMap<String, Double> team1Leaderboard;
        public final LinkedHashMap<String, Double> team2Leaderboard;
        public final int team1TotalScore;
        public final int team2TotalScore;

        public HuntTeamData(String team1Name, String team2Name,
                            LinkedHashMap<String, Double> team1Leaderboard,
                            LinkedHashMap<String, Double> team2Leaderboard,
                            int team1TotalScore, int team2TotalScore) {
            this.team1Name = team1Name;
            this.team2Name = team2Name;
            this.team1Leaderboard = team1Leaderboard;
            this.team2Leaderboard = team2Leaderboard;
            this.team1TotalScore = team1TotalScore;
            this.team2TotalScore = team2TotalScore;
        }
    }

    public static class HuntParticipant {
        public final String username;
        public final double ehb;

        public HuntParticipant(String username, double ehb) {
            this.username = username;
            this.ehb = ehb;
        }
    }

    public enum EventType {
        SOTW("sotw", "sotw"),
        BOTM("botm", "botm"),
        HUNT("the hunt", "hunt");

        private final String keyword;
        private final String configPrefix;

        EventType(String keyword, String configPrefix) {
            this.keyword = keyword;
            this.configPrefix = configPrefix;
        }

        public String getConfigPrefix() {
            return configPrefix;
        }

        // Checks if a competition title matches this event type.
        public boolean matchesTitle(String title) {
            String lowerTitle = title.toLowerCase();

            switch (this) {
                case SOTW:
                    return lowerTitle.matches(".*\\bsotw\\b.*");
                case BOTM:
                    return lowerTitle.matches(".*\\bbotm\\b.*");
                case HUNT:
                    // Hunt is fetched by ID, not title
                    return false; 
                default:
                    return lowerTitle.contains(keyword);
            }
        }
    }
}

package com.flux.services.wom;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import java.util.*;
import lombok.extern.slf4j.Slf4j;

import static com.flux.services.wom.CompetitionModels.*;

@Slf4j
public class CompetitionDataParser {
    private static final int TOP_PARTICIPANTS_COUNT = 10;

    // Parse SOTW leaderboard from WOM competition details.
    public LinkedHashMap<String, Integer> parseSotwLeaderboard(JsonObject competitionDetails) {
        LinkedHashMap<String, Integer> leaderboard = new LinkedHashMap<>();

        try {
            JsonArray participants = competitionDetails.has("participations")
                    ? competitionDetails.getAsJsonArray("participations")
                    : new JsonArray();
            List<ParticipantEntry> entries = new ArrayList<>();

            for (JsonElement element : participants) {
                JsonObject participant = element.getAsJsonObject();
                JsonObject player = participant.getAsJsonObject("player");

                String username = player != null && player.has("username")
                        ? player.get("username").getAsString()
                        : "";

                JsonObject progress = participant.has("progress")
                        ? participant.getAsJsonObject("progress")
                        : null;

                int xpGained = (progress != null && progress.has("gained"))
                        ? progress.get("gained").getAsInt()
                        : 0;


                entries.add(new ParticipantEntry(username, xpGained));
            }

            // Sort by XP descending and take top 10
            entries.stream()
                    .sorted((a, b) -> Integer.compare(b.xp, a.xp))
                    .limit(TOP_PARTICIPANTS_COUNT)
                    .forEach(entry -> leaderboard.put(entry.username, entry.xp));

        } catch (Exception e) {
            log.error("Error parsing SOTW leaderboard: " + e);
        }

        return leaderboard;
    }

    // Parses Hunt team data from competition JSON payload.
    public HuntTeamData parseHuntTeamData(JsonObject competitionDetails) {
        try {
            JsonArray participants = competitionDetails.has("participations")
                    ? competitionDetails.getAsJsonArray("participations")
                    : new JsonArray();

            // Extract team names
            TeamNames teamNames = extractTeamNames(participants);

            // Collect participants by team
            List<HuntParticipant> team1Participants = new ArrayList<>();
            List<HuntParticipant> team2Participants = new ArrayList<>();

            for (JsonElement element : participants) {
                JsonObject participant = element.getAsJsonObject();

                JsonObject player = participant.getAsJsonObject("player");
                String username = (player != null && player.has("displayName"))
                        ? player.get("displayName").getAsString()
                        : "";

                String teamName = participant.has("teamName")
                        ? participant.get("teamName").getAsString()
                        : "";

                JsonObject progress = participant.has("progress")
                        ? participant.getAsJsonObject("progress")
                        : null;

                double ehb = (progress != null && progress.has("gained"))
                        ? progress.get("gained").getAsDouble()
                        : 0.0;

                if (teamName.equals(teamNames.team1)) {
                    team1Participants.add(new HuntParticipant(username, ehb));
                } else if (teamName.equals(teamNames.team2)) {
                    team2Participants.add(new HuntParticipant(username, ehb));
                }
            }

            // Sort and get top 10 for each team
            LinkedHashMap<String, Double> team1Top10 = getTopParticipants(team1Participants);
            LinkedHashMap<String, Double> team2Top10 = getTopParticipants(team2Participants);

            // Calculate total scores
            double team1Total = team1Participants.stream().mapToDouble(p -> p.ehb).sum();
            double team2Total = team2Participants.stream().mapToDouble(p -> p.ehb).sum();

            return new HuntTeamData(
                    teamNames.team1,
                    teamNames.team2,
                    team1Top10,
                    team2Top10,
                    (int) Math.round(team1Total),
                    (int) Math.round(team2Total)
            );

        } catch (Exception e) {
            log.error("Error parsing Hunt team data: ", e);
        }

        return null;
    }


    private TeamNames extractTeamNames(JsonArray participants) {
        Set<String> teamNamesSet = new HashSet<>();

        for (JsonElement element : participants) {
            JsonObject participant = element.getAsJsonObject();
            String teamName = participant.has("teamName")
                    ? participant.get("teamName").getAsString()
                    : "";
            if (!teamName.isEmpty()) {
                teamNamesSet.add(teamName);
            }
        }

        if (teamNamesSet.size() >= 2) {
            Iterator<String> iter = teamNamesSet.iterator();
            String team1 = iter.next();
            String team2 = iter.next();
            return new TeamNames(team1, team2);
        }

        return new TeamNames("Team 1", "Team 2");
    }


    private LinkedHashMap<String, Double> getTopParticipants(List<HuntParticipant> participants) {
        LinkedHashMap<String, Double> top10 = new LinkedHashMap<>();

        participants.stream()
                .sorted((a, b) -> Double.compare(b.ehb, a.ehb))
                .limit(TOP_PARTICIPANTS_COUNT)
                .forEach(p -> top10.put(p.username, p.ehb));

        return top10;
    }

    // Helper classes
    private static class ParticipantEntry {
        final String username;
        final int xp;

        ParticipantEntry(String username, int xp) {
            this.username = username;
            this.xp = xp;
        }
    }

    private static class TeamNames {
        final String team1;
        final String team2;

        TeamNames(String team1, String team2) {
            this.team1 = team1;
            this.team2 = team2;
        }
    }
}

package com.flux;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class FluxPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FluxPlugin.class);
		RuneLite.main(args);
	}
}
