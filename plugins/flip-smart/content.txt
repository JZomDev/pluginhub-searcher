package com.flipsmart;

import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

/**
 * In-game overlay that displays all 8 Grand Exchange offer slots with real-time status
 */
public class GrandExchangeOverlay extends Overlay
{
	private static final DecimalFormat PERCENTAGE_FORMAT = new DecimalFormat("0");
	private static final DecimalFormat PRICE_FORMAT = new DecimalFormat("#,###");
	
	private static final Color COLOR_BUY = new Color(0, 128, 0);  // Dark green
	private static final Color COLOR_SELL = new Color(180, 0, 0); // Dark red
	private static final Color COLOR_COMPLETE = new Color(200, 180, 50); // Gold
	private static final Color COLOR_EMPTY = new Color(128, 128, 128); // Gray
	private static final Color COLOR_CANCELLED = new Color(200, 100, 0); // Orange
	private static final Color COLOR_BACKGROUND = new Color(62, 53, 41); // Dark brown (GE style)
	private static final Color COLOR_BORDER = new Color(0, 0, 0); // Black
	private static final Color COLOR_TEXT = new Color(255, 255, 255); // White
	private static final Color COLOR_TITLE = new Color(255, 215, 0); // Gold
	
	private static final Color COLOR_DIVIDER = new Color(90, 80, 65); // Brown divider
	private static final Color COLOR_PROGRESS_BG = new Color(40, 35, 28); // Dark progress bar background
	private static final Color COLOR_PROGRESS_BORDER = new Color(20, 18, 15); // Progress bar border
	
	private static final int PADDING = 8;
	private static final int LINE_HEIGHT = 17;
	private static final int ICON_SIZE = 32;
	private static final int PROGRESS_BAR_WIDTH = 60;
	private static final int PROGRESS_BAR_HEIGHT = 14;
	
	private final Client client;
	private final FlipSmartConfig config;
	private final ItemManager itemManager;
	
	private boolean isCollapsed = false;
	private Rectangle collapseButtonBounds = new Rectangle();
	private BufferedImage geIcon;

	@Inject
	private GrandExchangeOverlay(Client client, FlipSmartConfig config, ItemManager itemManager)
	{
		this.client = client;
		this.config = config;
		this.itemManager = itemManager;
		
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.MED);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setMovable(true);
		setResizable(false);
		
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, "GE Tracker"));
		
		// Load large coin stack icon - ItemManager can render with quantity to show stack size
		// Using a high quantity (1M) will display as the large coin pile
		AsyncBufferedImage coinsImage = itemManager.getImage(995, 1000000, false);
		if (coinsImage != null)
		{
			coinsImage.onLoaded(() -> geIcon = coinsImage);
		}
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showGEOverlay())
		{
			return null;
		}
		
		GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
		if (offers == null)
		{
			return null;
		}
		
		// Use RuneLite's font for crisp rendering
		graphics.setFont(FontManager.getRunescapeFont());
		
		// Enable proper anti-aliasing
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		graphics.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		
	// Calculate dimensions - more width for progress bars
	int textWidth = 200;
	// No extra icon column width since icons now overlay on the progress bars
	int totalWidth = textWidth + (PADDING * 2);
	
	// Draw at (0,0) - the overlay system handles positioning
	int x = 0;
	int y = 0;
	int currentY = y + PADDING + LINE_HEIGHT; // Start below top padding
	
	// If collapsed, only show the header
	if (isCollapsed)
	{
		int collapsedHeight = LINE_HEIGHT + (PADDING * 2) + 4; // Title + padding + extra spacing
		
		// Draw background
		graphics.setColor(COLOR_BACKGROUND);
		graphics.fillRect(x, y, totalWidth, collapsedHeight);
		
		// Draw border
		graphics.setColor(COLOR_BORDER);
		graphics.drawRect(x, y, totalWidth, collapsedHeight);
		graphics.drawRect(x + 1, y + 1, totalWidth - 2, collapsedHeight - 2);
		
		// Draw title
		graphics.setFont(FontManager.getRunescapeBoldFont());
		graphics.setColor(Color.BLACK);
		String title = "Grand Exchange Offers";
		FontMetrics metrics = graphics.getFontMetrics();
		int titleX = x + (totalWidth - metrics.stringWidth(title)) / 2;
		graphics.drawString(title, titleX + 1, currentY + 1);
		graphics.setColor(COLOR_TITLE);
		graphics.drawString(title, titleX, currentY);
		
		// Draw large coin stack icon button (collapsed state)
		if (geIcon != null)
		{
			int iconSize = 24; // Larger icon
			int iconX = x + PADDING - 2;
			int iconY = y + PADDING - 4;
			// Bigger click box - add padding around the icon
			int clickPadding = 4;
			collapseButtonBounds = new Rectangle(
				iconX - clickPadding, 
				iconY - clickPadding, 
				iconSize + (clickPadding * 2), 
				iconSize + (clickPadding * 2)
			);
			graphics.drawImage(geIcon, iconX, iconY, iconSize, iconSize, null);
		}
		
		return new Dimension(totalWidth, collapsedHeight);
	}
	
	// Count lines to calculate height (not collapsed)
	int lineCount = 1; // Title
		boolean hasActiveOffers = false;
		int dividerCount = 0;
		
		for (int i = 0; i < offers.length; i++)
		{
		GrandExchangeOffer offer = offers[i];
		if (offer.getState() == GrandExchangeOfferState.EMPTY)
		{
			continue; // Always hide empty slots
		}
		else
		{
			hasActiveOffers = true;
			lineCount++; // Slot line
			if (config.showGEItemNames()) lineCount++; // Item name line
			lineCount++; // Progress bar line (always present now)
			
			// Check if there's another non-empty slot for divider
			boolean needsDivider = false;
			for (int nextSlot = i + 1; nextSlot < offers.length; nextSlot++)
			{
				if (offers[nextSlot].getState() != GrandExchangeOfferState.EMPTY)
				{
					needsDivider = true;
					break;
				}
			}
			if (needsDivider)
			{
				dividerCount++;
			}
		}
		}
	
	if (!hasActiveOffers)
	{
		lineCount++; // "No offers" message
	}
		
	// Add space for dividers (-11px before + 19px after each divider = 8px total)
	int totalHeight = (lineCount * LINE_HEIGHT) + (PADDING * 2);
	totalHeight += dividerCount * 8;
	totalHeight += 4; // Add 4px padding after title
		
		// Draw background with GE-style brown
		graphics.setColor(COLOR_BACKGROUND);
		graphics.fillRect(x, y, totalWidth, totalHeight);
		
		// Draw border
		graphics.setColor(COLOR_BORDER);
		graphics.drawRect(x, y, totalWidth, totalHeight);
		graphics.drawRect(x + 1, y + 1, totalWidth - 2, totalHeight - 2); // Double border for depth
		
		// Draw title with bold font
		graphics.setFont(FontManager.getRunescapeBoldFont());
		
		// Draw title shadow
		graphics.setColor(Color.BLACK);
		String title = "Grand Exchange Offers";
		FontMetrics metrics = graphics.getFontMetrics();
		int titleX = x + (totalWidth - metrics.stringWidth(title)) / 2;
		graphics.drawString(title, titleX + 1, currentY + 1);
		
	// Draw title text
	graphics.setColor(COLOR_TITLE);
	graphics.drawString(title, titleX, currentY);
	
	// Draw large coin stack icon button when expanded
	if (geIcon != null)
	{
		int iconSize = 24; // Larger icon
		int iconX = x + PADDING - 2;
		int iconY = y + PADDING - 4;
		// Bigger click box - add padding around the icon
		int clickPadding = 4;
		collapseButtonBounds = new Rectangle(
			iconX - clickPadding, 
			iconY - clickPadding, 
			iconSize + (clickPadding * 2), 
			iconSize + (clickPadding * 2)
		);
		graphics.drawImage(geIcon, iconX, iconY, iconSize, iconSize, null);
	}
	
	currentY += LINE_HEIGHT;
	
	// Add 4px padding after title
	currentY += 4;
	
	// Reset to regular font for content
		graphics.setFont(FontManager.getRunescapeFont());
		
		// Render each slot
		for (int slot = 0; slot < offers.length; slot++)
		{
		GrandExchangeOffer offer = offers[slot];
		
		if (offer.getState() == GrandExchangeOfferState.EMPTY)
		{
			continue; // Always hide empty slots
		}
			
			// Get offer details
			GrandExchangeOfferState state = offer.getState();
			int itemId = offer.getItemId();
			int quantitySold = offer.getQuantitySold();
			int totalQuantity = offer.getTotalQuantity();
			int price = offer.getPrice();
			
			boolean isBuy = state == GrandExchangeOfferState.BUYING || 
							state == GrandExchangeOfferState.BOUGHT ||
							state == GrandExchangeOfferState.CANCELLED_BUY;
			
			double percentage = totalQuantity > 0 ? (quantitySold * 100.0) / totalQuantity : 0;
			String itemName = itemManager.getItemComposition(itemId).getName();
			
			// Determine status color based on offer state
			Color statusColor;
			
			switch (state)
			{
				case BOUGHT:
				case SOLD:
					statusColor = COLOR_COMPLETE;
					break;
				case CANCELLED_BUY:
				case CANCELLED_SELL:
					statusColor = COLOR_CANCELLED;
					break;
				case BUYING:
				case SELLING:
					statusColor = isBuy ? COLOR_BUY : COLOR_SELL;
					break;
				default:
					statusColor = COLOR_EMPTY;
			}
			
		// Draw divider BEFORE this item (except for first item)
		if (slot > 0)
		{
			// Check if previous slot was also visible
			boolean previousWasVisible = false;
			for (int prevSlot = slot - 1; prevSlot >= 0; prevSlot--)
			{
				if (offers[prevSlot].getState() != GrandExchangeOfferState.EMPTY)
				{
					previousWasVisible = true;
					break;
				}
			}
				
			if (previousWasVisible)
			{
				// Move divider up - 4px higher than before (-7 - 4 = -11)
				currentY += -11;
				
				// Draw divider line
				graphics.setColor(COLOR_DIVIDER);
				int dividerX1 = x + PADDING;
				int dividerX2 = x + textWidth + PADDING;
				graphics.drawLine(dividerX1, currentY, dividerX2, currentY);
				
				// Add space after divider to maintain 12px total spacing
				currentY += 19;
			}
			}
			
			// Line 1: Slot label only
			String slotLabel = (slot + 1) + ". " + (isBuy ? "Buy" : "Sell");
			// Draw shadow
			graphics.setColor(Color.BLACK);
			graphics.drawString(slotLabel, x + PADDING + 1, currentY + 1);
			// Draw main text
			graphics.setColor(isBuy ? COLOR_BUY : COLOR_SELL);
			graphics.drawString(slotLabel, x + PADDING, currentY);
			currentY += LINE_HEIGHT;
			
			// Line 2: Item name with icon on the right
			if (config.showGEItemNames())
			{
				// Draw shadow
				graphics.setColor(Color.BLACK);
				graphics.drawString(itemName, x + PADDING + 1, currentY + 1);
				// Draw main text
				graphics.setColor(COLOR_TEXT);
				graphics.drawString(itemName, x + PADDING, currentY);
				
				currentY += LINE_HEIGHT;
			}
			
			// Line 3: Details/Progress bar line
			// Always show details with price info
			String detailText = quantitySold + "/" + totalQuantity + " @ " + PRICE_FORMAT.format(price) + " gp";
			// Draw shadow
			graphics.setColor(Color.BLACK);
			graphics.drawString(detailText, x + PADDING + 1, currentY + 1);
			// Draw main text
			graphics.setColor(COLOR_TEXT);
			graphics.drawString(detailText, x + PADDING, currentY);
	
	// Always draw progress bar on this line (12px more spacing total: -10 changed to +2)
	int progressBarX = x + textWidth - PROGRESS_BAR_WIDTH + PADDING + 2;
	int progressBarY = currentY - PROGRESS_BAR_HEIGHT + 2;
			
			// Progress bar background
			graphics.setColor(COLOR_PROGRESS_BG);
			graphics.fillRect(progressBarX, progressBarY, PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT);
			
			// Progress bar border
			graphics.setColor(COLOR_PROGRESS_BORDER);
			graphics.drawRect(progressBarX, progressBarY, PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT);
			
			// Progress fill
			int fillWidth = (int) (PROGRESS_BAR_WIDTH * (percentage / 100.0));
			graphics.setColor(statusColor);
			graphics.fillRect(progressBarX + 1, progressBarY + 1, fillWidth - 1, PROGRESS_BAR_HEIGHT - 2);
			
			// Progress text centered with shadow
			String progressText = PERCENTAGE_FORMAT.format(percentage) + "%";
			
			// Use RuneLite's small font for crisp rendering
			Font originalFont = graphics.getFont();
			graphics.setFont(FontManager.getRunescapeSmallFont());
			
			FontMetrics fm = graphics.getFontMetrics();
			int progressTextWidth = fm.stringWidth(progressText);
			int textX = progressBarX + (PROGRESS_BAR_WIDTH - progressTextWidth) / 2;
			int textY = progressBarY + PROGRESS_BAR_HEIGHT - 2; // Adjusted Y position for small font
			
			graphics.setColor(Color.BLACK);
			graphics.drawString(progressText, textX + 1, textY + 1);
			graphics.setColor(Color.WHITE);
			graphics.drawString(progressText, textX, textY);
			
			// Restore original font
			graphics.setFont(originalFont);
			
			// Draw icon stacked on top of progress bar
			if (config.showGEItemIcons())
			{
				AsyncBufferedImage itemImage = itemManager.getImage(itemId);
				if (itemImage != null)
				{
					BufferedImage icon = itemImage;
					if (icon.getWidth() > 0)
					{
					// Center the icon horizontally on the progress bar, shifted 24px up (36 - 12)
					int iconX = progressBarX + (PROGRESS_BAR_WIDTH - ICON_SIZE) / 2;
					int iconY = progressBarY - ICON_SIZE / 2 + PROGRESS_BAR_HEIGHT / 2 - 24; // Shifted 24px up
					graphics.drawImage(icon, iconX, iconY, ICON_SIZE, ICON_SIZE, null);
					}
				}
			}
			
			currentY += LINE_HEIGHT;
		}
	
	// No offers message
	if (!hasActiveOffers)
	{
		graphics.setColor(COLOR_EMPTY);
		drawCenteredString(graphics, "No offers", x, currentY, totalWidth);
	}
		
		// Return dimensions - overlay system uses this for the bounds/hit box
		return new Dimension(totalWidth, totalHeight);
	}
	
	private void drawCenteredString(Graphics2D g, String text, int x, int y, int width)
	{
		FontMetrics metrics = g.getFontMetrics();
		int textX = x + (width - metrics.stringWidth(text)) / 2;
		g.drawString(text, textX, y);
	}
	
	public void toggleCollapse()
	{
		isCollapsed = !isCollapsed;
	}
	
	public boolean isCollapsed()
	{
		return isCollapsed;
	}
	
	public Rectangle getCollapseButtonBounds()
	{
		return collapseButtonBounds;
	}
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

@Data
public class FlipAnalysis
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	private boolean members;

	@SerializedName("buy_limit")
	private Integer buyLimit;

	@SerializedName("current_prices")
	private CurrentPrices currentPrices;

	private Liquidity liquidity;
	private Risk risk;
	private Efficiency efficiency;

	@SerializedName("historical_data")
	private HistoricalData historicalData;

	@Data
	public static class CurrentPrices
	{
		private Integer high;
		private Integer low;

		@SerializedName("gross_margin")
		private Integer grossMargin;

		@SerializedName("ge_tax")
		private Integer geTax;

		@SerializedName("net_margin")
		private Integer netMargin;

		@SerializedName("roi_percent")
		private Double roiPercent;
	}

	@Data
	public static class Liquidity
	{
		private Double score;
		private String rating;

		@SerializedName("buys_per_hour")
		private Double buysPerHour;

		@SerializedName("sells_per_hour")
		private Double sellsPerHour;

		@SerializedName("total_volume_per_hour")
		private Double totalVolumePerHour;
	}

	@Data
	public static class Risk
	{
		private Double score;
		private String rating;
	}

	@Data
	public static class Efficiency
	{
		private Double score;
		private String rating;
		private String recommendation;
	}

	@Data
	public static class HistoricalData
	{
		private String timeframe;

		@SerializedName("data_points")
		private Integer dataPoints;

		@SerializedName("avg_price")
		private Integer avgPrice;

		private Integer volatility;
	}

	/**
	 * Check if this item is a good flip based on efficiency score
	 */
	public boolean isGoodFlip(int minEfficiencyScore)
	{
		return efficiency != null &&
			efficiency.getScore() != null &&
			efficiency.getScore() >= minEfficiencyScore;
	}

	/**
	 * Check if the item has positive net margin
	 */
	public boolean hasPositiveMargin()
	{
		return currentPrices != null &&
			currentPrices.getNetMargin() != null &&
			currentPrices.getNetMargin() > 0;
	}
}


package com.flipsmart;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.AsyncBufferedImage;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.List;

@Slf4j
public class FlipFinderPanel extends PluginPanel
{
	// Constants for duplicated literals
	private static final String FONT_ARIAL = "Arial";
	private static final String ERROR_PREFIX = "Error: ";
	private static final String FORMAT_QTY = "Qty: %d";
	private static final String FORMAT_SELL = "Sell: %s";
	private static final String FORMAT_ROI = "ROI: %.1f%%";

	private final transient FlipSmartConfig config;
	private final transient FlipSmartApiClient apiClient;
	private final transient ItemManager itemManager;
	private final transient ConfigManager configManager;
	private final JPanel recommendedListContainer = new JPanel();
	private final JPanel activeFlipsListContainer = new JPanel();
	private final JPanel completedFlipsListContainer = new JPanel();
	private final JLabel statusLabel = new JLabel("Loading...");
	private final JButton refreshButton = new JButton("Refresh");
	private final JComboBox<FlipSmartConfig.FlipStyle> flipStyleDropdown;
	private final List<FlipRecommendation> currentRecommendations = new ArrayList<>();
	private final List<ActiveFlip> currentActiveFlips = new ArrayList<>();
	private final List<CompletedFlip> currentCompletedFlips = new ArrayList<>();
	private final JTabbedPane tabbedPane = new JTabbedPane();
	private final transient FlipSmartPlugin plugin;  // Reference to plugin to store recommended prices
	
	// Scroll panes for preserving scroll position during refresh
	private JScrollPane recommendedScrollPane;
	private JScrollPane activeFlipsScrollPane;
	private JScrollPane completedFlipsScrollPane;

	// Login panel components
	private JPanel loginPanel;
	private JPanel mainPanel;
	private JTextField emailField;
	private JPasswordField passwordField;
	private JLabel loginStatusLabel;
	private JButton loginButton;
	private JButton signupButton;
	private boolean isAuthenticated = false;

	public FlipFinderPanel(FlipSmartConfig config, FlipSmartApiClient apiClient, ItemManager itemManager, FlipSmartPlugin plugin, ConfigManager configManager)
	{
		super(false);
		this.config = config;
		this.apiClient = apiClient;
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.configManager = configManager;

		// Initialize flip style dropdown so it's available for both panels
		flipStyleDropdown = new JComboBox<>(FlipSmartConfig.FlipStyle.values());
		flipStyleDropdown.setFocusable(false);
		flipStyleDropdown.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		flipStyleDropdown.setForeground(Color.WHITE);
		flipStyleDropdown.addActionListener(e -> {
			// Refresh recommendations when flip style changes
			if (isAuthenticated)
			{
				refresh();
			}
		});

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Build both panels
		buildLoginPanel();
		buildMainPanel();

		// Start with login panel, then check authentication
		add(loginPanel, BorderLayout.CENTER);
		
		// Check if already authenticated and switch to main panel if so
		checkAuthenticationAndShow();
	}

	/**
	 * Build the login/signup panel
	 */
	private void buildLoginPanel()
	{
		loginPanel = new JPanel();
		loginPanel.setLayout(new BorderLayout());
		loginPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Center content panel
		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentPanel.setBorder(new EmptyBorder(40, 20, 40, 20));

		// Title
		JLabel titleLabel = new JLabel("Flip Smart");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 24));
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Subtitle
		JLabel subtitleLabel = new JLabel("Sign in to start flipping");
		subtitleLabel.setForeground(Color.LIGHT_GRAY);
		subtitleLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 14));
		subtitleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Email field
		JLabel emailLabel = new JLabel("Email");
		emailLabel.setForeground(Color.LIGHT_GRAY);
		emailLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));
		emailLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		emailField = new JTextField(20);
		emailField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
		emailField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		emailField.setForeground(Color.WHITE);
		emailField.setCaretColor(Color.WHITE);
		emailField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 10, 5, 10)
		));

		// Password field
		JLabel passwordLabel = new JLabel("Password");
		passwordLabel.setForeground(Color.LIGHT_GRAY);
		passwordLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));
		passwordLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		passwordField = new JPasswordField(20);
		passwordField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
		passwordField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		passwordField.setForeground(Color.WHITE);
		passwordField.setCaretColor(Color.WHITE);
		passwordField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 10, 5, 10)
		));

		// Status label for messages
		loginStatusLabel = new JLabel(" ");
		loginStatusLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));
		loginStatusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		loginStatusLabel.setForeground(Color.LIGHT_GRAY);

		// Buttons panel
		JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 10, 0));
		buttonsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));

		// Sign Up button
		signupButton = new JButton("Sign Up");
		signupButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		signupButton.setForeground(Color.WHITE);
		signupButton.setFocusPainted(false);
		signupButton.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE),
			BorderFactory.createEmptyBorder(8, 15, 8, 15)
		));
		signupButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		signupButton.addActionListener(e -> handleSignup());

		// Login button
		loginButton = new JButton("Login");
		loginButton.setBackground(ColorScheme.BRAND_ORANGE);
		loginButton.setForeground(Color.WHITE);
		loginButton.setFocusPainted(false);
		loginButton.setBorder(BorderFactory.createEmptyBorder(8, 15, 8, 15));
		loginButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		loginButton.addActionListener(e -> handleLogin());

		buttonsPanel.add(signupButton);
		buttonsPanel.add(loginButton);

		// Add components with spacing
		contentPanel.add(titleLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(subtitleLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 30)));
		contentPanel.add(emailLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(emailField);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(passwordLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(passwordField);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 20)));
		contentPanel.add(buttonsPanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(loginStatusLabel);

		// Center the content vertically
		loginPanel.add(contentPanel, BorderLayout.CENTER);
	}

	/**
	 * Build the main flip finder panel
	 */
	private void buildMainPanel()
	{
		mainPanel = new JPanel(new BorderLayout());
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Header panel
		JPanel headerPanel = new JPanel(new BorderLayout());
		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel titleLabel = new JLabel("Flip Finder");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 16));

		// Right side buttons panel (logout + refresh)
		JPanel rightButtonsPanel = new JPanel(new FlowLayout(FlowLayout.RIGHT, 5, 0));
		rightButtonsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Logout button
		JButton logoutButton = new JButton("Logout");
		logoutButton.setFocusable(false);
		logoutButton.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));
		logoutButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		logoutButton.setForeground(Color.LIGHT_GRAY);
		logoutButton.setBorder(BorderFactory.createEmptyBorder(3, 8, 3, 8));
		logoutButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		logoutButton.addActionListener(e -> handleLogout());

		refreshButton.setFocusable(false);
		refreshButton.addActionListener(e -> refresh());

		rightButtonsPanel.add(logoutButton);
		rightButtonsPanel.add(refreshButton);

		headerPanel.add(titleLabel, BorderLayout.WEST);
		headerPanel.add(rightButtonsPanel, BorderLayout.EAST);

		// Controls panel (flip style dropdown)
		JPanel controlsPanel = new JPanel(new BorderLayout());
		controlsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		controlsPanel.setBorder(new EmptyBorder(5, 10, 5, 10));

		JLabel flipStyleLabel = new JLabel("Style: ");
		flipStyleLabel.setForeground(Color.LIGHT_GRAY);
		flipStyleLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));

		// Custom renderer for better appearance
		flipStyleDropdown.setRenderer(new DefaultListCellRenderer() {
			@Override
			public Component getListCellRendererComponent(JList<?> list, Object value, int index,
														  boolean isSelected, boolean cellHasFocus) {
				Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
				if (c instanceof JLabel && value instanceof FlipSmartConfig.FlipStyle) {
					FlipSmartConfig.FlipStyle style = (FlipSmartConfig.FlipStyle) value;
					((JLabel) c).setText(style.name().charAt(0) + style.name().substring(1).toLowerCase());
				}
				if (isSelected) {
					c.setBackground(ColorScheme.BRAND_ORANGE);
				} else {
					c.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				}
				c.setForeground(Color.WHITE);
				return c;
			}
		});

		JPanel dropdownWrapper = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		dropdownWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		dropdownWrapper.add(flipStyleLabel);
		dropdownWrapper.add(flipStyleDropdown);

		controlsPanel.add(dropdownWrapper, BorderLayout.WEST);

		// Status panel
		JPanel statusPanel = new JPanel(new BorderLayout());
		statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statusPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
		statusLabel.setForeground(Color.LIGHT_GRAY);
		statusLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));
		statusPanel.add(statusLabel, BorderLayout.CENTER);

		// Combine controls and status into top panel
		JPanel topPanel = new JPanel();
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		topPanel.add(headerPanel);
		topPanel.add(controlsPanel);
		topPanel.add(statusPanel);

		// Recommended flips list container
		recommendedListContainer.setLayout(new BoxLayout(recommendedListContainer, BoxLayout.Y_AXIS));
		recommendedListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		recommendedScrollPane = new JScrollPane(recommendedListContainer);
		recommendedScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		recommendedScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		recommendedScrollPane.setBorder(BorderFactory.createEmptyBorder());
		recommendedScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		recommendedScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);

		// Active flips list container
		activeFlipsListContainer.setLayout(new BoxLayout(activeFlipsListContainer, BoxLayout.Y_AXIS));
		activeFlipsListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		activeFlipsScrollPane = new JScrollPane(activeFlipsListContainer);
		activeFlipsScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		activeFlipsScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		activeFlipsScrollPane.setBorder(BorderFactory.createEmptyBorder());
		activeFlipsScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		activeFlipsScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);

		// Completed flips list container
		completedFlipsListContainer.setLayout(new BoxLayout(completedFlipsListContainer, BoxLayout.Y_AXIS));
		completedFlipsListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		completedFlipsScrollPane = new JScrollPane(completedFlipsListContainer);
		completedFlipsScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		completedFlipsScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		completedFlipsScrollPane.setBorder(BorderFactory.createEmptyBorder());
		completedFlipsScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		completedFlipsScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);

		// Create tabbed pane with custom UI for full-width tabs
		tabbedPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		tabbedPane.setForeground(Color.WHITE);
		tabbedPane.setTabPlacement(SwingConstants.TOP);
		
		// Custom UI to make tabs fill the full width
		tabbedPane.setUI(new javax.swing.plaf.basic.BasicTabbedPaneUI() {
			@Override
			protected int calculateTabWidth(int tabPlacement, int tabIndex, java.awt.FontMetrics metrics) {
				// Calculate equal width for all tabs
				int totalWidth = tabbedPane.getWidth();
				int tabCount = tabbedPane.getTabCount();
				if (tabCount > 0 && totalWidth > 0) {
					return totalWidth / tabCount;
				}
				return super.calculateTabWidth(tabPlacement, tabIndex, metrics);
			}
			
			@Override
			protected void paintTabBackground(java.awt.Graphics g, int tabPlacement, int tabIndex,
											  int x, int y, int w, int h, boolean isSelected) {
				// Paint background for tabs
				g.setColor(isSelected ? ColorScheme.DARKER_GRAY_COLOR : ColorScheme.DARK_GRAY_COLOR);
				g.fillRect(x, y, w, h);
			}
			
			@Override
			protected void paintTabBorder(java.awt.Graphics g, int tabPlacement, int tabIndex,
										  int x, int y, int w, int h, boolean isSelected) {
				// Paint border/underline for selected tab
				if (isSelected) {
					g.setColor(ColorScheme.BRAND_ORANGE);
					g.fillRect(x, y + h - 3, w, 3);
				}
			}
			
			@Override
			protected void paintContentBorder(java.awt.Graphics g, int tabPlacement, int selectedIndex) {
				// Don't paint content border
			}
		});
		
		tabbedPane.addTab("Recommended", recommendedScrollPane);
		tabbedPane.addTab("Active Flips", activeFlipsScrollPane);
		tabbedPane.addTab("Completed", completedFlipsScrollPane);
		
		// Add listener to update status when switching tabs
		tabbedPane.addChangeListener(e ->
		{
			int selectedIndex = tabbedPane.getSelectedIndex();
			if (selectedIndex == 1 && !currentActiveFlips.isEmpty())
			{
				// Switched to Active Flips tab, update status
				int itemCount = currentActiveFlips.size();
				int invested = currentActiveFlips.stream()
					.mapToInt(ActiveFlip::getTotalInvested)
					.sum();
				statusLabel.setText(String.format("%d active %s | %s invested",
					itemCount,
					itemCount == 1 ? "flip" : "flips",
					formatGP(invested)));
			}
			else if (selectedIndex == 2 && !currentCompletedFlips.isEmpty())
			{
				// Switched to Completed Flips tab, update status
				int flipCount = currentCompletedFlips.size();
				int totalProfit = currentCompletedFlips.stream()
					.mapToInt(CompletedFlip::getNetProfit)
					.sum();
				statusLabel.setText(String.format("%d completed | %s profit",
					flipCount,
					formatGP(totalProfit)));
			}
			else if (selectedIndex == 0 && !currentRecommendations.isEmpty())
			{
				// Switched back to Recommended tab, restore original status
				FlipFinderResponse response = new FlipFinderResponse();
				response.setRecommendations(currentRecommendations);
				updateStatusLabel(response);
			}
		});

		mainPanel.add(topPanel, BorderLayout.NORTH);
		mainPanel.add(tabbedPane, BorderLayout.CENTER);
	}

	/**
	 * Check if already authenticated and show appropriate panel
	 */
	private void checkAuthenticationAndShow()
	{
		// Try to authenticate silently with saved credentials
		String email = config.email();
		String password = config.password();
		
		if (email != null && !email.isEmpty() && password != null && !password.isEmpty())
		{
			// Pre-fill the email field
			emailField.setText(email);
			
			// Try to authenticate in background
			java.util.concurrent.CompletableFuture.runAsync(() -> {
				FlipSmartApiClient.AuthResult result = apiClient.login(email, password);
				
				SwingUtilities.invokeLater(() -> {
					if (result.success)
					{
						showMainPanel();
					}
					else
					{
						// Stay on login panel, show message
						loginStatusLabel.setText("Please login to continue");
						loginStatusLabel.setForeground(Color.LIGHT_GRAY);
					}
				});
			});
		}
	}

	/**
	 * Handle login button click
	 */
	private void handleLogin()
	{
		String email = emailField.getText().trim();
		String password = new String(passwordField.getPassword());
		
		if (email.isEmpty() || password.isEmpty())
		{
			showLoginStatus("Please enter email and password", false);
			return;
		}
		
		setLoginButtonsEnabled(false);
		showLoginStatus("Logging in...", true);
		
		java.util.concurrent.CompletableFuture.runAsync(() -> {
			FlipSmartApiClient.AuthResult result = apiClient.login(email, password);
			
			SwingUtilities.invokeLater(() -> {
				setLoginButtonsEnabled(true);
				
				if (result.success)
				{
					// Save credentials for next session
					saveCredentials(email, password);
					
					showLoginStatus(result.message, true);
					// Small delay to show success message
					Timer timer = new Timer(500, e -> showMainPanel());
					timer.setRepeats(false);
					timer.start();
				}
				else
				{
					showLoginStatus(result.message, false);
				}
			});
		});
	}

	/**
	 * Handle signup button click
	 */
	private void handleSignup()
	{
		String email = emailField.getText().trim();
		String password = new String(passwordField.getPassword());
		
		if (email.isEmpty() || password.isEmpty())
		{
			showLoginStatus("Please enter email and password", false);
			return;
		}
		
		setLoginButtonsEnabled(false);
		showLoginStatus("Creating account...", true);
		
		java.util.concurrent.CompletableFuture.runAsync(() -> {
			FlipSmartApiClient.AuthResult result = apiClient.signup(email, password);
			
			SwingUtilities.invokeLater(() -> {
				setLoginButtonsEnabled(true);
				
				if (result.success)
				{
					// Save credentials for next session
					saveCredentials(email, password);
					
					showLoginStatus(result.message, true);
					// Small delay to show success message
					Timer timer = new Timer(500, e -> showMainPanel());
					timer.setRepeats(false);
					timer.start();
				}
				else
				{
					showLoginStatus(result.message, false);
				}
			});
		});
	}

	/**
	 * Save credentials for next session
	 */
	private void saveCredentials(String email, String password)
	{
		configManager.setConfiguration("flipsmart", "email", email);
		configManager.setConfiguration("flipsmart", "password", password);
	}

	/**
	 * Show status message on login panel
	 */
	private void showLoginStatus(String message, boolean success)
	{
		loginStatusLabel.setText(message);
		loginStatusLabel.setForeground(success ? new Color(100, 255, 100) : new Color(255, 100, 100));
	}

	/**
	 * Enable/disable login buttons during authentication
	 */
	private void setLoginButtonsEnabled(boolean enabled)
	{
		loginButton.setEnabled(enabled);
		signupButton.setEnabled(enabled);
		emailField.setEnabled(enabled);
		passwordField.setEnabled(enabled);
	}

	/**
	 * Switch from login panel to main panel
	 */
	private void showMainPanel()
	{
		isAuthenticated = true;
		removeAll();
		add(mainPanel, BorderLayout.CENTER);
		revalidate();
		repaint();
		
		// Load data
		refresh();
	}

	/**
	 * Switch from main panel to login panel (e.g., on auth error)
	 */
	public void showLoginPanel()
	{
		isAuthenticated = false;
		removeAll();
		add(loginPanel, BorderLayout.CENTER);
		revalidate();
		repaint();
	}

	/**
	 * Handle logout button click
	 */
	private void handleLogout()
	{
		// Clear API client authentication
		apiClient.clearAuth();
		
		// Clear password field but keep email
		passwordField.setText("");
		
		// Reset status
		loginStatusLabel.setText("Logged out successfully");
		loginStatusLabel.setForeground(Color.LIGHT_GRAY);
		
		// Show login panel
		showLoginPanel();
	}

	/**
	 * Refresh flip recommendations, active flips, and completed flips
	 */
	public void refresh()
	{
		refreshRecommendations();
		refreshActiveFlips();
		refreshCompletedFlips();
	}

	/**
	 * Refresh recommended flips
	 */
	private void refreshRecommendations()
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(recommendedScrollPane);
		
		statusLabel.setText("Loading recommendations...");
		refreshButton.setEnabled(false);
		recommendedListContainer.removeAll();
		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();

		// Fetch recommendations asynchronously
		Integer cashStack = getCashStack();
		// Use the selected flip style from dropdown instead of config
		FlipSmartConfig.FlipStyle selectedStyle = (FlipSmartConfig.FlipStyle) flipStyleDropdown.getSelectedItem();
		String flipStyle = selectedStyle != null ? selectedStyle.getApiValue() : config.flipStyle().getApiValue();
		int limit = Math.max(1, Math.min(50, config.flipFinderLimit()));

		apiClient.getFlipRecommendationsAsync(cashStack, flipStyle, limit).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				refreshButton.setEnabled(true);

				if (response == null)
				{
					showErrorInRecommended("Failed to fetch recommendations. Check your API settings.");
					restoreScrollPosition(recommendedScrollPane, scrollPos);
					return;
				}

				if (response.getRecommendations() == null || response.getRecommendations().isEmpty())
				{
					showErrorInRecommended("No flip recommendations found matching your criteria.");
					restoreScrollPosition(recommendedScrollPane, scrollPos);
					return;
				}

				currentRecommendations.clear();
				currentRecommendations.addAll(response.getRecommendations());

				// Store recommended sell prices in the plugin for transaction tracking
				for (FlipRecommendation rec : response.getRecommendations())
				{
					plugin.setRecommendedSellPrice(rec.getItemId(), rec.getRecommendedSellPrice());
				}

				updateStatusLabel(response);
				populateRecommendations(response.getRecommendations());
				restoreScrollPosition(recommendedScrollPane, scrollPos);
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				refreshButton.setEnabled(true);
				showErrorInRecommended(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(recommendedScrollPane, scrollPos);
			});
			return null;
		});
	}

	/**
	 * Refresh active flips
	 */
	public void refreshActiveFlips()
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(activeFlipsScrollPane);
		
		activeFlipsListContainer.removeAll();
		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();

		// Pass current RSN to filter data for the logged-in account
		String rsn = plugin.getCurrentRsnSafe().orElse(null);
		apiClient.getActiveFlipsAsync(rsn).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				if (response == null)
				{
					showErrorInActiveFlips("Failed to fetch active flips. Check your API settings.");
					restoreScrollPosition(activeFlipsScrollPane, scrollPos);
					return;
				}

				currentActiveFlips.clear();
				if (response.getActiveFlips() != null)
				{
					// Filter active flips to only show items that are currently being tracked:
					// 1. Items currently in GE buy slots (pending or filled)
					// 2. Items currently in GE sell slots (waiting to fully sell)
					// 3. Items collected from GE in this session (waiting to be sold)
					// This prevents showing old stale data while keeping active items visible
					java.util.Set<Integer> activeItemIds = plugin.getActiveFlipItemIds();
					log.debug("Active flip filter: {} tracked item IDs, {} flips from backend",
						activeItemIds.size(), response.getActiveFlips().size());
					for (ActiveFlip flip : response.getActiveFlips())
					{
						if (activeItemIds.contains(flip.getItemId()))
						{
							currentActiveFlips.add(flip);
							log.debug("Including active flip: {} (ID {})", flip.getItemName(), flip.getItemId());
						}
						else
						{
							log.debug("Filtering out active flip: {} (ID {}) - not in tracked items",
								flip.getItemName(), flip.getItemId());
						}
					}
				}

				// Get pending orders from plugin
				java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders = plugin.getPendingBuyOrders();

				if (currentActiveFlips.isEmpty() && pendingOrders.isEmpty())
				{
					showNoActiveFlips();
					restoreScrollPosition(activeFlipsScrollPane, scrollPos);
					return;
				}

				// Update status label with active flips info
				if (!currentActiveFlips.isEmpty())
				{
					// Update with filtered count
					int itemCount = currentActiveFlips.size();
					int invested = currentActiveFlips.stream()
						.mapToInt(ActiveFlip::getTotalInvested)
						.sum();
					if (tabbedPane.getSelectedIndex() == 1)
					{
						statusLabel.setText(String.format("%d active %s | %s invested",
							itemCount,
							itemCount == 1 ? "flip" : "flips",
							formatGP(invested)));
					}
				}
				else if (!pendingOrders.isEmpty())
				{
					statusLabel.setText(String.format("%d pending %s",
						pendingOrders.size(),
						pendingOrders.size() == 1 ? "order" : "orders"));
				}

				// Display both active flips and pending orders
				displayActiveFlipsAndPending(currentActiveFlips, pendingOrders);
				restoreScrollPosition(activeFlipsScrollPane, scrollPos);
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				showErrorInActiveFlips(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(activeFlipsScrollPane, scrollPos);
			});
			return null;
		});
	}
	
	/**
	 * Update pending orders display (called when GE offers change)
	 * @param pendingOrders the list of pending orders (used to trigger refresh)
	 */
	@SuppressWarnings("unused")
	public void updatePendingOrders(java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders)
	{
		// Only update if we're on the Active Flips tab
		if (tabbedPane.getSelectedIndex() == 1)
		{
			refreshActiveFlips();
		}
	}

	/**
	 * Refresh completed flips
	 */
	private void refreshCompletedFlips()
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(completedFlipsScrollPane);
		
		completedFlipsListContainer.removeAll();
		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();

		// Fetch last 50 completed flips for current RSN
		String rsn = plugin.getCurrentRsnSafe().orElse(null);
		apiClient.getCompletedFlipsAsync(50, rsn).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				if (response == null)
				{
					showErrorInCompletedFlips("Failed to fetch completed flips. Check your API settings.");
					restoreScrollPosition(completedFlipsScrollPane, scrollPos);
					return;
				}

				currentCompletedFlips.clear();
				if (response.getFlips() != null)
				{
					currentCompletedFlips.addAll(response.getFlips());
				}

				if (currentCompletedFlips.isEmpty())
				{
					showNoCompletedFlips();
					restoreScrollPosition(completedFlipsScrollPane, scrollPos);
					return;
				}

				// Update status if on completed flips tab
				if (tabbedPane.getSelectedIndex() == 2)
				{
					int totalProfit = currentCompletedFlips.stream()
						.mapToInt(CompletedFlip::getNetProfit)
						.sum();
					statusLabel.setText(String.format("%d completed | %s profit",
						currentCompletedFlips.size(),
						formatGP(totalProfit)));
				}

				populateCompletedFlips(currentCompletedFlips);
				restoreScrollPosition(completedFlipsScrollPane, scrollPos);
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				showErrorInCompletedFlips(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(completedFlipsScrollPane, scrollPos);
			});
			return null;
		});
	}

	/**
	 * Show error message in completed flips tab
	 */
	private void showErrorInCompletedFlips(String message)
	{
		completedFlipsListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Completed Flips", message);
		completedFlipsListContainer.add(errorPanel);

		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}

	/**
	 * Show message when there are no completed flips
	 */
	private void showNoCompletedFlips()
	{
		completedFlipsListContainer.removeAll();

		JPanel emptyPanel = new JPanel();
		emptyPanel.setLayout(new BoxLayout(emptyPanel, BoxLayout.Y_AXIS));
		emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		emptyPanel.setBorder(new EmptyBorder(60, 20, 60, 20));

		JLabel titleLabel = new JLabel("No completed flips");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 16));
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		JLabel instructionLabel = new JLabel("<html><center>Complete your first flip to see it here!<br>Buy and sell items to track your profits</center></html>");
		instructionLabel.setForeground(new Color(180, 180, 180));
		instructionLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 13));
		instructionLabel.setHorizontalAlignment(SwingConstants.CENTER);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		emptyPanel.add(titleLabel);
		emptyPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		emptyPanel.add(instructionLabel);

		completedFlipsListContainer.add(emptyPanel);

		statusLabel.setText("0 completed flips");

		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}

	/**
	 * Populate the completed flips list
	 */
	private void populateCompletedFlips(java.util.List<CompletedFlip> flips)
	{
		completedFlipsListContainer.removeAll();

		for (CompletedFlip flip : flips)
		{
			completedFlipsListContainer.add(createCompletedFlipPanel(flip));
			completedFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
		}

		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}
	
	/**
	 * Display both active flips and pending orders.
	 * Pending orders (items still in GE buy slots) take priority over active flips
	 * to avoid showing duplicates when an item is partially filled.
	 */
	private void displayActiveFlipsAndPending(java.util.List<ActiveFlip> activeFlips, java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders)
	{
		activeFlipsListContainer.removeAll();
		
		// Build a map of pending orders by itemId for smart deduplication
		// Key: itemId, Value: list of pending orders for that item
		java.util.Map<Integer, java.util.List<FlipSmartPlugin.PendingOrder>> pendingByItemId = new java.util.HashMap<>();
		for (FlipSmartPlugin.PendingOrder pending : pendingOrders)
		{
			pendingByItemId.computeIfAbsent(pending.itemId, k -> new java.util.ArrayList<>()).add(pending);
		}
		
		// First show pending orders (items currently in GE buy slots)
		if (!pendingOrders.isEmpty())
		{
			for (FlipSmartPlugin.PendingOrder pending : pendingOrders)
			{
				activeFlipsListContainer.add(createPendingOrderPanel(pending));
				activeFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
			}
		}
		
		// Then show active flips (items collected, waiting to sell)
		// Only skip an active flip if there's a pending order that appears to be the SAME transaction
		// (matching itemId AND the pending order's filled quantity accounts for all the active flip quantity)
		for (ActiveFlip flip : activeFlips)
		{
			java.util.List<FlipSmartPlugin.PendingOrder> matchingPending = pendingByItemId.get(flip.getItemId());
			
			boolean shouldShow = true;
			if (matchingPending != null)
			{
				// Check if any pending order fully accounts for this active flip
				// This happens when the pending order is the source of the active flip data
				for (FlipSmartPlugin.PendingOrder pending : matchingPending)
				{
					// If the pending order's filled quantity matches the active flip's remaining quantity
					// AND the prices are similar, it's likely the same transaction - skip to avoid duplicate
					if (pending.quantityFilled == flip.getTotalQuantity() && 
						Math.abs(pending.pricePerItem - flip.getAverageBuyPrice()) <= 1)
					{
						shouldShow = false;
						log.debug("Skipping active flip {} - matches pending order in slot {} (qty: {}, price: {})",
							flip.getItemName(), pending.slot, pending.quantityFilled, pending.pricePerItem);
						break;
					}
				}
			}
			
			if (shouldShow)
			{
				activeFlipsListContainer.add(createActiveFlipPanel(flip));
				activeFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
			}
		}

		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Get the player's current cash stack from inventory
	 * Returns null if not available
	 * Can be overridden by subclasses to provide actual cash stack
	 */
	protected Integer getCashStack()
	{
		// This will be overridden by the plugin
		// For now, return null to get all recommendations
		return null;
	}

	/**
	 * Update the status label with response info
	 */
	private void updateStatusLabel(FlipFinderResponse response)
	{
		String flipStyleText = config.flipStyle().toString();
		int count = response.getRecommendations().size();
		
		if (response.getCashStack() != null)
		{
			statusLabel.setText(String.format("%s | %d flips | Cash: %s",
				flipStyleText,
				count,
				formatGP(response.getCashStack())));
		}
		else
		{
			statusLabel.setText(String.format("%s | %d flips", flipStyleText, count));
		}
	}

	/**
	 * Show an error message in recommended tab
	 */
	private void showErrorInRecommended(String message)
	{
		statusLabel.setText("Error");
		recommendedListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Flip Finder", message);
		recommendedListContainer.add(errorPanel);

		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();
	}

	/**
	 * Show an error message in active flips tab
	 */
	private void showErrorInActiveFlips(String message)
	{
		activeFlipsListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Active Flips", message);
		activeFlipsListContainer.add(errorPanel);

		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Show message when there are no active flips
	 */
	private void showNoActiveFlips()
	{
		activeFlipsListContainer.removeAll();

		JPanel emptyPanel = new JPanel();
		emptyPanel.setLayout(new BoxLayout(emptyPanel, BoxLayout.Y_AXIS));
		emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		emptyPanel.setBorder(new EmptyBorder(60, 20, 60, 20));

		// Main message
		JLabel titleLabel = new JLabel("No active flips");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 16));
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Instructions
		JLabel instructionLabel = new JLabel("<html><center>Buy items from the Recommended tab<br>to start tracking your flips</center></html>");
		instructionLabel.setForeground(new Color(180, 180, 180));
		instructionLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 13));
		instructionLabel.setHorizontalAlignment(SwingConstants.CENTER);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		emptyPanel.add(titleLabel);
		emptyPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		emptyPanel.add(instructionLabel);

		activeFlipsListContainer.add(emptyPanel);

		// Update status label
		statusLabel.setText("0 active flips");

		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Populate the list with recommendations
	 */
	private void populateRecommendations(List<FlipRecommendation> recommendations)
	{
		recommendedListContainer.removeAll();

		for (FlipRecommendation rec : recommendations)
		{
			recommendedListContainer.add(createRecommendationPanel(rec));
			recommendedListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
		}

		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();
	}

	/**
	 * Create a panel for a single recommendation
	 */
	private JPanel createRecommendationPanel(FlipRecommendation rec)
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(8, 10, 8, 10));
		panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		// Ensure panel doesn't exceed container width
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));

		// Item name panel
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Item icon and name
		JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		namePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Get item image
		AsyncBufferedImage itemImage = itemManager.getImage(rec.getItemId());
		JLabel iconLabel = new JLabel();
		if (itemImage != null)
		{
			// Set initial icon
			iconLabel.setIcon(new ImageIcon(itemImage));
			
			// Add observer to update when image loads
			itemImage.onLoaded(() ->
			{
				iconLabel.setIcon(new ImageIcon(itemImage));
				iconLabel.revalidate();
				iconLabel.repaint();
			});
		}
		else
		{
			// Placeholder if no image
			iconLabel.setPreferredSize(new Dimension(32, 32));
		}

		JLabel nameLabel = new JLabel(rec.getItemName());
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 14));

		namePanel.add(iconLabel);
		namePanel.add(nameLabel);

		topPanel.add(namePanel, BorderLayout.WEST);

		// Details panel
		JPanel detailsPanel = new JPanel();
		detailsPanel.setLayout(new BoxLayout(detailsPanel, BoxLayout.Y_AXIS));
		detailsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		detailsPanel.setBorder(new EmptyBorder(5, 0, 0, 0));

		// Recommended Buy/Sell prices (full format with commas for easy copying)
		JLabel priceLabel = new JLabel(String.format("Buy: %s | Sell: %s",
			formatGPExact(rec.getRecommendedBuyPrice()),
			formatGPExact(rec.getRecommendedSellPrice())));
		priceLabel.setForeground(Color.LIGHT_GRAY);
		priceLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));

		// Quantity
		JLabel quantityLabel = new JLabel(String.format("Qty: %d (Limit: %d)",
			rec.getRecommendedQuantity(),
			rec.getBuyLimit()));
		quantityLabel.setForeground(new Color(200, 200, 255));
		quantityLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));

		// Margin and ROI
		JLabel marginLabel = new JLabel(String.format("Margin: %s (%s ROI)",
			formatGP(rec.getMargin()),
			rec.getFormattedROI()));
		marginLabel.setForeground(new Color(100, 255, 100));
		marginLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));

		// Potential profit and total cost
		JLabel profitLabel = new JLabel(String.format("Profit: %s | Cost: %s",
			formatGP(rec.getPotentialProfit()),
			formatGP(rec.getTotalCost())));
		profitLabel.setForeground(new Color(255, 215, 0));
		profitLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 12));

		detailsPanel.add(priceLabel);
		detailsPanel.add(Box.createRigidArea(new Dimension(0, 2)));
		detailsPanel.add(quantityLabel);
		detailsPanel.add(Box.createRigidArea(new Dimension(0, 2)));
		detailsPanel.add(marginLabel);
		detailsPanel.add(Box.createRigidArea(new Dimension(0, 2)));
		detailsPanel.add(profitLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Add click listener to expand/show more details
		panel.addMouseListener(new MouseAdapter()
		{
			private boolean expanded = false;

			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (!expanded)
				{
					// Add additional details
					JPanel extraDetails = new JPanel();
					extraDetails.setLayout(new BoxLayout(extraDetails, BoxLayout.Y_AXIS));
					extraDetails.setBackground(ColorScheme.DARKER_GRAY_COLOR);
					extraDetails.setBorder(new EmptyBorder(5, 0, 0, 0));

					JLabel liquidityLabel = new JLabel(String.format("Liquidity: %.0f (%s) | %.0f/hr",
						rec.getLiquidityScore(),
						rec.getLiquidityRating(),
						rec.getVolumePerHour()));
					liquidityLabel.setForeground(Color.CYAN);
					liquidityLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

					JLabel riskLabel = new JLabel(String.format("Risk: %.0f (%s)",
						rec.getRiskScore(),
						rec.getRiskRating()));
					riskLabel.setForeground(getRiskColor(rec.getRiskScore()));
					riskLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

					extraDetails.add(liquidityLabel);
					extraDetails.add(Box.createRigidArea(new Dimension(0, 2)));
					extraDetails.add(riskLabel);

					panel.add(extraDetails, BorderLayout.SOUTH);
					expanded = true;
				}
				else
				{
					// Remove extra details
					if (panel.getComponentCount() > 2)
					{
						panel.remove(2);
						expanded = false;
					}
				}

				panel.revalidate();
				panel.repaint();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}
		});

		return panel;
	}

	/**
	 * Get color based on risk score
	 */
	private Color getRiskColor(double score)
	{
		if (score <= 20)
		{
			return new Color(100, 255, 100); // Green
		}
		else if (score <= 40)
		{
			return new Color(150, 255, 100); // Yellow-green
		}
		else if (score <= 60)
		{
			return new Color(255, 255, 100); // Yellow
		}
		else
		{
			return new Color(255, 100, 100); // Red
		}
	}

	/**
	 * Format GP amount for display
	 */
	private String formatGP(int amount)
	{
		if (amount >= 1_000_000)
		{
			return String.format("%.1fM", amount / 1_000_000.0);
		}
		else if (amount >= 1_000)
		{
			return String.format("%.1fK", amount / 1_000.0);
		}
		return String.valueOf(amount);
	}

	/**
	 * Format GP amount with commas for exact input (e.g., "1,234,567")
	 */
	private String formatGPExact(int amount)
	{
		return String.format("%,d", amount);
	}

	/**
	 * Set the cash stack for filtering recommendations
	 * @param cashStack the cash stack value (used to trigger refresh)
	 */
	@SuppressWarnings("unused")
	public void setCashStack(Integer cashStack)
	{
		// This will trigger a refresh with the new cash stack
		refresh();
	}

	/**
	 * Get the current recommendations
	 */
	public List<FlipRecommendation> getCurrentRecommendations()
	{
		return new ArrayList<>(currentRecommendations);
	}

	/**
	 * Create a panel for an active flip with current market data
	 */
	private JPanel createActiveFlipPanel(ActiveFlip flip)
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(8, 8, 8, 8));
		panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));

		// Top section: Item icon and name
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		namePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Get item image
		AsyncBufferedImage itemImage = itemManager.getImage(flip.getItemId());
		JLabel iconLabel = new JLabel();
		if (itemImage != null)
		{
			iconLabel.setIcon(new ImageIcon(itemImage));
			itemImage.onLoaded(() ->
			{
				iconLabel.setIcon(new ImageIcon(itemImage));
				iconLabel.revalidate();
				iconLabel.repaint();
			});
		}
		else
		{
			iconLabel.setPreferredSize(new Dimension(32, 32));
		}

		JLabel nameLabel = new JLabel(flip.getItemName());
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 13));

		namePanel.add(iconLabel);
		namePanel.add(nameLabel);
		topPanel.add(namePanel, BorderLayout.WEST);

		// Details section with market data
		JPanel detailsPanel = new JPanel(new GridLayout(3, 2, 5, 2));
		detailsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		detailsPanel.setBorder(new EmptyBorder(3, 38, 0, 0));

		// Row 1: Quantity (sold/total) and Buy Price (exact price for easy GE input)
		String qtyText;
		if (flip.getOriginalQuantity() > 0)
		{
			// Show sold/total format (e.g., "0/200" means 0 sold out of 200)
			int soldQuantity = flip.getOriginalQuantity() - flip.getTotalQuantity();
			qtyText = String.format("Qty: %d/%d", soldQuantity, flip.getOriginalQuantity());
		}
		else
		{
			// Fallback if original not available
			qtyText = String.format(FORMAT_QTY, flip.getTotalQuantity());
		}
		JLabel qtyLabel = new JLabel(qtyText);
		qtyLabel.setForeground(new Color(200, 200, 200));
		qtyLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel buyPriceLabel = new JLabel(String.format("Buy: %s", formatGPExact(flip.getAverageBuyPrice())));
		buyPriceLabel.setForeground(new Color(255, 120, 120)); // Light red for buy
		buyPriceLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 2: Total Invested and Target Sell Price (exact price for GE input)
		JLabel investedLabel = new JLabel(String.format("Invested: %s", formatGP(flip.getTotalInvested())));
		investedLabel.setForeground(new Color(255, 200, 100)); // Gold
		investedLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 11));

		// Fetch current market price for this item
		JLabel sellPriceLabel = new JLabel("Sell: Loading...");
		sellPriceLabel.setForeground(new Color(120, 255, 120)); // Light green for sell
		sellPriceLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 3: Potential Profit and ROI
		JLabel profitLabel = new JLabel("Profit: Loading...");
		profitLabel.setForeground(Color.LIGHT_GRAY);
		profitLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel roiLabel = new JLabel("ROI: Loading...");
		roiLabel.setForeground(Color.LIGHT_GRAY);
		roiLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		detailsPanel.add(qtyLabel);
		detailsPanel.add(buyPriceLabel);
		detailsPanel.add(investedLabel);
		detailsPanel.add(sellPriceLabel);
		detailsPanel.add(profitLabel);
		detailsPanel.add(roiLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Use recommended sell price if available, otherwise fetch current market price
		if (flip.getRecommendedSellPrice() != null && flip.getRecommendedSellPrice() > 0)
		{
			// Use recommended price from when the flip was suggested
			int recommendedSellPrice = flip.getRecommendedSellPrice();
			
			// Update sell price
			sellPriceLabel.setText(String.format(FORMAT_SELL, formatGPExact(recommendedSellPrice)));

			// Calculate GE tax (2% capped at 5M)
			int geTax = Math.min((int)(recommendedSellPrice * 0.02), 5_000_000);
			
			// Calculate potential profit (per item)
			int profitPerItem = recommendedSellPrice - flip.getAverageBuyPrice() - geTax;
			int totalProfit = profitPerItem * flip.getTotalQuantity();

			// Calculate ROI
			double roi = (profitPerItem * 100.0) / flip.getAverageBuyPrice();

			// Update profit label with color
			String profitText = Math.abs(totalProfit) >= 100_000 
				? formatGP(totalProfit) 
				: formatGPExact(totalProfit);
			profitLabel.setText(String.format("Profit: %s", profitText));
			profitLabel.setForeground(totalProfit > 0 ? new Color(100, 255, 100) : new Color(255, 100, 100));
			profitLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 11));

			// Update ROI label with color
			roiLabel.setText(String.format(FORMAT_ROI, roi));
			roiLabel.setForeground(roi > 0 ? new Color(100, 255, 100) : new Color(255, 100, 100));
			roiLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 11));
		}
		else
		{
			// Fallback: fetch current market price
			apiClient.getItemAnalysisAsync(flip.getItemId()).thenAccept(analysis ->
			{
				SwingUtilities.invokeLater(() ->
				{
					if (analysis != null && analysis.getCurrentPrices() != null)
					{
						FlipAnalysis.CurrentPrices prices = analysis.getCurrentPrices();
						Integer currentSellPrice = prices.getHigh();
						Integer geTax = prices.getGeTax();

						if (currentSellPrice != null && geTax != null)
						{
							// Update sell price with exact number for easy GE input
							sellPriceLabel.setText(String.format("Sell: %s*", formatGPExact(currentSellPrice)));

							// Calculate potential profit (per item)
							int profitPerItem = currentSellPrice - flip.getAverageBuyPrice() - geTax;
							int totalProfit = profitPerItem * flip.getTotalQuantity();

							// Calculate ROI
							double roi = (profitPerItem * 100.0) / flip.getAverageBuyPrice();

							// Update profit label with color
							String profitText = Math.abs(totalProfit) >= 100_000 
								? formatGP(totalProfit) 
								: formatGPExact(totalProfit);
							profitLabel.setText(String.format("Profit: %s*", profitText));
							profitLabel.setForeground(totalProfit > 0 ? new Color(100, 255, 100) : new Color(255, 100, 100));
							profitLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

							// Update ROI label with color
							roiLabel.setText(String.format("ROI: %.1f%%*", roi));
							roiLabel.setForeground(roi > 0 ? new Color(100, 255, 100) : new Color(255, 100, 100));
							roiLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));
						}
						else
						{
							sellPriceLabel.setText("Sell: N/A");
							profitLabel.setText("Profit: N/A");
							roiLabel.setText("ROI: N/A");
						}
					}
					else
					{
						sellPriceLabel.setText("Sell: N/A");
						profitLabel.setText("Profit: N/A");
						roiLabel.setText("ROI: N/A");
					}
				});
			});
		}

		// Add hover effect and context menu
		panel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent e)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				topPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				namePanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
				detailsPanel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				namePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				detailsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			}

			@Override
			public void mousePressed(MouseEvent e)
			{
				showContextMenu(e, flip);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				showContextMenu(e, flip);
			}

			private void showContextMenu(MouseEvent e, ActiveFlip flip)
			{
				if (e.isPopupTrigger())
				{
					JPopupMenu contextMenu = new JPopupMenu();
					
					JMenuItem dismissItem = new JMenuItem("Dismiss from Active Flips");
					dismissItem.addActionListener(ae -> dismissActiveFlip(flip));
					contextMenu.add(dismissItem);
					
					contextMenu.show(e.getComponent(), e.getX(), e.getY());
				}
			}
		});

		return panel;
	}

	/**
	 * Create a panel for a pending order (not yet filled)
	 */
	private JPanel createPendingOrderPanel(FlipSmartPlugin.PendingOrder pending)
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBackground(new Color(55, 55, 65)); // Slightly different color for pending
		panel.setBorder(new EmptyBorder(8, 8, 8, 8));
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));

		// Top section: Item icon and name
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(new Color(55, 55, 65));

		JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		namePanel.setBackground(new Color(55, 55, 65));

		// Get item image
		AsyncBufferedImage itemImage = itemManager.getImage(pending.itemId);
		JLabel iconLabel = new JLabel();
		if (itemImage != null)
		{
			iconLabel.setIcon(new ImageIcon(itemImage));
			itemImage.onLoaded(() ->
			{
				iconLabel.setIcon(new ImageIcon(itemImage));
				iconLabel.revalidate();
				iconLabel.repaint();
			});
		}
		else
		{
			iconLabel.setPreferredSize(new Dimension(32, 32));
		}

		JLabel nameLabel = new JLabel(pending.itemName);
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 13));

		namePanel.add(iconLabel);
		namePanel.add(nameLabel);
		topPanel.add(namePanel, BorderLayout.WEST);

		// Details section - same grid layout as active flips
		JPanel detailsPanel = new JPanel(new GridLayout(3, 2, 5, 2));
		detailsPanel.setBackground(new Color(55, 55, 65));
		detailsPanel.setBorder(new EmptyBorder(3, 38, 0, 0));

		// Row 1: Quantity (filled/total) and Offer Price
		String qtyText;
		if (pending.quantityFilled > 0)
		{
			// Show progress: filled/total
			qtyText = String.format("Qty: %d/%d", pending.quantityFilled, pending.quantity);
		}
		else
		{
			// Show just total if nothing filled yet
			qtyText = String.format("Qty: 0/%d", pending.quantity);
		}
		JLabel qtyLabel = new JLabel(qtyText);
		qtyLabel.setForeground(new Color(200, 200, 200));
		qtyLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel offerLabel = new JLabel(String.format("Offer: %s", formatGPExact(pending.pricePerItem)));
		offerLabel.setForeground(new Color(255, 120, 120)); // Light red like buy prices
		offerLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 2: Invested (actual filled amount) and Target Sell
		int actualInvestment = pending.quantityFilled * pending.pricePerItem;
		int potentialInvestment = pending.quantity * pending.pricePerItem;
		String investedText;
		if (pending.quantityFilled > 0)
		{
			investedText = String.format("Invested: %s", formatGP(actualInvestment));
		}
		else
		{
			investedText = String.format("If filled: %s", formatGP(potentialInvestment));
		}
		JLabel investedLabel = new JLabel(investedText);
		investedLabel.setForeground(pending.quantityFilled > 0 ? new Color(255, 200, 100) : new Color(200, 200, 200));
		investedLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel sellLabel = new JLabel();
		if (pending.recommendedSellPrice != null && pending.recommendedSellPrice > 0)
		{
			sellLabel.setText(String.format(FORMAT_SELL, formatGPExact(pending.recommendedSellPrice)));
			sellLabel.setForeground(new Color(120, 255, 120)); // Light green for sell
		}
		else
		{
			sellLabel.setText("Sell: --");
			sellLabel.setForeground(Color.LIGHT_GRAY);
		}
		sellLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 3: Status and Expected ROI
		String statusText;
		Color statusColor;
		if (pending.quantityFilled > 0)
		{
			// Partially filled - show progress
			int percent = (pending.quantityFilled * 100) / pending.quantity;
			statusText = String.format("GE Slot %d: Filling (%d%%)", pending.slot + 1, percent);
			statusColor = new Color(120, 200, 255); // Light blue for in-progress
		}
		else
		{
			// Waiting for first fill
			statusText = String.format("GE Slot %d: Waiting", pending.slot + 1);
			statusColor = new Color(180, 180, 180);
		}
		JLabel slotStatusLabel = new JLabel(statusText);
		slotStatusLabel.setForeground(statusColor);
		slotStatusLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel roiLabel = new JLabel();
		if (pending.recommendedSellPrice != null && pending.recommendedSellPrice > 0)
		{
			int geTax = Math.min((int)(pending.recommendedSellPrice * 0.02), 5_000_000);
			int profitPerItem = pending.recommendedSellPrice - pending.pricePerItem - geTax;
			double roi = (profitPerItem * 100.0) / pending.pricePerItem;
			roiLabel.setText(String.format(FORMAT_ROI, roi));
			roiLabel.setForeground(roi > 0 ? new Color(100, 255, 100) : new Color(255, 100, 100));
		}
		else
		{
			roiLabel.setText("ROI: --");
			roiLabel.setForeground(Color.LIGHT_GRAY);
		}
		roiLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		detailsPanel.add(qtyLabel);
		detailsPanel.add(offerLabel);
		detailsPanel.add(investedLabel);
		detailsPanel.add(sellLabel);
		detailsPanel.add(slotStatusLabel);
		detailsPanel.add(roiLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		return panel;
	}
	
	/**
	 * Create a panel for a completed flip
	 */
	private JPanel createCompletedFlipPanel(CompletedFlip flip)
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		// Color based on profit/loss
		Color backgroundColor = flip.isSuccessful() ? 
			new Color(40, 60, 40) : // Dark green for profit
			new Color(60, 40, 40);  // Dark red for loss
		panel.setBackground(backgroundColor);
		panel.setBorder(new EmptyBorder(8, 8, 8, 8));
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));

		// Top section: Item icon and name
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(backgroundColor);

		JPanel namePanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		namePanel.setBackground(backgroundColor);

		// Get item image
		AsyncBufferedImage itemImage = itemManager.getImage(flip.getItemId());
		JLabel iconLabel = new JLabel();
		if (itemImage != null)
		{
			iconLabel.setIcon(new ImageIcon(itemImage));
			itemImage.onLoaded(() ->
			{
				iconLabel.setIcon(new ImageIcon(itemImage));
				iconLabel.revalidate();
				iconLabel.repaint();
			});
		}
		else
		{
			iconLabel.setPreferredSize(new Dimension(32, 32));
		}

		JLabel nameLabel = new JLabel(flip.getItemName());
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 13));

		namePanel.add(iconLabel);
		namePanel.add(nameLabel);
		topPanel.add(namePanel, BorderLayout.WEST);

		// Details section with profit/loss info
		JPanel detailsPanel = new JPanel(new GridLayout(3, 2, 5, 2));
		detailsPanel.setBackground(backgroundColor);
		detailsPanel.setBorder(new EmptyBorder(3, 38, 0, 0));

		// Row 1: Quantity and Buy Price
		JLabel qtyLabel = new JLabel(String.format(FORMAT_QTY, flip.getQuantity()));
		qtyLabel.setForeground(new Color(200, 200, 200));
		qtyLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel buyPriceLabel = new JLabel(String.format("Buy: %s", formatGPExact(flip.getBuyPricePerItem())));
		buyPriceLabel.setForeground(new Color(255, 120, 120));
		buyPriceLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 2: Invested and Sell Price
		JLabel investedLabel = new JLabel(String.format("Cost: %s", formatGP(flip.getBuyTotal())));
		investedLabel.setForeground(new Color(200, 200, 200));
		investedLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		JLabel sellPriceLabel = new JLabel(String.format(FORMAT_SELL, formatGPExact(flip.getSellPricePerItem())));
		sellPriceLabel.setForeground(new Color(120, 255, 120));
		sellPriceLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));

		// Row 3: Net Profit and ROI
		JLabel profitLabel = new JLabel(String.format("Profit: %s", formatGP(flip.getNetProfit())));
		Color profitColor = flip.isSuccessful() ? 
			new Color(100, 255, 100) : // Bright green
			new Color(255, 100, 100);  // Bright red
		profitLabel.setForeground(profitColor);
		profitLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 11));

		JLabel roiLabel = new JLabel(String.format(FORMAT_ROI, flip.getRoiPercent()));
		roiLabel.setForeground(profitColor);
		roiLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 11));

		detailsPanel.add(qtyLabel);
		detailsPanel.add(buyPriceLabel);
		detailsPanel.add(investedLabel);
		detailsPanel.add(sellPriceLabel);
		detailsPanel.add(profitLabel);
		detailsPanel.add(roiLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Add click to show more details
		panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		panel.addMouseListener(new MouseAdapter()
		{
			private boolean expanded = false;

			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (!expanded)
				{
					// Add extra details
					JPanel extraDetails = new JPanel();
					extraDetails.setLayout(new BoxLayout(extraDetails, BoxLayout.Y_AXIS));
					extraDetails.setBackground(backgroundColor);
					extraDetails.setBorder(new EmptyBorder(5, 38, 0, 0));

					// Duration
					int hours = flip.getFlipDurationSeconds() / 3600;
					int minutes = (flip.getFlipDurationSeconds() % 3600) / 60;
					String duration = hours > 0 ? 
						String.format("%dh %dm", hours, minutes) :
						String.format("%dm", minutes);

					JLabel durationLabel = new JLabel(String.format("Duration: %s", duration));
					durationLabel.setForeground(new Color(180, 180, 180));
					durationLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 10));

					// GE Tax
					JLabel taxLabel = new JLabel(String.format("GE Tax: %s", formatGP(flip.getGeTax())));
					taxLabel.setForeground(new Color(180, 180, 180));
					taxLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 10));

					extraDetails.add(durationLabel);
					extraDetails.add(Box.createRigidArea(new Dimension(0, 2)));
					extraDetails.add(taxLabel);

					panel.add(extraDetails, BorderLayout.SOUTH);
					expanded = true;
				}
				else
				{
					// Remove extra details
					if (panel.getComponentCount() > 2)
					{
						panel.remove(2);
						expanded = false;
					}
				}

				panel.revalidate();
				panel.repaint();
			}
		});

		return panel;
	}
	
	/**
	 * Dismiss an active flip (remove from tracking)
	 */
	private void dismissActiveFlip(ActiveFlip flip)
	{
		int result = JOptionPane.showConfirmDialog(
			this,
			String.format("Remove %s from active flips?%n%nThis will hide it from tracking.%nUse this if you sold/used the items outside of the GE.", flip.getItemName()),
			"Dismiss Active Flip",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.QUESTION_MESSAGE
		);

		if (result == JOptionPane.YES_OPTION)
		{
			// Dismiss asynchronously
			apiClient.dismissActiveFlipAsync(flip.getItemId()).thenAccept(success ->
			{
				SwingUtilities.invokeLater(() ->
				{
					if (Boolean.TRUE.equals(success))
					{
						// Refresh the active flips list
						refreshActiveFlips();
						JOptionPane.showMessageDialog(
							this,
							String.format("%s has been removed from active flips.", flip.getItemName()),
							"Dismissed",
							JOptionPane.INFORMATION_MESSAGE
						);
					}
					else
					{
						JOptionPane.showMessageDialog(
							this,
							"Failed to dismiss active flip. Please try again.",
							"Error",
							JOptionPane.ERROR_MESSAGE
						);
					}
				});
			});
		}
	}
	
	/**
	 * Get the current scroll position of a scroll pane.
	 */
	private int getScrollPosition(JScrollPane scrollPane)
	{
		if (scrollPane == null || scrollPane.getVerticalScrollBar() == null)
		{
			return 0;
		}
		return scrollPane.getVerticalScrollBar().getValue();
	}
	
	/**
	 * Restore the scroll position of a scroll pane after content refresh.
	 * Uses invokeLater to ensure layout is complete before restoring.
	 */
	private void restoreScrollPosition(JScrollPane scrollPane, int position)
	{
		if (scrollPane == null || scrollPane.getVerticalScrollBar() == null || position <= 0)
		{
			return;
		}
		// Use invokeLater to restore after layout is complete
		SwingUtilities.invokeLater(() -> scrollPane.getVerticalScrollBar().setValue(position));
	}
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Represents an active flip (item bought but not yet sold)
 */
@Data
public class ActiveFlip
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	@SerializedName("total_quantity")
	private int totalQuantity;

	@SerializedName("original_quantity")
	private int originalQuantity;

	@SerializedName("average_buy_price")
	private int averageBuyPrice;

	@SerializedName("total_invested")
	private int totalInvested;

	@SerializedName("first_buy_time")
	private String firstBuyTime;

	@SerializedName("last_buy_time")
	private String lastBuyTime;

	@SerializedName("transaction_count")
	private int transactionCount;

	@SerializedName("recommended_sell_price")
	private Integer recommendedSellPrice;
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

@Data
public class FlipRecommendation
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	private boolean members;

	@SerializedName("buy_limit")
	private Integer buyLimit;

	// Instant prices (reference only)
	@SerializedName("instant_buy_price")
	private int instantBuyPrice;

	@SerializedName("instant_sell_price")
	private int instantSellPrice;

	// Recommended prices (for GE offers)
	@SerializedName("recommended_buy_price")
	private int recommendedBuyPrice;

	@SerializedName("recommended_sell_price")
	private int recommendedSellPrice;

	@SerializedName("recommended_quantity")
	private int recommendedQuantity;

	private int margin;

	@SerializedName("roi_percent")
	private double roiPercent;

	@SerializedName("ge_tax")
	private int geTax;

	@SerializedName("liquidity_score")
	private double liquidityScore;

	@SerializedName("liquidity_rating")
	private String liquidityRating;

	@SerializedName("volume_per_hour")
	private double volumePerHour;

	@SerializedName("risk_score")
	private double riskScore;

	@SerializedName("risk_rating")
	private String riskRating;

	@SerializedName("efficiency_score")
	private double efficiencyScore;

	@SerializedName("efficiency_rating")
	private String efficiencyRating;

	@SerializedName("quantity_affordable")
	private Integer quantityAffordable;

	@SerializedName("potential_profit")
	private int potentialProfit;

	@SerializedName("total_cost")
	private int totalCost;

	// Deprecated fields (kept for backwards compatibility)
	@SerializedName("buy_price")
	private Integer buyPrice;

	@SerializedName("sell_price")
	private Integer sellPrice;

	@SerializedName("cost_per_flip")
	private Integer costPerFlip;

	/**
	 * Format GP amount for display
	 */
	public String formatGP(int amount)
	{
		if (amount >= 1_000_000)
		{
			return String.format("%.1fM", amount / 1_000_000.0);
		}
		else if (amount >= 1_000)
		{
			return String.format("%.1fK", amount / 1_000.0);
		}
		return String.valueOf(amount);
	}

	/**
	 * Get formatted margin text
	 */
	public String getFormattedMargin()
	{
		return formatGP(margin) + " gp";
	}

	/**
	 * Get formatted ROI text
	 */
	public String getFormattedROI()
	{
		return String.format("%.1f%%", roiPercent);
	}

	/**
	 * Get formatted potential profit text
	 */
	public String getFormattedPotentialProfit()
	{
		return formatGP(potentialProfit) + " gp";
	}
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

/**
 * Response from the completed flips API endpoint
 */
@Data
public class CompletedFlipsResponse
{
	@SerializedName("flips")
	private List<CompletedFlip> flips;

	@SerializedName("count")
	private int count;
}


package com.flipsmart;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

@ConfigGroup("flipsmart")
public interface FlipSmartConfig extends Config
{
	// ============================================
	// Advanced Section (API URL override only)
	// ============================================
	@ConfigSection(
		name = "Advanced",
		description = "Advanced settings",
		position = 0,
		closedByDefault = true
	)
	String advancedSection = "advanced";

	@ConfigItem(
		keyName = "apiUrl",
		name = "API URL Override",
		description = "Leave empty to use production server (https://flipsm.art). Only set this to override with a custom server URL.",
		section = advancedSection,
		position = 0
	)
	default String apiUrl()
	{
		return "";
	}

	// Hidden config items (not shown in UI, but used for persistence)
	// These are accessed via ConfigManager directly

	@ConfigItem(
		keyName = "email",
		name = "",
		description = "",
		hidden = true
	)
	default String email()
	{
		return "";
	}

	@ConfigItem(
		keyName = "password",
		name = "",
		description = "",
		hidden = true,
		secret = true
	)
	default String password()
	{
		return "";
	}

	// ============================================
	// Flip Finder Section
	// ============================================
	@ConfigSection(
		name = "Flip Finder",
		description = "Settings for flip recommendations",
		position = 1,
		closedByDefault = false
	)
	String flipFinderSection = "flipFinder";

	@ConfigItem(
		keyName = "showFlipFinder",
		name = "Enable Flip Finder",
		description = "Show the Flip Finder panel in the sidebar",
		section = flipFinderSection,
		position = 0
	)
	default boolean showFlipFinder()
	{
		return true;
	}

	@ConfigItem(
		keyName = "flipStyle",
		name = "Flip Style",
		description = "Your preferred flipping style",
		section = flipFinderSection,
		position = 1
	)
	default FlipStyle flipStyle()
	{
		return FlipStyle.BALANCED;
	}

	@ConfigItem(
		keyName = "flipFinderLimit",
		name = "Number of Recommendations",
		description = "Number of flip recommendations to show (1-50)",
		section = flipFinderSection,
		position = 2
	)
	default int flipFinderLimit()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "flipFinderRefreshMinutes",
		name = "Refresh Interval (minutes)",
		description = "How often to refresh flip recommendations (1-60 minutes)",
		section = flipFinderSection,
		position = 3
	)
	default int flipFinderRefreshMinutes()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "minProfit",
		name = "Minimum Profit",
		description = "Minimum profit margin to highlight (in GP)",
		section = flipFinderSection,
		position = 4
	)
	default int minimumProfit()
	{
		return 100;
	}

	// ============================================
	// Display Section
	// ============================================
	@ConfigSection(
		name = "Display",
		description = "Display and overlay settings",
		position = 2,
		closedByDefault = false
	)
	String displaySection = "display";

	@ConfigItem(
		keyName = "showGEOverlay",
		name = "Show GE Tracker",
		description = "Display in-game Grand Exchange offer tracker",
		section = displaySection,
		position = 0
	)
	default boolean showGEOverlay()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGEItemNames",
		name = "Show Item Names",
		description = "Display item names in the GE tracker",
		section = displaySection,
		position = 1
	)
	default boolean showGEItemNames()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGEItemIcons",
		name = "Show Item Icons",
		description = "Display item icons in the GE tracker",
		section = displaySection,
		position = 2
	)
	default boolean showGEItemIcons()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGEDetailedInfo",
		name = "Show Detailed Info",
		description = "Show quantity, price per item, and total value",
		section = displaySection,
		position = 3
	)
	default boolean showGEDetailedInfo()
	{
		return true;
	}

	// ============================================
	// General Section
	// ============================================
	@ConfigSection(
		name = "General",
		description = "General plugin settings",
		position = 3,
		closedByDefault = true
	)
	String generalSection = "general";

	@ConfigItem(
		keyName = "trackHistory",
		name = "Track History",
		description = "Track flipping history across sessions",
		section = generalSection,
		position = 0
	)
	default boolean trackHistory()
	{
		return true;
	}

	// ============================================
	// Flip Style Enum
	// ============================================
	enum FlipStyle
	{
		CONSERVATIVE("conservative"),
		BALANCED("balanced"),
		AGGRESSIVE("aggressive");

		private final String apiValue;

		FlipStyle(String apiValue)
		{
			this.apiValue = apiValue;
		}

		public String getApiValue()
		{
			return apiValue;
		}

		@Override
		public String toString()
		{
			return name().charAt(0) + name().substring(1).toLowerCase();
		}
	}
}


package com.flipsmart;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.awt.Point;
import java.awt.Rectangle;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@PluginDescriptor(
	name = "Flip Smart",
	description = "A tool to help with item flipping in the Grand Exchange",
	tags = {"grand exchange", "flipping", "trading", "money making"}
)
public class FlipSmartPlugin extends Plugin
{
	private static final int INVENTORY_CONTAINER_ID = 93;

	@Inject
	private Client client;

	@Inject
	private FlipSmartConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GrandExchangeOverlay geOverlay;

	@Inject
	private FlipSmartApiClient apiClient;

	@Inject
	private net.runelite.client.ui.ClientToolbar clientToolbar;

	@Inject
	private net.runelite.client.game.ItemManager itemManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	// Flip Finder panel
	private FlipFinderPanel flipFinderPanel;
	private net.runelite.client.ui.NavigationButton flipFinderNavButton;

	// Player's current cash stack (detected from inventory)
	@Getter
	private int currentCashStack = 0;

	// Auto-refresh timer for flip finder
	private java.util.Timer flipFinderRefreshTimer;
	private long lastFlipFinderRefresh = 0;

	// Track GE offers to detect when they complete
	private final Map<Integer, TrackedOffer> trackedOffers = new ConcurrentHashMap<>();
	
	// Track login to avoid recording existing offers as new transactions
	private static final int GE_LOGIN_BURST_WINDOW = 3; // ticks
	private int lastLoginTick = 0;
	
	// Track recommended prices from flip finder (item_id -> recommended_sell_price)
	private final Map<Integer, Integer> recommendedPrices = new ConcurrentHashMap<>();

	// Config keys for persisting offer state
	private static final String CONFIG_GROUP = "flipsmart";
	private static final String PERSISTED_OFFERS_KEY_PREFIX = "persistedOffers_";
	private static final String COLLECTED_ITEMS_KEY_PREFIX = "collectedItems_";
	
	// Flag to track if we've synced offline fills on this login
	private boolean offlineSyncCompleted = false;
	
	// Current RSN (set on login)
	@Getter
	private String currentRsn = null;
	
	// Track items collected from GE in current session (waiting to be sold)
	// These should show as active flips even though they're no longer in GE slots
	private final java.util.Set<Integer> collectedItemIds = ConcurrentHashMap.newKeySet();

	/**
	 * Helper class to track GE offers (serializable for persistence)
	 */
	public static class TrackedOffer
	{
		int itemId;
		String itemName;
		boolean isBuy;
		int totalQuantity;
		int price;
		int previousQuantitySold;

		// Default constructor for Gson deserialization
		TrackedOffer() {}

		TrackedOffer(int itemId, String itemName, boolean isBuy, int totalQuantity, int price, int quantitySold)
		{
			this.itemId = itemId;
			this.itemName = itemName;
			this.isBuy = isBuy;
			this.totalQuantity = totalQuantity;
			this.price = price;
			this.previousQuantitySold = quantitySold;
		}
	}
	
	/**
	 * Store recommended sell price when user views/acts on a flip recommendation
	 */
	public void setRecommendedSellPrice(int itemId, int recommendedSellPrice)
	{
		recommendedPrices.put(itemId, recommendedSellPrice);
		log.debug("Stored recommended sell price for item {}: {}", itemId, recommendedSellPrice);
	}
	
	/**
	 * Get current buy orders in GE slots (pending or partially filled).
	 * These are buy orders that haven't been fully collected yet.
	 */
	public java.util.List<PendingOrder> getPendingBuyOrders()
	{
		java.util.List<PendingOrder> pendingOrders = new java.util.ArrayList<>();
		
		for (java.util.Map.Entry<Integer, TrackedOffer> entry : trackedOffers.entrySet())
		{
			TrackedOffer offer = entry.getValue();
			
			// Include all buy orders (pending or partially filled)
			if (offer.isBuy)
			{
				Integer recommendedSellPrice = recommendedPrices.get(offer.itemId);
				
				PendingOrder pending = new PendingOrder(
					offer.itemId,
					offer.itemName,
					offer.totalQuantity,
					offer.previousQuantitySold, // How many filled so far
					offer.price,
					recommendedSellPrice,
					entry.getKey() // slot
				);
				
				pendingOrders.add(pending);
			}
		}
		
		return pendingOrders;
	}
	
	/**
	 * Get the set of item IDs currently in GE buy slots.
	 */
	public java.util.Set<Integer> getCurrentGEBuyItemIds()
	{
		java.util.Set<Integer> itemIds = new java.util.HashSet<>();
		
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (offer.isBuy)
			{
				itemIds.add(offer.itemId);
			}
		}
		
		return itemIds;
	}
	
	/**
	 * Get all active flip item IDs - items that should show as active flips.
	 * This includes:
	 * 1. Items currently in GE buy slots (pending or filled)
	 * 2. Items currently in GE sell slots (pending sale)
	 * 3. Items collected from GE in this session (waiting to be sold)
	 */
	public java.util.Set<Integer> getActiveFlipItemIds()
	{
		java.util.Set<Integer> itemIds = new java.util.HashSet<>();
		
		// Add items currently in ANY GE slots (buy OR sell)
		// Items in sell slots are still part of an active flip until sold
		for (TrackedOffer offer : trackedOffers.values())
		{
			itemIds.add(offer.itemId);
		}
		
		// Add items collected from GE (waiting to be sold)
		itemIds.addAll(collectedItemIds);
		
		return itemIds;
	}
	
	/**
	 * Mark an item as sold - removes it from the collected tracking.
	 * Called when a sell transaction is recorded.
	 * Also checks if inventory is empty AND no active GE sell slot for this item,
	 * then auto-closes the active flip.
	 */
	public void markItemSold(int itemId)
	{
		if (collectedItemIds.remove(itemId))
		{
			log.debug("Removed item {} from collected tracking (sold)", itemId);
		}
		
		// Check if this item is still in a GE sell slot (not yet fully sold)
		boolean hasActiveSellSlot = false;
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (offer.itemId == itemId && !offer.isBuy)
			{
				hasActiveSellSlot = true;
				break;
			}
		}
		
		// Only auto-close if inventory is empty AND there's no active sell slot
		// This prevents closing flips that are still selling in the GE
		if (!hasActiveSellSlot)
		{
			int inventoryCount = getInventoryCountForItem(itemId);
			if (inventoryCount == 0)
			{
				log.info("Inventory empty and no active sell slot for item {}, auto-closing active flip", itemId);
				apiClient.dismissActiveFlipAsync(itemId, getCurrentRsnSafe().orElse(null)).thenAccept(success ->
				{
					if (Boolean.TRUE.equals(success))
					{
						log.info("Successfully auto-closed active flip for item {} (no items remaining)", itemId);
						// Refresh the panel to reflect the change
						if (flipFinderPanel != null)
						{
							javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refresh());
						}
					}
				});
			}
		}
		else
		{
			log.debug("Item {} still has active sell slot, keeping flip open", itemId);
		}
	}
	
	/**
	 * Get the count of a specific item in the player's inventory
	 * @param itemId The item ID to check
	 * @return The quantity of the item in inventory (0 if not found)
	 */
	private int getInventoryCountForItem(int itemId)
	{
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory == null)
		{
			return 0;
		}
		
		int count = 0;
		Item[] items = inventory.getItems();
		for (Item item : items)
		{
			if (item.getId() == itemId)
			{
				count += item.getQuantity();
			}
		}
		
		return count;
	}
	
	/**
	 * Helper class for pending orders
	 */
	public static class PendingOrder
	{
		public final int itemId;
		public final String itemName;
		public final int quantity;        // Total quantity ordered
		public final int quantityFilled;  // How many have been filled so far
		public final int pricePerItem;
		public final Integer recommendedSellPrice;
		public final int slot;
		
		public PendingOrder(int itemId, String itemName, int quantity, int quantityFilled, int pricePerItem, Integer recommendedSellPrice, int slot)
		{
			this.itemId = itemId;
			this.itemName = itemName;
			this.quantity = quantity;
			this.quantityFilled = quantityFilled;
			this.pricePerItem = pricePerItem;
			this.recommendedSellPrice = recommendedSellPrice;
			this.slot = slot;
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		log.info("Flip Smart started!");
		overlayManager.add(geOverlay);
		mouseManager.registerMouseListener(overlayMouseListener);
		
		// Initialize Flip Finder panel
		if (config.showFlipFinder())
		{
			initializeFlipFinderPanel();
		}

		// Start auto-refresh timer for flip finder
		startFlipFinderRefreshTimer();
		
		// Note: Cash stack and RSN will be synced when player logs in via onGameStateChanged
		// Don't access client data during startup - must be on client thread
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Flip Smart stopped!");
		overlayManager.remove(geOverlay);
		mouseManager.unregisterMouseListener(overlayMouseListener);
		
		// Remove flip finder panel
		if (flipFinderNavButton != null)
		{
			clientToolbar.removeNavigation(flipFinderNavButton);
		}
		
		// Stop auto-refresh timer
		stopFlipFinderRefreshTimer();
		
		// Clear API client cache
		apiClient.clearCache();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState gameState = gameStateChanged.getGameState();
		
		// Track login/hopping to avoid recording existing GE offers
		if (gameState == GameState.LOGGING_IN || gameState == GameState.HOPPING || gameState == GameState.CONNECTION_LOST)
		{
			lastLoginTick = client.getTickCount();
			offlineSyncCompleted = false;
			// Note: Don't clear collectedItemIds here - we'll restore them after RSN is known
			log.debug("Login state change detected, setting lastLoginTick to {}", lastLoginTick);
		}
		
		// Persist offer state when logging out
		if (gameState == GameState.LOGIN_SCREEN)
		{
			persistOfferState();
		}
		
		if (gameState == GameState.LOGGED_IN)
		{
			log.info("Player logged in");
			syncRSN();
			updateCashStack();
			
			// Restore collected items from config (items bought but not yet sold)
			// Must be after syncRSN() so we have the correct RSN for the config key
			restoreCollectedItems();
			
			// Schedule offline sync after a delay to ensure all GE events have been processed
			// This must run AFTER syncRSN() so we have the correct RSN for the config key
			if (!offlineSyncCompleted)
			{
				javax.swing.Timer syncTimer = new javax.swing.Timer(2000, e -> syncOfflineFills());
				syncTimer.setRepeats(false);
				syncTimer.start();
			}
			
			// Refresh flip finder with current cash stack
			if (flipFinderPanel != null)
			{
				flipFinderPanel.refresh();
			}
		}
	}
	
	/**
	 * Restore collected item IDs from persisted config.
	 * These are items that were bought but not yet sold when the player logged out.
	 */
	private void restoreCollectedItems()
	{
		java.util.Set<Integer> persisted = loadPersistedCollectedItems();
		if (!persisted.isEmpty())
		{
			collectedItemIds.clear();
			collectedItemIds.addAll(persisted);
			log.info("Restored {} collected items from previous session (active flips)", persisted.size());
		}
		else
		{
			collectedItemIds.clear();
		}
	}
	
	/**
	 * Persist the current GE offer state to config for offline tracking.
	 * Called when the player logs out.
	 * Uses RSN-specific key to support multiple accounts.
	 */
	private void persistOfferState()
	{
		String offersKey = getPersistedOffersKey();
		String collectedKey = getCollectedItemsKey();
		
		// Persist tracked offers
		if (trackedOffers.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, offersKey);
			log.debug("No tracked offers to persist for {}", currentRsn);
		}
		else
		{
			try
			{
				Map<Integer, TrackedOffer> offersToSave = new HashMap<>(trackedOffers);
				String json = gson.toJson(offersToSave);
				configManager.setConfiguration(CONFIG_GROUP, offersKey, json);
				log.info("Persisted {} tracked offers for {} (offline sync)", offersToSave.size(), currentRsn);
			}
			catch (Exception e)
			{
				log.error("Failed to persist offer state for {}: {}", currentRsn, e.getMessage());
			}
		}
		
		// Persist collected item IDs (items bought but not yet sold)
		if (collectedItemIds.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, collectedKey);
			log.debug("No collected items to persist for {}", currentRsn);
		}
		else
		{
			try
			{
				String json = gson.toJson(new java.util.ArrayList<>(collectedItemIds));
				configManager.setConfiguration(CONFIG_GROUP, collectedKey, json);
				log.info("Persisted {} collected item IDs for {} (active flips)", collectedItemIds.size(), currentRsn);
			}
			catch (Exception e)
			{
				log.error("Failed to persist collected items for {}: {}", currentRsn, e.getMessage());
			}
		}
	}
	
	/**
	 * Load previously persisted offer state from config.
	 * Called during login burst to compare with current state.
	 * Uses RSN-specific key to support multiple accounts.
	 */
	private Map<Integer, TrackedOffer> loadPersistedOfferState()
	{
		String key = getPersistedOffersKey();
		
		try
		{
			String json = configManager.getConfiguration(CONFIG_GROUP, key);
			if (json == null || json.isEmpty())
			{
				return new HashMap<>();
			}
			
			Type type = new TypeToken<Map<Integer, TrackedOffer>>(){}.getType();
			Map<Integer, TrackedOffer> offers = gson.fromJson(json, type);
			log.debug("Loaded {} persisted offers for {}", offers != null ? offers.size() : 0, currentRsn);
			return offers != null ? offers : new HashMap<>();
		}
		catch (Exception e)
		{
			log.error("Failed to load persisted offer state for {}: {}", currentRsn, e.getMessage());
			return new HashMap<>();
		}
	}
	
	/**
	 * Sync fills that occurred while offline by comparing persisted state to current state.
	 * Should be called after all login burst offer events have been processed.
	 */
	private void syncOfflineFills()
	{
		if (offlineSyncCompleted)
		{
			return;
		}
		offlineSyncCompleted = true;
		
		Map<Integer, TrackedOffer> persistedOffers = loadPersistedOfferState();
		if (persistedOffers.isEmpty())
		{
			log.debug("No persisted offers to compare for offline sync");
			return;
		}
		
		log.info("Checking {} persisted offers against {} current offers for offline fills",
			persistedOffers.size(), trackedOffers.size());
		
		for (Map.Entry<Integer, TrackedOffer> entry : trackedOffers.entrySet())
		{
			int slot = entry.getKey();
			TrackedOffer currentOffer = entry.getValue();
			TrackedOffer persistedOffer = persistedOffers.get(slot);
			
			if (persistedOffer == null)
			{
				// New offer placed while offline (unlikely but possible)
				continue;
			}
			
			// Check if the same item in the same slot
			if (persistedOffer.itemId != currentOffer.itemId)
			{
				log.debug("Slot {} has different item (was {}, now {}), skipping offline sync for this slot",
					slot, persistedOffer.itemId, currentOffer.itemId);
				continue;
			}
			
			// Check if more items were sold while offline
			int offlineFills = currentOffer.previousQuantitySold - persistedOffer.previousQuantitySold;
			if (offlineFills > 0)
			{
				log.info("Detected {} offline fills for {} (slot {}): {} -> {}",
					offlineFills,
					currentOffer.itemName,
					slot,
					persistedOffer.previousQuantitySold,
					currentOffer.previousQuantitySold);
				
				// Record the offline transaction
				Integer recommendedSellPrice = currentOffer.isBuy ? recommendedPrices.get(currentOffer.itemId) : null;
				
				apiClient.recordTransactionAsync(
					currentOffer.itemId,
					currentOffer.itemName,
					currentOffer.isBuy,
					offlineFills,
					currentOffer.price,
					slot,
					recommendedSellPrice,
					getCurrentRsnSafe().orElse(null)
				);
			}
		}
		
		// Check for offers that completed (became empty) while offline
		for (Map.Entry<Integer, TrackedOffer> entry : persistedOffers.entrySet())
		{
			int slot = entry.getKey();
			TrackedOffer persistedOffer = entry.getValue();
			
			if (!trackedOffers.containsKey(slot))
			{
				// This slot is now empty - the offer either completed, was cancelled, or was collected while offline
				// We CANNOT safely assume it completed with all remaining items - it may have been cancelled
				// with only partial fills. The safest approach is to NOT auto-record anything here.
				// The actual fill amount should have been recorded when the items were collected in-game.
				log.info("Slot {} is now empty (was tracking {} x{}). Cannot determine if completed or cancelled offline - skipping auto-record.",
					slot, persistedOffer.itemName, persistedOffer.totalQuantity);
				
				// If this was a buy with some items already filled, add to collected tracking
				// so the user can still sell those items and complete the flip
				if (persistedOffer.isBuy && persistedOffer.previousQuantitySold > 0)
				{
					log.info("Adding {} to collected tracking (had {} items filled before going offline)",
						persistedOffer.itemName, persistedOffer.previousQuantitySold);
					collectedItemIds.add(persistedOffer.itemId);
				}
			}
		}
		
		// Clear persisted state after sync (RSN-specific key)
		configManager.unsetConfiguration(CONFIG_GROUP, getPersistedOffersKey());
		log.info("Offline sync completed for {}", currentRsn);
		
		// Refresh the flip finder panel to show updated data after offline sync
		if (flipFinderPanel != null)
		{
			javax.swing.Timer refreshTimer = new javax.swing.Timer(1000, e -> flipFinderPanel.refresh());
			refreshTimer.setRepeats(false);
			refreshTimer.start();
		}
	}

	
	/**
	 * Sync the player's RSN with the API and store locally
	 */
	private void syncRSN()
	{
		if (client.getLocalPlayer() == null)
		{
			log.warn("syncRSN called but getLocalPlayer() is null");
			return;
		}
		
		String rsn = client.getLocalPlayer().getName();
		if (rsn != null && !rsn.isEmpty())
		{
			currentRsn = rsn;
			log.info("RSN synced: {}", rsn);
			apiClient.updateRSN(rsn);
		}
		else
		{
			log.warn("syncRSN: player name is null or empty");
		}
	}
	
	/**
	 * Get the current RSN, attempting to fetch from client if not cached.
	 * Returns Optional.empty() if RSN cannot be determined.
	 * This ensures callers explicitly handle the case where RSN is unavailable.
	 */
	public Optional<String> getCurrentRsnSafe()
	{
		if (currentRsn != null && !currentRsn.isEmpty())
		{
			return Optional.of(currentRsn);
		}
		
		// Try to get RSN from client if not cached
		if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null)
		{
			currentRsn = client.getLocalPlayer().getName();
			log.info("RSN fetched from client on-demand: {}", currentRsn);
			return Optional.of(currentRsn);
		}
		
		log.warn("Unable to determine RSN - transactions will be recorded without RSN");
		return Optional.empty();
	}
	
	/**
	 * Get the RSN-specific config key for persisted offers
	 */
	private String getPersistedOffersKey()
	{
		if (currentRsn == null || currentRsn.isEmpty())
		{
			return PERSISTED_OFFERS_KEY_PREFIX + "unknown";
		}
		return PERSISTED_OFFERS_KEY_PREFIX + currentRsn;
	}
	
	private String getCollectedItemsKey()
	{
		if (currentRsn == null || currentRsn.isEmpty())
		{
			return COLLECTED_ITEMS_KEY_PREFIX + "unknown";
		}
		return COLLECTED_ITEMS_KEY_PREFIX + currentRsn;
	}
	
	/**
	 * Load previously persisted collected item IDs from config.
	 * These are items that were bought but not yet sold when the player logged out.
	 */
	private java.util.Set<Integer> loadPersistedCollectedItems()
	{
		String key = getCollectedItemsKey();
		
		try
		{
			String json = configManager.getConfiguration(CONFIG_GROUP, key);
			if (json == null || json.isEmpty())
			{
				return new java.util.HashSet<>();
			}
			
			Type type = new TypeToken<java.util.List<Integer>>(){}.getType();
			java.util.List<Integer> items = gson.fromJson(json, type);
			log.debug("Loaded {} persisted collected items for {}", items != null ? items.size() : 0, currentRsn);
			return items != null ? new java.util.HashSet<>(items) : new java.util.HashSet<>();
		}
		catch (Exception e)
		{
			log.error("Failed to load persisted collected items for {}: {}", currentRsn, e.getMessage());
			return new java.util.HashSet<>();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		// Only process inventory changes
		if (event.getContainerId() != 93) // 93 is the inventory container ID
		{
			return;
		}

		updateCashStack();
	}

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent)
	{
		final int slot = offerEvent.getSlot();
		final GrandExchangeOffer offer = offerEvent.getOffer();

		// Skip if game is not in LOGGED_IN state
		if (client.getGameState() != GameState.LOGGED_IN && offer.getState() == GrandExchangeOfferState.EMPTY)
		{
			return;
		}

		int itemId = offer.getItemId();
		int quantitySold = offer.getQuantitySold();
		int totalQuantity = offer.getTotalQuantity();
		int price = offer.getPrice();
		int spent = offer.getSpent();
		GrandExchangeOfferState state = offer.getState();
		
		// Get item name (must be called on client thread)
		String itemName = itemManager.getItemComposition(itemId).getName();
		
		// Check if this is during the login burst window
		int currentTick = client.getTickCount();
		boolean isLoginBurst = (currentTick - lastLoginTick) <= GE_LOGIN_BURST_WINDOW;
		
		if (isLoginBurst && state != GrandExchangeOfferState.EMPTY)
		{
			// During login, just track existing offers without recording transactions
			log.debug("Login burst: initializing tracking for slot {} with {} items sold", slot, quantitySold);
			
			boolean isBuy = state == GrandExchangeOfferState.BUYING || 
							state == GrandExchangeOfferState.BOUGHT ||
							state == GrandExchangeOfferState.CANCELLED_BUY;
			
			// Track the current state so future changes are detected correctly
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, quantitySold));
			
			// Note: offline sync is now scheduled from LOGGED_IN state change
			// after syncRSN() to ensure correct RSN-specific config key
			return;
		}

		// Check if this is a buy or sell offer
		boolean isBuy = state == GrandExchangeOfferState.BUYING || 
						state == GrandExchangeOfferState.BOUGHT ||
						state == GrandExchangeOfferState.CANCELLED_BUY;
		
		// Handle cancelled offers
		if (state == GrandExchangeOfferState.CANCELLED_BUY || state == GrandExchangeOfferState.CANCELLED_SELL)
		{
			// Only record the cancellation if some items were actually filled
			if (quantitySold > 0)
			{
				TrackedOffer previousOffer = trackedOffers.get(slot);
				
				// Check if we have any unfilled items that need to be recorded as cancelled
				if (previousOffer != null && quantitySold > previousOffer.previousQuantitySold)
				{
					// Record the final partial fill before cancellation
					int newQuantity = quantitySold - previousOffer.previousQuantitySold;
					int pricePerItem = spent / quantitySold;

					log.info("Recording final transaction before cancellation: {} {} x{} @ {} gp each",
						isBuy ? "BUY" : "SELL",
						previousOffer.itemName,
						newQuantity,
						pricePerItem);

					// Get recommended sell price if available
					Integer recommendedSellPrice = isBuy ? recommendedPrices.get(itemId) : null;
					
					apiClient.recordTransactionAsync(
						itemId,
						previousOffer.itemName,
						isBuy,
						newQuantity,
						pricePerItem,
						slot,
						recommendedSellPrice,
						getCurrentRsnSafe().orElse(null)
					);
				}
				
				log.info("Order cancelled: {} {} - {} items filled out of {}",
					isBuy ? "BUY" : "SELL",
					previousOffer != null ? previousOffer.itemName : itemName,
					quantitySold,
					totalQuantity);
			}
			else
			{
				TrackedOffer previousOffer = trackedOffers.get(slot);
				log.info("Order cancelled with no fills: {} {}",
					isBuy ? "BUY" : "SELL",
					previousOffer != null ? previousOffer.itemName : itemName);
			}
			
			// For cancelled BUY orders with partial fills, track the items as collected
			// so they still show as active flips until the user sells them
			if (isBuy && quantitySold > 0)
			{
				log.info("Cancelled buy order had {} items filled - tracking until sold", quantitySold);
				collectedItemIds.add(itemId);
				
				// Refresh panel to show the flip is still active
				if (flipFinderPanel != null)
				{
					javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refreshActiveFlips());
				}
			}
			
			// Clean up tracked offer
			trackedOffers.remove(slot);
			return;
		}
		
		// Handle empty state (offer collected/cleared)
		if (state == GrandExchangeOfferState.EMPTY)
		{
			TrackedOffer collectedOffer = trackedOffers.remove(slot);
			
			// Track collected buy offers so they still show as active flips until sold
			if (collectedOffer != null && collectedOffer.isBuy && collectedOffer.previousQuantitySold > 0)
			{
				log.info("Buy offer collected from GE: {} x{} - tracking until sold", 
					collectedOffer.itemName, collectedOffer.previousQuantitySold);
				collectedItemIds.add(collectedOffer.itemId);
				
				// Refresh panel to show updated state
				if (flipFinderPanel != null)
				{
					javax.swing.Timer refreshTimer = new javax.swing.Timer(500, e -> flipFinderPanel.refresh());
					refreshTimer.setRepeats(false);
					refreshTimer.start();
				}
			}
			return;
		}

		// Get the previously tracked offer for this slot
		TrackedOffer previousOffer = trackedOffers.get(slot);

		// Detect if quantity sold has increased (partial or full fill)
		if (quantitySold > 0)
		{
			int newQuantity = 0;

			if (previousOffer != null)
			{
				// Calculate how many items were just sold/bought
				newQuantity = quantitySold - previousOffer.previousQuantitySold;
			}
			else
			{
				// First time seeing this offer with sold items
				newQuantity = quantitySold;
			}

			// Record transaction if we have new items
			if (newQuantity > 0)
			{
				// Calculate the actual price per item from the spent amount
				int pricePerItem = spent / quantitySold;

				log.info("Recording transaction: {} {} x{} @ {} gp each (slot {}, {}/{})",
					isBuy ? "BUY" : "SELL",
					itemName,
					newQuantity,
					pricePerItem,
					slot,
					quantitySold,
					totalQuantity);

				// Get recommended sell price if this was a buy from a recommendation
				Integer recommendedSellPrice = isBuy ? recommendedPrices.get(itemId) : null;
				
				// Record the transaction asynchronously
				apiClient.recordTransactionAsync(
					itemId,
					itemName,
					isBuy,
					newQuantity,
					pricePerItem,
					slot,
					recommendedSellPrice,
					getCurrentRsnSafe().orElse(null)
				);
				
				// Clear recommended price after recording (only for buys)
				if (isBuy && recommendedSellPrice != null)
				{
					recommendedPrices.remove(itemId);
				}
				
				// If this was a sell, remove from collected tracking
				if (!isBuy)
				{
					markItemSold(itemId);
				}

				// Refresh active flips panel if it exists
				// Use a Swing Timer to add a small delay without blocking the EDT
				if (flipFinderPanel != null)
				{
					javax.swing.Timer refreshTimer = new javax.swing.Timer(500, e -> {
						// This will update both pending orders and active flips
						flipFinderPanel.refresh();
					});
					refreshTimer.setRepeats(false);
					refreshTimer.start();
				}
			}

			// Update tracked offer
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, quantitySold));
		}
		else
		{
			// New offer with no items sold yet, track it
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, 0));
			
			// Refresh the flip finder panel when any new order is submitted
			// This ensures sell orders show up immediately in active flips
			if (previousOffer == null && flipFinderPanel != null)
			{
				javax.swing.SwingUtilities.invokeLater(() -> {
					flipFinderPanel.updatePendingOrders(getPendingBuyOrders());
					// Also refresh active flips to pick up new sell orders
					flipFinderPanel.refreshActiveFlips();
				});
			}
		}
	}

	/**
	 * Initialize the Flip Finder panel and add it to the sidebar
	 */
	private void initializeFlipFinderPanel()
	{
		flipFinderPanel = new FlipFinderPanel(config, apiClient, itemManager, this, configManager)
		{
			@Override
			protected Integer getCashStack()
			{
				return currentCashStack > 0 ? currentCashStack : null;
			}
		};

		// Try to load custom icon from resources
		java.awt.image.BufferedImage iconImage = null;
		try
		{
			iconImage = net.runelite.client.util.ImageUtil.loadImageResource(getClass(), "/flip_finder_icon.png");
		}
		catch (Exception e)
		{
			log.debug("Could not load flip finder icon, using default icon");
		}

		// If custom icon not found, create a default one
		if (iconImage == null)
		{
			iconImage = createDefaultIcon();
		}

		// Create navigation button
		flipFinderNavButton = net.runelite.client.ui.NavigationButton.builder()
			.tooltip("Flip Finder")
			.icon(iconImage)
			.priority(7)
			.panel(flipFinderPanel)
			.build();

		clientToolbar.addNavigation(flipFinderNavButton);
		log.info("Flip Finder panel initialized");
	}

	/**
	 * Create a default icon for the Flip Finder button
	 */
	private java.awt.image.BufferedImage createDefaultIcon()
	{
		// Create a simple default icon
		java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(16, 16, java.awt.image.BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g = image.createGraphics();
		g.setColor(java.awt.Color.ORANGE);
		g.fillRect(2, 2, 12, 12);
		g.setColor(java.awt.Color.WHITE);
		g.drawString("F", 5, 12);
		g.dispose();
		return image;
	}

	/**
	 * Update the player's current cash stack from inventory
	 */
	private void updateCashStack()
	{
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory == null)
		{
			currentCashStack = 0;
			return;
		}

		int totalCash = 0;
		Item[] items = inventory.getItems();

		// Item IDs for coins
		final int COINS_995 = 995;

		for (Item item : items)
		{
			if (item.getId() == COINS_995)
			{
				totalCash += item.getQuantity();
			}
		}

		if (totalCash != currentCashStack)
		{
			currentCashStack = totalCash;
			log.debug("Updated cash stack: {}", currentCashStack);

			// If cash stack changed significantly and we have a flip finder panel, refresh it
			if (flipFinderPanel != null && totalCash > 100_000)
			{
				// Only auto-refresh if it's been more than 30 seconds since last refresh
				long now = System.currentTimeMillis();
				if (now - lastFlipFinderRefresh > 30_000)
				{
					lastFlipFinderRefresh = now;
					flipFinderPanel.refresh();
				}
			}
		}
	}

	/**
	 * Start the auto-refresh timer for flip finder
	 */
	private void startFlipFinderRefreshTimer()
	{
		if (flipFinderRefreshTimer != null)
		{
			flipFinderRefreshTimer.cancel();
		}

		flipFinderRefreshTimer = new java.util.Timer("FlipFinderRefreshTimer", true);
		
		// Schedule refresh based on config
		int refreshMinutes = Math.max(1, Math.min(60, config.flipFinderRefreshMinutes()));
		long refreshIntervalMs = refreshMinutes * 60 * 1000L;

		flipFinderRefreshTimer.scheduleAtFixedRate(new java.util.TimerTask()
		{
			@Override
			public void run()
			{
				if (flipFinderPanel != null && config.showFlipFinder())
				{
					javax.swing.SwingUtilities.invokeLater(() ->
					{
						log.debug("Auto-refreshing flip finder");
						lastFlipFinderRefresh = System.currentTimeMillis();
						flipFinderPanel.refresh();
					});
				}
			}
		}, refreshIntervalMs, refreshIntervalMs);

		log.info("Flip Finder auto-refresh started (every {} minutes)", refreshMinutes);
	}

	/**
	 * Stop the auto-refresh timer for flip finder
	 */
	private void stopFlipFinderRefreshTimer()
	{
		if (flipFinderRefreshTimer != null)
		{
			flipFinderRefreshTimer.cancel();
			flipFinderRefreshTimer = null;
			log.info("Flip Finder auto-refresh stopped");
		}
	}

	@Provides
	FlipSmartConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FlipSmartConfig.class);
	}
	
	// Mouse listener for GE overlay clicks
	private final MouseListener overlayMouseListener = new MouseListener()
	{
		@Override
		public java.awt.event.MouseEvent mouseClicked(java.awt.event.MouseEvent e)
		{
			// Get the overlay bounds
			Rectangle overlayBounds = geOverlay.getBounds();
			if (overlayBounds == null)
			{
				return e;
			}
			
			// Convert absolute click to relative coordinates
			Point relativeClick = new Point(
				e.getX() - overlayBounds.x,
				e.getY() - overlayBounds.y
			);
			
			// Check if click is on the collapse button
			Rectangle buttonBounds = geOverlay.getCollapseButtonBounds();
			if (buttonBounds.contains(relativeClick))
			{
				geOverlay.toggleCollapse();
				e.consume();
			}
			
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mousePressed(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseReleased(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseEntered(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseExited(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseDragged(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseMoved(java.awt.event.MouseEvent e)
		{
			return e;
		}
	};
}


package com.flipsmart;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.function.Function;

@Slf4j
@Singleton
public class FlipSmartApiClient
{
	private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
	private static final String PRODUCTION_API_URL = "https://api.flipsm.art";
	
	private final OkHttpClient httpClient;
	private final Gson gson;
	private final FlipSmartConfig config;
	
	// Cache to avoid spamming the API
	private final Map<Integer, CachedAnalysis> analysisCache = new ConcurrentHashMap<>();
	private static final long CACHE_DURATION_MS = 180_000; // 3 minute cache
	
	// JWT token management
	private volatile String jwtToken = null;
	private volatile long tokenExpiry = 0;
	
	// Lock for authentication to prevent concurrent auth attempts
	private final Object authLock = new Object();

	@Inject
	public FlipSmartApiClient(FlipSmartConfig config, Gson gson, OkHttpClient okHttpClient)
	{
		this.config = config;
		// Use the injected Gson's builder to create a customized instance
		this.gson = gson.newBuilder().create();
		// Use the injected OkHttpClient directly as required by RuneLite
		this.httpClient = okHttpClient;
	}

	/**
	 * Get the API URL to use. Returns the configured override URL if set,
	 * otherwise returns the production URL.
	 */
	private String getApiUrl()
	{
		String configuredUrl = config.apiUrl();
		if (configuredUrl == null || configuredUrl.isEmpty())
		{
			return PRODUCTION_API_URL;
		}
		return configuredUrl;
	}

	/**
	 * Authentication result with status and message
	 */
	public static class AuthResult
	{
		public final boolean success;
		public final String message;
		
		public AuthResult(boolean success, String message)
		{
			this.success = success;
			this.message = message;
		}
	}
	
	/**
	 * Execute an HTTP request asynchronously with automatic retry on 401
	 * This is the core method that handles all HTTP requests off the main threads
	 * 
	 * @param request The request to execute
	 * @param responseHandler Function to process successful response body and return result
	 * @param errorHandler Consumer to handle errors
	 * @param retryOnAuth Whether to retry with re-authentication on 401
	 * @param <T> The return type
	 * @return CompletableFuture with the result
	 */
	private <T> CompletableFuture<T> executeAsync(Request request, Function<String, T> responseHandler, 
												   Consumer<String> errorHandler, boolean retryOnAuth)
	{
		CompletableFuture<T> future = new CompletableFuture<>();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("Request failed: {}", e.getMessage());
				if (errorHandler != null)
				{
					errorHandler.accept("Connection error: " + e.getMessage());
				}
				future.complete(null);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (response.code() == 401 && retryOnAuth)
					{
						// Token might have expired, try to re-authenticate
						log.debug("Received 401, attempting to re-authenticate");
						jwtToken = null;
						
						authenticateAsync().thenAccept(authSuccess ->
						{
							if (authSuccess)
							{
								// Rebuild request with new token
								Request retryRequest = request.newBuilder()
									.header("Authorization", "Bearer " + jwtToken)
									.build();
								
								// Retry without auth retry to prevent infinite loop
								executeAsync(retryRequest, responseHandler, errorHandler, false)
									.thenAccept(future::complete);
							}
							else
							{
								future.complete(null);
							}
						});
						return;
					}
					
					if (!response.isSuccessful())
					{
						log.debug("Request returned error: {}", response.code());
						if (errorHandler != null)
						{
							errorHandler.accept("Error " + response.code());
						}
						future.complete(null);
						return;
					}

					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					T result = responseHandler.apply(jsonData);
					future.complete(result);
				}
				catch (Exception e)
				{
					log.debug("Error processing response: {}", e.getMessage());
					future.complete(null);
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Execute an authenticated request asynchronously
	 */
	private <T> CompletableFuture<T> executeAuthenticatedAsync(Request.Builder requestBuilder,
															   Function<String, T> responseHandler)
	{
		return ensureAuthenticatedAsync().thenCompose(authenticated ->
		{
			if (!authenticated)
			{
				log.debug("Failed to authenticate");
				return CompletableFuture.completedFuture(null);
			}
			
			Request request = requestBuilder
				.header("Authorization", "Bearer " + jwtToken)
				.build();
			
			return executeAsync(request, responseHandler, null, true);
		});
	}
	
	/**
	 * Authenticate with the API and obtain a JWT token via login (async)
	 */
	private CompletableFuture<Boolean> authenticateAsync()
	{
		return loginAsync(config.email(), config.password())
			.thenApply(result -> result.success);
	}
	
	/**
	 * Login with email and password (async)
	 * @return CompletableFuture with AuthResult containing success status and message
	 */
	public CompletableFuture<AuthResult> loginAsync(String email, String password)
	{
		CompletableFuture<AuthResult> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		
		if (email == null || email.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your email address"));
			return future;
		}
		
		if (password == null || password.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your password"));
			return future;
		}
		
		String url = String.format("%s/auth/login", apiUrl);
		
		// Create JSON body with email and password
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("email", email);
		jsonBody.addProperty("password", password);
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request request = new Request.Builder()
			.url(url)
			.post(body)
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Failed to authenticate with API: {}", e.getMessage());
				future.complete(new AuthResult(false, "Connection error: " + e.getMessage()));
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (!response.isSuccessful())
					{
						if (response.code() == 401)
						{
							future.complete(new AuthResult(false, "Incorrect email or password"));
						}
						else if (response.code() == 404)
						{
							future.complete(new AuthResult(false, "Account not found. Please sign up first."));
						}
						else
						{
							future.complete(new AuthResult(false, "Login failed (error " + response.code() + ")"));
						}
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject tokenResponse = gson.fromJson(jsonData, JsonObject.class);
					
					synchronized (authLock)
					{
						jwtToken = tokenResponse.get("access_token").getAsString();
						// JWT tokens from this API expire in 7 days, but we'll check earlier
						// Set expiry to 6 days to refresh before actual expiry
						tokenExpiry = System.currentTimeMillis() + (6 * 24 * 60 * 60 * 1000L);
					}
					
					log.info("Successfully authenticated with API");
					future.complete(new AuthResult(true, "Login successful!"));
				}
				catch (Exception e)
				{
					log.error("Error processing login response: {}", e.getMessage());
					future.complete(new AuthResult(false, "Error processing response"));
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Synchronous login wrapper for backward compatibility
	 * Note: This should only be called from background threads
	 */
	public AuthResult login(String email, String password)
	{
		try
		{
			return loginAsync(email, password).get();
		}
		catch (Exception e)
		{
			log.error("Login failed: {}", e.getMessage());
			return new AuthResult(false, "Login failed: " + e.getMessage());
		}
	}
	
	/**
	 * Sign up a new account with email and password (async)
	 * @return CompletableFuture with AuthResult containing success status and message
	 */
	public CompletableFuture<AuthResult> signupAsync(String email, String password)
	{
		CompletableFuture<AuthResult> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		
		if (email == null || email.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your email address"));
			return future;
		}
		
		if (password == null || password.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your password"));
			return future;
		}
		
		if (password.length() < 6)
		{
			future.complete(new AuthResult(false, "Password must be at least 6 characters"));
			return future;
		}
		
		String url = String.format("%s/auth/signup", apiUrl);
		
		// Create JSON body with email and password
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("email", email);
		jsonBody.addProperty("password", password);
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request request = new Request.Builder()
			.url(url)
			.post(body)
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Failed to sign up with API: {}", e.getMessage());
				future.complete(new AuthResult(false, "Connection error: " + e.getMessage()));
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (!response.isSuccessful())
					{
						if (response.code() == 400)
						{
							future.complete(new AuthResult(false, "Email already registered. Please login instead."));
						}
						else
						{
							future.complete(new AuthResult(false, "Sign up failed (error " + response.code() + ")"));
						}
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject tokenResponse = gson.fromJson(jsonData, JsonObject.class);
					
					synchronized (authLock)
					{
						jwtToken = tokenResponse.get("access_token").getAsString();
						tokenExpiry = System.currentTimeMillis() + (6 * 24 * 60 * 60 * 1000L);
					}
					
					log.info("Successfully signed up and authenticated with API");
					future.complete(new AuthResult(true, "Account created successfully!"));
				}
				catch (Exception e)
				{
					log.error("Error processing signup response: {}", e.getMessage());
					future.complete(new AuthResult(false, "Error processing response"));
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Synchronous signup wrapper for backward compatibility
	 * Note: This should only be called from background threads
	 */
	public AuthResult signup(String email, String password)
	{
		try
		{
			return signupAsync(email, password).get();
		}
		catch (Exception e)
		{
			log.error("Signup failed: {}", e.getMessage());
			return new AuthResult(false, "Signup failed: " + e.getMessage());
		}
	}
	
	/**
	 * Check if currently authenticated
	 */
	public boolean isAuthenticated()
	{
		return jwtToken != null && System.currentTimeMillis() < tokenExpiry;
	}
	
	/**
	 * Clear the current authentication token
	 */
	public void clearAuth()
	{
		synchronized (authLock)
		{
			jwtToken = null;
			tokenExpiry = 0;
		}
	}
	
	/**
	 * Update the user's RuneScape Name on the server (async)
	 */
	public void updateRSN(String rsn)
	{
		if (rsn == null || rsn.isEmpty())
		{
			return;
		}
		
		String apiUrl = getApiUrl();
		String url = String.format("%s/auth/rsn?rsn=%s", apiUrl, rsn);
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.put(RequestBody.create(JSON, ""));
		
		executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			log.info("Successfully updated RSN to: {}", rsn);
			return true;
		}).exceptionally(e ->
		{
			log.debug("Failed to update RSN: {}", e.getMessage());
			return false;
		});
	}
	
	/**
	 * Check if we have a valid JWT token, and refresh if needed (async)
	 */
	private CompletableFuture<Boolean> ensureAuthenticatedAsync()
	{
		// Check if we have a token and it's not expired
		if (jwtToken != null && System.currentTimeMillis() < tokenExpiry)
		{
			return CompletableFuture.completedFuture(true);
		}
		
		// Token is missing or expired, authenticate
		return authenticateAsync();
	}

	/**
	 * Fetch item analysis from the API asynchronously
	 */
	public CompletableFuture<FlipAnalysis> getItemAnalysisAsync(int itemId)
	{
		// Check cache first
		CachedAnalysis cached = analysisCache.get(itemId);
		if (cached != null && !cached.isExpired())
		{
			return CompletableFuture.completedFuture(cached.getAnalysis());
		}

		String apiUrl = getApiUrl();
		String url = String.format("%s/analysis/%d?timeframe=1h", apiUrl, itemId);
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			FlipAnalysis analysis = gson.fromJson(jsonData, FlipAnalysis.class);
			removedExpiredCacheEntries();
			analysisCache.put(itemId, new CachedAnalysis(analysis));
			return analysis;
		});
	}

	/**
	 * Fetch flip recommendations from the API asynchronously
	 */
	public CompletableFuture<FlipFinderResponse> getFlipRecommendationsAsync(Integer cashStack, String flipStyle, int limit)
	{
		String apiUrl = getApiUrl();
		
		// Build URL with query parameters
		StringBuilder urlBuilder = new StringBuilder();
		urlBuilder.append(String.format("%s/flip-finder?limit=%d&flip_style=%s", apiUrl, limit, flipStyle));
		
		if (cashStack != null)
		{
			urlBuilder.append(String.format("&cash_stack=%d", cashStack));
		}
		
		String url = urlBuilder.toString();
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, FlipFinderResponse.class));
	}

	/**
	 * Record a Grand Exchange transaction asynchronously
	 */
	public CompletableFuture<Void> recordTransactionAsync(int itemId, String itemName, boolean isBuy, 
														  int quantity, int pricePerItem, Integer geSlot, 
														  Integer recommendedSellPrice, String rsn)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/transactions", apiUrl);
		
		// Create JSON body
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("item_id", itemId);
		jsonBody.addProperty("item_name", itemName);
		jsonBody.addProperty("is_buy", isBuy);
		jsonBody.addProperty("quantity", quantity);
		jsonBody.addProperty("price_per_item", pricePerItem);
		if (geSlot != null)
		{
			jsonBody.addProperty("ge_slot", geSlot);
		}
		if (recommendedSellPrice != null)
		{
			jsonBody.addProperty("recommended_sell_price", recommendedSellPrice);
		}
		if (rsn != null && !rsn.isEmpty())
		{
			jsonBody.addProperty("rsn", rsn);
		}
		
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(body);
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			JsonObject responseObj = gson.fromJson(jsonData, JsonObject.class);
			log.info("Transaction recorded for {}: {}", rsn, responseObj.get("message").getAsString());
			return null;
		}).thenApply(v -> null);
	}

	/**
	 * Fetch active flips from the API asynchronously
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<ActiveFlipsResponse> getActiveFlipsAsync(String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/transactions/active-flips?rsn=%s", apiUrl, rsn);
		}
		else
		{
			url = String.format("%s/transactions/active-flips", apiUrl);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, ActiveFlipsResponse.class));
	}
	
	/**
	 * Fetch active flips from the API asynchronously (all RSNs)
	 */
	public CompletableFuture<ActiveFlipsResponse> getActiveFlipsAsync()
	{
		return getActiveFlipsAsync(null);
	}

	/**
	 * Dismiss an active flip asynchronously
	 */
	public CompletableFuture<Boolean> dismissActiveFlipAsync(int itemId)
	{
		return dismissActiveFlipAsync(itemId, null);
	}
	
	/**
	 * Dismiss an active flip asynchronously with RSN support
	 * @param itemId The item ID to dismiss
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<Boolean> dismissActiveFlipAsync(int itemId, String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/transactions/active-flips/%d?rsn=%s", apiUrl, itemId, rsn);
		}
		else
		{
			url = String.format("%s/transactions/active-flips/%d", apiUrl, itemId);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.delete();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			log.info("Successfully dismissed active flip for item {}", itemId);
			return true;
		}).exceptionally(e ->
		{
			log.warn("Failed to dismiss active flip: {}", e.getMessage());
			return false;
		});
	}

	/**
	 * Fetch completed flips from the API asynchronously
	 * @param limit Maximum number of flips to return
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<CompletedFlipsResponse> getCompletedFlipsAsync(int limit, String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/flips/completed?limit=%d&rsn=%s", apiUrl, limit, rsn);
		}
		else
		{
			url = String.format("%s/flips/completed?limit=%d", apiUrl, limit);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, CompletedFlipsResponse.class));
	}
	
	/**
	 * Fetch completed flips from the API asynchronously (all RSNs)
	 */
	public CompletableFuture<CompletedFlipsResponse> getCompletedFlipsAsync(int limit)
	{
		return getCompletedFlipsAsync(limit, null);
	}

	/**
	 * Clear the analysis cache
	 */
	public void clearCache()
	{
		analysisCache.clear();
	}

	/**
	 * Remove a specific item from the cache
	 */
	public void invalidateCache(int itemId)
	{
		analysisCache.remove(itemId);
	}

	/**
	 * Removes expired entries from the cache
	 */
	private void removedExpiredCacheEntries()
	{
		analysisCache.entrySet().removeIf(entry -> entry.getValue().isExpired());
	}

	/**
	 * Inner class to store cached analysis with timestamp
	 */
	private static class CachedAnalysis
	{
		private final FlipAnalysis analysis;
		private final long timestamp;

		public CachedAnalysis(FlipAnalysis analysis)
		{
			this.analysis = analysis;
			this.timestamp = System.currentTimeMillis();
		}

		public FlipAnalysis getAnalysis()
		{
			return analysis;
		}

		public boolean isExpired()
		{
			return System.currentTimeMillis() - timestamp > CACHE_DURATION_MS;
		}
	}
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Represents a completed flip (matched buy/sell pair)
 */
@Data
public class CompletedFlip
{
	@SerializedName("id")
	private int id;

	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	@SerializedName("quantity")
	private int quantity;

	@SerializedName("buy_price_per_item")
	private int buyPricePerItem;

	@SerializedName("buy_total")
	private int buyTotal;

	@SerializedName("buy_time")
	private String buyTime;

	@SerializedName("sell_price_per_item")
	private int sellPricePerItem;

	@SerializedName("sell_total")
	private int sellTotal;

	@SerializedName("sell_time")
	private String sellTime;

	@SerializedName("gross_profit")
	private int grossProfit;

	@SerializedName("ge_tax")
	private int geTax;

	@SerializedName("net_profit")
	private int netProfit;

	@SerializedName("roi_percent")
	private double roiPercent;

	@SerializedName("flip_duration_seconds")
	private int flipDurationSeconds;

	@SerializedName("is_successful")
	private boolean isSuccessful;
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

/**
 * Response from the active flips API endpoint
 */
@Data
public class ActiveFlipsResponse
{
	@SerializedName("active_flips")
	private List<ActiveFlip> activeFlips;

	@SerializedName("total_items")
	private int totalItems;

	@SerializedName("total_invested")
	private int totalInvested;
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

@Data
public class FlipFinderResponse
{
	@SerializedName("flip_style")
	private String flipStyle;

	@SerializedName("cash_stack")
	private Integer cashStack;

	@SerializedName("per_slot_budget")
	private Double perSlotBudget;

	@SerializedName("total_items_analyzed")
	private int totalItemsAnalyzed;

	@SerializedName("items_matching_criteria")
	private int itemsMatchingCriteria;

	private List<FlipRecommendation> recommendations;
}


package com.flipsmart;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlipSmartPlugin.class);
		RuneLite.main(args);
	}
}
