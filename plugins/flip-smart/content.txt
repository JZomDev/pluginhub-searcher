package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Represents a market dump event from the Flip Smart API.
 * A dump is a sudden price drop (≥5%) with high trading volume.
 */
@Data
public class DumpEvent
{
	/**
	 * Unique identifier for this dump event
	 */
	private int id;

	/**
	 * OSRS item ID
	 */
	@SerializedName("item_id")
	private int itemId;

	/**
	 * Item name
	 */
	@SerializedName("item_name")
	private String itemName;

	/**
	 * Price before the dump
	 */
	@SerializedName("previous_price")
	private int previousPrice;

	/**
	 * Price after the dump (current instant-sell price)
	 */
	@SerializedName("current_price")
	private int currentPrice;

	/**
	 * Percentage drop (e.g., 5.5 for a 5.5% drop)
	 */
	@SerializedName("price_drop_percent")
	private double priceDropPercent;

	/**
	 * Type of price change: "dump" (decrease) or "pump" (increase)
	 */
	@SerializedName("price_change_type")
	private String priceChangeType;

	/**
	 * Current instant-sell price (buy price for players)
	 */
	@SerializedName("buy_price")
	private int buyPrice;

	/**
	 * Current instant-buy price (sell price for players)
	 */
	@SerializedName("sell_price")
	private int sellPrice;

	/**
	 * Net margin after GE tax
	 */
	private int margin;

	/**
	 * 1-hour average price (may be null)
	 */
	@SerializedName("price_1h_avg")
	private Integer price1hAvg;

	/**
	 * 24-hour average price (may be null)
	 */
	@SerializedName("price_24h_avg")
	private Integer price24hAvg;

	/**
	 * Estimated 24-hour trading volume
	 */
	@SerializedName("volume_24h")
	private int volume24h;

	/**
	 * GE buy limit for this item (may be null)
	 */
	@SerializedName("buy_limit")
	private Integer buyLimit;

	/**
	 * Estimated profit (margin × buy_limit, may be null)
	 */
	@SerializedName("estimated_profit")
	private Integer estimatedProfit;

	/**
	 * When the dump was detected (ISO 8601 timestamp string)
	 */
	@SerializedName("dump_detected_at")
	private String dumpDetectedAt;

	/**
	 * Format the dump as a chat message
	 */
	public String toChatMessage()
	{
		String profitStr = estimatedProfit != null
			? String.format("~%s", formatGP(estimatedProfit))
			: "Unknown";

		String eventType = "pump".equalsIgnoreCase(priceChangeType) ? "PUMP" : "DUMP";
		String changeSymbol = "pump".equalsIgnoreCase(priceChangeType) ? "+" : "-";

		return String.format(
			"%s: %s (%s%.1f%%) - Buy: %s | Sell: %s | Limit: %s | Profit: %s",
			eventType,
			itemName,
			changeSymbol,
			priceDropPercent,
			formatGP(buyPrice),
			formatGP(sellPrice),
			buyLimit != null ? String.format("%,d", buyLimit) : "Unknown",
			profitStr
		);
	}

	/**
	 * Format GP with commas
	 */
	private static String formatGP(int value)
	{
		return String.format("%,d", value);
	}
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Response from checking bank snapshot rate limit status
 */
@Data
public class BankSnapshotStatusResponse
{
	@SerializedName("can_snapshot")
	private boolean canSnapshot;

	@SerializedName("next_snapshot_available")
	private String nextSnapshotAvailable;

	@SerializedName("hours_until_available")
	private Double hoursUntilAvailable;

	private String message;
}

package com.flipsmart;

import net.runelite.api.Client;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.Player;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayMenuEntry;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;

import static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;
import static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;

/**
 * In-game overlay that displays all 8 Grand Exchange offer slots with real-time status.
 * Hidden when the player is at the Grand Exchange area, shown everywhere else.
 */
public class GrandExchangeOverlay extends Overlay
{
	private static final DecimalFormat PERCENTAGE_FORMAT = new DecimalFormat("0");
	private static final DecimalFormat PRICE_FORMAT = new DecimalFormat("#,###");
	
	// String constants
	private static final String OVERLAY_TITLE = "Exchange Viewer";
	private static final String NO_OFFERS_MESSAGE = "No offers";
	
	// Grand Exchange region ID
	private static final int GE_REGION_ID = 12598;
	
	private static final Color COLOR_BUY = new Color(0, 128, 0);  // Dark green
	private static final Color COLOR_SELL = new Color(180, 0, 0); // Dark red
	private static final Color COLOR_COMPLETE = new Color(200, 180, 50); // Gold
	private static final Color COLOR_EMPTY = new Color(128, 128, 128); // Gray
	private static final Color COLOR_CANCELLED = new Color(200, 100, 0); // Orange
	private static final Color COLOR_BACKGROUND = new Color(62, 53, 41); // Dark brown (GE style)
	private static final Color COLOR_BORDER = new Color(0, 0, 0); // Black
	private static final Color COLOR_TEXT = new Color(255, 255, 255); // White
	private static final Color COLOR_TITLE = new Color(255, 215, 0); // Gold
	
	private static final Color COLOR_DIVIDER = new Color(90, 80, 65); // Brown divider
	private static final Color COLOR_PROGRESS_BG = new Color(40, 35, 28); // Dark progress bar background
	private static final Color COLOR_PROGRESS_BORDER = new Color(20, 18, 15); // Progress bar border
	
	private static final int PADDING = 8;
	private static final int LINE_HEIGHT = 17;
	private static final int ICON_SIZE = 32;
	private static final int PROGRESS_BAR_WIDTH = 60;
	private static final int PROGRESS_BAR_HEIGHT = 14;
	private static final int MAX_ITEM_NAME_LENGTH = 12;
	
	// Compact mode constants
	private static final int COMPACT_LINE_HEIGHT = 14;
	private static final int COMPACT_ICON_SIZE = 18;
	
	private final Client client;
	private final FlipSmartConfig config;
	private final ItemManager itemManager;
	
	private boolean isCollapsed = false;
	private Rectangle collapseButtonBounds = new Rectangle();

	@Inject
	private GrandExchangeOverlay(Client client, FlipSmartConfig config, ItemManager itemManager)
	{
		this.client = client;
		this.config = config;
		this.itemManager = itemManager;
		
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.MED);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setMovable(true);
		setResizable(false);
		
		getMenuEntries().add(new OverlayMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, OVERLAY_TITLE));
	}
	
	/**
	 * Check if the player is at the Grand Exchange area.
	 */
	private boolean isAtGrandExchange()
	{
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null)
		{
			return false;
		}
		
		// Get player's current region ID
		int regionId = localPlayer.getWorldLocation().getRegionID();
		return regionId == GE_REGION_ID;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.showGEOverlay())
		{
			return null;
		}
		
		// Hide when player is at the Grand Exchange area
		if (isAtGrandExchange())
		{
			return null;
		}
		
		GrandExchangeOffer[] offers = client.getGrandExchangeOffers();
		
		// GE offers may be null if player hasn't opened GE this session
		// In that case, don't show overlay
		if (offers == null)
		{
			return null;
		}
		
		// Use RuneLite's font for crisp rendering
		graphics.setFont(FontManager.getRunescapeFont());
		
		// Enable proper anti-aliasing
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		graphics.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		
		// Render based on display size mode
		switch (config.exchangeViewerSize())
		{
			case COMPACT:
				return renderCompact(graphics, offers);
			case FULL:
			default:
				return renderFull(graphics, offers);
		}
	}
	
	/**
	 * Render the full-size overlay (original layout).
	 */
	private Dimension renderFull(Graphics2D graphics, GrandExchangeOffer[] offers)
	{
		int textWidth = 200;
		int totalWidth = textWidth + (PADDING * 2);
		
		int x = 0;
		int y = 0;
		int currentY = y + PADDING + LINE_HEIGHT;
		
		// If collapsed, only show the header
		if (isCollapsed)
		{
			int collapsedHeight = LINE_HEIGHT + (PADDING * 2) + 4;
			
			// Draw background
			graphics.setColor(COLOR_BACKGROUND);
			graphics.fillRect(x, y, totalWidth, collapsedHeight);
			
			// Draw border
			graphics.setColor(COLOR_BORDER);
			graphics.drawRect(x, y, totalWidth, collapsedHeight);
			graphics.drawRect(x + 1, y + 1, totalWidth - 2, collapsedHeight - 2);
			
			// Draw centered title
			graphics.setFont(FontManager.getRunescapeBoldFont());
			FontMetrics metrics = graphics.getFontMetrics();
			int titleX = x + (totalWidth - metrics.stringWidth(OVERLAY_TITLE)) / 2;
			graphics.setColor(Color.BLACK);
			graphics.drawString(OVERLAY_TITLE, titleX + 1, currentY + 1);
			graphics.setColor(COLOR_TITLE);
			graphics.drawString(OVERLAY_TITLE, titleX, currentY);
			
			// Set collapse button bounds for the entire header area
			collapseButtonBounds = new Rectangle(x, y, totalWidth, collapsedHeight);
			
			return new Dimension(totalWidth, collapsedHeight);
		}
		
		// Count lines to calculate height (not collapsed)
		int lineCount = 1; // Title
		boolean hasActiveOffers = false;
		int dividerCount = 0;
		
		for (int i = 0; i < offers.length; i++)
		{
			GrandExchangeOffer offer = offers[i];
			if (offer.getState() == GrandExchangeOfferState.EMPTY)
			{
				continue;
			}
			
			hasActiveOffers = true;
			lineCount++; // Slot line
			if (config.showGEItemNames()) lineCount++; // Item name line
			lineCount++; // Progress bar line (always present now)
			
			// Check if there's another non-empty slot for divider
			boolean needsDivider = false;
			for (int nextSlot = i + 1; nextSlot < offers.length; nextSlot++)
			{
				if (offers[nextSlot].getState() != GrandExchangeOfferState.EMPTY)
				{
					needsDivider = true;
					break;
				}
			}
			if (needsDivider)
			{
				dividerCount++;
			}
		}
		
		if (!hasActiveOffers)
		{
			lineCount++; // "No offers" message
		}
		
		int totalHeight = (lineCount * LINE_HEIGHT) + (PADDING * 2);
		totalHeight += dividerCount * 8;
		totalHeight += 4; // Add 4px padding after title
		
		// Draw background with GE-style brown
		graphics.setColor(COLOR_BACKGROUND);
		graphics.fillRect(x, y, totalWidth, totalHeight);
		
		// Draw border
		graphics.setColor(COLOR_BORDER);
		graphics.drawRect(x, y, totalWidth, totalHeight);
		graphics.drawRect(x + 1, y + 1, totalWidth - 2, totalHeight - 2);
		
		// Draw centered title with bold font
		graphics.setFont(FontManager.getRunescapeBoldFont());
		FontMetrics metrics = graphics.getFontMetrics();
		int titleX = x + (totalWidth - metrics.stringWidth(OVERLAY_TITLE)) / 2;
		
		// Draw title shadow
		graphics.setColor(Color.BLACK);
		graphics.drawString(OVERLAY_TITLE, titleX + 1, currentY + 1);
		
		// Draw title text
		graphics.setColor(COLOR_TITLE);
		graphics.drawString(OVERLAY_TITLE, titleX, currentY);
		
		// Set collapse button bounds for the title area
		collapseButtonBounds = new Rectangle(x, y, totalWidth, LINE_HEIGHT + PADDING);
		
		currentY += LINE_HEIGHT;
		currentY += 4; // Add 4px padding after title
		
		// Reset to regular font for content
		graphics.setFont(FontManager.getRunescapeFont());
		
		// Render each slot
		for (int slot = 0; slot < offers.length; slot++)
		{
			GrandExchangeOffer offer = offers[slot];
			
			if (offer.getState() == GrandExchangeOfferState.EMPTY)
			{
				continue;
			}
			
			// Get offer details
			GrandExchangeOfferState state = offer.getState();
			int itemId = offer.getItemId();
			int quantitySold = offer.getQuantitySold();
			int totalQuantity = offer.getTotalQuantity();
			int price = offer.getPrice();
			
			boolean isBuy = state == GrandExchangeOfferState.BUYING || 
							state == GrandExchangeOfferState.BOUGHT ||
							state == GrandExchangeOfferState.CANCELLED_BUY;
			
			double percentage = totalQuantity > 0 ? (quantitySold * 100.0) / totalQuantity : 0;
			String itemName = itemManager.getItemComposition(itemId).getName();
			
			// Determine status color based on offer state
			Color statusColor = getStatusColor(state, isBuy);
			
			// Draw divider BEFORE this item (except for first visible)
			if (slot > 0)
			{
				boolean previousWasVisible = false;
				for (int prevSlot = slot - 1; prevSlot >= 0; prevSlot--)
				{
					if (offers[prevSlot].getState() != GrandExchangeOfferState.EMPTY)
					{
						previousWasVisible = true;
						break;
					}
				}
				
				if (previousWasVisible)
				{
					currentY += -11;
					
					graphics.setColor(COLOR_DIVIDER);
					int dividerX1 = x + PADDING;
					int dividerX2 = x + textWidth + PADDING;
					graphics.drawLine(dividerX1, currentY, dividerX2, currentY);
					
					currentY += 19;
				}
			}
			
			// Line 1: Slot label only
			String slotLabel = (slot + 1) + ". " + (isBuy ? "Buy" : "Sell");
			graphics.setColor(Color.BLACK);
			graphics.drawString(slotLabel, x + PADDING + 1, currentY + 1);
			graphics.setColor(isBuy ? COLOR_BUY : COLOR_SELL);
			graphics.drawString(slotLabel, x + PADDING, currentY);
			currentY += LINE_HEIGHT;
			
			// Line 2: Item name
			if (config.showGEItemNames())
			{
				graphics.setColor(Color.BLACK);
				graphics.drawString(itemName, x + PADDING + 1, currentY + 1);
				graphics.setColor(COLOR_TEXT);
				graphics.drawString(itemName, x + PADDING, currentY);
				currentY += LINE_HEIGHT;
			}
			
			// Line 3: Details/Progress bar line
			String detailText = quantitySold + "/" + totalQuantity + " @ " + PRICE_FORMAT.format(price) + " gp";
			graphics.setColor(Color.BLACK);
			graphics.drawString(detailText, x + PADDING + 1, currentY + 1);
			graphics.setColor(COLOR_TEXT);
			graphics.drawString(detailText, x + PADDING, currentY);
			
			// Draw progress bar
			int progressBarX = x + textWidth - PROGRESS_BAR_WIDTH + PADDING + 2;
			int progressBarY = currentY - PROGRESS_BAR_HEIGHT + 2;
			
			drawProgressBar(graphics, progressBarX, progressBarY, PROGRESS_BAR_WIDTH, PROGRESS_BAR_HEIGHT, percentage, statusColor);
			
			// Draw icon stacked on top of progress bar
			if (config.showGEItemIcons())
			{
				AsyncBufferedImage itemImage = itemManager.getImage(itemId);
				if (itemImage != null)
				{
					BufferedImage icon = itemImage;
					if (icon.getWidth() > 0)
					{
						int iconX = progressBarX + (PROGRESS_BAR_WIDTH - ICON_SIZE) / 2;
						int iconY = progressBarY - ICON_SIZE / 2 + PROGRESS_BAR_HEIGHT / 2 - 24;
						graphics.drawImage(icon, iconX, iconY, ICON_SIZE, ICON_SIZE, null);
					}
				}
			}
			
			currentY += LINE_HEIGHT;
		}
		
		// No offers message
		if (!hasActiveOffers)
		{
			graphics.setColor(COLOR_EMPTY);
			drawCenteredString(graphics, NO_OFFERS_MESSAGE, x, currentY, totalWidth);
		}
		
		return new Dimension(totalWidth, totalHeight);
	}
	
	/**
	 * Render the compact (mini) overlay - shows item name and percentage only.
	 */
	private Dimension renderCompact(Graphics2D graphics, GrandExchangeOffer[] offers)
	{
		int totalWidth = 150;
		
		int x = 0;
		int y = 0;
		int currentY = y + PADDING + COMPACT_LINE_HEIGHT;
		
		// Count active offers
		int activeCount = 0;
		for (GrandExchangeOffer offer : offers)
		{
			if (offer.getState() != GrandExchangeOfferState.EMPTY)
			{
				activeCount++;
			}
		}
		
		// Calculate height: title + active offers + padding
		int totalHeight = COMPACT_LINE_HEIGHT + (PADDING * 2);
		if (activeCount == 0)
		{
			totalHeight += COMPACT_LINE_HEIGHT; // "No offers" line
		}
		else
		{
			totalHeight += activeCount * COMPACT_LINE_HEIGHT;
		}
		
		// Draw background
		graphics.setColor(COLOR_BACKGROUND);
		graphics.fillRect(x, y, totalWidth, totalHeight);
		
		// Draw border
		graphics.setColor(COLOR_BORDER);
		graphics.drawRect(x, y, totalWidth, totalHeight);
		
		// Draw centered title
		graphics.setFont(FontManager.getRunescapeSmallFont());
		FontMetrics metrics = graphics.getFontMetrics();
		int titleX = x + (totalWidth - metrics.stringWidth(OVERLAY_TITLE)) / 2;
		graphics.setColor(Color.BLACK);
		graphics.drawString(OVERLAY_TITLE, titleX + 1, currentY + 1);
		graphics.setColor(COLOR_TITLE);
		graphics.drawString(OVERLAY_TITLE, titleX, currentY);
		
		// Set collapse button bounds
		collapseButtonBounds = new Rectangle(x, y, totalWidth, totalHeight);
		
		currentY += COMPACT_LINE_HEIGHT + 2;
		
		// Render each slot
		for (int slot = 0; slot < offers.length; slot++)
		{
			GrandExchangeOffer offer = offers[slot];
			
			if (offer.getState() == GrandExchangeOfferState.EMPTY)
			{
				continue;
			}
			
			GrandExchangeOfferState state = offer.getState();
			int itemId = offer.getItemId();
			int quantitySold = offer.getQuantitySold();
			int totalQuantity = offer.getTotalQuantity();
			
			boolean isBuy = state == GrandExchangeOfferState.BUYING || 
							state == GrandExchangeOfferState.BOUGHT ||
							state == GrandExchangeOfferState.CANCELLED_BUY;
			
			double percentage = totalQuantity > 0 ? (quantitySold * 100.0) / totalQuantity : 0;
			String itemName = itemManager.getItemComposition(itemId).getName();
			
			// Truncate item name if too long
			if (itemName.length() > MAX_ITEM_NAME_LENGTH)
			{
				itemName = itemName.substring(0, MAX_ITEM_NAME_LENGTH - 1) + "..";
			}
			
			Color statusColor = getStatusColor(state, isBuy);
			
			// Draw compact icon
			if (config.showGEItemIcons())
			{
				AsyncBufferedImage itemImage = itemManager.getImage(itemId);
				if (itemImage != null && itemImage.getWidth() > 0)
				{
					int iconX = x + PADDING - 2;
					int iconY = currentY - COMPACT_ICON_SIZE + 4;
					graphics.drawImage(itemImage, iconX, iconY, COMPACT_ICON_SIZE, COMPACT_ICON_SIZE, null);
				}
			}
			
			// Draw item name with B/S indicator
			int textX = x + PADDING + (config.showGEItemIcons() ? COMPACT_ICON_SIZE : 0);
			String displayText = (isBuy ? "B: " : "S: ") + itemName;
			graphics.setColor(Color.BLACK);
			graphics.drawString(displayText, textX + 1, currentY + 1);
			graphics.setColor(isBuy ? COLOR_BUY : COLOR_SELL);
			graphics.drawString(displayText, textX, currentY);
			
			// Draw percentage on the right
			String pctText = PERCENTAGE_FORMAT.format(percentage) + "%";
			int pctWidth = metrics.stringWidth(pctText);
			int pctX = x + totalWidth - pctWidth - PADDING;
			graphics.setColor(Color.BLACK);
			graphics.drawString(pctText, pctX + 1, currentY + 1);
			graphics.setColor(statusColor);
			graphics.drawString(pctText, pctX, currentY);
			
			currentY += COMPACT_LINE_HEIGHT;
		}
		
		// No offers message
		if (activeCount == 0)
		{
			graphics.setColor(COLOR_EMPTY);
			drawCenteredString(graphics, NO_OFFERS_MESSAGE, x, currentY, totalWidth);
		}
		
		return new Dimension(totalWidth, totalHeight);
	}
	
	/**
	 * Draw a progress bar with the given parameters.
	 */
	private void drawProgressBar(Graphics2D graphics, int x, int y, int width, int height, double percentage, Color fillColor)
	{
		// Background
		graphics.setColor(COLOR_PROGRESS_BG);
		graphics.fillRect(x, y, width, height);
		
		// Border
		graphics.setColor(COLOR_PROGRESS_BORDER);
		graphics.drawRect(x, y, width, height);
		
		// Fill
		int fillWidth = (int) (width * (percentage / 100.0));
		if (fillWidth > 0)
		{
			graphics.setColor(fillColor);
			graphics.fillRect(x + 1, y + 1, fillWidth - 1, height - 2);
		}
		
		// Percentage text centered
		String progressText = PERCENTAGE_FORMAT.format(percentage) + "%";
		Font originalFont = graphics.getFont();
		graphics.setFont(FontManager.getRunescapeSmallFont());
		
		FontMetrics fm = graphics.getFontMetrics();
		int progressTextWidth = fm.stringWidth(progressText);
		int textX = x + (width - progressTextWidth) / 2;
		int textY = y + height - 2;
		
		graphics.setColor(Color.BLACK);
		graphics.drawString(progressText, textX + 1, textY + 1);
		graphics.setColor(Color.WHITE);
		graphics.drawString(progressText, textX, textY);
		
		graphics.setFont(originalFont);
	}
	
	/**
	 * Get the status color for an offer state.
	 */
	private Color getStatusColor(GrandExchangeOfferState state, boolean isBuy)
	{
		switch (state)
		{
			case BOUGHT:
			case SOLD:
				return COLOR_COMPLETE;
			case CANCELLED_BUY:
			case CANCELLED_SELL:
				return COLOR_CANCELLED;
			case BUYING:
			case SELLING:
				return isBuy ? COLOR_BUY : COLOR_SELL;
			default:
				return COLOR_EMPTY;
		}
	}
	
	private void drawCenteredString(Graphics2D g, String text, int x, int y, int width)
	{
		FontMetrics metrics = g.getFontMetrics();
		int textX = x + (width - metrics.stringWidth(text)) / 2;
		g.drawString(text, textX, y);
	}
	
	public void toggleCollapse()
	{
		isCollapsed = !isCollapsed;
	}
	
	public boolean isCollapsed()
	{
		return isCollapsed;
	}
	
	public Rectangle getCollapseButtonBounds()
	{
		return collapseButtonBounds;
	}
}

package com.flipsmart;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;

/**
 * Service for polling market dumps and posting chat alerts
 */
@Slf4j
@Singleton
public class DumpAlertService
{
	private final Client client;
	private final FlipSmartConfig config;
	private final FlipSmartApiClient apiClient;
	private final ChatMessageManager chatMessageManager;

	// Track when we last alerted for each item (itemId -> timestamp)
	private final Map<Integer, Long> itemAlertCooldowns = new HashMap<>();

	private ScheduledExecutorService executor;
	private ScheduledFuture<?> pollingTask;

	@Inject
	public DumpAlertService(
		Client client,
		FlipSmartConfig config,
		FlipSmartApiClient apiClient,
		ChatMessageManager chatMessageManager
	)
	{
		this.client = client;
		this.config = config;
		this.apiClient = apiClient;
		this.chatMessageManager = chatMessageManager;
	}

	/**
	 * Start the dump alert service
	 */
	public void start()
	{
		if (!config.enableDumpAlerts())
		{
			log.debug("Dump alerts disabled in config, not starting");
			return;
		}

		// Stop any existing task
		stop();

		int intervalSeconds = Math.max(30, Math.min(300, config.dumpAlertInterval()));

		log.info("Starting dump alert service with {}s interval", intervalSeconds);

		if (executor == null || executor.isShutdown())
		{
			executor = Executors.newSingleThreadScheduledExecutor();
		}

		pollingTask = executor.scheduleAtFixedRate(() ->
		{
			try
			{
				checkForDumps();
			}
			catch (Exception e)
			{
				log.error("Error checking for dumps", e);
			}
		}, 5, intervalSeconds, TimeUnit.SECONDS);
	}

	/**
	 * Stop the dump alert service
	 */
	public void stop()
	{
		if (pollingTask != null)
		{
			log.info("Stopping dump alert service");
			pollingTask.cancel(false);
			pollingTask = null;
		}
		if (executor != null)
		{
			executor.shutdownNow();
			executor = null;
		}
	}

	/**
	 * Restart the service (called when config changes)
	 */
	public void restart()
	{
		stop();
		start();
	}

	/**
	 * Check for new dumps and post alerts
	 */
	private void checkForDumps()
	{
		if (!config.enableDumpAlerts() || client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		int minProfit = config.dumpAlertMinProfit();
		int maxCount = Math.max(1, Math.min(50, config.dumpAlertMaxCount()));
		int cooldownMinutes = Math.max(0, Math.min(1440, config.dumpAlertCooldownMinutes()));
		long cooldownMs = cooldownMinutes * 60 * 1000L;
		long currentTime = System.currentTimeMillis();

		log.debug("Checking for dumps (minProfit: {}, maxCount: {}, cooldown: {}m)",
			minProfit, maxCount, cooldownMinutes);

		// Cleanup expired cooldowns first
		itemAlertCooldowns.entrySet().removeIf(entry ->
			currentTime - entry.getValue() > cooldownMs);

		// Sort by profit or recency based on config
		String sortBy = config.dumpAlertSortByProfit() ? "profit" : "recency";

		apiClient.getDumpsAsync(
			sortBy,
			minProfit,
			50, // Fetch up to 50 recent dumps
			dumps ->
			{
				if (dumps == null || dumps.length == 0)
				{
					log.debug("No dumps returned from API");
					return;
				}

				log.debug("Received {} dumps from API", dumps.length);

				FlipSmartConfig.PriceAlertType alertType = config.priceAlertType();

				int alertCount = 0;
				for (DumpEvent dump : dumps)
				{
					// Stop once we've alerted on the max count
					if (alertCount >= maxCount)
					{
						break;
					}

					// Filter by price change type based on config
					String changeType = dump.getPriceChangeType();
					boolean isDump = "dump".equalsIgnoreCase(changeType);
					boolean isPump = "pump".equalsIgnoreCase(changeType);

					// Skip if it doesn't match the configured alert type
					if (alertType == FlipSmartConfig.PriceAlertType.DUMPS_ONLY && !isDump)
					{
						log.debug("Skipping {} - is a pump but alerts set to dumps only", dump.getItemName());
						continue;
					}
					if (alertType == FlipSmartConfig.PriceAlertType.PUMPS_ONLY && !isPump)
					{
						log.debug("Skipping {} - is a dump but alerts set to pumps only", dump.getItemName());
						continue;
					}

					int itemId = dump.getItemId();

					// Check if item is on cooldown
					if (itemAlertCooldowns.containsKey(itemId))
					{
						long lastAlertTime = itemAlertCooldowns.get(itemId);
						long timeSinceAlert = currentTime - lastAlertTime;

						if (timeSinceAlert < cooldownMs)
						{
							long minutesRemaining = (cooldownMs - timeSinceAlert) / 60000;
							log.debug("Skipping {} - on cooldown for {} more minutes",
								dump.getItemName(), minutesRemaining);
							continue;
						}
					}

					// Mark item as alerted with current timestamp
					itemAlertCooldowns.put(itemId, currentTime);

					// Post to game chat
					postDumpAlert(dump);
					alertCount++;
				}

				log.debug("Posted {} new dump alerts", alertCount);

				// Cleanup if map gets too large (shouldn't happen often with cooldown cleanup)
				if (itemAlertCooldowns.size() > 500)
				{
					log.debug("Cleaning up item cooldowns (size: {})", itemAlertCooldowns.size());
					// Remove oldest entries
					long cutoffTime = currentTime - cooldownMs;
					itemAlertCooldowns.entrySet().removeIf(entry -> entry.getValue() < cutoffTime);
				}
			},
			error -> log.warn("Failed to fetch dumps: {}", error)
		);
	}

	/**
	 * Post a dump alert to game chat
	 */
	private void postDumpAlert(DumpEvent dump)
	{
		String message = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("[Flip Smart] ")
			.append(ChatColorType.NORMAL)
			.append(dump.toChatMessage())
			.build();

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(message)
			.build());

		log.info("Posted dump alert: {} ({}% drop, {} profit)",
			dump.getItemName(),
			String.format("%.1f", dump.getPriceDropPercent()),
			dump.getEstimatedProfit() != null ? dump.getEstimatedProfit() + "gp" : "unknown");
	}

	/**
	 * Clear the item cooldown tracking (useful for testing or after long periods)
	 */
	public void clearItemCooldowns()
	{
		itemAlertCooldowns.clear();
		log.debug("Cleared item cooldowns");
	}
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

@Data
public class FlipAnalysis
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	private boolean members;

	@SerializedName("buy_limit")
	private Integer buyLimit;

	@SerializedName("current_prices")
	private CurrentPrices currentPrices;

	private Liquidity liquidity;
	private Risk risk;
	private Efficiency efficiency;

	@SerializedName("historical_data")
	private HistoricalData historicalData;

	@Data
	public static class CurrentPrices
	{
		private Integer high;
		private Integer low;

		@SerializedName("gross_margin")
		private Integer grossMargin;

		@SerializedName("ge_tax")
		private Integer geTax;

		@SerializedName("net_margin")
		private Integer netMargin;

		@SerializedName("roi_percent")
		private Double roiPercent;
	}

	@Data
	public static class Liquidity
	{
		private Double score;
		private String rating;

		@SerializedName("buys_per_hour")
		private Double buysPerHour;

		@SerializedName("sells_per_hour")
		private Double sellsPerHour;

		@SerializedName("total_volume_per_hour")
		private Double totalVolumePerHour;
	}

	@Data
	public static class Risk
	{
		private Double score;
		private String rating;
	}

	@Data
	public static class Efficiency
	{
		private Double score;
		private String rating;
		private String recommendation;
	}

	@Data
	public static class HistoricalData
	{
		private String timeframe;

		@SerializedName("data_points")
		private Integer dataPoints;

		@SerializedName("avg_price")
		private Integer avgPrice;

		private Integer volatility;
	}

	/**
	 * Check if this item is a good flip based on efficiency score
	 */
	public boolean isGoodFlip(int minEfficiencyScore)
	{
		return efficiency != null &&
			efficiency.getScore() != null &&
			efficiency.getScore() >= minEfficiencyScore;
	}

	/**
	 * Check if the item has positive net margin
	 */
	public boolean hasPositiveMargin()
	{
		return currentPrices != null &&
			currentPrices.getNetMargin() != null &&
			currentPrices.getNetMargin() > 0;
	}
}


package com.flipsmart;

import lombok.Data;

/**
 * Represents a flip that the user has selected as their current focus.
 * This can be either a recommended flip (buying step) or an active flip (selling step).
 */
@Data
public class FocusedFlip
{
	/**
	 * The step of the flip process
	 */
	public enum FlipStep
	{
		BUY,  // Need to buy the item
		SELL  // Already bought, need to sell
	}

	private final int itemId;
	private final String itemName;
	private final FlipStep step;
	
	// Buy step fields
	private final int buyPrice;
	private final int buyQuantity;
	
	// Sell step fields
	private final int sellPrice;
	private final int sellQuantity;
	
	/**
	 * Create a FocusedFlip for the BUY step (from a recommendation)
	 */
	public static FocusedFlip forBuy(int itemId, String itemName, int buyPrice, int buyQuantity, int sellPrice)
	{
		return forBuy(itemId, itemName, buyPrice, buyQuantity, sellPrice, 0);
	}
	
	/**
	 * Create a FocusedFlip for the BUY step with price offset applied
	 * @param priceOffset Positive offset = buy higher to fill faster
	 */
	public static FocusedFlip forBuy(int itemId, String itemName, int buyPrice, int buyQuantity, int sellPrice, int priceOffset)
	{
		// Apply offset: add to buy price (pay more to fill faster)
		int adjustedBuyPrice = Math.max(1, buyPrice + priceOffset);
		// Also adjust sell price by subtracting offset (sell lower to fill faster)
		int adjustedSellPrice = Math.max(1, sellPrice - priceOffset);
		
		return new FocusedFlip(
			itemId,
			itemName,
			FlipStep.BUY,
			adjustedBuyPrice,
			buyQuantity,
			adjustedSellPrice,
			0  // No sell quantity yet
		);
	}
	
	/**
	 * Create a FocusedFlip for the SELL step (from an active flip)
	 */
	public static FocusedFlip forSell(int itemId, String itemName, int sellPrice, int sellQuantity)
	{
		return forSell(itemId, itemName, sellPrice, sellQuantity, 0);
	}
	
	/**
	 * Create a FocusedFlip for the SELL step with price offset applied
	 * @param priceOffset Positive offset = sell lower to fill faster
	 */
	public static FocusedFlip forSell(int itemId, String itemName, int sellPrice, int sellQuantity, int priceOffset)
	{
		// Apply offset: subtract from sell price (sell lower to fill faster)
		int adjustedSellPrice = Math.max(1, sellPrice - priceOffset);
		
		return new FocusedFlip(
			itemId,
			itemName,
			FlipStep.SELL,
			0,  // Not relevant for selling
			0,
			adjustedSellPrice,
			sellQuantity
		);
	}
	
	/**
	 * Get the price relevant to the current step
	 */
	public int getCurrentStepPrice()
	{
		return step == FlipStep.BUY ? buyPrice : sellPrice;
	}
	
	/**
	 * Get the quantity relevant to the current step
	 */
	public int getCurrentStepQuantity()
	{
		return step == FlipStep.BUY ? buyQuantity : sellQuantity;
	}
	
	/**
	 * Check if we're in the buying step
	 */
	public boolean isBuying()
	{
		return step == FlipStep.BUY;
	}
	
	/**
	 * Check if we're in the selling step
	 */
	public boolean isSelling()
	{
		return step == FlipStep.SELL;
	}
}


package com.flipsmart;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Duration;
import java.time.Instant;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;

@Slf4j
public class FlipFinderPanel extends PluginPanel
{
	// Configuration constants
	private static final String CONFIG_GROUP = "flipsmart";
	private static final String CONFIG_KEY_FLIP_STYLE = "flipStyle";
	private static final String CONFIG_KEY_EMAIL = "email";
	private static final String CONFIG_KEY_PASSWORD = "password";
	
	// Constants for duplicated literals
	private static final String FONT_ARIAL = "Arial";
	private static final String ERROR_PREFIX = "Error: ";
	private static final String FORMAT_QTY = "Qty: %d";
	private static final String FORMAT_SELL = "Sell: %s";
	private static final String FORMAT_ROI = "ROI: %.1f%%";
	private static final String FORMAT_BUY_SELL = "Buy: %s | Sell: %s";
	private static final String FORMAT_PROFIT_COST = "Profit: %s | Cost: %s";
	private static final String FORMAT_MARGIN_ROI = "Margin: %s (%.1f%% ROI)";
	private static final String FORMAT_MARGIN_ROI_LOSS = "Margin: %s (%.1f%% ROI) - Loss";
	private static final String FORMAT_LIQUIDITY = "Liquidity: %.0f (%s) | %s";
	private static final String FORMAT_RISK = "Risk: %.0f (%s)";
	private static final String UNKNOWN_RATING = "Unknown";
	private static final String LIQUIDITY_NA = "Liquidity: N/A";
	private static final String RISK_NA = "Risk: N/A";
	private static final String MSG_LOGIN_TO_RUNESCAPE = "Log in to RuneScape";
	private static final String MSG_LOGIN_INSTRUCTION = "<html><center>Log in to the game to get<br>flip suggestions and track your flips</center></html>";
	
	// Colors for focused/selected items
	private static final Color COLOR_FOCUSED_BORDER = new Color(0, 200, 220);
	private static final Color COLOR_FOCUSED_BG = new Color(0, 60, 70);
	
	// Common UI colors
	private static final Color COLOR_TEXT_GRAY = new Color(200, 200, 200);
	private static final Color COLOR_TEXT_DIM_GRAY = new Color(180, 180, 180);
	private static final Color COLOR_YELLOW = new Color(255, 255, 100);
	private static final Color COLOR_PROFIT_GREEN = new Color(100, 255, 100);
	private static final Color COLOR_LOSS_RED = new Color(255, 100, 100);
	private static final Color COLOR_BUY_RED = new Color(255, 120, 120);
	private static final Color COLOR_SELL_GREEN = new Color(120, 255, 120);
	
	// Common fonts
	private static final Font FONT_PLAIN_12 = new Font(FONT_ARIAL, Font.PLAIN, 12);
	private static final Font FONT_BOLD_12 = new Font(FONT_ARIAL, Font.BOLD, 12);
	private static final Font FONT_BOLD_13 = new Font(FONT_ARIAL, Font.BOLD, 13);
	private static final Font FONT_BOLD_16 = new Font(FONT_ARIAL, Font.BOLD, 16);
	
	// Time-based sell price thresholds (in minutes)
	// High volume items (>500k daily trades): switch to loss-minimizing after 10 min
	private static final int HIGH_VOLUME_THRESHOLD = 500_000;
	private static final int HIGH_VOLUME_TIME_MINUTES = 10;
	// Regular items: switch after 20 min
	private static final int REGULAR_TIME_MINUTES = 20;
	// High value items (>250M): give them 30 min before loss-minimizing
	private static final int HIGH_VALUE_THRESHOLD = 250_000_000;
	private static final int HIGH_VALUE_TIME_MINUTES = 30;

	private final transient FlipSmartConfig config;
	private final transient FlipSmartApiClient apiClient;
	private final transient ItemManager itemManager;
	private final transient ConfigManager configManager;
	private final JPanel recommendedListContainer = new JPanel();
	private final JPanel activeFlipsListContainer = new JPanel();
	private final JPanel completedFlipsListContainer = new JPanel();
	private final JLabel statusLabel = new JLabel("Loading...");
	private final JButton refreshButton = new JButton("Refresh");
	private final JComboBox<FlipSmartConfig.FlipStyle> flipStyleDropdown;
	private final List<FlipRecommendation> currentRecommendations = new ArrayList<>();
	private final List<ActiveFlip> currentActiveFlips = new ArrayList<>();
	private final List<CompletedFlip> currentCompletedFlips = new ArrayList<>();
	private final JTabbedPane tabbedPane = new JTabbedPane();
	private final transient FlipSmartPlugin plugin;  // Reference to plugin to store recommended prices
	
	// Scroll panes for preserving scroll position during refresh
	private JScrollPane recommendedScrollPane;
	private JScrollPane activeFlipsScrollPane;
	private JScrollPane completedFlipsScrollPane;

	// Login panel components
	private JPanel loginPanel;
	private JPanel mainPanel;
	private JTextField emailField;
	private JPasswordField passwordField;
	private JLabel loginStatusLabel;
	private JButton loginButton;
	private JButton signupButton;
	private JButton discordButton;
	private boolean isAuthenticated = false;
	
	// Discord device auth polling
	private ScheduledExecutorService deviceAuthScheduler;
	private ScheduledFuture<?> deviceAuthPollTask;
	private volatile String currentDeviceCode;
	
	// Callback for when authentication completes (to sync RSN)
	private transient Runnable onAuthSuccess;
	
	// Flip Assist focus tracking
	private transient FocusedFlip currentFocus = null;
	private transient JPanel currentFocusedPanel = null;
	private transient int currentFocusedItemId = -1;
	private transient java.util.function.Consumer<FocusedFlip> onFocusChanged;
	
	// Cache displayed sell prices to ensure focus uses same price as shown in UI
	// Key: itemId, Value: calculated sell price shown in the active flip panel
	private final java.util.Map<Integer, Integer> displayedSellPrices = new java.util.concurrent.ConcurrentHashMap<>();

	public FlipFinderPanel(FlipSmartConfig config, FlipSmartApiClient apiClient, ItemManager itemManager, FlipSmartPlugin plugin, ConfigManager configManager)
	{
		super(false);
		this.config = config;
		this.apiClient = apiClient;
		this.itemManager = itemManager;
		this.plugin = plugin;
		this.configManager = configManager;

		// Initialize flip style dropdown so it's available for both panels
		flipStyleDropdown = new JComboBox<>(FlipSmartConfig.FlipStyle.values());
		flipStyleDropdown.setFocusable(false);
		flipStyleDropdown.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		flipStyleDropdown.setForeground(Color.WHITE);
		// Load saved flip style from config
		flipStyleDropdown.setSelectedItem(config.flipStyle());
		flipStyleDropdown.addActionListener(e -> {
			// Save selection to config
			FlipSmartConfig.FlipStyle selectedStyle = (FlipSmartConfig.FlipStyle) flipStyleDropdown.getSelectedItem();
			if (selectedStyle != null)
			{
				configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_FLIP_STYLE, selectedStyle);
			}
			// Refresh recommendations when flip style changes
			if (isAuthenticated)
			{
				refresh();
			}
		});

		setLayout(new BorderLayout());
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Build both panels
		buildLoginPanel();
		buildMainPanel();

		// Start with login panel, then check authentication
		add(loginPanel, BorderLayout.CENTER);
		
		// Check if already authenticated and switch to main panel if so
		checkAuthenticationAndShow();
	}

	/**
	 * Build the login/signup panel
	 */
	private void buildLoginPanel()
	{
		loginPanel = new JPanel();
		loginPanel.setLayout(new BorderLayout());
		loginPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Center content panel
		JPanel contentPanel = new JPanel();
		contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));
		contentPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		contentPanel.setBorder(new EmptyBorder(40, 20, 40, 20));

		// Title
		JLabel titleLabel = new JLabel("Flip Smart");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(new Font(FONT_ARIAL, Font.BOLD, 24));
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Subtitle
		JLabel subtitleLabel = new JLabel("Sign in to start flipping");
		subtitleLabel.setForeground(Color.LIGHT_GRAY);
		subtitleLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 14));
		subtitleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		// Email field
		JLabel emailLabel = new JLabel("Email");
		emailLabel.setForeground(Color.LIGHT_GRAY);
		emailLabel.setFont(FONT_PLAIN_12);
		emailLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		emailField = new JTextField(20);
		emailField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
		emailField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		emailField.setForeground(Color.WHITE);
		emailField.setCaretColor(Color.WHITE);
		emailField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 10, 5, 10)
		));

		// Password field
		JLabel passwordLabel = new JLabel("Password");
		passwordLabel.setForeground(Color.LIGHT_GRAY);
		passwordLabel.setFont(FONT_PLAIN_12);
		passwordLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		passwordField = new JPasswordField(20);
		passwordField.setMaximumSize(new Dimension(Integer.MAX_VALUE, 30));
		passwordField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		passwordField.setForeground(Color.WHITE);
		passwordField.setCaretColor(Color.WHITE);
		passwordField.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),
			BorderFactory.createEmptyBorder(5, 10, 5, 10)
		));

		// Status label for messages
		loginStatusLabel = new JLabel(" ");
		loginStatusLabel.setFont(FONT_PLAIN_12);
		loginStatusLabel.setAlignmentX(Component.CENTER_ALIGNMENT);
		loginStatusLabel.setForeground(Color.LIGHT_GRAY);

		// Buttons panel for Login/Sign Up
		JPanel buttonsPanel = new JPanel(new GridLayout(1, 2, 10, 0));
		buttonsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		buttonsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 35));

		// Sign Up button
		signupButton = new JButton("Sign Up");
		signupButton.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		signupButton.setForeground(Color.WHITE);
		signupButton.setFocusPainted(false);
		signupButton.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(ColorScheme.BRAND_ORANGE),
			BorderFactory.createEmptyBorder(8, 15, 8, 15)
		));
		signupButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		signupButton.addActionListener(e -> handleSignup());

		// Login button
		loginButton = new JButton("Login");
		loginButton.setBackground(ColorScheme.BRAND_ORANGE);
		loginButton.setForeground(Color.WHITE);
		loginButton.setFocusPainted(false);
		loginButton.setBorder(BorderFactory.createEmptyBorder(8, 15, 8, 15));
		loginButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		loginButton.addActionListener(e -> handleLogin());

		buttonsPanel.add(signupButton);
		buttonsPanel.add(loginButton);
		
		// Divider
		JPanel dividerPanel = new JPanel(new BorderLayout());
		dividerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		dividerPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
		
		JLabel orLabel = new JLabel("OR", SwingConstants.CENTER);
		orLabel.setForeground(Color.GRAY);
		orLabel.setFont(new Font(FONT_ARIAL, Font.PLAIN, 11));
		dividerPanel.add(orLabel, BorderLayout.CENTER);
		
		// Discord login button (with Discord purple color)
		discordButton = new JButton("Login with Discord");
		discordButton.setBackground(new Color(88, 101, 242)); // Discord blurple
		discordButton.setForeground(Color.WHITE);
		discordButton.setFocusPainted(false);
		discordButton.setBorder(BorderFactory.createEmptyBorder(10, 15, 10, 15));
		discordButton.setCursor(new Cursor(Cursor.HAND_CURSOR));
		discordButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));
		discordButton.setAlignmentX(Component.CENTER_ALIGNMENT);
		discordButton.addActionListener(e -> handleDiscordLogin());

		// Add components with spacing
		contentPanel.add(titleLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(subtitleLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 30)));
		contentPanel.add(emailLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(emailField);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(passwordLabel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		contentPanel.add(passwordField);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 20)));
		contentPanel.add(buttonsPanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(dividerPanel);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(discordButton);
		contentPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		contentPanel.add(loginStatusLabel);

		// Center the content vertically
		loginPanel.add(contentPanel, BorderLayout.CENTER);
	}

	/**
	 * Build the main flip finder panel
	 */
	private void buildMainPanel()
	{
		mainPanel = new JPanel(new BorderLayout());
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Header panel with even spacing between title and buttons
		JPanel headerPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 8, 0));
		headerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		headerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));

		JLabel titleLabel = new JLabel("Flip Finder");
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FONT_BOLD_16);

		// Logout button with compact styling
		JButton logoutButton = new JButton("Logout");
		logoutButton.setFocusable(false);
		logoutButton.setMargin(new Insets(2, 4, 2, 4));
		logoutButton.addActionListener(e -> handleLogout());

		// Refresh button with compact styling
		refreshButton.setFocusable(false);
		refreshButton.setMargin(new Insets(2, 4, 2, 4));
		refreshButton.addActionListener(e -> refresh(true));

		headerPanel.add(titleLabel);
		headerPanel.add(logoutButton);
		headerPanel.add(refreshButton);

		// Controls panel (flip style dropdown)
		JPanel controlsPanel = new JPanel(new BorderLayout());
		controlsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		controlsPanel.setBorder(new EmptyBorder(5, 10, 5, 10));

		JLabel flipStyleLabel = new JLabel("Style: ");
		flipStyleLabel.setForeground(Color.LIGHT_GRAY);
		flipStyleLabel.setFont(FONT_PLAIN_12);

		// Custom renderer for better appearance
		flipStyleDropdown.setRenderer(new DefaultListCellRenderer() {
			@Override
			public Component getListCellRendererComponent(JList<?> list, Object value, int index,
														  boolean isSelected, boolean cellHasFocus) {
				Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
				if (c instanceof JLabel && value instanceof FlipSmartConfig.FlipStyle) {
					FlipSmartConfig.FlipStyle style = (FlipSmartConfig.FlipStyle) value;
					((JLabel) c).setText(style.name().charAt(0) + style.name().substring(1).toLowerCase());
				}
				if (isSelected) {
					c.setBackground(ColorScheme.BRAND_ORANGE);
				} else {
					c.setBackground(ColorScheme.DARKER_GRAY_COLOR);
				}
				c.setForeground(Color.WHITE);
				return c;
			}
		});

		JPanel dropdownWrapper = new JPanel(new FlowLayout(FlowLayout.LEFT, 5, 0));
		dropdownWrapper.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		dropdownWrapper.add(flipStyleLabel);
		dropdownWrapper.add(flipStyleDropdown);

		controlsPanel.add(dropdownWrapper, BorderLayout.WEST);

		// Status panel
		JPanel statusPanel = new JPanel(new BorderLayout());
		statusPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		statusPanel.setBorder(new EmptyBorder(5, 10, 5, 10));
		statusLabel.setForeground(Color.LIGHT_GRAY);
		statusLabel.setFont(FONT_PLAIN_12);
		statusPanel.add(statusLabel, BorderLayout.CENTER);

		// Combine controls and status into top panel
		JPanel topPanel = new JPanel();
		topPanel.setLayout(new BoxLayout(topPanel, BoxLayout.Y_AXIS));
		topPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		topPanel.add(headerPanel);
		topPanel.add(controlsPanel);
		topPanel.add(statusPanel);

		// Recommended flips list container
		recommendedListContainer.setLayout(new BoxLayout(recommendedListContainer, BoxLayout.Y_AXIS));
		recommendedListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		recommendedScrollPane = new JScrollPane(recommendedListContainer);
		recommendedScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		recommendedScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		recommendedScrollPane.setBorder(BorderFactory.createEmptyBorder());
		recommendedScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		// Always show scrollbar so layout always accounts for it
		recommendedScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

		// Active flips list container
		activeFlipsListContainer.setLayout(new BoxLayout(activeFlipsListContainer, BoxLayout.Y_AXIS));
		activeFlipsListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		activeFlipsScrollPane = new JScrollPane(activeFlipsListContainer);
		activeFlipsScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		activeFlipsScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		activeFlipsScrollPane.setBorder(BorderFactory.createEmptyBorder());
		activeFlipsScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		// Always show scrollbar so layout always accounts for it
		activeFlipsScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

		// Completed flips list container
		completedFlipsListContainer.setLayout(new BoxLayout(completedFlipsListContainer, BoxLayout.Y_AXIS));
		completedFlipsListContainer.setBackground(ColorScheme.DARK_GRAY_COLOR);

		completedFlipsScrollPane = new JScrollPane(completedFlipsListContainer);
		completedFlipsScrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
		completedFlipsScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(8, 0));
		completedFlipsScrollPane.setBorder(BorderFactory.createEmptyBorder());
		completedFlipsScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		// Always show scrollbar so layout always accounts for it
		completedFlipsScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

		// Create tabbed pane with custom UI for full-width tabs
		tabbedPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		tabbedPane.setForeground(Color.WHITE);
		tabbedPane.setTabPlacement(SwingConstants.TOP);
		
		// Custom UI to make tabs fill the full width
		tabbedPane.setUI(new javax.swing.plaf.basic.BasicTabbedPaneUI() {
			@Override
			protected int calculateTabWidth(int tabPlacement, int tabIndex, java.awt.FontMetrics metrics) {
				// Calculate equal width for all tabs
				int totalWidth = tabbedPane.getWidth();
				int tabCount = tabbedPane.getTabCount();
				if (tabCount > 0 && totalWidth > 0) {
					return totalWidth / tabCount;
				}
				return super.calculateTabWidth(tabPlacement, tabIndex, metrics);
			}
			
			@Override
			protected void paintTabBackground(java.awt.Graphics g, int tabPlacement, int tabIndex,
											  int x, int y, int w, int h, boolean isSelected) {
				// Paint background for tabs
				g.setColor(isSelected ? ColorScheme.DARKER_GRAY_COLOR : ColorScheme.DARK_GRAY_COLOR);
				g.fillRect(x, y, w, h);
			}
			
			@Override
			protected void paintTabBorder(java.awt.Graphics g, int tabPlacement, int tabIndex,
										  int x, int y, int w, int h, boolean isSelected) {
				// Paint border/underline for selected tab
				if (isSelected) {
					g.setColor(ColorScheme.BRAND_ORANGE);
					g.fillRect(x, y + h - 3, w, 3);
				}
			}
			
			@Override
			protected void paintContentBorder(java.awt.Graphics g, int tabPlacement, int selectedIndex) {
				// Don't paint content border
			}
		});
		
		tabbedPane.addTab("Recommended", recommendedScrollPane);
		tabbedPane.addTab("Active Flips", activeFlipsScrollPane);
		tabbedPane.addTab("Completed", completedFlipsScrollPane);
		
		// Add listener to update status when switching tabs
		tabbedPane.addChangeListener(e ->
		{
			int selectedIndex = tabbedPane.getSelectedIndex();
			if (selectedIndex == 1 && !currentActiveFlips.isEmpty())
			{
				// Switched to Active Flips tab, update status
				int itemCount = currentActiveFlips.size();
				int invested = currentActiveFlips.stream()
					.mapToInt(ActiveFlip::getTotalInvested)
					.sum();
				statusLabel.setText(String.format("%d active %s | %s invested",
					itemCount,
					itemCount == 1 ? "flip" : "flips",
					formatGP(invested)));
			}
			else if (selectedIndex == 2 && !currentCompletedFlips.isEmpty())
			{
				// Switched to Completed Flips tab, update status
				int flipCount = currentCompletedFlips.size();
				int totalProfit = currentCompletedFlips.stream()
					.mapToInt(CompletedFlip::getNetProfit)
					.sum();
				statusLabel.setText(String.format("%d completed | %s profit",
					flipCount,
					formatGP(totalProfit)));
			}
			else if (selectedIndex == 0 && !currentRecommendations.isEmpty())
			{
				// Switched back to Recommended tab, restore original status
				FlipFinderResponse response = new FlipFinderResponse();
				response.setRecommendations(currentRecommendations);
				updateStatusLabel(response);
			}
		});

		// Footer panel with website link
		JPanel footerPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 0, 5));
		footerPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		footerPanel.setBorder(new EmptyBorder(0, 0, 5, 0));

		JLabel websiteLink = new JLabel("Flip Smart Website");
		websiteLink.setForeground(new Color(100, 180, 255));
		websiteLink.setFont(new Font(FONT_ARIAL, Font.PLAIN, 14));
		websiteLink.setCursor(new Cursor(Cursor.HAND_CURSOR));
		websiteLink.setToolTipText("Visit our website to view your flips and track your performance");
		websiteLink.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				LinkBrowser.browse("https://flipsmart.net");
			}
		});

		footerPanel.add(websiteLink);

		mainPanel.add(topPanel, BorderLayout.NORTH);
		mainPanel.add(tabbedPane, BorderLayout.CENTER);
		mainPanel.add(footerPanel, BorderLayout.SOUTH);
	}

	/**
	 * Check if already authenticated and show appropriate panel
	 */
	private void checkAuthenticationAndShow()
	{
		// Try to authenticate silently with saved credentials
		String email = config.email();
		String password = config.password();
		
		if (email != null && !email.isEmpty() && password != null && !password.isEmpty())
		{
			// Pre-fill the email field
			emailField.setText(email);
			
			// Try to authenticate in background
			java.util.concurrent.CompletableFuture.runAsync(() -> {
				FlipSmartApiClient.AuthResult result = apiClient.login(email, password);
				
				SwingUtilities.invokeLater(() -> {
					if (result.success)
					{
						onAuthenticationSuccess(null, false);
					}
					else
					{
						// Stay on login panel, show message
						loginStatusLabel.setText("Please login to continue");
						loginStatusLabel.setForeground(Color.LIGHT_GRAY);
					}
				});
			});
		}
	}

	/**
	 * Handle login button click
	 */
	private void handleLogin()
	{
		String email = emailField.getText().trim();
		String password = new String(passwordField.getPassword());
		
		if (email.isEmpty() || password.isEmpty())
		{
			showLoginStatus("Please enter email and password", false);
			return;
		}
		
		setLoginButtonsEnabled(false);
		showLoginStatus("Logging in...", true);
		
		java.util.concurrent.CompletableFuture.runAsync(() -> {
			FlipSmartApiClient.AuthResult result = apiClient.login(email, password);
			
			SwingUtilities.invokeLater(() -> {
				setLoginButtonsEnabled(true);
				
				if (result.success)
				{
					// Save credentials for next session
					saveCredentials(email, password);
					onAuthenticationSuccess(result.message, true);
				}
				else
				{
					showLoginStatus(result.message, false);
				}
			});
		});
	}

	/**
	 * Handle signup button click
	 */
	private void handleSignup()
	{
		String email = emailField.getText().trim();
		String password = new String(passwordField.getPassword());
		
		if (email.isEmpty() || password.isEmpty())
		{
			showLoginStatus("Please enter email and password", false);
			return;
		}
		
		setLoginButtonsEnabled(false);
		showLoginStatus("Creating account...", true);
		
		java.util.concurrent.CompletableFuture.runAsync(() -> {
			FlipSmartApiClient.AuthResult result = apiClient.signup(email, password);
			
			SwingUtilities.invokeLater(() -> {
				setLoginButtonsEnabled(true);
				
				if (result.success)
				{
					// Save credentials for next session
					saveCredentials(email, password);
					onAuthenticationSuccess(result.message, true);
				}
				else
				{
					showLoginStatus(result.message, false);
				}
			});
		});
	}

	/**
	 * Save credentials for next session
	 */
	private void saveCredentials(String email, String password)
	{
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_EMAIL, email);
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_PASSWORD, password);
	}

	/**
	 * Show status message on login panel
	 */
	private void showLoginStatus(String message, boolean success)
	{
		loginStatusLabel.setText(message);
		loginStatusLabel.setForeground(success ? COLOR_PROFIT_GREEN : COLOR_LOSS_RED);
	}

	/**
	 * Enable/disable login buttons during authentication
	 */
	private void setLoginButtonsEnabled(boolean enabled)
	{
		loginButton.setEnabled(enabled);
		signupButton.setEnabled(enabled);
		discordButton.setEnabled(enabled);
		emailField.setEnabled(enabled);
		passwordField.setEnabled(enabled);
	}
	
	/**
	 * Handle Discord login button click
	 */
	private void handleDiscordLogin()
	{
		setLoginButtonsEnabled(false);
		showLoginStatus("Starting Discord login...", true);
		
		// Start device auth flow
		apiClient.startDeviceAuthAsync().thenAccept(response ->
		{
			if (response == null)
			{
				SwingUtilities.invokeLater(() ->
				{
					setLoginButtonsEnabled(true);
					showLoginStatus("Failed to start Discord login", false);
				});
				return;
			}
			
			// Store device code for polling
			currentDeviceCode = response.getDeviceCode();
			
			// Open browser with verification URL using RuneLite's LinkBrowser
            // which properly handles sandboxed environments (Flatpak, etc.)
            LinkBrowser.browse(response.getVerificationUrl());

        	SwingUtilities.invokeLater(() ->
            	showLoginStatus("Complete login in your browser...", true));

		   // Start polling for completion
		   startDeviceAuthPolling(response.getDeviceCode(), response.getPollInterval(), response.getExpiresIn());
		});
	}
	
	/**
	 * Start polling for device authorization completion
	 */
	private void startDeviceAuthPolling(String deviceCode, int pollIntervalSeconds, int expiresInSeconds)
	{
		// Cancel any existing poll task
		stopDeviceAuthPolling();
		
		// Create scheduler if needed
		if (deviceAuthScheduler == null || deviceAuthScheduler.isShutdown())
		{
			deviceAuthScheduler = Executors.newSingleThreadScheduledExecutor();
		}
		
		// Calculate max poll attempts based on expiry time
		int maxAttempts = expiresInSeconds / pollIntervalSeconds;
		final int[] attempts = {0};
		
		deviceAuthPollTask = deviceAuthScheduler.scheduleAtFixedRate(() ->
		{
			attempts[0]++;
			
			// Check if we've exceeded max attempts
			if (attempts[0] > maxAttempts)
			{
				stopDeviceAuthPolling();
				SwingUtilities.invokeLater(() ->
				{
					setLoginButtonsEnabled(true);
					showLoginStatus("Discord login timed out", false);
				});
				return;
			}
			
			// Poll status
			apiClient.pollDeviceStatusAsync(deviceCode).thenAccept(status ->
			{
				if (status == null)
				{
					return; // Network error, will retry
				}
				
				switch (status.getStatus())
				{
					case "authorized":
						// Success! Set the token and switch to main panel
						stopDeviceAuthPolling();
						apiClient.setAuthToken(status.getAccessToken());
						SwingUtilities.invokeLater(() ->
							onAuthenticationSuccess("Login successful!", true));
						break;
						
					case "expired":
						// Device code expired
						stopDeviceAuthPolling();
						SwingUtilities.invokeLater(() ->
						{
							setLoginButtonsEnabled(true);
							showLoginStatus("Discord login expired. Try again.", false);
						});
						break;
						
					case "pending":
						// Still waiting - continue polling
						break;
						
					default:
						log.warn("Unknown device status: {}", status.getStatus());
						break;
				}
			});
		}, pollIntervalSeconds, pollIntervalSeconds, TimeUnit.SECONDS);
	}
	
	/**
	 * Stop device auth polling
	 */
	private void stopDeviceAuthPolling()
	{
		if (deviceAuthPollTask != null)
		{
			deviceAuthPollTask.cancel(false);
			deviceAuthPollTask = null;
		}
		currentDeviceCode = null;
	}
	
	/**
	 * Clean up resources when panel is destroyed
	 */
	public void shutdown()
	{
		stopDeviceAuthPolling();
		if (deviceAuthScheduler != null)
		{
			deviceAuthScheduler.shutdownNow();
			deviceAuthScheduler = null;
		}
	}

	/**
	 * Switch from login panel to main panel
	 */
	private void showMainPanel()
	{
		isAuthenticated = true;
		removeAll();
		add(mainPanel, BorderLayout.CENTER);
		revalidate();
		repaint();
		
		// Load data
		refresh();
	}

	/**
	 * Switch from main panel to login panel (e.g., on auth error)
	 */
	public void showLoginPanel()
	{
		isAuthenticated = false;
		// Stop any pending device auth polling
		stopDeviceAuthPolling();
		// Re-enable all login buttons
		setLoginButtonsEnabled(true);
		removeAll();
		add(loginPanel, BorderLayout.CENTER);
		revalidate();
		repaint();
	}

	/**
	 * Handle successful authentication - notify plugin and transition to main panel.
	 * @param successMessage message to display, or null to skip showing message
	 * @param showDelay if true, show message briefly before transitioning
	 */
	private void onAuthenticationSuccess(String successMessage, boolean showDelay)
	{
		if (onAuthSuccess != null)
		{
			onAuthSuccess.run();
		}
		if (showDelay && successMessage != null)
		{
			showLoginStatus(successMessage, true);
			Timer timer = new Timer(500, e -> showMainPanel());
			timer.setRepeats(false);
			timer.start();
		}
		else
		{
			showMainPanel();
		}
	}

	/**
	 * Handle logout button click
	 */
	private void handleLogout()
	{
		// Clear API client authentication
		apiClient.clearAuth();
		
		// Clear password field but keep email
		passwordField.setText("");
		
		// Reset status
		loginStatusLabel.setText("Logged out successfully");
		loginStatusLabel.setForeground(Color.LIGHT_GRAY);
		
		// Show login panel
		showLoginPanel();
	}

	/**
	 * Refresh flip recommendations, active flips, and completed flips.
	 * Uses deterministic recommendations (no randomization) for auto-refresh.
	 */
	public void refresh()
	{
		refresh(false);
	}

	/**
	 * Refresh flip recommendations, active flips, and completed flips.
	 *
	 * @param shuffleSuggestions if true, randomizes suggestions within quality tiers (for manual refresh)
	 */
	public void refresh(boolean shuffleSuggestions)
	{
		// Skip API calls if player is not logged into RuneScape
		// This saves API requests and battery when at the login screen
		if (!plugin.isLoggedIntoRunescape())
		{
			log.debug("Skipping refresh - player not logged into RuneScape");
			showLoggedOutOfGameState();
			return;
		}
		
		// Skip recommendations refresh during auto-refresh if user is focused on a flip
		// This prevents the focused item from disappearing while user is mid-transaction
		// Manual refresh (shuffleSuggestions=true) always refreshes
		boolean skipRecommendationsRefresh = !shuffleSuggestions && currentFocus != null;
		
		if (skipRecommendationsRefresh)
		{
			log.debug("Skipping recommendations refresh - user is focused on {} ({})", 
				currentFocus.getItemName(), currentFocus.isBuying() ? "BUY" : "SELL");
		}
		else
		{
			refreshRecommendations(shuffleSuggestions);
		}
		
		refreshActiveFlips();
		refreshCompletedFlips();
	}

	/**
	 * Refresh recommended flips
	 *
	 * @param shuffleSuggestions if true, randomizes suggestions within quality tiers
	 */
	private void refreshRecommendations(boolean shuffleSuggestions)
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(recommendedScrollPane);
		
		statusLabel.setText("Loading recommendations...");
		refreshButton.setEnabled(false);
		// Don't clear container yet - keep showing old recommendations until new data arrives
		// This prevents the UI flash when recommendations disappear and reappear

		// Fetch recommendations asynchronously
		Integer cashStack = getCashStack();
		// Use the selected flip style from dropdown
		FlipSmartConfig.FlipStyle selectedStyle = (FlipSmartConfig.FlipStyle) flipStyleDropdown.getSelectedItem();
		String flipStyle = selectedStyle != null ? selectedStyle.getApiValue() : FlipSmartConfig.FlipStyle.BALANCED.getApiValue();
		int limit = Math.max(1, Math.min(50, config.flipFinderLimit()));
		// Only generate random seed for manual refresh to get variety in suggestions
		// Auto-refresh keeps same items so user can focus on setting up flips
		Integer randomSeed = shuffleSuggestions ? ThreadLocalRandom.current().nextInt() : null;

		apiClient.getFlipRecommendationsAsync(cashStack, flipStyle, limit, randomSeed).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				refreshButton.setEnabled(true);

				if (response == null)
				{
					showErrorInRecommended("Failed to fetch recommendations. Check your API settings.");
					restoreScrollPosition(recommendedScrollPane, scrollPos);
					return;
				}

				if (response.getRecommendations() == null || response.getRecommendations().isEmpty())
				{
					showErrorInRecommended("No flip recommendations found matching your criteria.");
					restoreScrollPosition(recommendedScrollPane, scrollPos);
					return;
				}

				currentRecommendations.clear();
				currentRecommendations.addAll(response.getRecommendations());

				// Store recommended sell prices in the plugin for transaction tracking
				for (FlipRecommendation rec : response.getRecommendations())
				{
					plugin.setRecommendedSellPrice(rec.getItemId(), rec.getRecommendedSellPrice());
				}

				updateStatusLabel(response);
				populateRecommendations(response.getRecommendations());
				restoreScrollPosition(recommendedScrollPane, scrollPos);
				
				// Validate focus after refresh in case focused item is no longer recommended
				validateFocus();
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				refreshButton.setEnabled(true);
				showErrorInRecommended(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(recommendedScrollPane, scrollPos);
			});
			return null;
		});
	}

	/**
	 * Refresh active flips
	 */
	public void refreshActiveFlips()
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(activeFlipsScrollPane);
		// Don't clear container yet - keep showing old flips until new data arrives
		// This prevents the UI flash when flips disappear and reappear
		
		// Clear cached sell prices - they'll be recalculated when panels are created
		displayedSellPrices.clear();

		// Pass current RSN to filter data for the logged-in account
		String rsn = plugin.getCurrentRsnSafe().orElse(null);
		apiClient.getActiveFlipsAsync(rsn).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				if (response == null)
				{
					showErrorInActiveFlips("Failed to fetch active flips. Check your API settings.");
					restoreScrollPosition(activeFlipsScrollPane, scrollPos);
					return;
				}

				currentActiveFlips.clear();
				if (response.getActiveFlips() != null)
				{
					// Show flips that are either:
					// 1. Currently in GE slots or collected items (thread-safe check)
					// 2. Had activity in the last 7 days (covers client restart scenarios)
					// We use a generous 7-day threshold because:
					// - On client restart, GE tracking takes time to populate
					// - collectedItemIds is session-only and resets on restart
					// - The backend handles proper stale flip cleanup via /flips/cleanup
					// Note: Using getActiveFlipItemIds() instead of WithInventory() to avoid thread issues
					java.util.Set<Integer> activeItemIds = plugin.getActiveFlipItemIds();
					java.time.Instant sevenDaysAgo = java.time.Instant.now().minus(java.time.Duration.ofDays(7));
					
					for (ActiveFlip flip : response.getActiveFlips())
					{
						boolean inGeOrCollected = activeItemIds.contains(flip.getItemId());
						boolean isRecent = false;
						
						// Check if flip had activity in the last 7 days
						// Use lastBuyTime if available (more accurate), fall back to firstBuyTime
						String timeStr = flip.getLastBuyTime();
						if (timeStr == null || timeStr.isEmpty())
						{
							timeStr = flip.getFirstBuyTime();
						}
						
						if (timeStr != null && !timeStr.isEmpty())
						{
							try
							{
								java.time.Instant buyTime = java.time.Instant.parse(timeStr);
								isRecent = buyTime.isAfter(sevenDaysAgo);
							}
							catch (Exception e)
							{
								// Can't parse, assume recent to be safe
								isRecent = true;
							}
						}
						else
						{
							// No timestamp, assume recent
							isRecent = true;
						}
						
						if (inGeOrCollected || isRecent)
						{
							currentActiveFlips.add(flip);
							log.debug("Including flip: {} (inGE={}, recent={})", 
								flip.getItemName(), inGeOrCollected, isRecent);
						}
						else
						{
							log.debug("Filtering stale flip: {} (not in GE and older than 7 days)", flip.getItemName());
						}
					}
					log.debug("Loaded {} active flips ({} from backend, {} filtered)", 
						currentActiveFlips.size(), response.getActiveFlips().size(),
						response.getActiveFlips().size() - currentActiveFlips.size());
				}

				// Get pending orders from plugin
				java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders = plugin.getPendingBuyOrders();

				if (currentActiveFlips.isEmpty() && pendingOrders.isEmpty())
				{
					showNoActiveFlips();
					restoreScrollPosition(activeFlipsScrollPane, scrollPos);
					return;
				}

				// Update status label with active flips info
				if (!currentActiveFlips.isEmpty())
				{
					// Update with filtered count
					int itemCount = currentActiveFlips.size();
					int invested = currentActiveFlips.stream()
						.mapToInt(ActiveFlip::getTotalInvested)
						.sum();
					if (tabbedPane.getSelectedIndex() == 1)
					{
						statusLabel.setText(String.format("%d active %s | %s invested",
							itemCount,
							itemCount == 1 ? "flip" : "flips",
							formatGP(invested)));
					}
				}
				else if (!pendingOrders.isEmpty())
				{
					statusLabel.setText(String.format("%d pending %s",
						pendingOrders.size(),
						pendingOrders.size() == 1 ? "order" : "orders"));
				}

				// Display both active flips and pending orders
				displayActiveFlipsAndPending(currentActiveFlips, pendingOrders);
				restoreScrollPosition(activeFlipsScrollPane, scrollPos);
				
				// Validate focus after refresh in case focused item is no longer active
				validateFocus();
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				showErrorInActiveFlips(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(activeFlipsScrollPane, scrollPos);
			});
			return null;
		});
	}
	
	/**
	 * Update pending orders display (called when GE offers change)
	 * @param pendingOrders the list of pending orders (used to trigger refresh)
	 */
	@SuppressWarnings("unused")
	public void updatePendingOrders(java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders)
	{
		// Only update if we're on the Active Flips tab
		if (tabbedPane.getSelectedIndex() == 1)
		{
			refreshActiveFlips();
		}
	}

	/**
	 * Refresh completed flips
	 */
	private void refreshCompletedFlips()
	{
		// Save scroll position before refresh
		final int scrollPos = getScrollPosition(completedFlipsScrollPane);
		// Don't clear container yet - keep showing old flips until new data arrives
		// This prevents the UI flash when flips disappear and reappear

		// Fetch last 50 completed flips for current RSN
		String rsn = plugin.getCurrentRsnSafe().orElse(null);
		apiClient.getCompletedFlipsAsync(50, rsn).thenAccept(response ->
		{
			SwingUtilities.invokeLater(() ->
			{
				if (response == null)
				{
					showErrorInCompletedFlips("Failed to fetch completed flips. Check your API settings.");
					restoreScrollPosition(completedFlipsScrollPane, scrollPos);
					return;
				}

				currentCompletedFlips.clear();
				if (response.getFlips() != null)
				{
					currentCompletedFlips.addAll(response.getFlips());
				}

				if (currentCompletedFlips.isEmpty())
				{
					showNoCompletedFlips();
					restoreScrollPosition(completedFlipsScrollPane, scrollPos);
					return;
				}

				// Update status if on completed flips tab
				if (tabbedPane.getSelectedIndex() == 2)
				{
					int totalProfit = currentCompletedFlips.stream()
						.mapToInt(CompletedFlip::getNetProfit)
						.sum();
					statusLabel.setText(String.format("%d completed | %s profit",
						currentCompletedFlips.size(),
						formatGP(totalProfit)));
				}

				populateCompletedFlips(currentCompletedFlips);
				restoreScrollPosition(completedFlipsScrollPane, scrollPos);
			});
		}).exceptionally(throwable ->
		{
			SwingUtilities.invokeLater(() ->
			{
				showErrorInCompletedFlips(ERROR_PREFIX + throwable.getMessage());
				restoreScrollPosition(completedFlipsScrollPane, scrollPos);
			});
			return null;
		});
	}

	/**
	 * Show error message in completed flips tab
	 */
	private void showErrorInCompletedFlips(String message)
	{
		completedFlipsListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Completed Flips", message);
		errorPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		errorPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
		completedFlipsListContainer.add(errorPanel);

		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}

	/**
	 * Show message when there are no completed flips
	 */
	private void showNoCompletedFlips()
	{
		completedFlipsListContainer.removeAll();
		completedFlipsListContainer.add(createEmptyStatePanel(
			"No completed flips",
			"<html><center>Complete your first flip to see<br>it here! Buy and sell items to<br>track your profits</center></html>",
			60
		));
		statusLabel.setText("0 completed flips");
		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}

	/**
	 * Populate the completed flips list
	 */
	private void populateCompletedFlips(java.util.List<CompletedFlip> flips)
	{
		completedFlipsListContainer.removeAll();

		for (CompletedFlip flip : flips)
		{
			completedFlipsListContainer.add(createCompletedFlipPanel(flip));
			completedFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
		}

		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}
	
	/**
	 * Display both active flips and pending orders.
	 * Pending orders (items still in GE buy slots) take priority over active flips
	 * to avoid showing duplicates when an item is partially filled.
	 */
	private void displayActiveFlipsAndPending(java.util.List<ActiveFlip> activeFlips, java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders)
	{
		activeFlipsListContainer.removeAll();
		
		// Build a map of pending orders by itemId for smart deduplication
		java.util.Map<Integer, java.util.List<FlipSmartPlugin.PendingOrder>> pendingByItemId = buildPendingOrdersMap(pendingOrders);
		
		// First show pending orders (items currently in GE buy slots)
		for (FlipSmartPlugin.PendingOrder pending : pendingOrders)
		{
			activeFlipsListContainer.add(createPendingOrderPanel(pending));
			activeFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
		}
		
		// Then show active flips (items collected, waiting to sell)
		// Skip active flips if pending orders already account for those items
		for (ActiveFlip flip : activeFlips)
		{
			if (shouldShowActiveFlip(flip, pendingByItemId))
			{
				activeFlipsListContainer.add(createActiveFlipPanel(flip));
				activeFlipsListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
			}
		}

		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Build a map of pending orders grouped by item ID
	 */
	private java.util.Map<Integer, java.util.List<FlipSmartPlugin.PendingOrder>> buildPendingOrdersMap(
			java.util.List<FlipSmartPlugin.PendingOrder> pendingOrders)
	{
		java.util.Map<Integer, java.util.List<FlipSmartPlugin.PendingOrder>> pendingByItemId = new java.util.HashMap<>();
		for (FlipSmartPlugin.PendingOrder pending : pendingOrders)
		{
			pendingByItemId.computeIfAbsent(pending.itemId, k -> new java.util.ArrayList<>()).add(pending);
		}
		return pendingByItemId;
	}

	/**
	 * Determine if an active flip should be shown (not duplicated by pending orders)
	 * 
	 * Logic: If an item has ANY pending buy order in the GE, skip the active flip.
	 * The pending order is the source of truth for items currently in buy slots.
	 * Active flips should only show for COLLECTED items (no longer in GE, waiting to sell).
	 */
	private boolean shouldShowActiveFlip(ActiveFlip flip, 
			java.util.Map<Integer, java.util.List<FlipSmartPlugin.PendingOrder>> pendingByItemId)
	{
		java.util.List<FlipSmartPlugin.PendingOrder> matchingPending = pendingByItemId.get(flip.getItemId());
		
		if (matchingPending == null || matchingPending.isEmpty())
		{
			// No pending buy orders for this item - show the active flip
			return true;
		}
		
		// There's a pending buy order for this item in the GE.
		// Skip the active flip to avoid duplicates - the pending order panel shows the current state.
		log.debug("Skipping active flip {} - has {} pending buy order(s) in GE",
			flip.getItemName(), matchingPending.size());
		return false;
	}

	/**
	 * Get the player's current cash stack from inventory
	 * Returns null if not available
	 * Can be overridden by subclasses to provide actual cash stack
	 */
	protected Integer getCashStack()
	{
		// This will be overridden by the plugin
		// For now, return null to get all recommendations
		return null;
	}

	/**
	 * Update the status label with response info (for Recommended tab)
	 */
	private void updateStatusLabel(FlipFinderResponse response)
	{
		FlipSmartConfig.FlipStyle selectedStyle = (FlipSmartConfig.FlipStyle) flipStyleDropdown.getSelectedItem();
		String flipStyleText = selectedStyle != null ? selectedStyle.toString() : "Balanced";
		int count = response.getRecommendations().size();
		String itemWord = count == 1 ? "suggestion" : "suggestions";
		
		if (response.getCashStack() != null)
		{
			statusLabel.setText(String.format("%s | %d %s | Cash: %s",
				flipStyleText,
				count,
				itemWord,
				formatGP(response.getCashStack())));
		}
		else
		{
			statusLabel.setText(String.format("%s | %d %s", flipStyleText, count, itemWord));
		}
	}

	/**
	 * Show an error message in recommended tab
	 */
	private void showErrorInRecommended(String message)
	{
		statusLabel.setText("Error");
		recommendedListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Flip Finder", message);
		errorPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		errorPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
		recommendedListContainer.add(errorPanel);

		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();
	}

	/**
	 * Show an error message in active flips tab
	 */
	private void showErrorInActiveFlips(String message)
	{
		activeFlipsListContainer.removeAll();

		PluginErrorPanel errorPanel = new PluginErrorPanel();
		errorPanel.setContent("Active Flips", message);
		errorPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		errorPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));
		activeFlipsListContainer.add(errorPanel);

		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Create an empty state panel with a title and instruction message.
	 * This is a helper to reduce code duplication across empty state displays.
	 * 
	 * @param title The main title text
	 * @param instruction The instruction/explanation HTML text
	 * @param topPadding Top padding for the panel
	 * @return A configured empty state panel
	 */
	private JPanel createEmptyStatePanel(String title, String instruction, int topPadding)
	{
		JPanel emptyPanel = new JPanel();
		emptyPanel.setLayout(new BoxLayout(emptyPanel, BoxLayout.Y_AXIS));
		emptyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
		emptyPanel.setBorder(new EmptyBorder(topPadding, 15, topPadding, 15));
		emptyPanel.setAlignmentX(Component.LEFT_ALIGNMENT);
		emptyPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE));

		JLabel titleLabel = new JLabel(title);
		titleLabel.setForeground(Color.WHITE);
		titleLabel.setFont(FONT_BOLD_16);
		titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
		titleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		JLabel instructionLabel = new JLabel(instruction);
		instructionLabel.setForeground(COLOR_TEXT_DIM_GRAY);
		instructionLabel.setFont(FONT_PLAIN_12);
		instructionLabel.setHorizontalAlignment(SwingConstants.CENTER);
		instructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);

		emptyPanel.add(titleLabel);
		emptyPanel.add(Box.createRigidArea(new Dimension(0, 15)));
		emptyPanel.add(instructionLabel);

		return emptyPanel;
	}

	/**
	 * Show message when player is logged out of RuneScape (at login screen).
	 * This saves API requests and battery by not polling while the player can't use the GE anyway.
	 */
	public void showLoggedOutOfGameState()
	{
		statusLabel.setText(MSG_LOGIN_TO_RUNESCAPE);
		
		// Update all tabs with logged out message
		recommendedListContainer.removeAll();
		recommendedListContainer.add(createEmptyStatePanel(MSG_LOGIN_TO_RUNESCAPE, MSG_LOGIN_INSTRUCTION, 80));
		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();
		
		activeFlipsListContainer.removeAll();
		activeFlipsListContainer.add(createEmptyStatePanel(MSG_LOGIN_TO_RUNESCAPE, MSG_LOGIN_INSTRUCTION, 80));
		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
		
		completedFlipsListContainer.removeAll();
		completedFlipsListContainer.add(createEmptyStatePanel(MSG_LOGIN_TO_RUNESCAPE, MSG_LOGIN_INSTRUCTION, 80));
		completedFlipsListContainer.revalidate();
		completedFlipsListContainer.repaint();
	}

	/**
	 * Show message when there are no active flips
	 */
	private void showNoActiveFlips()
	{
		activeFlipsListContainer.removeAll();
		activeFlipsListContainer.add(createEmptyStatePanel(
			"No active flips",
			"<html><center>Buy items from the Recommended<br>tab to start tracking your flips</center></html>",
			60
		));
		statusLabel.setText("0 active flips");
		activeFlipsListContainer.revalidate();
		activeFlipsListContainer.repaint();
	}

	/**
	 * Populate the list with recommendations
	 */
	private void populateRecommendations(List<FlipRecommendation> recommendations)
	{
		recommendedListContainer.removeAll();

		for (FlipRecommendation rec : recommendations)
		{
			recommendedListContainer.add(createRecommendationPanel(rec));
			recommendedListContainer.add(Box.createRigidArea(new Dimension(0, 5)));
		}

		recommendedListContainer.revalidate();
		recommendedListContainer.repaint();
	}

	/**
	 * Create a panel for a single recommendation
	 */
	private JPanel createRecommendationPanel(FlipRecommendation rec)
	{
		JPanel panel = createBaseItemPanel(ColorScheme.DARKER_GRAY_COLOR, Integer.MAX_VALUE, true);

		// Item header with icon and name
		HeaderPanels header = createItemHeaderPanels(rec.getItemId(), rec.getItemName(), ColorScheme.DARKER_GRAY_COLOR);
		JPanel topPanel = header.topPanel;

		// Details panel with all recommendation info
		JPanel detailsPanel = createRecommendationDetailsPanel(rec);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Add mouse listener for interactions
		addRecommendationPanelListeners(panel, rec);

		return panel;
	}

	/**
	 * Create the details panel for a recommendation with all stats
	 */
	private JPanel createRecommendationDetailsPanel(FlipRecommendation rec)
	{
		JPanel detailsPanel = createDetailsPanel(ColorScheme.DARKER_GRAY_COLOR);

		// Recommended Buy/Sell prices
		JLabel priceLabel = new JLabel(formatBuySellText(rec.getRecommendedBuyPrice(), rec.getRecommendedSellPrice()));
		priceLabel.setForeground(Color.LIGHT_GRAY);
		priceLabel.setFont(FONT_PLAIN_12);

		// Quantity
		JLabel quantityLabel = new JLabel(String.format("Qty: %d (Limit: %d)",
			rec.getRecommendedQuantity(), rec.getBuyLimit()));
		quantityLabel.setForeground(new Color(200, 200, 255));
		quantityLabel.setFont(FONT_PLAIN_12);

		// Margin and ROI
		JLabel marginLabel = new JLabel(String.format("Margin: %s (%s ROI)",
			formatGP(rec.getMargin()), rec.getFormattedROI()));
		marginLabel.setForeground(COLOR_PROFIT_GREEN);
		marginLabel.setFont(FONT_PLAIN_12);

		// Potential profit and total cost
		JLabel profitLabel = new JLabel(formatProfitCostText(rec.getPotentialProfit(), rec.getTotalCost()));
		profitLabel.setForeground(new Color(255, 215, 0));
		profitLabel.setFont(FONT_PLAIN_12);

		// Liquidity info
		JLabel liquidityLabel = new JLabel(formatLiquidityText(
			rec.getLiquidityScore(), rec.getLiquidityRating(), rec.getVolumePerHour()));
		liquidityLabel.setForeground(Color.CYAN);
		liquidityLabel.setFont(FONT_PLAIN_12);

		// Risk info
		JLabel riskLabel = new JLabel(formatRiskText(rec.getRiskScore(), rec.getRiskRating()));
		riskLabel.setForeground(getRiskColor(rec.getRiskScore()));
		riskLabel.setFont(FONT_PLAIN_12);

		addLabelsWithSpacing(detailsPanel, priceLabel, quantityLabel, marginLabel, 
			profitLabel, liquidityLabel, riskLabel);

		return detailsPanel;
	}

	/**
	 * Add mouse listeners for recommendation panel (focus, expand, hover)
	 */
	private void addRecommendationPanelListeners(JPanel panel, FlipRecommendation rec)
	{
		panel.addMouseListener(new MouseAdapter()
		{
			private boolean expanded = false;

			@Override
			public void mouseClicked(MouseEvent e)
			{
				handleRecommendationClick(e, panel, rec);
			}

			private void handleRecommendationClick(MouseEvent e, JPanel panel, FlipRecommendation rec)
			{
				// Left click: set as Flip Assist focus
				if (e.getButton() == MouseEvent.BUTTON1 && e.getClickCount() == 1)
				{
					setFocus(rec, panel);
					return;
				}
				
				// Right click or double click: toggle focus hint
				if (e.getButton() != MouseEvent.BUTTON3 && e.getClickCount() != 2)
				{
					return;
				}

				expanded = toggleExpandedState(panel, expanded);
				panel.revalidate();
				panel.repaint();
			}

			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != rec.getItemId())
				{
					panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
					updateChildBackgrounds(panel, ColorScheme.DARKER_GRAY_HOVER_COLOR);
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != rec.getItemId())
				{
					panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
					updateChildBackgrounds(panel, ColorScheme.DARKER_GRAY_COLOR);
				}
			}
		});
	}

	/**
	 * Toggle expanded state of a panel (show/hide focus hint)
	 */
	private boolean toggleExpandedState(JPanel panel, boolean currentlyExpanded)
	{
		if (!currentlyExpanded)
		{
			// Add focus hint
			JPanel extraDetails = new JPanel();
			extraDetails.setLayout(new BoxLayout(extraDetails, BoxLayout.Y_AXIS));
			extraDetails.setBackground(panel.getBackground());
			extraDetails.setBorder(new EmptyBorder(5, 0, 0, 0));

			JLabel focusHint = new JLabel("Click to focus • Press hotkey to auto-fill GE");
			focusHint.setForeground(COLOR_FOCUSED_BORDER);
			focusHint.setFont(new Font(FONT_ARIAL, Font.ITALIC, 10));

			extraDetails.add(focusHint);
			panel.add(extraDetails, BorderLayout.SOUTH);
			return true;
		}
		else
		{
			// Remove extra details
			if (panel.getComponentCount() > 2)
			{
				panel.remove(2);
			}
			return false;
		}
	}
	
	/**
	 * Update child panel backgrounds
	 */
	private void updateChildBackgrounds(JPanel panel, Color color)
	{
		for (Component comp : panel.getComponents())
		{
			if (comp instanceof JPanel)
			{
				((JPanel) comp).setBackground(color);
				for (Component child : ((JPanel) comp).getComponents())
				{
					if (child instanceof JPanel)
					{
						((JPanel) child).setBackground(color);
					}
				}
			}
		}
	}

	/**
	 * Get color based on risk score
	 */
	private Color getRiskColor(double score)
	{
		if (score <= 20)
		{
			return COLOR_PROFIT_GREEN; // Green
		}
		else if (score <= 40)
		{
			return new Color(150, 255, 100); // Yellow-green
		}
		else if (score <= 60)
		{
			return COLOR_YELLOW; // Yellow
		}
		else
		{
			return COLOR_LOSS_RED; // Red
		}
	}

	/**
	 * Format GP amount for display
	 */
	private String formatGP(int amount)
	{
		int absAmount = Math.abs(amount);
		String sign = amount < 0 ? "-" : "";
		
		if (absAmount >= 1_000_000)
		{
			return String.format("%s%.1fM", sign, absAmount / 1_000_000.0);
		}
		else if (absAmount >= 1_000)
		{
			return String.format("%s%.1fK", sign, absAmount / 1_000.0);
		}
		return String.valueOf(amount);
	}

	/**
	 * Format GP amount with commas for exact input (e.g., "1,234,567")
	 */
	private String formatGPExact(int amount)
	{
		return String.format("%,d", amount);
	}

	/**
	 * Holder for header panels (needed for hover effects)
	 */
	private static class HeaderPanels
	{
		final JPanel topPanel;
		final JPanel namePanel;

		HeaderPanels(JPanel topPanel, JPanel namePanel)
		{
			this.topPanel = topPanel;
			this.namePanel = namePanel;
		}
	}

	/**
	 * Create the item header panel with icon and name
	 */
	private HeaderPanels createItemHeaderPanels(int itemId, String itemName, Color bgColor)
	{
		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.setBackground(bgColor);

		JPanel namePanel = new JPanel(new BorderLayout(5, 0));
		namePanel.setBackground(bgColor);

		// Get item image
		AsyncBufferedImage itemImage = itemManager.getImage(itemId);
		JLabel iconLabel = new JLabel();
		setupIconLabel(iconLabel, itemImage);

		JLabel nameLabel = new JLabel(itemName);
		nameLabel.setForeground(Color.WHITE);
		nameLabel.setFont(FONT_BOLD_13);

		namePanel.add(iconLabel, BorderLayout.WEST);
		namePanel.add(nameLabel, BorderLayout.CENTER);
		topPanel.add(namePanel, BorderLayout.CENTER);

		return new HeaderPanels(topPanel, namePanel);
	}

	/**
	 * Format liquidity text for display
	 */
	private String formatLiquidityText(Double score, String rating, Double volumePerHour)
	{
		if (score == null)
		{
			return LIQUIDITY_NA;
		}
		String displayRating = rating != null ? rating : UNKNOWN_RATING;
		String volText = volumePerHour != null ? formatGP(volumePerHour.intValue()) + "/hr" : "";
		return String.format(FORMAT_LIQUIDITY, score, displayRating, volText);
	}

	/**
	 * Format risk text for display
	 */
	private String formatRiskText(Double score, String rating)
	{
		if (score == null)
		{
			return RISK_NA;
		}
		String displayRating = rating != null ? rating : UNKNOWN_RATING;
		return String.format(FORMAT_RISK, score, displayRating);
	}

	/**
	 * Format margin text with ROI for display
	 */
	private String formatMarginText(int marginPerItem, double roi, boolean isLoss)
	{
		String marginText = Math.abs(marginPerItem) >= 1000 
			? formatGP(marginPerItem) 
			: formatGPExact(marginPerItem);
		
		// Handle Infinity/NaN ROI (happens when cost is 0, e.g. pending orders with no fills)
		if (Double.isInfinite(roi) || Double.isNaN(roi))
		{
			return String.format("Margin: %s (pending)", marginText);
		}
		
		if (isLoss)
		{
			return String.format(FORMAT_MARGIN_ROI_LOSS, marginText, roi);
		}
		return String.format(FORMAT_MARGIN_ROI, marginText, roi);
	}

	/**
	 * Format profit and cost text for display
	 */
	private String formatProfitCostText(int totalProfit, int totalCost)
	{
		String profitText = Math.abs(totalProfit) >= 1000 
			? formatGP(totalProfit) 
			: formatGPExact(totalProfit);
		return String.format(FORMAT_PROFIT_COST, profitText, formatGP(totalCost));
	}

	/**
	 * Format buy/sell prices text for display
	 */
	private String formatBuySellText(int buyPrice, Integer sellPrice)
	{
		String sellText = sellPrice != null && sellPrice > 0 
			? formatGPExact(sellPrice) 
			: "N/A";
		return String.format(FORMAT_BUY_SELL, formatGPExact(buyPrice), sellText);
	}

	/**
	 * Create a styled JLabel with common settings for detail rows
	 */
	private JLabel createStyledLabel(String text, Color foreground)
	{
		JLabel label = new JLabel(text);
		label.setForeground(foreground);
		label.setFont(FONT_PLAIN_12);
		label.setAlignmentX(Component.LEFT_ALIGNMENT);
		return label;
	}

	/**
	 * Create a details panel with BoxLayout for vertical rows
	 */
	private JPanel createDetailsPanel(Color bgColor)
	{
		JPanel detailsPanel = new JPanel();
		detailsPanel.setLayout(new BoxLayout(detailsPanel, BoxLayout.Y_AXIS));
		detailsPanel.setBackground(bgColor);
		detailsPanel.setBorder(new EmptyBorder(5, 0, 0, 0));
		return detailsPanel;
	}

	/**
	 * Add labels to a details panel with standard 2px vertical spacing
	 */
	private void addLabelsWithSpacing(JPanel panel, JLabel... labels)
	{
		for (int i = 0; i < labels.length; i++)
		{
			panel.add(labels[i]);
			if (i < labels.length - 1)
			{
				panel.add(Box.createRigidArea(new Dimension(0, 2)));
			}
		}
	}

	/**
	 * Update background color for multiple panels (used in mouse listeners)
	 */
	private void setPanelBackgrounds(Color color, JPanel... panels)
	{
		for (JPanel panel : panels)
		{
			panel.setBackground(color);
		}
	}

	/**
	 * Create a base panel with common settings for flip/recommendation items
	 */
	private JPanel createBaseItemPanel(Color bgColor, int maxHeight, boolean handCursor)
	{
		JPanel panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.setBackground(bgColor);
		panel.setBorder(new EmptyBorder(8, 8, 8, 8));
		panel.setAlignmentX(Component.LEFT_ALIGNMENT);
		panel.setMaximumSize(new Dimension(Integer.MAX_VALUE, maxHeight));
		if (handCursor)
		{
			panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		}
		return panel;
	}

	/**
	 * Update liquidity label with data from analysis
	 */
	private void updateLiquidityLabel(JLabel label, FlipAnalysis.Liquidity liquidity)
	{
		label.setText(liquidity != null 
			? formatLiquidityText(liquidity.getScore(), liquidity.getRating(), liquidity.getTotalVolumePerHour())
			: LIQUIDITY_NA);
	}

	/**
	 * Update risk label with data from analysis
	 */
	private void updateRiskLabel(JLabel label, FlipAnalysis.Risk risk)
	{
		if (risk != null && risk.getScore() != null)
		{
			label.setText(formatRiskText(risk.getScore(), risk.getRating()));
			label.setForeground(getRiskColor(risk.getScore()));
		}
		else
		{
			label.setText(RISK_NA);
		}
	}

	/**
	 * Setup icon label with async image loading
	 */
	private void setupIconLabel(JLabel iconLabel, AsyncBufferedImage itemImage)
	{
		if (itemImage != null)
		{
			iconLabel.setIcon(new ImageIcon(itemImage));
			itemImage.onLoaded(() ->
			{
				iconLabel.setIcon(new ImageIcon(itemImage));
				iconLabel.revalidate();
				iconLabel.repaint();
			});
		}
		else
		{
			iconLabel.setPreferredSize(new Dimension(32, 32));
		}
	}

	/**
	 * Set the cash stack for filtering recommendations
	 * @param cashStack the cash stack value (used to trigger refresh)
	 */
	@SuppressWarnings("unused")
	public void setCashStack(Integer cashStack)
	{
		// This will trigger a refresh with the new cash stack
		refresh();
	}

	/**
	 * Get the current recommendations
	 */
	public List<FlipRecommendation> getCurrentRecommendations()
	{
		return new ArrayList<>(currentRecommendations);
	}
	
	/**
	 * Get the current active flips
	 */
	public List<ActiveFlip> getCurrentActiveFlips()
	{
		return new ArrayList<>(currentActiveFlips);
	}
	
	/**
	 * Check if an item exists in recommendations or active flips
	 */
	public boolean hasFlipForItem(int itemId)
	{
		// Check recommendations
		for (FlipRecommendation rec : currentRecommendations)
		{
			if (rec.getItemId() == itemId)
			{
				return true;
			}
		}
		// Check active flips
		for (ActiveFlip flip : currentActiveFlips)
		{
			if (flip.getItemId() == itemId)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Validate the current focus - clear it if the flip no longer exists
	 */
	public void validateFocus()
	{
		if (currentFocusedItemId <= 0)
		{
			return;
		}
		
		// Check if the focused item still exists in recommendations or active flips
		if (!hasFlipForItem(currentFocusedItemId))
		{
			log.debug("Clearing Flip Assist focus - item {} no longer in recommendations or active flips", currentFocusedItemId);
			clearFocus();
		}
	}
	
	/**
	 * Set the callback for when the focused flip changes
	 */
	public void setOnFocusChanged(java.util.function.Consumer<FocusedFlip> callback)
	{
		this.onFocusChanged = callback;
	}
	
	/**
	 * Set the callback for when authentication succeeds.
	 * This allows the plugin to sync RSN after Discord login.
	 */
	public void setOnAuthSuccess(Runnable callback)
	{
		this.onAuthSuccess = callback;
	}
	
	/**
	 * Set a recommendation as the current focus for Flip Assist
	 */
	private void setFocus(FlipRecommendation rec, JPanel panel)
	{
		// Create focused flip for buying with price offset applied
		int priceOffset = config.priceOffset();
		FocusedFlip newFocus = FocusedFlip.forBuy(
			rec.getItemId(),
			rec.getItemName(),
			rec.getRecommendedBuyPrice(),
			rec.getRecommendedQuantity(),
			rec.getRecommendedSellPrice(),
			priceOffset
		);
		
		updateFocus(newFocus, panel);
	}
	
	/**
	 * Set an active flip as the current focus for Flip Assist.
	 * Uses the cached sell price from the panel display to ensure consistency.
	 */
	private void setFocus(ActiveFlip flip, JPanel panel)
	{
		// Use the cached sell price that's already displayed in the panel
		// This ensures the Flip Assist shows the same price as the Active Flips tab
		Integer cachedSellPrice = displayedSellPrices.get(flip.getItemId());
		int priceOffset = config.priceOffset();
		
		if (cachedSellPrice != null && cachedSellPrice > 0)
		{
			// Use the price that's already shown in the UI with offset applied
			FocusedFlip newFocus = FocusedFlip.forSell(
				flip.getItemId(),
				flip.getItemName(),
				cachedSellPrice,
				flip.getTotalQuantity(),
				priceOffset
			);
			updateFocus(newFocus, panel);
		}
		else
		{
			// Fallback: fetch market data if no cached price (shouldn't normally happen)
			apiClient.getItemAnalysisAsync(flip.getItemId()).thenAccept(analysis ->
			{
				Integer currentMarketPrice = null;
				Integer dailyVolume = null;
				
				if (analysis != null && analysis.getCurrentPrices() != null)
				{
					FlipAnalysis.CurrentPrices prices = analysis.getCurrentPrices();
					currentMarketPrice = prices.getHigh();
					
					if (analysis.getLiquidity() != null && analysis.getLiquidity().getTotalVolumePerHour() != null)
					{
						dailyVolume = (int)(analysis.getLiquidity().getTotalVolumePerHour() * 24);
					}
				}
				
				// Calculate smart sell price
				Integer smartSellPrice = calculateSmartSellPrice(flip, currentMarketPrice, dailyVolume);
				int sellPrice = smartSellPrice != null ? smartSellPrice : calculateMinProfitableSellPrice(flip.getAverageBuyPrice());
				
				// Cache this price for future use
				displayedSellPrices.put(flip.getItemId(), sellPrice);
				
				// Create focused flip for selling with offset applied
				FocusedFlip newFocus = FocusedFlip.forSell(
					flip.getItemId(),
					flip.getItemName(),
					sellPrice,
					flip.getTotalQuantity(),
					priceOffset
				);
				
				SwingUtilities.invokeLater(() -> updateFocus(newFocus, panel));
			});
		}
	}
	
	/**
	 * Set a pending order as the current focus for Flip Assist (selling step)
	 */
	private void setFocus(FlipSmartPlugin.PendingOrder pending, JPanel panel)
	{
		// Pending orders that are filled should show sell step
		int sellPrice = pending.recommendedSellPrice != null 
			? pending.recommendedSellPrice 
			: (int)(pending.pricePerItem * 1.05); // Default 5% markup
		
		// Create focused flip for selling the filled items with price offset applied
		int priceOffset = config.priceOffset();
		FocusedFlip newFocus = FocusedFlip.forSell(
			pending.itemId,
			pending.itemName,
			sellPrice,
			pending.quantityFilled > 0 ? pending.quantityFilled : pending.quantity,
			priceOffset
		);
		
		updateFocus(newFocus, panel);
	}
	
	/**
	 * Update the current focus and visual state
	 */
	private void updateFocus(FocusedFlip newFocus, JPanel panel)
	{
		// Reset previous focused panel
		if (currentFocusedPanel != null)
		{
			resetPanelStyle(currentFocusedPanel);
		}
		
		// If clicking the same item, toggle off
		if (currentFocus != null && currentFocus.getItemId() == newFocus.getItemId() 
			&& currentFocus.getStep() == newFocus.getStep())
		{
			currentFocus = null;
			currentFocusedPanel = null;
			currentFocusedItemId = -1;
			
			if (onFocusChanged != null)
			{
				onFocusChanged.accept(null);
			}
			return;
		}
		
		// Set new focus
		currentFocus = newFocus;
		currentFocusedPanel = panel;
		currentFocusedItemId = newFocus.getItemId();
		
		// Update panel style to show focus
		applyFocusedStyle(panel);
		
		// Notify callback
		if (onFocusChanged != null)
		{
			try
			{
				onFocusChanged.accept(newFocus);
			}
			catch (Exception e)
			{
				log.warn("Error in onFocusChanged callback", e);
			}
		}
		
		log.info("Set Flip Assist focus: {} - {} at {} gp x{}", 
			newFocus.getStep(), 
			newFocus.getItemName(), 
			newFocus.getCurrentStepPrice(),
			newFocus.getCurrentStepQuantity());
	}
	
	/**
	 * Apply focused style to a panel
	 */
	private void applyFocusedStyle(JPanel panel)
	{
		panel.setBackground(COLOR_FOCUSED_BG);
		panel.setBorder(BorderFactory.createCompoundBorder(
			BorderFactory.createLineBorder(COLOR_FOCUSED_BORDER, 2),
			BorderFactory.createEmptyBorder(6, 8, 6, 8)
		));
		
		// Update child panel backgrounds
		for (Component comp : panel.getComponents())
		{
			if (comp instanceof JPanel)
			{
				((JPanel) comp).setBackground(COLOR_FOCUSED_BG);
				for (Component child : ((JPanel) comp).getComponents())
				{
					if (child instanceof JPanel)
					{
						((JPanel) child).setBackground(COLOR_FOCUSED_BG);
					}
				}
			}
		}
		
		panel.revalidate();
		panel.repaint();
	}
	
	/**
	 * Reset a panel to its default style
	 */
	private void resetPanelStyle(JPanel panel)
	{
		panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		panel.setBorder(new EmptyBorder(8, 10, 8, 10));
		
		// Reset child panel backgrounds
		for (Component comp : panel.getComponents())
		{
			if (comp instanceof JPanel)
			{
				((JPanel) comp).setBackground(ColorScheme.DARKER_GRAY_COLOR);
				for (Component child : ((JPanel) comp).getComponents())
				{
					if (child instanceof JPanel)
					{
						((JPanel) child).setBackground(ColorScheme.DARKER_GRAY_COLOR);
					}
				}
			}
		}
		
		panel.revalidate();
		panel.repaint();
	}
	
	/**
	 * Get the current focused flip
	 */
	public FocusedFlip getCurrentFocus()
	{
		return currentFocus;
	}
	
	/**
	 * Get the displayed sell price for an item from the Active Flips panel.
	 * This is the "smart" price that considers time thresholds and market conditions.
	 * @param itemId The item ID
	 * @return The displayed sell price, or null if not cached
	 */
	public Integer getDisplayedSellPrice(int itemId)
	{
		return displayedSellPrices.get(itemId);
	}
	
	/**
	 * Clear the current focus
	 */
	public void clearFocus()
	{
		if (currentFocusedPanel != null)
		{
			resetPanelStyle(currentFocusedPanel);
		}
		currentFocus = null;
		currentFocusedPanel = null;
		currentFocusedItemId = -1;
		
		if (onFocusChanged != null)
		{
			onFocusChanged.accept(null);
		}
	}
	
	/**
	 * Set focus from external source (e.g., auto-focus when setting up a sell offer).
	 * This sets the logical focus without highlighting a specific panel.
	 */
	public void setExternalFocus(FocusedFlip focus)
	{
		if (focus == null)
		{
			clearFocus();
			return;
		}
		
		// Clear any existing panel highlight
		if (currentFocusedPanel != null)
		{
			resetPanelStyle(currentFocusedPanel);
			currentFocusedPanel = null;
		}
		
		// Set the focus state
		currentFocus = focus;
		currentFocusedItemId = focus.getItemId();
		
		// Note: We don't have a panel to highlight since this was set externally
		// The Flip Assist overlay will show the focused item info
		
		log.debug("External focus set: {} - {} at {} gp", 
			focus.isBuying() ? "BUY" : "SELL",
			focus.getItemName(),
			focus.getCurrentStepPrice());
	}

	/**
	 * Create a panel for an active flip with current market data
	 */
	private JPanel createActiveFlipPanel(ActiveFlip flip)
	{
		JPanel panel = createBaseItemPanel(ColorScheme.DARKER_GRAY_COLOR, 180, true);

		// Top section: Item icon and name
		HeaderPanels header = createItemHeaderPanels(flip.getItemId(), flip.getItemName(), ColorScheme.DARKER_GRAY_COLOR);
		JPanel topPanel = header.topPanel;
		JPanel namePanel = header.namePanel;

		// Details section using BoxLayout for vertical rows
		JPanel detailsPanel = createDetailsPanel(ColorScheme.DARKER_GRAY_COLOR);

		// Row 1: Buy: X | Sell: Y (placeholders until data loads)
		JLabel pricesLabel = createStyledLabel(
			String.format("Buy: %s | Sell: ...", formatGPExact(flip.getAverageBuyPrice())), Color.WHITE);

		// Row 2: Qty: X (Limit: Y)
		JLabel qtyLabel = createStyledLabel(
			String.format("Qty: %d (Limit: ...)", flip.getTotalQuantity()), COLOR_TEXT_GRAY);

		// Row 3: Tax = Z
		JLabel taxLabel = createStyledLabel("Tax = ...", Color.CYAN);

		// Row 4: Margin: X (Y% ROI)
		JLabel marginLabel = createStyledLabel("Margin: ...", COLOR_YELLOW);

		// Row 5: Profit: X | Cost: Y
		JLabel profitCostLabel = createStyledLabel(
			String.format("Profit: ... | Cost: %s", formatGP(flip.getTotalInvested())), COLOR_PROFIT_GREEN);

		// Row 6: Liquidity: X (Rating) | Y/hr
		JLabel liquidityLabel = createStyledLabel("Liquidity: ...", Color.CYAN);

		// Row 7: Risk: X (Rating)
		JLabel riskLabel = createStyledLabel("Risk: ...", COLOR_YELLOW);

		// Add all rows with small spacing
		addLabelsWithSpacing(detailsPanel, pricesLabel, qtyLabel, taxLabel, marginLabel, 
			profitCostLabel, liquidityLabel, riskLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Fetch current market data to populate all fields
		apiClient.getItemAnalysisAsync(flip.getItemId()).thenAccept(analysis ->
		{
			SwingUtilities.invokeLater(() ->
			{
				Integer currentMarketPrice = null;
				Integer dailyVolume = null;
				Integer buyLimit = null;
				FlipAnalysis.Liquidity liquidity = null;
				FlipAnalysis.Risk risk = null;
				
				if (analysis != null)
				{
					buyLimit = analysis.getBuyLimit();
					liquidity = analysis.getLiquidity();
					risk = analysis.getRisk();
					
					if (analysis.getCurrentPrices() != null)
					{
						FlipAnalysis.CurrentPrices prices = analysis.getCurrentPrices();
						currentMarketPrice = prices.getHigh();
					}
					
					// Get daily volume from liquidity info
					if (liquidity != null && liquidity.getTotalVolumePerHour() != null)
					{
						dailyVolume = (int)(liquidity.getTotalVolumePerHour() * 24);
					}
				}
				
				// Calculate smart sell price based on time, volume, and profitability
				Integer smartSellPrice = calculateSmartSellPrice(flip, currentMarketPrice, dailyVolume);
				boolean pastThreshold = shouldUseLossMinimizingPrice(flip, dailyVolume);
				
				if (smartSellPrice != null && smartSellPrice > 0)
				{
					// Cache the displayed sell price so Flip Assist uses the same value
					displayedSellPrices.put(flip.getItemId(), smartSellPrice);
					
					// Update Flip Assist if this item is currently focused
					if (currentFocus != null && currentFocus.getItemId() == flip.getItemId() && currentFocus.isSelling())
					{
						int priceOffset = config.priceOffset();
						FocusedFlip updatedFocus = FocusedFlip.forSell(
							flip.getItemId(),
							flip.getItemName(),
							smartSellPrice,
							flip.getTotalQuantity(),
							priceOffset
						);
						currentFocus = updatedFocus;
						if (onFocusChanged != null)
						{
							onFocusChanged.accept(updatedFocus);
						}
					}
					
					// Row 1: Update Buy | Sell prices
					String priceSuffix = pastThreshold ? "*" : "";
					pricesLabel.setText(String.format("Buy: %s | Sell: %s%s", 
						formatGPExact(flip.getAverageBuyPrice()),
						formatGPExact(smartSellPrice),
						priceSuffix));

					// Calculate GE tax (2% capped at 5M)
					int geTax = Math.min((int)(smartSellPrice * 0.02), 5_000_000);
					
					// Calculate margin and profit
					int marginPerItem = smartSellPrice - flip.getAverageBuyPrice() - geTax;
					int totalProfit = marginPerItem * flip.getTotalQuantity();
					double roi = (marginPerItem * 100.0) / flip.getAverageBuyPrice();
					
					// Row 2: Update Qty (Limit) | Tax
					String limitText = buyLimit != null ? String.valueOf(buyLimit) : "?";
					qtyLabel.setText(String.format("Qty: %d (Limit: %s)", flip.getTotalQuantity(), limitText));
					taxLabel.setText(String.format("Tax = %s", formatGP(geTax * flip.getTotalQuantity())));
					
					// Row 3: Update Margin with ROI (show warning color if not profitable)
					marginLabel.setText(formatMarginText(marginPerItem, roi, totalProfit <= 0));
					marginLabel.setForeground(totalProfit <= 0 ? COLOR_LOSS_RED : COLOR_YELLOW);
					
					// Row 4: Update Profit | Cost
					profitCostLabel.setText(formatProfitCostText(totalProfit, flip.getTotalInvested()));
					profitCostLabel.setForeground(totalProfit > 0 ? COLOR_PROFIT_GREEN : COLOR_LOSS_RED);
					
					// Show warning tooltip if past threshold and losing money
					if (pastThreshold && totalProfit < 0)
					{
						panel.setToolTipText("Price adjusted to minimize loss. Original recommended price was not achievable.");
					}
				}
				else
				{
					pricesLabel.setText(formatBuySellText(flip.getAverageBuyPrice(), null));
					marginLabel.setText("Margin: N/A");
					profitCostLabel.setText(String.format("Profit: N/A | Cost: %s", formatGP(flip.getTotalInvested())));
				}
				
				// Row 5: Update Liquidity
				updateLiquidityLabel(liquidityLabel, liquidity);
				
				// Row 6: Update Risk
				updateRiskLabel(riskLabel, risk);
			});
		});

		// Add hover effect, click to focus, and context menu
		panel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				// Left click: set as Flip Assist focus for selling
				if (e.getButton() == MouseEvent.BUTTON1 && !e.isPopupTrigger())
				{
					setFocus(flip, panel);
				}
			}
			
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != flip.getItemId() 
					|| !currentFocus.isSelling())
				{
					setPanelBackgrounds(ColorScheme.DARKER_GRAY_HOVER_COLOR, panel, topPanel, namePanel, detailsPanel);
				}
			}

			@Override
			public void mouseExited(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != flip.getItemId() 
					|| !currentFocus.isSelling())
				{
					setPanelBackgrounds(ColorScheme.DARKER_GRAY_COLOR, panel, topPanel, namePanel, detailsPanel);
				}
			}

			@Override
			public void mousePressed(MouseEvent e)
			{
				showContextMenu(e, flip);
			}

			@Override
			public void mouseReleased(MouseEvent e)
			{
				showContextMenu(e, flip);
			}

			private void showContextMenu(MouseEvent e, ActiveFlip flip)
			{
				if (e.isPopupTrigger())
				{
					JPopupMenu contextMenu = new JPopupMenu();
					
					// Add focus option
					JMenuItem focusItem = new JMenuItem("Set as Flip Assist Focus (Sell)");
					focusItem.addActionListener(ae -> setFocus(flip, panel));
					contextMenu.add(focusItem);
					
					contextMenu.addSeparator();
					
					JMenuItem dismissItem = new JMenuItem("Dismiss from Active Flips");
					dismissItem.addActionListener(ae -> dismissActiveFlip(flip));
					contextMenu.add(dismissItem);
					
					contextMenu.show(e.getComponent(), e.getX(), e.getY());
				}
			}
		});

		return panel;
	}

	/**
	 * Create a panel for a pending order (not yet filled)
	 * Uses same detailed layout as active flips with Liquidity/Risk data
	 */
	private JPanel createPendingOrderPanel(FlipSmartPlugin.PendingOrder pending)
	{
		Color bgColor = new Color(55, 55, 65); // Slightly different color for pending
		JPanel panel = createBaseItemPanel(bgColor, 180, false);

		// Top section: Item icon and name
		HeaderPanels header = createItemHeaderPanels(pending.itemId, pending.itemName, bgColor);
		JPanel topPanel = header.topPanel;
		JPanel namePanel = header.namePanel;

		// Details section using BoxLayout for vertical rows
		JPanel detailsPanel = createDetailsPanel(bgColor);

		// Row 1: Buy: X | Sell: Y (with placeholders until data loads)
		String sellText = pending.recommendedSellPrice != null && pending.recommendedSellPrice > 0
			? formatGPExact(pending.recommendedSellPrice) : "...";
		JLabel pricesLabel = createStyledLabel(
			String.format(FORMAT_BUY_SELL, formatGPExact(pending.pricePerItem), sellText), Color.WHITE);

		// Row 2: Qty: X/Y (Limit: Z)
		JLabel qtyLabel = createStyledLabel(
			String.format("Qty: %d/%d (Limit: ...)", pending.quantityFilled, pending.quantity), COLOR_TEXT_GRAY);

		// Row 3: Tax = W
		JLabel taxLabel = createStyledLabel("Tax = ...", Color.CYAN);

		// Row 4: Margin: X (Y% ROI)
		JLabel marginLabel = createStyledLabel("Margin: ...", COLOR_YELLOW);

		// Row 5: Profit: X | Cost: Y
		int potentialInvestment = pending.quantity * pending.pricePerItem;
		JLabel profitCostLabel = createStyledLabel(
			String.format("Profit: ... | Cost: %s", formatGP(potentialInvestment)), COLOR_PROFIT_GREEN);

		// Row 6: Liquidity: X (Rating) | Y/hr
		JLabel liquidityLabel = createStyledLabel("Liquidity: ...", Color.CYAN);

		// Row 7: Risk: X (Rating)
		JLabel riskLabel = createStyledLabel("Risk: ...", COLOR_YELLOW);

		// Add all rows with small spacing
		addLabelsWithSpacing(detailsPanel, pricesLabel, qtyLabel, taxLabel, marginLabel, 
			profitCostLabel, liquidityLabel, riskLabel);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Fetch market data to populate all fields
		apiClient.getItemAnalysisAsync(pending.itemId).thenAccept(analysis ->
		{
			SwingUtilities.invokeLater(() ->
			{
				Integer buyLimit = null;
				FlipAnalysis.Liquidity liquidity = null;
				FlipAnalysis.Risk risk = null;
				Integer currentSellPrice = null;
				
				if (analysis != null)
				{
					buyLimit = analysis.getBuyLimit();
					liquidity = analysis.getLiquidity();
					risk = analysis.getRisk();
					
					if (analysis.getCurrentPrices() != null)
					{
						currentSellPrice = analysis.getCurrentPrices().getHigh();
					}
				}
				
				// Use recommended sell price or current market price
				Integer sellPrice = pending.recommendedSellPrice != null && pending.recommendedSellPrice > 0
					? pending.recommendedSellPrice : currentSellPrice;
				
				if (sellPrice != null && sellPrice > 0)
				{
					// Row 1: Update prices
					pricesLabel.setText(formatBuySellText(pending.pricePerItem, sellPrice));

					// Calculate GE tax (2% capped at 5M)
					int geTax = Math.min((int)(sellPrice * 0.02), 5_000_000);
					
					// Calculate margin and profit
					int marginPerItem = sellPrice - pending.pricePerItem - geTax;
					int totalProfit = marginPerItem * pending.quantity;
					double roi = (marginPerItem * 100.0) / pending.pricePerItem;
					
					// Row 2: Update Qty (Limit) | Tax
					String limitText = buyLimit != null ? String.valueOf(buyLimit) : "?";
					qtyLabel.setText(String.format("Qty: %d/%d (Limit: %s)", 
						pending.quantityFilled, pending.quantity, limitText));
					taxLabel.setText(String.format("Tax = %s", formatGP(geTax * pending.quantity)));
					
					// Row 3: Update Margin
					marginLabel.setText(formatMarginText(marginPerItem, roi, totalProfit <= 0));
					marginLabel.setForeground(totalProfit <= 0 ? COLOR_LOSS_RED : COLOR_YELLOW);
					
					// Row 4: Update Profit | Cost
					profitCostLabel.setText(formatProfitCostText(totalProfit, potentialInvestment));
					profitCostLabel.setForeground(totalProfit > 0 ? COLOR_PROFIT_GREEN : COLOR_LOSS_RED);
				}
				else
				{
					pricesLabel.setText(formatBuySellText(pending.pricePerItem, null));
					marginLabel.setText("Margin: N/A");
					profitCostLabel.setText(String.format("Profit: N/A | Cost: %s", formatGP(potentialInvestment)));
				}
				
				// Row 5: Update Liquidity
				updateLiquidityLabel(liquidityLabel, liquidity);
				
				// Row 6: Update Risk
				updateRiskLabel(riskLabel, risk);
			});
		});

		// Add click listener for focus selection
		panel.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent e)
			{
				// Only allow focus if there are filled items to sell
				if (pending.quantityFilled > 0 && e.getButton() == MouseEvent.BUTTON1)
				{
					setFocus(pending, panel);
				}
			}
			
			@Override
			public void mouseEntered(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != pending.itemId)
				{
					setPanelBackgrounds(new Color(65, 65, 75), panel, topPanel, namePanel, detailsPanel);
				}
			}
			
			@Override
			public void mouseExited(MouseEvent e)
			{
				if (currentFocus == null || currentFocus.getItemId() != pending.itemId)
				{
					setPanelBackgrounds(bgColor, panel, topPanel, namePanel, detailsPanel);
				}
			}
		});
		
		// Set cursor to indicate clickable if filled
		if (pending.quantityFilled > 0)
		{
			panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		}

		return panel;
	}
	
	/**
	 * Create a panel for a completed flip
	 */
	private JPanel createCompletedFlipPanel(CompletedFlip flip)
	{
		// Color based on profit/loss
		Color backgroundColor = flip.isSuccessful() ? 
			new Color(40, 60, 40) : // Dark green for profit
			new Color(60, 40, 40);  // Dark red for loss
		JPanel panel = createBaseItemPanel(backgroundColor, 110, false);

		// Top section: Item icon and name
		HeaderPanels header = createItemHeaderPanels(flip.getItemId(), flip.getItemName(), backgroundColor);
		JPanel topPanel = header.topPanel;

		// Details section with profit/loss info - use GridBagLayout for tighter column spacing
		JPanel detailsPanel = new JPanel(new GridBagLayout());
		detailsPanel.setBackground(backgroundColor);
		detailsPanel.setBorder(new EmptyBorder(3, 0, 0, 0));
		
		GridBagConstraints gbc = new GridBagConstraints();
		gbc.anchor = GridBagConstraints.WEST;
		gbc.insets = new Insets(1, 0, 1, 15); // 15px gap between columns

		// Row 1: Quantity and Buy Price
		JLabel qtyLabel = new JLabel(String.format(FORMAT_QTY, flip.getQuantity()));
		qtyLabel.setForeground(COLOR_TEXT_GRAY);
		qtyLabel.setFont(FONT_PLAIN_12);

		JLabel buyPriceLabel = new JLabel(String.format("Buy: %s", formatGPExact(flip.getBuyPricePerItem())));
		buyPriceLabel.setForeground(COLOR_BUY_RED);
		buyPriceLabel.setFont(FONT_PLAIN_12);

		// Row 2: Invested and Sell Price
		JLabel investedLabel = new JLabel(String.format("Cost: %s", formatGP(flip.getBuyTotal())));
		investedLabel.setForeground(COLOR_TEXT_GRAY);
		investedLabel.setFont(FONT_PLAIN_12);

		JLabel sellPriceLabel = new JLabel(String.format(FORMAT_SELL, formatGPExact(flip.getSellPricePerItem())));
		sellPriceLabel.setForeground(COLOR_SELL_GREEN);
		sellPriceLabel.setFont(FONT_PLAIN_12);

		// Row 3: Net Profit and ROI
		JLabel profitLabel = new JLabel(String.format("Profit: %s", formatGP(flip.getNetProfit())));
		Color profitColor = flip.isSuccessful() ? 
			COLOR_PROFIT_GREEN : // Bright green
			COLOR_LOSS_RED;  // Bright red
		profitLabel.setForeground(profitColor);
		profitLabel.setFont(FONT_BOLD_12);

		JLabel roiLabel = new JLabel(String.format(FORMAT_ROI, flip.getRoiPercent()));
		roiLabel.setForeground(profitColor);
		roiLabel.setFont(FONT_BOLD_12);

		// Add labels with GridBagLayout - columns stay compact
		gbc.gridx = 0; gbc.gridy = 0; detailsPanel.add(qtyLabel, gbc);
		gbc.gridx = 1; gbc.gridy = 0; gbc.insets = new Insets(1, 0, 1, 0); detailsPanel.add(buyPriceLabel, gbc);
		gbc.gridx = 0; gbc.gridy = 1; gbc.insets = new Insets(1, 0, 1, 15); detailsPanel.add(investedLabel, gbc);
		gbc.gridx = 1; gbc.gridy = 1; gbc.insets = new Insets(1, 0, 1, 0); detailsPanel.add(sellPriceLabel, gbc);
		gbc.gridx = 0; gbc.gridy = 2; gbc.insets = new Insets(1, 0, 1, 15); detailsPanel.add(profitLabel, gbc);
		gbc.gridx = 1; gbc.gridy = 2; gbc.insets = new Insets(1, 0, 1, 0); detailsPanel.add(roiLabel, gbc);
		
		// Add horizontal glue to prevent stretching
		gbc.gridx = 2; gbc.gridy = 0; gbc.weightx = 1.0; gbc.fill = GridBagConstraints.HORIZONTAL;
		detailsPanel.add(Box.createHorizontalGlue(), gbc);

		panel.add(topPanel, BorderLayout.NORTH);
		panel.add(detailsPanel, BorderLayout.CENTER);

		// Add click to show more details
		panel.setCursor(new Cursor(Cursor.HAND_CURSOR));
		panel.addMouseListener(new MouseAdapter()
		{
			private boolean expanded = false;

			@Override
			public void mouseClicked(MouseEvent e)
			{
				if (!expanded)
				{
					// Add extra details
					JPanel extraDetails = new JPanel();
					extraDetails.setLayout(new BoxLayout(extraDetails, BoxLayout.Y_AXIS));
					extraDetails.setBackground(backgroundColor);
					extraDetails.setBorder(new EmptyBorder(5, 38, 0, 0));

					// Duration
					int hours = flip.getFlipDurationSeconds() / 3600;
					int minutes = (flip.getFlipDurationSeconds() % 3600) / 60;
					String duration = hours > 0 ? 
						String.format("%dh %dm", hours, minutes) :
						String.format("%dm", minutes);

					JLabel durationLabel = new JLabel(String.format("Duration: %s", duration));
					durationLabel.setForeground(COLOR_TEXT_DIM_GRAY);
					durationLabel.setFont(FONT_PLAIN_12);

					// GE Tax
					JLabel taxLabel = new JLabel(String.format("GE Tax: %s", formatGP(flip.getGeTax())));
					taxLabel.setForeground(COLOR_TEXT_DIM_GRAY);
					taxLabel.setFont(FONT_PLAIN_12);

					extraDetails.add(durationLabel);
					extraDetails.add(Box.createRigidArea(new Dimension(0, 2)));
					extraDetails.add(taxLabel);

					panel.add(extraDetails, BorderLayout.SOUTH);
					expanded = true;
				}
				else
				{
					// Remove extra details
					if (panel.getComponentCount() > 2)
					{
						panel.remove(2);
						expanded = false;
					}
				}

				panel.revalidate();
				panel.repaint();
			}
		});

		return panel;
	}
	
	/**
	 * Dismiss an active flip (remove from tracking)
	 */
	private void dismissActiveFlip(ActiveFlip flip)
	{
		int result = JOptionPane.showConfirmDialog(
			this,
			String.format("Remove %s from active flips?%n%nThis will hide it from tracking.%nUse this if you sold/used the items outside of the GE.", flip.getItemName()),
			"Dismiss Active Flip",
			JOptionPane.YES_NO_OPTION,
			JOptionPane.QUESTION_MESSAGE
		);

		if (result == JOptionPane.YES_OPTION)
		{
			// Dismiss asynchronously with RSN filter for multi-account support
			String rsn = plugin.getCurrentRsnSafe().orElse(null);
			apiClient.dismissActiveFlipAsync(flip.getItemId(), rsn).thenAccept(success ->
			{
				SwingUtilities.invokeLater(() ->
				{
					if (Boolean.TRUE.equals(success))
					{
						// Refresh the active flips list
						refreshActiveFlips();
						JOptionPane.showMessageDialog(
							this,
							String.format("%s has been removed from active flips.", flip.getItemName()),
							"Dismissed",
							JOptionPane.INFORMATION_MESSAGE
						);
					}
					else
					{
						JOptionPane.showMessageDialog(
							this,
							"Failed to dismiss active flip. Please try again.",
							"Error",
							JOptionPane.ERROR_MESSAGE
						);
					}
				});
			});
		}
	}
	
	/**
	 * Get the current scroll position of a scroll pane.
	 */
	private int getScrollPosition(JScrollPane scrollPane)
	{
		if (scrollPane == null || scrollPane.getVerticalScrollBar() == null)
		{
			return 0;
		}
		return scrollPane.getVerticalScrollBar().getValue();
	}
	
	/**
	 * Restore the scroll position of a scroll pane after content refresh.
	 * Uses invokeLater to ensure layout is complete before restoring.
	 */
	private void restoreScrollPosition(JScrollPane scrollPane, int position)
	{
		if (scrollPane == null || scrollPane.getVerticalScrollBar() == null || position <= 0)
		{
			return;
		}
		// Use invokeLater to restore after layout is complete
		SwingUtilities.invokeLater(() -> scrollPane.getVerticalScrollBar().setValue(position));
	}
	
	
	/**
	 * Calculate the sell price threshold time for an active flip.
	 * Returns the number of minutes after which we should switch from 
	 * profit-first to loss-minimizing strategy.
	 * 
	 * Rules:
	 * - High volume items (>500k daily): 10 minutes
	 * - High value items (>250M buy price): 30 minutes
	 * - Regular items: 20 minutes
	 */
	private int getSellPriceThresholdMinutes(ActiveFlip flip, Integer dailyVolume)
	{
		// High value items get more time
		if (flip.getAverageBuyPrice() >= HIGH_VALUE_THRESHOLD)
		{
			return HIGH_VALUE_TIME_MINUTES;
		}
		
		// High volume items should sell quickly
		if (dailyVolume != null && dailyVolume >= HIGH_VOLUME_THRESHOLD)
		{
			return HIGH_VOLUME_TIME_MINUTES;
		}
		
		// Regular items
		return REGULAR_TIME_MINUTES;
	}
	
	/**
	 * Check if an active flip has exceeded its time threshold and should
	 * switch to loss-minimizing sell price.
	 */
	private boolean shouldUseLossMinimizingPrice(ActiveFlip flip, Integer dailyVolume)
	{
		String buyTimeStr = flip.getLastBuyTime();
		if (buyTimeStr == null || buyTimeStr.isEmpty())
		{
			return false;
		}
		
		try
		{
			Instant buyTime = Instant.parse(buyTimeStr);
			Duration elapsed = Duration.between(buyTime, Instant.now());
			int thresholdMinutes = getSellPriceThresholdMinutes(flip, dailyVolume);
			return elapsed.toMinutes() >= thresholdMinutes;
		}
		catch (DateTimeParseException e)
		{
			log.debug("Failed to parse buy time: {}", buyTimeStr);
			return false;
		}
	}
	
	/**
	 * Calculate the minimum profitable sell price for an active flip.
	 * This is the price that would result in zero profit after tax.
	 * Formula: minSellPrice = buyPrice / (1 - taxRate)
	 * Adding 1gp ensures a small profit.
	 */
	private int calculateMinProfitableSellPrice(int buyPrice)
	{
		// GE tax is 2%, so to break even: sellPrice * 0.98 = buyPrice
		// sellPrice = buyPrice / 0.98
		// Add 1gp to ensure profit
		return (int) Math.ceil(buyPrice / 0.98) + 1;
	}
	
	/**
	 * Determine the smart sell price for an active flip.
	 * 
	 * Strategy:
	 * 1. First try to sell at the recommended price (profitable)
	 * 2. If no recommended price, calculate minimum profitable price
	 * 3. After time threshold, switch to current market price to minimize loss
	 * 
	 * @param flip The active flip
	 * @param currentMarketPrice The current instant sell price from market
	 * @param dailyVolume Daily trade volume (optional)
	 * @return The recommended sell price, or null to indicate need to fetch market price
	 */
	private Integer calculateSmartSellPrice(ActiveFlip flip, Integer currentMarketPrice, Integer dailyVolume)
	{
		int buyPrice = flip.getAverageBuyPrice();
		int minProfitablePrice = calculateMinProfitableSellPrice(buyPrice);
		
		// Check if we've exceeded the time threshold
		boolean pastThreshold = shouldUseLossMinimizingPrice(flip, dailyVolume);
		
		if (pastThreshold && currentMarketPrice != null)
		{
			// Past threshold: prioritize selling, even at potential loss
			// Use current market price, but at minimum use the market price
			// that gives best chance of selling
			return currentMarketPrice;
		}
		
		// Before threshold: prioritize profit
		if (flip.getRecommendedSellPrice() != null && flip.getRecommendedSellPrice() >= minProfitablePrice)
		{
			// Use recommended price if it's profitable
			return flip.getRecommendedSellPrice();
		}
		
		// No recommended price or it's not profitable - use minimum profitable price
		// but only if market price is higher (otherwise the flip was never good)
		if (currentMarketPrice != null && currentMarketPrice >= minProfitablePrice)
		{
			return minProfitablePrice;
		}
		
		// Market price is below profitable threshold
		// Before time threshold: still try to sell at profitable price
		// After threshold: this would be handled above
		if (flip.getRecommendedSellPrice() != null)
		{
			return flip.getRecommendedSellPrice();
		}
		
		return minProfitablePrice;
	}
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Represents an active flip (item bought but not yet sold)
 */
@Data
public class ActiveFlip
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	@SerializedName("total_quantity")
	private int totalQuantity;

	@SerializedName("original_quantity")
	private int originalQuantity;

	@SerializedName("average_buy_price")
	private int averageBuyPrice;

	@SerializedName("total_invested")
	private int totalInvested;

	@SerializedName("first_buy_time")
	private String firstBuyTime;

	@SerializedName("last_buy_time")
	private String lastBuyTime;

	@SerializedName("transaction_count")
	private int transactionCount;

	@SerializedName("recommended_sell_price")
	private Integer recommendedSellPrice;

	@SerializedName("order_quantity")
	private int orderQuantity;

	@SerializedName("phase")
	private String phase;  // "buy" or "sell"
}


package com.flipsmart;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.ItemManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.util.AsyncBufferedImage;

import javax.inject.Inject;
import java.awt.*;
import java.text.DecimalFormat;

/**
 * Flip Assist overlay - a unique step-by-step workflow guide.
 * 
 * Unlike other flipping tools that use widget highlights, this shows a
 * floating panel with:
 * - Horizontal progress indicator showing the complete flip journey
 * - Current step prominently displayed with animated effects
 * - All relevant info (item, price, qty, profit) in one place
 * - Clear hotkey prompts at each step
 * 
 * Design philosophy: Guide the player through the ENTIRE flip journey
 * from initial purchase to final sale, not just one transaction.
 */
@Slf4j
public class FlipAssistOverlay extends Overlay
{
	private static final DecimalFormat PRICE_FORMAT = new DecimalFormat("#,###");
	
	// Color theme
	private static final Color COLOR_BG_DARK = new Color(25, 22, 18, 245);
	private static final Color COLOR_BORDER = new Color(10, 10, 10);
	private static final Color COLOR_ACCENT = new Color(255, 185, 50);
	private static final Color COLOR_ACCENT_GLOW = new Color(255, 185, 50, 60);
	private static final Color COLOR_TEXT = new Color(245, 240, 230);
	private static final Color COLOR_TEXT_DIM = new Color(160, 150, 140);
	private static final Color COLOR_BUY = new Color(100, 220, 130);
	private static final Color COLOR_SELL = new Color(255, 140, 80);
	private static final Color COLOR_PROFIT = new Color(80, 255, 120);
	private static final Color COLOR_STEP_COMPLETE = new Color(80, 200, 100);
	private static final Color COLOR_STEP_CURRENT = COLOR_ACCENT;
	private static final Color COLOR_STEP_PENDING = new Color(80, 75, 70);
	private static final Color COLOR_ACTION_BOX = new Color(45, 42, 38);
	
	// Layout constants
	private static final int PANEL_WIDTH = 220;
	private static final int PANEL_HEIGHT = 170;
	private static final int HINT_PANEL_WIDTH = 200;
	private static final int HINT_PANEL_HEIGHT = 50;
	private static final int PADDING = 6;
	private static final int SECTION_PADDING = 10;
	private static final int ICON_SIZE = 28;
	private static final int STEP_INDICATOR_SIZE = 10;
	
	// Hint message
	private static final String HINT_TITLE = "Flip Assist";
	private static final String HINT_MESSAGE = "Click on a flip suggestion to start";
	
	// GE Interface IDs
	private static final int GE_INTERFACE_GROUP = 465;
	private static final int GE_OFFER_PANEL_CHILD = 26;
	private static final int GE_QTY_CHILD_START = 31;
	private static final int GE_QTY_CHILD_END = 36;
	private static final int GE_PRICE_CHILD_START = 38;
	private static final int GE_PRICE_CHILD_END = 44;
	// VarClientInt.INPUT_TYPE value (raw ID to avoid deprecated API)
	private static final int VARCLIENT_INPUT_TYPE = 5;
	private static final int INPUT_TYPE_NUMERIC = 7;
	private static final int INPUT_TYPE_GE_SEARCH = 14;
	private static final String COINS_TEXT = "coins";
	private static final int[] CHATBOX_WIDGET_GROUPS = {162, 163, 164, 217, 219, 229, 548, 161};
	
	private final Client client;
	private final ClientThread clientThread;
	private final FlipSmartConfig config;
	private final ItemManager itemManager;
	
	@Getter
	private FocusedFlip focusedFlip;
	
	// Animation state
	private long animationStartTime = System.currentTimeMillis();
	private static final long PULSE_DURATION = 1500; // ms for one pulse cycle
	
	/**
	 * The current step in the flip assist workflow
	 */
	public enum FlipAssistStep
	{
		SELECT_ITEM("Select Item", "Click BUY on an empty slot"),
		SEARCH_ITEM("Search Item", "Item auto-selected, press Enter"),
		SET_QUANTITY("Set Quantity", "Press [%s] to set qty: %s"),
		SET_PRICE("Set Price", "Press [%s] to set price: %s"),
		CONFIRM_OFFER("Confirm", "Click the confirm button"),
		WAITING_BUY("Buying...", "Offer placed, waiting to fill"),
		COLLECT_ITEMS("Collect", "Items bought! Collect from slot"),
		SELL_ITEMS("Sell Items", "Click SELL on collected items"),
		SET_SELL_PRICE("Set Sell Price", "Press [%s] to set: %s"),
		CONFIRM_SELL("Confirm Sale", "Click confirm to list"),
		WAITING_SELL("Selling...", "Listed! Waiting to sell"),
		COMPLETE("Complete!", "Flip finished - collect GP");
		
		private final String title;
		private final String description;
		
		FlipAssistStep(String title, String description)
		{
			this.title = title;
			this.description = description;
		}
		
		public String getTitle()
		{
			return title;
		}
		
		public String getDescription()
		{
			return description;
		}
	}
	
	@Getter
	private FlipAssistStep currentStep = FlipAssistStep.SELECT_ITEM;
	
	@Inject
	private FlipAssistOverlay(Client client, ClientThread clientThread, FlipSmartConfig config, ItemManager itemManager)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.config = config;
		this.itemManager = itemManager;
		
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_WIDGETS);
		setPriority(PRIORITY_HIGH);
		setMovable(true);
	}
	
	public void updateStep()
	{
		if (focusedFlip == null)
		{
			currentStep = FlipAssistStep.SELECT_ITEM;
			return;
		}
		
		if (!isGrandExchangeOpen())
		{
			currentStep = focusedFlip.isBuying() ? FlipAssistStep.WAITING_BUY : FlipAssistStep.WAITING_SELL;
			return;
		}
		
		int inputType = getInputType();
		if (inputType == INPUT_TYPE_GE_SEARCH)
		{
			currentStep = FlipAssistStep.SEARCH_ITEM;
			return;
		}
		
		if (inputType == INPUT_TYPE_NUMERIC)
		{
			currentStep = determineNumericInputStep();
			return;
		}
		
		if (isOfferSetupOpen())
		{
			currentStep = determineOfferSetupStep();
			return;
		}
		
		currentStep = focusedFlip.isBuying() ? FlipAssistStep.SELECT_ITEM : FlipAssistStep.SELL_ITEMS;
	}
	
	private FlipAssistStep determineNumericInputStep()
	{
		if (isLikelyPriceInput())
		{
			return focusedFlip.isBuying() ? FlipAssistStep.SET_PRICE : FlipAssistStep.SET_SELL_PRICE;
		}
		return FlipAssistStep.SET_QUANTITY;
	}
	
	private FlipAssistStep determineOfferSetupStep()
	{
		boolean qtyCorrect = isValueWithinTolerance(getCurrentQuantityFromGE(), focusedFlip.getCurrentStepQuantity());
		boolean priceCorrect = isValueWithinTolerance(getCurrentPriceFromGE(), focusedFlip.getCurrentStepPrice());
		
		if (qtyCorrect && priceCorrect)
		{
			return focusedFlip.isBuying() ? FlipAssistStep.CONFIRM_OFFER : FlipAssistStep.CONFIRM_SELL;
		}
		if (!qtyCorrect)
		{
			return FlipAssistStep.SET_QUANTITY;
		}
		return focusedFlip.isBuying() ? FlipAssistStep.SET_PRICE : FlipAssistStep.SET_SELL_PRICE;
	}
	
	/**
	 * Check if a GE value matches the target within ±1 tolerance.
	 * Tolerance is needed because GE can have slight rounding differences
	 * when displaying prices/quantities (e.g., 1gp variance in price).
	 */
	private boolean isValueWithinTolerance(int current, int target)
	{
		return current > 0 && target > 0 && Math.abs(current - target) <= 1;
	}
	
	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!config.enableFlipAssistant())
		{
			return null;
		}
		
		// If no flip is focused, show hint box when GE is open
		if (focusedFlip == null)
		{
			if (isGrandExchangeOpen())
			{
				return renderHintBox(graphics);
			}
			return null;
		}
		
		// Only show when GE is open or when we have an active flip
		if (!isGrandExchangeOpen() && !config.showAssistantAlways())
		{
			return null;
		}
		
		// Update step based on current game state
		updateStep();
		
		// Enable anti-aliasing
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		
		// Calculate animation phase for pulse effect
		long elapsed = System.currentTimeMillis() - animationStartTime;
		double pulsePhase = (elapsed % PULSE_DURATION) / (double) PULSE_DURATION;
		float pulseAlpha = (float) (0.5 + 0.5 * Math.sin(pulsePhase * 2 * Math.PI));
		
		int panelHeight = PANEL_HEIGHT;
		
		// Draw outer glow (animated)
		Color glowColor = new Color(
			COLOR_ACCENT_GLOW.getRed(),
			COLOR_ACCENT_GLOW.getGreen(),
			COLOR_ACCENT_GLOW.getBlue(),
			(int)(COLOR_ACCENT_GLOW.getAlpha() * pulseAlpha)
		);
		graphics.setColor(glowColor);
		graphics.fillRoundRect(-4, -4, PANEL_WIDTH + 8, panelHeight + 8, 16, 16);
		
		// Draw background
		graphics.setColor(COLOR_BG_DARK);
		graphics.fillRoundRect(0, 0, PANEL_WIDTH, panelHeight, 12, 12);
		
		// Draw thin black border
		graphics.setColor(COLOR_BORDER);
		graphics.setStroke(new BasicStroke(1));
		graphics.drawRoundRect(0, 0, PANEL_WIDTH, panelHeight, 12, 12);
		
		int y = PADDING;
		
		// Draw header section
		y = renderHeader(graphics, y);
		
		// Draw step progress indicator
		y = renderStepProgress(graphics, y, pulseAlpha);
		
		// Draw current action panel
		y = renderCurrentAction(graphics, y, pulseAlpha);
		
		// Draw flip summary
		renderFlipSummary(graphics, y);
		
		return new Dimension(PANEL_WIDTH, panelHeight);
	}
	
	/**
	 * Render a small hint box prompting user to click on a flip suggestion.
	 */
	private Dimension renderHintBox(Graphics2D graphics)
	{
		// Enable anti-aliasing
		graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		
		// Calculate pulse animation
		long elapsed = System.currentTimeMillis() - animationStartTime;
		double pulsePhase = (elapsed % PULSE_DURATION) / (double) PULSE_DURATION;
		float pulseAlpha = (float) (0.5 + 0.5 * Math.sin(pulsePhase * 2 * Math.PI));
		
		// Draw subtle outer glow (animated)
		Color glowColor = new Color(
			COLOR_ACCENT_GLOW.getRed(),
			COLOR_ACCENT_GLOW.getGreen(),
			COLOR_ACCENT_GLOW.getBlue(),
			(int)(COLOR_ACCENT_GLOW.getAlpha() * pulseAlpha * 0.5)
		);
		graphics.setColor(glowColor);
		graphics.fillRoundRect(-3, -3, HINT_PANEL_WIDTH + 6, HINT_PANEL_HEIGHT + 6, 10, 10);
		
		// Draw background
		graphics.setColor(COLOR_BG_DARK);
		graphics.fillRoundRect(0, 0, HINT_PANEL_WIDTH, HINT_PANEL_HEIGHT, 8, 8);
		
		// Draw accent border (animated)
		Color borderColor = new Color(
			COLOR_ACCENT.getRed(),
			COLOR_ACCENT.getGreen(),
			COLOR_ACCENT.getBlue(),
			(int)(150 + 100 * pulseAlpha)
		);
		graphics.setColor(borderColor);
		graphics.setStroke(new BasicStroke(1.5f));
		graphics.drawRoundRect(0, 0, HINT_PANEL_WIDTH, HINT_PANEL_HEIGHT, 8, 8);
		
		// Draw title
		graphics.setFont(FontManager.getRunescapeBoldFont());
		graphics.setColor(COLOR_ACCENT);
		FontMetrics boldMetrics = graphics.getFontMetrics();
		int titleWidth = boldMetrics.stringWidth(HINT_TITLE);
		graphics.drawString(HINT_TITLE, (HINT_PANEL_WIDTH - titleWidth) / 2, 20);
		
		// Draw hint message
		graphics.setFont(FontManager.getRunescapeSmallFont());
		graphics.setColor(COLOR_TEXT);
		FontMetrics smallMetrics = graphics.getFontMetrics();
		int msgWidth = smallMetrics.stringWidth(HINT_MESSAGE);
		graphics.drawString(HINT_MESSAGE, (HINT_PANEL_WIDTH - msgWidth) / 2, 38);
		
		return new Dimension(HINT_PANEL_WIDTH, HINT_PANEL_HEIGHT);
	}
	
	private int renderHeader(Graphics2D graphics, int y)
	{
		y += 4;
		
		AsyncBufferedImage itemImage = itemManager.getImage(focusedFlip.getItemId());
		if (itemImage != null)
		{
			graphics.drawImage(itemImage, SECTION_PADDING, y, ICON_SIZE, ICON_SIZE, null);
		}
		
		graphics.setFont(FontManager.getRunescapeBoldFont());
		graphics.setColor(COLOR_TEXT);
		String itemName = truncateString(focusedFlip.getItemName(), PANEL_WIDTH - ICON_SIZE - SECTION_PADDING * 3, graphics.getFontMetrics());
		graphics.drawString(itemName, SECTION_PADDING + ICON_SIZE + 6, y + 10);
		
		graphics.setFont(FontManager.getRunescapeSmallFont());
		graphics.setColor(focusedFlip.isBuying() ? COLOR_BUY : COLOR_SELL);
		graphics.drawString(focusedFlip.isBuying() ? "BUYING" : "SELLING", SECTION_PADDING + ICON_SIZE + 6, y + 24);
		
		return y + ICON_SIZE + 4;
	}
	
	private int renderStepProgress(Graphics2D graphics, int y, float pulseAlpha)
	{
		y += 4;
		FlipAssistStep[] stepsToShow = getStepsForCurrentPhase();
		int currentStepIndex = getStepIndex(currentStep, stepsToShow);
		int stepX = 20;
		int stepWidth = (PANEL_WIDTH - 40) / (stepsToShow.length - 1);
		
		for (int i = 0; i < stepsToShow.length; i++)
		{
			if (i > 0)
			{
				drawStepConnector(graphics, stepX, y, stepWidth, i <= currentStepIndex);
			}
			drawStepCircle(graphics, stepX, y, i, currentStepIndex, pulseAlpha);
			drawStepLabel(graphics, stepX, y, stepsToShow[i], i == currentStepIndex);
			stepX += stepWidth;
		}
		return y + 34;
	}
	
	private FlipAssistStep[] getStepsForCurrentPhase()
	{
		if (focusedFlip.isBuying())
		{
			return new FlipAssistStep[]{
				FlipAssistStep.SELECT_ITEM, FlipAssistStep.SET_QUANTITY,
				FlipAssistStep.SET_PRICE, FlipAssistStep.CONFIRM_OFFER
			};
		}
		return new FlipAssistStep[]{
			FlipAssistStep.SELL_ITEMS, FlipAssistStep.SET_QUANTITY,
			FlipAssistStep.SET_SELL_PRICE, FlipAssistStep.CONFIRM_SELL
		};
	}
	
	private void drawStepConnector(Graphics2D graphics, int stepX, int y, int stepWidth, boolean completed)
	{
		graphics.setColor(completed ? COLOR_STEP_COMPLETE : COLOR_STEP_PENDING);
		graphics.setStroke(new BasicStroke(2));
		int lineGap = 6;
		int yCenter = y + STEP_INDICATOR_SIZE / 2;
		graphics.drawLine(stepX - stepWidth + STEP_INDICATOR_SIZE / 2 + lineGap, yCenter,
			stepX - STEP_INDICATOR_SIZE / 2 - lineGap, yCenter);
	}
	
	private void drawStepCircle(Graphics2D graphics, int stepX, int y, int index, int currentIndex, float pulseAlpha)
	{
		Color stepColor = getStepColor(index, currentIndex, pulseAlpha);
		graphics.setColor(stepColor);
		graphics.fillOval(stepX - STEP_INDICATOR_SIZE / 2, y, STEP_INDICATOR_SIZE, STEP_INDICATOR_SIZE);
		
		graphics.setColor(COLOR_BG_DARK);
		if (index < currentIndex)
		{
			graphics.setFont(new Font("Arial", Font.BOLD, 7));
			graphics.drawString("✓", stepX - 2, y + 8);
		}
		else if (index == currentIndex)
		{
			graphics.setFont(new Font("Arial", Font.BOLD, 8));
			graphics.drawString(String.valueOf(index + 1), stepX - 2, y + 8);
		}
	}
	
	private Color getStepColor(int index, int currentIndex, float pulseAlpha)
	{
		if (index < currentIndex)
		{
			return COLOR_STEP_COMPLETE;
		}
		if (index == currentIndex)
		{
			return new Color(COLOR_STEP_CURRENT.getRed(), COLOR_STEP_CURRENT.getGreen(),
				COLOR_STEP_CURRENT.getBlue(), (int)(180 + 75 * pulseAlpha));
		}
		return COLOR_STEP_PENDING;
	}
	
	private void drawStepLabel(Graphics2D graphics, int stepX, int y, FlipAssistStep step, boolean isCurrent)
	{
		graphics.setFont(FontManager.getRunescapeSmallFont());
		graphics.setColor(isCurrent ? COLOR_TEXT : COLOR_TEXT_DIM);
		String label = getShortStepLabel(step);
		int labelWidth = graphics.getFontMetrics().stringWidth(label);
		graphics.drawString(label, stepX - labelWidth / 2, y + STEP_INDICATOR_SIZE + 12);
	}
	
	private int renderCurrentAction(Graphics2D graphics, int y, float pulseAlpha)
	{
		int boxHeight = 42;
		int boxMargin = 10;
		int boxWidth = PANEL_WIDTH - boxMargin * 2;
		
		graphics.setColor(COLOR_ACTION_BOX);
		graphics.fillRoundRect(boxMargin, y, boxWidth, boxHeight, 6, 6);
		
		Color borderColor = new Color(COLOR_ACCENT.getRed(), COLOR_ACCENT.getGreen(),
			COLOR_ACCENT.getBlue(), (int)(150 + 100 * pulseAlpha));
		graphics.setColor(borderColor);
		graphics.setStroke(new BasicStroke(1.5f));
		graphics.drawRoundRect(boxMargin, y, boxWidth, boxHeight, 6, 6);
		
		drawCenteredText(graphics, currentStep.getTitle(), y + 18, FontManager.getRunescapeBoldFont(), COLOR_ACCENT);
		drawCenteredText(graphics, formatStepDescription(), y + 34, FontManager.getRunescapeSmallFont(), COLOR_TEXT);
		
		return y + boxHeight + 4;
	}
	
	private void drawCenteredText(Graphics2D graphics, String text, int y, Font font, Color color)
	{
		graphics.setFont(font);
		graphics.setColor(color);
		int width = graphics.getFontMetrics().stringWidth(text);
		graphics.drawString(text, (PANEL_WIDTH - width) / 2, y);
	}
	
	private void renderFlipSummary(Graphics2D graphics, int y)
	{
		graphics.setFont(FontManager.getRunescapeSmallFont());
		int lineHeight = 12;
		
		String priceLabel = focusedFlip.isBuying() ? "Buy at:" : "Sell at:";
		drawLabelValue(graphics, priceLabel, PRICE_FORMAT.format(focusedFlip.getCurrentStepPrice()) + " gp",
			y + lineHeight, focusedFlip.isBuying() ? COLOR_BUY : COLOR_SELL);
		
		drawLabelValue(graphics, "Qty:", PRICE_FORMAT.format(focusedFlip.getCurrentStepQuantity()),
			y + lineHeight * 2, COLOR_TEXT);
		
		if (focusedFlip.isBuying() && focusedFlip.getSellPrice() > 0)
		{
			int totalProfit = calculateTotalProfit();
			drawLabelValue(graphics, "Profit:", PRICE_FORMAT.format(totalProfit) + " gp",
				y + lineHeight * 3, totalProfit > 0 ? COLOR_PROFIT : new Color(255, 100, 100));
		}
	}
	
	private void drawLabelValue(Graphics2D graphics, String label, String value, int y, Color valueColor)
	{
		graphics.setColor(COLOR_TEXT_DIM);
		graphics.drawString(label, SECTION_PADDING, y);
		graphics.setColor(valueColor);
		graphics.drawString(value, SECTION_PADDING + 42, y);
	}
	
	private int calculateTotalProfit()
	{
		int margin = focusedFlip.getSellPrice() - focusedFlip.getBuyPrice();
		int geTax = Math.min((int)(focusedFlip.getSellPrice() * 0.02), 5_000_000);
		return (margin - geTax) * focusedFlip.getBuyQuantity();
	}
	
	private String formatStepDescription()
	{
		String hotkeyName = config.flipAssistHotkey().toString();
		
		switch (currentStep)
		{
			case SET_QUANTITY:
				int targetQty = focusedFlip.getCurrentStepQuantity();
				// Just show the target quantity with hotkey
				return String.format(currentStep.getDescription(), hotkeyName, 
					PRICE_FORMAT.format(targetQty));
			case SET_PRICE:
			case SET_SELL_PRICE:
				int targetPrice = focusedFlip.getCurrentStepPrice();
				// Just show the target price with hotkey
				return String.format(currentStep.getDescription(), hotkeyName,
					PRICE_FORMAT.format(targetPrice));
			default:
				return currentStep.getDescription();
		}
	}
	
	private String getShortStepLabel(FlipAssistStep step)
	{
		switch (step)
		{
			case SELECT_ITEM:
			case SELL_ITEMS:
				return "Select";
			case SET_QUANTITY:
				return "Qty";
			case SET_PRICE:
			case SET_SELL_PRICE:
				return "Price";
			case CONFIRM_OFFER:
			case CONFIRM_SELL:
				return "Confirm";
			case COMPLETE:
				return "Done";
			default:
				return step.getTitle().substring(0, Math.min(5, step.getTitle().length()));
		}
	}
	
	private int getStepIndex(FlipAssistStep step, FlipAssistStep[] steps)
	{
		for (int i = 0; i < steps.length; i++)
		{
			if (steps[i] == step || isEquivalentStep(steps[i], step))
			{
				return i;
			}
		}
		return 0;
	}
	
	private boolean isEquivalentStep(FlipAssistStep a, FlipAssistStep b)
	{
		if ((a == FlipAssistStep.SELECT_ITEM || a == FlipAssistStep.SELL_ITEMS) && b == FlipAssistStep.SEARCH_ITEM)
		{
			return true;
		}
		return a == FlipAssistStep.SET_QUANTITY && b == FlipAssistStep.SET_QUANTITY;
	}
	
	private boolean isGrandExchangeOpen()
	{
		// Check the main GE interface (465) - this is the primary indicator
		Widget geWidget = client.getWidget(GE_INTERFACE_GROUP, 0);
		if (geWidget != null && !geWidget.isHidden())
		{
			return true;
		}
		
		// Also check if we're in the GE offer setup dialog specifically
		// Widget 162 is the chatbox which is used for many dialogs, so we need
		// to verify it's actually a GE-related dialog by checking for GE-specific content
		Widget offerPanel = client.getWidget(GE_INTERFACE_GROUP, GE_OFFER_PANEL_CHILD);
		return offerPanel != null && !offerPanel.isHidden();
	}
	
	private boolean isOfferSetupOpen()
	{
		Widget[] children = getOfferPanelChildren();
		if (children.length < 30)
		{
			return false;
		}
		
		boolean hasQuantityLabel = false;
		boolean hasPriceCoins = false;
		
		for (Widget child : children)
		{
			String text = getVisibleWidgetText(child);
			if (text != null)
			{
				hasQuantityLabel = hasQuantityLabel || text.contains("Quantity:");
				hasPriceCoins = hasPriceCoins || (text.contains(COINS_TEXT) && text.matches(".*\\d+.*"));
			}
		}
		return hasQuantityLabel && hasPriceCoins;
	}
	
	private Widget[] getOfferPanelChildren()
	{
		Widget offerPanel = client.getWidget(GE_INTERFACE_GROUP, GE_OFFER_PANEL_CHILD);
		if (offerPanel == null || offerPanel.isHidden())
		{
			return new Widget[0];
		}
		Widget[] children = offerPanel.getDynamicChildren();
		return children != null ? children : new Widget[0];
	}
	
	private String getVisibleWidgetText(Widget widget)
	{
		if (widget == null || widget.isHidden())
		{
			return null;
		}
		return widget.getText();
	}
	
	private int getInputType()
	{
		return client.getVarcIntValue(VARCLIENT_INPUT_TYPE);
	}
	
	private boolean isLikelyPriceInput()
	{
		for (int groupId : CHATBOX_WIDGET_GROUPS)
		{
			Boolean result = checkChatboxGroupForInputType(groupId);
			if (result != null)
			{
				return result;
			}
		}
		return getCurrentQuantityFromGE() > 1;
	}
	
	@SuppressWarnings("java:S2447") // null represents "no determination made" in tri-state logic
	private Boolean checkChatboxGroupForInputType(int groupId)
	{
		for (int childId = 0; childId <= 50; childId++)
		{
			Boolean result = checkWidgetForInputType(client.getWidget(groupId, childId));
			if (result != null)
			{
				return result;
			}
		}
		return null;
	}
	
	@SuppressWarnings("java:S2447") // null represents "no determination made" in tri-state logic
	private Boolean checkWidgetForInputType(Widget widget)
	{
		String text = getVisibleWidgetText(widget);
		if (text == null || text.isEmpty())
		{
			return null;
		}
		String lowerText = text.toLowerCase();
		if (lowerText.contains("price") && !lowerText.contains("price:"))
		{
			return Boolean.TRUE;
		}
		if (lowerText.contains("how many"))
		{
			return Boolean.FALSE;
		}
		return null;
	}
	
	private int getCurrentQuantityFromGE()
	{
		Widget[] children = getOfferPanelChildren();
		return findNumericValueInRange(children, GE_QTY_CHILD_START, GE_QTY_CHILD_END, false);
	}
	
	private int findNumericValueInRange(Widget[] children, int start, int end, boolean requireCoins)
	{
		for (int i = start; i <= end && i < children.length; i++)
		{
			int value = extractValueFromWidget(children[i], requireCoins);
			if (value >= 1)
			{
				return value;
			}
		}
		return 0;
	}
	
	private int extractValueFromWidget(Widget widget, boolean requireCoins)
	{
		String text = getVisibleWidgetText(widget);
		if (text == null || text.isEmpty())
		{
			return 0;
		}
		String lowerText = text.toLowerCase();
		if (requireCoins && !lowerText.contains(COINS_TEXT))
		{
			return 0;
		}
		if (!requireCoins && (lowerText.contains(COINS_TEXT) || lowerText.contains("quantity") || lowerText.contains("price")))
		{
			return 0;
		}
		return parseNumericText(text);
	}
	
	private int getCurrentPriceFromGE()
	{
		Widget[] children = getOfferPanelChildren();
		int value = findNumericValueInRange(children, GE_PRICE_CHILD_START, GE_PRICE_CHILD_END, true);
		return value > 0 ? value : getCurrentPriceFromGEFallback();
	}
	
	private int getCurrentPriceFromGEFallback()
	{
		int[] priceWidgetIds = {25, 27};
		for (int childId : priceWidgetIds)
		{
			int value = findPriceInWidget(client.getWidget(GE_INTERFACE_GROUP, childId));
			if (value > 0)
			{
				return value;
			}
		}
		return 0;
	}
	
	private int findPriceInWidget(Widget widget)
	{
		if (widget == null || widget.isHidden())
		{
			return 0;
		}
		
		int value = extractCoinsValue(widget.getText());
		if (value > 0)
		{
			return value;
		}
		
		Widget[] children = widget.getDynamicChildren();
		if (children == null)
		{
			return 0;
		}
		for (Widget child : children)
		{
			value = extractCoinsValue(getVisibleWidgetText(child));
			if (value > 0)
			{
				return value;
			}
		}
		return 0;
	}
	
	private int extractCoinsValue(String text)
	{
		if (text != null && text.toLowerCase().contains(COINS_TEXT))
		{
			return parseNumericText(text);
		}
		return 0;
	}
	
	private int parseNumericText(String text)
	{
		if (text == null || text.isEmpty())
		{
			return 0;
		}
		
		try
		{
			// Remove all non-digit characters (commas, spaces, "coins", etc.)
			String numericOnly = text.replaceAll("\\D", "");
			if (!numericOnly.isEmpty())
			{
				return Integer.parseInt(numericOnly);
			}
		}
		catch (NumberFormatException e)
		{
			// Ignore
		}
		
		return 0;
	}
	
	private String truncateString(String str, int maxWidth, FontMetrics fm)
	{
		if (fm.stringWidth(str) <= maxWidth)
		{
			return str;
		}
		
		String ellipsis = "...";
		int len = str.length();
		while (len > 0 && fm.stringWidth(str.substring(0, len)) + fm.stringWidth(ellipsis) > maxWidth)
		{
			len--;
		}
		return str.substring(0, len) + ellipsis;
	}
	
	public void setFocusedFlip(FocusedFlip focusedFlip)
	{
		this.focusedFlip = focusedFlip;
		if (focusedFlip != null)
		{
			setGELastSearchedItem(focusedFlip.getItemId());
		}
	}
	
	private void setGELastSearchedItem(int itemId)
	{
		clientThread.invokeLater(() -> {
			try
			{
				int[] varps = client.getVarps();
				varps[VarPlayerID.GE_LAST_SEARCHED] = itemId;
				client.queueChangedVarp(VarPlayerID.GE_LAST_SEARCHED);
			}
			catch (Exception e)
			{
				log.warn("Failed to set GE last searched item: {}", e.getMessage());
			}
		});
	}
	
	public void clearFocus()
	{
		this.focusedFlip = null;
		this.currentStep = FlipAssistStep.SELECT_ITEM;
	}
}



package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

@Data
public class FlipRecommendation
{
	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	private boolean members;

	@SerializedName("buy_limit")
	private Integer buyLimit;

	// Instant prices (reference only)
	@SerializedName("instant_buy_price")
	private int instantBuyPrice;

	@SerializedName("instant_sell_price")
	private int instantSellPrice;

	// Recommended prices (for GE offers)
	@SerializedName("recommended_buy_price")
	private int recommendedBuyPrice;

	@SerializedName("recommended_sell_price")
	private int recommendedSellPrice;

	@SerializedName("recommended_quantity")
	private int recommendedQuantity;

	private int margin;

	@SerializedName("roi_percent")
	private double roiPercent;

	@SerializedName("ge_tax")
	private int geTax;

	@SerializedName("liquidity_score")
	private double liquidityScore;

	@SerializedName("liquidity_rating")
	private String liquidityRating;

	@SerializedName("volume_per_hour")
	private double volumePerHour;

	@SerializedName("risk_score")
	private double riskScore;

	@SerializedName("risk_rating")
	private String riskRating;

	@SerializedName("efficiency_score")
	private double efficiencyScore;

	@SerializedName("efficiency_rating")
	private String efficiencyRating;

	@SerializedName("quantity_affordable")
	private Integer quantityAffordable;

	@SerializedName("potential_profit")
	private int potentialProfit;

	@SerializedName("total_cost")
	private int totalCost;

	// Deprecated fields (kept for backwards compatibility)
	@SerializedName("buy_price")
	private Integer buyPrice;

	@SerializedName("sell_price")
	private Integer sellPrice;

	@SerializedName("cost_per_flip")
	private Integer costPerFlip;

	/**
	 * Format GP amount for display
	 */
	public String formatGP(int amount)
	{
		if (amount >= 1_000_000)
		{
			return String.format("%.1fM", amount / 1_000_000.0);
		}
		else if (amount >= 1_000)
		{
			return String.format("%.1fK", amount / 1_000.0);
		}
		return String.valueOf(amount);
	}

	/**
	 * Get formatted margin text
	 */
	public String getFormattedMargin()
	{
		return formatGP(margin) + " gp";
	}

	/**
	 * Get formatted ROI text
	 */
	public String getFormattedROI()
	{
		return String.format("%.1f%%", roiPercent);
	}

	/**
	 * Get formatted potential profit text
	 */
	public String getFormattedPotentialProfit()
	{
		return formatGP(potentialProfit) + " gp";
	}
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

/**
 * Response from the completed flips API endpoint
 */
@Data
public class CompletedFlipsResponse
{
	@SerializedName("flips")
	private List<CompletedFlip> flips;

	@SerializedName("count")
	private int count;
}


package com.flipsmart;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;

import java.awt.event.KeyEvent;

@ConfigGroup("flipsmart")
public interface FlipSmartConfig extends Config
{
	// ============================================
	// Advanced Section (API URL override only)
	// ============================================
	@ConfigSection(
		name = "Advanced",
		description = "Advanced settings",
		position = 0,
		closedByDefault = true
	)
	String advancedSection = "advanced";

	@ConfigItem(
		keyName = "apiUrl",
		name = "API URL Override",
		description = "Leave empty to use production server (https://flipsm.art). Only set this to override with a custom server URL.",
		section = advancedSection,
		position = 0
	)
	default String apiUrl()
	{
		return "";
	}

	// Hidden config items (not shown in UI, but used for persistence)
	// These are accessed via ConfigManager directly

	@ConfigItem(
		keyName = "email",
		name = "",
		description = "",
		hidden = true
	)
	default String email()
	{
		return "";
	}

	@ConfigItem(
		keyName = "password",
		name = "",
		description = "",
		hidden = true,
		secret = true
	)
	default String password()
	{
		return "";
	}

	// ============================================
	// Flip Finder Section
	// ============================================
	@ConfigSection(
		name = "Flip Finder",
		description = "Settings for flip recommendations",
		position = 1,
		closedByDefault = false
	)
	String flipFinderSection = "flipFinder";

	@ConfigItem(
		keyName = "showFlipFinder",
		name = "Enable Flip Finder",
		description = "Show the Flip Finder panel in the sidebar",
		section = flipFinderSection,
		position = 0
	)
	default boolean showFlipFinder()
	{
		return true;
	}

	@ConfigItem(
		keyName = "flipFinderLimit",
		name = "Number of Recommendations",
		description = "Number of flip recommendations to show (1-50)",
		section = flipFinderSection,
		position = 1
	)
	default int flipFinderLimit()
	{
		return 10;
	}

	@ConfigItem(
		keyName = "flipStyle",
		name = "Flip Style",
		description = "Your preferred flipping style: Conservative (safer, faster fills), Balanced (mix of both), Aggressive (higher profit, slower fills)",
		section = flipFinderSection,
		position = 2
	)
	default FlipStyle flipStyle()
	{
		return FlipStyle.BALANCED;
	}

	@ConfigItem(
		keyName = "flipFinderRefreshMinutes",
		name = "Refresh Interval (minutes)",
		description = "How often to refresh flip recommendations (1-60 minutes)",
		section = flipFinderSection,
		position = 4
	)
	default int flipFinderRefreshMinutes()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "minProfit",
		name = "Minimum Profit",
		description = "Minimum profit margin to highlight (in GP)",
		section = flipFinderSection,
		position = 4
	)
	default int minimumProfit()
	{
		return 100;
	}

	// ============================================
	// Display Section
	// ============================================
	@ConfigSection(
		name = "Display",
		description = "Display and overlay settings",
		position = 2,
		closedByDefault = false
	)
	String displaySection = "display";

	@ConfigItem(
		keyName = "showGEOverlay",
		name = "Show Exchange Viewer",
		description = "Display in-game Grand Exchange offer tracker (hidden when at the GE area)",
		section = displaySection,
		position = 0
	)
	default boolean showGEOverlay()
	{
		return false;
	}

	@ConfigItem(
		keyName = "exchangeViewerSize",
		name = "Display Size",
		description = "Size of the Exchange Viewer overlay",
		section = displaySection,
		position = 1
	)
	default ExchangeViewerSize exchangeViewerSize()
	{
		return ExchangeViewerSize.FULL;
	}

	@ConfigItem(
		keyName = "showGEItemNames",
		name = "Show Item Names",
		description = "Display item names in the Exchange Viewer (Full mode only)",
		section = displaySection,
		position = 2
	)
	default boolean showGEItemNames()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGEItemIcons",
		name = "Show Item Icons",
		description = "Display item icons in the Exchange Viewer",
		section = displaySection,
		position = 3
	)
	default boolean showGEItemIcons()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showGEDetailedInfo",
		name = "Show Detailed Info",
		description = "Show quantity, price per item, and total value (Full mode only)",
		section = displaySection,
		position = 4
	)
	default boolean showGEDetailedInfo()
	{
		return true;
	}

	// ============================================
	// Flip Assistant Section (Guided Workflow + Quick Actions)
	// ============================================
	@ConfigSection(
		name = "Flip Assistant",
		description = "Guided step-by-step flip workflow with hotkey support",
		position = 3,
		closedByDefault = false
	)
	String flipAssistantSection = "flipAssistant";

	@ConfigItem(
		keyName = "enableFlipAssistant",
		name = "Enable Flip Assistant",
		description = "Show the guided flip assistant panel when focusing on a flip",
		section = flipAssistantSection,
		position = 0
	)
	default boolean enableFlipAssistant()
	{
		return true;
	}

	@ConfigItem(
		keyName = "easyFlipHotkey",
		name = "Auto-Fill Hotkey",
		description = "Hotkey to auto-fill price/quantity in GE (default: E)",
		section = flipAssistantSection,
		position = 1
	)
	default Keybind flipAssistHotkey()
	{
		return new Keybind(KeyEvent.VK_E, 0);
	}

	@ConfigItem(
		keyName = "highlightGEWidgets",
		name = "Highlight GE Buttons",
		description = "Highlight buy/sell buttons and input fields in the GE",
		section = flipAssistantSection,
		position = 2
	)
	default boolean highlightGEWidgets()
	{
		return true;
	}

	@ConfigItem(
		keyName = "showAssistantAlways",
		name = "Show When GE Closed",
		description = "Show assistant even when Grand Exchange is not open",
		section = flipAssistantSection,
		position = 3
	)
	default boolean showAssistantAlways()
	{
		return false;
	}

	@ConfigItem(
		keyName = "priceOffset",
		name = "Price Offset (GP)",
		description = "Adjust buy/sell prices to fill faster. Positive = buy higher and sell lower by this amount. Set to 0 for no offset.",
		section = flipAssistantSection,
		position = 4
	)
	default int priceOffset()
	{
		return 0;
	}

	// ============================================
	// Market Dumps Section
	// ============================================
	@ConfigSection(
		name = "Market Dumps",
		description = "Real-time alerts for sudden price drops in the Grand Exchange",
		position = 4,
		closedByDefault = false
	)
	String marketDumpsSection = "marketDumps";

	@ConfigItem(
		keyName = "enableDumpAlerts",
		name = "Enable Price Alerts",
		description = "Show chat alerts when significant price changes are detected (≥5% price changes with high volume)",
		section = marketDumpsSection,
		position = 0
	)
	default boolean enableDumpAlerts()
	{
		return false;
	}

	@ConfigItem(
		keyName = "priceAlertType",
		name = "Alert Type",
		description = "Type of price changes to alert: Dumps (decreases), Pumps (increases), or Both",
		section = marketDumpsSection,
		position = 1
	)
	default PriceAlertType priceAlertType()
	{
		return PriceAlertType.DUMPS_ONLY;
	}

	@ConfigItem(
		keyName = "dumpAlertMinProfit",
		name = "Minimum Profit",
		description = "Only alert for price changes with estimated profit above this amount (in GP)",
		section = marketDumpsSection,
		position = 2
	)
	default int dumpAlertMinProfit()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "dumpAlertInterval",
		name = "Check Interval (seconds)",
		description = "How often to check for new price changes (30-300 seconds)",
		section = marketDumpsSection,
		position = 3
	)
	default int dumpAlertInterval()
	{
		return 60;
	}

	@ConfigItem(
		keyName = "dumpAlertMaxCount",
		name = "Max Alerts Per Check",
		description = "Only show the top X most profitable price changes per check (1-50)",
		section = marketDumpsSection,
		position = 4
	)
	default int dumpAlertMaxCount()
	{
		return 5;
	}

	@ConfigItem(
		keyName = "dumpAlertCooldownMinutes",
		name = "Item Cooldown (minutes)",
		description = "Don't re-alert for the same item within this many minutes (0-1440)",
		section = marketDumpsSection,
		position = 5
	)
	default int dumpAlertCooldownMinutes()
	{
		return 60;
	}

	@ConfigItem(
		keyName = "dumpAlertSortByProfit",
		name = "Sort by Profit",
		description = "Sort alerts by estimated profit instead of recency (most recent first)",
		section = marketDumpsSection,
		position = 6
	)
	default boolean dumpAlertSortByProfit()
	{
		return false;
	}

	// ============================================
	// General Section
	// ============================================
	@ConfigSection(
		name = "General",
		description = "General plugin settings",
		position = 5,
		closedByDefault = true
	)
	String generalSection = "general";

	@ConfigItem(
		keyName = "trackHistory",
		name = "Track History",
		description = "Track flipping history across sessions",
		section = generalSection,
		position = 0
	)
	default boolean trackHistory()
	{
		return true;
	}

	// ============================================
	// Flip Style Enum
	// ============================================
	enum FlipStyle
	{
		CONSERVATIVE("conservative"),
		BALANCED("balanced"),
		AGGRESSIVE("aggressive");

		private final String apiValue;

		FlipStyle(String apiValue)
		{
			this.apiValue = apiValue;
		}

		public String getApiValue()
		{
			return apiValue;
		}

		@Override
		public String toString()
		{
			return name().charAt(0) + name().substring(1).toLowerCase();
		}
	}

	// ============================================
	// Exchange Viewer Display Size Enum
	// ============================================
	enum ExchangeViewerSize
	{
		FULL("Full"),
		COMPACT("Compact");

		private final String displayName;

		ExchangeViewerSize(String displayName)
		{
			this.displayName = displayName;
		}

		@Override
		public String toString()
		{
			return displayName;
		}
	}

	// ============================================
	// Price Alert Type Enum
	// ============================================
	enum PriceAlertType
	{
		DUMPS_ONLY("Dumps Only"),
		PUMPS_ONLY("Pumps Only"),
		BOTH("Both");

		private final String displayName;

		PriceAlertType(String displayName)
		{
			this.displayName = displayName;
		}

		@Override
		public String toString()
		{
			return displayName;
		}
	}
}


package com.flipsmart;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.GrandExchangeOffer;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemComposition;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GrandExchangeOfferChanged;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.ScriptPostFired;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.VarbitID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;

import javax.inject.Inject;
import java.awt.Point;
import java.awt.Rectangle;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@PluginDescriptor(
	name = "Flip Smart",
	description = "A tool to help with item flipping in the Grand Exchange",
	tags = {"grand exchange", "flipping", "trading", "money making"}
)
public class FlipSmartPlugin extends Plugin
{
	private static final int INVENTORY_CONTAINER_ID = 93;

	@Inject
	private Client client;

	@Inject
	private FlipSmartConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private GrandExchangeOverlay geOverlay;
	
	@Inject
	private FlipAssistOverlay flipAssistOverlay;

	@Inject
	private FlipSmartApiClient apiClient;
	
	@Inject
	private KeyManager keyManager;
	
	@Inject
	private ClientThread clientThread;

	@Inject
	private net.runelite.client.ui.ClientToolbar clientToolbar;

	@Inject
	private net.runelite.client.game.ItemManager itemManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private Gson gson;

	@Inject
	private DumpAlertService dumpAlertService;

	@Inject
	private ChatMessageManager chatMessageManager;

	// Flip Finder panel
	private FlipFinderPanel flipFinderPanel;
	private net.runelite.client.ui.NavigationButton flipFinderNavButton;

	// Player's current cash stack (detected from inventory)
	@Getter
	private int currentCashStack = 0;

	// Auto-refresh timer for flip finder
	private java.util.Timer flipFinderRefreshTimer;
	private long lastFlipFinderRefresh = 0;

	// Track GE offers to detect when they complete
	private final Map<Integer, TrackedOffer> trackedOffers = new ConcurrentHashMap<>();
	
	// Track login to avoid recording existing offers as new transactions
	private static final int GE_LOGIN_BURST_WINDOW = 3; // ticks
	private int lastLoginTick = 0;
	
	// Track recommended prices from flip finder (item_id -> recommended_sell_price)
	private final Map<Integer, Integer> recommendedPrices = new ConcurrentHashMap<>();

	// Config keys for persisting offer state
	private static final String CONFIG_GROUP = "flipsmart";
	private static final String PERSISTED_OFFERS_KEY_PREFIX = "persistedOffers_";
	private static final String COLLECTED_ITEMS_KEY_PREFIX = "collectedItems_";
	
	// Flag to track if we've synced offline fills on this login
	private boolean offlineSyncCompleted = false;
	
	// Current RSN (set on login)
	@Getter
	private String currentRsn = null;
	
	// Track if player is logged into RuneScape (not our API, but the game itself)
	@Getter
	private boolean loggedIntoRunescape = false;
	
	// Track items collected from GE in current session (waiting to be sold)
	// These should show as active flips even though they're no longer in GE slots
	private final java.util.Set<Integer> collectedItemIds = ConcurrentHashMap.newKeySet();
	
	// Flip Assist input listener for hotkey handling
	private FlipAssistInputListener flipAssistInputListener;
	
	// Bank snapshot tracking
	private volatile boolean bankSnapshotInProgress = false;
	private long lastBankSnapshotAttempt = 0;
	private static final long BANK_SNAPSHOT_COOLDOWN_MS = 60_000; // 1 minute cooldown between attempts

	/**
	 * Helper class to track GE offers (serializable for persistence)
	 */
	public static class TrackedOffer
	{
		int itemId;
		String itemName;
		boolean isBuy;
		int totalQuantity;
		int price;
		int previousQuantitySold;

		// Default constructor for Gson deserialization
		TrackedOffer() {}

		TrackedOffer(int itemId, String itemName, boolean isBuy, int totalQuantity, int price, int quantitySold)
		{
			this.itemId = itemId;
			this.itemName = itemName;
			this.isBuy = isBuy;
			this.totalQuantity = totalQuantity;
			this.price = price;
			this.previousQuantitySold = quantitySold;
		}
	}
	
	/**
	 * Store recommended sell price when user views/acts on a flip recommendation
	 */
	public void setRecommendedSellPrice(int itemId, int recommendedSellPrice)
	{
		recommendedPrices.put(itemId, recommendedSellPrice);
		log.debug("Stored recommended sell price for item {}: {}", itemId, recommendedSellPrice);
	}
	
	/**
	 * Get current buy orders in GE slots (pending or partially filled).
	 * These are buy orders that haven't been fully collected yet.
	 */
	public java.util.List<PendingOrder> getPendingBuyOrders()
	{
		java.util.List<PendingOrder> pendingOrders = new java.util.ArrayList<>();
		
		for (java.util.Map.Entry<Integer, TrackedOffer> entry : trackedOffers.entrySet())
		{
			TrackedOffer offer = entry.getValue();
			
			// Include all buy orders (pending or partially filled)
			if (offer.isBuy)
			{
				Integer recommendedSellPrice = recommendedPrices.get(offer.itemId);
				
				PendingOrder pending = new PendingOrder(
					offer.itemId,
					offer.itemName,
					offer.totalQuantity,
					offer.previousQuantitySold, // How many filled so far
					offer.price,
					recommendedSellPrice,
					entry.getKey() // slot
				);
				
				pendingOrders.add(pending);
			}
		}
		
		return pendingOrders;
	}
	
	/**
	 * Get the set of item IDs currently in GE buy slots.
	 */
	public java.util.Set<Integer> getCurrentGEBuyItemIds()
	{
		java.util.Set<Integer> itemIds = new java.util.HashSet<>();
		
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (offer.isBuy)
			{
				itemIds.add(offer.itemId);
			}
		}
		
		return itemIds;
	}
	
	/**
	 * Get all active flip item IDs - items that should show as active flips.
	 * This includes:
	 * 1. Items currently in GE buy slots (pending or filled)
	 * 2. Items currently in GE sell slots (pending sale)
	 * 3. Items collected from GE in this session (waiting to be sold)
	 */
	public java.util.Set<Integer> getActiveFlipItemIds()
	{
		java.util.Set<Integer> itemIds = new java.util.HashSet<>();
		
		// Add items currently in ANY GE slots (buy OR sell)
		for (TrackedOffer offer : trackedOffers.values())
		{
			itemIds.add(offer.itemId);
		}
		
		// Add items collected from GE (waiting to be sold)
		itemIds.addAll(collectedItemIds);
		
		return itemIds;
	}
	
	/**
	 * Get all active flip item IDs including items in inventory.
	 * This is used for filtering active flips display to show items the player
	 * actually has (in GE slots or inventory).
	 */
	public java.util.Set<Integer> getActiveFlipItemIdsWithInventory()
	{
		java.util.Set<Integer> itemIds = getActiveFlipItemIds();
		
		// Also include items currently in inventory
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory != null)
		{
			for (Item item : inventory.getItems())
			{
				if (item.getId() > 0)
				{
					itemIds.add(item.getId());
				}
			}
		}
		
		return itemIds;
	}
	
	/**
	 * Mark an item as sold - removes it from the collected tracking.
	 * Called when a sell transaction is recorded.
	 * Also checks if inventory is empty AND no active GE sell slot for this item,
	 * then auto-closes the active flip.
	 */
	public void markItemSold(int itemId)
	{
		if (collectedItemIds.remove(itemId))
		{
			log.debug("Removed item {} from collected tracking (sold)", itemId);
		}
		
		boolean hasActiveSellSlot = hasActiveSellSlotForItem(itemId);
		
		if (hasActiveSellSlot)
		{
			log.debug("Item {} still has active sell slot, keeping flip open", itemId);
			return;
		}
		
		// Only auto-close if inventory is empty AND there's no active sell slot
		tryAutoCloseFlip(itemId);
	}
	
	/**
	 * Check if an item has an active sell slot in the GE.
	 */
	private boolean hasActiveSellSlotForItem(int itemId)
	{
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (offer.itemId == itemId && !offer.isBuy)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Attempt to auto-close a flip if inventory is empty.
	 */
	private void tryAutoCloseFlip(int itemId)
	{
		int inventoryCount = getInventoryCountForItem(itemId);
		if (inventoryCount > 0)
		{
			return;
		}
		
		log.info("Inventory empty and no active sell slot for item {}, auto-closing active flip", itemId);
		apiClient.dismissActiveFlipAsync(itemId, getCurrentRsnSafe().orElse(null)).thenAccept(success ->
		{
			if (Boolean.TRUE.equals(success))
			{
				log.info("Successfully auto-closed active flip for item {} (no items remaining)", itemId);
				refreshPanelOnSwingThread();
			}
		});
	}
	
	/**
	 * Refresh the flip finder panel on the Swing EDT.
	 */
	private void refreshPanelOnSwingThread()
	{
		if (flipFinderPanel != null)
		{
			javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refresh());
		}
	}
	
	/**
	 * Get the count of a specific item in the player's inventory
	 * @param itemId The item ID to check
	 * @return The quantity of the item in inventory (0 if not found)
	 */
	private int getInventoryCountForItem(int itemId)
	{
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory == null)
		{
			return 0;
		}
		
		int count = 0;
		Item[] items = inventory.getItems();
		for (Item item : items)
		{
			if (item.getId() == itemId)
			{
				count += item.getQuantity();
			}
		}
		
		return count;
	}
	
	/**
	 * Helper class for pending orders
	 */
	public static class PendingOrder
	{
		public final int itemId;
		public final String itemName;
		public final int quantity;        // Total quantity ordered
		public final int quantityFilled;  // How many have been filled so far
		public final int pricePerItem;
		public final Integer recommendedSellPrice;
		public final int slot;
		
		public PendingOrder(int itemId, String itemName, int quantity, int quantityFilled, int pricePerItem, Integer recommendedSellPrice, int slot)
		{
			this.itemId = itemId;
			this.itemName = itemName;
			this.quantity = quantity;
			this.quantityFilled = quantityFilled;
			this.pricePerItem = pricePerItem;
			this.recommendedSellPrice = recommendedSellPrice;
			this.slot = slot;
		}
	}

	@Override
	protected void startUp() throws Exception
	{
		log.info("Flip Smart started!");
		overlayManager.add(geOverlay);
		overlayManager.add(flipAssistOverlay);
		mouseManager.registerMouseListener(overlayMouseListener);
		
		// Initialize Flip Assist input listener for hotkey support
		flipAssistInputListener = new FlipAssistInputListener(client, clientThread, config, flipAssistOverlay);
		keyManager.registerKeyListener(flipAssistInputListener);
		
		// Initialize Flip Finder panel
		if (config.showFlipFinder())
		{
			initializeFlipFinderPanel();
		}

		// Start auto-refresh timer for flip finder
		startFlipFinderRefreshTimer();

		// Start dump alert service
		dumpAlertService.start();

		// Note: Cash stack and RSN will be synced when player logs in via onGameStateChanged
		// Don't access client data during startup - must be on client thread
	}

	@Override
	protected void shutDown() throws Exception
	{
		log.info("Flip Smart stopped!");
		
		// Persist offer state before shutting down (handles cases where client is closed without logout)
		// Only persist if we have a valid RSN to avoid overwriting good data
		if (currentRsn != null && !currentRsn.isEmpty())
		{
			persistOfferState();
			log.info("Persisted offer state on shutdown for {}", currentRsn);
		}
		
		overlayManager.remove(geOverlay);
		overlayManager.remove(flipAssistOverlay);
		mouseManager.unregisterMouseListener(overlayMouseListener);
		
		// Unregister Flip Assist input listener
		if (flipAssistInputListener != null)
		{
			keyManager.unregisterKeyListener(flipAssistInputListener);
			flipAssistInputListener = null;
		}
		
		// Remove flip finder panel
		if (flipFinderNavButton != null)
		{
			clientToolbar.removeNavigation(flipFinderNavButton);
		}
		
		// Shutdown flip finder panel (cleanup device auth polling, etc.)
		if (flipFinderPanel != null)
		{
			flipFinderPanel.shutdown();
		}
		
		// Stop auto-refresh timer
		stopFlipFinderRefreshTimer();

		// Stop dump alert service
		dumpAlertService.stop();

		// Clear API client cache
		apiClient.clearCache();
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		GameState gameState = gameStateChanged.getGameState();
		
		// Track login/hopping to avoid recording existing GE offers
		if (gameState == GameState.LOGGING_IN || gameState == GameState.HOPPING || gameState == GameState.CONNECTION_LOST)
		{
			lastLoginTick = client.getTickCount();
			offlineSyncCompleted = false;
			// Note: Don't clear collectedItemIds here - we'll restore them after RSN is known
			log.debug("Login state change detected, setting lastLoginTick to {}", lastLoginTick);
		}
		
		// Persist offer state when logging out and show "log in to game" message
		if (gameState == GameState.LOGIN_SCREEN)
		{
			loggedIntoRunescape = false;
			persistOfferState();
			
			// Update panel to show logged out state (saves API requests while at login screen)
			if (flipFinderPanel != null)
			{
				javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.showLoggedOutOfGameState());
			}
		}
		
		if (gameState == GameState.LOGGED_IN)
		{
			log.info("Player logged in");
			loggedIntoRunescape = true;
			syncRSN();
			updateCashStack();
			
			// Restore collected items from config (items bought but not yet sold)
			// Must be after syncRSN() so we have the correct RSN for the config key
			restoreCollectedItems();
			
			// Schedule offline sync after a delay to ensure all GE events have been processed
			// This must run AFTER syncRSN() so we have the correct RSN for the config key
			if (!offlineSyncCompleted)
			{
				javax.swing.Timer syncTimer = new javax.swing.Timer(2000, e -> syncOfflineFills());
				syncTimer.setRepeats(false);
				syncTimer.start();
			}
			
			// Refresh flip finder with current cash stack
			if (flipFinderPanel != null)
			{
				flipFinderPanel.refresh();
			}
		}
	}
	
	/**
	 * Restore collected item IDs from persisted config.
	 * These are items that were bought but not yet sold when the player logged out.
	 */
	private void restoreCollectedItems()
	{
		String key = getCollectedItemsKey();
		log.info("Attempting to restore collected items for RSN: {} (key: {})", currentRsn, key);
		
		java.util.Set<Integer> persisted = loadPersistedCollectedItems();
		if (!persisted.isEmpty())
		{
			collectedItemIds.clear();
			collectedItemIds.addAll(persisted);
			log.info("Restored {} collected items from previous session: {}", persisted.size(), persisted);
		}
		else
		{
			log.info("No collected items found in config for RSN: {}", currentRsn);
			collectedItemIds.clear();
		}
	}
	
	/**
	 * Persist the current GE offer state to config for offline tracking.
	 * Called when the player logs out.
	 * Uses RSN-specific key to support multiple accounts.
	 */
	private void persistOfferState()
	{
		String offersKey = getPersistedOffersKey();
		String collectedKey = getCollectedItemsKey();
		
		// Persist tracked offers
		if (trackedOffers.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, offersKey);
			log.debug("No tracked offers to persist for {}", currentRsn);
		}
		else
		{
			try
			{
				Map<Integer, TrackedOffer> offersToSave = new HashMap<>(trackedOffers);
				String json = gson.toJson(offersToSave);
				configManager.setConfiguration(CONFIG_GROUP, offersKey, json);
				log.info("Persisted {} tracked offers for {} (offline sync)", offersToSave.size(), currentRsn);
			}
			catch (Exception e)
			{
				log.error("Failed to persist offer state for {}: {}", currentRsn, e.getMessage());
			}
		}
		
		// Persist collected item IDs (items bought but not yet sold)
		if (collectedItemIds.isEmpty())
		{
			configManager.unsetConfiguration(CONFIG_GROUP, collectedKey);
			log.debug("No collected items to persist for {}", currentRsn);
		}
		else
		{
			try
			{
				String json = gson.toJson(new java.util.ArrayList<>(collectedItemIds));
				configManager.setConfiguration(CONFIG_GROUP, collectedKey, json);
				log.info("Persisted {} collected item IDs for {} (active flips)", collectedItemIds.size(), currentRsn);
			}
			catch (Exception e)
			{
				log.error("Failed to persist collected items for {}: {}", currentRsn, e.getMessage());
			}
		}
	}
	
	/**
	 * Sync fills that occurred while offline.
	 * Records current GE state to the backend. Cleanup of stale flips happens
	 * later via schedulePostSyncTasks() after GE state is fully loaded.
	 */
	private void syncOfflineFills()
	{
		if (offlineSyncCompleted)
		{
			return;
		}
		offlineSyncCompleted = true;
		
		// Load persisted offers from last session to compare against current state
		Map<Integer, TrackedOffer> persistedOffers = loadPersistedOffers();
		log.debug("Loaded {} persisted offers, comparing with {} current offers", 
			persistedOffers.size(), trackedOffers.size());
		
		// Always sync current offers - handles both:
		// 1. Offers with persisted state (compare for offline fills)
		// 2. Offers WITHOUT persisted state (record as new transactions)
		if (!trackedOffers.isEmpty())
		{
			syncCurrentOffersWithPersisted(persistedOffers);
		}
		
		// Handle slots that became empty while offline
		if (!persistedOffers.isEmpty())
		{
			handleEmptyPersistedSlots(persistedOffers);
			// Clear persisted state after sync (RSN-specific key)
			configManager.unsetConfiguration(CONFIG_GROUP, getPersistedOffersKey());
		}
		
		log.info("Offline sync completed for {}", currentRsn);
		
		// Schedule panel refresh and cleanup
		schedulePostSyncTasks();
	}
	
	/**
	 * Sync current GE offers against persisted state to detect offline fills.
	 */
	private void syncCurrentOffersWithPersisted(Map<Integer, TrackedOffer> persistedOffers)
	{
		for (Map.Entry<Integer, TrackedOffer> entry : trackedOffers.entrySet())
		{
			int slot = entry.getKey();
			TrackedOffer currentOffer = entry.getValue();
			TrackedOffer persistedOffer = persistedOffers.get(slot);
			
			if (persistedOffer != null && persistedOffer.itemId == currentOffer.itemId)
			{
				// Have persisted state - check for offline fills
				recordOfflineFillsIfAny(slot, currentOffer, persistedOffer);
			}
			else if (currentOffer.totalQuantity > 0)
			{
				// No persisted state but there's an active order - record it
				log.debug("Recording GE order for {} {} (slot {}): {}/{} items at {} gp",
					currentOffer.isBuy ? "BUY" : "SELL",
					currentOffer.itemName, slot, currentOffer.previousQuantitySold, 
					currentOffer.totalQuantity, currentOffer.price);
				
				Integer recommendedSellPrice = currentOffer.isBuy ? recommendedPrices.get(currentOffer.itemId) : null;
				
				apiClient.recordTransactionAsync(FlipSmartApiClient.TransactionRequest
					.builder(currentOffer.itemId, currentOffer.itemName, currentOffer.isBuy,
						currentOffer.previousQuantitySold, currentOffer.price)
					.geSlot(slot)
					.recommendedSellPrice(recommendedSellPrice)
					.rsn(getCurrentRsnSafe().orElse(null))
					.totalQuantity(currentOffer.totalQuantity)
					.build());
				
				// For buy orders with fills, add to collected tracking so it shows in active flips
				if (currentOffer.isBuy && currentOffer.previousQuantitySold > 0)
				{
					collectedItemIds.add(currentOffer.itemId);
				}
			}
		}
	}
	
	/**
	 * Record offline fills if the current offer has more fills than persisted.
	 */
	private void recordOfflineFillsIfAny(int slot, TrackedOffer currentOffer, TrackedOffer persistedOffer)
	{
		int offlineFills = currentOffer.previousQuantitySold - persistedOffer.previousQuantitySold;
		if (offlineFills <= 0)
		{
			return;
		}
		
		log.debug("Detected {} offline fills for {} (slot {}): {} -> {} (order size: {})",
			offlineFills, currentOffer.itemName, slot,
			persistedOffer.previousQuantitySold, currentOffer.previousQuantitySold,
			currentOffer.totalQuantity);
		
		Integer recommendedSellPrice = currentOffer.isBuy ? recommendedPrices.get(currentOffer.itemId) : null;
		
		apiClient.recordTransactionAsync(FlipSmartApiClient.TransactionRequest
			.builder(currentOffer.itemId, currentOffer.itemName, currentOffer.isBuy,
				offlineFills, currentOffer.price)
			.geSlot(slot)
			.recommendedSellPrice(recommendedSellPrice)
			.rsn(getCurrentRsnSafe().orElse(null))
			.totalQuantity(currentOffer.totalQuantity)
			.build());
	}
	
	/**
	 * Handle persisted slots that are now empty (offer completed or cancelled offline).
	 * Checks inventory to detect orders that completed while offline.
	 */
	private void handleEmptyPersistedSlots(Map<Integer, TrackedOffer> persistedOffers)
	{
		for (Map.Entry<Integer, TrackedOffer> entry : persistedOffers.entrySet())
		{
			int slot = entry.getKey();
			TrackedOffer persistedOffer = entry.getValue();
			
			if (trackedOffers.containsKey(slot))
			{
				continue;
			}
			
			log.info("Slot {} is now empty (was tracking {} x{}). Checking for offline completions.",
				slot, persistedOffer.itemName, persistedOffer.totalQuantity);
			
			if (persistedOffer.isBuy)
			{
				handleEmptyBuySlot(persistedOffer);
			}
			else
			{
				handleEmptySellSlot(persistedOffer);
			}
		}
	}
	
	/**
	 * Handle an empty slot that was previously a sell order.
	 * If items sold offline, record them as SELL transactions.
	 */
	private void handleEmptySellSlot(TrackedOffer persistedOffer)
	{
		int soldQuantity = persistedOffer.previousQuantitySold;
		
		if (soldQuantity > 0)
		{
			log.info("Detected {} {} sold offline. Recording SELL transaction.",
				soldQuantity, persistedOffer.itemName);
			
			// Record the offline sell transaction
			recordOfflineSellTransaction(persistedOffer, soldQuantity);
		}
		else
		{
			log.info("Sell order for {} was cancelled or no items sold.", persistedOffer.itemName);
		}
	}
	
	/**
	 * Record a SELL transaction for items that sold while offline.
	 */
	private void recordOfflineSellTransaction(TrackedOffer persistedOffer, int soldQuantity)
	{
		String rsn = getCurrentRsnSafe().orElse(null);
		if (rsn == null)
		{
			log.warn("Cannot record offline sell - no RSN available");
			return;
		}
		
		// Create a SELL transaction for the items that sold offline
		apiClient.recordTransactionAsync(
			persistedOffer.itemId,
			persistedOffer.itemName,
			"SELL",
			soldQuantity,
			persistedOffer.price,
			rsn
		);
	}
	
	/**
	 * Handle an empty slot that was previously a buy order.
	 * Checks inventory and syncs with backend if needed.
	 */
	private void handleEmptyBuySlot(TrackedOffer persistedOffer)
	{
		int inventoryCount = getInventoryCountForItem(persistedOffer.itemId);
		int trackedFills = persistedOffer.previousQuantitySold;
		
		if (inventoryCount > 0)
		{
			handleBuyOrderWithInventory(persistedOffer, inventoryCount, trackedFills);
		}
		else if (trackedFills > 0)
		{
			log.info("No {} found in inventory (had {} fills tracked). Items may have been sold/used offline.",
				persistedOffer.itemName, trackedFills);
		}
	}
	
	/**
	 * Handle a completed buy order that has items in inventory.
	 * Syncs with backend if inventory count exceeds tracked fills.
	 */
	private void handleBuyOrderWithInventory(TrackedOffer persistedOffer, int inventoryCount, int trackedFills)
	{
		collectedItemIds.add(persistedOffer.itemId);
		
		int actualFills = calculateActualFills(persistedOffer, inventoryCount, trackedFills);
		
		if (actualFills > trackedFills)
		{
			syncOfflineCompletedOrder(persistedOffer, inventoryCount, trackedFills, actualFills);
		}
		else
		{
			log.info("Adding {} to collected tracking (had {} items filled before going offline)",
				persistedOffer.itemName, trackedFills);
		}
	}
	
	/**
	 * Calculate actual fills based on inventory count, tracked fills, and order size.
	 */
	private int calculateActualFills(TrackedOffer persistedOffer, int inventoryCount, int trackedFills)
	{
		int actualFills = Math.max(inventoryCount, trackedFills);
		
		// If we have at least order_size items, the order completed fully
		if (inventoryCount >= persistedOffer.totalQuantity)
		{
			actualFills = persistedOffer.totalQuantity;
		}
		
		return actualFills;
	}
	
	/**
	 * Sync an offline-completed order with the backend.
	 */
	private void syncOfflineCompletedOrder(TrackedOffer persistedOffer, int inventoryCount, int trackedFills, int actualFills)
	{
		log.info("Detected offline completion for {} - tracked {} fills but have {} in inventory. Syncing {} items with backend.",
			persistedOffer.itemName, trackedFills, inventoryCount, actualFills);
		
		String rsn = getCurrentRsnSafe().orElse(null);
		if (rsn == null)
		{
			return;
		}
		
		apiClient.syncActiveFlipAsync(
			persistedOffer.itemId,
			persistedOffer.itemName,
			actualFills,
			persistedOffer.totalQuantity,
			persistedOffer.price,
			rsn
		);
	}
	
	/**
	 * Schedule panel refresh and stale flip cleanup after offline sync.
	 */
	private void schedulePostSyncTasks()
	{
		// Refresh the panel after a short delay
		if (flipFinderPanel != null)
		{
			javax.swing.Timer refreshTimer = new javax.swing.Timer(1000, e -> flipFinderPanel.refresh());
			refreshTimer.setRepeats(false);
			refreshTimer.start();
		}
		
		// Schedule stale flip cleanup after GE state is stable
		javax.swing.Timer cleanupTimer = new javax.swing.Timer(15000, e -> {
			if (!trackedOffers.isEmpty() || collectedItemIds.isEmpty())
			{
				cleanupStaleActiveFlips();
				// After cleanup, validate inventory quantities against active flips
				scheduleInventoryQuantityValidation();
			}
			else
			{
				log.info("Skipping cleanup - no GE offers detected yet, may not be safe");
			}
		});
		cleanupTimer.setRepeats(false);
		cleanupTimer.start();
	}
	
	/**
	 * Schedule validation of inventory quantities against active flips.
	 * If inventory has fewer items than an active flip shows, sync down.
	 */
	private void scheduleInventoryQuantityValidation()
	{
		// Delay slightly to ensure cleanup has completed
		javax.swing.Timer validationTimer = new javax.swing.Timer(2000, e -> {
			clientThread.invokeLater(this::validateInventoryQuantities);
		});
		validationTimer.setRepeats(false);
		validationTimer.start();
	}
	
	/**
	 * Validate inventory quantities against active flips and sync down if needed.
	 * Must be called on client thread.
	 * 
	 * This is a safeguard for when items were sold/used without plugin tracking.
	 * It counts items in BOTH inventory AND GE sell slots to get the true count.
	 */
	private void validateInventoryQuantities()
	{
		String rsn = getCurrentRsnSafe().orElse(null);
		if (rsn == null)
		{
			return;
		}
		
		// Get total item counts (inventory + items in sell slots)
		Map<Integer, Integer> totalItemCounts = getTotalItemCounts();
		
		// Fetch current active flips from backend
		apiClient.getActiveFlipsAsync(rsn).thenAccept(response -> {
			if (response == null || response.getActiveFlips() == null)
			{
				return;
			}
			
			for (ActiveFlip flip : response.getActiveFlips())
			{
				validateAndSyncFlipQuantity(flip, totalItemCounts, rsn);
			}
		}).exceptionally(e -> {
			log.debug("Failed to validate inventory quantities: {}", e.getMessage());
			return null;
		});
	}
	
	/**
	 * Validate a single flip's quantity against actual item count and sync if needed.
	 * GE + Inventory is the source of truth - syncs both UP and DOWN to match reality.
	 */
	private void validateAndSyncFlipQuantity(ActiveFlip flip, Map<Integer, Integer> totalItemCounts, String rsn)
	{
		int itemId = flip.getItemId();
		int activeFlipQty = flip.getTotalQuantity();
		int actualQty = totalItemCounts.getOrDefault(itemId, 0);
		
		// Skip if item is in an active BUY slot (still being purchased)
		if (isItemInActiveBuySlot(itemId))
		{
			log.debug("Skipping validation for {} - still in buy slot", flip.getItemName());
			return;
		}
		
		// Skip if quantities match
		if (actualQty == activeFlipQty)
		{
			return;
		}
		
		// Skip if we have 0 items - might be a stale flip or items elsewhere
		if (actualQty == 0)
		{
			log.debug("Skipping validation for {} - no items in inventory/sell slots", flip.getItemName());
			return;
		}
		
		// Check for significant difference (at least 10 items or 10% difference)
		int difference = Math.abs(activeFlipQty - actualQty);
		boolean significantDifference = difference >= 10 || (activeFlipQty > 0 && difference > activeFlipQty * 0.1);
		
		if (!significantDifference)
		{
			log.debug("Skipping validation for {} - difference of {} is not significant", flip.getItemName(), difference);
			return;
		}
		
		// Sync to actual quantity (both up and down)
		String direction = actualQty > activeFlipQty ? "up" : "down";
		log.info("Inventory quantity mismatch for {} - active flip shows {} but have {} (inv + sell slots). Syncing {}.",
			flip.getItemName(), activeFlipQty, actualQty, direction);
		
		int orderQty = flip.getOrderQuantity() > 0 ? flip.getOrderQuantity() : Math.max(activeFlipQty, actualQty);
		apiClient.syncActiveFlipAsync(
			itemId,
			flip.getItemName(),
			actualQty,
			orderQty,
			flip.getAverageBuyPrice(),
			rsn
		);
	}
	
	/**
	 * Check if an item is currently in an active BUY slot (still purchasing).
	 * Sell slots are okay - items there are "ours" and counted separately.
	 */
	private boolean isItemInActiveBuySlot(int itemId)
	{
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (offer.itemId == itemId && offer.isBuy)
			{
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Get counts of all items we own: inventory + items in GE sell slots.
	 * Must be called on client thread.
	 */
	private Map<Integer, Integer> getTotalItemCounts()
	{
		Map<Integer, Integer> counts = new HashMap<>();
		
		// Count items in inventory
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory != null)
		{
			for (Item item : inventory.getItems())
			{
				if (item.getId() > 0)
				{
					counts.merge(item.getId(), item.getQuantity(), Integer::sum);
				}
			}
		}
		
		// Count items in active SELL slots (these are still "ours")
		for (TrackedOffer offer : trackedOffers.values())
		{
			if (!offer.isBuy && offer.itemId > 0)
			{
				// For sell offers: total - sold = remaining in slot
				int remainingInSlot = offer.totalQuantity - offer.previousQuantitySold;
				if (remainingInSlot > 0)
				{
					counts.merge(offer.itemId, remainingInSlot, Integer::sum);
				}
			}
		}
		
		return counts;
	}
	
	/**
	 * Clean up stale active flips on the backend.
	 * Sends the list of item IDs that are "truly active" (in GE slots or inventory)
	 * to the API, which will mark all other active flips as closed.
	 */
	private void cleanupStaleActiveFlips()
	{
		// Must run on client thread to access game state
		clientThread.invokeLater(this::executeStaleFlipCleanup);
	}
	
	/**
	 * Execute the stale flip cleanup (must be called on client thread).
	 */
	private void executeStaleFlipCleanup()
	{
		java.util.Set<Integer> activeItemIds = collectAllActiveItemIds();
		
		log.info("Cleaning up stale flips - {} item IDs are truly active", activeItemIds.size());
		
		apiClient.cleanupStaleFlipsAsync(activeItemIds, getCurrentRsnSafe().orElse(null))
			.thenAccept(this::handleCleanupResult);
	}
	
	/**
	 * Collect all item IDs that are currently active (in GE slots or inventory).
	 * Must be called on client thread.
	 */
	private java.util.Set<Integer> collectAllActiveItemIds()
	{
		java.util.Set<Integer> activeItemIds = getActiveFlipItemIds();
		addInventoryItemIds(activeItemIds);
		return activeItemIds;
	}
	
	/**
	 * Add all item IDs from inventory to the given set.
	 * Must be called on client thread.
	 */
	private void addInventoryItemIds(java.util.Set<Integer> itemIds)
	{
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory == null)
		{
			return;
		}
		
		for (Item item : inventory.getItems())
		{
			if (item.getId() > 0)
			{
				itemIds.add(item.getId());
			}
		}
	}
	
	/**
	 * Handle the result of stale flip cleanup.
	 */
	private void handleCleanupResult(Boolean success)
	{
		if (Boolean.TRUE.equals(success))
		{
			log.info("Stale flip cleanup completed successfully");
			refreshActiveFlipsOnSwingThread();
		}
	}
	
	/**
	 * Refresh the active flips panel on the Swing EDT.
	 */
	private void refreshActiveFlipsOnSwingThread()
	{
		if (flipFinderPanel != null)
		{
			javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refreshActiveFlips());
		}
	}

	
	/**
	 * Sync the player's RSN with the API and store locally
	 */
	private void syncRSN()
	{
		if (client.getLocalPlayer() == null)
		{
			log.warn("syncRSN called but getLocalPlayer() is null");
			return;
		}
		
		String rsn = client.getLocalPlayer().getName();
		if (rsn != null && !rsn.isEmpty())
		{
			currentRsn = rsn;
			log.info("RSN synced: {}", rsn);
			apiClient.updateRSN(rsn);
		}
		else
		{
			log.warn("syncRSN: player name is null or empty");
		}
	}
	
	/**
	 * Get the current RSN, attempting to fetch from client if not cached.
	 * Returns Optional.empty() if RSN cannot be determined.
	 * This ensures callers explicitly handle the case where RSN is unavailable.
	 */
	public Optional<String> getCurrentRsnSafe()
	{
		if (currentRsn != null && !currentRsn.isEmpty())
		{
			return Optional.of(currentRsn);
		}
		
		// Try to get RSN from client if not cached
		if (client.getLocalPlayer() != null && client.getLocalPlayer().getName() != null)
		{
			currentRsn = client.getLocalPlayer().getName();
			log.info("RSN fetched from client on-demand: {}", currentRsn);
			return Optional.of(currentRsn);
		}
		
		log.warn("Unable to determine RSN - transactions will be recorded without RSN");
		return Optional.empty();
	}
	
	/**
	 * Get the RSN-specific config key for persisted offers
	 */
	private String getPersistedOffersKey()
	{
		if (currentRsn == null || currentRsn.isEmpty())
		{
			return PERSISTED_OFFERS_KEY_PREFIX + "unknown";
		}
		return PERSISTED_OFFERS_KEY_PREFIX + currentRsn;
	}
	
	private String getCollectedItemsKey()
	{
		if (currentRsn == null || currentRsn.isEmpty())
		{
			return COLLECTED_ITEMS_KEY_PREFIX + "unknown";
		}
		return COLLECTED_ITEMS_KEY_PREFIX + currentRsn;
	}
	
	/**
	 * Load previously persisted collected item IDs from config.
	 * These are items that were bought but not yet sold when the player logged out.
	 */
	private java.util.Set<Integer> loadPersistedCollectedItems()
	{
		String key = getCollectedItemsKey();
		
		try
		{
			String json = configManager.getConfiguration(CONFIG_GROUP, key);
			if (json == null || json.isEmpty())
			{
				return new java.util.HashSet<>();
			}
			
			Type type = new TypeToken<java.util.List<Integer>>(){}.getType();
			java.util.List<Integer> items = gson.fromJson(json, type);
			log.debug("Loaded {} persisted collected items for {}", items != null ? items.size() : 0, currentRsn);
			return items != null ? new java.util.HashSet<>(items) : new java.util.HashSet<>();
		}
		catch (Exception e)
		{
			log.error("Failed to load persisted collected items for {}: {}", currentRsn, e.getMessage());
			return new java.util.HashSet<>();
		}
	}
	
	/**
	 * Load previously persisted tracked offers from config.
	 * These represent the GE offer state when the player last logged out.
	 */
	private Map<Integer, TrackedOffer> loadPersistedOffers()
	{
		String key = getPersistedOffersKey();
		
		try
		{
			String json = configManager.getConfiguration(CONFIG_GROUP, key);
			if (json == null || json.isEmpty())
			{
				log.debug("No persisted offers found for {}", currentRsn);
				return new HashMap<>();
			}
			
			Type type = new TypeToken<Map<Integer, TrackedOffer>>(){}.getType();
			Map<Integer, TrackedOffer> offers = gson.fromJson(json, type);
			log.info("Loaded {} persisted offers for {}", offers != null ? offers.size() : 0, currentRsn);
			return offers != null ? offers : new HashMap<>();
		}
		catch (Exception e)
		{
			log.error("Failed to load persisted offers for {}: {}", currentRsn, e.getMessage());
			return new HashMap<>();
		}
	}

	@Subscribe
	public void onItemContainerChanged(ItemContainerChanged event)
	{
		int containerId = event.getContainerId();
		
		// Handle inventory changes
		if (containerId == INVENTORY_CONTAINER_ID)
		{
			updateCashStack();
			return;
		}
		
		// Handle bank container changes (bank opened/updated)
		if (containerId == InventoryID.BANK.getId())
		{
			onBankContainerChanged();
		}
	}
	
	/**
	 * Handle bank container changes - attempt to capture snapshot when bank is opened.
	 */
	private void onBankContainerChanged()
	{
		// Don't attempt if snapshot is already in progress
		if (bankSnapshotInProgress)
		{
			return;
		}
		
		// Enforce local cooldown to prevent spam
		long now = System.currentTimeMillis();
		if (now - lastBankSnapshotAttempt < BANK_SNAPSHOT_COOLDOWN_MS)
		{
			return;
		}
		
		// Must be logged in and have RSN
		String rsn = getCurrentRsnSafe().orElse(null);
		if (rsn == null)
		{
			return;
		}
		
		// Must be authenticated
		if (!apiClient.isAuthenticated())
		{
			return;
		}
		
		lastBankSnapshotAttempt = now;
		bankSnapshotInProgress = true;
		
		// Check rate limit first
		apiClient.checkBankSnapshotStatusAsync(rsn).thenAccept(status ->
		{
			if (status == null)
			{
				log.debug("Failed to check bank snapshot status");
				postBankSnapshotMessage("Failed to check snapshot status - will retry", true);
				bankSnapshotInProgress = false;
				// Reset cooldown on failure to allow retry
				lastBankSnapshotAttempt = 0;
				return;
			}
			
			if (!status.isCanSnapshot())
			{
				log.debug("Bank snapshot not available: {}", status.getMessage());
				// Don't spam the user - only show message if they might be expecting a snapshot
				// The rate limit message from server contains the next available time
				bankSnapshotInProgress = false;
				return;
			}
			
			// Rate limit passed - capture the snapshot on client thread
			clientThread.invokeLater(() -> captureBankSnapshot(rsn));
		}).exceptionally(e ->
		{
			log.debug("Error checking bank snapshot status: {}", e.getMessage());
			postBankSnapshotMessage("Connection error - will retry", true);
			bankSnapshotInProgress = false;
			// Reset cooldown on network failure to allow retry
			lastBankSnapshotAttempt = 0;
			return null;
		});
	}
	
	/**
	 * Capture the current bank contents and send to API.
	 * Must be called on client thread.
	 */
	private void captureBankSnapshot(String rsn)
	{
		try
		{
			java.util.List<FlipSmartApiClient.BankItem> items = collectTradeableBankItems();
			
			if (items == null || items.isEmpty())
			{
				bankSnapshotInProgress = false;
				return;
			}
			
			log.info("Capturing bank snapshot: {} tradeable items for RSN {}", items.size(), rsn);
			
			// Send snapshot to API
			apiClient.createBankSnapshotAsync(rsn, items).thenAccept(response ->
			{
				if (response != null)
				{
					String valueStr = String.format("%,d", response.getTotalValue());
					log.info("Bank snapshot captured: {} items worth {} GP", 
						response.getItemCount(), valueStr);
					postBankSnapshotMessage(
						String.format("Bank snapshot saved: %,d items worth %s GP", 
							response.getItemCount(), valueStr), 
						false);
				}
				else
				{
					log.debug("Failed to create bank snapshot");
					postBankSnapshotMessage("Failed to save bank snapshot", true);
				}
				bankSnapshotInProgress = false;
			}).exceptionally(e ->
			{
				log.debug("Error creating bank snapshot: {}", e.getMessage());
				postBankSnapshotMessage("Connection error - will retry", true);
				bankSnapshotInProgress = false;
				// Reset cooldown on network failure to allow retry
				lastBankSnapshotAttempt = 0;
				return null;
			});
		}
		catch (Exception e)
		{
			log.error("Error capturing bank snapshot: {}", e.getMessage());
			postBankSnapshotMessage("Error capturing bank data", true);
			bankSnapshotInProgress = false;
		}
	}
	
	/**
	 * Post a bank snapshot message to game chat.
	 * @param message The message to display (without prefix)
	 * @param isError Whether this is an error message (changes color)
	 */
	private void postBankSnapshotMessage(String message, boolean isError)
	{
		ChatMessageBuilder builder = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append("[Flip Smart] ")
			.append(isError ? ChatColorType.HIGHLIGHT : ChatColorType.NORMAL)
			.append(message);
		
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.CONSOLE)
			.runeLiteFormattedMessage(builder.build())
			.build());
	}
	
	/**
	 * Collect all tradeable items from the bank with their GE prices.
	 * @return List of bank items, or null if bank is unavailable/empty
	 */
	private java.util.List<FlipSmartApiClient.BankItem> collectTradeableBankItems()
	{
		ItemContainer bank = client.getItemContainer(InventoryID.BANK);
		if (bank == null)
		{
			log.debug("Bank container is null - bank may have been closed");
			return null;
		}
		
		Item[] bankItems = bank.getItems();
		if (bankItems == null || bankItems.length == 0)
		{
			log.debug("Bank is empty");
			return null;
		}
		
		java.util.List<FlipSmartApiClient.BankItem> items = new java.util.ArrayList<>();
		
		for (Item item : bankItems)
		{
			FlipSmartApiClient.BankItem bankItem = toTradeableBankItem(item);
			if (bankItem != null)
			{
				items.add(bankItem);
			}
		}
		
		if (items.isEmpty())
		{
			log.debug("No tradeable items with prices found in bank");
		}
		
		return items;
	}
	
	/**
	 * Convert a bank item to a BankItem if it's tradeable and has a price.
	 * @return BankItem or null if item should be skipped
	 */
	private FlipSmartApiClient.BankItem toTradeableBankItem(Item item)
	{
		int itemId = item.getId();
		int quantity = item.getQuantity();
		
		// Skip empty slots and placeholder items
		if (itemId <= 0 || quantity <= 0)
		{
			return null;
		}
		
		// Get item composition to check if tradeable
		ItemComposition comp = itemManager.getItemComposition(itemId);
		if (comp == null || !comp.isTradeable())
		{
			return null;
		}
		
		// Get GE price - itemManager uses cached wiki prices
		int gePrice = itemManager.getItemPrice(itemId);
		if (gePrice <= 0)
		{
			return null;
		}
		
		return new FlipSmartApiClient.BankItem(itemId, quantity, gePrice);
	}

	@Subscribe
	public void onScriptPostFired(ScriptPostFired event)
	{
		// Check if the GE offer setup screen was just built
		if (event.getScriptId() != ScriptID.GE_OFFERS_SETUP_BUILD)
		{
			return;
		}
		
		// Check if this is a SELL offer (type 1 = sell, type 0 = buy)
		int offerType = client.getVarbitValue(VarbitID.GE_NEWOFFER_TYPE);
		if (offerType != 1)
		{
			// Not a sell offer, don't auto-focus
			return;
		}
		
		// Get the item ID being set up for sale
		int itemId = client.getVarpValue(VarPlayerID.TRADINGPOST_SEARCH);
		if (itemId <= 0)
		{
			return;
		}
		
		// Check if we have an active flip for this item and auto-focus on it
		autoFocusOnActiveFlip(itemId);
	}
	
	/**
	 * Auto-focus on an active flip when the player sets up a sell offer for that item.
	 * This helps them see the recommended sell price without manually clicking in the panel.
	 */
	private void autoFocusOnActiveFlip(int itemId)
	{
		String rsn = getCurrentRsnSafe().orElse(null);
		
		apiClient.getActiveFlipsAsync(rsn).thenAccept(response ->
		{
			if (response == null || response.getActiveFlips() == null)
			{
				return;
			}
			
			// Find and focus on matching active flip
			ActiveFlip matchingFlip = findActiveFlipForItem(response.getActiveFlips(), itemId);
			if (matchingFlip != null)
			{
				setFocusForSell(matchingFlip);
			}
			else
			{
				log.debug("No active flip found for item {} when setting up sell offer", itemId);
			}
		});
	}
	
	/**
	 * Find an active flip matching the given item ID.
	 */
	private ActiveFlip findActiveFlipForItem(java.util.List<ActiveFlip> flips, int itemId)
	{
		for (ActiveFlip flip : flips)
		{
			if (flip.getItemId() == itemId)
			{
				return flip;
			}
		}
		return null;
	}
	
	/**
	 * Set the Flip Assist focus for selling an active flip.
	 * Prioritizes the panel's displayed sell price (which considers time thresholds
	 * and market conditions), then falls back to recommended price or minimum profitable.
	 */
	private void setFocusForSell(ActiveFlip flip)
	{
		int sellPrice;
		
		// First, check if the panel has a cached "smart" sell price for this item
		// This price considers time thresholds and current market conditions
		Integer panelPrice = flipFinderPanel != null ? flipFinderPanel.getDisplayedSellPrice(flip.getItemId()) : null;
		
		if (panelPrice != null && panelPrice > 0)
		{
			sellPrice = panelPrice;
			log.debug("Using panel's displayed sell price for {}: {} gp", flip.getItemName(), sellPrice);
		}
		else if (flip.getRecommendedSellPrice() != null && flip.getRecommendedSellPrice() > 0)
		{
			sellPrice = flip.getRecommendedSellPrice();
			log.debug("Using backend recommended sell price for {}: {} gp", flip.getItemName(), sellPrice);
		}
		else
		{
			// Calculate minimum profitable sell price (breakeven + 1gp after tax)
			// GE tax is 2%, so: sellPrice * 0.98 >= buyPrice + 1
			// sellPrice >= (buyPrice + 1) / 0.98
			sellPrice = (int) Math.ceil((flip.getAverageBuyPrice() + 1) / 0.98);
			log.debug("Using calculated min profitable price for {}: {} gp", flip.getItemName(), sellPrice);
		}
		
		FocusedFlip focus = FocusedFlip.forSell(
			flip.getItemId(),
			flip.getItemName(),
			sellPrice,
			flip.getTotalQuantity()
		);
		
		flipAssistOverlay.setFocusedFlip(focus);
		log.info("Auto-focused on active flip for sell: {} @ {} gp", flip.getItemName(), sellPrice);
		
		if (flipFinderPanel != null)
		{
			javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.setExternalFocus(focus));
		}
	}

	@Subscribe
	public void onGrandExchangeOfferChanged(GrandExchangeOfferChanged offerEvent)
	{
		final int slot = offerEvent.getSlot();
		final GrandExchangeOffer offer = offerEvent.getOffer();

		// Skip if game is not in LOGGED_IN state
		if (client.getGameState() != GameState.LOGGED_IN && offer.getState() == GrandExchangeOfferState.EMPTY)
		{
			return;
		}

		int itemId = offer.getItemId();
		int quantitySold = offer.getQuantitySold();
		int totalQuantity = offer.getTotalQuantity();
		int price = offer.getPrice();
		int spent = offer.getSpent();
		GrandExchangeOfferState state = offer.getState();
		
		// Get item name (must be called on client thread)
		String itemName = itemManager.getItemComposition(itemId).getName();
		
		// Check if this is during the login burst window
		int currentTick = client.getTickCount();
		boolean isLoginBurst = (currentTick - lastLoginTick) <= GE_LOGIN_BURST_WINDOW;
		
		if (isLoginBurst && state != GrandExchangeOfferState.EMPTY)
		{
			// During login, just track existing offers without recording transactions
			log.debug("Login burst: initializing tracking for slot {} with {} items sold", slot, quantitySold);
			
			boolean isBuy = state == GrandExchangeOfferState.BUYING || 
							state == GrandExchangeOfferState.BOUGHT ||
							state == GrandExchangeOfferState.CANCELLED_BUY;
			
			// Track the current state so future changes are detected correctly
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, quantitySold));
			
			// Note: offline sync is now scheduled from LOGGED_IN state change
			// after syncRSN() to ensure correct RSN-specific config key
			return;
		}

		// Check if this is a buy or sell offer
		boolean isBuy = state == GrandExchangeOfferState.BUYING || 
						state == GrandExchangeOfferState.BOUGHT ||
						state == GrandExchangeOfferState.CANCELLED_BUY;
		
		// Handle cancelled offers
		if (state == GrandExchangeOfferState.CANCELLED_BUY || state == GrandExchangeOfferState.CANCELLED_SELL)
		{
			// Only record the cancellation if some items were actually filled
			if (quantitySold > 0)
			{
				TrackedOffer previousOffer = trackedOffers.get(slot);
				
				// Check if we have any unfilled items that need to be recorded as cancelled
				if (previousOffer != null && quantitySold > previousOffer.previousQuantitySold)
				{
					// Record the final partial fill before cancellation
					int newQuantity = quantitySold - previousOffer.previousQuantitySold;
					int pricePerItem = spent / quantitySold;

					log.info("Recording final transaction before cancellation: {} {} x{}/{} @ {} gp each",
						isBuy ? "BUY" : "SELL",
						previousOffer.itemName,
						newQuantity,
						previousOffer.totalQuantity,
						pricePerItem);

					// Get recommended sell price if available
					Integer recommendedSellPrice = isBuy ? recommendedPrices.get(itemId) : null;
					
					apiClient.recordTransactionAsync(FlipSmartApiClient.TransactionRequest
						.builder(itemId, previousOffer.itemName, isBuy, newQuantity, pricePerItem)
						.geSlot(slot)
						.recommendedSellPrice(recommendedSellPrice)
						.rsn(getCurrentRsnSafe().orElse(null))
						.totalQuantity(previousOffer.totalQuantity)
						.build());
				}
				
			log.info("Order cancelled: {} {} - {} items filled out of {}",
				isBuy ? "BUY" : "SELL",
				previousOffer != null ? previousOffer.itemName : itemName,
				quantitySold,
				totalQuantity);
		}
		else
		{
			TrackedOffer previousOffer = trackedOffers.get(slot);
			log.info("Order cancelled with no fills: {} {}",
				isBuy ? "BUY" : "SELL",
				previousOffer != null ? previousOffer.itemName : itemName);
			
			// For cancelled BUY orders with 0 fills, dismiss the active flip
			// There's nothing to track - the order never filled
			if (isBuy)
			{
				log.info("Dismissing active flip for {} - buy order cancelled with 0 fills", itemName);
				apiClient.dismissActiveFlipAsync(itemId, getCurrentRsnSafe().orElse(null));
				
				// Refresh panel to remove the stale flip
				if (flipFinderPanel != null)
				{
					javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refreshActiveFlips());
				}
			}
		}
		
		// For cancelled BUY orders with partial fills, track the items as collected
			// so they still show as active flips until the user sells them
			if (isBuy && quantitySold > 0)
			{
				log.info("Cancelled buy order had {} items filled - tracking until sold", quantitySold);
				collectedItemIds.add(itemId);
				
				// Refresh panel to show the flip is still active
				if (flipFinderPanel != null)
				{
					javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.refreshActiveFlips());
				}
			}
			
			// Clean up tracked offer
			trackedOffers.remove(slot);
			return;
		}
		
		// Handle empty state (offer collected/cleared)
		if (state == GrandExchangeOfferState.EMPTY)
		{
			TrackedOffer collectedOffer = trackedOffers.remove(slot);
			
			// Track collected buy offers so they still show as active flips until sold
			if (collectedOffer != null && collectedOffer.isBuy && collectedOffer.previousQuantitySold > 0)
			{
				log.info("Buy offer collected from GE: {} x{} - tracking until sold", 
					collectedOffer.itemName, collectedOffer.previousQuantitySold);
				collectedItemIds.add(collectedOffer.itemId);
				
				// Check if the order completed fully and we might have missed fills
				// This handles the case where fills happened rapidly or while we weren't tracking
				int inventoryCount = getInventoryCountForItem(collectedOffer.itemId);
				int trackedFills = collectedOffer.previousQuantitySold;
				
				// If inventory shows more items than we tracked, sync with backend
				if (inventoryCount > trackedFills)
				{
					log.info("Order for {} may have completed offline - tracked {} fills but have {} in inventory. Syncing.",
						collectedOffer.itemName, trackedFills, inventoryCount);
					
					String rsn = getCurrentRsnSafe().orElse(null);
					if (rsn != null)
					{
						// Use the inventory count as the actual fill count
						int actualFills = Math.min(inventoryCount, collectedOffer.totalQuantity);
						apiClient.syncActiveFlipAsync(
							collectedOffer.itemId,
							collectedOffer.itemName,
							actualFills,
							collectedOffer.totalQuantity,
							collectedOffer.price,
							rsn
						);
					}
				}
				
				// Refresh panel to show updated state
				if (flipFinderPanel != null)
				{
					javax.swing.Timer refreshTimer = new javax.swing.Timer(500, e -> flipFinderPanel.refresh());
					refreshTimer.setRepeats(false);
					refreshTimer.start();
				}
			}
			return;
		}

		// Get the previously tracked offer for this slot
		TrackedOffer previousOffer = trackedOffers.get(slot);

		// Detect if quantity sold has increased (partial or full fill)
		if (quantitySold > 0)
		{
			int newQuantity = 0;

			if (previousOffer != null)
			{
				// Calculate how many items were just sold/bought
				newQuantity = quantitySold - previousOffer.previousQuantitySold;
			}
			else
			{
				// First time seeing this offer with sold items
				newQuantity = quantitySold;
			}

			// Record transaction if we have new items
			if (newQuantity > 0)
			{
				// Calculate the actual price per item from the spent amount
				int pricePerItem = spent / quantitySold;

				log.info("Recording transaction: {} {} x{} @ {} gp each (slot {}, {}/{} filled)",
					isBuy ? "BUY" : "SELL",
					itemName,
					newQuantity,
					pricePerItem,
					slot,
					quantitySold,
					totalQuantity);

				// Get recommended sell price if this was a buy from a recommendation
				Integer recommendedSellPrice = isBuy ? recommendedPrices.get(itemId) : null;
				
				// Record the transaction asynchronously with total order quantity
				apiClient.recordTransactionAsync(FlipSmartApiClient.TransactionRequest
					.builder(itemId, itemName, isBuy, newQuantity, pricePerItem)
					.geSlot(slot)
					.recommendedSellPrice(recommendedSellPrice)
					.rsn(getCurrentRsnSafe().orElse(null))
					.totalQuantity(totalQuantity)
					.build());
				
				// Clear recommended price after recording (only for buys)
				if (isBuy && recommendedSellPrice != null)
				{
					recommendedPrices.remove(itemId);
				}
				
				// If this was a sell, remove from collected tracking
				if (!isBuy)
				{
					markItemSold(itemId);
				}

				// Refresh active flips panel if it exists
				// Use a Swing Timer to add a small delay without blocking the EDT
				if (flipFinderPanel != null)
				{
					javax.swing.Timer refreshTimer = new javax.swing.Timer(500, e -> {
						// This will update both pending orders and active flips
						flipFinderPanel.refresh();
					});
					refreshTimer.setRepeats(false);
					refreshTimer.start();
				}
			}

			// Update tracked offer
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, quantitySold));
		}
		else
		{
			// New offer with no items sold yet, track it
			trackedOffers.put(slot, new TrackedOffer(itemId, itemName, isBuy, totalQuantity, price, 0));
			
			// Clear Flip Assist focus if this order matches the focused flip
			clearFlipAssistFocusIfMatches(itemId, isBuy);
			
			// Record new buy orders to the API (even with 0 fills) so webapp can track them
			if (isBuy && totalQuantity > 0 && previousOffer == null)
			{
				log.debug("Recording new buy order: {} x{} @ {} gp each (slot {}, 0/{} filled)",
					itemName, 0, price, slot, totalQuantity);
				
				Integer recommendedSellPrice = recommendedPrices.get(itemId);
				
				apiClient.recordTransactionAsync(FlipSmartApiClient.TransactionRequest
					.builder(itemId, itemName, true, 0, price)
					.geSlot(slot)
					.recommendedSellPrice(recommendedSellPrice)
					.rsn(getCurrentRsnSafe().orElse(null))
					.totalQuantity(totalQuantity)
					.build());
			}
			
			// When a SELL order is placed, mark the active flip as "selling" phase
			// This updates the backend so the webapp shows the correct phase
			if (!isBuy && totalQuantity > 0 && previousOffer == null)
			{
				log.info("Sell order placed for {} x{} - marking active flip as selling", itemName, totalQuantity);
				String rsn = getCurrentRsnSafe().orElse(null);
				if (rsn != null)
				{
					apiClient.markActiveFlipSellingAsync(itemId, rsn);
				}
			}
			
			// Refresh the flip finder panel when any new order is submitted
			// This ensures sell orders show up immediately in active flips
			if (previousOffer == null && flipFinderPanel != null)
			{
				javax.swing.SwingUtilities.invokeLater(() -> {
					flipFinderPanel.updatePendingOrders(getPendingBuyOrders());
					// Also refresh active flips to pick up new sell orders
					flipFinderPanel.refreshActiveFlips();
				});
			}
		}
	}
	
	/**
	 * Clear the Flip Assist focus if the submitted order matches the focused item
	 */
	private void clearFlipAssistFocusIfMatches(int itemId, boolean isBuy)
	{
		FocusedFlip focusedFlip = flipAssistOverlay.getFocusedFlip();
		if (focusedFlip == null)
		{
			return;
		}
		
		// Clear focus if the item matches and the order type matches the step
		if (focusedFlip.getItemId() == itemId)
		{
			boolean stepMatches = (isBuy && focusedFlip.isBuying()) || (!isBuy && focusedFlip.isSelling());
			if (stepMatches)
			{
				log.info("Clearing Flip Assist focus - order submitted for {} ({})", 
					focusedFlip.getItemName(), isBuy ? "BUY" : "SELL");
				flipAssistOverlay.clearFocus();
				
				// Also update the panel's visual state
				if (flipFinderPanel != null)
				{
					javax.swing.SwingUtilities.invokeLater(() -> flipFinderPanel.clearFocus());
				}
			}
		}
	}

	/**
	 * Initialize the Flip Finder panel and add it to the sidebar
	 */
	private void initializeFlipFinderPanel()
	{
		flipFinderPanel = new FlipFinderPanel(config, apiClient, itemManager, this, configManager)
		{
			@Override
			protected Integer getCashStack()
			{
				return currentCashStack > 0 ? currentCashStack : null;
			}
		};
		
		// Connect Flip Assist focus callback
		flipFinderPanel.setOnFocusChanged(focus -> {
			flipAssistOverlay.setFocusedFlip(focus);
			if (focus != null)
			{
				log.info("Flip Assist focus set: {} {} - {} @ {} gp", 
					focus.getStep(),
					focus.getItemName(),
					focus.getCurrentStepQuantity(),
					focus.getCurrentStepPrice());
			}
			else
			{
				log.info("Flip Assist focus cleared");
				flipAssistOverlay.clearFocus();
			}
		});
		
		// Connect auth success callback to sync RSN after Discord login
		flipFinderPanel.setOnAuthSuccess(() -> {
			// Sync RSN to API if we have one (player is logged in)
			if (currentRsn != null && !currentRsn.isEmpty())
			{
				log.info("Auth success callback - syncing RSN: {}", currentRsn);
				apiClient.updateRSN(currentRsn);
			}
			else
			{
				log.debug("Auth success callback - no RSN to sync yet");
			}
		});

		// Try to load custom icon from resources
		java.awt.image.BufferedImage iconImage = null;
		try
		{
			iconImage = net.runelite.client.util.ImageUtil.loadImageResource(getClass(), "/flip_finder_icon.png");
		}
		catch (Exception e)
		{
			log.debug("Could not load flip finder icon, using default icon");
		}

		// If custom icon not found, create a default one
		if (iconImage == null)
		{
			iconImage = createDefaultIcon();
		}

		// Create navigation button
		flipFinderNavButton = net.runelite.client.ui.NavigationButton.builder()
			.tooltip("Flip Finder")
			.icon(iconImage)
			.priority(7)
			.panel(flipFinderPanel)
			.build();

		clientToolbar.addNavigation(flipFinderNavButton);
		log.info("Flip Finder panel initialized");
	}

	/**
	 * Create a default icon for the Flip Finder button
	 */
	private java.awt.image.BufferedImage createDefaultIcon()
	{
		// Create a simple default icon
		java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(16, 16, java.awt.image.BufferedImage.TYPE_INT_ARGB);
		java.awt.Graphics2D g = image.createGraphics();
		g.setColor(java.awt.Color.ORANGE);
		g.fillRect(2, 2, 12, 12);
		g.setColor(java.awt.Color.WHITE);
		g.drawString("F", 5, 12);
		g.dispose();
		return image;
	}

	/**
	 * Update the player's current cash stack from inventory
	 */
	private void updateCashStack()
	{
		ItemContainer inventory = client.getItemContainer(INVENTORY_CONTAINER_ID);
		if (inventory == null)
		{
			currentCashStack = 0;
			return;
		}

		int totalCash = 0;
		Item[] items = inventory.getItems();

		// Item IDs for coins
		final int COINS_995 = 995;

		for (Item item : items)
		{
			if (item.getId() == COINS_995)
			{
				totalCash += item.getQuantity();
			}
		}

		if (totalCash != currentCashStack)
		{
			currentCashStack = totalCash;
			log.debug("Updated cash stack: {}", currentCashStack);

			// If cash stack changed significantly and we have a flip finder panel, refresh it
			if (flipFinderPanel != null && totalCash > 100_000)
			{
				// Only auto-refresh if it's been more than 30 seconds since last refresh
				long now = System.currentTimeMillis();
				if (now - lastFlipFinderRefresh > 30_000)
				{
					lastFlipFinderRefresh = now;
					flipFinderPanel.refresh();
				}
			}
		}
	}

	/**
	 * Start the auto-refresh timer for flip finder
	 */
	private void startFlipFinderRefreshTimer()
	{
		if (flipFinderRefreshTimer != null)
		{
			flipFinderRefreshTimer.cancel();
		}

		flipFinderRefreshTimer = new java.util.Timer("FlipFinderRefreshTimer", true);
		
		// Schedule refresh based on config
		int refreshMinutes = Math.max(1, Math.min(60, config.flipFinderRefreshMinutes()));
		long refreshIntervalMs = refreshMinutes * 60 * 1000L;

		flipFinderRefreshTimer.scheduleAtFixedRate(new java.util.TimerTask()
		{
			@Override
			public void run()
			{
				// Skip API calls if player is not logged into RuneScape
				// This saves API requests and battery when at the login screen
				if (!loggedIntoRunescape)
				{
					log.debug("Skipping auto-refresh - player not logged into RuneScape");
					return;
				}
				
				if (flipFinderPanel != null && config.showFlipFinder())
				{
					javax.swing.SwingUtilities.invokeLater(() ->
					{
						log.debug("Auto-refreshing flip finder");
						lastFlipFinderRefresh = System.currentTimeMillis();
						flipFinderPanel.refresh();
					});
				}
			}
		}, refreshIntervalMs, refreshIntervalMs);

		log.info("Flip Finder auto-refresh started (every {} minutes)", refreshMinutes);
	}

	/**
	 * Stop the auto-refresh timer for flip finder
	 */
	private void stopFlipFinderRefreshTimer()
	{
		if (flipFinderRefreshTimer != null)
		{
			flipFinderRefreshTimer.cancel();
			flipFinderRefreshTimer = null;
			log.info("Flip Finder auto-refresh stopped");
		}
	}

	@Provides
	FlipSmartConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(FlipSmartConfig.class);
	}
	
	// Mouse listener for GE overlay clicks
	private final MouseListener overlayMouseListener = new MouseListener()
	{
		@Override
		public java.awt.event.MouseEvent mouseClicked(java.awt.event.MouseEvent e)
		{
			// Get the overlay bounds
			Rectangle overlayBounds = geOverlay.getBounds();
			if (overlayBounds == null)
			{
				return e;
			}
			
			// Convert absolute click to relative coordinates
			Point relativeClick = new Point(
				e.getX() - overlayBounds.x,
				e.getY() - overlayBounds.y
			);
			
			// Check if click is on the collapse button
			Rectangle buttonBounds = geOverlay.getCollapseButtonBounds();
			if (buttonBounds.contains(relativeClick))
			{
				geOverlay.toggleCollapse();
				e.consume();
			}
			
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mousePressed(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseReleased(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseEntered(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseExited(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseDragged(java.awt.event.MouseEvent e)
		{
			return e;
		}
		
		@Override
		public java.awt.event.MouseEvent mouseMoved(java.awt.event.MouseEvent e)
		{
			return e;
		}
	};
}


package com.flipsmart;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;
import java.util.function.Function;

@Slf4j
@Singleton
public class FlipSmartApiClient
{
	private static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
	private static final String PRODUCTION_API_URL = "https://api.flipsm.art";
	private static final String ACCESS_TOKEN_KEY = "access_token";
	private static final String JSON_KEY_ITEM_ID = "item_id";
	
	private final OkHttpClient httpClient;
	private final Gson gson;
	private final FlipSmartConfig config;
	
	// Cache to avoid spamming the API
	private final Map<Integer, CachedAnalysis> analysisCache = new ConcurrentHashMap<>();
	private static final long CACHE_DURATION_MS = 180_000; // 3 minute cache
	
	// JWT token management
	private volatile String jwtToken = null;
	private volatile long tokenExpiry = 0;
	
	// Lock for authentication to prevent concurrent auth attempts
	private final Object authLock = new Object();

	@Inject
	public FlipSmartApiClient(FlipSmartConfig config, Gson gson, OkHttpClient okHttpClient)
	{
		this.config = config;
		// Use the injected Gson's builder to create a customized instance
		this.gson = gson.newBuilder().create();
		// Use the injected OkHttpClient directly as required by RuneLite
		this.httpClient = okHttpClient;
	}

	/**
	 * Get the API URL to use. Returns the configured override URL if set,
	 * otherwise returns the production URL.
	 */
	private String getApiUrl()
	{
		String configuredUrl = config.apiUrl();
		if (configuredUrl == null || configuredUrl.isEmpty())
		{
			return PRODUCTION_API_URL;
		}
		return configuredUrl;
	}

	/**
	 * Authentication result with status and message
	 */
	public static class AuthResult
	{
		public final boolean success;
		public final String message;
		
		public AuthResult(boolean success, String message)
		{
			this.success = success;
			this.message = message;
		}
	}
	
	/**
	 * Execute an HTTP request asynchronously with automatic retry on 401
	 * This is the core method that handles all HTTP requests off the main threads
	 * 
	 * @param request The request to execute
	 * @param responseHandler Function to process successful response body and return result
	 * @param errorHandler Consumer to handle errors
	 * @param retryOnAuth Whether to retry with re-authentication on 401
	 * @param <T> The return type
	 * @return CompletableFuture with the result
	 */
	private <T> CompletableFuture<T> executeAsync(Request request, Function<String, T> responseHandler, 
												   Consumer<String> errorHandler, boolean retryOnAuth)
	{
		CompletableFuture<T> future = new CompletableFuture<>();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("Request failed: {}", e.getMessage());
				if (errorHandler != null)
				{
					errorHandler.accept("Connection error: " + e.getMessage());
				}
				future.complete(null);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (response.code() == 401 && retryOnAuth)
					{
						// Token might have expired, try to re-authenticate
						log.debug("Received 401, attempting to re-authenticate");
						jwtToken = null;
						
						authenticateAsync().thenAccept(authSuccess ->
						{
							if (authSuccess)
							{
								// Rebuild request with new token
								Request retryRequest = request.newBuilder()
									.header("Authorization", "Bearer " + jwtToken)
									.build();
								
								// Retry without auth retry to prevent infinite loop
								executeAsync(retryRequest, responseHandler, errorHandler, false)
									.thenAccept(future::complete);
							}
							else
							{
								future.complete(null);
							}
						});
						return;
					}
					
					if (!response.isSuccessful())
					{
						log.debug("Request returned error: {}", response.code());
						if (errorHandler != null)
						{
							errorHandler.accept("Error " + response.code());
						}
						future.complete(null);
						return;
					}

					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					T result = responseHandler.apply(jsonData);
					future.complete(result);
				}
				catch (Exception e)
				{
					log.debug("Error processing response: {}", e.getMessage());
					future.complete(null);
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Execute an authenticated request asynchronously
	 */
	private <T> CompletableFuture<T> executeAuthenticatedAsync(Request.Builder requestBuilder,
															   Function<String, T> responseHandler)
	{
		return ensureAuthenticatedAsync().thenCompose(authenticated ->
		{
			if (!authenticated)
			{
				log.debug("Failed to authenticate");
				return CompletableFuture.completedFuture(null);
			}
			
			Request request = requestBuilder
				.header("Authorization", "Bearer " + jwtToken)
				.build();
			
			return executeAsync(request, responseHandler, null, true);
		});
	}
	
	/**
	 * Authenticate with the API and obtain a JWT token via login (async)
	 */
	private CompletableFuture<Boolean> authenticateAsync()
	{
		return loginAsync(config.email(), config.password())
			.thenApply(result -> result.success);
	}
	
	/**
	 * Login with email and password (async)
	 * @return CompletableFuture with AuthResult containing success status and message
	 */
	public CompletableFuture<AuthResult> loginAsync(String email, String password)
	{
		CompletableFuture<AuthResult> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		
		if (email == null || email.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your email address"));
			return future;
		}
		
		if (password == null || password.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your password"));
			return future;
		}
		
		String url = String.format("%s/auth/login", apiUrl);
		
		// Create JSON body with email and password
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("email", email);
		jsonBody.addProperty("password", password);
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request request = new Request.Builder()
			.url(url)
			.post(body)
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Failed to authenticate with API: {}", e.getMessage());
				future.complete(new AuthResult(false, "Connection error: " + e.getMessage()));
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (!response.isSuccessful())
					{
						if (response.code() == 401)
						{
							future.complete(new AuthResult(false, "Incorrect email or password"));
						}
						else if (response.code() == 404)
						{
							future.complete(new AuthResult(false, "Account not found. Please sign up first."));
						}
						else
						{
							future.complete(new AuthResult(false, "Login failed (error " + response.code() + ")"));
						}
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject tokenResponse = gson.fromJson(jsonData, JsonObject.class);
					
					synchronized (authLock)
					{
						jwtToken = tokenResponse.get(ACCESS_TOKEN_KEY).getAsString();
						// JWT tokens from this API expire in 7 days, but we'll check earlier
						// Set expiry to 6 days to refresh before actual expiry
						tokenExpiry = System.currentTimeMillis() + (6 * 24 * 60 * 60 * 1000L);
					}
					
					log.info("Successfully authenticated with API");
					future.complete(new AuthResult(true, "Login successful!"));
				}
				catch (Exception e)
				{
					log.error("Error processing login response: {}", e.getMessage());
					future.complete(new AuthResult(false, "Error processing response"));
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Synchronous login wrapper for backward compatibility
	 * Note: This should only be called from background threads
	 */
	public AuthResult login(String email, String password)
	{
		try
		{
			return loginAsync(email, password).get();
		}
		catch (Exception e)
		{
			log.error("Login failed: {}", e.getMessage());
			return new AuthResult(false, "Login failed: " + e.getMessage());
		}
	}
	
	/**
	 * Sign up a new account with email and password (async)
	 * @return CompletableFuture with AuthResult containing success status and message
	 */
	public CompletableFuture<AuthResult> signupAsync(String email, String password)
	{
		CompletableFuture<AuthResult> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		
		if (email == null || email.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your email address"));
			return future;
		}
		
		if (password == null || password.isEmpty())
		{
			future.complete(new AuthResult(false, "Please enter your password"));
			return future;
		}
		
		if (password.length() < 6)
		{
			future.complete(new AuthResult(false, "Password must be at least 6 characters"));
			return future;
		}
		
		String url = String.format("%s/auth/signup", apiUrl);
		
		// Create JSON body with email and password
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty("email", email);
		jsonBody.addProperty("password", password);
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request request = new Request.Builder()
			.url(url)
			.post(body)
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Failed to sign up with API: {}", e.getMessage());
				future.complete(new AuthResult(false, "Connection error: " + e.getMessage()));
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (!response.isSuccessful())
					{
						if (response.code() == 400)
						{
							future.complete(new AuthResult(false, "Email already registered. Please login instead."));
						}
						else
						{
							future.complete(new AuthResult(false, "Sign up failed (error " + response.code() + ")"));
						}
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject tokenResponse = gson.fromJson(jsonData, JsonObject.class);
					
					synchronized (authLock)
					{
						jwtToken = tokenResponse.get(ACCESS_TOKEN_KEY).getAsString();
						tokenExpiry = System.currentTimeMillis() + (6 * 24 * 60 * 60 * 1000L);
					}
					
					log.info("Successfully signed up and authenticated with API");
					future.complete(new AuthResult(true, "Account created successfully!"));
				}
				catch (Exception e)
				{
					log.error("Error processing signup response: {}", e.getMessage());
					future.complete(new AuthResult(false, "Error processing response"));
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Synchronous signup wrapper for backward compatibility
	 * Note: This should only be called from background threads
	 */
	public AuthResult signup(String email, String password)
	{
		try
		{
			return signupAsync(email, password).get();
		}
		catch (Exception e)
		{
			log.error("Signup failed: {}", e.getMessage());
			return new AuthResult(false, "Signup failed: " + e.getMessage());
		}
	}
	
	/**
	 * Check if currently authenticated
	 */
	public boolean isAuthenticated()
	{
		return jwtToken != null && System.currentTimeMillis() < tokenExpiry;
	}
	
	/**
	 * Clear the current authentication token
	 */
	public void clearAuth()
	{
		synchronized (authLock)
		{
			jwtToken = null;
			tokenExpiry = 0;
		}
	}
	
	// ============================================================================
	// Device Authorization Flow (Discord Login for Desktop Plugin)
	// ============================================================================
	
	/**
	 * Response from starting device authorization
	 */
	public static class DeviceAuthResponse
	{
		private String deviceCode;
		private String userCode;
		private String verificationUrl;
		private int expiresIn;
		private int pollInterval;
		
		/** Default constructor required for Gson deserialization */
		public DeviceAuthResponse() { }
		
		public String getDeviceCode() { return deviceCode; }
		public void setDeviceCode(String deviceCode) { this.deviceCode = deviceCode; }
		
		public String getUserCode() { return userCode; }
		public void setUserCode(String userCode) { this.userCode = userCode; }
		
		public String getVerificationUrl() { return verificationUrl; }
		public void setVerificationUrl(String verificationUrl) { this.verificationUrl = verificationUrl; }
		
		public int getExpiresIn() { return expiresIn; }
		public void setExpiresIn(int expiresIn) { this.expiresIn = expiresIn; }
		
		public int getPollInterval() { return pollInterval; }
		public void setPollInterval(int pollInterval) { this.pollInterval = pollInterval; }
	}
	
	/**
	 * Response from polling device authorization status
	 */
	public static class DeviceStatusResponse
	{
		private String status;  // pending, authorized, expired
		private String accessToken;
		private String tokenType;
		
		/** Default constructor required for Gson deserialization */
		public DeviceStatusResponse() { }
		
		public String getStatus() { return status; }
		public void setStatus(String status) { this.status = status; }
		
		public String getAccessToken() { return accessToken; }
		public void setAccessToken(String accessToken) { this.accessToken = accessToken; }
		
		public String getTokenType() { return tokenType; }
		public void setTokenType(String tokenType) { this.tokenType = tokenType; }
	}
	
	/**
	 * Start the device authorization flow for Discord login.
	 * Returns a device code and verification URL that the user should open in their browser.
	 * 
	 * @return CompletableFuture with DeviceAuthResponse containing device_code and verification_url
	 */
	public CompletableFuture<DeviceAuthResponse> startDeviceAuthAsync()
	{
		CompletableFuture<DeviceAuthResponse> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		String url = String.format("%s/auth/device/start", apiUrl);
		
		Request request = new Request.Builder()
			.url(url)
			.post(RequestBody.create(JSON, ""))
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.error("Failed to start device auth: {}", e.getMessage());
				future.complete(null);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (!response.isSuccessful())
					{
						log.error("Device auth start failed: {}", response.code());
						future.complete(null);
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject json = gson.fromJson(jsonData, JsonObject.class);
					
					DeviceAuthResponse authResponse = new DeviceAuthResponse();
					authResponse.deviceCode = json.get("device_code").getAsString();
					authResponse.userCode = json.get("user_code").getAsString();
					authResponse.verificationUrl = json.get("verification_url").getAsString();
					authResponse.expiresIn = json.get("expires_in").getAsInt();
					authResponse.pollInterval = json.get("poll_interval").getAsInt();
					
					log.info("Device auth started, verification URL: {}", authResponse.verificationUrl);
					future.complete(authResponse);
				}
				catch (Exception e)
				{
					log.error("Error parsing device auth response: {}", e.getMessage());
					future.complete(null);
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Poll the device authorization status to check if the user has completed Discord OAuth.
	 * 
	 * @param deviceCode The device code from startDeviceAuthAsync
	 * @return CompletableFuture with DeviceStatusResponse
	 */
	public CompletableFuture<DeviceStatusResponse> pollDeviceStatusAsync(String deviceCode)
	{
		CompletableFuture<DeviceStatusResponse> future = new CompletableFuture<>();
		
		String apiUrl = getApiUrl();
		String url = String.format("%s/auth/device/status?code=%s", apiUrl, deviceCode);
		
		Request request = new Request.Builder()
			.url(url)
			.get()
			.build();
		
		httpClient.newCall(request).enqueue(new Callback()
		{
			@Override
			public void onFailure(Call call, IOException e)
			{
				log.debug("Device status poll failed: {}", e.getMessage());
				future.complete(null);
			}

			@Override
			public void onResponse(Call call, Response response) throws IOException
			{
				try (response)
				{
					if (response.code() == 404)
					{
						// Device code not found - treat as expired
						DeviceStatusResponse statusResponse = new DeviceStatusResponse();
						statusResponse.status = "expired";
						future.complete(statusResponse);
						return;
					}
					
					if (!response.isSuccessful())
					{
						log.debug("Device status poll error: {}", response.code());
						future.complete(null);
						return;
					}
					
					okhttp3.ResponseBody responseBody = response.body();
					String jsonData = responseBody != null ? responseBody.string() : "";
					JsonObject json = gson.fromJson(jsonData, JsonObject.class);
					
					DeviceStatusResponse statusResponse = new DeviceStatusResponse();
					statusResponse.setStatus(json.get("status").getAsString());
					
					if ("authorized".equals(statusResponse.getStatus()) && json.has(ACCESS_TOKEN_KEY))
					{
						statusResponse.setAccessToken(json.get(ACCESS_TOKEN_KEY).getAsString());
						statusResponse.setTokenType(json.has("token_type") 
							? json.get("token_type").getAsString() : "bearer");
					}
					
					future.complete(statusResponse);
				}
				catch (Exception e)
				{
					log.error("Error parsing device status response: {}", e.getMessage());
					future.complete(null);
				}
			}
		});
		
		return future;
	}
	
	/**
	 * Set the JWT token directly (used when receiving token from device auth flow)
	 * @param token The JWT access token
	 */
	public void setAuthToken(String token)
	{
		synchronized (authLock)
		{
			this.jwtToken = token;
			// JWT tokens from this API expire in 7 days, but we'll check earlier
			this.tokenExpiry = System.currentTimeMillis() + (6 * 24 * 60 * 60 * 1000L);
		}
		log.info("Successfully authenticated via Discord");
	}
	
	/**
	 * Update the user's RuneScape Name on the server (async)
	 */
	public void updateRSN(String rsn)
	{
		if (rsn == null || rsn.isEmpty())
		{
			return;
		}
		
		String apiUrl = getApiUrl();
		String url = String.format("%s/auth/rsn?rsn=%s", apiUrl, rsn);
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.put(RequestBody.create(JSON, ""));
		
		executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			log.info("Successfully updated RSN to: {}", rsn);
			return true;
		}).exceptionally(e ->
		{
			log.debug("Failed to update RSN: {}", e.getMessage());
			return false;
		});
	}
	
	/**
	 * Check if we have a valid JWT token, and refresh if needed (async)
	 */
	private CompletableFuture<Boolean> ensureAuthenticatedAsync()
	{
		// Check if we have a token and it's not expired
		if (jwtToken != null && System.currentTimeMillis() < tokenExpiry)
		{
			return CompletableFuture.completedFuture(true);
		}
		
		// Token is missing or expired, authenticate
		return authenticateAsync();
	}

	/**
	 * Fetch item analysis from the API asynchronously
	 */
	public CompletableFuture<FlipAnalysis> getItemAnalysisAsync(int itemId)
	{
		// Check cache first
		CachedAnalysis cached = analysisCache.get(itemId);
		if (cached != null && !cached.isExpired())
		{
			return CompletableFuture.completedFuture(cached.getAnalysis());
		}

		String apiUrl = getApiUrl();
		String url = String.format("%s/analysis/%d?timeframe=1h", apiUrl, itemId);
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			FlipAnalysis analysis = gson.fromJson(jsonData, FlipAnalysis.class);
			removedExpiredCacheEntries();
			analysisCache.put(itemId, new CachedAnalysis(analysis));
			return analysis;
		});
	}

	/**
	 * Fetch flip recommendations from the API asynchronously
	 */
	public CompletableFuture<FlipFinderResponse> getFlipRecommendationsAsync(Integer cashStack, String flipStyle, int limit, Integer randomSeed)
	{
		String apiUrl = getApiUrl();
		
		// Build URL with query parameters
		StringBuilder urlBuilder = new StringBuilder();
		urlBuilder.append(String.format("%s/flip-finder?limit=%d&flip_style=%s", apiUrl, limit, flipStyle));
		
		if (cashStack != null)
		{
			urlBuilder.append(String.format("&cash_stack=%d", cashStack));
		}
		
		if (randomSeed != null)
		{
			urlBuilder.append(String.format("&random_seed=%d", randomSeed));
		}
		
		String url = urlBuilder.toString();
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, FlipFinderResponse.class));
	}

	/**
	 * Data class for transaction request parameters (use Builder to construct)
	 */
	public static class TransactionRequest
	{
		public final int itemId;
		public final String itemName;
		public final boolean isBuy;
		public final int quantity;
		public final int pricePerItem;
		public final Integer geSlot;
		public final Integer recommendedSellPrice;
		public final String rsn;
		public final Integer totalQuantity;

		private TransactionRequest(Builder builder)
		{
			this.itemId = builder.itemId;
			this.itemName = builder.itemName;
			this.isBuy = builder.isBuy;
			this.quantity = builder.quantity;
			this.pricePerItem = builder.pricePerItem;
			this.geSlot = builder.geSlot;
			this.recommendedSellPrice = builder.recommendedSellPrice;
			this.rsn = builder.rsn;
			this.totalQuantity = builder.totalQuantity;
		}

		public static Builder builder(int itemId, String itemName, boolean isBuy, int quantity, int pricePerItem)
		{
			return new Builder(itemId, itemName, isBuy, quantity, pricePerItem);
		}

		public static class Builder
		{
			private final int itemId;
			private final String itemName;
			private final boolean isBuy;
			private final int quantity;
			private final int pricePerItem;
			private Integer geSlot;
			private Integer recommendedSellPrice;
			private String rsn;
			private Integer totalQuantity;

			private Builder(int itemId, String itemName, boolean isBuy, int quantity, int pricePerItem)
			{
				this.itemId = itemId;
				this.itemName = itemName;
				this.isBuy = isBuy;
				this.quantity = quantity;
				this.pricePerItem = pricePerItem;
			}

			public Builder geSlot(Integer geSlot) { this.geSlot = geSlot; return this; }
			public Builder recommendedSellPrice(Integer price) { this.recommendedSellPrice = price; return this; }
			public Builder rsn(String rsn) { this.rsn = rsn; return this; }
			public Builder totalQuantity(Integer qty) { this.totalQuantity = qty; return this; }

			public TransactionRequest build() { return new TransactionRequest(this); }
		}
	}

	/**
	 * Record a Grand Exchange transaction asynchronously
	 */
	public CompletableFuture<Void> recordTransactionAsync(TransactionRequest request)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/transactions", apiUrl);
		
		// Create JSON body
		JsonObject jsonBody = new JsonObject();
		jsonBody.addProperty(JSON_KEY_ITEM_ID, request.itemId);
		jsonBody.addProperty("item_name", request.itemName);
		jsonBody.addProperty("is_buy", request.isBuy);
		jsonBody.addProperty("quantity", request.quantity);
		jsonBody.addProperty("price_per_item", request.pricePerItem);
		if (request.geSlot != null)
		{
			jsonBody.addProperty("ge_slot", request.geSlot);
		}
		if (request.recommendedSellPrice != null)
		{
			jsonBody.addProperty("recommended_sell_price", request.recommendedSellPrice);
		}
		if (request.rsn != null && !request.rsn.isEmpty())
		{
			jsonBody.addProperty("rsn", request.rsn);
		}
		if (request.totalQuantity != null && request.totalQuantity > 0)
		{
			jsonBody.addProperty("total_quantity", request.totalQuantity);
		}
		
		RequestBody body = RequestBody.create(JSON, jsonBody.toString());
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(body);
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			JsonObject responseObj = gson.fromJson(jsonData, JsonObject.class);
			log.info("Transaction recorded for {}: {}", request.rsn, responseObj.get("message").getAsString());
			return null;
		}).thenApply(v -> null);
	}

	/**
	 * Record a Grand Exchange transaction asynchronously (simplified overload)
	 * Used for recording offline transactions detected on login.
	 * 
	 * @param itemId Item ID
	 * @param itemName Item name
	 * @param transactionType "BUY" or "SELL"
	 * @param quantity Quantity traded
	 * @param pricePerItem Price per item
	 * @param rsn RuneScape Name
	 */
	public CompletableFuture<Void> recordTransactionAsync(int itemId, String itemName, String transactionType,
			int quantity, int pricePerItem, String rsn)
	{
		boolean isBuy = "BUY".equalsIgnoreCase(transactionType);
		TransactionRequest request = TransactionRequest
			.builder(itemId, itemName, isBuy, quantity, pricePerItem)
			.rsn(rsn)
			.build();
		
		return recordTransactionAsync(request);
	}

	/**
	 * Fetch active flips from the API asynchronously
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<ActiveFlipsResponse> getActiveFlipsAsync(String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/transactions/active-flips?rsn=%s", apiUrl, rsn);
		}
		else
		{
			url = String.format("%s/transactions/active-flips", apiUrl);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, ActiveFlipsResponse.class));
	}
	
	/**
	 * Fetch active flips from the API asynchronously (all RSNs)
	 */
	public CompletableFuture<ActiveFlipsResponse> getActiveFlipsAsync()
	{
		return getActiveFlipsAsync(null);
	}

	/**
	 * Dismiss an active flip asynchronously
	 */
	public CompletableFuture<Boolean> dismissActiveFlipAsync(int itemId)
	{
		return dismissActiveFlipAsync(itemId, null);
	}
	
	/**
	 * Dismiss an active flip asynchronously with RSN support
	 * @param itemId The item ID to dismiss
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<Boolean> dismissActiveFlipAsync(int itemId, String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/transactions/active-flips/%d?rsn=%s", apiUrl, itemId, rsn);
		}
		else
		{
			url = String.format("%s/transactions/active-flips/%d", apiUrl, itemId);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.delete();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			log.info("Successfully dismissed active flip for item {}", itemId);
			return true;
		}).exceptionally(e ->
		{
			log.warn("Failed to dismiss active flip: {}", e.getMessage());
			return false;
		});
	}

	/**
	 * Clean up stale active flips that are no longer being tracked.
	 * Sends the list of item IDs that the plugin considers "truly active"
	 * (items in GE slots or inventory). The API will mark all other active
	 * flips as manually closed.
	 * 
	 * @param activeItemIds Set of item IDs that are truly active
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 * @return CompletableFuture with cleanup result
	 */
	public CompletableFuture<Boolean> cleanupStaleFlipsAsync(java.util.Set<Integer> activeItemIds, String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/transactions/active-flips/cleanup?rsn=%s", apiUrl, rsn);
		}
		else
		{
			url = String.format("%s/transactions/active-flips/cleanup", apiUrl);
		}
		
		// Build the request body
		JsonObject requestBody = new JsonObject();
		com.google.gson.JsonArray itemIdsArray = new com.google.gson.JsonArray();
		for (Integer itemId : activeItemIds)
		{
			itemIdsArray.add(itemId);
		}
		requestBody.add("active_item_ids", itemIdsArray);
		
		RequestBody body = RequestBody.create(JSON, requestBody.toString());
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(body);
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			JsonObject responseObj = gson.fromJson(jsonData, JsonObject.class);
			int itemsCleaned = responseObj.has("items_cleaned") ? responseObj.get("items_cleaned").getAsInt() : 0;
			if (itemsCleaned > 0)
			{
				log.info("Cleaned up {} stale active flips", itemsCleaned);
			}
			else
			{
				log.debug("No stale flips to clean up");
			}
			return true;
		}).exceptionally(e ->
		{
			log.warn("Failed to cleanup stale flips: {}", e.getMessage());
			return false;
		});
	}

	/**
	 * Sync the filled quantity for an active flip when the plugin detects a mismatch.
	 * This is used when orders complete while offline and the plugin couldn't track
	 * incremental fills.
	 * 
	 * @param itemId Item ID to sync
	 * @param itemName Item name
	 * @param filledQuantity Actual filled quantity from GE/inventory
	 * @param orderQuantity Total order size
	 * @param pricePerItem Price per item
	 * @param rsn RuneScape Name
	 * @return CompletableFuture with success status
	 */
	public CompletableFuture<Boolean> syncActiveFlipAsync(int itemId, String itemName, int filledQuantity, 
			int orderQuantity, int pricePerItem, String rsn)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/transactions/active-flips/sync", apiUrl);
		
		JsonObject requestBody = new JsonObject();
		requestBody.addProperty(JSON_KEY_ITEM_ID, itemId);
		requestBody.addProperty("filled_quantity", filledQuantity);
		requestBody.addProperty("order_quantity", orderQuantity);
		requestBody.addProperty("price_per_item", pricePerItem);
		requestBody.addProperty("rsn", rsn);
		
		RequestBody body = RequestBody.create(JSON, requestBody.toString());
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(body);
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			JsonObject responseObj = gson.fromJson(jsonData, JsonObject.class);
			int previousQty = responseObj.has("previous_quantity") ? responseObj.get("previous_quantity").getAsInt() : 0;
			int newQty = responseObj.has("new_quantity") ? responseObj.get("new_quantity").getAsInt() : 0;
			if (previousQty != newQty)
			{
				log.info("Synced active flip for {} ({}): {} -> {} items", 
					itemName, itemId, previousQty, newQty);
			}
			return true;
		}).exceptionally(e ->
		{
			log.warn("Failed to sync active flip for {}: {}", itemId, e.getMessage());
			return false;
		});
	}

	/**
	 * Mark an active flip as in the 'sell' phase.
	 * Called when a sell order is placed for an item.
	 *
	 * @param itemId Item ID
	 * @param rsn RuneScape Name
	 * @return CompletableFuture with success status
	 */
	public CompletableFuture<Boolean> markActiveFlipSellingAsync(int itemId, String rsn)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/transactions/active-flips/%d/mark-selling?rsn=%s", apiUrl, itemId, rsn);

		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(RequestBody.create(JSON, ""));

		return executeAuthenticatedAsync(requestBuilder, jsonData ->
		{
			log.info("Marked active flip for item {} as selling", itemId);
			return true;
		}).exceptionally(e ->
		{
			log.debug("Failed to mark active flip as selling: {}", e.getMessage());
			return false;
		});
	}

	/**
	 * Fetch completed flips from the API asynchronously
	 * @param limit Maximum number of flips to return
	 * @param rsn Optional RSN to filter by (for multi-account support)
	 */
	public CompletableFuture<CompletedFlipsResponse> getCompletedFlipsAsync(int limit, String rsn)
	{
		String apiUrl = getApiUrl();
		String url;
		if (rsn != null && !rsn.isEmpty())
		{
			url = String.format("%s/flips/completed?limit=%d&rsn=%s", apiUrl, limit, rsn);
		}
		else
		{
			url = String.format("%s/flips/completed?limit=%d", apiUrl, limit);
		}
		
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();
		
		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, CompletedFlipsResponse.class));
	}
	
	/**
	 * Fetch completed flips from the API asynchronously (all RSNs)
	 */
	public CompletableFuture<CompletedFlipsResponse> getCompletedFlipsAsync(int limit)
	{
		return getCompletedFlipsAsync(limit, null);
	}

	/**
	 * Response wrapper for dumps API
	 */
	public static class DumpsResponse
	{
		public DumpEvent[] dumps;
		public int count;
		public String sort_by;
	}

	/**
	 * Fetch market dumps from the API asynchronously
	 *
	 * @param sortBy Sort order: "recency" or "profit"
	 * @param minProfit Minimum profit threshold (0 for all)
	 * @param limit Maximum number of dumps to return
	 * @param onSuccess Callback with dumps array
	 * @param onError Callback for error messages
	 */
	public void getDumpsAsync(String sortBy, int minProfit, int limit,
	                          Consumer<DumpEvent[]> onSuccess,
	                          Consumer<String> onError)
	{
		ensureAuthenticatedAsync().thenAccept(authSuccess ->
		{
			if (!authSuccess)
			{
				if (onError != null)
				{
					onError.accept("Authentication required");
				}
				return;
			}

			// Build query parameters
			HttpUrl.Builder urlBuilder = HttpUrl.parse(getApiUrl() + "/dumps").newBuilder();
			if (sortBy != null && !sortBy.isEmpty())
			{
				urlBuilder.addQueryParameter("sort_by", sortBy);
			}
			if (minProfit > 0)
			{
				urlBuilder.addQueryParameter("min_profit", String.valueOf(minProfit));
			}
			if (limit > 0)
			{
				urlBuilder.addQueryParameter("limit", String.valueOf(limit));
			}

			Request request = new Request.Builder()
				.url(urlBuilder.build())
				.header("Authorization", "Bearer " + jwtToken)
				.get()
				.build();

			executeAsync(request,
				body ->
				{
					DumpsResponse response = gson.fromJson(body, DumpsResponse.class);
					if (onSuccess != null)
					{
						onSuccess.accept(response != null ? response.dumps : new DumpEvent[0]);
					}
					return null;
				},
				onError,
				true // Retry on 401
			);
		});
	}

	/**
	 * Fetch market dumps with default parameters (recency sort, no min profit, limit 50)
	 */
	public void getDumpsAsync(Consumer<DumpEvent[]> onSuccess, Consumer<String> onError)
	{
		getDumpsAsync("recency", 0, 50, onSuccess, onError);
	}

	/**
	 * Clear the analysis cache
	 */
	public void clearCache()
	{
		analysisCache.clear();
	}

	/**
	 * Remove a specific item from the cache
	 */
	public void invalidateCache(int itemId)
	{
		analysisCache.remove(itemId);
	}

	/**
	 * Removes expired entries from the cache
	 */
	private void removedExpiredCacheEntries()
	{
		analysisCache.entrySet().removeIf(entry -> entry.getValue().isExpired());
	}

	/**
	 * Inner class to store cached analysis with timestamp
	 */
	private static class CachedAnalysis
	{
		private final FlipAnalysis analysis;
		private final long timestamp;

		public CachedAnalysis(FlipAnalysis analysis)
		{
			this.analysis = analysis;
			this.timestamp = System.currentTimeMillis();
		}

		public FlipAnalysis getAnalysis()
		{
			return analysis;
		}

		public boolean isExpired()
		{
			return System.currentTimeMillis() - timestamp > CACHE_DURATION_MS;
		}
	}

	// ============================================================================
	// Bank Snapshot API Methods
	// ============================================================================

	/**
	 * Data class for bank snapshot item
	 */
	public static class BankItem
	{
		public final int itemId;
		public final int quantity;
		public final int valuePerItem;

		public BankItem(int itemId, int quantity, int valuePerItem)
		{
			this.itemId = itemId;
			this.quantity = quantity;
			this.valuePerItem = valuePerItem;
		}
	}

	/**
	 * Check if a bank snapshot can be taken (rate limit check)
	 *
	 * @param rsn RuneScape Name to check
	 * @return CompletableFuture with BankSnapshotStatusResponse
	 */
	public CompletableFuture<BankSnapshotStatusResponse> checkBankSnapshotStatusAsync(String rsn)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/bank/snapshot/status?rsn=%s", apiUrl, rsn);

		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.get();

		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, BankSnapshotStatusResponse.class));
	}

	/**
	 * Create a bank snapshot with all items
	 *
	 * @param rsn RuneScape Name
	 * @param items List of bank items with quantities and values
	 * @return CompletableFuture with BankSnapshotResponse
	 */
	public CompletableFuture<BankSnapshotResponse> createBankSnapshotAsync(String rsn, java.util.List<BankItem> items)
	{
		String apiUrl = getApiUrl();
		String url = String.format("%s/bank/snapshot", apiUrl);

		// Build the request body
		JsonObject requestBody = new JsonObject();
		requestBody.addProperty("rsn", rsn);

		com.google.gson.JsonArray itemsArray = new com.google.gson.JsonArray();
		for (BankItem item : items)
		{
			JsonObject itemObj = new JsonObject();
			itemObj.addProperty(JSON_KEY_ITEM_ID, item.itemId);
			itemObj.addProperty("quantity", item.quantity);
			itemObj.addProperty("value_per_item", item.valuePerItem);
			itemsArray.add(itemObj);
		}
		requestBody.add("items", itemsArray);

		RequestBody body = RequestBody.create(JSON, requestBody.toString());
		Request.Builder requestBuilder = new Request.Builder()
			.url(url)
			.post(body);

		return executeAuthenticatedAsync(requestBuilder, jsonData ->
			gson.fromJson(jsonData, BankSnapshotResponse.class));
	}
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Represents a completed flip (matched buy/sell pair)
 */
@Data
public class CompletedFlip
{
	@SerializedName("id")
	private int id;

	@SerializedName("item_id")
	private int itemId;

	@SerializedName("item_name")
	private String itemName;

	@SerializedName("quantity")
	private int quantity;

	@SerializedName("buy_price_per_item")
	private int buyPricePerItem;

	@SerializedName("buy_total")
	private int buyTotal;

	@SerializedName("buy_time")
	private String buyTime;

	@SerializedName("sell_price_per_item")
	private int sellPricePerItem;

	@SerializedName("sell_total")
	private int sellTotal;

	@SerializedName("sell_time")
	private String sellTime;

	@SerializedName("gross_profit")
	private int grossProfit;

	@SerializedName("ge_tax")
	private int geTax;

	@SerializedName("net_profit")
	private int netProfit;

	@SerializedName("roi_percent")
	private double roiPercent;

	@SerializedName("flip_duration_seconds")
	private int flipDurationSeconds;

	@SerializedName("is_successful")
	private boolean isSuccessful;
}


package com.flipsmart;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ScriptID;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.Keybind;
import net.runelite.client.input.KeyListener;

import javax.inject.Inject;
import java.awt.Canvas;
import java.awt.KeyboardFocusManager;
import java.awt.event.KeyEvent;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Key listener for the Flip Assist feature.
 * Handles the hotkey press to auto-fill price and quantity in the GE.
 */
@Slf4j
public class FlipAssistInputListener implements KeyListener
{
	private final Client client;
	private final ClientThread clientThread;
	private final FlipSmartConfig config;
	private final FlipAssistOverlay flipAssistOverlay;
	
	// GE Interface group IDs
	private static final int GE_INTERFACE_GROUP = 465;
	private static final int GE_OFFER_GROUP = 162;
	
	// GE Interface child IDs
	private static final int GE_QUANTITY_CHILD = 24;
	
	// VarClient IDs (raw values to avoid deprecated API)
	private static final int VARCLIENT_INPUT_TYPE = 5;
	private static final int VARCLIENT_INPUT_TEXT = 359;
	
	// Input type values
	private static final int INPUT_TYPE_NUMERIC = 7;
	private static final int INPUT_TYPE_GE_ITEM_SEARCH = 14;
	
	// Chat message prefix - cyan color for visibility
	private static final String CHAT_MESSAGE_PREFIX = "<col=00e5ff>[FlipSmart]</col> ";
	
	// Widget groups to scan for price/quantity dialog title
	private static final int[] CHATBOX_WIDGET_GROUPS = {162, 163, 164, 217, 219, 229, 548, 161};
	
	// Parent widgets to check for static/dynamic children with price/quantity text
	private static final int[][] CHATBOX_PARENT_WIDGETS = {
		{162, 0}, {162, 1}, {162, 5}, {162, 24},
		{217, 0}, {217, 4}, {217, 5}, {217, 6}
	};
	
	@Inject
	public FlipAssistInputListener(Client client, ClientThread clientThread, FlipSmartConfig config, FlipAssistOverlay flipAssistOverlay)
	{
		this.client = client;
		this.clientThread = clientThread;
		this.config = config;
		this.flipAssistOverlay = flipAssistOverlay;
	}
	
	// Track the keyPressed event we're handling to consume its corresponding keyTyped
	private final AtomicReference<KeyEvent> handledKeyPressedEvent = new AtomicReference<>(null);
	
	@Override
	public void keyTyped(KeyEvent e)
	{
		// Only consume if this keyTyped corresponds to a keyPressed we handled
		// Check by comparing the key character
		KeyEvent handled = handledKeyPressedEvent.get();
		if (handled != null && 
			Character.toLowerCase(e.getKeyChar()) == Character.toLowerCase(handled.getKeyChar()))
		{
			handledKeyPressedEvent.set(null);
			e.consume();
		}
	}
	
	@Override
	public void keyPressed(KeyEvent e)
	{
		// Don't process hotkeys if Flip Assist is disabled
		if (!config.enableFlipAssistant())
		{
			return;
		}
		
		// Check if the hotkey matches
		Keybind hotkey = config.flipAssistHotkey();
		if (!hotkey.matches(e))
		{
			return;
		}
		
		// Don't trigger if no focused flip (this doesn't need client thread)
		FocusedFlip focusedFlip = flipAssistOverlay.getFocusedFlip();
		if (focusedFlip == null)
		{
			return;
		}
		
		// Use synchronous invoke to check conditions BEFORE consuming the event
		clientThread.invoke(() -> {
			// Check if GE is open (must be on client thread)
			if (!isGrandExchangeOpen())
			{
				return;
			}
			
			int inputType = client.getVarcIntValue(VARCLIENT_INPUT_TYPE);
			
			// Handle GE item search - press hotkey to select the first result
			// (Item name is auto-populated via GE_LAST_SEARCHED when flip is focused)
			if (inputType == INPUT_TYPE_GE_ITEM_SEARCH)
			{
				if (hasSearchResults())
				{
					handledKeyPressedEvent.set(e);
					e.consume();
					selectFirstSearchResult();
					flipAssistOverlay.updateStep();
				}
				return;
			}
			
			// Handle numeric input (price/quantity)
			if (inputType == INPUT_TYPE_NUMERIC)
			{
				handledKeyPressedEvent.set(e);
				e.consume();
				handleFlipAssistAction(focusedFlip);
				flipAssistOverlay.updateStep();
			}
		});
	}
	
	@Override
	public void keyReleased(KeyEvent e)
	{
		// Not used
	}
	
	/**
	 * Check if the Grand Exchange interface is open.
	 * MUST be called on client thread.
	 */
	private boolean isGrandExchangeOpen()
	{
		Widget geWidget = client.getWidget(GE_INTERFACE_GROUP, 0);
		Widget offerWidget = client.getWidget(GE_OFFER_GROUP, 0);
		
		return (geWidget != null && !geWidget.isHidden()) ||
			   (offerWidget != null && !offerWidget.isHidden());
	}
	
	/**
	 * Handle the Flip Assist action - auto-fill price/quantity in GE.
	 * Called only when in a numeric input dialog.
	 * MUST be called on client thread.
	 */
	private void handleFlipAssistAction(FocusedFlip focusedFlip)
	{
		// Determine if it's price or quantity based on context
		if (isLikelyPriceInput())
		{
			setInputValue(focusedFlip.getCurrentStepPrice());
			sendChatMessage(focusedFlip.getItemName() + " price set to " + String.format("%,d", focusedFlip.getCurrentStepPrice()) + " gp");
		}
		else
		{
			setInputValue(focusedFlip.getCurrentStepQuantity());
			sendChatMessage(focusedFlip.getItemName() + " quantity set to " + String.format("%,d", focusedFlip.getCurrentStepQuantity()));
		}
	}
	
	/**
	 * Set the current input field value and refresh the display.
	 * MUST be called on client thread.
	 */
	private void setInputValue(int value)
	{
		String valueStr = String.valueOf(value);
		client.setVarcStrValue(VARCLIENT_INPUT_TEXT, valueStr);
		
		// Run the script to rebuild/refresh the chatbox input display
		// This makes the value visible in the input field
		client.runScript(ScriptID.CHAT_TEXT_INPUT_REBUILD, valueStr);
	}
	
	/**
	 * Determine if we're in a price input dialog vs quantity input.
	 * Checks the chatbox dialog title text for keywords.
	 * MUST be called on client thread.
	 */
	private boolean isLikelyPriceInput()
	{
		// Scan ALL visible widgets in chatbox-related groups for the dialog title
		// The OSRS chatbox input dialog title can appear in various locations
		for (int groupId : CHATBOX_WIDGET_GROUPS)
		{
			// Check children 0-100 for each group
			for (int childId = 0; childId <= 100; childId++)
			{
				Optional<Boolean> result = checkWidgetForPriceKeyword(groupId, childId);
				if (result.isPresent())
				{
					return result.get();
				}
			}
		}
		
		// Also try checking static and dynamic children of key parent widgets
		for (int[] parent : CHATBOX_PARENT_WIDGETS)
		{
			Widget parentWidget = client.getWidget(parent[0], parent[1]);
			if (parentWidget != null)
			{
				// Check static children
				Optional<Boolean> staticResult = checkChildrenForPriceKeyword(parentWidget.getStaticChildren());
				if (staticResult.isPresent())
				{
					return staticResult.get();
				}
				
				// Check dynamic children
				Optional<Boolean> dynamicResult = checkChildrenForPriceKeyword(parentWidget.getDynamicChildren());
				if (dynamicResult.isPresent())
				{
					return dynamicResult.get();
				}
				
				// Check nested children
				Optional<Boolean> nestedResult = checkChildrenForPriceKeyword(parentWidget.getNestedChildren());
				if (nestedResult.isPresent())
				{
					return nestedResult.get();
				}
			}
		}
		
		// Fallback: Check the GE interface state to determine what we're setting
		// If quantity field has a non-default value, we're probably setting price
		return determineFromGEState();
	}
	
	/**
	 * Check an array of widget children for price/quantity keywords.
	 */
	private Optional<Boolean> checkChildrenForPriceKeyword(Widget[] children)
	{
		if (children == null)
		{
			return Optional.empty();
		}
		for (Widget child : children)
		{
			if (child != null && !child.isHidden())
			{
				Optional<Boolean> result = checkTextForPriceKeyword(child.getText());
				if (result.isPresent())
				{
					return result;
				}
			}
		}
		return Optional.empty();
	}
	
	/**
	 * Try to determine price vs quantity input based on GE interface state.
	 * If quantity is already set to a non-default value, we're likely setting price.
	 * @return true if likely price input, false if likely quantity input
	 */
	private boolean determineFromGEState()
	{
		// GE offer setup widget children for quantity and price displays
		Widget quantityWidget = client.getWidget(GE_INTERFACE_GROUP, GE_QUANTITY_CHILD);
		
		String quantityText = (quantityWidget != null && !quantityWidget.isHidden()) ? quantityWidget.getText() : null;
		
		// Parse quantity from text (e.g., "6,000" -> 6000)
		int currentQuantity = parseNumberFromText(quantityText);
		
		// If quantity has been set (> 1, since default is often 1) and we're in an input,
		// user is probably now setting price
		return currentQuantity > 1;
	}
	
	/**
	 * Parse a number from formatted text like "6,000" or "6000 coins".
	 */
	private int parseNumberFromText(String text)
	{
		if (text == null || text.isEmpty())
		{
			return 0;
		}
		try
		{
			// Remove commas, "coins", "gp", and any other non-numeric characters
			String numericOnly = text.replaceAll("\\D", "");
			if (numericOnly.isEmpty())
			{
				return 0;
			}
			return Integer.parseInt(numericOnly);
		}
		catch (NumberFormatException e)
		{
			return 0;
		}
	}
	
	/**
	 * Check a specific widget for price/quantity keywords.
	 * Returns Optional containing true if price, false if quantity, empty if no match.
	 */
	private Optional<Boolean> checkWidgetForPriceKeyword(int groupId, int childId)
	{
		Widget widget = client.getWidget(groupId, childId);
		if (widget != null && !widget.isHidden())
		{
			return checkTextForPriceKeyword(widget.getText());
		}
		return Optional.empty();
	}
	
	/**
	 * Check text for price/quantity keywords.
	 * Returns Optional containing true if price, false if quantity, empty if no match.
	 */
	private Optional<Boolean> checkTextForPriceKeyword(String text)
	{
		if (text != null && !text.isEmpty())
		{
			String lowerText = text.toLowerCase();
			// "Set a price for each item" = price input
			if (lowerText.contains("price") && !lowerText.contains("price:"))
			{
				return Optional.of(Boolean.TRUE);
			}
			// "How many do you wish to" = quantity input
			if (lowerText.contains("how many"))
			{
				return Optional.of(Boolean.FALSE);
			}
		}
		return Optional.empty();
	}
	
	/**
	 * Send a message to the chatbox (game message style).
	 * MUST be called on client thread.
	 */
	private void sendChatMessage(String message)
	{
		client.addChatMessage(
			net.runelite.api.ChatMessageType.GAMEMESSAGE,
			"",
			CHAT_MESSAGE_PREFIX + message,
			null
		);
	}
	
	/**
	 * Check if there are GE search results displayed.
	 * MUST be called on client thread.
	 */
	private boolean hasSearchResults()
	{
		// Check if the search results widget exists and has children
		Widget searchResults = client.getWidget(InterfaceID.Chatbox.MES_LAYER_SCROLLCONTENTS);
		if (searchResults == null || searchResults.isHidden())
		{
			return false;
		}
		
		Widget[] children = searchResults.getDynamicChildren();
		// Each search result has 3 children (icon, name, ?)
		return children != null && children.length >= 3;
	}
	
	/**
	 * Select the first item in the GE search results by dispatching Enter key.
	 * This simulates the user pressing Enter to confirm their search selection.
	 * MUST be called on client thread.
	 */
	private void selectFirstSearchResult()
	{
		// Get the game canvas to dispatch the key event to
		Canvas canvas = client.getCanvas();
		if (canvas == null)
		{
			return;
		}
		
		// Create and dispatch Enter key press event
		KeyEvent enterPressed = new KeyEvent(
			canvas,
			KeyEvent.KEY_PRESSED,
			System.currentTimeMillis(),
			0,  // no modifiers
			KeyEvent.VK_ENTER,
			KeyEvent.CHAR_UNDEFINED
		);
		
		// Create and dispatch Enter key typed event
		KeyEvent enterTyped = new KeyEvent(
			canvas,
			KeyEvent.KEY_TYPED,
			System.currentTimeMillis(),
			0,  // no modifiers
			KeyEvent.VK_UNDEFINED,
			'\n'
		);
		
		// Create and dispatch Enter key released event
		KeyEvent enterReleased = new KeyEvent(
			canvas,
			KeyEvent.KEY_RELEASED,
			System.currentTimeMillis(),
			0,  // no modifiers
			KeyEvent.VK_ENTER,
			KeyEvent.CHAR_UNDEFINED
		);
		
		// Dispatch through the keyboard focus manager to properly route to the game
		KeyboardFocusManager focusManager = KeyboardFocusManager.getCurrentKeyboardFocusManager();
		focusManager.dispatchKeyEvent(enterPressed);
		focusManager.dispatchKeyEvent(enterTyped);
		focusManager.dispatchKeyEvent(enterReleased);
	}
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

/**
 * Response from the active flips API endpoint
 */
@Data
public class ActiveFlipsResponse
{
	@SerializedName("active_flips")
	private List<ActiveFlip> activeFlips;

	@SerializedName("total_items")
	private int totalItems;

	@SerializedName("total_invested")
	private int totalInvested;
}


package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

/**
 * Response from creating a bank snapshot
 */
@Data
public class BankSnapshotResponse
{
	private int id;

	private String rsn;

	@SerializedName("total_value")
	private long totalValue;

	@SerializedName("item_count")
	private int itemCount;

	@SerializedName("snapshot_time")
	private String snapshotTime;

	private String message;
}

package com.flipsmart;

import com.google.gson.annotations.SerializedName;
import lombok.Data;

import java.util.List;

@Data
public class FlipFinderResponse
{
	@SerializedName("flip_style")
	private String flipStyle;

	@SerializedName("cash_stack")
	private Integer cashStack;

	@SerializedName("per_slot_budget")
	private Double perSlotBudget;

	@SerializedName("total_items_analyzed")
	private int totalItemsAnalyzed;

	@SerializedName("items_matching_criteria")
	private int itemsMatchingCriteria;

	private List<FlipRecommendation> recommendations;
}


package com.flipsmart;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(FlipSmartPlugin.class);
		RuneLite.main(args);
	}
}
