package com.regionchat;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class RegionChatTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(RegionChatPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

import java.awt.Color;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.ui.JagexColors;

@ConfigGroup("regionchat")
public interface RegionChatConfig extends Config
{
	@ConfigItem(
		keyName = "regionChatColour",
		name = "Region chat colour",
		description = "The colour the region messages should appear in"
	)
	default Color regionChatColour()
	{
		return JagexColors.CHAT_PUBLIC_TEXT_OPAQUE_BACKGROUND;
	}

	@ConfigItem(
		keyName = "shouldShowStateChanges",
		name = "Show enter/leave messages for regions",
		description = "Receive a message saying whenever you've entered/left a region"
	)
	default boolean shouldShowStateChanges()
	{
		return true;
	}

	@ConfigSection(
		position = 1,
		name = "Regions",
		description = "Which regions to have chat in"
	)
	String regions = "regionsSection";

	@ConfigItem(
		keyName = "barbFishingBaRegion",
		name = "Region chat at Barb Fishing",
		description = "Join region chat at Barbarian Fishing locations",
		section = regions
	)
	default boolean barbFishingBaRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "temporossRegion",
		name = "Region chat at Tempoross",
		description = "Join region chat at Tempoross",
		section = regions
	)
	default boolean temporossRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "zeahRcRegion",
		name = "Region chat whilst Zeah Runecrafting",
		description = "Join region chat at the Zeah Runecrafting areas",
		section = regions
	)
	default boolean zeahRcRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "zeahCatacombRegion",
		name = "Region chat whilst in the Zeah Catacombs",
		description = "Join region chat at the Zeah Catacombs",
		section = regions
	)
	default boolean zeahCatacombRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "wyrmRegion",
		name = "Region chat whilst at Wyrms",
		description = "Join region chat at Wyrms",
		section = regions
	)
	default boolean wyrmRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "motherlodeMineRegion",
		name = "Region chat in the Motherlode Mine",
		description = "Join region chat at the Motherlode Mine",
		section = regions
	)
	default boolean motherlodeMineRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "sepulchreRegion",
		name = "Region chat in the Sepulchre",
		description = "Join region chat at the Sepulchre",
		section = regions
	)
	default boolean sepulchreRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "zalcanoRegion",
		name = "Region chat at Zalcano",
		description = "Join region chat at Zalcano",
		section = regions
	)
	default boolean zalcanoRegion()
	{
		return true;
	}

	@ConfigItem(
		keyName = "sulliuscepRegion",
		name = "Region chat at Sulliusceps",
		description = "Join region chat at Sulliusceps",
		section = regions
	)
	default boolean sulliuscepRegion()
	{
		return true;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;
import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import io.ably.lib.realtime.AblyRealtime;
import io.ably.lib.realtime.Channel;
import io.ably.lib.realtime.ChannelEvent;
import io.ably.lib.realtime.ChannelState;
import io.ably.lib.realtime.CompletionListener;
import io.ably.lib.types.AblyException;
import io.ably.lib.types.ClientOptions;
import io.ably.lib.types.ErrorInfo;
import io.ably.lib.types.Message;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.MenuEntry;
import net.runelite.api.WorldType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class AblyManager
{
	private final Client client;

	private final Gson gson;

	private final Map<String, String> previousMessages = new HashMap<>();
	public final Map<String, String> previousRealMessages = new HashMap<>();

	private final String CHANNEL_NAME_PREFIX = "regionchat";

	private boolean changingChannels;

	@Inject
	ChatMessageManager chatMessageManager;

	private final RegionChatConfig config;

	private AblyRealtime ablyRealtime;
	private Channel ablyRegionChannel;

	private SpamMessages spamMessages;

	public final String BUBBLE_ICON = "<img=19>";

	@Inject
	public AblyManager(Client client, RegionChatConfig config, Gson gson)
	{
		this.client = client;
		this.config = config;
		this.gson = gson;
		this.spamMessages = new SpamMessages();
	}

	public void startConnection()
	{
		setupAblyInstances();
	}

	public void closeConnection()
	{
		ablyRealtime.close();
		ablyRealtime = null;
		ablyRegionChannel = null;
	}

	public void publishMessage(String message)
	{
		if (client.getLocalPlayer() == null)
		{
			return;
		}

		if (ablyRegionChannel == null)
		{
			return;
		}

		if (spamMessages.isSpam(message)) return;

		try
		{
			JsonObject msg = io.ably.lib.util.JsonUtils.object()
				.add("username", client.getLocalPlayer().getName())
				.add("message", message).toJson();

			ablyRegionChannel.publish("event", msg);
		}
		catch (AblyException err)
		{
			System.out.println(err.getMessage());
		}
	}

	private void handleMessage(Message message)
	{
		if (client.getGameState() == GameState.LOGGED_IN)
		{
			handleAblyMessage(message, config.regionChatColour());
		}
	}

	private void handleAblyMessage(Message message, Color color)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		RegionChatMessage msg = gson.fromJson((JsonElement) message.data, RegionChatMessage.class);

		String username = msg.username;
		String receivedMsg = Text.removeTags(msg.message);

		if (spamMessages.isSpam(msg.message)) return;
		if (isInvalidUsername(msg.username)) return;
		if (!tryUpdateMessages(username, receivedMsg)) return;

		final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
			.append(color, receivedMsg);

		if (username.length() > 12)
		{
			return;
		}
		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.PUBLICCHAT)
			.name(BUBBLE_ICON + msg.username)
			.runeLiteFormattedMessage(chatMessageBuilder.build())
			.build());
	}

	public boolean tryUpdateMessages(String name, String message)
	{
		String prevMessage = previousMessages.get(name);
		// If someone is spamming the same message during a session, block it
		if (message.equals(prevMessage))
		{
			return false;
		}

		String lastRealMessage = previousRealMessages.get(name);
		if (message.equals(lastRealMessage))
		{
			return false;
		}

		previousMessages.put(name, message);

		return true;
	}

	private void setupAblyInstances()
	{
		try
		{
			ClientOptions clientOptions = new ClientOptions();
			clientOptions.authUrl = "https://runelite-regionchat.herokuapp.com/token";
			ablyRealtime = new AblyRealtime(clientOptions);
		}
		catch (AblyException e)
		{
			e.printStackTrace();
		}
	}

	public void connectToRegion(Region region, String world)
	{
		String newChannelName = CHANNEL_NAME_PREFIX + ":" + world + ":" + region.getName();

		if (changingChannels)
		{
			return;
		}

		if (ablyRegionChannel != null && ablyRegionChannel.name.equals(newChannelName))
		{
			if (ablyRegionChannel.state == ChannelState.detached)
			{
				subscribeToChannel();
			}

			return;
		}

		changingChannels = true;

		if (ablyRegionChannel == null)
		{
			ablyRegionChannel = ablyRealtime.channels.get(newChannelName);
			setupAlerts(region);
			subscribeToChannel();
			return;
		}

		try
		{
			ablyRegionChannel.unsubscribe();
			ablyRegionChannel.detach(detatchListener(newChannelName, region));
		}
		catch (AblyException err)
		{
			changingChannels = false;
			System.err.println(err.getMessage());
		}
	}

	private void setupAlerts(Region region)
	{
		ablyRegionChannel.on(ChannelEvent.attached, stateChange -> {
			if (!config.shouldShowStateChanges())
			{
				return;
			}

			final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
				.append("Entered new Region Chat area: " + region.getName());

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ENGINE)
				.runeLiteFormattedMessage(chatMessageBuilder.build())
				.build());
		});

		ablyRegionChannel.on(ChannelEvent.detached, stateChange -> {
			if (!config.shouldShowStateChanges())
			{
				return;
			}

			final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
				.append("Left Region Chat area: " + region.getName());

			chatMessageManager.queue(QueuedMessage.builder()
				.type(ChatMessageType.ENGINE)
				.runeLiteFormattedMessage(chatMessageBuilder.build())
				.build());
		});
	}

	public CompletionListener detatchListener(String newChannelName, Region region)
	{
		return new CompletionListener()
		{
			@Override
			public void onSuccess()
			{
				ablyRegionChannel = ablyRealtime.channels.get(newChannelName);
				setupAlerts(region);
				subscribeToChannel();
			}

			@Override
			public void onError(ErrorInfo reason)
			{
				System.err.println(reason.message);
				changingChannels = false;
			}
		};
	}

	public void disconnectFromRegions()
	{
		if (ablyRegionChannel != null && ablyRegionChannel.state == ChannelState.attached)
		{
			try
			{
				ablyRegionChannel.unsubscribe();
				ablyRegionChannel.detach();
			}
			catch(AblyException err)
			{
				System.err.println(err.getMessage());
			}
		}
	}

	private void subscribeToChannel()
	{
		try
		{
			ablyRegionChannel.subscribe(this::handleMessage);
		}
		catch(AblyException err)
		{
			System.err.println(err.getMessage());
		}

		changingChannels = false;
	}

	// Checks for bits someone could insert in to be icons
	// Important in case it's a JMod icon or something
	private boolean isInvalidUsername(String username)
	{
		return username.toLowerCase().contains("<") || username.toLowerCase().startsWith("mod ");
	}

	public void printInfo(MenuEntry menuEntry)
	{
		final ChatMessageBuilder chatMessageBuilder = new ChatMessageBuilder()
			.append("This is a message from the Region Chat Runelite Plugin.");

		chatMessageManager.queue(QueuedMessage.builder()
			.type(ChatMessageType.ENGINE)
			.runeLiteFormattedMessage(chatMessageBuilder.build())
			.build());
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

import com.google.gson.Gson;
import com.google.inject.Provides;
import com.regionchat.overlay.RegionWidgetOverlay;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;
import javax.inject.Inject;
import javax.inject.Named;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.Varbits;
import net.runelite.api.WorldType;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.VarbitChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.Text;

@Slf4j
@PluginDescriptor(
	name = "Region Chat",
	description = "Talk to others even if they go to another fishing spot!",
	tags = { "chat" }
)
public class RegionChatPlugin extends Plugin
{
	@Inject
	private AblyManager ablyManager;

	@Inject
	private Client client;

	@Inject
	private Gson gson;

	@Inject
	private RegionChatConfig config;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private RegionWidgetOverlay regionWidgetOverlay;

	@Getter
	@Inject
	@Named("developerMode")
	private boolean developerMode;

	boolean inPvp;

	@Override
	protected void startUp() throws Exception
	{
		initRegions();
		ablyManager.startConnection();
	}

	@Override
	protected void shutDown() throws Exception
	{
		ablyManager.closeConnection();
	}

	// TODO: If not logged in, close channel

	@Subscribe
	public void onGameTick(GameTick event)
	{
		LocalPoint currentPos = client.getLocalPlayer().getLocalLocation();
		WorldPoint currentWorldPos = client.getLocalPlayer().getWorldLocation();

		WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, currentPos);

		boolean foundRegion = false;

		for (Region region : Region.values())
		{
			boolean validRegion = false;
			try
			{
				validRegion = (boolean) regionsToConfigs.get(region).call();
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}

			if (validRegion && region.getZones().stream().anyMatch((zone) -> zone.contains(worldPoint)))
			{
				int regionID = region.getInstancedRegionID(currentWorldPos, worldPoint);
				foundRegion = true;
				String channelName = "";
				channelName += client.getWorld();
				if (region.isInstance())
				{
					channelName +=  ":" + regionID;
				}

				ablyManager.connectToRegion(region, channelName);
			}
		}

		if (!foundRegion)
		{
			ablyManager.disconnectFromRegions();
		}
	}

	@Subscribe
	public void onVarbitChanged(VarbitChanged e)
	{
		inPvp = client.getVarbitValue(Varbits.PVP_SPEC_ORB) == 1;
	}

	@Subscribe
	public void onChatMessage(ChatMessage event)
	{
		EnumSet<WorldType> wt = client.getWorldType();

		if (wt.contains(WorldType.BOUNTY) ||
			wt.contains(WorldType.DEADMAN) ||
			wt.contains(WorldType.PVP) ||
			inPvp
		)
		{
			return;
		}

		String cleanedName = Text.sanitize(event.getName());
		String cleanedMessage = Text.removeTags(event.getMessage());

		if ((event.getType() != ChatMessageType.PUBLICCHAT &&
			event.getType() != ChatMessageType.MODCHAT))
		{
			return;
		}

		ablyManager.previousRealMessages.put(cleanedName, cleanedMessage);

		if(!cleanedName.equals(client.getLocalPlayer().getName()))
		{
			return;
		}

		ablyManager.tryUpdateMessages(cleanedName, cleanedMessage);
		ablyManager.publishMessage(cleanedMessage);
	}

	@Subscribe
	public void onCommandExecuted(CommandExecuted commandExecuted)
	{
		if (developerMode && commandExecuted.getCommand().equals("regionchat"))
		{
			if (commandExecuted.getArguments().length == 0 ||
				(Arrays.stream(commandExecuted.getArguments()).toArray()[0]).equals("hide"))
			{
				overlayManager.remove(regionWidgetOverlay);
			}
			else if ((Arrays.stream(commandExecuted.getArguments()).toArray()[0]).equals("show"))
				overlayManager.add(regionWidgetOverlay);
		}
	}

	@Provides
	RegionChatConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(RegionChatConfig.class);
	}

	@Getter
	private final Map<Region, Callable> regionsToConfigs = new HashMap<>();

	private void initRegions()
	{
		regionsToConfigs.put(Region.BARBARIAN_FISHING, config::barbFishingBaRegion);
		regionsToConfigs.put(Region.ZEAH_RC, config::zeahRcRegion);
		regionsToConfigs.put(Region.TEMPOROSS, config::temporossRegion);
		regionsToConfigs.put(Region.MOTHERLODE_MINE, config::motherlodeMineRegion);
		regionsToConfigs.put(Region.ZALCANO, config::zalcanoRegion);
		regionsToConfigs.put(Region.SEPULCHRE, config::sepulchreRegion);
		regionsToConfigs.put(Region.SULLIUSCEP, config::sulliuscepRegion);
		regionsToConfigs.put(Region.ZEAH_CATACOMBS, config::zeahCatacombRegion);
		regionsToConfigs.put(Region.WYRMS, config::wyrmRegion);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (event.getOption() != null &&
			event.getOption().equals("Message") &&
			event.getTarget() != null &&
			event.getTarget().contains(ablyManager.BUBBLE_ICON))
		{
			addNewEntry(client.getMenuEntries());
		}
	}

	private MenuEntry[] addNewEntry(MenuEntry[] menuEntries)
	{
		MenuEntry[] newMenuEntries = Arrays.copyOf(menuEntries, menuEntries.length + 1);

		client.createMenuEntry(menuEntries.length - 1)
			.setOption("Info")
			.setTarget("Region Chat")
			.onClick(ablyManager::printInfo)
			.setType(MenuAction.RUNELITE);

		return newMenuEntries;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * Copyright (c) 2016-2017, Seth <Sethtroll3@gmail.com>
 * Copyright (c) 2018, Lotto <https://github.com/devLotto>
 * Copyright (c) 2019, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat.overlay;

import com.regionchat.Region;
import com.regionchat.Zone;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import javax.inject.Inject;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayPriority;

public class RegionWidgetOverlay extends OverlayPanel
{
	private final Client client;

	@Inject
	public RegionWidgetOverlay(Client client)
	{
		this.client = client;

		setPosition(OverlayPosition.DYNAMIC);
		setPriority(OverlayPriority.HIGHEST);
		setLayer(OverlayLayer.MANUAL);
		drawAfterInterface(InterfaceID.WORLD_MAP);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		Widget worldMapWidget = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);

		if (worldMapWidget == null)
		{
			return null;
		}
		Rectangle worldMapRectangle = worldMapWidget.getBounds();

		graphics.setClip(worldMapRectangle);
		graphics.setColor(Color.CYAN);

		for (Region region : Region.values())
		{
			for (Zone zone : region.getZones())
			{
				Point bottomLeft = Perspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(zone.getMinX(),
					zone.getMinY(), 0));

				Point bottomRight = Perspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(zone.getMaxX(),
					zone.getMinY(), 0));

				Point topLeft = Perspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(zone.getMinX(),
					zone.getMaxY(), 0));

				Point topRight = Perspective.mapWorldPointToGraphicsPoint(client, new WorldPoint(zone.getMaxX(),
					zone.getMaxY(), 0));

				renderWorldMapLine(graphics, bottomLeft, bottomRight);
				renderWorldMapLine(graphics, bottomLeft, topLeft);
				renderWorldMapLine(graphics, topLeft, topRight);
				renderWorldMapLine(graphics, bottomRight, topRight);
			}
		}

		return null;
	}

	public void renderWorldMapLine(Graphics2D graphics, Point startPoint, Point endPoint)
	{
		if (startPoint == null || endPoint == null)
		{
			return;
		}

		graphics.drawLine(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
	}
}

/*
 * Copyright (c) 2018, Alex Kolpa <https://github.com/AlexKolpa>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat.overlay;

import java.awt.Rectangle;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.RenderOverview;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;

public class Perspective
{
	public static Point mapWorldPointToGraphicsPoint(Client client, WorldPoint worldPoint)
	{
		RenderOverview ro = client.getRenderOverview();

		if (!ro.getWorldMapData().surfaceContainsPosition(worldPoint.getX(), worldPoint.getY()))
		{
			return null;
		}

		float pixelsPerTile = ro.getWorldMapZoom();

		Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
		if (map != null)
		{
			Rectangle worldMapRect = map.getBounds();

			int widthInTiles = (int) Math.ceil(worldMapRect.getWidth() / pixelsPerTile);
			int heightInTiles = (int) Math.ceil(worldMapRect.getHeight() / pixelsPerTile);

			Point worldMapPosition = ro.getWorldMapPosition();

			//Offset in tiles from anchor sides
			int yTileMax = worldMapPosition.getY() - heightInTiles / 2;
			int yTileOffset = (yTileMax - worldPoint.getY() - 1) * -1;
			int xTileOffset = worldPoint.getX() + widthInTiles / 2 - worldMapPosition.getX();

			int xGraphDiff = ((int) (xTileOffset * pixelsPerTile));
			int yGraphDiff = (int) (yTileOffset * pixelsPerTile);

			//Center on tile.
			yGraphDiff -= pixelsPerTile - Math.ceil(pixelsPerTile / 2);
			xGraphDiff += pixelsPerTile - Math.ceil(pixelsPerTile / 2);

			yGraphDiff = worldMapRect.height - yGraphDiff;
			yGraphDiff += (int) worldMapRect.getY();
			xGraphDiff += (int) worldMapRect.getX();

			return new Point(xGraphDiff, yGraphDiff);
		}
		return null;
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

public class RegionChatMessage
{
	public String username;
	public String symbol;
	public String message;

	public RegionChatMessage(String username, String symbol, String message)
	{
		this.username = username;
		this.symbol = symbol;
		this.message = message;
	}
}

/*
 * Copyright (c) 2023, Russel <https://github.com/RusseII>
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import lombok.Getter;

public class SpamMessages
{
	@Getter
	Set<String> spamMessages = new HashSet<>();

	public SpamMessages()
	{
		spamMessages.addAll(Arrays.asList(
			"In the name of Saradomin, protector of us all, I now join you in the eyes of Saradomin.",
			"Thy cause was false, thy skills did lack; See you in Lumbridge when you get back.",
			"Go in peace in the name of Saradomin; May his glory shine upon you like the sun.",
			"The currency of goodness is honour; It retains its value through scarcity. This is Saradomin's wisdom.",
			"Two great warriors, joined by hand, to spread destruction across the land. In Zamorak's name, now two are one.",
			"The weak deserve to die, so the strong may flourish. This is the creed of Zamorak.",
			"May your bloodthirst never be sated, and may all your battles be glorious. Zamorak bring you strength.",
			"There is no opinion that cannot be proven true...by crushing those who choose to disagree with it. Zamorak give me strength!",
			"Battles are not lost and won; They simply remove the weak from the equation. Zamorak give me strength!",
			"Those who fight, then run away, shame Zamorak with their cowardice. Zamorak give me strength!",
			"Battle is by those who choose to disagree with it. Zamorak give me strength!",
			"Strike fast, strike hard, strike true: The strength of Zamorak will be with you. Zamorak give me strength!",
			"Light and dark, day and night, balance arises from contrast. I unify thee in the name of Guthix.",
			"Thy death was not in vain, for it brought some balance to the world. May Guthix bring you rest.",
			"May you walk the path, and never fall, for Guthix walks beside thee on thy journey. May Guthix bring you peace.",
			"The trees, the earth, the sky, the waters; All play their part upon this land. May Guthix bring you balance.",
			"Big High War God want great warriors. Because you can make more... I bind you in Big High War God name.",
			"You not worthy of Big High War God; you die too easy.",
			"Big High War God make you strong... so you smash enemies.",
			"War is best, peace is for weak. If you not worthy of Big High War God... you get made dead soon.",
			"As ye vow to be at peace with each other... and to uphold high values of morality and friendship... I now pronounce you united in the law of Armadyl.",
			"Thou didst fight true... but the foe was too great. May thy return be as swift as the flight of Armadyl.",
			"For thy task is lawful... May the blessing of Armadyl be upon thee.",
			"Peace shall bring thee wisdom; Wisdom shall bring thee peace. This is the law of Armadyl.",
			"Ye faithful and loyal to the Great Lord... May ye together succeed in your deeds. Ye are now joined by the greatest power.",
			"Thy faith faltered, no power could save thee. Like the Great Lord, one day you shall rise again.",
			"By day or night, in defeat or victory... the power of the Great Lord be with thee.",
			"Follower of the Great Lord be relieved: One day your loyalty will be rewarded. Power to the Great Lord!",
			"Just say neigh to gambling!", "Eww stinky!", "I will burn with you.",
			"Burn with me!", "Here fishy fishies!",
			"For Camelot!", "Raarrrrrgggggghhhhhhh", "Taste vengeance!", "Smashing!", "*yawn*"));
		// Messages from tobMistakeTrackerSpam
		spamMessages.addAll(Arrays.asList(
			"I'm planking!", // Note: Only need to add "I'm planking!" once
			"I'm drowning in Maiden's blood!",
			"I'm stunned!",
			"Bye!",
			"I'm eating cabbages!",
			"I can't count to four!",
			"I'm PKing my team!",
			"I was stuck in a web!",
			"I'm healing Verzik!"));
		// Messages from TOAMistakeTrackerSpam
		spamMessages.addAll(Arrays.asList(
			"Argh! It burns!",
			"Come on and slam!",
			"Ah! It burns!",
			"Embrace Darkness!",
			"I'm too slow!",
			"I'm griefing!",
			"?",
			"This jug feels a little light...",
			"I'm drowning in acid!",
			"I'm on a blood cloud!",
			"Nihil!",
			"I'm surfing!",
			"I'm exploding!",
			"The swarms are going in!",
			"I've been hatched!",
			"I'm fuming!",
			"The sky is falling!",
			"I've been corrupted!",
			"It's venomous!",
			"Come on and slam!|And welcome to the jam!",
			"I got rocked!",
			"They see me rollin'...",
			"It's raining!",
			"Who put that there?",
			"I'm going down!",
			"I'm disco-ing!",
			"I'm dancing!",
			"I'm winded!",
			"I'm getting bombed!",
			"I'm in jail!",
			"What even was that attack?",
			"I'm tripping!"));
	}

	public boolean isSpam(String message)
	{
		System.err.println(spamMessages.contains(message));
		return spamMessages.contains(message);
	}
}

/*
 * Copyright (c) 2019, Trevor <https://github.com/Trevor159>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

import lombok.Getter;
import static net.runelite.api.Constants.REGION_SIZE;
import net.runelite.api.coords.WorldPoint;

public class Zone
{
	@Getter
	private final int minX;
	@Getter
	private final int maxX;
	@Getter
	private final int minY;
	@Getter
	private final int maxY;
	private int minPlane = 0;
	private int maxPlane = 2;

	//The first plane of the "Overworld"
	public Zone()
	{
		minX = 1152;
		maxX = 3903;
		minY = 2496;
		maxY = 4159;
		maxPlane = 0;
	}

	public Zone(WorldPoint p1, WorldPoint p2)
	{
		minX = Math.min(p1.getX(), p2.getX());
		maxX = Math.max(p1.getX(), p2.getX());
		minY = Math.min(p1.getY(), p2.getY());
		maxY = Math.max(p1.getY(), p2.getY());
		minPlane = Math.min(p1.getPlane(), p2.getPlane());
		maxPlane = Math.max(p1.getPlane(), p2.getPlane());
	}

	public Zone(WorldPoint p)
	{
		minX = p.getX();
		maxX = p.getX();
		minY = p.getY();
		maxY = p.getY();
		minPlane = p.getPlane();
		maxPlane = p.getPlane();
	}

	public Zone(int regionID)
	{
		minX = ((regionID >> 8) & 0xFF) << 6;
		maxX = minX + REGION_SIZE;
		minY = (regionID & 0xFF) << 6;
		maxY = minY + REGION_SIZE;
	}

	public Zone(int regionID, int plane)
	{
		this(regionID);
		minPlane = plane;
		maxPlane = plane;
	}

	public boolean contains(WorldPoint worldPoint)
	{
		return minX <= worldPoint.getX()
			&& worldPoint.getX() <= maxX
			&& minY <= worldPoint.getY()
			&& worldPoint.getY() <= maxY
			&& minPlane <= worldPoint.getPlane()
			&& worldPoint.getPlane() <= maxPlane;
	}

	public WorldPoint getMinWorldPoint()
	{
		return new WorldPoint(minX, minY, minPlane);
	}
}

/*
 * Copyright (c) 2021, Zoinkwiz <https://github.com/Zoinkwiz>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.regionchat;

import java.util.Arrays;
import java.util.List;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

public enum Region
{
	BARBARIAN_FISHING("barb-fishing-ba", new Zone(new WorldPoint(2495, 3474, 0), new WorldPoint(2527, 3532, 0))),
	TEMPOROSS("tempoross", true, new Zone(12078)),
	ZEAH_RC("zeahrc",
		new Zone(new WorldPoint(1672, 3814, 0), new WorldPoint(1858, 3903, 0)),
		new Zone(new WorldPoint(1636, 3848, 0), new WorldPoint(1671, 3902, 0))
	),
	MOTHERLODE_MINE("motherlode", new Zone(14936)),
	ZALCANO("zalcano", new Zone(12126)),
	SEPULCHRE("sepulchre", new Zone(new WorldPoint(2220, 5760, 0), new WorldPoint(2591, 6039, 3))),
	SULLIUSCEP("sulliuscep", new Zone(new WorldPoint(3627, 3725, 0), new WorldPoint(3697, 3811, 0))),
	ZEAH_CATACOMBS("zeah-catacombs", new Zone(new WorldPoint(1599, 9983, 0), new WorldPoint(1730, 10115, 0))),
	WYRMS("wyrms", new Zone(new WorldPoint(1248, 10144, 0), new WorldPoint(1300, 10209, 0)));

	@Getter
	private final List<Zone> zones;

	@Getter
	private final String name;

	@Getter
	private final boolean isInstance;

	Region(String name, Zone... zone)
	{
		this.name = name;
		this.zones = Arrays.asList(zone);
		this.isInstance = false;
	}

	Region(String name, boolean isInstance, Zone... zone)
	{
		this.name = name;
		this.zones = Arrays.asList(zone);
		this.isInstance = isInstance;
	}

	public int getInstancedRegionID(WorldPoint realPlayerPoint, WorldPoint instancePlayerPoint)
	{
		WorldPoint minPoint = this.getZones().get(0).getMinWorldPoint();

		int xDiff = instancePlayerPoint.getX() - minPoint.getX();
		int yDiff = instancePlayerPoint.getY() - minPoint.getY();
		int realMinPointX = realPlayerPoint.getX() - xDiff;
		int realMinPointY = realPlayerPoint.getY() - yDiff;

		WorldPoint realMinPoint = new WorldPoint(realMinPointX, realMinPointY, 0);

		return realMinPoint.getRegionID();
	}
}

