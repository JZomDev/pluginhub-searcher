package com.bossbuddy;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.NPC;
import net.runelite.api.NPCComposition;
import net.runelite.api.coords.WorldPoint;

import java.util.ArrayList;
import java.util.List;

public class BossBuddyNPC
{
	@Getter
	private final int npcIndex;

	@Getter
	private final String npcName;

	@Getter
	private final int id;
	@Getter
	@Setter
	private NPC npc;

	@Getter
	@Setter
	private WorldPoint currentLocation;

	@Getter
	@Setter
	private double currentHp;

	@Getter
	@Setter
	private double healthRatio;

	@Getter
	@Setter
	private double healthScale;

	@Getter
	@Setter
	private boolean isDead;

	@Getter
	@Setter
	private int offset;

	@Getter
	@Setter
	private int isTypeNumeric;

	@Getter
	private int npcSize;

	/**
	 * The time the npc died at, in game ticks, relative to the tick counter
	 */
	@Getter
	@Setter
	private int diedOnTick;

	/**
	 * The time it takes for the npc to respawn, in game ticks
	 */
	@Getter
	@Setter
	private int respawnTime;

	@Getter
	@Setter
	private List<WorldPoint> possibleRespawnLocations;

	BossBuddyNPC(NPC npc)
	{
		this.npc = npc;
		this.id = npc.getId();
		this.npcName = npc.getName();
		this.npcIndex = npc.getIndex();
		this.currentLocation = npc.getWorldLocation();
		this.currentHp = 100;
		this.healthRatio = 100;
		this.healthScale = npc.getHealthScale();
		this.isDead = false;
		this.offset = 0;
		this.isTypeNumeric = 0;

		this.possibleRespawnLocations = new ArrayList<>(2);
		this.respawnTime = -1;
		this.diedOnTick = -1;

		final NPCComposition composition = npc.getTransformedComposition();

		if (composition != null)
		{
			this.npcSize = composition.getSize();
		}
	}
}

package com.bossbuddy.osrswiki;

import com.bossbuddy.util.Constants;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import okhttp3.*;
import java.io.IOException;
import java.text.NumberFormat;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

public class WikiScraper
{
	private final static String baseUrl = "https://oldschool.runescape.wiki";
	private final static String baseWikiUrl = baseUrl + "/w/";

	public static CompletableFuture<WikiItem[]> getWikiItemsByMonster(OkHttpClient okHttpClient, String monsterName, int monsterId)
	{
		CompletableFuture<WikiItem[]> future = new CompletableFuture<>();

		String rawURL;
		if (monsterId > -1)
		{
			rawURL = getWikiUrlWithIdRaw(monsterName, monsterId);
		}
		else
		{
			rawURL = getWikiUrlRaw(monsterName);
		}

		requestAsync(okHttpClient, rawURL).whenCompleteAsync((responseHTML, ex) -> {
			List<WikiItem> wikiItems = new ArrayList<>();

			if (ex != null)
			{
				WikiItem[] result = new WikiItem[0];
				future.complete(result);
			}

			List<String> matches = new ArrayList<>();
			Pattern pattern = Pattern.compile("^.*DropsLine.*$", Pattern.MULTILINE);
			Matcher matcher = pattern.matcher(responseHTML);

			while (matcher.find())
			{
				matches.add(matcher.group());
			}

			for (String match : matches)
			{
				WikiItem wikiItem = parseWikiItemString(match);
				wikiItems.add(wikiItem);
			}

			WikiItem[] result = wikiItems.toArray(new WikiItem[wikiItems.size()]);
			future.complete(result);
		});

		return future;
	}

	private static WikiItem parseWikiItemString(String wikiItemString){
		String name = "";
		int quantity = -1;
		double rarity = -1;
		String quantityString = "";
		String rarityString = "";

		String[] itemProperties = wikiItemString.split("\\|");
		NumberFormat nf = NumberFormat.getNumberInstance();

		for(String prop : itemProperties){
			String[] propKvP = prop.split("=");
			if (propKvP.length != 2)
				continue;

			String propName = propKvP[0];
			String propValue = propKvP[1].replace("}}","");

			switch(propName){
				case "name":
					name = propValue;
					break;
				case "quantity":
					quantityString = propValue;
					try
					{
						String[] quantityStrs = quantityString.replaceAll("\\s+", "").split("-");
						String firstQuantityStr = quantityStrs.length > 0 ? quantityStrs[0] : null;
						quantity = nf.parse(firstQuantityStr).intValue();
					}
					catch (ParseException ignored)
					{
					}
					break;
				case "rarity":
					rarityString = propValue;
					if (rarityString.startsWith("~"))
					{
						rarityString = rarityString.substring(1);
					}
					else if (rarityString.startsWith("2 × ") || rarityString.startsWith("3 × "))
					{
						rarityString = rarityString.substring(4);
					}

					try
					{
						String[] rarityStrs = rarityString.replaceAll("\\s+", "").split(";");
						String firstRarityStr = rarityStrs.length > 0 ? rarityStrs[0] : null;

						if (firstRarityStr != null)
						{
							if (firstRarityStr.equals("Always"))
							{
								rarity = 1.0;
							}
							else
							{
								String[] fraction = firstRarityStr.split("/");
								if (fraction.length > 1)
								{
									double numer = nf.parse(fraction[0]).doubleValue();
									double denom = nf.parse(fraction[1]).doubleValue();
									rarity = numer / denom;
								}

							}
						}
					}
					catch (ParseException ignored)
					{
					}
				}
			}
		return new WikiItem(name,quantity,quantityString,rarityString, rarity);
	}

	public static String getWikiUrl(String itemOrMonsterName)
	{
		String sanitizedName = sanitizeName(itemOrMonsterName);
		return baseWikiUrl + sanitizedName;
	}

	public static String getWikiUrlRaw(String monsterName)
	{
		String sanitizedName = sanitizeName(monsterName);
		return baseWikiUrl + sanitizedName + "?action=raw";
	}

	public static String getWikiUrlWithIdRaw(String monsterName, int monsterId)
	{
		String sanitizedName = sanitizeName(monsterName);
		if (monsterId == 7851 || monsterId == 7852)
		{
			sanitizedName = "Grotesque_Guardians";
		}
		return baseWikiUrl + sanitizedName + "?action=raw";
	}

	public static String sanitizeName(String name)
	{
		if (name.equalsIgnoreCase("tzhaar-mej"))
		{
			name = "tzhaar-mej (monster)";
		}
		if (name.equalsIgnoreCase("dusk") || name.equalsIgnoreCase("dawn"))
		{
			name = "grotesque guardians";
		}

		name = name.trim().toLowerCase().replaceAll("\\s+", "_");
		return name.substring(0, 1).toUpperCase() + name.substring(1);
	}

	private static CompletableFuture<String> requestAsync(OkHttpClient okHttpClient, String url)
	{
		CompletableFuture<String> future = new CompletableFuture<>();

		Request request = new Request.Builder().url(url).header("User-Agent", Constants.USER_AGENT).build();

		okHttpClient
			.newCall(request)
			.enqueue(
				new Callback()
				{
					@Override
					public void onFailure(Call call, IOException ex)
					{
						future.completeExceptionally(ex);
					}

					@Override
					public void onResponse(Call call, Response response) throws IOException
					{
						try (ResponseBody responseBody = response.body())
						{
							if (!response.isSuccessful())
							{
								future.complete("");
							}

							future.complete(responseBody.string());
						}
						finally
						{
							response.close();
						}
					}
				});

		return future;
	}
}
package com.bossbuddy.osrswiki;

import com.bossbuddy.util.Util;
import java.util.Objects;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class WikiItem
{
	@Getter
	private final String name;
	private final int quantity;
	private final String quantityStr;
	private final String rarityStr;
	private final double rarity;

	public WikiItem(String name, int quantity, String quantityStr, String rarityStr, double rarity)
	{
		this.name = name;
		this.quantity = quantity;
		this.quantityStr = quantityStr.replace(",", "");
		this.rarityStr = rarityStr.replace(",", "");
		this.rarity = rarity;
	}

	public boolean quantityMatch(int amount)
	{
		if (quantityStr.contains("-"))
		{
			String[] quantityBound = quantityStr.split("-");

			if (quantityStr.contains("noted"))
			{
				String notedQuantity = quantityStr.split("\\(noted\\)")[0];
				quantityBound = notedQuantity.split("-");
			}
			int[] intNumbers = new int[quantityBound.length];

			for (int i = 0; i < quantityBound.length; i++)
			{
				try
				{
					intNumbers[i] = Integer.parseInt(quantityBound[i].trim().replace(",", "")); // .trim() removes leading/trailing whitespace
				}
				catch (NumberFormatException e)
				{
					log.error("2 Could not parse '{}' to an integer. Skipping.", quantityBound[i]);
				}
			}

			return intNumbers[0] <= amount && amount <= intNumbers[1];
		}
		else if (quantityStr.contains("noted"))
		{
			String notedQuantity = quantityStr.split("\\(noted\\)")[0];

			String[] quantityBound = notedQuantity.split("-");
			int[] intNumbers = new int[quantityBound.length];

			for (int i = 0; i < quantityBound.length; i++)
			{
				try
				{
					intNumbers[i] = Integer.parseInt(quantityBound[i].trim().replace(",", ""));
				}
				catch (NumberFormatException e)
				{
					log.error("3 Could not parse '{}' to an integer. Skipping.", quantityBound[i]);
				}
			}

			if (quantityBound.length == 1)
			{
				return amount == Integer.parseInt(notedQuantity.trim());
			}

			return intNumbers[0] <= amount && amount <= intNumbers[1];
		}
		else if (Objects.equals(quantityStr, "N/A"))
		{
			return false;
		}
		return amount == Integer.parseInt(quantityStr);
	}

	public String getRarityLabelText(boolean percentMode)
	{
		String rarityLabelStr = rarityStr.contains(";") || rarityStr.equals("Always") || rarityStr.contains(" × ") ? rarityStr : Util.convertDecimalToFraction(rarity);
		if (percentMode)
		{
			rarityLabelStr = Util.toPercentage(rarity, rarity <= 0.0001 ? 3 : 2);
		}
		return rarityLabelStr;
	}
}
package com.bossbuddy.respawn;

import com.bossbuddy.Boss;
import com.bossbuddy.BossBuddyNPC;
import com.bossbuddy.BossBuddyPlugin;
import lombok.Getter;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.ui.overlay.infobox.Timer;
import net.runelite.client.util.AsyncBufferedImage;

import java.awt.image.BufferedImage;
import java.time.temporal.ChronoUnit;

@Getter
public class RespawnTimer extends Timer
{
	private final Boss boss;
	private final BossBuddyNPC bossBuddyNPC;

	public RespawnTimer(Boss boss, BufferedImage bossImage, Plugin plugin)
	{
		super(boss.getSpawnTime().toMillis(), ChronoUnit.MILLIS, bossImage, plugin);
		this.boss = boss;
		this.bossBuddyNPC = null;
	}

	public RespawnTimer(BossBuddyNPC bossBuddyNPC, AsyncBufferedImage image, BossBuddyPlugin bossBuddyPlugin)
	{
		super(bossBuddyNPC.getRespawnTime() * 600L, ChronoUnit.MILLIS, image, bossBuddyPlugin);
		this.boss = null;
		this.bossBuddyNPC = bossBuddyNPC;
	}

	public RespawnTimer(BossBuddyNPC bossBuddyNPC, Boss boss, BufferedImage bossImage, Plugin plugin)
	{
		super(boss.getSpawnTime().toMillis(), ChronoUnit.MILLIS, bossImage, plugin);
		this.boss = boss;
		this.bossBuddyNPC = bossBuddyNPC;
	}
}
package com.bossbuddy.respawn;

import net.runelite.client.Notifier;

import java.util.concurrent.Callable;

public class RespawnNotification implements Callable<String>
{

	private final Notifier notifier;
	private final String npcName;

	public RespawnNotification(String npcName, Notifier notifier)
	{
		this.npcName = npcName;
		this.notifier = notifier;
	}

	@Override
	public String call()
	{
		notifier.notify(npcName + " is about to spawn.");
		return "Result from " + npcName + " timer";
	}
}

package com.bossbuddy.respawn;

import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.BossBuddyNPC;
import com.bossbuddy.BossBuddyPlugin;
import com.google.common.base.Strings;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.awt.Polygon;
import java.awt.Stroke;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;
import javax.inject.Inject;

import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

public class RespawnOverlay extends Overlay
{

	private static final int MAX_DRAW_DISTANCE = 32;

	private final Client client;
	private final Map<Integer, BossBuddyNPC> bossBuddyNPCs;
	private final BossBuddyConfig config;
	private final BossBuddyPlugin plugin;

	@Inject
	private RespawnOverlay(Client client, BossBuddyConfig config, BossBuddyPlugin plugin)
	{
		this.bossBuddyNPCs = plugin.bossBuddyNPCs;
		this.client = client;
		this.config = config;
		this.plugin = plugin;
		setPosition(OverlayPosition.DYNAMIC);
		setPriority(PRIORITY_LOW);
		setLayer(OverlayLayer.ABOVE_SCENE);
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!this.config.npcRespawnLocation())
		{
			return null;
		}

		for (Integer npcIndex : this.bossBuddyNPCs.keySet())
		{
			BossBuddyNPC bossBuddyNPC = this.bossBuddyNPCs.get(npcIndex);
			if (!bossBuddyNPC.isDead())
			{
				continue;
			}

			final List<WorldPoint> spawnPoints = bossBuddyNPC.getPossibleRespawnLocations();

			for (WorldPoint spawnPoint : spawnPoints)
			{
				String text;
				Stroke stroke = new BasicStroke((float) 2);//config.borderWidth());
				Color tileColor = Color.CYAN;//point.getColor();
				final Instant now = Instant.now();
				final double baseTick = (bossBuddyNPC.getRespawnTime() - (client.getTickCount() - bossBuddyNPC.getDiedOnTick())) * (Constants.GAME_TICK_LENGTH / 1000.0);
				final double sinceLast = (now.toEpochMilli() - plugin.lastTickUpdate.toEpochMilli()) / 1000.0;
				final double timeLeft = Math.max(0, baseTick - sinceLast);
				if (timeLeft ==0)
					continue;

				text = String.valueOf(timeLeft);
				if (text.contains("."))
				{
					text = text.substring(0, text.indexOf(".") + 2);
				}
				WorldView wv = client.findWorldViewFromWorldPoint(spawnPoint);
				drawTile(graphics, wv, spawnPoint, tileColor, text, stroke);
			}
		}
		return null;
	}

	private void drawTile(Graphics2D graphics, WorldView wv, WorldPoint point, Color color, @Nullable String label, Stroke borderStroke)
	{
		if (wv.isTopLevel())
		{
			WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();

			if (point.distanceTo(playerLocation) >= MAX_DRAW_DISTANCE)
			{
				return;
			}
		}

		LocalPoint lp = LocalPoint.fromWorld(wv, point);
		if (lp == null)
		{
			return;
		}

		Polygon poly = Perspective.getCanvasTilePoly(client, lp);
		if (poly != null)
		{
			OverlayUtil.renderPolygon(graphics, poly, color, new Color(0, 0, 0, 50), borderStroke);
		}

		if (!Strings.isNullOrEmpty(label))
		{
			Point canvasTextLocation = Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);
			if (canvasTextLocation != null)
			{

				OverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);
			}
		}
	}
}

package com.bossbuddy.util;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.DecimalFormat;
import java.text.NumberFormat;

public class Util
{
	public static void showHandCursorOnHover(Component component)
	{
		component.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseEntered(MouseEvent evt)
			{
				evt.getComponent().setCursor(new Cursor(Cursor.HAND_CURSOR));
			}

			@Override
			public void mouseExited(MouseEvent evt)
			{
				evt.getComponent().setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
			}
		});
	}

	public static String rsFormat(double number)
	{
		int power;
		String suffix = " KMBT";
		String formattedNumber = "";

		NumberFormat formatter = new DecimalFormat("#,###.#");
		power = (int) StrictMath.log10(number);
		number = number / (Math.pow(10, (power / 3) * 3));
		formattedNumber = formatter.format(number);
		formattedNumber = formattedNumber + suffix.charAt(power / 3);
		return formattedNumber.length() > 4 ? formattedNumber.replaceAll("\\.[0-9]+", "") : formattedNumber;
	}

	public static String toPercentage(double n, int digits)
	{
		return String.format("%." + digits + "f", n * 100) + "%";
	}

	public static String convertDecimalToFraction(double x)
	{
		if (x < 0)
		{
			return "-" + convertDecimalToFraction(-x);
		}

		double tolerance = 1.0E-6;
		double h1 = 1;
		double h2 = 0;
		double k1 = 0;
		double k2 = 1;
		double b = x;
		do
		{
			double a = Math.floor(b);
			double aux = h1;
			h1 = a * h1 + h2;
			h2 = aux;
			aux = k1;
			k1 = a * k1 + k2;
			k2 = aux;
			b = 1 / (b - a);
		} while (Math.abs(x - h1 / k1) > x * tolerance);

		int h1Int = (int) h1;
		int k1Int = (int) k1;

		double denom = k1 / h1;

		int denomInt = k1Int / h1Int;

		String denomStr = String.valueOf(Math.round(denom * 100.0) / 100.0);
		if (Math.floor(denom) == denom)
		{
			denomStr = String.valueOf(denomInt);
		}

		return 1 + "/" + denomStr;
	}
}
package com.bossbuddy.util;

import net.runelite.client.RuneLite;
import net.runelite.client.ui.ColorScheme;

import java.awt.*;

public class Constants
{
	public static final String PLUGIN_NAME = "Boss Buddy";
	public static final String CONFIG_GROUP = "BossBuddy";
	public static final int DEFAULT_PRIORITY = 5;
	public static final String USER_AGENT = RuneLite.USER_AGENT + " (boss-buddy)";

	public static final Color DEFAULT_COMMON_COLOR = Color.white;
	public static final Color DEFAULT_PRICE_COLOR = ColorScheme.GRAND_EXCHANGE_ALCH;
}
package com.bossbuddy.util;

import net.runelite.client.util.ImageUtil;

import java.awt.image.BufferedImage;

public class Icons
{
	public static final BufferedImage navImg = ImageUtil.loadImageResource(Icons.class, "/Boss_Buddy_Nav.png");
}
package com.bossbuddy;

import com.bossbuddy.hp.HPOverlay;
import com.bossbuddy.respawn.RespawnOverlay;
import com.bossbuddy.gearhelper.EquipmentOverlay;
import com.bossbuddy.loot.BossDropFraction;
import com.bossbuddy.loot.BossDropItem;
import com.bossbuddy.osrswiki.WikiItem;
import com.bossbuddy.osrswiki.WikiScraper;
import com.bossbuddy.respawn.RespawnNotification;
import com.bossbuddy.respawn.RespawnTimer;
import com.bossbuddy.util.Icons;
import com.bossbuddy.util.Constants;
import com.bossbuddy.views.BossBuddyPanel;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.Notifier;
import net.runelite.client.chat.*;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.*;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemStack;
import net.runelite.api.WorldView;
import net.runelite.api.gameval.ItemID;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.Timer;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.stream.Collectors;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.infobox.InfoBoxManager;
import static net.runelite.api.gameval.NpcID.*;
import static net.runelite.api.gameval.VarbitID.*;
import okhttp3.OkHttpClient;

@SuppressWarnings("SameReturnValue")
@Slf4j
@PluginDescriptor(
	name = "Boss Buddy"
)
public class BossBuddyPlugin extends Plugin
{
	ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();
	private static final int MAX_ACTOR_VIEW_RANGE = 15;
	private static final int MAX_RESPAWN_TIME_TICKS = 500;

	@Setter
	private boolean isUserLoggedIn = false;

	private boolean skipNextSpawnCheck = false;
	private static final int COINS = ItemID.COINS;
	private static final Duration WAIT = Duration.ofSeconds(5);

	@Getter(AccessLevel.PACKAGE)
	private Actor lastOpponent;

	@Getter(AccessLevel.PACKAGE)
	private NPC lastNPC;

	@Getter(AccessLevel.PACKAGE)
	@VisibleForTesting
	private Instant lastTime;

	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private HPOverlay hpOverlay;

	@Inject
	private RespawnOverlay respawnOverlay;

	@Inject
	private EquipmentOverlay equipmentOverlay;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ItemManager itemManager;

	@Inject
	private Notifier notifier;

	@Inject
	private InfoBoxManager infoBoxManager;

	@Inject
	private ConfigManager configManager;

	@Inject
	private EventBus eventBus;

	@Inject
	private Gson gson;

	@Inject
	private ScheduledExecutorService executor;

	@Inject
	public OkHttpClient okHttpClient;

	@Getter(AccessLevel.PACKAGE)
	public Instant lastTickUpdate;

	@Getter(AccessLevel.PUBLIC)
	public final Map<Integer, BossBuddyNPC> bossBuddyNPCs = new HashMap<>();

	DateTimeFormatter formatter = DateTimeFormatter
		.ofPattern("yyyyMMdd")
		.withZone(ZoneOffset.UTC);

	private static final Multimap<String, String> NPC_DISAMBIGUATION_MAP = ImmutableMultimap.of(
		"Dusk", "Grotesque Guardians"
	);

	private String profileKey;
	private final Map<Integer, WikiItem[]> loadedWikiItems = new HashMap<>();
	private final List<NPC> spawnedNpcsThisTick = new ArrayList<>();
	private final List<NPC> despawnedNpcsThisTick = new ArrayList<>();
	private WorldPoint lastPlayerLocation;
	private final HashMap<Integer, WorldPoint> npcLocations = new HashMap<>();

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private BossBuddyConfig config;

	private BossBuddyPanel panel;
	private NavigationButton navButton;

	@Override
	protected void startUp()
	{
		profileKey = null;

		if (client.getGameState() == GameState.LOGGED_IN)
		{
			isUserLoggedIn = true;
		}

		scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();

		String profileKey = configManager.getRSProfileKey();
		if (profileKey != null)
		{
			switchProfile(profileKey);
		}
		panel = new BossBuddyPanel(this, config, configManager, gson, clientThread, profileKey);

		navButton =
			NavigationButton.builder()
				.tooltip(Constants.PLUGIN_NAME)
				.icon(Icons.navImg)
				.priority(Constants.DEFAULT_PRIORITY)
				.panel(panel)
				.build();

		clientToolbar.addNavigation(navButton);
		overlayManager.add(hpOverlay);
		overlayManager.add(respawnOverlay);
		overlayManager.add(equipmentOverlay);

		clientThread.invokeLater(this::rebuildAllNpcs);
	}

	@Override
	protected void shutDown()
	{
		clientThread.invoke(() ->
		{
			bossBuddyNPCs.clear();
			spawnedNpcsThisTick.clear();
			despawnedNpcsThisTick.clear();
		});
		overlayManager.remove(hpOverlay);
		overlayManager.remove(respawnOverlay);
		overlayManager.remove(equipmentOverlay);
		npcLocations.clear();
		bossBuddyNPCs.clear();
		clientToolbar.removeNavigation(navButton);
		scheduledExecutorService.shutdown();
	}

	private void switchProfile(String profileKey)
	{
		executor.execute(() ->
		{
			this.profileKey = profileKey;

			log.debug("Switched to profile {}", profileKey);

			clientThread.invokeLater(() ->
			{
				if (client.getGameState().getState() < GameState.LOGIN_SCREEN.getState())
				{
					return false;
				}

				SwingUtilities.invokeLater(() ->
					panel.profileKey = this.profileKey);

				return true;
			});
		});
	}

	public void buildPanelItems(ConfigLoot lootConfig)
	{
		BossDropItem[] bdi = buildBossDropItemsFromConfig(lootConfig);
		panel.refreshMainPanelWithRecords(lootConfig.getName(), bdi, lootConfig.getKills());
	}

	private BossDropItem[] buildBossDropItemsFromConfig(ConfigLoot configLoot)
	{
		int dropsCount = configLoot.numDrops();
		int[] drops = configLoot.getDrops();

		BossDropItem[] items = new BossDropItem[dropsCount];
		for (int i = 0; i < dropsCount * 4; i += 4)
		{
			int id = drops[i];
			int killCount = drops[i + 1];
			int gePrice = drops[i + 2];
			int date = drops[i + 3];
			items[i / 4] = buildBossDropItem(id, 0, killCount, gePrice, date);
		}
		return items;
	}

	private BossDropItem buildBossDropItem(int itemId, int quantity, int killCount, int gePrice, int date)
	{
		final ItemComposition itemComposition = itemManager.getItemComposition(itemId);
		if (gePrice == -1)
		{
			gePrice = itemManager.getItemPrice(itemId);
		}

		boolean tradeable = itemComposition.isTradeable();
		int isNoted = itemComposition.getNote();

		if (isNoted == 799)
		{
			int noteId = itemComposition.getLinkedNoteId();
			if (noteId != -1)
			{
				ItemComposition notedItem = itemManager.getItemComposition(noteId);
				tradeable = notedItem.isTradeable();
			}
		}
		if (Objects.equals(itemComposition.getName(), "Coins"))
		{
			tradeable = true;
		}

		return new BossDropItem(
			itemId,
			itemComposition.getMembersName(),
			quantity,
			killCount,
			date,
			gePrice,
			tradeable,
			itemManager.getImage(itemId));
	}

	public void setLootConfig(String name, ConfigLoot loot)
	{
		String profile = profileKey;
		if (Strings.isNullOrEmpty(profile))
		{
			log.debug("Trying to set loot with no profile!");
			return;
		}

		String json = gson.toJson(loot);
		configManager.setConfiguration(BossBuddyConfig.GROUP, profile, "BOSS_BUDDY_NPC_" + name.toUpperCase(), json);
	}

	ConfigLoot getLootConfig(String name)
	{
		String profile = profileKey;
		if (Strings.isNullOrEmpty(profile))
		{
			log.debug("Trying to get loot with no profile!");
			return null;
		}

		String json = configManager.getConfiguration(BossBuddyConfig.GROUP, profile, "BOSS_BUDDY_NPC_" + name.toUpperCase());
		if (json == null)
		{
			return null;
		}

		return gson.fromJson(json, ConfigLoot.class);
	}

	@Subscribe
	public void onRuneScapeProfileChanged(RuneScapeProfileChanged e)
	{
		final String profileKey = configManager.getRSProfileKey();
		if (profileKey == null)
		{
			return;
		}

		if (profileKey.equals(this.profileKey))
		{
			return;
		}

		switchProfile(profileKey);
	}

	@Subscribe
	public void onMenuOpened(final MenuOpened event)
	{
		if (!config.coinSplit())
			return;

		final MenuEntry[] entries = event.getMenuEntries();
		for (int idx = entries.length - 1; idx >= 0; --idx)
		{
			final MenuEntry entry = entries[idx];
			final Widget w = entry.getWidget();
			if (w != null && WidgetUtil.componentToInterface(w.getId()) == InterfaceID.INVENTORY
				&& "Examine".equals(entry.getOption()) && entry.getIdentifier() == 10)
			{
				final int itemId = w.getItemId();
				final int itemCount = w.getItemQuantity();
				if (itemId == COINS)
				{
					entry
						.setOption("Split")
						.setTarget(entry.getTarget())
						.setType(MenuAction.RUNELITE);

					Menu subLeft = entry.createSubMenu();

					subLeft.createMenuEntry(-1)
						.setOption("Split 2")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> splitCoins(itemCount, 2));

					subLeft.createMenuEntry(-1)
						.setOption("Split 3")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> splitCoins(itemCount, 3));

					subLeft.createMenuEntry(-1)
						.setOption("Split 4")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> splitCoins(itemCount, 4));

					subLeft.createMenuEntry(-1)
						.setOption("Split 5")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> splitCoins(itemCount, 5));
				}
			}
		}
	}

	private void splitCoins(int quantity, int splitAmount)
	{
		DecimalFormat formatter = new DecimalFormat("#,###");
		log.info(String.valueOf(quantity / splitAmount));

		String chatMessage = new ChatMessageBuilder()
			.append(ChatColorType.HIGHLIGHT)
			.append(String.format("Split: %s / %d = %s", formatter.format(quantity), splitAmount, formatter.format(quantity / splitAmount)))
			.build();

		chatMessageManager.queue(
			QueuedMessage.builder()
				.type(ChatMessageType.CONSOLE)
				.runeLiteFormattedMessage(chatMessage)
				.build());
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged)
	{
		if (gameStateChanged.getGameState() == GameState.LOGIN_SCREEN ||
			gameStateChanged.getGameState() == GameState.HOPPING)
		{
			bossBuddyNPCs.forEach((id, npc) -> npc.setDiedOnTick(-1));
			lastPlayerLocation = null;
			skipNextSpawnCheck = true;
		}
	}

	private static Collection<ItemStack> stack(Collection<ItemStack> items)
	{
		final List<ItemStack> list = new ArrayList<>();

		for (final ItemStack item : items)
		{
			int quantity = 0;
			for (final ItemStack i : list)
			{
				if (i.getId() == item.getId())
				{
					quantity = i.getQuantity();
					list.remove(i);
					break;
				}
			}
			if (quantity > 0)
			{
				list.add(new ItemStack(item.getId(), item.getQuantity() + quantity));
			}
			else
			{
				list.add(item);
			}
		}
		return list;
	}


	@Provides
	BossBuddyConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BossBuddyConfig.class);
	}

	@Subscribe
	public void onInteractingChanged(InteractingChanged event)
	{
		WorldView worldView = client.getTopLevelWorldView();
		if (event.getSource() != client.getLocalPlayer())
		{
			return;
		}

		Actor opponent = event.getTarget();

		if (opponent == null)
		{
			lastTime = Instant.now();
			return;
		}

		lastOpponent = opponent;
		List<NPC> matchingNPC = worldView.npcs().stream().filter(npc -> Objects.equals(npc.getName(), lastOpponent.getName()) && npc.getCombatLevel() == lastOpponent.getCombatLevel()).collect(Collectors.toList());
		for (NPC curNPC : matchingNPC)
		{
			lastNPC = curNPC;

			if (!loadedWikiItems.isEmpty() && loadedWikiItems.containsKey(curNPC.getId()))
			{
				log.debug("Drop table already loaded");
			}
			else
			{
				WikiScraper.getWikiItemsByMonster(okHttpClient, curNPC.getName(), curNPC.getId()).whenCompleteAsync((wikiItems, ex) -> {
					DecimalFormat df = new DecimalFormat("#.####");
					df.setRoundingMode(RoundingMode.CEILING);

					loadedWikiItems.put(curNPC.getId(), wikiItems);
				});
			}
		}
	}

	@Subscribe
	public void onGameTick(GameTick gameTick)
	{
		validateSpawnedNpcs();
		lastTickUpdate = Instant.now();
		lastPlayerLocation = client.getLocalPlayer().getWorldLocation();

		if (lastOpponent != null
			&& lastTime != null
			&& client.getLocalPlayer().getInteracting() == null)
		{
			if (Duration.between(lastTime, Instant.now()).compareTo(WAIT) > 0)
			{
				lastOpponent = null;
				lastNPC = null;
			}
		}

		if (!config.showOverlay())
		{
			return;
		}

		HashMap<WorldPoint, Integer> locationCount = new HashMap<>();
		for (WorldPoint location : npcLocations.values())
		{
			locationCount.put(location, locationCount.getOrDefault(location, 0) + 1);
		}

		for (NPC npc : client.getTopLevelWorldView().npcs())
		{
			if (npc.getCombatLevel() <= 0)
			{
				continue;
			}

			BossBuddyNPC bossBuddyNPC = bossBuddyNPCs.get(npc.getIndex());

			if (bossBuddyNPC != null)
			{
				updateBossBuddyNPCProperties(npc, bossBuddyNPC, locationCount);
			}
		}

		List<Integer> npcToRemove = new ArrayList<>();
		for (BossBuddyNPC bossBuddyNPC : this.bossBuddyNPCs.values())
		{
			final Instant now = Instant.now();
			final double baseTick = (bossBuddyNPC.getRespawnTime() - (client.getTickCount() - bossBuddyNPC.getDiedOnTick())) * (net.runelite.api.Constants.GAME_TICK_LENGTH / 1000.0);
			final double sinceLast = (now.toEpochMilli() - this.lastTickUpdate.toEpochMilli()) / 1000.0;
			final double timeLeft = baseTick - sinceLast;

			if (timeLeft <= -60 && !isInViewRange(client.getLocalPlayer().getWorldLocation(), bossBuddyNPC.getNpc().getWorldLocation()))
			{
				npcToRemove.add(bossBuddyNPC.getNpcIndex());
			}
		}

		for (Integer npcIndex : npcToRemove)
		{
			this.bossBuddyNPCs.remove(npcIndex);
		}
	}

	private void updateBossBuddyNPCProperties(NPC npc, BossBuddyNPC bossBuddyNPC, Map<WorldPoint, Integer> locationCount)
	{
		double monsterHpRatio = ((double) npc.getHealthRatio() / (double) npc.getHealthScale() * 100);
		double monsterHp = 0;

		boolean isBoss = Boss.isNpcBoss(npc);
		if (isBoss)
		{
			Boss boss = Boss.find(npc.getId());
			int curHp = client.getVarbitValue(HPBAR_HUD_HP);
			int maxHp = client.getVarbitValue(HPBAR_HUD_BASEHP);

			if(!boss.isIgnoreMaxHp())
			{
				maxHp = boss.getMaxHp();
				curHp = (int) (maxHp * ((double) npc.getHealthRatio() / (double) npc.getHealthScale()));
				monsterHp = curHp;
			}

			if (maxHp > 0 && curHp >= 0)
			{
				double hpVarbitRatio = 100.0 * curHp / maxHp;
				if (hpVarbitRatio > 0)
				{
					monsterHpRatio = hpVarbitRatio;
				}
			}
			//else
			//{
			//	return;
			//}
		}
		boolean isDoomBoss = Boss.DOOM_BOSS_IDS.contains(npc.getId());

		if (!npc.isDead() && ((npc.getHealthRatio() / npc.getHealthScale() != 1) || isDoomBoss))
		{
			bossBuddyNPC.setHealthRatio(monsterHpRatio);
			bossBuddyNPC.setCurrentHp(monsterHp);
			bossBuddyNPC.setCurrentLocation(npc.getWorldLocation());
			bossBuddyNPC.setDead(false);

			WorldPoint currentLocation = bossBuddyNPC.getCurrentLocation();

			if (locationCount.containsKey(currentLocation))
			{
				bossBuddyNPC.setOffset(locationCount.get(currentLocation) - 1);
				locationCount.put(currentLocation, locationCount.get(currentLocation) - 1);
			}
		}
		else if (npc.isDead())
		{
			bossBuddyNPC.setHealthRatio(0);
			bossBuddyNPC.setDead(true);
		}

		npcLocations.put(bossBuddyNPC.getNpcIndex(), bossBuddyNPC.getCurrentLocation());
	}

	private void checkRates(BossDropItem item, NPCComposition npc)
	{
		int npcId = npc.getId();
		String npcName = npc.getName();

		if (NPC_DISAMBIGUATION_MAP.containsKey(npcName))
		{
			Collection<String> npcMap = NPC_DISAMBIGUATION_MAP.get(npcName);
			npcName = npcMap.stream().findFirst().orElse("None");
			npcId = -1;
		}

		if (!loadedWikiItems.isEmpty() && loadedWikiItems.containsKey(npcId))
		{
			log.debug("Drop table already loaded");
		}
		else
		{
			int finalNpcId = npcId;
			WikiScraper.getWikiItemsByMonster(okHttpClient, npcName, npcId).whenCompleteAsync((wikiItems, ex) -> {
				DecimalFormat df = new DecimalFormat("#.####");
				df.setRoundingMode(RoundingMode.CEILING);

				loadedWikiItems.put(finalNpcId, wikiItems);
			});
		}

		WikiItem[] wikiItems = loadedWikiItems.get(npcId);
		if (wikiItems == null)
			return;

		Map<String, Integer> commonDrops = new HashMap<>();

		for(WikiItem wItem: wikiItems)
		{
			String dropItemName = item.getName();
			int dropItemQuant = item.getQuantity();

			if (commonDrops.containsKey(dropItemName) && commonDrops.get(dropItemName) == dropItemQuant)
			{
				log.info("Most likely rare drop that is under report rate");
				continue;
			}

			WikiItem wikiItem = null;
			if(Objects.equals(wItem.getName(), dropItemName) && wItem.quantityMatch(dropItemQuant))
				wikiItem = wItem;

			if (wikiItem != null)
			{
				String itemRarity = wikiItem.getRarityLabelText(false);
				if (Objects.equals(itemRarity, "Always") || Objects.equals(wikiItem.getName(), "Coins"))
				{
					continue;
				}

				if (itemRarity.contains(";"))
				{
					itemRarity = Arrays.stream(itemRarity.split(";")).findFirst().get();
				}

				BossDropFraction itemRarityFraction = BossDropFraction.parseFraction(itemRarity);
				BossDropFraction rarityLimitFraction = BossDropFraction.parseFraction(config.dropRarityLimit());
				int fractionCompare = itemRarityFraction.compareTo(rarityLimitFraction);

				if (fractionCompare > 0)
				{
					commonDrops.put(dropItemName, dropItemQuant);
					continue;
				}

				SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
				String formattedDate = sdf.format(new Date());

				String chatMessageString = String.format("Item: %s - Rarity: %s", item.getName(), itemRarity);
				if (config.displayDate())
				{
					chatMessageString = String.format("%s - Date: %s", chatMessageString, formattedDate);
				}

				String chatMessage = new ChatMessageBuilder()
					.append(ChatColorType.HIGHLIGHT)
					.append(chatMessageString)
					.build();

				chatMessageManager.queue(
					QueuedMessage.builder()
						.type(ChatMessageType.CONSOLE)
						.runeLiteFormattedMessage(chatMessage)
						.build());
				break;
			}
		}
	}

	@Subscribe
	public void onServerNpcLoot(final ServerNpcLoot event)
	{
		final NPCComposition npc = event.getComposition();
		final Collection<ItemStack> items = event.getItems();
		String name = npc.getName();

		if (NPC_DISAMBIGUATION_MAP.containsKey(name))
		{
			Collection<String> npcMap = NPC_DISAMBIGUATION_MAP.get(name);
			name = npcMap.stream().findFirst().orElse("None");
		}

		int killCount = getKc(name);
		addLoot(npc, items, killCount);
	}

	private int getKc(String npcName)
	{
		Integer killCount = configManager.getRSProfileConfiguration("killcount", npcName.toLowerCase(), int.class);
		if (killCount == null)
		{
			String bossBuddyJson = configManager.getConfiguration(BossBuddyConfig.GROUP, profileKey, "BOSS_BUDDY_NPC_" + npcName.toUpperCase());
			String lootTrackerJson = configManager.getConfiguration(BossBuddyConfig.LOOT_TRACKER_GROUP, profileKey, "drops_NPC_" + npcName);

			if (bossBuddyJson == null && lootTrackerJson != null)
			{
				ConfigLoot savedConfig = gson.fromJson(lootTrackerJson, ConfigLoot.class);
				killCount = savedConfig.kills;
			}
			else if (bossBuddyJson != null && lootTrackerJson != null)
			{
				ConfigLoot bbConfig = gson.fromJson(bossBuddyJson, ConfigLoot.class);
				ConfigLoot ltConfig = gson.fromJson(lootTrackerJson, ConfigLoot.class);

				if (ltConfig.kills > bbConfig.kills)
				{
					bbConfig.kills = ltConfig.kills;
				}
				killCount = bbConfig.kills;

			}
			else if (bossBuddyJson != null)
			{
				ConfigLoot savedConfig = gson.fromJson(bossBuddyJson, ConfigLoot.class);
				killCount = savedConfig.kills;
			}
			else
			{
				killCount = 0;
			}
		}
		return killCount + 1;
	}

	void addLoot(NPCComposition npc, Collection<ItemStack> items, int killCount)
	{
		int intdate = Integer.parseInt(formatter.format(Instant.now()));
		final BossDropItem[] entries = buildEntries(stack(items), killCount, intdate);
		for (BossDropItem bdi : entries)
		{
			if (Objects.equals(bdi.getName(), "Dwarf remains") || Arrays.stream(config.ignoreItems().split(",")).anyMatch(k -> k.equals(bdi.getName())))
			{
				continue;
			}

			checkRates(bdi, npc);
			ConfigLoot lootConfig = getLootConfig(npc.getName());
			if (lootConfig == null)
			{
				lootConfig = new ConfigLoot(npc.getName());
			}

			lootConfig.kills = killCount;

			if (bdi.getGePrice() * bdi.getQuantity() >= config.trackBossDropValue() || !bdi.isTradeable())
			{
				lootConfig.lastDropKC = bdi.getKillCount();
				lootConfig.lastDrop = bdi.getName();
				lootConfig.add(bdi.getId(), bdi.getKillCount(), bdi.getGePrice() * bdi.getQuantity(), bdi.getDate());
				lootConfig.last = Instant.now();
			}

			setLootConfig(lootConfig.name, lootConfig);
			buildPanelItems(lootConfig);
		}
	}

	private BossDropItem[] buildEntries(final Collection<ItemStack> itemStacks, int killCount, int date)
	{
		return itemStacks.stream()
			.map(itemStack -> buildBossDropItem(itemStack.getId(), itemStack.getQuantity(), killCount, -1, date))
			.toArray(BossDropItem[]::new);
	}

	@Subscribe
	public void onNpcSpawned(NpcSpawned npcSpawned)
	{
		final NPC npc = npcSpawned.getNpc();
		final String npcName = npc.getName();

		if (npcName == null)
		{
			return;
		}
		if (npc.getCombatLevel() <= 0)
		{
			return;
		}

		BossBuddyNPC previousNPC = bossBuddyNPCs.get(npc.getIndex());
		BossBuddyNPC bossBuddyNPC = new BossBuddyNPC(npc);

		if (previousNPC != null)
		{
			bossBuddyNPC.setDiedOnTick(previousNPC.getDiedOnTick());
		}

		bossBuddyNPC.setDead(false);
		spawnedNpcsThisTick.add(npc);
		bossBuddyNPCs.put(npc.getIndex(), bossBuddyNPC);
		npcLocations.put(npc.getIndex(), npc.getWorldLocation());
	}

	@Subscribe
	public void onNpcDespawned(NpcDespawned npcDespawned)
	{
		NPC npc = npcDespawned.getNpc();
		if (npc == null)
		{
			return;
		}
		Actor actor = npcDespawned.getActor();

		if (bossBuddyNPCs.containsKey(npc.getIndex()))
		{
			createTimer(npc);
		}

		npcLocations.remove(npc.getIndex());
	}

	@Subscribe
	public void onNpcChanged(NpcChanged e)
	{
		final NPC npc = e.getNpc();
		int id = npc.getId();
		int idx = npc.getIndex();

		if (id == DUKE_SUCELLUS_DEAD || id == DUKE_SUCELLUS_DEAD_QUEST)
		{
			bossBuddyNPCs.remove(idx);
			npcLocations.remove(idx);
		}

		if (id == 412)
		{
			return;
		}

		BossBuddyNPC previousNPC = bossBuddyNPCs.get(npc.getIndex());
		BossBuddyNPC bossBuddyNPC = new BossBuddyNPC(npc);

		if (previousNPC != null)
		{
			bossBuddyNPC.setDiedOnTick(previousNPC.getDiedOnTick());
		}

		bossBuddyNPCs.put(idx, bossBuddyNPC);
		npcLocations.put(idx, npc.getWorldLocation());
	}

	private void createTimer(NPC npc)
	{
		RespawnTimer timer = null;
		BossBuddyNPC bossBuddyNPC = bossBuddyNPCs.get(npc.getIndex());
		bossBuddyNPC.setDead(true);
		despawnedNpcsThisTick.add(npc);
		clearTimer(bossBuddyNPC);

		if (Boss.isNpcBoss(npc) && config.bossRespawnTimer())
		{
			Boss boss = Boss.find(npc.getId());
			if (boss != null && !boss.isIgnoreAlarm())
			{
				//log.info("Creating boss spawn timer for {} ({})", bossBuddyNPC.getNpcName(), boss.getSpawnTime());
				timer = new RespawnTimer(bossBuddyNPC, boss, itemManager.getImage(boss.getItemSpriteId()), this);

			}
		}
		else
		{
			if (bossBuddyNPC.getRespawnTime() > -1 && config.npcRespawnTimer())
			{
				//log.info("Creating spawn timer for {} ({})", npc.getName(), bossBuddyNPC.getRespawnTime());
				timer = new RespawnTimer(bossBuddyNPC, itemManager.getImage(ItemID.SKULL), this);
				timer.setTooltip(npc.getName());
			}
		}

		if (timer != null)
		{
			timer.setTooltip(bossBuddyNPC.getNpcName());
			infoBoxManager.addInfoBox(timer);
			createRespawnNotification(timer, bossBuddyNPC.getNpcName(), Boss.isNpcBoss(npc));
		}
	}

	private void clearTimer(BossBuddyNPC bossBuddyNPC)
	{
		infoBoxManager.removeIf(t -> t instanceof RespawnTimer && ((RespawnTimer) t).getBossBuddyNPC() == bossBuddyNPC);
	}

	private void createRespawnNotification(RespawnTimer timer, String npcName, boolean isBoss)
	{
		RespawnNotification respawnNotification = new RespawnNotification(npcName, notifier);
		boolean createNotification = isBoss && config.bossRespawnNotification();

		if (!isBoss && config.npcRespawnNotification())
		{
			createNotification = true;
		}

		if (createNotification)
		{
			Timer t = new java.util.Timer();
			t.schedule(
				new java.util.TimerTask()
				{
					@Override
					public void run()
					{
						try
						{
							respawnNotification.call();
						}
						catch (Exception e)
						{
							throw new RuntimeException(e);
						}
						t.cancel();
					}
				},
				timer.getDuration().minusSeconds(5).toMillis()
			);
		}
	}

	private void validateSpawnedNpcs()
	{
		if (skipNextSpawnCheck)
		{
			skipNextSpawnCheck = false;
		}
		else
		{
			for (NPC npc : despawnedNpcsThisTick)
			{
				if (isInViewRange(client.getLocalPlayer().getWorldLocation(), npc.getWorldLocation()))
				{
					BossBuddyNPC mn = bossBuddyNPCs.get(npc.getIndex());

					if (mn != null)
					{
						int tickDied = client.getTickCount() + 1;
						mn.setDiedOnTick(tickDied); // This runs before tickCounter updates, so we add 1
					}
				}
			}

			for (NPC npc : spawnedNpcsThisTick)
			{
				if (lastPlayerLocation != null && isInViewRange(lastPlayerLocation, npc.getWorldLocation()))
				{
					BossBuddyNPC mn = bossBuddyNPCs.get(npc.getIndex());

					if (mn.getDiedOnTick() != -1)
					{
						final int respawnTime = client.getTickCount() + 1 - mn.getDiedOnTick();

						if ((mn.getRespawnTime() == -1 || respawnTime < mn.getRespawnTime()) && respawnTime <= MAX_RESPAWN_TIME_TICKS)
						{
							mn.setRespawnTime(respawnTime);
						}

						mn.setDiedOnTick(-1);
					}

					final WorldPoint npcLocation = npc.getWorldLocation();
					final WorldPoint possibleOtherNpcLocation = getWorldLocationBehind(npc);

					mn.getPossibleRespawnLocations().removeIf(x ->
						!x.equals(npcLocation) && !x.equals(possibleOtherNpcLocation));

					if (mn.getPossibleRespawnLocations().isEmpty())
					{
						mn.getPossibleRespawnLocations().add(npcLocation);
					}
				}
			}
		}

		spawnedNpcsThisTick.clear();
		despawnedNpcsThisTick.clear();
	}

	private static boolean isInViewRange(WorldPoint wp1, WorldPoint wp2)
	{
		int distance = wp1.distanceTo(wp2);
		return distance < MAX_ACTOR_VIEW_RANGE;
	}

	private static WorldPoint getWorldLocationBehind(NPC npc)
	{
		final int orientation = npc.getOrientation() / 256;
		int dx = 0, dy = 0;

		switch (orientation)
		{
			case 0: // South
				dy = -1;
				break;
			case 1: // Southwest
				dx = -1;
				dy = -1;
				break;
			case 2: // West
				dx = -1;
				break;
			case 3: // Northwest
				dx = -1;
				dy = 1;
				break;
			case 4: // North
				dy = 1;
				break;
			case 5: // Northeast
				dx = 1;
				dy = 1;
				break;
			case 6: // East
				dx = 1;
				break;
			case 7: // Southeast
				dx = 1;
				dy = -1;
				break;
		}

		final WorldPoint currWP = npc.getWorldLocation();
		return new WorldPoint(currWP.getX() - dx, currWP.getY() - dy, currWP.getPlane());
	}

	public void removeLoot(String monsterName, int indexToRemove)
	{
		ConfigLoot lootConfig = getLootConfig(monsterName);
		int[] newArray = new int[lootConfig.getDrops().length - 4];
		int newArrayIndex = 0;
		for (int i = 0; i < lootConfig.getDrops().length; i++)
		{
			if (i != indexToRemove && i != indexToRemove + 1 && i != indexToRemove + 2 && i != indexToRemove + 3)
			{
				newArray[newArrayIndex++] = lootConfig.getDrops()[i];
			}
		}
		lootConfig.setDrops(newArray);
		setLootConfig(lootConfig.getName(), lootConfig);
		buildPanelItems(lootConfig);

	}

	public void removeLoot(String monsterName, int indexToRemove, boolean removeAll)
	{
		ConfigLoot lootConfig = getLootConfig(monsterName);
		int[] newArray = new int[lootConfig.getDrops().length - 3];
		int newArrayIndex = 0;
		for (int i = 0; i < lootConfig.getDrops().length; i++)
		{
			if (!removeAll)
			{
				if (i != indexToRemove && i != indexToRemove + 1 && i != indexToRemove + 2)
				{
					newArray[newArrayIndex++] = lootConfig.getDrops()[i];
				}
			}
		}
		lootConfig.setDrops(newArray);
		setLootConfig(lootConfig.getName(), lootConfig);
		buildPanelItems(lootConfig);

	}

	@Subscribe
	public void onConfigChanged(ConfigChanged configChanged)
	{
		if (Objects.equals(configChanged.getGroup(), "MonsterHP") && (Objects.equals(configChanged.getKey(), "npcShowAll") || Objects.equals(configChanged.getKey(), "npcShowAllBlacklist") || Objects.equals(configChanged.getKey(), "npcToShowHp") || Objects.equals(configChanged.getKey(), "npcIdToShowHp")))
		{
			clientThread.invokeLater(this::rebuildAllNpcs);
		}
	}

	private void rebuildAllNpcs()
	{
		bossBuddyNPCs.clear();

		if (client.getGameState() != GameState.LOGGED_IN &&
			client.getGameState() != GameState.LOADING)
		{
			return;
		}

		for (NPC npc : client.getTopLevelWorldView().npcs())
		{
				BossBuddyNPC bossBuddyNPC = new BossBuddyNPC(npc);

				bossBuddyNPCs.put(npc.getIndex(), bossBuddyNPC);
				npcLocations.put(npc.getIndex(), npc.getWorldLocation());
		}
	}
}

package com.bossbuddy.gearhelper;

import com.bossbuddy.BossBuddyConfig;
import com.google.common.collect.ImmutableSet;
import java.awt.Dimension;
import java.awt.Graphics2D;
import java.util.HashMap;
import java.util.Map;
import static java.util.Map.entry;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.gameval.InterfaceID;
import net.runelite.api.gameval.VarPlayerID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.game.ItemManager;
import net.runelite.client.game.ItemVariationMapping;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ImageComponent;
import net.runelite.client.ui.overlay.components.ComponentOrientation;
import javax.inject.Inject;
import java.awt.Point;
import java.awt.image.BufferedImage;
import java.util.Set;

@Slf4j
public class EquipmentOverlay extends OverlayPanel
{
	private static final int PLACEHOLDER_WIDTH_150_PERCENT = 57;
	private static final int PLACEHOLDER_HEIGHT = 32;
	private final ItemManager itemManager;
	private final Client client;
	private final BossBuddyConfig bossBuddyConfig;

	private static final Set<Integer> DIZANAS_QUIVER_IDS = ImmutableSet.<Integer>builder()
		.addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(28951)))
		.addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(28955)))
		.addAll(ItemVariationMapping.getVariations(ItemVariationMapping.map(28902)))
		.build();

	@Inject
	private EquipmentOverlay(Client client, ItemManager itemManager, BossBuddyConfig bossBuddyConfig)
	{
		setPosition(OverlayPosition.BOTTOM_RIGHT);

		panelComponent.setWrap(true);
		panelComponent.setGap(new Point(6, 4));
		panelComponent.setPreferredSize(new Dimension(3 * (Constants.ITEM_SPRITE_WIDTH), 5 * (Constants.ITEM_SPRITE_HEIGHT)));
		panelComponent.setOrientation(ComponentOrientation.HORIZONTAL);

		this.itemManager = itemManager;
		this.client = client;
		this.bossBuddyConfig = bossBuddyConfig;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		if (!this.bossBuddyConfig.wornItems())
		{
			return null;
		}

		Widget bankContainer = client.getWidget(InterfaceID.Bankmain.ITEMS);

		if (bankContainer == null || bankContainer.isSelfHidden())
		{
			return null;
		}

		Map<Integer, Item> equippedItems = new HashMap<>();
		int slot = 0;
		ItemContainer itemContainer = client.getItemContainer(94);
		if (itemContainer != null)
		{
			Item[] containerItems = itemContainer.getItems();
			for (Item it : containerItems)
			{
				Item slotItem = new Item(it.getId(), it.getQuantity());
				equippedItems.put(slot, slotItem);
				slot++;
			}

			final Item cape = itemContainer.getItem(1);
			var isWearingQuiver = cape != null && DIZANAS_QUIVER_IDS.contains(cape.getId());

			if (isWearingQuiver)
			{
				final int quiverAmmoId = client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO);
				final int quiverAmmoCount = client.getVarpValue(VarPlayerID.DIZANAS_QUIVER_TEMP_AMMO_AMOUNT);
				final Item quiverAmmo = new Item(quiverAmmoId, quiverAmmoCount);
				equippedItems.put(11, quiverAmmo);
			}
		}

		panelComponent.getChildren().clear();
		buildInventoryOverlay(equippedItems);
		return panelComponent.render(graphics);
	}

	private void buildInventoryOverlay(Map<Integer, Item> equippedItems)
	{
		Map<Integer, Integer> equipmentMap = Map.ofEntries(
			entry(14, 0), //NULL
			entry(0, 1), //Head
			entry(6, 2), //NULL
			entry(1, 3), //Cape
			entry(2, 4), //Amulet
			entry(13, 5), //Ammo
			entry(3, 6), //Weapon
			entry(4, 7), //Body
			entry(5, 8), //Shield
			entry(8, 9), //NULL
			entry(7, 10), //Legs
			entry(11, 11), //Quiver Ammo
			entry(9, 12), //Gloves
			entry(10, 13), //Boots
			entry(12, 14) //Ring
		);

		for (int i = 0; i < equipmentMap.size(); i++)
		{
			panelComponent.getChildren().add(new ImageComponent(new BufferedImage(36, PLACEHOLDER_HEIGHT, BufferedImage.TYPE_4BYTE_ABGR)));
		}

		for (Map.Entry<Integer, Item> itemMap : equippedItems.entrySet())
		{
			Integer itemSlot = itemMap.getKey();
			Item item = itemMap.getValue();
			if (!equipmentMap.containsKey(itemSlot))
			{
				panelComponent.getChildren().add(new ImageComponent(new BufferedImage(PLACEHOLDER_WIDTH_150_PERCENT, PLACEHOLDER_HEIGHT, BufferedImage.TYPE_4BYTE_ABGR)));
			}
			else
			{
				if (item != null && item.getId() != -1 && item.getQuantity() > 0)
				{
					final BufferedImage image = getImage(item);
					if (image != null)
					{
						panelComponent.getChildren().set(equipmentMap.get(itemSlot), new ImageComponent(image));
					}
				}
			}
		}
	}


	private BufferedImage getImage(Item item)
	{
		return itemManager.getImage(item.getId(), item.getQuantity(), item.getQuantity() > 1);
	}
}

package com.bossbuddy;

import java.time.Instant;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import net.runelite.http.api.loottracker.LootRecordType;

@Data
@NoArgsConstructor
@EqualsAndHashCode(of = {"type", "name"})
public class ConfigLoot
{
	LootRecordType type;
	String name;
	int kills;
	Instant first = Instant.now();
	Instant last;
	String lastDrop;
	int lastDropKC;
	int gePrice;
	int[] drops;

	ConfigLoot(String name)
	{
		this.type = LootRecordType.NPC;
		this.name = name;
		this.drops = new int[0];
	}

	void add(int id, int killCount, int gePrice, int date)
	{
		int[] newDrops = new int[drops.length + 4];

		for (int i = 0; i < drops.length + 4; i += 4)
		{
			if (i == 0)
			{
				newDrops[0] = id;
				newDrops[1] = killCount;
				newDrops[2] = gePrice;
				newDrops[3] = date;
			}
			else
			{
				newDrops[i] = drops[i - 4];
				newDrops[i + 1] = drops[i - 3];
				newDrops[i + 2] = drops[i - 2];
				newDrops[i + 3] = drops[i - 1];
			}
		}
		drops = newDrops;
	}

	public int numDrops()
	{
		return drops.length / 4;
	}
}
package com.bossbuddy.views;


import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.loot.BossDropItem;
import com.bossbuddy.loot.BossDropRecord;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.util.ArrayList;
import javax.swing.border.EmptyBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import javax.swing.*;
import java.util.List;

@Slf4j
public class TableBox extends JPanel
{
	private final BossBuddyConfig config;
	private final TableResultsPanel tableResultsPanel;

	private final BossDropRecord bossDropRecord;
	public BossDropItem[] items;
	private final String fullHeaderStr;
	private String headerStr;

	private final JPanel listViewContainer = new JPanel();
	private final JPanel headerContainer = new JPanel();
	private final JPanel leftHeader = new JPanel();
	private final Color HEADER_BG_COLOR = ColorScheme.DARKER_GRAY_COLOR.darker();
	private final List<BossDropItemPanel> itemPanels = new ArrayList<>();

	public TableBox(TableResultsPanel tableResultsPanel, BossBuddyConfig config, BossDropRecord bossDropRecord, String headerStr)
	{
		this.tableResultsPanel = tableResultsPanel;
		this.config = config;
		this.bossDropRecord = bossDropRecord;
		this.items = bossDropRecord.getItems();
		this.fullHeaderStr = headerStr;
		this.headerStr = headerStr;

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		buildHeader();
		buildItemsContainer();
	}

	void removeRecord(int itemIndex)
	{
		tableResultsPanel.removeRecord(itemIndex);
	}

	void buildHeader()
	{
		buildLeftHeader();
		buildHeaderContainer();
	}


	void buildLeftHeader()
	{
		int maxHeaderLength = 18;
		if (headerStr.length() > maxHeaderLength)
		{
			headerStr = headerStr.substring(0, maxHeaderLength) + "…"; // Manually truncate the header
		}

		JLabel headerLabel = new JLabel(headerStr);
		headerLabel.setFont(FontManager.getRunescapeBoldFont());
		headerLabel.setForeground(ColorScheme.BRAND_ORANGE);
		headerLabel.setMinimumSize(new Dimension(1, headerLabel.getPreferredSize().height));

		JLabel headerKillLabel = new JLabel("x " + bossDropRecord.getKills());
		headerKillLabel.setFont(FontManager.getRunescapeSmallFont());
		headerKillLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		JLabel headerPriceLabel = new JLabel(bossDropRecord.GEPriceTotalFormatted());
		headerPriceLabel.setFont(FontManager.getRunescapeSmallFont());
		headerPriceLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);

		leftHeader.setLayout(new BoxLayout(leftHeader, BoxLayout.X_AXIS));
		leftHeader.setBackground(HEADER_BG_COLOR);
		leftHeader.setBorder(new EmptyBorder(7, 7, 7, 7));

		leftHeader.add(Box.createRigidArea(new Dimension(10, 0)));
		leftHeader.add(headerLabel);

		leftHeader.add(Box.createRigidArea(new Dimension(5, 0)));
		leftHeader.add(headerKillLabel);
		leftHeader.add(Box.createHorizontalGlue());
		leftHeader.add(Box.createRigidArea(new Dimension(5, 0)));

		leftHeader.add(headerPriceLabel);

	}

	void buildHeaderContainer()
	{
		headerContainer.setLayout(new BorderLayout());
		headerContainer.setBackground(HEADER_BG_COLOR);
		headerContainer.setPreferredSize(new Dimension(0, 30));

		if (headerStr.endsWith("…"))
		{
			// If header is truncated, show the full text on hover
			headerContainer.setToolTipText(fullHeaderStr + " - " + bossDropRecord.GEPriceTotalFormatted());
		}

		headerContainer.add(leftHeader, BorderLayout.NORTH);
		add(headerContainer);

	}

	void buildItemsContainer()
	{

		int i = 0;
		for (BossDropItem item : items)
		{
			if (item != null)
			{
				try
				{
					BossDropItemPanel itemPanel = new BossDropItemPanel(this, item, config, i, i > 0);
					itemPanels.add(itemPanel);
					listViewContainer.add(itemPanel);
				}
				catch (Exception ex)
				{
					log.info(ex.getMessage());
				}
			}
			i++;
		}

		listViewContainer.setLayout(new BoxLayout(listViewContainer, BoxLayout.Y_AXIS));
		add(listViewContainer);
	}
}
package com.bossbuddy.views;

import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.loot.BossDropItem;
import com.bossbuddy.loot.BossDropRecord;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import net.runelite.client.ui.ColorScheme;
import javax.swing.border.MatteBorder;
import java.util.List;

public class TableResultsPanel extends JPanel
{
	private final BossBuddyConfig config;
	private final BossDropItem[] bossDropItems;
	private final BossDropRecord bossDropRecord;
	private final BossBuddyPanel bossBuddyPanel;

	private final List<TableBox> boxes = new ArrayList<>();
	private int selectedTabIndex;

	private final JPanel dropTableContent = new JPanel();

	public TableResultsPanel(BossBuddyPanel bossBuddyPanel, BossBuddyConfig config, BossDropRecord bossDropRecord)
	{
		this.config = config;
		this.bossBuddyPanel = bossBuddyPanel;
		this.bossDropRecord = bossDropRecord;
		this.bossDropItems = bossDropRecord.getItems();

		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		dropTableContent.setLayout(new BoxLayout(dropTableContent, BoxLayout.Y_AXIS));

		JScrollPane scrollPane = new JScrollPane(this);
		scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
		scrollPane.getVerticalScrollBar().setUnitIncrement(25);

		buildDropTableContent();
		add(dropTableContent);
	}

	void removeRecord(int itemIndex)
	{
		bossBuddyPanel.removeRecord(itemIndex);
	}

	void buildDropTableContent()
	{
		if (bossDropItems.length > 1)
		{
			dropTableContent.add(Box.createRigidArea(new Dimension(0, 5)));

			JPanel labelContainer = new JPanel(new BorderLayout());
			dropTableContent.add(labelContainer);

			dropTableContent.add(Box.createRigidArea(new Dimension(0, 5)));
			JPanel separator = new JPanel();
			separator.setPreferredSize(new Dimension(0, 6));
			separator.setBorder(new MatteBorder(1, 0, 0, 0, ColorScheme.DARKER_GRAY_COLOR));
			dropTableContent.add(separator);
		}

		String tableHeader = bossDropRecord.getBossName();

		TableBox tableBox = new TableBox(this, config, bossDropRecord, tableHeader);
		boxes.add(tableBox);

		dropTableContent.add(tableBox);
		dropTableContent.add(Box.createRigidArea(new Dimension(0, 5)));
	}
}
package com.bossbuddy.views;

import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.BossBuddyPlugin;
import com.bossbuddy.ConfigLoot;
import com.bossbuddy.loot.BossDropItem;
import com.bossbuddy.loot.BossDropRecord;
import com.bossbuddy.util.Constants;
import com.bossbuddy.util.Util;
import com.google.common.base.Strings;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.ui.components.PluginErrorPanel;
import net.runelite.client.util.SwingUtil;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

@Slf4j
public class BossBuddyPanel extends PluginPanel
{

	@Inject
	private Gson gson;
	private ConfigLoot configLoot = null;
	private final BossBuddyConfig config;
	private BossDropRecord bossDropRecord;
	private final IconTextField monsterSearchField = new IconTextField();
	private final JPanel mainPanel = new JPanel();
	private final PluginErrorPanel errorPanel = new PluginErrorPanel();
	private String panelMonsterName = "";
	public String profileKey = null;
	private ConfigManager configManager = null;
	private BossBuddyPlugin plugin = null;
	@Inject
	private ClientThread clientThread;

	public BossBuddyPanel(BossBuddyPlugin plugin, BossBuddyConfig config, ConfigManager configManager, Gson gson, ClientThread clientThread, String profileKey)
	{
		this.plugin = plugin;
		this.config = config;
		this.configManager = configManager;
		this.gson = gson;
		this.clientThread = clientThread;
		this.profileKey = profileKey;

		// Layout
		setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
		setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Main Panel

		mainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));
		mainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

		// Search Field

		buildSearchField();

		JButton removeLoot = new JButton();
		SwingUtil.removeButtonDecorations(removeLoot);
		removeLoot.setText("Remove All Drops");
		removeLoot.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		removeLoot.setUI(new BasicButtonUI());
		removeLoot.setToolTipText("Remove All Drops");
		removeLoot.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH, 30));
		removeLoot.setMinimumSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		Util.showHandCursorOnHover(removeLoot);

		removeLoot.addMouseListener(
			new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent evt)
				{
					removeAllLoot(monsterSearchField.getText());
				}
			});

		removeLoot.setLayout(new BorderLayout());

		// Error Panel - Empty State
		errorPanel.setContent(Constants.PLUGIN_NAME, "Enter a monster name.");

		add(monsterSearchField);

		add(mainPanel);
		add(errorPanel);
		// add(removeLoot);
	}

	void removeRecord(int itemIndex)
	{

		log.info(String.valueOf(itemIndex * 4));
		log.info(String.valueOf(configLoot.getDrops()[itemIndex * 4]));
		clientThread.invokeLater(() -> plugin.removeLoot(panelMonsterName, itemIndex * 4));

		//remove item from drops and reset loot config
		//plugin.removeRecord(itemIndex);
	}

	public void setLootConfig(String name, ConfigLoot loot)
	{
		String profile = profileKey;
		if (Strings.isNullOrEmpty(profile))
		{
			log.debug("Trying to set loot with no profile!");
			return;
		}

		String json = gson.toJson(loot);
		configManager.setConfiguration(BossBuddyConfig.GROUP, profile, "BOSS_BUDDY_NPC_" + name.toUpperCase(), json);
	}


	void rebuildMainPanel()
	{
		remove(errorPanel);
		SwingUtil.fastRemoveAll(mainPanel);

		TableResultsPanel tablePanel = new TableResultsPanel(this, config, bossDropRecord);

		mainPanel.add(tablePanel);
		mainPanel.revalidate();
		mainPanel.repaint();
	}

	void resetMainPanel()
	{
		SwingUtil.fastRemoveAll(mainPanel);
		mainPanel.revalidate();
		mainPanel.repaint();
		add(errorPanel);
	}

	void buildSearchField()
	{
		monsterSearchField.setIcon(IconTextField.Icon.SEARCH);
		monsterSearchField.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		monsterSearchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		monsterSearchField.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		monsterSearchField.setMinimumSize(new Dimension(0, 30));

		monsterSearchField.addActionListener(
			evt -> {
				searchForMonsterName(monsterSearchField.getText());
			});
		monsterSearchField.addMouseListener(
			new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent evt)
				{
					searchForMonsterName(monsterSearchField.getText());
				}
			});
		monsterSearchField.addClearListener(
			() -> {
				reset();
			});
	}

	void searchForMonsterName(String monsterName)
	{
		if (monsterName.isEmpty())
		{
			return;
		}

		monsterSearchField.setEditable(false);
		monsterSearchField.setIcon(IconTextField.Icon.LOADING_DARKER);
		configLoot = getLootConfig(monsterName);
		monsterSearchField.setIcon(configLoot == null ? IconTextField.Icon.ERROR : IconTextField.Icon.SEARCH);
		monsterSearchField.setEditable(true);

		if (configLoot == null)
		{
			return;
		}

		panelMonsterName = monsterName;
		clientThread.invokeLater(() -> plugin.buildPanelItems(configLoot));
	}

	public void refreshMainPanelWithRecords(String monsterName, BossDropItem[] bdi, int killCount)
	{
		configLoot = getLootConfig(monsterName);
		bossDropRecord = new BossDropRecord(monsterName, bdi, killCount);

		SwingUtilities.invokeLater(() -> {
			rebuildMainPanel();
		});
	}

	ConfigLoot getLootConfig(String name)
	{
		String profile = profileKey;
		if (Strings.isNullOrEmpty(profile))
		{
			log.debug("Trying to get loot with no profile!");
			return null;
		}

		String json = configManager.getConfiguration(BossBuddyConfig.GROUP, profile, "BOSS_BUDDY_NPC_" + name.toUpperCase());
		if (json == null)
		{
			return null;
		}

		return gson.fromJson(json, ConfigLoot.class);
	}

	void resetSearchField()
	{
		monsterSearchField.setIcon(IconTextField.Icon.SEARCH);
		monsterSearchField.setText("");
		monsterSearchField.setEditable(true);
	}

	public void reset()
	{
		SwingUtilities.invokeLater(() -> {
			resetSearchField();
			resetMainPanel();
		});
	}

	public void removeAllLoot(String monsterName)
	{
		ConfigLoot lootConfig = getLootConfig(monsterName);
		int[] newArray = new int[0];
		lootConfig.setDrops(newArray);
		setLootConfig(lootConfig.getName(), lootConfig);
	}
}
package com.bossbuddy.views;


import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.loot.BossDropItem;
import com.bossbuddy.osrswiki.WikiScraper;
import com.bossbuddy.util.Util;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.IconTextField;
import net.runelite.client.util.AsyncBufferedImage;
import net.runelite.client.util.SwingUtil;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.plaf.basic.BasicButtonUI;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.net.URL;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

@Slf4j
public class BossDropItemPanel extends JPanel
{
	private final TableBox tableBox;
	private final int itemIndex;
	private final BossDropItem item;
	private final AsyncBufferedImage image;
	private String itemName;
	private final Color bgColor = ColorScheme.DARKER_GRAY_COLOR;
	private final Color hoverColor = bgColor.brighter();
	private final JLabel rarityLabel = new JLabel();
	private final JLabel priceLabel = new JLabel();
	private final JLabel dateLabel = new JLabel();
	private final JPanel imageContainer = new JPanel(new BorderLayout());
	private final JPanel leftSidePanel = new JPanel(new GridLayout(2, 1));

	public BossDropItemPanel(TableBox tableBox, BossDropItem item, BossBuddyConfig config, int index, boolean showSeparator)
	{
		this.item = item;
		this.tableBox = tableBox;
		this.image = item.getImage();
		this.itemName = item.getName();
		this.itemIndex = index;

		int maxNameLength = 18;
		if (itemName.length() > maxNameLength)
		{
			itemName = itemName.replaceAll("\\(.*\\)", "").trim();

			if (itemName.length() > maxNameLength)
			{
				itemName = itemName.substring(0, maxNameLength) + "…";
			}
		}

		setBorder(new EmptyBorder(0, 0, 5, 0));
		setLayout(new BorderLayout());
		setBackground(bgColor);

		JPanel container = new JPanel(new BorderLayout());
		JPanel paddingContainer = new JPanel(new BorderLayout());
		int padding = 2;
		paddingContainer.setBorder(new EmptyBorder(padding, padding, padding, padding));

		if (showSeparator)
		{
			container.setBorder(BorderFactory.createMatteBorder(1, 0, 0, 0, ColorScheme.DARK_GRAY_COLOR));
		}
		paddingContainer.setBackground(bgColor);

		JPanel leftPanel = buildLeftPanel();
		JPanel rightPanel = buildRightPanel();
		rightPanel.setBackground(bgColor);

		paddingContainer.add(leftPanel, BorderLayout.WEST);
		paddingContainer.add(rightPanel, BorderLayout.EAST);

		container.add(paddingContainer);

		rarityLabel.setFont(FontManager.getRunescapeSmallFont());
		rarityLabel.setForeground(config.commonColor());

		priceLabel.setFont(FontManager.getRunescapeSmallFont());
		priceLabel.setForeground(config.priceColor());

		Util.showHandCursorOnHover(container);
		container.addMouseListener(new MouseAdapter()
		{
			@Override
			public void mouseClicked(MouseEvent evt)
			{
				String wikiUrl = WikiScraper.getWikiUrl(item.getName());
				try
				{
					Desktop.getDesktop().browse(new URL(wikiUrl).toURI());
				}
				catch (Exception ignored)
				{
				}
			}

			@Override
			public void mouseEntered(MouseEvent evt)
			{
				setBackground(hoverColor);
				paddingContainer.setBackground(hoverColor);
				leftSidePanel.setBackground(hoverColor);
				rightPanel.setBackground(hoverColor);
				imageContainer.setBackground(hoverColor);
			}

			@Override
			public void mouseExited(MouseEvent evt)
			{
				setBackground(bgColor);
				paddingContainer.setBackground(bgColor);
				leftSidePanel.setBackground(bgColor);
				rightPanel.setBackground(bgColor);
				imageContainer.setBackground(bgColor);
			}
		});

		if (itemName.endsWith("…"))
		{
			container.setToolTipText(item.getName());
		}

		add(container);
	}

	private JPanel buildImagePanel()
	{
		imageContainer.setSize(30, imageContainer.getHeight());
		JLabel imageLabel = new JLabel();
		imageLabel.setIcon(new ImageIcon(IconTextField.class.getResource(IconTextField.Icon.LOADING_DARKER.getFile()))); // set loading icon

		imageLabel.setIcon(new ImageIcon(image));
		imageContainer.setBorder(new EmptyBorder(0, 5, 0, Math.max(30 - image.getWidth(), 5)));

		imageLabel.setSize(35, imageLabel.getWidth());

		imageContainer.add(imageLabel, BorderLayout.WEST);
		imageContainer.setSize(30, imageContainer.getHeight());
		imageContainer.setBackground(bgColor);
		return imageContainer;
	}


	private JPanel buildLeftPanel()
	{
		JPanel container = new JPanel();
		container.setLayout(new BoxLayout(container, BoxLayout.X_AXIS));
		JPanel itemImage = buildImagePanel();

		leftSidePanel.setBorder(new EmptyBorder(2, 2, 2, 2));
		leftSidePanel.setBackground(bgColor);

		JLabel itemNameLabel = new JLabel(itemName);
		itemNameLabel.setBorder(new EmptyBorder(0, 0, 3, 0));
		itemNameLabel.setFont(FontManager.getRunescapeBoldFont());
		itemNameLabel.setHorizontalAlignment(JLabel.LEFT);
		itemNameLabel.setVerticalAlignment(JLabel.CENTER);

		rarityLabel.setHorizontalAlignment(JLabel.LEFT);
		rarityLabel.setVerticalAlignment(JLabel.CENTER);
		setRarityLabelText();

		leftSidePanel.add(itemNameLabel);
		leftSidePanel.add(rarityLabel);

		container.add(itemImage);
		container.add(leftSidePanel);
		return container;
	}

	private JPanel buildRightPanel()
	{
		JPanel rightSidePanel = new JPanel(new GridLayout(2, 1));

		JButton deleteBtn = new JButton();
		SwingUtil.removeButtonDecorations(deleteBtn);
		deleteBtn.setText("x");
		//deleteBtn.setForeground(ColorScheme.DARKER_GRAY_COLOR);
		deleteBtn.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		//deleteBtn.setBackground(ColorScheme.LIGHT_GRAY_COLOR);
		deleteBtn.setUI(new BasicButtonUI());
		deleteBtn.setToolTipText("Remove Record");
		deleteBtn.setPreferredSize(new Dimension(30, 10));
		Util.showHandCursorOnHover(deleteBtn);
		deleteBtn.addActionListener((evt) -> {
			tableBox.removeRecord(itemIndex);
		});
		deleteBtn.setLayout(new BorderLayout());

		dateLabel.setFont(FontManager.getRunescapeSmallFont());
		dateLabel.setBorder(new EmptyBorder(0, 0, 3, 2));
		dateLabel.setHorizontalAlignment(JLabel.RIGHT);
		dateLabel.setVerticalAlignment(JLabel.CENTER);

		setPriceLabelText();
		priceLabel.setVerticalAlignment(JLabel.CENTER);
		priceLabel.setHorizontalAlignment(JLabel.RIGHT);

		rightSidePanel.add(deleteBtn);
		rightSidePanel.add(priceLabel);

		return rightSidePanel;
	}

	void setRarityLabelText()
	{
		int kc = item.getKillCount();
		int dateInt = item.getDate();
		String dateString = String.valueOf(dateInt);
		DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyyMMdd");
		DateTimeFormatter stringFormatter = DateTimeFormatter.ofPattern("yyyy/MM/dd");
		LocalDate date = LocalDate.parse(dateString, dateFormatter);
		String formattedDate = stringFormatter.format(date);

		if (kc == 0)
		{
			rarityLabel.setText(formattedDate);
		}
		else
		{
			rarityLabel.setText(item.getKillCount() + " | " + formattedDate);
		}
	}

	void setPriceLabelText()
	{
		priceLabel.setText(item.getGEPriceFormatted());
	}

}
package com.bossbuddy;

import net.runelite.client.config.*;
import java.awt.*;
import static com.bossbuddy.util.Constants.*;

@SuppressWarnings("SameReturnValue")
@ConfigGroup("Boss Buddy")
public interface BossBuddyConfig extends Config
{
	String GROUP = "bossbuddy";
	String LOOT_TRACKER_GROUP = "loottracker";


	@ConfigItem(
		keyName = "coinSplit",
		name = "Coin Split",
		description = "Enable Coin menu option for splitting",
		position = 0
	)
	default boolean coinSplit()
	{
		return true;
	}

	@ConfigItem(
		keyName = "wornItems",
		name = "Worn items",
		description = "Enable display of worn items while banking",
		position = 0
	)
	default boolean wornItems()
	{
		return true;
	}


	@ConfigSection(
		name = "Loot Settings",
		description = "Settings relating to Loot",
		position = 1
	)
	String loot_settings = "loot_settings";

	@ConfigSection(
		name = "Notification Settings",
		description = "Settings relating to Notifications",
		position = 2
	)
	String notification_settings = "notification_settings";

	@ConfigSection(
		name = "HP Settings",
		description = "Settings relating to Monster HP",
		position = 3
	)
	String hp_settings = "hp_settings";

	@ConfigItem(
		keyName = "dropRarityLimit",
		name = "Drop Rarity",
		description = "Show rarity message for items greater than this",
		position = 0,
		section = loot_settings
	)
	default String dropRarityLimit()
	{
		return "1/128";
	}

	@ConfigItem(
		keyName = "trackBossDropValue",
		name = "Item Value",
		description = "Track kill count for items with GE value greater than this",
		position = 1,
		section = loot_settings
	)
	default int trackBossDropValue()
	{
		return 100000;
	}

	@ConfigItem(
		position = 2,
		keyName = "ignoreItems",
		name = "Ignore Items",
		description = "Items to ignore. Comma Separated.",
		section = loot_settings

	)
	default String ignoreItems()
	{
		return "";
	}

	@ConfigItem(
		position = 3,
		keyName = "displayDate",
		name = "Display Date",
		description = "Display date along side rarity message",
		section = loot_settings

	)
	default boolean displayDate()
	{
		return false;
	}


	@ConfigItem(
		keyName = "bossRespawnTimer",
		name = "Boss Respawn Timer",
		description = "Enable respawn notifications for bosses",
		position = 0,
		section = notification_settings
	)
	default boolean bossRespawnTimer()
	{
		return true;
	}

	@ConfigItem(
		keyName = "bossRespawnNotification",
		name = "Boss Respawn Notification",
		description = "Enable Boss respawn notification sound",
		position = 1,
		section = notification_settings
	)
	default boolean bossRespawnNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "npcRespawnTimer",
		name = "NPC Respawn Timer",
		description = "Enable respawn notifications for normal NPCs",
		position = 2,
		section = notification_settings
	)
	default boolean npcRespawnTimer()
	{
		return false;
	}

	@ConfigItem(
		keyName = "npcRespawnNotification",
		name = "NPC Respawn Notification",
		description = "Enable NPC respawn notification sound",
		position = 3,
		section = notification_settings
	)
	default boolean npcRespawnNotification()
	{
		return true;
	}

	@ConfigItem(
		keyName = "npcRespawnLocation",
		name = "NPC Respawn Location",
		description = "Enable NPC respawn location tile",
		position = 4,
		section = notification_settings
	)
	default boolean npcRespawnLocation()
	{
		return true;
	}

	@ConfigItem(
		position = 0,
		keyName = "showOverlay",
		name = "Show NPC HP overlay",
		description = "Turn on/off HP overlay",
		section = hp_settings
	)
	default boolean showOverlay()
	{
		return true;
	}

	@ConfigItem(
		position = 1,
		keyName = "aboveHP",
		name = "Display above HP",
		description = "Default position above enemy HP bar",
		section = hp_settings
	)
	default boolean aboveHP()
	{
		return false;
	}

	@Range(
		max = 200
	)
	@ConfigItem(
		position = 1,
		keyName = "overlayUp",
		name = "Move Up",
		description = "Change vertical placement of HP Overlay",
		section = hp_settings
	)
	default int overlayUp()
	{
		return 0;
	}

	@Range(
		max = 200
	)
	@ConfigItem(
		position = 2,
		keyName = "overlayDown",
		name = "Move Down",
		description = "Change vertical placement of HP Overlay",
		section = hp_settings
	)
	default int overlayDown()
	{
		return 0;
	}

	@Range(
		max = 200
	)
	@ConfigItem(
		position = 3,
		keyName = "overlayRight",
		name = "Move Right",
		description = "Change horizontal placement of HP Overlay",
		section = hp_settings
	)
	default int overlayRight()
	{
		return 0;
	}

	@Range(
		max = 200
	)
	@ConfigItem(
		position = 4,
		keyName = "overlayLeft",
		name = "Move Left",
		description = "Change horizontal placement of HP Overlay",
		section = hp_settings
	)
	default int overlayLeft()
	{
		return 0;
	}

	@ConfigItem(
		position = 5,
		keyName = "fontSize",
		name = "Overlay Size",
		description = "Size of the font to use for HP Overlay ",
		section = hp_settings
	)
	default int fontSize()
	{
		return 15;
	}

	@Range(
		max = 2
	)
	@ConfigItem(
		position = 6,
		keyName = "decimalHp",
		name = "Decimal Points ",
		description = "Show 0-2 decimals of precision.",
		section = hp_settings
	)
	default int decimalHp()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "hpPercentage",
		name = "HP Percentage",
		description = "Enable HP Percentage",
		position = 7,
		section = hp_settings
	)
	default boolean hpPercentage()
	{
		return false;
	}


	@ConfigItem(
		keyName = "hpValue",
		name = "HP Value",
		description = "Enable HP Value",
		position = 8,
		section = hp_settings
	)
	default boolean hpValue()
	{
		return false;
	}

	@ConfigItem(
		keyName = "stackOverlay",
		name = "Stack Value/Percent",
		description = "Stack the Value and Percentage overlays while both are displayed",
		position = 9,
		section = hp_settings
	)
	default boolean stackOverlay()
	{
		return false;
	}

	@ConfigItem(
		position = 10,
		keyName = "npcHideFull",
		name = "Hide Overlay when full HP",
		description = "Hide HP Overlay when full HP",
		section = hp_settings
	)
	default boolean npcHideFull()
	{
		return false;
	}

	default Color commonColor()
	{
		return DEFAULT_COMMON_COLOR;
	}

	default Color priceColor()
	{
		return DEFAULT_PRICE_COLOR;
	}


}

package com.bossbuddy.hp;

import javax.inject.Inject;
import com.bossbuddy.Boss;
import com.bossbuddy.BossBuddyConfig;
import com.bossbuddy.BossBuddyNPC;
import com.bossbuddy.BossBuddyPlugin;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.client.game.NPCManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import java.awt.*;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import static net.runelite.api.gameval.NpcID.*;
import static net.runelite.api.gameval.VarbitID.HPBAR_HUD_BASEHP;
import static net.runelite.api.gameval.VarbitID.HPBAR_HUD_HP;

@Slf4j
public class HPOverlay extends Overlay
{
	@Inject
	private Client client;

	private final BossBuddyPlugin bossBuddyPlugin;
	private final BossBuddyConfig bossBuddyConfig;
	private final NPCManager npcManager;

	protected String lastFont = "";
	protected int lastFontSize = 0;
	protected boolean useRunescapeFont = true;
	protected Font font = null;

	NumberFormat format = new DecimalFormat("#");
	NumberFormat oneDecimalFormat = new DecimalFormat("#.0");
	NumberFormat twoDecimalFormat = new DecimalFormat("#.00");

	@Inject
	HPOverlay(BossBuddyPlugin plugin, BossBuddyConfig config, NPCManager npcManager)
	{
		setPriority(0.75f);
		setPosition(OverlayPosition.DYNAMIC);
		setLayer(OverlayLayer.ABOVE_SCENE);
		this.bossBuddyPlugin = plugin;
		this.bossBuddyConfig = config;
		this.npcManager = npcManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		updateFont();
		graphics.setFont(font);
		graphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		if (bossBuddyConfig.showOverlay())
		{
			ArrayList<NPC> stackedNpcs = new ArrayList<>();
			bossBuddyPlugin.getBossBuddyNPCs().forEach((id, npc) -> renderTimer(npc, graphics, stackedNpcs));
		}
		return null;
	}

	private void renderTimer(final BossBuddyNPC bossBuddyNPC, final Graphics2D graphics, ArrayList<NPC> stackedNpcs)
	{
		if (bossBuddyNPC == null || bossBuddyNPC.isDead())
		{
			return;
		}

		NPC npc = bossBuddyNPC.getNpc();
		if (npc == null || npc.getName() == null)
		{
			return;
		}

		double wNpcHealthRatio = bossBuddyNPC.getHealthRatio();

		if (bossBuddyConfig.npcHideFull() && wNpcHealthRatio == 100)
		{
			return;
		}

		Integer maxHealth = npcManager.getHealth(npc.getId());

		if (Boss.isNpcBoss(npc))
		{
			Boss boss = Boss.find(npc.getId());
			if (boss.isIgnoreMaxHp())
			{
				maxHealth = client.getVarbitValue(HPBAR_HUD_BASEHP);

				if (npc.getId() == OLM_HEAD && isCoxOlmHandsAlive())
				{
					return;
				}
			}
			else if (boss.getMaxHp() != -1)
			{
				maxHealth = boss.getMaxHp();
			}
		}

		if (bossBuddyConfig.hpValue() || bossBuddyNPC.getIsTypeNumeric() == 1)
		{
			if (maxHealth != null && maxHealth != 0)
			{
				double numericHealth = (int) Math.floor((wNpcHealthRatio / 100) * maxHealth);
				bossBuddyNPC.setCurrentHp(numericHealth);
			}
		}

		Color timerColor = Color.GREEN;

		if (maxHealth != null && maxHealth > 1)
		{
			int curNumericHealth = (int) Math.floor((wNpcHealthRatio / 100) * maxHealth);
			timerColor = getGradientHpColor(curNumericHealth, maxHealth);
		}
		else
		{
			int curNumericHealth = (int) Math.floor(wNpcHealthRatio);
			timerColor = getGradientHpColor(curNumericHealth, 100);
		}

		String currentHPString = getCurrentHpString(bossBuddyNPC, true);
		if (maxHealth != null)
		{
			currentHPString += "/" + maxHealth;
		}
		String currentHPPercentString = getCurrentHpString(bossBuddyNPC, false);

		int offset = 0;
		NPC firstStack = null;
		for (NPC sNpc : stackedNpcs)
		{
			if (sNpc.getWorldLocation().getX() == npc.getWorldLocation().getX() && sNpc.getWorldLocation().getY() == npc.getWorldLocation().getY())
			{
				if (firstStack == null)
				{
					firstStack = npc;
				}
				offset += graphics.getFontMetrics().getHeight();
			}
		}

		int zOffset = 0;
		if (bossBuddyConfig.aboveHP())
		{
			zOffset += npc.getLogicalHeight();
		}
		Point textLocation = null;
		stackedNpcs.add(npc);
		if (firstStack != null && offset > 0)
		{
			textLocation = firstStack.getCanvasTextLocation(graphics, currentHPString, zOffset);
		}
		else
		{
			textLocation = npc.getCanvasTextLocation(graphics, currentHPString, zOffset);
		}
		if (textLocation != null)
		{
			Point stackOffset = new Point(textLocation.getX() + bossBuddyConfig.overlayRight() - bossBuddyConfig.overlayLeft(), (textLocation.getY() - bossBuddyConfig.overlayUp() + bossBuddyConfig.overlayDown()) - offset);

			if (bossBuddyConfig.hpValue() && !bossBuddyConfig.hpPercentage())
			{
				handleText(graphics, stackOffset, currentHPString, timerColor);
			}
			else if (!bossBuddyConfig.hpValue() && bossBuddyConfig.hpPercentage())
			{
				handleText(graphics, stackOffset, currentHPPercentString + "%", timerColor);
			}
			else if (bossBuddyConfig.hpValue() && bossBuddyConfig.hpPercentage())
			{
				if (bossBuddyConfig.stackOverlay())
				{
					handleText(graphics, stackOffset, "[ " + currentHPString + " ]", timerColor);
					stackOffset = new Point(textLocation.getX() + bossBuddyConfig.overlayRight() - bossBuddyConfig.overlayLeft(), (textLocation.getY() - bossBuddyConfig.overlayUp() + bossBuddyConfig.overlayDown() + graphics.getFontMetrics().getHeight()) - offset);
					handleText(graphics, stackOffset, currentHPPercentString + "%", timerColor);
				}
				else
				{
					handleText(graphics, stackOffset, "[ " + currentHPString + " ] " + currentHPPercentString + "%", timerColor);
				}
			}
		}
	}

	private boolean isCoxOlmHandsAlive()
	{
		for (BossBuddyNPC wnpc : bossBuddyPlugin.getBossBuddyNPCs().values())
		{
			NPC npc = wnpc.getNpc();
			if (npc == null)
			{
				continue;
			}

			int id = npc.getId();
			if ((id == OLM_HAND_RIGHT || id == OLM_HAND_LEFT) && !npc.isDead())
			{
				return true;
			}
		}

		return false;
	}

	private String getCurrentHpString(BossBuddyNPC bossBuddyNPC, boolean numeric)
	{
		NPC npc = bossBuddyNPC.getNpc();

		if (numeric)
		{
			String healthRatio = format.format(bossBuddyNPC.getHealthRatio());

			boolean usePercentage = bossBuddyNPC.getCurrentHp() == 100 && bossBuddyNPC.getHealthRatio() < 100.0;

			if (Boss.isNpcBoss(npc))
			{
				int curHp = client.getVarbitValue(HPBAR_HUD_HP);
				Boss boss = Boss.find(npc.getId());
				if(!boss.isIgnoreMaxHp())
				{
					curHp = (int) bossBuddyNPC.getCurrentHp();
				}
				return usePercentage ? healthRatio : String.valueOf(curHp);
			}

			return usePercentage ? healthRatio : String.valueOf((int) (bossBuddyNPC.getCurrentHp()));
		}

		switch (bossBuddyConfig.decimalHp())
		{
			case 1:
				return String.valueOf(oneDecimalFormat.format(bossBuddyNPC.getHealthRatio()));
			case 2:
				return String.valueOf(twoDecimalFormat.format(bossBuddyNPC.getHealthRatio()));
			default:
				return String.valueOf((bossBuddyNPC.getHealthRatio() >= 1) ? format.format(bossBuddyNPC.getHealthRatio()) : twoDecimalFormat.format(bossBuddyNPC.getHealthRatio()));
		}

	}

	private void handleText(Graphics2D graphics, Point textLoc, String text, Color color)
	{
		int offsetShadow = 1;

		graphics.setColor(new Color(0, 0, 0, color.getAlpha()));
		graphics.drawString(text, textLoc.getX() + offsetShadow, textLoc.getY() + offsetShadow);
		graphics.setColor(color);
		graphics.drawString(text, textLoc.getX(), textLoc.getY());
	}

	private void updateFont()
	{
		if (lastFontSize != bossBuddyConfig.fontSize())
		{
			lastFont = "roboto";
			lastFontSize = bossBuddyConfig.fontSize();
			int style = Font.PLAIN;
			font = new Font(lastFont, style, bossBuddyConfig.fontSize());
			useRunescapeFont = false;
		}
	}

	private Color getGradientHpColor(int currentHealth, int maxHealth)
	{
		currentHealth = Math.min(maxHealth, Math.max(0, currentHealth));

		double healthPercentage = (double) currentHealth / maxHealth;

		Color colorA = Color.GREEN;
		Color colorB = Color.RED;

		int red = (int) (colorB.getRed() + (colorA.getRed() - colorB.getRed()) * healthPercentage);
		int green = (int) (colorB.getGreen() + (colorA.getGreen() - colorB.getGreen()) * healthPercentage);
		int blue = (int) (colorB.getBlue() + (colorA.getBlue() - colorB.getBlue()) * healthPercentage);

		return new Color(red, green, blue);
	}
}

package com.bossbuddy;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import net.runelite.api.NPC;
import net.runelite.api.gameval.ItemID;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.util.RSTimeUnit;
import java.time.Duration;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalUnit;
import java.util.Map;

import static net.runelite.api.gameval.NpcID.*;

@Getter
public enum Boss
{
	GENERAL_GRAARDOR(NpcID.GODWARS_BANDOS_AVATAR, 90, ChronoUnit.SECONDS, ItemID.BANDOSPET),
	KRIL_TSUTSAROTH(NpcID.GODWARS_ZAMORAK_AVATAR, 90, ChronoUnit.SECONDS, ItemID.ZAMORAKPET),
	KREEARRA(NpcID.GODWARS_ARMADYL_AVATAR, 90, ChronoUnit.SECONDS, ItemID.ARMADYLPET),
	COMMANDER_ZILYANA(NpcID.GODWARS_SARADOMIN_AVATAR, 90, ChronoUnit.SECONDS, ItemID.SARADOMINPET),
	CALLISTO(NpcID.CALLISTO, 11, RSTimeUnit.GAME_TICKS, ItemID.CALLISTO_PET),
	ARTIO(NpcID.CALLISTO_SINGLES, 11, RSTimeUnit.GAME_TICKS, ItemID.CALLISTO_PET),
	CHAOS_ELEMENTAL(NpcID.CHAOSELEMENTAL, 14, RSTimeUnit.GAME_TICKS, ItemID.CHAOSELEPET),
	CHAOS_FANATIC(NpcID.CHAOS_FANATIC, 14, RSTimeUnit.GAME_TICKS, ItemID.STAFF_OF_ZAROS),
	CRAZY_ARCHAEOLOGIST(NpcID.CRAZY_ARCHAEOLOGIST, 9, ChronoUnit.SECONDS, ItemID.FEDORA),
	KING_BLACK_DRAGON(NpcID.KING_DRAGON, 9, ChronoUnit.SECONDS, ItemID.KBDPET, 240),
	SCORPIA(NpcID.SCORPIA, 14, RSTimeUnit.GAME_TICKS, ItemID.SCORPIA_PET),
	SCURRIUS(NpcID.RAT_BOSS_NORMAL, 29, RSTimeUnit.GAME_TICKS, ItemID.SCURRIUSPET),
	SCURRIUS_PRIVATE(NpcID.RAT_BOSS_INSTANCE, 29, RSTimeUnit.GAME_TICKS, ItemID.SCURRIUSPET),
	VENENATIS(NpcID.VENENATIS, 10, RSTimeUnit.GAME_TICKS, ItemID.VENENATIS_PET),
	SPINDEL(NpcID.VENENATIS_SINGLES, 9, RSTimeUnit.GAME_TICKS, ItemID.VENENATIS_PET),
	VETION(NpcID.VETION_2, 15, RSTimeUnit.GAME_TICKS, ItemID.VETION_PET),
	CALVARION(NpcID.VETION_2_SINGLE, 14, RSTimeUnit.GAME_TICKS, ItemID.VETION_PET),
	DAGANNOTH_PRIME(NpcID.DAGCAVE_MAGIC_BOSS, 90, ChronoUnit.SECONDS, ItemID.PRIMEPET),
	DAGANNOTH_REX(NpcID.DAGCAVE_MELEE_BOSS, 90, ChronoUnit.SECONDS, ItemID.REXPET),
	DAGANNOTH_SUPREME(NpcID.DAGCAVE_RANGED_BOSS, 90, ChronoUnit.SECONDS, ItemID.SUPREMEPET),
	CORPOREAL_BEAST(NpcID.CORP_BEAST, 30, ChronoUnit.SECONDS, ItemID.COREPET),
	GIANT_MOLE(NpcID.MOLE_GIANT, 9000, ChronoUnit.MILLIS, ItemID.MOLEPET, 200),
	DERANGED_ARCHAEOLOGIST(NpcID.FOSSIL_CRAZY_ARCHAEOLOGIST, 29400, ChronoUnit.MILLIS, ItemID.FOSSIL_LARGE_UNID),
	CERBERUS(NpcID.CERBERUS_ATTACKING, 8400, ChronoUnit.MILLIS, ItemID.HELL_PET),
	THERMONUCLEAR_SMOKE_DEVIL(NpcID.SMOKE_DEVIL_BOSS, 8400, ChronoUnit.MILLIS, ItemID.SMOKEPET),
	KRAKEN(NpcID.SLAYER_KRAKEN_BOSS, 8400, ChronoUnit.MILLIS, ItemID.KRAKENPET),
	KALPHITE_QUEEN(NpcID.KALPHITE_FLYINGQUEEN, 30, ChronoUnit.SECONDS, ItemID.KQPET_WALKING),
	DUSK(NpcID.GARGBOSS_DUSK_DEATH, 5, ChronoUnit.MINUTES, ItemID.DAWNPET, false, true, true,-1),
	ALCHEMICAL_HYDRA(NpcID.HYDRABOSS_FINALDEATH, 25200, ChronoUnit.MILLIS, ItemID.HYDRAPET),
	SARACHNIS(NpcID.SARACHNIS, 16, RSTimeUnit.GAME_TICKS, ItemID.SARACHNISPET),
	ZALCANO(NpcID.ZALCANO_WEAK, 21600, ChronoUnit.MILLIS, ItemID.ZALCANOPET),
	PHANTOM_MUSPAH(NpcID.MUSPAH_FINAL, 50, RSTimeUnit.GAME_TICKS, ItemID.MUSPAHPET),
	THE_LEVIATHAN(NpcID.LEVIATHAN, 30, RSTimeUnit.GAME_TICKS, ItemID.LEVIATHANPET),
	ARAXXOR(NpcID.ARAXXOR_DEAD, 15, RSTimeUnit.GAME_TICKS, ItemID.ARAXXORPET, true, false, false, 1020),
	ARAXXOR_ALIVE(NpcID.ARAXXOR, 15, RSTimeUnit.GAME_TICKS, ItemID.ARAXXORPET, true, true, false, 1020),
	AMOXLIATL(NpcID.AMOXLIATL, 28, RSTimeUnit.GAME_TICKS, ItemID.AMOXLIATLPET),
	HUEYCOATL(NpcID.HUEY_HEAD_DEFEATED, 50, RSTimeUnit.GAME_TICKS, ItemID.HUEYPET),
	YAMA(NpcID.YAMA,15,RSTimeUnit.GAME_TICKS, ItemID.YAMAPET, true,true,false,2500)
	;

	private static final Map<Integer, Boss> bosses;
	private final int id;
	private final Duration spawnTime;
	private final int itemSpriteId;
	private final boolean ignoreDead;
	private final boolean ignoreAlarm;
	private final boolean ignoreMaxHp;
	private final int maxHp;

	static
	{
		ImmutableMap.Builder<Integer, Boss> builder = new ImmutableMap.Builder<>();

		for (Boss boss : values())
		{
			builder.put(boss.getId(), boss);
		}

		bosses = builder.build();
	}

	Boss(int id, long period, TemporalUnit unit, int itemSpriteId)
	{
		this(id, period, unit, itemSpriteId, false, false, true, 0);
	}

	Boss(int id, long period, TemporalUnit unit, int itemSpriteId, int maxHp)
	{
		this(id, period, unit, itemSpriteId, false, false, false, maxHp);
	}

	Boss(int id, long period, TemporalUnit unit, int itemSpriteId, boolean ignoreDead, boolean ignoreAlarm, boolean ignoreMaxHp, int maxHp)
	{
		this.id = id;
		this.spawnTime = Duration.of(period, unit);
		this.itemSpriteId = itemSpriteId;
		this.ignoreDead = ignoreDead;
		this.ignoreAlarm = ignoreAlarm;
		this.ignoreMaxHp = ignoreMaxHp;
		this.maxHp = maxHp;
	}

	// Tombs of Amascut - String identification seems like the way to identify these bosses (with blacklist control)
	private static final ImmutableSet<String> TOA_BOSS_NAMES = ImmutableSet.of("Akkha", "Kephri", "Zebak", "Ba-Ba", "Tumeken's Warden", "Elidinis' Warden");

	// Chambers of Xeric - Some ids for cox that support varbits
	private static final ImmutableSet<Integer> COX_BOSS_IDS = ImmutableSet.of(
		// The Great Olm
		OLM_HEAD,
		// Tekton
		RAIDS_TEKTON_WAITING, RAIDS_TEKTON_WALKING_STANDARD, RAIDS_TEKTON_FIGHTING_STANDARD, RAIDS_TEKTON_WALKING_ENRAGED, RAIDS_TEKTON_FIGHTING_ENRAGED, RAIDS_TEKTON_HAMMERING,
		// Vespula
		RAIDS_VESPULA_FLYING, RAIDS_VESPULA_ENRAGED, RAIDS_VESPULA_WALKING, RAIDS_VESPULA_PORTAL,
		// Muttadile
		RAIDS_DOGODILE_SUBMERGED, RAIDS_DOGODILE_JUNIOR, RAIDS_DOGODILE,
		// Vasa
		RAIDS_VASANISTIRIO_WALKING, RAIDS_VASANISTIRIO_HEALING
	);

	// Desert Treasure 2
	private static final ImmutableSet<Integer> DT2_BOSS_IDS = ImmutableSet.of(
		LEVIATHAN,
		VARDORVIS, VARDORVIS_BASE_POSTQUEST,
		WHISPERER,
		DUKE_SUCELLUS_AWAKE, DUKE_SUCELLUS_ASLEEP
	);

	// Generic bosses - bosses that does not have a specific section
	private static final ImmutableSet<Integer> GEN_BOSS_IDS = ImmutableSet.of(
	);

	// Doom of Mokhaiotl
	public static final ImmutableSet<Integer> DOOM_BOSS_IDS = ImmutableSet.of(
		DOM_BOSS,
		DOM_BOSS_SHIELDED,
		DOM_BOSS_BURROWED
	);

	private static final ImmutableSet<Integer> ALL_BOSS_IDS =
		ImmutableSet.<Integer>builder()
			.addAll(GEN_BOSS_IDS)
			.addAll(COX_BOSS_IDS)
			.addAll(DT2_BOSS_IDS)
			.addAll(DOOM_BOSS_IDS)
			.build();

	public static boolean isNpcBossFromTOA(NPC npc)
	{
		int id = npc.getId();
		String name = npc.getName();
		boolean isWardenP1 = (id == TOA_WARDEN_TUMEKEN_PHASE1 || id == TOA_WARDEN_ELIDINIS_PHASE1);

		return name != null && TOA_BOSS_NAMES.contains(name) && !isWardenP1;
	}

	public static boolean isNpcBoss(NPC npc)
	{
		if (ALL_BOSS_IDS.contains(npc.getId()) || bosses.get(npc.getId()) != null)
		{
			return true;
		}
		// Only check TOA names if ID lookup fails
		return isNpcBossFromTOA(npc);
	}

	public static Boss find(int id)
	{
		return bosses.get(id);
	}
}
package com.bossbuddy.loot;

public class BossDropFraction implements Comparable<BossDropFraction>
{
	private final int numerator;
	private final int denominator;

	public BossDropFraction(int numerator, int denominator)
	{
		if (denominator == 0)
		{
			throw new IllegalArgumentException("Denominator cannot be zero.");
		}
		this.numerator = numerator;
		this.denominator = denominator;
	}


	public static BossDropFraction parseFraction(String s)
	{
		String[] parts = s.replace(",", "").split("/");
		if (parts.length == 2)
		{
			double num = Double.parseDouble(parts[0]);
			double den = Double.parseDouble(parts[1]);
			return new BossDropFraction((int) Math.round(num), (int) Math.round(den));
		}
		else if (parts.length == 1)
		{
			int num = Integer.parseInt(parts[0]);
			return new BossDropFraction(num, 1);
		}
		else
		{
			throw new IllegalArgumentException("Invalid fraction format: " + s);
		}
	}

	@Override
	public int compareTo(BossDropFraction other)
	{
		long val1 = (long) this.numerator * other.denominator;
		long val2 = (long) other.numerator * this.denominator;
		return Long.compare(val1, val2);
	}
}
package com.bossbuddy.loot;

import com.bossbuddy.util.Util;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import net.runelite.client.util.AsyncBufferedImage;

@AllArgsConstructor
@Getter
@EqualsAndHashCode
public class BossDropItem
{
	private final int id;
	private final String name;
	private final int quantity;
	private final int killCount;
	private final int date;
	private final int gePrice;
	private final boolean tradeable;
	private AsyncBufferedImage image;

	public String getGEPriceFormatted()
	{
		String priceLabelStr = gePrice > 0 ? Util.rsFormat(gePrice) : "";
		if (name.equals("Nothing"))
		{
			priceLabelStr = "";
		}
		return priceLabelStr;
	}
}



package com.bossbuddy.loot;

import com.bossbuddy.util.Util;
import lombok.NonNull;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Value
public class BossDropRecord
{
	@NonNull
	private final String bossName;
	private final BossDropItem[] items;
	private final int kills;

	public int GEPriceTotal()
	{
		int totalPrice = 0;
		for (BossDropItem item : items)
		{
			totalPrice += item.getGePrice();
		}
		return totalPrice;
	}

	public String GEPriceTotalFormatted()
	{

		return GEPriceTotal() > 0 ? Util.rsFormat(GEPriceTotal()) : "";
	}
}

package com.bossbuddy;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BossBuddyPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BossBuddyPlugin.class);
		RuneLite.main(args);
	}
}
