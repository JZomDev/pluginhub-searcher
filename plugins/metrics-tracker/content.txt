package com.metricstracker;

import net.runelite.client.config.*;

@ConfigGroup( "metricstracker" )
public interface MetricsTrackerConfig extends Config
{
    @ConfigItem(
            keyName = "monstersKilled",
            name = "NPC Kill Tracker",
            description = "Enable the npc kill metrics tracker",
            position = 1
    )
    default boolean monstersKilled() { return true; }

}

package com.metricstracker;

import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.MouseDragEventForwarder;
import net.runelite.client.ui.components.ProgressBar;
import net.runelite.client.util.ColorUtil;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.*;

public class MetricsInfoBox extends JPanel
{
	private static final String HTML_LABEL_TEMPLATE =
		"<html><body style='color:%s'>%s<span style='color:white'>%s</span></body></html>";

	private static final EmptyBorder DEFAULT_PROGRESS_WRAPPER_BORDER = new EmptyBorder( 0, 7, 7, 7 );
	private static final EmptyBorder COMPACT_PROGRESS_WRAPPER_BORDER = new EmptyBorder( 5, 1, 5, 5 );

	@Getter
	private final String name;
	private final JPanel container = new JPanel();
	private final JPanel headerPanel = new JPanel();
	private final JPanel statsPanel = new JPanel();
	private final JPanel progressWrapper = new JPanel();
	private final ProgressBar progressBar = new ProgressBar();
	private final JLabel topLeftStat = new JLabel();
	private final JLabel bottomLeftStat = new JLabel();
	private final JLabel topRightStat = new JLabel();
	private final JLabel bottomRightStat = new JLabel();
	private JComponent panel;

	MetricsInfoBox( MetricsTrackerPlugin plugin, JComponent panel, String name  )
	{
		this.name = name;
		this.panel = panel;

		setLayout( new BorderLayout() );
		setBorder( new EmptyBorder( 5, 0, 0, 0 ) );

		container.setLayout( new BorderLayout() );
		container.setBackground( ColorScheme.DARKER_GRAY_COLOR );

		// Create reset menu
		final JMenuItem reset = new JMenuItem( "Reset" );
		reset.addActionListener( e -> plugin.resetSingleMetric( name ) );

		final JMenuItem resetOthers = new JMenuItem( "Reset Others" );
		resetOthers.addActionListener( e -> plugin.resetOthers( name ) );

		final JPopupMenu popupMenu = new JPopupMenu();
		popupMenu.setBorder( new EmptyBorder(5, 5, 5, 5) );

		popupMenu.add( reset );
		popupMenu.add( resetOthers );
		popupMenu.addPopupMenuListener( new PopupMenuListener()
		{
			@Override
			public void popupMenuWillBecomeVisible( PopupMenuEvent popupMenuEvent )
			{
			}

			@Override
			public void popupMenuWillBecomeInvisible( PopupMenuEvent popupMenuEvent )
			{
			}

			@Override
			public void popupMenuCanceled( PopupMenuEvent popupMenuEvent )
			{
			}
		});

		headerPanel.setBackground( ColorScheme.DARKER_GRAY_COLOR );
		headerPanel.setLayout( new BorderLayout() );

		statsPanel.setLayout( new DynamicGridLayout( 2, 2 ) );
		statsPanel.setBackground( ColorScheme.DARKER_GRAY_COLOR );
		statsPanel.setBorder( new EmptyBorder( 9, 2, 9, 2 ) );

		topLeftStat.setFont( FontManager.getRunescapeSmallFont() );
		bottomLeftStat.setFont( FontManager.getRunescapeSmallFont() );
		topRightStat.setFont( FontManager.getRunescapeSmallFont() );
		bottomRightStat.setFont( FontManager.getRunescapeSmallFont() );

		statsPanel.add( topLeftStat );
		statsPanel.add( topRightStat );
		statsPanel.add( bottomLeftStat );
		statsPanel.add( bottomRightStat );

		headerPanel.add( statsPanel, BorderLayout.CENTER );
		container.add( headerPanel, BorderLayout.NORTH );

		container.setComponentPopupMenu( popupMenu );
		progressBar.setComponentPopupMenu( popupMenu );

		// forward mouse drag events to parent panel for drag and drop reordering
		MouseDragEventForwarder mouseDragEventForwarder = new MouseDragEventForwarder( panel );
		container.addMouseListener( mouseDragEventForwarder );
		container.addMouseMotionListener( mouseDragEventForwarder );
		progressBar.addMouseListener( mouseDragEventForwarder );
		progressBar.addMouseMotionListener( mouseDragEventForwarder );

		add( container, BorderLayout.NORTH );
	}

	public void reset( JComponent panel )
	{
		panel.remove( this );
		panel.revalidate();
	}

	void update( JComponent panel, String name, long quantity, float qph )
	{
		SwingUtilities.invokeLater( () -> rebuildAsync( panel, name, quantity, qph ) );
	}

	private void rebuildAsync( JComponent panel, String name, long quantity, float qph )
	{
		if ( getParent() != panel )
		{
			panel.add( this );
			panel.revalidate();
		}

		topLeftStat.setText(htmlLabel( "Monster:",  name ) );
		topRightStat.setText(htmlLabel( "Total Kills:", quantity ) );
		bottomLeftStat.setText(htmlLabel( "Kills Per hour:",  qph ) );
	}

	static String htmlLabel( String key, float value )
	{
		String valueStr = Float.toString( value );
		return htmlLabel( key, valueStr );
	}

	static String htmlLabel( String key, long value )
	{
		String valueStr = Integer.toString( ( int ) value );
		return htmlLabel( key, valueStr );
	}

	static String htmlLabel( String key, String valueStr )
	{
		return String.format( HTML_LABEL_TEMPLATE, ColorUtil.toHexColor( ColorScheme.LIGHT_GRAY_COLOR ), key, valueStr );
	}
}

package com.metricstracker;

import java.util.ArrayList;
import java.util.List;

public class EventConsumer
{
    private MetricsTrackerPanel panel;
    private List< Event > pendingEvents = new ArrayList<>();

    public EventConsumer( MetricsTrackerPanel panel )
    {
        this.panel = panel;
    }

    public void consumePendingEvents()
    {
        int sz = pendingEvents.size();
        for ( int i = sz - 1; i >= 0; --i )
        {
            Event event = pendingEvents.get( i );
            panel.addEvent( event );
            pendingEvents.remove( i );
        }
    }

    public void addPendingEvent( Event event )
    {
        pendingEvents.add( event );
    }
}

package com.metricstracker;

import java.time.Instant;
import java.util.HashMap;

public class MetricsManager
{
    private final static String overallKey = "OVERALL_KEY";
    private final static float MSEC_PER_SEC = 1000;
    private final static float SEC_PER_MIN = 60;
    private final static float MIN_PER_HOUR = 60;
    public HashMap< String, Event > lastEvent;
    private HashMap< String, Long > startTimes;
    private HashMap< String, Long > quantities;

    public MetricsManager()
    {
        this.lastEvent = new HashMap<>();
        this.startTimes = new HashMap<>();
        this.quantities = new HashMap<>();

        this.lastEvent.put( overallKey, new Event( Event.eventType.MASTER ) );
        this.quantities.put( overallKey, ( long ) 0 );
    }

    public void addDataPoint( Event event )
    {
        String key = event.getName();

        if ( !this.startTimes.containsKey( key ) )
        {
            this.startTimes.put( key, Instant.now().toEpochMilli() );
        }

        if ( !this.startTimes.containsKey( overallKey ) )
        {
            this.startTimes.put( overallKey, Instant.now().toEpochMilli() );
        }

        this.lastEvent.put( key, event );
        this.lastEvent.put( overallKey, event );

        long quantity = 0;
        if ( this.quantities.containsKey( key ) )
        {
            quantity = this.quantities.get( key );
        }

        quantity += event.getQuantity();
        this.quantities.put( key, quantity );

        quantity = this.quantities.get( overallKey ) + event.getQuantity();
        this.quantities.put( overallKey, quantity );
    }

    public float getQuantityPerHour( String key )
    {
        float qph = 0;
        float runTime = 0;

        if ( this.startTimes.containsKey( key ) )
        {
            runTime = Instant.now().toEpochMilli() - this.startTimes.get( key );
            runTime /= MSEC_PER_SEC;
            runTime /= SEC_PER_MIN;
            runTime /= MIN_PER_HOUR;

        }

        if ( this.quantities.containsKey( key ) )
        {
            qph = this.quantities.get( key );

            if ( runTime == 0 )
            {
                return ( this.quantities.get( key ) );
            }

            qph /= runTime;
        }

        return qph;
    }

    public float getOverallPerHour()
    {
        float qph = 0;
        float runTime = 0;
        String key = overallKey;

        if ( this.startTimes.containsKey( key ) )
        {
            runTime = Instant.now().toEpochMilli() - this.startTimes.get( key );
            runTime /= MSEC_PER_SEC;
            runTime /= SEC_PER_MIN;
            runTime /= MIN_PER_HOUR;

        }

        if ( this.quantities.containsKey( key ) )
        {
            qph = this.quantities.get( key );

            if ( runTime == 0 )
            {
                return ( this.quantities.get( key ) );
            }

            qph /= runTime;
        }

        return qph;
    }

    public long getCumulativeQuantity( String key )
    {
        if ( !this.quantities.containsKey( key ) )
        {
            return 0;
        }
        return this.quantities.get( key );
    }

    public long getOverallCumulativeQuantity()
    {
        String key = overallKey;
        if ( !this.quantities.containsKey( key ) )
        {
            return 0;
        }
        return this.quantities.get( key );
    }

    public void reset( String key )
    {
        if ( this.quantities.containsKey( key ) )
        {
            this.quantities.remove( key );
        }

        if ( this.startTimes.containsKey( key ) )
        {
            this.startTimes.remove( key );
        }

        if ( this.lastEvent.containsKey( key ) )
        {
            this.lastEvent.remove( key );
        }
    }

    public void resetOthers( String key )
    {
        int sz = this.quantities.keySet().size() - 1;

        if ( sz >= 0 )
        {
            String keys[] = this.quantities.keySet().toArray( new String[0] );
            for ( int i = sz; i >=0; --i )
            {
                if ( !( key.equals( keys[ i ] ) )
                &&   !( keys[ i ].equals( overallKey ) ) )
                {
                    reset( keys[ i ] );
                }
            }
        }
    }

    public void resetAll()
    {
        this.quantities.clear();
        this.startTimes.clear();
        this.lastEvent.clear();

        this.lastEvent = new HashMap<>();
        this.startTimes = new HashMap<>();
        this.quantities = new HashMap<>();

        this.lastEvent.put( overallKey, new Event( Event.eventType.MASTER ) );
        this.quantities.put( overallKey, ( long ) 0 );
    }

}

package com.metricstracker;

import net.runelite.api.Actor;
import net.runelite.api.Hitsplat;
import net.runelite.api.NPC;
import net.runelite.api.gameval.NpcID;
import net.runelite.client.game.NpcUtil;

import java.util.HashMap;

public class DamageHandler
{
    private int tickCounter = 0;
    private final int ticksToSelfDestruct = 100;
    private HashMap< Actor, Event > eventsToValidate = new HashMap<>();

    public boolean isMonsterKilledEvent( Hitsplat hitsplat,  Actor actor, NpcUtil npcUtil )
    {
        if ( !( actor instanceof NPC ) )
        {
            return false;
        }

        if ( hitsplat.isMine() )
        {
            // Start tracking the mob after the player deals damage below 50% hp
            if ( actor.getHealthRatio() <= 0 || ( actor.getHealthRatio() <= actor.getHealthScale() / 2 )  )
            {
                return true;
            }

            if ( npcUtil.isDying( ( NPC ) actor) )
            {
                return true;
            };
        }

        return false;
    }

    public void emitMonsterKilledEvent( Actor actor )
    {
        Event event = new Event( Event.eventType.MONSTERS_KILLED, actor.getName(), 1 );
        tickCounter = 0;
        eventsToValidate.put( actor, event );
    }

    public void tick( EventConsumer consumer, NpcUtil npcUtil )
    {
        int sz = eventsToValidate.keySet().size() - 1;
        if ( sz >= 0 )
        {
            Actor actors[] = eventsToValidate.keySet().toArray( new Actor[0] );
            for ( int i = sz; i >= 0; --i )
            {
                Actor actor = actors[i];

                if ( isActorDead( actor, npcUtil ) )
                {
                    consumer.addPendingEvent( eventsToValidate.get( actor ) );
                    eventsToValidate.remove( actor );
                }
            }
            // Delete lists after a minute of inactivity to avoid any memory leaks
            tickCounter++;
            if ( tickCounter == ticksToSelfDestruct )
            {
                eventsToValidate.clear();
                tickCounter = 0;
            }
        }
    }

    private boolean isActorDead( Actor actor, NpcUtil npcUtil )
    {
        if ( actor == null
        ||   npcUtil.isDying( ( NPC ) actor )
        ||   damageHandlerCheckSpecialCases( ( NPC ) actor ) )
        {
            return true;
        }
        return false;
    }

    private boolean damageHandlerCheckSpecialCases( NPC npc )
    {
        int id = npc.getId();

        switch ( id )
        {
            case NpcID.NIGHTMARE_TOTEM_1_CHARGED:
            case NpcID.NIGHTMARE_TOTEM_2_CHARGED:
            case NpcID.NIGHTMARE_TOTEM_3_CHARGED:
            case NpcID.NIGHTMARE_TOTEM_4_CHARGED:
                return true;
            default:
                return false;
        }
    }
}

package com.metricstracker;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.Hitsplat;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.NpcUtil;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import java.awt.image.BufferedImage;

@Slf4j
@PluginDescriptor(
        name = "Metrics Tracker",
        description = "Trackers miscellaneous player metrics"
)
public class MetricsTrackerPlugin extends Plugin
{
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private ConfigManager configManager;
    @Inject
    private EventBus eventBus;
    @Inject
    private NpcUtil npcUtil;
    @Inject
    private MetricsTrackerConfig config;
    @Inject
    private ClientToolbar clientToolbar;
    private static final String ICON_FILE = "/metrics_tracker_icon.png";
    private static final String PLUGIN_NAME = "Metrics Tracker";
    private final DamageHandler damageHandler = new DamageHandler();
    private MetricsTrackerPanel loggerPanel;
    private EventConsumer consumer;
    private NavigationButton navigationButton;

    @Override
    protected void startUp() throws Exception
    {
         loggerPanel = new MetricsTrackerPanel( this , config, client );
         final BufferedImage icon = ImageUtil.loadImageResource( getClass(), ICON_FILE );
         navigationButton = NavigationButton.builder()
            .tooltip( PLUGIN_NAME )
            .icon( icon )
            .priority( 6 )
            .panel( loggerPanel )
            .build();
        clientToolbar.addNavigation( navigationButton );
        consumer = new EventConsumer( loggerPanel );
    }

    @Override
    protected void shutDown() throws Exception
    {
        resetState();
        clientToolbar.removeNavigation( navigationButton );
    }

    @Provides
    MetricsTrackerConfig provideConfig( ConfigManager configManager )
    {
        return configManager.getConfig( MetricsTrackerConfig.class );
    }

    @Subscribe
    public void onGameTick( GameTick gameTick )
    {
        if ( !config.monstersKilled() )
        {
            return;
        }

        damageHandler.tick( consumer, npcUtil );
        consumer.consumePendingEvents();
    }

    @Subscribe
    public void onHitsplatApplied( HitsplatApplied event )
    {
        if ( !config.monstersKilled() )
        {
            return;
        }

        Actor actor = event.getActor();
        Hitsplat hitsplat = event.getHitsplat();

        if ( damageHandler.isMonsterKilledEvent( hitsplat, actor, npcUtil )
        &&   config.monstersKilled() )
        {
            damageHandler.emitMonsterKilledEvent( actor );
        }
    }

    public void resetState()
    {
        loggerPanel.resetAllInfoBoxes();
    }

    public void resetSingleMetric( String name )
    {
        loggerPanel.removeInfoBox( name );
    }

    void resetOthers( String name )
    {
        loggerPanel.removeOthers( name );
    }
}

package com.metricstracker;

import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.DragAndDropReorderPane;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.*;
import java.util.HashMap;
import java.util.Map;

public class MetricsTrackerPanel extends PluginPanel
{
    @Inject
    private Client client;
    private final MetricsTrackerPlugin plugin;
    private final String PANEL_KEY_STRING = "PanelStringMasterKey";
    private final JPanel overallPanel = new JPanel();
    private final JLabel monstersKilled = new JLabel( "Killed" );
    private final JLabel monstersPerHour = new JLabel( "Per hour" );
    private final Map< String, MetricsInfoBox > infoBoxes = new HashMap<>();
    private final MetricsManager metricsManager = new MetricsManager();
    private MetricsTrackerConfig config;
    JComponent infoBoxPanel;

    public MetricsTrackerPanel( MetricsTrackerPlugin metricsTrackerPlugin, MetricsTrackerConfig config, Client client )
    {
        super();
        this.plugin = metricsTrackerPlugin;
        this.config = config;
        this.client = client;

        setBorder( new EmptyBorder( 6, 6, 6, 6 ) );
        setBackground( ColorScheme.DARK_GRAY_COLOR );
        setLayout( new BorderLayout() );

        final JPanel layoutPanel = new JPanel();
        BoxLayout boxLayout = new BoxLayout( layoutPanel, BoxLayout.Y_AXIS );
        layoutPanel.setLayout( boxLayout );
        add( layoutPanel, BorderLayout.NORTH );

        overallPanel.setBorder( new EmptyBorder( 10, 10, 10, 10 ) );
        overallPanel.setBackground( ColorScheme.DARKER_GRAY_COLOR );
        overallPanel.setLayout( new BorderLayout() );
        overallPanel.setVisible( true ); // this will only become visible when the player gets exp

        // Create reset all menu
        final JMenuItem reset = new JMenuItem( "Reset All" );
        reset.addActionListener( e -> plugin.resetState() );

        // Create popup menu
        final JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder( new EmptyBorder( 5, 5, 5, 5 ) );
        popupMenu.add( reset );

        popupMenu.addPopupMenuListener( new PopupMenuListener()
        {
            @Override
            public void popupMenuWillBecomeVisible( PopupMenuEvent popupMenuEvent )
            {
            }

            @Override
            public void popupMenuWillBecomeInvisible( PopupMenuEvent popupMenuEvent )
            {
            }

            @Override
            public void popupMenuCanceled( PopupMenuEvent popupMenuEvent )
            {
            }
        });
        overallPanel.setComponentPopupMenu( popupMenu );

        final JLabel overallIcon = new JLabel( new ImageIcon( ImageUtil.loadImageResource(metricsTrackerPlugin.getClass(), "/metrics_tracker_icon.png" ) ) );

        final JPanel overallInfo = new JPanel();
        overallInfo.setBackground( ColorScheme.DARKER_GRAY_COLOR );
        overallInfo.setLayout( new GridLayout( 2, 1 ) );
        overallInfo.setBorder( new EmptyBorder( 0, 10, 0, 0) );

        monstersKilled.setFont( FontManager.getRunescapeSmallFont() );
        monstersPerHour.setFont( FontManager.getRunescapeSmallFont() );

        overallInfo.add( monstersKilled );
        overallInfo.add( monstersPerHour );

        overallPanel.add( overallIcon, BorderLayout.WEST );
        overallPanel.add( overallInfo, BorderLayout.CENTER );

        infoBoxPanel = new DragAndDropReorderPane();

        layoutPanel.add( overallPanel );
        layoutPanel.add( infoBoxPanel );

    }

    public void addEvent( Event event )
    {
        metricsManager.addDataPoint( event );

        if ( !infoBoxes.containsKey( event.getName() ) )
        {
            infoBoxes.put( event.getName(), new MetricsInfoBox( plugin, infoBoxPanel, event.getName() ) );
        }

        infoBoxes.get( event.getName() ).update( infoBoxPanel, event.getName(), metricsManager.getCumulativeQuantity( event.getName() ), metricsManager.getQuantityPerHour( event.getName() ) );
        updateOverallTrackerText();
    }

    public void resetAllInfoBoxes()
    {
        metricsManager.resetAll();

        for ( MetricsInfoBox box : infoBoxes.values() )
        {
            box.reset( infoBoxPanel );
        }

        infoBoxes.clear();

        monstersKilled.setText( "Total Killed:" );
        monstersPerHour.setText( "Total Per hour:" );
    }

    public void removeInfoBox( String name )
    {
        if ( infoBoxes.containsKey( name ) )
        {
            infoBoxes.get( name ).reset( infoBoxPanel );
            infoBoxes.remove( name );
        }

        metricsManager.reset( name );
    }

    public void removeOthers( String name )
    {
        int sz = infoBoxes.keySet().size() - 1;
        if ( sz >= 0 )
        {
            String keys[] = infoBoxes.keySet().toArray( new String[0] );
            for ( int i = sz; i >= 0; --i )
            {
                if ( !( keys[ i ].equals( name ) ) )
                {
                    removeInfoBox( keys[ i ] );
                }
            }
        }
        metricsManager.resetOthers( name );
    }

    private void updateOverallTrackerText()
    {
        final String killed = "Total Killed:" + metricsManager.getOverallCumulativeQuantity();
        final String kph = "Total Per hour:" + metricsManager.getOverallPerHour();

        monstersKilled.setText( killed );
        monstersPerHour.setText( kph );

    }

}

package com.metricstracker;

import lombok.Getter;

public class Event
{
    enum eventType
    {
        MASTER,
        NONE,
        ITEM_DROPS,
        XP_DROPS,
        LVLS_GAINED,
        MONSTERS_KILLED,
        DAMAGE_DEALT,
        DAMAGE_TAKEN,
        RESOURCES_GATHERED,
        CHAT_MESSAGES
    }

    // Type of the data point being created
    @Getter
    public eventType Type;
    @Getter
    public String name;
    @Getter
    public int Quantity;

    public Event( eventType type, String name, int quantity )
    {
        this.Type = type;
        this.name = name;
        this.Quantity = quantity;
    }

    public Event( eventType type )
    {
        this.Type = type;
        this.name = null;
        this.Quantity = 0;
    }
}

package com.example;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class ExamplePluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(ExamplePlugin.class);
		RuneLite.main(args);
	}
}
