package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import com.geel.customitemhovers.expressions.functions.Function;

import java.util.Stack;

/**
 * Evaluates compiled expressions, returning a single Token (if runtime evaluation) or multiple Tokens (if static evaluation).
 *
 * If a single Token with a constant value is returned, it is the output of the expression.
 *
 * Supports both runtime eval mode (must get an answer now or exception)
 * and static eval mode (evaluate as much as possible now, but leave any statically-unresolvable expressions or
 * functions alone). Static eval mode is useful for reducing expressions to their minimal form, improving runtime performance.
 */
class Evaluator {
    public static Token[] EvaluateExpression(CompiledExpression expression,
                                             ExecutionContext context,
                                             boolean staticEval) {
        Token[] rpn = expression.getTokens();
        Stack<Token> stack = new Stack<>();
        for (int i = 0; i < rpn.length; i++) {
            Token token = rpn[i];
            boolean isFirst = i == 0;
            boolean isLast = i == rpn.length - 1;

            // Handle values
            if (token.getType().isValue()) {
                if (isLast && !isFirst) {
                    throw new IllegalArgumentException("Dangling value");
                }

                stack.add(evaluateValue(token, context, staticEval));
                continue;
            }

            // Handle functions
            if (token.getType().isFunction()) {
                if (stack.isEmpty() && token.getNumFunctionArgs() != 0) {
                    throw new IllegalArgumentException("Function called with empty stack");
                }

                stack.add(evaluateFunction(stack, token, context, staticEval));
                continue;
            }

            // Handle operators
            if (token.getType().isOperator()) {
                if (stack.size() < 2) {
                    throw new IllegalArgumentException("Operator called with fewer than 2 items on the stack");
                }

                Token rightHand = stack.pop();
                Token leftHand = stack.pop();
                stack.add(evaluateOperator(stack, token, leftHand, rightHand, staticEval));
                continue;
            }
        }

        return stack.toArray(new Token[0]);
    }

    /**
     * Evaluates a Token to a constant numeric value.
     * <p>
     * If the Token is already a constant number, this just returns the Token.
     * <p>
     * Otherwise, the Token is a variable; evaluate the variable.
     */
    private static Token evaluateValue(
            Token value,
            ExecutionContext context,
            boolean staticEval
    ) {
        // If it's a constant type, just return that
        if (value.getType().isConstant()) {
            return value;
        }

        // Evaluate variable
        String variableVal = context.resolveVariable(value.getValue());
        if (variableVal == null) {
            // If we can't evaluate the variable, and we're in static eval mode, just return the variable token
            if (staticEval) {
                return value;
            }

            // Can't evaluate the variable and we're in runtime eval mode -- scream
            throw new IllegalArgumentException("Cannot resolve variable");
        }

        // Determine if variable is integer or double
        // TODO: Holy _wow_ this is fucking stupid
        int intVal = 0;
        double doubleVal = 0;
        boolean isInt = false;
        boolean isDouble = false;

        try {
            intVal = Integer.parseInt(variableVal);
            isInt = true;
        } catch (NumberFormatException e) {
        }

        try {
            doubleVal = Double.parseDouble(variableVal);
            isDouble = true;
        } catch (NumberFormatException e) {
        }

        if (isInt) {
            return Token.fromInt(intVal);
        } else if (isDouble) {
            return Token.fromDouble(doubleVal);
        } else {
            return Token.fromString(variableVal);
        }
    }

    /**
     * Evaluates a function call.
     *
     * If in static eval mode, any non-const arguments, or a call to a non-constexpr function, will result in
     * the function call being unchanged on the stack.
     *
     * If in runtime eval mode, any non-const arguments will result in an exception being thrown.
     */
    private static Token evaluateFunction(
            Stack<Token> stack,
            Token functionToken,
            ExecutionContext context,
            boolean staticEval) {
        String name = functionToken.getValue();
        int numArgs = functionToken.getNumFunctionArgs();

        // Ensure stack has the right amount of arguments
        if (stack.size() < numArgs) {
            throw new IllegalArgumentException("Function called with too few arguments on stack");
        }

        // Parse out the args.
        // They'll be on the stack in reverse order.
        Token[] args = new Token[numArgs];
        boolean allConst = true;
        int numArgsPopped = 0;
        for (int i = args.length - 1; i >= 0; i--) {
            args[i] = stack.pop();
            numArgsPopped++;

            // If any args are non-const, we should stop immediately -- we won't be able to evaluate the function.
            // (We're either in static eval mode, in which case, any non-const args are always a no go -- or we're in
            //  runtime eval mode, in which case, it's inherently erroneous that we end up with a function call
            //  without evaluated, constant arguments on the stack)
            if (!args[i].getType().isConstant()) {
                allConst = false;
                break;
            }
        }

        // If all the arguments are const, then try to find a function that fits
        if (allConst) {
            Function func = context.resolveFunction(name, args);
            if (func != null && (!staticEval || func.isConstExpr())) {
                // We found a function, and either we're not in static eval mode, or we are and it's a constexpr func
                return func.execute(args, context);
            }
        }

        // If nothing fits, and we're not in static eval mode, then we should just fail
        if (!staticEval) {
            throw new IllegalArgumentException("Invalid function call");
        }

        // We're in static eval mode and no function call fit (or it wasn't constexpr).
        // We need to put the stack back to where it was.
        //
        // Put all the args back on the stack
        for (int i = args.length - 1; i >= (args.length - numArgsPopped); i--) {
            stack.add(args[i]);
        }

        // Put the function back on the stack
        return functionToken;
    }

    /**
     * Evaluates an operator on the stack.
     *
     * If in static eval mode, operations involving anything non-const (unresolved variable, function call, etc),
     * or involving ternary, will result in the operation being put back on the stack, untouched.
     */
    private static Token evaluateOperator(
            Stack<Token> stack,
            Token operatorToken,
            Token leftValue,
            Token rightValue,
            boolean staticEvalMode
    ) {
        // In static eval mode, handle non-const operands or ternary operators specially
        boolean isTernary = operatorToken.getType().isTernaryOperator();
        if (staticEvalMode) {
            boolean isNonConst = (!leftValue.getType().isConstant() || !rightValue.getType().isConstant());

            if(isNonConst || isTernary) {
                // Put things back on the stack exactly as they were
                stack.add(leftValue);
                stack.add(rightValue);
                return operatorToken;
            }
        }

        // In runtime eval mode, handle ternary operators specially from the other operators. Fuck the other operators.
        if (operatorToken.getType() == TokenType.TERNARY_THEN) {
            return evaluateTernaryThen(operatorToken, leftValue, rightValue);
        } else if (operatorToken.getType() == TokenType.TERNARY_ELSE) {
            return evaluateTernaryElse(rightValue, leftValue);
        }

        // If either operator is a string, handle it specially
        if (leftValue.getType() == TokenType.STRING || rightValue.getType() == TokenType.STRING) {
            return evaluateStringOperator(operatorToken, leftValue, rightValue);
        }

        Number leftVal, rightVal, result;
        // TODO: Figure out a better way to handle this. Fundamentally, we are trying to figure out:
        // 1. How do we deserialize the input?
        // 2. How do we serialize the output?
        boolean isDoubleInput = isDoubleOperation(operatorToken, leftValue, rightValue);
        boolean isDoubleOutput = isDoubleInput && !operatorToken.getType().isBooleanOperator();

        // I hate this
        if (isDoubleInput) {
            leftVal = Double.parseDouble(leftValue.getValue());
            rightVal = Double.parseDouble(rightValue.getValue());
        } else {
            leftVal = Integer.parseInt(leftValue.getValue());
            rightVal = Integer.parseInt(rightValue.getValue());
        }

        // TODO: Surely this can be done more elegantly
        switch (operatorToken.getType()) {
            case OP_TIMES:
                result = isDoubleInput
                        ? (leftVal.doubleValue() * rightVal.doubleValue())
                        : (leftVal.intValue() * rightVal.intValue());
                break;
            case OP_DIVIDE:
                // Avoid a divide-by-zero
                if (Math.abs(rightVal.doubleValue()) < 0.0000001) {
                    result = 0;
                } else {
                    result = leftVal.doubleValue() / rightVal.doubleValue();
                }
                break;
            case OP_MODULO:
                // Avoid a divide-by-zero
                if (rightVal.intValue() == 0) {
                    result = 0;
                } else {
                    result = leftVal.intValue() % rightVal.intValue();
                }
                break;
            case OP_PLUS:
                result = isDoubleInput
                        ? (leftVal.doubleValue() + rightVal.doubleValue())
                        : (leftVal.intValue() + rightVal.intValue());
                break;
            case OP_MINUS:
                result = isDoubleInput
                        ? (leftVal.doubleValue() - rightVal.doubleValue())
                        : (leftVal.intValue() - rightVal.intValue());
                break;
            case CMP_LT:
                result = leftVal.doubleValue() < rightVal.doubleValue() ? 1 : 0; // EPSILON
                break;
            case CMP_LTE:
                result = (leftVal.doubleValue() - rightVal.doubleValue() < 0.000001) ? 1 : 0; // EPSILON
                break;
            case CMP_GT:
                result = leftVal.doubleValue() > rightVal.doubleValue() ? 1 : 0; // EPSILON
                break;
            case CMP_GTE:
                result = (leftVal.doubleValue() - rightVal.doubleValue() > -0.000001) ? 1 : 0; // EPSILON
                break;
            case CMP_EQUALS:
                result = Math.abs(leftVal.doubleValue() - rightVal.doubleValue()) < 0.000001 ? 1 : 0; // EPSILON
                break;
            case CMP_NEQUALS:
                result = Math.abs(leftVal.doubleValue() - rightVal.doubleValue()) > 0.000001 ? 1 : 0; // EPSILON
                break;
            case LOG_AND:
                result = (leftVal.intValue() != 0 && rightVal.intValue() != 0) ? 1 : 0;
                break;
            case LOG_OR:
                result = (leftVal.intValue() != 0 || rightVal.intValue() != 0) ? 1 : 0;
                break;
            case BIT_AND:
            case BIT_OR:
            case BIT_XOR:
            case BITSHIFT_LEFT:
            case BITSHIFT_RIGHT:
                throw new IllegalStateException("Bitwise operations are not presently supported");
            default:
                throw new IllegalStateException("Unexpected value: " + operatorToken.getType());
        }

        return isDoubleOutput
                ? Token.fromDouble(result.doubleValue())
                : Token.fromInt(result.intValue());
    }

    /**
     * Evaluates an operation involving string operands
     */
    private static Token evaluateStringOperator(Token operatorToken, Token leftValue, Token rightValue) {
        // Operator must be valid for use on strings
        if (!operatorToken.getType().operatorSupportsStringArguments()) {
            throw new IllegalArgumentException("Operator " + operatorToken.getValue() + " does not support strings");
        }

        // At least one argument must be a string
        if (leftValue.getType() != TokenType.STRING && rightValue.getType() != TokenType.STRING) {
            throw new IllegalArgumentException("Both arguments must be string values");
        }

        switch (operatorToken.getType()) {
            case CMP_EQUALS:
                return Token.fromInt(leftValue.getValue().equals(rightValue.getValue()) ? 1 : 0);
            case CMP_NEQUALS:
                return Token.fromInt(leftValue.getValue().equals(rightValue.getValue()) ? 0 : 1);
            case OP_PLUS:
                return Token.fromString(leftValue.getValue() + rightValue.getValue());
            default:
                throw new IllegalArgumentException("Unknown string operator " + operatorToken.getValue());
        }
    }

    /**
     * Evaluates a ternary ? operator.
     *
     * The expression `condition ? ifTrue : ifFalse` will result in a token stack of `condition ifTrue ? ifFalse :`.
     *
     * The ? operator receives `condition` and `ifTrue` as its arguments.
     *
     * If `condition` is truthy, then `ifTrue` is the result of this operator.
     * Otherwise, the TERNARY_WAS_FALSE token (?!) is the result of the operator.
     *
     * After evaluating the above ternary, the resulting stack will look like:
     * [if `condition` is true] `ifTrue ifFalse :`
     * [if `condition` is false] `?! ifFalse :`
     *
     * This sets up the `:` operator to do its job
     */
    private static Token evaluateTernaryThen(Token operator, Token condition, Token ifTrue) {
        // Ensure that the number is false in integer or double representation
        // (0.1 is not false)
        if(Math.abs(condition.getNumericValue().doubleValue()) > 0.0000001) {
            return ifTrue;
        }

        return new Token(TokenType.TERNARY_WAS_FALSE, "?!");
    }

    /**
     * Evaluates a ternary : operator.
     *
     * After evaluating the ? operator paired with this :, the resulting stack will look like:
     * [if `condition` is true] `ifTrue ifFalse :`
     * [if `condition` is false] `?! ifFalse :`
     *
     * So, to evaluate `:`, we just see if the lefthand argument is a `?!`.
     * If it is, then we return `ifFalse`.
     * Otherwise, we return the lefthand argument.
     */
    private static Token evaluateTernaryElse(Token ifFalse, Token discriminator) {
        if(discriminator.getType() == TokenType.TERNARY_WAS_FALSE) {
            return ifFalse;
        }

        return discriminator;
    }

    /**
     * Determines if an operation requires the use of decimal numbers.
     * <p>
     * This is true if either operand is a decimal itself, or if the operation is a division.
     */
    private static boolean isDoubleOperation(Token operatorToken, Token leftValue, Token rightValue) {
        // If a double is involved on either side, we get a double.
        if (leftValue.getType() == TokenType.DOUBLE || rightValue.getType() == TokenType.DOUBLE) {
            return true;
        }

        // Otherwise, division always results in doubles
        return operatorToken.getType() == TokenType.OP_DIVIDE;
    }
}

package com.geel.customitemhovers.expressions.models;

import lombok.Getter;

public enum TokenType {
    // Order of operations:
    // Parentheses/Functions (0), Multiplication/Division (1), Arithmetic (2), Constants/Variables (3),
    // Bitshifts (<<, >>) (4), Range Comparators (<, <=, >, >=) (5), Equality Comparators (==, !=) (6),
    // Bitwise AND (&) (7), Bitwise XOR (^) (8), Bitwise OR (|) (9),
    // Logical && (10), Logical || (11),
    // Ternary Then (?) (12), Ternary Else (:) (13),
    // Comma (,) (14),
    // Expression begin/end (${/<%, }/%>) (15)
    // Whitespace (16)

    PAREN_LEFT(0, "("),
    PAREN_RIGHT(0, ")"),
    FUNCTION(0, null, true),
    OP_TIMES(1, "*"),
    OP_DIVIDE(1, "/"),
    OP_MODULO(1, "%"),
    OP_PLUS(2, "+"),
    OP_MINUS(2, "-"),
    STRING(3, null),
    INTEGER(3, null),
    DOUBLE(3, null),
    VARIABLE(3, null),
    BITSHIFT_LEFT(4, "<<"),
    BITSHIFT_RIGHT(4, ">>"),
    CMP_LT(5, "<"),
    CMP_LTE(5, "<="),
    CMP_GT(5, ">"),
    CMP_GTE(5, ">="),
    CMP_EQUALS(6, "=="),
    CMP_NEQUALS(6, "!="),
    BIT_AND(7, "&"),
    BIT_XOR(8, "^"),
    BIT_OR(9, "|"),
    LOG_AND(10, "&&"),
    LOG_OR(11, "||"),
    TERNARY_THEN(12, "?", true),
    TERNARY_ELSE(13, ":", true),
    TERNARY_WAS_FALSE(13, "?!", true), // NOT A REAL TOKEN -- REPLACES `TERNARY_THEN` IF CONDITION IS FALSE
    COMMA(14, ","),
    EXPRESSION_BEGIN(15, "${"),
    EXPRESSION_BEGIN_LEGACY(15, "<%"),
    EXPRESSION_END(15, "}"),
    EXPRESSION_END_LEGACY(15, "%>"),
    WHITESPACE(16, null); // Not a real token

    @Getter
    private final int precedence;

    @Getter
    private final boolean rightAssociative;

    @Getter
    private final String constantValue;

    private TokenType(int precedence, String constantValue) {
        this.precedence = precedence;
        this.constantValue = constantValue;
        this.rightAssociative = false;
    }

    private TokenType(int precedence, String constantValue,  boolean rightAssociative) {
        this.precedence = precedence;
        this.constantValue = constantValue;
        this.rightAssociative = rightAssociative;
    }

    private static TokenType[] operatorTokens = new TokenType[] {
            EXPRESSION_BEGIN, EXPRESSION_BEGIN_LEGACY, EXPRESSION_END, EXPRESSION_END_LEGACY,
            OP_TIMES, OP_DIVIDE, OP_MODULO, OP_MINUS, OP_PLUS,
            CMP_LT, CMP_LTE, CMP_GT, CMP_GTE, CMP_EQUALS, CMP_NEQUALS,
            LOG_AND, LOG_OR,
            TERNARY_THEN, TERNARY_ELSE,
            BITSHIFT_LEFT, BITSHIFT_RIGHT, BIT_AND, BIT_OR, BIT_XOR,
            PAREN_LEFT, PAREN_RIGHT, COMMA
    };

    public static TokenType[] GetOperatorTokenTypes() {
        return operatorTokens;
    }

    public boolean isExpressionBeginOrEnd() {
        return isExpressionBegin() || isExpressionEnd();
    }

    public boolean isLegacyExpressionBeginOrEnd() {
        return this == EXPRESSION_BEGIN_LEGACY || this == EXPRESSION_END_LEGACY;
    }

    public boolean isExpressionBegin() {
        return this == EXPRESSION_BEGIN || this == EXPRESSION_BEGIN_LEGACY;
    }

    public boolean isExpressionEnd() {
        return this == EXPRESSION_END || this == EXPRESSION_END_LEGACY;
    }

    public boolean isArithmetic() {
        return this == OP_PLUS || this == OP_MINUS;
    }

    public boolean isMultDiv() {
        return this == OP_TIMES || this == OP_DIVIDE || this == OP_MODULO;
    }

    public boolean isLogicalOperator() {
        return this == LOG_AND || this == LOG_OR;
    }

    public boolean isComparatorOperator() {
        return this == CMP_LT || this == CMP_GT || this == CMP_LTE || this == CMP_GTE || this == CMP_EQUALS || this == CMP_NEQUALS;
    }

    public boolean operatorSupportsStringArguments() {
        return this == CMP_EQUALS || this == CMP_NEQUALS || this == OP_PLUS;
    }

    public boolean isBitShiftOperator() {
        return this == BITSHIFT_LEFT || this == BITSHIFT_RIGHT;
    }

    public boolean isLogicalBitwiseOperator() {
        return this == BIT_AND || this == BIT_OR || this == BIT_XOR;
    }

    public boolean isBitwiseOperator() {
        return isLogicalBitwiseOperator() || isBitShiftOperator();
    }

    public boolean isTernaryOperator() {
        return this == TERNARY_THEN || this == TERNARY_ELSE;
    }

    public boolean isBooleanOperator() {
        return isLogicalOperator() || isComparatorOperator();
    }

    public boolean isOperator() {
        return isArithmetic()
                || isMultDiv()
                || isLogicalOperator()
                || isComparatorOperator()
                || isTernaryOperator()
                || isBitwiseOperator()
                || this == COMMA;
    }

    public boolean isParenthesis() {
        return this == PAREN_LEFT || this == PAREN_RIGHT;
    }

    public boolean isValue() {
        return isVariable() || isConstant();
    }

    public boolean isFunction() {
        return this == FUNCTION;
    }

    public boolean isVariable() {
        return this == VARIABLE;
    }

    public boolean isConstant() {
        return this == INTEGER || this == DOUBLE || this == STRING;
    }

    public boolean isIdentifier() {
        return isValue() || isFunction();
    }
}
package com.geel.customitemhovers.expressions.models;

/**
 * An expression, after being tokenized, but before parsing.
 */
public class TokenizedExpression extends BaseExpression {
    public TokenizedExpression(Token[] tokens, String expressionText, boolean isLegacy) {
        super(tokens, expressionText, isLegacy);
    }

    public TokenizedExpression(BaseExpression expression) {
        super(expression.getTokens(), expression.getExpressionText(), expression.isLegacy());
    }
}

package com.geel.customitemhovers.expressions.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

public class Token {
    @Getter
    private TokenType type;

    @Getter
    private String value; // TODO: Make more efficient than Strings. Are slices a thing in Java?

    @Getter
    @Setter
    private int numFunctionArgs = 0;

    public Token(TokenType type, String value) {
        this.type = type;
        this.value = value;
    }

    public Number getNumericValue() {
        if(type == TokenType.INTEGER) {
            return Integer.parseInt(value);
        } else if(type == TokenType.DOUBLE) {
            return Double.parseDouble(value);
        } else {
            throw new IllegalArgumentException("Not a number type");
        }
    }

    public static Token fromDouble(double value) {
        return new Token(TokenType.DOUBLE, String.valueOf(value));
    }

    public static Token fromInt(int value) {
        return new Token(TokenType.INTEGER, String.valueOf(value));
    }

    public static Token fromString(String value) {
        return new Token(TokenType.STRING, value);
    }

    public static Token fromBool(boolean value) {
        return new Token(TokenType.INTEGER, value ? "1" : "0");
    }

    public static Token fromTrue() {
        return fromBool(true);
    }

    public static Token fromFalse() {
        return fromBool(false);
    }
}

package com.geel.customitemhovers.expressions.models;

/**
 * A "compiled" expression, after tokenization and parsing.
 *
 * TODO: Figure out a way to collapse constexpr expressions, eg:
 *      "(3 + 4) * 2" should collapse to a single constant token "24"
 *      "sqrt(3 + 4 + 2) * a" should collapse to "3.0 * a"
 */
public class CompiledExpression extends BaseExpression {
    public CompiledExpression(Token[] tokens, String expressionText, boolean isLegacy) {
        super(tokens, expressionText, isLegacy);
    }

    public CompiledExpression(BaseExpression expression) {
        super(expression.getTokens(), expression.getExpressionText(), expression.isLegacy());
    }
}

package com.geel.customitemhovers.expressions.models;

public enum ArgumentType {
    ANY,
    INTEGER,
    DOUBLE,
    STRING;

    public boolean fitsTokenType(TokenType type) {
        if (!type.isConstant()) return false;
        if (this == ANY) return true;
        if (this == INTEGER || this == DOUBLE) return type == TokenType.INTEGER || type == TokenType.DOUBLE;
        if (this == STRING) return type == TokenType.STRING;

        return false; //Should never get here
    }

    public Token coerceTokenToType(Token token) {
        if(!fitsTokenType(token.getType())) {
            throw new IllegalArgumentException("Cannot coerce token of invalid type");
        }

        if(this == ANY) return token;
        if(this == INTEGER) return token.getType() == TokenType.INTEGER ? token : Token.fromInt(token.getNumericValue().intValue());
        if(this == DOUBLE) return token.getType() == TokenType.DOUBLE ? token : Token.fromDouble(token.getNumericValue().doubleValue());
        if(this == STRING){
            if(token.getType() == TokenType.STRING) return token;
            return Token.fromString(token.getValue());
        }

        return token; // Should not get here
    }
}

package com.geel.customitemhovers.expressions.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
public class BaseExpression {
    /**
     * The Tokens that make up this expression, in Reverse Polish Notation
     */
    @Getter
    private Token[] tokens;

    /**
     * The original raw text of the expression
     */
    @Getter
    private String expressionText;

    /**
     * Whether the expression is "legacy" (begins with <% and ends with %>)
     */
    @Getter
    private boolean isLegacy = false;
}

package com.geel.customitemhovers.expressions.functions;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.models.ArgumentType;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import lombok.Getter;

public abstract class VariadicFunction extends Function {
    @Getter
    private int minVariadicArguments;

    @Getter
    private int maxVariadicArguments;

    @Getter
    private ArgumentType variadicArgumentType;

    @Getter
    private int numFixedArguments;

    @Getter
    private final ArgumentType[] fixedArgumentTypes;

    public VariadicFunction(String name,
                            TokenType returnType,
                            ArgumentType variadicArgumentType
    ) {
        this(name, returnType, 0, 100, variadicArgumentType, null, false);
    }

    public VariadicFunction(String name,
                            TokenType returnType,
                            ArgumentType variadicArgumentType,
                            boolean isConstExpr
    ) {
        this(name, returnType, 0, 100, variadicArgumentType, null, isConstExpr);
    }

    public VariadicFunction(String name,
                            TokenType returnType,
                            ArgumentType variadicArgumentType,
                            ArgumentType[] fixedArguments
    ) {
        this(name, returnType, 0, 100, variadicArgumentType, fixedArguments, false);
    }

    public VariadicFunction(String name,
                            TokenType returnType,
                            ArgumentType variadicArgumentType,
                            ArgumentType[] fixedArguments,
                            boolean isConstExpr
    ) {
        this(name, returnType, 0, 100, variadicArgumentType, fixedArguments, isConstExpr);
    }

    public VariadicFunction(String name,
                            TokenType returnType,
                            int minVariadicArguments,
                            int maxVariadicArguments,
                            ArgumentType variadicArgumentType,
                            ArgumentType[] fixedArguments,
                            boolean isConstExpr)
    {
        super(name, returnType, isConstExpr);

        this.minVariadicArguments = minVariadicArguments;
        this.maxVariadicArguments = maxVariadicArguments;
        this.variadicArgumentType = variadicArgumentType;

        if(fixedArguments == null) {
            fixedArguments = new ArgumentType[0];
        }

        this.fixedArgumentTypes = fixedArguments;
        this.numFixedArguments = fixedArguments.length;
    }

    @Override
    public int getArgumentsHashCode() {
        return -1;
    }

    public boolean argumentsMatch(Token[] matchArguments) {
        if(matchArguments.length < minVariadicArguments + numFixedArguments) {
            return false;
        }
        if(matchArguments.length > maxVariadicArguments + numFixedArguments) {
            return false;
        }

        // Check all fixed arguments
        for(int i = 0; i < numFixedArguments; i++) {
            if(!fixedArgumentTypes[i].fitsTokenType(matchArguments[i].getType()))
                return false;
        }

        // Check all variadic arguments
        for(int i = numFixedArguments; i < matchArguments.length; i++)
        {
            if(!variadicArgumentType.fitsTokenType(matchArguments[i].getType())) {
                return false;
            }
        }

        return true;
    }

    public Token execute(Token[] arguments, ExecutionContext context) {
        if(!argumentsMatch(arguments)) {
            throw new IllegalArgumentException("Invalid number of arguments to " + name);
        }

        Token[] coercedArguments = new Token[arguments.length];

        // Coerce all fixed arguments
        for(int i = 0; i < numFixedArguments; i++) {
            coercedArguments[i] = fixedArgumentTypes[i].coerceTokenToType(arguments[i]);
        }

        // Coerce all variadic arguments
        for(int i = numFixedArguments; i < arguments.length; i++) {
            coercedArguments[i] = variadicArgumentType.coerceTokenToType(arguments[i]);
        }

        return innerExecute(coercedArguments, context);
    }
}

package com.geel.customitemhovers.expressions.functions;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.models.ArgumentType;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;

import java.util.function.BiFunction;

public class LambdaVariadicFunction extends VariadicFunction {
    private BiFunction<Token[], ExecutionContext, Token> executionFunc;

    public LambdaVariadicFunction(String name,
                                  TokenType returnType,
                                  ArgumentType variadicArgumentType,
                                  ArgumentType[] fixedArguments,
                                  BiFunction<Token[], ExecutionContext, Token> callback
    ) {
        super(name, returnType, variadicArgumentType, fixedArguments);

        this.executionFunc = callback;
    }

    public LambdaVariadicFunction(String name,
                                  TokenType returnType,
                                  ArgumentType variadicArgumentType,
                                  ArgumentType[] fixedArguments,
                                  boolean isConstExpr,
                                  BiFunction<Token[], ExecutionContext, Token> callback
    ) {
        super(name, returnType, variadicArgumentType, fixedArguments, isConstExpr);

        this.executionFunc = callback;
    }

    protected Token innerExecute(Token[] arguments, ExecutionContext context) {
        return executionFunc.apply(arguments, context);
    }
}

package com.geel.customitemhovers.expressions.functions;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.models.ArgumentType;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;

public class LambdaFixedArgsFunction extends FixedArgsFunction {
    private java.util.function.BiFunction<Token[], ExecutionContext, Token> executionFunc;

    public LambdaFixedArgsFunction(String name, TokenType returnType, ArgumentType[] arguments,
                                   java.util.function.BiFunction<Token[], ExecutionContext, Token> executionFunc) {
        super(name, returnType, arguments);
        this.executionFunc = executionFunc;
    }

    public LambdaFixedArgsFunction(String name, TokenType returnType, ArgumentType[] arguments, boolean isConstExpr,
                                   java.util.function.BiFunction<Token[], ExecutionContext, Token> executionFunc) {
        super(name, returnType, arguments, isConstExpr);
        this.executionFunc = executionFunc;
    }

    protected Token innerExecute(Token[] arguments, ExecutionContext context) {
        return executionFunc.apply(arguments, context);
    }
}

package com.geel.customitemhovers.expressions.functions;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.models.ArgumentType;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import lombok.Getter;

public abstract class FixedArgsFunction extends Function {
    @Getter
    private int numArguments;

    @Getter
    private ArgumentType[] argumentTypes;

    public FixedArgsFunction(String name, TokenType returnType, ArgumentType[] arguments) {
        super(name, returnType);

        this.argumentTypes = arguments;
        this.numArguments = arguments.length;
    }

    public FixedArgsFunction(String name, TokenType returnType, ArgumentType[] arguments, boolean isConstExpr) {
        super(name, returnType, isConstExpr);

        this.argumentTypes = arguments;
        this.numArguments = arguments.length;
    }

    @Override
    public int getArgumentsHashCode() {
        return numArguments;
    }

    public boolean argumentsMatch(Token[] matchArguments) {
        if(matchArguments.length != numArguments) return false;

        for(int i = 0; i < numArguments; i++) {
            if(!argumentTypes[i].fitsTokenType(matchArguments[i].getType()))
                return false;
        }

        return true;
    }

    public Token execute(Token[] arguments, ExecutionContext context) {
        if(arguments.length != numArguments) {
            throw new IllegalArgumentException("Invalid number of arguments to " + name);
        }

        Token[] coercedArguments = new Token[arguments.length];
        for(int i = 0; i < arguments.length; i++) {
            coercedArguments[i] = argumentTypes[i].coerceTokenToType(arguments[i]);
        }

        return innerExecute(coercedArguments, context);
    }
}

package com.geel.customitemhovers.expressions.functions;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import lombok.Getter;

public abstract class Function {
    @Getter
    protected String name;

    @Getter
    protected TokenType returnType;

    @Getter
    protected boolean isConstExpr;

    public Function(String name, TokenType returnType) {
        this.name = name;
        this.returnType = returnType;
    }

    public Function(String name, TokenType returnType, boolean isConstExpr) {
        this(name, returnType);
        this.isConstExpr = isConstExpr;
    }

    public abstract int getArgumentsHashCode();

    public abstract boolean argumentsMatch(Token[] matchArguments);

    public abstract Token execute(Token[] arguments, ExecutionContext context);

    protected abstract Token innerExecute(Token[] arguments, ExecutionContext context);
}

package com.geel.customitemhovers.expressions;
import com.geel.customitemhovers.expressions.models.*;

import java.util.ArrayList;
import java.util.Stack;

/**
 * Performs the Shunting Yard Algorithm to convert an infix mathematical expression to Reverse Polish Notation (postfix).
 *
 * This is here so that we can enable rich mathematical expressions, including variables and functions, in
 * item hover text.
 */
public class Compiler {
    /**
     * Parses an infix notation (eg "(a + b) - sqrt(12)") expression, returning an Expression object.
     */
    public static CompiledExpression Compile(TokenizedExpression expression) {
        Token[] tokenized = expression.getTokens();
        if (tokenized.length == 0) {
            return new CompiledExpression(expression);
        }

        ArrayList<Token> outputQueue = new ArrayList<>();
        Stack<Token> operatorStack = new Stack<>();

        // Stack for tracking how many arguments are passed to each function as we parse it
        Stack<Integer> functionArgs = new Stack<>();

        for (int i = 0; i < tokenized.length; i++) {
            Token token = tokenized[i];

            // Handle numbers and variables
            if (token.getType().isValue()) {
                outputQueue.add(token);
                continue;
            }

            // Handle function calls
            if (token.getType() == TokenType.FUNCTION) {
                operatorStack.add(token);

                int numArgsToInitiateWith = 1;

                // HACK: look ahead two tokens, which we know will exist because the parser ensures it.
                //       If it's a right paren, we know it's a function with no arguments,
                //       so we can just add it to the output queue and move on.
                //       We do this because we track the number of function arguments by incrementing whenever we encounter
                //       an argument separator (comma), so to handle single-argument (no-comma) scenarios we start with 1,
                //       but this breaks in a no-argument scenario.
                if(i + 2 < tokenized.length
                        && tokenized[i + 2].getType() == TokenType.PAREN_RIGHT) {
                    numArgsToInitiateWith = 0;
                }

                functionArgs.add(numArgsToInitiateWith);
                continue;
            }

            // Handle comma
            if(token.getType() == TokenType.COMMA) {
                // While the top of the stack isn't a left paren, pop from operator stack to output queue
                while (true) {
                    // If the stack is empty before we hit a left paren, there's a mismatch
                    if (operatorStack.isEmpty()) {
                        throw new IllegalArgumentException("Operator stack empty");
                    }

                    // If we find a left paren, exit the loop. Leave the left paren on the stack.
                    if (operatorStack.peek().getType() == TokenType.PAREN_LEFT) {
                        break;
                    }

                    // If not a left paren, just move to the output queue
                    outputQueue.add(operatorStack.pop());
                }

                // Increment top of functionArgs stack
                functionArgs.push(functionArgs.pop() + 1);
                continue;
            }

            // Handle operators
            if (token.getType().isOperator()) {
                // While there exists a token at the top of the stack that should be moved to the output queue
                // before this operator is added to the stack, do so
                while (ShuntOperator(token, operatorStack)) {
                    outputQueue.add(operatorStack.pop());
                }

                operatorStack.add(token);
                continue;
            }

            // Handle left paren
            if (token.getType() == TokenType.PAREN_LEFT) {
                operatorStack.add(token);
            }

            // Handle right paren
            if (token.getType() == TokenType.PAREN_RIGHT) {
                // While the top of the stack isn't a left paren, pop from operator stack to output queue
                while (true) {
                    // If the stack is empty before we hit a left paren, there's a mismatch
                    if (operatorStack.isEmpty()) {
                        throw new IllegalArgumentException("Operator stack empty");
                    }

                    Token popped = operatorStack.pop();
                    if (popped.getType() == TokenType.PAREN_LEFT) {
                        // If we hit a left paren, drop it from the stack and don't move it to the output queue
                        break;
                    }

                    // If not a left paren, just move to the output queue
                    outputQueue.add(popped);
                }

                // If the top of the operator stack is a function, then the function should also be moved now
                if (!operatorStack.isEmpty() && operatorStack.peek().getType() == TokenType.FUNCTION) {
                    if(functionArgs.size() == 0) {
                        throw new IllegalArgumentException("Function argument stack corrupted");
                    }

                    Token funcArg = operatorStack.pop();
                    funcArg.setNumFunctionArgs(functionArgs.pop());
                    outputQueue.add(funcArg);
                }
            }
        }

        // Cleanup Stack
        while (!operatorStack.isEmpty()) {
            Token popped = operatorStack.pop();

            if (popped.getType().isParenthesis()) {
                throw new IllegalArgumentException("Mismatched parentheses");
            }

            outputQueue.add(popped);
        }

        CompiledExpression compiled = new CompiledExpression(outputQueue.toArray(new Token[0]), expression.getExpressionText(), expression.isLegacy());
        return compiled;
    }

    /**
     * Called when processing an operator token.
     *
     * Determines if the top of the stack should be popped to the output queue before the new operator
     * is added to the stack.
     */
    private static boolean ShuntOperator(Token newToken, Stack<Token> stack) {
        // No top of stack? Nothing to shunt
        // (I don't know if "shunt" is the right word to actually use, but I like it)
        if (stack.isEmpty()) {
            return false;
        }

        Token topOfStack = stack.peek();

        // If it's a left paren, don't shunt
        if (topOfStack.getType() == TokenType.PAREN_LEFT) {
            return false;
        }

        // If the top has higher precedence than the new operator,
        // OR the same precedence but the new operator is left-associative,
        // it should be shunted.
        int topPrecedence = topOfStack.getType().getPrecedence();
        int newPrecedence = newToken.getType().getPrecedence();

        if (topPrecedence < newPrecedence) {
            return true;
        }

        if (topPrecedence == newPrecedence && !newToken.getType().isRightAssociative()) {
            return true;
        }

        // No shuntage
        return false;
    }
}



package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import com.geel.customitemhovers.expressions.models.TokenizedExpression;
import lombok.Getter;

import java.util.ArrayList;

/**
 * Tokenizes a mathematical expression (including variables and functions).
 * <p>
 * Not for external use; used by `ExpressionParser` as first step in parsing of an expression
 */
public class Tokenizer {
    // The text we are evaluating to find an expression in
    private String haystack;

    // The actual expression we've parsed out
    private StringBuilder parsedExpressionBuilder = new StringBuilder();
    private TokenizedExpression tokenizedExpression = null;

    // The tokens we've read so far.
    // Empty if tokenization has not yet begun, or has already finished.
    private final ArrayList<Token> tokens = new ArrayList<>();

    // Where we started reading the string
    private int startPos = 0;

    // How far into the current string we've read
    @Getter
    private int numRead = 0;

    // The current parentheses depth
    private int parenDepth = 0;

    // The current ternary depth
    private int ternaryDepth = 0;

    public Tokenizer(String haystack, int position) {
        this.haystack = haystack;
        this.startPos = position;
    }

    /**
     * Tokenizes the expression and returns the result.
     * <p>
     * If the expression has already been tokenized, just returns the result.
     */
    public TokenizedExpression tokenize() {
        // Do actual tokenization if we haven't yet
        if (numRead == 0) {
            boolean isLegacyExpression = false;
            boolean isFirst = true;
            Token t;
            while ((t = readToken()) != null) {
                TokenType type = t.getType();
                // First token must be expression start, and expression start can only appear as the first token
                if (isFirst && !type.isExpressionBegin()) {
                    throw new IllegalArgumentException("Expected EXPRESSION_START");
                } else if (!isFirst && type.isExpressionBegin()) {
                    throw new IllegalArgumentException("Unexpected EXPRESSION_START");
                }

                // Detect if it's a legacy expression
                if (type.isLegacyExpressionBeginOrEnd()) {
                    isLegacyExpression = true;
                }

                // If we reach an expression end, we're done
                if (type.isExpressionEnd()) {
                    parsedExpressionBuilder.setLength(parsedExpressionBuilder.length() - t.getValue().length());
                    break;
                }

                // Don't add ${ and } to the actual tokenized output / expression
                if (!type.isExpressionBeginOrEnd()) {
                    tokens.add(t);
                } else {
                    // Strip out opening/ending tags from output
                    parsedExpressionBuilder.setLength(parsedExpressionBuilder.length() - t.getValue().length());
                }

                isFirst = false;
            }

            if (!isValidFinalToken()) {
                throw new IllegalArgumentException("Invalid final token in expression");
            }

            // Copy expression into parsedExpression, and clear out haystack and the builder
            tokenizedExpression = new TokenizedExpression(tokens.toArray(new Token[0]), parsedExpressionBuilder.toString(), isLegacyExpression);
            parsedExpressionBuilder.setLength(0);
            parsedExpressionBuilder = null;
            haystack = null;
        }

        // Result is null after we've read some -- expression must be invalid
        if (tokenizedExpression == null) {
            throw new IllegalArgumentException("Invalid expression");
        }

        return tokenizedExpression;
    }

    /**
     * Reads a single Token from the input string.
     * <p>
     * Returns null if the end of the string has been reached.
     */
    private Token readToken() {
        boolean isFirstToken = numRead == 0;

        if ((startPos + numRead) >= haystack.length()) {
            return null;
        }

        // Find the first next character that isn't whitespace
        while (isWhitespaceChar(peekChar()))
            readChar();

        char c = peekChar();

        // Handle expression begin/end. We do this specially here because, although we classify them as
        // "operators" (for ease of parsing), the rules are different for them.
        if (isFirstToken && isExpressionBeginFirstChar(c)) {
            return readOperator();
        } else if (!isFirstToken && isExpressionEndFirstChar(c)) {
            return readOperator();
        }

        // Handle numbers
        if (isNumber(c)) {
            assertCanReadIdentifier();
            return readNumber();
        }

        // Handle strings
        if (c == '\'') {
            assertCanReadIdentifier();
            return readString();
        }

        // Handle identifiers
        if (isNameChar(c)) {
            assertCanReadIdentifier();
            return readIdentifier();
        }

        // Handle parentheses
        if (c == '(') {
            assertCanReadParenStart();
            parenDepth++;
            return readOperator();
        } else if (c == ')') {
            assertCanReadParenEnd();
            parenDepth--;
            return readOperator();
        }

        // Handle ternary
        if (c == '?') {
            assertCanReadTernaryThen();
            ternaryDepth++;
            return readOperator();
        } else if (c == ':') {
            assertCanReadTernaryElse();
            ternaryDepth--;
            return readOperator();
        }

        // Handle all operators
        if (isOperatorChar(c)) {
            assertCanReadOperator();
            return readOperator();
        }

        return null;
    }

    /**
     * Reads a number Token from the string
     */
    private Token readNumber() {
        StringBuilder builder = new StringBuilder();
        boolean hasHadPeriod = false;

        do {
            char c = readChar();
            builder.append(c);

            if (c == '.') {
                if (hasHadPeriod || builder.length() == 1)
                    throw new IllegalArgumentException("Invalid period placement");

                hasHadPeriod = true;
            }
        } while (isNumericChar(peekChar()));

        if (hasHadPeriod) {
            return Token.fromDouble(Double.parseDouble(builder.toString()));
        } else {
            return Token.fromInt(Integer.parseInt(builder.toString()));
        }
    }

    /**
     * Reads a string constant Token from the string
     */
    private Token readString() {
        readChar(); // Discard opening '
        StringBuilder builder = new StringBuilder();
        boolean isEscaping = false;

        char c;
        while ((c = readChar()) != '\0') {
            // If an escape is afoot, just append whatever character is after.
            // There are no invalid escapes :)
            if (isEscaping) {
                builder.append(c);
                isEscaping = false;
                continue;
            }

            // Detect an escapee
            if (c == '\\') {
                isEscaping = true;
                continue;
            }

            // Handle closing string
            if (c == '\'') {
                return new Token(TokenType.STRING, builder.toString());
            }

            // If it's not an escape or a ', I think... any character is valid?
            builder.append(c);
        }

        throw new IllegalArgumentException("End of string reached without string termination");
    }

    /**
     * Reads an identifier Token (variable name, function name) from the string
     */
    private Token readIdentifier() {
        StringBuilder builder = new StringBuilder();

        do {
            char c = readChar();
            builder.append(c);

            if (builder.length() == 1 && isNumber(c)) {
                throw new IllegalArgumentException("First character of an identifier cannot be a number");
            }
        } while (isNameChar(peekChar()));

        // Won't catch a space between identifier and paren. Don't really care atm.
        if (peekChar() == '(') {
            return new Token(TokenType.FUNCTION, builder.toString());
        }

        return new Token(TokenType.VARIABLE, builder.toString());
    }

    /**
     * Reads an operator Token from the string
     */
    private Token readOperator() {
        StringBuilder buff = new StringBuilder();
        buff.append(readChar());

        ArrayList<TokenType> possibleOperators = computeOperatorsStartingWith(buff.toString());
        int offset = 0;
        while (true) {
            char c = peekChar();
            ArrayList<TokenType> newPossibleOperators = constrainOperators(c, ++offset, possibleOperators);

            // If nothing matches the next character, then we need to just use whatever matches `buff`
            if (newPossibleOperators.size() == 0) {
                TokenType type = possibleOperators.stream().filter(p -> p.getConstantValue().length() == buff.length()).findFirst().get();
                return new Token(type, buff.toString());
            }

            possibleOperators = newPossibleOperators;
            buff.append(readChar());

            // If only one matches, and it has the same length as the current buffer, use it
            if (possibleOperators.size() == 1) {
                TokenType type = possibleOperators.get(0);
                if (type.getConstantValue().length() == buff.length()) {
                    break;
                }
            }
        }

        return new Token(possibleOperators.get(0), buff.toString());
    }

    /**
     * Returns a list of the operators which start with the given string
     */
    private static ArrayList<TokenType> computeOperatorsStartingWith(String prefix) {
        ArrayList<TokenType> ret = new ArrayList<>(2);

        for (TokenType tokenType : TokenType.GetOperatorTokenTypes()) {
            if (tokenType.getConstantValue().startsWith(prefix)) {
                ret.add(tokenType);
            }
        }

        return ret;
    }

    /**
     * Returns a list of the operators in `existing` which continue to match with the addition of `newChar`
     */
    private static ArrayList<TokenType> constrainOperators(char newChar, int offset, ArrayList<TokenType> existing) {
        ArrayList<TokenType> ret = new ArrayList<>(2);

        for (TokenType tokenType : existing) {
            String value = tokenType.getConstantValue();

            // If it's too short, don't consider it
            if (offset >= value.length()) {
                continue;
            }

            if (value.charAt(offset) != newChar) {
                continue;
            }

            ret.add(tokenType);
        }

        return ret;
    }

    /**
     * Reads a single character and advances the stream
     */
    private char readChar() {
        if ((startPos + numRead) >= haystack.length()) return '\0';
        char ret = haystack.charAt((startPos + numRead++));
        parsedExpressionBuilder.append(ret);
        return ret;
    }

    /**
     * Reads a single character without advancing the stream
     */
    private char peekChar() {
        if ((startPos + numRead) >= haystack.length()) return '\0';
        return haystack.charAt(startPos + numRead);
    }

    /**
     * Gets the type of the last token we parsed
     */
    private TokenType lastTokenType() {
        return tokens.size() == 0 ? null : tokens.get(tokens.size() - 1).getType();
    }

    /**
     * Gets the type of the token BEFORE the last token we parsed
     */
    private TokenType secondToLastTokenType() {
        return tokens.size() <= 1 ? null : tokens.get(tokens.size() - 2).getType();
    }

    /**
     * Determines if an Identifier can start given the last Token
     */
    private void assertCanReadIdentifier() {
        TokenType token = lastTokenType();
        if (!(token == null || token.isOperator() || token == TokenType.PAREN_LEFT)) {
            throw new IllegalArgumentException("Unexpected identifier");
        }
    }

    /**
     * Determines if an Operator can start given the last Token
     */
    private void assertCanReadOperator() {
        TokenType token = lastTokenType();
        if (!(token != null && (token.isValue() || token == TokenType.PAREN_RIGHT))) {
            throw new IllegalArgumentException("Unexpected operator");
        }
    }

    private void assertCanReadTernaryThen() {
        assertCanReadOperator();
    }

    private void assertCanReadTernaryElse() {
        assertCanReadOperator();

        if (ternaryDepth <= 0) {
            throw new IllegalArgumentException("Mismatched ternary : operator");
        }
    }

    /**
     * Determines if a ) can occur given the last Token
     */
    private void assertCanReadParenEnd() {
        if (parenDepth <= 0) {
            throw new IllegalArgumentException("Mismatched ending parenthesis");
        }

        TokenType lastToken = lastTokenType();
        TokenType secondToLastToken = secondToLastTokenType();

        if (lastToken == null) {
            throw new IllegalArgumentException("Unexpected ) at start of expression");
        }

        // Right parentheses is always allowed to follow another right parentheses or a value
        if (lastToken == TokenType.PAREN_RIGHT || lastToken.isValue()) {
            return;
        }

        // HACK: If the last token isn't a right paren or a value, we *may* still be allowed to parse a right paren
        // *IF* the last token was a LEFT paren and the token before that is a function identifier.
        // This is a special case for function calls with no arguments.
        if (lastToken == TokenType.PAREN_LEFT && secondToLastToken == TokenType.FUNCTION) {
            return;
        }

        throw new IllegalArgumentException("Unexpected ) after " + lastToken.name());
    }

    /**
     * Determines if a ( can occur given the last Token
     */
    private void assertCanReadParenStart() {
        TokenType token = lastTokenType();
        if (!(token == null
                || token == TokenType.PAREN_LEFT
                || token == TokenType.FUNCTION
                || token.isOperator())) {
            throw new IllegalArgumentException("Unexpected (");
        }
    }

    /**
     * Determines if a Token is a valid ending token
     */
    private boolean isValidFinalToken() {
        TokenType token = lastTokenType();
        return token != null && token.isValue() || token == TokenType.PAREN_RIGHT;
    }

    private static boolean isExpressionBeginFirstChar(char c) {
        return c == '$' || c == '<';
    }

    private static boolean isExpressionEndFirstChar(char c) {
        return c == '}' || c == '%';
    }

    final static char[] allowedOperators = "${}+-*/%><=!&|^?:,".toCharArray();

    /**
     * Determines if c is a valid operator character
     */
    private static boolean isOperatorChar(char c) {

        for (char t : allowedOperators) {
            if (t == c) return true;
        }

        return false;
    }

    /**
     * Determines if a character is in the character set allowed for identifiers (function and variable names)
     */
    private static boolean isNameChar(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
    }

    /**
     * Determines if a character is in the character set allowed for numbers (0-9 and a period)
     */
    private static boolean isNumericChar(char c) {
        return isNumber(c) || c == '.';
    }

    /**
     * Determines if a character is in the character set allowed for numbers (0-9)
     */
    private static boolean isNumber(char c) {
        return (c >= '0' && c <= '9');
    }

    /**
     * Determines if a character is in the character set allowed for whitespace
     */
    private static boolean isWhitespaceChar(char c) {
        return c == ' ' || c == '\t';
    }
}

package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.expressions.functions.Function;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.providers.IFunctionProvider;
import com.geel.customitemhovers.expressions.providers.IVariableProvider;

/**
 * Context for expression execution -- packages together providers of functions and variables
 */
public class ExecutionContext {
    private final IFunctionProvider functionProvider;
    private final IVariableProvider variableProvider;

    public ExecutionContext(IFunctionProvider functionProvider,
                            IVariableProvider variableProvider) {
        this.functionProvider = functionProvider;
        this.variableProvider = variableProvider;
    }

    public String resolveVariable(String variableName) {
        if(variableProvider == null) {
            return null;
        }
        return variableProvider.resolveVariable(variableName);
    }

    public Function resolveFunction(String functionName, Token[] arguments) {
        if(functionProvider == null) {
            return null;
        }

        return functionProvider.findFunction(functionName, arguments);
    }
}

package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.models.Token;

/**
 * Helpers for simplifying the evaluation of expressions
 */
public class EvaluationUtil {
    /**
     * Evaluates a Reverse Polish Notation queue (output from `ExpressionCompiler`), returning the result
     */
    public static Token EvaluateAtRuntime(CompiledExpression expression, ExecutionContext context) {
        Token[] evaluationResult = Evaluator.EvaluateExpression(expression, context, false);

        // Stack should have one entry: the result
        if (evaluationResult.length != 1) {
            throw new IllegalArgumentException("Stack should only have a single entry at the end");
        }

        // Single entry should be a constant integer, double, or string value
        Token result = evaluationResult[0];
        if (!result.getType().isConstant()) {
            throw new IllegalArgumentException("Invalid token type after RPN evaluation");
        }

        // Return result
        return result;
    }

    /**
     * Statically evaluates a CompiledExpression, returning its simplified form.
     *
     * If the expression is fully statically evaluatable, the resultant `CompiledExpression` will contain only
     * a single Token, which is the result of evaluation.
     *
     *
     *
     * This will attempt to execute as much of the expression as possible, replacing constant operations (eg "3 + 4") with
     * their results.
     *
     * The end result will, ideally, be the simplest form of an expression possible, with all operations on constant values pre-resolved.
     *
     * For example, take the following expression: (3 + (4 - sqrt(sqrt(81))) - pow(2, 0) + (2 * a)
     *
     * This expression references a variable -- `a` -- which we will only be able to resolve at runtime, when we're hovering over an item.
     * However, it also contains many static math operations, including some functions -- `pow` and `sqrt`.
     *
     * Both functions called (`pow` and `sqrt`) are `constexpr` (meaning they can be evaluated without any game state),
     * and the arguments being fed into them are const themselves.
     *
     * sqrt(sqrt(81)) should simplify to sqrt(9) -> 3
     * pow(2,0) should simplify to 1
     *
     * Therefore, the entire above expression can be statically evaluated to:
     * (3 + (4 - 3)) - 1 + (2 * a) -> (4) - 1 + (2 * a) -> 3 + (2 * a)
     *
     * Which, in RPN form, would be: 2 a * 3 +
     *
     * That's a mere 5 tokens that we have to execute at runtime, instead of however many were in the original expression.
     */
    public static CompiledExpression EvaluateStatically(CompiledExpression expression, ExecutionContext context) {
        Token[] evaluationResult = Evaluator.EvaluateExpression(expression, context, true);

        // Stack should not be empty
        if (evaluationResult.length == 0) {
            throw new IllegalArgumentException("Stack empty??");
        }

        // Return result
        return new CompiledExpression(evaluationResult, expression.getExpressionText(), expression.isLegacy());
    }
}

package com.geel.customitemhovers.expressions.providers;

import com.geel.customitemhovers.expressions.functions.Function;
import com.geel.customitemhovers.expressions.models.Token;

public interface IFunctionProvider {
    Function findFunction(String name, Token[] arguments);
}

package com.geel.customitemhovers.expressions.providers;

public interface IVariableProvider {
    String resolveVariable(String name);
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.*;
import com.geel.customitemhovers.expressions.models.*;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import java.text.NumberFormat;
import java.util.Locale;

/***
 * Evaluates a hover text, replacing any expressions with their evaluated results.
 */
public class HoverEvaluator {
    /**
     * Evaluates a hover text for a given item.
     *
     * Evaluates expressions, returning a string ready to render into a hover box.
     *
     * @return A hover string, properly evaluated, ready to render into a hover box.
     */
    public static String Evaluate(ParsedHover hover, ExecutionContext context) {
        // If the ParsedHover has a condition, evaluate it -- if it returns a falsey value, don't render!
        if(hover.getCondition() != null) {
            Token conditionResult = EvaluationUtil.EvaluateAtRuntime(hover.getCondition(), context);
            if(conditionResult.getNumericValue().intValue() == 0) {
                return null;
            }
        }

        // No expressions? Nothing to evaluate
        if(hover.getExpressions().length == 0) {
            return hover.getHoverText();
        }

        return evaluateExpressions(hover, context);
    }

    private static String evaluateExpressions(ParsedHover hover, ExecutionContext context) {
        // Evaluate expressions (in the form ${expression} or <%expression%> (backwards-compat))
        StringBuilder ret = new StringBuilder();

        // For each expression in the hover text, copy the static text that precedes it,
        // then evaluate the expression and copy the result
        int pos = 0;
        for(int i = 0; i < hover.getExpressionLocations().length; i++) {
            int nextPos = hover.getExpressionLocations()[i];
            CompiledExpression expression = hover.getExpressions()[i];

            // Append all text preceding this expression
            ret.append(hover.getHoverText(), pos, nextPos);

            // Insert the expression
            ret.append(evaluateExpression(expression, context));

            // Update pos to nextPos
            pos = nextPos;
        }

        // After the last expression, there might be some static text left to copy
        if(pos < hover.getHoverText().length()) {
            ret.append(hover.getHoverText(), pos, hover.getHoverText().length());
        }

        return ret.toString();
    }

    private static String evaluateExpression(CompiledExpression expression, ExecutionContext context) {
        NumberFormat formatter = NumberFormat.getNumberInstance(Locale.getDefault());

        try {
            Token result = EvaluationUtil.EvaluateAtRuntime(expression, context);

            if(result.getType() == TokenType.STRING) {
                return result.getValue();
            }

            return formatter.format(result.getNumericValue());
        } catch (IllegalArgumentException e) {
            return "${" + expression.getExpressionText() + "}";
        }
    }
}

package com.geel.customitemhovers.models.hovers;

import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.google.gson.annotations.SerializedName;

/**
 * A parsed entry in a hoverfile.
 */
public class HoverDef {
    @SerializedName("ids")
    public int[] ItemIDs;

    @SerializedName("items")
    public String[] ItemNames;

    @SerializedName("items_regex")
    public String[] ItemNamesRegex;

    @SerializedName("condition")
    public String ConditionString;

    @SerializedName("hovers")
    public String[][] HoverTexts;

    /**
     * A condition expression, which controls whether or not this hover will display.
     */
    public CompiledExpression Condition;

    /**
     * An array of Hovers; each element in this array corresponds to an individual hover box that should be rendered.
     *
     * This is produced from `HoverTexts`, which is a 2D array of strings.
     * Each sub-array of strings in `HoverTexts` is treated as an array of lines which are concatenated together.
     */
    public ParsedHover[] ParsedHoverTexts;
}

package com.geel.customitemhovers.models.hovers;

import com.geel.customitemhovers.expressions.models.BaseExpression;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * A parsed Hover from a HoverFile.
 *
 * One ParsedHover is created for every 1D hover array in the 2D array of a HoverDef. That is, for every individual
 * hover box.
 *
 * This class exists as a caching mechanism for expressions; we want to parse (tokenize + shunting-yard) hover texts
 * as infrequently as possible (on load only).
 *
 * Therefore, `hoverText` contains a hoverbox text with all expressions removed.
 * `expressionLocations` is an ascending array of positions that expression results should be inserted,
 * and `expressions` is an array of expressions.
 *
 * To fully resolve `hoverText`, simply copy it, and then iterate through `expressionLocations` and `expressions`
 * simultaneously (their indexes align) -- evaluate each expression in turn, and insert the string result into
 * `hoverText` at the location indicated by `expressionLocations[i]`.
 */
@AllArgsConstructor
public class ParsedHover {
    /**
     * The text for this hover box, without any expressions.
     *
     * If any expressions were present in the original text, use `expressionLocations` and `expressions` to
     * build the final text.
     */
    @Getter
    private final String hoverText;

    @Getter
    private final Integer[] expressionLocations;

    @Getter
    private final CompiledExpression[] expressions;

    @Getter
    private final CompiledExpression condition;
}

package com.geel.customitemhovers.models.hovers;

import com.google.gson.annotations.SerializedName;

public class HoverFile {
    @SerializedName("is_hover_map")
    public String IsHoverMap;

    @SerializedName("hovers")
    public HoverDef[] Hovers;
}
package com.geel.customitemhovers.models.itemtables;

import lombok.Getter;

import java.util.HashMap;

/**
 * A collection of multiple ItemTables for a single item.
 *
 * An item can have multiple ItemTables if multiple ItemTableFiles contain ItemTables for the item.
 */
public class ItemTableCollection {
    @Getter
    private HashMap<String, ItemTable> itemTables;

    public ItemTableCollection() {
        this.itemTables = new HashMap<>();
    }

    public String resolveVariable(String variableName) {
        for (ItemTable i : itemTables.values()) {
            String val = i.getOrDefault(variableName, null);

            if (val == null) {
                continue;
            }

            return val;
        }

        return null;
    }
}

package com.geel.customitemhovers.models.itemtables;

import com.google.gson.annotations.SerializedName;

import java.util.Map;

public class ItemTableFile {
    @SerializedName("is_table_file")
    public String IsTableFile;

    @SerializedName("name")
    public String Name;

    @SerializedName("items")
    public Map<String, ItemTable> Items;
}
package com.geel.customitemhovers.models.itemtables;

import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

/**
 * A parsed entry in an ItemTableFile.
 *
 * Contains variables that are "attached" to items
 */
public class ItemTable extends HashMap<String, String> {
    @Getter
    @Setter
    private String itemName;

    @Getter
    @Setter
    private ItemTableFile parentFile;

    public String[] getAllNames() {
        ArrayList<String> ret = new ArrayList<>();
        ret.add(this.itemName);

        // Handle $also
        String also = this.getOrDefault("$also", null);
        if (also != null) {
            ret.addAll(Arrays.asList(also.split("\\|")));
        }

        return ret.toArray(new String[0]);
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.providers.IVariableProvider;
import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import lombok.Getter;

import java.util.Locale;

/**
 * Provides variables for an item hover.
 *
 * Basically just packages together an ItemTableCollection (containing variables that the user of the plugin has
 * set up) and a base ItemTable (generated for each item that is hovered over).
 */
public class CustomItemHoversVariableProvider implements IVariableProvider {
    @Getter
    private ItemTableCollection tableCollection;

    @Getter
    private ItemTable baseTable;

    public CustomItemHoversVariableProvider(
                                      ItemTableCollection tableCollection,
                                      ItemTable baseTable) {
        this.tableCollection = tableCollection;
        this.baseTable = baseTable;
    }

    public String resolveVariable(String variableName) {
        if(tableCollection != null) {
            variableName = variableName.toLowerCase(Locale.ROOT);

            // Try to resolve via explicit tables, then base table
            String tableCollectionRet = tableCollection.resolveVariable(variableName);
            if (tableCollectionRet != null) {
                return tableCollectionRet;
            }
        }

        if(baseTable == null) {
            return null;
        }

        return baseTable.getOrDefault(variableName, null);
    }
}

package com.geel.customitemhovers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

@ConfigGroup("customitemhovers")
public interface CustomItemHoversConfig extends Config {
    @ConfigSection(
            name = "Informational Messages",
            description = "Configures messages that the plugin posts to game chat",
            position = 2
    )
    static String messageSection = "messages";

    @ConfigItem(
            keyName = "hoverEnableHotReload",
            name = "Hot Reload",
            description = "Whether or not Hot Reload is enabled.",
            position = 1
    )
    default boolean hoverEnableHotReload() {
        return false;
    }

    @ConfigItem(
            keyName = "enableObsoleteMessage",
            name = "Deprecated Expression",
            description = "Display a message whenever your hover files are displayed if they contain obsolete expressions",
            section = messageSection,
            position = 1
    )
    default boolean enableObsoleteMessage() {
        return false;
    }

    @ConfigItem(
            keyName = "hoverDefaultColor",
            name = "Default Text Color",
            description = "The default text color for a hover when no color is specified",
            position = 2
    )
    default Color defaultHoverColor() {
        return new Color(238, 238, 238);
    }

    @ConfigItem(
            keyName = "openDirChatCommand",
            name = "Hover Directory Chat Command",
            description = "Chat command to open hoverfile directory in your file explorer",
            position = 3
    )
    default String openDirChatCommand() {
        return "openhoverdir";
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.functions.Function;
import com.geel.customitemhovers.expressions.functions.LambdaFixedArgsFunction;
import com.geel.customitemhovers.expressions.functions.LambdaVariadicFunction;
import com.geel.customitemhovers.expressions.models.ArgumentType;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import com.geel.customitemhovers.expressions.providers.IFunctionProvider;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.*;

/**
 * Provides functions to the expression engine.
 */
@Singleton
public class CustomItemHoversFunctionProvider implements IFunctionProvider {
    // A map(functionName -> map(numArguments -> listOfFunctions))
    @Getter
    private HashMap<String, HashMap<Integer, ArrayList<Function>>> functions;

    public Client client;

    public ItemManager itemManager;

    @Inject
    public CustomItemHoversFunctionProvider(Client client, ItemManager itemManager) {
        this.client = client;
        this.itemManager = itemManager;

        functions = new HashMap<>();
        prepareFunctions();
    }

    public Function findFunction(String name, Token[] arguments) {
        int numArgs = arguments.length;

        // Find the function by name. The result will be a map(numArgs -> list_of_functions)
        HashMap<Integer, ArrayList<Function>> numArgsMap = functions.getOrDefault(name, null);

        // If no functions found, obviously return null
        if (numArgsMap == null) {
            return null;
        }

        // Look for it in the fixed functions, then try variadic functions
        ArrayList<Function> fixedFunctions = numArgsMap.getOrDefault(numArgs, null);
        ArrayList<Function> variadicFunctions = numArgsMap.getOrDefault(-1, null);

        Function fixedFunction = searchFuncs(fixedFunctions, arguments);
        if (fixedFunction != null)
            return fixedFunction;

        return searchFuncs(variadicFunctions, arguments);
    }

    private Function searchFuncs(ArrayList<Function> functions, Token[] arguments) {
        if (functions == null)
            return null;

        for (Function func : functions) {
            if (func.argumentsMatch(arguments)) {
                return func;
            }
        }

        return null;
    }

    public void addFunction(Function f) {
        String name = f.getName();

        // Ensure that the overarching map has an entry for the function name
        if (!functions.containsKey(name)) {
            functions.put(name, new HashMap<>());
        }

        // Get the entry for the function name, and ensure the sub-map has an entry for the number of arguments
        HashMap<Integer, ArrayList<Function>> argumentsMap = functions.get(name);
        int argsHashCode = f.getArgumentsHashCode();
        if (!argumentsMap.containsKey(argsHashCode)) {
            argumentsMap.put(argsHashCode, new ArrayList<>(1));
        }

        // Get the entry for the number of arguments from the sub-map, and insert the function into the list
        ArrayList<Function> funcList = argumentsMap.get(argsHashCode);
        if (funcList.contains(f)) {
            throw new IllegalArgumentException("Function already exists");
        }

        funcList.add(f);
    }

    private void prepareFunctions() {
        // {inv}_contains() and {inv}_qty()
        prepareInventoryFunctions();

        // floor(), ceil(), pow(), max(), min(), abs()
        prepareMathFunctions();

        // len(), contains(), red(), green(), blue(), yellow(), rgb()
        prepareStringFunctions();

        // varbit(), varplayer(), varcint(), varcstr()
        prepareVarBitFunctions();

        // qtymult(), qtydivide(), qtydivideceil()
        prepareBackwardsCompatFunctions();
    }

    /**
     * Prepares inventory-related functions.
     *
     * EG, inv_contains(), bank_contains(), inv_qty(), etc
     */
    private void prepareInventoryFunctions() {
        inventoryFunction("inv", InventoryID.INVENTORY);
        inventoryFunction("bank", InventoryID.BANK);
        inventoryFunction("equipment", InventoryID.EQUIPMENT);
    }

    /**
     * Creates varbit-related functions
     */
    private void prepareVarBitFunctions() {
        // The varbit(varbitId) function returns the integer value of a varbit
        addFunction(new LambdaFixedArgsFunction("varbit", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            if(client == null) return Token.fromFalse();
            return Token.fromInt(client.getVarbitValue(args[0].getNumericValue().intValue()));
        }));

        // The varplayer(varPlayerId) function returns the integer value of a varplayer
        addFunction(new LambdaFixedArgsFunction("varplayer", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            if(client == null) return Token.fromFalse();
            return Token.fromInt(client.getVarpValue(args[0].getNumericValue().intValue()));
        }));

        // The varcint(varCIntId) function returns the integer value of a varcint
        addFunction(new LambdaFixedArgsFunction("varcint", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            if(client == null) return Token.fromFalse();
            return Token.fromInt(client.getVarcIntValue(args[0].getNumericValue().intValue()));
        }));

        // The varcstr(varCStrId) function returns the string value of a varcstr
        addFunction(new LambdaFixedArgsFunction("varcstr", TokenType.STRING, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            if(client == null) return Token.fromFalse();
            return Token.fromString(client.getVarcStrValue(args[0].getNumericValue().intValue()));
        }));
    }

    /**
     * Creates string- and color-related functions
     */
    private void prepareStringFunctions() {
        addFunction(new LambdaFixedArgsFunction("len", TokenType.INTEGER, new ArgumentType[]{ArgumentType.STRING}, true, (args, context) -> {
            return Token.fromInt(args[0].getValue().length());
        }));

        addFunction(new LambdaFixedArgsFunction("contains", TokenType.INTEGER, new ArgumentType[]{ArgumentType.STRING, ArgumentType.STRING}, true, (args, context) -> {
            return Token.fromInt(args[0].getValue().contains(args[1].getValue()) ? 1 : 0);
        }));

        // Colors
        // Wrapping functions -- red(), green(), blue(), yellow()
        simpleColorStringFunc("red", Color.RED);
        simpleColorStringFunc("green", Color.GREEN);
        simpleColorStringFunc("blue", Color.BLUE);
        simpleColorStringFunc("yellow", Color.YELLOW);

        // Tag *start* functions -- redStart(), greenStart(), blueStart(), yellowStart()
        simpleColorStringStartFunc("red", Color.RED);
        simpleColorStringStartFunc("green", Color.GREEN);
        simpleColorStringStartFunc("blue", Color.BLUE);
        simpleColorStringStartFunc("yellow", Color.YELLOW);

        // colorEnd()
        addFunction(new LambdaFixedArgsFunction("colorEnd", TokenType.STRING,
                new ArgumentType[]{},
                true,
                (args, context) -> {
                    return Token.fromString("</col>");
                }));

        // rgb()
        addFunction(new LambdaFixedArgsFunction("rgb", TokenType.STRING,
                new ArgumentType[]{ArgumentType.INTEGER, ArgumentType.INTEGER, ArgumentType.INTEGER, ArgumentType.STRING},
                true,
                (args, context) -> {
                    int r = args[0].getNumericValue().intValue() % 256;
                    int g = args[1].getNumericValue().intValue() % 256;
                    int b = args[2].getNumericValue().intValue() % 256;

                    Color color = new Color(r, g, b);
                    return Token.fromString(ColorUtil.wrapWithColorTag(args[3].getValue(), color));
                }));

        // rgbStart()
        addFunction(new LambdaFixedArgsFunction("rgbStart", TokenType.STRING,
                new ArgumentType[]{ArgumentType.INTEGER, ArgumentType.INTEGER, ArgumentType.INTEGER},
                true,
                (args, context) -> {
                    int r = args[0].getNumericValue().intValue() % 256;
                    int g = args[1].getNumericValue().intValue() % 256;
                    int b = args[2].getNumericValue().intValue() % 256;

                    Color color = new Color(r, g, b);
                    return Token.fromString(ColorUtil.colorTag(color));
                }));
    }

    /**
     * Creates the floor(), ceil(), pow(), max(), min() functions
     */
    private void prepareMathFunctions() {
        // abs(x) takes a number and returns the absolute value
        addFunction(new LambdaFixedArgsFunction("abs", TokenType.DOUBLE, new ArgumentType[]{ArgumentType.DOUBLE}, true, (args, context) -> {
            return Token.fromDouble(Math.abs(args[0].getNumericValue().doubleValue()));
        }));
        addFunction(new LambdaFixedArgsFunction("abs", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, true, (args, context) -> {
            return Token.fromInt(Math.abs(args[0].getNumericValue().intValue()));
        }));

        // floor(x) takes a double and returns an integer
        addFunction(new LambdaFixedArgsFunction("floor", TokenType.INTEGER, new ArgumentType[]{ArgumentType.DOUBLE},true, (args, context) -> {
            return Token.fromInt((int) Math.floor(args[0].getNumericValue().doubleValue()));
        }));

        // ceil(x) takes a double and returns an integer
        addFunction(new LambdaFixedArgsFunction("ceil", TokenType.INTEGER, new ArgumentType[]{ArgumentType.DOUBLE},true, (args, context) -> {
            return Token.fromInt((int) Math.ceil(args[0].getNumericValue().doubleValue()));
        }));

        // pow(x) takes two numbers and returns the first to the power of the second as a double
        addFunction(new LambdaFixedArgsFunction("pow", TokenType.DOUBLE, new ArgumentType[]{ArgumentType.DOUBLE, ArgumentType.DOUBLE}, true, (args, context) -> {
            return Token.fromDouble(Math.pow(args[0].getNumericValue().doubleValue(), args[1].getNumericValue().doubleValue()));
        }));

        // max(...) takes in any amount of numbers and returns the largest one
        addFunction(new LambdaVariadicFunction("max", TokenType.DOUBLE, ArgumentType.DOUBLE, new ArgumentType[]{ArgumentType.DOUBLE}, true, (args, context) -> {
            double max = Double.MIN_VALUE;

            for(Token t : args) {
                double value = t.getNumericValue().doubleValue();
                if(value > max) {
                    max = value;
                }
            }

            return Token.fromDouble(max);
        }));

        // min(...) takes in any amount of numbers and returns the smallest one
        addFunction(new LambdaVariadicFunction("min", TokenType.DOUBLE, ArgumentType.DOUBLE, new ArgumentType[]{ArgumentType.DOUBLE}, true, (args, context) -> {
            double min = Double.MAX_VALUE;

            for(Token t : args) {
                double value = t.getNumericValue().doubleValue();
                if(value < min) {
                    min = value;
                }
            }

            return Token.fromDouble(min);
        }));
    }

    /**
     * Creates functions which exist for backwards compatibility with the previous (terrible) "expression" engine
     */
    private void prepareBackwardsCompatFunctions() {
        // THE FOLLOWING FUNCTIONS ARE ONLY PRESENT FOR BACKWARDS COMPATIBILITY WITH THE OLD SHITTY SYSTEM
        // qtymult(x) takes an integer and returns an integer
        addFunction(new LambdaFixedArgsFunction("qtymult", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            String numInStackStr = context.resolveVariable("qty");
            if(numInStackStr == null) return Token.fromInt(0);

            return Token.fromInt(Integer.parseInt(numInStackStr) * args[0].getNumericValue().intValue());
        }));
        // qtydivide(x) takes an integer and returns an integer
        addFunction(new LambdaFixedArgsFunction("qtydivide", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            String numInStackStr = context.resolveVariable("qty");
            if(numInStackStr == null) return Token.fromInt(0);

            return Token.fromInt(Integer.parseInt(numInStackStr) / args[0].getNumericValue().intValue());
        }));
        // qtydivideceil(x) takes an integer and returns an integer
        addFunction(new LambdaFixedArgsFunction("qtydivideceil", TokenType.INTEGER, new ArgumentType[]{ArgumentType.INTEGER}, (args, context) -> {
            String numInStackStr = context.resolveVariable("qty");
            if(numInStackStr == null) return Token.fromInt(0);

            return Token.fromInt((int) Math.ceil((double) Integer.parseInt(numInStackStr) / (double) args[0].getNumericValue().intValue()));
        }));
    }

    /**
     * Implements the logic for the `{inv}_qty()` functions
     */
    private Token containerQty(Token[] args, ExecutionContext context, InventoryID inventoryID, boolean shortCircuitOnFind) {
        if (client == null || client.getLocalPlayer() == null)
            return Token.fromInt(0);

        ItemContainer container = client.getItemContainer(inventoryID);
        if (container == null) {
            return Token.fromInt(0);
        }

        // Loop through the arguments, constructing a list of item IDs
        Set<Integer> itemIDs = new HashSet<>(args.length);
        for(Token arg : args) {
            if (arg.getType() == TokenType.STRING) {
                for(int itemId : ItemNameMap.GetItemIDs(arg.getValue())) {
                    itemIDs.add(itemId);
                }
            } else {
                int itemID = arg.getNumericValue().intValue();
                if (itemManager != null) itemID = itemManager.canonicalize(itemID);

                itemIDs.add(itemID);
            }
        }

        // No item IDs are relevant -- so zero
        if (itemIDs.size() == 0)
            return Token.fromInt(0);

        // Find the sum of quantities of items in the given inventory which are represented in `itemIDs`
        int count = 0;
        for (Item item : container.getItems()) {
            int canonicalId = itemManager == null ? item.getId() : itemManager.canonicalize(item.getId());
            if (itemIDs.contains(canonicalId)) {
                count += item.getQuantity();

                // If we should short-circuit when we find the first match, then... do that.
                if(shortCircuitOnFind) {
                    break;
                }
            }
        }

        return Token.fromInt(count);
    }

    /**
     * Implements the logic for the `{inv}_contains()` functions
     */
    private Token containerContainsAnyItem(Token[] args, ExecutionContext context, InventoryID inventoryID) {
        Token qty = containerQty(args, context, inventoryID, true);
        return Token.fromBool(qty.getNumericValue().intValue() > 0);
    }

    /**
     * Creates the `{inventory}_qty()` and `{inventory}_contains()` functions for a given inventory
     */
    private void inventoryFunction(String prefix, InventoryID inventoryID) {
        String containsFuncName = prefix + "_contains";
        String qtyFuncName = prefix + "_qty";

        // {prefix}_contains(idOrName, ...) takes variable item IDs/names and returns 1 if any of said items are in the specified inventory
        addFunction(new LambdaVariadicFunction(containsFuncName, TokenType.INTEGER, ArgumentType.ANY, null, (args, context) -> {
            return containerContainsAnyItem(args, context, inventoryID);
        }));

        // {prefix}_qty(idOrName, ...) takes variable item IDs/names and returns the number of items with any of said IDs in the given inventory
        addFunction(new LambdaVariadicFunction(qtyFuncName, TokenType.INTEGER, ArgumentType.ANY, null, (args, context) -> {
            return containerQty(args, context, inventoryID, false);
        }));
    }

    private void simpleColorStringFunc(String colorName, Color color) {
        addFunction(new LambdaFixedArgsFunction(colorName, TokenType.STRING, new ArgumentType[]{ArgumentType.ANY}, true, (args, context) -> {
            return Token.fromString(ColorUtil.wrapWithColorTag(args[0].getValue(), color));
        }));
    }

    private void simpleColorStringStartFunc(String colorName, Color color) {
        addFunction(new LambdaFixedArgsFunction(colorName + "Start", TokenType.STRING, new ArgumentType[]{}, true, (args, context) -> {
            return Token.fromString(ColorUtil.colorTag(color));
        }));
    }
}

package com.geel.customitemhovers;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

import java.lang.reflect.Field;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Stores an (item name -> [item ids]) and (item id -> item name) mapping for all items in game
 */
@Slf4j
public class ItemNameMap {
    //Map of (item name -> [item id, ...])
    private final static Map<String, ArrayList<Integer>> itemNameToIDs = new HashMap<>();

    /**
     * Prepare map of item names to IDs
     *
     * @param client      Reference to RL Client; used to fetch total number of items
     * @param itemManager Reference to ItemManager; used to fetch item compositions
     */
    public static void PrepareMap(Client client, ItemManager itemManager) {
        //Don't do anything if already prepared
        if (itemNameToIDs.size() > 0)
            return;

        //Clear just to be safe
        itemNameToIDs.clear();

        Set<Integer> processedIDs = new HashSet<>();

        for (int i = 0; i < client.getItemCount(); i++) {
            int canonicalID = itemManager.canonicalize(i);

            if(processedIDs.contains(canonicalID))
                continue;

            processedIDs.add(canonicalID);

            ItemComposition comp = itemManager.getItemComposition(canonicalID);
            String itemName = comp.getName();

            if(itemName.toLowerCase().equals("null")) {
                continue;
            }

            //Create list for item name if it doesn't exist
            if (!itemNameToIDs.containsKey(itemName)) {
                itemNameToIDs.put(itemName, new ArrayList<>(1));
            }

            itemNameToIDs.get(itemName).add(canonicalID);
        }
    }

    /**
     * Returns all item IDs which correspond to the given string name
     *
     * @param itemName The name of an entry in the `ItemID` class, eg, "PINEAPPLE_SAPLING"
     */
    public static int[] GetItemIDs(String itemName) {
        ArrayList<Integer> itemIDs = itemNameToIDs.getOrDefault(itemName, new ArrayList<>(0));

        //The lack of a sane toArray() function is going to kill me
        int[] ret = new int[itemIDs.size()];

        for (int i = 0; i < itemIDs.size(); i++) {
            ret[i] = itemIDs.get(i);
        }

        return ret;
    }


    /**
     * Returns all IDs of items whose names match the given regex
     *
     * @param itemNameRegex A regex string to match item names against
     * @return A list of all item IDs whose names match the given regex
     */
    public static ArrayList<Integer> GetItemIDsRegex(String itemNameRegex) {
        ArrayList<Integer> ret = new ArrayList<>(1);
        Pattern finder = Pattern.compile(itemNameRegex);

        if (finder == null) {
            return ret;
        }

        for (String entry : itemNameToIDs.keySet()) {
            if (!finder.matcher(entry).matches())
                continue;

            for (int itemID : itemNameToIDs.get(entry)) {
                //O(n^2), sue me (don't)
                if (!ret.contains(itemID))
                    ret.add(itemID);
            }
        }

        return ret;
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.*;
import com.geel.customitemhovers.expressions.Compiler;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.providers.IFunctionProvider;
import com.geel.customitemhovers.models.hovers.HoverDef;
import com.geel.customitemhovers.models.hovers.HoverFile;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.stream.Stream;

@Slf4j
public class HoverFileParser {
    @Inject
    private Gson gson;

    @Inject
    private CustomItemHoversFunctionProvider functionProvider;

    public ArrayList<HoverFile> readHoverFiles(Path dirPath) {
        ArrayList<HoverFile> ret = new ArrayList<>();

        if (!Files.isDirectory(dirPath) || !Files.isReadable(dirPath)) {
            return ret;
        }

        try {
            Stream fileStream = Files.list(dirPath);
            for (Iterator it = fileStream.iterator(); it.hasNext(); ) {
                Path p = (Path) it.next();

                //Ensure it's a regular readable file
                if (!Files.isRegularFile(p) || !Files.isReadable(p))
                    continue;

                //Ensure it's a json file
                if (!p.toString().endsWith(".json"))
                    continue;

                HoverFile file = parseHoverFile(p);

                //Must absolutely be a hover file
                if (file == null || file.IsHoverMap == null || !file.IsHoverMap.equals("absolutely"))
                    continue;

                //Post-process (right now just combine arrays of text into single strings)
                postProcessHoverFile(file);

                ret.add(file);
            }
        } catch (IOException e) {
            log.error(e.toString());

            return ret;
        }

        return ret;
    }

    private HoverFile parseHoverFile(Path hoverFile) {
        try {
            byte[] fileBytes = Files.readAllBytes(hoverFile);
            String fileString = new String(fileBytes);

            return gson.fromJson(fileString, HoverFile.class);
        } catch (Exception e) {
            log.error(e.toString());
            return null;
        }
    }

    private void postProcessHoverFile(HoverFile f) {
        for (HoverDef d : f.Hovers) {
            parseHoverDefHovers(d);
            parseHoverDefCondition(d);
        }
    }

    private final StringBuilder _hoverBuilder = new StringBuilder();

    private void parseHoverDefHovers(HoverDef d) {
        d.ParsedHoverTexts = new ParsedHover[d.HoverTexts.length];

        int i = 0;
        for (String[] hovers : d.HoverTexts) {
            CompiledExpression hoverBlockCondition = null; // Condition for whether this hoverblock should render
            int startPoint = 0; // Which entry in `hovers` to start reading from -- the first could be a condition
            _hoverBuilder.setLength(0); //clear stringbuilder but keep memory allocated

            // First, detect if the first entry indicates a condition.
            if (hovers.length > 0 && hovers[0].startsWith("?${") && hovers[0].endsWith("}")) {
                //Try to parse the condition
                hoverBlockCondition = compileSingleExpression(hovers[0].substring(1));

                // If the condition parses and is valid, ignore the first entry when building the hover.
                if (hoverBlockCondition != null) {
                    startPoint++;
                }
            }

            // Collapse each sub-array into a <br/>-delimited single String
            for (int j = startPoint; j < hovers.length; j++) {
                if (j != startPoint)
                    _hoverBuilder.append("</br>");
                _hoverBuilder.append(hovers[j]);
            }

            String concatenatedHovers = _hoverBuilder.toString();
            _hoverBuilder.setLength(0);

            // Now, find all expressions in the hoverText
            ArrayList<CompiledExpression> expressions = new ArrayList<>();
            ArrayList<Integer> expressionLocations = new ArrayList<>();

            int offset = 0;
            int curPos = 0;
            while (curPos < concatenatedHovers.length()) {
                char c = concatenatedHovers.charAt(curPos);

                // If not a tag opener, or the end of the string, just add to output
                if ((c != '$' && c != '<') || curPos == concatenatedHovers.length() - 1) {
                    _hoverBuilder.append(c);
                    curPos++;
                    continue;
                }

                // Ensure this is a tag opener
                char nextChar = concatenatedHovers.charAt(curPos + 1);
                if ((c == '$' && nextChar != '{') || (c == '<' && nextChar != '%')) {
                    // Not a tag opener. Just continue.
                    _hoverBuilder.append(c);
                    _hoverBuilder.append(nextChar);
                    curPos += 2;
                    continue;
                }

                // We have a tag opener. Try to read the expression.
                Tokenizer tokenizer = new Tokenizer(concatenatedHovers, curPos);
                CompiledExpression compiledExpression = null;
                try {
                    compiledExpression = Compiler.Compile(tokenizer.tokenize());
                    compiledExpression = EvaluationUtil.EvaluateStatically(compiledExpression, new ExecutionContext(functionProvider, null));
                } catch (IllegalArgumentException e) {
                }

                int len = tokenizer.getNumRead();
                int endPos = curPos + len;

                // If a failed parse, just add the raw expression text
                if (compiledExpression == null) {
                    String expression = concatenatedHovers.substring(curPos, endPos);
                    curPos = endPos;
                    _hoverBuilder.append(expression);
                    continue;
                }

                // If a successful parse, skip ahead to endPos
                expressionLocations.add(curPos - offset);
                expressions.add(compiledExpression);
                curPos = endPos;
                offset += len;
            }

            d.ParsedHoverTexts[i++] = new ParsedHover(
                    _hoverBuilder.toString(),
                    expressionLocations.toArray(new Integer[0]),
                    expressions.toArray(new CompiledExpression[0]),
                    hoverBlockCondition
            );
        }
    }

    private void parseHoverDefCondition(HoverDef hover) {
        if (hover.ConditionString == null || hover.ConditionString.length() == 0) {
            return;
        }

        if (!hover.ConditionString.startsWith("${") && !hover.ConditionString.startsWith("<%")) {
            hover.ConditionString = "${" + hover.ConditionString + "}";
        }

        // TODO: If static eval returns a constant value, we can resolve the condition here
        //      (either remove the condition if it should always be shown, or remove the hover if it should never be shown)
        hover.Condition = compileSingleExpression(hover.ConditionString);
    }

    private CompiledExpression compileSingleExpression(String expression) {
        try {
            Tokenizer tokenizer = new Tokenizer(expression, 0);
            CompiledExpression compiled = Compiler.Compile(tokenizer.tokenize());
            return EvaluationUtil.EvaluateStatically(compiled, new ExecutionContext(functionProvider, null));
        } catch (IllegalArgumentException e) {
            log.error("Failed to parse hover condition");
            return null;
        }
    }
}

package com.geel.customitemhovers;

import javax.inject.Inject;

import com.geel.customitemhovers.expressions.ExecutionContext;
import com.geel.customitemhovers.expressions.EvaluationUtil;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.models.hovers.HoverFile;
import com.geel.customitemhovers.models.hovers.HoverDef;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;

import java.awt.*;
import java.io.IOException;
import java.nio.file.*;
import java.util.*;

import static java.nio.file.StandardWatchEventKinds.*;

@Slf4j
@PluginDescriptor(
        name = "Custom Item Hovers",
        description = "Enables custom item hovers. Read github page.",
        tags = {"custom", "item", "hovers", "tooltips"},
        enabledByDefault = true
)
public class CustomItemHoversPlugin extends Plugin {
    private static final String PLUGIN_FOLDER_NAME = "customitemhovers";

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ItemManager itemManager;

    @Inject
    private CustomItemHoversOverlay overlay;

    @Inject
    private CustomItemHoversConfig config;

    @Inject
    private Gson gson;

    @Inject
    private HoverFileParser parser;

    @Inject
    private ItemTableManager itemTableManager;

    @Inject
    private CustomItemHoversFunctionProvider functionProvider;

    @Provides
    CustomItemHoversConfig getConfig(ConfigManager configManager) {
        return configManager.getConfig(CustomItemHoversConfig.class);
    }

    //Map between an Item ID and all of its associated HoverDefs.
    public Map<Integer, ArrayList<HoverDef>> hovers = new HashMap<>();

    // Watchers of the hover directory
    WatchService hoverWatcher;
    WatchKey hoverWatchKey;
    WatchKey tableWatchKey;

    @Override
    protected void startUp() throws Exception {
        prepareHoverFolder();

        //Invoke this on the client thread because `itemManager.canonicalize()` must be run in the client thread
        clientThread.invokeLater(() -> {
            prepareItemNameMap();
            prepareItemTables();
            prepareHoverMap();
            prepareHoverWatcher();
        });

        overlayManager.add(overlay);
    }

    @Override
    protected void shutDown() throws Exception {
        if (hoverWatcher != null)
            hoverWatcher.close();

        overlayManager.remove(overlay);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged ev) {
        if (ev.getGroup().equals("customitemhovers") && ev.getKey().equals("hoverEnableHotReload")) {
            if (config.hoverEnableHotReload()) {
                clientThread.invoke(this::prepareHoverWatcher);
            } else {
                clientThread.invoke(this::stopHoverWatcher);
            }
        }
    }

    @Subscribe
    public void onCommandExecuted(CommandExecuted commandExecuted) {
        if (!commandExecuted.getCommand().equals(config.openDirChatCommand())) {
            return;
        }

        Path hoverPath = getHoverPath();

        if (hoverPath == null) {
            return;
        }

        try {
            Desktop.getDesktop().open(hoverPath.toFile());
        } catch (Exception e) {
            log.error("Got exception opening hover folder", e);
        }
    }

    /**
     * Returns an array of hover texts that should be rendered for a given item
     */
    private Item lastItem = null;
    private String[] lastHovers = null;

    /**
     * Resets the cache of the item hover.
     *
     * This system seems badly coupled. I should refactor this. Blech.
     */
    public void resetHoveredItemCache() {
        lastHovers = null;
        lastItem = null;
    }

    /**
     *
     * For the given Item in a supported container, returns a String array, each representing
     * HTML that should be rendered in a hover box.
     *
     * Fully processes all expressions contained within hover texts.
     */
    public String[] getItemHovers(Item item) {
        // Cache hovers
        // TODO: FIXME: This prevents users from creating hovers which update dynamically without having to re-hover
        if (item.equals(lastItem)) {
            return lastHovers;
        }

        //Do a hot-reload if we should
        if (config.hoverEnableHotReload()) {
            if (hoverWatcherTriggered()) {
                prepareHoverMap();
            }

            if (tableWatcherTriggered()) {
                prepareItemTables();
            }
        }

        // Canonicalize the item and get its composition
        int itemID = itemManager.canonicalize(item.getId());
        ItemComposition comp = itemManager.getItemComposition(itemID);

        //If item's ID is not in `hovers`, it has no hovers.
        if (!hovers.containsKey(itemID))
            return new String[0];

        // Prepare expression execution context
        ItemTableCollection tableCollection = itemTableManager.getCollectionForItem(comp.getName());
        ItemTable baseTable = itemTableManager.getBaseTableForItemAndPlayer(item, client);
        CustomItemHoversVariableProvider variableProvider = new CustomItemHoversVariableProvider(tableCollection, baseTable);
        ExecutionContext context = new ExecutionContext(functionProvider, variableProvider);

        //For each hover associated with this item, add its transformed text to the resultant array
        boolean obsoleteExpressionDetected = false;
        ArrayList<String> ret = new ArrayList<>();
        for (HoverDef hoverDef : hovers.get(itemID)) {
            // If the hoverdef has a condition, evaluate it first
            if(hoverDef.Condition != null) {
                Token conditionResult = EvaluationUtil.EvaluateAtRuntime(hoverDef.Condition, context);
                if(conditionResult.getNumericValue().intValue() == 0) {
                    continue;
                }
            }

            for (ParsedHover parsedHover : hoverDef.ParsedHoverTexts) {
                String transformed = HoverEvaluator.Evaluate(parsedHover, context);
                if(transformed == null) {
                    continue;
                }

                ret.add(transformed);

                // Warn about obsolete expressions
                if (config.enableObsoleteMessage()) {
                    obsoleteExpressionDetected = obsoleteExpressionDetected ||
                            Arrays
                                    .stream(parsedHover.getExpressions())
                                    .anyMatch(e -> e.isLegacy());
                }
            }
        }

        // Warn about obsolete expressions if we find any
        if(obsoleteExpressionDetected) {
            warnObsoleteExpression();
        }

        //Turn `ret` into an array from an ArrayList
        String[] retArr = new String[ret.size()];
        retArr = ret.toArray(retArr);

        lastItem = item;
        lastHovers = retArr;

        return retArr;
    }

    private void warnObsoleteExpression() {
        client.addChatMessage(ChatMessageType.GAMEMESSAGE,
                "",
                "<col=e74c3c>[Custom Item Hovers]</col> " +
                        "Obsolete expression detected. " +
                        "See the plugin support page (or GitHub) to learn about the new, better expression system. " +
                        "Turn this message off in settings.",
                "");
    }

    /**
     * Parses the config's hover dirs path and returns it if it's a readable directory.
     *
     * @return Path|null The path if it's a valid, readable directory Path, null otherwise.
     */
    public Path getHoverPath() {
        return Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath() + "/" + PLUGIN_FOLDER_NAME);
    }

    /**
     * Parses the config's table path and returns it if it's a readable directory.
     *
     * @return Path|null The path if it's a valid, readable directory Path, null otherwise.
     */
    public Path getTablePath() {
        return Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath() + "/" + PLUGIN_FOLDER_NAME + "/tables");
    }

    /**
     * Prepare ItemNameMap
     */
    protected void prepareItemNameMap() {
        ItemNameMap.PrepareMap(client, itemManager);
    }

    /**
     * Creates, if necessary, the `customitemhovers` folder in the user's `.runelite` directory
     *
     * @throws IOException
     */
    protected void prepareHoverFolder() throws IOException {
        Path rlPath = RuneLite.RUNELITE_DIR.toPath();

        if (!Files.isDirectory(rlPath) || !Files.isReadable(rlPath) || !Files.isWritable(rlPath)) {
            log.error("[CUSTOMITEMHOVERS] Bad .runelite path");
            return;
        }

        // Ensure that `/customitemhovers` and `/customitemhovers/tables` exist in RL directory
        prepareSpecificHoverFolder(getHoverPath());
        prepareSpecificHoverFolder(getTablePath());
    }

    /**
     * Creates a directory if it doesn't exist, logging an error if creation failed
     */
    private void prepareSpecificHoverFolder(Path path) throws IOException {
        // Create directory if it doesn't exist
        if (Files.notExists(path)) {
            Files.createDirectory(path);
        }

        // Make sure we actually created the directory and it's readable
        if (!Files.isDirectory(path) || !Files.isReadable(path)) {
            log.error("[CUSTOMITEMHOVERS] Couldn't ensure path " + path);
        }
    }

    /**
     * Reads all files from the `customitemhovers` directory, parses them, and
     * prepares a map of (itemID, hovers) for each item that has a hover.
     */
    protected void prepareHoverMap() {
        hovers.clear();

        //Read all hover files
        ArrayList<HoverFile> hoverFiles = parser.readHoverFiles(getHoverPath());

        for (HoverFile f : hoverFiles) {
            for (HoverDef d : f.Hovers) {
                //Compute which item IDs this HoverDef is attached to. This fills in `d.ItemIDs`.
                parseHoverDefNames(d);

                //Add this HoverDef to the map for every Item ID it represents
                for (int itemID : d.ItemIDs) {
                    if (!hovers.containsKey(itemID))
                        hovers.put(itemID, new ArrayList<>());

                    ArrayList<HoverDef> curArr = hovers.get(itemID);
                    curArr.add(d);
                }
            }
        }
    }

    /**
     * TODO document
     */
    protected void prepareItemTables() {
        itemTableManager.reparseItemDatabase(getTablePath());
    }

    /**
     * @return True if the `customitemhovers` directory has changed since the last time this function was called
     */
    private boolean hoverWatcherTriggered() {
        if (hoverWatchKey == null || !hoverWatchKey.isValid())
            return false;

        //If we've received any filesystem events, then assume it changed
        boolean triggered = hoverWatchKey.pollEvents().size() > 0;

        //Enable more events to be queued
        hoverWatchKey.reset();

        return triggered;
    }

    /**
     * @return True if the `customitemhovers` directory has changed since the last time this function was called
     */
    private boolean tableWatcherTriggered() {
        if (tableWatchKey == null || !tableWatchKey.isValid())
            return false;

        //If we've received any filesystem events, then assume it changed
        boolean triggered = tableWatchKey.pollEvents().size() > 0;

        //Enable more events to be queued
        tableWatchKey.reset();

        return triggered;
    }

    /**
     * Set up a filesystem watcher on the `customitemhovers` directory.
     * <p>
     * This enables hot-reloading.
     */
    private void prepareHoverWatcher() {
        if (!config.hoverEnableHotReload())
            return;

        Path hoverPath = getHoverPath();
        Path tablePath = getTablePath();

        //Nothing to watch
        if (hoverPath == null)
            return;

        try {
            hoverWatcher = FileSystems.getDefault().newWatchService();

            hoverWatchKey = hoverPath.register(hoverWatcher,
                    ENTRY_CREATE,
                    ENTRY_DELETE,
                    ENTRY_MODIFY);

            if (tablePath != null) {
                tableWatchKey = tablePath.register(hoverWatcher,
                        ENTRY_CREATE,
                        ENTRY_DELETE,
                        ENTRY_MODIFY);
            }
        } catch (Exception e) {

        }
    }

    /**
     * Closes `hoverWatcher` and `hoverWatchKey`, if possible.
     */
    private void stopHoverWatcher() {
        if (hoverWatcher != null) {
            try {
                hoverWatcher.close();
            } catch (IOException e) {
                log.error("[CUSTOMITEMHOVERS]: exception closing hover watcher", e);
            }

            hoverWatcher = null;
        }

        if (hoverWatchKey != null) {
            hoverWatchKey.cancel();
            hoverWatchKey = null;
        }

        if (tableWatchKey != null) {
            tableWatchKey.cancel();
            tableWatchKey = null;
        }
    }

    /**
     * Computes all item IDs that a HoverDef is targeting, and stores the results in
     * its `ItemIDs` member variable.
     *
     * @param d HoverDef to parse names for
     */
    private void parseHoverDefNames(HoverDef d) {
        Set<Integer> itemIDs = new HashSet<>();

        //If ItemNamesRegex is non-empty, insert all item IDs whose name matches any of the given regexes
        if (d.ItemNamesRegex != null) {
            for (String name : d.ItemNamesRegex) {
                itemIDs.addAll(ItemNameMap.GetItemIDsRegex(name));
            }
        }

        //If ItemNames is non-empty, insert all item IDs with the exact name(s) specified
        if (d.ItemNames != null) {
            for (String name : d.ItemNames) {
                for (int id : ItemNameMap.GetItemIDs(name)) {
                    itemIDs.add(id);
                }
            }
        }

        //If ItemIDs has any IDs specified, copy them in
        if (d.ItemIDs != null && d.ItemIDs.length > 0) {
            for (int id : d.ItemIDs) {
                itemIDs.add(id);
            }
        }

        //Convert `itemIDs` into an array and store it in `d.ItemIDs`
        d.ItemIDs = new int[itemIDs.size()];
        int i = 0;
        for (Iterator<Integer> it = itemIDs.iterator(); it.hasNext(); ) {
            int id = it.next();
            d.ItemIDs[i++] = id;
        }
    }
}

package com.geel.customitemhovers;

import net.runelite.api.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static net.runelite.api.MenuAction.CC_OP;
import static net.runelite.api.MenuAction.WIDGET_TARGET;
import static net.runelite.api.MenuAction.ITEM_USE;
import static net.runelite.api.MenuAction.ITEM_FIRST_OPTION;
import static net.runelite.api.MenuAction.ITEM_SECOND_OPTION;
import static net.runelite.api.MenuAction.ITEM_THIRD_OPTION;
import static net.runelite.api.MenuAction.ITEM_FOURTH_OPTION;
import static net.runelite.api.MenuAction.ITEM_FIFTH_OPTION;

class CustomItemHoversOverlay extends Overlay
{
	//Interface IDs for the standard inventory container
	private static final Set<Integer> INVENTORY_COMPONENT_IDS = new HashSet<>(
			Arrays.asList(
					InterfaceID.INVENTORY,
					InterfaceID.BANK_INVENTORY,
					InterfaceID.SEED_VAULT_INVENTORY,
					InterfaceID.EXPLORERS_RING
			)
	);

	//Interface IDs which an item hover MenuAction will be related to
	private static final Set<Integer> VALID_INTERFACE_IDS = new HashSet<>(
			Arrays.asList(InterfaceID.INVENTORY, InterfaceID.BANK, InterfaceID.BANK_INVENTORY,
					InterfaceID.SEED_VAULT, InterfaceID.SEED_VAULT_INVENTORY, InterfaceID.EXPLORERS_RING)
	);

	//MenuActions which indicate an item is being hovered on
	private static final Set<MenuAction> VALID_MENU_ACTIONS = new HashSet<>(
			Arrays.asList(CC_OP, ITEM_USE, WIDGET_TARGET, ITEM_FIRST_OPTION, ITEM_SECOND_OPTION,
					ITEM_THIRD_OPTION, ITEM_FOURTH_OPTION, ITEM_FIFTH_OPTION)
	);

	private final Client client;
	private final CustomItemHoversConfig config;
	private final CustomItemHoversPlugin plugin;
	private final TooltipManager tooltipManager;

	@Inject
	CustomItemHoversOverlay(Client client, CustomItemHoversPlugin plugin, CustomItemHoversConfig config, TooltipManager tooltipManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.tooltipManager = tooltipManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		// If the player is not hovering over any items, reset the cache
		if(!innerRender(graphics)) {
			plugin.resetHoveredItemCache();
		}

		return null;
	}

	/**
	 * Handles the hover.
	 *
	 * Returns true if the user is presently hovering over any item, inlcuding those without a hover.
	 */
	private boolean innerRender(Graphics2D graphics) {
		//Don't display anything if a right-click menu is open.
		if (client.isMenuOpen())
			return false;

		//Get the current menu entries; if there aren't any, return.
		final MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length <= 0)
			return false;

		final MenuEntry lastEntry = menuEntries[menuEntries.length - 1];
		final MenuAction action = lastEntry.getType();
		final Widget widget = lastEntry.getWidget();

		if(widget == null) {
			return false;
		}

		final int widgetId = widget.getId();
		final int interfaceId = widgetId >>> 16;

		if (!VALID_MENU_ACTIONS.contains(action))
			return false;

		if (!VALID_INTERFACE_IDS.contains(interfaceId))
			return false;

		//We should now display a hover.
		ItemContainer container = getContainer(interfaceId);

		if (container == null)
			return false;

		//Get the Item from the Container
		final int containerItemIndex = lastEntry.getParam0();
		final Item item = container.getItem(containerItemIndex);
		if (item == null)
			return false;

		//Get the hovers for this item ID
		String[] hoverTexts = plugin.getItemHovers(item);
		if (hoverTexts.length == 0)
			return true;

		for (String s : hoverTexts) {
			tooltipManager.add(new Tooltip(ColorUtil.prependColorTag(s, config.defaultHoverColor())));
		}

		return true;
	}

	private ItemContainer getContainer(int interfaceId)
	{
		if (INVENTORY_COMPONENT_IDS.contains(interfaceId))
			return client.getItemContainer(InventoryID.INVENTORY);
		else if (interfaceId == InterfaceID.BANK)
			return client.getItemContainer(InventoryID.BANK);
		else if (interfaceId == InterfaceID.SEED_VAULT) {
			return client.getItemContainer(InventoryID.SEED_VAULT);
		}

		return null;
	}
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import com.geel.customitemhovers.models.itemtables.ItemTableFile;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.stream.Stream;

@Singleton
@Slf4j
/**
 * Manages ItemTables for the plugin.
 *
 * Responsible for loading, parsing, storing, and providing ItemTables from JSON files.
 */
public class ItemTableManager {
    @Inject
    private Gson gson;

    @Inject
    private ItemManager itemManager;

    private HashMap<String, ItemTableFile> parsedFiles = new HashMap<>();
    private HashMap<String, ItemTableCollection> itemMap = new HashMap<>();

    /**
     * Clear the in-memory ItemTable database and load it from scratch
     */
    public void reparseItemDatabase(Path tablePath) {
        if (!Files.isDirectory(tablePath) || !Files.isReadable(tablePath)) {
            return;
        }

        HashMap<String, ItemTableFile> newParsedFiles = new HashMap<>();
        HashMap<String, ItemTableCollection> newItemMap = new HashMap<>();

        try {
            Stream fileStream = Files.list(tablePath);
            for (Iterator it = fileStream.iterator(); it.hasNext(); ) {
                Path p = (Path) it.next();

                //Ensure it's a regular readable file
                if (!Files.isRegularFile(p) || !Files.isReadable(p))
                    continue;

                //Ensure it's a json file
                if (!p.toString().endsWith(".json"))
                    continue;

                ItemTableFile file = parseTableFile(p);

                //Must absolutely be a hover file
                if (file == null || file.IsTableFile == null || !file.IsTableFile.equals("absolutely"))
                    continue;

                // Process file
                newParsedFiles.put(file.Name, file);

                for (String baseItemName : file.Items.keySet()) {
                    ItemTable itemTable = file.Items.get(baseItemName);

                    // Set properties on TableItem
                    itemTable.setParentFile(file);
                    itemTable.setItemName(baseItemName);

                    String[] itemNames = itemTable.getAllNames();
                    for (String itemName : itemNames) {
                        // Store an (itemName -> collection) reference in newItemMap
                        if (!newItemMap.containsKey(itemName)) {
                            newItemMap.put(itemName, new ItemTableCollection());
                        }

                        // Put TableItem into itemMapEntry
                        ItemTableCollection itemMapEntry = newItemMap.get(itemName);
                        itemMapEntry.getItemTables().put(file.Name, itemTable);
                    }
                }
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        parsedFiles.clear();
        itemMap.clear();

        parsedFiles.putAll(newParsedFiles);
        itemMap.putAll(newItemMap);
    }

    /**
     * Get the ItemCollection associated with the given item name
     */
    public ItemTableCollection getCollectionForItem(String itemName) {
        return itemMap.getOrDefault(itemName, new ItemTableCollection());
    }

    /**
     * Get the base ItemTable for the given item/player combo.
     * <p>
     * This is a special table, available for every item, which defines certain variables -- eg "id", "qty", etc.
     */
    public ItemTable getBaseTableForItemAndPlayer(Item item, Client client) {
        // TODO: It's silly to construct this every time. So many heap allocations :(
        //       Instead, we should just compute these values on the fly when an expression actually needs one.
        ItemComposition itemComposition = itemManager.getItemComposition(item.getId());

        ItemTable baseTable = new ItemTable();
        baseTable.put("id", String.valueOf(item.getId()));
        baseTable.put("name", itemComposition.getName());
        baseTable.put("qty", String.valueOf(item.getQuantity()));
        baseTable.put("value", String.valueOf(itemComposition.getPrice()));
        baseTable.put("high_alch", String.valueOf(itemComposition.getHaPrice()));

        if (client == null || client.getGameState() != GameState.LOGGED_IN) {
            return baseTable;
        }

        // Prepare player variables
        // TODO: move this somewhere else
        Player player = client.getLocalPlayer();

        // Skill levels/xp
        for (Skill skill : Skill.values()) {
            String skillName = skill.getName().toLowerCase(Locale.ROOT);
            baseTable.put(skillName + "_level", String.valueOf(client.getBoostedSkillLevel(skill)));
            baseTable.put(skillName + "_level_real", String.valueOf(client.getRealSkillLevel(skill)));
            baseTable.put(skillName + "_xp", String.valueOf(client.getSkillExperience(skill)));
        }

        // World location
        baseTable.put("player_x", String.valueOf(player.getWorldLocation().getX()));
        baseTable.put("player_y", String.valueOf(player.getWorldLocation().getY()));
        baseTable.put("player_plane", String.valueOf(player.getWorldLocation().getPlane()));
        baseTable.put("player_region", String.valueOf(player.getWorldLocation().getRegionID()));
        baseTable.put("player_region_x", String.valueOf(player.getWorldLocation().getRegionX()));
        baseTable.put("player_region_y", String.valueOf(player.getWorldLocation().getRegionY()));

        // Health/prayer
        baseTable.put("player_hp", String.valueOf(client.getBoostedSkillLevel(Skill.HITPOINTS)));
        baseTable.put("player_prayer", String.valueOf(client.getBoostedSkillLevel(Skill.PRAYER)));

        return baseTable;
    }

    /**
     * Parse a file from JSON
     *
     * @param tableFile
     * @return
     */
    private ItemTableFile parseTableFile(Path tableFile) {
        try {
            byte[] fileBytes = Files.readAllBytes(tableFile);
            String fileString = new String(fileBytes);

            return gson.fromJson(fileString, ItemTableFile.class);
        } catch (Exception e) {
            log.error(e.toString());
            return null;
        }
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.*;
import com.geel.customitemhovers.expressions.Compiler;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import com.geel.customitemhovers.expressions.providers.IFunctionProvider;
import org.junit.Test;

import static org.junit.Assert.*;

public class ExpressionTest {
    private static double EPSILON = 0.000001;
    private static ExecutionContext context;

    @Test
    public void TestTokenizer() {
        // Prepare execution context
        TestVariableProvider variableProvider = new TestVariableProvider();
        variableProvider.put("a", "b");
        IFunctionProvider functionProvider = new CustomItemHoversFunctionProvider(null, null);
        context = new ExecutionContext(functionProvider, variableProvider);

        // Functions
        testStringExpr("red(a)", "<col=ff0000>b</col>");
        testStringExpr("green('a')", "<col=00ff00>a</col>");
        testStringExpr("blue('a')", "<col=0000ff>a</col>");
        testStringExpr("rgb(255, pow(2, 8) - 1, 2, 'hi')", "<col=ffff02>hi</col>");
        testStringExpr("rgb(255, 255, 255, 'hi')", "<col=ffffff>hi</col>");
        testDoubleExpr("pow(2, 3)", 8);
        testDoubleExpr("pow(2, 3.0)", 8);
        testDoubleExpr("pow(2.0, 3)", 8);
        testDoubleExpr("pow(2.0, 3.0)", 8);
        testDoubleExpr("pow(2, 3.0000000000001)", 8);
        testDoubleExpr("max(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 + 0.5 - (2 * 1/3)))", 15.833333333333);
        testDoubleExpr("min(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)))", -52);
        testDoubleExpr("min((15 - (201 * 1/3)))", -52);
        testDoubleExpr("max((15 + 0.5 + (1/3)), (15 - (201 * 1/3)))", 15.833333333333);
        testDoubleExpr("max(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)))", 15.833333333333);
        testDoubleExpr("max(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)), 0)", 15.833333333333);
        testDoubleExpr("min(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)), 0)", -52);
        testDoubleExpr("min(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)), 0, 100)", -52);
        testDoubleExpr("max(1,2,15, 2.3, 15.4, (15 + 0.5 + (1/3)), (15 - (201 * 1/3)), 0, 100)", 100);


        // Arithmetic
        testIntExpr("0 + 0", 0);
        testIntExpr("0 + 1", 1);
        testIntExpr("1 + 1", 2);
        testDoubleExpr("1.1 + 1.01", 2.11);
        testIntExpr("0 - 0", 0);
        testIntExpr("0 - 1", -1);
        testIntExpr("1 - 1", 0);
        testDoubleExpr("1.1 - 1.01", 0.09);
        testDoubleExpr("1 - 1.01", -0.01);
        testDoubleExpr("1.0 - 1", 0);
        testDoubleExpr("1 - 1.0", 0);
        testDoubleExpr("1.0 - 1.0000000000001", 0);
        testDoubleExpr("1.0000000000001 - 1", 0);
        testDoubleExpr("1.0000000000001 - 1.0000000000001", 0);

        // Multiplication/division
        testIntExpr("0 * 0", 0);
        testIntExpr("0 * 1", 0);
        testIntExpr("1 * 0", 0);
        testIntExpr("1 * 1", 1);
        testIntExpr("1 * 2", 2);
        testIntExpr("2.0 * 1", 2);
        testIntExpr("(1 + 3) * (4.5 * 2)", 36);
        testIntExpr("0 / 1", 0);
        testIntExpr("1 / 1", 1);
        testDoubleExpr("1 / 2", 0.5);
        testIntExpr("2 / 1", 2);
        testDoubleExpr("(1 + 3) / (4.5 * 2)", 4d / 9d);
        testDoubleExpr("1 / 2.0", 0.5);
        testDoubleExpr("1.0 / 2", 0.5);
        testDoubleExpr("1.0 / 2.0", 0.5);
        testDoubleExpr("1.0 / 2.0000000000001", 0.4999999999999999);
        testDoubleExpr("1.0000000000001 / 2", 0.5000000000000002);


        // Modulo
        testIntExpr("0 % 1", 0);
        testIntExpr("0 % 15", 0);
        testIntExpr("1 % 1", 0);
        testIntExpr("1 % 15", 1);
        testIntExpr("14 % 15", 14);
        testIntExpr("15 % 15", 0);
        testIntExpr("18 % 15", 3);
        testIntExpr("18 % (0 - 5)", 3);

        // Functions
        testIntExpr("ceil(0) == 0", 1);
        testIntExpr("floor(0) == 0", 1);
        testIntExpr("floor(0) == ceil(0)", 1);
        testIntExpr("floor(0.01) != ceil(0.01)", 1);
        testIntExpr("floor(2)", 2);
        testIntExpr("ceil(2)", 2);
        testDoubleExpr("floor(2.0)", 2);
        testDoubleExpr("ceil(2.0)", 2);
        testDoubleExpr("floor(2.1)", 2);
        testDoubleExpr("ceil(2.1)", 3);
        testDoubleExpr("floor((0.01 + 15.03))", 15);
        testDoubleExpr("ceil((0.01 + 15.03))", 16);
        testDoubleExpr("floor(0.01 + 15.03)", 15);
        testDoubleExpr("ceil(0.01 + 15.03)", 16);
        testDoubleExpr("floor(0.01 + 15.03) == ceil(0.01 + 15.03)", 0);

        // Boolean tests
        testIntExpr("((1 + 3) * (4.5 * 2)) == 36", 1);
        testIntExpr("((1 + 3) >= (0 + 2)) && ((1 - 4) == (0 - 3))", 1);
        testIntExpr("((1 + 3) >= (15 + 5)) && ((1 - 4) == (0 - 3))", 0);
        testIntExpr("((1 + 3) >= (15 + 5)) || ((1 - 4) == (0 - 3))", 1);
        testIntExpr("1 || 0 || 0", 1);
        testIntExpr("1 || 0 && 0", 1);
        testIntExpr("1 && 0 || 0", 0);
        testIntExpr("0 && 0", 0);
        testIntExpr("1 && 1", 1);
        testIntExpr("0 && 1", 0);
        testIntExpr("1 && 0", 0);
        testIntExpr("0 || 0", 0);
        testIntExpr("1 || 1", 1);
        testIntExpr("0 || 1", 1);
        testIntExpr("1 || 0", 1);
        testIntExpr("1 > 0", 1);
        testIntExpr("1 > 1", 0);
        testIntExpr("1 > 2", 0);
        testIntExpr("1 >= 0", 1);
        testIntExpr("1 >= 1", 1);
        testIntExpr("1.0 >= 1.0", 1);
        testIntExpr("1.0 > 0.999", 1);
        testIntExpr("0.999 >= 0.999", 1);
        testIntExpr("1.0 >= 1.0001", 0);
        testIntExpr("1.0 >= 2", 0);
        testIntExpr("1 < 0", 0);
        testIntExpr("1 < 1", 0);
        testIntExpr("1 < 2", 1);
        testIntExpr("1 <= 0", 0);
        testIntExpr("1 <= 1", 1);
        testIntExpr("1 <= 2", 1);
        testIntExpr("1 <= 0.0", 0);
        testIntExpr("1 <= 1.0000000000001", 1);
        testIntExpr("1 <= 2.0", 1);
        testIntExpr("1 <= 0.999", 0);
        testIntExpr("0.999 <= 0.999", 1);
        testIntExpr("1 <= 1.0001", 1);
        testIntExpr("1 == 1", 1);
        testIntExpr("1 == 2", 0);
        testIntExpr("0 == 0", 1);
        testIntExpr("1.123 == 1.123", 1);
        testIntExpr("1.123 == 1.12300000001", 1);
        testIntExpr("1.123 == 1.1234", 0);
        testIntExpr("1 == 1.0", 1);
        testIntExpr("1 == 1.00000000001", 1);

        // Ternary
        testIntExpr("1 ? 2 : 3", 2);
        testIntExpr("0 ? 2 : 3", 3);
        testIntExpr("1 ? 2 : 0", 2);
        testIntExpr("0 ? 2 : 0", 0);
        testIntExpr("1 + 0 ? (1 + 1) : (2 + 1)", 2);
        testIntExpr("1 - 1 ? (1 + 1) : (2 + 1)", 3);
        testIntExpr("(1 - 1) ? (4 / 4) : (3 - 4)", -1);
        testIntExpr("(1 + 1) ? (8 / 4) : (3 - 4)", 2);
        testIntExpr("1 ? 1 ? 2 : 3 : 4", 2);
        testIntExpr("1 ? 1 ? 3 : 2 : 4", 3);
        // This kind of breaks without parens but fuck you if you write ternary like this anyways, the base shit works
        testIntExpr("0 ? (1 ? 3 : 2) : 4", 4);
        testIntExpr("1 ? 0 ? 3 : 2 : 4", 2);


        // Strings
        testStringExpr("'a'", "a");
        testStringExpr("'a' + 'b'", "ab");
        testStringExpr("1 ? 'hello' : 'world'", "hello");
        testStringExpr("0 ? 'hello' : 'world'", "world");
        testStringExpr("1 ? 'hello' : 'world' + 'foo'", "hello");
        testStringExpr("0 ? 'hello' : 'world' + 'foo'", "worldfoo");
        testStringExpr("(1 ? 'hello' : 'world') + 'foo'", "hellofoo");
        testStringExpr("(0 ? 'hello' : 'world') + 'foo'", "worldfoo");
        testIntExpr("'hello' == 'world'", 0);
        testIntExpr("'hello' != 'world'", 1);
        testIntExpr("'hello' == 'hello'", 1);
        testIntExpr("'hello' != 'hello'", 0);
        testIntExpr("'hello' == 'he' + 'llo'", 1);
        testStringExpr("('hello' + (1 > 5 ? ' world' : ' something else')) + ('abc' == ('a' + 'b' + 'c') ? 'foo' : 'bar')",
                "hello something elsefoo");

        // Color functions
        testStringExpr("red('a')", "<col=ff0000>a</col>");
        testStringExpr("green('a')", "<col=00ff00>a</col>");
        testStringExpr("blue('a')", "<col=0000ff>a</col>");
        testStringExpr("rgb(255, 255, 255, 'hi')", "<col=ffffff>hi</col>");
        testStringExpr("rgb(255, 0, 0, 'hi')", "<col=ff0000>hi</col>");
        testStringExpr("rgb(0, 255, 0, 'hi')", "<col=00ff00>hi</col>");
        testStringExpr("rgb(0, 0, 255, 'hi')", "<col=0000ff>hi</col>");
        testStringExpr("rgb(255, 255, 0, 'hi')", "<col=ffff00>hi</col>");
        testStringExpr("rgb(255, 255, 0, green(redStart() + blueStart()))", "<col=ffff00><col=00ff00><col=ff0000><col=0000ff></col></col>");

        // redStart(), greenStart(), blueStart(), yellowStart(), rgbStart(), colorEnd()
        testStringExpr("redStart()", "<col=ff0000>");
        testStringExpr("greenStart()", "<col=00ff00>");
        testStringExpr("blueStart()", "<col=0000ff>");
        testStringExpr("yellowStart()", "<col=ffff00>");
        testStringExpr("rgbStart(255, 255, 255)", "<col=ffffff>");
        testStringExpr("rgbStart(255, 0, 0)", "<col=ff0000>");
        testStringExpr("rgbStart(0, 255, 0)", "<col=00ff00>");
        testStringExpr("rgbStart(0, 0, 255)", "<col=0000ff>");
        testStringExpr("rgbStart(255, 255, 0) + 'hi' + colorEnd()", "<col=ffff00>hi</col>");
 }

    private void testIntExpr(String expression, int expected) {
        Tokenizer t = new Tokenizer("${" + expression + "}", 0);
        CompiledExpression compiled = Compiler.Compile(t.tokenize());
        CompiledExpression condensed = EvaluationUtil.EvaluateStatically(compiled, context);
        Token result = EvaluationUtil.EvaluateAtRuntime(condensed, context);

        assertNotSame(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getNumericValue().intValue());
    }

    private void testDoubleExpr(String expression, double expected) {
        Tokenizer t = new Tokenizer("<%" + expression + "%>", 0);
        CompiledExpression compiled = Compiler.Compile(t.tokenize());
        CompiledExpression condensed = EvaluationUtil.EvaluateStatically(compiled, context);
        Token result = EvaluationUtil.EvaluateAtRuntime(condensed, context);

        assertNotSame(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getNumericValue().doubleValue(), EPSILON);
    }

    private void testStringExpr(String expression, String expected) {
        Tokenizer t = new Tokenizer("<%" + expression + "%>", 0);
        CompiledExpression compiled = Compiler.Compile(t.tokenize());
        CompiledExpression condensed = EvaluationUtil.EvaluateStatically(compiled, context);
        Token result = EvaluationUtil.EvaluateAtRuntime(condensed, context);

        assertEquals(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getValue());
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.providers.IVariableProvider;

import java.util.HashMap;

public class TestVariableProvider extends HashMap<String, String> implements IVariableProvider {
    @Override
    public String resolveVariable(String name) {
        return getOrDefault(name, null);
    }
}

package com.geel.customitemhovers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CustomItemHoversTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomItemHoversPlugin.class);
		RuneLite.main(args);
	}
}
