package com.geel.customitemhovers;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CustomItemHoversTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CustomItemHoversPlugin.class);
		RuneLite.main(args);
	}
}
package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.*;
import com.geel.customitemhovers.expressions.Compiler;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import org.junit.Test;

import static org.junit.Assert.*;

public class ExpressionTest {
    private static double EPSILON = 0.000001;

    @Test
    public void TestTokenizer() {
        // Arithmetic
        testIntExpr("0 + 0", 0);
        testIntExpr("0 + 1", 1);
        testIntExpr("1 + 1", 2);
        testDoubleExpr("1.1 + 1.01", 2.11);
        testIntExpr("0 - 0", 0);
        testIntExpr("0 - 1", -1);
        testIntExpr("1 - 1", 0);
        testDoubleExpr("1.1 - 1.01", 0.09);
        testDoubleExpr("1 - 1.01", -0.01);
        testDoubleExpr("1.0 - 1", 0);
        testDoubleExpr("1 - 1.0", 0);

        // Multiplication/division
        testIntExpr("0 * 0", 0);
        testIntExpr("0 * 1", 0);
        testIntExpr("1 * 0", 0);
        testIntExpr("1 * 1", 1);
        testIntExpr("1 * 2", 2);
        testIntExpr("2.0 * 1", 2);
        testIntExpr("(1 + 3) * (4.5 * 2)", 36);
        testIntExpr("0 / 1", 0);
        testIntExpr("1 / 1", 1);
        testDoubleExpr("1 / 2", 0.5);
        testIntExpr("2 / 1", 2);
        testDoubleExpr("(1 + 3) / (4.5 * 2)", 4d / 9d);

        // Modulo
        testIntExpr("0 % 1", 0);
        testIntExpr("0 % 15", 0);
        testIntExpr("1 % 1", 0);
        testIntExpr("1 % 15", 1);
        testIntExpr("14 % 15", 14);
        testIntExpr("15 % 15", 0);
        testIntExpr("18 % 15", 3);
        testIntExpr("18 % (0 - 5)", 3);

        // Functions
        testIntExpr("ceil(0) == 0", 1);
        testIntExpr("floor(0) == 0", 1);
        testIntExpr("floor(0) == ceil(0)", 1);
        testIntExpr("floor(0.01) != ceil(0.01)", 1);
        testIntExpr("floor(2)", 2);
        testIntExpr("ceil(2)", 2);
        testDoubleExpr("floor(2.0)", 2);
        testDoubleExpr("ceil(2.0)", 2);
        testDoubleExpr("floor(2.1)", 2);
        testDoubleExpr("ceil(2.1)", 3);
        testDoubleExpr("floor((0.01 + 15.03))", 15);
        testDoubleExpr("ceil((0.01 + 15.03))", 16);

        // Boolean tests
        testIntExpr("((1 + 3) * (4.5 * 2)) == 36", 1);
        testIntExpr("((1 + 3) >= (0 + 2)) && ((1 - 4) == (0 - 3))", 1);
        testIntExpr("((1 + 3) >= (15 + 5)) && ((1 - 4) == (0 - 3))", 0);
        testIntExpr("((1 + 3) >= (15 + 5)) || ((1 - 4) == (0 - 3))", 1);
        testIntExpr("1 || 0 || 0", 1);
        testIntExpr("1 || 0 && 0", 1);
        testIntExpr("1 && 0 || 0", 0);
        testIntExpr("0 && 0", 0);
        testIntExpr("1 && 1", 1);
        testIntExpr("0 && 1", 0);
        testIntExpr("1 && 0", 0);
        testIntExpr("0 || 0", 0);
        testIntExpr("1 || 1", 1);
        testIntExpr("0 || 1", 1);
        testIntExpr("1 || 0", 1);
        testIntExpr("1 > 0", 1);
        testIntExpr("1 > 1", 0);
        testIntExpr("1 > 2", 0);
        testIntExpr("1 >= 0", 1);
        testIntExpr("1 >= 1", 1);
        testIntExpr("1.0 >= 1.0", 1);
        testIntExpr("1.0 > 0.999", 1);
        testIntExpr("0.999 >= 0.999", 1);
        testIntExpr("1.0 >= 1.0001", 0);
        testIntExpr("1.0 >= 2", 0);
        testIntExpr("1 < 0", 0);
        testIntExpr("1 < 1", 0);
        testIntExpr("1 < 2", 1);
        testIntExpr("1 <= 0", 0);
        testIntExpr("1 <= 1", 1);
        testIntExpr("1 <= 2", 1);
        testIntExpr("1 <= 0.0", 0);
        testIntExpr("1 <= 1.0000000000001", 1);
        testIntExpr("1 <= 2.0", 1);
        testIntExpr("1 <= 0.999", 0);
        testIntExpr("0.999 <= 0.999", 1);
        testIntExpr("1 <= 1.0001", 1);
        testIntExpr("1 == 1", 1);
        testIntExpr("1 == 2", 0);
        testIntExpr("0 == 0", 1);
        testIntExpr("1.123 == 1.123", 1);
        testIntExpr("1.123 == 1.12300000001", 1);
        testIntExpr("1.123 == 1.1234", 0);
        testIntExpr("1 == 1.0", 1);
        testIntExpr("1 == 1.00000000001", 1);

        // Ternary
        testIntExpr("1 ? 2 : 3", 2);
        testIntExpr("0 ? 2 : 3", 3);
        testIntExpr("1 + 0 ? (1 + 1) : (2 + 1)", 2);
        testIntExpr("1 - 1 ? (1 + 1) : (2 + 1)", 3);
        testIntExpr("(1 - 1) ? (4 / 4) : (3 - 4)", -1);
        testIntExpr("(1 + 1) ? (8 / 4) : (3 - 4)", 2);
        testIntExpr("1 ? 1 ? 3 : 2 : 4", 3);
        // This kind of breaks without parens but fuck you if you write ternary like this anyways, the base shit works
        testIntExpr("0 ? (1 ? 3 : 2) : 4", 4);
        testIntExpr("1 ? 0 ? 3 : 2 : 4", 2);

        // Strings
        testStringExpr("'a'", "a");
        testStringExpr("'a' + 'b'", "ab");
        testStringExpr("1 ? 'hello' : 'world'", "hello");
        testStringExpr("0 ? 'hello' : 'world'", "world");
        testStringExpr("1 ? 'hello' : 'world' + 'foo'", "hello");
        testStringExpr("0 ? 'hello' : 'world' + 'foo'", "worldfoo");
        testStringExpr("(1 ? 'hello' : 'world') + 'foo'", "hellofoo");
        testStringExpr("(0 ? 'hello' : 'world') + 'foo'", "worldfoo");
        testIntExpr("'hello' == 'world'", 0);
        testIntExpr("'hello' != 'world'", 1);
        testIntExpr("'hello' == 'hello'", 1);
        testIntExpr("'hello' != 'hello'", 0);
        testIntExpr("'hello' == 'he' + 'llo'", 1);
        testStringExpr("('hello' + (1 > 5 ? ' world' : ' something else')) + ('abc' == ('a' + 'b' + 'c') ? 'foo' : 'bar')",
                "hello something elsefoo");
    }

    private void testIntExpr(String expression, int expected) {
        Tokenizer t = new Tokenizer("${" + expression + "}", 0);
        Token result = Evaluator.Evaluate(Compiler.Compile(t.tokenize()), null);

        assertNotSame(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getNumericValue().intValue());
    }

    private void testDoubleExpr(String expression, double expected) {
        Tokenizer t = new Tokenizer("<%" + expression + "%>", 0);
        Token result = Evaluator.Evaluate(Compiler.Compile(t.tokenize()), null);

        assertNotSame(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getNumericValue().doubleValue(), EPSILON);
    }

    private void testStringExpr(String expression, String expected) {
        Tokenizer t = new Tokenizer("<%" + expression + "%>", 0);
        Token result = Evaluator.Evaluate(Compiler.Compile(t.tokenize()), null);

        assertEquals(result.getType(), TokenType.STRING);
        assertEquals(expression, expected, result.getValue());
    }
}

package com.geel.customitemhovers;

import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

import java.lang.reflect.Field;
import java.util.*;
import java.util.regex.Pattern;

/**
 * Stores an (item name -> [item ids]) and (item id -> item name) mapping for all items in game
 */
@Slf4j
public class ItemNameMap {
    //Map of (item name -> [item id, ...])
    private final static Map<String, ArrayList<Integer>> itemNameToIDs = new HashMap<>();

    /**
     * Prepare map of item names to IDs
     *
     * @param client      Reference to RL Client; used to fetch total number of items
     * @param itemManager Reference to ItemManager; used to fetch item compositions
     */
    public static void PrepareMap(Client client, ItemManager itemManager) {
        //Don't do anything if already prepared
        if (itemNameToIDs.size() > 0)
            return;

        //Clear just to be safe
        itemNameToIDs.clear();

        Set<Integer> processedIDs = new HashSet<>();

        for (int i = 0; i < client.getItemCount(); i++) {
            int canonicalID = itemManager.canonicalize(i);

            if(processedIDs.contains(canonicalID))
                continue;

            processedIDs.add(canonicalID);

            ItemComposition comp = itemManager.getItemComposition(canonicalID);
            String itemName = comp.getName();

            if(itemName.toLowerCase().equals("null")) {
                log.error("Item ID " + canonicalID + " has a null name");
                continue;
            }

            //Create list for item name if it doesn't exist
            if (!itemNameToIDs.containsKey(itemName)) {
                itemNameToIDs.put(itemName, new ArrayList<>(1));
            }

            itemNameToIDs.get(itemName).add(canonicalID);
        }
    }

    /**
     * Returns all item IDs which correspond to the given string name
     *
     * @param itemName The name of an entry in the `ItemID` class, eg, "PINEAPPLE_SAPLING"
     */
    public static int[] GetItemIDs(String itemName) {
        ArrayList<Integer> itemIDs = itemNameToIDs.getOrDefault(itemName, new ArrayList<>(0));

        //The lack of a sane toArray() function is going to kill me
        int[] ret = new int[itemIDs.size()];

        for (int i = 0; i < itemIDs.size(); i++) {
            ret[i] = itemIDs.get(i);
        }

        return ret;
    }


    /**
     * Returns all IDs of items whose names match the given regex
     *
     * @param itemNameRegex A regex string to match item names against
     * @return A list of all item IDs whose names match the given regex
     */
    public static ArrayList<Integer> GetItemIDsRegex(String itemNameRegex) {
        ArrayList<Integer> ret = new ArrayList<>(1);
        Pattern finder = Pattern.compile(itemNameRegex);

        if (finder == null) {
            return ret;
        }

        for (String entry : itemNameToIDs.keySet()) {
            if (!finder.matcher(entry).matches())
                continue;

            for (int itemID : itemNameToIDs.get(entry)) {
                //O(n^2), sue me (don't)
                if (!ret.contains(itemID))
                    ret.add(itemID);
            }
        }

        return ret;
    }
}

package com.geel.customitemhovers;

import javax.inject.Inject;

import com.geel.customitemhovers.models.hovers.HoverFile;
import com.geel.customitemhovers.models.hovers.HoverDef;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import com.google.gson.Gson;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.events.CommandExecuted;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.overlay.OverlayManager;

import java.awt.*;
import java.io.IOException;
import java.nio.file.*;
import java.util.*;

import static java.nio.file.StandardWatchEventKinds.*;

@Slf4j
@PluginDescriptor(
        name = "Custom Item Hovers",
        description = "Enables custom item hovers. Read github page.",
        tags = {"custom", "item", "hovers", "tooltips"},
        enabledByDefault = true
)
public class CustomItemHoversPlugin extends Plugin {
    private static final String PLUGIN_FOLDER_NAME = "customitemhovers";

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ConfigManager configManager;

    @Inject
    private OverlayManager overlayManager;

    @Inject
    private ClientToolbar clientToolbar;

    @Inject
    private ItemManager itemManager;

    @Inject
    private CustomItemHoversOverlay overlay;

    @Inject
    private CustomItemHoversConfig config;

    @Inject
    private Gson gson;

    @Inject
    private HoverFileParser parser;

    @Inject
    private ItemTableManager itemTableManager;

    @Provides
    CustomItemHoversConfig getConfig(ConfigManager configManager) {
        return configManager.getConfig(CustomItemHoversConfig.class);
    }

    //Map between an Item ID and all of its associated HoverDefs.
    public Map<Integer, ArrayList<HoverDef>> hovers = new HashMap<>();

    WatchService hoverWatcher;
    WatchKey hoverWatchKey;
    WatchKey tableWatchKey;

    @Override
    protected void startUp() throws Exception {
        prepareHoverFolder();

        //Invoke this on the client thread because `itemManager.canonicalize()` must be run in the client thread
        clientThread.invokeLater(() -> {
            prepareItemNameMap();
            prepareItemTables();
            prepareHoverMap();
            prepareHoverWatcher();
        });

        overlayManager.add(overlay);
    }

    @Override
    protected void shutDown() throws Exception {
        if (hoverWatcher != null)
            hoverWatcher.close();

        overlayManager.remove(overlay);
    }

    @Subscribe
    public void onConfigChanged(ConfigChanged ev) {
        if (ev.getGroup().equals("customitemhovers") && ev.getKey().equals("hoverEnableHotReload")) {
            if (config.hoverEnableHotReload()) {
                clientThread.invoke(this::prepareHoverWatcher);
            } else {
                clientThread.invoke(this::stopHoverWatcher);
            }
        }
    }

    @Subscribe
    public void onCommandExecuted(CommandExecuted commandExecuted) {
        if (!commandExecuted.getCommand().equals(config.openDirChatCommand())) {
            return;
        }

        Path hoverPath = getHoverPath();

        if (hoverPath == null) {
            return;
        }

        try {
            Desktop.getDesktop().open(hoverPath.toFile());
        } catch (Exception e) {
            log.error("Got exception opening hover folder", e);
        }
    }

    /**
     * Returns an array of hover texts that should be rendered for a given item
     */
    private Item lastItem = null;
    private String[] lastHovers = null;

    public String[] getItemHovers(Item item) {
        if (item.equals(lastItem)) {
            return lastHovers;
        }

        //Do a hot-reload if we should
        if (config.hoverEnableHotReload()) {
            if (hoverWatcherTriggered()) {
                prepareHoverMap();
            }

            if (tableWatcherTriggered()) {
                prepareItemTables();
            }
        }

        int itemID = itemManager.canonicalize(item.getId());
        ItemComposition comp = itemManager.getItemComposition(itemID);

        //If item's ID is not in `hovers`, it has no hovers.
        if (!hovers.containsKey(itemID))
            return new String[0];

        // Get item data tables
        ItemTableCollection tableCollection = itemTableManager.getCollectionForItem(comp.getName());
        ItemTable baseTable = itemTableManager.getBaseTableForItem(item);

        //For each hover associated with this item, add its transformed text to the resultant array
        boolean obsoleteExpressionDetected = false;
        ItemHoverContext context = new ItemHoverContext(item, comp, tableCollection, baseTable);
        ArrayList<String> ret = new ArrayList<>();
        for (HoverDef hoverDef : hovers.get(itemID)) {
            String[] transformed = new String[hoverDef.ParsedHoverTexts.length];

            int i = 0;
            for (ParsedHover parsedHover : hoverDef.ParsedHoverTexts) {
                transformed[i++] = HoverEvaluator.Evaluate(parsedHover, context);

                // Warn about obsolete expressions
                if (config.enableObsoleteMessage()) {
                    obsoleteExpressionDetected = obsoleteExpressionDetected ||
                            Arrays
                                    .stream(parsedHover.getExpressions())
                                    .anyMatch(e -> e.isLegacy());
                }
            }

            ret.addAll(Arrays.asList(transformed));
        }

        // Warn about obsolete expressions if we find any
        if(obsoleteExpressionDetected) {
            warnObsoleteExpression();
        }

        //Turn `ret` into an array from an ArrayList
        String[] retArr = new String[ret.size()];
        retArr = ret.toArray(retArr);

        lastItem = item;
        lastHovers = retArr;

        return retArr;
    }

    private void warnObsoleteExpression() {
        client.addChatMessage(ChatMessageType.GAMEMESSAGE,
                "",
                "<col=e74c3c>[Custom Item Hovers]</col> " +
                        "Obsolete expression detected. " +
                        "See the plugin support page (or GitHub) to learn about the new, better expression system. " +
                        "Turn this message off in settings.",
                "");
    }

    /**
     * Parses the config's hover dirs path and returns it if it's a readable directory.
     *
     * @return Path|null The path if it's a valid, readable directory Path, null otherwise.
     */
    public Path getHoverPath() {
        return Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath() + "/" + PLUGIN_FOLDER_NAME);
    }

    /**
     * Parses the config's table path and returns it if it's a readable directory.
     *
     * @return Path|null The path if it's a valid, readable directory Path, null otherwise.
     */
    public Path getTablePath() {
        return Paths.get(RuneLite.RUNELITE_DIR.getAbsolutePath() + "/" + PLUGIN_FOLDER_NAME + "/tables");
    }

    /**
     * Prepare ItemNameMap
     */
    protected void prepareItemNameMap() {
        ItemNameMap.PrepareMap(client, itemManager);
    }

    /**
     * Creates, if necessary, the `customitemhovers` folder in the user's `.runelite` directory
     *
     * @throws IOException
     */
    protected void prepareHoverFolder() throws IOException {
        Path rlPath = RuneLite.RUNELITE_DIR.toPath();

        if (!Files.isDirectory(rlPath) || !Files.isReadable(rlPath) || !Files.isWritable(rlPath)) {
            log.error("[CUSTOMITEMHOVERS] Bad .runelite path");
            return;
        }

        // Ensure that `/customitemhovers` and `/customitemhovers/tables` exist in RL directory
        prepareSpecificHoverFolder(getHoverPath());
        prepareSpecificHoverFolder(getTablePath());
    }

    private void prepareSpecificHoverFolder(Path path) throws IOException {
        // Create directory if it doesn't exist
        if (Files.notExists(path)) {
            Files.createDirectory(path);
        }

        // Make sure we actually created the directory and it's readable
        if (!Files.isDirectory(path) || !Files.isReadable(path)) {
            log.error("[CUSTOMITEMHOVERS] Couldn't ensure path " + path);
        }
    }

    /**
     * Reads all files from the `customitemhovers` directory, parses them, and
     * prepares a map of (itemID, hovers) for each item that has a hover.
     */
    protected void prepareHoverMap() {
        hovers.clear();

        //Read all hover files
        ArrayList<HoverFile> hoverFiles = parser.readHoverFiles(getHoverPath());

        for (HoverFile f : hoverFiles) {
            for (HoverDef d : f.Hovers) {
                //Compute which item IDs this HoverDef is attached to. This fills in `d.ItemIDs`.
                parseHoverDefNames(d);

                //Add this HoverDef to the map for every Item ID it represents
                for (int itemID : d.ItemIDs) {
                    if (!hovers.containsKey(itemID))
                        hovers.put(itemID, new ArrayList<>());

                    ArrayList<HoverDef> curArr = hovers.get(itemID);
                    curArr.add(d);
                }
            }
        }
    }

    /**
     * TODO document
     */
    protected void prepareItemTables() {
        itemTableManager.reparseItemDatabase(getTablePath());
    }

    /**
     * @return True if the `customitemhovers` directory has changed since the last time this function was called
     */
    private boolean hoverWatcherTriggered() {
        if (hoverWatchKey == null || !hoverWatchKey.isValid())
            return false;

        //If we've received any filesystem events, then assume it changed
        boolean triggered = hoverWatchKey.pollEvents().size() > 0;

        //Enable more events to be queued
        hoverWatchKey.reset();

        return triggered;
    }

    /**
     * @return True if the `customitemhovers` directory has changed since the last time this function was called
     */
    private boolean tableWatcherTriggered() {
        if (tableWatchKey == null || !tableWatchKey.isValid())
            return false;

        //If we've received any filesystem events, then assume it changed
        boolean triggered = tableWatchKey.pollEvents().size() > 0;

        //Enable more events to be queued
        tableWatchKey.reset();

        return triggered;
    }

    /**
     * Set up a filesystem watcher on the `customitemhovers` directory.
     * <p>
     * This enables hot-reloading.
     */
    private void prepareHoverWatcher() {
        if (!config.hoverEnableHotReload())
            return;

        Path hoverPath = getHoverPath();
        Path tablePath = getTablePath();

        //Nothing to watch
        if (hoverPath == null)
            return;

        try {
            hoverWatcher = FileSystems.getDefault().newWatchService();

            hoverWatchKey = hoverPath.register(hoverWatcher,
                    ENTRY_CREATE,
                    ENTRY_DELETE,
                    ENTRY_MODIFY);

            if (tablePath != null) {
                tableWatchKey = tablePath.register(hoverWatcher,
                        ENTRY_CREATE,
                        ENTRY_DELETE,
                        ENTRY_MODIFY);
            }
        } catch (Exception e) {

        }
    }

    /**
     * Closes `hoverWatcher` and `hoverWatchKey`, if possible.
     */
    private void stopHoverWatcher() {
        if (hoverWatcher != null) {
            try {
                hoverWatcher.close();
            } catch (IOException e) {
                log.error("[CUSTOMITEMHOVERS]: exception closing hover watcher", e);
            }

            hoverWatcher = null;
        }

        if (hoverWatchKey != null) {
            hoverWatchKey.cancel();
            hoverWatchKey = null;
        }

        if (tableWatchKey != null) {
            tableWatchKey.cancel();
            tableWatchKey = null;
        }
    }

    /**
     * Computes all item IDs that a HoverDef is targeting, and stores the results in
     * its `ItemIDs` member variable.
     *
     * @param d HoverDef to parse names for
     */
    private void parseHoverDefNames(HoverDef d) {
        Set<Integer> itemIDs = new HashSet<>();

        //If ItemNamesRegex is non-empty, insert all item IDs whose name matches any of the given regexes
        if (d.ItemNamesRegex != null) {
            for (String name : d.ItemNamesRegex) {
                itemIDs.addAll(ItemNameMap.GetItemIDsRegex(name));
            }
        }

        //If ItemNames is non-empty, insert all item IDs with the exact name(s) specified
        if (d.ItemNames != null) {
            for (String name : d.ItemNames) {
                for (int id : ItemNameMap.GetItemIDs(name)) {
                    itemIDs.add(id);
                }
            }
        }

        //If ItemIDs has any IDs specified, copy them in
        if (d.ItemIDs != null && d.ItemIDs.length > 0) {
            for (int id : d.ItemIDs) {
                itemIDs.add(id);
            }
        }

        //Convert `itemIDs` into an array and store it in `d.ItemIDs`
        d.ItemIDs = new int[itemIDs.size()];
        int i = 0;
        for (Iterator<Integer> it = itemIDs.iterator(); it.hasNext(); ) {
            int id = it.next();
            d.ItemIDs[i++] = id;
        }
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.models.BaseExpression;
import com.geel.customitemhovers.expressions.Compiler;
import com.geel.customitemhovers.expressions.Tokenizer;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.models.TokenizedExpression;
import com.geel.customitemhovers.models.hovers.HoverFile;
import com.geel.customitemhovers.models.hovers.HoverDef;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Inject;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.stream.Stream;

@Slf4j
public class HoverFileParser {
    @Inject
    private Gson gson;

    public ArrayList<HoverFile> readHoverFiles(Path dirPath) {
        ArrayList<HoverFile> ret = new ArrayList<>();

        if (!Files.isDirectory(dirPath) || !Files.isReadable(dirPath)) {
            return ret;
        }

        try {
            Stream fileStream = Files.list(dirPath);
            for (Iterator it = fileStream.iterator(); it.hasNext(); ) {
                Path p = (Path) it.next();

                //Ensure it's a regular readable file
                if (!Files.isRegularFile(p) || !Files.isReadable(p))
                    continue;

                //Ensure it's a json file
                if (!p.toString().endsWith(".json"))
                    continue;

                HoverFile file = parseHoverFile(p);

                //Must absolutely be a hover file
                if (file == null || file.IsHoverMap == null || !file.IsHoverMap.equals("absolutely"))
                    continue;

                //Post-process (right now just combine arrays of text into single strings)
                postProcessHoverFile(file);

                ret.add(file);
            }
        } catch (IOException e) {
            log.error(e.toString());

            return ret;
        }

        return ret;
    }

    private HoverFile parseHoverFile(Path hoverFile) {
        try {
            byte[] fileBytes = Files.readAllBytes(hoverFile);
            String fileString = new String(fileBytes);

            return gson.fromJson(fileString, HoverFile.class);
        } catch (Exception e) {
            log.error(e.toString());
            return null;
        }
    }

    private void postProcessHoverFile(HoverFile f) {
        for (HoverDef d : f.Hovers) {
            parseHoverDefHovers(d);
        }
    }

    private final StringBuilder _hoverBuilder = new StringBuilder();

    private void parseHoverDefHovers(HoverDef d) {
        d.ParsedHoverTexts = new ParsedHover[d.HoverTexts.length];

        int i = 0;
        for (String[] hovers : d.HoverTexts) {
            _hoverBuilder.setLength(0); //clear stringbuilder but keep memory allocated

            // First, collapse each sub-array into a <br/>-delimited single String
            boolean firstLine = true;
            for (String hoverLine : hovers) {
                if (!firstLine)
                    _hoverBuilder.append("</br>");
                _hoverBuilder.append(hoverLine);

                firstLine = false;
            }

            String concatenatedHovers = _hoverBuilder.toString();
            _hoverBuilder.setLength(0);

            // Now, find all expressions in the hoverText
            ArrayList<CompiledExpression> expressions = new ArrayList<>();
            ArrayList<Integer> expressionLocations = new ArrayList<>();

            int offset = 0;
            int curPos = 0;
            while (curPos < concatenatedHovers.length()) {
                char c = concatenatedHovers.charAt(curPos);

                // If not a tag opener, or the end of the string, just add to output
                if ((c != '$' && c != '<') || curPos == concatenatedHovers.length() - 1) {
                    _hoverBuilder.append(c);
                    curPos++;
                    continue;
                }

                // Ensure this is a tag opener
                char nextChar = concatenatedHovers.charAt(curPos + 1);
                if((c == '$' && nextChar != '{') || (c == '<' && nextChar != '%')) {
                    // Not a tag opener. Just continue.
                    _hoverBuilder.append(c);
                    _hoverBuilder.append(nextChar);
                    curPos += 2;
                    continue;
                }

                // We have a tag opener. Try to read the expression.
                Tokenizer tokenizer = new Tokenizer(concatenatedHovers, curPos);
                CompiledExpression compiledExpression = null;
                try {
                    compiledExpression = Compiler.Compile(tokenizer.tokenize());
                } catch (IllegalArgumentException e) {
                }

                int len = tokenizer.getNumRead();
                int endPos = curPos + len;

                // If a failed parse, just add the raw expression text
                if(compiledExpression == null) {
                    String expression = concatenatedHovers.substring(curPos, endPos);
                    curPos = endPos;
                    _hoverBuilder.append(expression);
                    continue;
                }

                // If a successful parse, skip ahead to endPos
                expressionLocations.add(curPos - offset);
                expressions.add(compiledExpression);
                curPos = endPos;
                offset += len;
            }

            d.ParsedHoverTexts[i++] = new ParsedHover(_hoverBuilder.toString(),
                    expressionLocations.toArray(new Integer[0]),
                    expressions.toArray(new CompiledExpression[0]));
        }
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.expressions.*;
import com.geel.customitemhovers.expressions.models.*;
import com.geel.customitemhovers.models.hovers.ParsedHover;
import java.text.NumberFormat;
import java.util.Locale;

/***
 * Evaluates a hover text, replacing variable names with their values, and replacing function calls with their results.
 */
public class HoverEvaluator {
    /**
     * Evaluates a hover text for a given item.
     *
     * Evaluates expressions, returning a string ready to render into a hover box.
     *
     * @return A hover string, properly evaluated, ready to render into a hover box.
     */
    public static String Evaluate(ParsedHover hover, ItemHoverContext context) {
        // No expressions? Nothing to evaluate
        if(hover.getExpressions().length == 0) {
            return hover.getHoverText();
        }

        return evaluateExpressions(hover, context);
    }

    private static String evaluateExpressions(ParsedHover hover, ItemHoverContext context) {
        // Evaluate expressions (in the form ${expression} or <%expression%> (backwards-compat))
        StringBuilder ret = new StringBuilder();

        // For each expression in the hover text, copy the static text that precedes it,
        // then evaluate the expression and copy the result
        int pos = 0;
        for(int i = 0; i < hover.getExpressionLocations().length; i++) {
            int nextPos = hover.getExpressionLocations()[i];
            CompiledExpression expression = hover.getExpressions()[i];

            // Append all text preceding this expression
            ret.append(hover.getHoverText(), pos, nextPos);

            // Insert the expression
            ret.append(evaluateExpression(expression, context));

            // Update pos to nextPos
            pos = nextPos;
        }

        // After the last expression, there might be some static text left to copy
        if(pos < hover.getHoverText().length()) {
            ret.append(hover.getHoverText(), pos, hover.getHoverText().length());
        }

        return ret.toString();
    }

    private static String evaluateExpression(CompiledExpression expression, ItemHoverContext context) {
        NumberFormat formatter = NumberFormat.getNumberInstance(Locale.getDefault());

        try {
            Token result = Evaluator.Evaluate(expression, context);

            if(result.getType() == TokenType.STRING) {
                return result.getValue();
            }

            return formatter.format(result.getNumericValue());
        } catch (IllegalArgumentException e) {
            return "${" + expression.getExpressionText() + "}";
        }
    }
}

package com.geel.customitemhovers;

import net.runelite.api.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.tooltip.Tooltip;
import net.runelite.client.ui.overlay.tooltip.TooltipManager;
import net.runelite.client.util.ColorUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import static net.runelite.api.MenuAction.CC_OP;
import static net.runelite.api.MenuAction.WIDGET_TARGET;
import static net.runelite.api.MenuAction.ITEM_USE;
import static net.runelite.api.MenuAction.ITEM_FIRST_OPTION;
import static net.runelite.api.MenuAction.ITEM_SECOND_OPTION;
import static net.runelite.api.MenuAction.ITEM_THIRD_OPTION;
import static net.runelite.api.MenuAction.ITEM_FOURTH_OPTION;
import static net.runelite.api.MenuAction.ITEM_FIFTH_OPTION;

class CustomItemHoversOverlay extends Overlay
{
	//Interface IDs for the standard inventory container
	private static final Set<Integer> INVENTORY_COMPONENT_IDS = new HashSet<>(
			Arrays.asList(
					InterfaceID.INVENTORY,
					InterfaceID.BANK_INVENTORY,
					InterfaceID.SEED_VAULT_INVENTORY,
					InterfaceID.EXPLORERS_RING
			)
	);

	//Interface IDs which an item hover MenuAction will be related to
	private static final Set<Integer> VALID_INTERFACE_IDS = new HashSet<>(
			Arrays.asList(InterfaceID.INVENTORY, InterfaceID.BANK, InterfaceID.BANK_INVENTORY,
					InterfaceID.SEED_VAULT, InterfaceID.SEED_VAULT_INVENTORY, InterfaceID.EXPLORERS_RING)
	);

	//MenuActions which indicate an item is being hovered on
	private static final Set<MenuAction> VALID_MENU_ACTIONS = new HashSet<>(
			Arrays.asList(CC_OP, ITEM_USE, WIDGET_TARGET, ITEM_FIRST_OPTION, ITEM_SECOND_OPTION,
					ITEM_THIRD_OPTION, ITEM_FOURTH_OPTION, ITEM_FIFTH_OPTION)
	);

	private final Client client;
	private final CustomItemHoversConfig config;
	private final CustomItemHoversPlugin plugin;
	private final TooltipManager tooltipManager;

	@Inject
	CustomItemHoversOverlay(Client client, CustomItemHoversPlugin plugin, CustomItemHoversConfig config, TooltipManager tooltipManager)
	{
		setPosition(OverlayPosition.DYNAMIC);
		this.client = client;
		this.plugin = plugin;
		this.config = config;
		this.tooltipManager = tooltipManager;
	}

	@Override
	public Dimension render(Graphics2D graphics)
	{
		//Don't display anything if a right-click menu is open.
		if (client.isMenuOpen())
			return null;

		//Get the current menu entries; if there aren't any, return.
		final MenuEntry[] menuEntries = client.getMenuEntries();
		if (menuEntries.length <= 0)
			return null;

		final MenuEntry lastEntry = menuEntries[menuEntries.length - 1];
		final MenuAction action = lastEntry.getType();
		final Widget widget = lastEntry.getWidget();

		if(widget == null)
			return null;

		final int widgetId = widget.getId();
		final int interfaceId = widgetId >>> 16;

		if (!VALID_MENU_ACTIONS.contains(action))
			return null;

		if (!VALID_INTERFACE_IDS.contains(interfaceId))
			return null;

		//We should now display a hover.
		ItemContainer container = getContainer(interfaceId);

		if (container == null)
			return null;

		//Get the Item from the Container
		final int containerItemIndex = lastEntry.getParam0();
		final Item item = container.getItem(containerItemIndex);
		if (item == null)
			return null;

		//Get the hovers for this item ID
		String[] hoverTexts = plugin.getItemHovers(item);
		if (hoverTexts.length == 0)
			return null;

		for (String s : hoverTexts) {
			tooltipManager.add(new Tooltip(ColorUtil.prependColorTag(s, config.defaultHoverColor())));
		}

		return null;
	}

	private ItemContainer getContainer(int interfaceId)
	{
		if (INVENTORY_COMPONENT_IDS.contains(interfaceId))
			return client.getItemContainer(InventoryID.INVENTORY);
		else if (interfaceId == InterfaceID.BANK)
			return client.getItemContainer(InventoryID.BANK);
		else if (interfaceId == InterfaceID.SEED_VAULT) {
			return client.getItemContainer(InventoryID.SEED_VAULT);
		}

		return null;
	}
}

package com.geel.customitemhovers;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;

import java.awt.*;

@ConfigGroup("customitemhovers")
public interface CustomItemHoversConfig extends Config {
    @ConfigSection(
            name = "Informational Messages",
            description = "Configures messages that the plugin posts to game chat",
            position = 2
    )
    static String messageSection = "messages";

    @ConfigItem(
            keyName = "hoverEnableHotReload",
            name = "Hot Reload",
            description = "Whether or not Hot Reload is enabled.",
            position = 1
    )
    default boolean hoverEnableHotReload() {
        return false;
    }

    @ConfigItem(
            keyName = "enableObsoleteMessage",
            name = "Deprecated Expression",
            description = "Display a message whenever your hover files are displayed if they contain obsolete expressions",
            section = messageSection,
            position = 1
    )
    default boolean enableObsoleteMessage() {
        return false;
    }

    @ConfigItem(
            keyName = "hoverDefaultColor",
            name = "Default Text Color",
            description = "The default text color for a hover when no color is specified",
            position = 2
    )
    default Color defaultHoverColor() {
        return new Color(238, 238, 238);
    }

    @ConfigItem(
            keyName = "openDirChatCommand",
            name = "Hover Directory Chat Command",
            description = "Chat command to open hoverfile directory in your file explorer",
            position = 3
    )
    default String openDirChatCommand() {
        return "openhoverdir";
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.models.itemtables.ItemTableFile;
import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import com.google.gson.Gson;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.client.game.ItemManager;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Stream;

@Singleton
@Slf4j
/**
 * Manages ItemTables for the plugin.
 *
 * Responsible for loading, parsing, storing, and providing ItemTables from JSON files.
 */
public class ItemTableManager {
    @Inject
    private Gson gson;

    @Inject
    private ItemManager itemManager;

    private HashMap<String, ItemTableFile> parsedFiles = new HashMap<>();
    private HashMap<String, ItemTableCollection> itemMap = new HashMap<>();

    /**
     * Clear the in-memory ItemTable database and load it from scratch
     */
    public void reparseItemDatabase(Path tablePath) {
        if (!Files.isDirectory(tablePath) || !Files.isReadable(tablePath)) {
            return;
        }

        HashMap<String, ItemTableFile> newParsedFiles = new HashMap<>();
        HashMap<String, ItemTableCollection> newItemMap = new HashMap<>();

        try {
            Stream fileStream = Files.list(tablePath);
            for (Iterator it = fileStream.iterator(); it.hasNext(); ) {
                Path p = (Path) it.next();

                //Ensure it's a regular readable file
                if (!Files.isRegularFile(p) || !Files.isReadable(p))
                    continue;

                //Ensure it's a json file
                if (!p.toString().endsWith(".json"))
                    continue;

                ItemTableFile file = parseTableFile(p);

                //Must absolutely be a hover file
                if (file == null || file.IsTableFile == null || !file.IsTableFile.equals("absolutely"))
                    continue;

                // Process file
                newParsedFiles.put(file.Name, file);

                for (String baseItemName : file.Items.keySet()) {
                    ItemTable itemTable = file.Items.get(baseItemName);

                    // Set properties on TableItem
                    itemTable.setParentFile(file);
                    itemTable.setItemName(baseItemName);

                    String[] itemNames = itemTable.getAllNames();
                    for(String itemName : itemNames) {
                        // Store an (itemName -> collection) reference in newItemMap
                        if (!newItemMap.containsKey(itemName)) {
                            newItemMap.put(itemName, new ItemTableCollection());
                        }

                        // Put TableItem into itemMapEntry
                        ItemTableCollection itemMapEntry = newItemMap.get(itemName);
                        itemMapEntry.getItemTables().put(file.Name, itemTable);
                    }
                }
            }
        } catch (Exception e) {
            log.error(e.toString());
        }

        parsedFiles.clear();
        itemMap.clear();

        parsedFiles.putAll(newParsedFiles);
        itemMap.putAll(newItemMap);
    }

    /**
     * Get the ItemCollection associated with the given item name
     */
    public ItemTableCollection getCollectionForItem(String itemName)
    {
        return itemMap.getOrDefault(itemName, new ItemTableCollection());
    }

    /**
     * Get the base ItemTable for the given item.
     *
     * This is a special table, available for every item, which defines certain variables -- eg "id", "qty", etc.
     */
    public ItemTable getBaseTableForItem(Item item) {
        ItemComposition itemComposition = itemManager.getItemComposition(item.getId());

        ItemTable baseTable = new ItemTable();
        baseTable.put("id", String.valueOf(item.getId()));
        baseTable.put("qty", String.valueOf(item.getQuantity()));
        baseTable.put("value", String.valueOf(itemComposition.getPrice()));
        baseTable.put("high_alch", String.valueOf(itemComposition.getHaPrice()));

        return baseTable;
    }

    /**
     * Parse a file from JSON
     * @param tableFile
     * @return
     */
    private ItemTableFile parseTableFile(Path tableFile) {
        try {
            byte[] fileBytes = Files.readAllBytes(tableFile);
            String fileString = new String(fileBytes);

            return gson.fromJson(fileString, ItemTableFile.class);
        } catch (Exception e) {
            log.error(e.toString());
            return null;
        }
    }
}

package com.geel.customitemhovers;

import com.geel.customitemhovers.models.itemtables.ItemTable;
import com.geel.customitemhovers.models.itemtables.ItemTableCollection;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;

import java.util.Locale;

/**
 * Context file for an item hover; used to simplify method signatures internally
 */
public class ItemHoverContext {
    @Getter
    private Item item;

    @Getter
    private ItemComposition itemComposition;

    @Getter
    private ItemTableCollection tableCollection;

    @Getter
    private ItemTable baseTable;

    public ItemHoverContext(Item item, ItemComposition composition, ItemTableCollection tableCollection, ItemTable baseTable) {
        this.item = item;
        this.itemComposition = composition;
        this.tableCollection = tableCollection;
        this.baseTable = baseTable;
    }

    public String resolveVariable(String variableName) {
        variableName = variableName.toLowerCase(Locale.ROOT);

        // Try to resolve via explicit tables, then base table
        String tableCollectionRet = tableCollection.resolveVariable(variableName);
        if(tableCollectionRet != null)
        {
            return tableCollectionRet;
        }

        return baseTable.getOrDefault(variableName, null);
    }
}

package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.ItemHoverContext;
import com.geel.customitemhovers.expressions.models.BaseExpression;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;

import java.util.Stack;

/**
 * Expression evaluator.
 * <p>
 * Responsible for taking the output of the Shunting Yard Algorithm (implemented by `ExpressionCompiler`), and evaluating
 * it to produce a final numerical result.
 */
public class Evaluator {
    /**
     * Evaluates a Reverse Polish Notation queue (output from `ExpressionCompiler`), returning the result
     */
    public static Token Evaluate(CompiledExpression expression, ItemHoverContext context) {
        Token[] rpn = expression.getTokens();
        Stack<Token> stack = new Stack<>();
        for (int i = 0; i < rpn.length; i++) {
            boolean isFirst = i == 0;
            boolean isLast = i == rpn.length - 1;
            Token token = rpn[i];

            // Handle values
            if (token.getType().isValue()) {
                if (isLast && !isFirst) {
                    throw new IllegalArgumentException("Dangling value");
                }
                stack.add(evaluateValue(token, context));
            }

            // Handle functions
            if (token.getType().isFunction()) {
                if (stack.isEmpty()) {
                    throw new IllegalArgumentException("Function called with empty stack");
                }

                Token popped = stack.pop();
                stack.add(evaluateFunction(token, popped, context));
            }

            // Handle operators
            if (token.getType().isOperator()) {
                if (stack.size() < 2) {
                    throw new IllegalArgumentException("Operator called with fewer than 2 items on the stack");
                }

                Token rightHand = stack.pop();
                Token leftHand = stack.pop();
                stack.add(evaluateOperator(token, leftHand, rightHand));
            }
        }

        // Stack should have one entry: the result
        if (stack.size() != 1) {
            throw new IllegalArgumentException("Stack should only have a single entry at the end");
        }

        // Single entry should be a constant integer, double, or string value
        Token result = stack.pop();
        if (!result.getType().isConstant()) {
            throw new IllegalArgumentException("Invalid token type after RPN evaluation");
        }

        // Return result
        return result;
    }

    private static Token evaluateFunction(Token functionToken, Token argToken, ItemHoverContext context) {
        // TODO: Better argument typing restriction system
        if(argToken.getType() == TokenType.STRING) {
            throw new IllegalArgumentException("No functions currently support string arguments");
        }

        Number argValue = argToken.getNumericValue();
        switch (functionToken.getValue()) {
            case "floor":
                return new Token(TokenType.INTEGER, String.valueOf((int) Math.floor(argValue.doubleValue())));
            case "ceil":
                return new Token(TokenType.INTEGER, String.valueOf((int) Math.ceil(argValue.doubleValue())));

            // These three functions are here for backwards-compatibility with the old, garbage, function system
            case "qtymult":
                return new Token(TokenType.INTEGER, String.valueOf(context.getItem().getQuantity() * argValue.intValue()));
            case "qtydivide":
                return new Token(TokenType.INTEGER, String.valueOf(context.getItem().getQuantity() / argValue.intValue()));
            case "qtydivideceil":
                return new Token(TokenType.INTEGER, String.valueOf(Math.ceil((double) context.getItem().getQuantity() / (double) argValue.intValue())));
            default:
                return argToken;
        }
    }

    /**
     * Evaluates a ternary ? operator.
     *
     * The expression `condition ? ifTrue : ifFalse` will result in a token stack of `condition ifTrue ? ifFalse :`.
     *
     * The ? operator receives `condition` and `ifTrue` as its arguments.
     *
     * If `condition` is truthy, then `ifTrue` is the result of this operator.
     * Otherwise, the operator token itself is the result of the operator.
     *
     * After evaluating the above ternary, the resulting stack will look like:
     * [if `condition` is true] `ifTrue ifFalse :`
     * [if `condition` is false] `? ifFalse :`
     *
     * This sets up the `:` operator to do its job
     */
    private static Token evaluateTernaryThen(Token operator, Token condition, Token ifTrue) {
        // Ensure that the number is false in integer or double representation
        // (0.1 is not false)
        if(Math.abs(condition.getNumericValue().doubleValue()) > 0.0000001) {
            return ifTrue;
        }

        return operator;
    }

    /**
     * Evaluates a ternary : operator.
     *
     * After evaluating the ? operator paired with this :, the resulting stack will look like:
     * [if `condition` is true] `ifTrue ifFalse :`
     * [if `condition` is false] `? ifFalse :`
     *
     * So, to evaluate `:`, we just see if the lefthand argument is a `?`.
     * If it is, then we return `ifFalse`.
     * Otherwise, we return the lefthand argument.
     */
    private static Token evaluateTernaryElse(Token ifFalse, Token discriminator) {
        if(discriminator.getType() == TokenType.TERNARY_THEN) {
            return ifFalse;
        }

        return discriminator;
    }

    private static Token evaluateOperator(Token operatorToken, Token leftValue, Token rightValue) {
        // Handle ternary operators specially from the other operators. Fuck the other operators.
        if(operatorToken.getType() == TokenType.TERNARY_THEN) {
            return evaluateTernaryThen(operatorToken, leftValue, rightValue);
        } else if(operatorToken.getType() == TokenType.TERNARY_ELSE) {
            return evaluateTernaryElse(rightValue, leftValue);
        }

        // If either operator is a string, handle it specially
        if(leftValue.getType() == TokenType.STRING || rightValue.getType() == TokenType.STRING) {
            return evaluateStringOperator(operatorToken, leftValue, rightValue);
        }

        Number leftVal, rightVal, result;
        // TODO: Figure out a better way to handle this. Fundamentally, we are trying to figure out:
        // 1. How do we deserialize the input?
        // 2. How do we serialize the output?
        boolean isDoubleInput = isDoubleOperation(operatorToken, leftValue, rightValue);
        boolean isDoubleOutput = isDoubleInput && !operatorToken.getType().isBooleanOperator();

        // I hate this
        if (isDoubleInput) {
            leftVal = Double.parseDouble(leftValue.getValue());
            rightVal = Double.parseDouble(rightValue.getValue());
        } else {
            leftVal = Integer.parseInt(leftValue.getValue());
            rightVal = Integer.parseInt(rightValue.getValue());
        }

        // TODO: Surely this can be done more elegantly
        switch (operatorToken.getType()) {
            case OP_TIMES:
                result = isDoubleInput
                        ? (leftVal.doubleValue() * rightVal.doubleValue())
                        : (leftVal.intValue() * rightVal.intValue());
                break;
            case OP_DIVIDE:
                // Avoid a divide-by-zero
                if (Math.abs(rightVal.doubleValue()) < 0.0000001) {
                    result = 0;
                } else {
                    result = leftVal.doubleValue() / rightVal.doubleValue();
                }
                break;
            case OP_MODULO:
                // Avoid a divide-by-zero
                if (rightVal.intValue() == 0) {
                    result = 0;
                } else {
                    result = leftVal.intValue() % rightVal.intValue();
                }
                break;
            case OP_PLUS:
                result = isDoubleInput
                        ? (leftVal.doubleValue() + rightVal.doubleValue())
                        : (leftVal.intValue() + rightVal.intValue());
                break;
            case OP_MINUS:
                result = isDoubleInput
                        ? (leftVal.doubleValue() - rightVal.doubleValue())
                        : (leftVal.intValue() - rightVal.intValue());
                break;
            case CMP_LT:
                result = leftVal.doubleValue() < rightVal.doubleValue() ? 1 : 0; // EPSILON
                break;
            case CMP_LTE:
                result = (leftVal.doubleValue() - rightVal.doubleValue() < 0.000001) ? 1 : 0; // EPSILON
                break;
            case CMP_GT:
                result = leftVal.doubleValue() > rightVal.doubleValue() ? 1 : 0; // EPSILON
                break;
            case CMP_GTE:
                result = (leftVal.doubleValue() - rightVal.doubleValue() > -0.000001) ? 1 : 0; // EPSILON
                break;
            case CMP_EQUALS:
                result = Math.abs(leftVal.doubleValue() - rightVal.doubleValue()) < 0.000001 ? 1 : 0; // EPSILON
                break;
            case CMP_NEQUALS:
                result = Math.abs(leftVal.doubleValue() - rightVal.doubleValue()) > 0.000001 ? 1 : 0; // EPSILON
                break;
            case LOG_AND:
                result = (leftVal.intValue() != 0 && rightVal.intValue() != 0) ? 1 : 0;
                break;
            case LOG_OR:
                result = (leftVal.intValue() != 0 || rightVal.intValue() != 0) ? 1 : 0;
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + operatorToken.getType());
        }

        return isDoubleOutput
                ? Token.fromDouble(result.doubleValue())
                : Token.fromInt(result.intValue());
    }

    private static Token evaluateStringOperator(Token operatorToken, Token leftValue, Token rightValue) {
        // Operator must be valid for use on strings
        if(!operatorToken.getType().operatorSupportsStringArguments()) {
            throw new IllegalArgumentException("Operator " + operatorToken.getValue() + " does not support strings");
        }

        // Both arguments must be strings
        if(leftValue.getType() != rightValue.getType() || leftValue.getType() != TokenType.STRING) {
            throw new IllegalArgumentException("Both arguments must be string values");
        }

        switch(operatorToken.getType()) {
            case CMP_EQUALS:
                return Token.fromInt(leftValue.getValue().equals(rightValue.getValue()) ? 1 : 0);
            case CMP_NEQUALS:
                return Token.fromInt(leftValue.getValue().equals(rightValue.getValue()) ? 0 : 1);
            case OP_PLUS:
                return Token.fromString(leftValue.getValue() + rightValue.getValue());
            default:
                throw new IllegalArgumentException("Unknown string operator " + operatorToken.getValue());
        }
    }

    /**
     * Determines if an operation requires the use of decimal numbers.
     * <p>
     * This is true if either operand is a decimal itself, or if the operation is a division.
     */
    private static boolean isDoubleOperation(Token operatorToken, Token leftValue, Token rightValue) {
        // If a double is involved on either side, we get a double.
        if (leftValue.getType() == TokenType.DOUBLE || rightValue.getType() == TokenType.DOUBLE) {
            return true;
        }

        // Otherwise, division always results in doubles
        return operatorToken.getType() == TokenType.OP_DIVIDE;
    }

    /**
     * Evaluates a Token to a constant numeric value.
     * <p>
     * If the Token is already a constant number, this just returns the Token.
     * <p>
     * Otherwise, the Token is a variable; the variable is evaluated and, if it's a number, its value is returned.
     */
    private static Token evaluateValue(Token value, ItemHoverContext context) {
        if (value.getType().isConstant()) {
            return value;
        }

        // Evaluate variable
        String variableVal = context.resolveVariable(value.getValue());
        if (variableVal == null) {
            throw new IllegalArgumentException("Unknown variable " + value.getValue());
        }

        // Determine if variable is integer or double
        // TODO: Holy _wow_ this is fucking stupid
        int intVal = 0;
        double doubleVal = 0;
        boolean isInt = false;
        boolean isDouble = false;

        try {
            intVal = Integer.parseInt(variableVal);
            isInt = true;
        } catch (NumberFormatException e) {
        }

        try {
            doubleVal = Double.parseDouble(variableVal);
            isDouble = true;
        } catch (NumberFormatException e) {
        }

        if (isInt) {
            return Token.fromInt(intVal);
        } else if (isDouble) {
            return Token.fromDouble(doubleVal);
        } else {
            return Token.fromString(variableVal);
        }
    }
}

package com.geel.customitemhovers.expressions;

import com.geel.customitemhovers.expressions.models.Token;
import com.geel.customitemhovers.expressions.models.TokenType;
import com.geel.customitemhovers.expressions.models.TokenizedExpression;
import lombok.Getter;

import java.util.ArrayList;

/**
 * Tokenizes a mathematical expression (including variables and functions).
 * <p>
 * Not for external use; used by `ExpressionParser` as first step in parsing of an expression
 */
public class Tokenizer {
    // The text we are evaluating to find an expression in
    private String haystack;

    // The actual expression we've parsed out
    private StringBuilder parsedExpressionBuilder = new StringBuilder();
    private TokenizedExpression tokenizedExpression = null;

    // The tokens we've read so far.
    // Empty if tokenization has not yet begun, or has already finished.
    private final ArrayList<Token> tokens = new ArrayList<>();

    // Where we started reading the string
    private int startPos = 0;

    // How far into the current string we've read
    @Getter
    private int numRead = 0;

    // The current parentheses depth
    private int parenDepth = 0;

    // The current ternary depth
    private int ternaryDepth = 0;

    public Tokenizer(String haystack, int position) {
        this.haystack = haystack;
        this.startPos = position;
    }

    /**
     * Tokenizes the expression and returns the result.
     * <p>
     * If the expression has already been tokenized, just returns the result.
     */
    public TokenizedExpression tokenize() {
        // Do actual tokenization if we haven't yet
        if (numRead == 0) {
            boolean isLegacyExpression = false;
            boolean isFirst = true;
            Token t;
            while ((t = readToken()) != null) {
                TokenType type = t.getType();
                // First token must be expression start, and expression start can only appear as the first token
                if (isFirst && !type.isExpressionBegin()) {
                    throw new IllegalArgumentException("Expected EXPRESSION_START");
                } else if (!isFirst && type.isExpressionBegin()) {
                    throw new IllegalArgumentException("Unexpected EXPRESSION_START");
                }

                // Detect if it's a legacy expression
                if (type.isLegacyExpressionBeginOrEnd()) {
                    isLegacyExpression = true;
                }

                // If we reach an expression end, we're done
                if (type.isExpressionEnd()) {
                    parsedExpressionBuilder.setLength(parsedExpressionBuilder.length() - t.getValue().length());
                    break;
                }

                // Don't add ${ and } to the actual tokenized output / expression
                if (!type.isExpressionBeginOrEnd()) {
                    tokens.add(t);
                } else {
                    // Strip out opening/ending tags from output
                    parsedExpressionBuilder.setLength(parsedExpressionBuilder.length() - t.getValue().length());
                }

                isFirst = false;
            }

            if (!isValidFinalToken()) {
                throw new IllegalArgumentException("Invalid final token in expression");
            }

            // Copy expression into parsedExpression, and clear out haystack and the builder
            tokenizedExpression = new TokenizedExpression(tokens.toArray(new Token[0]), parsedExpressionBuilder.toString(), isLegacyExpression);
            parsedExpressionBuilder.setLength(0);
            parsedExpressionBuilder = null;
            haystack = null;
        }

        // Result is null after we've read some -- expression must be invalid
        if(tokenizedExpression == null) {
            throw new IllegalArgumentException("Invalid expression");
        }

        return tokenizedExpression;
    }

    /**
     * Reads a single Token from the input string.
     * <p>
     * Returns null if the end of the string has been reached.
     */
    private Token readToken() {
        boolean isFirstToken = numRead == 0;

        if ((startPos + numRead) >= haystack.length()) {
            return null;
        }

        // Find the first next character that isn't whitespace
        while (isWhitespaceChar(peekChar()))
            readChar();

        char c = peekChar();

        // Handle expression begin/end. We do this specially here because, although we classify them as
        // "operators" (for ease of parsing), the rules are different for them.
        if (isFirstToken && isExpressionBeginFirstChar(c)) {
            return readOperator();
        } else if (!isFirstToken && isExpressionEndFirstChar(c)) {
            return readOperator();
        }

        // Handle numbers
        if (isNumber(c)) {
            assertCanReadIdentifier();
            return readNumber();
        }

        // Handle strings
        if (c == '\'') {
            assertCanReadIdentifier();
            return readString();
        }

        // Handle identifiers
        if (isNameChar(c)) {
            assertCanReadIdentifier();
            return readIdentifier();
        }

        // Handle parentheses
        if (c == '(') {
            assertCanReadParenStart();
            parenDepth++;
            return readOperator();
        } else if (c == ')') {
            assertCanReadParenEnd();
            parenDepth--;
            return readOperator();
        }

        // Handle ternary
        if (c == '?') {
            assertCanReadTernaryThen();
            ternaryDepth++;
            return readOperator();
        } else if (c == ':') {
            assertCanReadTernaryElse();
            ternaryDepth--;
            return readOperator();
        }

        // Handle all operators
        if (isOperatorChar(c)) {
            assertCanReadOperator();
            return readOperator();
        }

        return null;
    }

    /**
     * Reads a number Token from the string
     */
    private Token readNumber() {
        StringBuilder builder = new StringBuilder();
        boolean hasHadPeriod = false;

        do {
            char c = readChar();
            builder.append(c);

            if (c == '.') {
                if (hasHadPeriod || builder.length() == 1)
                    throw new IllegalArgumentException("Invalid period placement");

                hasHadPeriod = true;
            }
        } while (isNumericChar(peekChar()));

        if (hasHadPeriod) {
            return Token.fromDouble(Double.parseDouble(builder.toString()));
        } else {
            return Token.fromInt(Integer.parseInt(builder.toString()));
        }
    }

    /**
     * Reads a string constant Token from the string
     */
    private Token readString() {
        readChar(); // Discard opening '
        StringBuilder builder = new StringBuilder();
        boolean isEscaping = false;

        char c;
        while ((c = readChar()) != '\0') {
            // If an escape is afoot, just append whatever character is after.
            // There are no invalid escapes :)
            if (isEscaping) {
                builder.append(c);
                isEscaping = false;
                continue;
            }

            // Detect an escapee
            if (c == '\\') {
                isEscaping = true;
                continue;
            }

            // Handle closing string
            if (c == '\'') {
                return new Token(TokenType.STRING, builder.toString());
            }

            // If it's not an escape or a ', I think... any character is valid?
            builder.append(c);
        }

        throw new IllegalArgumentException("End of string reached without string termination");
    }

    /**
     * Reads an identifier Token (variable name, function name) from the string
     */
    private Token readIdentifier() {
        StringBuilder builder = new StringBuilder();

        do {
            char c = readChar();
            builder.append(c);

            if (builder.length() == 1 && isNumber(c)) {
                throw new IllegalArgumentException("First character of an identifier cannot be a number");
            }
        } while (isNameChar(peekChar()));

        // Won't catch a space between identifier and paren. Don't really care atm.
        if (peekChar() == '(') {
            return new Token(TokenType.FUNCTION, builder.toString());
        }

        return new Token(TokenType.VARIABLE, builder.toString());
    }

    /**
     * Reads an operator Token from the string
     */
    private Token readOperator() {
        StringBuilder buff = new StringBuilder();
        buff.append(readChar());

        ArrayList<TokenType> possibleOperators = computeOperatorsStartingWith(buff.toString());
        int offset = 0;
        while (true) {
            char c = peekChar();
            ArrayList<TokenType> newPossibleOperators = constrainOperators(c, ++offset, possibleOperators);

            // If nothing matches the next character, then we need to just use whatever matches `buff`
            if (newPossibleOperators.size() == 0) {
                TokenType type = possibleOperators.stream().filter(p -> p.getConstantValue().length() == buff.length()).findFirst().get();
                return new Token(type, buff.toString());
            }

            possibleOperators = newPossibleOperators;
            buff.append(readChar());

            // If only one matches, and it has the same length as the current buffer, use it
            if (possibleOperators.size() == 1) {
                TokenType type = possibleOperators.get(0);
                if (type.getConstantValue().length() == buff.length()) {
                    break;
                }
            }
        }

        return new Token(possibleOperators.get(0), buff.toString());
    }

    /**
     * Returns a list of the operators which start with the given string
     */
    private static ArrayList<TokenType> computeOperatorsStartingWith(String prefix) {
        ArrayList<TokenType> ret = new ArrayList<>(2);

        for (TokenType tokenType : TokenType.GetOperatorTokenTypes()) {
            if (tokenType.getConstantValue().startsWith(prefix)) {
                ret.add(tokenType);
            }
        }

        return ret;
    }

    /**
     * Returns a list of the operators in `existing` which continue to match with the addition of `newChar`
     */
    private static ArrayList<TokenType> constrainOperators(char newChar, int offset, ArrayList<TokenType> existing) {
        ArrayList<TokenType> ret = new ArrayList<>(2);

        for (TokenType tokenType : existing) {
            String value = tokenType.getConstantValue();

            // If it's too short, don't consider it
            if (offset >= value.length()) {
                continue;
            }

            if (value.charAt(offset) != newChar) {
                continue;
            }

            ret.add(tokenType);
        }

        return ret;
    }

    /**
     * Reads a single character and advances the stream
     */
    private char readChar() {
        if ((startPos + numRead) >= haystack.length()) return '\0';
        char ret = haystack.charAt((startPos + numRead++));
        parsedExpressionBuilder.append(ret);
        return ret;
    }

    /**
     * Reads a single character without advancing the stream
     */
    private char peekChar() {
        if ((startPos + numRead) >= haystack.length()) return '\0';
        return haystack.charAt(startPos + numRead);
    }

    /**
     * Gets the type of the last token we parsed
     */
    private TokenType lastTokenType() {
        return tokens.size() == 0 ? null : tokens.get(tokens.size() - 1).getType();
    }

    /**
     * Determines if an Identifier can start given the last Token
     */
    private void assertCanReadIdentifier() {
        TokenType token = lastTokenType();
        if (!(token == null || token.isOperator() || token == TokenType.PAREN_LEFT)) {
            throw new IllegalArgumentException("Unexpected identifier");
        }
    }

    /**
     * Determines if an Operator can start given the last Token
     */
    private void assertCanReadOperator() {
        TokenType token = lastTokenType();
        if (!(token != null && (token.isValue() || token == TokenType.PAREN_RIGHT))) {
            throw new IllegalArgumentException("Unexpected operator");
        }
    }

    private void assertCanReadTernaryThen() {
        assertCanReadOperator();
    }

    private void assertCanReadTernaryElse() {
        assertCanReadOperator();

        if (ternaryDepth <= 0) {
            throw new IllegalArgumentException("Mismatched ternary : operator");
        }
    }

    /**
     * Determines if a ) can occur given the last Token
     */
    private void assertCanReadParenEnd() {
        if (parenDepth <= 0) {
            throw new IllegalArgumentException("Mismatched ending parenthesis");
        }
        TokenType token = lastTokenType();
        if (!(token != null
                && (token == TokenType.PAREN_RIGHT || token.isValue()))) {
            throw new IllegalArgumentException("Unexpected )");
        }
    }

    /**
     * Determines if a ( can occur given the last Token
     */
    private void assertCanReadParenStart() {
        TokenType token = lastTokenType();
        if (!(token == null
                || token == TokenType.PAREN_LEFT
                || token == TokenType.FUNCTION
                || token.isOperator())) {
            throw new IllegalArgumentException("Unexpected (");
        }
    }

    /**
     * Determines if a Token is a valid ending token
     */
    private boolean isValidFinalToken() {
        TokenType token = lastTokenType();
        return token != null && token.isValue() || token == TokenType.PAREN_RIGHT;
    }

    private static boolean isExpressionBeginFirstChar(char c) {
        return c == '$' || c == '<';
    }

    private static boolean isExpressionEndFirstChar(char c) {
        return c == '}' || c == '%';
    }

    final static char[] allowedOperators = "${}+-*/%><=!&|?:".toCharArray();

    /**
     * Determines if c is a valid operator character
     */
    private static boolean isOperatorChar(char c) {

        for (char t : allowedOperators) {
            if (t == c) return true;
        }

        return false;
    }

    /**
     * Determines if a character is in the character set allowed for identifiers (function and variable names)
     */
    private static boolean isNameChar(char c) {
        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_';
    }

    /**
     * Determines if a character is in the character set allowed for numbers (0-9 and a period)
     */
    private static boolean isNumericChar(char c) {
        return isNumber(c) || c == '.';
    }

    /**
     * Determines if a character is in the character set allowed for numbers (0-9)
     */
    private static boolean isNumber(char c) {
        return (c >= '0' && c <= '9');
    }

    /**
     * Determines if a character is in the character set allowed for whitespace
     */
    private static boolean isWhitespaceChar(char c) {
        return c == ' ' || c == '\t';
    }
}

package com.geel.customitemhovers.expressions;
import com.geel.customitemhovers.expressions.models.*;

import java.util.ArrayList;
import java.util.Stack;

/**
 * Performs the Shunting Yard Algorithm to convert an infix mathematical expression to Reverse Polish Notation (postfix).
 *
 * This is here so that we can enable rich mathematical expressions, including variables and functions, in
 * item hover text.
 */
public class Compiler {
    /**
     * Parses an infix notation (eg "(a + b) - sqrt(12)") expression, returning an Expression object.
     */
    public static CompiledExpression Compile(TokenizedExpression expression) {
        Token[] tokenized = expression.getTokens();
        if (tokenized.length == 0) {
            return new CompiledExpression(expression);
        }

        ArrayList<Token> outputQueue = new ArrayList<>();
        Stack<Token> operatorStack = new Stack<>();

        for (Token token : tokenized) {
            // Handle numbers and variables
            if (token.getType().isValue()) {
                outputQueue.add(token);
                continue;
            }

            // Handle functions
            if (token.getType() == TokenType.FUNCTION) {
                operatorStack.add(token);
                continue;
            }

            // Handle operators
            if (token.getType().isOperator()) {
                // While there exists a token at the top of the stack that should be moved to the output queue
                // before this operator is added to the stack, do so
                while (ShuntOperator(token, operatorStack)) {
                    outputQueue.add(operatorStack.pop());
                }

                operatorStack.add(token);
                continue;
            }

            // Handle left paren
            if (token.getType() == TokenType.PAREN_LEFT) {
                operatorStack.add(token);
            }

            // Handle right paren
            if (token.getType() == TokenType.PAREN_RIGHT) {
                // While the top of the stack isn't a left paren, pop from operator stack to output queue
                while (true) {
                    // If the stack is empty before we hit a left paren, there's a mismatch
                    if (operatorStack.isEmpty()) {
                        throw new IllegalArgumentException("Operator stack empty");
                    }

                    Token popped = operatorStack.pop();
                    if (popped.getType() == TokenType.PAREN_LEFT) {
                        // If we hit a left paren, drop it from the stack and don't move it to the output queue
                        break;
                    }

                    // If not a left paren, just move to the output queue
                    outputQueue.add(popped);
                }

                // If the top of the operator stack is a function, then the function should also be moved now
                if (!operatorStack.isEmpty() && operatorStack.peek().getType() == TokenType.FUNCTION) {
                    outputQueue.add(operatorStack.pop());
                }
            }
        }

        // Cleanup Stack
        while (!operatorStack.isEmpty()) {
            Token popped = operatorStack.pop();

            if (popped.getType().isParenthesis()) {
                throw new IllegalArgumentException("Mismatched parentheses");
            }

            outputQueue.add(popped);
        }

        return new CompiledExpression(outputQueue.toArray(new Token[0]), expression.getExpressionText(), expression.isLegacy());
    }

    /**
     * Called when processing an operator token.
     *
     * Determines if the top of the stack should be popped to the output queue before the new operator
     * is added to the stack.
     */
    private static boolean ShuntOperator(Token newToken, Stack<Token> stack) {
        // No top of stack? Nothing to shunt
        // (I don't know if "shunt" is the right word to actually use, but I like it)
        if (stack.isEmpty()) {
            return false;
        }

        Token topOfStack = stack.peek();

        // If it's a left paren, don't shunt
        if (topOfStack.getType() == TokenType.PAREN_LEFT) {
            return false;
        }

        // If the top has higher precedence than the new operator,
        // OR the same precedence but the new operator is left-associative,
        // it should be shunted.
        int topPrecedence = topOfStack.getType().getPrecedence();
        int newPrecedence = newToken.getType().getPrecedence();

        if (topPrecedence < newPrecedence) {
            return true;
        }

        if (topPrecedence == newPrecedence && !newToken.getType().isRightAssociative()) {
            return true;
        }

        // No shuntage
        return false;
    }
}



package com.geel.customitemhovers.expressions.models;

import lombok.Getter;

public enum TokenType {
    // Order of operations:
    // Parentheses/Functions (0), Multiplication/Division (1), Arithmetic (2), Constants/Variables (3),
    // Range Comparators (<, <=, >, >=) (4), Equality Comparators (==, !=) (5), Logical && (6), Logical || (7),
    // Ternary Then (?) (8), Ternary Else (:) (9)
    // Whitespace (10)
    //
    //PFMDACVRCECLALOTW :)

    PAREN_LEFT(0, "("),
    PAREN_RIGHT(0, ")"),
    FUNCTION(0, null, true),
    OP_TIMES(1, "*"),
    OP_DIVIDE(1, "/"),
    OP_MODULO(1, "%"),
    OP_PLUS(2, "+"),
    OP_MINUS(2, "-"),
    STRING(3, null),
    INTEGER(3, null),
    DOUBLE(3, null),
    VARIABLE(3, null),
    CMP_LT(4, "<"),
    CMP_LTE(4, "<="),
    CMP_GT(4, ">"),
    CMP_GTE(4, ">="),
    CMP_EQUALS(5, "=="),
    CMP_NEQUALS(5, "!="),
    LOG_AND(6, "&&"),
    LOG_OR(7, "||"),
    TERNARY_THEN(8, "?", true),
    TERNARY_ELSE(9, ":", true),
    EXPRESSION_BEGIN(10, "${"),
    EXPRESSION_BEGIN_LEGACY(10, "<%"),
    EXPRESSION_END(10, "}"),
    EXPRESSION_END_LEGACY(10, "%>"),
    WHITESPACE(10, null); // Not a real token

    @Getter
    private final int precedence;

    @Getter
    private final boolean rightAssociative;

    @Getter
    private final String constantValue;

    private TokenType(int precedence, String constantValue) {
        this.precedence = precedence;
        this.constantValue = constantValue;
        this.rightAssociative = false;
    }

    private TokenType(int precedence, String constantValue,  boolean rightAssociative) {
        this.precedence = precedence;
        this.constantValue = constantValue;
        this.rightAssociative = rightAssociative;
    }

    private static TokenType[] operatorTokens = new TokenType[] {
            EXPRESSION_BEGIN, EXPRESSION_BEGIN_LEGACY, EXPRESSION_END, EXPRESSION_END_LEGACY,
            OP_TIMES, OP_DIVIDE, OP_MODULO, OP_MINUS, OP_PLUS,
            CMP_LT, CMP_LTE, CMP_GT, CMP_GTE, CMP_EQUALS, CMP_NEQUALS,
            LOG_AND, LOG_OR, TERNARY_THEN, TERNARY_ELSE, PAREN_LEFT, PAREN_RIGHT
    };

    public static TokenType[] GetOperatorTokenTypes() {
        return operatorTokens;
    }

    public boolean isExpressionBeginOrEnd() {
        return isExpressionBegin() || isExpressionEnd();
    }

    public boolean isLegacyExpressionBeginOrEnd() {
        return this == EXPRESSION_BEGIN_LEGACY || this == EXPRESSION_END_LEGACY;
    }

    public boolean isExpressionBegin() {
        return this == EXPRESSION_BEGIN || this == EXPRESSION_BEGIN_LEGACY;
    }

    public boolean isExpressionEnd() {
        return this == EXPRESSION_END || this == EXPRESSION_END_LEGACY;
    }

    public boolean isArithmetic() {
        return this == OP_PLUS || this == OP_MINUS;
    }

    public boolean isMultDiv() {
        return this == OP_TIMES || this == OP_DIVIDE || this == OP_MODULO;
    }

    public boolean isLogicalOperator() {
        return this == LOG_AND || this == LOG_OR;
    }

    public boolean isComparatorOperator() {
        return this == CMP_LT || this == CMP_GT || this == CMP_LTE || this == CMP_GTE || this == CMP_EQUALS || this == CMP_NEQUALS;
    }

    public boolean operatorSupportsStringArguments() {
        return this == CMP_EQUALS || this == CMP_NEQUALS || this == OP_PLUS;
    }

    public boolean isTernaryOperator() {
        return this == TERNARY_THEN || this == TERNARY_ELSE;
    }

    public boolean isBooleanOperator() {
        return isLogicalOperator() || isComparatorOperator();
    }

    public boolean isOperator() {
        return isArithmetic() || isMultDiv() || isLogicalOperator() || isComparatorOperator() || isTernaryOperator();
    }

    public boolean isParenthesis() {
        return this == PAREN_LEFT || this == PAREN_RIGHT;
    }

    public boolean isValue() {
        return isVariable() || isConstant();
    }

    public boolean isFunction() {
        return this == FUNCTION;
    }

    public boolean isVariable() {
        return this == VARIABLE;
    }

    public boolean isConstant() {
        return this == INTEGER || this == DOUBLE || this == STRING;
    }

    public boolean isIdentifier() {
        return isValue() || isFunction();
    }
}
package com.geel.customitemhovers.expressions.models;

/**
 * An expression, after being tokenized, but before parsing.
 */
public class TokenizedExpression extends BaseExpression {
    public TokenizedExpression(Token[] tokens, String expressionText, boolean isLegacy) {
        super(tokens, expressionText, isLegacy);
    }

    public TokenizedExpression(BaseExpression expression) {
        super(expression.getTokens(), expression.getExpressionText(), expression.isLegacy());
    }
}

package com.geel.customitemhovers.expressions.models;

/**
 * A "compiled" expression, after tokenization and parsing.
 *
 * TODO: Figure out a way to collapse constexpr expressions, eg:
 *      "(3 + 4) * 2" should collapse to a single constant token "24"
 *      "sqrt(3 + 4 + 2) * a" should collapse to "3.0 * a"
 */
public class CompiledExpression extends BaseExpression {
    public CompiledExpression(Token[] tokens, String expressionText, boolean isLegacy) {
        super(tokens, expressionText, isLegacy);
    }

    public CompiledExpression(BaseExpression expression) {
        super(expression.getTokens(), expression.getExpressionText(), expression.isLegacy());
    }
}

package com.geel.customitemhovers.expressions.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
public class Token {
    @Getter
    private TokenType type;

    @Getter
    private String value; // TODO: Make more efficient than Strings. Are slices a thing in Java?

    public Number getNumericValue() {
        if(type == TokenType.INTEGER) {
            return Integer.parseInt(value);
        } else if(type == TokenType.DOUBLE) {
            return Double.parseDouble(value);
        } else {
            throw new IllegalArgumentException("Not a number type");
        }
    }

    public static Token fromDouble(double value) {
        return new Token(TokenType.DOUBLE, String.valueOf(value));
    }

    public static Token fromInt(int value) {
        return new Token(TokenType.INTEGER, String.valueOf(value));
    }

    public static Token fromString(String value) {
        return new Token(TokenType.STRING, value);
    }
}

package com.geel.customitemhovers.expressions.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
public class BaseExpression {
    /**
     * The Tokens that make up this expression, in Reverse Polish Notation
     */
    @Getter
    private Token[] tokens;

    /**
     * The original raw text of the expression
     */
    @Getter
    private String expressionText;

    /**
     * Whether the expression is "legacy" (begins with <% and ends with %>)
     */
    @Getter
    private boolean isLegacy = false;
}

package com.geel.customitemhovers.models.hovers;

import com.geel.customitemhovers.HoverEvaluator;
import com.geel.customitemhovers.ItemHoverContext;
import com.google.gson.annotations.SerializedName;

/**
 * A parsed entry in a hoverfile.
 */
public class HoverDef {
    @SerializedName("ids")
    public int[] ItemIDs;

    @SerializedName("items")
    public String[] ItemNames;

    @SerializedName("items_regex")
    public String[] ItemNamesRegex;

    @SerializedName("hovers")
    public String[][] HoverTexts;

    /**
     * An array of Hovers; each element in this array corresponds to an individual hover box that should be rendered.
     *
     * This is produced from `HoverTexts`, which is a 2D array of strings.
     * Each sub-array of strings in `HoverTexts` is treated as an array of lines which are concatenated together.
     */
    public ParsedHover[] ParsedHoverTexts;

    /**
     * Creates and returns an array of hover text strings, after transformation for a specific item.
     *
     * Transformation involves replacing function calls with their results, and variables with their values.
     */
    public String[] GetTransformedTexts(ItemHoverContext context) {
        String[] transformed = new String[ParsedHoverTexts.length];

        int i = 0;
        for(ParsedHover text : ParsedHoverTexts) {
            transformed[i++] = HoverEvaluator.Evaluate(text, context);
        }

        return transformed;
    }
}

package com.geel.customitemhovers.models.hovers;

import com.google.gson.annotations.SerializedName;

public class HoverFile {
    @SerializedName("is_hover_map")
    public String IsHoverMap;

    @SerializedName("hovers")
    public HoverDef[] Hovers;
}
package com.geel.customitemhovers.models.hovers;

import com.geel.customitemhovers.expressions.models.BaseExpression;
import com.geel.customitemhovers.expressions.models.CompiledExpression;
import lombok.AllArgsConstructor;
import lombok.Getter;

/**
 * A parsed Hover from a HoverFile.
 *
 * One ParsedHover is created for every 1D hover array in the 2D array of a HoverDef. That is, for every individual
 * hover box.
 *
 * This class exists as a caching mechanism for expressions; we want to parse (tokenize + shunting-yard) hover texts
 * as infrequently as possible (on load only).
 *
 * Therefore, `hoverText` contains a hoverbox text with all expressions removed.
 * `expressionLocations` is an ascending array of positions that expression results should be inserted,
 * and `expressions` is an array of expressions.
 *
 * To fully resolve `hoverText`, simply copy it, and then iterate through `expressionLocations` and `expressions`
 * simultaneously (their indexes align) -- evaluate each expression in turn, and insert the string result into
 * `hoverText` at the location indicated by `expressionLocations[i]`.
 */
@AllArgsConstructor
public class ParsedHover {
    /**
     * The text for this hover box, without any expressions.
     *
     * If any expressions were present in the original text, use `expressionLocations` and `expressions` to
     * build the final text.
     */
    @Getter
    private final String hoverText;

    @Getter
    private final Integer[] expressionLocations;

    @Getter
    private final CompiledExpression[] expressions;
}

package com.geel.customitemhovers.models.itemtables;

import lombok.Getter;

import java.util.HashMap;

/**
 * A collection of multiple ItemTables for a single item.
 *
 * An item can have multiple ItemTables if multiple ItemTableFiles contain ItemTables for the item.
 */
public class ItemTableCollection {
    @Getter
    private HashMap<String, ItemTable> itemTables;

    public ItemTableCollection() {
        this.itemTables = new HashMap<>();
    }

    public String resolveVariable(String variableName) {
        for (ItemTable i : itemTables.values()) {
            String val = i.getOrDefault(variableName, null);

            if (val == null) {
                continue;
            }

            return val;
        }

        return null;
    }
}

package com.geel.customitemhovers.models.itemtables;

import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

/**
 * A parsed entry in an ItemTableFile.
 *
 * Contains variables that are "attached" to items
 */
public class ItemTable extends HashMap<String, String> {
    @Getter
    @Setter
    private String itemName;

    @Getter
    @Setter
    private ItemTableFile parentFile;

    public String[] getAllNames() {
        ArrayList<String> ret = new ArrayList<>();
        ret.add(this.itemName);

        // Handle $also
        String also = this.getOrDefault("$also", null);
        if (also != null) {
            ret.addAll(Arrays.asList(also.split("\\|")));
        }

        return ret.toArray(new String[0]);
    }
}

package com.geel.customitemhovers.models.itemtables;

import com.google.gson.annotations.SerializedName;

import java.util.Map;

public class ItemTableFile {
    @SerializedName("is_table_file")
    public String IsTableFile;

    @SerializedName("name")
    public String Name;

    @SerializedName("items")
    public Map<String, ItemTable> Items;
}
