[{"commit":"ccde3741496bd6927db70de90c545ad6e4cf1ed5","repository":"https://github.com/kuldarvakker/keybinds-overlay.git","internalName":"keybinds-overlay","files":[{"fileName":"KeybindsOverlayConfig.java","content":"package com.keybindsOverlay;\n\nimport net.runelite.client.config.*;\n\nimport java.awt.event.KeyEvent;\n\n@ConfigGroup(\"example\")\npublic interface KeybindsOverlayConfig extends Config\n{\n\t@ConfigSection(\n\t\t\tposition \u003d 1,\n\t\t\tname \u003d \"Overlay\",\n\t\t\tdescription \u003d \"Settings for the overlay.\"\n\n\t)\n\tString keybindsSection \u003d \"keybinds\";\n\n\t@ConfigSection(\n\t\t\tposition \u003d 2,\n\t\t\tname \u003d \"Order of the icons\",\n\t\t\tdescription \u003d \"Settings for the icons \\n 1 \u003c--\u003e 7\"\n\n\t)\n\tString iconOrderSection \u003d \"layout\";\n\n\t@ConfigItem(\n\t\t\tposition \u003d 0,\n\t\t\tkeyName \u003d \"combat_icon\",\n\t\t\tname \u003d \"Combat icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int combatLocation(){ return 1; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"skills_icon\",\n\t\t\tname \u003d \"Skills icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int skillsLocation(){ return 2; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"quests_icon\",\n\t\t\tname \u003d \"Quests icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int questsLocation(){ return 3; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"inventory_icon\",\n\t\t\tname \u003d \"Inventory icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int inventoryLocation(){ return 4; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"equipment_icon\",\n\t\t\tname \u003d \"Equipment icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int equipmentLocation(){ return 5; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"prayer_icon\",\n\t\t\tname \u003d \"Prayer icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\n\tdefault int prayerLocation(){ return 6; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"spellbook_icon\",\n\t\t\tname \u003d \"Spellbook icon\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d iconOrderSection\n\t)\n\tdefault int spellbookLocation(){ return 7; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"combat\",\n\t\t\tname \u003d \"Combat\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind combatKey(){ return new Keybind(KeyEvent.VK_F1, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"skills\",\n\t\t\tname \u003d \"Skills\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind skillsKey(){ return new Keybind(KeyEvent.VK_F2, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"quests\",\n\t\t\tname \u003d \"Quests\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind questsKey(){ return new Keybind(KeyEvent.VK_F3, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"inventory\",\n\t\t\tname \u003d \"Inventory\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind inventoryKey(){ return new Keybind(KeyEvent.VK_ESCAPE, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 7,\n\t\t\tkeyName \u003d \"equipment\",\n\t\t\tname \u003d \"Equipment\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind equipmentKey(){ return new Keybind(KeyEvent.VK_F4, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 8,\n\t\t\tkeyName \u003d \"prayers\",\n\t\t\tname \u003d \"Prayers\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind prayerKey(){ return new Keybind(KeyEvent.VK_F5, 0); }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 9,\n\t\t\tkeyName \u003d \"spellbook\",\n\t\t\tname \u003d \"Spellbook\",\n\t\t\tdescription \u003d \"\",\n\t\t\tsection \u003d keybindsSection\n\t)\n\tdefault Keybind spellbookKey(){ return new Keybind(KeyEvent.VK_F6, 0); }\n}\n","filePath":"src\\main\\java\\com\\keybindsOverlay\\KeybindsOverlayConfig.java"},{"fileName":"KeybindsOverlayOverlay.java","content":"package com.keybindsOverlay;\n\nimport net.runelite.client.config.Keybind;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.components.ComponentOrientation;\nimport net.runelite.client.ui.overlay.components.ImageComponent;\nimport net.runelite.client.ui.overlay.components.LineComponent;\nimport net.runelite.client.ui.overlay.components.PanelComponent;\n\nimport javax.inject.Inject;\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.image.BufferedImage;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\npublic class KeybindsOverlayOverlay extends Overlay {\n\n    private final KeybindsOverlayConfig config;\n    private final PanelComponent panelComponent \u003d new PanelComponent();\n\n    @Inject\n    private KeybindsOverlayOverlay(KeybindsOverlayConfig config)\n    {\n        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);\n        setPriority(OverlayPriority.HIGH);\n        this.config \u003d config;\n\n    }\n\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n\n        panelComponent.getChildren().clear();\n\n        panelComponent.setOrientation(ComponentOrientation.HORIZONTAL);\n        panelComponent.setGap(new Point(20, 0));\n\n\n        for (sidePanelTab tab: getOrderOfTabs())\n        {\n            if (isKeybindingDefined(getKeybinding(tab))) {\n                addTabToPanel(tab);\n            }\n        }\n\n        return panelComponent.render(graphics);\n    }\n\n    private void addLine(String text)\n    {\n        panelComponent.getChildren().add(LineComponent.builder()\n                .right(text.substring(0, Math.min(3, text.length())).toUpperCase())\n                .rightColor(Color.PINK)\n                .build());\n    }\n\n    private void addIcon(BufferedImage icon)\n    {\n        panelComponent.getChildren()\n                .add(new ImageComponent(icon));\n    }\n\n    private void addTabToPanel(sidePanelTab tab)\n    {\n        addIcon(tab.getIcon());\n        addKeybinding(getKeybinding(tab));\n    }\n\n    private Keybind getKeybinding(sidePanelTab tab) {\n        Keybind keybind;\n        try {\n            keybind \u003d (Keybind) tab.getKeybindingMethod().invoke(config);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            keybind \u003d new Keybind(KeyEvent.VK_UNDEFINED,0);\n        }\n        return keybind;\n    }\n\n    private int getLocation(sidePanelTab tab)\n    {\n        int location;\n        try {\n            location \u003d (int) tab.getLocationMethod().invoke(config);\n        } catch (IllegalAccessException | InvocationTargetException e) {\n            Random random \u003d new Random();\n            location \u003d 20 + random.nextInt(14);\n        }\n        return location;\n    }\n\n    private void addKeybinding(Keybind keybind)\n    {\n        addLine(String.valueOf(keybind));\n    }\n\n    private boolean isKeybindingDefined(Keybind keybind)\n    {\n        return keybind.getKeyCode() !\u003d KeyEvent.VK_UNDEFINED;\n    }\n\n    private Set\u003csidePanelTab\u003e getOrderOfTabs()\n    {\n        Map\u003csidePanelTab, Integer\u003e orderOfTabs \u003d new HashMap\u003c\u003e();\n        for (sidePanelTab tab: sidePanelTab.values()){\n            orderOfTabs.merge(tab, getLocation(tab), (oldVale, newValue)-\u003e newValue);\n            getLocation(tab);\n        }\n\n        return orderOfTabs.entrySet()\n                .stream()\n                .sorted((Map.Entry.comparingByValue()))\n                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -\u003e e1, LinkedHashMap::new)).keySet();\n\n\n    }\n\n}\n","filePath":"src\\main\\java\\com\\keybindsOverlay\\KeybindsOverlayOverlay.java"},{"fileName":"KeybindsOverlayPlugin.java","content":"package com.keybindsOverlay;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Keybinds Overlay\"\n)\npublic class KeybindsOverlayPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate KeybindsOverlayOverlay overlay;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\toverlayManager.add(overlay);\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\toverlayManager.remove(overlay);\n\t}\n\n\t@Provides\n\tKeybindsOverlayConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(KeybindsOverlayConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\keybindsOverlay\\KeybindsOverlayPlugin.java"},{"fileName":"sidePanelTab.java","content":"package com.keybindsOverlay;\n\nimport net.runelite.client.util.ImageUtil;\n\nimport java.awt.image.BufferedImage;\nimport java.lang.reflect.Method;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic enum sidePanelTab {\n\n     COMBAT, SKILLS, QUESTS, INVENTORY, EQUIPMENT, PRAYER, SPELLBOOK;\n\n    // Not in use tabs rn.\n    // ACCOUNT_MANAGEMENT, CLAN_CHAT, EMOTE,  FRIENDS, LOGOUT, MUSIC, OPTIONS\n\n    public BufferedImage getIcon() {\n        try {\n            return ImageUtil.resizeImage(ImageUtil.loadImageResource(getClass(), \"/sidePanel/tabs/\"+ name().toLowerCase() + \".png\"), 18, 18);\n        } catch (Exception e) {\n            System.err.println(\"errorLoading image\");\n        }\n        throw new RuntimeException(\"Shouldn\u0027t be here.\");\n    }\n\n    public Method getKeybindingMethod() {\n        return getMethod(name(), \"Key\");\n    }\n\n    public Method getLocationMethod() {\n        return getMethod(name(), \"Location\");\n    }\n\n    private Method getMethod(String mainSpecifier, String secondSpecifier)\n    {\n        Method[] methods \u003d KeybindsOverlayConfig.class.getMethods();\n        Pattern pattern \u003d Pattern.compile(mainSpecifier.toLowerCase() + secondSpecifier);\n        for (Method method : methods) {\n            Matcher matcher \u003d pattern.matcher(method.getName());\n            if (matcher.lookingAt()) {\n                return method;\n            }\n        }\n        throw new RuntimeException(\"Programming error. \\n\" + mainSpecifier + secondSpecifier);\n    }\n\n}\n","filePath":"src\\main\\java\\com\\keybindsOverlay\\sidePanelTab.java"},{"fileName":"KeybindsOverlayPluginTest.java","content":"package com.keybindsOverlay;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class KeybindsOverlayPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(KeybindsOverlayPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\keybindsOverlay\\KeybindsOverlayPluginTest.java"}]},{"commit":"ace2c2a0e786688bba1ae10a579100bef51b6992","repository":"https://github.com/geheur/rainbow-rave.git","internalName":"rainbow-rave","files":[{"fileName":"ItemThreshold.java","content":"/*\n * Copyright (c) 2020, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport lombok.Value;\n\n@Value\nclass ItemThreshold\n{\n\tenum Inequality\n\t{\n\t\tLESS_THAN,\n\t\tMORE_THAN\n\t}\n\n\tprivate final String itemName;\n\tprivate final int quantity;\n\tprivate final Inequality inequality;\n\n\tstatic ItemThreshold fromConfigEntry(String entry)\n\t{\n\t\tif (Strings.isNullOrEmpty(entry))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tInequality operator \u003d Inequality.MORE_THAN;\n\t\tint qty \u003d 0;\n\n\t\tfor (int i \u003d entry.length() - 1; i \u003e\u003d 0; i--)\n\t\t{\n\t\t\tchar c \u003d entry.charAt(i);\n\t\t\tif (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027 || Character.isWhitespace(c))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (c)\n\t\t\t{\n\t\t\t\tcase \u0027\u003c\u0027:\n\t\t\t\t\toperator \u003d Inequality.LESS_THAN;\n\t\t\t\t\t// fallthrough\n\t\t\t\tcase \u0027\u003e\u0027:\n\t\t\t\t\tif (i + 1 \u003c entry.length())\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqty \u003d Integer.parseInt(entry.substring(i + 1).trim());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NumberFormatException e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tqty \u003d 0;\n\t\t\t\t\t\t\toperator \u003d Inequality.MORE_THAN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tentry \u003d entry.substring(0, i);\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\treturn new ItemThreshold(entry.trim(), qty, operator);\n\t}\n\n\tboolean quantityHolds(int itemCount)\n\t{\n\t\tif (inequality \u003d\u003d Inequality.LESS_THAN)\n\t\t{\n\t\t\treturn itemCount \u003c quantity;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn itemCount \u003e quantity;\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/ItemThreshold.java"},{"fileName":"RainbowRaveObjectIndicatorsOverlay.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Shape;\nimport java.awt.Stroke;\nimport net.runelite.api.Client;\nimport net.runelite.api.DecorativeObject;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.GroundObject;\nimport net.runelite.api.ObjectComposition;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.WallObject;\nimport net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\n\nclass RainbowRaveObjectIndicatorsOverlay extends Overlay\n{\n\tprivate final Client client;\n\tprivate final ObjectIndicatorsConfig config;\n\tprivate final RainbowRaveObjectIndicatorsPlugin plugin;\n\tprivate final RainbowRaveConfig rainbowRaveConfig;\n\tprivate final ModelOutlineRenderer modelOutlineRenderer;\n\tprivate final RainbowRavePlugin rainbowRavePlugin;\n\n\tpublic RainbowRaveObjectIndicatorsOverlay(Client client, ObjectIndicatorsConfig config, RainbowRaveObjectIndicatorsPlugin plugin,\n\t\t\t\t\t\t\t\t\t\t\t   ModelOutlineRenderer modelOutlineRenderer, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.config \u003d config;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.modelOutlineRenderer \u003d modelOutlineRenderer;\n\t\tthis.rainbowRaveConfig \u003d rainbowRaveConfig;\n\t\tthis.rainbowRavePlugin \u003d rainbowRavePlugin;\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetPriority(Overlay.PRIORITY_LOW);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tStroke stroke \u003d new BasicStroke((float) config.borderWidth());\n\t\tint plane \u003d client.getTopLevelWorldView().getPlane();\n\t\tfor (ColorTileObject colorTileObject : plugin.getObjects())\n\t\t{\n\t\t\tTileObject object \u003d colorTileObject.getTileObject();\n\t\t\tColor color \u003d rainbowRavePlugin.getColor(colorTileObject.hashCode());\n\n\t\t\tif (object.getPlane() !\u003d plane)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObjectComposition composition \u003d colorTileObject.getComposition();\n\t\t\tif (composition.getImpostorIds() !\u003d null)\n\t\t\t{\n\t\t\t\t// This is a multiloc\n\t\t\t\tcomposition \u003d composition.getImpostor();\n\t\t\t\t// Only mark the object if the name still matches\n\t\t\t\tif (composition \u003d\u003d null\n\t\t\t\t\t|| Strings.isNullOrEmpty(composition.getName())\n\t\t\t\t\t|| \"null\".equals(composition.getName())\n\t\t\t\t\t|| !composition.getName().equals(colorTileObject.getName()))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (color \u003d\u003d null)\n\t\t\t{\n\t\t\t\t// Fallback to the current config if the object is marked before the addition of multiple colors\n\t\t\t\tcolor \u003d config.markerColor();\n\t\t\t}\n\n\t\t\tif (config.highlightHull())\n\t\t\t{\n\t\t\t\trenderConvexHull(graphics, object, color, stroke);\n\t\t\t}\n\n\t\t\tif (config.highlightOutline())\n\t\t\t{\n\t\t\t\tmodelOutlineRenderer.drawOutline(object, (int)config.borderWidth(), color, config.outlineFeather());\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void renderConvexHull(Graphics2D graphics, TileObject object, Color color, Stroke stroke)\n\t{\n\t\tfinal Shape polygon;\n\t\tShape polygon2 \u003d null;\n\n\t\tif (object instanceof GameObject)\n\t\t{\n\t\t\tpolygon \u003d ((GameObject) object).getConvexHull();\n\t\t}\n\t\telse if (object instanceof WallObject)\n\t\t{\n\t\t\tpolygon \u003d ((WallObject) object).getConvexHull();\n\t\t\tpolygon2 \u003d ((WallObject) object).getConvexHull2();\n\t\t}\n\t\telse if (object instanceof DecorativeObject)\n\t\t{\n\t\t\tpolygon \u003d ((DecorativeObject) object).getConvexHull();\n\t\t\tpolygon2 \u003d ((DecorativeObject) object).getConvexHull2();\n\t\t}\n\t\telse if (object instanceof GroundObject)\n\t\t{\n\t\t\tpolygon \u003d ((GroundObject) object).getConvexHull();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpolygon \u003d object.getCanvasTilePoly();\n\t\t}\n\n\t\tif (polygon !\u003d null)\n\t\t{\n\t\t\tOverlayUtil.renderPolygon(graphics, polygon, color, stroke);\n\t\t}\n\n\t\tif (polygon2 !\u003d null)\n\t\t{\n\t\t\tOverlayUtil.renderPolygon(graphics, polygon2, color, stroke);\n\t\t}\n\t}\n}","filePath":"src/main/java/com/rainbowrave/RainbowRaveObjectIndicatorsOverlay.java"},{"fileName":"RainbowRaveConfig.java","content":"package com.rainbowrave;\n\nimport static com.rainbowrave.RainbowRaveConfig.NpcsToHighlight.SAME;\nimport lombok.RequiredArgsConstructor;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.plugins.grounditems.config.HighlightTier;\n\n@ConfigGroup(RainbowRavePlugin.GROUP)\npublic interface RainbowRaveConfig extends Config\n{\n\n\tString LOOT_BEAMS_TIER_CONFIG_KEY \u003d \"groundItemsLootbeamTier\";\n\tString LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY \u003d \"groundItemsHighlightedItemsLootbeam\";\n\n\tenum NpcsToHighlight {\n\t\tNONE,\n\t\tSAME,\n\t\tALL\n\t}\n\n\tenum ObjectsToHighlight {\n\t\tNONE,\n\t\tSAME,\n\t\tALL\n\t}\n\n\tenum ItemsToTag {\n\t\tNONE,\n\t\tSAME,\n\t\tALL\n\t}\n\n\t@RequiredArgsConstructor\n\tenum GroundItemsToColor {\n\t\tNONE(HighlightTier.INSANE.ordinal() + 1),\n\t\tINSANE(HighlightTier.INSANE.ordinal()),\n\t\tHIGH(HighlightTier.HIGH.ordinal()),\n\t\tMEDIUM(HighlightTier.MEDIUM.ordinal()),\n\t\tLOW(HighlightTier.LOW.ordinal()),\n\t\tREGULAR(HighlightTier.LOW.ordinal() - 1),\n\t\tHIDDEN(HighlightTier.LOW.ordinal() - 2),\n\t\t;\n\n\t\tpublic final int highlightTierRelativeOrdinal;\n\t}\n\n\tenum GroundMarkerColorMode {\n\t\tWAVES,\n\t\tRANDOM,\n\t\tCOLOR_SYNC\n\t}\n\n\tenum MouseTrailStyle {\n\t\tNONE,\n\t\tENABLED,\n\t\tSYNCED,\n\t\tPARTYMODE,\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"theme\",\n\t\t\tname \u003d \"Theme\",\n\t\t\tdescription \u003d \"The color theme used for highlighting things.\",\n\t\t\tposition \u003d 0\n\t)\n\tdefault Theme theme()\n\t{\n\t\treturn Theme.RAINBOW;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"colorSpeed\",\n\t\tname \u003d \"Color speed (ms)\",\n\t\tdescription \u003d \"How fast the colors change (ms per full cycle)\",\n\t\tposition \u003d 0\n\t)\n\tdefault int colorSpeed()\n\t{\n\t\treturn 6000;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"syncColor\",\n\t\tname \u003d \"Sync colors\",\n\t\tdescription \u003d \"Make all highlighted things be the same color as each other.\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean syncColor()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"highlightSelf\",\n\t\tname \u003d \"Highlight self\",\n\t\tdescription \u003d \"Highlight your own player character. Uses Npc Indicator\u0027s settings.\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean highlightSelf()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"highlightOthers\",\n\t\tname \u003d \"Highlight others\",\n\t\tdescription \u003d \"Highlight other players\u0027 characters. Uses Npc Indicator\u0027s settings.\",\n\t\tposition \u003d 3\n\t)\n\tdefault boolean highlightOthers()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"whichNpcsToHighlight\",\n\t\tname \u003d \"Npc highlight\",\n\t\tdescription \u003d \"Which npcs to highlight\",\n\t\tposition \u003d 4\n\t)\n\tdefault NpcsToHighlight whichNpcsToHighlight()\n\t{\n\t\treturn SAME;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"rainbowTileMarkers\",\n\t\tname \u003d \"Rainbow tile markers\",\n\t\tdescription \u003d \"Make tile markers rainbow\",\n\t\tposition \u003d 5\n\t)\n\tdefault boolean rainbowTileMarkers()\n\t{\n\t\treturn true;\n\t}\n\n\tString OLD_TILE_COLOR_WAVES_KEY \u003d \"smoothWaves\";\n\tString GROUND_MARKER_COLOR_MODE_KEY \u003d \"groundMarkerColorMode\";\n\n\t@ConfigItem(name\u003d\n\t\t\"Tile Color Mode\",\n\t\tdescription \u003d \"\\\"waves\\\" makes tile color smooth between adjacent tiles, and \\\"color sync\\\" makes tiles with the same color in ground markers share the same color.\", keyName \u003d GROUND_MARKER_COLOR_MODE_KEY, position \u003d 6\n\t) default GroundMarkerColorMode groundMarkerColorMode() { return GroundMarkerColorMode.RANDOM; }\n\n\t@ConfigItem(name\u003d\n\t\t\"Fill tiles\",\n\t\tdescription \u003d \"Fills the tile with an opaque square.\", keyName \u003d \"fillTiles\", position \u003d 7\n\t) default boolean fillTiles() { return false; }\n\n\t@ConfigItem(name\u003d\n\t\t\"Brush Marker Tiles\",\n\t\tdescription \u003d \"Applies rainbow to tile markers from the \\\"Brush Markers\\\" plugin hub plugin. This plugin can be used to mark lots of tiles at once.\", keyName \u003d \"useBrushMarkerTiles\", position \u003d 8\n\t) default boolean useBrushMarkerTiles() { return false; }\n\n\t@ConfigItem(name\u003d\n\t\t\"Object highlight\",\n\t\tdescription \u003d \"Which objects to highlight.\", keyName \u003d \"whichObjectsToHighlight\", position \u003d 9\n\t) default ObjectsToHighlight whichObjectsToHighlight() { return ObjectsToHighlight.SAME; }\n\n\t@ConfigItem(name\u003d\n\t\t\"Inventory tags\",\n\t\tdescription \u003d \"Which items to tag.\", keyName \u003d \"whichItemsToInventoryTag\", position \u003d 10\n\t) default ItemsToTag whichItemsToInventoryTag() { return ItemsToTag.SAME; }\n\n\t@ConfigItem(name \u003d\n\t\t\"Highlight Ground Items\",\n\t\tdescription \u003d \"Applies rainbow to highlighted items.\", keyName \u003d \"colorHighlightedGroundItems\", position \u003d 11\n\t) default boolean colorHighlightedGroundItems() { return true; }\n\n\t@ConfigItem(name \u003d\n\t\t\"Ground Items\",\n\t\tdescription \u003d \"Items in this tier and above are colored.\", keyName \u003d \"whichGroundItemsToColor\", position \u003d 12\n\t) default GroundItemsToColor whichGroundItemsToColor() { return GroundItemsToColor.REGULAR; }\n\n\t@ConfigItem(name \u003d\n\t\t\"Scythe swings\",\n\t\tdescription \u003d \"Recolor scythe swings. Swing trails may not return to normal after disabling.\", keyName \u003d \"recolorScytheSwings\", position \u003d 13\n\t) default boolean recolorScytheSwings() { return false; }\n\n\tString RECOLOR_LOOT_BEAMS_KEY \u003d \"recolorLootBeams\";\n\t@ConfigItem(\n\t\tkeyName \u003d RECOLOR_LOOT_BEAMS_KEY,\n\t\tname \u003d \"Loot beams\",\n\t\tdescription \u003d \"Recolor loot beams.\",\n\t\tposition \u003d 14\n\t)\n\tdefault boolean recolorLootBeams()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"whichMouseTrailStyle\",\n\t\t\tname \u003d \"Mouse Trail Style\",\n\t\t\tdescription \u003d \"Which trail style to use.\",\n\t\t\tposition \u003d 16\n\t)\n\tdefault MouseTrailStyle whichMouseTrailStyle()\n\t{\n\t\treturn MouseTrailStyle.NONE;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d LOOT_BEAMS_TIER_CONFIG_KEY,\n\t\tname \u003d \"Lootbeam tier\",\n\t\tdescription \u003d \"The lowest tier of which lootbeams should be shown for. You should modify this setting instead of the identical setting in Ground items, if you are using rainbow rave to recolor loot beams.\",\n\t\tposition \u003d 101\n\t)\n\tdefault HighlightTier getGroundItemsLootbeamTier() {\n\t\treturn HighlightTier.OFF; // Needs a value to prevent NPE in some situations.\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d LOOT_BEAMS_TIER_CONFIG_KEY,\n\t\tname \u003d \"\",\n\t\tdescription \u003d \"\",\n\t\thidden \u003d true\n\t)\n\tdefault void setGroundItemsLootbeamTier(HighlightTier tier) {\n\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY,\n\t\tname \u003d \"Highlighted item lootbeams\",\n\t\tdescription \u003d \"Show lootbeams for highlighted items. You should modify this setting instead of the identical setting in Ground items, if you are using rainbow rave to recolor loot beams.\",\n\t\tposition \u003d 100\n\t)\n\tdefault boolean getGroundItemsHighlightedItemsLootbeam() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d LOOT_BEAMS_HIGHLIGHT_CONFIG_KEY,\n\t\tname \u003d \"\",\n\t\tdescription \u003d \"\",\n\t\thidden \u003d true\n\t)\n\tdefault void setGroundItemsHighlightedItemsLootbeam(boolean lootbeamsForHighlightedItems) {\n\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"recolorDukeLights\",\n\t\tname \u003d \"Duke rave\",\n\t\tdescription \u003d \"Recolor the lights at duke. Duke lights may not return to normal after disabling.\",\n\t\tposition \u003d 110\n\t)\n\tdefault boolean dukeRave()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigSection(name \u003d \"Tile Indicators\", description \u003d \"Tile Indicators\", position \u003d 150)\n\tString tileIndicatorsSection \u003d \"tileIndicatorsSection\";\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"recolorTileIndicators\",\n\t\tname \u003d \"Tile indicators\",\n\t\tdescription \u003d \"Recolor the tiles from the tile indicators plugin.\",\n\t\tsection \u003d tileIndicatorsSection,\n\t\tposition \u003d 150\n\t)\n\tdefault boolean recolorTileIndicators() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"recolorTileIndicatorFill\",\n\t\tname \u003d \"Also recolor fill\",\n\t\tdescription \u003d \"Recolor the fill color of tile indicators as well\",\n\t\tsection \u003d tileIndicatorsSection,\n\t\tposition \u003d 151\n\t)\n\tdefault boolean recolorTileIndicatorFill() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"preferCornerTileIndicatorsConfig\",\n\t\tname \u003d \"Prefer \\\"Corner tile indicators\\\"\",\n\t\tdescription \u003d \"Prefers to use the config from my \\\"Corner tile indicators\\\" plugin, if it is installed, including true tile fadeout and corner-only highlight.\",\n\t\tsection \u003d tileIndicatorsSection,\n\t\tposition \u003d 152\n\t)\n\tdefault boolean preferCornerTileIndicatorsConfig() {\n\t\treturn false;\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveConfig.java"},{"fileName":"ColorTileMarker.java","content":"/*\n * Copyright (c) 2019, Jordan Atwood \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport javax.annotation.Nullable;\nimport lombok.Value;\nimport net.runelite.api.coords.WorldPoint;\n\n/**\n * Used to denote marked tiles and their colors.\n * Note: This is not used for serialization of ground markers; see {@link net.runelite.client.plugins.groundmarkers.GroundMarkerPoint}\n */\n@Value\nclass ColorTileMarker\n{\n\tprivate WorldPoint worldPoint;\n\t@Nullable\n\tprivate Color color;\n\t@Nullable\n\tprivate String label;\n}\n","filePath":"src/main/java/com/rainbowrave/ColorTileMarker.java"},{"fileName":"RainbowRaveMouseTrailOverlay.java","content":"/*\n * Copyright (c) 2022, Ryan Bell \u003cllaver@live.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.runelite.api.Point;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\n\nclass RainbowRaveMouseTrailOverlay extends Overlay\n{\n    private final RainbowRavePlugin rainbowRavePlugin;\n    private final RainbowRaveMouseTrailPlugin plugin;\n    private final RainbowRaveConfig rainbowRaveConfig;\n\n    public RainbowRaveMouseTrailOverlay(RainbowRavePlugin rainbowRavePlugin, RainbowRaveMouseTrailPlugin plugin, RainbowRaveConfig rainbowRaveConfig)\n    {\n        this.plugin \u003d plugin;\n        this.rainbowRavePlugin \u003d rainbowRavePlugin;\n        this.rainbowRaveConfig \u003d rainbowRaveConfig;\n        setPosition(OverlayPosition.DYNAMIC);\n        setPriority(Overlay.PRIORITY_HIGH);\n        setLayer(OverlayLayer.ABOVE_WIDGETS);\n    }\n\n    // Function the get the rainbow color for a particular point based on the size of the trail\n    private Color getRainbowColor(int trailSize, int position) {\n        float currentPercent \u003d (float) (position) / (trailSize);\n        float hue \u003d currentPercent * (trailSize);\n        return rainbowRaveConfig.theme().getColor(hue / 100f);\n    }\n\n    // Helper method to handle choosing the correct coloring function\n    private Color getColor(int size, int position) {\n        if (rainbowRaveConfig.whichMouseTrailStyle() \u003d\u003d RainbowRaveConfig.MouseTrailStyle.SYNCED) {\n            return rainbowRavePlugin.getColor(0);\n        }\n        // Fall back to standard coloring\n        return getRainbowColor(size, position);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        // Disable overlay if mouse trail style set to None\n        if (rainbowRaveConfig.whichMouseTrailStyle() \u003d\u003d RainbowRaveConfig.MouseTrailStyle.NONE) {\n            return null;\n        }\n        // Set Partymode variables\n        boolean isPartyMode \u003d rainbowRaveConfig.whichMouseTrailStyle() \u003d\u003d RainbowRaveConfig.MouseTrailStyle.PARTYMODE;\n        // Get ArrayList of Curves\n        List\u003cCurve\u003e trail \u003d new ArrayList\u003c\u003e(plugin.getTrail());\n        // Points to track where to render a line between Curves\n        Point midBefore \u003d null;\n        Point midAfter \u003d null;\n\n        // Set trail size, stroke, and antialiasing\n        graphics.setStroke(new BasicStroke(2, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND));\n        graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        // Fallback default color\n        graphics.setColor(Color.BLUE);\n        // Loop through Curves of trail\n        for(int i \u003d 0; i \u003c trail.size(); i++) {\n            // Get Points from Curve\n            List\u003cPoint\u003e points \u003d trail.get(i).getCurve();\n            // Loop through points\n            for(int j \u003d 0; j \u003c points.size(); j++ ) {\n\n                // Initialize points used to calculate parts of trail with null\n                Point before \u003d null;\n                Point after \u003d null;\n                Point previous \u003d null;\n                Point current \u003d null;\n                // Logic for setting points depending on where in the loops we are\n                if(i !\u003d 0 \u0026\u0026 j \u003d\u003d 0) {\n                    // Get previous list of points from the previous Curve\n                    List\u003cPoint\u003e previousPoints \u003d trail.get(i - 1).getCurve();\n                    before \u003d previousPoints.get(previousPoints.size() - 2);\n                    after \u003d points.get(j + 1);\n                    previous \u003d previousPoints.get(previousPoints.size() - 1);\n                    current \u003d points.get(j);\n                } else if(j \u003e 1) {\n                    // Set points from current Curve\n                    before \u003d points.get(j - 2);\n                    previous \u003d points.get(j - 1);\n                    current \u003d points.get(j);\n                    // If the last point in the Curve, and not the last curve in the trail, get second point from next Curve\n                    if(i \u003c trail.size() - 1 \u0026\u0026 j \u003d\u003d points.size() - 1) {\n                        after \u003d trail.get(i + 1).getCurve().get(1);\n                    }\n                }\n                // Get second to last in previous Curve and third point in current Curve\n                // Will be used to draw another line due to tiny gaps left in between Curves\n                if(j \u003d\u003d 4) {\n                    if (midBefore \u003d\u003d null) {\n                        midBefore \u003d points.get(j);\n                    }\n                } else if (j \u003d\u003d 2 \u0026\u0026 midBefore !\u003d null) {\n                        midAfter \u003d points.get(j);\n                }\n                // Set position and size of trail\n                // Multiply by five due to preset size of Curve\n                // TODO hook curve size multiplier into config\n                int position \u003d i * 5 + j;\n                int size \u003d trail.size() * 5;\n                // Get the rainbow color from helper method.\n                // Dividing by 3 to throttle the speed of the rainbow color\n                final Color color \u003d getColor(isPartyMode ? size : size / 3, isPartyMode ? position : position / 3);\n                graphics.setColor(color);\n\n                // Draw lines of the trail\n                // We are drawing three to fill in gaps and slight inconsistencies\n                // Still a small bug when drawing large circles very quickly\n                // Causes lines to occasionally overlap at the edges\n                if(previous !\u003d null \u0026\u0026 current !\u003d null) {\n                    graphics.drawLine(previous.getX(), previous.getY(), current.getX(), current.getY());\n                }\n                if(before !\u003d null \u0026\u0026 after !\u003d null) {\n                    graphics.drawLine(before.getX(), before.getY(), after.getX(), after.getY());\n                }\n                if(midBefore !\u003d null \u0026\u0026 midAfter !\u003d null) {\n                    graphics.drawLine(midBefore.getX(), midBefore.getY(), midAfter.getX(), midAfter.getY());\n                    // Progress mid points\n                    midBefore \u003d midAfter;\n                    midAfter \u003d null;\n                }\n            }\n        }\n        return null;\n    }\n}","filePath":"src/main/java/com/rainbowrave/RainbowRaveMouseTrailOverlay.java"},{"fileName":"LootBeam.java","content":"/*\n * Copyright (c) 2021, Trevor \u003chttps://github.com/Trevor159\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport java.util.function.Function;\nimport lombok.RequiredArgsConstructor;\nimport net.runelite.api.Animation;\nimport net.runelite.api.AnimationID;\nimport net.runelite.api.Client;\nimport net.runelite.api.JagexColor;\nimport net.runelite.api.Model;\nimport net.runelite.api.ModelData;\nimport net.runelite.api.RuneLiteObject;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.plugins.grounditems.config.HighlightTier;\n\nclass Lootbeam\n{\n\tfinal RuneLiteObject runeLiteObject;\n\tprivate final Client client;\n\tprivate final ClientThread clientThread;\n\tprivate Color color;\n\tprivate Lootbeam.Style style;\n\tfinal HighlightTier tier;\n\n\t@RequiredArgsConstructor\n\tpublic enum Style\n\t{\n\t\tLIGHT(l -\u003e l.client.loadModel(\n\t\t\t5809,\n\t\t\tnew short[]{6371},\n\t\t\tnew short[]{JagexColor.rgbToHSL(l.color.getRGB(), 1.0d)}\n\t\t), anim(AnimationID.RAID_LIGHT_ANIMATION)),\n\t\tMODERN(l -\u003e\n\t\t{\n\t\t\tModelData md \u003d l.client.loadModelData(43330);\n\t\t\tif (md \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tshort hsl \u003d JagexColor.rgbToHSL(l.color.getRGB(), 1.0d);\n\t\t\tint hue \u003d JagexColor.unpackHue(hsl);\n\t\t\tint sat \u003d JagexColor.unpackSaturation(hsl);\n\t\t\tint lum \u003d JagexColor.unpackLuminance(hsl);\n\t\t\tint satDelta \u003d sat \u003e 2 ? 1 : 0;\n\n\t\t\treturn md.cloneColors()\n\t\t\t\t.recolor((short) 26432, JagexColor.packHSL(hue, sat - satDelta, lum))\n\t\t\t\t.recolor((short) 26584, JagexColor.packHSL(hue, sat, Math.min(lum + 24, JagexColor.LUMINANCE_MAX)))\n\t\t\t\t.light(75 + ModelData.DEFAULT_AMBIENT, 1875 + ModelData.DEFAULT_CONTRAST,\n\t\t\t\t\tModelData.DEFAULT_X, ModelData.DEFAULT_Y, ModelData.DEFAULT_Z);\n\t\t}, anim(AnimationID.LOOTBEAM_ANIMATION)),\n\t\t;\n\n\t\tprivate final Function\u003cLootbeam, Model\u003e modelSupplier;\n\t\tprivate final Function\u003cLootbeam, Animation\u003e animationSupplier;\n\t}\n\n\tprivate static Function\u003cLootbeam, Animation\u003e anim(int id)\n\t{\n\t\treturn b -\u003e b.client.loadAnimation(id);\n\t}\n\n\tpublic Lootbeam(Client client, ClientThread clientThread, WorldPoint worldPoint, Color color, String style, HighlightTier tier)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.clientThread \u003d clientThread;\n\t\tthis.tier \u003d tier;\n\t\truneLiteObject \u003d client.createRuneLiteObject();\n\n\t\tthis.color \u003d color;\n\t\tthis.style \u003d style.equals(\"MODERN\") ? Style.MODERN : Style.LIGHT;\n\t\tupdate();\n\t\truneLiteObject.setShouldLoop(true);\n\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\n\t\tLocalPoint lp \u003d LocalPoint.fromWorld(worldView, worldPoint);\n\t\truneLiteObject.setLocation(lp, worldView.getPlane());\n\n\t\truneLiteObject.setActive(true);\n\t}\n\n\tpublic void setColor(Color color)\n\t{\n\t\tif (this.color !\u003d null \u0026\u0026 this.color.equals(color))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.color \u003d color;\n\t\tupdate();\n\t}\n\n\tpublic void setStyle(String styleString)\n\t{\n\t\tStyle style \u003d styleString.equals(\"MODERN\") ? Style.MODERN : Style.LIGHT;\n\t\tif (this.style \u003d\u003d style)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.style \u003d style;\n\t\tupdate();\n\t}\n\n\tprivate void update()\n\t{\n\t\tclientThread.invoke(() -\u003e\n\t\t{\n\t\t\tModel model \u003d style.modelSupplier.apply(this);\n\t\t\tif (model \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tAnimation anim \u003d style.animationSupplier.apply(this);\n\n\t\t\truneLiteObject.setAnimation(anim);\n\t\t\truneLiteObject.setModel(model);\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tpublic void remove()\n\t{\n\t\truneLiteObject.setActive(false);\n\t}\n\n}\n","filePath":"src/main/java/com/rainbowrave/LootBeam.java"},{"fileName":"RainbowRavePlugin.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.inject.Provides;\nimport com.rainbowrave.RainbowRaveNpcIndicatorsPlugin.HighlightedNpc;\nimport java.awt.Color;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Function;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.GraphicsObject;\nimport net.runelite.api.Model;\nimport net.runelite.api.NPC;\nimport net.runelite.api.events.ClientTick;\nimport net.runelite.api.events.ItemSpawned;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.EventBus;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDependency;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.plugins.grounditems.GroundItemsConfig;\nimport net.runelite.client.plugins.grounditems.GroundItemsPlugin;\nimport net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;\nimport net.runelite.client.plugins.groundmarkers.GroundMarkerPlugin;\nimport net.runelite.client.plugins.inventorytags.InventoryTagsConfig;\nimport net.runelite.client.plugins.inventorytags.InventoryTagsPlugin;\nimport net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;\nimport net.runelite.client.plugins.npchighlight.NpcIndicatorsPlugin;\nimport net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;\nimport net.runelite.client.plugins.objectindicators.ObjectIndicatorsPlugin;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Rainbow Rave\",\n\ttags \u003d {\"loot, beam, ground, item, tile, indicator, npc, object, inventory, tag\"}\n)\n@PluginDependency(NpcIndicatorsPlugin.class)\n@PluginDependency(GroundMarkerPlugin.class)\n@PluginDependency(ObjectIndicatorsPlugin.class)\n@PluginDependency(InventoryTagsPlugin.class)\n@PluginDependency(GroundItemsPlugin.class)\npublic class RainbowRavePlugin extends Plugin\n{\n\tpublic static final String GROUP \u003d \"rainbow_rave\";\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate RainbowRaveConfig config;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ModelOutlineRenderer modelOutlineRenderer;\n\n\t@Inject\n\tprivate NpcIndicatorsConfig npcIndicatorsConfig;\n\n\t@Inject\n\tprivate RainbowRaveNpcIndicatorsPlugin rainbowRaveNpcIndicatorsPlugin;\n\n\tprivate RainbowRaveNpcSceneOverlay rainbowRaveNpcSceneOverlay;\n\n\t@Inject\n\tprivate GroundMarkerConfig groundMarkerConfig;\n\n\t@Inject\n\tprivate RainbowRaveGroundMarkerPlugin rainbowRaveGroundMarkerPlugin;\n\n\tprivate RainbowRaveGroundMarkerOverlay rainbowRaveGroundMarkerOverlay;\n\n\t@Inject\n\tprivate ObjectIndicatorsConfig objectIndicatorsConfig;\n\n\t@Inject\n\tprivate RainbowRaveObjectIndicatorsPlugin rainbowRaveObjectIndicatorsPlugin;\n\n\tprivate RainbowRaveObjectIndicatorsOverlay rainbowRaveObjectIndicatorsOverlay;\n\n\tprivate RainbowRaveInventoryTagsOverlay rainbowRaveInventoryTagsOverlay;\n\n\t@Inject\n\tprivate InventoryTagsConfig inventoryTagsConfig;\n\n\t@Inject\n\tprivate GroundItemsConfig groundItemsConfig;\n\n\t@Inject\n\tprivate RainbowRaveGroundItemsPlugin rainbowRaveGroundItemsPlugin;\n\n\tprivate RainbowRaveGroundItemsOverlay rainbowRaveGroundItemsOverlay;\n\n\t@Inject\n\tprivate RainbowRaveTileIndicatorsPlugin rainbowRaveTileIndicatorsPlugin;\n\n\tprivate RainbowRaveTileIndicatorsOverlay rainbowRaveTileIndicatorsOverlay;\n\n\t@Inject\n\tprivate RainbowRaveMouseTrailPlugin rainbowRaveMouseTrailPlugin;\n\n\tprivate RainbowRaveMouseTrailOverlay rainbowRaveMouseTrailOverlay;\n\n\t@Inject\n\tprivate EventBus eventBus;\n\n\t@Inject\n\tprivate ItemManager itemManager;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\tif (rainbowRaveGroundMarkerOverlay \u003d\u003d null) {\n\t\t\trainbowRaveGroundMarkerOverlay \u003d new RainbowRaveGroundMarkerOverlay(client, groundMarkerConfig, rainbowRaveGroundMarkerPlugin, this, config);\n\t\t}\n\t\trainbowRaveGroundMarkerPlugin.startUp();\n\t\toverlayManager.add(rainbowRaveGroundMarkerOverlay);\n\t\teventBus.register(rainbowRaveGroundMarkerPlugin);\n\n\t\tif (rainbowRaveObjectIndicatorsOverlay \u003d\u003d null) {\n\t\t\trainbowRaveObjectIndicatorsOverlay \u003d new RainbowRaveObjectIndicatorsOverlay(client, objectIndicatorsConfig, rainbowRaveObjectIndicatorsPlugin, modelOutlineRenderer, this, config);\n\t\t}\n\t\trainbowRaveObjectIndicatorsPlugin.startUp();\n\t\toverlayManager.add(rainbowRaveObjectIndicatorsOverlay);\n\t\teventBus.register(rainbowRaveObjectIndicatorsPlugin);\n\n\t\tif (rainbowRaveNpcSceneOverlay \u003d\u003d null) {\n\t\t\trainbowRaveNpcSceneOverlay \u003d new RainbowRaveNpcSceneOverlay(client, npcIndicatorsConfig, rainbowRaveNpcIndicatorsPlugin, modelOutlineRenderer, this, config);\n\t\t}\n\t\tupdateNpcHighlighterWithConfigSettings();\n\t\trainbowRaveNpcIndicatorsPlugin.startUp();\n\t\toverlayManager.add(rainbowRaveNpcSceneOverlay);\n\t\teventBus.register(rainbowRaveNpcIndicatorsPlugin);\n\n\t\tif (rainbowRaveInventoryTagsOverlay \u003d\u003d null) {\n\t\t\trainbowRaveInventoryTagsOverlay \u003d new RainbowRaveInventoryTagsOverlay(itemManager, this, inventoryTagsConfig, config, configManager);\n\t\t}\n\t\toverlayManager.add(rainbowRaveInventoryTagsOverlay);\n\n\t\tif (rainbowRaveGroundItemsOverlay \u003d\u003d null) {\n\t\t\trainbowRaveGroundItemsOverlay \u003d new RainbowRaveGroundItemsOverlay(client, rainbowRaveGroundItemsPlugin, groundItemsConfig);\n\t\t}\n\t\toverlayManager.add(rainbowRaveGroundItemsOverlay);\n\t\trainbowRaveGroundItemsPlugin.startUp();\n\t\teventBus.register(rainbowRaveGroundItemsPlugin);\n\n\t\tif (config.recolorTileIndicators()) {\n\t\t\tstartRRTIPlugin();\n\t\t}\n\n\t\tif (rainbowRaveMouseTrailOverlay \u003d\u003d null) {\n\t\t\trainbowRaveMouseTrailOverlay \u003d new RainbowRaveMouseTrailOverlay(this, rainbowRaveMouseTrailPlugin, config);\n\t\t}\n\t\toverlayManager.add(rainbowRaveMouseTrailOverlay);\n\t\trainbowRaveMouseTrailPlugin.startUp();\n\t\teventBus.register(rainbowRaveMouseTrailPlugin);\n\n\t\tmigrateConfig();\n\t}\n\n\tprivate void migrateConfig()\n\t{\n\t\tString previousSmoothWaves \u003d configManager.getConfiguration(GROUP, RainbowRaveConfig.OLD_TILE_COLOR_WAVES_KEY);\n\t\tif (previousSmoothWaves !\u003d null) {\n\t\t\tif (Boolean.valueOf(previousSmoothWaves)) {\n\t\t\t\tconfigManager.setConfiguration(GROUP, RainbowRaveConfig.GROUND_MARKER_COLOR_MODE_KEY, RainbowRaveConfig.GroundMarkerColorMode.WAVES);\n\t\t\t} // else it would be \"random\" which is default\n\t\t\tconfigManager.unsetConfiguration(GROUP, RainbowRaveConfig.OLD_TILE_COLOR_WAVES_KEY);\n\t\t}\n\t}\n\n\t// Ground items has to use this itemspawned subscriber because registering it in startup is not fast enough to get the itemspawned events that are fired when a plugin is started.\n\t@Subscribe\n\tpublic void onItemSpawned(ItemSpawned e) {\n\t\trainbowRaveGroundItemsPlugin.onItemSpawned(e);\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\trainbowRaveGroundMarkerPlugin.shutDown();\n\t\toverlayManager.remove(rainbowRaveGroundMarkerOverlay);\n\t\teventBus.unregister(rainbowRaveGroundMarkerPlugin);\n\n\t\trainbowRaveObjectIndicatorsPlugin.shutDown();\n\t\toverlayManager.remove(rainbowRaveObjectIndicatorsOverlay);\n\t\teventBus.unregister(rainbowRaveObjectIndicatorsPlugin);\n\n\t\trainbowRaveNpcIndicatorsPlugin.shutDown();\n\t\toverlayManager.remove(rainbowRaveNpcSceneOverlay);\n\t\teventBus.unregister(rainbowRaveNpcIndicatorsPlugin);\n\n\t\toverlayManager.remove(rainbowRaveInventoryTagsOverlay);\n\n\t\toverlayManager.remove(rainbowRaveGroundItemsOverlay);\n\t\trainbowRaveGroundItemsPlugin.shutDown();\n\t\teventBus.unregister(rainbowRaveGroundItemsPlugin);\n\n\t\tstopRRTIPlugin();\n\n\t\toverlayManager.remove(rainbowRaveMouseTrailOverlay);\n\t\trainbowRaveMouseTrailPlugin.shutDown();\n\t\teventBus.unregister(rainbowRaveMouseTrailPlugin);\n\t}\n\n\t@Provides\n\tRainbowRaveConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(RainbowRaveConfig.class);\n\t}\n\n\tprivate Function\u003cNPC, HighlightedNpc\u003e highlighterPredicate;\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged) {\n\t\tif (configChanged.getGroup().equals(\"runelite\"))\n\t\t{\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"grounditemsplugin\", rainbowRaveGroundItemsOverlay);\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"groundmarkerplugin\", rainbowRaveGroundMarkerOverlay);\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"inventorytagsplugin\", rainbowRaveInventoryTagsOverlay);\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"npcindicatorsplugin\", rainbowRaveNpcSceneOverlay);\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"objectindicatorsplugin\", rainbowRaveObjectIndicatorsOverlay);\n\t\t\tcheckAndPushOverlayToFront(configChanged, \"brushmarkerplugin\", rainbowRaveGroundMarkerOverlay);\n\t\t\tif (config.recolorTileIndicators()) {\n\t\t\t\tcheckAndPushOverlayToFront(configChanged, \"tileindicatorsplugin\", rainbowRaveTileIndicatorsOverlay);\n\t\t\t\tcheckAndPushOverlayToFront(configChanged, \"cornertileindicatorsplugin\", rainbowRaveTileIndicatorsOverlay);\n\t\t\t}\n\t\t}\n\t\telse if (configChanged.getGroup().equals(\"rainbow_rave\"))\n\t\t{\n\t\t\tif (configChanged.getKey().equals(\"whichNpcsToHighlight\"))\n\t\t\t{\n\t\t\t\tupdateNpcHighlighterWithConfigSettings();\n\t\t\t}\n\t\t\telse if (configChanged.getKey().equals(\"recolorTileIndicators\"))\n\t\t\t{\n\t\t\t\tif (config.recolorTileIndicators())\n\t\t\t\t{\n\t\t\t\t\tstartRRTIPlugin();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tstopRRTIPlugin();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void stopRRTIPlugin()\n\t{\n\t\toverlayManager.remove(rainbowRaveTileIndicatorsOverlay);\n\t\trainbowRaveTileIndicatorsPlugin.shutDown();\n\t\teventBus.unregister(rainbowRaveTileIndicatorsPlugin);\n\t}\n\n\tprivate void startRRTIPlugin()\n\t{\n\t\tif (rainbowRaveTileIndicatorsOverlay \u003d\u003d null)\n\t\t{\n\t\t\trainbowRaveTileIndicatorsOverlay \u003d new RainbowRaveTileIndicatorsOverlay(client, rainbowRaveTileIndicatorsPlugin, this);\n\t\t}\n\t\toverlayManager.add(rainbowRaveTileIndicatorsOverlay);\n\t\trainbowRaveTileIndicatorsPlugin.startUp();\n\t\teventBus.register(rainbowRaveTileIndicatorsPlugin);\n\t}\n\n\tprivate void checkAndPushOverlayToFront(ConfigChanged configChanged, String key, Overlay overlay)\n\t{\n\t\tif (configChanged.getKey().equals(key) \u0026\u0026 configChanged.getNewValue().equalsIgnoreCase(\"true\")) {\n\t\t\tclientThread.invokeLater(() -\u003e {\n\t\t\t\toverlayManager.remove(overlay);\n\t\t\t\toverlayManager.add(overlay);\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate void updateNpcHighlighterWithConfigSettings()\n\t{\n\t\tFunction\u003cNPC, HighlightedNpc\u003e f;\n\t\tif (config.whichNpcsToHighlight() \u003d\u003d RainbowRaveConfig.NpcsToHighlight.ALL) {\n\t\t\tf \u003d npc -\u003e rainbowRaveNpcIndicatorsPlugin.highlightedNpc(npc);\n\t\t\trainbowRaveNpcSceneOverlay.enable(true);\n\t\t} else if (config.whichNpcsToHighlight() \u003d\u003d RainbowRaveConfig.NpcsToHighlight.SAME) {\n\t\t\tf \u003d npc -\u003e null;\n\t\t\trainbowRaveNpcSceneOverlay.enable(true);\n\t\t} else if (config.whichNpcsToHighlight() \u003d\u003d RainbowRaveConfig.NpcsToHighlight.NONE) {\n\t\t\tf \u003d npc -\u003e null;\n\t\t\trainbowRaveNpcSceneOverlay.enable(false);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tif (highlighterPredicate !\u003d null) rainbowRaveNpcIndicatorsPlugin.unregisterHighlighter(highlighterPredicate);\n\t\thighlighterPredicate \u003d f;\n\t\trainbowRaveNpcIndicatorsPlugin.registerHighlighter(highlighterPredicate);\n\t\tclientThread.invoke(rainbowRaveNpcIndicatorsPlugin::rebuild);\n\t}\n\n\tpublic Color getColor(int hashCode)\n\t{\n\t\treturn getColor(hashCode, client.getGameCycle(), config.syncColor(), config.colorSpeed());\n\t}\n\n\tpublic Color getColor(int hashCode, int gameCycle, boolean syncColor, int colorSpeed)\n\t{\n\t\tif (syncColor) hashCode \u003d 0;\n\t\tint clientTicks \u003d colorSpeed / 20;\n\t\treturn config.theme().getColor(((hashCode + gameCycle) % clientTicks) / ((float) clientTicks));\n\t}\n\n\tprivate static final List\u003cInteger\u003e scytheTrailIds \u003d Arrays.asList(478, 506, 1172);\n\n\t@Subscribe\n\tpublic void onClientTick(ClientTick clientTick)\n\t{\n\t\tif(config.dukeRave())\n\t\t{\n\t\t\tfor (NPC npc : client.getTopLevelWorldView().npcs())\n\t\t\t{\n\t\t\t\tif(npc.getId()\u003e\u003d12199 \u0026\u0026 npc.getId() \u003c\u003d 12201)\n\t\t\t\t{\n\t\t\t\t\trecolorAllFaces(npc.getModel(), getColor((int)npc.getHash()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (config.recolorLootBeams())\n\t{\n\t\tboolean colorHighlightedItems \u003d config.getGroundItemsHighlightedItemsLootbeam();\n\t\t\tint tierOrdinal \u003d config.getGroundItemsLootbeamTier().ordinal();\n\t\t\tfor (Lootbeam value : rainbowRaveGroundItemsPlugin.lootbeams.values())\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\tvalue.tier \u003d\u003d null ?\n\t\t\t\t\t\tcolorHighlightedItems :\n\t\t\t\t\t\tvalue.tier.ordinal() \u003e\u003d tierOrdinal\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\trecolorAllFaces(value.runeLiteObject.getModel(), getColor(value.runeLiteObject.getLocation().hashCode()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (config.recolorScytheSwings())\n\t\t{\n\t\t\tfor (GraphicsObject graphicsObject : client.getTopLevelWorldView().getGraphicsObjects())\n\t\t\t{\n\t\t\t\tif (\n\t\t\t\t\tscytheTrailIds.contains(graphicsObject.getId()) ||\n\t\t\t\t\t(graphicsObject.getId() \u003e\u003d 1231 \u0026\u0026 graphicsObject.getId() \u003c\u003d 1235) || // chally trails + 1 red trail.\n\t\t\t\t\t(graphicsObject.getId() \u003e\u003d 1891 \u0026\u0026 graphicsObject.getId() \u003c\u003d 1898) // sara and sang scythe swing trails\n\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\trecolorAllFaces(graphicsObject.getModel(), getColor(graphicsObject.getLocation().hashCode()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate int colorToRs2hsb(Color color)\n\t{\n\t\tfloat[] hsbVals \u003d Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), null);\n\n\t\t// \"Correct\" the brightness level to avoid going to white at full saturation, or having a low brightness at\n\t\t// low saturation\n\t\thsbVals[2] -\u003d Math.min(hsbVals[1], hsbVals[2] / 2);\n\n\t\tint encode_hue \u003d (int)(hsbVals[0] * 63);\n\t\tint encode_saturation \u003d (int)(hsbVals[1] * 7);\n\t\tint encode_brightness \u003d (int)(hsbVals[2] * 127);\n\t\treturn (encode_hue \u003c\u003c 10) + (encode_saturation \u003c\u003c 7) + (encode_brightness);\n\t}\n\n\tprivate void recolorAllFaces(Model model, Color color)\n\t{\n\t\tif (model \u003d\u003d null || color \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint rs2hsb \u003d colorToRs2hsb(color);\n\t\tint[] faceColors1 \u003d model.getFaceColors1();\n\t\tint[] faceColors2 \u003d model.getFaceColors2();\n\t\tint[] faceColors3 \u003d model.getFaceColors3();\n\n\t\tfor (int i \u003d 0; i \u003c faceColors1.length; i++)\n\t\t{\n\t\t\tfaceColors1[i] \u003d rs2hsb;\n\t\t}\n\t\tfor (int i \u003d 0; i \u003c faceColors2.length; i++)\n\t\t{\n\t\t\tfaceColors2[i] \u003d rs2hsb;\n\t\t}\n\t\tfor (int i \u003d 0; i \u003c faceColors3.length; i++)\n\t\t{\n\t\t\tfaceColors3[i] \u003d rs2hsb;\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRavePlugin.java"},{"fileName":"RainbowRaveGroundItemsOverlay.java","content":"/*\n * Copyright (c) 2017, Aria \u003caria@ar1as.space\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Rectangle;\nimport java.time.Instant;\nimport java.util.AbstractMap.SimpleEntry;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport javax.inject.Inject;\nimport net.runelite.api.*;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.plugins.grounditems.GroundItemsConfig;\nimport net.runelite.client.plugins.grounditems.config.DespawnTimerMode;\nimport static net.runelite.client.plugins.grounditems.config.ItemHighlightMode.MENU;\nimport static net.runelite.client.plugins.grounditems.config.ItemHighlightMode.NONE;\nimport net.runelite.client.plugins.grounditems.config.OwnershipFilterMode;\nimport net.runelite.client.plugins.grounditems.config.PriceDisplayMode;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.ui.overlay.components.BackgroundComponent;\nimport net.runelite.client.ui.overlay.components.ProgressPieComponent;\nimport net.runelite.client.ui.overlay.components.TextComponent;\nimport net.runelite.client.util.QuantityFormatter;\n\npublic class RainbowRaveGroundItemsOverlay extends Overlay\n{\n\tprivate static final int MAX_DISTANCE \u003d 2500;\n\t// We must offset the text on the z-axis such that\n\t// it doesn\u0027t obscure the ground items below it.\n\tprivate static final int OFFSET_Z \u003d 20;\n\t// The 15 pixel gap between each drawn ground item.\n\tprivate static final int STRING_GAP \u003d 15;\n\t// Size of the hidden/highlight boxes\n\tprivate static final int RECTANGLE_SIZE \u003d 8;\n\tprivate static final Color PUBLIC_TIMER_COLOR \u003d Color.YELLOW;\n\tprivate static final Color PRIVATE_TIMER_COLOR \u003d Color.GREEN;\n\tprivate static final int TIMER_OVERLAY_DIAMETER \u003d 10;\n\n\tprivate final Client client;\n\tprivate final RainbowRaveGroundItemsPlugin plugin;\n\tprivate final GroundItemsConfig config;\n\tprivate final StringBuilder itemStringBuilder \u003d new StringBuilder();\n\tprivate final BackgroundComponent backgroundComponent \u003d new BackgroundComponent();\n\tprivate final TextComponent textComponent \u003d new TextComponent();\n\tprivate final ProgressPieComponent progressPieComponent \u003d new ProgressPieComponent();\n\tprivate final Map\u003cWorldPoint, Integer\u003e offsetMap \u003d new HashMap\u003c\u003e();\n\n\t@Inject\n\tpublic RainbowRaveGroundItemsOverlay(Client client, RainbowRaveGroundItemsPlugin plugin, GroundItemsConfig config)\n\t{\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tfinal boolean dontShowOverlay \u003d (config.itemHighlightMode() \u003d\u003d MENU || config.itemHighlightMode() \u003d\u003d NONE\n\t\t\t|| plugin.isHideAll()) \u0026\u0026 !plugin.isHotKeyPressed();\n\n\t\tif (dontShowOverlay \u0026\u0026 !config.highlightTiles())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal FontMetrics fm \u003d graphics.getFontMetrics();\n\t\tfinal Player player \u003d client.getLocalPlayer();\n\n\t\tif (player \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\toffsetMap.clear();\n\t\tfinal LocalPoint localLocation \u003d player.getLocalLocation();\n\t\tfinal Point mousePos \u003d client.getMouseCanvasPosition();\n\t\tCollection\u003cGroundItem\u003e groundItemList \u003d plugin.getCollectedGroundItems().values();\n\t\tGroundItem topGroundItem \u003d null;\n\n\t\tif (plugin.isHotKeyPressed())\n\t\t{\n\t\t\t// Make copy of ground items because we are going to modify them here, and the array list supports our\n\t\t\t// desired behaviour here\n\t\t\tgroundItemList \u003d new ArrayList\u003c\u003e(groundItemList);\n\t\t\tfinal java.awt.Point awtMousePos \u003d new java.awt.Point(mousePos.getX(), mousePos.getY());\n\t\t\tGroundItem groundItem \u003d null;\n\n\t\t\tfor (GroundItem item : groundItemList)\n\t\t\t{\n\t\t\t\titem.setOffset(offsetMap.compute(item.getLocation(), (k, v) -\u003e v !\u003d null ? v + 1 : 0));\n\n\t\t\t\tif (groundItem !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.getTextBoxBounds() !\u003d null\n\t\t\t\t\t\u0026\u0026 item.equals(plugin.getTextBoxBounds().getValue())\n\t\t\t\t\t\u0026\u0026 plugin.getTextBoxBounds().getKey().contains(awtMousePos))\n\t\t\t\t{\n\t\t\t\t\tgroundItem \u003d item;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.getHiddenBoxBounds() !\u003d null\n\t\t\t\t\t\u0026\u0026 item.equals(plugin.getHiddenBoxBounds().getValue())\n\t\t\t\t\t\u0026\u0026 plugin.getHiddenBoxBounds().getKey().contains(awtMousePos))\n\t\t\t\t{\n\t\t\t\t\tgroundItem \u003d item;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.getHighlightBoxBounds() !\u003d null\n\t\t\t\t\t\u0026\u0026 item.equals(plugin.getHighlightBoxBounds().getValue())\n\t\t\t\t\t\u0026\u0026 plugin.getHighlightBoxBounds().getKey().contains(awtMousePos))\n\t\t\t\t{\n\t\t\t\t\tgroundItem \u003d item;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (groundItem !\u003d null)\n\t\t\t{\n\t\t\t\tgroundItemList.remove(groundItem);\n\t\t\t\tgroundItemList.add(groundItem);\n\t\t\t\ttopGroundItem \u003d groundItem;\n\t\t\t}\n\t\t}\n\n\t\tplugin.setTextBoxBounds(null);\n\t\tplugin.setHiddenBoxBounds(null);\n\t\tplugin.setHighlightBoxBounds(null);\n\n\t\tfinal DespawnTimerMode groundItemTimers \u003d config.groundItemTimers();\n\t\tfinal boolean outline \u003d config.textOutline();\n\t\tfinal OwnershipFilterMode ownershipFilterMode \u003d config.ownershipFilterMode();\n\t\tfinal int accountType \u003d client.getVarbitValue(Varbits.ACCOUNT_TYPE);\n\t\tfinal WorldView worldView \u003d client.getTopLevelWorldView();\n\n\t\tfor (GroundItem item : groundItemList)\n\t\t{\n\t\t\tfinal LocalPoint groundPoint \u003d LocalPoint.fromWorld(worldView, item.getLocation());\n\n\t\t\tif (groundPoint \u003d\u003d null || localLocation.distanceTo(groundPoint) \u003e MAX_DISTANCE\n\t\t\t\t|| !plugin.shouldDisplayItem(ownershipFilterMode, item.getOwnership(), accountType))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal Optional\u003cColor\u003e highlighted \u003d plugin.getHighlighted(new NamedQuantity(item), item.getGePrice(), item.getHaPrice());\n\t\t\tfinal Optional\u003cColor\u003e hidden \u003d plugin.getHidden(new NamedQuantity(item), item.getGePrice(), item.getHaPrice(), item.isTradeable());\n\t\t\tif (highlighted \u003d\u003d null \u0026\u0026 !plugin.isHotKeyPressed())\n\t\t\t{\n\t\t\t\t// Do not display hidden items\n\t\t\t\tif (hidden !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Do not display non-highlighted items\n\t\t\t\tif (config.showHighlightedOnly())\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal Optional\u003cColor\u003e groundItemColor \u003d plugin.getItemColor(highlighted, hidden, new NamedQuantity(item));\n\n\t\t\tif (groundItemColor \u003d\u003d null) continue;\n\t\t\tif (!groundItemColor.isPresent()) {\n\t\t\t\tif (!plugin.isHotKeyPressed()) offsetMap.compute(item.getLocation(), (k, v) -\u003e v !\u003d null ? v + 1 : 0);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tColor color \u003d groundItemColor.get();\n\n\t\t\tif (config.highlightTiles())\n\t\t\t{\n\t\t\t\tfinal Polygon poly \u003d Perspective.getCanvasTilePoly(client, groundPoint, item.getHeight());\n\n\t\t\t\tif (poly !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tOverlayUtil.renderPolygon(graphics, poly, color);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dontShowOverlay)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titemStringBuilder.append(item.getName());\n\n\t\t\tif (item.getQuantity() \u003e 1)\n\t\t\t{\n\t\t\t\titemStringBuilder.append(\" (\")\n\t\t\t\t\t.append(QuantityFormatter.quantityToStackSize(item.getQuantity()))\n\t\t\t\t\t.append(\u0027)\u0027);\n\t\t\t}\n\n\t\t\tif (item.getId() !\u003d ItemID.COINS_995)\n\t\t\t{\n\t\t\t\tPriceDisplayMode displayMode \u003d config.priceDisplayMode();\n\t\t\t\tif (displayMode \u003d\u003d PriceDisplayMode.BOTH)\n\t\t\t\t{\n\t\t\t\t\tif (item.getGePrice() \u003e 0)\n\t\t\t\t\t{\n\t\t\t\t\t\titemStringBuilder.append(\" (GE: \")\n\t\t\t\t\t\t\t.append(QuantityFormatter.quantityToStackSize(item.getGePrice()))\n\t\t\t\t\t\t\t.append(\" gp)\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (item.getHaPrice() \u003e 0)\n\t\t\t\t\t{\n\t\t\t\t\t\titemStringBuilder.append(\" (HA: \")\n\t\t\t\t\t\t\t.append(QuantityFormatter.quantityToStackSize(item.getHaPrice()))\n\t\t\t\t\t\t\t.append(\" gp)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (displayMode !\u003d PriceDisplayMode.OFF)\n\t\t\t\t{\n\t\t\t\t\tfinal int price \u003d displayMode \u003d\u003d PriceDisplayMode.GE\n\t\t\t\t\t\t? item.getGePrice()\n\t\t\t\t\t\t: item.getHaPrice();\n\n\t\t\t\t\tif (price \u003e 0)\n\t\t\t\t\t{\n\t\t\t\t\t\titemStringBuilder\n\t\t\t\t\t\t\t.append(\" (\")\n\t\t\t\t\t\t\t.append(QuantityFormatter.quantityToStackSize(price))\n\t\t\t\t\t\t\t.append(\" gp)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal String itemString \u003d itemStringBuilder.toString();\n\t\t\titemStringBuilder.setLength(0);\n\n\t\t\tfinal Point textPoint \u003d Perspective.getCanvasTextLocation(client,\n\t\t\t\tgraphics,\n\t\t\t\tgroundPoint,\n\t\t\t\titemString,\n\t\t\t\titem.getHeight() + OFFSET_Z);\n\n\t\t\tif (textPoint \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal int offset \u003d plugin.isHotKeyPressed()\n\t\t\t\t? item.getOffset()\n\t\t\t\t: offsetMap.compute(item.getLocation(), (k, v) -\u003e v !\u003d null ? v + 1 : 0);\n\n\t\t\tfinal int textX \u003d textPoint.getX();\n\t\t\tfinal int textY \u003d textPoint.getY() - (STRING_GAP * offset);\n\n\t\t\tif (plugin.isHotKeyPressed())\n\t\t\t{\n\t\t\t\tfinal int stringWidth \u003d fm.stringWidth(itemString);\n\t\t\t\tfinal int stringHeight \u003d fm.getHeight();\n\n\t\t\t\t// Item bounds\n\t\t\t\tint x \u003d textX - 2;\n\t\t\t\tint y \u003d textY - stringHeight - 2;\n\t\t\t\tint width \u003d stringWidth + 4;\n\t\t\t\tint height \u003d stringHeight + 4;\n\t\t\t\tfinal Rectangle itemBounds \u003d new Rectangle(x, y, width, height);\n\n\t\t\t\t// Hidden box\n\t\t\t\tx +\u003d width + 2;\n\t\t\t\ty \u003d textY - (RECTANGLE_SIZE + stringHeight) / 2;\n\t\t\t\twidth \u003d height \u003d RECTANGLE_SIZE;\n\t\t\t\tfinal Rectangle itemHiddenBox \u003d new Rectangle(x, y, width, height);\n\n\t\t\t\t// Highlight box\n\t\t\t\tx +\u003d width + 2;\n\t\t\t\tfinal Rectangle itemHighlightBox \u003d new Rectangle(x, y, width, height);\n\n\t\t\t\tboolean mouseInBox \u003d itemBounds.contains(mousePos.getX(), mousePos.getY());\n\t\t\t\tboolean mouseInHiddenBox \u003d itemHiddenBox.contains(mousePos.getX(), mousePos.getY());\n\t\t\t\tboolean mouseInHighlightBox \u003d itemHighlightBox.contains(mousePos.getX(), mousePos.getY());\n\n\t\t\t\tif (mouseInBox)\n\t\t\t\t{\n\t\t\t\t\tplugin.setTextBoxBounds(new SimpleEntry\u003c\u003e(itemBounds, item));\n\t\t\t\t}\n\t\t\t\telse if (mouseInHiddenBox)\n\t\t\t\t{\n\t\t\t\t\tplugin.setHiddenBoxBounds(new SimpleEntry\u003c\u003e(itemHiddenBox, item));\n\n\t\t\t\t}\n\t\t\t\telse if (mouseInHighlightBox)\n\t\t\t\t{\n\t\t\t\t\tplugin.setHighlightBoxBounds(new SimpleEntry\u003c\u003e(itemHighlightBox, item));\n\t\t\t\t}\n\n\t\t\t\tboolean topItem \u003d topGroundItem \u003d\u003d item;\n\n\t\t\t\t// Draw background if hovering\n\t\t\t\tif (topItem \u0026\u0026 (mouseInBox || mouseInHiddenBox || mouseInHighlightBox))\n\t\t\t\t{\n\t\t\t\t\tbackgroundComponent.setRectangle(itemBounds);\n//\t\t\t\t\tbackgroundComponent.render(graphics);\n\t\t\t\t}\n\n\t\t\t\t// Draw hidden box\n//\t\t\t\tdrawRectangle(graphics, itemHiddenBox, topItem \u0026\u0026 mouseInHiddenBox ? Color.RED : color, hidden !\u003d null, true);\n\n\t\t\t\t// Draw highlight box\n//\t\t\t\tdrawRectangle(graphics, itemHighlightBox, topItem \u0026\u0026 mouseInHighlightBox ? Color.GREEN : color, highlighted !\u003d null, false);\n\t\t\t}\n\n\t\t\t// When the hotkey is pressed the hidden/highlight boxes are drawn to the right of the text,\n\t\t\t// so always draw the pie since it is on the left hand side.\n\t\t\tif (groundItemTimers \u003d\u003d DespawnTimerMode.PIE || plugin.isHotKeyPressed())\n\t\t\t{\n\t\t\t\tdrawTimerPieOverlay(graphics, textX, textY, item, color);\n\t\t\t}\n\t\t\telse if (groundItemTimers \u003d\u003d DespawnTimerMode.SECONDS || groundItemTimers \u003d\u003d DespawnTimerMode.TICKS)\n\t\t\t{\n\t\t\t\tInstant despawnTime \u003d calculateDespawnTime(item);\n\t\t\t\tColor timerColor \u003d color;\n\t\t\t\tif (despawnTime !\u003d null \u0026\u0026 timerColor !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tlong despawnTimeMillis \u003d despawnTime.toEpochMilli() - Instant.now().toEpochMilli();\n\t\t\t\t\tfinal String timerText;\n\t\t\t\t\tif (groundItemTimers \u003d\u003d DespawnTimerMode.SECONDS)\n\t\t\t\t\t{\n\t\t\t\t\t\ttimerText \u003d String.format(\" - %.1f\", despawnTimeMillis / 1000f);\n\t\t\t\t\t}\n\t\t\t\t\telse // TICKS\n\t\t\t\t\t{\n\t\t\t\t\t\ttimerText \u003d String.format(\" - %d\", despawnTimeMillis / 600);\n\t\t\t\t\t}\n\n\t\t\t\t\t// The timer text is drawn separately to have its own color, and is intentionally not included\n\t\t\t\t\t// in the getCanvasTextLocation() call because the timer text can change per frame and we do not\n\t\t\t\t\t// use a monospaced font, which causes the text location on screen to jump around slightly each frame.\n\t\t\t\t\ttextComponent.setText(timerText);\n\t\t\t\t\ttextComponent.setColor(timerColor);\n\t\t\t\t\ttextComponent.setOutline(outline);\n\t\t\t\t\ttextComponent.setPosition(new java.awt.Point(textX + fm.stringWidth(itemString), textY));\n\t\t\t\t\ttextComponent.render(graphics);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttextComponent.setText(itemString);\n\t\t\ttextComponent.setColor(color);\n\t\t\ttextComponent.setOutline(outline);\n\t\t\ttextComponent.setPosition(new java.awt.Point(textX, textY));\n\t\t\ttextComponent.render(graphics);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate Instant calculateDespawnTime(GroundItem groundItem)\n\t{\n\t\tInstant spawnTime \u003d groundItem.getSpawnTime();\n\t\tif (spawnTime \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tInstant despawnTime \u003d spawnTime.plus(groundItem.getDespawnTime());\n\t\tif (Instant.now().isAfter(despawnTime))\n\t\t{\n\t\t\t// that\u0027s weird\n\t\t\treturn null;\n\t\t}\n\n\t\treturn despawnTime;\n\t}\n\n\tprivate Color getItemTimerColor(GroundItem groundItem)\n\t{\n\t\tfinal Instant spawnTime \u003d groundItem.getSpawnTime();\n\t\tif (spawnTime \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal Instant now \u003d Instant.now();\n\t\tfinal Instant despawnTime \u003d spawnTime.plus(groundItem.getDespawnTime());\n\n\t\tif (groundItem.isPrivate())\n\t\t{\n\t\t\tif (despawnTime.isAfter(now))\n\t\t\t{\n\t\t\t\treturn PRIVATE_TIMER_COLOR;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// otherwise it is private until visibleTime, then it is public\n\t\tfinal Instant visibleTime \u003d spawnTime.plus(groundItem.getVisibleTime());\n\t\tif (visibleTime.isAfter(now))\n\t\t{\n\t\t\treturn PRIVATE_TIMER_COLOR;\n\t\t}\n\t\tif (despawnTime.isAfter(now))\n\t\t{\n\t\t\treturn PUBLIC_TIMER_COLOR;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void drawTimerPieOverlay(Graphics2D graphics, int textX, int textY, GroundItem groundItem, Color color)\n\t{\n\t\tInstant now \u003d Instant.now();\n\t\tInstant spawnTime \u003d groundItem.getSpawnTime();\n\t\tInstant despawnTime \u003d calculateDespawnTime(groundItem);\n\t\tColor fillColor \u003d color;\n\n\t\tif (spawnTime \u003d\u003d null || despawnTime \u003d\u003d null || fillColor \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfloat percent \u003d (float) (now.toEpochMilli() - spawnTime.toEpochMilli()) / (despawnTime.toEpochMilli() - spawnTime.toEpochMilli());\n\n\t\tprogressPieComponent.setDiameter(TIMER_OVERLAY_DIAMETER);\n\t\t// Shift over to not be on top of the text\n\t\tint x \u003d textX - TIMER_OVERLAY_DIAMETER;\n\t\tint y \u003d textY - TIMER_OVERLAY_DIAMETER / 2;\n\t\tprogressPieComponent.setPosition(new Point(x, y));\n\t\tprogressPieComponent.setFill(fillColor);\n\t\tprogressPieComponent.setBorderColor(fillColor);\n\t\tprogressPieComponent.setProgress(1 - percent); // inverse so pie drains over time\n\t\tprogressPieComponent.render(graphics);\n\t}\n\n\tprivate void drawRectangle(Graphics2D graphics, Rectangle rect, Color color, boolean inList, boolean hiddenBox)\n\t{\n\t\tgraphics.setColor(Color.BLACK);\n\t\tgraphics.drawRect(rect.x + 1, rect.y + 1, rect.width, rect.height);\n\n\t\tgraphics.setColor(color);\n\t\tgraphics.draw(rect);\n\n\t\tif (inList)\n\t\t{\n\t\t\tgraphics.fill(rect);\n\t\t}\n\n\t\tgraphics.setColor(Color.WHITE);\n\t\t// Minus symbol\n\t\tgraphics.drawLine\n\t\t\t(\n\t\t\t\trect.x + 2,\n\t\t\t\trect.y + (rect.height / 2),\n\t\t\t\trect.x + rect.width - 2,\n\t\t\t\trect.y + (rect.height / 2)\n\t\t\t);\n\n\t\tif (!hiddenBox)\n\t\t{\n\t\t\t// Plus symbol\n\t\t\tgraphics.drawLine\n\t\t\t\t(\n\t\t\t\t\trect.x + (rect.width / 2),\n\t\t\t\t\trect.y + 2,\n\t\t\t\t\trect.x + (rect.width / 2),\n\t\t\t\t\trect.y + rect.height - 2\n\t\t\t\t);\n\t\t}\n\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveGroundItemsOverlay.java"},{"fileName":"RainbowRaveTileIndicatorsOverlay.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Stroke;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.util.ColorUtil;\n\npublic class RainbowRaveTileIndicatorsOverlay extends Overlay\n{\n\tprivate final Client client;\n\tprivate final RainbowRaveTileIndicatorsPlugin plugin;\n\tprivate final RainbowRavePlugin rainbowRavePlugin;\n\n\tpublic RainbowRaveTileIndicatorsOverlay(Client client, RainbowRaveTileIndicatorsPlugin plugin, RainbowRavePlugin rainbowRavePlugin)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.rainbowRavePlugin \u003d rainbowRavePlugin;\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t\tsetPriority(Overlay.PRIORITY_MED);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tWorldView wv \u003d client.getTopLevelWorldView();\n\t\tif (plugin.highlightHoveredTile)\n\t\t{\n\t\t\t// If we have tile \"selected\" render it\n\t\t\tif (wv.getSelectedSceneTile() !\u003d null)\n\t\t\t{\n\t\t\t\trenderTile(graphics, wv.getSelectedSceneTile().getLocalLocation(), rainbowRavePlugin.getColor(0), plugin.hoveredTileBorderWidth, plugin.hoveredTileFillColor, plugin.hoveredTileCornersOnly, plugin.hoveredTileCornerSize);\n\t\t\t}\n\t\t}\n\n\t\tif (plugin.highlightDestinationTile)\n\t\t{\n\t\t\trenderTile(graphics, client.getLocalDestinationLocation(), rainbowRavePlugin.getColor(0), plugin.destinationTileBorderWidth, plugin.destinationTileFillColor, plugin.destinationTileCornersOnly, plugin.destinationTileCornerSize);\n\t\t}\n\n\t\tif (plugin.highlightCurrentTile)\n\t\t{\n\t\t\tfinal LocalPoint playerPosLocal \u003d LocalPoint.fromWorld(wv, plugin.getLastPlayerPosition());\n\t\t\tif (playerPosLocal \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tColor rainbowColor \u003d rainbowRavePlugin.getColor(0);\n\t\t\tColor color \u003d ColorUtil.colorWithAlpha(rainbowColor, plugin.highlightCurrentColor.getAlpha());\n\t\t\tColor fillColor \u003d plugin.recolorFill ? ColorUtil.colorWithAlpha(rainbowColor, plugin.currentTileFillColor.getAlpha()) : plugin.currentTileFillColor;\n\t\t\t// When not fading out the current tile, or when it has been 1 game tick or less since the player last\n\t\t\t// moved, draw the tile at full opacity. When using fadeout, drawing the indicator at full opacity for 1\n\t\t\t// game tick prevents it from fading out when moving on consecutive ticks.\n\t\t\tif (!plugin.trueTileFadeout || client.getTickCount() - plugin.getLastTickPlayerMoved() \u003c\u003d 1)\n\t\t\t{\n\t\t\t\trenderTile(graphics, playerPosLocal, color, plugin.currentTileBorderWidth, fillColor, plugin.currentTileCornersOnly, plugin.currentTileCornerSize);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// It is 1 game tick after the player has stopped moving, so fade out the tile.\n\t\t\t\tlong timeSinceLastMove \u003d System.currentTimeMillis() - plugin.getLastTimePlayerStoppedMoving();\n\t\t\t\t// The fadeout does not begin for 1 game tick, so subtract that.\n\t\t\t\tint fadeoutTime \u003d plugin.trueTileFadeoutTime - Constants.GAME_TICK_LENGTH;\n\t\t\t\tif (fadeoutTime !\u003d 0 \u0026\u0026 timeSinceLastMove \u003c fadeoutTime)\n\t\t\t\t{\n\t\t\t\t\tdouble opacity \u003d 1.0d - Math.pow(timeSinceLastMove / (double) fadeoutTime, 2);\n\t\t\t\t\trenderTile(graphics, playerPosLocal, ColorUtil.colorWithAlpha(color, (int) (opacity * color.getAlpha())), plugin.currentTileBorderWidth, ColorUtil.colorWithAlpha(fillColor, (int) (opacity * fillColor.getAlpha())), plugin.currentTileCornersOnly, plugin.currentTileCornerSize);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void renderTile(final Graphics2D graphics, final LocalPoint dest, final Color color, final double borderWidth, final Color fillColor, boolean cornersOnly, int divisor)\n\t{\n\t\tif (dest \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Polygon poly \u003d Perspective.getCanvasTilePoly(client, dest);\n\n\t\tif (poly \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (cornersOnly)\n\t\t{\n\t\t\trenderPolygonCorners(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth), divisor);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));\n\t\t}\n\t}\n\n\tpublic static void renderPolygonCorners(Graphics2D graphics, Polygon poly, Color color, Color fillColor, Stroke borderStroke, int divisor)\n\t{\n\t\tgraphics.setColor(color);\n\t\tfinal Stroke originalStroke \u003d graphics.getStroke();\n\t\tgraphics.setStroke(borderStroke);\n\n\t\tfor (int i \u003d 0; i \u003c poly.npoints; i++)\n\t\t{\n\t\t\tint ptx \u003d poly.xpoints[i];\n\t\t\tint pty \u003d poly.ypoints[i];\n\t\t\tint prev \u003d (i - 1) \u003c 0 ? (poly.npoints - 1) : (i - 1);\n\t\t\tint next \u003d (i + 1) \u003e (poly.npoints - 1) ? 0 : (i + 1);\n\t\t\tint ptxN \u003d ((poly.xpoints[next]) - ptx) / divisor + ptx;\n\t\t\tint ptyN \u003d ((poly.ypoints[next]) - pty) / divisor + pty;\n\t\t\tint ptxP \u003d ((poly.xpoints[prev]) - ptx) / divisor + ptx;\n\t\t\tint ptyP \u003d ((poly.ypoints[prev]) - pty) / divisor + pty;\n\t\t\tgraphics.drawLine(ptx, pty, ptxN, ptyN);\n\t\t\tgraphics.drawLine(ptx, pty, ptxP, ptyP);\n\t\t}\n\n\t\tgraphics.setColor(fillColor);\n\t\tgraphics.fill(poly);\n\n\t\tgraphics.setStroke(originalStroke);\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveTileIndicatorsOverlay.java"},{"fileName":"Theme.java","content":"package com.rainbowrave;\n\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic enum Theme\n{\n    RAINBOW,\n    TRANS(new Color(91, 206, 250),\n            new Color(245, 169, 184),\n            new Color(255, 255, 255),\n            new Color(245, 169, 184)\n    ),\n\tENBY(\n\t\tnew Color(255, 255, 255),\n\t\tnew Color(156, 89, 209),\n\t\tnew Color(44, 44, 44),\n\t\tnew Color(252, 244, 52)\n\t),\n\tLESBIAN(\n\t\tnew Color(212, 44, 0),\n\t\tnew Color(253, 152, 85),\n\t\tnew Color(255, 255, 255),\n\t\tnew Color(209, 97, 162),\n\t\tnew Color(162, 1, 97)\n\t),\n\tPAN(\n\t\tnew Color(255, 33, 140),\n\t\tnew Color(255, 216, 0),\n\t\tnew Color(255, 33, 140),\n\t\tnew Color(33, 177, 255)\n\t),\n\tACE(\n\t\tnew Color(0, 0, 0),\n\t\tnew Color(163, 163, 163),\n\t\tnew Color(255, 255, 255),\n\t\tnew Color(128, 0, 128)\n\t),\n\tBI(\n\t\tnew Color(214, 2, 112),\n\t\tnew Color(0, 56, 168),\n\t\tnew Color(155, 79, 150)\n\t),\n\tGENDER_QUEER(\n\t\tnew Color(181, 126, 220),\n\t\tnew Color(255, 255, 255),\n\t\tnew Color(74, 129, 35)\n\t),\n\tGAY(\n\t\tnew Color(255, 255, 255),\n\t\tnew Color(123, 173, 226),\n\t\tnew Color(80, 73, 204),\n\t\tnew Color(61, 26, 120),\n\t\tnew Color(7, 141, 112),\n\t\tnew Color(38, 206, 170),\n\t\tnew Color(152, 232, 193)\n\t);\n\n\tprivate final List\u003cPerceptualGradient\u003e gradients;\n\n\tTheme()\n\t{\n\t\tgradients \u003d new ArrayList\u003c\u003e();\n\t}\n\n\tTheme(Color... colors) {\n\t\tgradients \u003d new ArrayList\u003c\u003e();\n\t\tfor (int i\u003d0; i\u003ccolors.length; i++) {\n\t\t\tColor startColor \u003d colors[i];\n\t\t\t// When at the last index then wrap back to first color\n\t\t\tColor endColor \u003d i \u003d\u003d colors.length-1 ? colors[0] : colors[i+1];\n            gradients.add(new PerceptualGradient(startColor, endColor));\n        }\n    }\n\n    public Color getColor(float ratio)\n    {\n        // Subtract floor to match Color.getHSBColor() functionality\n        ratio \u003d Math.abs((float) (ratio - Math.floor(ratio)));\n\n        if (gradients.size() \u003d\u003d 0) { // This applies to the RAINBOW theme only.\n            return Color.getHSBColor(ratio, 1.0f, 1.0f);\n        }\n\n        float increment \u003d 1.0f/gradients.size(); // Since size isn\u0027t 0, increment is always (0-1]\n        PerceptualGradient gradient \u003d gradients.get((int) Math.floor(ratio/increment));\n        float relativeRatio \u003d (ratio%increment)/increment;\n        return gradient.getColorMix(relativeRatio);\n    }\n}\n","filePath":"src/main/java/com/rainbowrave/Theme.java"},{"fileName":"RainbowRaveInventoryTagsOverlay.java","content":"/*\n * Copyright (c) 2018 kulers\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Image;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport net.runelite.api.widgets.WidgetItem;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.plugins.inventorytags.InventoryTagsConfig;\nimport net.runelite.client.ui.overlay.WidgetItemOverlay;\nimport net.runelite.client.util.ColorUtil;\nimport net.runelite.client.util.ImageUtil;\n\npublic class RainbowRaveInventoryTagsOverlay extends WidgetItemOverlay\n{\n\tprivate final ItemManager itemManager;\n\tprivate final RainbowRavePlugin rainbowRavePlugin;\n\tprivate final InventoryTagsConfig config;\n\tprivate final RainbowRaveConfig rainbowRaveConfig;\n\n\tprivate ConfigManager configManager;\n\n\tpublic RainbowRaveInventoryTagsOverlay(ItemManager itemManager, RainbowRavePlugin rainbowRavePlugin, InventoryTagsConfig config, RainbowRaveConfig rainbowRaveConfig, ConfigManager configManager)\n\t{\n\t\tthis.itemManager \u003d itemManager;\n\t\tthis.rainbowRavePlugin \u003d rainbowRavePlugin;\n\t\tthis.config \u003d config;\n\t\tthis.rainbowRaveConfig \u003d rainbowRaveConfig;\n\t\tthis.configManager \u003d configManager;\n\t\tshowOnEquipment();\n\t\tshowOnInventory();\n\t\tshowOnBank();\n\t}\n\n\t@Override\n\tpublic void renderItemOverlay(Graphics2D graphics, int itemId, WidgetItem widgetItem)\n\t{\n\t\tif (rainbowRaveConfig.whichItemsToInventoryTag() \u003d\u003d RainbowRaveConfig.ItemsToTag.NONE) return;\n\t\tString tag \u003d configManager.getConfiguration(InventoryTagsConfig.GROUP, \"item_\" + itemId);\n\t\tif ((tag !\u003d null \u0026\u0026 !tag.isEmpty()) || rainbowRaveConfig.whichItemsToInventoryTag() \u003d\u003d RainbowRaveConfig.ItemsToTag.ALL)\n\t\t{\n\t\t\tfinal Color color \u003d rainbowRavePlugin.getColor(itemId);\n\t\t\tif (color !\u003d null)\n\t\t\t{\n\t\t\t\tRectangle bounds \u003d widgetItem.getCanvasBounds();\n\t\t\t\tif (config.showTagOutline())\n\t\t\t\t{\n\t\t\t\t\tfinal BufferedImage outline \u003d itemManager.getItemOutline(itemId, widgetItem.getQuantity(), color);\n\t\t\t\t\tgraphics.drawImage(outline, (int) bounds.getX(), (int) bounds.getY(), null);\n\t\t\t\t}\n\n\t\t\t\tif (config.showTagFill())\n\t\t\t\t{\n\t\t\t\t\tfinal Image image \u003d getFillImage(color, widgetItem.getId(), widgetItem.getQuantity());\n\t\t\t\t\tgraphics.drawImage(image, (int) bounds.getX(), (int) bounds.getY(), null);\n\t\t\t\t}\n\n\t\t\t\tif (config.showTagUnderline())\n\t\t\t\t{\n\t\t\t\t\tint heightOffSet \u003d (int) bounds.getY() + (int) bounds.getHeight() + 2;\n\t\t\t\t\tgraphics.setColor(color);\n\t\t\t\t\tgraphics.drawLine((int) bounds.getX(), heightOffSet, (int) bounds.getX() + (int) bounds.getWidth(), heightOffSet);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Image getFillImage(Color color, int itemId, int qty)\n\t{\n\t\tfinal Color fillColor \u003d ColorUtil.colorWithAlpha(color, config.fillOpacity());\n\t\treturn ImageUtil.fillImage(itemManager.getImage(itemId, qty, false), fillColor);\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveInventoryTagsOverlay.java"},{"fileName":"PerceptualGradient.java","content":"package com.rainbowrave;\n\nimport java.awt.Color;\n\n/*\nThe explanation of the gradient algorithm used can be found here.\nhttps://stackoverflow.com/questions/22607043/color-gradient-algorithm/49321304#49321304\n */\npublic class PerceptualGradient\n{\n    private static final double GAMMA \u003d .43;\n\n    private final float[] normalizedStartColor;\n    private final float[] normalizedEndColor;\n\n    private final float startColorBrightness;\n    private final float endColorBrightness;\n\n\n    PerceptualGradient(Color startColor, Color endColor) {\n        this.normalizedStartColor \u003d normalize(startColor);\n        this.normalizedEndColor \u003d normalize(endColor);\n        this.startColorBrightness \u003d (float) Math.pow(sum(this.normalizedStartColor), GAMMA);\n        this.endColorBrightness \u003d (float) Math.pow(sum(this.normalizedEndColor), GAMMA);\n    }\n\n    public Color getColorMix(float frac) {\n        float intensity \u003d (float) Math.pow(lerp(this.startColorBrightness, this.endColorBrightness, frac), (1/GAMMA));\n\n        float total \u003d 0;\n        float[] components \u003d new float[3];\n        for (int i\u003d0; i\u003ccomponents.length; i++) {\n            components[i] \u003d lerp(this.normalizedStartColor[i], this.normalizedEndColor[i], frac);\n            total +\u003d components[i];\n        }\n        if (total !\u003d 0) {\n            for (int i\u003d0; i\u003ccomponents.length; i++) {\n                components[i] \u003d components[i] * intensity / total;\n            }\n        }\n\n        for (int i\u003d0; i\u003ccomponents.length; i++) {\n            float x \u003d components[i];\n            if (x \u003c\u003d 0.0031308) {\n                components[i] \u003d (float) (12.92*x);\n            } else {\n                components[i] \u003d (float) ((1.055 * Math.pow(x , (1/2.4))) - 0.055);\n            }\n        }\n\n        return new Color(components[0], components[1], components[2]);\n    }\n\n    public float sum(float[] array) {\n        float sum \u003d 0;\n        for (float v : array)\n        {\n            sum +\u003d v;\n        }\n        return sum;\n    }\n\n    private float[] normalize(Color color) {\n        float[] components \u003d {color.getRed(), color.getGreen(), color.getBlue()};\n\n        for (int i\u003d0; i \u003c components.length; i++) {\n            double y;\n            float x \u003d components[i];\n\n            x /\u003d 255.0;\n            if (x \u003c\u003d 0.04045) {\n                y \u003d x / 12.92;\n            }\n            else {\n                y \u003d Math.pow(((x + 0.055) / 1.055), 2.4);\n            }\n            components[i] \u003d (float) y;\n        }\n\n        return components;\n    }\n\n    private float lerp(float color1, float color2, float frac)\n    {\n        return color1 * (1 - frac) + color2 * frac;\n    }\n}\n","filePath":"src/main/java/com/rainbowrave/PerceptualGradient.java"},{"fileName":"Curve.java","content":"/*\n * Copyright (c) 2022, Ryan Bell \u003cllaver@live.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport net.runelite.api.Point;\n\npublic class Curve {\n\n    private final Point from;\n    private final Point to;\n    private final List\u003cPoint\u003e curve \u003d new ArrayList\u003c\u003e();\n\n    public Curve(Point from, Point to) {\n        this.from \u003d from;\n        this.to \u003d to;\n\n        // TODO hook size of Curve into config\n        for(int i \u003d 1; i \u003c\u003d 5; i++) {\n            curve.add(interpolate(from, to, (double) (i * 2) / 10));\n        }\n    }\n\n    /**\n     * Linearly interpolates between two points.\n     *\n     * @param from The starting point.\n     * @param to The ending point.\n     * @param t The interpolation progress starting at 0 and going to 1 (percent of distance between points).\n     * @return The interpolated point.\n     */\n    private Point interpolate(Point from, Point to, double t) {\n        double x \u003d from.getX() * (1 - t) + to.getX() * t;\n        double y \u003d from.getY() * (1 - t) + to.getY() * t;\n        return new Point((int) Math.round(x), (int) Math.round(y));\n    }\n\n    public Point getFrom() {\n        return from;\n    }\n\n    public Point getTo() {\n        return to;\n    }\n\n    public List\u003cPoint\u003e getCurve() {\n        return curve;\n    }\n}\n","filePath":"src/main/java/com/rainbowrave/Curve.java"},{"fileName":"RainbowRaveMouseTrailPlugin.java","content":"/*\n * Copyright (c) 2022, Ryan Bell \u003cllaver@live.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.event.MouseEvent;\nimport java.util.*;\nimport java.util.Deque;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.events.ClientTick;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.input.MouseAdapter;\nimport net.runelite.client.input.MouseManager;\n\n@Slf4j\npublic class RainbowRaveMouseTrailPlugin\n{\n    private final Deque\u003cCurve\u003e curve \u003d new ArrayDeque\u003c\u003e();\n    private Point temp \u003d null;\n\n    @Inject\n    private MouseManager mouseManager;\n\n    private final MouseAdapter mouseAdapter \u003d new MouseAdapter() {\n        @Override\n        public MouseEvent mouseMoved(MouseEvent event)\n        {\n            updateMousePositions(new Point(event.getX(), event.getY()));\n            return event;\n        }\n        @Override\n        public MouseEvent mouseDragged(MouseEvent event)\n        {\n            updateMousePositions(new Point(event.getX(), event.getY()));\n            return event;\n        }\n    };\n\n    protected void startUp()\n    {\n        setMouseListenerEnabled(true);\n    }\n\n    protected void shutDown()\n    {\n        curve.clear();\n\n        setMouseListenerEnabled(false);\n    }\n\n    public void setMouseListenerEnabled(boolean enabled)\n    {\n        if (enabled)\n        {\n            mouseManager.registerMouseListener(mouseAdapter);\n        }\n        else\n        {\n            mouseManager.unregisterMouseListener(mouseAdapter);\n        }\n    }\n\n    @Subscribe\n    public void onClientTick(ClientTick event)\n    {\n        popTrail();\n        popTrail();\n    }\n\n    @Subscribe\n    public void onConfigChanged(ConfigChanged configChanged) {\n        if (configChanged.getGroup().equals(\"rainbow_rave\") \u0026\u0026 configChanged.getKey().equals(\"whichMouseTrailStyle\") \u0026\u0026 configChanged.getNewValue() !\u003d null) {\n\t\t\tsetMouseListenerEnabled(!configChanged.getNewValue().equals(\"NONE\"));\n\t\t}\n    }\n\n    public void updateMousePositions(Point point) {\n            if (curve.size() \u003c 50) {\n                if (temp !\u003d null) {\n                    Curve current \u003d new Curve(temp, point);\n                    curve.add(current);\n                }\n                temp \u003d point;\n            }\n    }\n\n    public Deque\u003cCurve\u003e getTrail() {\n        return curve;\n    }\n\n    public void popTrail() {\n        if(curve.size() \u003e 0) {\n            curve.pop();\n        }\n    }\n}","filePath":"src/main/java/com/rainbowrave/RainbowRaveMouseTrailPlugin.java"},{"fileName":"NamedQuantity.java","content":"/*\n * Copyright (c) 2020, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport lombok.RequiredArgsConstructor;\nimport lombok.Value;\n\n@Value\n@RequiredArgsConstructor\nclass NamedQuantity\n{\n\tprivate final String name;\n\tprivate final int quantity;\n\n\tNamedQuantity(GroundItem groundItem)\n\t{\n\t\tthis(groundItem.getName(), groundItem.getQuantity());\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/NamedQuantity.java"},{"fileName":"RainbowRaveGroundMarkerPlugin.java","content":"/*\n * Copyright (c) 2018, TheLonelyDev \u003chttps://github.com/TheLonelyDev\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\nimport javax.inject.Inject;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.MenuAction;\nimport net.runelite.api.Tile;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.MenuOptionClicked;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.EventBus;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.chatbox.ChatboxPanelManager;\nimport net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport static net.runelite.http.api.RuneLiteAPI.GSON;\n\n@Slf4j\npublic class RainbowRaveGroundMarkerPlugin\n{\n\tprivate static final String CONFIG_GROUP \u003d \"groundMarker\";\n\tprivate static final String WALK_HERE \u003d \"Walk here\";\n\tprivate static final String REGION_PREFIX \u003d \"region_\";\n\n\tprivate static final String BRUSH_CONFIG_GROUP \u003d \"brushMarkers\";\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final List\u003cColorTileMarker\u003e points \u003d new ArrayList\u003c\u003e();\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate GroundMarkerConfig config;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ChatboxPanelManager chatboxPanelManager;\n\n\t@Inject\n\tprivate RainbowRaveConfig rainbowRaveConfig;\n\n\t@Inject\n\tprivate EventBus eventBus;\n\n\t@Inject\n\tprivate Gson gson;\n\n\tCollection\u003cGroundMarkerPoint\u003e getPoints(int regionId)\n\t{\n\t\tString json \u003d configManager.getConfiguration(CONFIG_GROUP, REGION_PREFIX + regionId);\n\t\tif (Strings.isNullOrEmpty(json))\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\t// CHECKSTYLE:OFF\n\t\treturn gson.fromJson(json, new TypeToken\u003cList\u003cGroundMarkerPoint\u003e\u003e(){}.getType());\n\t\t// CHECKSTYLE:ON\n\t}\n\n\tvoid loadPoints()\n\t{\n\t\tloadPoints(null, false);\n\t}\n\n\tvoid loadPoints(GroundMarkerPoint extraPoint, boolean added)\n\t{\n\t\tpoints.clear();\n\n\t\tint[] regions \u003d client.getTopLevelWorldView().getMapRegions();\n\n\t\tif (regions \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int regionId : regions)\n\t\t{\n\t\t\t// load points for region\n\t\t\tlog.debug(\"Loading points for region {}\", regionId);\n\t\t\tCollection\u003cGroundMarkerPoint\u003e regionPoints \u003d new ArrayList\u003c\u003e(getPoints(regionId));\n\t\t\tif (extraPoint !\u003d null \u0026\u0026 !added)\n\t\t\t{\n\t\t\t\tregionPoints.remove(extraPoint);\n\t\t\t}\n\t\t\tCollection\u003cColorTileMarker\u003e colorTileMarkers \u003d translateToColorTileMarker(regionPoints);\n\t\t\tpoints.addAll(colorTileMarkers);\n\n\t\t\tif (rainbowRaveConfig.useBrushMarkerTiles())\n\t\t\t{\n\t\t\t\tCollection\u003cGroundMarkerPoint\u003e brushRegionPoints \u003d getBrushPoints(regionId);\n\t\t\t\tCollection\u003cColorTileMarker\u003e brushColorTileMarkers \u003d translateToColorTileMarker(brushRegionPoints);\n\t\t\t\tpoints.addAll(brushColorTileMarkers);\n\t\t\t}\n\t\t}\n\n\t\tif (extraPoint !\u003d null \u0026\u0026 added) {\n\t\t\tCollection\u003cColorTileMarker\u003e colorTileMarkers \u003d translateToColorTileMarker(Collections.singletonList(extraPoint));\n\t\t\tpoints.addAll(colorTileMarkers);\n\t\t}\n\t}\n\n\t/**\n\t * Translate a collection of ground marker points to color tile markers, accounting for instances\n\t *\n\t * @param points {@link GroundMarkerPoint}s to be converted to {@link ColorTileMarker}s\n\t * @return A collection of color tile markers, converted from the passed ground marker points, accounting for local\n\t *         instance points. See {@link WorldPoint#toLocalInstance(WorldView, WorldPoint)}\n\t */\n\tprivate Collection\u003cColorTileMarker\u003e translateToColorTileMarker(Collection\u003cGroundMarkerPoint\u003e points)\n\t{\n\t\tif (points.isEmpty())\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\tWorldView wv \u003d client.getTopLevelWorldView();\n\t\treturn points.stream()\n\t\t\t.map(point -\u003e new ColorTileMarker(\n\t\t\t\tWorldPoint.fromRegion(point.getRegionId(), point.getRegionX(), point.getRegionY(), point.getZ()),\n\t\t\t\tpoint.getColor(), point.getLabel()))\n\t\t\t.flatMap(colorTile -\u003e\n\t\t\t{\n\t\t\t\tfinal Collection\u003cWorldPoint\u003e localWorldPoints \u003d WorldPoint.toLocalInstance(wv, colorTile.getWorldPoint());\n\t\t\t\treturn localWorldPoints.stream().map(wp -\u003e new ColorTileMarker(wp, colorTile.getColor(), colorTile.getLabel()));\n\t\t\t})\n\t\t\t.collect(Collectors.toList());\n\t}\n\n\tpublic void startUp()\n\t{\n\t\tloadPoints();\n\t}\n\n\tpublic void shutDown()\n\t{\n\t\tpoints.clear();\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() !\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// map region has just been updated\n\t\tloadPoints();\n\t}\n\n\t@Subscribe\n\tpublic void onMenuOptionClicked(MenuOptionClicked event)\n\t{\n\t\tif (event.getMenuAction().getId() !\u003d MenuAction.RUNELITE.getId())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tTile target \u003d client.getTopLevelWorldView().getSelectedSceneTile();\n\t\tif (target \u003d\u003d null || !event.getMenuTarget().equals(\"Tile\"))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal String option \u003d event.getMenuOption();\n\t\tif (option.equals(\"Mark\") || option.equals(\"Unmark\"))\n\t\t{\n\t\t\tmarkTile(target.getLocalLocation());\n\t\t}\n\t\telse if (option.equals(\"Label\"))\n\t\t{\n\t\t\tlabelTile(target);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged event)\n\t{\n\t\tif (event.getGroup().equals(RainbowRavePlugin.GROUP) \u0026\u0026 event.getKey().equals(\"useBrushMarkerTiles\")) {\n\t\t\tloadPoints();\n\t\t}\n\t\tif (event.getGroup().equals(BRUSH_CONFIG_GROUP) \u0026\u0026 event.getKey().startsWith(REGION_PREFIX)) {\n\t\t\tloadPoints();\n\t\t}\n//\t\tif (event.getGroup().equals(GroundMarkerConfig.GROUND_MARKER_CONFIG_GROUP)\n//\t\t\t\u0026\u0026 (event.getKey().equals(GroundMarkerConfig.SHOW_IMPORT_EXPORT_KEY_NAME)\n//\t\t\t\t|| event.getKey().equals(GroundMarkerConfig.SHOW_CLEAR_KEY_NAME)))\n//\t\t{\n\t\t\t// Maintain consistent menu option order by removing everything then adding according to config\n//\t\t\tsharingManager.removeMenuOptions();\n//\n//\t\t\tif (config.showImportExport())\n//\t\t\t{\n//\t\t\t\tsharingManager.addImportExportMenuOptions();\n//\t\t\t}\n//\t\t\tif (config.showClear())\n//\t\t\t{\n//\t\t\t\tsharingManager.addClearMenuOption();\n//\t\t\t}\n//\t\t}\n\t}\n\n\tprivate void markTile(LocalPoint localPoint)\n\t{\n\t\tif (localPoint \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tWorldPoint worldPoint \u003d WorldPoint.fromLocalInstance(client, localPoint);\n\n\t\tint regionId \u003d worldPoint.getRegionID();\n\t\tGroundMarkerPoint point \u003d new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), config.markerColor(), null);\n\t\tlog.debug(\"Updating point: {} - {}\", point, worldPoint);\n\n\t\tList\u003cGroundMarkerPoint\u003e groundMarkerPoints \u003d new ArrayList\u003c\u003e(getPoints(regionId));\n\t\tif (groundMarkerPoints.contains(point))\n\t\t{\n\t\t\t// since I don\u0027t save points this won\u0027t see any tiles added through ground markers immediately, hence the extra args.\n\t\t\tloadPoints(point, false);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// since I don\u0027t save points this won\u0027t see any tiles added through ground markers immediately, hence the extra args.\n\t\t\tloadPoints(point, true);\n\t\t}\n\n//\t\tsavePoints(regionId, groundMarkerPoints);\n\t}\n\n\tprivate void labelTile(Tile tile)\n\t{\n\t\tLocalPoint localPoint \u003d tile.getLocalLocation();\n\t\tWorldPoint worldPoint \u003d WorldPoint.fromLocalInstance(client, localPoint);\n\t\tfinal int regionId \u003d worldPoint.getRegionID();\n\n\t\tGroundMarkerPoint searchPoint \u003d new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), null, null);\n\t\tCollection\u003cGroundMarkerPoint\u003e points \u003d getPoints(regionId);\n\t\tGroundMarkerPoint existing \u003d points.stream()\n\t\t\t.filter(p -\u003e p.equals(searchPoint))\n\t\t\t.findFirst().orElse(null);\n\t\tif (existing \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tchatboxPanelManager.openTextInput(\"Tile label\")\n\t\t\t.value(Optional.ofNullable(existing.getLabel()).orElse(\"\"))\n\t\t\t.onDone((input) -\u003e\n\t\t\t{\n\t\t\t\tinput \u003d Strings.emptyToNull(input);\n\n\t\t\t\tGroundMarkerPoint newPoint \u003d new GroundMarkerPoint(regionId, worldPoint.getRegionX(), worldPoint.getRegionY(), worldPoint.getPlane(), existing.getColor(), input);\n\t\t\t\tpoints.remove(searchPoint);\n\t\t\t\tpoints.add(newPoint);\n//\t\t\t\tsavePoints(regionId, points);\n\n\t\t\t\tloadPoints();\n\t\t\t})\n\t\t\t.build();\n\t}\n\n\tprivate Collection\u003cGroundMarkerPoint\u003e getBrushPoints(int regionId)\n\t{\n\t\tString json \u003d configManager.getConfiguration(BRUSH_CONFIG_GROUP, REGION_PREFIX + regionId);\n\t\tif (Strings.isNullOrEmpty(json))\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\t// CHECKSTYLE:OFF\n\t\treturn GSON.fromJson(json, new TypeToken\u003cList\u003cGroundMarkerPoint\u003e\u003e()\n\t\t{\n\t\t}.getType());\n\t\t// CHECKSTYLE:ON\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveGroundMarkerPlugin.java"},{"fileName":"RainbowRaveNpcSceneOverlay.java","content":"/*\n * Copyright (c) 2018, James Swindle \u003cwilingua@gmail.com\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.rainbowrave.RainbowRaveNpcIndicatorsPlugin.HighlightedNpc;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport java.text.DecimalFormat;\nimport java.text.NumberFormat;\nimport java.time.Instant;\nimport java.util.Locale;\nimport net.runelite.api.Actor;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.NPCComposition;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Player;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\nimport net.runelite.client.util.Text;\n\npublic class RainbowRaveNpcSceneOverlay extends Overlay\n{\n\t// Anything but white text is quite hard to see since it is drawn on\n\t// a dark background\n\tprivate static final Color TEXT_COLOR \u003d Color.WHITE;\n\n\tprivate static final NumberFormat TIME_LEFT_FORMATTER \u003d DecimalFormat.getInstance(Locale.US);\n\n\tstatic\n\t{\n\t\t((DecimalFormat)TIME_LEFT_FORMATTER).applyPattern(\"#0.0\");\n\t}\n\n\tprivate final Client client;\n\tprivate final NpcIndicatorsConfig config;\n\tprivate final RainbowRaveNpcIndicatorsPlugin plugin;\n\tprivate final RainbowRaveConfig rainbowRaveConfig;\n\tprivate final ModelOutlineRenderer modelOutlineRenderer;\n\n\tprivate final RainbowRavePlugin rainbowRavePlugin;\n\n\tRainbowRaveNpcSceneOverlay(Client client, NpcIndicatorsConfig config, RainbowRaveNpcIndicatorsPlugin plugin,\n\t\t\t\t\t\t\t   ModelOutlineRenderer modelOutlineRenderer, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.config \u003d config;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.modelOutlineRenderer \u003d modelOutlineRenderer;\n\t\tthis.rainbowRavePlugin \u003d rainbowRavePlugin;\n\t\tthis.rainbowRaveConfig \u003d rainbowRaveConfig;\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (enabled)\n\t\t{\n\t\t\tif (config.showRespawnTimer())\n\t\t\t{\n\t\t\t\tplugin.getDeadNpcsToDisplay().forEach((id, npc) -\u003e renderNpcRespawn(npc, graphics));\n\t\t\t}\n\n\t\t\tfor (HighlightedNpc highlightedNpc : plugin.getHighlightedNpcs().values())\n\t\t\t{\n\t\t\t\trenderNpcOverlay(graphics, highlightedNpc, null);\n\t\t\t}\n\t\t}\n\n\t\tif (rainbowRaveConfig.highlightSelf() || rainbowRaveConfig.highlightOthers())\n\t\t{\n\t\t\t// The NPC here is never used, but HighlightedNpc requires it to be non-null.\n\t\t\tif (rainbowRaveConfig.highlightSelf())\n\t\t\t{\n\t\t\t\trenderNpcOverlay(graphics, plugin.highlightedPlayer(), client.getLocalPlayer());\n\t\t\t}\n\t\t\tif (rainbowRaveConfig.highlightOthers())\n\t\t\t{\n\t\t\t\tfor (Player player : client.getTopLevelWorldView().players())\n\t\t\t\t{\n\t\t\t\t\tif (player !\u003d client.getLocalPlayer())\n\t\t\t\t\t\trenderNpcOverlay(graphics, plugin.highlightedPlayer(), player);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void renderNpcRespawn(final MemorizedNpc npc, final Graphics2D graphics)\n\t{\n\t\tif (npc.getPossibleRespawnLocations().isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal WorldPoint respawnLocation \u003d npc.getPossibleRespawnLocations().get(0);\n\t\tfinal LocalPoint lp \u003d LocalPoint.fromWorld(npc.getWorldView(), respawnLocation.getX(), respawnLocation.getY());\n\n\t\tif (lp \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal LocalPoint centerLp \u003d new LocalPoint(\n\t\t\tlp.getX() + Perspective.LOCAL_TILE_SIZE * (npc.getNpcSize() - 1) / 2,\n\t\t\tlp.getY() + Perspective.LOCAL_TILE_SIZE * (npc.getNpcSize() - 1) / 2,\n\t\t\tnpc.getWorldView());\n\n\t\tfinal Polygon poly \u003d Perspective.getCanvasTileAreaPoly(client, centerLp, npc.getNpcSize());\n\t\trenderPoly(graphics, config.highlightColor(), config.fillColor(), poly);\n\n\t\tfinal Instant now \u003d Instant.now();\n\t\tfinal double baseTick \u003d ((npc.getDiedOnTick() + npc.getRespawnTime()) - client.getTickCount()) * (Constants.GAME_TICK_LENGTH / 1000.0);\n\t\tfinal double sinceLast \u003d (now.toEpochMilli() - plugin.getLastTickUpdate().toEpochMilli()) / 1000.0;\n\t\tfinal double timeLeft \u003d Math.max(0.0, baseTick - sinceLast);\n\t\tfinal String timeLeftStr \u003d TIME_LEFT_FORMATTER.format(timeLeft);\n\n\t\tfinal int textWidth \u003d graphics.getFontMetrics().stringWidth(timeLeftStr);\n\t\tfinal int textHeight \u003d graphics.getFontMetrics().getAscent();\n\n\t\tfinal Point canvasPoint \u003d Perspective\n\t\t\t.localToCanvas(client, centerLp, respawnLocation.getPlane());\n\n\t\tif (canvasPoint !\u003d null)\n\t\t{\n\t\t\tfinal Point canvasCenterPoint \u003d new Point(\n\t\t\t\tcanvasPoint.getX() - textWidth / 2,\n\t\t\t\tcanvasPoint.getY() + textHeight / 2);\n\n\t\t\tOverlayUtil.renderTextLocation(graphics, canvasCenterPoint, timeLeftStr, TEXT_COLOR);\n\t\t}\n\t}\n\n\tprivate void renderNpcOverlay(Graphics2D graphics, HighlightedNpc highlightedNpc, Player player)\n\t{\n\t\tActor actor;\n\t\tNPCComposition npcComposition \u003d null;\n\t\tif (player \u003d\u003d null)\n\t\t{\n\t\t\tactor \u003d highlightedNpc.getNpc();\n\t\t\tnpcComposition \u003d highlightedNpc.getNpc().getTransformedComposition();\n\t\t\tif (npcComposition \u003d\u003d null || !npcComposition.isInteractible()\n\t\t\t\t|| (actor.isDead() \u0026\u0026 config.ignoreDeadNpcs()))\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tactor \u003d player;\n\t\t}\n\n\t\tfinal Color borderColor \u003d rainbowRavePlugin.getColor(actor.hashCode());\n\t\tColor fillColor \u003d rainbowRavePlugin.getColor(actor.hashCode());\n\t\tfillColor \u003d new Color(fillColor.getRed(), fillColor.getGreen(), fillColor.getBlue(), config.fillColor().getAlpha());\n\n\t\tif (highlightedNpc.isHull())\n\t\t{\n\t\t\tShape objectClickbox \u003d actor.getConvexHull();\n\t\t\trenderPoly(graphics, borderColor, fillColor, objectClickbox);\n\t\t}\n\n\t\tif (highlightedNpc.isTile())\n\t\t{\n\t\t\tint size \u003d npcComposition \u003d\u003d null ? 1 : npcComposition.getSize();\n\t\t\tLocalPoint lp \u003d actor.getLocalLocation();\n\t\t\tPolygon tilePoly \u003d Perspective.getCanvasTileAreaPoly(client, lp, size);\n\n\t\t\trenderPoly(graphics, borderColor, fillColor, tilePoly);\n\t\t}\n\n\t\tif (highlightedNpc.isTrueTile())\n\t\t{\n\t\t\tLocalPoint lp \u003d LocalPoint.fromWorld(actor.getWorldView(), actor.getWorldLocation()); // centered on sw tile\n\t\t\tif (lp !\u003d null)\n\t\t\t{\n\t\t\t\tint size \u003d npcComposition \u003d\u003d null ? 1 : npcComposition.getSize();\n\t\t\t\tfinal LocalPoint centerLp \u003d new LocalPoint(\n\t\t\t\t\tlp.getX() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2,\n\t\t\t\t\tlp.getY() + Perspective.LOCAL_TILE_SIZE * (size - 1) / 2,\n\t\t\t\t\tactor.getWorldView());\n\t\t\t\tPolygon tilePoly \u003d Perspective.getCanvasTileAreaPoly(client, centerLp, size);\n\t\t\t\trenderPoly(graphics, borderColor, fillColor, tilePoly);\n\t\t\t}\n\t\t}\n\n\t\tif (highlightedNpc.isSwTile())\n\t\t{\n\t\t\tint size \u003d npcComposition \u003d\u003d null ? 1 : npcComposition.getSize();\n\t\t\tLocalPoint lp \u003d actor.getLocalLocation();\n\n\t\t\tint x \u003d lp.getX() - ((size - 1) * Perspective.LOCAL_TILE_SIZE / 2);\n\t\t\tint y \u003d lp.getY() - ((size - 1) * Perspective.LOCAL_TILE_SIZE / 2);\n\n\t\t\tPolygon southWestTilePoly \u003d Perspective.getCanvasTilePoly(client, new LocalPoint(x, y, actor.getWorldView()));\n\t\t\trenderPoly(graphics, borderColor, fillColor, southWestTilePoly);\n\t\t}\n\n\t\tif (highlightedNpc.isSwTrueTile())\n\t\t{\n\t\t\tLocalPoint lp \u003d LocalPoint.fromWorld(actor.getWorldView(), actor.getWorldLocation());\n\t\t\tif (lp !\u003d null)\n\t\t\t{\n\t\t\t\tPolygon tilePoly \u003d Perspective.getCanvasTilePoly(client, lp);\n\t\t\t\trenderPoly(graphics, borderColor, fillColor, tilePoly);\n\t\t\t}\n\t\t}\n\n\t\tif (highlightedNpc.isOutline())\n\t\t{\n\t\t\tif (player \u003d\u003d null)\n\t\t\t{\n\t\t\t\tmodelOutlineRenderer.drawOutline(highlightedNpc.getNpc(), (int) config.borderWidth(), borderColor, config.outlineFeather());\n\t\t\t} else {\n\t\t\t\tmodelOutlineRenderer.drawOutline(player, (int) config.borderWidth(), borderColor, config.outlineFeather());\n\t\t\t}\n\t\t}\n\n\t\tif (highlightedNpc.isName() \u0026\u0026 actor.getName() !\u003d null)\n\t\t{\n\t\t\tString npcName \u003d Text.removeTags(actor.getName());\n\t\t\tPoint textLocation \u003d actor.getCanvasTextLocation(graphics, npcName, actor.getLogicalHeight() + 40);\n\n\t\t\tif (textLocation !\u003d null)\n\t\t\t{\n\t\t\t\tOverlayUtil.renderTextLocation(graphics, textLocation, npcName, borderColor);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void renderPoly(Graphics2D graphics, Color borderColor, Color fillColor, Shape polygon)\n\t{\n\t\tif (polygon !\u003d null)\n\t\t{\n\t\t\tgraphics.setColor(borderColor);\n\t\t\tgraphics.setStroke(new BasicStroke((float) config.borderWidth()));\n\t\t\tgraphics.draw(polygon);\n\t\t\tgraphics.setColor(fillColor);\n\t\t\tgraphics.fill(polygon);\n\t\t}\n\t}\n\n\tprivate boolean enabled \u003d true;\n\tpublic void enable(boolean enabled)\n\t{\n\t\tthis.enabled \u003d enabled;\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveNpcSceneOverlay.java"},{"fileName":"RainbowRaveGroundItemInputListener.java","content":"/*\n * Copyright (c) 2018, Seth \u003chttps://github.com/sethtroll\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Point;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport java.time.Duration;\nimport java.time.Instant;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport net.runelite.client.input.KeyListener;\nimport net.runelite.client.input.MouseAdapter;\nimport net.runelite.client.plugins.grounditems.GroundItemsConfig;\n\npublic class RainbowRaveGroundItemInputListener extends MouseAdapter implements KeyListener\n{\n\tprivate static final int HOTKEY \u003d KeyEvent.VK_ALT;\n\n\tprivate Instant lastPress;\n\n\t@Inject\n\tprivate RainbowRaveGroundItemsPlugin plugin;\n\n\t@Inject\n\tprivate GroundItemsConfig config;\n\n\t@Override\n\tpublic void keyTyped(KeyEvent e)\n\t{\n\n\t}\n\n\t@Override\n\tpublic void keyPressed(KeyEvent e)\n\t{\n\t\tif (e.getKeyCode() \u003d\u003d HOTKEY)\n\t\t{\n\t\t\tif (plugin.isHideAll())\n\t\t\t{\n\t\t\t\tplugin.setHideAll(false);\n\t\t\t\tplugin.setHotKeyPressed(true);\n\t\t\t\tlastPress \u003d null;\n\t\t\t}\n\t\t\telse if (lastPress !\u003d null \u0026\u0026 !plugin.isHotKeyPressed() \u0026\u0026 config.doubleTapDelay() \u003e 0 \u0026\u0026 Duration.between(lastPress, Instant.now()).compareTo(Duration.ofMillis(config.doubleTapDelay())) \u003c 0)\n\t\t\t{\n\t\t\t\tplugin.setHideAll(true);\n\t\t\t\tlastPress \u003d null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplugin.setHotKeyPressed(true);\n\t\t\t\tlastPress \u003d Instant.now();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void keyReleased(KeyEvent e)\n\t{\n\t\tif (e.getKeyCode() \u003d\u003d HOTKEY)\n\t\t{\n\t\t\tplugin.setHotKeyPressed(false);\n\t\t\tplugin.setTextBoxBounds(null);\n\t\t\tplugin.setHiddenBoxBounds(null);\n\t\t\tplugin.setHighlightBoxBounds(null);\n\t\t}\n\t}\n\n\t@Override\n\tpublic MouseEvent mousePressed(MouseEvent e)\n\t{\n\t\tfinal Point mousePos \u003d e.getPoint();\n\n\t\tif (plugin.isHotKeyPressed())\n\t\t{\n\t\t\tif (SwingUtilities.isLeftMouseButton(e))\n\t\t\t{\n\t\t\t\t// Process both click boxes for hidden and highlighted items\n\t\t\t\tif (plugin.getHiddenBoxBounds() !\u003d null \u0026\u0026 plugin.getHiddenBoxBounds().getKey().contains(mousePos))\n\t\t\t\t{\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\tif (plugin.getHighlightBoxBounds() !\u003d null \u0026\u0026 plugin.getHighlightBoxBounds().getKey().contains(mousePos))\n\t\t\t\t{\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\n\t\t\t\t// There is one name click box for left click and one for right click\n\t\t\t\tif (plugin.getTextBoxBounds() !\u003d null \u0026\u0026 plugin.getTextBoxBounds().getKey().contains(mousePos))\n\t\t\t\t{\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (SwingUtilities.isRightMouseButton(e))\n\t\t\t{\n\t\t\t\tif (plugin.getTextBoxBounds() !\u003d null \u0026\u0026 plugin.getTextBoxBounds().getKey().contains(mousePos))\n\t\t\t\t{\n\t\t\t\t\treturn e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn e;\n\t}\n}\n\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveGroundItemInputListener.java"},{"fileName":"GroundItem.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport java.time.Duration;\nimport java.time.Instant;\nimport javax.annotation.Nullable;\nimport lombok.Builder;\nimport lombok.Data;\nimport static net.runelite.api.TileItem.OWNERSHIP_OTHER;\nimport net.runelite.api.coords.WorldPoint;\n\n@Data\n@Builder\nclass GroundItem\n{\n\tprivate int id;\n\tprivate int itemId;\n\tprivate String name;\n\tprivate int quantity;\n\tprivate WorldPoint location;\n\tprivate int height;\n\tprivate int haPrice;\n\tprivate int gePrice;\n\tprivate int offset;\n\tprivate boolean tradeable;\n\tprivate int ownership;\n\tprivate boolean isPrivate;\n\t@Nullable\n\tprivate Instant spawnTime;\n\tprivate boolean stackable;\n\tprivate Duration despawnTime;\n\tprivate Duration visibleTime;\n\n\t// cached values derived from config\n\tboolean highlighted;\n\tboolean hidden;\n\tColor color;\n\n\tint getHaPrice()\n\t{\n\t\treturn haPrice * quantity;\n\t}\n\n\tint getGePrice()\n\t{\n\t\treturn gePrice * quantity;\n\t}\n\n\tboolean isMine()\n\t{\n\t\treturn ownership !\u003d OWNERSHIP_OTHER;\n\t}\n\n\tvoid reset()\n\t{\n\t\thighlighted \u003d hidden \u003d false;\n\t\tcolor \u003d null;\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/GroundItem.java"},{"fileName":"ObjectPoint.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\nclass ObjectPoint\n{\n\tprivate int id \u003d -1;\n\tprivate String name;\n\tprivate int regionId;\n\tprivate int regionX;\n\tprivate int regionY;\n\tprivate int z;\n\tprivate Color color;\n}\n","filePath":"src/main/java/com/rainbowrave/ObjectPoint.java"},{"fileName":"RainbowRaveGroundMarkerOverlay.java","content":"/*\n * Copyright (c) 2018, TheLonelyDev \u003chttps://github.com/TheLonelyDev\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Stroke;\nimport java.util.Collection;\nimport java.util.ConcurrentModificationException;\nimport java.util.Random;\nimport javax.annotation.Nullable;\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.plugins.groundmarkers.GroundMarkerConfig;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\n\npublic class RainbowRaveGroundMarkerOverlay extends Overlay\n{\n\tprivate static final int MAX_DRAW_DISTANCE \u003d 32;\n\n\tprivate final Client client;\n\tprivate final GroundMarkerConfig config;\n\tprivate final RainbowRaveGroundMarkerPlugin plugin;\n\tprivate final RainbowRaveConfig rainbowRaveConfig;\n\tprivate final RainbowRavePlugin rainbowRavePlugin;\n\n\tpublic RainbowRaveGroundMarkerOverlay(Client client, GroundMarkerConfig config, RainbowRaveGroundMarkerPlugin plugin, RainbowRavePlugin rainbowRavePlugin, RainbowRaveConfig rainbowRaveConfig)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.config \u003d config;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.rainbowRavePlugin \u003d rainbowRavePlugin;\n\t\tthis.rainbowRaveConfig \u003d rainbowRaveConfig;\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetPriority(Overlay.PRIORITY_LOW);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t}\n\n\tprivate Random random \u003d new Random();\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (!rainbowRaveConfig.rainbowTileMarkers()) return null;\n\n\t\tfinal Collection\u003cColorTileMarker\u003e points \u003d plugin.getPoints();\n\t\tif (points.isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tStroke stroke \u003d new BasicStroke((float) config.borderWidth());\n\t\ttry\n\t\t{\n\t\t\tint plane \u003d client.getTopLevelWorldView().getPlane();\n\t\t\tfor (final ColorTileMarker point : points)\n\t\t\t{\n\t\t\t\tWorldPoint worldPoint \u003d point.getWorldPoint();\n\t\t\t\tif (worldPoint.getPlane() !\u003d plane)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// This formula does not have a solid concept behind it, I just tried random stuff.\n\t\t\t\tint hashCode;\n\t\t\t\tswitch (rainbowRaveConfig.groundMarkerColorMode()) {\n\t\t\t\t\tcase WAVES:\n\t\t\t\t\t\thashCode \u003d (point.getWorldPoint().getX() + point.getWorldPoint().getY()) * 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase COLOR_SYNC:\n\t\t\t\t\t\tif (point.getColor() !\u003d null) {\n\t\t\t\t\t\t\trandom.setSeed(point.getColor().getRGB());\n\t\t\t\t\t\t\thashCode \u003d random.nextInt(1000);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tcase RANDOM:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\trandom.setSeed(((long) point.getWorldPoint().getX() \u003c\u003c 16) + point.getWorldPoint().getY());\n\t\t\t\t\t\thashCode \u003d random.nextInt(1000);\n\t\t\t\t}\n\t\t\t\tColor tileColor \u003d rainbowRaveConfig.syncColor() ? rainbowRavePlugin.getColor(0) : rainbowRaveConfig.theme().getColor(((hashCode + (client.getGameCycle() * (6000f / rainbowRaveConfig.colorSpeed()))) % 300) / 300f);\n\t\t\t\tdrawTile(graphics, worldPoint, tileColor, point.getLabel(), stroke, rainbowRaveConfig.fillTiles());\n\t\t\t}\n\t\t} catch (ConcurrentModificationException e) {\n\t\t\t// can happen when removing stuff from points, such as when disabling drawing brush markers tiles.\n\t\t\t// don\u0027t care, doesn\u0027t have a significant visual effect.\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void drawTile(Graphics2D graphics, WorldPoint point, Color color, @Nullable String label, Stroke borderStroke, boolean fill)\n\t{\n\t\tWorldPoint playerLocation \u003d client.getLocalPlayer().getWorldLocation();\n\n\t\tif (point.distanceTo(playerLocation) \u003e\u003d MAX_DRAW_DISTANCE)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tLocalPoint lp \u003d LocalPoint.fromWorld(client.getTopLevelWorldView(), point);\n\t\tif (lp \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tPolygon poly \u003d Perspective.getCanvasTilePoly(client, lp);\n\t\tif (poly !\u003d null)\n\t\t{\n\t\t\tif (fill)\n\t\t\t{\n\t\t\t\tgraphics.setColor(color);\n\t\t\t\tgraphics.fillPolygon(poly);\n\t\t\t}\n\t\t\tgraphics.setColor(color);\n\t\t\tStroke originalStroke \u003d graphics.getStroke();\n\t\t\tgraphics.setStroke(borderStroke);\n\t\t\tgraphics.draw(poly);\n\t\t\tgraphics.setStroke(originalStroke);\n\t\t}\n\n\t\tif (!Strings.isNullOrEmpty(label))\n\t\t{\n\t\t\tPoint canvasTextLocation \u003d Perspective.getCanvasTextLocation(client, graphics, lp, label, 0);\n\t\t\tif (canvasTextLocation !\u003d null)\n\t\t\t{\n\t\t\t\tOverlayUtil.renderTextLocation(graphics, canvasTextLocation, label, color);\n\t\t\t}\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveGroundMarkerOverlay.java"},{"fileName":"RainbowRaveGroundItemsPlugin.java","content":"/*\n * Copyright (c) 2017, Aria \u003caria@ar1as.space\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.HashBasedTable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Table;\nimport static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.HIGH;\nimport static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.INSANE;\nimport static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.LOW;\nimport static com.rainbowrave.RainbowRaveConfig.GroundItemsToColor.MEDIUM;\nimport java.awt.Color;\nimport java.awt.Rectangle;\nimport static java.lang.Boolean.TRUE;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.Setter;\nimport lombok.Value;\nimport net.runelite.api.*;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.FocusChanged;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.ItemDespawned;\nimport net.runelite.api.events.ItemQuantityChanged;\nimport net.runelite.api.events.ItemSpawned;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ClientShutdown;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.input.KeyManager;\nimport net.runelite.client.input.MouseManager;\nimport net.runelite.client.plugins.grounditems.GroundItemsConfig;\nimport net.runelite.client.plugins.grounditems.config.OwnershipFilterMode;\nimport static net.runelite.api.TileItem.OWNERSHIP_GROUP;\nimport static net.runelite.api.TileItem.OWNERSHIP_NONE;\nimport static net.runelite.api.TileItem.OWNERSHIP_OTHER;\nimport static net.runelite.api.TileItem.OWNERSHIP_SELF;\nimport net.runelite.client.plugins.grounditems.config.HighlightTier;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.util.RSTimeUnit;\nimport net.runelite.client.util.Text;\n\npublic class RainbowRaveGroundItemsPlugin\n{\n\n\tpublic static final String GROUND_ITEMS_CONFIG_GROUP \u003d \"grounditems\";\n\tpublic static final String SHOW_LOOTBEAM_TIER_CONFIG_KEY \u003d \"showLootbeamTier\";\n\tpublic static final String SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY \u003d \"showLootbeamForHighlighted\";\n\n\t@Value\n\tstatic class PriceHighlight\n\t{\n\t\tprivate final int price;\n\t\tprivate final Color color;\n\t}\n\n\t// ItemID for coins\n\tprivate static final int COINS \u003d ItemID.COINS_995;\n\n\t@Getter(AccessLevel.PACKAGE)\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate Map.Entry\u003cRectangle, GroundItem\u003e textBoxBounds;\n\n\t@Getter(AccessLevel.PACKAGE)\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate Map.Entry\u003cRectangle, GroundItem\u003e hiddenBoxBounds;\n\n\t@Getter(AccessLevel.PACKAGE)\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate Map.Entry\u003cRectangle, GroundItem\u003e highlightBoxBounds;\n\n\t@Getter(AccessLevel.PACKAGE)\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate boolean hotKeyPressed;\n\n\t@Getter(AccessLevel.PACKAGE)\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate boolean hideAll;\n\n\tprivate List\u003cString\u003e hiddenItemList \u003d new CopyOnWriteArrayList\u003c\u003e();\n\tprivate List\u003cString\u003e highlightedItemsList \u003d new CopyOnWriteArrayList\u003c\u003e();\n\n\t@Inject\n\tpublic RainbowRaveGroundItemInputListener inputListener;\n\n\t@Inject\n\tprivate MouseManager mouseManager;\n\n\t@Inject\n\tprivate KeyManager keyManager;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate ItemManager itemManager;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate GroundItemsConfig config;\n\n//\t@Inject\n//\tprivate RainbowRaveGroundItemsOverlay overlay;\n//\n\t@Inject\n\tprivate Notifier notifier;\n\n\t@Inject\n\tprivate ScheduledExecutorService executor;\n\n\t@Inject\n\tprivate RainbowRaveConfig rainbowRaveConfig;\n\n\t@Inject\n\tprivate RainbowRavePlugin rainbowRavePlugin;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Getter\n\tprivate final Table\u003cWorldPoint, Integer, GroundItem\u003e collectedGroundItems \u003d HashBasedTable.create();\n\tprivate List\u003cPriceHighlight\u003e priceChecks \u003d ImmutableList.of();\n\tprivate LoadingCache\u003cNamedQuantity, Boolean\u003e highlightedItems;\n\tprivate LoadingCache\u003cNamedQuantity, Boolean\u003e hiddenItems;\n\tfinal Map\u003cWorldPoint, Lootbeam\u003e lootbeams \u003d new HashMap\u003c\u003e();\n\n//\t@Override\n\tprotected void startUp()\n\t{\n\t\tgroundItemsLootBeamChange(false, false, true);\n//\t\toverlayManager.add(overlay);\n\t\tmouseManager.registerMouseListener(inputListener);\n\t\tkeyManager.registerKeyListener(inputListener);\n\t\texecutor.execute(this::reset);\n\t}\n\n\t@Subscribe\n\tpublic void onClientShutdown(ClientShutdown e) {\n\t\tif (rainbowRaveConfig.recolorLootBeams())\n\t\t{\n\t\t\trestoreGroundItemLootBeams();\n\t\t}\n\t}\n\n//\t@Override\n\tprotected void shutDown()\n\t{\n\t\tif (rainbowRaveConfig.recolorLootBeams())\n\t\t{\n\t\t\trestoreGroundItemLootBeams();\n\t\t}\n//\t\toverlayManager.remove(overlay);\n\t\tmouseManager.unregisterMouseListener(inputListener);\n\t\tkeyManager.unregisterKeyListener(inputListener);\n\t\tif (highlightedItems !\u003d null)\n\t\t{\n\t\t\thighlightedItems.invalidateAll();\n\t\t\thighlightedItems \u003d null;\n\t\t}\n\t\tif (hiddenItems !\u003d null)\n\t\t{\n\t\t\thiddenItems.invalidateAll();\n\t\t\thiddenItems \u003d null;\n\t\t}\n\t\thiddenItemList \u003d null;\n\t\thighlightedItemsList \u003d null;\n\t\tcollectedGroundItems.clear();\n\t\tclientThread.invokeLater(this::removeAllLootbeams);\n\t}\n\n\tprivate boolean ignoreConfigChange \u003d false;\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged event)\n\t{\n\t\tif (ignoreConfigChange) return;\n\n\t\tif (event.getGroup().equals(GROUND_ITEMS_CONFIG_GROUP))\n\t\t{\n\t\t\tif (event.getKey().equals(SHOW_LOOTBEAM_TIER_CONFIG_KEY)) {\n\t\t\t\tgroundItemsLootBeamChange(true, false, false);\n\t\t\t}\n\t\t\telse if (event.getKey().equals(SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY))\n\t\t\t{\n\t\t\t\tgroundItemsLootBeamChange(false, true, false);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\texecutor.execute(this::reset);\n\t\t\t}\n\t\t}\n\t\telse if (event.getGroup().equals(RainbowRavePlugin.GROUP))\n\t\t{\n\t\t\tif (event.getKey().equals(RainbowRaveConfig.RECOLOR_LOOT_BEAMS_KEY))\n\t\t\t{\n\t\t\t\tif (rainbowRaveConfig.recolorLootBeams())\n\t\t\t\t{\n\t\t\t\t\tgroundItemsLootBeamChange(false, false, true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trestoreGroundItemLootBeams();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void groundItemsLootBeamChange(boolean tierChanged, boolean highlightedChanged, boolean turningOnRecolorLootBeams)\n\t{\n\t\tif (rainbowRaveConfig.recolorLootBeams())\n\t\t{\n\t\t\tif (!turningOnRecolorLootBeams \u0026\u0026 SwingUtilities.isEventDispatchThread()) // Changes from profile changes happen on the executor thread, only show the message when it happens on the swing thread.\n\t\t\t{\n\t\t\t\tclientThread.invoke(() -\u003e client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\",\n\t\t\t\t\t\"Rainbow Rave: Please change loot beam settings through the rainbow rave plugin\u0027s settings, as rainbow rave needs to disable regular loot beams in order to recolor them.\",\n\t\t\t\t\t\"\", false));\n\t\t\t}\n\t\t\tignoreConfigChange \u003d true;\n\t\t\tif (tierChanged || turningOnRecolorLootBeams)\n\t\t\t{\n\t\t\t\tHighlightTier highlightTier \u003d config.showLootbeamTier();\n\t\t\t\trainbowRaveConfig.setGroundItemsLootbeamTier(highlightTier);\n\t\t\t\tconfigManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_TIER_CONFIG_KEY, HighlightTier.OFF);\n\t\t\t}\n\t\t\tif (highlightedChanged || turningOnRecolorLootBeams)\n\t\t\t{\n\t\t\t\tboolean showLootbeamForHighlighted \u003d config.showLootbeamForHighlighted();\n\t\t\t\trainbowRaveConfig.setGroundItemsHighlightedItemsLootbeam(showLootbeamForHighlighted);\n\t\t\t\tconfigManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY, false);\n\t\t\t}\n\t\t\tignoreConfigChange \u003d false;\n\n\t\t\texecutor.execute(this::reset);\n\t\t}\n\t}\n\n\tprivate void restoreGroundItemLootBeams()\n\t{\n\t\tHighlightTier tier \u003d rainbowRaveConfig.getGroundItemsLootbeamTier();\n\t\tBoolean showLootbeamForHighlighted \u003d rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam();\n\t\tignoreConfigChange \u003d true;\n\t\tconfigManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_TIER_CONFIG_KEY, tier);\n\t\tconfigManager.setConfiguration(GROUND_ITEMS_CONFIG_GROUP, SHOW_LOOTBEAM_FOR_HIGHLIGHTED_CONFIG_KEY, showLootbeamForHighlighted);\n\t\tignoreConfigChange \u003d false;\n\n\t\texecutor.execute(this::reset);\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(final GameStateChanged event)\n\t{\n\t\tif (event.getGameState() \u003d\u003d GameState.LOADING)\n\t\t{\n\t\t\tcollectedGroundItems.clear();\n\t\t\tlootbeams.clear();\n\t\t}\n\t}\n\n\tpublic void onItemSpawned(ItemSpawned itemSpawned)\n\t{\n\t\tTileItem item \u003d itemSpawned.getItem();\n\t\tTile tile \u003d itemSpawned.getTile();\n\n\t\tGroundItem groundItem \u003d buildGroundItem(tile, item);\n\t\tGroundItem existing \u003d collectedGroundItems.get(tile.getWorldLocation(), item.getId());\n\t\tif (existing !\u003d null)\n\t\t{\n\t\t\texisting.setQuantity(existing.getQuantity() + groundItem.getQuantity());\n\t\t\t// The spawn time remains set at the oldest spawn\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcollectedGroundItems.put(tile.getWorldLocation(), item.getId(), groundItem);\n\t\t}\n\n//\t\tif (shouldDisplayItem(config.ownershipFilterMode(), groundItem.getOwnership(), client.getVarbitValue(Varbits.ACCOUNT_TYPE)))\n//\t\t{\n//\t\t\tnotifyHighlightedItem(groundItem);\n//\t\t}\n\n\t\thandleLootbeam(tile.getWorldLocation());\n\t}\n\n\t@Subscribe\n\tpublic void onItemDespawned(ItemDespawned itemDespawned)\n\t{\n\t\tTileItem item \u003d itemDespawned.getItem();\n\t\tTile tile \u003d itemDespawned.getTile();\n\n\t\tGroundItem groundItem \u003d collectedGroundItems.get(tile.getWorldLocation(), item.getId());\n\t\tif (groundItem \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (groundItem.getQuantity() \u003c\u003d item.getQuantity())\n\t\t{\n\t\t\tcollectedGroundItems.remove(tile.getWorldLocation(), item.getId());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgroundItem.setQuantity(groundItem.getQuantity() - item.getQuantity());\n\t\t\t// When picking up an item when multiple stacks appear on the ground,\n\t\t\t// it is not known which item is picked up, so we invalidate the spawn\n\t\t\t// time\n\t\t\tgroundItem.setSpawnTime(null);\n\t\t}\n\n\t\thandleLootbeam(tile.getWorldLocation());\n\t}\n\n\t@Subscribe\n\tpublic void onItemQuantityChanged(ItemQuantityChanged itemQuantityChanged)\n\t{\n\t\tTileItem item \u003d itemQuantityChanged.getItem();\n\t\tTile tile \u003d itemQuantityChanged.getTile();\n\t\tint oldQuantity \u003d itemQuantityChanged.getOldQuantity();\n\t\tint newQuantity \u003d itemQuantityChanged.getNewQuantity();\n\n\t\tint diff \u003d newQuantity - oldQuantity;\n\t\tGroundItem groundItem \u003d collectedGroundItems.get(tile.getWorldLocation(), item.getId());\n\t\tif (groundItem !\u003d null)\n\t\t{\n\t\t\tgroundItem.setQuantity(groundItem.getQuantity() + diff);\n\t\t}\n\n\t\thandleLootbeam(tile.getWorldLocation());\n\t}\n\n//\t@Subscribe\n//\tpublic void onClientTick(ClientTick event)\n//\t{\n//\t}\n\n\tprivate GroundItem buildGroundItem(final Tile tile, final TileItem item)\n\t{\n\t\t// Collect the data for the item\n\t\tfinal int itemId \u003d item.getId();\n\t\tfinal ItemComposition itemComposition \u003d itemManager.getItemComposition(itemId);\n\t\tfinal int realItemId \u003d itemComposition.getNote() !\u003d -1 ? itemComposition.getLinkedNoteId() : itemId;\n\t\tfinal int alchPrice \u003d itemComposition.getHaPrice();\n\t\tfinal int despawnTime \u003d item.getDespawnTime() - client.getTickCount();\n\t\tfinal int visibleTime \u003d item.getVisibleTime() - client.getTickCount();\n\n\t\tfinal GroundItem groundItem \u003d GroundItem.builder()\n\t\t\t.id(itemId)\n\t\t\t.location(tile.getWorldLocation())\n\t\t\t.itemId(realItemId)\n\t\t\t.quantity(item.getQuantity())\n\t\t\t.name(itemComposition.getName())\n\t\t\t.haPrice(alchPrice)\n\t\t\t.height(tile.getItemLayer().getHeight())\n\t\t\t.tradeable(itemComposition.isTradeable())\n\t\t\t.ownership(item.getOwnership())\n\t\t\t.isPrivate(item.isPrivate())\n\t\t\t.spawnTime(Instant.now())\n\t\t\t.stackable(itemComposition.isStackable())\n\t\t\t.despawnTime(Duration.of(despawnTime, RSTimeUnit.GAME_TICKS))\n\t\t\t.visibleTime(Duration.of(visibleTime, RSTimeUnit.GAME_TICKS))\n\t\t\t.build();\n\n\t\t// Update item price in case it is coins\n\t\tif (realItemId \u003d\u003d COINS)\n\t\t{\n\t\t\tgroundItem.setHaPrice(1);\n\t\t\tgroundItem.setGePrice(1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgroundItem.setGePrice(itemManager.getItemPrice(realItemId));\n\t\t}\n\n\t\treturn groundItem;\n\t}\n\n\tprivate void reset()\n\t{\n\t\t// gets the hidden items from the text box in the config\n\t\thiddenItemList \u003d Text.fromCSV(config.getHiddenItems());\n\n\t\t// gets the highlighted items from the text box in the config\n\t\thighlightedItemsList \u003d Text.fromCSV(config.getHighlightItems());\n\n\t\thighlightedItems \u003d CacheBuilder.newBuilder()\n\t\t\t.maximumSize(512L)\n\t\t\t.expireAfterAccess(10, TimeUnit.MINUTES)\n\t\t\t.build(new WildcardMatchLoader(highlightedItemsList));\n\n\t\thiddenItems \u003d CacheBuilder.newBuilder()\n\t\t\t.maximumSize(512L)\n\t\t\t.expireAfterAccess(10, TimeUnit.MINUTES)\n\t\t\t.build(new WildcardMatchLoader(hiddenItemList));\n\n\t\t// Cache colors\n\t\tImmutableList.Builder\u003cPriceHighlight\u003e priceCheckBuilder \u003d ImmutableList.builder();\n\n\t\tif (config.insaneValuePrice() \u003e 0)\n\t\t{\n\t\t\tpriceCheckBuilder.add(new PriceHighlight(config.insaneValuePrice(), config.insaneValueColor()));\n\t\t}\n\n\t\tif (config.highValuePrice() \u003e 0)\n\t\t{\n\t\t\tpriceCheckBuilder.add(new PriceHighlight(config.highValuePrice(), config.highValueColor()));\n\t\t}\n\n\t\tif (config.mediumValuePrice() \u003e 0)\n\t\t{\n\t\t\tpriceCheckBuilder.add(new PriceHighlight(config.mediumValuePrice(), config.mediumValueColor()));\n\t\t}\n\n\t\tif (config.lowValuePrice() \u003e 0)\n\t\t{\n\t\t\tpriceCheckBuilder.add(new PriceHighlight(config.lowValuePrice(), config.lowValueColor()));\n\t\t}\n\n\t\tpriceChecks \u003d priceCheckBuilder.build();\n\n\t\tclientThread.invokeLater(this::handleLootbeams);\n\t}\n\n//\t@Subscribe\n//\tpublic void onMenuEntryAdded(MenuEntryAdded event)\n//\t{\n//\t}\n\n//\tvoid updateList(String item, boolean hiddenList)\n//\t{\n//\t}\n\n\tOptional\u003cColor\u003e getHighlighted(NamedQuantity item, int gePrice, int haPrice)\n\t{\n\t\tif (TRUE.equals(highlightedItems.getUnchecked(item)))\n\t\t{\n\t\t\treturn rainbowRaveConfig.colorHighlightedGroundItems() ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();\n\t\t}\n\n\t\t// Explicit hide takes priority over implicit highlight\n\t\tif (TRUE.equals(hiddenItems.getUnchecked(item)))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal int price \u003d getValueByMode(gePrice, haPrice);\n\t\tif (price \u003e config.insaneValuePrice())\n\t\t{\n\t\t\treturn colorForTier(INSANE, item);\n\t\t}\n\n\t\tif (price \u003e config.highValuePrice())\n\t\t{\n\t\t\treturn colorForTier(HIGH, item);\n\t\t}\n\n\t\tif (price \u003e config.mediumValuePrice())\n\t\t{\n\t\t\treturn colorForTier(MEDIUM, item);\n\t\t}\n\n\t\tif (price \u003e config.lowValuePrice())\n\t\t{\n\t\t\treturn colorForTier(LOW, item);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate Optional\u003cColor\u003e colorForTier(RainbowRaveConfig.GroundItemsToColor tier, NamedQuantity item)\n\t{\n\t\treturn rainbowRaveConfig.whichGroundItemsToColor().compareTo(tier) \u003e\u003d 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();\n\t}\n\n\tOptional\u003cColor\u003e getHidden(NamedQuantity item, int gePrice, int haPrice, boolean isTradeable)\n\t{\n\t\tfinal boolean isExplicitHidden \u003d TRUE.equals(hiddenItems.getUnchecked(item));\n\t\tfinal boolean isExplicitHighlight \u003d TRUE.equals(highlightedItems.getUnchecked(item));\n\t\tfinal boolean canBeHidden \u003d gePrice \u003e 0 || isTradeable || !config.dontHideUntradeables();\n\t\tfinal boolean underGe \u003d gePrice \u003c config.getHideUnderValue();\n\t\tfinal boolean underHa \u003d haPrice \u003c config.getHideUnderValue();\n\n\t\t// Explicit highlight takes priority over implicit hide\n\t\treturn isExplicitHidden || (!isExplicitHighlight \u0026\u0026 canBeHidden \u0026\u0026 underGe \u0026\u0026 underHa)\n\t\t\t? rainbowRaveConfig.whichGroundItemsToColor().compareTo(RainbowRaveConfig.GroundItemsToColor.HIDDEN) \u003e\u003d 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty()\n\t\t\t: null;\n\t}\n\n\tOptional\u003cColor\u003e getItemColor(Optional\u003cColor\u003e highlighted, Optional\u003cColor\u003e hidden, NamedQuantity item)\n\t{\n\t\tif (highlighted !\u003d null)\n\t\t{\n\t\t\treturn highlighted;\n\t\t}\n\n\t\tif (hidden !\u003d null)\n\t\t{\n\t\t\treturn hidden;\n\t\t}\n\n\t\treturn rainbowRaveConfig.whichGroundItemsToColor().compareTo(RainbowRaveConfig.GroundItemsToColor.REGULAR) \u003e\u003d 0 ? Optional.of(rainbowRavePlugin.getColor(item.getName().hashCode())) : Optional.empty();\n\t}\n\n\t@Subscribe\n\tpublic void onFocusChanged(FocusChanged focusChanged)\n\t{\n\t\tif (!focusChanged.isFocused())\n\t\t{\n\t\t\tsetHotKeyPressed(false);\n\t\t}\n\t}\n\n//\tprivate void notifyHighlightedItem(net.runelite.client.plugins.grounditems.GroundItem item)\n//\t{\n//\t}\n\n\tprivate int getValueByMode(int gePrice, int haPrice)\n\t{\n\t\tswitch (config.valueCalculationMode())\n\t\t{\n\t\t\tcase GE:\n\t\t\t\treturn gePrice;\n\t\t\tcase HA:\n\t\t\t\treturn haPrice;\n\t\t\tdefault: // Highest\n\t\t\t\treturn Math.max(gePrice, haPrice);\n\t\t}\n\t}\n\n\tprivate void handleLootbeam(WorldPoint worldPoint)\n\t{\n\t\t/*\n\t\t * Return and remove the lootbeam from this location if lootbeam are disabled\n\t\t * Lootbeam can be at this location if the config was just changed\n\t\t */\n\t\tif (!rainbowRaveConfig.recolorLootBeams() || !(rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam() || rainbowRaveConfig.getGroundItemsLootbeamTier() !\u003d HighlightTier.OFF))\n\t\t{\n\t\t\tremoveLootbeam(worldPoint);\n\t\t\treturn;\n\t\t}\n\n\t\tint price \u003d -1;\n\t\tCollection\u003cGroundItem\u003e groundItems \u003d collectedGroundItems.row(worldPoint).values();\n\t\tfinal OwnershipFilterMode ownershipFilterMode \u003d config.ownershipFilterMode();\n\t\tfinal int accountType \u003d client.getVarbitValue(Varbits.ACCOUNT_TYPE);\n\t\tfor (GroundItem groundItem : groundItems)\n\t\t{\n\t\t\tif (!shouldDisplayItem(ownershipFilterMode, groundItem.getOwnership(), accountType))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * highlighted items have the highest priority so if an item is highlighted at this location\n\t\t\t * we can early return\n\t\t\t */\n\t\t\tNamedQuantity item \u003d new NamedQuantity(groundItem);\n\t\t\tif (rainbowRaveConfig.getGroundItemsHighlightedItemsLootbeam()\n\t\t\t\t\u0026\u0026 TRUE.equals(highlightedItems.getUnchecked(item)))\n\t\t\t{\n\t\t\t\taddLootbeam(worldPoint, config.highlightedColor(), null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Explicit hide takes priority over implicit highlight\n\t\t\tif (TRUE.equals(hiddenItems.getUnchecked(item)))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint itemPrice \u003d getValueByMode(groundItem.getGePrice(), groundItem.getHaPrice());\n\t\t\tprice \u003d Math.max(itemPrice, price);\n\t\t}\n\n\t\tif (rainbowRaveConfig.getGroundItemsLootbeamTier() !\u003d HighlightTier.OFF)\n\t\t{\n\t\t\tfor (PriceHighlight highlight : priceChecks)\n\t\t\t{\n\t\t\t\tif (price \u003e highlight.getPrice() \u0026\u0026 price \u003e rainbowRaveConfig.getGroundItemsLootbeamTier().getValueFromTier(config))\n\t\t\t\t{\n\t\t\t\t\taddLootbeam(worldPoint, highlight.color, rainbowRaveConfig.getGroundItemsLootbeamTier());\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tremoveLootbeam(worldPoint);\n\t}\n\n\tprivate void handleLootbeams()\n\t{\n\t\tfor (WorldPoint worldPoint : collectedGroundItems.rowKeySet())\n\t\t{\n\t\t\thandleLootbeam(worldPoint);\n\t\t}\n\t}\n\n\tprivate void removeAllLootbeams()\n\t{\n\t\tfor (Lootbeam lootbeam : lootbeams.values())\n\t\t{\n\t\t\tlootbeam.remove();\n\t\t}\n\n\t\tlootbeams.clear();\n\t}\n\n\tprivate void addLootbeam(WorldPoint worldPoint, Color color, HighlightTier tier)\n\t{\n\t\tLootbeam lootbeam \u003d lootbeams.get(worldPoint);\n\t\tif (lootbeam \u003d\u003d null)\n\t\t{\n\t\t\tlootbeam \u003d new Lootbeam(client, clientThread, worldPoint, color, config.lootbeamStyle().name(), tier);\n\t\t\tlootbeams.put(worldPoint, lootbeam);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlootbeam.setColor(color);\n\t\t\tlootbeam.setStyle(config.lootbeamStyle().name());\n\t\t}\n\t}\n\n\tprivate void removeLootbeam(WorldPoint worldPoint)\n\t{\n\t\tLootbeam lootbeam \u003d lootbeams.remove(worldPoint);\n\t\tif (lootbeam !\u003d null)\n\t\t{\n\t\t\tlootbeam.remove();\n\t\t}\n\t}\n\n\t/*\n\t * All      -\u003e none | self | other | group\n\t * Drops    -\u003e self | group\n\t * Takeable -\u003e none | self | group | (if a main then other)\n\t */\n\tboolean shouldDisplayItem(OwnershipFilterMode filterMode, int ownership, int accountType)\n\t{\n\t\tswitch (filterMode)\n\t\t{\n\t\t\tcase DROPS:\n\t\t\t\treturn ownership \u003d\u003d OWNERSHIP_SELF || ownership \u003d\u003d OWNERSHIP_GROUP;\n\t\t\tcase TAKEABLE:\n\t\t\t\treturn ownership !\u003d OWNERSHIP_OTHER || accountType \u003d\u003d 0; // Mains can always take items\n\t\t\tdefault:\n\t\t\t\treturn true;\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveGroundItemsPlugin.java"},{"fileName":"RainbowRaveTileIndicatorsPlugin.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.events.ProfileChanged;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n@Slf4j\npublic class RainbowRaveTileIndicatorsPlugin\n{\n\t@Inject private Client client;\n\t@Inject private OverlayManager overlayManager;\n\t@Inject private ConfigManager configManager;\n\t@Inject private RainbowRaveConfig rainbowRaveConfig;\n\n\t@Getter private WorldPoint lastPlayerPosition \u003d new WorldPoint(0, 0, 0);\n\t@Getter private int lastTickPlayerMoved \u003d 0;\n\t@Getter private long lastTimePlayerStoppedMoving \u003d 0;\n\n\tboolean recolorFill;\n\n\tboolean highlightDestinationTile;\n\tColor highlightDestinationColor;\n\tColor destinationTileFillColor;\n\tdouble destinationTileBorderWidth;\n\tboolean highlightHoveredTile;\n\tColor highlightHoveredColor;\n\tColor hoveredTileFillColor;\n\tdouble hoveredTileBorderWidth;\n\tboolean highlightCurrentTile;\n\tColor highlightCurrentColor;\n\tColor currentTileFillColor;\n\tdouble currentTileBorderWidth;\n\n\tboolean trueTileFadeout;\n\tint trueTileFadeoutTime;\n\tboolean destinationTileCornersOnly;\n\tboolean hoveredTileCornersOnly;\n\tboolean currentTileCornersOnly;\n\tint hoveredTileCornerSize;\n\tint destinationTileCornerSize;\n\tint currentTileCornerSize;\n\n\tprotected void startUp()\n\t{\n\t\tloadConfig();\n\t}\n\n\t@Subscribe\n\tpublic void onProfileChanged(ProfileChanged e) {\n\t\tloadConfig();\n\t}\n\n\tprotected void shutDown()\n\t{\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged e) {\n\t\t// I don\u0027t want this to apply to profile change config changes because the config is in an invalid state\n\t\t// during a profile change, so I check the thread since the EDT is where normal config changes happen.\n\t\tif (!SwingUtilities.isEventDispatchThread()) return;\n\t\tif (e.getGroup().equals(\"cornertileindicators\") || e.getGroup().equals(\"tileindicators\") || e.getGroup().equals(\"rainbow_rave\"))\n\t\t{\n\t\t\tloadConfig();\n\t\t}\n\t}\n\n\tprivate void loadConfig() {\n\t\tboolean cornerTileIndicatorsInstalled \u003d configManager.getConfiguration(\"runelite\", \"externalPlugins\").contains(\"corner-tile-indicators\");\n\t\tString group \u003d cornerTileIndicatorsInstalled \u0026\u0026 rainbowRaveConfig.preferCornerTileIndicatorsConfig() ? \"cornertileindicators\" : \"tileindicators\";\n\n\t\trecolorFill \u003d rainbowRaveConfig.recolorTileIndicatorFill();\n\n\t\thighlightDestinationTile \u003d configManager.getConfiguration(group, \"highlightDestinationTile\", boolean.class);\n\t\thighlightDestinationColor \u003d configManager.getConfiguration(group, \"highlightDestinationColor\", Color.class);\n\t\tdestinationTileFillColor \u003d configManager.getConfiguration(group, \"destinationTileFillColor\", Color.class);\n\t\tdestinationTileBorderWidth \u003d configManager.getConfiguration(group, \"destinationTileBorderWidth\", double.class);\n\t\thighlightHoveredTile \u003d configManager.getConfiguration(group, \"highlightHoveredTile\", boolean.class);\n\t\thighlightHoveredColor \u003d configManager.getConfiguration(group, \"highlightHoveredColor\", Color.class);\n\t\thoveredTileFillColor \u003d configManager.getConfiguration(group, \"hoveredTileFillColor\", Color.class);\n\t\thoveredTileBorderWidth \u003d configManager.getConfiguration(group, \"hoveredTileBorderWidth\", double.class);\n\t\thighlightCurrentTile \u003d configManager.getConfiguration(group, \"highlightCurrentTile\", boolean.class);\n\t\thighlightCurrentColor \u003d configManager.getConfiguration(group, \"highlightCurrentColor\", Color.class);\n\t\tcurrentTileFillColor \u003d configManager.getConfiguration(group, \"currentTileFillColor\", Color.class);\n\t\tcurrentTileBorderWidth \u003d configManager.getConfiguration(group, \"currentTileBorderWidth\", double.class);\n\n\t\tif (\"cornertileindicators\".equals(group))\n\t\t{\n\t\t\ttrueTileFadeout \u003d configManager.getConfiguration(group, \"trueTileFadeout\", boolean.class);\n\t\t\ttrueTileFadeoutTime \u003d configManager.getConfiguration(group, \"trueTileFadeoutTime\", int.class);\n\t\t\tdestinationTileCornersOnly \u003d configManager.getConfiguration(group, \"destinationTileCornersOnly\", boolean.class);\n\t\t\thoveredTileCornersOnly \u003d configManager.getConfiguration(group, \"hoveredTileCornersOnly\", boolean.class);\n\t\t\tcurrentTileCornersOnly \u003d configManager.getConfiguration(group, \"currentTileCornersOnly\", boolean.class);\n\t\t\thoveredTileCornerSize \u003d configManager.getConfiguration(group, \"hoveredTileCornerSize\", int.class);\n\t\t\tdestinationTileCornerSize \u003d configManager.getConfiguration(group, \"destinationTileCornerSize\", int.class);\n\t\t\tcurrentTileCornerSize \u003d configManager.getConfiguration(group, \"currentTileCornerSize\", int.class);\n\t\t} else {\n\t\t\ttrueTileFadeout \u003d false;\n\t\t\tdestinationTileCornersOnly \u003d false;\n\t\t\thoveredTileCornersOnly \u003d false;\n\t\t\tcurrentTileCornersOnly \u003d false;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick e)\n\t{\n\t\tWorldPoint playerPos \u003d client.getLocalPlayer().getWorldLocation();\n\n\t\tif (!playerPos.equals(lastPlayerPosition))\n\t\t{\n\t\t\tlastTickPlayerMoved \u003d client.getTickCount();\n\t\t}\n\t\telse if (lastTickPlayerMoved + 1 \u003d\u003d client.getTickCount())\n\t\t{\n\t\t\tlastTimePlayerStoppedMoving \u003d System.currentTimeMillis();\n\t\t}\n\n\t\tlastPlayerPosition \u003d playerPos;\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveTileIndicatorsPlugin.java"},{"fileName":"RainbowRaveObjectIndicatorsPlugin.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.DecorativeObject;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.GameState;\nimport net.runelite.api.GroundObject;\nimport net.runelite.api.MenuAction;\nimport net.runelite.api.ObjectComposition;\nimport net.runelite.api.Scene;\nimport net.runelite.api.Tile;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.WallObject;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.DecorativeObjectDespawned;\nimport net.runelite.api.events.DecorativeObjectSpawned;\nimport net.runelite.api.events.GameObjectDespawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GroundObjectDespawned;\nimport net.runelite.api.events.GroundObjectSpawned;\nimport net.runelite.api.events.MenuOptionClicked;\nimport net.runelite.api.events.WallObjectDespawned;\nimport net.runelite.api.events.WallObjectSpawned;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.objectindicators.ObjectIndicatorsConfig;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n@Slf4j\npublic class RainbowRaveObjectIndicatorsPlugin\n{\n\tprivate static final String CONFIG_GROUP \u003d \"objectindicators\";\n\tprivate static final String MARK \u003d \"Mark object\";\n\tprivate static final String UNMARK \u003d \"Unmark object\";\n\n\tprivate final List\u003cColorTileObject\u003e objects \u003d new ArrayList\u003c\u003e();\n\tprivate final List\u003cColorTileObject\u003e allObjects \u003d new ArrayList\u003c\u003e();\n\tprivate final Map\u003cInteger, Set\u003cObjectPoint\u003e\u003e points \u003d new HashMap\u003c\u003e();\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ObjectIndicatorsConfig config;\n\n\t@Inject\n\tprivate Gson gson;\n\n\t@Inject\n\tprivate RainbowRaveConfig rainbowRaveConfig;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\tprotected void startUp()\n\t{\n\t}\n\n\tprotected void shutDown()\n\t{\n\t\tpoints.clear();\n\t\tobjects.clear();\n\t\tallObjects.clear();\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectSpawned(WallObjectSpawned event)\n\t{\n\t\tcheckObjectPoints(event.getWallObject());\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectDespawned(WallObjectDespawned event)\n\t{\n\t\tobjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getWallObject());\n\t\tallObjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getWallObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectSpawned(GameObjectSpawned event)\n\t{\n\t\tcheckObjectPoints(event.getGameObject());\n\t}\n\n\t@Subscribe\n\tpublic void onDecorativeObjectSpawned(DecorativeObjectSpawned event)\n\t{\n\t\tcheckObjectPoints(event.getDecorativeObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectDespawned(GameObjectDespawned event)\n\t{\n\t\tobjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getGameObject());\n\t\tallObjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getGameObject());\n\t}\n\n\t@Subscribe\n\tpublic void onDecorativeObjectDespawned(DecorativeObjectDespawned event)\n\t{\n\t\tobjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getDecorativeObject());\n\t\tallObjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getDecorativeObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGroundObjectSpawned(GroundObjectSpawned event)\n\t{\n\t\tcheckObjectPoints(event.getGroundObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGroundObjectDespawned(GroundObjectDespawned event)\n\t{\n\t\tobjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getGroundObject());\n\t\tallObjects.removeIf(o -\u003e o.getTileObject() \u003d\u003d event.getGroundObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tGameState gameState \u003d gameStateChanged.getGameState();\n\t\tif (gameState \u003d\u003d GameState.LOADING)\n\t\t{\n\t\t\t// Reload points with new map regions\n\n\t\t\tpoints.clear();\n\t\t\tfor (int regionId : client.getTopLevelWorldView().getMapRegions())\n\t\t\t{\n\t\t\t\t// load points for region\n\t\t\t\tfinal Set\u003cObjectPoint\u003e regionPoints \u003d loadPoints(regionId);\n\t\t\t\tif (regionPoints !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tpoints.put(regionId, regionPoints);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (gameStateChanged.getGameState() !\u003d GameState.LOGGED_IN \u0026\u0026 gameStateChanged.getGameState() !\u003d GameState.CONNECTION_LOST)\n\t\t{\n\t\t\tallObjects.clear();\n\t\t\tobjects.clear();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onMenuOptionClicked(MenuOptionClicked event)\n\t{\n\t\tif (event.getMenuAction() !\u003d MenuAction.RUNELITE\n\t\t\t|| !(event.getMenuOption().equals(MARK) || event.getMenuOption().equals(UNMARK)))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tWorldView wv \u003d client.getTopLevelWorldView();\n\t\tScene scene \u003d wv.getScene();\n\t\tTile[][][] tiles \u003d scene.getTiles();\n\t\tfinal int x \u003d event.getParam0();\n\t\tfinal int y \u003d event.getParam1();\n\t\tfinal int z \u003d wv.getPlane();\n\t\tfinal Tile tile \u003d tiles[z][x][y];\n\n\t\tTileObject object \u003d findTileObject(tile, event.getId());\n\t\tif (object \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// object.getId() is always the base object id, getObjectComposition transforms it to\n\t\t// the correct object we see\n\t\tObjectComposition objectDefinition \u003d getObjectComposition(object.getId());\n\t\tString name \u003d objectDefinition.getName();\n\t\t// Name is probably never \"null\" - however prevent adding it if it is, as it will\n\t\t// become ambiguous as objects with no name are assigned name \"null\"\n\t\tif (Strings.isNullOrEmpty(name) || name.equals(\"null\"))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tmarkObject(objectDefinition, name, object);\n\t}\n\n\tprivate void checkObjectPoints(TileObject object)\n\t{\n\t\tfinal WorldPoint worldPoint \u003d WorldPoint.fromLocalInstance(client, object.getLocalLocation(), object.getPlane());\n\t\tfinal Set\u003cObjectPoint\u003e objectPoints \u003d points.get(worldPoint.getRegionID());\n\n\t\tif (objectPoints \u003d\u003d null \u0026\u0026 rainbowRaveConfig.whichObjectsToHighlight() !\u003d RainbowRaveConfig.ObjectsToHighlight.ALL)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tObjectComposition objectComposition \u003d client.getObjectDefinition(object.getId());\n\t\tif (objectComposition.getImpostorIds() \u003d\u003d null)\n\t\t{\n\t\t\t// Multiloc names are instead checked in the overlay\n\t\t\tString name \u003d objectComposition.getName();\n\t\t\tif (Strings.isNullOrEmpty(name) || name.equals(\"null\"))\n\t\t\t{\n\t\t\t\t// was marked, but name has changed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tboolean found \u003d false;\n\t\tif (objectPoints !\u003d null)\n\t\t{\n\t\t\tfor (ObjectPoint objectPoint : objectPoints)\n\t\t\t{\n\t\t\t\tif (worldPoint.getRegionX() \u003d\u003d objectPoint.getRegionX()\n\t\t\t\t\t\u0026\u0026 worldPoint.getRegionY() \u003d\u003d objectPoint.getRegionY()\n\t\t\t\t\t\u0026\u0026 worldPoint.getPlane() \u003d\u003d objectPoint.getZ()\n\t\t\t\t\t\u0026\u0026 objectPoint.getId() \u003d\u003d object.getId())\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"Marking object {} due to matching {}\", object, objectPoint);\n\t\t\t\t\tobjects.add(new ColorTileObject(object,\n\t\t\t\t\t\tobjectComposition,\n\t\t\t\t\t\tobjectPoint.getName(),\n\t\t\t\t\t\tobjectPoint.getColor()));\n\t\t\t\t\tfound \u003d true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found \u0026\u0026 rainbowRaveConfig.whichObjectsToHighlight() \u003d\u003d RainbowRaveConfig.ObjectsToHighlight.ALL) {\n\t\t\tallObjects.add(new ColorTileObject(object,\n\t\t\t\tobjectComposition,\n\t\t\t\t\"name\",\n\t\t\t\tColor.WHITE));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate TileObject findTileObject(Tile tile, int id)\n\t{\n\t\tif (tile \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal GameObject[] tileGameObjects \u003d tile.getGameObjects();\n\t\tfinal DecorativeObject tileDecorativeObject \u003d tile.getDecorativeObject();\n\t\tfinal WallObject tileWallObject \u003d tile.getWallObject();\n\t\tfinal GroundObject groundObject \u003d tile.getGroundObject();\n\n\t\tif (objectIdEquals(tileWallObject, id))\n\t\t{\n\t\t\treturn tileWallObject;\n\t\t}\n\n\t\tif (objectIdEquals(tileDecorativeObject, id))\n\t\t{\n\t\t\treturn tileDecorativeObject;\n\t\t}\n\n\t\tif (objectIdEquals(groundObject, id))\n\t\t{\n\t\t\treturn groundObject;\n\t\t}\n\n\t\tfor (GameObject object : tileGameObjects)\n\t\t{\n\t\t\tif (objectIdEquals(object, id))\n\t\t\t{\n\t\t\t\treturn object;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate boolean objectIdEquals(TileObject tileObject, int id)\n\t{\n\t\tif (tileObject \u003d\u003d null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (tileObject.getId() \u003d\u003d id)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t// Menu action EXAMINE_OBJECT sends the transformed object id, not the base id, unlike\n\t\t// all of the GAME_OBJECT_OPTION actions, so check the id against the impostor ids\n\t\tfinal ObjectComposition comp \u003d client.getObjectDefinition(tileObject.getId());\n\n\t\tif (comp.getImpostorIds() !\u003d null)\n\t\t{\n\t\t\tfor (int impostorId : comp.getImpostorIds())\n\t\t\t{\n\t\t\t\tif (impostorId \u003d\u003d id)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** mark or unmark an object\n\t *\n\t * @param objectComposition transformed composition of object based on vars\n\t * @param name name of objectComposition\n\t * @param object tile object, for multilocs object.getId() is the base id\n\t */\n\tprivate void markObject(ObjectComposition objectComposition, String name, final TileObject object)\n\t{\n\t\tfinal WorldPoint worldPoint \u003d WorldPoint.fromLocalInstance(client, object.getLocalLocation());\n\t\tfinal int regionId \u003d worldPoint.getRegionID();\n\t\tfinal Color color \u003d config.markerColor();\n\t\tfinal ObjectPoint point \u003d new ObjectPoint(\n\t\t\tobject.getId(),\n\t\t\tname,\n\t\t\tregionId,\n\t\t\tworldPoint.getRegionX(),\n\t\t\tworldPoint.getRegionY(),\n\t\t\tworldPoint.getPlane(),\n\t\t\tcolor);\n\n\t\tSet\u003cObjectPoint\u003e objectPoints \u003d points.computeIfAbsent(regionId, k -\u003e new HashSet\u003c\u003e());\n\n\t\tif (objects.removeIf(o -\u003e o.getTileObject() \u003d\u003d object))\n\t\t{\n\t\t\t// Find the object point that caused this object to be marked, there are two cases:\n\t\t\t// 1) object is a multiloc, the name may have changed since marking - match from base id\n\t\t\t// 2) not a multiloc, but an object has spawned with an identical name and a different\n\t\t\t//    id as what was originally marked\n\t\t\tif (!objectPoints.removeIf(op -\u003e ((op.getId() \u003d\u003d -1 || op.getId() \u003d\u003d object.getId()) || op.getName().equals(objectComposition.getName()))\n\t\t\t\t\u0026\u0026 op.getRegionX() \u003d\u003d worldPoint.getRegionX()\n\t\t\t\t\u0026\u0026 op.getRegionY() \u003d\u003d worldPoint.getRegionY()\n\t\t\t\t\u0026\u0026 op.getZ() \u003d\u003d worldPoint.getPlane()))\n\t\t\t{\n\t\t\t\tlog.warn(\"unable to find object point for unmarked object {}\", object.getId());\n\t\t\t}\n\n\t\t\tlog.debug(\"Unmarking object: {}\", point);\n\n\t\t\tallObjects.add(new ColorTileObject(object,\n\t\t\t\tobjectComposition,\n\t\t\t\t\"name\",\n\t\t\t\tColor.WHITE));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tobjectPoints.add(point);\n\t\t\tColorTileObject o \u003d new ColorTileObject(object,\n\t\t\t\tclient.getObjectDefinition(object.getId()),\n\t\t\t\tname,\n\t\t\t\tcolor);\n\t\t\tobjects.add(o);\n\t\t\tallObjects.removeIf(allO -\u003e allO.getTileObject().equals(o.getTileObject()));\n\t\t\tlog.debug(\"Marking object: {}\", point);\n\t\t}\n\t}\n\n\tprivate Set\u003cObjectPoint\u003e loadPoints(final int id)\n\t{\n\t\tfinal String json \u003d configManager.getConfiguration(CONFIG_GROUP, \"region_\" + id);\n\n\t\tif (Strings.isNullOrEmpty(json))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tSet\u003cObjectPoint\u003e points \u003d gson.fromJson(json, new TypeToken\u003cSet\u003cObjectPoint\u003e\u003e()\n\t\t{\n\t\t}.getType());\n\t\t// Prior to multiloc support the plugin would mark objects named \"null\", which breaks\n\t\t// in most cases due to the specific object being identified being ambiguous, so remove\n\t\t// them\n\t\treturn points.stream()\n\t\t\t.filter(point -\u003e !point.getName().equals(\"null\"))\n\t\t\t.collect(Collectors.toSet());\n\t}\n\n\t@Nullable\n\tprivate ObjectComposition getObjectComposition(int id)\n\t{\n\t\tObjectComposition objectComposition \u003d client.getObjectDefinition(id);\n\t\treturn objectComposition.getImpostorIds() \u003d\u003d null ? objectComposition : objectComposition.getImpostor();\n\t}\n\n\tpublic List\u003cColorTileObject\u003e getObjects() {\n\t\tif (rainbowRaveConfig.whichObjectsToHighlight() \u003d\u003d RainbowRaveConfig.ObjectsToHighlight.NONE) return Collections.emptyList();\n\t\telse if (rainbowRaveConfig.whichObjectsToHighlight() \u003d\u003d RainbowRaveConfig.ObjectsToHighlight.SAME) return objects;\n\n\t\tArrayList\u003cColorTileObject\u003e combinedObjects \u003d new ArrayList\u003c\u003e(allObjects);\n\t\tcombinedObjects.addAll(objects);\n\t\treturn combinedObjects;\n\t}\n}","filePath":"src/main/java/com/rainbowrave/RainbowRaveObjectIndicatorsPlugin.java"},{"fileName":"GroundMarkerPoint.java","content":"/*\n * Copyright (c) 2018, TheLonelyDev \u003chttps://github.com/TheLonelyDev\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport javax.annotation.Nullable;\nimport lombok.EqualsAndHashCode;\nimport lombok.Value;\n\n/**\n * Used for serialization of ground marker points.\n */\n@Value\n@EqualsAndHashCode(exclude \u003d { \"color\", \"label\" })\nclass GroundMarkerPoint\n{\n\tprivate int regionId;\n\tprivate int regionX;\n\tprivate int regionY;\n\tprivate int z;\n\t@Nullable\n\tprivate Color color;\n\t@Nullable\n\tprivate String label;\n}\n","filePath":"src/main/java/com/rainbowrave/GroundMarkerPoint.java"},{"fileName":"WildcardMatchLoader.java","content":"/*\n * Copyright (c) 2018, Tomas Slusny \u003cslusnucky@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.base.Strings;\nimport com.google.common.cache.CacheLoader;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nonnull;\nimport net.runelite.client.util.WildcardMatcher;\n\nclass WildcardMatchLoader extends CacheLoader\u003cNamedQuantity, Boolean\u003e\n{\n\tprivate final List\u003cItemThreshold\u003e itemThresholds;\n\n\tWildcardMatchLoader(List\u003cString\u003e configEntries)\n\t{\n\t\tthis.itemThresholds \u003d configEntries.stream()\n\t\t\t.map(ItemThreshold::fromConfigEntry)\n\t\t\t.filter(Objects::nonNull)\n\t\t\t.collect(Collectors.toList());\n\t}\n\n\t@Override\n\tpublic Boolean load(@Nonnull final NamedQuantity key)\n\t{\n\t\tif (Strings.isNullOrEmpty(key.getName()))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal String filteredName \u003d key.getName().trim();\n\n\t\tfor (final ItemThreshold entry : itemThresholds)\n\t\t{\n\t\t\tif (WildcardMatcher.matches(entry.getItemName(), filteredName)\n\t\t\t\t\u0026\u0026 entry.quantityHolds(key.getQuantity()))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/WildcardMatchLoader.java"},{"fileName":"ColorTileObject.java","content":"/*\n * Copyright (c) 2020, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.awt.Color;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Value;\nimport net.runelite.api.ObjectComposition;\nimport net.runelite.api.TileObject;\n\n/**\n * Used to denote marked objects and their colors.\n * Note: This is not used for serialization of object indicators; see {@link ObjectPoint}\n */\n@Value\n@RequiredArgsConstructor\nclass ColorTileObject\n{\n\tprivate final TileObject tileObject;\n\t/**\n\t * Non-transformed object composition for the object\n\t */\n\tprivate final ObjectComposition composition;\n\t/**\n\t * Name to highlight for multilocs\n\t */\n\tprivate final String name;\n\tprivate final Color color;\n}\n","filePath":"src/main/java/com/rainbowrave/ColorTileObject.java"},{"fileName":"MemorizedNpc.java","content":"/*\n * Copyright (c) 2018, Woox \u003chttps://github.com/wooxsolo\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.Setter;\nimport net.runelite.api.NPC;\nimport net.runelite.api.NPCComposition;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.WorldPoint;\n\nclass MemorizedNpc\n{\n\t@Getter\n\tprivate int npcIndex;\n\n\t@Getter\n\tprivate WorldView worldView;\n\n\t@Getter\n\tprivate String npcName;\n\n\t@Getter\n\tprivate int npcSize;\n\n\t/**\n\t * The time the npc died at, in game ticks, relative to the tick counter\n\t */\n\t@Getter\n\t@Setter\n\tprivate int diedOnTick;\n\n\t/**\n\t * The time it takes for the npc to respawn, in game ticks\n\t */\n\t@Getter\n\t@Setter\n\tprivate int respawnTime;\n\n\t@Getter\n\t@Setter\n\tprivate List\u003cWorldPoint\u003e possibleRespawnLocations;\n\n\tMemorizedNpc(NPC npc)\n\t{\n\t\tthis.npcName \u003d npc.getName();\n\t\tthis.npcIndex \u003d npc.getIndex();\n\t\tthis.worldView \u003d npc.getWorldView();\n\t\tthis.possibleRespawnLocations \u003d new ArrayList\u003c\u003e();\n\t\tthis.respawnTime \u003d -1;\n\t\tthis.diedOnTick \u003d -1;\n\n\t\tfinal NPCComposition composition \u003d npc.getTransformedComposition();\n\n\t\tif (composition !\u003d null)\n\t\t{\n\t\t\tthis.npcSize \u003d composition.getSize();\n\t\t}\n\t}\n}","filePath":"src/main/java/com/rainbowrave/MemorizedNpc.java"},{"fileName":"RainbowRaveNpcIndicatorsPlugin.java","content":"/*\n * Copyright (c) 2018, James Swindle \u003cwilingua@gmail.com\u003e\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.rainbowrave;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.MoreObjects;\nimport java.awt.Color;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport javax.inject.Inject;\nimport lombok.AccessLevel;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.Value;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.GraphicID;\nimport net.runelite.api.GraphicsObject;\nimport net.runelite.api.MenuAction;\nimport net.runelite.api.NPC;\nimport net.runelite.api.NPCComposition;\nimport net.runelite.api.WorldView;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.GraphicsObjectCreated;\nimport net.runelite.api.events.MenuOptionClicked;\nimport net.runelite.api.events.NpcChanged;\nimport net.runelite.api.events.NpcDespawned;\nimport net.runelite.api.events.NpcSpawned;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.NpcUtil;\nimport net.runelite.client.plugins.npchighlight.NpcIndicatorsConfig;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.util.Text;\nimport net.runelite.client.util.WildcardMatcher;\n\n@Slf4j\npublic class RainbowRaveNpcIndicatorsPlugin\n{\n\tprivate static final int MAX_ACTOR_VIEW_RANGE \u003d 15;\n\n\t// Option added to NPC menu\n\tprivate static final String TAG \u003d \"Tag\";\n\tprivate static final String UNTAG \u003d \"Un-tag\";\n\n\tprivate static final String TAG_ALL \u003d \"Tag-All\";\n\tprivate static final String UNTAG_ALL \u003d \"Un-tag-All\";\n\n\tprivate static final String STYLE_HULL \u003d \"hull\";\n\tprivate static final String STYLE_TILE \u003d \"tile\";\n\tprivate static final String STYLE_TRUE_TILE \u003d \"truetile\";\n\tprivate static final String STYLE_SW_TILE \u003d \"swtile\";\n\tprivate static final String STYLE_SW_TRUE_TILE \u003d \"swtruetile\";\n\tprivate static final String STYLE_OUTLINE \u003d \"outline\";\n\n\t@Inject private Client client;\n\t@Inject private NpcIndicatorsConfig config;\n\t@Inject private OverlayManager overlayManager;\n\t@Inject private ClientThread clientThread;\n\t@Inject private NpcUtil npcUtil;\n\t@Inject private ConfigManager configManager;\n\n\t/**\n\t * NPCs to highlight\n\t */\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final Map\u003cNPC, HighlightedNpc\u003e highlightedNpcs \u003d new HashMap\u003c\u003e();\n\n\t/**\n\t * Dead NPCs that should be displayed with a respawn indicator if the config is on.\n\t */\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final Map\u003cInteger, MemorizedNpc\u003e deadNpcsToDisplay \u003d new HashMap\u003c\u003e();\n\n\t/**\n\t * The time when the last game tick event ran.\n\t */\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate Instant lastTickUpdate;\n\n\t/**\n\t * Tagged NPCs that have died at some point, which are memorized to\n\t * remember when and where they will respawn\n\t */\n\tprivate final Map\u003cInteger, MemorizedNpc\u003e memorizedNpcs \u003d new HashMap\u003c\u003e();\n\n\t/**\n\t * Highlight strings from the configuration\n\t */\n\tprivate List\u003cString\u003e highlights \u003d new ArrayList\u003c\u003e();\n\n\t/**\n\t * NPC ids marked with the Tag option\n\t */\n\tprivate final Set\u003cInteger\u003e npcTags \u003d new HashSet\u003c\u003e();\n\n\t/**\n\t * Tagged NPCs that spawned this tick, which need to be verified that\n\t * they actually spawned and didn\u0027t just walk into view range.\n\t */\n\tprivate final List\u003cNPC\u003e spawnedNpcsThisTick \u003d new ArrayList\u003c\u003e();\n\n\t/**\n\t * Tagged NPCs that despawned this tick, which need to be verified that\n\t * they actually spawned and didn\u0027t just walk into view range.\n\t */\n\tprivate final List\u003cNPC\u003e despawnedNpcsThisTick \u003d new ArrayList\u003c\u003e();\n\n\t/**\n\t * World locations of graphics object which indicate that an\n\t * NPC teleported that were played this tick.\n\t */\n\tprivate final Set\u003cWorldPoint\u003e teleportGraphicsObjectSpawnedThisTick \u003d new HashSet\u003c\u003e();\n\n\t/**\n\t * The players location on the last game tick.\n\t */\n\tprivate WorldPoint lastPlayerLocation;\n\n\t/**\n\t * When hopping worlds, NPCs can spawn without them actually respawning,\n\t * so we would not want to mark it as a real spawn in those cases.\n\t */\n\tprivate boolean skipNextSpawnCheck \u003d false;\n\n\tprivate final List\u003cFunction\u003cNPC, HighlightedNpc\u003e\u003e higlightPredicates \u003d new ArrayList\u003c\u003e();\n\n\tprotected void startUp()\n\t{\n\t\tclientThread.invoke(() -\u003e\n\t\t{\n\t\t\tskipNextSpawnCheck \u003d true;\n\t\t\trebuild();\n\t\t});\n\t}\n\n\tprotected void shutDown()\n\t{\n\t\tclientThread.invoke(() -\u003e\n\t\t{\n\t\t\tdeadNpcsToDisplay.clear();\n\t\t\tmemorizedNpcs.clear();\n\t\t\tspawnedNpcsThisTick.clear();\n\t\t\tdespawnedNpcsThisTick.clear();\n\t\t\tteleportGraphicsObjectSpawnedThisTick.clear();\n\t\t\tnpcTags.clear();\n\t\t\thighlightedNpcs.clear();\n\t\t});\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged event)\n\t{\n\t\tif (event.getGameState() \u003d\u003d GameState.LOGIN_SCREEN ||\n\t\t\tevent.getGameState() \u003d\u003d GameState.HOPPING)\n\t\t{\n\t\t\thighlightedNpcs.clear();\n\t\t\tdeadNpcsToDisplay.clear();\n\t\t\tmemorizedNpcs.forEach((id, npc) -\u003e npc.setDiedOnTick(-1));\n\t\t\tlastPlayerLocation \u003d null;\n\t\t\tskipNextSpawnCheck \u003d true;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\t\tif (!configChanged.getGroup().equals(NpcIndicatorsConfig.GROUP))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tclientThread.invoke(this::rebuild);\n\t}\n\n\t@Subscribe\n\tpublic void onMenuOptionClicked(MenuOptionClicked click)\n\t{\n\t\tif (click.getMenuAction() !\u003d MenuAction.RUNELITE ||\n\t\t\t!(click.getMenuOption().equals(TAG) || click.getMenuOption().equals(UNTAG) ||\n\t\t\t\tclick.getMenuOption().equals(TAG_ALL) || click.getMenuOption().equals(UNTAG_ALL)))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\n\t\tfinal int id \u003d click.getId();\n\t\tfinal NPC npc \u003d worldView.npcs().byIndex(id);\n\n\t\tif (npc \u003d\u003d null || npc.getName() \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (click.getMenuOption().equals(TAG) || click.getMenuOption().equals(UNTAG))\n\t\t{\n\t\t\tfinal boolean removed \u003d npcTags.remove(id);\n\n\t\t\tif (removed)\n\t\t\t{\n\t\t\t\tif (!highlightMatchesNPCName(npc.getName()))\n\t\t\t\t{\n\t\t\t\t\thighlightedNpcs.remove(npc);\n\t\t\t\t\tmemorizedNpcs.remove(npc.getIndex());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!worldView.isInstance())\n\t\t\t\t{\n\t\t\t\t\tmemorizeNpc(npc);\n\t\t\t\t\tnpcTags.add(id);\n\t\t\t\t}\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onNpcSpawned(NpcSpawned npcSpawned)\n\t{\n\t\tfinal NPC npc \u003d npcSpawned.getNpc();\n\t\tfinal String npcName \u003d npc.getName();\n\n\t\tif (npcName \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (npcTags.contains(npc.getIndex()))\n\t\t{\n\t\t\tmemorizeNpc(npc);\n\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\tspawnedNpcsThisTick.add(npc);\n\t\t\treturn;\n\t\t}\n\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\n\t\tif (highlightMatchesNPCName(npcName))\n\t\t{\n\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\tif (!worldView.isInstance())\n\t\t\t{\n\t\t\t\tmemorizeNpc(npc);\n\t\t\t\tspawnedNpcsThisTick.add(npc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Function\u003cNPC, HighlightedNpc\u003e predicate : higlightPredicates)\n\t\t{\n\t\t\tHighlightedNpc highlightedNpc \u003d predicate.apply(npc);\n\t\t\tif (highlightedNpc !\u003d null)\n\t\t\t{\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc);\n\t\t\t\tif (!worldView.isInstance())\n\t\t\t\t{\n\t\t\t\t\tmemorizeNpc(npc);\n\t\t\t\t\tspawnedNpcsThisTick.add(npc);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t@Subscribe\n\tpublic void onNpcDespawned(NpcDespawned npcDespawned)\n\t{\n\t\tfinal NPC npc \u003d npcDespawned.getNpc();\n\n\t\tif (memorizedNpcs.containsKey(npc.getIndex()))\n\t\t{\n\t\t\tdespawnedNpcsThisTick.add(npc);\n\t\t}\n\n\t\thighlightedNpcs.remove(npc);\n\t}\n\n\t@Subscribe\n\tpublic void onNpcChanged(NpcChanged event)\n\t{\n\t\tfinal NPC npc \u003d event.getNpc();\n\t\tfinal String npcName \u003d npc.getName();\n\n\t\thighlightedNpcs.remove(npc);\n\n\t\tif (npcName \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (npcTags.contains(npc.getIndex())\n\t\t\t|| highlightMatchesNPCName(npcName))\n\t\t{\n\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Function\u003cNPC, HighlightedNpc\u003e predicate : higlightPredicates)\n\t\t{\n\t\t\tHighlightedNpc highlightedNpc \u003d predicate.apply(npc);\n\t\t\tif (highlightedNpc !\u003d null)\n\t\t\t{\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGraphicsObjectCreated(GraphicsObjectCreated event)\n\t{\n\t\tfinal GraphicsObject go \u003d event.getGraphicsObject();\n\n\t\tif (go.getId() \u003d\u003d GraphicID.GREY_BUBBLE_TELEPORT)\n\t\t{\n\t\t\tteleportGraphicsObjectSpawnedThisTick.add(WorldPoint.fromLocal(client, go.getLocation()));\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick event)\n\t{\n\t\tremoveOldHighlightedRespawns();\n\t\tvalidateSpawnedNpcs();\n\t\tlastTickUpdate \u003d Instant.now();\n\t\tlastPlayerLocation \u003d client.getLocalPlayer().getWorldLocation();\n\t}\n\n\tprivate static boolean isInViewRange(WorldPoint wp1, WorldPoint wp2)\n\t{\n\t\tint distance \u003d wp1.distanceTo(wp2);\n\t\treturn distance \u003c MAX_ACTOR_VIEW_RANGE;\n\t}\n\n\tprivate static WorldPoint getWorldLocationBehind(NPC npc)\n\t{\n\t\tfinal int orientation \u003d npc.getOrientation() / 256;\n\t\tint dx \u003d 0, dy \u003d 0;\n\n\t\tswitch (orientation)\n\t\t{\n\t\t\tcase 0: // South\n\t\t\t\tdy \u003d -1;\n\t\t\t\tbreak;\n\t\t\tcase 1: // Southwest\n\t\t\t\tdx \u003d -1;\n\t\t\t\tdy \u003d -1;\n\t\t\t\tbreak;\n\t\t\tcase 2: // West\n\t\t\t\tdx \u003d -1;\n\t\t\t\tbreak;\n\t\t\tcase 3: // Northwest\n\t\t\t\tdx \u003d -1;\n\t\t\t\tdy \u003d 1;\n\t\t\t\tbreak;\n\t\t\tcase 4: // North\n\t\t\t\tdy \u003d 1;\n\t\t\t\tbreak;\n\t\t\tcase 5: // Northeast\n\t\t\t\tdx \u003d 1;\n\t\t\t\tdy \u003d 1;\n\t\t\t\tbreak;\n\t\t\tcase 6: // East\n\t\t\t\tdx \u003d 1;\n\t\t\t\tbreak;\n\t\t\tcase 7: // Southeast\n\t\t\t\tdx \u003d 1;\n\t\t\t\tdy \u003d -1;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfinal WorldPoint currWP \u003d npc.getWorldLocation();\n\t\treturn new WorldPoint(currWP.getX() - dx, currWP.getY() - dy, currWP.getPlane());\n\t}\n\n\tprivate void memorizeNpc(NPC npc)\n\t{\n\t\tfinal int npcIndex \u003d npc.getIndex();\n\t\tmemorizedNpcs.putIfAbsent(npcIndex, new MemorizedNpc(npc));\n\t}\n\n\tprivate void removeOldHighlightedRespawns()\n\t{\n\t\tdeadNpcsToDisplay.values().removeIf(x -\u003e x.getDiedOnTick() + x.getRespawnTime() \u003c\u003d client.getTickCount() + 1);\n\t}\n\n\t@VisibleForTesting\n\tList\u003cString\u003e getHighlights()\n\t{\n\t\tfinal String configNpcs \u003d config.getNpcToHighlight();\n\n\t\tif (configNpcs.isEmpty())\n\t\t{\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\treturn Text.fromCSV(configNpcs);\n\t}\n\n\tpublic void rebuild()\n\t{\n\t\thighlights \u003d getHighlights();\n\t\thighlightedNpcs.clear();\n\n\t\tif (client.getGameState() !\u003d GameState.LOGGED_IN \u0026\u0026\n\t\t\tclient.getGameState() !\u003d GameState.LOADING)\n\t\t{\n\t\t\t// NPCs are still in the client after logging out,\n\t\t\t// but we don\u0027t want to highlight those.\n\t\t\treturn;\n\t\t}\n\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\n\t\touter:\n\t\tfor (NPC npc : worldView.npcs())\n\t\t{\n\t\t\tfinal String npcName \u003d npc.getName();\n\n\t\t\tif (npcName \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (npcTags.contains(npc.getIndex()))\n\t\t\t{\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (highlightMatchesNPCName(npcName))\n\t\t\t{\n\t\t\t\tif (!worldView.isInstance())\n\t\t\t\t{\n\t\t\t\t\tmemorizeNpc(npc);\n\t\t\t\t}\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (Function\u003cNPC, HighlightedNpc\u003e predicate : higlightPredicates)\n\t\t\t{\n\t\t\t\tHighlightedNpc highlightedNpc \u003d predicate.apply(npc);\n\t\t\t\tif (highlightedNpc !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tif (!worldView.isInstance())\n\t\t\t\t\t{\n\t\t\t\t\t\tmemorizeNpc(npc);\n\t\t\t\t\t}\n\t\t\t\t\thighlightedNpcs.put(npc, highlightedNpc);\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// NPC is not highlighted\n\t\t\tmemorizedNpcs.remove(npc.getIndex());\n\t\t}\n\t}\n\n\tprivate boolean highlightMatchesNPCName(String npcName)\n\t{\n\t\tfor (String highlight : highlights)\n\t\t{\n\t\t\tif (WildcardMatcher.matches(highlight, npcName))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate void validateSpawnedNpcs()\n\t{\n\t\tif (skipNextSpawnCheck)\n\t\t{\n\t\t\tskipNextSpawnCheck \u003d false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (NPC npc : despawnedNpcsThisTick)\n\t\t\t{\n\t\t\t\tif (!teleportGraphicsObjectSpawnedThisTick.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tif (teleportGraphicsObjectSpawnedThisTick.contains(npc.getWorldLocation()))\n\t\t\t\t\t{\n\t\t\t\t\t\t// NPC teleported away, so we don\u0027t want to add the respawn timer\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (isInViewRange(client.getLocalPlayer().getWorldLocation(), npc.getWorldLocation()))\n\t\t\t\t{\n\t\t\t\t\tfinal MemorizedNpc mn \u003d memorizedNpcs.get(npc.getIndex());\n\n\t\t\t\t\tif (mn !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmn.setDiedOnTick(client.getTickCount() + 1); // This runs before tickCounter updates, so we add 1\n\n\t\t\t\t\t\tif (!mn.getPossibleRespawnLocations().isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.debug(\"Starting {} tick countdown for {}\", mn.getRespawnTime(), mn.getNpcName());\n\t\t\t\t\t\t\tdeadNpcsToDisplay.put(mn.getNpcIndex(), mn);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (NPC npc : spawnedNpcsThisTick)\n\t\t\t{\n\t\t\t\tif (!teleportGraphicsObjectSpawnedThisTick.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tif (teleportGraphicsObjectSpawnedThisTick.contains(npc.getWorldLocation()) ||\n\t\t\t\t\t\tteleportGraphicsObjectSpawnedThisTick.contains(getWorldLocationBehind(npc)))\n\t\t\t\t\t{\n\t\t\t\t\t\t// NPC teleported here, so we don\u0027t want to update the respawn timer\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (lastPlayerLocation !\u003d null \u0026\u0026 isInViewRange(lastPlayerLocation, npc.getWorldLocation()))\n\t\t\t\t{\n\t\t\t\t\tfinal MemorizedNpc mn \u003d memorizedNpcs.get(npc.getIndex());\n\n\t\t\t\t\tif (mn.getDiedOnTick() !\u003d -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal int respawnTime \u003d client.getTickCount() + 1 - mn.getDiedOnTick();\n\n\t\t\t\t\t\t// By killing a monster and leaving the area before seeing it again, an erroneously lengthy\n\t\t\t\t\t\t// respawn time can be recorded. Thus, if the respawn time is already set and is greater than\n\t\t\t\t\t\t// the observed time, assume that the lower observed respawn time is correct.\n\t\t\t\t\t\tif (mn.getRespawnTime() \u003d\u003d -1 || respawnTime \u003c mn.getRespawnTime())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmn.setRespawnTime(respawnTime);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmn.setDiedOnTick(-1);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal WorldPoint npcLocation \u003d npc.getWorldLocation();\n\n\t\t\t\t\t// An NPC can move in the same tick as it spawns, so we also have\n\t\t\t\t\t// to consider whatever tile is behind the npc\n\t\t\t\t\tfinal WorldPoint possibleOtherNpcLocation \u003d getWorldLocationBehind(npc);\n\n\t\t\t\t\tmn.getPossibleRespawnLocations().removeIf(x -\u003e\n\t\t\t\t\t\t!x.equals(npcLocation) \u0026\u0026 !x.equals(possibleOtherNpcLocation));\n\n\t\t\t\t\tif (mn.getPossibleRespawnLocations().isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tmn.getPossibleRespawnLocations().add(npcLocation);\n\t\t\t\t\t\tmn.getPossibleRespawnLocations().add(possibleOtherNpcLocation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tspawnedNpcsThisTick.clear();\n\t\tdespawnedNpcsThisTick.clear();\n\t\tteleportGraphicsObjectSpawnedThisTick.clear();\n\t}\n\n\t@Value\n\t@Builder\n\tpublic static class HighlightedNpc\n\t{\n\t\tNPC npc;\n\t\t@NonNull\n\t\tColor highlightColor;\n\t\t@Builder.Default\n\t\tColor fillColor \u003d new Color(0, 0, 0, 50);\n\t\tboolean hull;\n\t\tboolean tile;\n\t\tboolean trueTile;\n\t\tboolean swTile;\n\t\tboolean swTrueTile;\n\t\tboolean outline;\n\t\tboolean name;\n\t\tboolean nameOnMinimap;\n\t\t@Builder.Default\n\t\tfloat borderWidth \u003d 2.0f;\n\t\tint outlineFeather;\n\t\tPredicate\u003cNPC\u003e render;\n\t}\n\n\tpublic HighlightedNpc highlightedPlayer()\n\t{\n\t\treturn HighlightedNpc.builder()\n\t\t\t.highlightColor(config.highlightColor())\n\t\t\t.fillColor(config.fillColor())\n\t\t\t.hull(config.highlightHull())\n\t\t\t.tile(config.highlightTile())\n\t\t\t.trueTile(config.highlightTrueTile())\n\t\t\t.swTile(config.highlightSouthWestTile())\n\t\t\t.swTrueTile(config.highlightSouthWestTrueTile())\n\t\t\t.outline(config.highlightOutline())\n\t\t\t.name(config.drawNames())\n\t\t\t.nameOnMinimap(config.drawMinimapNames())\n\t\t\t.borderWidth((float) config.borderWidth())\n\t\t\t.outlineFeather(config.outlineFeather())\n\t\t\t.render(this::render)\n\t\t\t.build();\n\t}\n\n\tpublic HighlightedNpc highlightedNpc(NPC npc)\n\t{\n\t\tfinal int npcId \u003d npc.getId();\n\n\t\tfinal String style \u003d getNpcTagStyle(npcId);\n\t\tfinal boolean hull, tile, trueTile, swTile, swTrueTile, outline;\n\t\t// if set, value from config overrides global config\n\t\tif (style !\u003d null)\n\t\t{\n\t\t\thull \u003d STYLE_HULL.equals(style);\n\t\t\ttile \u003d STYLE_TILE.equals(style);\n\t\t\ttrueTile \u003d STYLE_TRUE_TILE.equals(style);\n\t\t\tswTile \u003d STYLE_SW_TILE.equals(style);\n\t\t\tswTrueTile \u003d STYLE_SW_TRUE_TILE.equals(style);\n\t\t\toutline \u003d STYLE_OUTLINE.equals(style);\n\t\t}\n\t\telse\n\t\t{\n\t\t\thull \u003d config.highlightHull();\n\t\t\ttile \u003d config.highlightTile();\n\t\t\ttrueTile \u003d config.highlightTrueTile();\n\t\t\tswTile \u003d config.highlightSouthWestTile();\n\t\t\tswTrueTile \u003d config.highlightSouthWestTrueTile();\n\t\t\toutline \u003d config.highlightOutline();\n\t\t}\n\n\t\treturn HighlightedNpc.builder()\n\t\t\t.npc(npc)\n\t\t\t.highlightColor(MoreObjects.firstNonNull(getNpcHighlightColor(npcId), config.highlightColor()))\n\t\t\t.fillColor(config.fillColor())\n\t\t\t.hull(hull)\n\t\t\t.tile(tile)\n\t\t\t.trueTile(trueTile)\n\t\t\t.swTile(swTile)\n\t\t\t.swTrueTile(swTrueTile)\n\t\t\t.outline(outline)\n\t\t\t.name(config.drawNames())\n\t\t\t.nameOnMinimap(config.drawMinimapNames())\n\t\t\t.borderWidth((float) config.borderWidth())\n\t\t\t.outlineFeather(config.outlineFeather())\n\t\t\t.render(this::render)\n\t\t\t.build();\n\t}\n\n\tprivate boolean render(NPC n)\n\t{\n\t\tif (npcUtil.isDying(n) \u0026\u0026 config.ignoreDeadNpcs())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal NPCComposition c \u003d n.getTransformedComposition();\n\t\tif (c !\u003d null \u0026\u0026 c.isFollower() \u0026\u0026 config.ignorePets())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate Color getNpcHighlightColor(int npcId)\n\t{\n\t\treturn configManager.getConfiguration(NpcIndicatorsConfig.GROUP, \"highlightcolor_\" + npcId, Color.class);\n\t}\n\n\tprivate String getNpcTagStyle(int npcId)\n\t{\n\t\treturn configManager.getConfiguration(NpcIndicatorsConfig.GROUP, \"tagstyle_\" + npcId);\n\t}\n\n\tpublic void registerHighlighter(Function\u003cNPC, HighlightedNpc\u003e p)\n\t{\n\t\thiglightPredicates.add(p);\n\t}\n\n\tpublic void unregisterHighlighter(Function\u003cNPC, HighlightedNpc\u003e p)\n\t{\n\t\thiglightPredicates.remove(p);\n\t}\n}\n","filePath":"src/main/java/com/rainbowrave/RainbowRaveNpcIndicatorsPlugin.java"},{"fileName":"ConfigGenerator.java","content":"package com.rainbowrave;\n\n//import lombok.Builder;\n\npublic class ConfigGenerator\n{\n//\tprivate static final boolean autoPosition \u003d true;\n//\n//\tprivate static int i \u003d 0;\n//\n//\tpublic static void main(String[] args)\n//\t{\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"colorSpeed\")\n//\t\t\t\t.name(\"Color speed (ms)\")\n//\t\t\t\t.description(\"How fast the colors change (ms per full cycle)\")\n//\t\t\t\t.defaultValue(6000)\n//\t\t\t\t.typeName(\"int\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\tSingleConfigGenerator.builder()\n//\t\t\t.key(\"syncColor\")\n//\t\t\t.name(\"Sync colors\")\n//\t\t\t.description(\"Make all highlighted things be the same color as each other.\")\n//\t\t\t.defaultValue(false)\n//\t\t\t.typeName(\"boolean\")\n//\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\tSingleConfigGenerator.builder()\n//\t\t\t.key(\"highlightSelf\")\n//\t\t\t.name(\"Highlight self\")\n//\t\t\t.description(\"Highlight your own player character. Uses Npc Indicator\u0027s settings.\")\n//\t\t\t.defaultValue(false)\n//\t\t\t.typeName(\"boolean\")\n//\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\tSingleConfigGenerator.builder()\n//\t\t\t.key(\"highlightOthers\")\n//\t\t\t.name(\"Highlight others\")\n//\t\t\t.description(\"Highlight other players\u0027 characters. Uses Npc Indicator\u0027s settings.\")\n//\t\t\t.defaultValue(false)\n//\t\t\t.typeName(\"boolean\")\n//\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\tSingleConfigGenerator.builder()\n//\t\t\t.key(\"whichNpcsToHighlight\")\n//\t\t\t.name(\"Npc highlight\")\n//\t\t\t.description(\"Which npcs to highlight\")\n//\t\t\t.defaultValue(RainbowRaveConfig.NpcsToHighlight.SAME)\n//\t\t\t.typeName(\"NpcsToHighlight\")\n//\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"smoothWaves\")\n//\t\t\t\t.name(\"Tile color waves\")\n//\t\t\t\t.description(\"Whether the tiles should have a smooth transition from color to color between two adjacent tiles.\")\n//\t\t\t\t.defaultValue(false)\n//\t\t\t\t.typeName(\"boolean\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"fillTiles\")\n//\t\t\t\t.name(\"Fill tiles\")\n//\t\t\t\t.description(\"Fills the tile with an opaque square.\")\n//\t\t\t\t.defaultValue(false)\n//\t\t\t\t.typeName(\"boolean\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"useBrushMarkerTiles\")\n//\t\t\t\t.name(\"Brush Marker Tiles\")\n//\t\t\t\t.description(\"Applies rainbow to tile markers from the \\\\\\\"Brush Markers\\\\\\\" plugin hub plugin. This plugin can be used to mark lots of tiles at once.\")\n//\t\t\t\t.defaultValue(false)\n//\t\t\t\t.typeName(\"boolean\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"whichObjectsToHighlight\")\n//\t\t\t\t.name(\"Object highlight\")\n//\t\t\t\t.description(\"Which objects to highlight.\")\n//\t\t\t\t.defaultValue(RainbowRaveConfig.ObjectsToHighlight.SAME)\n//\t\t\t\t.typeName(\"ObjectsToHighlight\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"whichItemsToInventoryTag\")\n//\t\t\t\t.name(\"Inventory tags\")\n//\t\t\t\t.description(\"Which items to tag.\")\n//\t\t\t\t.defaultValue(RainbowRaveConfig.ItemsToTag.SAME)\n//\t\t\t\t.typeName(\"ItemsToTag\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"colorHighlightedGroundItems\")\n//\t\t\t\t.name(\"Highlight Ground Items\")\n//\t\t\t\t.description(\"Applies rainbow to highlighted items.\")\n//\t\t\t\t.defaultValue(true)\n//\t\t\t\t.typeName(\"boolean\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"whichGroundItemsToColor\")\n//\t\t\t\t.name(\"Ground Items\")\n//\t\t\t\t.description(\"Items in this tier and above are colored.\")\n//\t\t\t\t.defaultValue(RainbowRaveConfig.GroundItemsToColor.REGULAR)\n//\t\t\t\t.typeName(\"GroundItemsToColor\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t\tSystem.out.println(\n//\t\t\tSingleConfigGenerator.builder()\n//\t\t\t\t.key(\"recolorScytheSwings\")\n//\t\t\t\t.name(\"Scythe swings\")\n//\t\t\t\t.description(\"Recolor scythe swings. Swing trails may not return to normal after disabling.\")\n//\t\t\t\t.defaultValue(false)\n//\t\t\t\t.typeName(\"boolean\")\n//\t\t\t\t.build().generate()\n//\t\t);\n//\n//\t}\n//\n//\t@Builder\n//\tpublic static final class SingleConfigGenerator\u003cT\u003e {\n//\t\tprivate final String key;\n//\t\tprivate final String name;\n//\t\tprivate String description;\n//\t\tprivate String section;\n//\t\tprivate T defaultValue;\n//\t\tprivate String typeName;\n//\n//\t\tpublic String generate() {\n//\t\t\tString n \u003d \"\\n\";\n//\t\t\treturn String.format(\n//\t\t\t\t\t\"\\t@ConfigItem(\" + n +\n//\t\t\t\t\t\"\\t\\tkeyName \u003d \\\"%s\\\",\" + n +\n//\t\t\t\t\t\"\\t\\tname \u003d \\\"%s\\\",\" + n +\n//\t\t\t\t\t\"\\t\\tdescription \u003d \\\"%s\\\",\" + n +\n//\t\t\t\t\t(section \u003d\u003d null ? \"%s\" : \"\\t\\tsection \u003d %s,\" + n) +\n//\t\t\t\t\t\"\\t\\tposition \u003d \" + i++ + \"\" + n +\n//\t\t\t\t\t\"\\t)\" + n +\n//\t\t\t\t\t\"\\tdefault \" + ((typeName \u003d\u003d null) ? defaultValue.getClass().getSimpleName() : typeName) + \" %s()\" + n +\n//\t\t\t\t\t\"\\t{\" + n +\n//\t\t\t\t\t\"\\t\\treturn %s;\" + n +\n//\t\t\t\t\t\"\\t}\" + n,\n//\t\t\t\tkey, name, description, (section \u003d\u003d null) ? \"\" : section, key, defaultValue\n//\t\t\t);\n//\t\t}\n//\t}\n}\n","filePath":"src/test/java/com/rainbowrave/ConfigGenerator.java"},{"fileName":"ExamplePluginTest.java","content":"package com.rainbowrave;\n\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Field;\nimport java.util.Properties;\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.RuneLiteProperties;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ExamplePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tsetWindowTitle(\"rainbow-rave (\" + getCurrentGitBranch() + \") RL-\" + RuneLiteProperties.getVersion());\n\n\t\tExternalPluginManager.loadBuiltin(RainbowRavePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n\n\tprivate static void setWindowTitle(String title) throws NoSuchFieldException, IllegalAccessException\n\t{\n\t\tField propertiesField \u003d RuneLiteProperties.class.getDeclaredField(\"properties\");\n\t\tpropertiesField.setAccessible(true);\n\t\tProperties properties \u003d (Properties) propertiesField.get(null);\n\t\tproperties.setProperty(\"runelite.title\", title);\n\t}\n\n\tpublic static String getCurrentGitBranch() {\n\t\ttry\n\t\t{\n\t\t\tProcess process \u003d Runtime.getRuntime().exec(\"git rev-parse --abbrev-ref HEAD\");\n\t\t\tprocess.waitFor();\n\n\t\t\tBufferedReader reader \u003d new BufferedReader(\n\t\t\t\tnew InputStreamReader(process.getInputStream()));\n\n\t\t\treturn reader.readLine();\n\t\t}catch (Exception e) {\n\t\t\treturn \"threw exception\";\n\t\t}\n\t}\n}","filePath":"src/test/java/com/rainbowrave/ExamplePluginTest.java"}]},{"commit":"86916a10ae623c1356356b0c69144b12c880f935","repository":"https://github.com/TicTac7x/runelite-plugins.git","internalName":"tictac7x-motherlode","files":[{"fileName":"Bank.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.Item;\nimport net.runelite.api.ItemID;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.client.config.ConfigManager;\n\npublic class Bank {\n    private final ConfigManager configManager;\n    private final TicTac7xMotherlodeConfig config;\n\n    public Bank(final ConfigManager configManager, final TicTac7xMotherlodeConfig config) {\n        this.configManager \u003d configManager;\n        this.config \u003d config;\n    }\n\n    public int getGoldenNuggets() {\n        return config.getBankGoldenNuggets();\n    }\n\n    public void onItemContainerChanged(final ItemContainerChanged event) {\n        if (event.getContainerId() !\u003d InventoryID.BANK.getId()) return;\n\n        for (final Item item : event.getItemContainer().getItems()) {\n            if (item.getId() \u003d\u003d ItemID.GOLDEN_NUGGET) {\n                setGoldenNuggets(item.getQuantity());\n                return;\n            }\n        }\n    }\n\n    public void depositGoldenNuggets(final int quantity) {\n        setGoldenNuggets(config.getBankGoldenNuggets() + quantity);\n    }\n\n    private void setGoldenNuggets(final int quantity) {\n        configManager.setConfiguration(TicTac7xMotherlodeConfig.group, TicTac7xMotherlodeConfig.bank_golden_nuggets, quantity);\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Bank.java"},{"fileName":"Character.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.Client;\nimport tictac7x.motherlode.sectors.Sector;\nimport tictac7x.motherlode.sectors.Sectors;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static tictac7x.motherlode.sectors.Sector.DOWNSTAIRS;\n\npublic class Character {\n    private final Client client;\n\n    public Character(final Client client) {\n        this.client \u003d client;\n    }\n\n    private final int[] MOTHERLODE_REGIONS \u003d new int[]{ 14679, 14680, 14681, 14935, 14936, 14937, 15191, 15192, 15193 };\n\n    private boolean inMotherlode \u003d false;\n    private List\u003cSector\u003e sectors \u003d Arrays.asList(DOWNSTAIRS);\n\n    public boolean isInMotherlode() {\n        return inMotherlode;\n    }\n\n    public List\u003cSector\u003e getSectors() {\n        return sectors;\n    }\n\n    public void onGameTick() {\n        this.sectors \u003d Sectors.getSectors(client.getLocalPlayer().getWorldLocation().getX(), client.getLocalPlayer().getWorldLocation().getY(), true);\n    }\n\n    public void checkIsInMotherlode() {\n        for (final int playerRegion : client.getMapRegions()) {\n            for (final int motherlodeRegion : MOTHERLODE_REGIONS) {\n                if (motherlodeRegion \u003d\u003d playerRegion) {\n                    inMotherlode \u003d true;\n                    return;\n                }\n            }\n        }\n\n        inMotherlode \u003d false;\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Character.java"},{"fileName":"Hopper.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.AnimationID;\nimport net.runelite.api.Client;\nimport net.runelite.api.Varbits;\nimport net.runelite.api.events.AnimationChanged;\nimport net.runelite.api.events.VarbitChanged;\n\npublic class Hopper {\n    private final Client client;\n    private final Inventory inventory;\n    private int paydirt \u003d 0;\n\n    public Hopper(final Client client, final Inventory inventory) {\n        this.client \u003d client;\n        this.inventory \u003d inventory;\n    }\n\n    public int getPaydirt() {\n        return paydirt;\n    }\n\n    public void onAnimationChanged(final AnimationChanged event) {\n        if (event.getActor() \u003d\u003d client.getLocalPlayer() \u0026\u0026 event.getActor().getAnimation() \u003d\u003d AnimationID.LOOKING_INTO) {\n            paydirt \u003d inventory.getPaydirt();\n        }\n    }\n\n    public void onVarbitChanged(final VarbitChanged event) {\n        if (event.getVarbitId() \u003d\u003d Varbits.SACK_NUMBER) {\n            paydirt \u003d 0;\n        }\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Hopper.java"},{"fileName":"Inventory.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.Item;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.ItemID;\nimport net.runelite.api.events.ItemContainerChanged;\n\npublic class Inventory {\n    private int paydirt \u003d 0;\n    private int otherItems \u003d 0;\n\n    public void onItemContainerChanged(final ItemContainerChanged event) {\n        if (event.getContainerId() !\u003d InventoryID.INVENTORY.getId()) return;\n\n        int paydirt \u003d 0;\n        int otherItems \u003d 0;\n\n        for (final Item item : event.getItemContainer().getItems()) {\n            if (item.getId() \u003e\u003d 0) {\n                otherItems +\u003d item.getId() \u003d\u003d ItemID.PAYDIRT ? 0 : 1;\n                paydirt +\u003d item.getId() \u003d\u003d ItemID.PAYDIRT ? 1 : 0;\n            }\n        }\n\n        this.paydirt \u003d paydirt;\n        this.otherItems \u003d otherItems;\n    }\n\n    public int getPaydirt() {\n        return paydirt;\n    }\n\n    public int getMaximumAvailablePayDirt() {\n        return 28 - otherItems;\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Inventory.java"},{"fileName":"Motherlode.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.Item;\nimport net.runelite.api.ItemContainer;\nimport net.runelite.api.ItemID;\nimport net.runelite.api.Varbits;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.callback.ClientThread;\n\npublic class Motherlode {\n    private final Client client;\n    private final ClientThread clientThread;\n    private final Notifier notifier;\n    private final TicTac7xMotherlodeConfig config;\n    private final Bank bank;\n    private final Inventory inventory;\n    private final Sack sack;\n    private final Hopper hopper;\n    private boolean notifiedToStopMining \u003d false;\n    private int goldenNuggetsBefore \u003d 0;\n    private int goldenNuggetsSession \u003d 0;\n\n    public Motherlode(final Client client, final ClientThread clientThread, final Notifier notifier, final TicTac7xMotherlodeConfig config, final Bank bank, final Inventory inventory, final Sack sack, final Hopper hopper) {\n        this.client \u003d client;\n        this.clientThread \u003d clientThread;\n        this.notifier \u003d notifier;\n        this.config \u003d config;\n        this.bank \u003d bank;\n        this.inventory \u003d inventory;\n        this.sack \u003d sack;\n        this.hopper \u003d hopper;\n    }\n\n    public int getDepositedPaydirt() {\n        return sack.getPaydirt() + hopper.getPaydirt();\n    }\n\n    public int getSpaceLeftToDeposit() {\n        return sack.getSize() - sack.getPaydirt() - hopper.getPaydirt();\n    }\n\n    public int getNeededPaydirt() {\n        return Math.min(\n            sack.getSize() - getDepositedPaydirt(),\n            inventory.getMaximumAvailablePayDirt()\n        ) - inventory.getPaydirt();\n    }\n\n    public boolean shouldStopMining() {\n        return (\n            getSpaceLeftToDeposit() \u003d\u003d 0 ||\n            getNeededPaydirt() \u003c 0 ||\n            getNeededPaydirt() \u003d\u003d 0 \u0026\u0026 inventory.getPaydirt() \u003c inventory.getMaximumAvailablePayDirt()\n        );\n    }\n\n    public boolean shouldDepositPaydirt() {\n        return getNeededPaydirt() \u003d\u003d 0 \u0026\u0026 inventory.getPaydirt() \u003e 0;\n    }\n\n    public int getGoldenNuggetsTotal() {\n        return bank.getGoldenNuggets();\n    }\n\n    public int getDepositsLeft() {\n        return inventory.getMaximumAvailablePayDirt() \u003d\u003d 0 ? 0 : (int) Math.ceil((double) getSpaceLeftToDeposit() / inventory.getMaximumAvailablePayDirt());\n    }\n\n    public int getInventoryPaydirt() {\n        return inventory.getPaydirt();\n    }\n\n    public int getSackSize() {\n        return sack.getSize();\n    }\n\n    public boolean sackCanBeMoreThanFull() {\n        return inventory.getMaximumAvailablePayDirt() \u003e getSpaceLeftToDeposit();\n    }\n\n    public int getGoldenNuggetsSession() {\n        return goldenNuggetsSession;\n    }\n\n    public void onItemContainerChanged(final ItemContainerChanged event) {\n        if (!notifiedToStopMining \u0026\u0026 event.getContainerId() \u003d\u003d InventoryID.INVENTORY.getId() \u0026\u0026 shouldStopMining() \u0026\u0026 config.notifyToStopMining()) {\n            notifier.notify(\"Stop mining! Sack will be too full.\");\n            notifiedToStopMining \u003d true;\n        }\n    }\n\n    public void onVarbitChanged(final VarbitChanged event) {\n        if (event.getVarbitId() \u003d\u003d Varbits.SACK_NUMBER) {\n            notifiedToStopMining \u003d false;\n        }\n    }\n\n    public void onChatMessage(final ChatMessage event) {\n        if (event.getType() \u003d\u003d ChatMessageType.MESBOX \u0026\u0026 event.getMessage().contains(\"You collect your ore from the sack.\")) {\n            depositFoundGoldenNuggetsToBank();\n        }\n    }\n\n    private void depositFoundGoldenNuggetsToBank() {\n        final ItemContainer inventory \u003d client.getItemContainer(InventoryID.INVENTORY);\n        if (inventory \u003d\u003d null) return;\n\n        for (final Item item : inventory.getItems()) {\n            if (item.getId() \u003d\u003d ItemID.GOLDEN_NUGGET) {\n                goldenNuggetsBefore \u003d item.getQuantity();\n                break;\n            }\n        }\n\n        clientThread.invokeLater(() -\u003e {\n            final ItemContainer inventoryNextTick \u003d client.getItemContainer(InventoryID.INVENTORY);\n            if (inventoryNextTick \u003d\u003d null) return;\n\n            for (final Item item : inventoryNextTick.getItems()) {\n                if (item.getId() \u003d\u003d ItemID.GOLDEN_NUGGET) {\n                    final int quantity \u003d item.getQuantity() - goldenNuggetsBefore;\n                    bank.depositGoldenNuggets(quantity);\n                    goldenNuggetsSession +\u003d quantity;\n                    break;\n                }\n            }\n        });\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Motherlode.java"},{"fileName":"OreVein.java","content":"package tictac7x.motherlode.oreveins;\n\nimport net.runelite.api.WallObject;\nimport tictac7x.motherlode.Motherlode;\nimport tictac7x.motherlode.sectors.Sectors;\nimport tictac7x.motherlode.Character;\nimport tictac7x.motherlode.sectors.Sector;\nimport tictac7x.motherlode.TicTac7xMotherlodeConfig;\n\nimport java.awt.Color;\n\npublic class OreVein {\n    public final int x;\n    public final int y;\n    private boolean isDepleted;\n    private boolean isDepleting;\n    private float health;\n    public final Sector sector;\n\n    private final int RESPAWN_TIME_GAMETICKS \u003d 100;\n    private final int DESPAWN_TIME_DOWNSTAIRS_GAMETICKS \u003d 45;\n    private final int DESPAWN_TIME_UPPERFLOOR_GAMETICKS \u003d 67;\n    private static final int[] ORE_VEINS_IDS \u003d new int[]{ 26661, 26662, 26663, 26664};\n    private static final int[] DEPLETED_ORE_VEINS_IDS \u003d new int[]{ 26665, 26666, 26667, 26668 };\n\n    public OreVein(final int x, final int y, final boolean isDepleted) {\n        this.x \u003d x;\n        this.y \u003d y;\n        this.isDepleted \u003d isDepleted;\n        this.sector \u003d Sectors.getSectors(x, y, false).get(0);\n        this.health \u003d getMaxHealth();\n    }\n\n    public void setDepleted(final boolean isDepleted) {\n        if (this.isDepleted \u003d\u003d isDepleted) return;\n\n        this.isDepleted \u003d isDepleted;\n        this.health \u003d isDepleted ? 0 : getMaxHealth();\n        this.isDepleting \u003d false;\n    }\n\n    public void startDepleting() {\n        isDepleting \u003d true;\n    }\n\n    public void onGameTick() {\n        if (isDepleted) {\n            health +\u003d (getMaxHealth()) / RESPAWN_TIME_GAMETICKS;\n        } else if (isDepleting) {\n            health \u003d Math.max(health - 1, 0);\n        }\n    }\n\n    public float getPieProgress() {\n        return health / getMaxHealth() * (isDepleted ? -1 : 1);\n    }\n\n    public Color getPieColor(final TicTac7xMotherlodeConfig config, final Motherlode motherlode) {\n        return\n            motherlode.shouldStopMining() ? config.getOreVeinsStoppingColor() :\n            isDepleted ? config.getOreVeinsDepletedColor() :\n            config.getOreVeinsColor();\n    }\n\n    public boolean isRendering(final TicTac7xMotherlodeConfig config, final Character character) {\n        if (config.upstairsOnly() \u0026\u0026 sector \u003d\u003d Sector.DOWNSTAIRS) {\n            return false;\n        }\n\n        if (!character.getSectors().contains(sector)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private float getMaxHealth() {\n        return sector \u003d\u003d Sector.DOWNSTAIRS\n            ? DESPAWN_TIME_DOWNSTAIRS_GAMETICKS\n            : DESPAWN_TIME_UPPERFLOOR_GAMETICKS;\n    }\n\n    public static boolean isOreVein(final WallObject wallObject) {\n        for (final int oreVeinId : ORE_VEINS_IDS) {\n            if (wallObject.getId() \u003d\u003d oreVeinId) return true;\n        }\n\n        return false;\n    }\n\n    public static boolean isDepletedOreVein(final WallObject wallObject) {\n        for (final int depletedOreVeinId : DEPLETED_ORE_VEINS_IDS) {\n            if (wallObject.getId() \u003d\u003d depletedOreVeinId) return true;\n        }\n\n        return false;\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\oreveins\\OreVein.java"},{"fileName":"OreVeins.java","content":"package tictac7x.motherlode.oreveins;\n\nimport net.runelite.api.Actor;\nimport net.runelite.api.AnimationID;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.WallObject;\nimport net.runelite.api.events.AnimationChanged;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.WallObjectDespawned;\nimport net.runelite.api.events.WallObjectSpawned;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.ProgressPieComponent;\nimport tictac7x.motherlode.Motherlode;\nimport tictac7x.motherlode.Character;\nimport tictac7x.motherlode.TicTac7xMotherlodeConfig;\n\nimport javax.annotation.Nullable;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static tictac7x.motherlode.TicTac7xMotherlodePlugin.getWorldObjectKey;\n\npublic class OreVeins extends Overlay {\n    private final TicTac7xMotherlodeConfig config;\n    private final Character character;\n    private final Motherlode motherlode;\n\n    public OreVeins(final TicTac7xMotherlodeConfig config, final Character character, final Motherlode motherlode) {\n        this.config \u003d config;\n        this.character \u003d character;\n        this.motherlode \u003d motherlode;\n\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n    }\n\n    public Map\u003cString, OreVein\u003e oreVeins \u003d new HashMap\u003c\u003e();\n    public Set\u003cWallObject\u003e oreVeinsWallObjects \u003d new HashSet\u003c\u003e();\n\n    public void onWallObjectSpawned(final WallObjectSpawned event) {\n        final WallObject wallObject \u003d event.getWallObject();\n        final boolean isOreVein \u003d OreVein.isOreVein(wallObject);\n        final boolean isDepletedOreVein \u003d OreVein.isDepletedOreVein(wallObject);\n        if (!isOreVein \u0026\u0026 !isDepletedOreVein) return;\n\n        updateOreVein(wallObject, isDepletedOreVein);\n        oreVeinsWallObjects.add(event.getWallObject());\n    }\n\n    public void onWallObjectDespawned(final WallObjectDespawned event) {\n        final WallObject wallObject \u003d event.getWallObject();\n        final boolean isOreVein \u003d OreVein.isOreVein(wallObject);\n        final boolean isDepletedOreVein \u003d OreVein.isDepletedOreVein(wallObject);\n        if (!isOreVein \u0026\u0026 !isDepletedOreVein) return;\n\n        updateOreVein(wallObject, isDepletedOreVein);\n        oreVeinsWallObjects.remove(event.getWallObject());\n    }\n\n    public void onGameStateChanged(final GameStateChanged event) {\n        if (event.getGameState() \u003d\u003d GameState.LOADING) {\n            oreVeinsWallObjects.clear();\n        }\n    }\n\n    public void onAnimationChanged(final AnimationChanged event) {\n        setOreVeinMinedFromAnimation(event);\n    }\n\n    public void onGameTick() {\n        for (final OreVein oreVein : oreVeins.values()) {\n            oreVein.onGameTick();\n        }\n    }\n\n    private void updateOreVein(final WallObject wallObject, final boolean isDepleted) {\n        final String key \u003d getWorldObjectKey(wallObject);\n\n        if (oreVeins.containsKey(key)) {\n            oreVeins.get(key).setDepleted(isDepleted);\n        } else {\n            oreVeins.put(key, new OreVein(\n                wallObject.getWorldLocation().getX(),\n                wallObject.getWorldLocation().getY(),\n                isDepleted\n            ));\n        }\n    }\n\n    private void setOreVeinMinedFromAnimation(final AnimationChanged event) {\n        final Actor player \u003d event.getActor();\n        if (!isMiningAnimation(event.getActor().getAnimation())) return;\n\n        final int playerX \u003d player.getWorldLocation().getX();\n        final int playerY \u003d player.getWorldLocation().getY();\n        final int playerOrientation \u003d player.getOrientation();\n\n        // Find correct ore vein based on actor orientation when mining.\n        for (final OreVein oreVein : oreVeins.values()) {\n            if (\n                // Facing south.\n                playerOrientation \u003d\u003d 0 \u0026\u0026 playerX \u003d\u003d oreVein.x \u0026\u0026 playerY \u003d\u003d oreVein.y + 1 ||\n                // Facing west.\n                playerOrientation \u003d\u003d 512 \u0026\u0026 playerX \u003d\u003d oreVein.x + 1 \u0026\u0026 playerY \u003d\u003d oreVein.y ||\n                // Facing north.\n                playerOrientation \u003d\u003d 1024 \u0026\u0026 playerX \u003d\u003d oreVein.x \u0026\u0026 playerY \u003d\u003d oreVein.y - 1 ||\n                // Facing east.\n                playerOrientation \u003d\u003d 1536 \u0026\u0026 playerX \u003d\u003d oreVein.x - 1 \u0026\u0026 playerY \u003d\u003d oreVein.y\n            ) {\n                oreVein.startDepleting();\n            }\n        }\n    }\n\n    @Nullable\n    private OreVein getOreVeinFromWallObject(final WallObject wallObject) {\n        return oreVeins.getOrDefault(getWorldObjectKey(wallObject), null);\n    }\n\n    @Override\n    public Dimension render(final Graphics2D graphics2D) {\n        for (final WallObject wallObject : oreVeinsWallObjects) {\n            final OreVein oreVein \u003d getOreVeinFromWallObject(wallObject);\n            if (oreVein \u003d\u003d null || !oreVein.isRendering(config, character)) continue;\n\n            renderPie(graphics2D, wallObject, oreVein.getPieColor(config, motherlode), oreVein.getPieProgress());\n        }\n\n        return null;\n    }\n\n    private void renderPie(final Graphics2D graphics, final WallObject object, final Color color, final float progress) {\n        try {\n            final ProgressPieComponent progressPieComponentBackground \u003d new ProgressPieComponent();\n            progressPieComponentBackground.setPosition(object.getCanvasLocation(160));\n            progressPieComponentBackground.setProgress(1);\n            progressPieComponentBackground.setFill(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 100, 0)));\n            progressPieComponentBackground.render(graphics);\n\n            final ProgressPieComponent progressPieComponentTimer \u003d new ProgressPieComponent();\n            progressPieComponentTimer.setPosition(object.getCanvasLocation(160));\n            progressPieComponentTimer.setProgress(progress);\n            progressPieComponentTimer.setBorderColor(color);\n            progressPieComponentTimer.setFill(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 20, 0)));\n            progressPieComponentTimer.render(graphics);\n        } catch (final Exception ignored) {}\n    }\n\n    private boolean isMiningAnimation(final int animationId) {\n        switch (animationId) {\n            case AnimationID.MINING_MOTHERLODE_BRONZE:\n            case AnimationID.MINING_MOTHERLODE_IRON:\n            case AnimationID.MINING_MOTHERLODE_STEEL:\n            case AnimationID.MINING_MOTHERLODE_BLACK:\n            case AnimationID.MINING_MOTHERLODE_MITHRIL:\n            case AnimationID.MINING_MOTHERLODE_ADAMANT:\n            case AnimationID.MINING_MOTHERLODE_RUNE:\n            case AnimationID.MINING_MOTHERLODE_DRAGON:\n            case AnimationID.MINING_MOTHERLODE_DRAGON_OR:\n            case AnimationID.MINING_MOTHERLODE_DRAGON_UPGRADED:\n            case AnimationID.MINING_MOTHERLODE_DRAGON_OR_TRAILBLAZER:\n            case AnimationID.MINING_MOTHERLODE_3A:\n            case AnimationID.MINING_MOTHERLODE_CRYSTAL:\n            case AnimationID.MINING_MOTHERLODE_INFERNAL:\n            case AnimationID.MINING_MOTHERLODE_GILDED:\n            case AnimationID.MINING_MOTHERLODE_TRAILBLAZER:\n                return true;\n            default:\n                return false;\n        }\n    }\n}","filePath":"src\\main\\java\\tictac7x\\motherlode\\oreveins\\OreVeins.java"},{"fileName":"Rockfall.java","content":"package tictac7x.motherlode.rockfalls;\n\nimport net.runelite.api.GameObject;\nimport tictac7x.motherlode.sectors.Sectors;\nimport tictac7x.motherlode.Character;\nimport tictac7x.motherlode.sectors.Sector;\nimport tictac7x.motherlode.TicTac7xMotherlodeConfig;\n\nimport java.awt.Color;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Rockfall {\n    public final int x;\n    public final int y;\n    public final List\u003cSector\u003e sectors;\n\n    public Rockfall(final int x, final int y) {\n        this.x \u003d x;\n        this.y \u003d y;\n        this.sectors \u003d Sectors.getSectors(x, y, true);\n    }\n\n    public Color getTileColor(final TicTac7xMotherlodeConfig config) {\n        return config.getRockfallsColor();\n    }\n\n    public boolean isRendering(final TicTac7xMotherlodeConfig config, final Character character) {\n        if (config.upstairsOnly() \u0026\u0026 sectors.contains(Sector.DOWNSTAIRS)) {\n            return false;\n        }\n\n        if (Collections.disjoint(character.getSectors(), sectors)) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public static boolean isRockfall(final GameObject gameObject) {\n        switch (gameObject.getId()) {\n            case 26679:\n            case 26680:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\rockfalls\\Rockfall.java"},{"fileName":"Rockfalls.java","content":"package tictac7x.motherlode.rockfalls;\n\nimport net.runelite.api.GameObject;\nimport net.runelite.api.GameState;\nimport net.runelite.api.events.GameObjectDespawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport tictac7x.motherlode.Character;\nimport tictac7x.motherlode.TicTac7xMotherlodeConfig;\n\nimport javax.annotation.Nullable;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static tictac7x.motherlode.TicTac7xMotherlodePlugin.getWorldObjectKey;\n\npublic class Rockfalls extends Overlay {\n    private final TicTac7xMotherlodeConfig config;\n    private final Character character;\n\n    private Map\u003cString, Rockfall\u003e rockfalls \u003d new HashMap\u003c\u003e();\n    private Set\u003cGameObject\u003e rockfallsGameObjects \u003d new HashSet\u003c\u003e();\n\n    public Rockfalls(final TicTac7xMotherlodeConfig config, final Character character) {\n        this.config \u003d config;\n        this.character \u003d character;\n\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n    }\n\n\n    public void onGameObjectSpawned(final GameObjectSpawned event) {\n        if (!Rockfall.isRockfall(event.getGameObject())) return;\n\n        updateRockfall(event.getGameObject());\n        rockfallsGameObjects.add(event.getGameObject());\n    }\n\n    public void onGameObjectDespawned(final GameObjectDespawned event) {\n        if (!Rockfall.isRockfall(event.getGameObject())) return;\n\n        rockfallsGameObjects.remove(event.getGameObject());\n    }\n\n    public void onGameStateChanged(final GameStateChanged event) {\n        if (event.getGameState() \u003d\u003d GameState.LOADING) {\n            rockfallsGameObjects.clear();\n        }\n    }\n\n    private void updateRockfall(final GameObject gameObject) {\n        final String key \u003d getWorldObjectKey(gameObject);\n\n        if (!rockfalls.containsKey(key)) {\n            rockfalls.put(key, new Rockfall(gameObject.getWorldLocation().getX(), gameObject.getWorldLocation().getY()));\n        }\n    }\n\n    @Nullable\n    private Rockfall getRockfallFromGameObject(final GameObject gameObject) {\n        for (final Rockfall rockfall : rockfalls.values()) {\n            if (rockfall.x \u003d\u003d gameObject.getWorldLocation().getX() \u0026\u0026 rockfall.y \u003d\u003d gameObject.getWorldLocation().getY()) {\n                return rockfall;\n            }\n        }\n\n        return null;\n    }\n\n    @Override\n    public Dimension render(final Graphics2D graphics2D) {\n        if (config.getRockfallsColor().getAlpha() \u003d\u003d 0) return null;\n\n        for (final GameObject rockfallGameObject : rockfallsGameObjects) {\n            final Rockfall rockfall \u003d getRockfallFromGameObject(rockfallGameObject);\n            if (rockfall \u003d\u003d null || !rockfall.isRendering(config, character)) continue;\n\n            renderTile(graphics2D, rockfallGameObject, rockfall.getTileColor(config));\n        }\n\n        return null;\n    }\n\n    private void renderTile(final Graphics2D graphics, final GameObject gameObject, final Color color) {\n        try {\n            // Area border.\n            graphics.setColor(color);\n            graphics.setStroke(new BasicStroke(1));\n            graphics.draw(gameObject.getCanvasTilePoly());\n\n            // Area fill.\n            graphics.setColor(new Color(color.getRed(), color.getGreen(), color.getBlue(), Math.max(color.getAlpha() - 20, 0)));\n            graphics.fill(gameObject.getCanvasTilePoly());\n        } catch (final Exception ignored) {}\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\rockfalls\\Rockfalls.java"},{"fileName":"Sack.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Varbits;\n\n\npublic class Sack {\n    private final Client client;\n\n    private final int SACK_SIZE_SMALL \u003d 108;\n    private final int SACK_SIZE_UPGRADED \u003d 189;\n\n    public Sack(final Client client) {\n        this.client \u003d client;\n    }\n\n    public int getPaydirt() {\n        return client.getVarbitValue(Varbits.SACK_NUMBER);\n    }\n\n    private boolean isSackUpgraded() {\n        return client.getVarbitValue(Varbits.SACK_UPGRADED) \u003d\u003d 1;\n    }\n\n    public int getSize() {\n        return isSackUpgraded() ? SACK_SIZE_UPGRADED : SACK_SIZE_SMALL;\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Sack.java"},{"fileName":"Sector.java","content":"package tictac7x.motherlode.sectors;\n\npublic enum Sector {\n    DOWNSTAIRS,\n    UPSTAIRS_W,\n    UPSTAIRS_NW,\n    UPSTAIRS_SE,\n    UPSTAIRS_S,\n    UPSTAIRS_NE,\n    UPSTAIRS_E\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\sectors\\Sector.java"},{"fileName":"Sectors.java","content":"package tictac7x.motherlode.sectors;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Sectors {\n    public static List\u003cSector\u003e getSectors(final int x, final int y, final boolean multi) {\n        final List\u003cSector\u003e sectors \u003d new ArrayList\u003c\u003e();\n        final int[] location \u003d new int[]{x, y};\n\n        if (isInSector(UPSTAIRS_W, location)) {\n            sectors.add(Sector.UPSTAIRS_W);\n            if (!multi) return sectors;\n        }\n        if (isInSector(UPSTAIRS_NW, location)) {\n            sectors.add(Sector.UPSTAIRS_NW);\n            if (!multi) return sectors;\n        }\n        if (isInSector(UPSTAIRS_SE, location)) {\n            sectors.add(Sector.UPSTAIRS_SE);\n            if (!multi) return sectors;\n        }\n        if (isInSector(UPSTAIRS_S, location)) {\n            sectors.add(Sector.UPSTAIRS_S);\n            if (!multi) return sectors;\n        }\n        if (isInSector(UPSTAIRS_NE, location)) {\n            sectors.add(Sector.UPSTAIRS_NE);\n            if (!multi) return sectors;\n        }\n        if (isInSector(UPSTAIRS_E, location)) {\n            sectors.add(Sector.UPSTAIRS_E);\n            if (!multi) return sectors;\n        }\n\n        if (sectors.isEmpty()) {\n            sectors.add(Sector.DOWNSTAIRS);\n        }\n\n        return sectors;\n    }\n\n    private static boolean isInSector(final int[][] sector, final int[] location) {\n        for (int[] point : sector) {\n            if (Arrays.equals(point, location)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private static final int[][] UPSTAIRS_W \u003d {\n            {3734, 5685},\n            {3735, 5684}, {3735, 5685}, {3735, 5686},\n            {3736, 5685},\n            {3737, 5682}, {3737, 5683}, {3737, 5684}, {3737, 5685},\n            {3738, 5682}, {3738, 5683}, {3738, 5684}, {3738, 5685},\n            {3739, 5683}, {3739, 5684}, {3739, 5685},\n            {3740, 5684}, {3740, 5685}, {3740, 5686},\n            {3741, 5683}, {3741, 5684}, {3741, 5685}, {3741, 5686},\n            {3742, 5683}, {3742, 5684}, {3742, 5685}, {3742, 5686},\n            {3743, 5684}, {3743, 5686}, {3743, 5687},\n            {3744, 5686}, {3744, 5687},\n            {3745, 5684}, {3745, 5685}, {3745, 5686},\n            {3746, 5684}, {3746, 5685}, {3746, 5686},\n            {3747, 5685}, {3747, 5686},\n            {3748, 5684}, {3748, 5685}\n    };\n\n    private static final int[][] UPSTAIRS_NW \u003d {\n            {3747, 5683},\n            {3748, 5682}, {3748, 5683}, {3748, 5684},\n            {3749, 5682}, {3749, 5683}, {3749, 5684},\n            {3750, 5682}, {3750, 5683}, {3750, 5684}, {3750, 5685},\n            {3751, 5678}, {3751, 5680}, {3751, 5681}, {3751, 5683}, {3751, 5684},\n            {3752, 5676}, {3752, 5677}, {3752, 5678}, {3752, 5679}, {3752, 5680}, {3752, 5681}, {3752, 5682}, {3752, 5683}, {3752, 5684},\n            {3753, 5676}, {3753, 5677}, {3753, 5678}, {3753, 5680}, {3753, 5682}, {3753, 5683}, {3753, 5684},\n            {3754, 5675}, {3754, 5676}, {3754, 5677},{3754, 5678}, {3754, 5682}, {3754, 5683},\n            {3755, 5675}, {3755, 5676}, {3755, 5677}\n    };\n\n    private static final int[][] UPSTAIRS_SE \u003d {\n            {3755, 5675}, {3755, 5676},\n            {3756, 5674}, {3756, 5675}, {3756, 5676},\n            {3757, 5673}, {3757, 5674}, {3757, 5675}, {3757, 5676},\n            {3758, 5673}, {3758, 5675},\n            {3759, 5672}, {3759, 5673}, {3759, 5674},\n            {3760, 5671}, {3760, 5672}, {3760, 5673}, {3760, 5674},\n            {3761, 5668}, {3761, 5669}, {3761, 5670}, {3761, 5671}, {3761, 5672}, {3761, 5673}, {3761, 5674},\n            {3762, 5668}, {3762, 5670}, {3762, 5671}, {3762, 5672}, {3762, 5673}\n    };\n\n    private static final int[][] UPSTAIRS_S \u003d {\n            {3761, 5660}, {3761, 5661}, {3761, 5662}, {3761, 5663}, {3761, 5664},\n            {3762, 5657}, {3762, 5658}, {3762, 5660}, {3762, 5661}, {3762, 5662}, {3762, 5663}, {3762, 5664}, {3762, 5665}, {3762, 5667}, {3762, 5668},\n            {3763, 5656}, {3763, 5657}, {3763, 5658}, {3763, 5659}, {3763, 5660}, {3763, 5662}, {3763, 5663}, {3763, 5665}, {3763, 5666}, {3763, 5667}, {3763, 5668}, {3763, 5670},\n            {3764, 5656}, {3764, 5657}, {3764, 5658}, {3764, 5659}, {3764, 5665}, {3764, 5667}, {3764, 5668}, {3764, 5669}, {3764, 5670},\n            {3765, 5656}, {3765, 5657}, {3765, 5658},\n            {3766, 5657}\n    };\n\n    private static final int[][] UPSTAIRS_NE \u003d {\n            {3755, 5675}, {3755, 5676}, {3755, 5681}, {3755, 5682}, {3755, 5683},\n            {3756, 5676}, {3756, 5677}, {3756, 5678}, {3756, 5679}, {3756, 5681}, {3756, 5682}, {3756, 5683}, {3756, 5684},\n            {3757, 5676}, {3757, 5677}, {3757, 5678}, {3757, 5679}, {3757, 5680}, {3757, 5681}, {3757, 5682}, {3757, 5683}, {3757, 5684},\n            {3758, 5680}, {3758, 5681}, {3758, 5683}, {3758, 5685},\n            {3759, 5682}, {3759, 5683}, {3759, 5684}, {3759, 5685},\n            {3760, 5683}, {3760, 5684}, {3760, 5685},\n            {3761, 5681}, {3761, 5682}, {3761, 5683}, {3761, 5684}, {3761, 5685},\n            {3762, 5682}, {3762, 5683}\n    };\n\n    private static final int[][] UPSTAIRS_E \u003d {\n            {3755, 5675}, {3755, 5676},\n            {3756, 5676}, {3756, 5677},\n            {3757, 5676}, {3757, 5677},\n            {3758, 5677}, {3758, 5678},\n            {3759, 5676}, {3759, 5677}, {3759, 5678},\n            {3760, 5677}, {3760, 5678}, {3760, 5679}, {3760, 5680},\n            {3761, 5675}, {3761, 5676}, {3761, 5677}, {3761, 5678}, {3761, 5679}, {3761, 5680},\n            {3762, 5675}, {3762, 5676}, {3762, 5677}, {3762, 5678}, {3762, 5679}, {3762, 5680},\n            {3763, 5678}, {3763, 5679}, {3763, 5678}, {3763, 5681}, {3763, 5682}, {3763, 5683},\n            {3764, 5677}, {3764, 5678}, {3764, 5679}, {3764, 5680}, {3764, 5681}, {3764, 5682}, {3764, 5683},\n            {3765, 5677}, {3765, 5678}, {3765, 5679},\n            {3766, 5678}\n    };\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\sectors\\Sectors.java"},{"fileName":"TicTac7xMotherlodeConfig.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.client.config.*;\nimport java.awt.Color;\n\n@ConfigGroup(TicTac7xMotherlodeConfig.group)\npublic interface TicTac7xMotherlodeConfig extends Config {\n\tString group \u003d \"tictac7x-motherlode\";\n\tString sack_custom \u003d \"sack_custom\";\n\tString bank_golden_nuggets \u003d \"bank_golden_nuggets\";\n\tString version \u003d \"version\";\n\n\t@ConfigItem(\n\t\tkeyName \u003d bank_golden_nuggets,\n\t\tname \u003d bank_golden_nuggets,\n\t\tdescription \u003d bank_golden_nuggets,\n\t\thidden \u003d true\n\t) default int getBankGoldenNuggets() { return 0; }\n\n\t@ConfigItem(\n\t\tkeyName \u003d version,\n\t\tname \u003d version,\n\t\tdescription \u003d version,\n\t\thidden \u003d true\n\t) default String getVersion() { return \"0\"; }\n\n\t@ConfigSection(\n\t\tname \u003d \"General\",\n\t\tdescription \u003d \"General options to improve overall experience.\",\n\t\tposition \u003d 1\n\t) String general \u003d \"general\";\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"upstairs_only\",\n\t\t\tname \u003d \"Only upstairs veins and rockfalls\",\n\t\t\tdescription \u003d \"Highlight only upstairs ore veins and rockfalls.\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d general\n\t\t) default boolean upstairsOnly() { return false; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"notify_to_stop_mining\",\n\t\t\tname \u003d \"Notify to stop mining\",\n\t\t\tdescription \u003d \"Notifies user to stop mining when sack would become full with already owned paydirt.\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d general\n\t\t) default boolean notifyToStopMining() { return true; }\n\n\t\t@ConfigSection(\n\t\t\tname \u003d \"Ore veins and rockfalls\",\n\t\t\tdescription \u003d \"Highlight ore veins and rockfalls based on their states.\",\n\t\t\tposition \u003d 2\n\t\t) String ore_veins_and_rockfalls \u003d \"ore_veins_and_rockfalls\";\n\n\t\t@Alpha\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"ore_veins\",\n\t\t\tname \u003d \"Mineable Ore Veins\",\n\t\t\tdescription \u003d \"Highlight ore veins that can be mined.\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d ore_veins_and_rockfalls\n\t\t) default Color getOreVeinsColor() { return new Color(0, 255, 0, 140); }\n\n\t\t@Alpha\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"ore_veins_depleted\",\n\t\t\tname \u003d \"Depleted Ore Veins\",\n\t\t\tdescription \u003d \"Highlight ore veins that are depleted.\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d ore_veins_and_rockfalls\n\t\t) default Color getOreVeinsDepletedColor() { return new Color(255, 180, 0, 140); }\n\n\t\t@Alpha\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"ore_veins_stop\",\n\t\t\tname \u003d \"Stopping Ore Veins\",\n\t\t\tdescription \u003d \"Highlight ore veins when they shouldn\u0027t be mined.\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d ore_veins_and_rockfalls\n\t\t) default Color getOreVeinsStoppingColor() { return new Color(255, 0, 0, 140); }\n\n\t\t@Alpha\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"rockfalls\",\n\t\t\tname \u003d \"Rockfalls\",\n\t\t\tdescription \u003d \"Highlight rockfalls that need to be cleared.\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d ore_veins_and_rockfalls\n\t\t) default Color getRockfallsColor() { return new Color(255, 0, 0, 80); }\n\n\t@ConfigSection(\n\t\tname \u003d \"Custom sack widget\",\n\t\tdescription \u003d \"Show custom sack widget with helpful information.\",\n\t\tposition \u003d 3\n\t) String custom_sack_widget \u003d \"custom_sack_widget\";\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d sack_custom,\n\t\t\tname \u003d \"Use custom sack widget\",\n\t\t\tdescription \u003d \"Whether to show custom sack widget or not.\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showCustomSackWidget() { return true; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"show_golden_nuggets_total\",\n\t\t\tname \u003d \"Total golden nuggets\",\n\t\t\tdescription \u003d \"Show the total number of golden nuggets that you have.\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showGoldenNuggetsTotal() { return true; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"show_golden_nuggets_session\",\n\t\t\tname \u003d \"Session golden nuggets\",\n\t\t\tdescription \u003d \"Show the total number of golden nuggets you have found during this session.\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showGoldenNuggetsSession() { return false; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"sack_paydirt\",\n\t\t\tname \u003d \"Sack pay-dirt\",\n\t\t\tdescription \u003d \"Show total number of pay-dirt in sack and hopper.\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showSackAndHopperPaydirt() { return true; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"sack_paydirt_inventory\",\n\t\t\tname \u003d \"Pay-dirt from inventory\",\n\t\t\tdescription \u003d \"Show how many pay dirt will be added to the sack.\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showSackPaydirtFromInventory() { return false; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"sack_size\",\n\t\t\tname \u003d \"Sack total size\",\n\t\t\tdescription \u003d \"Show total size of the sack.\",\n\t\t\tposition \u003d 6,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showSackSize() { return true; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"sack_deposits\",\n\t\t\tname \u003d \"Deposits left\",\n\t\t\tdescription \u003d \"Show number of inventories you can store before sack gets full.\",\n\t\t\tposition \u003d 7,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showSackDeposits() { return true; }\n\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"sack_needed\",\n\t\t\tname \u003d \"Needed pay-dirt\",\n\t\t\tdescription \u003d \"Show number of pay-dirt needed to mine before you should deposit the pay-dirt.\",\n\t\t\tposition \u003d 8,\n\t\t\tsection \u003d custom_sack_widget\n\t\t) default boolean showSackNeeded() { return true; }\n\n\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\TicTac7xMotherlodeConfig.java"},{"fileName":"TicTac7xMotherlodePlugin.java","content":"package tictac7x.motherlode;\n\nimport com.google.inject.Provides;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.events.AnimationChanged;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameObjectDespawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.api.events.WallObjectDespawned;\nimport net.runelite.api.events.WallObjectSpawned;\nimport net.runelite.api.events.WidgetLoaded;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.chat.ChatMessageManager;\nimport net.runelite.client.chat.QueuedMessage;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport tictac7x.motherlode.oreveins.OreVeins;\nimport tictac7x.motherlode.rockfalls.Rockfalls;\n\nimport javax.inject.Inject;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Motherlode Mine Improved\",\n\tdescription \u003d \"Better indicators for ore veins\",\n\ttags \u003d { \"motherlode\", \"prospector\", \"golden\", \"nugget\" },\n\tconflicts \u003d {\"Motherlode Mine\", \"MLM Mining Markers\"}\n)\npublic class TicTac7xMotherlodePlugin extends Plugin {\n\tprivate final String pluginVersion \u003d \"v0.4.3\";\n\tprivate final String pluginMessage \u003d \"\" +\n\t\t\"\u003ccolHIGHLIGHT\u003eMotherlode Mine Improved \" + pluginVersion + \":\u003cbr\u003e\" +\n\t\t\"\u003ccolHIGHLIGHT\u003e* Needed paydirt improvements.\"\n\t;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate TicTac7xMotherlodeConfig config;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate Notifier notifier;\n\n\t@Inject\n\tprivate ChatMessageManager chatMessageManager;\n\n\tprivate Character character;\n\tprivate Bank bank;\n\tprivate Inventory inventory;\n\tprivate Hopper hopper;\n\tprivate OreVeins oreVeins;\n\tprivate Rockfalls rockfalls;\n\tprivate Sack sack;\n\tprivate Motherlode motherlode;\n\tprivate Widget widget;\n\n\t@Provides\n\tTicTac7xMotherlodeConfig provideConfig(ConfigManager configManager) {\n\t\treturn configManager.getConfig(TicTac7xMotherlodeConfig.class);\n\t}\n\n\t@Override\n\tprotected void startUp() {\n\t\tcharacter \u003d new Character(client);\n\t\tbank \u003d new Bank(configManager, config);\n\t\tinventory \u003d new Inventory();\n\t\thopper \u003d new Hopper(client, inventory);\n\t\tsack \u003d new Sack(client);\n\t\tmotherlode \u003d new Motherlode(client, clientThread, notifier, config, bank, inventory, sack, hopper);\n\t\twidget \u003d new Widget(client, config, motherlode, character);\n\t\toreVeins \u003d new OreVeins(config, character, motherlode);\n\t\trockfalls \u003d new Rockfalls(config, character);\n\n\t\toverlayManager.add(oreVeins);\n\t\toverlayManager.add(rockfalls);\n\t\toverlayManager.add(widget);\n\t}\n\n\t@Override\n\tprotected void shutDown() {\n\t\twidget.shutDown();\n\t\toverlayManager.remove(oreVeins);\n\t\toverlayManager.remove(rockfalls);\n\t\toverlayManager.remove(widget);\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(final GameStateChanged event) {\n\t\toreVeins.onGameStateChanged(event);\n\t\trockfalls.onGameStateChanged(event);\n\t\tsendMessageAboutPluginVersion(event);\n\t}\n\n\t@Subscribe\n\tpublic void onItemContainerChanged(final ItemContainerChanged event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\tinventory.onItemContainerChanged(event);\n\t\tbank.onItemContainerChanged(event);\n\t\tmotherlode.onItemContainerChanged(event);\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(final ChatMessage event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\tmotherlode.onChatMessage(event);\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectSpawned(final WallObjectSpawned event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\toreVeins.onWallObjectSpawned(event);\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectDespawned(final WallObjectDespawned event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\toreVeins.onWallObjectDespawned(event);\n\t}\n\n\t@Subscribe\n\tpublic void onAnimationChanged(final AnimationChanged event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\toreVeins.onAnimationChanged(event);\n\t\thopper.onAnimationChanged(event);\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectSpawned(final GameObjectSpawned event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\trockfalls.onGameObjectSpawned(event);\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectDespawned(final GameObjectDespawned event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\trockfalls.onGameObjectDespawned(event);\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(final GameTick event) {\n\t\tcharacter.checkIsInMotherlode();\n\t\tif (!character.isInMotherlode()) return;\n\n\t\tcharacter.onGameTick();\n\t\toreVeins.onGameTick();\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(final ConfigChanged event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\twidget.onConfigChanged(event);\n\t}\n\n\t@Subscribe\n\tpublic void onWidgetLoaded(final WidgetLoaded event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\twidget.onWidgetLoaded(event);\n\t}\n\n\t@Subscribe\n\tpublic void onVarbitChanged(final VarbitChanged event) {\n\t\tif (!character.isInMotherlode()) return;\n\t\thopper.onVarbitChanged(event);\n\t\tmotherlode.onVarbitChanged(event);\n\t}\n\n\tprivate void sendMessageAboutPluginVersion(final GameStateChanged event) {\n\t\tif (event.getGameState() \u003d\u003d GameState.LOGGED_IN \u0026\u0026 !config.getVersion().equals(pluginVersion)) {\n\t\t\tconfigManager.setConfiguration(TicTac7xMotherlodeConfig.group, TicTac7xMotherlodeConfig.version, pluginVersion);\n\t\t\tchatMessageManager.queue(QueuedMessage.builder()\n\t\t\t\t.type(ChatMessageType.CONSOLE)\n\t\t\t\t.runeLiteFormattedMessage(pluginMessage)\n\t\t\t\t.build()\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic static String getWorldObjectKey(final TileObject tileObject) {\n\t\treturn tileObject.getWorldLocation().getX() + \"_\" + tileObject.getWorldLocation().getY();\n\t}\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\TicTac7xMotherlodePlugin.java"},{"fileName":"Widget.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.events.WidgetLoaded;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.LineComponent;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\n\npublic class Widget extends OverlayPanel {\n    private final Client client;\n    private final TicTac7xMotherlodeConfig config;\n    private final Motherlode motherlode;\n    private final Character character;\n\n    private final int SACK_WIDGET_GROUP \u003d 382;\n    private final int SACK_WIDGET_CHILD \u003d 0;\n\n    public Widget(final Client client, final TicTac7xMotherlodeConfig config, final Motherlode motherlode, final Character character) {\n        this.client \u003d client;\n        this.config \u003d config;\n        this.motherlode \u003d motherlode;\n        this.character \u003d character;\n\n        setPosition(OverlayPosition.TOP_LEFT);\n        setLayer(OverlayLayer.ABOVE_WIDGETS);\n        toggleOriginalWidget(config.showCustomSackWidget());\n    }\n\n    // On first widget load.\n    public void onWidgetLoaded(final WidgetLoaded event) {\n        if (event.getGroupId() \u003d\u003d SACK_WIDGET_GROUP) {\n            toggleOriginalWidget(config.showCustomSackWidget());\n        }\n    }\n\n    // Widget needs to be toggled based on config changed.\n    public void onConfigChanged(final ConfigChanged event) {\n        if (event.getGroup().equals(TicTac7xMotherlodeConfig.group) \u0026\u0026 event.getKey().equals(TicTac7xMotherlodeConfig.sack_custom)) {\n            toggleOriginalWidget(config.showCustomSackWidget());\n        }\n    }\n\n    public void shutDown() {\n        toggleOriginalWidget(false);\n    }\n\n    private void toggleOriginalWidget(final boolean hidden) {\n        final net.runelite.api.widgets.Widget widget \u003d client.getWidget(SACK_WIDGET_GROUP, SACK_WIDGET_CHILD);\n\n        if (widget !\u003d null) {\n            widget.setHidden(hidden);\n        }\n    }\n\n    @Override\n    public Dimension render(final Graphics2D graphics2D) {\n        if (!character.isInMotherlode() || !config.showCustomSackWidget()) return null;\n\n        panelComponent.getChildren().clear();\n\n        setPreferredColor(\n            motherlode.shouldStopMining() ? new Color(255,0,0, 70) :\n            motherlode.sackCanBeMoreThanFull() ? new Color(255, 165, 0, 70) :\n            motherlode.shouldDepositPaydirt() ? new Color(0, 255, 0, 70) :\n            null\n        );\n\n\n        if (config.showGoldenNuggetsTotal() || config.showGoldenNuggetsSession()) {\n            String nuggets \u003d \"\";\n\n            if (config.showGoldenNuggetsTotal()) {\n                nuggets +\u003d motherlode.getGoldenNuggetsTotal();\n            }\n\n            if (config.showGoldenNuggetsSession()) {\n                nuggets +\u003d config.showGoldenNuggetsTotal() ? \" (+\" + motherlode.getGoldenNuggetsSession() + \")\" : motherlode.getGoldenNuggetsSession();\n            }\n\n            panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Nuggets:\")\n                .right(nuggets).rightColor(Color.ORANGE)\n                .build()\n            );\n        }\n\n        if (config.showSackAndHopperPaydirt() || config.showSackSize()) {\n            String paydirt \u003d \"\";\n\n            if (config.showSackAndHopperPaydirt()) {\n                paydirt +\u003d motherlode.getDepositedPaydirt();\n\n                if (config.showSackPaydirtFromInventory()) {\n                    paydirt +\u003d \" + \" + motherlode.getInventoryPaydirt();\n                }\n            }\n\n            if (config.showSackSize()) {\n                if (config.showSackAndHopperPaydirt()) {\n                    paydirt +\u003d \" / \";\n                }\n\n                paydirt +\u003d motherlode.getSackSize();\n            }\n\n            panelComponent.getChildren().add(LineComponent.builder().left(\"Sack:\").right(paydirt).build());\n        }\n\n        if (config.showSackDeposits()) {\n            panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Deposits:\")\n                .right(motherlode.getDepositsLeft() + \"\")\n                .build()\n            );\n        }\n\n        if (config.showSackNeeded()) {\n            panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Needed:\")\n                .right(motherlode.getNeededPaydirt() + \"\").rightColor(\n                    (motherlode.getSpaceLeftToDeposit() \u003d\u003d 0 || motherlode.getNeededPaydirt() \u003d\u003d 0) ? Color.WHITE :\n                    motherlode.getNeededPaydirt() \u003c 0 ? Color.RED :\n                    Color.GREEN )\n                .build()\n            );\n        }\n\n        return super.render(graphics2D);\n    }\n}\n","filePath":"src\\main\\java\\tictac7x\\motherlode\\Widget.java"},{"fileName":"MotherlodePluginTest.java","content":"package tictac7x.motherlode;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class MotherlodePluginTest {\n\tpublic static void main(String[] args) throws Exception {\n\t\tExternalPluginManager.loadBuiltin(TicTac7xMotherlodePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\tictac7x\\motherlode\\MotherlodePluginTest.java"}]},{"commit":"710891d827c0678d3e7816e6e76ecb770d403c06","repository":"https://github.com/BenLite0/1-5-Woodcutting.git","internalName":"1-5-woodcutting","files":[{"fileName":"PatchTimerConfig.java","content":"package com.patchtimer;\n\nimport net.runelite.client.config.*;\nimport java.awt.*;\n\n@ConfigGroup(\"patchtimer\")\npublic interface PatchTimerConfig extends Config {\n\t@ConfigSection(\n\t\tname \u003d \"Timer Settings\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 100\n\t)\n\tString timerSettings \u003d \"timersettings\";\n\n\t@Alpha\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"backgroundSize\",\n\t\t\tname \u003d \"Background Size\",\n\t\t\tdescription \u003d \"How large the timer background should be\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d timerSettings\n\t)\n\tdefault int getBackgroundSize() {\n\t\treturn 16;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"backgroundColor\",\n\t\t\tname \u003d \"Background Color\",\n\t\t\tdescription \u003d \"The color the timer background should be\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d timerSettings\n\t)\n\n\t@Alpha\n\tdefault Color getBackgroundColor() {\n\t\treturn new Color(0,0,0,167);\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"textColor\",\n\t\t\tname \u003d \"Text Color\",\n\t\t\tdescription \u003d \"The color the timer text should be\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d timerSettings\n\t)\n\tdefault Color getTextColor() {\n\t\treturn new Color(255,255,255,255);\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"tick_early_color\",\n\t\t\tname \u003d \"Early Tick Color\",\n\t\t\tdescription \u003d \"The color to be 1t early to chop on tree respawn\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d timerSettings\n\t)\n\tdefault Color getTick_early_color() {\n\t\treturn new Color(255, 0, 0,255);\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"tick_perfect_color\",\n\t\t\tname \u003d \"Perfect Tick Color\",\n\t\t\tdescription \u003d \"The color to be tick perfect to chop on tree respawn\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d timerSettings\n\t)\n\tdefault Color getTick_perfect_color() {\n\t\treturn new Color(64, 255, 0,255);\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"tick_late_color\",\n\t\t\tname \u003d \"Late Tick Color\",\n\t\t\tdescription \u003d \"The color to be 1 tick late to chop on tree respawn\",\n\t\t\tposition \u003d 6,\n\t\t\tsection \u003d timerSettings\n\t)\n\tdefault Color getTick_late_color() {\n\t\treturn new Color(255, 239, 0,255);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"assumeTick\",\n\t\t\tname \u003d \"Assume Respawn tick\",\n\t\t\tdescription \u003d \"If the timer should assume that the tree will respawn 1 tick sooner on single log roll\",\n\t\t\tposition \u003d 101\n\t)\n\tdefault boolean getAssumeTick(){\n\t\treturn false;\n\t}\n}\n","filePath":"src\\main\\java\\com\\patchtimer\\PatchTimerConfig.java"},{"fileName":"PatchTimerPlugin.java","content":"package com.patchtimer;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Skill;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.api.events.StatChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport java.util.LinkedList;\nimport java.util.List;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"1.5 Woodcutting\"\n)\n\npublic class PatchTimerPlugin extends Plugin\n{\n\tstatic final int LEFT_TREE \u003d 4771;\n\tstatic final int MIDDLE_TREE \u003d 4772;\n\tstatic final int RIGHT_TREE \u003d 4773;\n\tstatic final int TEAK_STUMP \u003d 17;\n\tstatic final int MAHOGANY_STUMP \u003d 40;\n\n\tstatic final int TEAK_XP \u003d 85;\n\tstatic final int MAHOGANY_XP \u003d 125;\n\n\tstatic final int TEAK_RESPAWN \u003d 18;\n\tstatic final int MAHOGANY_RESPAWN \u003d 41;\n\n\t@Getter\n\tprivate final List\u003cTreeTimer\u003e treeTimerList \u003d new LinkedList\u003c\u003e();\n\n\tprivate int lastWoodcuttingXp \u003d 0;\n\tprivate boolean treeFell \u003d false;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate PatchTimerConfig config;\n\n\t@Inject\n\tprivate TimerOverlay overlay;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\toverlayManager.add(overlay);\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\toverlayManager.remove(overlay);\n\t\tthis.treeTimerList.clear();\n\t}\n\tprivate int lastFallenTreeId \u003d -1;\n\n\t@Subscribe\n\tpublic void onVarbitChanged(VarbitChanged event)\n\t{\n\t\tif ((event.getVarbitId() \u003d\u003d LEFT_TREE || event.getVarbitId() \u003d\u003d MIDDLE_TREE || event.getVarbitId() \u003d\u003d RIGHT_TREE)\n\t\t\t\t\u0026\u0026 (event.getValue() \u003d\u003d TEAK_STUMP || event.getValue() \u003d\u003d MAHOGANY_STUMP)){\n\t\t\ttreeFell \u003d true;\n\t\t\tlastFallenTreeId\u003d event.getVarbitId();\n\t\t\tlog.debug(\"Tree Fell: ID \u003d \" + lastFallenTreeId);\n\t\t}\n\t}\n\t@Subscribe\n\tpublic void onStatChanged(StatChanged statChanged) {\n\t\tif (statChanged.getSkill() !\u003d Skill.WOODCUTTING) {\n\t\t\treturn;\n\t\t}\n\t\tint woodcuttingXp \u003d statChanged.getXp();\n\t\tint skillGained \u003d woodcuttingXp - lastWoodcuttingXp;\n\t\tlastWoodcuttingXp \u003d woodcuttingXp;\n\n\t\tif (treeFell \u0026\u0026 lastFallenTreeId !\u003d -1)\n\t\t{\n\t\t\tint teakRespawn \u003d config.getAssumeTick() ? TEAK_RESPAWN -1 : TEAK_RESPAWN;\n\t\t\tint mahoganyRespawn \u003d config.getAssumeTick() ? MAHOGANY_RESPAWN -1 : MAHOGANY_RESPAWN;\n\n\t\t\tif (isInRange(skillGained, TEAK_XP)) {\n\t\t\t\tlog.debug(\"Single Teak log\");\n\t\t\t\taddTreeTimer(lastFallenTreeId, teakRespawn);\n\t\t\t}\n\t\t\telse if (isInRange(skillGained, MAHOGANY_XP)) {\n\t\t\t\tlog.debug(\"Single Mahogany log\");\n\t\t\t\taddTreeTimer(lastFallenTreeId, mahoganyRespawn);\n\t\t\t}\n\t\telse if (isInRange(skillGained, TEAK_XP * 2)) {\n\t\tlog.debug(\"Double Teak log\");\n\t\taddTreeTimer(lastFallenTreeId, TEAK_RESPAWN);\n\t\t}\n\n\t\telse if (isInRange(skillGained, MAHOGANY_XP * 2)) {\n\t\tlog.debug(\"Double Mahogany log\");\n\t\taddTreeTimer(lastFallenTreeId, MAHOGANY_RESPAWN);\n\t\t\t}\n\t\t\ttreeFell \u003d false;\n\t\t\tlastFallenTreeId \u003d -1;\n\t\t}\n\t}\nprivate void addTreeTimer(int treeId, int respawnDuration)\n{\n\tWorldPoint treeLocation \u003d getTreeLocation(treeId);\n\tif (treeLocation !\u003d null)\n\t{\n\t\ttreeTimerList.add(new TreeTimer(treeLocation, respawnDuration));\n\t\tlog.debug(\"Added TreeTimer for Tree ID \" + treeId + \" at \" + treeLocation + \" with respawn duration \" + respawnDuration);\n\t}\n\telse\n\t{\n\t\tlog.warn(\"Tree ID \" + treeId + \" does not have a mapped location!\");\n\t}\n}\n\nprivate WorldPoint getTreeLocation(int treeId)\n{\n\tswitch (treeId)\n\t{\n\t\tcase LEFT_TREE:\n\t\t\treturn new WorldPoint(3715, 3835, 0);\n\t\tcase MIDDLE_TREE:\n\t\t\treturn new WorldPoint(3708, 3833, 0);\n\t\tcase RIGHT_TREE:\n\t\t\treturn new WorldPoint(3702, 3837, 0);\n\t\tdefault:\n\t\t\treturn null;\n\t}\n}\n\t@Subscribe\n\tpublic void onGameTick(GameTick event){\n\t\t\tthis.treeTimerList.removeIf(TreeTimer -\u003e {\n\t\t\t\tTreeTimer.decrement();\n\t\t\t\treturn TreeTimer.getTicksLeft() \u003c 0;\n\t\t\t});\n\t}\nprivate boolean isInRange(int value, int base)\n{\n\treturn value \u003e\u003d base \u0026\u0026 value \u003c\u003d base * 1.13;\n}\n\t@Provides\n\tPatchTimerConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(PatchTimerConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\patchtimer\\PatchTimerPlugin.java"},{"fileName":"TimerOverlay.java","content":"package com.patchtimer;\n\nimport com.google.inject.Inject;\nimport net.runelite.api.*;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Rectangle2D;\n\npublic class TimerOverlay extends Overlay{\n    private final PatchTimerPlugin plugin;\n    private final PatchTimerConfig config;\n    private final Client client;\n\n    @Inject\n    TimerOverlay(PatchTimerPlugin plugin, PatchTimerConfig config, Client client ){\n    setPosition(OverlayPosition.DYNAMIC);\n    setLayer(OverlayLayer.ABOVE_SCENE);\n    this.plugin \u003d plugin;\n    this.config \u003d config;\n    this.client \u003d client;\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        final int backgroundSize \u003d this.config.getBackgroundSize();\n        final Color colorBackground \u003d this.config.getBackgroundColor();\n        final Color colorText \u003d this.config.getTextColor();\n        final Color tick_early_color \u003d this.config.getTick_early_color();\n        final Color tick_perfect_color \u003d this.config.getTick_perfect_color();\n        final Color tick_late_color \u003d this.config.getTick_late_color();\n\n        this.plugin.getTreeTimerList().forEach(TreeTimer -\u003e {\n            final String text \u003d TreeTimer.getTicksLeftDisplay();\n            final LocalPoint localPoint \u003d LocalPoint.fromWorld(this.client, TreeTimer.getLocation());\n            if (localPoint !\u003d null){\n                final Color color;\n                final int counter \u003d TreeTimer.getTicksLeft();\n\n                if (counter \u003d\u003d 3)\n                {\n                    color \u003d tick_early_color;\n                }\n                else if (counter \u003d\u003d 2)\n                {\n                    color \u003d tick_perfect_color;\n                }\n                else if (counter \u003d\u003d 1)\n                {\n                    color \u003d tick_late_color;\n                }\n                else {\n                    color \u003d colorText;\n                }\n\n                final Point point \u003d Perspective.getCanvasTextLocation(this.client, graphics, localPoint, text, 0);\n                Rectangle2D textBounds \u003d graphics.getFontMetrics().getStringBounds(text, graphics);\n                this.drawTextBackground(graphics, point, colorBackground, textBounds, backgroundSize);\n                this.drawText(graphics, point, color, text);\n            }\n\n        });\n        return null;\n    }\n    private void drawTextBackground(Graphics2D graphics, Point point, Color color, Rectangle2D textBounds, int size) {\n        graphics.setColor(color);\n\n        final int x \u003d (int) (point.getX() - ((double) size / 2) + (textBounds.getWidth() / 2));\n        final int y \u003d (int) (point.getY() - ((double) size / 2) - (textBounds.getHeight() / 2));\n\n        graphics.fillRect(x, y, size, size);\n    }\n    private void drawText(Graphics2D graphics, Point point, Color color, String text) {\n        final int x \u003d point.getX();\n        final int y \u003d point.getY();\n        graphics.setColor(color);\n        graphics.drawString(text, x, y);\n    }\n}","filePath":"src\\main\\java\\com\\patchtimer\\TimerOverlay.java"},{"fileName":"TreeTimer.java","content":"package com.patchtimer;\n\nimport lombok.Getter;\nimport net.runelite.api.coords.WorldPoint;\n\n\n@Getter\npublic class TreeTimer{\n    private final WorldPoint location;\n    private String ticksLeftDisplay;\n    private int ticksLeft;\n\n    TreeTimer(WorldPoint location, int respawnTime) {\n        this.ticksLeft \u003d respawnTime;\n        this.ticksLeftDisplay \u003d \"\" + this.ticksLeft;\n        this.location \u003d location;\n    }\n\n    public void decrement() {\n        this.ticksLeftDisplay \u003d \"\" + --this.ticksLeft;\n    }\n}\n","filePath":"src\\main\\java\\com\\patchtimer\\TreeTimer.java"},{"fileName":"PatchTimerPluginTest.java","content":"package com.patchtimer;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class PatchTimerPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(PatchTimerPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\patchtimer\\PatchTimerPluginTest.java"}]},{"commit":"c07263b542e966e3f1fcd3c1c9cb56becb42f27d","repository":"https://github.com/Maurits825/snake.git","internalName":"snake","files":[{"fileName":"SnakeConfig.java","content":"package com.snake;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Range;\n\n@ConfigGroup(SnakeConfig.GROUP)\npublic interface SnakeConfig extends Config\n{\n\tString GROUP \u003d \"snakeConfig\";\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"gameSize\",\n\t\tname \u003d \"Game size\",\n\t\tdescription \u003d \"The size of the game.\",\n\t\tposition \u003d 0\n\t)\n\t@Range(min \u003d 1, max \u003d 30)\n\tdefault int gameSize()\n\t{\n\t\treturn 2;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"allowRun\",\n\t\tname \u003d \"Allow run\",\n\t\tdescription \u003d \"Allow running.\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean allowRun()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"gridTheme\",\n\t\tname \u003d \"Grid theme\",\n\t\tdescription \u003d \"The theme of the grid.\",\n\t\tposition \u003d 2\n\t)\n\tdefault SnakeGridTheme gridTheme()\n\t{\n\t\treturn SnakeGridTheme.ORIGINAL;\n\t}\n\n\t@ConfigSection(\n\t\tname \u003d \"Multiplayer options\",\n\t\tdescription \u003d \"Refer to the readme via support link for more info.\",\n\t\tposition \u003d 3\n\t)\n\tString multiplayerOptionsSection \u003d \"multiplayerOptionsSection\";\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"enableMultiplayer\",\n\t\tname \u003d \"Enable multiplayer\",\n\t\tdescription \u003d \"Enable multiplayer mode.\",\n\t\tposition \u003d 0,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault boolean enableMultiplayer()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"seed\",\n\t\tname \u003d \"Seed\",\n\t\tdescription \u003d \"The seed used to randomize spawn locations.\",\n\t\tposition \u003d 1,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault int seed()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"isSameFoodSpawn\",\n\t\tname \u003d \"Same food spawn\",\n\t\tdescription \u003d \"If enabled all players have the same food spawn location, otherwise it is per player.\",\n\t\tposition \u003d 2,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault boolean isSameFoodSpawn()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showAllFood\",\n\t\tname \u003d \"Show all food\",\n\t\tdescription \u003d \"Show all food spawns if same food spawn is enabled.\",\n\t\tposition \u003d 3,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault boolean showAllFood()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"playerNames\",\n\t\tname \u003d \"Player names\",\n\t\tdescription \u003d \"RSN of all the players participating, as comma separated list.\",\n\t\tposition \u003d 4,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault String playerNames()\n\t{\n\t\treturn \"\";\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"addPlayerMenuEntry\",\n\t\tname \u003d \"Show add player menu\",\n\t\tdescription \u003d \"Show add player menu on players.\",\n\t\tposition \u003d 5,\n\t\tsection \u003d multiplayerOptionsSection\n\t)\n\tdefault boolean addPlayerMenuEntry()\n\t{\n\t\treturn false;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeConfig.java"},{"fileName":"SnakeController.java","content":"package com.snake;\n\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.TreeSet;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\n\n@Slf4j\n@Singleton\npublic class SnakeController\n{\n\tpublic static final String READY_MESSAGE \u003d \"r\";\n\n\tpublic enum State\n\t{\n\t\tIDLE,\n\t\tWAITING_TO_START,\n\t\tREADY,\n\t\tPLAYING,\n\t\tGAME_OVER,\n\t}\n\n\tprivate static final List\u003cColor\u003e PLAYER_COLORS \u003d Arrays.asList(\n\t\tColor.BLUE, Color.YELLOW, Color.MAGENTA, Color.CYAN, Color.RED\n\t);\n\tprivate static final int READY_COUNTDOWN_TICKS \u003d 5;\n\tprivate static final int MAX_RANDOM_POINT_TRIES \u003d 100;\n\n\tprivate final Client client;\n\n\t@Getter\n\tprivate State currentState \u003d State.IDLE;\n\n\t@Getter\n\tprivate List\u003cSnakePlayer\u003e snakePlayers;\n\t@Getter\n\tprivate boolean[][] walkableTiles;\n\n\tprivate WorldPoint wallStartPoint;\n\tprivate int gameSize;\n\tprivate boolean allowRun;\n\tprivate boolean isSameFoodSpawn;\n\n\tprivate int readyCount;\n\t@Getter\n\tprivate int readyTickCountdown;\n\tprivate int deadCount;\n\tprivate int gameOverDeadCount;\n\n\tprivate Random generator;\n\n\t@Inject\n\tpublic SnakeController(Client client)\n\t{\n\t\tthis.client \u003d client;\n\t}\n\n\tpublic void initialize(List\u003cString\u003e playerNames, int gameSize, boolean allowRun, boolean isMultiplayer, boolean isSameFoodSpawn, int seed)\n\t{\n\t\tthis.wallStartPoint \u003d SnakeUtils.getWallStartPoint(client.getLocalPlayer().getWorldLocation(), gameSize);\n\t\tthis.gameSize \u003d gameSize;\n\t\tthis.allowRun \u003d allowRun;\n\t\tthis.isSameFoodSpawn \u003d isSameFoodSpawn;\n\t\tgenerator \u003d new Random(isMultiplayer ? seed : System.nanoTime());\n\n\t\treset();\n\n\t\tList\u003cPlayer\u003e players \u003d client.getPlayers();\n\t\tString currentPlayer \u003d client.getLocalPlayer().getName();\n\t\twalkableTiles \u003d getWalkableTiles(wallStartPoint.dx(1).dy(-1));\n\n\t\tint colorIndex \u003d 0;\n\t\tTreeSet\u003cString\u003e uniquePlayerNames \u003d new TreeSet\u003c\u003e(playerNames);\n\t\tfor (String playerName : uniquePlayerNames)\n\t\t{\n\t\t\tPlayer player \u003d SnakeUtils.findPlayer(players, playerName);\n\t\t\tif (player !\u003d null)\n\t\t\t{\n\t\t\t\tboolean isActivePlayer \u003d playerName.equals(currentPlayer);\n\t\t\t\tColor color \u003d PLAYER_COLORS.get(colorIndex);\n\t\t\t\tif (isActivePlayer)\n\t\t\t\t{\n\t\t\t\t\tcolor \u003d Color.GREEN;\n\t\t\t\t}\n\t\t\t\tsnakePlayers.add(new SnakePlayer(player, color, isActivePlayer));\n\t\t\t\tcolorIndex \u003d (colorIndex + 1) % PLAYER_COLORS.size();\n\t\t\t}\n\t\t}\n\n\t\tgameOverDeadCount \u003d snakePlayers.size() - (isMultiplayer \u0026\u0026 snakePlayers.size() !\u003d 1 ? 1 : 0);\n\n\t\tif (!isMultiplayer)\n\t\t{\n\t\t\tsnakePlayers.get(0).setReady(true);\n\t\t\treadyTickCountdown \u003d READY_COUNTDOWN_TICKS;\n\t\t\tcurrentState \u003d State.READY;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurrentState \u003d State.WAITING_TO_START;\n\t\t}\n\t}\n\n\tpublic void reset()\n\t{\n\t\tsnakePlayers \u003d new ArrayList\u003c\u003e();\n\t\treadyCount \u003d 0;\n\t\treadyTickCountdown \u003d 0;\n\t\tdeadCount \u003d 0;\n\t\tthis.currentState \u003d State.IDLE;\n\t}\n\n\tpublic void tick()\n\t{\n\t\tState nextState \u003d currentState;\n\t\tswitch (currentState)\n\t\t{\n\t\t\tcase WAITING_TO_START:\n\t\t\t\tnextState \u003d waiting();\n\t\t\t\tbreak;\n\t\t\tcase READY:\n\t\t\t\tnextState \u003d ready();\n\t\t\t\tbreak;\n\t\t\tcase PLAYING:\n\t\t\t\tnextState \u003d playing();\n\t\t\t\tbreak;\n\t\t\tcase IDLE:\n\t\t\tcase GAME_OVER:\n\t\t\t\tbreak;\n\t\t}\n\t\tcurrentState \u003d nextState;\n\t}\n\n\tpublic void handleChatMessage(String playerName, String message)\n\t{\n\t\tif (currentState \u003d\u003d State.WAITING_TO_START \u0026\u0026 message.equals(READY_MESSAGE))\n\t\t{\n\t\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t\t{\n\t\t\t\tif (snakePlayer.getPlayerName().equals(playerName) \u0026\u0026 !snakePlayer.isReady())\n\t\t\t\t{\n\t\t\t\t\tsnakePlayer.setReady(true);\n\t\t\t\t\treadyCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate State waiting()\n\t{\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tsnakePlayer.updateLocation();\n\t\t\tsnakePlayer.moveSnakeTrail();\n\t\t}\n\n\t\tif (readyCount \u003d\u003d snakePlayers.size())\n\t\t{\n\t\t\treadyTickCountdown \u003d READY_COUNTDOWN_TICKS;\n\t\t\treturn State.READY;\n\t\t}\n\t\treturn currentState;\n\t}\n\n\tprivate State ready()\n\t{\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tsnakePlayer.updateLocation();\n\t\t\tsnakePlayer.moveSnakeTrail();\n\t\t}\n\n\t\treadyTickCountdown--;\n\t\tsetAllOverheadText(String.valueOf(readyTickCountdown));\n\t\tif (readyTickCountdown \u003d\u003d 0)\n\t\t{\n\t\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t\t{\n\t\t\t\tsnakePlayer.fillInitialSnakeTrail();\n\t\t\t}\n\t\t\tsetAllOverheadText(\"Go!\");\n\n\t\t\trespawnAllFood();\n\t\t\treturn State.PLAYING;\n\t\t}\n\t\treturn currentState;\n\t}\n\n\tprivate State playing()\n\t{\n\t\tupdateAllPlayers();\n\n\t\tif (deadCount \u003e\u003d gameOverDeadCount)\n\t\t{\n\t\t\treturn State.GAME_OVER;\n\t\t}\n\n\t\tupdatePlayersOnFood();\n\t\tupdateAllSnakeTrails();\n\n\t\treturn currentState;\n\t}\n\n\tprivate void updateAllPlayers()\n\t{\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tif (snakePlayer.isAlive())\n\t\t\t{\n\t\t\t\tsnakePlayer.updateLocation();\n\t\t\t\tboolean isAlive \u003d checkValidMovement(snakePlayer);\n\t\t\t\tif (!isAlive)\n\t\t\t\t{\n\t\t\t\t\tsnakePlayer.setAlive(false);\n\t\t\t\t\tdeadCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updatePlayersOnFood()\n\t{\n\t\tList\u003cSnakePlayer\u003e onFoodPlayers \u003d new ArrayList\u003c\u003e();\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tif (snakePlayer.isAlive() \u0026\u0026 snakePlayer.getCurrentLocation().equals(snakePlayer.getFoodLocation()))\n\t\t\t{\n\t\t\t\tonFoodPlayers.add(snakePlayer);\n\t\t\t}\n\t\t}\n\n\t\tif (onFoodPlayers.size() \u003e\u003d 1)\n\t\t{\n\t\t\tif (isSameFoodSpawn)\n\t\t\t{\n\t\t\t\tint randomIndex \u003d generator.nextInt(onFoodPlayers.size());\n\t\t\t\tSnakePlayer snakePlayerGrow \u003d onFoodPlayers.get(randomIndex);\n\t\t\t\tsnakePlayerGrow.setShouldGrow(true);\n\t\t\t\tsnakePlayerGrow.increaseScore();\n\t\t\t\tsnakePlayerGrow.setOverHeadText(\"+1\");\n\t\t\t\trespawnAllFood();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (SnakePlayer snakePlayerGrow : onFoodPlayers)\n\t\t\t\t{\n\t\t\t\t\tsnakePlayerGrow.setShouldGrow(true);\n\t\t\t\t\tsnakePlayerGrow.setOverHeadText(\"+1\");\n\t\t\t\t\tsnakePlayerGrow.increaseScore();\n\t\t\t\t\tsnakePlayerGrow.setFoodLocation(getRandomPointInGrid());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateAllSnakeTrails()\n\t{\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tif (snakePlayer.isAlive())\n\t\t\t{\n\t\t\t\tsnakePlayer.moveSnakeTrail();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean checkValidMovement(SnakePlayer snakePlayer)\n\t{\n\t\tWorldPoint playerWorldPosition \u003d snakePlayer.getCurrentLocation();\n\t\tboolean inGameBoundary \u003d\n\t\t\tplayerWorldPosition.getX() \u003e wallStartPoint.getX() \u0026\u0026\n\t\t\t\tplayerWorldPosition.getX() \u003c\u003d (wallStartPoint.getX() + gameSize) \u0026\u0026\n\t\t\t\tplayerWorldPosition.getY() \u003c wallStartPoint.getY() \u0026\u0026\n\t\t\t\tplayerWorldPosition.getY() \u003e\u003d (wallStartPoint.getY() - gameSize);\n\n\t\tif (!inGameBoundary)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!allowRun \u0026\u0026 snakePlayer.isRunning())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn !checkCollision(snakePlayer);\n\t}\n\n\tprivate boolean checkCollision(SnakePlayer sPlayer)\n\t{\n\t\tWorldPoint playerLocation \u003d sPlayer.getCurrentLocation();\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tfor (WorldPoint trailPoint : snakePlayer.getSnakeTrail())\n\t\t\t{\n\t\t\t\tif (trailPoint.equals(playerLocation))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void setAllOverheadText(String text)\n\t{\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tsnakePlayer.setOverHeadText(text);\n\t\t}\n\t}\n\n\tprivate void respawnAllFood()\n\t{\n\t\tif (isSameFoodSpawn)\n\t\t{\n\t\t\tWorldPoint foodLocation \u003d getRandomPointInGrid();\n\t\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t\t{\n\t\t\t\tsnakePlayer.setFoodLocation(foodLocation);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t\t{\n\t\t\t\tsnakePlayer.setFoodLocation(getRandomPointInGrid());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate WorldPoint getRandomPointInGrid()\n\t{\n\t\tWorldPoint randomPoint;\n\t\tint x;\n\t\tint y;\n\t\tint count \u003d 0;\n\t\tdo\n\t\t{\n\t\t\tx \u003d generator.nextInt(gameSize);\n\t\t\ty \u003d generator.nextInt(gameSize);\n\t\t\trandomPoint \u003d wallStartPoint.dx(x + 1).dy(-(y + 1));\n\t\t\tcount++;\n\t\t} while (count \u003c MAX_RANDOM_POINT_TRIES \u0026\u0026 !isFoodSpawnValid(randomPoint, x, y));\n\n\t\treturn randomPoint;\n\t}\n\n\tprivate boolean isFoodSpawnValid(WorldPoint point, int x, int y)\n\t{\n\t\tif (!walkableTiles[x][y])\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tif (point.equals(snakePlayer.getFoodLocation()))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean[][] getWalkableTiles(WorldPoint gridStart)\n\t{\n\t\tboolean[][] walkable \u003d new boolean[gameSize][gameSize];\n\n\t\tint[][] flags \u003d client.getCollisionMaps()[client.getPlane()].getFlags();\n\t\tLocalPoint gridStartInScene \u003d SnakeUtils.getWorldPointLocationInScene(client, gridStart);\n\t\tfor (int x \u003d 0; x \u003c gameSize; ++x)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c gameSize; ++y)\n\t\t\t{\n\t\t\t\tint data \u003d flags[x + gridStartInScene.getX()][gridStartInScene.getY() - y];\n\t\t\t\twalkable[x][y] \u003d data \u003d\u003d 0;\n\t\t\t}\n\t\t}\n\t\treturn walkable;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeController.java"},{"fileName":"SnakeGridTheme.java","content":"package com.snake;\n\nimport lombok.Getter;\n\n@Getter\npublic enum SnakeGridTheme\n{\n\tORIGINAL(32693, -1, -1),\n\tTOA(-1, 45510, 45432);\n\n\tprivate final int wallModelId;\n\tprivate final int tileModelId1;\n\tprivate final int tileModelId2;\n\n\tSnakeGridTheme(int wallModelId, int tileModelId1, int tileModelId2)\n\t{\n\t\tthis.wallModelId \u003d wallModelId;\n\t\tthis.tileModelId1 \u003d tileModelId1;\n\t\tthis.tileModelId2 \u003d tileModelId2;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeGridTheme.java"},{"fileName":"SnakeOverlay.java","content":"package com.snake;\n\nimport static com.snake.SnakeController.READY_MESSAGE;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport javax.inject.Inject;\nimport static net.runelite.api.MenuAction.RUNELITE_OVERLAY;\nimport static net.runelite.api.MenuAction.RUNELITE_OVERLAY_CONFIG;\nimport static net.runelite.client.ui.overlay.OverlayManager.OPTION_CONFIGURE;\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.LineComponent;\nimport net.runelite.client.ui.overlay.components.TitleComponent;\n\nclass SnakeOverlay extends OverlayPanel\n{\n\n\tprivate final SnakeController snakeController;\n\n\t@Inject\n\tSnakeOverlay(SnakePlugin plugin, SnakeController snakeController)\n\t{\n\t\tsuper(plugin);\n\t\tthis.snakeController \u003d snakeController;\n\n\t\tsetPosition(OverlayPosition.TOP_LEFT);\n\t\taddMenuEntry(RUNELITE_OVERLAY, \"Start\", \"new game\");\n\t\taddMenuEntry(RUNELITE_OVERLAY_CONFIG, OPTION_CONFIGURE, \"Snake\");\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tSnakeController.State currentState \u003d snakeController.getCurrentState();\n\t\tString status \u003d getStatusText(currentState);\n\n\t\tpanelComponent.getChildren().add(TitleComponent.builder()\n\t\t\t.text(\"Snake - \" + status)\n\t\t\t.build());\n\n\t\tif (currentState \u003d\u003d SnakeController.State.WAITING_TO_START ||\n\t\t\tcurrentState \u003d\u003d SnakeController.State.READY ||\n\t\t\tcurrentState \u003d\u003d SnakeController.State.PLAYING ||\n\t\t\tcurrentState \u003d\u003d SnakeController.State.GAME_OVER)\n\t\t{\n\t\t\tbuildScoreOverlay(currentState);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"shift right-click to start a new game\")\n\t\t\t\t.build());\n\t\t}\n\n\t\treturn super.render(graphics);\n\t}\n\n\tprivate void buildScoreOverlay(SnakeController.State currentState)\n\t{\n\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t.left(\"Score\")\n\t\t\t.build());\n\n\t\tfor (SnakePlayer snakePlayer : snakeController.getSnakePlayers())\n\t\t{\n\t\t\tString rightText \u003d (currentState \u003d\u003d SnakeController.State.GAME_OVER ? \"Win: \" : \"\") + snakePlayer.getScore();\n\t\t\tif (currentState \u003d\u003d SnakeController.State.WAITING_TO_START)\n\t\t\t{\n\t\t\t\trightText \u003d snakePlayer.isReady() ? \"R\" : \"-\";\n\t\t\t}\n\t\t\telse if (!snakePlayer.isAlive())\n\t\t\t{\n\t\t\t\trightText \u003d \"Dead: \" + snakePlayer.getScore();\n\t\t\t}\n\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(snakePlayer.getPlayerName())\n\t\t\t\t.leftColor(snakePlayer.isAlive() ? snakePlayer.getColor() : Color.DARK_GRAY)\n\t\t\t\t.right(rightText)\n\t\t\t\t.build());\n\n\t\t\tif (!snakePlayer.isReady() \u0026\u0026 snakePlayer.isActivePlayer())\n\t\t\t{\n\t\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t\t.left(\"Type \" + READY_MESSAGE + \" in chat to ready!\")\n\t\t\t\t\t.leftColor(Color.RED)\n\t\t\t\t\t.build());\n\t\t\t}\n\t\t}\n\n\t\tif (currentState \u003d\u003d SnakeController.State.READY)\n\t\t{\n\t\t\tint tickCountDown \u003d snakeController.getReadyTickCountdown();\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(tickCountDown \u003d\u003d 0 ? \"Go!\" : \"Starting in \" + snakeController.getReadyTickCountdown())\n\t\t\t\t.build());\n\t\t}\n\t}\n\n\tprivate String getStatusText(SnakeController.State state)\n\t{\n\t\tswitch (state)\n\t\t{\n\t\t\tcase IDLE:\n\t\t\t\treturn \"Idle\";\n\t\t\tcase WAITING_TO_START:\n\t\t\t\treturn \"Waiting\";\n\t\t\tcase READY:\n\t\t\t\treturn \"Get Ready!\";\n\t\t\tcase PLAYING:\n\t\t\t\treturn \"Playing\";\n\t\t\tcase GAME_OVER:\n\t\t\t\treturn \"Game Over\";\n\t\t\tdefault:\n\t\t\t\treturn \"-\";\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeOverlay.java"},{"fileName":"SnakePlayer.java","content":"package com.snake;\n\nimport java.awt.Color;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport lombok.Getter;\nimport lombok.Setter;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.util.ColorUtil;\n\npublic class SnakePlayer\n{\n\tprivate static final int INITIAL_TRAIL_SIZE \u003d 2;\n\n\t@Getter\n\tprivate WorldPoint currentLocation;\n\tprivate WorldPoint previousLocation;\n\n\t@Getter\n\tprivate boolean isAlive;\n\t@Getter\n\t@Setter\n\tprivate boolean isReady;\n\n\tprivate final Player player;\n\t@Getter\n\tprivate final String playerName;\n\t@Getter\n\tprivate final Color color;\n\t@Getter\n\tprivate final boolean isActivePlayer;\n\n\t@Setter\n\tprivate boolean shouldGrow;\n\n\t@Getter\n\tprivate final Queue\u003cWorldPoint\u003e snakeTrail \u003d new ArrayDeque\u003c\u003e();\n\t@Getter\n\t@Setter\n\tprivate WorldPoint foodLocation;\n\n\t@Getter\n\t@Setter\n\tprivate int score;\n\n\tpublic SnakePlayer(Player player, Color color, boolean isActivePlayer)\n\t{\n\t\tthis.player \u003d player;\n\t\tthis.color \u003d color;\n\t\tthis.isActivePlayer \u003d isActivePlayer;\n\t\tthis.score \u003d INITIAL_TRAIL_SIZE;\n\n\t\tcurrentLocation \u003d player.getWorldLocation();\n\t\tpreviousLocation \u003d currentLocation;\n\t\tisAlive \u003d true;\n\t\tplayerName \u003d player.getName();\n\t\tisReady \u003d false;\n\n\t\tshouldGrow \u003d false;\n\n\t\tsnakeTrail.add(currentLocation);\n\t\tfoodLocation \u003d null;\n\t}\n\n    public void setOverHeadText(String text)\n\t{\n\t\tsetOverHeadText(text, 50);\n\t}\n\n\tpublic void setOverHeadText(String text, int duration)\n\t{\n\t\tplayer.setOverheadCycle(duration);\n\t\tplayer.setOverheadText(ColorUtil.wrapWithColorTag(text, color));\n\t}\n\n\tpublic void fillInitialSnakeTrail()\n\t{\n\t\tfor (int i \u003d 0; i \u003c INITIAL_TRAIL_SIZE - 1; i++)\n\t\t{\n\t\t\tsnakeTrail.add(player.getWorldLocation());\n\t\t}\n\t}\n\n\tpublic void increaseScore()\n\t{\n\t\tscore++;\n\t}\n\n\tpublic void updateLocation()\n\t{\n\t\tpreviousLocation \u003d currentLocation;\n\t\tcurrentLocation \u003d player.getWorldLocation();\n\t}\n\n\tpublic void moveSnakeTrail()\n\t{\n\t\tif (shouldGrow)\n\t\t{\n\t\t\tsnakeTrail.add(currentLocation);\n\t\t\tshouldGrow \u003d false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsnakeTrail.poll();\n\t\t\tsnakeTrail.add(currentLocation);\n\t\t}\n\t}\n\n\tpublic void setAlive(boolean isAlive)\n\t{\n\t\tthis.isAlive \u003d isAlive;\n\t\tif (!isAlive)\n\t\t{\n\t\t\tsetOverHeadText(\"Game Over!\");\n\t\t\tplayer.setAnimation(2925);\n\t\t\tplayer.setAnimationFrame(0);\n\t\t\tsnakeTrail.clear();\n\t\t}\n\t}\n\n\tpublic boolean isRunning()\n\t{\n\t\treturn previousLocation.distanceTo(currentLocation) \u003e 1;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakePlayer.java"},{"fileName":"SnakePlugin.java","content":"package com.snake;\n\nimport com.google.inject.Provides;\nimport java.awt.Color;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.MenuAction;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.MenuOptionClicked;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.events.OverlayMenuClicked;\nimport net.runelite.client.menus.MenuManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.ui.overlay.OverlayMenuEntry;\nimport net.runelite.client.util.ColorUtil;\nimport net.runelite.client.util.Text;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Snake\",\n\tdescription \u003d \"Play snake in game!\"\n)\npublic class SnakePlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate SnakeConfig config;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate Provider\u003cMenuManager\u003e menuManager;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate SnakeOverlay overlay;\n\n\t@Inject\n\tprivate SnakeController snakeController;\n\n\t@Inject\n\tprivate SnakeView snakeView;\n\n\tprivate static final String ADD_PLAYER_MENU \u003d ColorUtil.wrapWithColorTag(\"Add snake player\", Color.GREEN);\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\toverlayManager.add(overlay);\n\n\t\tif (config.addPlayerMenuEntry() \u0026\u0026 client !\u003d null)\n\t\t{\n\t\t\tmenuManager.get().addPlayerMenuItem(ADD_PLAYER_MENU);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\toverlayManager.remove(overlay);\n\t\tclientThread.invokeLater(() -\u003e\n\t\t{\n\t\t\tresetGame();\n\t\t\treturn true;\n\t\t});\n\n\t\tif (client !\u003d null)\n\t\t{\n\t\t\tmenuManager.get().removePlayerMenuItem(ADD_PLAYER_MENU);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick tick)\n\t{\n\t\tsnakeController.tick();\n\t\tsnakeView.update();\n\t}\n\n\t@Subscribe\n\tpublic void onMenuOptionClicked(MenuOptionClicked event)\n\t{\n\t\tif (event.getMenuAction() \u003d\u003d MenuAction.RUNELITE_PLAYER \u0026\u0026 event.getMenuOption().equals(ADD_PLAYER_MENU))\n\t\t{\n\t\t\tString playerName \u003d event.getMenuEntry().getPlayer().getName();\n\t\t\tString newPlayerNames \u003d config.playerNames() + \",\" + playerName;\n\t\t\tconfigManager.setConfiguration(SnakeConfig.GROUP, \"playerNames\", newPlayerNames);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tresetGame();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage event)\n\t{\n\t\tif (event.getType() \u003d\u003d ChatMessageType.PUBLICCHAT)\n\t\t{\n\t\t\tString playerName \u003d Text.sanitize(Text.removeTags(event.getName()));\n\t\t\tString message \u003d Text.sanitize(Text.removeTags(event.getMessage())).toLowerCase();\n\t\t\tsnakeController.handleChatMessage(playerName, message);\n\t\t}\n\t}\n\n\tprivate void initializeGame()\n\t{\n\t\tresetGame();\n\n\t\tList\u003cString\u003e playerNames \u003d config.enableMultiplayer() ?\n\t\t\tText.fromCSV(config.playerNames()) : Collections.singletonList(client.getLocalPlayer().getName());\n\t\tsnakeController.initialize(playerNames, getGameSize(), config.allowRun(), config.enableMultiplayer(), config.isSameFoodSpawn(), config.seed());\n\t\tsnakeView.initialize(snakeController.getSnakePlayers(), getGameSize(), config.gridTheme(), snakeController.getWalkableTiles(), config.isSameFoodSpawn(), config.showAllFood());\n\t}\n\n\tprivate void resetGame()\n\t{\n\t\tsnakeController.reset();\n\t\tsnakeView.reset();\n\t}\n\n\n\tprivate int getGameSize()\n\t{\n\t\treturn 1 + 2 * config.gameSize();\n\t}\n\n\t@Subscribe\n\tpublic void onOverlayMenuClicked(OverlayMenuClicked overlayMenuClicked)\n\t{\n\t\tOverlayMenuEntry overlayMenuEntry \u003d overlayMenuClicked.getEntry();\n\t\tif (overlayMenuEntry.getMenuAction() \u003d\u003d MenuAction.RUNELITE_OVERLAY\n\t\t\t\u0026\u0026 overlayMenuClicked.getEntry().getOption().equals(\"Start\")\n\t\t\t\u0026\u0026 overlayMenuClicked.getOverlay() \u003d\u003d overlay)\n\t\t{\n\t\t\tinitializeGame();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\t\tif (configChanged.getGroup().equals(SnakeConfig.GROUP))\n\t\t{\n\t\t\tclientThread.invokeLater(() -\u003e\n\t\t\t{\n\t\t\t\tresetGame();\n\t\t\t\treturn true;\n\t\t\t});\n\n\t\t\tif (client !\u003d null)\n\t\t\t{\n\t\t\t\tmenuManager.get().removePlayerMenuItem(ADD_PLAYER_MENU);\n\n\t\t\t\tif (config.addPlayerMenuEntry())\n\t\t\t\t{\n\t\t\t\t\tmenuManager.get().addPlayerMenuItem(ADD_PLAYER_MENU);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Provides\n\tSnakeConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(SnakeConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakePlugin.java"},{"fileName":"SnakeUtils.java","content":"package com.snake;\n\nimport java.util.List;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.Player;\nimport net.runelite.api.Tile;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\n\npublic class SnakeUtils\n{\n\tpublic static WorldPoint getWallStartPoint(WorldPoint playerWorldPosition, int gameSize)\n\t{\n\t\tint offset \u003d (int) Math.ceil(gameSize / 2.0f);\n\t\treturn playerWorldPosition.dx(-offset).dy(offset);\n\t}\n\n\tpublic static LocalPoint getWorldPointLocationInScene(Client client, WorldPoint worldPoint)\n\t{\n\t\tTile[][][] tiles \u003d client.getScene().getTiles();\n\t\tint z \u003d client.getPlane();\n\t\tfor (int x \u003d 0; x \u003c Constants.SCENE_SIZE; ++x)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c Constants.SCENE_SIZE; ++y)\n\t\t\t{\n\t\t\t\tTile tile \u003d tiles[z][x][y];\n\t\t\t\tif (tile.getWorldLocation().equals(worldPoint))\n\t\t\t\t{\n\t\t\t\t\treturn new LocalPoint(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static Player findPlayer(List\u003cPlayer\u003e players, String name)\n\t{\n\t\tfor (Player player : players)\n\t\t{\n\t\t\tif (name.equals(player.getName()))\n\t\t\t{\n\t\t\t\treturn player;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeUtils.java"},{"fileName":"SnakeView.java","content":"package com.snake;\n\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport javax.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.JagexColor;\nimport net.runelite.api.Model;\nimport net.runelite.api.ModelData;\nimport net.runelite.api.RuneLiteObject;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\n\npublic class SnakeView\n{\n\tprivate final Client client;\n\n\tprivate List\u003cSnakePlayer\u003e snakePlayers;\n\tprivate int gameSize;\n\tprivate boolean[][] walkableTiles;\n\tprivate SnakeGridTheme theme;\n\tprivate boolean isSameFoodSpawn;\n\tprivate boolean showAllFood;\n\n\tprivate final Map\u003cSnakePlayer, List\u003cRuneLiteObject\u003e\u003e snakePlayerTrails \u003d new HashMap\u003c\u003e();\n\tprivate final List\u003cRuneLiteObject\u003e walls \u003d new ArrayList\u003c\u003e();\n\tprivate final List\u003cRuneLiteObject\u003e tiles \u003d new ArrayList\u003c\u003e();\n\tprivate final List\u003cRuneLiteObject\u003e foods \u003d new ArrayList\u003c\u003e();\n\n\tprivate WorldPoint wallStartPoint;\n\n\tprivate static final int TRAIL_MODEL_ID \u003d 29311;\n\tprivate static final int FOOD_MODEL_ID \u003d 2317;\n\n\tprivate static final Color DEFAULT_FOOD_COLOR \u003d new Color(186, 16, 225);\n\n\t@Inject\n\tpublic SnakeView(Client client)\n\t{\n\t\tthis.client \u003d client;\n\t}\n\n\tpublic void initialize(List\u003cSnakePlayer\u003e snakePlayers, int gameSize, SnakeGridTheme theme, boolean[][] walkableTiles, boolean isSameFoodSpawn, boolean showAllFood)\n\t{\n\t\tthis.snakePlayers \u003d snakePlayers;\n\t\tthis.gameSize \u003d gameSize;\n\t\tthis.theme \u003d theme;\n\t\tthis.walkableTiles \u003d walkableTiles;\n\t\tthis.isSameFoodSpawn \u003d isSameFoodSpawn;\n\t\tthis.showAllFood \u003d showAllFood;\n\n\t\twallStartPoint \u003d SnakeUtils.getWallStartPoint(client.getLocalPlayer().getWorldLocation(), gameSize);\n\n\t\tif (theme.getWallModelId() !\u003d -1)\n\t\t{\n\t\t\tspawnWalls();\n\t\t}\n\t\tif (theme.getTileModelId1() !\u003d -1 \u0026\u0026 theme.getTileModelId2() !\u003d -1)\n\t\t{\n\t\t\tspawnGridTiles();\n\t\t}\n\n\t\tspawnFoods();\n\t}\n\n\tpublic void update()\n\t{\n\t\tupdateFoodObjects();\n\t\tupdateSnakeTrails();\n\t}\n\n\tpublic void reset()\n\t{\n\t\tclearAll(Arrays.asList(tiles, walls, foods));\n\t\tclearSnakeTrails();\n\n\t\tsnakePlayers \u003d null;\n\t}\n\n\tprivate void updateSnakeTrails()\n\t{\n\t\tif (snakePlayers \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t{\n\t\t\tif (snakePlayer.isAlive())\n\t\t\t{\n\t\t\t\tif (!snakePlayerTrails.containsKey(snakePlayer))\n\t\t\t\t{\n\t\t\t\t\tsnakePlayerTrails.put(snakePlayer, new ArrayList\u003c\u003e());\n\t\t\t\t}\n\n\t\t\t\tList\u003cRuneLiteObject\u003e snakeObjectTrail \u003d snakePlayerTrails.get(snakePlayer);\n\t\t\t\tQueue\u003cWorldPoint\u003e snakePointTrail \u003d snakePlayer.getSnakeTrail();\n\t\t\t\tfor (int i \u003d 0; i \u003c\u003d (snakePointTrail.size() - snakeObjectTrail.size()); i++)\n\t\t\t\t{\n\t\t\t\t\tsnakeObjectTrail.add(spawnSnakeTrailObject(snakePlayer.getColor()));\n\t\t\t\t}\n\n\t\t\t\tint index \u003d 0;\n\t\t\t\tfor (WorldPoint point : snakePointTrail)\n\t\t\t\t{\n\t\t\t\t\tRuneLiteObject obj \u003d snakeObjectTrail.get(index);\n\t\t\t\t\tLocalPoint lp \u003d LocalPoint.fromWorld(client, point);\n\t\t\t\t\tobj.setLocation(lp, client.getPlane());\n\t\t\t\t\tif (!obj.isActive())\n\t\t\t\t\t{\n\t\t\t\t\t\tobj.setActive(true);\n\t\t\t\t\t}\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse if (snakePlayerTrails.containsKey(snakePlayer))\n\t\t\t{\n\t\t\t\tfor (RuneLiteObject rlObject : snakePlayerTrails.get(snakePlayer))\n\t\t\t\t{\n\t\t\t\t\trlObject.setActive(false);\n\t\t\t\t}\n\t\t\t\tsnakePlayerTrails.remove(snakePlayer);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateFoodObjects()\n\t{\n\t\tif (snakePlayers \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (isSameFoodSpawn)\n\t\t{\n\t\t\tdrawFoodAtLocation(foods.get(0), snakePlayers.get(0).getFoodLocation());\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i \u003d 0; i \u003c snakePlayers.size(); i++)\n\t\t\t{\n\t\t\t\tif (showAllFood)\n\t\t\t\t{\n\t\t\t\t\tdrawFoodAtLocation(foods.get(i), snakePlayers.get(i).getFoodLocation());\n\t\t\t\t}\n\t\t\t\telse if (snakePlayers.get(i).isActivePlayer())\n\t\t\t\t{\n\t\t\t\t\tdrawFoodAtLocation(foods.get(0), snakePlayers.get(i).getFoodLocation());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void drawFoodAtLocation(RuneLiteObject food, WorldPoint location)\n\t{\n\t\tif (location \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfood.setLocation(LocalPoint.fromWorld(client, location), client.getPlane());\n\t\tif (!food.isActive())\n\t\t{\n\t\t\tfood.setActive(true);\n\t\t}\n\t}\n\n\tprivate void spawnWalls()\n\t{\n\t\tfor (int x \u003d 0; x \u003c gameSize + 2; x++)\n\t\t{\n\t\t\twalls.add(spawnWallObject(wallStartPoint.dx(x)));\n\t\t}\n\n\t\tfor (int x \u003d 0; x \u003c gameSize + 2; x++)\n\t\t{\n\t\t\twalls.add(spawnWallObject(wallStartPoint.dx(x).dy(-gameSize - 1)));\n\t\t}\n\n\t\tfor (int y \u003d 0; y \u003c gameSize; y++)\n\t\t{\n\t\t\twalls.add(spawnWallObject(wallStartPoint.dy(-y - 1)));\n\t\t}\n\n\t\tfor (int y \u003d 0; y \u003c gameSize; y++)\n\t\t{\n\t\t\twalls.add(spawnWallObject(wallStartPoint.dx(gameSize + 1).dy(-y - 1)));\n\t\t}\n\t}\n\n\tprivate void spawnGridTiles()\n\t{\n\t\tint tileObjectId;\n\t\tfor (int x \u003d 0; x \u003c gameSize; x++)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c gameSize; y++)\n\t\t\t{\n\t\t\t\tif ((x + y) % 2 \u003d\u003d 0)\n\t\t\t\t{\n\t\t\t\t\ttileObjectId \u003d theme.getTileModelId1();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttileObjectId \u003d theme.getTileModelId2();\n\t\t\t\t}\n\n\t\t\t\tif (walkableTiles[x][y])\n\t\t\t\t{\n\t\t\t\t\ttiles.add(spawnGridTileObject(wallStartPoint.dx(x + 1).dy(-(y + 1)), tileObjectId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void spawnFoods()\n\t{\n\t\tif (isSameFoodSpawn || !showAllFood || snakePlayers.size() \u003d\u003d 1)\n\t\t{\n\t\t\tfoods.add(spawnFoodObject(DEFAULT_FOOD_COLOR));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (SnakePlayer snakePlayer : snakePlayers)\n\t\t\t{\n\t\t\t\tfoods.add(spawnFoodObject(snakePlayer.getColor()));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void clearAll(List\u003cList\u003cRuneLiteObject\u003e\u003e allObjectLists)\n\t{\n\t\tfor (List\u003cRuneLiteObject\u003e objectList : allObjectLists)\n\t\t{\n\t\t\tfor (RuneLiteObject obj : objectList)\n\t\t\t{\n\t\t\t\tobj.setActive(false);\n\t\t\t}\n\t\t\tobjectList.clear();\n\t\t}\n\t}\n\n\tprivate void clearSnakeTrails()\n\t{\n\t\tsnakePlayerTrails.forEach((snakePlayer, runeLiteObjects) -\u003e {\n\t\t\tfor (RuneLiteObject runeLiteObject : runeLiteObjects)\n\t\t\t{\n\t\t\t\truneLiteObject.setActive(false);\n\t\t\t}\n\t\t});\n\t\tsnakePlayerTrails.clear();\n\t}\n\n\tprivate RuneLiteObject spawnSnakeTrailObject(Color color)\n\t{\n\t\tRuneLiteObject obj \u003d client.createRuneLiteObject();\n\t\tModelData trailModel \u003d client.loadModelData(TRAIL_MODEL_ID).cloneColors();\n\n\t\ttrailModel.recolor(trailModel.getFaceColors()[0],\n\t\t\tJagexColor.rgbToHSL(color.getRGB(), 0.01d));\n\t\ttrailModel.recolor(trailModel.getFaceColors()[1],\n\t\t\tJagexColor.rgbToHSL(color.getRGB(), 1.0d));\n\n\t\tobj.setModel(trailModel.light());\n\n\t\treturn obj;\n\t}\n\n\tprivate RuneLiteObject spawnWallObject(WorldPoint point)\n\t{\n\t\tRuneLiteObject obj \u003d client.createRuneLiteObject();\n\n\t\tModel wall \u003d client.loadModel(theme.getWallModelId());\n\t\tobj.setModel(wall);\n\t\tLocalPoint lp \u003d LocalPoint.fromWorld(client, point);\n\t\tobj.setLocation(lp, client.getPlane());\n\t\tobj.setActive(true);\n\t\treturn obj;\n\t}\n\n\tprivate RuneLiteObject spawnGridTileObject(WorldPoint point, int tileObjectId)\n\t{\n\t\tRuneLiteObject obj \u003d client.createRuneLiteObject();\n\n\t\tModel tile \u003d client.loadModel(tileObjectId);\n\t\tobj.setModel(tile);\n\t\tLocalPoint lp \u003d LocalPoint.fromWorld(client, point);\n\t\tobj.setLocation(lp, client.getPlane());\n\n\t\tobj.setActive(true);\n\t\treturn obj;\n\t}\n\n\tprivate RuneLiteObject spawnFoodObject(Color color)\n\t{\n\t\tRuneLiteObject obj \u003d client.createRuneLiteObject();\n\n\t\tModelData foodModel \u003d client.loadModelData(FOOD_MODEL_ID)\n\t\t\t.cloneVertices()\n\t\t\t.translate(0, 200, 0)\n\t\t\t.cloneColors();\n\t\tfoodModel.recolor(foodModel.getFaceColors()[0],\n\t\t\tJagexColor.rgbToHSL(color.getRGB(), 1.0d));\n\t\tobj.setModel(foodModel.light());\n\n\t\tobj.setAnimation(client.loadAnimation(502));\n\t\tobj.setShouldLoop(true);\n\n\t\tobj.setDrawFrontTilesFirst(true);\n\n\t\treturn obj;\n\t}\n}\n","filePath":"src\\main\\java\\com\\snake\\SnakeView.java"},{"fileName":"SnakePluginTest.java","content":"package com.snake;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class SnakePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(SnakePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\snake\\SnakePluginTest.java"}]},{"commit":"4f554f97d5b2bacff54f74677b8713953e473dfb","repository":"https://github.com/kanderson66/Calculator-Pro.git","internalName":"calculator-pro","files":[{"fileName":"CalculatorProConfig.java","content":"/*\n * Copyright (c) 2023,  \u003chttps://github.com/kanderson66/Calculator-Pro\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\n\n@ConfigGroup(\"calculatorpro\")\npublic interface CalculatorProConfig extends Config {\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"panel\",\n\t\t\tname \u003d \"Panel Active\",\n\t\t\tdescription \u003d \"Configures whether to turn the Calculator panel on or off\"\n\t)\n\tdefault boolean panelActive()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"calculate\",\n\t\t\tname \u003d \"Calculator Command\",\n\t\t\tdescription \u003d \"Configures whether the Calculator command is enabled  !calc 3*4\"\n\t)\n\tdefault boolean calcCommand()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"numDecimals\",\n\t\t\tname \u003d \"Decimals to Display\",\n\t\t\tdescription \u003d \"Configures how many decimal places to display on the Calculator chat result (max 15)\"\n\t)\n\tdefault int numDecimals() {\n\t\treturn 3;\n\t}\n\n\t//Make section for instructions, so they can be collapsible\n\t@ConfigSection(\n\t\t\tname \u003d \"Instructions/Features\",\n\t\t\tdescription \u003d \"How to use the calculator in the chatbox\",\n\t\t\tposition \u003d 4,\n\t\t\tclosedByDefault \u003d false\n\t)\n\tString instructionSection \u003d \"instructions\";\n\n\t//STRING VALUE (TEXTBOX) collapsible instructions\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"instructions\",\n\t\t\tname \u003d \"Instructions\",\n\t\t\tdescription \u003d \"How to use the calculator in the chatbox\",\n\t\t\tsection \u003d instructionSection\n\t)\n\tdefault String instructions()\n\t{\n\t\treturn \"Call the calculator through the chatbox using the !calc command:\" +\n\t\t\t\t\"\\n!calc 2+3\\n\\n\" +\n\t\t\t\t\"You can create a tag for the result: \\n!calc [tagName] 2+3\\n\\n\" +\n\t\t\t\t\"You can reference tags in your equation:\\n\" +\n\t\t\t\t\"!calc 5*tagName+3\\n\\n\" +\n\t\t\t\t\"Handles complex calculations:\\n!calc 5*((tagName+2)-lvl90+1.3m)\\n\\n\" +\n\t\t\t\t\"For a complete set of included commands and tags, see the Pre-set Tags and Commands infobox below\"\n\t\t\t\t;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Custom Tags\",\n\t\t\tdescription \u003d \"Text-based custom tags\",\n\t\t\tposition \u003d 6,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString customTagsSection \u003d \"Custom Tags\";\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"customTags\",\n\t\t\tname \u003d \"Custom Tags\",\n\t\t\tdescription \u003d \"Tags to use in the calculator\",\n\t\t\tsection \u003d customTagsSection,\n\t\t\tposition \u003d 7\n\t)\n\tdefault String customTags() {\n\t\treturn \"tag1\u003d123\\n\" +\n\t\t\t\t\"oak\u003d37.5\\n\" +\n\t\t\t\t\"xp\u003doak+tag1\\n\" +\n\t\t\t\t\"func(x,y)\u003dy*2+x+oak\\n\\n\" +\n\t\t\t\t\"###\\n\" +\n\t\t\t\t\"Insert tags above this line, notes below this line\"\n\t\t\t\t+\"\\n\\nTags should look like this:\\n\"\n\t\t\t\t+\"tagName\u003d###\\n\\n\" +\n\t\t\t\t\"Where \\\"tagName\\\" is at least 1 letter, and can contain letters and numbers, but no symbols\"\n\t\t\t\t+\"\\n\\nYou can then reference these tags in your equation\\n\" +\n\t\t\t\t\"!calc 4*tagName\\n\\n\"\n\t\t\t\t+ \"Also supports custom functions. Define a function and its varables:\\n\"\n\t\t\t\t+ \"func(x,y)\u003dx+y+oak*3\\n\\n\"\n\t\t\t\t+ \"Then call it in-game, with the desired values:\\n\" +\n\t\t\t\t\"!calc func(2,3)\";\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Custom Equation\",\n\t\t\tdescription \u003d \"Text-based custom equation\",\n\t\t\tposition \u003d 8,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString customEquationSection \u003d \"Custom Equation\";\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"customEquation\",\n\t\t\tname \u003d \"Custom Equation\",\n\t\t\tdescription \u003d \"Equation to execute by calling \\\"!calc\\\" with nothing after it\",\n\t\t\tsection \u003d customEquationSection,\n\t\t\tposition \u003d 9\n\t)\n\tdefault String customEquation() {\n\t\treturn \"[tag] (lvl99-lvl60)/oak\\n\\n\" +\n\t\t\t\t\"###\\nWrite the equation you want to execute on the top line of this textbox.\\n\\n\" +\n\t\t\t\t\"Execute this equation in-game by calling: \\n\" +\n\t\t\t\t\"!calc \\n\" +\n\t\t\t\t\"in-game with nothing after it\";\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Pre-set Tags and Commands\",\n\t\t\tdescription \u003d \"Ready-to-use Tags and Commands\",\n\t\t\tposition \u003d 10,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString presetTagsSection \u003d \"Pre-set Tags and Commands\";\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"presetTags\",\n\t\t\tname \u003d \"Preset Tags\",\n\t\t\tdescription \u003d \"Ready-to-use Tags and Commands\",\n\t\t\tsection \u003d presetTagsSection,\n\t\t\tposition \u003d 11\n\t)\n\tdefault String presetTags() {\n\t\treturn \"\"\n\t\t\t\t+ \"Math functions such as %, ^2, sqrt, sin, cos, tan are supported:\\n\"\n\t\t\t\t+ \"!calc sqrt(9^3)+5%\\n\\n\"\n\t\t\t\t+ \"Tags:\\n\"\n\t\t\t\t+ \"Include this tag to enter the result of the last calculation:\\n\"\n\t\t\t\t+ \"last\\n\"\n\t\t\t\t+ \"!calc last+200k\\n\\n\"\n\t\t\t\t+ \"Level Tags:\\n\"\n\t\t\t\t+ \"Include these tags to enter the xp for the desired lvl (1-126)\\n\"\n\t\t\t\t+ \"lvl1\\n\"\n\t\t\t\t+ \"lvl2\\n\"\n\t\t\t\t+ \"...\\n\"\n\t\t\t\t+ \"lvl126\\n\"\n\t\t\t\t+ \"!calc lvl90-lvl87\\n\\n\"\n\t\t\t\t+ \"Skill Current xp Tags:\\n\"\n\t\t\t\t+ \"Enter your current xp in the desired skill:\\n\"\n\t\t\t\t+ \"myatt OR myattack\\n\"\n\t\t\t\t+ \"!calc lvl90-myfm\\n\\n\"\n\t\t\t\t+ \"Commands:\\n\"\n                + \"Use the ge market price for an item: \\n\"\n                + \"!calc 500*!price raw shark\\n\\n\"\n\t\t\t\t+ \"Remove all user-created tags:\\n\"\n\t\t\t\t+ \"!calc !clear\\n\\n\"\n\t\t\t\t+ \"Remove a user-created tag:\\n\"\n\t\t\t\t+ \"!calc !remove tagName\\n\\n\"\n\t\t\t\t+ \"List all stored CustomTags or RunTimeTags:\\n\"\n\t\t\t\t+ \"!calc !list RunTimeTags\\n\"\n\t\t\t\t+ \"!calc !list CustomTags\"\n\t\t\t\t;\n\t}\n\n//\t@ConfigSection(\n//\t\t\tname \u003d \"Update Log\",\n//\t\t\tdescription \u003d \"Update Log\",\n//\t\t\tposition \u003d 12,\n//\t\t\tclosedByDefault \u003d true\n//\t)\n//\tString updateLogSection \u003d \"Update Log\";\n//\t@ConfigItem(\n//\t\t\tkeyName \u003d \"updateLog\",\n//\t\t\tname \u003d \"Update Log\",\n//\t\t\tdescription \u003d \"Update Log\",\n//\t\t\tsection \u003d updateLogSection,\n//\t\t\tposition \u003d 13\n//\t)\n//\tdefault String updateLog() {\n//\t\treturn \"Apr 2025\\n\" +\n//\t\t\t\t\"     -Current xp Lookup\\n\" +\n//\t\t\t\t\"     -Config Panel Updated\\n\\n\" +\n//\t\t\t\t\"Dec 2023\\n\" +\n//\t\t\t\t\"     -Scientific Notation\\n\" +\n//\t\t\t\t\"     -lvl100 to lvl126 pre-sets added\\n\\n\" +\n//\t\t\t\t\"Apr 2023\\n\" +\n//\t\t\t\t\"     -Plugin Created\\n\\n\\n\" +\n//\t\t\t\t\"Click \u0027Reset\u0027 button below to get all updated notes and info from developer\\n\\n\" +\n//\t\t\t\t\"NOTE:\\n\" +\n//\t\t\t\t\"This will delete ALL custom tags, equations and notes you may have stored in any infoboxes in this config panel\"\n//\t\t\t\t;\n//\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Bugs/Improvements\",\n\t\t\tdescription \u003d \"Bugs/Improvements\",\n\t\t\tposition \u003d 12,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString bugsSection \u003d \"Bugs/Improvements\";\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"bugs/Improvements\",\n\t\t\tname \u003d \"Bugs/Improvements\",\n\t\t\tdescription \u003d \"Bugs/Improvements\",\n\t\t\tsection \u003d bugsSection,\n\t\t\tposition \u003d 13\n\t)\n\tdefault String bugsImprovements() {\n\t\treturn \"Please submit any bugs or improvement requests to:\\n\\n\" +\n\t\t\t\t\"https://github.com/kanderson66/Calculator-Pro/issues\"\n\t\t\t\t;\n\t}\n}","filePath":"src\\main\\java\\com\\calculatorpro\\CalculatorProConfig.java"},{"fileName":"CalculatorProPlugin.java","content":"/*\n * Copyright (c) 2023,  \u003chttps://github.com/kanderson66/Calculator-Pro\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro;\n\nimport com.google.inject.Provides;\nimport net.runelite.api.Client;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.MessageNode;\nimport net.runelite.client.chat.ChatColorType;\nimport net.runelite.client.chat.ChatCommandManager;\nimport net.runelite.client.chat.ChatMessageBuilder;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\n\nimport javax.inject.Inject;\n//import java.io.IOException;\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.calculatorpro.uiSpedwards.CalculatorPluginPanel;\n\nimport java.awt.image.BufferedImage;\n\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\n//import java.io.InputStream;\n//import javax.imageio.ImageIO;\nimport net.runelite.client.util.ImageUtil;\nimport net.runelite.api.Skill;    //to get current xp in a skill\nimport net.runelite.client.game.ItemManager; //lookup item price \u0026 alch\nimport net.runelite.http.api.item.ItemPrice; //lookup item price\nimport net.runelite.client.config.RuneLiteConfig;\nimport net.runelite.api.ItemComposition;    //lookup alch price\n\n////auto equate\n//import net.runelite.client.chat.ChatMessageManager;\n//import net.runelite.api.ChatMessageType;\n\n@PluginDescriptor(\n        name \u003d \"Calculator Pro\",\n        description \u003d \"Perform calculations using the side panel or in-game chat commands\",\n        tags \u003d {\"calculator\", \"math\", \"chat\", \"command\", \"text\"}\n)\npublic class CalculatorProPlugin extends Plugin {\n    //calc panel from Spedwards\n    @Inject\n    private ClientToolbar clientToolbar;\n    private NavigationButton navButton;\n    //end calc panel from Spedwards\n    @Inject\n    private CalculatorProConfig config;\n    @Inject\n    private ChatCommandManager chatCommandManager;\n    @Inject\n    private Client client;\n    @Inject\n    private ItemManager itemManager;\n    @Inject\n    private RuneLiteConfig runeLiteConfig;\n\n//\t//auto equate\n//\t@Inject\n//\tprivate ChatMessageManager chatMessageManager;\n\n    private static final String CALCULATE_STRING \u003d \"!calc\";\n    private static final String PRICE_COMMAND_STRING \u003d \"!price\";\n    private static final String ALCH_COMMAND_STRING \u003d \"!alch\";\n\n    //store xp values of each lvl (lvl 1-126)\n    final HashMap\u003cString, String\u003e lvlTags \u003d new HashMap\u003c\u003e();\n    //store custom tags from config panel\n    final HashMap\u003cString, String\u003e configTags \u003d new HashMap\u003c\u003e();\n    //store tags made by user during runtime (last, etc)\n    final HashMap\u003cString, String\u003e runTimeTags \u003d new HashMap\u003c\u003e();\n    //store skill current xp values\n    final HashMap\u003cString, String\u003e SkillTags \u003d new HashMap\u003c\u003e();\n\n    //store whether the panel is currently active or not\n    boolean panelActive \u003d false;\n\n    //track autoTag values\n    boolean needAutoTag;\n    int autoTag \u003d 0;\n\n    //ignore checking in runTimeTags if new tag is coming from Config textbox\n    boolean isConfigTag \u003d false;\n\n    //store the newTagName (after tagName is valid, wait for value to pass check)\n    String newTagName;\n    //Message to output (Error/result)\n    String output;\n    //Store equation from Config textbox\n    String customEquation \u003d \"\";\n\n    @Override\n    public void startUp() {\n        //load lvl xp tags (lvl 1-126)\n        loadLvlTags();\n        //load skill xp values\n        loadSkillTags();\n        //load runTime tags (default with a0-a9 with value 0)\n        loadRunTimeTags();\n        //load tags \u0026 equation from Config text boxes\n        reloadTags();\n\n        //watch for !calc keyword in chat, perform calculate function if found\n        chatCommandManager.registerCommandAsync(CALCULATE_STRING, this::calculate);\n\n        CalculatorPluginPanel panel \u003d new CalculatorPluginPanel();\n\n        BufferedImage icon \u003d ImageUtil.loadImageResource(getClass(), \"/icon.png\");\n\n        navButton \u003d NavigationButton.builder()\n                .tooltip(\"Calculator Pro\")\n                .priority(7)\n                .icon(icon)\n                .panel(panel)\n                .build();\n\n        if (config.panelActive()) {\n            clientToolbar.addNavigation(navButton);\n            panelActive \u003d true;\n        }\n    }\n\n    @Override\n    public void shutDown() {\n\n        chatCommandManager.unregisterCommand(CALCULATE_STRING);\n\n        //calc panel from Spedwards\n        if (panelActive) {\n            clientToolbar.removeNavigation(navButton);\n            panelActive \u003d false;\n        }\n        //end calc panel from Spedwards\n    }\n\n    //adds Calculator Pro to config panel\n    @Provides\n    CalculatorProConfig provideConfig(ConfigManager configManager) {\n        return configManager.getConfig(CalculatorProConfig.class);\n    }\n\n    //load tags for xp at each lvl (lvl1-lvl126)\n    public void loadLvlTags() {\n        //Formula from Wiki \u0027Experience\u0027 page (see \u0027Formula\u0027)\n        for (Integer lvl \u003d 1; lvl \u003c 127; lvl++) {\n            lvlTags.put(\"lvl\" + lvl, Integer.toString(Integer.valueOf((int) eval(\"(1/8)*(\" + lvl + \"^2-\" + lvl + \"+600*((2^(\" + lvl + \"/7)-2^(1/7)))/(2^(1/7)-1))-(\" + lvl + \"/10)\"))));\n        }\n    }\n\n    //load Skill tags, all starting at 0xp\n    public void loadSkillTags() {\n        SkillTags.put(\"myattack\", \"0\");\n        SkillTags.put(\"myatt\", \"0\");\n        SkillTags.put(\"myatk\", \"0\");\n        SkillTags.put(\"myhitpoints\", \"0\");\n        SkillTags.put(\"myhitpoint\", \"0\");\n        SkillTags.put(\"myhealth\", \"0\");\n        SkillTags.put(\"myhit\", \"0\");\n        SkillTags.put(\"myhp\", \"0\");\n        SkillTags.put(\"mymining\", \"0\");\n        SkillTags.put(\"mymine\", \"0\");\n        SkillTags.put(\"mystrength\", \"0\");\n        SkillTags.put(\"mystr\", \"0\");\n        SkillTags.put(\"myagility\", \"0\");\n        SkillTags.put(\"myagil\", \"0\");\n        SkillTags.put(\"myagi\", \"0\");\n        SkillTags.put(\"mysmithing\", \"0\");\n        SkillTags.put(\"mysmith\", \"0\");\n        SkillTags.put(\"mydefence\", \"0\");\n        SkillTags.put(\"mydef\", \"0\");\n        SkillTags.put(\"myherblore\", \"0\");\n        SkillTags.put(\"myherb\", \"0\");\n        SkillTags.put(\"myhl\", \"0\");\n        SkillTags.put(\"myfishing\", \"0\");\n        SkillTags.put(\"myfish\", \"0\");\n        SkillTags.put(\"myranged\", \"0\");\n        SkillTags.put(\"myrange\", \"0\");\n        SkillTags.put(\"myranging\", \"0\");\n        SkillTags.put(\"myrng\", \"0\");\n        SkillTags.put(\"mythieving\", \"0\");\n        SkillTags.put(\"mythieve\", \"0\");\n        SkillTags.put(\"mythief\", \"0\");\n        SkillTags.put(\"mycooking\", \"0\");\n        SkillTags.put(\"mycook\", \"0\");\n        SkillTags.put(\"myprayer\", \"0\");\n        SkillTags.put(\"mypray\", \"0\");\n        SkillTags.put(\"mycrafting\", \"0\");\n        SkillTags.put(\"mycraft\", \"0\");\n        SkillTags.put(\"myfiremaking\", \"0\");\n        SkillTags.put(\"myfire\", \"0\");\n        SkillTags.put(\"myfm\", \"0\");\n        SkillTags.put(\"mymagic\", \"0\");\n        SkillTags.put(\"mymage\", \"0\");\n        SkillTags.put(\"mymag\", \"0\");\n        SkillTags.put(\"myfletching\", \"0\");\n        SkillTags.put(\"myfletch\", \"0\");\n        SkillTags.put(\"mywoodcutting\", \"0\");\n        SkillTags.put(\"mywoodcut\", \"0\");\n        SkillTags.put(\"mywood\", \"0\");\n        SkillTags.put(\"mywc\", \"0\");\n        SkillTags.put(\"myrunecrafting\", \"0\");\n        SkillTags.put(\"myrc\", \"0\");\n        SkillTags.put(\"myrune\", \"0\");\n        SkillTags.put(\"myslayer\", \"0\");\n        SkillTags.put(\"myslay\", \"0\");\n        SkillTags.put(\"myfarming\", \"0\");\n        SkillTags.put(\"myfarm\", \"0\");\n        SkillTags.put(\"myconstruction\", \"0\");\n        SkillTags.put(\"myconstruct\", \"0\");\n        SkillTags.put(\"mycon\", \"0\");\n        SkillTags.put(\"myhunter\", \"0\");\n        SkillTags.put(\"myhunt\", \"0\");\n    }\n\n    //reserve last and a0-a9 tags for autoTag (not a hard reserve)\n    private void loadRunTimeTags() {\n        runTimeTags.put(\"last\", \"0\");\n\n        for (; autoTag \u003c 10; autoTag++) {\n            runTimeTags.put(\"a\" + autoTag, \"0\");\n        }\n        autoTag \u003d 0;\n    }\n\n    //detect change in Config textbox, update tags \u0026 equation\n    @Subscribe\n    public void onConfigChanged(ConfigChanged configChanged) {\n        if (configChanged.getGroup().equals(\"calculatorpro\")) {\n            reloadTags();\n\n            //auto equate check if custom equation changed (and !\u003d last custom equation or blank), output to chat (no !calc command needed)\n            //client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Example says \", null);\n//\t\t\tif (configChanged.getKey().equals(\"customEquation\")){\n//\t\t\t\tchatMessageManager.queue(\n//\t\t\t\t\t\tChatMessageType.GAMEMESSAGE,\n//\t\t\t\t\t\t\"\",\n//\t\t\t\t\t\t\"Custom equation updated to: \"\n//\t\t\t\t);\n//\t\t\t}\n\n            if (!config.panelActive() \u0026\u0026 panelActive) {\n                clientToolbar.removeNavigation(navButton);\n                panelActive \u003d false;\n            }\n            if (config.panelActive() \u0026\u0026 !panelActive) {\n                clientToolbar.addNavigation(navButton);\n                panelActive \u003d true;\n            }\n        }\n    }\n    //clear current config panel Tags \u0026 equation \u0026 update with new tags from Config Text boxes\n    private void reloadTags() {\n        configTags.clear();\n        customEquation \u003d \"\";\n\n        loadTags(config.customTags());\n        loadEquation(config.customEquation());\n    }\n\n    //load tags from Config text box\n    private void loadTags(String textbox) {\n        //HashMap\u003cString, String\u003e swaps \u003d new HashMap\u003cString, String\u003e();\n        for (String line : textbox.split(\"\\n\")) {\n            //get next line if this line is empty\n            if (line.trim().equals(\"\")) {\n                continue;\n            }\n            //end of tags, now entering notes\n            if (line.trim().contains(\"###\")) {\n                break;\n            }\n            line \u003d line.toLowerCase();\n            \n            if (line.contains(PRICE_COMMAND_STRING)) {\n                line \u003d priceLookup(line, PRICE_COMMAND_STRING);\n\n                if (line.charAt(0) \u003d\u003d \u0027E\u0027) {\n                    continue;\n                }\n            }\n            line \u003d line.replaceAll(\"\\\\s\", \"\");\n            //Split string between tag \u0026 value\n            String[] lineSplit \u003d line.split(\"\u003d\");\n\n            //check if tag has name (possibly empty) and value\n            if (lineSplit.length !\u003d 2) {\n                //\tSystem.out.println(\"no value\");\n                continue;\n            }\n\n            //CF Step 3: check if is custom function (will contain at least 1 ( and ) )\n            //check if name of custom function is valid func(2)\n            String name \u003d lineSplit[0];\n            String value \u003d lineSplit[1];\n            String funcValue \u003d \"\";\n\n            //if, it is a function declaration func(x) \u003d x\n            if (name.contains(\"(\") || name.contains(\")\")) {\n\n                //check # ) never above # (, and add ) if needed\n                List\u003cString\u003e compName \u003d tokenize(name);\n                if (compName.contains(\"(\") || compName.contains(\")\")) {\n                    //check # ) never above # (, and add ) if needed\n                    compName\u003dcheckParenth(compName);\n                    if (compName.get(0).contains(\"Error\")) {\n                        continue;\n                    }\n                    //merge list of strings back into single string\n                    name \u003d \"\";\n                    for (String s : compName) {\n                        name +\u003d s;\n                    }\n                }\n\n                //check Custom function variables names are valid\n                //extract variables from between the ( )    func(x,y) \u003e x,y\n                int start \u003d name.indexOf(\u0027(\u0027);\n                int end \u003d name.lastIndexOf(\u0027)\u0027);\n\n                //find # of variables in function\n                String variables \u003d name.substring(start + 1, end);\n                String[] varSplit \u003d variables.split(\",\");\n\n                //extract name of function before the (, then add number of variables in brackets func(2)\n                name \u003d name.substring(0, start).trim() + \"(\" + varSplit.length + \")\";\n\n                //validate the tag/function name\n                // config tag skips looking in runTime tags (replace it if exists, after value validated)\n                isConfigTag \u003d true;\n                if (!checkTagName(name)) {\n                    isConfigTag \u003d false;\n                    continue;\n                }\n                isConfigTag \u003d false;\n\n                boolean isError \u003d false;\n                for (String s : varSplit) {\n                    //ensure variable has a name\n                    if (s.isEmpty()) {\n                        output \u003d \"Error- no tag name\";\n                        //System.out.println(output);\n                        isError \u003d true;\n                        break;\n                    }\n                    //variable contains at least 1 letter\n                    if (!s.matches(\".*[a-z]+.*\")) {\n                        output \u003d \"Error- tag name/function (no letters): \\\"\" + s + \"\\\"\";\n                        //System.out.println(output);\n                        isError \u003d true;\n                        break;\n                    }\n\n                    //variable contains only letters and/or #s, and/or ()\n                    int len \u003d s.length();\n                    for (int i \u003d 0; i \u003c len; i++) {\n                        if (!(Character.isLetterOrDigit(s.charAt(i)) || s.charAt(i) \u003d\u003d \u0027(\u0027 || s.charAt(i) \u003d\u003d \u0027)\u0027)) {\n                            output \u003d \"Error- tag name (contains symbols): \\\"\" + s + \"\\\"\";\n                            //System.out.println(output);\n                            isError \u003d true;\n                            break;\n                        }\n                    }\n                }\n\n                //error with func variable, end processing config line\n                if (isError) {\n                    continue;\n                }\n\n                //Prepare custom function equation to pass check (replace variables with 1)\n                //prepare custom function for storage (replace custom variable names with var0, etc\n                //split equation into individual components\n\n                List\u003cString\u003e components \u003d tokenize(value);\n                List\u003cString\u003e funcComp \u003d tokenize(value);\n\n                for (int n \u003d 0; n \u003c varSplit.length; n++) {\n                    for (int m \u003d 0; m \u003c components.size(); m++) {\n                        if (varSplit[n].equals(components.get(m))) {\n                            components.set(m, \"1\");\n                            funcComp.set(m, \"var\" + n);\n                        }\n                    }\n                }\n\n                //func(x,y) \u003d splinters(x)*200\n                //splinters(var0)*200\n\n                //if a component has a letter and immediately followed by (, check if is a tag( or func( and replace as needed\n                for (int i \u003d 1; i \u003c components.size(); i++) {\n                    if (components.get(i).equals(\"(\") \u0026\u0026 components.get(i - 1).matches(\".*[a-zA-Z]+.*\")) {\n                        //System.out.println(\"Before entering Nested Functions: \" + components);\n                        components \u003d evaluateNestedFunctions(components);\n                        //System.out.println(\"After Nested Functions: \" + components);\n\n                        //System.out.println(\"Before entering Nested Functions: \" + funcComp);\n                        funcComp \u003d evaluateNestedFunctions(funcComp);\n                        //System.out.println(\"After Nested Functions: \" + funcComp);\n\n                        if (components.get(0).contains(\"Error\") || funcComp.get(0).contains(\"Error\")) {\n                            break;\n                        }\n                        //re-string all components, then properly re-tokenize (evalNestedFunc will string multiple components together)\n                        String tempComp \u003d \"\";\n                        String tempFuncComp \u003d \"\";\n                        for (int n\u003d0; n \u003c components.size(); n++) {\n                                tempComp +\u003d components.get(n);\n                                tempFuncComp +\u003d funcComp.get(n);\n                        }\n                        components \u003d tokenize(tempComp);\n                        funcComp \u003d tokenize(tempFuncComp);\n                        break;\n                    }\n                }\n                //get next line\n                if (components.get(0).contains(\"Error\")  || funcComp.get(0).contains(\"Error\")) {\n                    continue;\n                }\n                //recreate strings with variables replaced with 1\u0027s (value) and val0 val1 (funcValue)\n                for (int n \u003d 0; n \u003c components.size(); n++) {\n                    //this good to replace tags, but not functions in function definition\n                    //if components contains a letter, its a tag, evaluate value of tag and put in funcValue\n                    if (components.get(n).matches(\".*[a-z]+.*\")) {\n                        if(!mathFunction(components.get(n))) {\n                            //funcValue +\u003d checkEquation(components[n]);\n                            funcValue +\u003d evaluateTag(components.get(n));\n\n                            if (funcValue.contains(\"Error\")) {\n                                break;\n                            }\n\n                        }\n                        else {\n                            funcValue +\u003d components.get(n);\n                        }\n\n                        continue;\n                    }\n                    funcValue +\u003d funcComp.get(n);\n                }\n                value \u003d funcValue;                \n            } // not a function declaration, is a tag\n            else {\n\n                //validate the tag/function name\n                // config tag skips looking in runTime tags (replace it if exists, after value validated)\n                isConfigTag \u003d true;\n                if (!checkTagName(name)) {\n                    isConfigTag \u003d false;\n                    continue;\n                }\n                isConfigTag \u003d false;\n                //validate the value of the tag/function\n                //String correctedEquation \u003d checkEquation(value);\n                value \u003d checkEquation(value);\n\n                //Error with tag value- dont add\n                if (value.contains(\"Error\")) {\n                    //System.out.println(correctedEquation);\n                    continue;\n                }\n            }\n\n            if (value.contains(\"Error\")) {\n                continue;\n            }\n\n            //name, with function name being func(2), value being var1+var2*2\n            //add tag\n            configTags.put(name, value);\n\n            //System.out.println(\"Tag/Func added: \" + name + \" , \" + value);\n\n            //remove tag from runTimeTags if it exists\n            if (runTimeTags.get(name) !\u003d null) {\n                runTimeTags.remove(name);\n            }\n        }\n    }\n\n    //load equation from Config text box\n    private void loadEquation(String textbox) {\n        //add a new line incase user has equation on 1 line w/o any new lines\n        textbox \u003d textbox + \"\\n\";\n        String[] equation \u003d textbox.split(\"\\n\", 2);\n\n        customEquation \u003d equation[0];\n        if (customEquation.isEmpty()) {\n            customEquation \u003d \"Error- First line in Custom Equation box is empty\";\n            return;\n        }\n\n        //remove any capitals\n        customEquation \u003d customEquation.toLowerCase();\n\n        //replace !price keyword with value\n        if (customEquation.contains(PRICE_COMMAND_STRING)) {\n\n            customEquation \u003d priceLookup(customEquation, PRICE_COMMAND_STRING);\n\n            if (customEquation.charAt(0) \u003d\u003d \u0027E\u0027) {\n                customEquation \u003d \"Error- Custom Equation !price invalid\";\n                return;\n            }\n        }\n        //remove whitespace\n        customEquation \u003d customEquation.replaceAll(\"\\\\s\", \"\");\n    }\n\n    //check that the config or runTime [tag] is valid\n    private boolean checkTagName(String newTagString) {\n        /*\n            ERRORS TO CHECK\n            -value not # DONE\n            -value has spaces DONE\n            -tag name needs at least 1 letter DONE\n            -tag name contain only numbers and/or letters DONE\n            -tag name doesnt already exist DONE\n         */\n\n        //ensure tag has a name\n        if (newTagString.isEmpty()) {\n            output \u003d \"Error- no tag name\";\n            //System.out.println(output);\n            return false;\n        }\n        //tag name contains at least 1 letter\n        if (!newTagString.matches(\".*[a-z]+.*\")) {\n            output \u003d \"Error- tag name/function (no letters): \\\"\" + newTagString + \"\\\"\";\n            //System.out.println(output);\n            return false;\n        }\n\n        //tag name contains only letters and/or #s, and/or ()\n        int len \u003d newTagString.length();\n        for (int i \u003d 0; i \u003c len; i++) {\n            if (!(Character.isLetterOrDigit(newTagString.charAt(i)) || newTagString.charAt(i) \u003d\u003d \u0027(\u0027 || newTagString.charAt(i) \u003d\u003d \u0027)\u0027)) {\n                output \u003d \"Error- tag name (contains symbols): \\\"\" + newTagString + \"\\\"\";\n                //System.out.println(output);\n                return false;\n            }\n        }\n        //check if tag already exists\n        if (configTags.get(newTagString) !\u003d null)  {\n            output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" already exists in configTags\";\n            //System.out.println(output);\n            return false;\n        }\n        if (lvlTags.get(newTagString) !\u003d null)  {\n            output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" already exists in lvlTags\";\n            //System.out.println(output);\n            return false;\n        }\n        if (SkillTags.get(newTagString) !\u003d null)  {\n            output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" already exists in SkillTags\";\n            //System.out.println(output);\n            return false;\n        }\n        //config tag overrides tags in runTimeTags **all tags override runTimeTags\n//        if (!isConfigTag \u0026\u0026 runTimeTags.get(newTagString) !\u003d null) {\n//            output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" already exists\";\n//            //System.out.println(output);\n//            return false;\n//        }\n        //check if tag is reserved\n        switch (newTagString) {\n            case \"sqrt\":\n            case \"cos\":\n            case \"sin\":\n            case \"tan\":\n                output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" is reserved for math operations\";\n                //System.out.println(output);\n                return false;\n            case \"last\":\n            case \"a0\":\n            case \"a1\":\n            case \"a2\":\n            case \"a3\":\n            case \"a4\":\n            case \"a5\":\n            case \"a6\":\n            case \"a7\":\n            case \"a8\":\n            case \"a9\":\n                output \u003d \"Error- tag \\\"\" + newTagString + \"\\\" is reserved for default tags\";\n                //System.out.println(output);\n                return false;\n            default:\n                break;\n        }\n        return true;\n    }\n\n    //5 + 3 * !price uncut emerald + 2\n    private String priceLookup(String equation, String LOOKUP) {\n        List \u003cString\u003e newEquation \u003d tokenize(equation);\n        for (int n \u003d 0; n \u003c newEquation.size(); n++) {\n            if (newEquation.get(n).contains(LOOKUP)) {\n\n                //get beginning of element, up to LOOKUP\n                String header \u003d newEquation.get(n).substring(0, newEquation.get(n).indexOf(LOOKUP));\n\n                String message \u003d newEquation.get(n);\n                //!price uncut emerald\n                //if !calc !price item, tokenizer leave calc in, need include that\n                int offset \u003d message.indexOf(LOOKUP);\n\n                //!price with no item name after\n                if (message.trim().length() \u003c\u003d LOOKUP.length() + offset) {\n                    return \"Error- no item after \" + LOOKUP;\n                }\n\n                //+1 to account for space after !price\n                String search \u003d message.substring(LOOKUP.length() + offset).trim();\n                List\u003cItemPrice\u003e results \u003d itemManager.search(search);\n\n                if (!results.isEmpty()) {\n                    ItemPrice item \u003d retrieveFromList(results, search);\n\n                    //get alch price\n                    int itemId \u003d item.getId();\n                    //get item price\n                    int itemPrice \u003d runeLiteConfig.useWikiItemPrices() ? itemManager.getWikiPrice(item) : item.getPrice();\n\n                    //todo alch compatibility\n                    //ItemComposition itemComposition \u003d itemManager.getItemComposition(itemId);\n                    //final int alchPrice \u003d itemComposition.getHaPrice();\n\n                    String value \u003d \"\";\n                    if (LOOKUP.equals(PRICE_COMMAND_STRING)) {\n                        value \u003d String.valueOf(itemPrice);\n                    }\n                    else if (LOOKUP.equals(ALCH_COMMAND_STRING)) {\n                        //value \u003d String.valueOf(alchPrice);\n                    }\n\n                    value \u003d header + value;\n\n                    newEquation.remove(n);\n                    newEquation.add(n, value);\n                }\n                else {\n                    return \"Error- cant find item \" + search;\n                }\n            }\n        }\n        return String.join(\"\", newEquation);\n    }\n\n    private ItemPrice retrieveFromList(List\u003cItemPrice\u003e items, String originalInput)\n    {\n        ItemPrice shortest \u003d null;\n        for (ItemPrice item : items)\n        {\n            if (item.getName().toLowerCase().equals(originalInput.toLowerCase()))\n            {\n                return item;\n            }\n\n            if (shortest \u003d\u003d null || item.getName().length() \u003c shortest.getName().length())\n            {\n                shortest \u003d item;\n            }\n        }\n\n        // Take a guess\n        return shortest;\n    }\n\n    //perform all checks, commands, calculations and tagging\n    private void calculate(ChatMessage chatMessage, String message) {\n        //command turned off\n        if (!config.calcCommand()) {\n            return;\n        }\n        output \u003d \"\";\n        newTagName \u003d \"\";\n        needAutoTag \u003d false;\n        Double answer \u003d 0.0;\n\n        //reload custom tags \u0026 equation incase values in tags changed (gained xp, etc)\n        reloadTags();\n\n        String equation \u003d message.toLowerCase();\n        message \u003d message.substring(CALCULATE_STRING.length()).trim();\n\n        //replace price lookup with price\n        if (equation.contains(PRICE_COMMAND_STRING)) {\n            equation \u003d priceLookup(equation, PRICE_COMMAND_STRING);\n\n            if (equation.charAt(0) \u003d\u003d \u0027E\u0027) {\n                build(message, equation, answer.toString(), chatMessage);\n                return;\n            }\n        }\n\n        //replace alch lookup with alch amount (to be implemented later)\n        if (equation.contains(ALCH_COMMAND_STRING)) {\n            equation \u003d priceLookup(equation, ALCH_COMMAND_STRING);\n\n            if (equation.charAt(0) \u003d\u003d \u0027E\u0027) {\n                build(message, equation, answer.toString(), chatMessage);\n                return;\n            }\n        }\n\n\n        //remove any whitespaces in equation\t//DOESNT remove ,\n        equation \u003d equation.replaceAll(\"\\\\s\", \"\");\n\n        //remove !calc beginning\n        String[] split \u003d equation.split(CALCULATE_STRING);\n\n        //check if nothing entered after !calc\n        switch (split.length) {\n            case 0:\n                //check if Custom Equation was valid\n                if (customEquation.charAt(0) \u003d\u003d \u0027E\u0027) {\n                    build(message, customEquation, answer.toString(), chatMessage);\n                    return;\n                }\n                //get verified equation\n                equation \u003d customEquation;\n\n                //get equation from Custom Equation textbox in Config Panel\n                message \u003d config.customEquation();\n                message +\u003d \"\\n\";    //add new line incase only 1 line in panel\n                message \u003d message.split(\"\\n\", 2)[0].trim();    //grab only 1st line of panel\n                break;\n            case 2:\n                //success\n                //get equation from chatbox w/o !calc command\n                equation \u003d split[1];\n                break;\n            default:\n                //should never reach, but just for safety\n                build(message, \"Error- invalid entry\", answer.toString(), chatMessage);\n                return;\n        }\n\n        //check for header (!command or [tagName])\n        if (equation.charAt(0) \u003d\u003d \u0027!\u0027 || equation.charAt(0) \u003d\u003d \u0027[\u0027) {\n            equation \u003d checkHeaders(equation);\n            if (output.charAt(0) \u003d\u003d \u0027E\u0027 || output.equals(\"Command Complete\") || output.contains(\"Tags\")) {\n                //print output\n                build(message, output, answer.toString(), chatMessage);\n                return;\n            }\n        } //equation is removed of !calc and any !commands or [tagName]\n\n        //no [tagName] entered, add new autoTag\n        else {\n            needAutoTag \u003d true;\n        }\n\n        //check equation for errors, replace any tags needed\n        String correctedEquation \u003d checkEquation(equation);\n\n        //Check for error message\n        if (correctedEquation.contains(\"Error\")) {\n            correctedEquation \u003d errorStrip(correctedEquation);\n            build(message, correctedEquation, answer.toString(), chatMessage);\n            return;\n        }\n\n        //evaluate expression, remove any , present (NEEDED)\n        answer \u003d eval(correctedEquation.replaceAll(\",\", \"\"));\n        //answer \u003d eval(correctedEquation);\n\n        //check for divide by 0 error message (\"Infinity\")\n        if (answer.toString().charAt(0) \u003d\u003d \u0027I\u0027) {\n            build(message, correctedEquation, answer.toString(), chatMessage);\n            return;\n        }\n\n        //reduce answer to desired # decimal places or less \u0026 include commas for easier reading\n        String format \u003d \"#,###\";\n\n        if (config.numDecimals() \u003e 0) {\n            format +\u003d \".\";\n\n            //limit decimal points to 15 places\n            if (config.numDecimals() \u003e 15) {\n                for (int n \u003d 0; n \u003c 15; n++) {\n                    format +\u003d \"#\";\n                }\n            } else {\n                for (int n \u003d 0; n \u003c config.numDecimals(); n++) {\n                    format +\u003d \"#\";\n                }\n            }\n        }\n        DecimalFormat df \u003d new DecimalFormat(format);\n        df.setRoundingMode(RoundingMode.HALF_UP);\n\n        //update runTimeTags to include last \u0026 custom tag or default tag (a1-a9)\n        addNewTag(df.format(answer));\n\n        //output results\n        build(message, correctedEquation, \"[\" + newTagName + \"] \" + df.format(answer), chatMessage);\n    }\n\n    //check !command or [newTag] are valid\n    //returns just equation, no !command or [tagName]\n    public String checkHeaders(String input) {\n        //input is either [tagName] equation or !command ????\n        String[] split;\n\n        switch (input.charAt(0)) {\n            //check if new tag name \u0026 separate tag name from equation\n            case \u0027[\u0027:\n                split \u003d input.split(\"\\\\[\");\n                split \u003d split[1].split(\"]\");\n                //check if tag name was followed by ]\n                if (split.length \u003c 2) {\n                    output \u003d \"Error- missing \u0027]\u0027 or missing equation after \u0027]\u0027\";\n                    return input;\n                }\n                //remove whitespace from tag name\n                split[0] \u003d split[0].replaceAll(\"\\\\s\", \"\");\n                if (!checkTagName(split[0])) {\n                    return input;\n                } //split[0] has tagName split[1] has equation\n\n                //valid tag. Save name to assign if value also passes\n                newTagName \u003d split[0];\n                output \u003d split[1];\n                break;\n            case \u0027!\u0027:\n                //!clear command. Clear all saved values, but keep last if currently set\n                if (input.equals(\"!clear\")) {\n                    String temp \u003d \"0\";\n                    if (runTimeTags.get(\"last\") !\u003d null) {\n                        temp \u003d runTimeTags.get(\"last\");\n                    }\n                    runTimeTags.clear();\n                    loadRunTimeTags();\n                    runTimeTags.replace(\"last\", temp);\n                    autoTag \u003d 0;\n                    output \u003d \"Command Complete\";\n                    return input;\n                }\n                //!remove command\n                else if (input.charAt(1) \u003d\u003d \u0027r\u0027) {\n                    split \u003d input.split(\"!remove\");\n                    //nothing after !remove\n                    if (split.length !\u003d 2) {\n                        output \u003d \"Error- invalid command. Usage: !remove tagName\";\n                        return input;\n                    }\n\n                    //tagName not found in runTimeTags (cant remove tags from other HashMaps)\n                    if (runTimeTags.get(split[1]) \u003d\u003d null) {\n                        output \u003d \"Error- tagName not found in runTimeTags. Usage: !remove tagName\";\n                        return input;\n                    }\n                    //remove the desired tag from runTimeTags\n                    runTimeTags.remove(split[1]);\n                    output \u003d \"Command Complete\";\n                    return \"!remove \" + split[1];\n                } //end !remove command\n                else if (input.charAt(1) \u003d\u003d \u0027l\u0027) {\n                    split \u003d input.split(\"!list\");\n                    //nothing after !list\n                    if (split.length !\u003d 2) {\n                        output \u003d \"Error- invalid command.\\nUsage: !list RunTimeTags or !list CustomTags\";\n                        return input;\n                    }\n                    if (split[1].equals(\"runtimetags\")) {\n                        output \u003d \"RunTimeTags: \\n\" + runTimeTags.toString();\n                        return input;\n                    }\n                    else if (split[1].equals(\"customtags\")) {\n                        output \u003d \"CustomTags: \\n\" + configTags.toString();\n                        return input;\n                    }\n                    output \u003d \"Error- invalid command.\\nUsage: !list RunTimeTags or !list CustomTags\";\n                    return input;\n                }\n                else {\n                    output \u003d \"Error- unknown command\";\n                    return input;\n                }\n            default:\n                //should never reach\n                output \u003d \"Error- headers\";\n                return input;\n        }//end switch 1st character\n        //returns the equation w/o headers\n        return output;\n    }\n\n    //check equation will evaluate properly (no illegal characters or tags, etc)\n    //input just equation (no !command or [tagName])\n    public String checkEquation(String input) {\n\n        //check no illegal characters or spaces\n        //remove any math symbols\n        Pattern p \u003d Pattern.compile(\"(.{1})\");\n        Matcher m \u003d p.matcher(\"(),.+-/*^%\");\n        String temp \u003d input.replaceAll(m.replaceAll(\"\\\\\\\\$1\\\\|\"), \"\");\n\n\n        //check if remaining are just letters and #s\n        int len \u003d temp.length();\n        for (int i \u003d 0; i \u003c len; i++) {\n            if (!Character.isLetterOrDigit(temp.charAt(i))) {\n                output \u003d \"Error- unsupported symbols\";\n                return output;\n            }\n        }\n        //split equation into individual components\n        //String[] components \u003d input.split(\"(?\u003c\u003d[-+*/^()\\\\[\\\\]])|(?\u003d[-+*/^()\\\\[\\\\]])\");\n        List\u003cString\u003e components \u003d tokenize(input);\n\n        //todo % at start of func or tag   tax\u003d5%    func(5%)\n        if (components.contains(\"%\")) {\n            for (int n \u003d 0; n \u003c components.size(); n++) {\n                if (components.get(n).equals(\"%\")) {\n                    if (n \u003d\u003d 0) {\n                        return \"Error- no # before %\";\n                    }\n                    try {\n                        //check if % is after a #  5.3%\n                        Double.parseDouble(components.get(n-1));\n                    } catch (NumberFormatException e) {\n                        return \"Error- incorrect % usage\";\n                    }\n                    //!calc 50%    \u003d 0.5\n                    if (n \u003d\u003d 1) {\n                        return \"Error- cant have % as first value\";\n                    }\n                    if (n \u003d\u003d 2) {\n                        return \"Error- missing value at beginning of equation\";\n                    }\n                    //change # and math symbols into required forms\n                    switch (components.get(n-2)){\n                        case \"+\":\n                            components.set(n - 2, \"*\");\n                            components.set(n - 1, String.format(\"%.3f\", 1 + Double.parseDouble(components.get(n -1)) / 100));\n                            break;\n                        case \"-\":   //5 * -5%  \u003e  5 * *0.95     want 5 * -0.95\n                            switch (components.get(n-3)) {\n                                case \"+\":\n                                    components.set(n - 3, \"*\");\n                                    components.set(n - 2, String.format(\"%.3f\", 1 - Double.parseDouble(components.get(n -1)) / 100));\n                                    components.remove(n - 1);\n                                    n -\u003d 1;\n                                    break;\n                                case \"-\":\n                                    components.set(n - 3, \"*\");\n                                    components.set(n - 2, String.format(\"%.3f\", 1 + Double.parseDouble(components.get(n -1)) / 100));\n                                    components.remove(n - 1);\n                                    n -\u003d 1;\n                                    break;\n                                case \"*\":\n                                case \"/\":\n                                    components.set(n - 1, String.format(\"%.3f\", Double.parseDouble(components.get(n -1)) / 100));\n                                    break;\n                                default:\n                                    components.set(n - 2, \"*\");\n                                    components.set(n - 1, String.format(\"%.3f\", 1 - Double.parseDouble(components.get(n -1)) / 100));\n                                    break;\n                        }\n                            break;\n                        case \")\":\n                        case \"*\":\n                        case \"/\":\n                            components.set(n - 1, String.format(\"%.3f\", Double.parseDouble(components.get(n -1)) / 100));\n                            break;\n                        case \"(\":\n                        case \",\":\n                            return \"Error- % cant be first value after \\\"(\\\" or \\\",\\\"\";\n                        default:\n                            return \"Error- invalid use of %\";\n\n                    }\n                    components.remove(n);\n                    n -\u003d 1;\n                }\n            }\n        }\n\n        if (components.contains(\"(\") || components.contains(\")\")) {\n            //check # ) never above # (, and add ) if needed\n            components\u003dcheckParenth(components);\n            if (components.get(0).contains(\"Error\")) {\n                return components.get(0);\n            }\n        }\n        //if a component has a letter and immediately followed by (, check if is a tag( or func( and replace as needed\n        for (int i \u003d 1; i \u003c components.size(); i++) {\n            if (components.get(i).equals(\"(\") \u0026\u0026 components.get(i - 1).matches(\".*[a-zA-Z]+.*\")) {\n                //System.out.println(\"Before entering Nested Functions: \" + components);\n                components \u003d evaluateNestedFunctions(components);\n                //System.out.println(\"After Nested Functions: \" + components);\n\n                if (components.get(0).contains(\"Error\")) {\n                    components.set(0, errorStrip(components.get(0)));\n                    return components.get(0);\n                }\n                //re-string all components, then properly re-tokenize (evalNestedFunc will string multiple components together)\n                String tempComp \u003d \"\";\n                for (int n\u003d0; n \u003c components.size(); n++) {\n                    tempComp +\u003d components.get(n);\n                }\n                components \u003d tokenize(tempComp);\n\n                //check # ) never above # (, and add ) if needed\n                components \u003d checkParenth(components);\n                if (components.get(0).contains(\"Error\")) {\n                    return components.get(0);\n                }\n                break;\n            }\n        }\n\n\n\n        //check all math operators legal\n        for (int n \u003d 0; n \u003c components.size(); n++) {\n            // -+*/^( cant be followed by +*/^)\n            switch (components.get(n)) {\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                case \"/\":\n                case \"^\":\n                case \"(\":\n                    if (n + 1 !\u003d components.size()) {\n                        switch (components.get(n + 1)) {\n                            case \"+\":\n                            case \"*\":\n                            case \"/\":\n                            case \"^\":\n                            case \")\":\n                                output \u003d \"Error- 2 math operators together\";\n                                return output;\n                            default:\n                                break;\n                        }\n                    } else {\n                        output \u003d \"Error- cant end equation in math operator\";\n                        return output;\n                    }\n                default:\n                    break;\n            }\n\n            //add * after ) if not end of equation, or followed by math operator\n            if (components.get(n).equals(\")\") \u0026\u0026 n + 1 !\u003d components.size()) {\n                switch (components.get(n + 1)) {\n                    case \"+\":\n                    case \"-\":\n                    case \"*\":\n                    case \"/\":\n                    case \")\":\n                    case \"^\":\n                    case \",\":\n                        break;\n                    default:\n                        components.set(n, \")*\");\n                        break;\n                }\n            }\n            //dont allow math tag at end of equation\n            switch (components.get(n)) {\n                case \"sqrt\":\n                case \"cos\":\n                case \"sin\":\n                case \"tan\":\n                    if (n + 1 \u003d\u003d components.size()) {\n                        output \u003d \"Error- math tag not followed by (###)\";\n                        return output;\n                    } else if (!components.get(n + 1).equals(\"(\")) {\n                        output \u003d \"Error- math tag not followed by (###)\";\n                        return output;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            //check . is before at least 1 # \u0026 only 1 in component\n            if (components.get(n).matches(\".*[.]+.*\")) {\n                String[] split \u003d components.get(n).split(\"\\\\.\");\n                if (split.length \u003d\u003d 1) {\n                    //add 0 after . if needed  2.  \u003e  2.0\n                    components.set(n, components.get(n) + \"0\");\n                }\n                //is just \".\" OR has 2 or more . in same # 5..3\n                else if(split.length \u003d\u003d 0 || split.length \u003e 2) {\n                    output \u003d \"Error- incorrect decimal usage\";\n                    return output;\n                }\n            }\n        } //end for\n\n        //if any , remain, is an extra and unnecessary\n        if (components.contains(\",\")) {\n            return \"Error- extra \\\",\\\" in equation or function definition\";\n        }\n        //check remaining tags and ( correctly placed\n        for (int n \u003d 0; n \u003c components.size(); n++) {\n            //add * before ( if needed  (\"56(4-2)\" changes to \"56*(4-2)\")\n            //here handles # before (, evaluateFunction handles tag/func before (\n            if (components.get(n).equals(\"(\") \u0026\u0026 n!\u003d0) {\n                switch (components.get(n - 1)) {\n                    case \"+\":\n                    case \"-\":\n                    case \"*\":\n                    case \"/\":\n                    case \"^\":\n                    case \"(\":\n                    case \"*(\":\n                    case \"sqrt\":\n                    case \"cos\":\n                    case \"sin\":\n                    case \"tan\":\n                        break;\n                    default:\n                        components.set(n, \"*(\");\n                        break;\n                }\n            }\n            //if component contains a letter, its a tag or scientific notation (ignore math tags (sqrt, sin, cos, tan))\n            if (components.get(n).matches(\".*[a-zA-Z]+.*\")) {\n                components.set(n, evaluateTag(components.get(n)));\n            } //end if\n        }\n\n        //convert components back into 1 string\n        output \u003d \"\";\n        for (String component : components) {\n            output +\u003d component;\n        }\n        //System.out.println(\"Tags Replaced in checkEquation: \" + output);\n        return output;\n    }\n\n    //evaluate string math equation\n    public static double eval(final String str) {\n        //System.out.println(\"Enter eval: \" + str);\n        return new Object() {\n            int pos \u003d -1, ch;\n\n            void nextChar() {\n                ch \u003d (++pos \u003c str.length()) ? str.charAt(pos) : -1;\n            }\n\n            boolean eat(int charToEat) {\n                while (ch \u003d\u003d \u0027 \u0027) nextChar();\n                if (ch \u003d\u003d charToEat) {\n                    nextChar();\n                    return true;\n                }\n                return false;\n            }\n\n            double parse() {\n                nextChar();\n                double x \u003d parseExpression();\n                if (pos \u003c str.length()) throw new RuntimeException(\"Unexpected: \" + (char) ch);\n                return x;\n            }\n\n            // Grammar:\n            // expression \u003d term | expression `+` term | expression `-` term\n            // term \u003d factor | term `*` factor | term `/` factor\n            // factor \u003d `+` factor | `-` factor | `(` expression `)` | number\n            //        | functionName `(` expression `)` | functionName factor\n            //        | factor `^` factor\n\n            double parseExpression() {\n                double x \u003d parseTerm();\n                for (; ; ) {\n                    if (eat(\u0027+\u0027)) x +\u003d parseTerm(); // addition\n                    else if (eat(\u0027-\u0027)) x -\u003d parseTerm(); // subtraction\n                    else return x;\n                }\n            }\n\n            double parseTerm() {\n                double x \u003d parseFactor();\n                for (; ; ) {\n                    if (eat(\u0027*\u0027)) x *\u003d parseFactor(); // multiplication\n                    else if (eat(\u0027/\u0027)) x /\u003d parseFactor(); // division\n                    else return x;\n                }\n            }\n\n            double parseFactor() {\n                if (eat(\u0027+\u0027)) return +parseFactor(); // unary plus\n                if (eat(\u0027-\u0027)) return -parseFactor(); // unary minus\n\n                double x;\n                int startPos \u003d this.pos;\n                if (eat(\u0027(\u0027)) { // parentheses\n                    x \u003d parseExpression();\n                    if (!eat(\u0027)\u0027)) throw new RuntimeException(\"Missing \u0027)\u0027\");\n                } else if ((ch \u003e\u003d \u00270\u0027 \u0026\u0026 ch \u003c\u003d \u00279\u0027) || ch \u003d\u003d \u0027.\u0027) { // numbers\n                    while ((ch \u003e\u003d \u00270\u0027 \u0026\u0026 ch \u003c\u003d \u00279\u0027) || ch \u003d\u003d \u0027.\u0027) nextChar();\n                    x \u003d Double.parseDouble(str.substring(startPos, this.pos));\n                } else if (ch \u003e\u003d \u0027a\u0027 \u0026\u0026 ch \u003c\u003d \u0027z\u0027) { // functions\n                    while (ch \u003e\u003d \u0027a\u0027 \u0026\u0026 ch \u003c\u003d \u0027z\u0027) nextChar();\n                    String func \u003d str.substring(startPos, this.pos);\n                    if (eat(\u0027(\u0027)) {\n                        x \u003d parseExpression();\n                        if (!eat(\u0027)\u0027)) throw new RuntimeException(\"Missing \u0027)\u0027 after argument to \" + func);\n                    } else {\n                        x \u003d parseFactor();\n                    }\n                    switch (func) {\n                        case \"sqrt\":\n                            x \u003d Math.sqrt(x);\n                            break;\n                        case \"sin\":\n                            x \u003d Math.sin(Math.toRadians(x));\n                            break;\n                        case \"cos\":\n                            x \u003d Math.cos(Math.toRadians(x));\n                            break;\n                        case \"tan\":\n                            x \u003d Math.tan(Math.toRadians(x));\n                            break;\n                        default:\n                            throw new RuntimeException(\"Unknown function: \" + func);\n                    }\n                } else {\n                    throw new RuntimeException(\"Unexpected: \" + (char) ch);\n                }\n\n                if (eat(\u0027^\u0027)) x \u003d Math.pow(x, parseFactor()); // exponentiation\n\n                return x;\n            }\n        }.parse();\n    }\n\n    //Lookup current xp for desired skill\n    public String xpLookup(String skill) {\n        switch (skill) {\n            case \"myattack\":\n            case \"myatt\":\n            case \"myatk\":\n                return Integer.toString(client.getSkillExperience(Skill.ATTACK));\n            case \"myhitpoints\":\n            case \"myhp\":\n            case \"myhitpoint\":\n            case \"myhealth\":\n            case \"myhit\":\n                return Integer.toString(client.getSkillExperience(Skill.HITPOINTS));\n            case \"mymining\":\n            case \"mymine\":\n                return Integer.toString(client.getSkillExperience(Skill.MINING));\n            case \"mystrength\":\n            case \"mystr\":\n                return Integer.toString(client.getSkillExperience(Skill.STRENGTH));\n            case \"myagility\":\n            case \"myagil\":\n            case \"myagi\":\n                return Integer.toString(client.getSkillExperience(Skill.AGILITY));\n            case \"mysmithing\":\n            case \"mysmith\":\n                return Integer.toString(client.getSkillExperience(Skill.SMITHING));\n            case \"mydefence\":\n            case \"mydef\":\n                return Integer.toString(client.getSkillExperience(Skill.DEFENCE));\n            case \"myherblore\":\n            case \"myherb\":\n            case \"myhl\":\n                return Integer.toString(client.getSkillExperience(Skill.HERBLORE));\n            case \"myfishing\":\n            case \"myfish\":\n                return Integer.toString(client.getSkillExperience(Skill.FISHING));\n            case \"myranged\":\n            case \"myranging\":\n            case \"myrange\":\n            case \"myrng\":\n                return Integer.toString(client.getSkillExperience(Skill.RANGED));\n            case \"mythieving\":\n            case \"mythieve\":\n            case \"mythief\":\n                return Integer.toString(client.getSkillExperience(Skill.THIEVING));\n            case \"mycooking\":\n            case \"mycook\":\n                return Integer.toString(client.getSkillExperience(Skill.COOKING));\n            case \"myprayer\":\n            case \"mypray\":\n                return Integer.toString(client.getSkillExperience(Skill.PRAYER));\n            case \"mycrafting\":\n            case \"mycraft\":\n                return Integer.toString(client.getSkillExperience(Skill.CRAFTING));\n            case \"myfiremaking\":\n            case \"myfm\":\n            case \"myfire\":\n                return Integer.toString(client.getSkillExperience(Skill.FIREMAKING));\n            case \"mymagic\":\n            case \"mymage\":\n            case \"mymag\":\n                return Integer.toString(client.getSkillExperience(Skill.MAGIC));\n            case \"myfletching\":\n            case \"myfletch\":\n                return Integer.toString(client.getSkillExperience(Skill.FLETCHING));\n            case \"mywoodcutting\":\n            case \"mywc\":\n            case \"mywoodcut\":\n            case \"mywood\":\n                return Integer.toString(client.getSkillExperience(Skill.WOODCUTTING));\n            case \"myrunecrafting\":\n            case \"myrc\":\n            case \"myrune\":\n                return Integer.toString(client.getSkillExperience(Skill.RUNECRAFT));\n            case \"myslayer\":\n            case \"myslay\":\n                return Integer.toString(client.getSkillExperience(Skill.SLAYER));\n            case \"myfarming\":\n            case \"myfarm\":\n                return Integer.toString(client.getSkillExperience(Skill.FARMING));\n            case \"myconstruction\":\n            case \"mycon\":\n            case \"myconstruct\":\n                return Integer.toString(client.getSkillExperience(Skill.CONSTRUCTION));\n            case \"myhunter\":\n            case \"myhunt\":\n                return Integer.toString(client.getSkillExperience(Skill.HUNTER));\n            default:\n                return \"Error in xpLookup\";\n        }\n    }\n\n    //add new tag \u0026 value to runTimeTags\n    public void addNewTag(String value) {\n        //add auto tag (no tag name provided)\n        if (needAutoTag) {\n            //only hold 10 auto-tags (a0-a9), then write-over old auto tags\n            if (autoTag \u003d\u003d 10) {\n                autoTag \u003d 0;\n            }\n\n            newTagName \u003d \"a\" + autoTag++;\n\n            if (runTimeTags.get(newTagName) !\u003d null) {\n                runTimeTags.remove(newTagName);\n            }\n            runTimeTags.put(newTagName, value);\n        }\n\n        //add new tag \u0026 value\n        else {\n            //replace old runTimeTag with new\n            if (runTimeTags.get(newTagName) !\u003d null) {\n                runTimeTags.remove(newTagName);\n            }\n            runTimeTags.put(newTagName, value);\n        }\n\n        //update \"last\" tag to last result value\n        if (runTimeTags.get(\"last\") !\u003d null) {\n            runTimeTags.remove(\"last\");\n        }\n        runTimeTags.put(\"last\", value);\n    }\n\n    //build chat message (error or result)\n    public void build(String equ, String corEqu, String ans, ChatMessage chatMessage) {\n        String response;\n        //If input equation is more than 45 characters, just write \"Your long equation equals \"\n        if (equ.length() \u003e 45) {\n            equ \u003d \" Your long equation\";\n        }\n        //error message received, or command (!clear, !remove, !list) completed (C \u0026 R)\n        if (corEqu.charAt(0) \u003d\u003d \u0027E\u0027 || corEqu.charAt(0) \u003d\u003d \u0027C\u0027 || corEqu.charAt(0) \u003d\u003d \u0027R\u0027) {\n            //trim error message between \"Error\" and possibly \"@\u0026\"\n            if (corEqu.charAt(0) \u003d\u003d \u0027E\u0027) {\n                corEqu \u003d errorStrip(corEqu);\n            }\n            //System.out.println(equ + \" \" + corEqu);\n            response \u003d new ChatMessageBuilder()\n                    .append(ChatColorType.NORMAL)\n                    .append(equ)\n                    .append(ChatColorType.HIGHLIGHT)\n                    .append(\" \" + corEqu)\n                    .build();\n        } else if (ans.charAt(0) \u003d\u003d \u0027I\u0027) {\n            //System.out.println(equ + \" Error- cannot divide by 0\");\n            //build new message\n            response \u003d new ChatMessageBuilder()\n                    .append(ChatColorType.NORMAL)\n                    .append(equ)\n                    .append(ChatColorType.HIGHLIGHT)\n                    .append(\" Error- number too large, or cannot divide by 0\")\n                    .build();\n        } else {\n            //build new message\n            response \u003d new ChatMessageBuilder()\n                    .append(ChatColorType.NORMAL)\n                    .append(equ)\n                    .append(ChatColorType.HIGHLIGHT)\n                    .append(\" equals \")\n                    .append(ChatColorType.NORMAL)\n                    .append(ans) //removed .toString()\n                    .build();\n        }\n\n        //print new message to chatbox\n        final MessageNode messageNode \u003d chatMessage.getMessageNode();\n        messageNode.setRuneLiteFormatMessage(response);\n        client.refreshChat();\n    }\n\n    // Tokenizer that includes words, numbers, operators, parentheses, and commas\n    public static List\u003cString\u003e tokenize(String input) {\n        //this pattern properly supports tokens starting with a #  50k\n        //Pattern pattern \u003d Pattern.compile(\"\\\\d+(?:\\\\.\\\\d+)?[a-zA-Z0-9]+|[a-zA-Z][a-zA-Z0-9]*|\\\\d+(?:\\\\.\\\\d+)?|[+\\\\-*/(),]\");\n        //this pattern meant to be the same, but also allow decimal numbers w/o leading # like .4\n//        Pattern pattern \u003d Pattern.compile(\n//                \"(?:\\\\d+\\\\.\\\\d*|\\\\.\\\\d+|\\\\d+)(?:[a-zA-Z0-9]+)?|\" +   // numbers with optional trailing letters (e.g., 2.5kg, .4kg)\n//                        \"[a-zA-Z][a-zA-Z0-9]*|\" +                            // variable names (e.g., x1, var2)\n//                        \"[+\\\\-*/(),^]\"\n//        );\n\n//        Pattern pattern \u003d Pattern.compile(\n//                \"(?:\\\\d+\\\\.\\\\d+|\\\\.\\\\d+|\\\\d+)[a-zA-Z][a-zA-Z0-9]*|\" +  // number with unit, e.g., 45.5fss, .4kg\n//                        \"\\\\d+\\\\.\\\\d+|\\\\.\\\\d+|\\\\d+|\" +                          // plain numbers\n//                        \"[a-zA-Z][a-zA-Z0-9]*|\" +                              // variables\n//                        \"[+\\\\-*/()^,]\"                                         // operators\n//        );\n//        Matcher matcher \u003d pattern.matcher(input);\n//\n//        List\u003cString\u003e tokens \u003d new ArrayList\u003c\u003e();\n//        while (matcher.find()) {\n//            tokens.add(matcher.group());\n//        }\n//        return tokens;\n\n        // Split while keeping the delimiters (math operators)\n        String[] rawTokens \u003d input.split(\"(?\u003d[+\\\\-*/()^,%])|(?\u003c\u003d[+\\\\-*/()^,%])\");\n\n        // Remove empty strings and trim whitespace\n        List\u003cString\u003e tokens \u003d new ArrayList\u003c\u003e();\n        for (String token : rawTokens) {\n            String trimmed \u003d token.trim();\n            if (!trimmed.isEmpty()) {\n                tokens.add(trimmed);\n            }\n        }\n        return tokens;\n    }\n\n    // Recursively evaluate all nested functions\n    private List\u003cString\u003e evaluateNestedFunctions(List\u003cString\u003e tokens) {\n        List\u003cString\u003e result \u003d new ArrayList\u003c\u003e(tokens);\n\n        while (true) {\n            boolean changed \u003d false;\n\n            for (int i \u003d 1; i \u003c result.size(); i++) {\n                if (result.get(i).equals(\"(\") \u0026\u0026 result.get(i - 1).matches(\".*[a-zA-Z]+.*\")) {\n                    String functionName \u003d result.get(i - 1);\n                    int closingIndex \u003d findMatchingClosingParen(result, i);\n                    if (closingIndex !\u003d -1) {\n                        List\u003cString\u003e innerTokens \u003d new ArrayList\u003c\u003e(result.subList(i + 1, closingIndex));\n                        List\u003cString\u003e argStrings \u003d splitFunctionArguments(innerTokens);\n\n                        // Evaluate each argument recursively\n                        List\u003cString\u003e evaluatedArgs \u003d new ArrayList\u003c\u003e();\n                        for (String arg : argStrings) {\n                            List\u003cString\u003e argTokens \u003d tokenize(arg);\n                            List\u003cString\u003e evaluated \u003d evaluateNestedFunctions(argTokens);\n                            evaluatedArgs.add(String.join(\"\", evaluated));\n                        }\n\n                        // Simulate function evaluation\n                        String value \u003d evaluateFunction(functionName, evaluatedArgs);\n\n                        // Replace function call with its result\n                        result.set(i - 1, value);\n                        result.subList(i, closingIndex + 1).clear();\n\n                        changed \u003d true;\n                        break; // Start over after modification\n                    }\n                }\n            }\n\n            if (!changed) break;\n        }\n    //evaluateNestedFunctions return\n        return result;\n    }\n\n    // Finds the index of the closing parenthesis that matches the one at startIndex\n    private static int findMatchingClosingParen(List\u003cString\u003e tokens, int startIndex) {\n        int depth \u003d 1;\n        for (int i \u003d startIndex + 1; i \u003c tokens.size(); i++) {\n            if (tokens.get(i).equals(\"(\")) depth++;\n            else if (tokens.get(i).equals(\")\")) depth--;\n            if (depth \u003d\u003d 0) return i;\n        }\n        return -1;\n    }\n\n    // Splits tokens by commas, respecting nested parentheses\n    private static List\u003cString\u003e splitFunctionArguments(List\u003cString\u003e tokens) {\n        List\u003cString\u003e args \u003d new ArrayList\u003c\u003e();\n        StringBuilder current \u003d new StringBuilder();\n        int depth \u003d 0;\n\n        for (String token : tokens) {\n            if (token.equals(\"(\")) depth++;\n            if (token.equals(\")\")) depth--;\n\n            if (token.equals(\",\") \u0026\u0026 depth \u003d\u003d 0) {\n                args.add(current.toString().trim());\n                current.setLength(0);\n            } else {\n                current.append(token);\n            }\n        }\n\n        if (current.length() \u003e 0) {\n            args.add(current.toString().trim());\n        }\n\n        return args;\n    }\n\n    // Stub for evaluating a function with arguments\n    //func(2,func(3,4))\n    //receive func(3,4)\n    //then receive func(2,func(3,4))\n    private String evaluateFunction(String name, List\u003cString\u003e args) {\n        //System.out.println(\"EvaluateFunction begin: \" + name + \" with args: \" + args);\n        //receive func(3,4)\n        //var1+var2*var1+4\n        for (int n\u003d0; n\u003c args.size(); n++) {\n            if (args.get(n).isEmpty()) {\n                return \"Error- variable is empty\";\n            }\n        }\n\n        //oak(5)  \u003e  oak , 5   \u003e   oak(1)\n        //Check if name and size is a stored function\n        String checkForFunc \u003d name + \"(\" + args.size() + \")\" ;\n        if(configTags.get(checkForFunc) !\u003d null) {\n            //get function definition (var1+var2*var1+4)\n            List\u003cString\u003e funcDef \u003d tokenize(configTags.get(checkForFunc));\n\n            //replace var placeholders with passed args\n            List\u003cString\u003e indexesChanged \u003d new ArrayList\u003c\u003e();\n            for (int n\u003d0; n\u003cargs.size(); n++) {\n                for (int m\u003d0; m\u003cfuncDef.size(); m++) {\n                    //dont replace variable twice (can change to var1 on first loop, then match again on 2nd loop and change)\n                    if (funcDef.get(m).equals(\"var\"+n) \u0026\u0026 !indexesChanged.contains(Integer.toString(m))) {\n                        indexesChanged.add(Integer.toString(m));\n                        funcDef.set(m,args.get(n));\n                    }\n                }\n            }\n            //component of function can contain multiple components splinters(oak+500,15)  \u003e  oak+500 , 15    \u003e need check if multiple items, send back into check equation\n            //check if any component still has letters (tags), replace them now if possible\n            //dont replace if component is still var# (used when function is within another functions definition) func(x,y) \u003d splinters(x)*200\n            for (int n\u003d0; n\u003cfuncDef.size(); n++) {\n                if (funcDef.get(n).matches(\".*[a-z]+.*\") \u0026\u0026 !funcDef.get(n).matches(\"var\\\\d+\")) {\n\n                    // New block loop\n                    List\u003cString\u003e temp \u003d tokenize(funcDef.get(n));\n                    if (temp.size() \u003e 1) {\n                        funcDef.set(n, \"(\" + funcDef.get(n) + \")\");\n                        funcDef.set(n,checkEquation(funcDef.get(n)));\n                        if (funcDef.get(n).contains(\"Error\")) {\n                            funcDef.set(n, errorStrip(funcDef.get(n)));\n                            return funcDef.get(n);\n                        }\n                    }\n                    else {\n                        funcDef.set(n,evaluateTag(funcDef.get(n)));\n\n                        if (funcDef.get(n).contains(\"Error\")) {\n                            funcDef.set(n, errorStrip(funcDef.get(n)));\n                            //System.out.println(\"Error, no \\\"\" + name + \"\\\" tag or function with matching parameters found@\u0026\");\n                            return funcDef.get(n);\n                        }\n                    }\n                }\n            }\n            name \u003d \"(\";\n            for (String s:funcDef) {\n                name +\u003d s;\n            }\n            name +\u003d \")\";\n        }\n        //not a function, is tag(contents). Check if tag exists, and contents are valid (no , and valid math)\n        else {\n            //oak , 5\n            name \u003d evaluateTag(name);\n            if (name.charAt(0) \u003d\u003d \u0027E\u0027) {\n                //System.out.println(\"Error, no \\\"\" + name + \"\\\" tag or function with matching parameters found@\u0026\");\n                return name;\n            }\n            String temp \u003d\"\";\n            for (String component : args) {\n                temp +\u003d component;\n            }\n            //checkEquation checks validity of formattings, and replaces tags/handles functions\n            temp \u003d checkEquation(temp);\n            if (temp.contains(\"Error\")) {\n                temp \u003d errorStrip(temp);\n                return temp;\n            }\n\n            //close math function cos(45)\n            if (mathFunction(name)){\n                name +\u003d \"(\";\n                temp +\u003d \")\";\n            }\n\n            else {\n                name +\u003d \"*\";\n            }\n\n            name +\u003d temp;\n\n        }\n        //System.out.println(\"Evaluate Function end: \" + name);\n        return name;\n    }\n    //Receives a single component, return tag value if found\n    //Leave math tags (sqrt, cos, etc), Evaluate scientific notation, Replace tag with tag value\n    private String evaluateTag(String name) {\n        //for (int n \u003d 0; n \u003c name.length(); n++) {\n\n        //if component contains a letter, its a tag or scientific notation (ignore math tags (sqrt, sin, cos, tan))\n        if (name.matches(\".*[a-zA-Z]+.*\") \u0026\u0026 !mathFunction(name)) {\n            //check for scientific notation\n            //component would be # ended in k m or b (10.6k)\n            //String[] split \u003d name.split(\"(?\u003d[k|m|b])\");\n            String[] split \u003d name.split(\"(?\u003c\u003d\\\\d)(?\u003d[kmb]$)\");\n\n            //check for possible scientific notation (### k)\n            if (split[0].matches(\"\\\\d+.+|\\\\d+\") \u0026\u0026 split.length \u003d\u003d 2) {\n\n                boolean isScientific \u003d false;\n\n                //check if 2nd index is scientific notation\n                switch (split[1]) {\n                    case \"k\":\n                        name \u003d \"(\" + split[0] + \"*1000)\";\n                        isScientific \u003d true;\n                        break;\n                    case \"m\":\n                        name \u003d \"(\" + split[0] + \"*1000000)\";\n                        isScientific \u003d true;\n                        break;\n                    case \"b\":\n                        name \u003d \"(\" + split[0] + \"*1000000000)\";\n                        isScientific \u003d true;\n                        break;\n                    default:\n                        break;\n                }\n                //dont check if is a tag if is scientific notation\n                if (isScientific) {\n                    return name;\n                }\n            }\n\n            //check if is a tag\n            if (configTags.get(name) !\u003d null) {\n                name \u003d configTags.get(name);\n                //contain tag in brackets if it contains math symbols for proper eval\n                // tag \u003d 5 + 4 needs brackets, otherwise 3*tag  \u003d 3 * 5 + 4\n                for (char c : name.toCharArray()) {\n                    if (c \u003d\u003d \u0027+\u0027 || c \u003d\u003d \u0027-\u0027 || c \u003d\u003d \u0027*\u0027 || c \u003d\u003d \u0027/\u0027) {\n                        name \u003d \"(\" + name + \")\";\n                        break;\n                    }\n                }\n            } else if (lvlTags.get(name) !\u003d null) {\n                name \u003d lvlTags.get(name);\n            } else if (runTimeTags.get(name) !\u003d null) {\n                name \u003d runTimeTags.get(name);\n            } else if (SkillTags.get(name) !\u003d null) {\n                name \u003d xpLookup(name);\n            } else {\n                if (name.contains(\".\")) {\n                    output \u003d \"Error- tag or function name can\u0027t contain \\\".\\\" or symbols\";\n                    return output;\n                }\n                output \u003d \"Error- no \\\"\" + name + \"\\\" tag or function with matching parameters found@\u0026\";\n                //System.out.println(output);\n                return output;\n            }\n        } //end if\n        return name;\n    }\n    private boolean mathFunction(String item) {\n        switch (item) {\n            case \"sqrt\":\n            case \"cos\":\n            case \"sin\":\n            case \"tan\":\n                return true;\n            default:\n                return false;\n        }\n    }\n    private String errorStrip(String error) {\n        int start \u003d error.indexOf(\"Error\");\n        if (start \u003d\u003d -1) return \"\"; // Or handle \"Error\" not found\n\n        int end \u003d error.indexOf(\"@\u0026\", start);\n        if (end \u003d\u003d -1) {\n            return error.substring(start).trim(); // No \"@\u0026\" found; return from \"Error\" to end\n        } else {\n            return error.substring(start, end).trim(); // Return from \"Error\" to before \"@\u0026\"\n        }\n    }\n\n    List\u003cString\u003e checkParenth(List\u003cString\u003e components) {\n        int countOpenParen \u003d 0;\n        int countClosedParen \u003d 0;\n        //for(int n\u003d0;n\u003clength;n++){\n        for (String component : components) {\n            switch (component) {\n                case \"(\":\n                    countOpenParen++;\n                    break;\n                case \")\":\n                    countClosedParen++;\n                    if (countClosedParen \u003e countOpenParen) {\n                        components.set(0,\"Error- found ) before (\");\n                        return components;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        //add missing ) if needed\n        for (int n\u003d0; n\u003c(countOpenParen-countClosedParen); n++){\n            components.add(\")\");\n        }\n        return components;\n    }\n}\n","filePath":"src\\main\\java\\com\\calculatorpro\\CalculatorProPlugin.java"},{"fileName":"CalculatorButton.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport javax.swing.JButton;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class CalculatorButton extends JButton\n{\n    private static final Dimension PREFERRED_SIZE \u003d new Dimension(55, 55);\n\n    //Cyborger1 edit\n    private static final Dimension MINIMUM_SIZE \u003d new Dimension(54, 55);\n    //end Cyborger1 edit\n\n    public CalculatorButton(String text)\n    {\n        super(text);\n\n        setPreferredSize(PREFERRED_SIZE);\n        //Cyborger1 edit\n        setMinimumSize(MINIMUM_SIZE);\n        //end Cyborger1 edit\n\n        // Use Arial. Zero and Asterisk look funny in \"Runescape Standard\"\n        setFont(new Font(\"Arial\", Font.BOLD, 20));\n    }\n\n//    public CalculatorButton(Icon icon)\n//    {\n//        super(icon);\n//\n//        setPreferredSize(PREFERRED_SIZE);\n//        //Cyborger1 edit\n//        setMinimumSize(MINIMUM_SIZE);\n//        //end Cyborger1 edit\n//    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\CalculatorButton.java"},{"fileName":"CalculatorPanel.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport java.awt.Component;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.math.RoundingMode;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\nimport java.text.DecimalFormat;\n\npublic class CalculatorPanel extends JPanel\n{\n    private static final Insets INSETS_LEFT_BORDER \u003d new Insets(1, 0, 1, 1);\n    private static final Insets INSETS_RIGHT_BORDER \u003d new Insets(1, 1, 1, 0);\n    private static final Insets INSETS \u003d new Insets(1, 1, 1, 1);\n\n    private final CalculatorPluginPanel panel;\n    private final DisplayField displayField;\n    private final GridBagConstraints c;\n\n    protected CalculatorPanel(CalculatorPluginPanel panel)\n    {\n        super();\n        this.panel \u003d panel;\n        this.displayField \u003d panel.getDisplayField();\n\n        setLayout(new GridBagLayout());\n        //Cyborger1 edit\n        setBorder(new EmptyBorder(0, 1, 0, 1));\n        //end Cyborger1 edit\n\n        c \u003d new GridBagConstraints();\n        c.fill \u003d GridBagConstraints.HORIZONTAL;\n        c.gridx \u003d 0;\n        c.gridy \u003d 0;\n        //Cyborger1 edit\n        c.weightx \u003d 1;\n        c.weighty \u003d 1;\n        //end Cyborger1 edit\n\n//        CalculatorButton plusMinus \u003d new CalculatorButton(PLUS_MINUS_ICON);\n\n        addButton(\"+\");\n        addButton(\"7\");\n        addButton(\"8\");\n        addButton(\"9\");\n\n        addButton(\"-\");\n        addButton(\"4\");\n        addButton(\"5\");\n        addButton(\"6\");\n\n        addButton(\"*\");\n        addButton(\"1\");\n        addButton(\"2\");\n        addButton(\"3\");\n\n        addButton(\"/\");\n        addButton(\".\");\n        addButton(\"0\");\n        addButton(\"\u003d\");\n\n\n        addButton(\"(\");\n        addButton(\")\");\n        addButton(\"^\");\n        addButton(\"\u003c\");\n//        addComp(plusMinus);\n\n        addButton(\"C\");\n        c.gridwidth \u003d 3;\n        addButton(\"Clear History\");\n    }\n\n    private void addButton(String key)\n    {\n        //todo: add keyboard inputs (ctrl+v, nums, backspace, etc)\n        CalculatorButton btn \u003d new CalculatorButton(key);\n        btn.addActionListener(e -\u003e\n        {\n            //create string from button inputs, validate key presses on the go, dont allow invalid key presses\n            String text \u003d btn.getText();\n            switch (text) {\n                case \"\u003d\":\n                    if (displayField.input.equals(\"\")) {\n                        return;\n                    }\n\n                    //add extra ) if needed, check end of equation valid\n                    displayField.calculateResult();\n\n                    // Add new calculation to history\n                    if(displayField.calcDone){\n                        panel.getHistoryPanel().addHistoryItem(displayField.input + \" \u003d\", displayField.output);\n                    }\n                    break;\n\n                //clear display\n                case \"C\":\n                    displayField.clear();\n                    return;\n\n                //clear history\n                case \"Clear History\":\n                    panel.getHistoryPanel().clearHistory();\n                    displayField.previousResult \u003d \"0\";\n                    return;\n\n                //kanderson66 edit\n                //backspace function for display panel\n                case \"\u003c\":\n                    displayField.input \u003d deleteLastCharacter(displayField.input);\n                    break;\n                //input is a #\n                default:\n                    displayField.input +\u003d text;\n                    //input not valid, remove last input\n                    if (!inputValid(displayField.input.replaceAll(\",\", \"\"))) {\n                        displayField.input \u003d deleteLastCharacter(displayField.input);\n                        return;\n                    }\n                    break;\n                    //end kanderson66 edit\n            }\n            displayField.update();\n        });\n        addComp(btn);\n    }\n\n    private void addComp(Component component)\n    {\n        switch (c.gridx)\n        {\n            case 0:\n                c.insets \u003d INSETS_LEFT_BORDER;\n                break;\n            case 3:\n                c.insets \u003d INSETS_RIGHT_BORDER;\n                break;\n            default:\n                c.insets \u003d INSETS;\n        }\n        if (c.gridwidth \u003d\u003d 3)\n        {\n            c.insets \u003d INSETS_RIGHT_BORDER;\n        }\n        add(component, c);\n        c.gridx \u003d ++c.gridx % 4;\n        c.gridy \u003d c.gridx \u003d\u003d 0 ? ++c.gridy : c.gridy;\n    }\n\n    //kanderson66 edit\n    private String deleteLastCharacter(String string)\n    {\n        if (string.equals(\"\"))\n        {\n            return string;\n        }\n        return string.substring(0, string.length() - 1);\n    }\n\n    private boolean inputValid(String input)\n    {\n        //split equation into individual components\n        String[] components \u003d input.split(\"(?\u003c\u003d[-+*/^()\\\\[\\\\]])|(?\u003d[-+*/^()\\\\[\\\\]])\");\n\n        //check # ) never above # (\n        int length\u003dcomponents.length;\n        int countOpenParen \u003d 0;\n        int countClosedParen \u003d 0;\n\n        for(String component : components){\n            switch (component){\n                case \"(\":\n                    countOpenParen++;\n                    break;\n                case \")\":\n                    countClosedParen++;\n                    if(countClosedParen\u003ecountOpenParen){\n                        return false;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        //check all math operators legal\n        for(int n\u003d0;n\u003clength;n++){\n            //grab last result if first digit pressed is math symbol \u0026 display has not been cleared\n            if (n\u003d\u003d0  \u0026\u0026 !displayField.previousResult.equals(\"0\") \u0026\u0026 length \u003d\u003d 1){\n                switch(components[n]){\n                    case \"+\":\n                    case \"-\":\n                    case \"*\":\n                    case \"/\":\n                    case \"^\":\n                        //ensure last result enter properly w comma\n                        String temp \u003d components[n];\n                        components[n] \u003d displayField.previousResult.replaceAll(\",\",\"\") + temp;\n                        //re-submit value to properly separate previousResult and math operator\n                        if (inputValid(components[n].replaceAll(\",\",\"\")))\n                        {\n                            return true;\n                        }\n                        return false;\n                    default:\n                        break;\n                }\n            }\n            //check if previous component was ###. with no number after decimal (remove last decimal)\n            //# of length 1 does not have a .\n            if(n !\u003d 0 \u0026\u0026 components[n - 1].length() !\u003d 1) {\n                if (components[n - 1].charAt(components[n - 1].length() - 1) \u003d\u003d \u0027.\u0027) {\n                    components[n - 1] \u003d components[n - 1].substring(0, components[n - 1].length() - 1);\n                }\n            }\n            //  +*/^) cant come after +-*/^( or start of equation\n            switch(components[n]){\n                case \"+\":\n                case \"*\":\n                case \"/\":\n                case \"^\":\n                case \")\":\n                    if (n!\u003d0)\n                    {\n                        switch (components[n-1]){\n                            case \"+\":\n                            case \"-\":\n                            case \"*\":\n                            case \"/\":\n                            case \"^\":\n                            case \"(\":\n                                return false;\n                            default:\n                                break;\n                        }\n                        break;\n                    }\n                    //cant have math symbol at start of equation (except ( or -)\n                    else\n                    {\n                        return false;\n                    }\n                //check proper input before (\n                case \"(\":\n                    if (n!\u003d0)\n                    {\n                        switch (components[n-1]){\n                            case \"+\":\n                            case \"-\":\n                            case \"*\":\n                            case \"/\":\n                            case \"^\":\n                            case \"(\":\n                                break;\n                            //add * before ( if needed  (\"56(4-2)\" changes to \"56*(4-2)\")\n                            default:\n                                components[n] \u003d \"*(\";\n                                break;\n                        }\n                    }\n                    break;\n            }\n\n            //check . is before at least 1 # \u0026 only 1 in component\n            if(components[n].matches(\".*[.]+.*\")){\n                String[] split \u003d components[n].split(\"\\\\.\");\n                switch (split.length)\n                {\n                    // \".\"\n                    case 0:\n                        components[n] \u003d \"0.\";\n                        break;\n                    // \"4.\"\n                    case 1:\n                        break;\n                    // \"4.4\" or \"4.4.\"\n                    case 2:\n                        //check if last character is .\n                        if (components[n].charAt(components[n].length()-1) \u003d\u003d \u0027.\u0027)\n                        {\n                            return false;\n                        }\n                        break;\n                    // \"4.4.4\"\n                    //should not reach- should be corrected when 2nd . entered\n                    default:\n                        return false;\n                }\n            }\n        } //end for\n\n        //include commas for easier reading, display max 15 decimal points in input field\n        //(answer field decimal limit is set separately in DisplayField.java)\n        DecimalFormat df \u003d new DecimalFormat(\"#,###.###############\");\n        df.setRoundingMode(RoundingMode.HALF_UP);\n\n        //convert components back into 1 string, update displayField input incase changed\n        displayField.input\u003d\"\";\n        for (String component : components) {\n            if (component.length() \u003e 3) {\n                displayField.input +\u003d df.format(Double.parseDouble(component));\n            } else {\n                displayField.input +\u003d component;\n            }\n        }\n        return true;\n    }\n    //end kanderson66 edit\n}\n\n\n","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\CalculatorPanel.java"},{"fileName":"CalculatorPluginPanel.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport java.awt.BorderLayout;\nimport lombok.Getter;\nimport net.runelite.client.ui.PluginPanel;\n\npublic class CalculatorPluginPanel extends PluginPanel\n{\n    private final DisplayPanel displayPanel \u003d new DisplayPanel();\n\n    @Getter\n    private final HistoryPanel historyPanel \u003d new HistoryPanel();\n\n    public CalculatorPluginPanel()\n    {\n        super();\n\n        CalculatorPanel calculatorPanel \u003d new CalculatorPanel(this);\n\n        setLayout(new BorderLayout(5, 5));\n\n        add(displayPanel, BorderLayout.NORTH);\n        add(calculatorPanel, BorderLayout.CENTER);\n        add(historyPanel, BorderLayout.SOUTH);\n    }\n\n    protected DisplayField getDisplayField()\n    {\n        return displayPanel.getDisplayField();\n    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\CalculatorPluginPanel.java"},{"fileName":"DisplayField.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\n//import com.calculatorpro.CalculatorProConfig;\n//import com.google.inject.Provides;\n//import javax.inject.Inject;\nimport javax.swing.JTextField;\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\nimport com.calculatorpro.CalculatorProPlugin;\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\n//import net.runelite.client.config.ConfigManager;\n\n@EqualsAndHashCode(callSuper \u003d true)\n@Data\npublic class DisplayField extends JTextField\n{\n//    //todo test if effective\n//    //adds Calculator Pro to config panel\n//    @Provides\n//    CalculatorProConfig provideConfig(ConfigManager configManager) {\n//        return configManager.getConfig(CalculatorProConfig.class);\n//    }\n\n    Double result;\n    public String previousResult \u003d \"0\";\n    public String input \u003d \"\";\n    public String output \u003d \"0\";\n    boolean calcDone \u003d false;\n\n    //called after hitting \u003d\n    protected void calculateResult()\n    {\n        //kanderson66 edit\n        //check end of equation validity\n        //split equation into individual components\n        String[] components \u003d input.split(\"(?\u003c\u003d[-+*/^()\\\\[\\\\]])|(?\u003d[-+*/^()\\\\[\\\\]])\");\n\n        //restrict math if equation is only (up to 3) \"mathless\" operations\n        switch (components.length)\n        {\n            //dont do math on single component\n            case 1:\n                return;\n            //dont do math if only max 1 number\n            case 2:\n                //check for - or (\n                if (components[0].equals(\"-\") || components[0].equals(\"(\"))\n                {\n                    return;\n                }\n            case 3:\n                //check for -( or -- or (- or ((\n                if ((components[0].equals(\"-\") || components[0].equals(\"(\")) \u0026\u0026 (components[1].equals(\"-\") || components[1].equals(\"(\")))\n                {\n                    return;\n                }\n        }\n\n        //cant end in math symbol (remove it)\n        switch (components[components.length-1])\n        {\n            case \"+\":\n            case \"-\":\n            case \"*\":\n            case \"/\":\n            case \"^\":\n            case \"(\":\n                components[components.length-1] \u003d \"\";\n\n                //reform input, re-enter Calculate result\n                input \u003d \"\";\n                for (String component : components)\n                {\n                    input +\u003d component;\n                }\n                calculateResult();\n                return;\n            //last input is a ### - check if ended in a . (remove it)\n            default:\n                //# is a single digit, cant be a .\n                if (components[components.length-1].length() !\u003d 1 ) {\n                    //# ended in . (remove it)\n                    if (components[components.length-1].charAt(components[components.length-1].length()-1) \u003d\u003d \u0027.\u0027)\n                    {\n                        components[components.length-1] \u003d components[components.length-1].substring(0,components[components.length-1].length()-1);\n                        break;\n                    }\n                }\n                break;\n        }\n\n        //count num Open \u0026 closed Parenthesis \u0027(\u0027 and \u0027)\u0027\n        int countOpenParen \u003d 0;\n        int countClosedParen \u003d 0;\n        input\u003d\"\";\n\n        for(String component : components){\n            switch (component){\n                case \"(\":\n                    countOpenParen++;\n                    break;\n                case \")\":\n                    countClosedParen++;\n                    break;\n                default:\n                    break;\n            }\n            //put components back into 1 string if anything changed\n            input +\u003d component;\n        }\n        //if more \u0027(\u0027 than \u0027)\u0027, add as many \u0027)\u0027 to end as needed\n        if (countOpenParen-countClosedParen !\u003d 0)\n        {\n            for(int n\u003d0; n\u003c(countOpenParen-countClosedParen); n++)\n            {\n                input +\u003d \")\";\n            }\n        }\n\n        //evaluate the math equation string\n        result \u003d CalculatorProPlugin.eval(input.replaceAll(\",\",\"\"));\n\n        //check for divide by 0 error message (\"Infinity\")\n        if(result.toString().charAt(0)\u003d\u003d\u0027I\u0027){\n            output \u003d \"Cant divide by 0\";\n            calcDone \u003d true;\n            return;\n        }\n        //todo add ability to custom set how many decimals to display from CalculatorProConfig.numDecimals()\n\n//        CalculatorProConfig config2 \u003d new CalculatorProConfig() {\n//            @Override\n//            public int numDecimals() {\n//                return CalculatorProConfig.super.numDecimals();\n//            }\n//        };\n//\n//        //reduce answer to desired # decimal places or less \u0026 include commas for easier reading\n//        String format \u003d \"#,###\";\n//\n//        if (config2.numDecimals() \u003e 0)\n//        {\n//            format +\u003d \".\";\n//\n//            //limit decimal points to 15 places\n//            if(config2.numDecimals() \u003e 15)\n//            {\n//                for (int n\u003d0; n\u003c15; n++)\n//                {\n//                    format +\u003d \"#\";\n//                }\n//            }\n//            else\n//            {\n//                for (int n\u003d0; n\u003cconfig2.numDecimals(); n++)\n//                {\n//                    format +\u003d \"#\";\n//                }\n//            }\n//        }\n//        DecimalFormat df \u003d new DecimalFormat(format);\n\n\n        //reduce answer to 3 decimal places or less \u0026 include commas for easier reading\n        DecimalFormat df \u003d new DecimalFormat(\"#,###.###\");\n        df.setRoundingMode(RoundingMode.HALF_UP);\n\n        output \u003d df.format(result);\n        calcDone \u003d true;\n        previousResult \u003d output;\n    } //end kanderson66 edit\n\n    protected void reset()\n    {\n        result \u003d 0.0;\n        input \u003d \"\";\n        update();\n    }\n\n    protected void clear()\n    {\n        reset();\n    }\n\n    protected void update()\n    {\n        if(calcDone)\n        {\n            super.setText(this.input + \" \u003d \" + this.output);\n            input \u003d \"\";\n            calcDone \u003d false;\n        }\n        else {\n            super.setText(this.input);\n        }\n        repaint();\n    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\DisplayField.java"},{"fileName":"DisplayPanel.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport java.awt.BorderLayout;\nimport java.awt.Dimension;\nimport javax.swing.*;\nimport javax.swing.border.EmptyBorder;\nimport lombok.Getter;\n\npublic class DisplayPanel extends JPanel\n{\n    @Getter\n    private final DisplayField displayField \u003d new DisplayField();\n\n    public DisplayPanel()\n    {\n        super();\n\n        setLayout(new BorderLayout(4, 4));\n        setBorder(new EmptyBorder(0, 1, 0, 1));\n\n        displayField.setPreferredSize(new Dimension(228, 50));\n        displayField.setMinimumSize(new Dimension(170, 50));\n        displayField.setEditable(false);\n\n        add(displayField, BorderLayout.CENTER);\n\n    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\DisplayPanel.java"},{"fileName":"HistoryItemPanel.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport com.calculatorpro.CalculatorProPlugin;\nimport java.awt.BorderLayout;\nimport java.awt.Dimension;\nimport java.awt.Toolkit;\nimport java.awt.datatransfer.Clipboard;\nimport java.awt.datatransfer.StringSelection;\nimport java.awt.image.BufferedImage;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.MatteBorder;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.util.ImageUtil;\n\npublic class HistoryItemPanel extends JPanel\n{\n    private static final ImageIcon CLIPBOARD_ICON;\n\n    static\n    {\n        BufferedImage clipboardIcon \u003d ImageUtil.loadImageResource(CalculatorProPlugin.class, \"/clipboard_icon.png\");\n        clipboardIcon \u003d ImageUtil.resizeImage(clipboardIcon,20,20);\n        CLIPBOARD_ICON \u003d new ImageIcon(clipboardIcon);\n    }\n\n    public HistoryItemPanel(String line1, String line2)\n    {\n        super();\n\n        setLayout(new BorderLayout());\n        setBackground(ColorScheme.DARKER_GRAY_COLOR);\n        setBorder(new MatteBorder(0, 5, 0, 0, ColorScheme.BRAND_ORANGE));\n\n        JPanel text \u003d new JPanel(new BorderLayout());\n        text.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n        JLabel lineOneLabel \u003d new JLabel(line1);\n        lineOneLabel.setHorizontalAlignment(JLabel.CENTER);\n        JLabel lineTwoLabel \u003d new JLabel(line2);\n        lineTwoLabel.setHorizontalAlignment(JLabel.CENTER);\n        text.add(lineOneLabel, BorderLayout.NORTH);\n        text.add(lineTwoLabel, BorderLayout.SOUTH);\n\n        add(text, BorderLayout.CENTER);\n\n        JButton copy \u003d new JButton(CLIPBOARD_ICON);\n        copy.setPreferredSize(new Dimension(40, 40));\n        copy.setToolTipText(\"Copy result to clipboard\");\n        copy.addActionListener(e -\u003e\n        {\n            StringSelection selection \u003d new StringSelection(line2);\n            Clipboard clipboard \u003d Toolkit.getDefaultToolkit().getSystemClipboard();\n            clipboard.setContents(selection, null);\n        });\n\n        add(copy, BorderLayout.EAST);\n    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\HistoryItemPanel.java"},{"fileName":"HistoryPanel.java","content":"/*\n * Copyright (c) 2020, Spedwards \u003chttps://github.com/Spedwards\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.calculatorpro.uiSpedwards;\n\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.Insets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.JPanel;\n\npublic class HistoryPanel extends JPanel\n{\n    private final List\u003cHistoryItemPanel\u003e itemPanels \u003d new ArrayList\u003c\u003e();\n    private final GridBagConstraints c;\n\n    public HistoryPanel()\n    {\n        super();\n\n        setLayout(new GridBagLayout());\n\n        c \u003d new GridBagConstraints();\n        c.fill \u003d GridBagConstraints.HORIZONTAL;\n        c.gridx \u003d 0;\n        c.gridy \u003d 0;\n        c.weightx \u003d 1;\n        c.weighty \u003d 0;\n        c.insets \u003d new Insets(0, 0, 7, 0);\n    }\n\n    protected void addHistoryItem(String line1, String line2)\n    {\n        // Herein lies my horrible attempt at creating a new item at the top and pushing everything else down\n        // \\_()_/\n        removeAll();\n        HistoryItemPanel itemPanel \u003d new HistoryItemPanel(line1, line2);\n        itemPanels.add(0, itemPanel);\n        c.gridy \u003d 0;\n        itemPanels.forEach(panel -\u003e {\n            add(panel, c, 0);\n            c.gridy++;\n        });\n\n        repaint();\n        revalidate();\n    }\n\n    protected void clearHistory()\n    {\n        removeAll();\n        itemPanels.clear();\n        repaint();\n        revalidate();\n    }\n}","filePath":"src\\main\\java\\com\\calculatorpro\\uiSpedwards\\HistoryPanel.java"},{"fileName":"CalculatorProPluginTest.java","content":"package com.calculatorpro;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class CalculatorProPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(CalculatorProPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\calculatorpro\\CalculatorProPluginTest.java"}]},{"commit":"87b8458481166233f6756130fb18b51d5e5b5de8","repository":"https://github.com/cloudAspect/unregistered-hypercam-2.git","internalName":"unregistered-hypercam-2","files":[{"fileName":"UnregisteredHypercam2Overlay.java","content":"package cloudAspect.hypercam2;\n\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport javax.inject.Inject;\n\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.util.ImageUtil;\n\nclass UnregisteredHypercam2Overlay extends Overlay {\n\t\n\tprivate Client client;\n\t\n\tprivate BufferedImage image;\n\t\n\t@Inject\n\tprivate UnregisteredHypercam2Overlay(Client client) {\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ALWAYS_ON_TOP);\n\t\tthis.client \u003d client;\n\t\tthis.image \u003d ImageUtil.loadImageResource(getClass(), \"hypercam.png\");\n\t}\n\t\n\t@Override\n\tpublic Dimension render(Graphics2D graphics) {\n\t\tif (image !\u003d null) {\n\t\t\tgraphics.drawImage(image, 0,  0, null);\n\t\t}\n\t\treturn null;\n\t}\n}\n","filePath":"src\\main\\java\\cloudAspect\\hypercam2\\UnregisteredHypercam2Overlay.java"},{"fileName":"UnregisteredHypercam2Plugin.java","content":"package cloudAspect.hypercam2;\n\nimport com.google.inject.Provides;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\nimport javax.inject.Inject;\n\n@PluginDescriptor(\n\t\tname \u003d \"Unregistered Hypercam 2\",\n\t\tdescription \u003d \"Shows the Unregistered Hypercam 2 logo as an overlay\",\n\t\ttags \u003d {\"overlay\", \"meme\", \"fun\", \"cosmetic\"}\n)\npublic class UnregisteredHypercam2Plugin extends Plugin {\n\t\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\t\n\t@Inject\n\tprivate UnregisteredHypercam2Overlay overlay;\n\t\n\t\n\t\n\t@Override\n\tprotected void startUp() throws Exception {\n\t\toverlayManager.add(overlay);\n\t}\n\t\n\t@Override\n\tprotected void shutDown() throws Exception {\n\t\toverlayManager.remove(overlay);\n\t}\n}\n","filePath":"src\\main\\java\\cloudAspect\\hypercam2\\UnregisteredHypercam2Plugin.java"},{"fileName":"UnregisteredHypercam2PluginTest.java","content":"package cloudAspect.hypercam2;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class UnregisteredHypercam2PluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(UnregisteredHypercam2Plugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\cloudAspect\\hypercam2\\UnregisteredHypercam2PluginTest.java"}]},{"commit":"1bf8c29b66807b4c834a0e250d91b32835257ba1","repository":"https://github.com/ConradMS/Sprite-Markers.git","internalName":"sprite-markers","files":[{"fileName":"ImportExportTool.java","content":"package com.spritemarkers;\n\nimport com.google.common.reflect.TypeToken;\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.MenuEntry;\nimport net.runelite.api.widgets.WidgetInfo;\nimport net.runelite.client.chat.ChatMessageManager;\nimport net.runelite.client.chat.QueuedMessage;\nimport net.runelite.client.menus.MenuManager;\nimport net.runelite.client.menus.WidgetMenuOption;\n\nimport javax.inject.Inject;\nimport java.awt.Toolkit;\nimport java.awt.datatransfer.DataFlavor;\nimport java.awt.datatransfer.StringSelection;\nimport java.awt.datatransfer.UnsupportedFlavorException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\n\npublic class ImportExportTool\n{\n    private static final WidgetMenuOption EXPORT_SPRITE_MARKERS \u003d new WidgetMenuOption(\"Export\", \"Sprite Markers\", WidgetInfo.MINIMAP_TOGGLE_RUN_ORB);\n    private static final WidgetMenuOption IMPORT_SPRITE_MARKERS \u003d new WidgetMenuOption(\"Import\", \"Sprite Markers\", WidgetInfo.MINIMAP_TOGGLE_RUN_ORB);\n\n    private final SpriteMarkersPlugin spriteMarkersPlugin;\n    private final Client client;\n    private final MenuManager menuManager;\n    private final ChatMessageManager chatMessageManager;\n    private final Gson gson;\n\n    @Inject\n    private ImportExportTool(SpriteMarkersPlugin plugin, Client client, ChatMessageManager chatMessageManager, MenuManager menuManager, Gson gson)\n    {\n        this.spriteMarkersPlugin \u003d plugin;\n        this.client \u003d client;\n        this.menuManager \u003d menuManager;\n        this.chatMessageManager \u003d chatMessageManager;\n        this.gson \u003d gson;\n    }\n\n    void addOptions()\n    {\n        menuManager.addManagedCustomMenu(EXPORT_SPRITE_MARKERS, this::exportSpriteMarkers);\n        menuManager.addManagedCustomMenu(IMPORT_SPRITE_MARKERS, this::importSpriteMarkers);\n    }\n\n    void removeOptions()\n    {\n        menuManager.removeManagedCustomMenu(EXPORT_SPRITE_MARKERS);\n        menuManager.removeManagedCustomMenu(IMPORT_SPRITE_MARKERS);\n    }\n\n    private void exportSpriteMarkers(MenuEntry menuEntry)\n    {\n        final ArrayList\u003cSpriteMarker\u003e spriteMarkersLoaded \u003d spriteMarkersPlugin.getSpriteMarkersLoaded();\n        if (spriteMarkersLoaded.isEmpty())\n        {\n            addChatMessage(\"There are no loaded sprite markers to export\");\n            return;\n        }\n\n        final int[] loadedRegions \u003d client.getMapRegions();\n        if(loadedRegions \u003d\u003d null || loadedRegions.length \u003d\u003d 0)\n        {\n            return;\n        }\n\n        ArrayList\u003cSpriteMarkerID\u003e spriteIDSToSave \u003d new ArrayList\u003c\u003e();\n        for(int region : loadedRegions)\n        {\n            spriteIDSToSave.addAll(spriteMarkersPlugin.jsonToSprite(region));\n        }\n\n        String markersJSONString \u003d this.gson.toJson(spriteIDSToSave);\n\n        Toolkit.getDefaultToolkit()\n                .getSystemClipboard()\n                .setContents(new StringSelection(markersJSONString), null);\n        addChatMessage(\"Copied loaded sprite markers to clipboard\");\n    }\n\n    private void importSpriteMarkers(MenuEntry menuEntry)\n    {\n        final String text;\n        try\n        {\n           text \u003d Toolkit.getDefaultToolkit().getSystemClipboard()\n                   .getData(DataFlavor.stringFlavor)\n                   .toString();\n        }\n        catch (IOException | UnsupportedFlavorException e)\n        {\n            addChatMessage(\"Clipboard error - could not import sprite markers\");\n            return;\n        }\n\n        if(text.isEmpty() || text \u003d\u003d null)\n        {\n            addChatMessage(\"Empty clipboard - could not import sprite markers\");\n            return;\n        }\n\n        ArrayList\u003cSpriteMarkerID\u003e spriteMarkerIDS \u003d new ArrayList\u003c\u003e();\n\n        try\n        {\n            spriteMarkerIDS \u003d gson.fromJson(text, new TypeToken\u003cArrayList\u003cSpriteMarkerID\u003e\u003e(){}.getType());\n        }catch (JsonSyntaxException e)\n        {\n            addChatMessage(\"No Sprites in clipboard/Wrong formatting - could not import sprite markers\");\n            return;\n        }\n\n        if (spriteMarkerIDS \u003d\u003d null || spriteMarkerIDS.isEmpty())\n        {\n            addChatMessage(\"No Sprite Markers in clipboard\");\n            return;\n        }\n\n        addToConfig(spriteMarkerIDS);\n    }\n\n    private void addToConfig(ArrayList\u003cSpriteMarkerID\u003e spriteMarkerIDS)\n    {\n        HashMap\u003cInteger, ArrayList\u003cSpriteMarkerID\u003e\u003e IDToMarkers \u003d new HashMap\u003c\u003e();\n        int currRegion;\n        for(SpriteMarkerID spriteMarkerID : spriteMarkerIDS)\n        {\n            currRegion \u003d spriteMarkerID.getRegionId();\n            if(IDToMarkers.containsKey(currRegion))\n            {\n                IDToMarkers.get(currRegion).add(spriteMarkerID);\n            }\n            else\n            {\n                IDToMarkers.put(currRegion, new ArrayList\u003c\u003e(Collections.singletonList(spriteMarkerID)));\n            }\n        }\n\n        for(int regionId : IDToMarkers.keySet())\n        {\n            spriteMarkersPlugin.saveSprite(regionId, IDToMarkers.get(regionId));\n        }\n        spriteMarkersPlugin.loadSprites();\n        addChatMessage(\"Sprite Markers imported\");\n    }\n\n    private void addChatMessage(String message)\n    {\n        chatMessageManager.queue(QueuedMessage.builder()\n                .type(ChatMessageType.CONSOLE)\n                .runeLiteFormattedMessage(message)\n                .build()\n        );\n    }\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\ImportExportTool.java"},{"fileName":"MinimapSpriteOverlay.java","content":"package com.spritemarkers;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.game.SpriteManager;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.util.ImageUtil;\n\nimport javax.inject.Inject;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\n\npublic class MinimapSpriteOverlay extends Overlay\n{\n\n    private final Client client;\n    private final SpriteMarkersPlugin plugin;\n    private final SpriteMarkersConfig config;\n\n    private final static int MINIMAP_RADIUS \u003d 16;\n    private final static int BIG_SPRITE \u003d 250;\n\n    @Inject\n    SpriteManager spriteManager;\n\n    @Inject\n    public MinimapSpriteOverlay(Client client, SpriteMarkersConfig config, SpriteMarkersPlugin plugin)\n    {\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setPriority(OverlayPriority.LOW);\n        setLayer(OverlayLayer.ABOVE_WIDGETS);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n\n        if(!config.showSprites() || !config.showOnMap())\n        {\n            return null;\n        }\n\n        final ArrayList\u003cSpriteMarker\u003e spriteMarkers \u003d plugin.getSpriteMarkersLoaded();\n\n        if(spriteMarkers.isEmpty())\n        {\n            return null;\n        }\n\n        for(SpriteMarker spriteMarker : spriteMarkers)\n        {\n            drawMinimapSprite(graphics, spriteMarker);\n        }\n        return null;\n    }\n\n    private void drawMinimapSprite(Graphics2D graphics, SpriteMarker spriteMarker)\n    {\n        WorldPoint playerLoc \u003d client.getLocalPlayer().getWorldLocation();\n\n        if(playerLoc !\u003d null \u0026\u0026 playerLoc.distanceTo(spriteMarker.getWorldPoint()) \u003c\u003d MINIMAP_RADIUS)\n        {\n            LocalPoint localPoint \u003d LocalPoint.fromWorld(client, spriteMarker.worldPoint);\n\n            if(localPoint \u003d\u003d null)\n            {\n                return;\n            }\n\n            Point miniMapPoint \u003d Perspective.localToMinimap(client, localPoint);\n\n            if(miniMapPoint \u003d\u003d null)\n            {\n                return;\n            }\n\n            BufferedImage toImage \u003d  spriteManager.getSprite(1, 0);\n\n            try\n            {\n                toImage \u003d spriteManager.getSprite(spriteMarker.getSpriteId(), 0);\n            } catch (IllegalArgumentException e)\n            {\n                // not a sprite\n            }\n\n            if(toImage !\u003d null)\n            {\n                int scaleFactor \u003d Math.min(toImage.getHeight(), toImage.getWidth()) / config.largeMapSpriteSize();\n\n                if(Math.max(toImage.getHeight(), toImage.getWidth()) \u003c BIG_SPRITE)\n                {\n                    scaleFactor \u003d Math.min(toImage.getHeight(), toImage.getWidth()) / config.smallMapSpriteSize();\n                }\n\n                scaleFactor \u003d Math.max(scaleFactor, 1);\n\n                toImage \u003d ImageUtil.resizeImage(toImage, toImage.getWidth() / scaleFactor, toImage.getHeight() / scaleFactor);\n                Point offsetPoint \u003d new Point(miniMapPoint.getX() - toImage.getWidth() / 2, miniMapPoint.getY() - toImage.getHeight() / 2);\n                OverlayUtil.renderImageLocation(graphics, offsetPoint, toImage);\n            }\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\MinimapSpriteOverlay.java"},{"fileName":"SpriteMarker.java","content":"package com.spritemarkers;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport net.runelite.api.coords.WorldPoint;\n\n@Getter\n@Setter\npublic class SpriteMarker\n{\n    int spriteId;\n    int scale;\n    WorldPoint worldPoint;\n\n    public SpriteMarker(int spriteId, int scale, WorldPoint worldPoint)\n    {\n        this.spriteId \u003d spriteId;\n        this.scale \u003d scale;\n        this.worldPoint \u003d worldPoint;\n    }\n\n    public String toString()\n    {\n        return this.worldPoint.toString();\n    }\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\SpriteMarker.java"},{"fileName":"SpriteMarkerID.java","content":"package com.spritemarkers;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class SpriteMarkerID {\n    private int RegionId;\n    private int RegionX;\n    private int RegionY;\n    private int plane;\n    private int spriteId;\n    private int scale;\n\n    public SpriteMarkerID (int regionId, int regionX, int regionY, int plane, int spriteId, int scale)\n    {\n        setRegionId(regionId);\n        setRegionX(regionX);\n        setRegionY(regionY);\n        setPlane(plane);\n        setSpriteId(spriteId);\n        setScale(scale);\n    }\n\n    public boolean equals(SpriteMarkerID spriteMarkerID)\n    {\n        return spriteMarkerID.getRegionId() \u003d\u003d this.getRegionId() \u0026\u0026\n                spriteMarkerID.getRegionX() \u003d\u003d this.getRegionX() \u0026\u0026\n                spriteMarkerID.getRegionY() \u003d\u003d this.getRegionY() \u0026\u0026\n                spriteMarkerID.getPlane() \u003d\u003d this.getPlane();\n    }\n}","filePath":"src\\main\\java\\com\\spritemarkers\\SpriteMarkerID.java"},{"fileName":"SpriteMarkersConfig.java","content":"package com.spritemarkers;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"spriteMarkers\")\npublic interface SpriteMarkersConfig extends Config\n{\n\tString SHOW_IMPORT \u003d \"show import\";\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"showSprites\",\n\t\t\tname \u003d \"Display Sprites\",\n\t\t\tdescription \u003d \"Hides/Shows ground sprites\"\n\t)\n\tdefault boolean showSprites()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"spriteId\",\n\t\t\tname \u003d \"Sprite ID\",\n\t\t\tdescription \u003d \"What Sprite Id will be added\"\n\t)\n\tdefault int spriteID()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"scale\",\n\t\t\tname \u003d \"Sprite Scale\",\n\t\t\tdescription \u003d \"The Scale of the sprite as a percent\"\n\t)\n\tdefault int scale()\n\t{\n\t\treturn 100;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"showOnMap\",\n\t\t\tname \u003d \"Show On Map\",\n\t\t\tdescription \u003d \"Show the sprite on the minimap or not\"\n\t)\n\tdefault boolean showOnMap()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"smallMapSpriteSize\",\n\t\t\tname \u003d \"Small Sprite Map Size\",\n\t\t\tdescription \u003d \"The size that small sprites should be rendered on the minimap\"\n\t)\n\tdefault int smallMapSpriteSize() {return 8; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"largeMapSpriteSize\",\n\t\t\tname \u003d \"Large Sprite Map Size\",\n\t\t\tdescription \u003d \"The size that large sprites should be rendered on the minimap\"\n\t)\n\tdefault int largeMapSpriteSize() {return 16; }\n\n\t@ConfigItem(\n\t\t\tposition \u003d 7,\n\t\t\tkeyName \u003d \"highlightSprites\",\n\t\t\tname \u003d \"Show Sprite Tiles\",\n\t\t\tdescription \u003d \"Highlight the tiles sprites on to edit easier\"\n\t)\n\tdefault boolean highlightSprites() {return false; }\n\n\n\t@ConfigItem(\n\t\t\tposition \u003d 8,\n\t\t\tkeyName \u003d \"clear\",\n\t\t\tname \u003d \"Clear Sprites\",\n\t\t\tdescription \u003d \"Type clear to clear all loaded sprites\"\n\t)\n\tdefault String clear()\n\t{\n\t\treturn \"------\";\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 9,\n\t\t\tkeyName \u003d SHOW_IMPORT,\n\t\t\tname \u003d \"Show Import/Export\",\n\t\t\tdescription \u003d \"Show the import and export options under the run minimap orb\"\n\t)\n\tdefault boolean showImport() {return false;}\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\SpriteMarkersConfig.java"},{"fileName":"SpriteMarkersOverlay.java","content":"package com.spritemarkers;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport javax.inject.Inject;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.SpriteManager;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.util.ImageUtil;\n\npublic class SpriteMarkersOverlay extends Overlay\n{\n\n    private final Client client;\n    private final SpriteMarkersPlugin plugin;\n    private final SpriteMarkersConfig config;\n\n    private static final int MAX_TILES \u003d 32;\n\n    @Inject\n    SpriteManager spriteManager;\n\n    @Inject\n    private ConfigManager configManager;\n\n    @Inject\n    public SpriteMarkersOverlay(Client client, SpriteMarkersConfig config, SpriteMarkersPlugin plugin)\n    {\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setPriority(OverlayPriority.LOW);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        if(!(config.showSprites()))\n        {\n            return null;\n        }\n        final ArrayList\u003cSpriteMarker\u003e spriteMarkers \u003d plugin.getSpriteMarkersLoaded();\n        if (spriteMarkers.isEmpty())\n        {\n            return null;\n        }\n\n        for(final SpriteMarker spriteMarker : spriteMarkers)\n        {\n            BufferedImage toImage \u003d  spriteManager.getSprite(1, 0);\n\n            try\n            {\n                toImage \u003d spriteManager.getSprite(spriteMarker.getSpriteId(), 0);\n            } catch (IllegalArgumentException e)\n            {\n                // not a sprite\n            }\n\n            WorldPoint playerLoc \u003d client.getLocalPlayer().getWorldLocation();\n\n            if(toImage !\u003d null \u0026\u0026 spriteMarker.worldPoint.distanceTo(playerLoc) \u003c\u003d MAX_TILES)\n            {\n                final WorldPoint worldLoc \u003d spriteMarker.getWorldPoint();\n                final LocalPoint locPoint \u003d LocalPoint.fromWorld(client, worldLoc);\n\n                if (locPoint \u003d\u003d null)\n                {\n                    return null;\n                }\n\n                toImage \u003d ImageUtil.resizeImage(toImage, toImage.getWidth() * spriteMarker.getScale() / 100, toImage.getHeight() * spriteMarker.getScale() / 100);\n                OverlayUtil.renderImageLocation(client, graphics, locPoint, toImage, 0);\n            }\n        }\n\n        if (config.clear().equals(\"clear\"))\n        {\n\n            for(SpriteMarker spriteMarker : spriteMarkers)\n            {\n                if(configManager.getConfiguration(SpriteMarkersPlugin.CONFIG_GROUP, SpriteMarkersPlugin.REGION + spriteMarker.getWorldPoint().getRegionID()) !\u003d null)\n                    configManager.unsetConfiguration(SpriteMarkersPlugin.CONFIG_GROUP, SpriteMarkersPlugin.REGION + spriteMarker.getWorldPoint().getRegionID());\n            }\n\n            plugin.getSpriteMarkersLoaded().clear();\n        }\n        return null;\n    }\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\SpriteMarkersOverlay.java"},{"fileName":"SpriteMarkersPlugin.java","content":"package com.spritemarkers;\n\nimport com.google.common.reflect.TypeToken;\nimport com.google.gson.Gson;\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.Getter;\nimport net.runelite.api.Client;\nimport net.runelite.api.Tile;\nimport net.runelite.api.MenuAction;\nimport net.runelite.api.GameState;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.MenuEntryAdded;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n@PluginDescriptor(\n\t\tname \u003d \"Sprite Markers\",\n\t\tdescription \u003d \"Mark tiles with sprites\",\n\t\ttags \u003d {\"overlay\", \"tiles\"}\n)\npublic class SpriteMarkersPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate SpriteMarkersConfig config;\n\n\t@Inject\n\tprivate SpriteMarkersOverlay overlay;\n\n\t@Inject\n\tprivate TileHighlighterOverlay highlighterOverlay;\n\n\t@Inject\n\tprivate MinimapSpriteOverlay minimapSpriteOverlay;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ImportExportTool importExportTool;\n\n\t@Inject\n\tprivate Gson gson;\n\n\tprivate final static int LEFT_CONTROL_KEYCODE \u003d 82;\n\tprivate final static String ADD_SPRITE \u003d \"Add Sprite\";\n\tprivate final static String REMOVE_SPRITE \u003d \"Remove Sprite\";\n\tprivate final static String CANCEL \u003d \"Cancel\";\n\n\tprotected static final  String CONFIG_GROUP \u003d \"spriteMarkers\";\n\tprotected static final String REGION \u003d \"Region_\";\n\n\t@Getter\n\tprivate final ArrayList\u003cSpriteMarker\u003e spriteMarkersLoaded \u003d new ArrayList\u003c\u003e();\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\toverlayManager.add(overlay);\n\t\toverlayManager.add(highlighterOverlay);\n\t\toverlayManager.add(minimapSpriteOverlay);\n\t\timportExportTool.addOptions();\n\t\tloadSprites();\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\toverlayManager.remove(overlay);\n\t\toverlayManager.remove(highlighterOverlay);\n\t\toverlayManager.remove(minimapSpriteOverlay);\n\t\timportExportTool.removeOptions();\n\t\tspriteMarkersLoaded.clear();\n\t}\n\n\tprivate boolean containsSprite(ArrayList\u003cSpriteMarkerID\u003e spriteMarkerIDS, SpriteMarkerID targetSpriteMarker)\n\t{\n\t\tfor(SpriteMarkerID spriteMarkerID : spriteMarkerIDS)\n\t\t{\n\t\t\tif(spriteMarkerID.equals(targetSpriteMarker))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Subscribe\n\tpublic void onMenuEntryAdded(MenuEntryAdded menuEntryEvent)\n\t{\n\t\tfinal boolean markerKeyPressed \u003d client.isKeyPressed(LEFT_CONTROL_KEYCODE);\n\n\t\tif (markerKeyPressed \u0026\u0026 menuEntryEvent.getOption().equals(CANCEL))\n\t\t{\n\t\t\tfinal Tile targetTile \u003d client.getSelectedSceneTile();\n\n\t\t\tif(targetTile !\u003d null)\n\t\t\t{\n\t\t\t\tfinal LocalPoint localPoint \u003d targetTile.getLocalLocation();\n\t\t\t\tfinal WorldPoint worldLoc \u003d WorldPoint.fromLocalInstance(client, localPoint);\n\t\t\t\tfinal int regionID \u003d worldLoc.getRegionID();\n\t\t\t\tfinal SpriteMarkerID targetSpriteMarkerID \u003d new SpriteMarkerID(regionID,\n\t\t\t\t\t\tworldLoc.getRegionX(), worldLoc.getRegionY(), client.getPlane(),\n\t\t\t\t\t\tconfig.spriteID(), config.scale());\n\n\t\t\t\tfinal ArrayList\u003cSpriteMarkerID\u003e savedSprites \u003d jsonToSprite(regionID);\n\t\t\t\tfinal boolean spriteHere \u003d containsSprite(savedSprites, targetSpriteMarkerID);\n\n\t\t\t\tif (!spriteHere)\n\t\t\t\t{\n\t\t\t\t\tclient.createMenuEntry(-1).setOption(ADD_SPRITE)\n\t\t\t\t\t\t\t.setTarget(menuEntryEvent.getTarget())\n\t\t\t\t\t\t\t.setType(MenuAction.RUNELITE)\n\t\t\t\t\t\t\t.onClick(e -\u003e addTileSprite());\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tclient.createMenuEntry(-1).setOption(REMOVE_SPRITE)\n\t\t\t\t\t\t\t.setTarget(menuEntryEvent.getTarget())\n\t\t\t\t\t\t\t.setType(MenuAction.RUNELITE)\n\t\t\t\t\t\t\t.onClick(e -\u003e removeTileSprite());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tloadSprites();\n\t\t}\n\t}\n\n\tprivate void addTileSprite()\n\t{\n\t\tfinal Tile targetTile \u003d client.getSelectedSceneTile();\n\t\tif (targetTile !\u003d null)\n\t\t{\n\t\t\tfinal LocalPoint localPoint \u003d targetTile.getLocalLocation();\n\t\t\tfinal WorldPoint worldLoc \u003d WorldPoint.fromLocalInstance(client, localPoint);\n\t\t\tfinal int regionID \u003d worldLoc.getRegionID();\n\t\t\tSpriteMarkerID spriteMarkerID \u003d new SpriteMarkerID(regionID, worldLoc.getRegionX(), worldLoc.getRegionY(),\n\t\t\t\t\tclient.getPlane(), config.spriteID(), config.scale());\n\t\t\tsaveSprite(regionID, spriteMarkerID);\n\t\t\tloadSprites();\n\t\t}\n\n\t}\n\n\tprivate void removeTileSprite()\n\t{\n\t\tfinal Tile tile \u003d client.getSelectedSceneTile();\n\n\t\tif(tile \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal LocalPoint localPoint \u003d tile.getLocalLocation();\n\t\tfinal WorldPoint targetLocation \u003d WorldPoint.fromLocalInstance(client, localPoint);\n\t\tfinal int regionID \u003d targetLocation.getRegionID();\n\t\tfinal SpriteMarkerID TargetSpriteMarkerID \u003d new SpriteMarkerID(regionID, targetLocation.getRegionX(),\n\t\t\t\ttargetLocation.getRegionY(), client.getPlane(), config.spriteID(), config.scale());\n\n\t\tArrayList\u003cSpriteMarkerID\u003e currSprites \u003d jsonToSprite(regionID);\n\n\t\tfor (SpriteMarkerID spriteMarkerID : currSprites)\n\t\t{\n\t\t\tif(spriteMarkerID.equals(TargetSpriteMarkerID))\n\t\t\t{\n\t\t\t\tcurrSprites.remove(spriteMarkerID);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!currSprites.isEmpty())\n\t\t{\n\t\t\tString spriteMarkersToJson \u003d gson.toJson(currSprites);\n\t\t\tconfigManager.setConfiguration(CONFIG_GROUP, REGION + regionID, spriteMarkersToJson);\n\t\t} else\n\t\t{\n\t\t\tconfigManager.unsetConfiguration(CONFIG_GROUP, REGION + regionID);\n\t\t}\n\n\t\tloadSprites();\n\t}\n\n\tvoid saveSprite(int regionId, SpriteMarkerID newSprite)\n\t{\n\t\tArrayList\u003cSpriteMarkerID\u003e currPoints \u003d jsonToSprite(regionId);\n\t\tcurrPoints.add(newSprite);\n\n\t\tString spriteMarkersToJson \u003d gson.toJson(currPoints);\n\t\tconfigManager.setConfiguration(CONFIG_GROUP, REGION + regionId, spriteMarkersToJson);\n\t}\n\n\tvoid saveSprite(int regionId, ArrayList\u003cSpriteMarkerID\u003e newSprites)\n\t{\n\t\tArrayList\u003cSpriteMarkerID\u003e currPoints \u003d jsonToSprite(regionId);\n\t\tcurrPoints.addAll(newSprites);\n\n\t\tString spriteMarkersToJson \u003d gson.toJson(currPoints);\n\t\tconfigManager.setConfiguration(CONFIG_GROUP, REGION + regionId, spriteMarkersToJson);\n\t}\n\n\tvoid loadSprites()\n\t{\n\t\tspriteMarkersLoaded.clear();\n\t\tint[] loadedRegions \u003d client.getMapRegions();\n\n\t\tif(loadedRegions !\u003d null)\n\t\t{\n\t\t\tfor(int loadedRegion : loadedRegions)\n\t\t\t{\n\t\t\t\tArrayList\u003cSpriteMarkerID\u003e regionSprites \u003d jsonToSprite(loadedRegion);\n\t\t\t\tArrayList\u003cSpriteMarker\u003e spriteMarkers \u003d getSpriteMarkers(regionSprites);\n\t\t\t\tspriteMarkersLoaded.addAll(spriteMarkers);\n\t\t\t}\n\t\t}\n\t}\n\n\tArrayList\u003cSpriteMarkerID\u003e jsonToSprite(int regionId)\n\t{\n\t\tString json \u003d configManager.getConfiguration(CONFIG_GROUP, REGION + regionId);\n\t\tif(json !\u003d null \u0026\u0026 !json.equals(\"\"))\n\t\t{\n\t\t\treturn gson.fromJson(json, new TypeToken\u003cArrayList\u003cSpriteMarkerID\u003e\u003e(){}.getType());\n\t\t} else\n\t\t{\n\t\t\treturn new ArrayList\u003cSpriteMarkerID\u003e();\n\t\t}\n\t}\n\n\tprivate ArrayList\u003cSpriteMarker\u003e getSpriteMarkers(ArrayList\u003cSpriteMarkerID\u003e regionSprites)\n\t{\n\t\tif(regionSprites.isEmpty())\n\t\t{\n\t\t\treturn new ArrayList\u003cSpriteMarker\u003e();\n\t\t}\n\t\tArrayList\u003cSpriteMarker\u003e spriteMarkers \u003d new ArrayList\u003cSpriteMarker\u003e();\n\n\t\tfor (SpriteMarkerID spriteMarkerID : regionSprites)\n\t\t{\n\t\t\tWorldPoint worldLoc \u003d WorldPoint.fromRegion(spriteMarkerID.getRegionId(), spriteMarkerID.getRegionX(),\n\t\t\t\t\tspriteMarkerID.getRegionY(), spriteMarkerID.getPlane());\n\n\t\t\tSpriteMarker spriteMarker \u003d new SpriteMarker(spriteMarkerID.getSpriteId(), spriteMarkerID.getScale(), worldLoc);\n\t\t\tspriteMarkers.add(spriteMarker);\n\t\t\tfinal Collection\u003cWorldPoint\u003e localWorldPoints \u003d WorldPoint.toLocalInstance(client, spriteMarker.getWorldPoint());\n\n\t\t\tfor(WorldPoint worldPoint : localWorldPoints)\n\t\t\t{\n\t\t\t\tspriteMarkers.add(new SpriteMarker(spriteMarkerID.getSpriteId(), spriteMarkerID.getScale(), worldPoint));\n\t\t\t}\n\t\t}\n\n\t\treturn spriteMarkers;\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\t\tif(configChanged.getGroup().equals(CONFIG_GROUP) \u0026\u0026 configChanged.getKey().equals(SpriteMarkersConfig.SHOW_IMPORT))\n\t\t{\n\t\t\tif(config.showImport())\n\t\t\t{\n\t\t\t\timportExportTool.addOptions();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\timportExportTool.removeOptions();\n\t\t\t}\n\t\t}\n\t}\n\n\n\t@Provides\n\tSpriteMarkersConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(SpriteMarkersConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\SpriteMarkersPlugin.java"},{"fileName":"TileHighlighterOverlay.java","content":"package com.spritemarkers;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayUtil;\n\nimport javax.inject.Inject;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.util.ArrayList;\n\npublic class TileHighlighterOverlay extends Overlay\n{\n\n    private final Client client;\n    private final SpriteMarkersPlugin plugin;\n    private final SpriteMarkersConfig config;\n\n    private static final int MAX_TILES \u003d 32;\n\n    @Inject\n    public TileHighlighterOverlay(Client client, SpriteMarkersConfig config, SpriteMarkersPlugin plugin)\n    {\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setPriority(OverlayPriority.MED);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n\n        if(!config.showSprites() || !config.highlightSprites())\n        {\n            return null;\n        }\n\n        final ArrayList\u003cSpriteMarker\u003e spriteMarkers \u003d plugin.getSpriteMarkersLoaded();\n\n        if(spriteMarkers.isEmpty())\n        {\n            return null;\n        }\n\n        for(SpriteMarker spriteMarker : spriteMarkers)\n        {\n            WorldPoint playerLoc \u003d client.getLocalPlayer().getWorldLocation();\n\n            if(playerLoc.distanceTo(spriteMarker.getWorldPoint()) \u003c\u003d MAX_TILES)\n            {\n                WorldPoint worldLoc \u003d spriteMarker.getWorldPoint();\n                LocalPoint localPoint \u003d LocalPoint.fromWorld(client, worldLoc);\n\n                if(localPoint \u003d\u003d null)\n                {\n                    return null;\n                }\n\n                Polygon tilePolygon \u003d Perspective.getCanvasTilePoly(client, localPoint);\n                if(tilePolygon !\u003d null)\n                {\n                    OverlayUtil.renderPolygon(graphics, tilePolygon, Color.WHITE);\n                }\n            }\n        }\n        return null;\n    }\n}\n","filePath":"src\\main\\java\\com\\spritemarkers\\TileHighlighterOverlay.java"},{"fileName":"SpriteMarkers.java","content":"package com.spritemarkers;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class SpriteMarkers\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(SpriteMarkersPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\spritemarkers\\SpriteMarkers.java"}]},{"commit":"9f58304e61b4f2c8e494648d48e0165bbc3b1c1c","repository":"https://github.com/JohnathonNow/runelite-cosmetic-network.git","internalName":"cosmetics","files":[{"fileName":"CosmeticsCache.java","content":"package com.cosmetics;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\nimport lombok.extern.slf4j.Slf4j;\nimport okhttp3.*;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\n\n@Slf4j\npublic class CosmeticsCache {\n    private static final String DATABASE_URL \u003d \"https://billiardssketch.fun/cosmetics/\";\n    private static final int TIME_TO_LIVE \u003d 5 * 60 * 1000;\n    private final HashMap\u003cString, CosmeticsData\u003e cache \u003d new HashMap\u003c\u003e();\n    private final OkHttpClient httpClient \u003d new OkHttpClient();\n\n    public void clear() {\n        cache.clear();\n    }\n\n    public CosmeticsPlayer getCosmetics(String username) {\n        if (isValid(username)) {\n            return cache.get(username).getPlayer();\n        } else {\n            return null;\n        }\n    }\n\n    public void save(CosmeticsPlayer p, String apiKey) {\n        synchronized (cache) {\n            cache.put(p.name, new CosmeticsData(System.currentTimeMillis(), p));\n        }\n        httpClient.newCall(buildRequestSave(p, apiKey)).enqueue(new Callback()\n        {\n            @Override\n            public void onFailure(Call call, IOException e)\n            {\n\n            }\n\n            @Override\n            public void onResponse(Call call, Response response)\n            {\n\n            }\n        });\n    }\n\n    public void fillCache(String[] names) {\n        String[] filtered \u003d Arrays.stream(names).filter((x) -\u003e !isValid(x)).toArray(String[]::new);\n        if (filtered.length \u003d\u003d 0) {\n            return;\n        }\n        synchronized (cache) {\n            long time \u003d System.currentTimeMillis();\n            for (String s: filtered) {\n                CosmeticsData cd \u003d cache.get(s);\n                if (cd !\u003d null) {\n                    cd.setFetchedTime(time);\n                } else {\n                    cache.put(s, new CosmeticsData(time, null));\n                }\n            }\n        }\n        httpClient.newCall(buildRequestFetch(filtered)).enqueue(new Callback()\n        {\n            @Override\n            public void onFailure(Call call, IOException e)\n            {\n\n            }\n\n            @Override\n            public void onResponse(Call call, Response response) throws IOException\n            {\n                synchronized (cache) {\n                    Gson gson \u003d new Gson();\n                    long time \u003d System.currentTimeMillis();\n                    List\u003cCosmeticsPlayer\u003e data \u003d gson.fromJson(response.body().string(), new TypeToken\u003cList\u003cCosmeticsPlayer\u003e\u003e() {}.getType());\n                    for (CosmeticsPlayer p: data) {\n                        cache.put(p.name, new CosmeticsData(time, p));\n                    }\n                }\n            }\n        });\n    }\n\n    public boolean isValid(String username) {\n        return cache.containsKey(username) \u0026\u0026 cache.get(username).getFetchedTime() + TIME_TO_LIVE \u003e System.currentTimeMillis();\n    }\n\n    public Request buildRequestFetch(String[] names) {\n        HttpUrl url \u003d null;\n        try {\n            url \u003d HttpUrl.get(new URL(DATABASE_URL)).newBuilder()\n                    .addPathSegment(String.join(\",\", names))\n                    .build();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n\n        return new Request.Builder()\n                .url(url)\n                .build();\n    }\n\n    public Request buildRequestSave(CosmeticsPlayer p, String apiKey) {\n        HttpUrl url \u003d null;\n        try {\n            url \u003d HttpUrl.get(new URL(DATABASE_URL)).newBuilder()\n                    .addPathSegment(apiKey)\n                    .build();\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        }\n        MediaType JSON \u003d MediaType.parse(\"application/json; charset\u003dutf-8\");\n        Gson gson \u003d new Gson();\n        String s \u003d gson.toJson(p);\n        RequestBody body \u003d RequestBody.create(JSON, s);\n        log.debug(\"{}\", s);\n        return new Request.Builder()\n                .url(url)\n                .put(body)\n                .build();\n    }\n}\n","filePath":"src\\main\\java\\com\\cosmetics\\CosmeticsCache.java"},{"fileName":"CosmeticsConfig.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.cosmetics;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"cosmetics\")\npublic interface CosmeticsConfig extends Config\n{\n    @ConfigItem(\n            keyName \u003d \"apiKey\",\n            name \u003d \"API Key\",\n            description \u003d \"If you are a ranked member of the RLCosmetics Chat Channel, fill this with your API Key.\",\n            position \u003d 0\n    )\n    default String apiKey()\n    {\n        return \"\";\n    }\n}","filePath":"src\\main\\java\\com\\cosmetics\\CosmeticsConfig.java"},{"fileName":"CosmeticsData.java","content":"package com.cosmetics;\n\npublic class CosmeticsData {\n    public long getFetchedTime() {\n        return fetchedTime;\n    }\n\n    public void setFetchedTime(long fetchedTime) {\n        this.fetchedTime \u003d fetchedTime;\n    }\n\n    public CosmeticsPlayer getPlayer() {\n        return cp;\n\n    }\n    private long fetchedTime;\n\n\n    public CosmeticsData(long fetchedTime, CosmeticsPlayer cp) {\n        this.fetchedTime \u003d fetchedTime;\n        this.cp \u003d cp;\n    }\n\n    private final CosmeticsPlayer cp;\n}\n","filePath":"src\\main\\java\\com\\cosmetics\\CosmeticsData.java"},{"fileName":"CosmeticsPlayer.java","content":"package com.cosmetics;\n\nimport net.runelite.api.Player;\nimport net.runelite.api.kit.KitType;\n\npublic class CosmeticsPlayer {\n    public String name;\n    public int head;\n    public int body;\n    public int cape;\n    public int legs;\n    public int neck;\n    public int hand;\n    public int ring;\n    public int feet;\n    public int weap;\n    public int shld;\n    public int jaws;\n    public int hair;\n\n    public CosmeticsPlayer(Player p) {\n        int[] equipmentIds \u003d p.getPlayerComposition().getEquipmentIds();\n        name \u003d p.getName();\n        weap \u003d equipmentIds[KitType.WEAPON.getIndex()];\n        shld \u003d equipmentIds[KitType.SHIELD.getIndex()];\n        body \u003d equipmentIds[KitType.TORSO.getIndex()];\n        cape \u003d equipmentIds[KitType.CAPE.getIndex()];\n        legs \u003d equipmentIds[KitType.LEGS.getIndex()];\n        feet \u003d equipmentIds[KitType.BOOTS.getIndex()];\n        neck \u003d equipmentIds[KitType.AMULET.getIndex()];\n        head \u003d equipmentIds[KitType.HEAD.getIndex()];\n        hand \u003d equipmentIds[KitType.HANDS.getIndex()];\n        ring \u003d equipmentIds[KitType.ARMS.getIndex()];\n        jaws \u003d equipmentIds[KitType.JAW.getIndex()];\n        hair \u003d equipmentIds[KitType.HAIR.getIndex()];\n    }\n\n    public void write(int[] equipmentIds) {\n        equipmentIds[KitType.WEAPON.getIndex()] \u003d weap \u003e\u003d 0? weap : equipmentIds[KitType.WEAPON.getIndex()];\n        equipmentIds[KitType.SHIELD.getIndex()] \u003d shld \u003e\u003d 0? shld : equipmentIds[KitType.SHIELD.getIndex()];\n        equipmentIds[KitType.TORSO.getIndex()] \u003d body \u003e\u003d 0? body : equipmentIds[KitType.TORSO.getIndex()];\n        equipmentIds[KitType.CAPE.getIndex()] \u003d cape \u003e\u003d 0? cape : equipmentIds[KitType.CAPE.getIndex()];\n        equipmentIds[KitType.LEGS.getIndex()] \u003d legs \u003e\u003d 0? legs : equipmentIds[KitType.LEGS.getIndex()];\n        equipmentIds[KitType.BOOTS.getIndex()] \u003d feet \u003e\u003d 0? feet : equipmentIds[KitType.BOOTS.getIndex()];\n        equipmentIds[KitType.AMULET.getIndex()] \u003d neck \u003e\u003d 0? neck : equipmentIds[KitType.AMULET.getIndex()];\n        equipmentIds[KitType.HEAD.getIndex()] \u003d head \u003e\u003d 0? head : equipmentIds[KitType.HEAD.getIndex()];\n        equipmentIds[KitType.HANDS.getIndex()] \u003d hand \u003e\u003d 0? hand : equipmentIds[KitType.HANDS.getIndex()];\n        equipmentIds[KitType.ARMS.getIndex()] \u003d ring \u003e\u003d 0? ring : equipmentIds[KitType.ARMS.getIndex()];\n        equipmentIds[KitType.JAW.getIndex()] \u003d jaws \u003e\u003d 0? jaws : equipmentIds[KitType.JAW.getIndex()];\n        equipmentIds[KitType.HAIR.getIndex()] \u003d hair \u003e\u003d 0? hair : equipmentIds[KitType.HAIR.getIndex()];\n\n    }\n\n}\n\n","filePath":"src\\main\\java\\com\\cosmetics\\CosmeticsPlayer.java"},{"fileName":"CosmeticsPlugin.java","content":"/*\n * Copyright (c) 2021, JohnathonNow \u003cjohnjwesthoff@gmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.cosmetics;\n\nimport com.google.inject.Provides;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.PlayerChanged;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\n\nimport javax.inject.Inject;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Cosmetics\",\n\tdescription \u003d \"Allows users to customize their appearance\",\n\ttags \u003d {\"cosmetics\", \"players\"}\n)\npublic class CosmeticsPlugin extends Plugin {\n\tpublic static String CHAT_COMMAND \u003d \"!cosmetics\";\n\tprivate final int FREQUENCY \u003d 3;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate CosmeticsConfig config;\n\n\t@Provides\n\tCosmeticsConfig getConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(CosmeticsConfig.class);\n\t}\n\n\n\tprivate boolean isPvp \u003d false;\n\tprivate boolean wasPvp \u003d false;\n\tprivate boolean enabled \u003d false;\n\tprivate final CosmeticsCache cache \u003d new CosmeticsCache();\n\n\tprivate final HashMap\u003cString, int[]\u003e preTransform \u003d new HashMap\u003c\u003e();\n\tprivate final HashMap\u003cString, int[]\u003e postTransform \u003d new HashMap\u003c\u003e();\n\tprivate int timer \u003d 0;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\tenabled \u003d true;\n\t\tprocess();\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage event) {\n\t\tif (enabled \u0026\u0026 event.getMessage().toLowerCase().startsWith(CHAT_COMMAND) \u0026\u0026 !config.apiKey().isEmpty()) {\n\t\t\tfor (Player p : client.getPlayers()) {\n\t\t\t\tif (p.getName()!\u003d null \u0026\u0026 p.getName().equals(event.getName())) {\n\t\t\t\t\twipe(p.getName(), p.getPlayerComposition().getEquipmentIds());\n\t\t\t\t\tcache.save(new CosmeticsPlayer(p), config.apiKey());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\tenabled \u003d false;\n\t\tprocess();\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick gt)\n\t{\n\t\ttimer++;\n\t\tif ((isPvp \u003d\u003d wasPvp \u0026\u0026 timer \u003c FREQUENCY) || !enabled) {\n\t\t\treturn;\n\t\t}\n\t\ttimer \u003d 0;\n\t\tprocess();\n\t\tcache.clear();\n\t}\n\n\tprivate void wipe(String name, int[] equipmentIds) {\n\t\tif (postTransform.containsKey(name) \u0026\u0026 !Arrays.equals(postTransform.get(name), equipmentIds)) {\n\t\t\tpreTransform.put(name, equipmentIds.clone());\n\t\t}\n\t\tint[] newIds \u003d preTransform.get(name);\n\t\tSystem.arraycopy(newIds, 0, equipmentIds, 0, newIds.length);\n\t}\n\n\tprivate void process() {\n\t\ttry {\n\t\t\tArrayList\u003cString\u003e allNames \u003d new ArrayList\u003c\u003e();\n\t\t\tfor (Player player : client.getPlayers()) {\n\t\t\t\tallNames.add(player.getName());\n\t\t\t\tPlayerComposition comp \u003d player.getPlayerComposition();\n\t\t\t\tint[] equipmentIds \u003d comp.getEquipmentIds();\n\t\t\t\tString name \u003d player.getName();\n\t\t\t\tif (!preTransform.containsKey(name)) {\n\t\t\t\t\tpreTransform.put(name, equipmentIds.clone());\n\t\t\t\t}\n\t\t\t\tif (isPvp || !enabled) {\n\t\t\t\t\t//in PvP we should _not_ show cosmetics\n\t\t\t\t\twipe(name, equipmentIds);\n\t\t\t\t} else {\n\t\t\t\t\tif (postTransform.containsKey(name) \u0026\u0026 !Arrays.equals(postTransform.get(name), equipmentIds)) {\n\t\t\t\t\t\tpreTransform.put(name, equipmentIds.clone());\n\t\t\t\t\t}\n\t\t\t\t\tCosmeticsPlayer p \u003d cache.getCosmetics(player.getName());\n\t\t\t\t\tif (p !\u003d null) {\n\t\t\t\t\t\tp.write(equipmentIds);\n\t\t\t\t\t}\n\t\t\t\t\tpostTransform.put(name, equipmentIds.clone());\n\t\t\t\t}\n\t\t\t\tcomp.setHash();\n\t\t\t}\n\t\t\tcache.fillCache(allNames.toArray(new String[0]));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.debug(\"Sad: \" + e.toString());\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onVarbitChanged(VarbitChanged event) {\n\t\twasPvp \u003d isPvp;\n\t\tisPvp \u003d client.getVar(Varbits.PVP_SPEC_ORB) !\u003d 0;\n\t}\n\n\t@Subscribe\n\tpublic void onPlayerChanged(PlayerChanged event) {\n\t\ttimer \u003d FREQUENCY;\n\t}\n}\n","filePath":"src\\main\\java\\com\\cosmetics\\CosmeticsPlugin.java"},{"fileName":"CosmeticsPluginTest.java","content":"package com.cosmetics;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class CosmeticsPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(CosmeticsPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\cosmetics\\CosmeticsPluginTest.java"}]},{"commit":"d936ddff4ecf6455f2df0302c9234106cd29febd","repository":"https://github.com/marknewan/newan-plugins.git","internalName":"demonic-larva-tracker","files":[{"fileName":"AttackStyle.java","content":"/*\n * Copyright (c) 2017, honeyhoney \u003chttps://github.com/honeyhoney\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.demoniclarvatracker;\n\nenum AttackStyle\n{\n\tACCURATE,\n\tAGGRESSIVE,\n\tDEFENSIVE,\n\tCONTROLLED,\n\tRANGING,\n\tLONGRANGE,\n\tCASTING,\n\tDEFENSIVE_CASTING,\n\tOTHER;\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\AttackStyle.java"},{"fileName":"DemonicLarvaTrackerConfig.java","content":"package com.demoniclarvatracker;\n\nimport java.awt.Color;\nimport net.runelite.client.config.Alpha;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Range;\nimport net.runelite.client.config.Units;\nimport net.runelite.client.util.ColorUtil;\n\n@ConfigGroup(DemonicLarvaTrackerConfig.CONFIG_GROUP)\npublic interface DemonicLarvaTrackerConfig extends Config\n{\n\tString CONFIG_GROUP \u003d \"demoniclarvatracker\";\n\n\t@ConfigSection(\n\t\tname \u003d \"General\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 0,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_GENERAL \u003d \"general\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Highlights\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 1,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_HIGHLIGHTS \u003d \"highlights\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Base Larva\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 2,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_BASE_LARVA \u003d \"baseLarva\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Melee Larva\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 3,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_MELEE_LARVA \u003d \"meleeLarva\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Range Larva\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 4,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_RANGE_LARVA \u003d \"rangeLarva\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Magic Larva\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 5,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_MAGIC_LARVA \u003d \"magicLarva\";\n\n\t@ConfigSection(\n\t\tname \u003d \"Advanced\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 6,\n\t\tclosedByDefault \u003d true\n\t)\n\tString SECTION_ADVANCED \u003d \"advanced\";\n\n\t// General\n\n\t@ConfigItem(\n\t\tname \u003d \"Death Prediction\",\n\t\tdescription \u003d \"Hide larva predicted to die.\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"hideDeadLarva\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean hideDeadLarva()\n\t{\n\t\treturn true;\n\t}\n\n\t@Units(value \u003d \"ms\")\n\t@ConfigItem(\n\t\tname \u003d \"Death Lag Protection\",\n\t\tdescription \u003d \"Unhide larva after a lag spike.\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"lagProtectionThreshold\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault int lagProtectionThreshold()\n\t{\n\t\treturn 1000;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Print Lag Messages\",\n\t\tdescription \u003d \"Print to chat when a lag spike is encountered.\" +\n\t\t\t\"\u003cbr\u003eIncrease the lag protection if you see these messages a lot.\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"printLagMessages\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean printLagMessages()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Hide Larva Overheads\",\n\t\tdescription \u003d \"Hide larva overheads.\" +\n\t\t\t\"\u003cbr\u003eOnly applies to range, melee, and magic larvae.\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"hideLarvaOverheads\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean hideLarvaOverheads()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Recolor Larva Menu Entries\",\n\t\tdescription \u003d \"Recolor menu entries for larva npcs.\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"recolorLarvaMenuEntries\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean recolorLarvaMenuEntries()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Remove Spawn Animation\",\n\t\tdescription \u003d \"Remove the spawn animation from larvas.\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"removeSpawnAnimation\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean removeSpawnAnimation()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Infobox Larva Counter\",\n\t\tdescription \u003d \"Displays a counter of how many larva have been absorbed.\" +\n\t\t\t\"\u003cbr\u003eOnly displayed when there is at least 1 demonic charge.\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"infoboxLarvaCounter\",\n\t\tsection \u003d SECTION_GENERAL\n\t)\n\tdefault boolean infoboxLarvaCounter()\n\t{\n\t\treturn true;\n\t}\n\n\t// Highlights\n\n\t// Highlight Outline\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Outline\",\n\t\tdescription \u003d \"Highlight outline of larva npcs.\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"highlightOutline\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightOutline()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(max \u003d 50)\n\t@ConfigItem(\n\t\tname \u003d \"Width\",\n\t\tdescription \u003d \"Width of highlight outline.\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"highlightOutlineWidth\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault int highlightOutlineWidth()\n\t{\n\t\treturn 1;\n\t}\n\n\t@Range(max \u003d 4)\n\t@ConfigItem(\n\t\tname \u003d \"Feather\",\n\t\tdescription \u003d \"Feather of highlight outline.\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"highlightOutlineFeather\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault int highlightOutlineFeather()\n\t{\n\t\treturn 1;\n\t}\n\n\t// Highlight Tile\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Tile Outline\",\n\t\tdescription \u003d \"Highlight tile outline of larva npcs.\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"highlightTileOutline\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightTileOutline()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(max \u003d 5)\n\t@ConfigItem(\n\t\tname \u003d \"Width\",\n\t\tdescription \u003d \"Width of highlight tile outline.\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"highlightTileOutlineWidth\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault double highlightTileOutlineWidth()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Tile Fill\",\n\t\tdescription \u003d \"Highlight tile fill of larva npcs.\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"highlightTileFill\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightTileFill()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Tile Mode\",\n\t\tdescription \u003d \"Highlight tile mode of larva npcs.\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"highlightTileMode\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault TileMode highlightTileMode()\n\t{\n\t\treturn TileMode.TRUE_TILE;\n\t}\n\n\t// Highlight Hull\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Hull Outline\",\n\t\tdescription \u003d \"Highlight hull outline of larva npcs.\",\n\t\tposition \u003d 7,\n\t\tkeyName \u003d \"highlightHullOutline\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightHullOutline()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(max \u003d 50)\n\t@ConfigItem(\n\t\tname \u003d \"Width\",\n\t\tdescription \u003d \"Width of highlight hull outline.\",\n\t\tposition \u003d 8,\n\t\tkeyName \u003d \"highlightHullWidth\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault double highlightHullWidth()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Hull Fill\",\n\t\tdescription \u003d \"Highlight hull fill of larva npcs.\",\n\t\tposition \u003d 9,\n\t\tkeyName \u003d \"highlightHullFill\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightHullFill()\n\t{\n\t\treturn false;\n\t}\n\n\t// Highlight Clickbox\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Clickbox Outline\",\n\t\tdescription \u003d \"Highlight clickbox outline of larva npcs.\",\n\t\tposition \u003d 10,\n\t\tkeyName \u003d \"highlightClickBoxOutline\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightClickBoxOutline()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(max \u003d 50)\n\t@ConfigItem(\n\t\tname \u003d \"Width\",\n\t\tdescription \u003d \"Width of highlight clickbox outline.\",\n\t\tposition \u003d 11,\n\t\tkeyName \u003d \"highlightClickBoxWidth\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault double highlightClickBoxWidth()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Clickbox Fill\",\n\t\tdescription \u003d \"Highlight clickbox fill of larva npcs.\",\n\t\tposition \u003d 12,\n\t\tkeyName \u003d \"highlightClickBoxFill\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightClickBoxFill()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Mouseover\",\n\t\tdescription \u003d \"Darken color of the clickbox on mouseover.\",\n\t\tposition \u003d 13,\n\t\tkeyName \u003d \"highlightClickboxMouseover\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightClickboxMouseover()\n\t{\n\t\treturn false;\n\t}\n\n\t// Highlight Minimap\n\n\t@ConfigItem(\n\t\tname \u003d \"Highlight Minimap\",\n\t\tdescription \u003d \"Highlight minimap location of larva npcs.\",\n\t\tposition \u003d 14,\n\t\tkeyName \u003d \"highlightMinimap\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightMinimap()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Name Labels\",\n\t\tdescription \u003d \"Draw names above larva npcs.\" +\n\t\t\t\"\u003cbr\u003eOnly applies to range, melee, and magic larvae.\",\n\t\tposition \u003d 15,\n\t\tkeyName \u003d \"highlightNameLabel\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean highlightNameLabel()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Anti-aliasing\",\n\t\tdescription \u003d \"Smooths out edges of outlines.\" +\n\t\t\t\"\u003cbr\u003eReduces \u0027jagged\u0027 or \u0027stair-step\u0027 appearance that can occur.\",\n\t\tposition \u003d 16,\n\t\tkeyName \u003d \"antiAliasing\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean antiAliasing()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Hide Highlights On Death\",\n\t\tdescription \u003d \"Hides the highlighting of dead npcs.\",\n\t\tposition \u003d 17,\n\t\tkeyName \u003d \"hideHighlightOnDeath\",\n\t\tsection \u003d SECTION_HIGHLIGHTS\n\t)\n\tdefault boolean hideHighlightOnDeath()\n\t{\n\t\treturn true;\n\t}\n\n\t// Colors\n\n\t// Base Colors\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"colorOutlineBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorOutlineBase()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"colorTileOutlineBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorTileOutlineBase()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"colorTileFillBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorTileFillBase()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.WHITE, 32);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"colorHullOutlineBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorHullOutlineBase()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"colorHullFillBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorHullFillBase()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.WHITE, 16);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"colorClickBoxOutlineBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorClickBoxOutlineBase()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"colorClickBoxFillBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorClickBoxFillBase()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.WHITE, 16);\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Menu Entry\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 7,\n\t\tkeyName \u003d \"colorMenuBase\",\n\t\tsection \u003d SECTION_BASE_LARVA\n\t)\n\tdefault Color colorMenuBase()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t// Melee Colors\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"colorOutlineMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorOutlineMelee()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"colorTileOutlineMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorTileOutlineMelee()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"colorTileFillMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorTileFillMelee()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.RED, 32);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"colorHullOutlineMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorHullOutlineMelee()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"colorHullFillMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorHullFillMelee()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.RED, 16);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"colorClickBoxOutlineMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorClickBoxOutlineMelee()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"colorClickBoxFillMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorClickBoxFillMelee()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.RED, 16);\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Menu Entry\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 7,\n\t\tkeyName \u003d \"colorMenuMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault Color colorMenuMelee()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Name Label\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 8,\n\t\tkeyName \u003d \"nameLabelMelee\",\n\t\tsection \u003d SECTION_MELEE_LARVA\n\t)\n\tdefault String nameLabelMelee()\n\t{\n\t\treturn \"Melee\";\n\t}\n\n\t// Range Colors\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"colorOutlineRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorOutlineRange()\n\t{\n\t\treturn Color.GREEN;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"colorTileOutlineRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorTileOutlineRange()\n\t{\n\t\treturn Color.GREEN;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"colorTileFillRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorTileFillRange()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.GREEN, 32);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"colorHullOutlineRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorHullOutlineRange()\n\t{\n\t\treturn Color.GREEN;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"colorHullFillRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorHullFillRange()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.GREEN, 16);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"colorClickBoxOutlineRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorClickBoxOutlineRange()\n\t{\n\t\treturn Color.GREEN;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"colorClickBoxFillRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorClickBoxFillRange()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.GREEN, 16);\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Menu Entry\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 7,\n\t\tkeyName \u003d \"colorMenuRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault Color colorMenuRange()\n\t{\n\t\treturn Color.GREEN;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Name Label\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 8,\n\t\tkeyName \u003d \"nameLabelRange\",\n\t\tsection \u003d SECTION_RANGE_LARVA\n\t)\n\tdefault String nameLabelRange()\n\t{\n\t\treturn \"Range\";\n\t}\n\n\t// Magic Colors\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"colorOutlineMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorOutlineMagic()\n\t{\n\t\treturn Color.BLUE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 1,\n\t\tkeyName \u003d \"colorTileOutlineMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorTileOutlineMagic()\n\t{\n\t\treturn Color.BLUE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Tile Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"colorTileFillMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorTileFillMagic()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.BLUE, 32);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 3,\n\t\tkeyName \u003d \"colorHullOutlineMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorHullOutlineMagic()\n\t{\n\t\treturn Color.BLUE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Hull Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 4,\n\t\tkeyName \u003d \"colorHullFillMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorHullFillMagic()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.BLUE, 16);\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Outline\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 5,\n\t\tkeyName \u003d \"colorClickBoxOutlineMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorClickBoxOutlineMagic()\n\t{\n\t\treturn Color.BLUE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tname \u003d \"Clickbox Fill\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 6,\n\t\tkeyName \u003d \"colorClickBoxFillMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorClickBoxFillMagic()\n\t{\n\t\treturn ColorUtil.colorWithAlpha(Color.BLUE, 16);\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Menu Entry\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 7,\n\t\tkeyName \u003d \"colorMenuMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault Color colorMenuMagic()\n\t{\n\t\treturn Color.BLUE;\n\t}\n\n\t@ConfigItem(\n\t\tname \u003d \"Name Label\",\n\t\tdescription \u003d \"\",\n\t\tposition \u003d 8,\n\t\tkeyName \u003d \"nameLabelMagic\",\n\t\tsection \u003d SECTION_MAGIC_LARVA\n\t)\n\tdefault String nameLabelMagic()\n\t{\n\t\treturn \"Mage\";\n\t}\n\n\t// Advanced\n\n\t@Range(min \u003d 2, max \u003d 10)\n\t@ConfigItem(\n\t\tname \u003d \"Death Tick-timeout\",\n\t\tdescription \u003d \"Failsafe timeout that unhides npcs after a # of ticks.\" +\n\t\t\t\"\u003cbr\u003eDefault value \u003d 2.\" +\n\t\t\t\"\u003cbr\u003eA sufficiently high value effectively disables the failsafe.\",\n\t\tposition \u003d 0,\n\t\tkeyName \u003d \"deathTickTimeout\",\n\t\tsection \u003d SECTION_ADVANCED\n\t)\n\tdefault int deathTickTimeout()\n\t{\n\t\treturn 2;\n\t}\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\DemonicLarvaTrackerConfig.java"},{"fileName":"DemonicLarvaTrackerPlugin.java","content":"/*\n * Copyright (c) 2025, marknewan \u003chttp://github.com/marknewan\u003e\n * Copyright (c) 2023, Buchus \u003chttp://github.com/MoreBuchus\u003e\n * Copyright (c) 2017, honeyhoney \u003chttps://github.com/honeyhoney\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.demoniclarvatracker;\n\nimport com.google.inject.Provides;\nimport java.awt.Color;\nimport java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.EnumID;\nimport net.runelite.api.GameState;\nimport net.runelite.api.Hitsplat;\nimport net.runelite.api.NPC;\nimport net.runelite.api.ParamID;\nimport net.runelite.api.Renderable;\nimport net.runelite.api.Skill;\nimport net.runelite.api.StructComposition;\nimport net.runelite.api.events.ActorDeath;\nimport net.runelite.api.events.FakeXpDrop;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.GraphicChanged;\nimport net.runelite.api.events.HitsplatApplied;\nimport net.runelite.api.events.InteractingChanged;\nimport net.runelite.api.events.MenuEntryAdded;\nimport net.runelite.api.events.NpcDespawned;\nimport net.runelite.api.events.NpcSpawned;\nimport net.runelite.api.events.StatChanged;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.api.gameval.AnimationID;\nimport net.runelite.api.gameval.NpcID;\nimport net.runelite.api.gameval.SpriteID;\nimport net.runelite.api.gameval.VarPlayerID;\nimport net.runelite.api.gameval.VarbitID;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.callback.Hooks;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.game.SpriteManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.ui.overlay.infobox.Counter;\nimport net.runelite.client.ui.overlay.infobox.InfoBoxManager;\nimport net.runelite.client.util.ColorUtil;\n\n@Slf4j\n@Singleton\n@PluginDescriptor(\n\tname \u003d \"Demonic Larva Tracker\",\n\tdescription \u003d \"Tracks demonic larva at Doom of Mokhaiotl.\",\n\ttags \u003d {\"doom\", \"mokhaiotl\", \"demonic\", \"larva\", \"grub\", \"tracker\", \"delve\"}\n)\npublic class DemonicLarvaTrackerPlugin extends Plugin\n{\n\tprivate static final Set\u003cInteger\u003e REGION_IDS \u003d Set.of(5269, 13668, 14180);\n\tprivate static final AttackStyle[] ATTACK_STYLES_POWERED_STAVE \u003d new AttackStyle[]{\n\t\tAttackStyle.CASTING, AttackStyle.CASTING, null, AttackStyle.DEFENSIVE, null, null\n\t};\n\n\t@Inject\n\tprivate Client client;\n\t@Inject\n\tprivate ClientThread clientThread;\n\t@Inject\n\tprivate Hooks hooks;\n\t@Inject\n\tprivate DemonicLarvaTrackerConfig config;\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\t@Inject\n\tprivate SceneOverlay sceneOverlay;\n\t@Inject\n\tprivate WidgetOverlay widgetOverlay;\n\t@Inject\n\tprivate InfoBoxManager infoBoxManager;\n\t@Inject\n\tprivate SpriteManager spriteManager;\n\n\tprivate final Hooks.RenderableDrawListener drawListener \u003d this::shouldDraw;\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final Map\u003cNPC, Larva\u003e larvae \u003d new HashMap\u003c\u003e();\n\n\tprivate final Map\u003cLarva, Hitsplat\u003e larvaHitsplats \u003d new HashMap\u003c\u003e();\n\tprivate final Map\u003cSkill, Integer\u003e realXpDrops \u003d new EnumMap\u003c\u003e(Skill.class);\n\tprivate final Map\u003cSkill, Integer\u003e fakeXpDrops \u003d new EnumMap\u003c\u003e(Skill.class);\n\n\tprivate final int[] previousSkillXp \u003d new int[Skill.values().length];\n\n\t@Nullable\n\tprivate NPC interactingNpc;\n\t@Nullable\n\tprivate AttackStyle attackStyle;\n\t@Nullable\n\tprivate Counter counter;\n\n\tprivate long lastTickNano;\n\n\tprivate boolean enabled;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\tclientThread.invokeLater(() -\u003e {\n\t\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN \u0026\u0026 inRegion())\n\t\t\t{\n\t\t\t\tinit();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void init()\n\t{\n\t\tassert client.isClientThread();\n\n\t\tenabled \u003d true;\n\n\t\thooks.registerRenderableDrawListener(drawListener);\n\n\t\toverlayManager.add(sceneOverlay);\n\t\toverlayManager.add(widgetOverlay);\n\n\t\tsetCounter();\n\n\t\tinitAttackStyles();\n\t\tSystem.arraycopy(client.getSkillExperiences(), 0, previousSkillXp, 0, previousSkillXp.length);\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\tenabled \u003d false;\n\n\t\thooks.unregisterRenderableDrawListener(drawListener);\n\n\t\toverlayManager.remove(sceneOverlay);\n\t\toverlayManager.remove(widgetOverlay);\n\n\t\tinfoBoxManager.removeInfoBox(counter);\n\n\t\tlarvae.clear();\n\t\tlarvaHitsplats.clear();\n\t\trealXpDrops.clear();\n\t\tfakeXpDrops.clear();\n\n\t\tArrays.fill(previousSkillXp, 0);\n\n\t\tinteractingNpc \u003d null;\n\t\tattackStyle \u003d null;\n\t\tcounter \u003d null;\n\n\t\tlastTickNano \u003d 0;\n\t}\n\n\t@Provides\n\tDemonicLarvaTrackerConfig provideConfig(final ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(DemonicLarvaTrackerConfig.class);\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(final GameStateChanged event)\n\t{\n\t\tswitch (event.getGameState())\n\t\t{\n\t\t\tcase LOGGED_IN:\n\t\t\t\tif (inRegion())\n\t\t\t\t{\n\t\t\t\t\tif (!enabled)\n\t\t\t\t\t{\n\t\t\t\t\t\tinit();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (enabled)\n\t\t\t\t\t{\n\t\t\t\t\t\tshutDown();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HOPPING:\n\t\t\tcase LOGIN_SCREEN:\n\t\t\t\tif (enabled)\n\t\t\t\t{\n\t\t\t\t\tshutDown();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGraphicChanged(final GraphicChanged event)\n\t{\n\t\tif (!enabled || !config.removeSpawnAnimation())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var actor \u003d event.getActor();\n\t\tif (!(actor instanceof NPC))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d (NPC) actor;\n\t\tif (!isLarva(npc))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tnpc.clearSpotAnims();\n\t}\n\n\t@Subscribe\n\tpublic void onNpcSpawned(final NpcSpawned event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d event.getNpc();\n\n\t\tif (!isLarva(npc))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlarvae.put(npc, new Larva(npc));\n\t\tif (config.removeSpawnAnimation())\n\t\t{\n\t\t\tnpc.clearSpotAnims();\n\t\t\tnpc.setAnimation(AnimationID.NPC_DEMONIC_GRUB_WALK);\n\t\t\tnpc.setAnimationFrame(0);\n\t\t}\n\n\t\tlog.debug(\"{} - onNpcSpawned: {} ({})\", client.getTickCount(), npc.getName(), npc.getIndex());\n\t}\n\n\t@Subscribe\n\tpublic void onNpcDespawned(final NpcDespawned event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d event.getNpc();\n\t\tfinal int id \u003d npc.getId();\n\n\t\tif (isLarva(npc))\n\t\t{\n\t\t\tlarvae.remove(npc);\n\n\t\t\tlog.debug(\"{} - onNpcDespawned: {} ({})\", client.getTickCount(), npc.getName(), npc.getIndex());\n\t\t}\n\t\telse if (id \u003e\u003d NpcID.DOM_BOSS \u0026\u0026 id \u003c\u003d NpcID.DOM_BOSS_BURROWED)\n\t\t{\n\t\t\tlarvae.clear();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onActorDeath(final ActorDeath event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var actor \u003d event.getActor();\n\t\tif (!(actor instanceof NPC))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d (NPC) actor;\n\n\t\tfinal var larva \u003d larvae.get(npc);\n\t\tif (larva \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlarva.kill(client.getTickCount());\n\n\t\tlog.debug(\"{} - onActorDeath: {} ({})\", client.getTickCount(), npc.getName(), npc.getIndex());\n\t}\n\n\t@Subscribe()\n\tprivate void onInteractingChanged(final InteractingChanged event)\n\t{\n\t\tif (!enabled || event.getSource() !\u003d client.getLocalPlayer())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tinteractingNpc \u003d null;\n\n\t\tfinal var actor \u003d event.getTarget();\n\t\tif (!(actor instanceof NPC))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d (NPC) actor;\n\t\tif (!isLarva(npc))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tthis.interactingNpc \u003d npc;\n\n\t\tlog.debug(\"{} - onInteractingChanged: {} ({})\", client.getTickCount(), npc.getName(), npc.getIndex());\n\t}\n\n\t@Subscribe\n\tpublic void onFakeXpDrop(final FakeXpDrop event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var skill \u003d event.getSkill();\n\t\tfinal var xp \u003d event.getXp();\n\n\t\tswitch (skill)\n\t\t{\n\t\t\tcase ATTACK:\n\t\t\tcase STRENGTH:\n\t\t\tcase DEFENCE:\n\t\t\tcase RANGED:\n\t\t\tcase HITPOINTS:\n\t\t\t\tfakeXpDrops.merge(skill, xp, Integer::sum);\n\n\t\t\t\tlog.debug(\"{} - onFakeXpDrop: {} {}\", client.getTickCount(), skill, xp);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onStatChanged(final StatChanged event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var skill \u003d event.getSkill();\n\t\tfinal var xp \u003d event.getXp();\n\n\t\tfinal int idx \u003d skill.ordinal();\n\t\tfinal int prevXp \u003d previousSkillXp[idx];\n\t\tpreviousSkillXp[idx] \u003d xp;\n\t\tif (prevXp \u003d\u003d 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int xpDiff \u003d xp - prevXp;\n\t\tif (xpDiff \u003c\u003d 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (skill)\n\t\t{\n\t\t\tcase ATTACK:\n\t\t\tcase STRENGTH:\n\t\t\tcase DEFENCE:\n\t\t\tcase RANGED:\n\t\t\tcase HITPOINTS:\n\t\t\t\trealXpDrops.merge(skill, xpDiff, Integer::sum);\n\n\t\t\t\tlog.debug(\"{} - onStatChanged: skill\u003d{} xp\u003d{}\", client.getTickCount(), skill, xpDiff);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Subscribe\n\tprivate void onHitsplatApplied(final HitsplatApplied event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var hitsplat \u003d event.getHitsplat();\n\t\tfinal int damage \u003d hitsplat.getAmount();\n\t\tif (damage \u003d\u003d 0)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var actor \u003d event.getActor();\n\t\tif (!(actor instanceof NPC))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d (NPC) actor;\n\n\t\tfinal var larva \u003d larvae.get(npc);\n\t\tif (larva \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlarvaHitsplats.put(larva, hitsplat);\n\n\t\tlog.debug(\"{} - onHitsplatApplied: {} ({}) damage\u003d{}\", client.getTickCount(), npc.getName(), npc.getIndex(), damage);\n\t}\n\n\t@Subscribe\n\tpublic void onMenuEntryAdded(final MenuEntryAdded event)\n\t{\n\t\tif (!enabled || !config.recolorLarvaMenuEntries())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var entry \u003d event.getMenuEntry();\n\n\t\tfinal var npc \u003d entry.getNpc();\n\t\tif (npc \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Color color;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\tcolor \u003d config.colorMenuBase();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\tcolor \u003d config.colorMenuRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\tcolor \u003d config.colorMenuMagic();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\tcolor \u003d config.colorMenuMelee();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tentry.setTarget(ColorUtil.colorTag(color) + npc.getName());\n\t}\n\n\t@Subscribe\n\tprivate void onVarbitChanged(final VarbitChanged event)\n\t{\n\t\tif (!enabled)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.getVarpId() \u003d\u003d VarPlayerID.COM_MODE ||\n\t\t\tevent.getVarbitId() \u003d\u003d VarbitID.COMBAT_WEAPON_CATEGORY ||\n\t\t\tevent.getVarbitId() \u003d\u003d VarbitID.AUTOCAST_DEFMODE)\n\t\t{\n\t\t\tinitAttackStyles();\n\t\t}\n\t\telse if (event.getVarbitId() \u003d\u003d VarbitID.DOM_MISSED_ORBS)\n\t\t{\n\t\t\tif (counter !\u003d null)\n\t\t\t{\n\t\t\t\tcounter.setCount(event.getValue());\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(final GameTick event)\n\t{\n\t\tif (!enabled || processLag())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlarvae.values().forEach(larva -\u003e larva.setXpProcessed(false));\n\n\t\tprocessHitSplats();\n\t\tlarvaHitsplats.clear();\n\n\t\tprocessXpDrops(realXpDrops);\n\t\trealXpDrops.clear();\n\n\t\tprocessXpDrops(fakeXpDrops);\n\t\tfakeXpDrops.clear();\n\n\t\treviveLarvae();\n\n\t\tlog.debug(\"---- END GAME TICK {} ----\", client.getTickCount());\n\t}\n\n\tprivate void setCounter()\n\t{\n\t\tcounter \u003d new Counter(spriteManager.getSprite(SpriteID.IconBoss25x25.DOOM_OF_MOKHAIOTL, 0), this, client.getVarbitValue(VarbitID.DOM_MISSED_ORBS))\n\t\t{\n\t\t\t@Override\n\t\t\tpublic boolean render()\n\t\t\t{\n\t\t\t\treturn getCount() \u003e 0 \u0026\u0026 config.infoboxLarvaCounter();\n\t\t\t}\n\t\t};\n\n\t\tcounter.setTooltip(\"Demonic Charge\");\n\n\t\tinfoBoxManager.addInfoBox(counter);\n\t}\n\n\tprivate boolean inRegion()\n\t{\n\t\tfinal var wv \u003d client.getTopLevelWorldView();\n\t\treturn wv.isInstance() \u0026\u0026 Arrays.stream(wv.getMapRegions()).anyMatch(REGION_IDS::contains);\n\t}\n\n\tprivate boolean shouldDraw(final Renderable renderable, final boolean overheads)\n\t{\n\t\tif (renderable instanceof NPC)\n\t\t{\n\t\t\tfinal var npc \u003d (NPC) renderable;\n\t\t\tfinal var larva \u003d larvae.get(npc);\n\t\t\tif (larva !\u003d null)\n\t\t\t{\n\t\t\t\tif (config.hideDeadLarva() \u0026\u0026 (npc.isDead() || larva.isDead()))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (npc.getId() !\u003d NpcID.DOM_DEMONIC_ENERGY)\n\t\t\t\t{\n\t\t\t\t\treturn !(overheads \u0026\u0026 config.hideLarvaOverheads());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate boolean processLag()\n\t{\n\t\tif (lastTickNano \u003d\u003d 0)\n\t\t{\n\t\t\tlastTickNano \u003d System.nanoTime();\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal long time \u003d System.nanoTime();\n\t\tfinal int lastTickMillis \u003d (int) ((time - lastTickNano) / 1_000_000L);\n\t\tlastTickNano \u003d time;\n\n\t\tif (lastTickMillis \u003c config.lagProtectionThreshold())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (config.printLagMessages())\n\t\t{\n\t\t\tclient.addChatMessage(\n\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\"DemonicLarvaTracker\",\n\t\t\t\tString.format(\"[\u003ccol\u003dFF0000\u003eD\u003ccol\u003d00FF00\u003eL\u003ccol\u003d0000FF\u003eT\u003c/col\u003e] \u003ccol\u003dFFFF00\u003eWarning\u003c/col\u003e: Tick %d was \u003ccol\u003dFFA500\u003e%d ms\u003c/col\u003e.\",\n\t\t\t\t\tclient.getTickCount(), lastTickMillis),\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\tlarvae.values().forEach(Larva::revive);\n\t\tlarvaHitsplats.clear();\n\t\trealXpDrops.clear();\n\t\tfakeXpDrops.clear();\n\n\t\treturn true;\n\t}\n\n\tprivate void processHitSplats()\n\t{\n\t\tif (larvaHitsplats.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlarvaHitsplats.keySet().removeIf(l -\u003e !larvae.containsValue(l));\n\n\t\tfor (final var entry : larvaHitsplats.entrySet())\n\t\t{\n\t\t\tfinal var larva \u003d entry.getKey();\n\t\t\tfinal var npc \u003d larva.getNpc();\n\n\t\t\tfinal int damage \u003d entry.getValue().getAmount();\n\n\t\t\tlog.debug(\"{} - processHitSplats (damage): {} ({}) queuedDamage\u003d{} damage\u003d{}\",\n\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), larva.getQueuedDamage(), damage);\n\n\t\t\tlarva.dequeueDamage(damage);\n\t\t\tif (larva.hasQueuedDamage())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlarva.recalcHp();\n\n\t\t\tlog.debug(\"{} - processHitSplats (hp): {} ({}) healthRatio\u003d{} healthScale\u003d{} hp\u003d{}\",\n\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), npc.getHealthRatio(), npc.getHealthScale(), larva.getHp());\n\n\t\t\tif (larva.isDead())\n\t\t\t{\n\t\t\t\tlarva.kill(client.getTickCount());\n\n\t\t\t\tlog.debug(\"{} - processHitSplats (kill): {} ({}) hp\u003d{} deathTick\u003d{}\",\n\t\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getDeathTick());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlarva.resetDeathTick();\n\n\t\t\t\tlog.debug(\"{} - processHitSplats (alive): {} ({}) hp\u003d{} deathTick\u003d{}\",\n\t\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getDeathTick());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void processXpDrops(final Map\u003cSkill, Integer\u003e xpDrops)\n\t{\n\t\tif (xpDrops.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (interactingNpc \u003d\u003d null || attackStyle \u003d\u003d null)\n\t\t{\n\t\t\tlog.debug(\"{} - processXpDrops (skipping): interactingNpc\u003d{} attackStyle\u003d{}\",\n\t\t\t\tclient.getTickCount(), interactingNpc, attackStyle);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var larva \u003d larvae.get(interactingNpc);\n\t\tif (larva \u003d\u003d null || larva.isDead() || larva.isXpProcessed())\n\t\t{\n\t\t\tlog.debug(\"{} - processXpDrops (skipping): larva null/dead/processed\", client.getTickCount());\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var npc \u003d larva.getNpc();\n\n\t\tfor (final var entry : xpDrops.entrySet())\n\t\t{\n\t\t\tvar skill \u003d entry.getKey();\n\t\t\tfinal var xp \u003d entry.getValue();\n\n\t\t\tif (skill \u003d\u003d Skill.ATTACK || skill \u003d\u003d Skill.STRENGTH || skill \u003d\u003d Skill.DEFENCE || skill \u003d\u003d Skill.RANGED)\n\t\t\t{\n\t\t\t\tif (attackStyle \u003d\u003d AttackStyle.LONGRANGE)\n\t\t\t\t{\n\t\t\t\t\tskill \u003d Skill.RANGED;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (skill \u003d\u003d Skill.HITPOINTS \u0026\u0026 attackStyle !\u003d AttackStyle.CASTING)\n\t\t\t{\n\t\t\t\tlog.debug(\"{} - processXpDrops (skipping): skill\u003d{} attackStyle\u003d{} !\u003d CASTING\", client.getTickCount(), skill, attackStyle);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlarva.setXpProcessed(true);\n\n\t\t\tfinal int damage \u003d calcDamageFromXpDrop(skill, xp);\n\t\t\tlarva.damage(damage);\n\n\t\t\tif (larva.isDead())\n\t\t\t{\n\t\t\t\tlarva.kill(client.getTickCount());\n\n\t\t\t\tlog.debug(\"{} - processXpDrops (killed): {} ({}) damage\u003d{} queuedDamage\u003d{} hp\u003d{} deathTick\u003d{}\",\n\t\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), damage, larva.getQueuedDamage(), larva.getHp(), larva.getDeathTick());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlarva.resetDeathTick();\n\n\t\t\t\tlog.debug(\"{} - processXpDrops (alive): {} ({}) damage\u003d{} queuedDamage\u003d{} hp\u003d{} deathTick\u003d{}\",\n\t\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), damage, larva.getQueuedDamage(), larva.getHp(), larva.getDeathTick());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void reviveLarvae()\n\t{\n\t\tif (larvae.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (final var entry : larvae.entrySet())\n\t\t{\n\t\t\tfinal var npc \u003d entry.getKey();\n\t\t\tfinal var larva \u003d entry.getValue();\n\n\t\t\tif (!larva.isTimedOut(client.getTickCount(), config.deathTickTimeout()))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal int deathTick \u003d larva.getDeathTick();\n\n\t\t\tlarva.revive();\n\n\t\t\tlog.debug(\"{} - reviveLarvae: {} ({}) hp\u003d{} queuedDamage\u003d{} deathTick\u003d{}\",\n\t\t\t\tclient.getTickCount(), npc.getName(), npc.getIndex(), larva.getHp(), larva.getQueuedDamage(), deathTick);\n\t\t}\n\t}\n\n\tprivate void initAttackStyles()\n\t{\n\t\tfinal int equippedWeaponTypeVarbit \u003d client.getVarbitValue(VarbitID.COMBAT_WEAPON_CATEGORY);\n\t\tfinal int attackStyleVarbit \u003d client.getVarpValue(VarPlayerID.COM_MODE);\n\t\tfinal int castingModeVarbit \u003d client.getVarbitValue(VarbitID.AUTOCAST_DEFMODE);\n\n\t\tupdateAttackStyle(equippedWeaponTypeVarbit, attackStyleVarbit, castingModeVarbit);\n\t}\n\n\tprivate void updateAttackStyle(final int equippedWeaponType, int attackStyleIndex, final int castingMode)\n\t{\n\t\tfinal AttackStyle[] attackStyles \u003d getWeaponTypeStyles(equippedWeaponType);\n\n\t\tif (attackStyleIndex \u003c attackStyles.length)\n\t\t{\n\t\t\tif (attackStyleIndex \u003d\u003d 4)\n\t\t\t{\n\t\t\t\tattackStyleIndex +\u003d castingMode;\n\t\t\t}\n\n\t\t\tattackStyle \u003d attackStyles[attackStyleIndex];\n\n\t\t\tif (attackStyle \u003d\u003d AttackStyle.DEFENSIVE)\n\t\t\t{\n\t\t\t\tif (Arrays.equals(attackStyles, ATTACK_STYLES_POWERED_STAVE))\n\t\t\t\t{\n\t\t\t\t\tattackStyle \u003d AttackStyle.DEFENSIVE_CASTING;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (attackStyle \u003d\u003d null)\n\t\t\t{\n\t\t\t\tattackStyle \u003d AttackStyle.OTHER;\n\t\t\t}\n\n\t\t\tlog.debug(\"{} - updateAttackStyle: attackStyle\u003d{}\", client.getTickCount(), attackStyle);\n\t\t}\n\t}\n\n\tprivate AttackStyle[] getWeaponTypeStyles(final int weaponType)\n\t{\n\t\tfinal int weaponStyleEnum \u003d client.getEnum(EnumID.WEAPON_STYLES).getIntValue(weaponType);\n\t\tif (weaponStyleEnum \u003d\u003d -1)\n\t\t{\n\t\t\tif (weaponType \u003d\u003d 22)\n\t\t\t{\n\t\t\t\treturn new AttackStyle[]{\n\t\t\t\t\tAttackStyle.ACCURATE,\n\t\t\t\t\tAttackStyle.AGGRESSIVE,\n\t\t\t\t\tnull,\n\t\t\t\t\tAttackStyle.DEFENSIVE,\n\t\t\t\t\tAttackStyle.CASTING,\n\t\t\t\t\tAttackStyle.DEFENSIVE_CASTING\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (weaponType \u003d\u003d 30)\n\t\t\t{\n\t\t\t\treturn new AttackStyle[]{\n\t\t\t\t\tAttackStyle.ACCURATE, AttackStyle.AGGRESSIVE, AttackStyle.AGGRESSIVE, AttackStyle.DEFENSIVE\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn new AttackStyle[0];\n\t\t}\n\t\tfinal int[] weaponStyleStructs \u003d client.getEnum(weaponStyleEnum).getIntVals();\n\n\t\tfinal AttackStyle[] styles \u003d new AttackStyle[weaponStyleStructs.length];\n\t\tint i \u003d 0;\n\t\tfor (final int style : weaponStyleStructs)\n\t\t{\n\t\t\tfinal StructComposition attackStyleStruct \u003d client.getStructComposition(style);\n\t\t\tfinal String attackStyleName \u003d attackStyleStruct.getStringValue(ParamID.ATTACK_STYLE_NAME);\n\n\t\t\tAttackStyle attackStyle \u003d AttackStyle.valueOf(attackStyleName.toUpperCase());\n\t\t\tif (attackStyle \u003d\u003d AttackStyle.OTHER)\n\t\t\t{\n\t\t\t\t++i;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (i \u003d\u003d 5 \u0026\u0026 attackStyle \u003d\u003d AttackStyle.DEFENSIVE)\n\t\t\t{\n\t\t\t\tattackStyle \u003d AttackStyle.DEFENSIVE_CASTING;\n\t\t\t}\n\n\t\t\tstyles[i++] \u003d attackStyle;\n\t\t}\n\t\treturn styles;\n\t}\n\n\tprivate int calcDamageFromXpDrop(final Skill skill, final int xp)\n\t{\n\t\tif (attackStyle \u003d\u003d null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tdouble damage \u003d 0;\n\n\t\tswitch (skill)\n\t\t{\n\t\t\tcase ATTACK:\n\t\t\tcase STRENGTH:\n\t\t\tcase DEFENCE:\n\t\t\t\tswitch (attackStyle)\n\t\t\t\t{\n\t\t\t\t\tcase ACCURATE:\n\t\t\t\t\tcase AGGRESSIVE:\n\t\t\t\t\tcase DEFENSIVE:\n\t\t\t\t\t\tdamage \u003d xp / 4.0D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase CONTROLLED:\n\t\t\t\t\t\tdamage \u003d xp / 1.33D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase DEFENSIVE_CASTING:\n\t\t\t\t\t\tdamage \u003d xp;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase HITPOINTS:\n\t\t\t\tif (attackStyle \u003d\u003d AttackStyle.CASTING)\n\t\t\t\t{\n\t\t\t\t\tdamage \u003d xp / 1.33D;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RANGED:\n\t\t\t\tswitch (attackStyle)\n\t\t\t\t{\n\t\t\t\t\tcase RANGING:\n\t\t\t\t\t\tdamage \u003d xp / 4.0D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase LONGRANGE:\n\t\t\t\t\t\tdamage \u003d xp / 2.0D;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn (int) Math.round(damage);\n\t}\n\n\tprivate static boolean isLarva(final NPC npc)\n\t{\n\t\tif (npc \u003d\u003d null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal int id \u003d npc.getId();\n\n\t\treturn id \u003d\u003d NpcID.DOM_DEMONIC_ENERGY || id \u003d\u003d NpcID.DOM_DEMONIC_ENERGY_RANGE ||\n\t\t\tid \u003d\u003d NpcID.DOM_DEMONIC_ENERGY_MAGE || id \u003d\u003d NpcID.DOM_DEMONIC_ENERGY_MELEE ||\n\t\t\tid \u003d\u003d NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE || id \u003d\u003d NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE;\n\t}\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\DemonicLarvaTrackerPlugin.java"},{"fileName":"Larva.java","content":"package com.demoniclarvatracker;\n\nimport lombok.AccessLevel;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.Setter;\nimport lombok.ToString;\nimport net.runelite.api.NPC;\nimport net.runelite.api.gameval.NpcID;\n\n@ToString\n@Getter(AccessLevel.PACKAGE)\n@EqualsAndHashCode(onlyExplicitlyIncluded \u003d true)\nclass Larva\n{\n\t@EqualsAndHashCode.Include\n\tprivate final NPC npc;\n\n\tprivate final int maxHp;\n\tprivate int hp;\n\n\tprivate int queuedDamage;\n\n\tprivate int deathTick;\n\n\t@Setter(AccessLevel.PACKAGE)\n\tprivate boolean xpProcessed;\n\n\tLarva(final @NonNull NPC npc)\n\t{\n\t\tthis.npc \u003d npc;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\tmaxHp \u003d 2;\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\tmaxHp \u003d 4;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Not a larva: \" + npc.getName());\n\t\t}\n\n\t\tthis.hp \u003d maxHp;\n\t}\n\n\tboolean isDead()\n\t{\n\t\treturn hp \u003d\u003d 0;\n\t}\n\n\tvoid damage(final int amount)\n\t{\n\t\tqueuedDamage \u003d Math.min(maxHp, queuedDamage + amount);\n\t\thp \u003d Math.max(0, hp - amount);\n\t}\n\n\tvoid kill(final int tick)\n\t{\n\t\thp \u003d 0;\n\t\tdeathTick \u003d tick;\n\t}\n\n\tvoid resetDeathTick()\n\t{\n\t\tdeathTick \u003d 0;\n\t}\n\n\tvoid revive()\n\t{\n\t\trecalcHp();\n\t\tqueuedDamage \u003d 0;\n\t\tdeathTick \u003d 0;\n\t}\n\n\tvoid recalcHp()\n\t{\n\t\tfinal int ratio \u003d npc.getHealthRatio();\n\t\tfinal int scale \u003d npc.getHealthScale();\n\n\t\tif (ratio \u003d\u003d -1 || scale \u003d\u003d -1)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\thp \u003d (int) (maxHp * ((double) ratio / scale));\n\t}\n\n\tboolean isTimedOut(final int tick, final int timeout)\n\t{\n\t\treturn deathTick !\u003d 0 \u0026\u0026 tick \u003e (deathTick + timeout);\n\t}\n\n\tvoid dequeueDamage(final int amount)\n\t{\n\t\tqueuedDamage \u003d Math.max(0, queuedDamage - amount);\n\t}\n\n\tboolean hasQueuedDamage()\n\t{\n\t\treturn queuedDamage \u003e 0;\n\t}\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\Larva.java"},{"fileName":"SceneOverlay.java","content":"package com.demoniclarvatracker;\n\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.RenderingHints;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport net.runelite.api.Client;\nimport net.runelite.api.NPC;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.gameval.NpcID;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\n\n@Singleton\nclass SceneOverlay extends Overlay\n{\n\tprivate final Client client;\n\tprivate final DemonicLarvaTrackerPlugin plugin;\n\tprivate final DemonicLarvaTrackerConfig config;\n\tprivate final ModelOutlineRenderer modelOutlineRenderer;\n\n\t@Inject\n\tSceneOverlay(\n\t\tfinal Client client,\n\t\tfinal DemonicLarvaTrackerPlugin plugin,\n\t\tfinal DemonicLarvaTrackerConfig config,\n\t\tfinal ModelOutlineRenderer modelOutlineRenderer)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\t\tthis.modelOutlineRenderer \u003d modelOutlineRenderer;\n\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t}\n\n\t@Override\n\tpublic Dimension render(final Graphics2D graphics)\n\t{\n\t\tif (!config.highlightOutline() \u0026\u0026\n\t\t\t!config.highlightTileOutline() \u0026\u0026\n\t\t\t!config.highlightTileFill() \u0026\u0026\n\t\t\t!config.highlightHullOutline() \u0026\u0026\n\t\t\t!config.highlightHullFill() \u0026\u0026\n\t\t\t!config.highlightClickBoxOutline() \u0026\u0026\n\t\t\t!config.highlightClickBoxFill() \u0026\u0026\n\t\t\t!config.highlightNameLabel())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal var larvae \u003d plugin.getLarvae();\n\t\tif (larvae.isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tgraphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING, config.antiAliasing() ?\n\t\t\tRenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\n\n\t\tgraphics.setFont(FontManager.getRunescapeFont());\n\n\t\tfor (final var entry : larvae.entrySet())\n\t\t{\n\t\t\tfinal var npc \u003d entry.getKey();\n\n\t\t\tif (config.hideHighlightOnDeath() \u0026\u0026 (npc.isDead() || (config.hideDeadLarva() \u0026\u0026 entry.getValue().isDead())))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (config.highlightOutline())\n\t\t\t{\n\t\t\t\trenderOutline(npc);\n\t\t\t}\n\n\t\t\tif (config.highlightTileOutline() || config.highlightTileFill())\n\t\t\t{\n\t\t\t\trenderTile(graphics, npc);\n\t\t\t}\n\n\t\t\tif (config.highlightHullOutline() || config.highlightHullFill())\n\t\t\t{\n\t\t\t\trenderHull(graphics, npc);\n\t\t\t}\n\n\t\t\tif (config.highlightClickBoxOutline() || config.highlightClickBoxFill())\n\t\t\t{\n\t\t\t\trenderClickBox(graphics, npc);\n\t\t\t}\n\n\t\t\tif (config.highlightNameLabel())\n\t\t\t{\n\t\t\t\trenderNameLabel(graphics, npc);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void renderOutline(final NPC npc)\n\t{\n\t\tfinal Color color;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\tcolor \u003d config.colorOutlineBase();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\tcolor \u003d config.colorOutlineRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\tcolor \u003d config.colorOutlineMagic();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\tcolor \u003d config.colorOutlineMelee();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tmodelOutlineRenderer.drawOutline(npc, config.highlightOutlineWidth(), color, config.highlightOutlineFeather());\n\t}\n\n\tprivate void renderTile(final Graphics2D graphics, final NPC npc)\n\t{\n\t\tfinal Polygon polygon;\n\n\t\tswitch (config.highlightTileMode())\n\t\t{\n\t\t\tcase TILE:\n\t\t\t\tpolygon \u003d npc.getCanvasTilePoly();\n\t\t\t\tbreak;\n\t\t\tcase TRUE_TILE:\n\t\t\t\tvar lp \u003d LocalPoint.fromWorld(client.getTopLevelWorldView(), npc.getWorldLocation());\n\t\t\t\tif (lp \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal var comp \u003d npc.getTransformedComposition();\n\t\t\t\tif (comp \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinal int size \u003d comp.getSize();\n\t\t\t\tlp \u003d lp.plus(Perspective.LOCAL_TILE_SIZE * (size - 1) / 2, Perspective.LOCAL_TILE_SIZE * (size - 1) / 2);\n\t\t\t\tpolygon \u003d Perspective.getCanvasTileAreaPoly(client, lp, size);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (polygon \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Color outlineColor;\n\t\tfinal Color fillColor;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\toutlineColor \u003d config.colorTileOutlineBase();\n\t\t\t\tfillColor \u003d config.colorTileFillBase();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\toutlineColor \u003d config.colorTileOutlineRange();\n\t\t\t\tfillColor \u003d config.colorTileFillRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\toutlineColor \u003d config.colorTileOutlineMagic();\n\t\t\t\tfillColor \u003d config.colorTileFillMagic();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\toutlineColor \u003d config.colorTileOutlineMelee();\n\t\t\t\tfillColor \u003d config.colorTileFillMelee();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (config.highlightTileOutline())\n\t\t{\n\t\t\tgraphics.setColor(outlineColor);\n\t\t\tgraphics.setStroke(new BasicStroke((float) config.highlightTileOutlineWidth()));\n\t\t\tgraphics.draw(polygon);\n\t\t}\n\n\t\tif (config.highlightTileFill())\n\t\t{\n\t\t\tgraphics.setColor(fillColor);\n\t\t\tgraphics.fill(polygon);\n\t\t}\n\t}\n\n\tprivate void renderHull(final Graphics2D graphics, final NPC npc)\n\t{\n\t\tfinal var shape \u003d npc.getConvexHull();\n\t\tif (shape \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal Color outlineColor;\n\t\tfinal Color fillColor;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\toutlineColor \u003d config.colorHullOutlineBase();\n\t\t\t\tfillColor \u003d config.colorHullFillBase();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\toutlineColor \u003d config.colorHullOutlineRange();\n\t\t\t\tfillColor \u003d config.colorHullFillRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\toutlineColor \u003d config.colorHullOutlineMagic();\n\t\t\t\tfillColor \u003d config.colorHullFillMagic();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\toutlineColor \u003d config.colorHullOutlineMelee();\n\t\t\t\tfillColor \u003d config.colorHullFillMelee();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (config.highlightHullOutline())\n\t\t{\n\t\t\tgraphics.setColor(outlineColor);\n\t\t\tgraphics.setStroke(new BasicStroke((float) config.highlightHullWidth()));\n\t\t\tgraphics.draw(shape);\n\t\t}\n\n\t\tif (config.highlightHullFill())\n\t\t{\n\t\t\tgraphics.setColor(fillColor);\n\t\t\tgraphics.fill(shape);\n\t\t}\n\t}\n\n\tprivate void renderClickBox(final Graphics2D graphics, final NPC npc)\n\t{\n\t\tfinal var lp \u003d npc.getLocalLocation();\n\t\tif (lp \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var shape \u003d Perspective.getClickbox(client, npc.getWorldView(), npc.getModel(), npc.getCurrentOrientation(), lp.getX(), lp.getY(),\n\t\t\tPerspective.getTileHeight(client, lp, npc.getWorldView().getPlane()));\n\t\tif (shape \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tColor outlineColor;\n\t\tColor fillColor;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\toutlineColor \u003d config.colorClickBoxOutlineBase();\n\t\t\t\tfillColor \u003d config.colorClickBoxFillBase();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\toutlineColor \u003d config.colorClickBoxOutlineRange();\n\t\t\t\tfillColor \u003d config.colorClickBoxFillRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\toutlineColor \u003d config.colorClickBoxOutlineMagic();\n\t\t\t\tfillColor \u003d config.colorClickBoxFillMagic();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\toutlineColor \u003d config.colorClickBoxOutlineMelee();\n\t\t\t\tfillColor \u003d config.colorClickBoxFillMelee();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tboolean mouseover \u003d false;\n\n\t\tif (config.highlightClickboxMouseover())\n\t\t{\n\t\t\tfinal var point \u003d client.getMouseCanvasPosition();\n\t\t\tmouseover \u003d shape.contains(point.getX(), point.getY());\n\t\t}\n\n\t\tif (config.highlightClickBoxOutline())\n\t\t{\n\t\t\tif (mouseover)\n\t\t\t{\n\t\t\t\toutlineColor \u003d darken(outlineColor, 0.7);\n\t\t\t}\n\n\t\t\tgraphics.setColor(outlineColor);\n\t\t\tgraphics.setStroke(new BasicStroke((float) config.highlightClickBoxWidth()));\n\t\t\tgraphics.draw(shape);\n\t\t}\n\n\t\tif (config.highlightClickBoxFill())\n\t\t{\n\t\t\tif (mouseover)\n\t\t\t{\n\t\t\t\tfillColor \u003d darken(fillColor, 0.5);\n\t\t\t}\n\n\t\t\tgraphics.setColor(fillColor);\n\t\t\tgraphics.fill(shape);\n\t\t}\n\t}\n\n\tprivate void renderNameLabel(final Graphics2D graphics, final NPC npc)\n\t{\n\t\tfinal String label;\n\t\tfinal Color color;\n\n\t\tswitch (npc.getId())\n\t\t{\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\tlabel \u003d config.nameLabelMelee();\n\t\t\t\tcolor \u003d config.colorMenuMelee();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\tlabel \u003d config.nameLabelRange();\n\t\t\t\tcolor \u003d config.colorMenuRange();\n\t\t\t\tbreak;\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\tlabel \u003d config.nameLabelMagic();\n\t\t\t\tcolor \u003d config.colorMenuMagic();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (label.isBlank())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal var point \u003d npc.getCanvasTextLocation(graphics, label, npc.getLogicalHeight() + 40);\n\t\tif (point \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int x \u003d point.getX();\n\t\tfinal int y \u003d point.getY();\n\n\t\tgraphics.setColor(Color.BLACK);\n\t\tgraphics.drawString(label, x + 1, y + 1);\n\t\tgraphics.drawString(label, x + 2, y + 2);\n\n\t\tgraphics.setColor(color);\n\t\tgraphics.drawString(label, x, y);\n\t}\n\n\tprivate static Color darken(final Color color, final double factor)\n\t{\n\t\treturn new Color(\n\t\t\tMath.max((int) (color.getRed() * factor), 0),\n\t\t\tMath.max((int) (color.getGreen() * factor), 0),\n\t\t\tMath.max((int) (color.getBlue() * factor), 0),\n\t\t\tcolor.getAlpha()\n\t\t);\n\t}\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\SceneOverlay.java"},{"fileName":"TileMode.java","content":"package com.demoniclarvatracker;\n\npublic enum TileMode\n{\n\tTILE,\n\tTRUE_TILE\n}\n","filePath":"src\\main\\java\\com\\demoniclarvatracker\\TileMode.java"},{"fileName":"WidgetOverlay.java","content":"package com.demoniclarvatracker;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport net.runelite.api.gameval.NpcID;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\n\n@Singleton\nclass WidgetOverlay extends Overlay\n{\n\tprivate static final int MINIMAP_DOT_RADIUS \u003d 4;\n\n\tprivate final DemonicLarvaTrackerPlugin plugin;\n\tprivate final DemonicLarvaTrackerConfig config;\n\n\t@Inject\n\tpublic WidgetOverlay(final DemonicLarvaTrackerPlugin plugin, final DemonicLarvaTrackerConfig config)\n\t{\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_WIDGETS);\n\t}\n\n\t@Override\n\tpublic Dimension render(final Graphics2D graphics2D)\n\t{\n\t\tif (config.highlightMinimap())\n\t\t{\n\t\t\trenderMinimap(graphics2D);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void renderMinimap(final Graphics2D graphics2D)\n\t{\n\t\tfinal var larvae \u003d plugin.getLarvae();\n\t\tif (larvae.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (final var entry : larvae.entrySet())\n\t\t{\n\t\t\tfinal var npc \u003d entry.getKey();\n\n\t\t\tif (npc.isDead() || (config.hideDeadLarva() \u0026\u0026 entry.getValue().isDead()))\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal var point \u003d npc.getMinimapLocation();\n\t\t\tif (point \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal Color color;\n\n\t\t\tswitch (npc.getId())\n\t\t\t{\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY:\n\t\t\t\t\tcolor \u003d config.colorMenuBase();\n\t\t\t\t\tbreak;\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_RANGE:\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_RANGE:\n\t\t\t\t\tcolor \u003d config.colorMenuRange();\n\t\t\t\t\tbreak;\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MAGE:\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_GIANT_MAGE:\n\t\t\t\t\tcolor \u003d config.colorMenuMagic();\n\t\t\t\t\tbreak;\n\t\t\t\tcase NpcID.DOM_DEMONIC_ENERGY_MELEE:\n\t\t\t\t\tcolor \u003d config.colorMenuMelee();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tgraphics2D.setColor(Color.BLACK);\n\t\t\tgraphics2D.fillOval(point.getX() - MINIMAP_DOT_RADIUS / 2, point.getY() - MINIMAP_DOT_RADIUS / 2 + 1, MINIMAP_DOT_RADIUS, MINIMAP_DOT_RADIUS);\n\t\t\tgraphics2D.setColor(color);\n\t\t\tgraphics2D.fillOval(point.getX() - MINIMAP_DOT_RADIUS / 2, point.getY() - MINIMAP_DOT_RADIUS / 2, MINIMAP_DOT_RADIUS, MINIMAP_DOT_RADIUS);\n\t\t}\n\t}\n}","filePath":"src\\main\\java\\com\\demoniclarvatracker\\WidgetOverlay.java"},{"fileName":"ExamplePluginTest.java","content":"package com.demoniclarvatracker;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ExamplePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(DemonicLarvaTrackerPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\demoniclarvatracker\\ExamplePluginTest.java"}]},{"commit":"488fa2b23bb1d00821f88916da4949e8ee9d7093","repository":"https://github.com/jkvlntn/vorkath-run-warning.git","internalName":"vorkath-run-warning","files":[{"fileName":"VorkathRunWarningConfig.java","content":"package com.vorkathrunwarning;\n\nimport net.runelite.client.config.Alpha;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\nimport java.awt.Color;\n\n@ConfigGroup(\"vorkathrunwarning\")\npublic interface VorkathRunWarningConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"displayTintWarning\",\n\t\tname \u003d \"Display tint warning\",\n\t\tdescription \u003d \"Configures whether to warn by coloring the screen.\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean displayTintWarning() { return true; }\n\n\t@Alpha\n\t@ConfigItem(\n\t\tkeyName \u003d \"tintColor\",\n\t\tname \u003d \"Tint color\",\n\t\tdescription \u003d \"Color used for the tint warning.\",\n\t\tposition \u003d 2\n\t)\n\tdefault Color tintColor()\n\t{\n\t\treturn new Color(255, 127, 127, 50);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"displayTextWarning\",\n\t\tname \u003d \"Display text warning\",\n\t\tdescription \u003d \"Configures whether to warn with a text box.\",\n\t\tposition \u003d 3\n\t)\n\tdefault boolean displayTextWarning() { return true; }\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"textColor\",\n\t\tname \u003d \"Text color\",\n\t\tdescription \u003d \"Color used for the text warning.\",\n\t\tposition \u003d 4\n\t)\n\tdefault Color textColor() { return Color.white; }\n}\n","filePath":"src\\main\\java\\com\\vorkathrunwarning\\VorkathRunWarningConfig.java"},{"fileName":"VorkathRunWarningPlugin.java","content":"package com.vorkathrunwarning;\n\nimport com.google.inject.Provides;\n\nimport javax.inject.Inject;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.NpcID;\nimport net.runelite.api.events.NpcChanged;\nimport net.runelite.api.events.NpcDespawned;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\nimport java.util.Set;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Vorkath Run Warning\"\n)\npublic class VorkathRunWarningPlugin extends Plugin\n{\n\tprivate static final int RUN_VARIABLE_ID \u003d 173;\n\tprivate static final Set\u003cInteger\u003e VORKATH_ALIVE_IDS \u003d Set.of(\n\t\t\tNpcID.VORKATH,\n\t\t\tNpcID.VORKATH_8060,\n\t\t\tNpcID.VORKATH_8061,\n\t\t\tNpcID.VORKATH_11959);\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate VorkathRunWarningConfig config;\n\n\t@Inject\n\tprivate VorkathRunWarningTintOverlay tintOverlay;\n\n\t@Inject\n\tprivate VorkathRunWarningTextOverlay textOverlay;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Getter (AccessLevel.PACKAGE)\n\tprivate boolean shouldWarn;\n\n\tprivate boolean isFighting;\n\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tupdateShouldWarn();\n\t\toverlayManager.add(tintOverlay);\n\t\toverlayManager.add(textOverlay);\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\toverlayManager.remove(tintOverlay);\n\t\toverlayManager.remove(textOverlay);\n\t}\n\n\t@Subscribe\n\tpublic void onVarbitChanged(VarbitChanged event) {\n\t\tif(event.getVarpId() \u003d\u003d RUN_VARIABLE_ID) {\n\t\t\tthis.updateShouldWarn();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onNpcChanged(NpcChanged event) {\n\t\tif (event.getOld().getId() \u003d\u003d NpcID.VORKATH_8059 \u0026\u0026 event.getNpc().getId() \u003d\u003d NpcID.VORKATH_8058) {\n\t\t\tisFighting \u003d true;\n\t\t\tthis.updateShouldWarn();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onNpcDespawned(NpcDespawned event) {\n\t\tif (VORKATH_ALIVE_IDS.contains(event.getNpc().getId())) {\n\t\t\tisFighting \u003d false;\n\t\t\tthis.updateShouldWarn();\n\t\t}\n\t}\n\n\tprivate void updateShouldWarn() {\n        this.shouldWarn \u003d this.isFighting \u0026\u0026 this.isRunEnabled();\n\t}\n\n\tprivate boolean isRunEnabled() {\n\t\treturn client.getVarpValue(RUN_VARIABLE_ID) \u003d\u003d 1;\n\t}\n\n\t@Provides\n\tVorkathRunWarningConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(VorkathRunWarningConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\vorkathrunwarning\\VorkathRunWarningPlugin.java"},{"fileName":"VorkathRunWarningTextOverlay.java","content":"package com.vorkathrunwarning;\n\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.TitleComponent;\n\nimport javax.inject.Inject;\nimport java.awt.Graphics2D;\nimport java.awt.Dimension;\n\npublic class VorkathRunWarningTextOverlay extends OverlayPanel {\n\n    private final VorkathRunWarningConfig config;\n    private final  VorkathRunWarningPlugin plugin;\n\n    @Inject\n    private VorkathRunWarningTextOverlay(VorkathRunWarningPlugin plugin, VorkathRunWarningConfig config) {\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        if (!this.plugin.isShouldWarn() || !this.config.displayTextWarning()) {\n            return null;\n        }\n        this.panelComponent.getChildren().add(TitleComponent.builder().text(\"Run Enabled!\").color(this.config.textColor()).build());\n        return super.render(graphics);\n    }\n}\n","filePath":"src\\main\\java\\com\\vorkathrunwarning\\VorkathRunWarningTextOverlay.java"},{"fileName":"VorkathRunWarningTintOverlay.java","content":"package com.vorkathrunwarning;\n\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.TitleComponent;\n\nimport javax.inject.Inject;\nimport java.awt.*;\n\npublic class VorkathRunWarningTintOverlay extends Overlay {\n\n    private final VorkathRunWarningConfig config;\n    private final  VorkathRunWarningPlugin plugin;\n    private final Client client;\n\n    @Inject\n    private VorkathRunWarningTintOverlay(VorkathRunWarningPlugin plugin, VorkathRunWarningConfig config, Client client) {\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n        this.client \u003d client;\n        setPosition(OverlayPosition.DYNAMIC);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        if (!this.plugin.isShouldWarn() || !this.config.displayTintWarning()) {\n            return null;\n        }\n        Rectangle screenRect \u003d new Rectangle(0, 0, this.client.getCanvasWidth(), this.client.getCanvasHeight());\n        graphics.setColor(this.config.tintColor());\n        graphics.fill(screenRect);\n        graphics.draw(screenRect);\n        TitleComponent pluginIndicator \u003d TitleComponent.builder().text(\"Vorkath Run Warning Active\").build();\n        pluginIndicator.setPreferredLocation(new Point(8, 20));\n        pluginIndicator.render(graphics);\n        return null;\n    }\n}\n","filePath":"src\\main\\java\\com\\vorkathrunwarning\\VorkathRunWarningTintOverlay.java"},{"fileName":"VorkathRunWarningPluginTest.java","content":"package com.vorkathrunwarning;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class VorkathRunWarningPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(VorkathRunWarningPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\vorkathrunwarning\\VorkathRunWarningPluginTest.java"}]},{"commit":"6099efb9b1b554811d242f58a775eba69c6474dc","repository":"https://github.com/VerchaSEL/spec-sound-replacer.git","internalName":"spec-sound-replacer","files":[{"fileName":"SpecSoundPanel.java","content":"package com.verchasel.specsound;\n\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.ui.PluginPanel;\n\nimport javax.swing.*;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.event.ChangeEvent;\nimport javax.swing.filechooser.FileNameExtensionFilter;\nimport java.awt.*;\nimport java.io.File;\nimport java.util.function.Function;\n\nimport static com.verchasel.specsound.SpecSoundPlugin.*;\n\npublic class SpecSoundPanel extends PluginPanel\n{\n    private final ConfigManager configManager;\n\n    private final JCheckBox useBundledCheck;\n    private JButton chooseBtn \u003d null;\n    private JLabel pathLabel \u003d null;\n    private final JSlider volumeSlider;\n    private final JLabel volumeValue;\n\n    public SpecSoundPanel(ConfigManager configManager, Runnable testAction)\n    {\n        this.configManager \u003d configManager;\n\n        setLayout(new BorderLayout());\n        JPanel col \u003d new JPanel();\n        col.setLayout(new BoxLayout(col, BoxLayout.Y_AXIS));\n        col.setBorder(new EmptyBorder(12, 12, 16, 12));\n        add(col, BorderLayout.CENTER);\n\n        Function\u003cJComponent, JPanel\u003e row \u003d comp -\u003e {\n            JPanel p \u003d new JPanel(new FlowLayout(FlowLayout.CENTER, 8, 0));\n            p.setBorder(new EmptyBorder(0, 0, 10, 0));\n            p.add(comp);\n            return p;\n        };\n        Function\u003cJComponent[], JPanel\u003e rowMany \u003d comps -\u003e {\n            JPanel p \u003d new JPanel(new FlowLayout(FlowLayout.CENTER, 8, 0));\n            p.setBorder(new EmptyBorder(0, 0, 10, 0));\n            for (JComponent c : comps) p.add(c);\n            return p;\n        };\n\n        useBundledCheck \u003d new JCheckBox(\"Use bundled sound\");\n        useBundledCheck.addActionListener(e -\u003e {\n            boolean val \u003d useBundledCheck.isSelected();\n            setCfg(K_USE_BUNDLED, val);\n            if (val) {\n                setCfg(K_CUSTOM_PATH, \"\");\n                pathLabel.setText(\"(no file selected)\");\n                chooseBtn.setEnabled(false);\n            } else {\n                chooseBtn.setEnabled(true);\n            }\n        });\n        col.add(row.apply(useBundledCheck));\n\n        chooseBtn \u003d new JButton(\"Choose custom WAV\");\n        chooseBtn.addActionListener(e -\u003e {\n            JFileChooser fc \u003d new JFileChooser();\n            fc.setDialogTitle(\"Select a WAV file\");\n            fc.setFileFilter(new FileNameExtensionFilter(\"WAV files\", \"wav\", \"wave\"));\n            if (fc.showOpenDialog(this) \u003d\u003d JFileChooser.APPROVE_OPTION) {\n                File f \u003d fc.getSelectedFile();\n                if (f !\u003d null) {\n                    setCfg(K_CUSTOM_PATH, f.getAbsolutePath());\n                    setCfg(K_USE_BUNDLED, false);\n                    pathLabel.setText(shorten(f.getAbsolutePath()));\n                    useBundledCheck.setSelected(false);\n                    chooseBtn.setEnabled(true);\n                    JOptionPane.showMessageDialog(this, \"Custom sound set.\");\n                }\n            }\n        });\n        col.add(row.apply(chooseBtn));\n\n        pathLabel \u003d new JLabel(\"(no file selected)\", SwingConstants.CENTER);\n        JPanel pathRow \u003d row.apply(pathLabel);\n        pathRow.setBorder(new EmptyBorder(0, 0, 14, 0));\n        col.add(pathRow);\n\n        JLabel volLabel \u003d new JLabel(\"Volume\");\n        volumeSlider \u003d new JSlider(0, 100, 100);\n        volumeSlider.setPaintTicks(true);\n        volumeSlider.setMajorTickSpacing(25);\n        volumeSlider.setMinorTickSpacing(5);\n        volumeValue \u003d new JLabel(\"100%\");\n\n        volumeSlider.addChangeListener((ChangeEvent e) -\u003e {\n            int val \u003d volumeSlider.getValue();\n            volumeValue.setText(val + \"%\");\n            if (!volumeSlider.getValueIsAdjusting()) {\n                setCfg(K_VOLUME, val);\n            }\n        });\n\n        JPanel volRowPanel \u003d rowMany.apply(new JComponent[]{ volLabel, volumeSlider, volumeValue });\n        volRowPanel.setBorder(new EmptyBorder(6, 0, 14, 0));\n        col.add(volRowPanel);\n\n        JButton testBtn \u003d new JButton(\"Test sound\");\n        testBtn.addActionListener(e -\u003e { if (testAction !\u003d null) testAction.run(); });\n        col.add(row.apply(testBtn));\n\n        refreshFromConfig();\n    }\n\n    public void refreshFromConfig()\n    {\n        boolean useBundled \u003d getBool();\n        String path        \u003d getString();\n        int vol            \u003d getInt();\n\n        useBundledCheck.setSelected(useBundled);\n        chooseBtn.setEnabled(!useBundled);\n        pathLabel.setText(shorten(path));\n        volumeSlider.setValue(Math.max(0, Math.min(100, vol)));\n        volumeValue.setText(volumeSlider.getValue() + \"%\");\n    }\n\n    private void setCfg(String key, Object value)\n    {\n        configManager.setConfiguration(GROUP, key, value);\n    }\n    private boolean getBool()\n    {\n        String s \u003d configManager.getConfiguration(GROUP, K_USE_BUNDLED);\n        return (s \u003d\u003d null) ? D_USE_BUNDLED : Boolean.parseBoolean(s);\n    }\n    private int getInt()\n    {\n        String s \u003d configManager.getConfiguration(GROUP, K_VOLUME);\n        if (s \u003d\u003d null) return D_VOLUME;\n        try { return Integer.parseInt(s); } catch (Exception ignored) { return D_VOLUME; }\n    }\n    private String getString()\n    {\n        String s \u003d configManager.getConfiguration(GROUP, K_CUSTOM_PATH);\n        return (s \u003d\u003d null) ? D_CUSTOM_PATH : s;\n    }\n\n    private static String shorten(String s)\n    {\n        if (s \u003d\u003d null || s.isBlank()) return \"(no file selected)\";\n        return s.length() \u003e 60 ? \"\" + s.substring(s.length() - 60) : s;\n    }\n}\n","filePath":"src\\main\\java\\com\\verchasel\\specsound\\SpecSoundPanel.java"},{"fileName":"SpecSoundPlugin.java","content":"package com.verchasel.specsound;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.events.GameTick;\n\nimport net.runelite.client.audio.AudioPlayer;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.ImageUtil;\n\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"Special Attack Sound\",\n        description \u003d \"Plays one custom WAV when your special-attack energy decreases. In-client file picker and volumeno sound IDs or folders.\",\n        tags \u003d {\"special-attack\",\"spec\",\"audio\",\"sound\",\"sfx\",\"custom\"}\n)\npublic class SpecSoundPlugin extends Plugin\n{\n    private static final int VARP_SPEC_PERCENT \u003d 300;\n\n    static final String GROUP         \u003d \"specsound\";\n    static final String K_USE_BUNDLED \u003d \"useBundled\";\n    static final String K_CUSTOM_PATH \u003d \"customPath\";\n    static final String K_VOLUME      \u003d \"volume\";\n\n    static final boolean D_USE_BUNDLED \u003d true;\n    static final String  D_CUSTOM_PATH \u003d \"\";\n    static final int     D_VOLUME      \u003d 100;\n\n    private int  lastSpecPct \u003d -1;\n    private long lastPlayMs  \u003d 0;\n\n    @Inject private Client client;\n    @Inject private ClientToolbar clientToolbar;\n    @Inject private ConfigManager configManager;\n    @Inject private AudioPlayer audioPlayer;\n    @Inject private ClientThread clientThread;\n\n    private NavigationButton navButton;\n    private SpecSoundPanel panel;\n\n    @Override\n    protected void startUp()\n    {\n        if (configManager.getConfiguration(GROUP, K_USE_BUNDLED) \u003d\u003d null)\n            configManager.setConfiguration(GROUP, K_USE_BUNDLED, D_USE_BUNDLED);\n        if (configManager.getConfiguration(GROUP, K_CUSTOM_PATH) \u003d\u003d null)\n            configManager.setConfiguration(GROUP, K_CUSTOM_PATH, D_CUSTOM_PATH);\n        if (configManager.getConfiguration(GROUP, K_VOLUME) \u003d\u003d null)\n            configManager.setConfiguration(GROUP, K_VOLUME, D_VOLUME);\n\n        panel \u003d new SpecSoundPanel(configManager, this::playCustomSound);\n\n        BufferedImage icon \u003d ImageUtil.loadImageResource(SpecSoundPlugin.class, \"/icons/icon.png\");\n        navButton \u003d NavigationButton.builder()\n                .tooltip(\"Spec Sound\")\n                .icon(icon)\n                .panel(panel)\n                .priority(5)\n                .build();\n        clientToolbar.addNavigation(navButton);\n\n        clientThread.invoke(() -\u003e {\n            lastSpecPct \u003d client.getVarpValue(VARP_SPEC_PERCENT);\n            lastPlayMs  \u003d 0;\n        });\n\n        SwingUtilities.invokeLater(panel::refreshFromConfig);\n    }\n\n    @Override\n    protected void shutDown()\n    {\n        if (navButton !\u003d null) clientToolbar.removeNavigation(navButton);\n        navButton \u003d null;\n        panel \u003d null;\n\n        lastSpecPct \u003d -1;\n        lastPlayMs  \u003d 0;\n    }\n\n    @Subscribe\n    public void onGameTick(GameTick t)\n    {\n        final int now \u003d client.getVarpValue(VARP_SPEC_PERCENT);\n\n        if (lastSpecPct \u003e\u003d 0 \u0026\u0026 now \u003c lastSpecPct \u0026\u0026 System.currentTimeMillis() - lastPlayMs \u003e 250)\n        {\n            log.debug(\"Spec drop detected: {} -\u003e {}\", lastSpecPct, now);\n            playCustomSound();\n            lastPlayMs \u003d System.currentTimeMillis();\n        }\n\n        lastSpecPct \u003d now;\n    }\n\n    void playCustomSound()\n    {\n        try\n        {\n            final boolean useBundled \u003d getBool();\n            final String path        \u003d getString();\n            final float gainDb       \u003d volumeToDb(getInt());\n\n            if (useBundled)\n            {\n                if (SpecSoundPlugin.class.getResource(\"/specsound/bundled.wav\") \u003d\u003d null) {\n                    log.warn(\"Bundled sound missing at /specsound/bundled.wav\");\n                    return;\n                }\n                audioPlayer.play(SpecSoundPlugin.class, \"/specsound/bundled.wav\", gainDb);\n            }\n            else\n            {\n                if (path !\u003d null \u0026\u0026 !path.isBlank())\n                {\n                    final File f \u003d new File(path);\n                    if (f.exists() \u0026\u0026 f.isFile())\n                    {\n                        audioPlayer.play(f, gainDb);\n                        return;\n                    }\n                    log.info(\"Custom file missing ({}), falling back to bundled\", path);\n                }\n                if (SpecSoundPlugin.class.getResource(\"/specsound/bundled.wav\") !\u003d null) {\n                    audioPlayer.play(SpecSoundPlugin.class, \"/specsound/bundled.wav\", gainDb);\n                } else {\n                    log.warn(\"Fallback bundled sound missing at /specsound/bundled.wav\");\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            log.warn(\"Failed to play custom spec sound\", ex);\n        }\n    }\n\n    boolean getBool() {\n        final String s \u003d configManager.getConfiguration(GROUP, SpecSoundPlugin.K_USE_BUNDLED);\n        return (s \u003d\u003d null) ? SpecSoundPlugin.D_USE_BUNDLED : Boolean.parseBoolean(s);\n    }\n    int getInt() {\n        final String s \u003d configManager.getConfiguration(GROUP, SpecSoundPlugin.K_VOLUME);\n        if (s \u003d\u003d null) return SpecSoundPlugin.D_VOLUME;\n        try { return Integer.parseInt(s); } catch (Exception ignored) { return SpecSoundPlugin.D_VOLUME; }\n    }\n    String getString() {\n        final String s \u003d configManager.getConfiguration(GROUP, SpecSoundPlugin.K_CUSTOM_PATH);\n        return (s \u003d\u003d null) ? SpecSoundPlugin.D_CUSTOM_PATH : s;\n    }\n\n    private static float volumeToDb(int vol0to100)\n    {\n        int v \u003d Math.max(0, Math.min(100, vol0to100));\n        return (v \u003d\u003d 0) ? -80f : (float)(20.0 * Math.log10(v / 100.0));\n    }\n}\n","filePath":"src\\main\\java\\com\\verchasel\\specsound\\SpecSoundPlugin.java"},{"fileName":"SpecSoundPluginTest.java","content":"package com.verchasel.specsound;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class SpecSoundPluginTest {\n    public static void main(String[] args) throws Exception {\n        ExternalPluginManager.loadBuiltin(SpecSoundPlugin.class);\n        RuneLite.main(args);\n    }\n}","filePath":"src\\test\\java\\com\\verchasel\\specsound\\SpecSoundPluginTest.java"}]},{"commit":"b3c5fe74e9ca44157de7996823889e2b092be391","repository":"https://github.com/DunkingOreos/Cannon-Damage.git","internalName":"cannon-damage","files":[{"fileName":"CannonDamageOverlay.java","content":"package com.cannondamage;\n\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.LineComponent;\n\nimport javax.inject.Inject;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\n\npublic class CannonDamageOverlay extends OverlayPanel\n{\n    private final CannonDamagePlugin plugin;\n\n    @Inject\n    public CannonDamageOverlay(CannonDamagePlugin plugin)\n    {\n        super(plugin);\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.TOP_LEFT);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        if (!plugin.isPluginEnabled())\n        {\n            return null;\n        }\n\n        panelComponent.getChildren().clear();\n\n        panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Cannon Damage:\")\n                .right(String.valueOf(plugin.getTotalDamage()))\n                .build());\n\n        panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Cannonballs Used:\")\n                .right(String.valueOf(plugin.getCannonballsUsed()))\n                .build());\n\n        panelComponent.getChildren().add(LineComponent.builder()\n                .left(\"Avg Dmg/Ball:\")\n                .right(String.format(\"%.2f\", plugin.getAverageDamagePerCannonball()))\n                .build());\n\n        return super.render(graphics);\n    }\n}\n","filePath":"src\\main\\java\\com\\cannondamage\\CannonDamageOverlay.java"},{"fileName":"CannonDamagePlugin.java","content":"package com.cannondamage;\n\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.Projectile;\nimport net.runelite.api.Skill;\nimport net.runelite.api.events.GameObjectDespawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.ProjectileMoved;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\nimport javax.inject.Inject;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Set;\n\n@PluginDescriptor(\n        name \u003d \"Cannon Damage\",\n        description \u003d \"Tracks the amount of damage done from the cannon and the number of cannonballs used.\",\n        tags \u003d {\"cannon\", \"damage\", \"tracker\"}\n)\n@Slf4j\npublic class CannonDamagePlugin extends Plugin {\n\n    @Inject\n    private Client client;\n\n    @Inject\n    private ClientThread clientThread;\n\n    @Inject\n    private OverlayManager overlayManager;\n\n    @Inject\n    private CannonDamageOverlay cannonDamageOverlay;\n\n    private static final Set\u003cInteger\u003e CANNON_GAME_OBJECT_IDS \u003d Set.of(6, 43027);\n    private static final Set\u003cInteger\u003e CANNONBALL_PROJECTILE_IDS \u003d Set.of(53, 2018);\n    private static final double XP_PER_DAMAGE \u003d 2.0;\n\n    private final Queue\u003cProjectile\u003e trackedProjectiles \u003d new LinkedList\u003c\u003e();\n    private boolean cannonIsPlaced \u003d false;\n\n    private int totalDamage \u003d 0;\n    private int cannonballsUsed \u003d 0;\n\n    private double cannonStartRangedXp \u003d 0;\n    private double lastRangedXp \u003d 0;\n    private boolean hasStartedTrackingXp \u003d false;\n\n    private boolean pluginEnabled \u003d false;\n\n    @Override\n    protected void startUp() {\n        log.info(\"Cannon Damage Plugin started.\");\n        overlayManager.add(cannonDamageOverlay);\n        pluginEnabled \u003d true;\n    }\n\n    @Override\n    protected void shutDown() {\n        log.info(\"Cannon Damage Plugin stopped.\");\n        overlayManager.remove(cannonDamageOverlay);\n        pluginEnabled \u003d false;\n        resetTracker();\n    }\n\n    public boolean isPluginEnabled() {\n        return pluginEnabled;\n    }\n\n    private void resetTracker() {\n        totalDamage \u003d 0;\n        cannonballsUsed \u003d 0;\n        cannonIsPlaced \u003d false;\n        trackedProjectiles.clear();\n        cannonStartRangedXp \u003d 0;\n        lastRangedXp \u003d 0;\n        hasStartedTrackingXp \u003d false;\n    }\n\n    @Subscribe\n    public void onGameObjectSpawned(GameObjectSpawned event) {\n        GameObject spawnedObject \u003d event.getGameObject();\n\n        if (CANNON_GAME_OBJECT_IDS.contains(spawnedObject.getId())) {\n            cannonIsPlaced \u003d true;\n        }\n    }\n\n    @Subscribe\n    public void onGameObjectDespawned(GameObjectDespawned event) {\n        GameObject despawnedObject \u003d event.getGameObject();\n\n        if (CANNON_GAME_OBJECT_IDS.contains(despawnedObject.getId())) {\n            cannonIsPlaced \u003d false;\n        }\n    }\n\n    @Subscribe\n    public void onProjectileMoved(ProjectileMoved event) {\n        Projectile projectile \u003d event.getProjectile();\n\n        if (CANNONBALL_PROJECTILE_IDS.contains(projectile.getId()) \u0026\u0026 !trackedProjectiles.contains(projectile)) {\n            if (trackedProjectiles.size() \u003e\u003d 5) {\n                trackedProjectiles.poll();\n            }\n\n            trackedProjectiles.add(projectile);\n            cannonballsUsed++;\n\n            if (!hasStartedTrackingXp) {\n                hasStartedTrackingXp \u003d true;\n                cannonStartRangedXp \u003d client.getSkillExperience(Skill.RANGED);\n                lastRangedXp \u003d cannonStartRangedXp;\n            }\n        }\n    }\n\n    @Subscribe\n    public void onGameTick(GameTick event) {\n        if (!pluginEnabled || !hasStartedTrackingXp) {\n            return;\n        }\n\n        double currentRangedXp \u003d client.getSkillExperience(Skill.RANGED);\n        double xpGained \u003d currentRangedXp - lastRangedXp;\n\n        if (xpGained \u003e 0) {\n            int damageDealt \u003d (int) Math.round(xpGained / XP_PER_DAMAGE);\n            totalDamage +\u003d damageDealt;\n            lastRangedXp \u003d currentRangedXp;\n        }\n    }\n\n    public int getTotalDamage() {\n        return totalDamage;\n    }\n\n    public int getCannonballsUsed() {\n        return cannonballsUsed;\n    }\n\n    public double getAverageDamagePerCannonball() {\n        return (cannonballsUsed \u003e 0) ? (double) totalDamage / cannonballsUsed : 0.0;\n    }\n}\n","filePath":"src\\main\\java\\com\\cannondamage\\CannonDamagePlugin.java"},{"fileName":"CannonDamagePluginTest.java","content":"package com.cannondamage;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class CannonDamagePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(CannonDamagePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\cannondamage\\CannonDamagePluginTest.java"}]},{"commit":"d13ab66ffe6eedc696db3003add1b8c15202d3fc","repository":"https://github.com/Richardant/minimaphider.git","internalName":"minimaphider","files":[{"fileName":"MinimapHiderPlugin.java","content":"package com.minimaphider;\n\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.ScriptID;\nimport net.runelite.api.events.ScriptPostFired;\nimport net.runelite.api.gameval.InterfaceID;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"Minimap Hider\",\n        description \u003d \"Hides minimap\",\n        tags \u003d {\"minimap\", \"hide\"}\n)\npublic class MinimapHiderPlugin extends Plugin\n{\n    @Inject\n    private Client client;\n\n    @Override\n    protected void startUp()\n    {\n        setMapHidden(true);\n    }\n\n    @Override\n    protected void shutDown()\n    {\n        setMapHidden(false);\n    }\n\n    @Subscribe\n    public void onScriptPostFired(ScriptPostFired s)\n    {\n        if (s.getScriptId() \u003d\u003d ScriptID.TOPLEVEL_REDRAW || s.getScriptId() \u003d\u003d 902 || s.getScriptId() \u003d\u003d 903 || s.getScriptId() \u003d\u003d 920)\n        {\n            setMapHidden(true);\n        }\n    }\n\n    private void setMapHidden(boolean hidden)\n    {\n        Widget classic \u003d client.getWidget(InterfaceID.TOPLEVEL_OSRS_STRETCH, 22);\n        if (classic !\u003d null)\n        {\n            classic.setHidden(hidden);\n        }\n        for (int i \u003d 23; i \u003c\u003d 32; i++)\n        {\n            Widget modern \u003d client.getWidget(InterfaceID.TOPLEVEL_PRE_EOC, i);\n            if (modern !\u003d null)\n            {\n                modern.setHidden(hidden);\n            }\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\minimaphider\\MinimapHiderPlugin.java"},{"fileName":"MinimapHiderPluginTest.java","content":"package com.minimaphider;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class MinimapHiderPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(MinimapHiderPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\minimaphider\\MinimapHiderPluginTest.java"}]},{"commit":"682d3107f6f683e443cb193d64329dd48b17bfc5","repository":"https://github.com/michael-gutman/konar-milestone-reminder.git","internalName":"konar-milestone-reminder","files":[{"fileName":"KonarReminderConfig.java","content":"package com.konarreminder;\n\nimport java.awt.Color;\n\nimport net.runelite.client.config.*;\n\n@ConfigGroup(KonarReminderConfig.CONFIG_GROUP)\npublic interface KonarReminderConfig extends Config\n{\n\tString CONFIG_GROUP \u003d \"konarreminder\";\n\tString TASK_UNIT \u003d \" tasks\";\n\tString DEFAULT_REMINDER_MSG \u003d \"You should visit Konar to get bonus points for your next task.\";\n\tString SLAYER_MASTERS \u003d \"Turael,Aya,Spria,Krystilia,Mazchna,Achtryn,Vannaka,Chaeldar,Nieve,Steve,Duradel,Kuradal\";\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"multiple\",\n\t\t\tname \u003d \"Milestone Reminder\",\n\t\t\tdescription \u003d \"Sets the task multiple/milestone to activate the reminder before\"\n\t)\n\t@Units(KonarReminderConfig.TASK_UNIT)\n\tdefault int multiple()\n\t{\n\t\treturn 50;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"chatMessageColor\",\n\t\t\tname \u003d \"Chat Message Color\",\n\t\t\tdescription \u003d \"The chat message reminder to use Konar will be this color.\"\n\t)\n\tdefault Color chatMessageColor()\n\t{\n\t\treturn Color.decode(\"#11979B\");\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"chatMessageText\",\n\t\t\tname \u003d \"Chat Message Text\",\n\t\t\tdescription \u003d \"The chat message that is sent in the chatbox.\"\n\t)\n\tdefault String chatMessageText() { return DEFAULT_REMINDER_MSG; }\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Other Master Highlight style\",\n\t\t\tdescription \u003d \"The render style of NPC highlighting for other slayer masters\",\n\t\t\tposition \u003d 0\n\t)\n\tString renderStyleSection \u003d \"renderStyleSection\";\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"hideOtherSlayerMasters\",\n\t\t\tname \u003d \"Hide non-Konar on reminder\",\n\t\t\tdescription \u003d \"Configures whether or not other slayer masters should be hidden when you should go to konar\",\n\t\t\tsection \u003d renderStyleSection,\n\t\t\tposition \u003d -2\n\t)\n\tdefault boolean hideOtherSlayerMasters()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"otherHighlight\",\n\t\t\tname \u003d \"Highlight non-Konar on reminder\",\n\t\t\tdescription \u003d \"Configures whether or not other slayer masters should be highlighted when you should go to konar\",\n\t\t\tsection \u003d renderStyleSection,\n\t\t\tposition \u003d -1\n\t)\n\tdefault boolean otherHighlight()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 0,\n\t\t\tkeyName \u003d \"highlightHull\",\n\t\t\tname \u003d \"Highlight hull\",\n\t\t\tdescription \u003d \"Configures whether or not NPC should be highlighted by hull\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault boolean highlightHull()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"highlightTile\",\n\t\t\tname \u003d \"Highlight tile\",\n\t\t\tdescription \u003d \"Configures whether or not NPC should be highlighted by tile\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault boolean highlightTile()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"highlightOutline\",\n\t\t\tname \u003d \"Highlight outline\",\n\t\t\tdescription \u003d \"Configures whether or not the model of the NPC should be highlighted by outline\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault boolean highlightOutline()\n\t{\n\t\treturn true;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 10,\n\t\t\tkeyName \u003d \"npcColor\",\n\t\t\tname \u003d \"Highlight Color\",\n\t\t\tdescription \u003d \"Color of the NPC highlight border, menu, and text\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault Color highlightColor()\n\t{\n\t\treturn Color.RED;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 11,\n\t\t\tkeyName \u003d \"fillColor\",\n\t\t\tname \u003d \"Fill Color\",\n\t\t\tdescription \u003d \"Color of the NPC highlight fill\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault Color fillColor()\n\t{\n\t\treturn new Color(0, 255, 255, 20);\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 12,\n\t\t\tkeyName \u003d \"borderWidth\",\n\t\t\tname \u003d \"Border Width\",\n\t\t\tdescription \u003d \"Width of the highlighted NPC border\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\tdefault double borderWidth()\n\t{\n\t\treturn 2;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 13,\n\t\t\tkeyName \u003d \"outlineFeather\",\n\t\t\tname \u003d \"Outline feather\",\n\t\t\tdescription \u003d \"Specify between 0-4 how much of the model outline should be faded\",\n\t\t\tsection \u003d renderStyleSection\n\t)\n\t@Range(\n\t\t\tmin \u003d 0,\n\t\t\tmax \u003d 4\n\t)\n\tdefault int outlineFeather()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"reminderStatus\",\n\t\t\tname \u003d \"\",\n\t\t\tdescription \u003d \"\",\n\t\t\thidden \u003d true\n\t)\n\tdefault boolean getReminderStatus()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"reminderStatus\",\n\t\t\tname \u003d \"\",\n\t\t\tdescription \u003d \"\"\n\t)\n\tvoid setReminderStatus(boolean reminderStatus);\n\n}\n","filePath":"src\\main\\java\\com\\konarreminder\\KonarReminderConfig.java"},{"fileName":"KonarReminderPlugin.java","content":"package com.konarreminder;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\n\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.time.Instant;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport net.runelite.api.*;\nimport net.runelite.api.events.*;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.callback.Hooks;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.npcoverlay.HighlightedNpc;\nimport net.runelite.client.game.npcoverlay.NpcOverlayService;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.util.ColorUtil;\nimport net.runelite.client.util.Text;\nimport net.runelite.client.util.WildcardMatcher;\n\nimport static com.konarreminder.KonarReminderConfig.CONFIG_GROUP;\n\n@Slf4j\n@PluginDescriptor(\n\t\tname \u003d \"Konar Milestone Reminder\"\n)\npublic class KonarReminderPlugin extends Plugin\n{\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate KonarReminderConfig config;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate NpcOverlayService npcOverlayService;\n\n\t@Inject\n\tprivate Hooks hooks;\n\n\t/**\n\t * NPCs to highlight\n\t */\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final Map\u003cNPC, HighlightedNpc\u003e highlightedNpcs \u003d new HashMap\u003c\u003e();\n\n\t/**\n\t * The time when the last game tick event ran.\n\t */\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate Instant lastTickUpdate;\n\n\t/**\n\t * Highlight strings from the configuration\n\t */\n\tprivate List\u003cString\u003e highlights \u003d new ArrayList\u003c\u003e();\n\n\tprivate final Hooks.RenderableDrawListener drawListener \u003d this::shouldDraw;\n\n\tprivate final Function\u003cNPC, HighlightedNpc\u003e isHighlighted \u003d highlightedNpcs::get;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tnpcOverlayService.registerHighlighter(isHighlighted);\n\t\thooks.registerRenderableDrawListener(drawListener);\n\n\t\tclientThread.invoke(this::rebuild);\n\n\t\tlog.info(\"Konar Milestone Reminder started!\");\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tnpcOverlayService.unregisterHighlighter(isHighlighted);\n\t\thooks.unregisterRenderableDrawListener(drawListener);\n\n\t\tclientThread.invoke(highlightedNpcs::clear);\n\n\t\tlog.info(\"Konar Milestone Reminder stopped!\");\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged event)\n\t{\n\t\tif (event.getGameState() \u003d\u003d GameState.LOGIN_SCREEN ||\n\t\t\t\tevent.getGameState() \u003d\u003d GameState.HOPPING)\n\t\t{\n\t\t\thighlightedNpcs.clear();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\t\tif (!configChanged.getGroup().equals(CONFIG_GROUP))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tclientThread.invoke(this::rebuild);\n\t}\n\n\t@Subscribe\n\tpublic void onNpcSpawned(NpcSpawned npcSpawned)\n\t{\n\t\tfinal NPC npc \u003d npcSpawned.getNpc();\n\t\tfinal String npcName \u003d npc.getName();\n\n\t\tif (npcName \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (highlightMatchesNPCName(npcName))\n\t\t{\n\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onNpcDespawned(NpcDespawned npcDespawned)\n\t{\n\t\tfinal NPC npc \u003d npcDespawned.getNpc();\n\n\t\thighlightedNpcs.remove(npc);\n\t}\n\n\t@Subscribe\n\tpublic void onNpcChanged(NpcChanged event)\n\t{\n\t\tfinal NPC npc \u003d event.getNpc();\n\t\tfinal String npcName \u003d npc.getName();\n\n\t\thighlightedNpcs.remove(npc);\n\n\t\tif (npcName \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick event)\n\t{\n\t\tlastTickUpdate \u003d Instant.now();\n\t}\n\n\t@VisibleForTesting\n\tList\u003cString\u003e getHighlights()\n\t{\n\t\treturn Text.fromCSV(config.SLAYER_MASTERS);\n\t}\n\n\n\tvoid rebuild()\n\t{\n\t\thighlights \u003d getHighlights();\n\t\thighlightedNpcs.clear();\n\n\t\tif (client.getGameState() !\u003d GameState.LOGGED_IN \u0026\u0026\n\t\t\t\tclient.getGameState() !\u003d GameState.LOADING)\n\t\t{\n\t\t\t// NPCs are still in the client after logging out,\n\t\t\t// but we don\u0027t want to highlight those.\n\t\t\treturn;\n\t\t}\n\n\t\tfor (NPC npc : client.getNpcs())\n\t\t{\n\t\t\tfinal String npcName \u003d npc.getName();\n\n\t\t\tif (npcName \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (highlightMatchesNPCName(npcName))\n\t\t\t{\n\t\t\t\thighlightedNpcs.put(npc, highlightedNpc(npc));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tnpcOverlayService.rebuild();\n\t}\n\n\tprivate boolean highlightMatchesNPCName(String npcName)\n\t{\n\t\tfor (String highlight : highlights)\n\t\t{\n\t\t\tif (WildcardMatcher.matches(highlight, npcName))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate HighlightedNpc highlightedNpc(NPC npc)\n\t{\n\t\tif (config.otherHighlight() \u0026\u0026 config.getReminderStatus()) {\n\t\t\treturn HighlightedNpc.builder()\n\t\t\t\t\t.npc(npc)\n\t\t\t\t\t.highlightColor(config.highlightColor())\n\t\t\t\t\t.fillColor(config.fillColor())\n\t\t\t\t\t.hull(config.highlightHull())\n\t\t\t\t\t.tile(config.highlightTile())\n\t\t\t\t\t.outline(config.highlightOutline())\n\t\t\t\t\t.borderWidth((float) config.borderWidth())\n\t\t\t\t\t.outlineFeather(config.outlineFeather())\n\t\t\t\t\t.build();\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage chatMessage)\n\t{\n\t\tString message \u003d chatMessage.getMessage();\n\t\tif (chatMessage.getType() !\u003d ChatMessageType.GAMEMESSAGE)\n\t\t\treturn;\n\n\t\tString reminderText \u003d config.chatMessageText().isEmpty() ? config.DEFAULT_REMINDER_MSG : config.chatMessageText();\n\t\tString reminderMessage \u003d ColorUtil.wrapWithColorTag(reminderText, config.chatMessageColor());\n\t\tif (message.equals(reminderMessage))\n\t\t\treturn;\n\n\t\tPattern streakPattern \u003d Pattern.compile(\"\\\\d+ tasks\");\n\t\tMatcher messageMatcher \u003d streakPattern.matcher(message);\n\t\tif (!messageMatcher.find())\n\t\t\treturn;\n\n\t\tint streak \u003d Integer.parseInt(messageMatcher.group().replaceAll(\"\\\\D\", \"\"));\n\t\tif ((streak + 1) % config.multiple() \u003d\u003d 0) {\n\t\t\tconfig.setReminderStatus(true);\n\t\t\tclient.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", reminderMessage, null);\n\t\t} else {\n\t\t\tconfig.setReminderStatus(false);\n\t\t}\n\t\trebuild();\n\t}\n\n\t@Provides\n\tKonarReminderConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(KonarReminderConfig.class);\n\t}\n\n\t@VisibleForTesting\n\tboolean shouldDraw(Renderable renderable, boolean drawingUI)\n\t{\n\t\tif (renderable instanceof NPC)\n\t\t{\n\t\t\tNPC npc \u003d (NPC) renderable;\n\n\t\t\tif (highlightMatchesNPCName(npc.getName()) \u0026\u0026 config.getReminderStatus())\n\t\t\t{\n\t\t\t\treturn !config.hideOtherSlayerMasters();\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\com\\konarreminder\\KonarReminderPlugin.java"},{"fileName":"KonarReminderPluginTest.java","content":"package com.konarreminder;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class KonarReminderPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(KonarReminderPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\konarreminder\\KonarReminderPluginTest.java"}]},{"commit":"6bd14a006a9d8b94addde53ec947d87210de480a","repository":"https://github.com/Skretzo/runelite-plugins.git","internalName":"tunnel-vision","files":[{"fileName":"TunnelVisionPlugin.java","content":"package com.tunnelvision;\n\nimport java.awt.AWTEvent;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.IllegalComponentStateException;\nimport java.awt.Toolkit;\nimport java.awt.event.AWTEventListener;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseWheelEvent;\nimport java.awt.geom.Ellipse2D;\nimport javax.inject.Inject;\nimport javax.swing.JOptionPane;\nimport javax.swing.JRootPane;\nimport javax.swing.SwingUtilities;\nimport net.runelite.api.Client;\nimport net.runelite.client.config.RuneLiteConfig;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ContainableFrame;\n\n@PluginDescriptor(\n\tname \u003d \"Tunnel vision\",\n\tdescription \u003d \"Crop the client to secretly multitask\",\n\ttags \u003d {\"circle\", \"resize\", \"small\", \"hide\"}\n)\npublic class TunnelVisionPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate RuneLiteConfig runeLiteConfig;\n\n\tprivate int oldX;\n\tprivate int oldY;\n\tprivate int oldWidth;\n\tprivate int oldHeight;\n\tprivate int radius \u003d 200;\n\tprivate int diagonal \u003d Integer.MAX_VALUE;\n\tprivate ContainableFrame frame \u003d null;\n\tprivate boolean isHotkeyPressed \u003d false;\n\n\tprivate final AWTEventListener awtKeyListener \u003d awtEvent -\u003e\n\t{\n\t\tif (awtEvent instanceof KeyEvent)\n\t\t{\n\t\t\tKeyEvent keyEvent \u003d (KeyEvent) awtEvent;\n\n\t\t\tif (keyEvent.getKeyCode() !\u003d KeyEvent.VK_ALT)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (keyEvent.getID() \u003d\u003d KeyEvent.KEY_PRESSED)\n\t\t\t{\n\t\t\t\tisHotkeyPressed \u003d true;\n\t\t\t}\n\t\t\telse if (keyEvent.getID() \u003d\u003d KeyEvent.KEY_RELEASED)\n\t\t\t{\n\t\t\t\tisHotkeyPressed \u003d false;\n\t\t\t}\n\t\t}\n\t};\n\tprivate final AWTEventListener awtMouseWheelListener \u003d awtEvent -\u003e\n\t{\n\t\tif (!isHotkeyPressed)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (awtEvent instanceof MouseWheelEvent)\n\t\t{\n\t\t\tMouseWheelEvent mouseWheelEvent \u003d (MouseWheelEvent) awtEvent;\n\n\t\t\tint direction \u003d mouseWheelEvent.getWheelRotation();\n\t\t\tif (direction \u003e 0)\n\t\t\t{\n\t\t\t\tradius \u003d Math.min(radius + 10, diagonal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tradius \u003d Math.max(radius - 10, 10);\n\t\t\t}\n\n\t\t\tmouseWheelEvent.consume();\n\n\t\t\tupdate(mouseWheelEvent.getXOnScreen(), mouseWheelEvent.getYOnScreen());\n\t\t}\n\t};\n\tprivate final AWTEventListener awtMouseListener \u003d awtEvent -\u003e\n\t{\n\t\tif (awtEvent instanceof MouseEvent)\n\t\t{\n\t\t\tMouseEvent mouseEvent \u003d (MouseEvent) awtEvent;\n\t\t\tupdate(mouseEvent.getXOnScreen(), mouseEvent.getYOnScreen());\n\t\t}\n\t};\n\tprivate final ComponentAdapter clientResizeListener \u003d new ComponentAdapter()\n\t{\n\t\t@Override\n\t\tpublic void componentResized(ComponentEvent componentEvent)\n\t\t{\n\t\t\tint width \u003d frame.getWidth();\n\t\t\tint height \u003d frame.getHeight();\n\t\t\tdiagonal \u003d (int) Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)) + 1;\n\n\t\t\tif (width \u003c oldWidth || height \u003c oldHeight)\n\t\t\t{\n\t\t\t\tupdate(oldX + frame.getX(), oldY + frame.getY());\n\t\t\t}\n\n\t\t\toldWidth \u003d width;\n\t\t\toldHeight \u003d height;\n\t\t}\n\t};\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tfindFrame(client);\n\t\tToolkit.getDefaultToolkit().addAWTEventListener(awtKeyListener, AWTEvent.KEY_EVENT_MASK);\n\t\tToolkit.getDefaultToolkit().addAWTEventListener(awtMouseWheelListener, AWTEvent.MOUSE_WHEEL_EVENT_MASK);\n\t\tToolkit.getDefaultToolkit().addAWTEventListener(awtMouseListener, AWTEvent.MOUSE_MOTION_EVENT_MASK);\n\t\tframe.addComponentListener(clientResizeListener);\n\n\t\tif (!frame.isVisible())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tframe.setUndecorated(true);\n\t\t\t\tframe.getRootPane().setWindowDecorationStyle(JRootPane.FRAME);\n\t\t\t}\n\t\t\tcatch (IllegalComponentStateException e)\n\t\t\t{\n\t\t\t\tSwingUtilities.invokeLater(() -\u003e JOptionPane.showMessageDialog(frame,\n\t\t\t\t\t\"Unable to start the plugin.\\n\"\n\t\t\t\t\t+ \"The plugin was unable to remove the client window UI \"\n\t\t\t\t\t+ \"decoration, which is necessary to enable this plugin. \"\n\t\t\t\t\t+ \"Please restart the client to try again.\",\n\t\t\t\t\t\"Unable to start the plugin\", JOptionPane.ERROR_MESSAGE));\n\t\t\t}\n\t\t}\n\t\telse if (!frame.isUndecorated())\n\t\t{\n\t\t\tSwingUtilities.invokeLater(() -\u003e JOptionPane.showMessageDialog(frame,\n\t\t\t\t\"Please restart the client to properly start the plugin.\\n\"\n\t\t\t\t+ (!runeLiteConfig.enableCustomChrome() ? (\"This plugin will \"\n\t\t\t\t+ \"re-enable the custom chrome taskbar while the plugin is active. \"\n\t\t\t\t+ \"Otherwise the client no longer has an exit button. The taskbar \"\n\t\t\t\t+ \"will be removed again once the plugin is deactivated.\\n\") : \"\")\n\t\t\t\t+ \"While using the plugin you can hold down the ALT key and use \"\n\t\t\t\t+ \"the mouse scroll wheel to change the size of the cropped area.\\n\"\n\t\t\t\t+ \"It is unfortunately not possible to resize the client while \"\n\t\t\t\t+ \"this plugin is activated.\",\n\t\t\t\t\"Restart the client\", JOptionPane.INFORMATION_MESSAGE));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(oldX + frame.getX(), oldY + frame.getY());\n\t\t}\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\tToolkit.getDefaultToolkit().removeAWTEventListener(awtMouseListener);\n\t\tToolkit.getDefaultToolkit().removeAWTEventListener(awtMouseWheelListener);\n\t\tToolkit.getDefaultToolkit().removeAWTEventListener(awtKeyListener);\n\t\tframe.removeComponentListener(clientResizeListener);\n\n\t\ttry\n\t\t{\n\t\t\tframe.setShape(null);\n\t\t\tframe.setUndecorated(false);\n\t\t}\n\t\tcatch (IllegalComponentStateException e)\n\t\t{\n\t\t\tif (!runeLiteConfig.enableCustomChrome())\n\t\t\t{\n\t\t\t\tSwingUtilities.invokeLater(() -\u003e JOptionPane.showMessageDialog(frame,\n\t\t\t\t\t\"Please restart the client to restore the window UI \"\n\t\t\t\t\t+ \"decoration and remove the custom chrome taskbar.\",\n\t\t\t\t\t\"Restart the client\", JOptionPane.INFORMATION_MESSAGE));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void update(int x, int y)\n\t{\n\t\tint left \u003d frame.getX();\n\t\tint top \u003d frame.getY();\n\t\tint right \u003d left + frame.getWidth();\n\t\tint bottom \u003d top + frame.getHeight();\n\n\t\tif (x \u003c left)\n\t\t{\n\t\t\tx \u003d left;\n\t\t}\n\t\telse if (x \u003e right)\n\t\t{\n\t\t\tx \u003d right;\n\t\t}\n\n\t\tif (y \u003c top)\n\t\t{\n\t\t\ty \u003d top;\n\t\t}\n\t\telse if (y \u003e bottom)\n\t\t{\n\t\t\ty \u003d bottom;\n\t\t}\n\n\t\toldX \u003d x - left;\n\t\toldY \u003d y - top;\n\n\t\ttry\n\t\t{\n\t\t\tframe.setShape(new Ellipse2D.Double(\n\t\t\t\toldX - radius,\n\t\t\t\toldY - radius,\n\t\t\t\t2 * radius,\n\t\t\t\t2 * radius));\n\t\t}\n\t\tcatch (IllegalComponentStateException ignore)\n\t\t{\n\t\t}\n\t}\n\n\tprivate void findFrame(Client client)\n\t{\n\t\tComponent component \u003d (Component) client;\n\t\tContainer container \u003d component.getParent();\n\t\twhile (container !\u003d null)\n\t\t{\n\t\t\tif (container instanceof ContainableFrame)\n\t\t\t{\n\t\t\t\tframe \u003d (ContainableFrame) container;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontainer \u003d container.getParent();\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\tunnelvision\\TunnelVisionPlugin.java"},{"fileName":"TunnelVisionPluginTest.java","content":"package com.tunnelvision;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class TunnelVisionPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(TunnelVisionPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\tunnelvision\\TunnelVisionPluginTest.java"}]},{"commit":"f2e29bb52f895c74b22814c6d4028c5a4261a74d","repository":"https://github.com/bluelightzero/unresponsive-cursor.git","internalName":"unresponsive-cursor","files":[{"fileName":"CursorType.java","content":"package bluelightzero;\n\npublic enum CursorType {\n    DEFAULT,\n    WAITING,\n}\n","filePath":"src\\main\\java\\bluelightzero\\CursorType.java"},{"fileName":"InfoOverlay.java","content":"package bluelightzero;\n\nimport com.google.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.Point;\nimport net.runelite.client.ui.overlay.*;\n\nimport java.awt.*;\n\npublic class InfoOverlay extends Overlay {\n\n    private final Client client;\n    private final UnresponsiveCursorPlugin plugin;\n    private final UnresponsiveCursorConfig config;\n\n    private String text \u003d \"\";\n    private Color color;\n\n    @Inject\n    private InfoOverlay(Client client, UnresponsiveCursorPlugin plugin, UnresponsiveCursorConfig config)\n    {\n        this.client \u003d client;\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n        setLayer(OverlayLayer.ALWAYS_ON_TOP);\n        setPriority(OverlayPriority.HIGH);\n        setPosition(OverlayPosition.TOOLTIP);\n    }\n\n    public void clearText() {\n        this.text \u003d \"\";\n    }\n\n    public void setText(String text) {\n        this.text \u003d text;\n    }\n\n    public void setColor(Color color) {\n        this.color \u003d color;\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        if(!text.isEmpty()) {\n            final int textWidth \u003d graphics.getFontMetrics().stringWidth(text);\n            final int textHeight \u003d graphics.getFontMetrics().getAscent() - graphics.getFontMetrics().getDescent();\n\n            final Point mousePosition \u003d client.getMouseCanvasPosition();\n            final Point textPosition \u003d new Point(mousePosition.getX() + 16, mousePosition.getY() + textHeight / 2);\n            OverlayUtil.renderTextLocation(graphics, textPosition, text, color);\n        }\n\n        return null;\n    }\n}\n","filePath":"src\\main\\java\\bluelightzero\\InfoOverlay.java"},{"fileName":"UnresponsiveCursorConfig.java","content":"package bluelightzero;\n\nimport net.runelite.client.config.*;\n\nimport java.awt.*;\n\n@ConfigGroup(\"example\")\npublic interface UnresponsiveCursorConfig extends Config {\n\t@ConfigSection(\n\t\t\tname \u003d \"Server Freeze Style\",\n\t\t\tdescription \u003d \"Settings for when the server freezes. (This is when things stop for everyone.)\",\n\t\t\tposition \u003d 3\n\t)\n\tString serverFreezeSection \u003d \"Server Freeze Style\";\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Connection Lost Style\",\n\t\t\tdescription \u003d \"Settings for when you lose connection. (This is when things stop for you, but then catch up afterwards.)\",\n\t\t\tposition \u003d 5\n\t)\n\tString connectionLostSection \u003d \"Connection Lost Style\";\n\n\t@Range(\n\t\t\tmin \u003d 0\n\t)\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"delay\",\n\t\t\tname \u003d \"Delay (ms)\",\n\t\t\tdescription \u003d \"How long to wait after lag before changing cursor in milliseconds. Low values may cause cursor to flicker.\",\n\t\t\tposition \u003d 1\n\t)\n\tdefault int lagThreshold() { return 100; }\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"enableText\",\n\t\t\tname \u003d \"Enable Text\",\n\t\t\tdescription \u003d \"When turned on shows cause of lag as text next to cursor.\",\n\t\t\tposition \u003d 2\n\t)\n\tdefault boolean enableText() { return true; }\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"serverLagText\",\n\t\t\tname \u003d \"Text\",\n\t\t\tdescription \u003d \"The text to use when server freezes. (This is when things stop for everyone.)\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d serverFreezeSection\n\t)\n\tdefault String serverLagText() { return \"Server Freeze!\"; }\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"serverLagTextColor\",\n\t\t\tname \u003d \"Text Color\",\n\t\t\tdescription \u003d \"The text color to use when server freezes. (This is when things stop for everyone.)\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d serverFreezeSection\n\t)\n\tdefault Color serverLagTextColor() { return new Color(255, 141, 60); }\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"connectionLostText\",\n\t\t\tname \u003d \"Text\",\n\t\t\tdescription \u003d \"The text to use when you lose connection. (This is when things stop for you, but then catch up afterwards.)\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d connectionLostSection\n\t)\n\tdefault String connectionLostText() { return \"Connection Lost!\"; }\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"connectionLostTextColor\",\n\t\t\tname \u003d \"Text Color\",\n\t\t\tdescription \u003d \"The text color to use when you lose connection. (This is when things stop for you, but then catch up afterwards.)\",\n\t\t\tposition \u003d 6,\n\t\t\tsection \u003d connectionLostSection\n\t)\n\tdefault Color connectionLostTextColor() { return new Color(255, 57, 57); }\n\n}","filePath":"src\\main\\java\\bluelightzero\\UnresponsiveCursorConfig.java"},{"fileName":"UnresponsiveCursorPlugin.java","content":"package bluelightzero;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.events.ClientTick;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.game.WorldService;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientUI;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.util.ExecutorServiceExceptionLogger;\nimport net.runelite.http.api.worlds.World;\nimport net.runelite.http.api.worlds.WorldResult;\n\nimport java.awt.*;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.util.Date;\nimport java.util.LinkedList;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Unresponsive Cursor\"\n)\npublic class UnresponsiveCursorPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientUI clientUI;\n\n\t@Inject\n\tprivate WorldService worldService;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate InfoOverlay infoOverlay;\n\n\tprivate static final int TICK_TIME \u003d 600;\n\tprivate static final int PING_SLOW_INTERVAL \u003d 6000;\n\tprivate static final int PING_FAST_INTERVAL \u003d 200;\n\n\tprivate boolean wasLagging \u003d false;\n\tprivate Cursor replacedCursor \u003d null;\n\tprivate long lastTickTime;\n\n\tprivate ScheduledExecutorService scheduledExecutorService;\n\tprivate static final int TIMEOUT \u003d 1000;\n\tprivate static final int PORT \u003d 43594;\n\tprivate long lastPingTime;\n\tprivate final LinkedList\u003cLong\u003e recentPings \u003d new LinkedList\u003c\u003e();\n\tprivate long lastPongTime;\n\tprivate long lastPingLatency;\n\n\t@Inject\n\tprivate UnresponsiveCursorConfig config;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tscheduledExecutorService \u003d new ExecutorServiceExceptionLogger(Executors.newSingleThreadScheduledExecutor());\n\t\toverlayManager.add(infoOverlay);\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tscheduledExecutorService.shutdown();\n\t\tscheduledExecutorService \u003d null;\n\t\toverlayManager.remove(infoOverlay);\n\n\t\tif(wasLagging) {\n\t\t\twasLagging \u003d false;\n\t\t\tclientUI.resetCursor();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif(gameStateChanged.getGameState() \u003d\u003d GameState.LOGIN_SCREEN) {\n\t\t\tif(wasLagging) {\n\t\t\t\twasLagging \u003d false;\n\t\t\t\tclientUI.resetCursor();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick tick)\n\t{\n\t\tlastTickTime \u003d new Date().getTime();\n\t}\n\n\tprivate void pingCurrentWorld() {\n\t\ttry {\n\t\t\tWorldResult worldResult \u003d worldService.getWorlds();\n\t\t\tif (worldResult \u003d\u003d null || client.getGameState() !\u003d GameState.LOGGED_IN) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfinal World currentWorld \u003d worldResult.findWorld(client.getWorld());\n\t\t\tif (currentWorld \u003d\u003d null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString address \u003d currentWorld.getAddress();\n\n\t\t\tSocket socket \u003d new Socket();\n\t\t\tInetAddress inetAddress \u003d InetAddress.getByName(address);\n\t\t\tlong before \u003d new Date().getTime();\n\t\t\tsocket.connect(new InetSocketAddress(inetAddress, PORT), TIMEOUT);\n\t\t\tlong after \u003d new Date().getTime();\n\t\t\tlastPongTime \u003d after;\n\t\t\tlastPingLatency \u003d after - before;\n\t\t} catch (IOException exception) {\n\t\t}\n\t}\n\n\tprivate boolean hasBeenRecentPing() {\n\t\tlong now \u003d new Date().getTime();\n\t\tfor (Long pingTime : recentPings) {\n\t\t\tlong timeSinceRecentPing \u003d now-pingTime;\n\t\t\tif(timeSinceRecentPing \u003c PING_SLOW_INTERVAL \u0026\u0026 timeSinceRecentPing \u003e lastPingLatency) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Subscribe\n\tpublic void onClientTick(ClientTick tick) {\n\t\tlong now \u003d new Date().getTime();\n\n\t\tlong timeSinceLastTick \u003d now-lastTickTime;\n\n\t\tboolean isLagging \u003d timeSinceLastTick \u003e (600 + config.lagThreshold());\n\n\t\tif(config.enableText()) {\n\t\t\tif (isLagging \u0026\u0026 hasBeenRecentPing()) {\n\t\t\t\tlong timeSincePong \u003d now - lastPongTime;\n\t\t\t\tif (timeSincePong \u003e PING_FAST_INTERVAL + lastPingLatency) {\n\t\t\t\t\tinfoOverlay.setText(config.connectionLostText());\n\t\t\t\t\tinfoOverlay.setColor(config.connectionLostTextColor());\n\t\t\t\t} else {\n\t\t\t\t\tinfoOverlay.setText(config.serverLagText());\n\t\t\t\t\tinfoOverlay.setColor(config.serverLagTextColor());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinfoOverlay.clearText();\n\t\t\t}\n\t\t} else {\n\t\t\tinfoOverlay.clearText();\n\t\t}\n\n\t\tboolean isDefaultCursor \u003d (clientUI.getCurrentCursor().getType() \u003d\u003d Cursor.DEFAULT_CURSOR);\n\t\tboolean isCustomCursor \u003d (clientUI.getCurrentCursor().getType() \u003d\u003d Cursor.CUSTOM_CURSOR);\n\n\t\tif(isLagging \u0026\u0026 !wasLagging) {\n\t\t\tif(isDefaultCursor) {\n\t\t\t\treplacedCursor \u003d null;\n\t\t\t\tclientUI.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\t\t\t\twasLagging \u003d true;\n\t\t\t} else if(isCustomCursor) {\n\t\t\t\treplacedCursor \u003d clientUI.getCurrentCursor();\n\t\t\t\tclientUI.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n\t\t\t\twasLagging \u003d true;\n\t\t\t}\n\t\t} else if(!isLagging \u0026\u0026 wasLagging) {\n\t\t\tif(replacedCursor !\u003d null) {\n\t\t\t\tclientUI.setCursor(replacedCursor);\n\t\t\t} else {\n\t\t\t\tclientUI.resetCursor();\n\t\t\t}\n\t\t\twasLagging \u003d false;\n\t\t}\n\n\t\tlong timeSincePing \u003d now-lastPingTime;\n\t\tif(isLagging) {\n\t\t\tif(timeSincePing \u003e PING_FAST_INTERVAL) {\n\t\t\t\tscheduledExecutorService.execute(this::pingCurrentWorld);\n\t\t\t\tlastPingTime \u003d now;\n\t\t\t\trecentPings.add(now);\n\t\t\t}\n\t\t} else {\n\t\t\tif(timeSincePing \u003e PING_SLOW_INTERVAL) {\n\t\t\t\tscheduledExecutorService.execute(this::pingCurrentWorld);\n\t\t\t\tlastPingTime \u003d now;\n\t\t\t\trecentPings.add(now);\n\t\t\t}\n\t\t}\n\n\t\tif(recentPings.size() \u003e 10) {\n\t\t\trecentPings.remove();\n\t\t}\n\t}\n\n\t@Provides\n    UnresponsiveCursorConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(UnresponsiveCursorConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\bluelightzero\\UnresponsiveCursorPlugin.java"},{"fileName":"UnresponsiveCursorTest.java","content":"package bluelightzero;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class UnresponsiveCursorTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(UnresponsiveCursorPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\bluelightzero\\UnresponsiveCursorTest.java"}]},{"commit":"504883ffbc0e2c060881b9c98b7bd6769b4568aa","repository":"https://github.com/while-loop/runelite-plugins.git","internalName":"zulrah-helper","files":[{"fileName":"ImageOrientation.java","content":"package com.zulrahhelper;\n\n/**\n * Orientation of the phase images in Cardinal directions\n */\npublic enum ImageOrientation\n{\n\tSOUTH,\n\tNORTH,\n\tEAST,\n\tWEST;\n\n\tpublic double getRotation()\n\t{\n\t\tswitch (this)\n\t\t{\n\t\t\tcase NORTH:\n\t\t\t\treturn Math.PI;\n\t\t\tcase EAST:\n\t\t\t\treturn Math.PI / 2;\n\t\t\tcase WEST:\n\t\t\t\treturn Math.PI * 1.5f;\n\t\t\tcase SOUTH:\n\t\t\tdefault:\n\t\t\t\treturn 0.0;\n\t\t}\n\t}\n}","filePath":"src\\main\\java\\com\\zulrahhelper\\ImageOrientation.java"},{"fileName":"Prayer.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.options;\n\nimport java.awt.image.BufferedImage;\nimport lombok.Getter;\nimport net.runelite.client.util.ImageUtil;\n\n@Getter\npublic enum Prayer\n{\n\tMAGIC(\"protect-from-magic.png\"),\n\tRANGE(\"protect-from-missiles.png\");\n\n\tprivate final BufferedImage image;\n\n\tPrayer(String file)\n\t{\n\t\tthis.image \u003d ImageUtil.loadImageResource(Prayer.class, \"/options/\" + file);\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\options\\Prayer.java"},{"fileName":"StandLocation.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.options;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport lombok.RequiredArgsConstructor;\n\n@RequiredArgsConstructor\npublic enum StandLocation\n{\n\n\tSTART(19, 52),\n\tSTART_MAGMA(11, 43),\n\tPILLAR_1_SOUTH(20, 23),\n\tPILLAR_1_WEST(18, 16),\n\tPILLAR_1_NORTH(26, 9),\n\tNORTH(41, 10),\n\tPILLAR_2_SOUTH(62, 23),\n\tPILLAR_2_EAST(63, 16),\n\tPILLAR_2_NORTH(55, 9);\n\n\tprivate static final int WIDTH \u003d 6;\n\tprivate static final int HEIGHT \u003d 6;\n\n\tprivate final int x;\n\tprivate final int y;\n\n\tpublic void drawX(Graphics g, int px, int py)\n\t{\n\t\tvar x \u003d px + this.x - WIDTH / 2;\n\t\tvar y \u003d py + this.y - HEIGHT / 2;\n\n\t\tg.setColor(Color.WHITE);\n\n\t\tg.drawLine(x, y, x + WIDTH, y + HEIGHT);\n\t\tg.drawLine(x, y + HEIGHT, x + WIDTH, y);\n\n\t\tg.drawLine(x - 1, y, x + WIDTH - 1, y + HEIGHT);\n\t\tg.drawLine(x - 1, y + HEIGHT, x + WIDTH - 1, y);\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\options\\StandLocation.java"},{"fileName":"ZulrahForm.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.options;\n\nimport com.zulrahhelper.ZulrahHelperConfig;\nimport java.awt.Color;\n\npublic enum ZulrahForm\n{\n\tRANGE,\n\tMAGE,\n\tMELEE;\n\n\tpublic Color getColor(ZulrahHelperConfig config)\n\t{\n\t\tswitch (this)\n\t\t{\n\t\t\tcase RANGE:\n\t\t\t\treturn config.rangeColor();\n\t\t\tcase MAGE:\n\t\t\t\treturn config.mageColor();\n\t\t\tdefault:\n\t\t\t\treturn config.meleeColor();\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\options\\ZulrahForm.java"},{"fileName":"ZulrahLocation.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.options;\n\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport lombok.RequiredArgsConstructor;\n\n@RequiredArgsConstructor\npublic enum ZulrahLocation\n{\n\tNORTH(39, -10),\n\tSOUTH(40, 30),\n\tEAST(82, 25),\n\tWEST(-5, 35);\n\n\tprivate static final int PHASE_RADIUS \u003d 5;\n\tprivate static final Color BORDER_COLOR \u003d new Color(140, 140, 140);\n\n\tprivate final int x;\n\tprivate final int y;\n\n\tpublic int getX()\n\t{\n\t\treturn x - PHASE_RADIUS;\n\t}\n\n\tpublic int getY()\n\t{\n\t\treturn y - PHASE_RADIUS;\n\t}\n\n\tpublic int getWidth()\n\t{\n\t\treturn PHASE_RADIUS * 2 + 1;\n\t}\n\n\tpublic int getHeight()\n\t{\n\t\treturn PHASE_RADIUS * 2 + 1;\n\t}\n\n\tpublic void drawLocation(Graphics2D g, Color c, int px, int py)\n\t{\n\t\t// draw a little bit bigger for a sharper circle\n\t\tg.setColor(c);\n\t\tg.fillOval(getX() + px - 1, getY() + py - 1, getWidth() + 2, getHeight() + 2);\n\n\t\tg.setColor(BORDER_COLOR);\n\t\tg.drawOval(getX() + px - 1, getY() + py - 1, getWidth() + 2, getHeight() + 2);\n\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\options\\ZulrahLocation.java"},{"fileName":"Node.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.tree;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.annotation.Nonnull;\nimport lombok.Builder;\nimport lombok.EqualsAndHashCode;\nimport lombok.Getter;\nimport lombok.Singular;\nimport lombok.ToString;\n\n@Getter\n@Builder()\n@EqualsAndHashCode(onlyExplicitlyIncluded \u003d true)\n@ToString(onlyExplicitlyIncluded \u003d true)\npublic class Node\n{\n\tprotected Node parent;\n\n\t@ToString.Include\n\t@EqualsAndHashCode.Include\n\tprotected Step value;\n\n\t@Singular\n\tprotected List\u003cNode\u003e children;\n\n\tpublic int size()\n\t{\n\t\treturn this.getChildren().size();\n\t}\n\n\tpublic Node find(Step val)\n\t{\n\t\tif (this.value.equals(val))\n\t\t{\n\t\t\treturn this;\n\t\t}\n\n\t\tfor (var c : children)\n\t\t{\n\t\t\tvar n \u003d c.find(val);\n\t\t\tif (n !\u003d null)\n\t\t\t{\n\t\t\t\treturn n;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic boolean find(Node node)\n\t{\n\t\tif (node \u003d\u003d null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this \u003d\u003d node || this.value.equals(node.value))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (var c : children)\n\t\t{\n\t\t\tif (c.find(node))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic static Node of(@Nonnull Node n)\n\t{\n\t\treturn new Node(null, n.value, new ArrayList\u003c\u003e());\n\t}\n\n\tpublic static class NodeBuilder\n\t{\n\t\tNodeBuilder parentBuilder;\n\n\t\tpublic NodeBuilder node()\n\t\t{\n\t\t\tvar c \u003d Node.builder();\n\t\t\tc.parentBuilder \u003d this;\n\t\t\treturn c;\n\t\t}\n\n\t\tpublic Node buildUp()\n\t\t{\n\t\t\tNodeBuilder b \u003d this;\n\t\t\tNodeBuilder p;\n\t\t\tNode n \u003d null;\n\t\t\twhile (b !\u003d null)\n\t\t\t{\n\t\t\t\tn \u003d b.build();\n\t\t\t\tp \u003d b.parentBuilder;\n\t\t\t\tif (p !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tp.child(n);\n\t\t\t\t}\n\t\t\t\tb \u003d p;\n\t\t\t}\n\n\t\t\treturn n;\n\t\t}\n\n\t\tpublic Node build()\n\t\t{\n\t\t\tif (this.children \u003d\u003d null)\n\t\t\t{\n\t\t\t\tthis.children \u003d new ArrayList\u003c\u003e();\n\t\t\t}\n\n\t\t\tNode n \u003d new Node(null, this.value, this.children);\n\n\t\t\tfor (var c : n.children)\n\t\t\t{\n\t\t\t\tc.parent \u003d n;\n\t\t\t}\n\n\t\t\treturn n;\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\tree\\Node.java"},{"fileName":"PatternTree.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.tree;\n\nimport com.google.common.collect.Iterables;\nimport com.zulrahhelper.options.Prayer;\nimport com.zulrahhelper.options.StandLocation;\nimport com.zulrahhelper.options.ZulrahForm;\nimport com.zulrahhelper.options.ZulrahLocation;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nonnull;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport lombok.Getter;\nimport lombok.NonNull;\nimport lombok.extern.slf4j.Slf4j;\n\n@Singleton\n@Slf4j\npublic class PatternTree\n{\n\tprotected Node root;\n\n\t@Getter\n\t@NonNull\n\tprotected Node state;\n\n\t@Inject\n\tpublic PatternTree()\n\t{\n\t\tthis.root \u003d build();\n\t\tthis.state \u003d root;\n\t}\n\n\tpublic Node find(Step value)\n\t{\n\t\treturn root.find(value);\n\t}\n\n\tpublic void setState(@Nonnull Node n)\n\t{\n\t\tif (contains(n))\n\t\t{\n\t\t\tstate \u003d n;\n\t\t}\n\t}\n\n\tpublic boolean contains(Node node)\n\t{\n\t\treturn root.find(node);\n\t}\n\n\tpublic void reset()\n\t{\n\t\tstate \u003d root;\n\t}\n\n\tpublic int depth(Node node)\n\t{\n\t\treturn depth(node.getValue());\n\t}\n\n\tpublic int depth(Step value)\n\t{\n\t\tNode node \u003d find(value);\n\t\tif (node \u003d\u003d null)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tint i \u003d 0;\n\t\twhile (node.parent !\u003d null)\n\t\t{\n\t\t\ti++;\n\t\t\tnode \u003d node.parent;\n\t\t}\n\n\t\treturn i;\n\t}\n\n\tpublic List\u003cNode\u003e buildPath()\n\t{\n\t\treturn buildPath(state);\n\t}\n\n\tpublic List\u003cNode\u003e buildPath(Node n)\n\t{\n\t\tList\u003cNode\u003e path \u003d new ArrayList\u003c\u003e();\n\t\tif (n.getParent() !\u003d null)\n\t\t{\n\t\t\tvar p \u003d n.getParent();\n\t\t\twhile (p !\u003d null)\n\t\t\t{\n\t\t\t\tpath.add(0, Node.of(p));\n\t\t\t\tp \u003d p.getParent();\n\t\t\t}\n\t\t}\n\n\t\tpath.add(Node.of(n));\n\t\tvar nc \u003d n.getChildren();\n\t\twhile (!nc.isEmpty())\n\t\t{\n\t\t\tif (nc.size() \u003e 1)\n\t\t\t{\n\t\t\t\tIterables.getLast(path)\n\t\t\t\t\t.children.addAll(nc.stream()\n\t\t\t\t\t\t.map(Node::of)\n\t\t\t\t\t\t.collect(Collectors.toList()));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpath.add(Node.of(nc.get(0)));\n\t\t\t}\n\n\t\t\tnc \u003d nc.get(0).getChildren();\n\t\t}\n\n\t\treturn path;\n\t}\n\n\tprivate static Node build()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"START\")\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.build())\n\t\t\t.child(buildMelee())\n\t\t\t.child(buildRange())\n\t\t\t.child(buildMage())\n\t\t\t.build();\n\t}\n\n\tprivate static Node buildMelee()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"MAGMA\")\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t.attacks(2)\n\t\t\t\t.build())\n\t\t\t.child(Node.builder()\n\t\t\t\t.value(Step.builder()\n\t\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t\t.attacks(4)\n\t\t\t\t\t.point(StandLocation.START)\n\t\t\t\t\t.build())\n\t\t\t\t.child(buildMeleeA())\n\t\t\t\t.child(buildMeleeB())\n\t\t\t\t.build())\n\t\t\t.build();\n\t}\n\n\tprivate static Node buildMeleeA()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"MAGMA A\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(2)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.attacks(2)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.point(StandLocation.NORTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.venom(3)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(2)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(10)\n\t\t\t\t.venom(4)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.attacks(2)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"RESET\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.reset(true)\n\t\t\t\t.build())\n\t\t\t.buildUp();\n\t}\n\n\tprivate static Node buildMeleeB()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"MAGMA B\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.venom(3)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(2)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.attacks(2)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.NORTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(2)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(10)\n\t\t\t\t.venom(4)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.attacks(2)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"RESET\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.reset(true)\n\t\t\t\t.build())\n\t\t\t.buildUp();\n\t}\n\n\tprivate static Node buildRange()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"SERP\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.attacks(2)\n\t\t\t\t.venom(3)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.NORTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.NORTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.NORTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.venom(3)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(2)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(10)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"RESET\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.reset(true)\n\t\t\t\t.build())\n\t\t\t.buildUp();\n\t}\n\n\tprivate static Node buildMage()\n\t{\n\t\treturn Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"TANZ\")\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.attacks(6)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(4)\n\t\t\t\t.venom(2)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_SOUTH)\n\t\t\t\t.attacks(4)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.attacks(2)\n\t\t\t\t.venom(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.attacks(4)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.venom(3)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.EAST)\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_2_EAST)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.attacks(5)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.attacks(4)\n\t\t\t\t.venom(3)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.spawn(ZulrahLocation.WEST)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.PILLAR_1_SOUTH)\n\t\t\t\t.attacks(8)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.snakelings(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.title(\"RESET\")\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.prayer(Prayer.RANGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.reset(true)\n\t\t\t\t.build())\n\t\t\t.buildUp();\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\tree\\PatternTree.java"},{"fileName":"Step.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.tree;\n\nimport com.zulrahhelper.options.Prayer;\nimport com.zulrahhelper.options.StandLocation;\nimport com.zulrahhelper.options.ZulrahForm;\nimport com.zulrahhelper.options.ZulrahLocation;\nimport java.security.SecureRandom;\nimport java.util.List;\nimport lombok.Builder;\nimport lombok.NonNull;\nimport lombok.Singular;\nimport lombok.Value;\n\n@Value\n@Builder(toBuilder \u003d true)\npublic class Step\n{\n\tprivate static final SecureRandom RANDOM \u003d new SecureRandom();\n\n\t@Builder.Default\n\tint id \u003d RANDOM.nextInt();\n\n\tString title;\n\n\tint attacks;\n\tint venom;\n\tint snakelings;\n\n\tZulrahForm form;\n\n\t@Singular\n\tList\u003cStandLocation\u003e points;\n\n\t@Singular\n\tList\u003cPrayer\u003e prayers;\n\n\t@Builder.Default\n\tZulrahLocation spawn \u003d ZulrahLocation.SOUTH;\n\n\tboolean reset;\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\tree\\Step.java"},{"fileName":"Images.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.ui;\n\nimport com.zulrahhelper.ZulrahHelperConfig;\nimport com.zulrahhelper.ZulrahHelperPlugin;\nimport com.zulrahhelper.tree.Step;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.util.ImageUtil;\n\npublic class Images\n{\n\tprivate static final BufferedImage FLOOR_IMG \u003d ImageUtil.loadImageResource(Step.class, \"/floor.png\");\n\tprivate static final BufferedImage SNAKELINGS \u003d ImageUtil.loadImageResource(Step.class, \"/options/snakeling2.png\");\n\tprivate static final BufferedImage HITSPLAT \u003d ImageUtil.loadImageResource(Step.class, \"/options/hitsplat.png\");\n\tprivate static final BufferedImage VENOM \u003d ImageUtil.loadImageResource(Step.class, \"/options/venom.png\");\n\tprivate static final BufferedImage RESET \u003d ImageUtil.loadImageResource(ZulrahHelperPlugin.class, \"/ui/reset_icon.png\");;\n\n\n\tprivate static final int WIDTH \u003d 105;\n\tprivate static final int HEIGHT \u003d 105;\n\n\tprivate static final int PADDING \u003d 2;\n\n\tprivate static final Color DARK_BACKGROUND \u003d new Color(24, 24, 24, 65);\n\tprivate static final Color LIGHT_BACKGROUND \u003d new Color(255, 255, 255, 200);\n\n\tpublic static BufferedImage createImage(final Step step, final ZulrahHelperConfig config)\n\t{\n\t\tBufferedImage image \u003d new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_ARGB);\n\t\tGraphics2D g \u003d (Graphics2D) image.getGraphics();\n\n\t\tg.setColor(config.darkMode() ? DARK_BACKGROUND : LIGHT_BACKGROUND);\n\t\tg.fillRect(0, 0, WIDTH, HEIGHT);\n\n\t\tint px \u003d (WIDTH - FLOOR_IMG.getWidth()) / 2 + 1;\n\t\tint py \u003d (HEIGHT - FLOOR_IMG.getHeight()) / 2;\n\n\t\tg.drawImage(FLOOR_IMG, null, px, py);\n\n\t\tfor (var p : step.getPoints())\n\t\t{\n\t\t\tp.drawX(g, px, py);\n\t\t}\n\n\t\tvar spawn \u003d step.getSpawn();\n\t\tspawn.drawLocation(g, step.getForm().getColor(config), px, py);\n\n\t\tvar theta \u003d config.imageOrientation().getRotation();\n\t\tif (theta !\u003d 0)\n\t\t{\n\t\t\timage \u003d ImageUtil.rotateImage(image, theta);\n\t\t\tg.dispose();\n\t\t\tg \u003d (Graphics2D) image.getGraphics();\n\t\t}\n\n\t\tvar prayers \u003d step.getPrayers();\n\t\tif (config.displayPrayerIcons())\n\t\t{\n\t\t\tfor (int idx \u003d 0; idx \u003c prayers.size(); idx++)\n\t\t\t{\n\t\t\t\tvar p \u003d prayers.get(idx);\n\t\t\t\tvar img \u003d p.getImage();\n\n\t\t\t\tint offset \u003d idx \u003d\u003d 1 ? WIDTH - img.getWidth() - PADDING : PADDING;\n\t\t\t\tg.drawImage(img, null, offset, PADDING);\n\t\t\t}\n\t\t}\n\n\t\tg.setFont(FontManager.getRunescapeBoldFont());\n\t\tif (config.displayAttackIcons() \u0026\u0026 step.getAttacks() \u003e 0)\n\t\t{\n\t\t\tdrawSplat(g, Color.WHITE, HITSPLAT, step.getAttacks() + \"\", 0);\n\t\t}\n\n\t\tif (config.displayVenom() \u0026\u0026 step.getVenom() \u003e 0)\n\t\t{\n\t\t\tdrawSplat(g, Color.WHITE, VENOM, step.getVenom() + \"\", WIDTH / 2 - VENOM.getWidth() / 2);\n\t\t}\n\n\t\tif (config.displaySnakelings() \u0026\u0026 step.getSnakelings() \u003e 0)\n\t\t{\n\t\t\tvar c \u003d config.darkMode() ? Color.WHITE : Color.BLACK;\n\t\t\tvar x \u003d WIDTH - SNAKELINGS.getWidth() * 2 + PADDING * 2;\n\t\t\tdrawSplat(g, c, SNAKELINGS, step.getSnakelings() + \"\", x, x + PADDING);\n\t\t}\n\n\t\tif (step.isReset())\n\t\t{\n\t\t\tvar p \u003d 23;\n\t\t\tg.drawImage(RESET, p, p, RESET.getWidth() * 3, RESET.getHeight() * 3, null);\n\t\t}\n\n\t\tg.dispose();\n\t\treturn image;\n\t}\n\n\tprivate static void drawSplat(Graphics2D g, Color c, BufferedImage img, String text, int splatX, int textX)\n\t{\n\t\tvar fm \u003d g.getFontMetrics();\n\t\tg.drawImage(img, null, splatX + PADDING, HEIGHT - PADDING - HITSPLAT.getHeight());\n\t\tvar tw \u003d fm.stringWidth(text);\n\t\tvar cx \u003d HITSPLAT.getWidth() / 2 - tw / 2 + (tw % 2 \u003d\u003d 1 ? -2 : 0);\n\t\tvar cy \u003d HITSPLAT.getHeight() / 2 - fm.getFont().getSize();\n\n\t\tvar tx \u003d textX + PADDING + cx;\n\t\tvar ty \u003d HEIGHT - PADDING + cy;\n\n\t\tg.setColor(Color.BLACK);\n\t\tg.drawString(text, tx + 1, ty + 1);\n\n\t\tg.setColor(c);\n\t\tg.drawString(text, tx, ty);\n\t}\n\n\tprivate static void drawSplat(Graphics2D g, Color c, BufferedImage img, String text, int x)\n\t{\n\t\tdrawSplat(g, c, img, text, x, x);\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\ui\\Images.java"},{"fileName":"ZulrahHelperPanel.java","content":"/*\n * Copyright (c) 2020, Anthony Alves\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.ui;\n\nimport com.google.common.base.Strings;\nimport com.zulrahhelper.ZulrahHelperPlugin;\nimport com.zulrahhelper.tree.PatternTree;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.GridBagConstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.image.BufferedImage;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.swing.Box;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.PluginPanel;\nimport net.runelite.client.util.ImageUtil;\nimport net.runelite.client.util.SwingUtil;\n\n@Slf4j\n@Singleton\npublic class ZulrahHelperPanel extends PluginPanel\n{\n\tprivate static final ImageIcon RESET_ICON;\n\tprivate static final ImageIcon RESET_HOVER_ICON;\n\n\tstatic\n\t{\n\t\tfinal BufferedImage addIcon \u003d ImageUtil.loadImageResource(ZulrahHelperPlugin.class, \"/ui/reset_icon.png\");\n\t\tRESET_ICON \u003d new ImageIcon(addIcon);\n\t\tRESET_HOVER_ICON \u003d new ImageIcon(ImageUtil.alphaOffset(addIcon, 0.53f));\n\t}\n\n\tprivate final ZulrahHelperPlugin plugin;\n\tprivate final PatternTree tree;\n\n\tprivate final JPanel phasesView \u003d new JPanel(new GridBagLayout());\n\n\t@Inject\n\tZulrahHelperPanel(ZulrahHelperPlugin plugin, PatternTree tree)\n\t{\n\t\tthis.plugin \u003d plugin;\n\t\tthis.tree \u003d tree;\n\n\t\tsetLayout(new BorderLayout());\n\t\tsetBorder(new EmptyBorder(10, 10, 10, 10));\n\n\t\tJPanel northPanel \u003d new JPanel(new BorderLayout());\n\t\tnorthPanel.setBorder(new EmptyBorder(1, 0, 10, 0));\n\n\t\tJLabel title \u003d new JLabel();\n\t\ttitle.setText(\"Zulrah Helper\");\n\t\ttitle.setForeground(Color.WHITE);\n\n\t\tnorthPanel.add(title, BorderLayout.WEST);\n\t\tJButton reset \u003d new JButton(RESET_ICON);\n\t\tnorthPanel.add(reset, BorderLayout.EAST);\n\n\t\tJPanel centerPanel \u003d new JPanel(new BorderLayout());\n\t\tcenterPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tphasesView.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\treset.setToolTipText(\"Reset Zulrah rotation\");\n\t\treset.setRolloverIcon(RESET_HOVER_ICON);\n\t\treset.addActionListener(l -\u003e plugin.reset());\n\t\treset.setFocusable(false);\n\n\t\tcenterPanel.add(phasesView, BorderLayout.CENTER);\n\n\t\tadd(northPanel, BorderLayout.NORTH);\n\t\tadd(centerPanel, BorderLayout.CENTER);\n\n\t\trebuildPanel();\n\t}\n\n\tpublic void rebuildPanel()\n\t{\n\t\tSwingUtil.fastRemoveAll(phasesView);\n\n\t\tGridBagConstraints constraints \u003d new GridBagConstraints();\n\t\tconstraints.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\tconstraints.weightx \u003d 1;\n\t\tconstraints.gridx \u003d 0;\n\t\tconstraints.gridy \u003d 0;\n\n\t\tJPanel rowPanel \u003d new JPanel(new GridBagLayout());\n\t\tGridBagConstraints rowConstraints \u003d resetRowConstraints();\n\n\t\tvar path \u003d tree.buildPath();\n\t\tint phaseNumber \u003d 1;\n\t\tString title \u003d null;\n\t\tfor (var node : path)\n\t\t{\n\t\t\tif (!Strings.isNullOrEmpty(node.getValue().getTitle()))\n\t\t\t{\n\t\t\t\ttitle \u003d node.getValue().getTitle();\n\t\t\t}\n\n\t\t\tif (rowPanel.getComponentCount() \u003e\u003d 2)\n\t\t\t{\n\t\t\t\tphasesView.add(rowPanel, constraints);\n\t\t\t\tconstraints.gridy++;\n\t\t\t\trowPanel \u003d new JPanel(new GridBagLayout());\n\t\t\t\trowConstraints \u003d resetRowConstraints();\n\t\t\t}\n\n\t\t\tif (node.equals(tree.getState()))\n\t\t\t{\n\t\t\t\tcreateLabel(String.format(\"Current Phase: %s #%d\", title, phaseNumber), constraints);\n\t\t\t}\n\n\t\t\trowPanel.add(new ZulrahHelperPhasePanel(plugin, tree, node, 1), rowConstraints);\n\t\t\trowConstraints.gridx++;\n\n\t\t\tif (node.size() \u003e\u003d 2)\n\t\t\t{\n\t\t\t\tphasesView.add(rowPanel, constraints);\n\t\t\t\tconstraints.gridy++;\n\t\t\t\trowPanel \u003d new JPanel(new GridBagLayout());\n\t\t\t\trowConstraints \u003d resetRowConstraints();\n\n\t\t\t\tcreateLabel(\"Select Phase...\", constraints);\n\n\t\t\t\tfor (var nc : node.getChildren())\n\t\t\t\t{\n\t\t\t\t\trowPanel.add(new ZulrahHelperPhasePanel(plugin, tree, nc, node.size()), rowConstraints);\n\t\t\t\t\trowConstraints.gridx++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tphasesView.add(rowPanel, constraints);\n\t\t\tconstraints.gridy++;\n\t\t\tphaseNumber++;\n\t\t}\n\n\t\trepaint();\n\t\trevalidate();\n\t}\n\n\tprivate GridBagConstraints resetRowConstraints()\n\t{\n\t\tvar c \u003d new GridBagConstraints();\n\t\tc.fill \u003d GridBagConstraints.VERTICAL;\n\t\tc.weighty \u003d 1;\n\t\tc.gridx \u003d 0;\n\t\tc.gridy \u003d 0;\n\n\t\treturn c;\n\t}\n\n\tprivate void createLabel(String text, GridBagConstraints constraints)\n\t{\n\t\tphasesView.add(Box.createRigidArea(new Dimension(0, 12)), constraints);\n\t\tconstraints.gridy++;\n\t\tphasesView.add(new JLabel(text), constraints);\n\t\tconstraints.gridy++;\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\ui\\ZulrahHelperPanel.java"},{"fileName":"ZulrahHelperPhasePanel.java","content":"/*\n * Copyright (c) 2020, Anthony Alves\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper.ui;\n\nimport com.zulrahhelper.ZulrahHelperPlugin;\nimport com.zulrahhelper.tree.Node;\nimport com.zulrahhelper.tree.PatternTree;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.image.BufferedImage;\nimport javax.swing.ImageIcon;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.LineBorder;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.util.ImageUtil;\n\n@Slf4j\npublic class ZulrahHelperPhasePanel extends JPanel implements MouseListener\n{\n\tprivate final ZulrahHelperPlugin plugin;\n\tprivate final Node node;\n\n\tprivate final JLabel picLabel;\n\tprivate final ImageIcon phaseIcon;\n\tprivate final ImageIcon phaseIconHover;\n\n\tprivate final PatternTree tree;\n\n\tZulrahHelperPhasePanel(ZulrahHelperPlugin plugin, PatternTree tree, Node node, int columns)\n\t{\n\t\tthis.plugin \u003d plugin;\n\t\tthis.node \u003d node;\n\t\tthis.tree \u003d tree;\n\n\t\tBufferedImage img \u003d processImg(Images.createImage(node.getValue(), plugin.getConfig()), columns);\n\t\tphaseIcon \u003d new ImageIcon(img);\n\t\tphaseIconHover \u003d new ImageIcon(ImageUtil.luminanceScale(img, .75f));\n\n\t\tpicLabel \u003d new JLabel(phaseIcon);\n\t\tpicLabel.addMouseListener(this);\n//\n\t\tif (node.equals(tree.getState()))\n\t\t{\n\t\t\tsetBorder(new LineBorder(ColorScheme.PROGRESS_COMPLETE_COLOR));\n\t\t}\n\n\t\tif (columns \u003e\u003d 2)\n\t\t{\n\t\t\tsetBorder(new LineBorder(ColorScheme.PROGRESS_INPROGRESS_COLOR));\n\t\t}\n\n\t\tadd(picLabel);\n\t}\n\n\tprivate BufferedImage processImg(BufferedImage img, int columns)\n\t{\n\t\tint size \u003d 95;\n\t\t// make the images smaller if we\u0027re showing more than 3 images on the same row\n\t\tif (columns \u003e\u003d 3)\n\t\t{\n\t\t\tsize \u003d 60;\n\t\t}\n\t\timg \u003d ImageUtil.resizeImage(img, size, size);\n\t\tif (tree.depth(node) \u003c tree.depth(tree.getState()))\n\t\t{\n\t\t\timg \u003d ImageUtil.luminanceScale(img, 0.35f);\n\t\t}\n\n\t\treturn img;\n\t}\n\n\t@Override\n\tpublic void mouseClicked(MouseEvent mouseEvent)\n\t{\n\t}\n\n\t@Override\n\tpublic void mousePressed(MouseEvent mouseEvent)\n\t{\n\t\tplugin.setState(node);\n\t}\n\n\t@Override\n\tpublic void mouseReleased(MouseEvent mouseEvent)\n\t{\n\n\t}\n\n\t@Override\n\tpublic void mouseEntered(MouseEvent mouseEvent)\n\t{\n\t\tpicLabel.setIcon(phaseIconHover);\n\t}\n\n\t@Override\n\tpublic void mouseExited(MouseEvent mouseEvent)\n\t{\n\t\tpicLabel.setIcon(phaseIcon);\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\ui\\ZulrahHelperPhasePanel.java"},{"fileName":"ZulrahHelperConfig.java","content":"package com.zulrahhelper;\n\nimport java.awt.Color;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Keybind;\n\n@ConfigGroup(ZulrahHelperPlugin.CONFIG_GROUP)\npublic interface ZulrahHelperConfig extends Config\n{\n\t@ConfigSection(\n\t\tname \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tdescription \u003d \"All the options for image options\",\n\t\tposition \u003d 0\n\t)\n\tString SECTION_IMAGE_OPTIONS \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS;\n\n\t@ConfigSection(\n\t\tname \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tdescription \u003d \"All the options for binding hotkeys\",\n\t\tposition \u003d 1\n\t)\n\tString SECTION_HOTKEYS \u003d \"Hotkeys\";\n\n\t@ConfigSection(\n\t\tname \u003d ZulrahHelperPlugin.SECTION_MISC,\n\t\tdescription \u003d \"Miscellaneous options for the plugin\",\n\t\tposition \u003d 2\n\t)\n\tString SECTION_MISC \u003d ZulrahHelperPlugin.SECTION_MISC;\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.DISPLAY_PRAYER_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Prayer Icons\",\n\t\tdescription \u003d \"Set phase images to use prayer icons, \" +\n\t\t\t\"denoting what overhead prayer to use per phase. \" +\n\t\t\t\"No prayer icon means the phase is safe to turn overheads off.\",\n\t\tposition \u003d 0\n\t)\n\tdefault boolean displayPrayerIcons()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.DISPLAY_ATTACK_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Attack Icons\",\n\t\tdescription \u003d \"Display number of Zulrah attacks\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean displayAttackIcons()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.DISPLAY_VENOM_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Venom Icons\",\n\t\tdescription \u003d \"Display number of venom attacks\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean displayVenom()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.DISPLAY_SNAKELINGS_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Snakeling Icons\",\n\t\tdescription \u003d \"Display snakeling spawns\",\n\t\tposition \u003d 1\n\t)\n\tdefault boolean displaySnakelings()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.DARK_MODE_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Dark Mode\",\n\t\tdescription \u003d \"Set phase images to dark mode\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean darkMode()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.MAGE_COLOR_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Mage Form Color\",\n\t\tdescription \u003d \"Color of Zulrah mage form\",\n\t\tposition \u003d 3\n\t)\n\tdefault Color mageColor()\n\t{\n\t\treturn new Color(0, 51, 255);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.RANGE_COLOR_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Range Form Color\",\n\t\tdescription \u003d \"Color of Zulrah range form\",\n\t\tposition \u003d 3\n\t)\n\tdefault Color rangeColor()\n\t{\n\t\treturn new Color(25, 194, 4);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.MELEE_COLOR_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Melee Form Color\",\n\t\tdescription \u003d \"Color of Zulrah melee form\",\n\t\tposition \u003d 3\n\t)\n\tdefault Color meleeColor()\n\t{\n\t\treturn new Color(251, 0, 7);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.AUTO_HIDE_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_MISC,\n\t\tname \u003d \"Hide when outside of Zul-Andra\",\n\t\tdescription \u003d \"Don\u0027t show the button in the sidebar when you\u0027re not in Zul-Andra\",\n\t\tposition \u003d 3\n\t)\n\tdefault boolean autoHide()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d ZulrahHelperPlugin.RESET_ON_LEAVE_KEY,\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_MISC,\n\t\tname \u003d \"Reset on Leave\",\n\t\tdescription \u003d \"Automatically reset when leaving the Zulrah area\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean resetOnLeave()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"resetPhasesHotkey\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tname \u003d \"Reset Phases\",\n\t\tdescription \u003d \"Set phases back to start\",\n\t\tposition \u003d 4\n\t)\n\tdefault Keybind resetPhasesHotkey()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"nextPhaseHotkey\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tname \u003d \"Next Phase\",\n\t\tdescription \u003d \"Increment the phase number by 1\",\n\t\tposition \u003d 5\n\t)\n\tdefault Keybind nextPhaseHotkey()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"phaseSelection1Hotkey\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tname \u003d \"Phase Selection 1\",\n\t\tdescription \u003d \"Choose the first option in phase selection\",\n\t\tposition \u003d 6\n\t)\n\tdefault Keybind phaseSelection1Hotkey()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"phaseSelection2Hotkey\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tname \u003d \"Phase Selection 2\",\n\t\tdescription \u003d \"Choose the second option in phase selection\",\n\t\tposition \u003d 7\n\t)\n\tdefault Keybind phaseSelection2Hotkey()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"phaseSelection3Hotkey\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_HOTKEYS,\n\t\tname \u003d \"Phase Selection 3\",\n\t\tdescription \u003d \"Choose the third option in phase selection\",\n\t\tposition \u003d 8\n\t)\n\tdefault Keybind phaseSelection3Hotkey()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"imageOrientation\",\n\t\tsection \u003d ZulrahHelperPlugin.SECTION_IMAGE_OPTIONS,\n\t\tname \u003d \"Orientation\",\n\t\tdescription \u003d \"Rotate the phase images to the specified cardinal direction\",\n\t\tposition \u003d 9\n\t)\n\tdefault ImageOrientation imageOrientation()\n\t{\n\t\treturn ImageOrientation.SOUTH;\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\ZulrahHelperConfig.java"},{"fileName":"ZulrahHelperPlugin.java","content":"package com.zulrahhelper;\n\nimport com.google.inject.Provides;\nimport com.zulrahhelper.tree.Node;\nimport com.zulrahhelper.tree.PatternTree;\nimport com.zulrahhelper.ui.ZulrahHelperPanel;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.input.KeyManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.HotkeyListener;\nimport net.runelite.client.util.ImageUtil;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Zulrah Helper\",\n\tdescription \u003d \"Panel to show Zulrah rotations\",\n\ttags \u003d {\"zulrah\", \"pvm\"}\n)\npublic class ZulrahHelperPlugin extends Plugin\n{\n\tstatic final String CONFIG_GROUP \u003d \"zulrahhelper\";\n\tstatic final String SECTION_IMAGE_OPTIONS \u003d \"Image Options\";\n\tstatic final String SECTION_HOTKEYS \u003d \"Hotkeys\";\n\tstatic final String SECTION_MISC \u003d \"Miscellaneous\";\n\n\tstatic final String DARK_MODE_KEY \u003d \"darkMode\";\n\tstatic final String DISPLAY_PRAYER_KEY \u003d \"displayPrayer\";\n\tstatic final String DISPLAY_ATTACK_KEY \u003d \"displayAttack\";\n\tstatic final String DISPLAY_VENOM_KEY \u003d \"displayVenom\";\n\tstatic final String DISPLAY_SNAKELINGS_KEY \u003d \"displaySnakelings\";\n\tstatic final String IMAGE_ORIENTATION_KEY \u003d \"imageOrientation\";\n\tstatic final String AUTO_HIDE_KEY \u003d \"autoHide\";\n\tstatic final String RESET_ON_LEAVE_KEY \u003d \"resetOnLeave\";\n\tstatic final String MAGE_COLOR_KEY \u003d \"mageColor\";\n\tstatic final String RANGE_COLOR_KEY \u003d \"rangeColor\";\n\tstatic final String MELEE_COLOR_KEY \u003d \"meleeColor\";\n\n\n\tprivate static final int ZULANDRA_REGION_ID \u003d 8751;\n\tprivate static final int ZULRAH_SPAWN_REGION_ID \u003d 9007;\n\tprivate static final int ZULRAH_REGION_ID \u003d 9008;\n\n\tprivate static final List\u003cString\u003e OPTION_KEYS \u003d Arrays.asList(\n\t\tDARK_MODE_KEY,\n\t\tDISPLAY_PRAYER_KEY,\n\t\tDISPLAY_ATTACK_KEY,\n\t\tIMAGE_ORIENTATION_KEY,\n\t\tRESET_ON_LEAVE_KEY,\n\t\tDISPLAY_VENOM_KEY,\n\t\tDISPLAY_SNAKELINGS_KEY,\n\t\tMAGE_COLOR_KEY,\n\t\tMELEE_COLOR_KEY,\n\t\tRANGE_COLOR_KEY\n\t);\n\n\t@Inject\n\tprivate KeyManager keyManager;\n\n\t@Inject\n\tprivate ClientToolbar clientToolbar;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate PatternTree tree;\n\n\t@Inject\n\t@Getter\n\tprivate ZulrahHelperConfig config;\n\n\tprivate ZulrahHelperPanel panel;\n\tprivate NavigationButton navButton;\n\n\tprivate final List\u003cHotkeyListener\u003e hotkeys \u003d new ArrayList\u003c\u003e();\n\tprivate boolean hotkeysEnabled \u003d false;\n\tprivate boolean panelEnabled \u003d false;\n\tprivate boolean wasInInstance \u003d false;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tpanel \u003d injector.getInstance(ZulrahHelperPanel.class);\n\t\tnavButton \u003d NavigationButton.builder()\n\t\t\t.tooltip(\"Zulrah Helper\")\n\t\t\t.icon(ImageUtil.loadImageResource(getClass(), \"/icon.png\"))\n\t\t\t.priority(70)\n\t\t\t.panel(panel)\n\t\t\t.build();\n\t\tclientToolbar.addNavigation(navButton);\n\n\t\tinitHotkeys();\n\t\ttogglePanel(!config.autoHide(), false);\n\t\treset();\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tclientToolbar.removeNavigation(navButton);\n\t\thotkeys.forEach(keyManager::unregisterKeyListener);\n\t\thotkeys.clear();\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged event)\n\t{\n\t\tif (!event.getGroup().equals(CONFIG_GROUP))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (OPTION_KEYS.contains(event.getKey()))\n\t\t{\n\t\t\trebuildPanel();\n\t\t}\n\n\t\tif (event.getKey().equals(AUTO_HIDE_KEY) \u0026\u0026 !config.autoHide())\n\t\t{\n\t\t\ttogglePanel(true, false);\n\t\t}\n\t}\n\n\t@Provides\n\tZulrahHelperConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(ZulrahHelperConfig.class);\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick tick)\n\t{\n\t\tcheckRegion();\n\t}\n\n\tprivate void checkRegion()\n\t{\n\t\tif (inZulrahRegion())\n\t\t{\n\t\t\tif (!hotkeysEnabled)\n\t\t\t{\n\t\t\t\ttoggleHotkeys();\n\t\t\t}\n\n\t\t\tif (config.autoHide() \u0026\u0026 !panelEnabled)\n\t\t\t{\n\t\t\t\ttogglePanel(true, true);\n\t\t\t}\n\n\t\t\tif (wasInInstance \u0026\u0026 !client.isInInstancedRegion())\n\t\t\t{\n\t\t\t\treset();\n\t\t\t}\n\n\t\t\twasInInstance \u003d client.isInInstancedRegion();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (hotkeysEnabled)\n\t\t\t{\n\t\t\t\ttoggleHotkeys();\n\t\t\t}\n\n\t\t\tif (panelEnabled \u0026\u0026 config.autoHide())\n\t\t\t{\n\t\t\t\ttogglePanel(false, false);\n\t\t\t}\n\n\t\t\tif (wasInInstance)\n\t\t\t{\n\t\t\t\tif (config.resetOnLeave())\n\t\t\t\t{\n\t\t\t\t\treset();\n\t\t\t\t}\n\n\t\t\t\twasInInstance \u003d false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean inZulrahRegion()\n\t{\n\t\tfinal int regionId \u003d getRegionId();\n\n\t\treturn regionId \u003d\u003d ZULANDRA_REGION_ID ||\n\t\t\t((regionId \u003d\u003d ZULRAH_SPAWN_REGION_ID || regionId \u003d\u003d ZULRAH_REGION_ID) \u0026\u0026 client.isInInstancedRegion());\n\t}\n\n\tprivate int getRegionId()\n\t{\n\t\tPlayer player \u003d client.getLocalPlayer();\n\t\tif (player \u003d\u003d null)\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn WorldPoint.fromLocalInstance(client, player.getLocalLocation()).getRegionID();\n\t}\n\n\tpublic void reset()\n\t{\n\t\ttree.reset();\n\t\tSwingUtilities.invokeLater(() -\u003e panel.rebuildPanel());\n\t}\n\n\tpublic void setState(Node node)\n\t{\n\t\tvar s \u003d tree.find(node.getValue());\n\t\tif (s \u003d\u003d null)\n\t\t{\n\t\t\tlog.debug(\"state not found {}\", node);\n\t\t\treturn;\n\t\t}\n\n\t\tif (s.getValue().isReset())\n\t\t{\n\t\t\treset();\n\t\t\treturn;\n\t\t}\n\n\t\ttree.setState(s);\n\t\trebuildPanel();\n\t}\n\n\tprivate void rebuildPanel()\n\t{\n\t\tSwingUtilities.invokeLater(() -\u003e panel.rebuildPanel());\n\t}\n\n\tprivate void selectOption(int choice)\n\t{\n\t\tvar node \u003d tree.getState();\n\t\tvar choices \u003d node.getChildren();\n\t\tif (choice \u003e\u003d choices.size())\n\t\t{\n\t\t\tlog.error(\"trying to select nonexistent phase: {} {}\", choice, choices.size());\n\t\t\treturn;\n\t\t}\n\n\t\tsetState(choices.get(choice));\n\t}\n\n\tprivate void initHotkeys()\n\t{\n\t\thotkeys.forEach(keyManager::unregisterKeyListener);\n\t\thotkeys.clear();\n\n\t\thotkeys.add(new HotkeyListener(() -\u003e config.phaseSelection1Hotkey())\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void hotkeyPressed()\n\t\t\t{\n\t\t\t\tselectOption(0);\n\t\t\t}\n\t\t});\n\n\t\thotkeys.add(new HotkeyListener(() -\u003e config.phaseSelection2Hotkey())\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void hotkeyPressed()\n\t\t\t{\n\t\t\t\tselectOption(1);\n\t\t\t}\n\t\t});\n\n\t\thotkeys.add(new HotkeyListener(() -\u003e config.phaseSelection3Hotkey())\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void hotkeyPressed()\n\t\t\t{\n\t\t\t\tselectOption(2);\n\t\t\t}\n\t\t});\n\n\t\thotkeys.add(new HotkeyListener(() -\u003e config.nextPhaseHotkey())\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void hotkeyPressed()\n\t\t\t{\n\t\t\t\tselectOption(0);\n\t\t\t}\n\t\t});\n\n\t\thotkeys.add(new HotkeyListener(() -\u003e config.resetPhasesHotkey())\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void hotkeyPressed()\n\t\t\t{\n\t\t\t\treset();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void toggleHotkeys()\n\t{\n\t\thotkeys.forEach(hotkeysEnabled ? keyManager::unregisterKeyListener : keyManager::registerKeyListener);\n\t\thotkeysEnabled \u003d !hotkeysEnabled;\n\t}\n\n\tprivate void togglePanel(boolean enable, boolean show)\n\t{\n\t\tpanelEnabled \u003d enable;\n\t\tif (enable)\n\t\t{\n\t\t\tclientToolbar.addNavigation(navButton);\n\t\t\tif (show)\n\t\t\t{\n\t\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\t\tclientToolbar.openPanel(navButton);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclientToolbar.removeNavigation(navButton);\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\zulrahhelper\\ZulrahHelperPlugin.java"},{"fileName":"ImageBuilderTest.java","content":"/*\n * Copyright (c) 2024, Ron Young \u003chttps://github.com/raiyni\u003e\n * All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *     list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\npackage com.zulrahhelper;\n\nimport com.zulrahhelper.options.Prayer;\nimport com.zulrahhelper.options.StandLocation;\nimport com.zulrahhelper.options.ZulrahForm;\nimport com.zulrahhelper.options.ZulrahLocation;\nimport com.zulrahhelper.tree.Node;\nimport com.zulrahhelper.tree.Step;\nimport com.zulrahhelper.ui.Images;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport lombok.extern.slf4j.Slf4j;\nimport static org.junit.Assert.assertEquals;\nimport org.junit.Test;\nimport static org.mockito.Mockito.spy;\n\n@Slf4j\npublic class ImageBuilderTest\n{\n\tprivate ZulrahHelperConfig getConfig()\n\t{\n\t\treturn spy(ZulrahHelperConfig.class);\n\t}\n\n\t@Test\n\tpublic void streamlinedBuilder()\n\t{\n\t\tvar root \u003d Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t.attacks(2)\n\t\t\t\t.build())\n\t\t\t.node()\n\t\t\t.value(Step.builder()\n\t\t\t\t.form(ZulrahForm.MAGE)\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t.attacks(4)\n\t\t\t\t.build())\n\t\t\t.buildUp();\n\n\t\tassertEquals(1, root.getChildren().size());\n\t\tassertEquals(root, root.getChildren().get(0).getParent());\n\t\tassertEquals(1, root.getChildren().get(0).getChildren().size());\n\t\tassertEquals(ZulrahForm.MAGE, root.getChildren().get(0).getChildren().get(0).getValue().getForm());\n\t}\n\n\t@Test\n\tpublic void childrenHasParent()\n\t{\n\t\tvar root \u003d Node.builder()\n\t\t\t.value(Step.builder()\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.form(ZulrahForm.RANGE)\n\t\t\t\t.attacks(5)\n\t\t\t\t.venom(4)\n\t\t\t\t.build())\n\t\t\t.child(Node.builder()\n\t\t\t\t.value(Step.builder()\n\t\t\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t\t\t.point(StandLocation.START)\n\t\t\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t\t\t.attacks(2)\n\t\t\t\t\t.build())\n\t\t\t\t.build())\n\t\t\t.build();\n\n\t\tassertEquals(1, root.getChildren().size());\n\t\tassertEquals(root, root.getChildren().get(0).getParent());\n\t\tassertEquals(0, root.getChildren().get(0).getChildren().size());\n\t}\n\n\t@Test\n\tpublic void simpleStep() throws IOException\n\t{\n\t\tStep step \u003d Step.builder()\n\t\t\t.point(StandLocation.START)\n\t\t\t.point(StandLocation.START_MAGMA)\n\t\t\t.spawn(ZulrahLocation.NORTH)\n\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t.prayer(Prayer.RANGE)\n\t\t\t.form(ZulrahForm.MELEE)\n\t\t\t.snakelings(2)\n\t\t\t.attacks(6)\n\t\t\t.venom(3)\n\t\t\t.build();\n\n\t\tassertEquals(StandLocation.START, step.getPoints().get(0));\n\t\tassertEquals(ZulrahLocation.NORTH, step.getSpawn());\n\t\tassertEquals(2, step.getPrayers().size());\n\t\tassertEquals(Prayer.MAGIC, step.getPrayers().get(0));\n\n\t\tBufferedImage img \u003d Images.createImage(step, getConfig());\n\n\t\tFile out \u003d new File(\"out/simple.png\");\n\t\tImageIO.write(img, \"png\", out);\n\t}\n\n\t@Test\n\tpublic void spawns() throws IOException\n\t{\n\t\tfor (var loc : ZulrahLocation.values())\n\t\t{\n\t\t\tStep step \u003d Step.builder()\n\t\t\t\t.point(StandLocation.START)\n\t\t\t\t.spawn(loc)\n\t\t\t\t.build();\n\n\t\t\tBufferedImage img \u003d Images.createImage(step, getConfig());\n\n\t\t\tFile out \u003d new File(\"out/spawns/\" + loc + \".png\");\n\t\t\tImageIO.write(img, \"png\", out);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void points() throws IOException\n\t{\n\t\tfor (var loc : StandLocation.values())\n\t\t{\n\t\t\tStep step \u003d Step.builder()\n\t\t\t\t.point(loc)\n\t\t\t\t.prayer(Prayer.MAGIC)\n\t\t\t\t.build();\n\n\t\t\tBufferedImage img \u003d Images.createImage(step, getConfig());\n\n\t\t\tFile out \u003d new File(\"out/points/\" + loc + \".png\");\n\t\t\tImageIO.write(img, \"png\", out);\n\t\t}\n\t}\n}\n","filePath":"src\\test\\java\\com\\zulrahhelper\\ImageBuilderTest.java"},{"fileName":"ZulrahHelperPluginTest.java","content":"package com.zulrahhelper;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ZulrahHelperPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(ZulrahHelperPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\zulrahhelper\\ZulrahHelperPluginTest.java"}]},{"commit":"08c784abc517f4b1f2e6fd9271a52142f9312542","repository":"https://github.com/Adam-/runelite-plugins.git","internalName":"gpu-legacy","files":[{"fileName":"AntiAliasingMode.java","content":"/*\n * Copyright (c) 2018, Lotto \u003chttps://github.com/devLotto\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.config;\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@Getter\n@RequiredArgsConstructor\npublic enum AntiAliasingMode\n{\n\tDISABLED(\"Disabled\", 0),\n\tMSAA_2(\"MSAA x2\", 2),\n\tMSAA_4(\"MSAA x4\", 4),\n\tMSAA_8(\"MSAA x8\", 8),\n\tMSAA_16(\"MSAA x16\", 16);\n\n\tprivate final String name;\n\tprivate final int samples;\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn name;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\config\\AntiAliasingMode.java"},{"fileName":"ColorBlindMode.java","content":"/*\n * Copyright (c) 2020 Ben Poulson \u003chttps://github.com/benpoulson\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.config;\n\npublic enum ColorBlindMode\n{\n\tNONE,\n\tPROTANOPE,\n\tDEUTERANOPE,\n\tTRITANOPE;\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\config\\ColorBlindMode.java"},{"fileName":"UIScalingMode.java","content":"/*\n * Copyright (c) 2019 logarrhytmic \u003chttps://github.com/logarrhythmic\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.config;\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@Getter\n@RequiredArgsConstructor\npublic enum UIScalingMode\n{\n\tNEAREST(\"Nearest Neighbor\", 0),\n\tLINEAR(\"Bilinear\", 0),\n\tMITCHELL(\"Bicubic (Mitchell)\", 1),\n\tCATMULL_ROM(\"Bicubic (Catmull-Rom)\", 2),\n\tXBR(\"xBR\", 3);\n\n\tprivate final String name;\n\tprivate final int mode;\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn name;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\config\\UIScalingMode.java"},{"fileName":"GLBuffer.java","content":"/*\n * Copyright (c) 2021, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nclass GLBuffer\n{\n\tString name;\n\tint glBufferId \u003d -1;\n\tint size \u003d -1;\n\tlong clBuffer \u003d -1;\n\n\tGLBuffer(String name)\n\t{\n\t\tthis.name \u003d name;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\GLBuffer.java"},{"fileName":"GpuFloatBuffer.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\n\nclass GpuFloatBuffer\n{\n\tprivate FloatBuffer buffer \u003d allocateDirect(65536);\n\n\tvoid put(float s, float t, float p, float q)\n\t{\n\t\tbuffer.put(s).put(t).put(p).put(q);\n\t}\n\n\tvoid flip()\n\t{\n\t\tbuffer.flip();\n\t}\n\n\tvoid clear()\n\t{\n\t\tbuffer.clear();\n\t}\n\n\tvoid ensureCapacity(int size)\n\t{\n\t\tint capacity \u003d buffer.capacity();\n\t\tfinal int position \u003d buffer.position();\n\t\tif ((capacity - position) \u003c size)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcapacity *\u003d 2;\n\t\t\t}\n\t\t\twhile ((capacity - position) \u003c size);\n\n\t\t\tFloatBuffer newB \u003d allocateDirect(capacity);\n\t\t\tbuffer.flip();\n\t\t\tnewB.put(buffer);\n\t\t\tbuffer \u003d newB;\n\t\t}\n\t}\n\n\tFloatBuffer getBuffer()\n\t{\n\t\treturn buffer;\n\t}\n\n\tstatic FloatBuffer allocateDirect(int size)\n\t{\n\t\treturn ByteBuffer.allocateDirect(size * Float.BYTES)\n\t\t\t.order(ByteOrder.nativeOrder())\n\t\t\t.asFloatBuffer();\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\GpuFloatBuffer.java"},{"fileName":"GpuIntBuffer.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.IntBuffer;\n\nclass GpuIntBuffer\n{\n\tprivate IntBuffer buffer \u003d allocateDirect(65536);\n\n\tvoid put(float x, float y, float z, int w)\n\t{\n\t\tbuffer.put(Float.floatToIntBits(x))\n\t\t\t.put(Float.floatToIntBits(y))\n\t\t\t.put(Float.floatToIntBits(z))\n\t\t\t.put(w);\n\t}\n\n\tvoid flip()\n\t{\n\t\tbuffer.flip();\n\t}\n\n\tvoid clear()\n\t{\n\t\tbuffer.clear();\n\t}\n\n\tvoid ensureCapacity(int size)\n\t{\n\t\tint capacity \u003d buffer.capacity();\n\t\tfinal int position \u003d buffer.position();\n\t\tif ((capacity - position) \u003c size)\n\t\t{\n\t\t\tdo\n\t\t\t{\n\t\t\t\tcapacity *\u003d 2;\n\t\t\t}\n\t\t\twhile ((capacity - position) \u003c size);\n\n\t\t\tIntBuffer newB \u003d allocateDirect(capacity);\n\t\t\tbuffer.flip();\n\t\t\tnewB.put(buffer);\n\t\t\tbuffer \u003d newB;\n\t\t}\n\t}\n\n\tIntBuffer getBuffer()\n\t{\n\t\treturn buffer;\n\t}\n\n\tstatic IntBuffer allocateDirect(int size)\n\t{\n\t\treturn ByteBuffer.allocateDirect(size * Integer.BYTES)\n\t\t\t.order(ByteOrder.nativeOrder())\n\t\t\t.asIntBuffer();\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\GpuIntBuffer.java"},{"fileName":"GpuPlugin.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport com.google.common.primitives.Ints;\nimport com.google.inject.Provides;\nimport java.awt.Canvas;\nimport java.awt.Dimension;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.Image;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.DataBufferInt;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\nimport java.nio.ShortBuffer;\nimport javax.annotation.Nonnull;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.BufferProvider;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.GameState;\nimport net.runelite.api.IntProjection;\nimport net.runelite.api.Model;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Projection;\nimport net.runelite.api.Renderable;\nimport net.runelite.api.Scene;\nimport net.runelite.api.SceneTileModel;\nimport net.runelite.api.SceneTilePaint;\nimport net.runelite.api.Texture;\nimport net.runelite.api.TextureProvider;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.hooks.DrawCallbacks;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.plugins.PluginInstantiationException;\nimport net.runelite.client.plugins.PluginManager;\nimport info.sigterm.plugins.gpulegacy.config.AntiAliasingMode;\nimport info.sigterm.plugins.gpulegacy.config.UIScalingMode;\nimport info.sigterm.plugins.gpulegacy.template.Template;\nimport net.runelite.client.ui.ClientUI;\nimport net.runelite.client.ui.DrawManager;\nimport net.runelite.client.util.OSType;\nimport net.runelite.rlawt.AWTContext;\nimport org.lwjgl.opencl.CL10;\nimport org.lwjgl.opencl.CL10GL;\nimport org.lwjgl.opencl.CL12;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GL43C;\nimport org.lwjgl.opengl.GLCapabilities;\nimport org.lwjgl.opengl.GLUtil;\nimport org.lwjgl.system.Callback;\nimport org.lwjgl.system.Configuration;\n\n@PluginDescriptor(\n\tname \u003d \"GPU (legacy)\",\n\tconfigName \u003d \"GpuLegacy\",\n\tdescription \u003d \"Utilizes the GPU\",\n\tenabledByDefault \u003d false,\n\ttags \u003d {\"fog\", \"draw distance\"},\n\tloadInSafeMode \u003d false,\n\tconflicts \u003d \"GPU\"\n)\n@Slf4j\npublic class GpuPlugin extends Plugin implements DrawCallbacks\n{\n\t// This is the maximum number of triangles the compute shaders support\n\tstatic final int MAX_TRIANGLE \u003d 6144;\n\tstatic final int SMALL_TRIANGLE_COUNT \u003d 512;\n\tprivate static final int FLAG_SCENE_BUFFER \u003d Integer.MIN_VALUE;\n\tstatic final int MAX_DISTANCE \u003d 184;\n\tstatic final int MAX_FOG_DEPTH \u003d 100;\n\tstatic final int SCENE_OFFSET \u003d (Constants.EXTENDED_SCENE_SIZE - Constants.SCENE_SIZE) / 2; // offset for sxy -\u003e msxy\n\tprivate static final int GROUND_MIN_Y \u003d 350; // how far below the ground models extend\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientUI clientUI;\n\n\t@Inject\n\tprivate OpenCLManager openCLManager;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate GpuPluginConfig config;\n\n\t@Inject\n\tprivate TextureManager textureManager;\n\n\t@Inject\n\tprivate SceneUploader sceneUploader;\n\n\t@Inject\n\tprivate DrawManager drawManager;\n\n\t@Inject\n\tprivate PluginManager pluginManager;\n\n\tenum ComputeMode\n\t{\n\t\tNONE,\n\t\tOPENGL,\n\t\tOPENCL\n\t}\n\n\tprivate ComputeMode computeMode \u003d ComputeMode.NONE;\n\n\tprivate Canvas canvas;\n\tprivate AWTContext awtContext;\n\tprivate Callback debugCallback;\n\n\tprivate GLCapabilities glCapabilities;\n\n\tstatic final String LINUX_VERSION_HEADER \u003d\n\t\t\"#version 420\\n\" +\n\t\t\t\"#extension GL_ARB_compute_shader : require\\n\" +\n\t\t\t\"#extension GL_ARB_shader_storage_buffer_object : require\\n\" +\n\t\t\t\"#extension GL_ARB_explicit_attrib_location : require\\n\";\n\tstatic final String WINDOWS_VERSION_HEADER \u003d \"#version 430\\n\";\n\n\tstatic final Shader PROGRAM \u003d new Shader()\n\t\t.add(GL43C.GL_VERTEX_SHADER, \"vert.glsl\")\n\t\t.add(GL43C.GL_GEOMETRY_SHADER, \"geom.glsl\")\n\t\t.add(GL43C.GL_FRAGMENT_SHADER, \"frag.glsl\");\n\n\tstatic final Shader COMPUTE_PROGRAM \u003d new Shader()\n\t\t.add(GL43C.GL_COMPUTE_SHADER, \"comp.glsl\");\n\n\tstatic final Shader SMALL_COMPUTE_PROGRAM \u003d new Shader()\n\t\t.add(GL43C.GL_COMPUTE_SHADER, \"comp.glsl\");\n\n\tstatic final Shader UNORDERED_COMPUTE_PROGRAM \u003d new Shader()\n\t\t.add(GL43C.GL_COMPUTE_SHADER, \"comp_unordered.glsl\");\n\n\tstatic final Shader UI_PROGRAM \u003d new Shader()\n\t\t.add(GL43C.GL_VERTEX_SHADER, \"vertui.glsl\")\n\t\t.add(GL43C.GL_FRAGMENT_SHADER, \"fragui.glsl\");\n\n\tprivate int glProgram;\n\tprivate int glComputeProgram;\n\tprivate int glSmallComputeProgram;\n\tprivate int glUnorderedComputeProgram;\n\tprivate int glUiProgram;\n\n\tprivate int vaoCompute;\n\tprivate int vaoTemp;\n\n\tprivate int interfaceTexture;\n\tprivate int interfacePbo;\n\n\tprivate int vaoUiHandle;\n\tprivate int vboUiHandle;\n\n\tprivate int fboScene;\n\tprivate int rboColorBuffer;\n\n\tprivate final GLBuffer sceneVertexBuffer \u003d new GLBuffer(\"scene vertex buffer\");\n\tprivate final GLBuffer sceneUvBuffer \u003d new GLBuffer(\"scene tex buffer\");\n\tprivate final GLBuffer tmpVertexBuffer \u003d new GLBuffer(\"tmp vertex buffer\");\n\tprivate final GLBuffer tmpUvBuffer \u003d new GLBuffer(\"tmp tex buffer\");\n\tprivate final GLBuffer tmpModelBufferLarge \u003d new GLBuffer(\"model buffer large\");\n\tprivate final GLBuffer tmpModelBufferSmall \u003d new GLBuffer(\"model buffer small\");\n\tprivate final GLBuffer tmpModelBufferUnordered \u003d new GLBuffer(\"model buffer unordered\");\n\tprivate final GLBuffer tmpOutBuffer \u003d new GLBuffer(\"out vertex buffer\");\n\tprivate final GLBuffer tmpOutUvBuffer \u003d new GLBuffer(\"out tex buffer\");\n\n\tprivate int textureArrayId;\n\tprivate int tileHeightTex;\n\n\tprivate final GLBuffer uniformBuffer \u003d new GLBuffer(\"uniform buffer\");\n\n\tprivate GpuIntBuffer vertexBuffer;\n\tprivate GpuFloatBuffer uvBuffer;\n\n\tprivate GpuIntBuffer modelBufferUnordered;\n\tprivate GpuIntBuffer modelBufferSmall;\n\tprivate GpuIntBuffer modelBuffer;\n\n\tprivate int unorderedModels;\n\n\t/**\n\t * number of models in small buffer\n\t */\n\tprivate int smallModels;\n\n\t/**\n\t * number of models in large buffer\n\t */\n\tprivate int largeModels;\n\n\t/**\n\t * offset in the target buffer for model\n\t */\n\tprivate int targetBufferOffset;\n\n\t/**\n\t * offset into the temporary scene vertex buffer\n\t */\n\tprivate int tempOffset;\n\n\t/**\n\t * offset into the temporary scene uv buffer\n\t */\n\tprivate int tempUvOffset;\n\n\tprivate int lastCanvasWidth;\n\tprivate int lastCanvasHeight;\n\tprivate int lastStretchedCanvasWidth;\n\tprivate int lastStretchedCanvasHeight;\n\tprivate AntiAliasingMode lastAntiAliasingMode;\n\tprivate int lastAnisotropicFilteringLevel \u003d -1;\n\n\tprivate double cameraX, cameraY, cameraZ;\n\tprivate double cameraYaw, cameraPitch;\n\n\tprivate int viewportOffsetX;\n\tprivate int viewportOffsetY;\n\tprivate int viewportWidth;\n\tprivate int viewportHeight;\n\n\t// Uniforms\n\tprivate int uniColorBlindMode;\n\tprivate int uniUiColorBlindMode;\n\tprivate int uniUseFog;\n\tprivate int uniFogColor;\n\tprivate int uniFogDepth;\n\tprivate int uniDrawDistance;\n\tprivate int uniExpandedMapLoadingChunks;\n\tprivate int uniProjectionMatrix;\n\tprivate int uniBrightness;\n\tprivate int uniTex;\n\tprivate int uniTexSamplingMode;\n\tprivate int uniTexSourceDimensions;\n\tprivate int uniTexTargetDimensions;\n\tprivate int uniUiAlphaOverlay;\n\tprivate int uniTextures;\n\tprivate int uniTextureAnimations;\n\tprivate int uniBlockSmall;\n\tprivate int uniBlockLarge;\n\tprivate int uniBlockMain;\n\tprivate int uniSmoothBanding;\n\tprivate int uniTextureLightMode;\n\tprivate int uniTick;\n\n\tprivate boolean lwjglInitted \u003d false;\n\n\tprivate int sceneId;\n\tprivate int nextSceneId;\n\tprivate GpuIntBuffer nextSceneVertexBuffer;\n\tprivate GpuFloatBuffer nextSceneTexBuffer;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\tclientThread.invoke(() -\u003e\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tfboScene \u003d rboColorBuffer \u003d -1;\n\t\t\t\ttargetBufferOffset \u003d 0;\n\t\t\t\tunorderedModels \u003d smallModels \u003d largeModels \u003d 0;\n\n\t\t\t\tAWTContext.loadNatives();\n\n\t\t\t\tcanvas \u003d client.getCanvas();\n\n\t\t\t\tsynchronized (canvas.getTreeLock())\n\t\t\t\t{\n\t\t\t\t\tif (!canvas.isValid())\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tawtContext \u003d new AWTContext(canvas);\n\t\t\t\t\tawtContext.configurePixelFormat(0, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tawtContext.createGLContext();\n\n\t\t\t\tcanvas.setIgnoreRepaint(true);\n\n\t\t\t\tcomputeMode \u003d config.useComputeShaders()\n\t\t\t\t\t? (OSType.getOSType() \u003d\u003d OSType.MacOS ? ComputeMode.OPENCL : ComputeMode.OPENGL)\n\t\t\t\t\t: ComputeMode.NONE;\n\n\t\t\t\t// lwjgl defaults to lwjgl- + user.name, but this breaks if the username would cause an invalid path\n\t\t\t\t// to be created.\n\t\t\t\tConfiguration.SHARED_LIBRARY_EXTRACT_DIRECTORY.set(\"lwjgl-rl\");\n\n\t\t\t\tglCapabilities \u003d GL.createCapabilities();\n\n\t\t\t\tlog.info(\"Using device: {}\", GL43C.glGetString(GL43C.GL_RENDERER));\n\t\t\t\tlog.info(\"Using driver: {}\", GL43C.glGetString(GL43C.GL_VERSION));\n\n\t\t\t\tif (!glCapabilities.OpenGL31)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(\"OpenGL 3.1 is required but not available\");\n\t\t\t\t}\n\n\t\t\t\tif (!glCapabilities.OpenGL43 \u0026\u0026 computeMode \u003d\u003d ComputeMode.OPENGL)\n\t\t\t\t{\n\t\t\t\t\tlog.info(\"disabling compute shaders because OpenGL 4.3 is not available\");\n\t\t\t\t\tcomputeMode \u003d ComputeMode.NONE;\n\t\t\t\t}\n\n\t\t\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t\t\t{\n\t\t\t\t\tsceneUploader.initSortingBuffers();\n\t\t\t\t}\n\n\t\t\t\tlwjglInitted \u003d true;\n\n\t\t\t\tcheckGLErrors();\n\t\t\t\tif (log.isDebugEnabled() \u0026\u0026 glCapabilities.glDebugMessageControl !\u003d 0)\n\t\t\t\t{\n\t\t\t\t\tdebugCallback \u003d GLUtil.setupDebugMessageCallback();\n\t\t\t\t\tif (debugCallback !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\t//\tGLDebugEvent[ id 0x20071\n\t\t\t\t\t\t//\t\ttype Warning: generic\n\t\t\t\t\t\t//\t\tseverity Unknown (0x826b)\n\t\t\t\t\t\t//\t\tsource GL API\n\t\t\t\t\t\t//\t\tmsg Buffer detailed info: Buffer object 11 (bound to GL_ARRAY_BUFFER_ARB, and GL_SHADER_STORAGE_BUFFER (4), usage hint is GL_STREAM_DRAW) will use VIDEO memory as the source for buffer object operations.\n\t\t\t\t\t\tGL43C.glDebugMessageControl(GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_OTHER,\n\t\t\t\t\t\t\tGL43C.GL_DONT_CARE, 0x20071, false);\n\n\t\t\t\t\t\t//\tGLDebugMessageHandler: GLDebugEvent[ id 0x20052\n\t\t\t\t\t\t//\t\ttype Warning: implementation dependent performance\n\t\t\t\t\t\t//\t\tseverity Medium: Severe performance/deprecation/other warnings\n\t\t\t\t\t\t//\t\tsource GL API\n\t\t\t\t\t\t//\t\tmsg Pixel-path performance warning: Pixel transfer is synchronized with 3D rendering.\n\t\t\t\t\t\tGL43C.glDebugMessageControl(GL43C.GL_DEBUG_SOURCE_API, GL43C.GL_DEBUG_TYPE_PERFORMANCE,\n\t\t\t\t\t\t\tGL43C.GL_DONT_CARE, 0x20052, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvertexBuffer \u003d new GpuIntBuffer();\n\t\t\t\tuvBuffer \u003d new GpuFloatBuffer();\n\n\t\t\t\tmodelBufferUnordered \u003d new GpuIntBuffer();\n\t\t\t\tmodelBufferSmall \u003d new GpuIntBuffer();\n\t\t\t\tmodelBuffer \u003d new GpuIntBuffer();\n\n\t\t\t\tsetupSyncMode();\n\n\t\t\t\tinitBuffers();\n\t\t\t\tinitVao();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tinitProgram();\n\t\t\t\t}\n\t\t\t\tcatch (ShaderException ex)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t\t}\n\t\t\t\tinitInterfaceTexture();\n\t\t\t\tinitUniformBuffer();\n\n\t\t\t\tclient.setDrawCallbacks(this);\n\t\t\t\tclient.setGpuFlags(DrawCallbacks.GPU\n\t\t\t\t\t| (computeMode \u003d\u003d ComputeMode.NONE ? 0 : DrawCallbacks.HILLSKEW)\n\t\t\t\t\t| (config.removeVertexSnapping() ? DrawCallbacks.NO_VERTEX_SNAPPING : 0)\n\t\t\t\t);\n\t\t\t\tclient.setExpandedMapLoading(config.expandedMapLoadingChunks());\n\n\t\t\t\t// force rebuild of main buffer provider to enable alpha channel\n\t\t\t\tclient.resizeCanvas();\n\n\t\t\t\tlastCanvasWidth \u003d lastCanvasHeight \u003d -1;\n\t\t\t\tlastStretchedCanvasWidth \u003d lastStretchedCanvasHeight \u003d -1;\n\t\t\t\tlastAntiAliasingMode \u003d null;\n\n\t\t\t\ttextureArrayId \u003d -1;\n\n\t\t\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t\t\t{\n\t\t\t\t\tScene scene \u003d client.getScene();\n\t\t\t\t\tloadScene(scene);\n\t\t\t\t\tswapScene(scene);\n\t\t\t\t}\n\n\t\t\t\tcheckGLErrors();\n\t\t\t}\n\t\t\tcatch (Throwable e)\n\t\t\t{\n\t\t\t\tlog.error(\"Error starting GPU plugin\", e);\n\n\t\t\t\tSwingUtilities.invokeLater(() -\u003e\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tpluginManager.setPluginEnabled(this, false);\n\t\t\t\t\t\tpluginManager.stopPlugin(this);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (PluginInstantiationException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"error stopping plugin\", ex);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tshutDown();\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\tclientThread.invoke(() -\u003e\n\t\t{\n\t\t\tclient.setGpuFlags(0);\n\t\t\tclient.setDrawCallbacks(null);\n\t\t\tclient.setUnlockedFps(false);\n\t\t\tclient.setExpandedMapLoading(0);\n\n\t\t\tsceneUploader.releaseSortingBuffers();\n\n\t\t\tif (lwjglInitted)\n\t\t\t{\n\t\t\t\tif (textureArrayId !\u003d -1)\n\t\t\t\t{\n\t\t\t\t\ttextureManager.freeTextureArray(textureArrayId);\n\t\t\t\t\ttextureArrayId \u003d -1;\n\t\t\t\t}\n\n\t\t\t\tif (tileHeightTex !\u003d 0)\n\t\t\t\t{\n\t\t\t\t\tGL43C.glDeleteTextures(tileHeightTex);\n\t\t\t\t\ttileHeightTex \u003d 0;\n\t\t\t\t}\n\n\t\t\t\tdestroyGlBuffer(uniformBuffer);\n\n\t\t\t\tshutdownInterfaceTexture();\n\t\t\t\tshutdownProgram();\n\t\t\t\tshutdownVao();\n\t\t\t\tshutdownBuffers();\n\t\t\t\tshutdownFbo();\n\t\t\t}\n\n\t\t\t// this must shutdown after the clgl buffers are freed\n\t\t\topenCLManager.cleanup();\n\n\t\t\tif (awtContext !\u003d null)\n\t\t\t{\n\t\t\t\tawtContext.destroy();\n\t\t\t\tawtContext \u003d null;\n\t\t\t}\n\n\t\t\tif (debugCallback !\u003d null)\n\t\t\t{\n\t\t\t\tdebugCallback.free();\n\t\t\t\tdebugCallback \u003d null;\n\t\t\t}\n\n\t\t\tglCapabilities \u003d null;\n\n\t\t\tvertexBuffer \u003d null;\n\t\t\tuvBuffer \u003d null;\n\n\t\t\tmodelBufferSmall \u003d null;\n\t\t\tmodelBuffer \u003d null;\n\t\t\tmodelBufferUnordered \u003d null;\n\n\t\t\tlastAnisotropicFilteringLevel \u003d -1;\n\n\t\t\t// force main buffer provider rebuild to turn off alpha channel\n\t\t\tclient.resizeCanvas();\n\t\t});\n\t}\n\n\t@Provides\n\tGpuPluginConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(GpuPluginConfig.class);\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\t\tif (configChanged.getGroup().equals(GpuPluginConfig.GROUP))\n\t\t{\n\t\t\tif (configChanged.getKey().equals(\"unlockFps\")\n\t\t\t\t|| configChanged.getKey().equals(\"vsyncMode\")\n\t\t\t\t|| configChanged.getKey().equals(\"fpsTarget\"))\n\t\t\t{\n\t\t\t\tlog.debug(\"Rebuilding sync mode\");\n\t\t\t\tclientThread.invokeLater(this::setupSyncMode);\n\t\t\t}\n\t\t\telse if (configChanged.getKey().equals(\"expandedMapLoadingChunks\"))\n\t\t\t{\n\t\t\t\tclientThread.invokeLater(() -\u003e\n\t\t\t\t{\n\t\t\t\t\tclient.setExpandedMapLoading(config.expandedMapLoadingChunks());\n\t\t\t\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t\t\t\t{\n\t\t\t\t\t\tclient.setGameState(GameState.LOADING);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (configChanged.getKey().equals(\"removeVertexSnapping\"))\n\t\t\t{\n\t\t\t\tlog.debug(\"Toggle {}\", configChanged.getKey());\n\t\t\t\tclient.setGpuFlags(DrawCallbacks.GPU\n\t\t\t\t\t| (computeMode \u003d\u003d ComputeMode.NONE ? 0 : DrawCallbacks.HILLSKEW)\n\t\t\t\t\t| (config.removeVertexSnapping() ? DrawCallbacks.NO_VERTEX_SNAPPING : 0)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void setupSyncMode()\n\t{\n\t\tfinal boolean unlockFps \u003d config.unlockFps();\n\t\tclient.setUnlockedFps(unlockFps);\n\n\t\t// Without unlocked fps, the client manages sync on its 20ms timer\n\t\tGpuPluginConfig.SyncMode syncMode \u003d unlockFps\n\t\t\t? this.config.syncMode()\n\t\t\t: GpuPluginConfig.SyncMode.OFF;\n\n\t\tint swapInterval \u003d 0;\n\t\tswitch (syncMode)\n\t\t{\n\t\t\tcase ON:\n\t\t\t\tswapInterval \u003d 1;\n\t\t\t\tbreak;\n\t\t\tcase OFF:\n\t\t\t\tswapInterval \u003d 0;\n\t\t\t\tbreak;\n\t\t\tcase ADAPTIVE:\n\t\t\t\tswapInterval \u003d -1;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tint actualSwapInterval \u003d awtContext.setSwapInterval(swapInterval);\n\t\tif (actualSwapInterval !\u003d swapInterval)\n\t\t{\n\t\t\tlog.info(\"unsupported swap interval {}, got {}\", swapInterval, actualSwapInterval);\n\t\t}\n\n\t\tclient.setUnlockedFpsTarget(actualSwapInterval \u003d\u003d 0 ? config.fpsTarget() : 0);\n\t\tcheckGLErrors();\n\t}\n\n\tprivate Template createTemplate(int threadCount, int facesPerThread)\n\t{\n\t\tString versionHeader \u003d OSType.getOSType() \u003d\u003d OSType.Linux ? LINUX_VERSION_HEADER : WINDOWS_VERSION_HEADER;\n\t\tTemplate template \u003d new Template();\n\t\ttemplate.add(key -\u003e\n\t\t{\n\t\t\tif (\"version_header\".equals(key))\n\t\t\t{\n\t\t\t\treturn versionHeader;\n\t\t\t}\n\t\t\tif (\"thread_config\".equals(key))\n\t\t\t{\n\t\t\t\treturn \"#define THREAD_COUNT \" + threadCount + \"\\n\" +\n\t\t\t\t\t\"#define FACES_PER_THREAD \" + facesPerThread + \"\\n\";\n\t\t\t}\n\t\t\tif (\"texture_config\".equals(key))\n\t\t\t{\n\t\t\t\treturn \"#define TEXTURE_COUNT \" + TextureManager.TEXTURE_COUNT + \"\\n\";\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t\ttemplate.addInclude(GpuPlugin.class);\n\t\treturn template;\n\t}\n\n\tprivate void initProgram() throws ShaderException\n\t{\n\t\tTemplate template \u003d createTemplate(-1, -1);\n\t\tglProgram \u003d PROGRAM.compile(template);\n\t\tglUiProgram \u003d UI_PROGRAM.compile(template);\n\n\t\tif (computeMode \u003d\u003d ComputeMode.OPENGL)\n\t\t{\n\t\t\tglComputeProgram \u003d COMPUTE_PROGRAM.compile(createTemplate(1024, 6));\n\t\t\tglSmallComputeProgram \u003d SMALL_COMPUTE_PROGRAM.compile(createTemplate(512, 1));\n\t\t\tglUnorderedComputeProgram \u003d UNORDERED_COMPUTE_PROGRAM.compile(template);\n\t\t}\n\t\telse if (computeMode \u003d\u003d ComputeMode.OPENCL)\n\t\t{\n\t\t\topenCLManager.init(awtContext);\n\t\t}\n\n\t\tinitUniforms();\n\t}\n\n\tprivate void initUniforms()\n\t{\n\t\tuniProjectionMatrix \u003d GL43C.glGetUniformLocation(glProgram, \"projectionMatrix\");\n\t\tuniBrightness \u003d GL43C.glGetUniformLocation(glProgram, \"brightness\");\n\t\tuniSmoothBanding \u003d GL43C.glGetUniformLocation(glProgram, \"smoothBanding\");\n\t\tuniUseFog \u003d GL43C.glGetUniformLocation(glProgram, \"useFog\");\n\t\tuniFogColor \u003d GL43C.glGetUniformLocation(glProgram, \"fogColor\");\n\t\tuniFogDepth \u003d GL43C.glGetUniformLocation(glProgram, \"fogDepth\");\n\t\tuniDrawDistance \u003d GL43C.glGetUniformLocation(glProgram, \"drawDistance\");\n\t\tuniExpandedMapLoadingChunks \u003d GL43C.glGetUniformLocation(glProgram, \"expandedMapLoadingChunks\");\n\t\tuniColorBlindMode \u003d GL43C.glGetUniformLocation(glProgram, \"colorBlindMode\");\n\t\tuniTextureLightMode \u003d GL43C.glGetUniformLocation(glProgram, \"textureLightMode\");\n\t\tuniTick \u003d GL43C.glGetUniformLocation(glProgram, \"tick\");\n\t\tuniBlockMain \u003d GL43C.glGetUniformBlockIndex(glProgram, \"uniforms\");\n\t\tuniTextures \u003d GL43C.glGetUniformLocation(glProgram, \"textures\");\n\t\tuniTextureAnimations \u003d GL43C.glGetUniformLocation(glProgram, \"textureAnimations\");\n\n\t\tuniTex \u003d GL43C.glGetUniformLocation(glUiProgram, \"tex\");\n\t\tuniTexSamplingMode \u003d GL43C.glGetUniformLocation(glUiProgram, \"samplingMode\");\n\t\tuniTexTargetDimensions \u003d GL43C.glGetUniformLocation(glUiProgram, \"targetDimensions\");\n\t\tuniTexSourceDimensions \u003d GL43C.glGetUniformLocation(glUiProgram, \"sourceDimensions\");\n\t\tuniUiColorBlindMode \u003d GL43C.glGetUniformLocation(glUiProgram, \"colorBlindMode\");\n\t\tuniUiAlphaOverlay \u003d GL43C.glGetUniformLocation(glUiProgram, \"alphaOverlay\");\n\n\t\tif (computeMode \u003d\u003d ComputeMode.OPENGL)\n\t\t{\n\t\t\tuniBlockSmall \u003d GL43C.glGetUniformBlockIndex(glSmallComputeProgram, \"uniforms\");\n\t\t\tuniBlockLarge \u003d GL43C.glGetUniformBlockIndex(glComputeProgram, \"uniforms\");\n\t\t}\n\t}\n\n\tprivate void shutdownProgram()\n\t{\n\t\tGL43C.glDeleteProgram(glProgram);\n\t\tglProgram \u003d -1;\n\n\t\tGL43C.glDeleteProgram(glComputeProgram);\n\t\tglComputeProgram \u003d -1;\n\n\t\tGL43C.glDeleteProgram(glSmallComputeProgram);\n\t\tglSmallComputeProgram \u003d -1;\n\n\t\tGL43C.glDeleteProgram(glUnorderedComputeProgram);\n\t\tglUnorderedComputeProgram \u003d -1;\n\n\t\tGL43C.glDeleteProgram(glUiProgram);\n\t\tglUiProgram \u003d -1;\n\t}\n\n\tprivate void initVao()\n\t{\n\t\t// Create compute VAO\n\t\tvaoCompute \u003d GL43C.glGenVertexArrays();\n\t\tGL43C.glBindVertexArray(vaoCompute);\n\n\t\tGL43C.glEnableVertexAttribArray(0);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpOutBuffer.glBufferId);\n\t\tGL43C.glVertexAttribPointer(0, 3, GL43C.GL_FLOAT, false, 16, 0);\n\n\t\tGL43C.glEnableVertexAttribArray(1);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpOutBuffer.glBufferId);\n\t\tGL43C.glVertexAttribIPointer(1, 1, GL43C.GL_INT, 16, 12);\n\n\t\tGL43C.glEnableVertexAttribArray(2);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpOutUvBuffer.glBufferId);\n\t\tGL43C.glVertexAttribPointer(2, 4, GL43C.GL_FLOAT, false, 0, 0);\n\n\t\t// Create temp VAO\n\t\tvaoTemp \u003d GL43C.glGenVertexArrays();\n\t\tGL43C.glBindVertexArray(vaoTemp);\n\n\t\tGL43C.glEnableVertexAttribArray(0);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpVertexBuffer.glBufferId);\n\t\tGL43C.glVertexAttribPointer(0, 3, GL43C.GL_FLOAT, false, 16, 0);\n\n\t\tGL43C.glEnableVertexAttribArray(1);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpVertexBuffer.glBufferId);\n\t\tGL43C.glVertexAttribIPointer(1, 1, GL43C.GL_INT, 16, 12);\n\n\t\tGL43C.glEnableVertexAttribArray(2);\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, tmpUvBuffer.glBufferId);\n\t\tGL43C.glVertexAttribPointer(2, 4, GL43C.GL_FLOAT, false, 0, 0);\n\n\t\t// Create UI VAO\n\t\tvaoUiHandle \u003d GL43C.glGenVertexArrays();\n\t\t// Create UI buffer\n\t\tvboUiHandle \u003d GL43C.glGenBuffers();\n\t\tGL43C.glBindVertexArray(vaoUiHandle);\n\n\t\tFloatBuffer vboUiBuf \u003d GpuFloatBuffer.allocateDirect(5 * 4);\n\t\tvboUiBuf.put(new float[]{\n\t\t\t// positions     // texture coords\n\t\t\t1f, 1f, 0.0f, 1.0f, 0f, // top right\n\t\t\t1f, -1f, 0.0f, 1.0f, 1f, // bottom right\n\t\t\t-1f, -1f, 0.0f, 0.0f, 1f, // bottom left\n\t\t\t-1f, 1f, 0.0f, 0.0f, 0f  // top left\n\t\t});\n\t\tvboUiBuf.rewind();\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, vboUiHandle);\n\t\tGL43C.glBufferData(GL43C.GL_ARRAY_BUFFER, vboUiBuf, GL43C.GL_STATIC_DRAW);\n\n\t\t// position attribute\n\t\tGL43C.glVertexAttribPointer(0, 3, GL43C.GL_FLOAT, false, 5 * Float.BYTES, 0);\n\t\tGL43C.glEnableVertexAttribArray(0);\n\n\t\t// texture coord attribute\n\t\tGL43C.glVertexAttribPointer(1, 2, GL43C.GL_FLOAT, false, 5 * Float.BYTES, 3 * Float.BYTES);\n\t\tGL43C.glEnableVertexAttribArray(1);\n\n\t\t// unbind VBO\n\t\tGL43C.glBindBuffer(GL43C.GL_ARRAY_BUFFER, 0);\n\t}\n\n\tprivate void shutdownVao()\n\t{\n\t\tGL43C.glDeleteVertexArrays(vaoCompute);\n\t\tvaoCompute \u003d -1;\n\n\t\tGL43C.glDeleteVertexArrays(vaoTemp);\n\t\tvaoTemp \u003d -1;\n\n\t\tGL43C.glDeleteBuffers(vboUiHandle);\n\t\tvboUiHandle \u003d -1;\n\n\t\tGL43C.glDeleteVertexArrays(vaoUiHandle);\n\t\tvaoUiHandle \u003d -1;\n\t}\n\n\tprivate void initBuffers()\n\t{\n\t\tinitGlBuffer(sceneVertexBuffer);\n\t\tinitGlBuffer(sceneUvBuffer);\n\t\tinitGlBuffer(tmpVertexBuffer);\n\t\tinitGlBuffer(tmpUvBuffer);\n\t\tinitGlBuffer(tmpModelBufferLarge);\n\t\tinitGlBuffer(tmpModelBufferSmall);\n\t\tinitGlBuffer(tmpModelBufferUnordered);\n\t\tinitGlBuffer(tmpOutBuffer);\n\t\tinitGlBuffer(tmpOutUvBuffer);\n\t}\n\n\tprivate void initGlBuffer(GLBuffer glBuffer)\n\t{\n\t\tglBuffer.glBufferId \u003d GL43C.glGenBuffers();\n\t}\n\n\tprivate void shutdownBuffers()\n\t{\n\t\tdestroyGlBuffer(sceneVertexBuffer);\n\t\tdestroyGlBuffer(sceneUvBuffer);\n\n\t\tdestroyGlBuffer(tmpVertexBuffer);\n\t\tdestroyGlBuffer(tmpUvBuffer);\n\t\tdestroyGlBuffer(tmpModelBufferLarge);\n\t\tdestroyGlBuffer(tmpModelBufferSmall);\n\t\tdestroyGlBuffer(tmpModelBufferUnordered);\n\t\tdestroyGlBuffer(tmpOutBuffer);\n\t\tdestroyGlBuffer(tmpOutUvBuffer);\n\t}\n\n\tprivate void destroyGlBuffer(GLBuffer glBuffer)\n\t{\n\t\tif (glBuffer.glBufferId !\u003d -1)\n\t\t{\n\t\t\tGL43C.glDeleteBuffers(glBuffer.glBufferId);\n\t\t\tglBuffer.glBufferId \u003d -1;\n\t\t}\n\t\tglBuffer.size \u003d -1;\n\n\t\tif (glBuffer.clBuffer !\u003d -1)\n\t\t{\n\t\t\tCL12.clReleaseMemObject(glBuffer.clBuffer);\n\t\t\tglBuffer.clBuffer \u003d -1;\n\t\t}\n\t}\n\n\tprivate void initInterfaceTexture()\n\t{\n\t\tinterfacePbo \u003d GL43C.glGenBuffers();\n\n\t\tinterfaceTexture \u003d GL43C.glGenTextures();\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, interfaceTexture);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_WRAP_S, GL43C.GL_CLAMP_TO_EDGE);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_WRAP_T, GL43C.GL_CLAMP_TO_EDGE);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_MIN_FILTER, GL43C.GL_LINEAR);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_MAG_FILTER, GL43C.GL_LINEAR);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, 0);\n\t}\n\n\tprivate void shutdownInterfaceTexture()\n\t{\n\t\tGL43C.glDeleteBuffers(interfacePbo);\n\t\tGL43C.glDeleteTextures(interfaceTexture);\n\t\tinterfaceTexture \u003d -1;\n\t}\n\n\tprivate void initUniformBuffer()\n\t{\n\t\tinitGlBuffer(uniformBuffer);\n\n\t\tupdateBuffer(uniformBuffer, GL43C.GL_UNIFORM_BUFFER, 8 * Integer.BYTES, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\t\tGL43C.glBindBuffer(GL43C.GL_UNIFORM_BUFFER, 0);\n\t}\n\n\tprivate void initFbo(int width, int height, int aaSamples)\n\t{\n\t\tfinal GraphicsConfiguration graphicsConfiguration \u003d clientUI.getGraphicsConfiguration();\n\t\tfinal AffineTransform transform \u003d graphicsConfiguration.getDefaultTransform();\n\n\t\twidth \u003d getScaledValue(transform.getScaleX(), width);\n\t\theight \u003d getScaledValue(transform.getScaleY(), height);\n\n\t\tif (aaSamples \u003e 0)\n\t\t{\n\t\t\tGL43C.glEnable(GL43C.GL_MULTISAMPLE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tGL43C.glDisable(GL43C.GL_MULTISAMPLE);\n\t\t}\n\n\t\t// Create and bind the FBO\n\t\tfboScene \u003d GL43C.glGenFramebuffers();\n\t\tGL43C.glBindFramebuffer(GL43C.GL_FRAMEBUFFER, fboScene);\n\n\t\t// Create color render buffer\n\t\trboColorBuffer \u003d GL43C.glGenRenderbuffers();\n\t\tGL43C.glBindRenderbuffer(GL43C.GL_RENDERBUFFER, rboColorBuffer);\n\t\tGL43C.glRenderbufferStorageMultisample(GL43C.GL_RENDERBUFFER, aaSamples, GL43C.GL_RGBA, width, height);\n\t\tGL43C.glFramebufferRenderbuffer(GL43C.GL_FRAMEBUFFER, GL43C.GL_COLOR_ATTACHMENT0, GL43C.GL_RENDERBUFFER, rboColorBuffer);\n\n\t\tint status \u003d GL43C.glCheckFramebufferStatus(GL43C.GL_FRAMEBUFFER);\n\t\tif (status !\u003d GL43C.GL_FRAMEBUFFER_COMPLETE)\n\t\t{\n\t\t\tthrow new RuntimeException(\"FBO is incomplete. status: \" + status);\n\t\t}\n\n\t\t// Reset\n\t\tGL43C.glBindFramebuffer(GL43C.GL_FRAMEBUFFER, awtContext.getFramebuffer(false));\n\t\tGL43C.glBindRenderbuffer(GL43C.GL_RENDERBUFFER, 0);\n\t}\n\n\tprivate void shutdownFbo()\n\t{\n\t\tif (fboScene !\u003d -1)\n\t\t{\n\t\t\tGL43C.glDeleteFramebuffers(fboScene);\n\t\t\tfboScene \u003d -1;\n\t\t}\n\n\t\tif (rboColorBuffer !\u003d -1)\n\t\t{\n\t\t\tGL43C.glDeleteRenderbuffers(rboColorBuffer);\n\t\t\trboColorBuffer \u003d -1;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void drawScene(double cameraX, double cameraY, double cameraZ, double cameraPitch, double cameraYaw, int plane)\n\t{\n\t\tthis.cameraX \u003d cameraX;\n\t\tthis.cameraY \u003d cameraY;\n\t\tthis.cameraZ \u003d cameraZ;\n\t\tthis.cameraPitch \u003d cameraPitch;\n\t\tthis.cameraYaw \u003d cameraYaw;\n\t\tviewportOffsetX \u003d client.getViewportXOffset();\n\t\tviewportOffsetY \u003d client.getViewportYOffset();\n\t\tviewportWidth \u003d client.getViewportWidth();\n\t\tviewportHeight \u003d client.getViewportHeight();\n\n\t\tfinal Scene scene \u003d client.getScene();\n\t\tscene.setDrawDistance(getDrawDistance());\n\n\t\t// Only reset the target buffer offset right before drawing the scene. That way if there are frames\n\t\t// after this that don\u0027t involve a scene draw, like during LOADING/HOPPING/CONNECTION_LOST, we can\n\t\t// still redraw the previous frame\u0027s scene to emulate the client behavior of not painting over the\n\t\t// viewport buffer.\n\t\ttargetBufferOffset \u003d 0;\n\n\t\t// UBO.\n\t\t// We can reuse the vertex buffer since it isn\u0027t used yet.\n\t\tvertexBuffer.clear();\n\t\tvertexBuffer.ensureCapacity(32);\n\t\tIntBuffer uniformBuf \u003d vertexBuffer.getBuffer();\n\t\tuniformBuf\n\t\t\t.put(Float.floatToIntBits((float) cameraYaw))\n\t\t\t.put(Float.floatToIntBits((float) cameraPitch))\n\t\t\t.put(client.getCenterX())\n\t\t\t.put(client.getCenterY())\n\t\t\t.put(client.getScale())\n\t\t\t.put(Float.floatToIntBits((float) cameraX))\n\t\t\t.put(Float.floatToIntBits((float) cameraY))\n\t\t\t.put(Float.floatToIntBits((float) cameraZ));\n\t\tuniformBuf.flip();\n\n\t\tupdateBuffer(uniformBuffer, GL43C.GL_UNIFORM_BUFFER, uniformBuf, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\t\tGL43C.glBindBuffer(GL43C.GL_UNIFORM_BUFFER, 0);\n\n\t\tGL43C.glBindBufferBase(GL43C.GL_UNIFORM_BUFFER, 0, uniformBuffer.glBufferId);\n\t\tuniformBuf.clear();\n\n\t\tcheckGLErrors();\n\t}\n\n\t@Override\n\tpublic void postDrawScene()\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\t// Upload buffers\n\t\t\tvertexBuffer.flip();\n\t\t\tuvBuffer.flip();\n\n\t\t\tIntBuffer vertexBuffer \u003d this.vertexBuffer.getBuffer();\n\t\t\tFloatBuffer uvBuffer \u003d this.uvBuffer.getBuffer();\n\n\t\t\tupdateBuffer(tmpVertexBuffer, GL43C.GL_ARRAY_BUFFER, vertexBuffer, GL43C.GL_DYNAMIC_DRAW, 0L);\n\t\t\tupdateBuffer(tmpUvBuffer, GL43C.GL_ARRAY_BUFFER, uvBuffer, GL43C.GL_DYNAMIC_DRAW, 0L);\n\n\t\t\tcheckGLErrors();\n\t\t\treturn;\n\t\t}\n\n\t\t// Upload buffers\n\t\tvertexBuffer.flip();\n\t\tuvBuffer.flip();\n\t\tmodelBuffer.flip();\n\t\tmodelBufferSmall.flip();\n\t\tmodelBufferUnordered.flip();\n\n\t\tIntBuffer vertexBuffer \u003d this.vertexBuffer.getBuffer();\n\t\tFloatBuffer uvBuffer \u003d this.uvBuffer.getBuffer();\n\t\tIntBuffer modelBuffer \u003d this.modelBuffer.getBuffer();\n\t\tIntBuffer modelBufferSmall \u003d this.modelBufferSmall.getBuffer();\n\t\tIntBuffer modelBufferUnordered \u003d this.modelBufferUnordered.getBuffer();\n\n\t\t// temp buffers\n\t\tupdateBuffer(tmpVertexBuffer, GL43C.GL_ARRAY_BUFFER, vertexBuffer, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\t\tupdateBuffer(tmpUvBuffer, GL43C.GL_ARRAY_BUFFER, uvBuffer, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\n\t\t// model buffers\n\t\tupdateBuffer(tmpModelBufferLarge, GL43C.GL_ARRAY_BUFFER, modelBuffer, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\t\tupdateBuffer(tmpModelBufferSmall, GL43C.GL_ARRAY_BUFFER, modelBufferSmall, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\t\tupdateBuffer(tmpModelBufferUnordered, GL43C.GL_ARRAY_BUFFER, modelBufferUnordered, GL43C.GL_DYNAMIC_DRAW, CL12.CL_MEM_READ_ONLY);\n\n\t\t// Output buffers\n\t\tupdateBuffer(tmpOutBuffer,\n\t\t\tGL43C.GL_ARRAY_BUFFER,\n\t\t\ttargetBufferOffset * 16, // each element is an ivec4, which is 16 bytes\n\t\t\tGL43C.GL_STREAM_DRAW,\n\t\t\tCL12.CL_MEM_WRITE_ONLY);\n\t\tupdateBuffer(tmpOutUvBuffer,\n\t\t\tGL43C.GL_ARRAY_BUFFER,\n\t\t\ttargetBufferOffset * 16, // each element is a vec4, which is 16 bytes\n\t\t\tGL43C.GL_STREAM_DRAW,\n\t\t\tCL12.CL_MEM_WRITE_ONLY);\n\n\t\tif (computeMode \u003d\u003d ComputeMode.OPENCL)\n\t\t{\n\t\t\t// The docs for clEnqueueAcquireGLObjects say all pending GL operations must be completed before calling\n\t\t\t// clEnqueueAcquireGLObjects, and recommends calling glFinish() as the only portable way to do that.\n\t\t\t// However no issues have been observed from not calling it, and so will leave disabled for now.\n\t\t\t// GL43C.glFinish();\n\n\t\t\topenCLManager.compute(\n\t\t\t\tunorderedModels, smallModels, largeModels,\n\t\t\t\tsceneVertexBuffer, sceneUvBuffer,\n\t\t\t\ttmpVertexBuffer, tmpUvBuffer,\n\t\t\t\ttmpModelBufferUnordered, tmpModelBufferSmall, tmpModelBufferLarge,\n\t\t\t\ttmpOutBuffer, tmpOutUvBuffer,\n\t\t\t\tuniformBuffer);\n\n\t\t\tcheckGLErrors();\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Compute is split into three separate programs: \u0027unordered\u0027, \u0027small\u0027, and \u0027large\u0027\n\t\t * to save on GPU resources. Small will sort \u003c\u003d 512 faces, large will do \u003c\u003d 6144.\n\t\t */\n\n\t\t// Bind UBO to compute programs\n\t\tGL43C.glUniformBlockBinding(glSmallComputeProgram, uniBlockSmall, 0);\n\t\tGL43C.glUniformBlockBinding(glComputeProgram, uniBlockLarge, 0);\n\n\t\t// unordered\n\t\tGL43C.glUseProgram(glUnorderedComputeProgram);\n\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, tmpModelBufferUnordered.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 1, sceneVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 2, tmpVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 3, tmpOutBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 4, tmpOutUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 5, sceneUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 6, tmpUvBuffer.glBufferId);\n\n\t\tGL43C.glDispatchCompute(unorderedModels, 1, 1);\n\n\t\t// small\n\t\tGL43C.glUseProgram(glSmallComputeProgram);\n\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, tmpModelBufferSmall.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 1, sceneVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 2, tmpVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 3, tmpOutBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 4, tmpOutUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 5, sceneUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 6, tmpUvBuffer.glBufferId);\n\n\t\tGL43C.glDispatchCompute(smallModels, 1, 1);\n\n\t\t// large\n\t\tGL43C.glUseProgram(glComputeProgram);\n\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 0, tmpModelBufferLarge.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 1, sceneVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 2, tmpVertexBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 3, tmpOutBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 4, tmpOutUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 5, sceneUvBuffer.glBufferId);\n\t\tGL43C.glBindBufferBase(GL43C.GL_SHADER_STORAGE_BUFFER, 6, tmpUvBuffer.glBufferId);\n\n\t\tGL43C.glDispatchCompute(largeModels, 1, 1);\n\n\t\tcheckGLErrors();\n\t}\n\n\t@Override\n\tpublic void drawScenePaint(Scene scene, SceneTilePaint paint, int plane, int tileX, int tileY)\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\ttargetBufferOffset +\u003d sceneUploader.upload(scene, paint,\n\t\t\t\tplane, tileX, tileY,\n\t\t\t\tvertexBuffer, uvBuffer,\n\t\t\t\ttileX \u003c\u003c Perspective.LOCAL_COORD_BITS,\n\t\t\t\ttileY \u003c\u003c Perspective.LOCAL_COORD_BITS,\n\t\t\t\ttrue\n\t\t\t);\n\t\t}\n\t\telse if (paint.getBufferLen() \u003e 0)\n\t\t{\n\t\t\tfinal int localX \u003d tileX \u003c\u003c Perspective.LOCAL_COORD_BITS;\n\t\t\tfinal int localY \u003d 0;\n\t\t\tfinal int localZ \u003d tileY \u003c\u003c Perspective.LOCAL_COORD_BITS;\n\n\t\t\tGpuIntBuffer b \u003d modelBufferUnordered;\n\t\t\t++unorderedModels;\n\n\t\t\tb.ensureCapacity(8);\n\t\t\tIntBuffer buffer \u003d b.getBuffer();\n\t\t\tbuffer.put(paint.getBufferOffset());\n\t\t\tbuffer.put(paint.getUvBufferOffset());\n\t\t\tbuffer.put(2);\n\t\t\tbuffer.put(targetBufferOffset);\n\t\t\tbuffer.put(FLAG_SCENE_BUFFER);\n\t\t\tbuffer.put(localX).put(localY).put(localZ);\n\n\t\t\ttargetBufferOffset +\u003d 2 * 3;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void drawSceneTileModel(Scene scene, SceneTileModel model, int tileX, int tileY)\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\ttargetBufferOffset +\u003d sceneUploader.upload(model,\n\t\t\t\t0, 0,\n\t\t\t\tvertexBuffer, uvBuffer,\n\t\t\t\ttrue);\n\t\t}\n\t\telse if (model.getBufferLen() \u003e 0)\n\t\t{\n\t\t\tfinal int localX \u003d tileX \u003c\u003c Perspective.LOCAL_COORD_BITS;\n\t\t\tfinal int localY \u003d 0;\n\t\t\tfinal int localZ \u003d tileY \u003c\u003c Perspective.LOCAL_COORD_BITS;\n\n\t\t\tGpuIntBuffer b \u003d modelBufferUnordered;\n\t\t\t++unorderedModels;\n\n\t\t\tb.ensureCapacity(8);\n\t\t\tIntBuffer buffer \u003d b.getBuffer();\n\t\t\tbuffer.put(model.getBufferOffset());\n\t\t\tbuffer.put(model.getUvBufferOffset());\n\t\t\tbuffer.put(model.getBufferLen() / 3);\n\t\t\tbuffer.put(targetBufferOffset);\n\t\t\tbuffer.put(FLAG_SCENE_BUFFER);\n\t\t\tbuffer.put(localX).put(localY).put(localZ);\n\n\t\t\ttargetBufferOffset +\u003d model.getBufferLen();\n\t\t}\n\t}\n\n\tprivate void prepareInterfaceTexture(int canvasWidth, int canvasHeight)\n\t{\n\t\tif (canvasWidth !\u003d lastCanvasWidth || canvasHeight !\u003d lastCanvasHeight)\n\t\t{\n\t\t\tlastCanvasWidth \u003d canvasWidth;\n\t\t\tlastCanvasHeight \u003d canvasHeight;\n\n\t\t\tGL43C.glBindBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER, interfacePbo);\n\t\t\tGL43C.glBufferData(GL43C.GL_PIXEL_UNPACK_BUFFER, canvasWidth * canvasHeight * 4L, GL43C.GL_STREAM_DRAW);\n\t\t\tGL43C.glBindBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER, 0);\n\n\t\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, interfaceTexture);\n\t\t\tGL43C.glTexImage2D(GL43C.GL_TEXTURE_2D, 0, GL43C.GL_RGBA, canvasWidth, canvasHeight, 0, GL43C.GL_BGRA, GL43C.GL_UNSIGNED_BYTE, 0);\n\t\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, 0);\n\t\t}\n\n\t\tfinal BufferProvider bufferProvider \u003d client.getBufferProvider();\n\t\tfinal int[] pixels \u003d bufferProvider.getPixels();\n\t\tfinal int width \u003d bufferProvider.getWidth();\n\t\tfinal int height \u003d bufferProvider.getHeight();\n\n\t\tGL43C.glBindBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER, interfacePbo);\n\t\tByteBuffer interfaceBuf \u003d GL43C.glMapBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER, GL43C.GL_WRITE_ONLY);\n\t\tif (interfaceBuf !\u003d null)\n\t\t{\n\t\t\tinterfaceBuf\n\t\t\t\t.asIntBuffer()\n\t\t\t\t.put(pixels, 0, width * height);\n\t\t\tGL43C.glUnmapBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER);\n\t\t}\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, interfaceTexture);\n\t\tGL43C.glTexSubImage2D(GL43C.GL_TEXTURE_2D, 0, 0, 0, width, height, GL43C.GL_BGRA, GL43C.GL_UNSIGNED_INT_8_8_8_8_REV, 0);\n\t\tGL43C.glBindBuffer(GL43C.GL_PIXEL_UNPACK_BUFFER, 0);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, 0);\n\t}\n\n\t@Override\n\tpublic void draw(int overlayColor)\n\t{\n\t\tfinal GameState gameState \u003d client.getGameState();\n\t\tif (gameState \u003d\u003d GameState.STARTING)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int canvasHeight \u003d client.getCanvasHeight();\n\t\tfinal int canvasWidth \u003d client.getCanvasWidth();\n\n\t\tprepareInterfaceTexture(canvasWidth, canvasHeight);\n\n\t\t// Setup FBO and anti-aliasing\n\t\t{\n\t\t\tfinal AntiAliasingMode antiAliasingMode \u003d config.antiAliasingMode();\n\t\t\tfinal Dimension stretchedDimensions \u003d client.getStretchedDimensions();\n\n\t\t\tfinal int stretchedCanvasWidth \u003d client.isStretchedEnabled() ? stretchedDimensions.width : canvasWidth;\n\t\t\tfinal int stretchedCanvasHeight \u003d client.isStretchedEnabled() ? stretchedDimensions.height : canvasHeight;\n\n\t\t\t// Re-create fbo\n\t\t\tif (lastStretchedCanvasWidth !\u003d stretchedCanvasWidth\n\t\t\t\t|| lastStretchedCanvasHeight !\u003d stretchedCanvasHeight\n\t\t\t\t|| lastAntiAliasingMode !\u003d antiAliasingMode)\n\t\t\t{\n\t\t\t\tshutdownFbo();\n\n\t\t\t\t// Bind default FBO to check whether anti-aliasing is forced\n\t\t\t\tGL43C.glBindFramebuffer(GL43C.GL_FRAMEBUFFER, awtContext.getFramebuffer(false));\n\t\t\t\tfinal int forcedAASamples \u003d GL43C.glGetInteger(GL43C.GL_SAMPLES);\n\t\t\t\tfinal int maxSamples \u003d GL43C.glGetInteger(GL43C.GL_MAX_SAMPLES);\n\t\t\t\tfinal int samples \u003d forcedAASamples !\u003d 0 ? forcedAASamples :\n\t\t\t\t\tMath.min(antiAliasingMode.getSamples(), maxSamples);\n\n\t\t\t\tlog.debug(\"AA samples: {}, max samples: {}, forced samples: {}\", samples, maxSamples, forcedAASamples);\n\n\t\t\t\tinitFbo(stretchedCanvasWidth, stretchedCanvasHeight, samples);\n\n\t\t\t\tlastStretchedCanvasWidth \u003d stretchedCanvasWidth;\n\t\t\t\tlastStretchedCanvasHeight \u003d stretchedCanvasHeight;\n\t\t\t\tlastAntiAliasingMode \u003d antiAliasingMode;\n\t\t\t}\n\n\t\t\tGL43C.glBindFramebuffer(GL43C.GL_DRAW_FRAMEBUFFER, fboScene);\n\t\t}\n\n\t\t// Clear scene\n\t\tint sky \u003d client.getSkyboxColor();\n\t\tGL43C.glClearColor((sky \u003e\u003e 16 \u0026 0xFF) / 255f, (sky \u003e\u003e 8 \u0026 0xFF) / 255f, (sky \u0026 0xFF) / 255f, 1f);\n\t\tGL43C.glClear(GL43C.GL_COLOR_BUFFER_BIT);\n\n\t\t// Draw 3d scene\n\t\tif (gameState.getState() \u003e\u003d GameState.LOADING.getState())\n\t\t{\n\t\t\tfinal TextureProvider textureProvider \u003d client.getTextureProvider();\n\t\t\tif (textureArrayId \u003d\u003d -1)\n\t\t\t{\n\t\t\t\t// lazy init textures as they may not be loaded at plugin start.\n\t\t\t\t// this will return -1 and retry if not all textures are loaded yet, too.\n\t\t\t\ttextureArrayId \u003d textureManager.initTextureArray(textureProvider);\n\t\t\t\tif (textureArrayId \u003e -1)\n\t\t\t\t{\n\t\t\t\t\t// if texture upload is successful, compute and set texture animations\n\t\t\t\t\tfloat[] texAnims \u003d textureManager.computeTextureAnimations(textureProvider);\n\t\t\t\t\tGL43C.glUseProgram(glProgram);\n\t\t\t\t\tGL43C.glUniform2fv(uniTextureAnimations, texAnims);\n\t\t\t\t\tGL43C.glUseProgram(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint renderWidthOff \u003d viewportOffsetX;\n\t\t\tint renderHeightOff \u003d viewportOffsetY;\n\t\t\tint renderCanvasHeight \u003d canvasHeight;\n\t\t\tint renderViewportHeight \u003d viewportHeight;\n\t\t\tint renderViewportWidth \u003d viewportWidth;\n\n\t\t\t// Setup anisotropic filtering\n\t\t\tfinal int anisotropicFilteringLevel \u003d config.anisotropicFilteringLevel();\n\n\t\t\tif (textureArrayId !\u003d -1 \u0026\u0026 lastAnisotropicFilteringLevel !\u003d anisotropicFilteringLevel)\n\t\t\t{\n\t\t\t\ttextureManager.setAnisotropicFilteringLevel(textureArrayId, anisotropicFilteringLevel);\n\t\t\t\tlastAnisotropicFilteringLevel \u003d anisotropicFilteringLevel;\n\t\t\t}\n\n\t\t\tif (client.isStretchedEnabled())\n\t\t\t{\n\t\t\t\tDimension dim \u003d client.getStretchedDimensions();\n\t\t\t\trenderCanvasHeight \u003d dim.height;\n\n\t\t\t\tdouble scaleFactorY \u003d dim.getHeight() / canvasHeight;\n\t\t\t\tdouble scaleFactorX \u003d dim.getWidth() / canvasWidth;\n\n\t\t\t\t// Pad the viewport a little because having ints for our viewport dimensions can introduce off-by-one errors.\n\t\t\t\tfinal int padding \u003d 1;\n\n\t\t\t\t// Ceil the sizes because even if the size is 599.1 we want to treat it as size 600 (i.e. render to the x\u003d599 pixel).\n\t\t\t\trenderViewportHeight \u003d (int) Math.ceil(scaleFactorY * (renderViewportHeight)) + padding * 2;\n\t\t\t\trenderViewportWidth \u003d (int) Math.ceil(scaleFactorX * (renderViewportWidth)) + padding * 2;\n\n\t\t\t\t// Floor the offsets because even if the offset is 4.9, we want to render to the x\u003d4 pixel anyway.\n\t\t\t\trenderHeightOff \u003d (int) Math.floor(scaleFactorY * (renderHeightOff)) - padding;\n\t\t\t\trenderWidthOff \u003d (int) Math.floor(scaleFactorX * (renderWidthOff)) - padding;\n\t\t\t}\n\n\t\t\tglDpiAwareViewport(renderWidthOff, renderCanvasHeight - renderViewportHeight - renderHeightOff, renderViewportWidth, renderViewportHeight);\n\n\t\t\tGL43C.glUseProgram(glProgram);\n\n\t\t\tfinal int drawDistance \u003d getDrawDistance();\n\t\t\tfinal int fogDepth \u003d config.fogDepth();\n\t\t\tGL43C.glUniform1i(uniUseFog, fogDepth \u003e 0 ? 1 : 0);\n\t\t\tGL43C.glUniform4f(uniFogColor, (sky \u003e\u003e 16 \u0026 0xFF) / 255f, (sky \u003e\u003e 8 \u0026 0xFF) / 255f, (sky \u0026 0xFF) / 255f, 1f);\n\t\t\tGL43C.glUniform1i(uniFogDepth, fogDepth);\n\t\t\tGL43C.glUniform1i(uniDrawDistance, drawDistance * Perspective.LOCAL_TILE_SIZE);\n\t\t\tGL43C.glUniform1i(uniExpandedMapLoadingChunks, client.getExpandedMapLoading());\n\n\t\t\t// Brightness happens to also be stored in the texture provider, so we use that\n\t\t\tGL43C.glUniform1f(uniBrightness, (float) textureProvider.getBrightness());\n\t\t\tGL43C.glUniform1f(uniSmoothBanding, config.smoothBanding() ? 0f : 1f);\n\t\t\tGL43C.glUniform1i(uniColorBlindMode, config.colorBlindMode().ordinal());\n\t\t\tGL43C.glUniform1f(uniTextureLightMode, config.brightTextures() ? 1f : 0f);\n\t\t\tif (gameState \u003d\u003d GameState.LOGGED_IN)\n\t\t\t{\n\t\t\t\t// avoid textures animating during loading\n\t\t\t\tGL43C.glUniform1i(uniTick, client.getGameCycle() \u0026 127);\n\t\t\t}\n\n\t\t\t// Calculate projection matrix\n\t\t\tfloat[] projectionMatrix \u003d Mat4.scale(client.getScale(), client.getScale(), 1);\n\t\t\tMat4.mul(projectionMatrix, Mat4.projection(viewportWidth, viewportHeight, 50));\n\t\t\tMat4.mul(projectionMatrix, Mat4.rotateX((float) cameraPitch));\n\t\t\tMat4.mul(projectionMatrix, Mat4.rotateY((float) cameraYaw));\n\t\t\tMat4.mul(projectionMatrix, Mat4.translate((float) -cameraX, (float) -cameraY, (float) -cameraZ));\n\t\t\tGL43C.glUniformMatrix4fv(uniProjectionMatrix, false, projectionMatrix);\n\n\t\t\t// Bind uniforms\n\t\t\tGL43C.glUniformBlockBinding(glProgram, uniBlockMain, 0);\n\t\t\tGL43C.glUniform1i(uniTextures, 1); // texture sampler array is bound to texture1\n\n\t\t\t// We just allow the GL to do face culling. Note this requires the priority renderer\n\t\t\t// to have logic to disregard culled faces in the priority depth testing.\n\t\t\tGL43C.glEnable(GL43C.GL_CULL_FACE);\n\n\t\t\t// Enable blending for alpha\n\t\t\tGL43C.glEnable(GL43C.GL_BLEND);\n\t\t\tGL43C.glBlendFuncSeparate(GL43C.GL_SRC_ALPHA, GL43C.GL_ONE_MINUS_SRC_ALPHA, GL43C.GL_ONE, GL43C.GL_ONE);\n\n\t\t\t// Draw buffers\n\t\t\tif (computeMode !\u003d ComputeMode.NONE)\n\t\t\t{\n\t\t\t\tif (computeMode \u003d\u003d ComputeMode.OPENGL)\n\t\t\t\t{\n\t\t\t\t\t// Before reading the SSBOs written to from postDrawScene() we must insert a barrier\n\t\t\t\t\tGL43C.glMemoryBarrier(GL43C.GL_SHADER_STORAGE_BARRIER_BIT);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Wait for the command queue to finish, so that we know the compute is done\n\t\t\t\t\topenCLManager.finish();\n\t\t\t\t}\n\n\t\t\t\t// Draw using the output buffer of the compute\n\t\t\t\tGL43C.glBindVertexArray(vaoCompute);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Only use the temporary buffers, which will contain the full scene\n\t\t\t\tGL43C.glBindVertexArray(vaoTemp);\n\t\t\t}\n\n\t\t\tGL43C.glDrawArrays(GL43C.GL_TRIANGLES, 0, targetBufferOffset);\n\n\t\t\tGL43C.glDisable(GL43C.GL_BLEND);\n\t\t\tGL43C.glDisable(GL43C.GL_CULL_FACE);\n\n\t\t\tGL43C.glUseProgram(0);\n\t\t}\n\n\t\t// Blit FBO\n\t\t{\n\t\t\tint width \u003d lastStretchedCanvasWidth;\n\t\t\tint height \u003d lastStretchedCanvasHeight;\n\n\t\t\tfinal GraphicsConfiguration graphicsConfiguration \u003d clientUI.getGraphicsConfiguration();\n\t\t\tfinal AffineTransform transform \u003d graphicsConfiguration.getDefaultTransform();\n\n\t\t\twidth \u003d getScaledValue(transform.getScaleX(), width);\n\t\t\theight \u003d getScaledValue(transform.getScaleY(), height);\n\n\t\t\tGL43C.glBindFramebuffer(GL43C.GL_READ_FRAMEBUFFER, fboScene);\n\t\t\tGL43C.glBindFramebuffer(GL43C.GL_DRAW_FRAMEBUFFER, awtContext.getFramebuffer(false));\n\t\t\tGL43C.glBlitFramebuffer(0, 0, width, height, 0, 0, width, height,\n\t\t\t\tGL43C.GL_COLOR_BUFFER_BIT, GL43C.GL_NEAREST);\n\n\t\t\t// Reset\n\t\t\tGL43C.glBindFramebuffer(GL43C.GL_READ_FRAMEBUFFER, awtContext.getFramebuffer(false));\n\t\t}\n\n\t\tvertexBuffer.clear();\n\t\tuvBuffer.clear();\n\t\tmodelBuffer.clear();\n\t\tmodelBufferSmall.clear();\n\t\tmodelBufferUnordered.clear();\n\n\t\tsmallModels \u003d largeModels \u003d unorderedModels \u003d 0;\n\t\ttempOffset \u003d 0;\n\t\ttempUvOffset \u003d 0;\n\n\t\t// Texture on UI\n\t\tdrawUi(overlayColor, canvasHeight, canvasWidth);\n\n\t\ttry\n\t\t{\n\t\t\tawtContext.swapBuffers();\n\t\t}\n\t\tcatch (RuntimeException ex)\n\t\t{\n\t\t\t// this is always fatal\n\t\t\tif (!canvas.isValid())\n\t\t\t{\n\t\t\t\t// this might be AWT shutting down on VM shutdown, ignore it\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlog.error(\"error swapping buffers\", ex);\n\n\t\t\t// try to stop the plugin\n\t\t\tSwingUtilities.invokeLater(() -\u003e\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tpluginManager.stopPlugin(this);\n\t\t\t\t}\n\t\t\t\tcatch (PluginInstantiationException ex2)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"error stopping plugin\", ex2);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tdrawManager.processDrawComplete(this::screenshot);\n\n\t\tGL43C.glBindFramebuffer(GL43C.GL_FRAMEBUFFER, awtContext.getFramebuffer(false));\n\n\t\tcheckGLErrors();\n\t}\n\n\tprivate void drawUi(final int overlayColor, final int canvasHeight, final int canvasWidth)\n\t{\n\t\tGL43C.glEnable(GL43C.GL_BLEND);\n\t\tGL43C.glBlendFunc(GL43C.GL_ONE, GL43C.GL_ONE_MINUS_SRC_ALPHA);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, interfaceTexture);\n\n\t\t// Use the texture bound in the first pass\n\t\tfinal UIScalingMode uiScalingMode \u003d config.uiScalingMode();\n\t\tGL43C.glUseProgram(glUiProgram);\n\t\tGL43C.glUniform1i(uniTex, 0);\n\t\tGL43C.glUniform1i(uniTexSamplingMode, uiScalingMode.getMode());\n\t\tGL43C.glUniform2i(uniTexSourceDimensions, canvasWidth, canvasHeight);\n\t\tGL43C.glUniform1i(uniUiColorBlindMode, config.colorBlindMode().ordinal());\n\t\tGL43C.glUniform4f(uniUiAlphaOverlay,\n\t\t\t(overlayColor \u003e\u003e 16 \u0026 0xFF) / 255f,\n\t\t\t(overlayColor \u003e\u003e 8 \u0026 0xFF) / 255f,\n\t\t\t(overlayColor \u0026 0xFF) / 255f,\n\t\t\t(overlayColor \u003e\u003e\u003e 24) / 255f\n\t\t);\n\n\t\tif (client.isStretchedEnabled())\n\t\t{\n\t\t\tDimension dim \u003d client.getStretchedDimensions();\n\t\t\tglDpiAwareViewport(0, 0, dim.width, dim.height);\n\t\t\tGL43C.glUniform2i(uniTexTargetDimensions, dim.width, dim.height);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tglDpiAwareViewport(0, 0, canvasWidth, canvasHeight);\n\t\t\tGL43C.glUniform2i(uniTexTargetDimensions, canvasWidth, canvasHeight);\n\t\t}\n\n\t\t// Set the sampling function used when stretching the UI.\n\t\t// This is probably better done with sampler objects instead of texture parameters, but this is easier and likely more portable.\n\t\t// See https://www.khronos.org/opengl/wiki/Sampler_Object for details.\n\t\t// GL_NEAREST makes sampling for bicubic/xBR simpler, so it should be used whenever linear isn\u0027t\n\t\tfinal int function \u003d uiScalingMode \u003d\u003d UIScalingMode.LINEAR ? GL43C.GL_LINEAR : GL43C.GL_NEAREST;\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_MIN_FILTER, function);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D, GL43C.GL_TEXTURE_MAG_FILTER, function);\n\n\t\t// Texture on UI\n\t\tGL43C.glBindVertexArray(vaoUiHandle);\n\t\tGL43C.glDrawArrays(GL43C.GL_TRIANGLE_FAN, 0, 4);\n\n\t\t// Reset\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D, 0);\n\t\tGL43C.glBindVertexArray(0);\n\t\tGL43C.glUseProgram(0);\n\t\tGL43C.glBlendFunc(GL43C.GL_SRC_ALPHA, GL43C.GL_ONE_MINUS_SRC_ALPHA);\n\t\tGL43C.glDisable(GL43C.GL_BLEND);\n\t}\n\n\t/**\n\t * Convert the front framebuffer to an Image\n\t *\n\t * @return\n\t */\n\tprivate Image screenshot()\n\t{\n\t\tint width \u003d client.getCanvasWidth();\n\t\tint height \u003d client.getCanvasHeight();\n\n\t\tif (client.isStretchedEnabled())\n\t\t{\n\t\t\tDimension dim \u003d client.getStretchedDimensions();\n\t\t\twidth \u003d dim.width;\n\t\t\theight \u003d dim.height;\n\t\t}\n\n\t\tfinal GraphicsConfiguration graphicsConfiguration \u003d clientUI.getGraphicsConfiguration();\n\t\tfinal AffineTransform t \u003d graphicsConfiguration.getDefaultTransform();\n\t\twidth \u003d getScaledValue(t.getScaleX(), width);\n\t\theight \u003d getScaledValue(t.getScaleY(), height);\n\n\t\tByteBuffer buffer \u003d ByteBuffer.allocateDirect(width * height * 4)\n\t\t\t.order(ByteOrder.nativeOrder());\n\n\t\tGL43C.glReadBuffer(awtContext.getBufferMode());\n\t\tGL43C.glReadPixels(0, 0, width, height, GL43C.GL_RGBA, GL43C.GL_UNSIGNED_BYTE, buffer);\n\n\t\tBufferedImage image \u003d new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n\t\tint[] pixels \u003d ((DataBufferInt) image.getRaster().getDataBuffer()).getData();\n\n\t\tfor (int y \u003d 0; y \u003c height; ++y)\n\t\t{\n\t\t\tfor (int x \u003d 0; x \u003c width; ++x)\n\t\t\t{\n\t\t\t\tint r \u003d buffer.get() \u0026 0xff;\n\t\t\t\tint g \u003d buffer.get() \u0026 0xff;\n\t\t\t\tint b \u003d buffer.get() \u0026 0xff;\n\t\t\t\tbuffer.get(); // alpha\n\n\t\t\t\tpixels[(height - y - 1) * width + x] \u003d (r \u003c\u003c 16) | (g \u003c\u003c 8) | b;\n\t\t\t}\n\t\t}\n\n\t\treturn image;\n\t}\n\n\t@Override\n\tpublic void animate(Texture texture, int diff)\n\t{\n\t\t// texture animation happens on gpu\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.LOGIN_SCREEN)\n\t\t{\n\t\t\t// Avoid drawing the last frame\u0027s buffer during LOADING after LOGIN_SCREEN\n\t\t\ttargetBufferOffset \u003d 0;\n\t\t}\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.STARTING)\n\t\t{\n\t\t\tif (textureArrayId !\u003d -1)\n\t\t\t{\n\t\t\t\ttextureManager.freeTextureArray(textureArrayId);\n\t\t\t}\n\t\t\ttextureArrayId \u003d -1;\n\t\t\tlastAnisotropicFilteringLevel \u003d -1;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void loadScene(Scene scene)\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tGpuIntBuffer vertexBuffer \u003d new GpuIntBuffer();\n\t\tGpuFloatBuffer uvBuffer \u003d new GpuFloatBuffer();\n\n\t\tsceneUploader.upload(scene, vertexBuffer, uvBuffer);\n\n\t\tvertexBuffer.flip();\n\t\tuvBuffer.flip();\n\n\t\tnextSceneVertexBuffer \u003d vertexBuffer;\n\t\tnextSceneTexBuffer \u003d uvBuffer;\n\t\tnextSceneId \u003d sceneUploader.sceneId;\n\t}\n\n\tprivate void uploadTileHeights(Scene scene)\n\t{\n\t\tif (tileHeightTex !\u003d 0)\n\t\t{\n\t\t\tGL43C.glDeleteTextures(tileHeightTex);\n\t\t\ttileHeightTex \u003d 0;\n\t\t}\n\n\t\tfinal int TILEHEIGHT_BUFFER_SIZE \u003d Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;\n\t\tShortBuffer tileBuffer \u003d ByteBuffer\n\t\t\t.allocateDirect(TILEHEIGHT_BUFFER_SIZE)\n\t\t\t.order(ByteOrder.nativeOrder())\n\t\t\t.asShortBuffer();\n\n\t\tint[][][] tileHeights \u003d scene.getTileHeights();\n\t\tfor (int z \u003d 0; z \u003c Constants.MAX_Z; ++z)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c Constants.EXTENDED_SCENE_SIZE; ++y)\n\t\t\t{\n\t\t\t\tfor (int x \u003d 0; x \u003c Constants.EXTENDED_SCENE_SIZE; ++x)\n\t\t\t\t{\n\t\t\t\t\tint h \u003d tileHeights[z][x][y];\n\t\t\t\t\tassert (h \u0026 0b111) \u003d\u003d 0;\n\t\t\t\t\th \u003e\u003e\u003d 3;\n\t\t\t\t\ttileBuffer.put((short) h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttileBuffer.flip();\n\n\t\ttileHeightTex \u003d GL43C.glGenTextures();\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_3D, tileHeightTex);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_3D, GL43C.GL_TEXTURE_MIN_FILTER, GL43C.GL_NEAREST);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_3D, GL43C.GL_TEXTURE_MAG_FILTER, GL43C.GL_NEAREST);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_3D, GL43C.GL_TEXTURE_WRAP_S, GL43C.GL_CLAMP_TO_EDGE);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_3D, GL43C.GL_TEXTURE_WRAP_T, GL43C.GL_CLAMP_TO_EDGE);\n\t\tGL43C.glTexImage3D(GL43C.GL_TEXTURE_3D, 0, GL43C.GL_R16I,\n\t\t\tConstants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,\n\t\t\t0, GL43C.GL_RED_INTEGER, GL43C.GL_SHORT, tileBuffer);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_3D, 0);\n\n\t\t// bind to texture 2\n\t\tGL43C.glActiveTexture(GL43C.GL_TEXTURE2);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_3D, tileHeightTex); // binding \u003d 2 in the shader\n\t\tGL43C.glActiveTexture(GL43C.GL_TEXTURE0);\n\t}\n\n\t@Override\n\tpublic void swapScene(Scene scene)\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (computeMode \u003d\u003d ComputeMode.OPENCL)\n\t\t{\n\t\t\topenCLManager.uploadTileHeights(scene);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tassert computeMode \u003d\u003d ComputeMode.OPENGL;\n\t\t\tuploadTileHeights(scene);\n\t\t}\n\n\t\tsceneId \u003d nextSceneId;\n\t\tupdateBuffer(sceneVertexBuffer, GL43C.GL_ARRAY_BUFFER, nextSceneVertexBuffer.getBuffer(), GL43C.GL_STATIC_COPY, CL12.CL_MEM_READ_ONLY);\n\t\tupdateBuffer(sceneUvBuffer, GL43C.GL_ARRAY_BUFFER, nextSceneTexBuffer.getBuffer(), GL43C.GL_STATIC_COPY, CL12.CL_MEM_READ_ONLY);\n\n\t\tnextSceneVertexBuffer \u003d null;\n\t\tnextSceneTexBuffer \u003d null;\n\t\tnextSceneId \u003d -1;\n\n\t\tcheckGLErrors();\n\t}\n\n\t@Override\n\tpublic boolean tileInFrustum(Scene scene, float pitchSin, float pitchCos, float yawSin, float yawCos, int cameraX, int cameraY, int cameraZ, int plane, int msx, int msy)\n\t{\n\t\tint[][][] tileHeights \u003d scene.getTileHeights();\n\t\tint x \u003d ((msx - SCENE_OFFSET) \u003c\u003c Perspective.LOCAL_COORD_BITS) + 64 - cameraX;\n\t\tint z \u003d ((msy - SCENE_OFFSET) \u003c\u003c Perspective.LOCAL_COORD_BITS) + 64 - cameraZ;\n\t\tint y \u003d Math.max(\n\t\t\tMath.max(tileHeights[plane][msx][msy], tileHeights[plane][msx][msy + 1]),\n\t\t\tMath.max(tileHeights[plane][msx + 1][msy], tileHeights[plane][msx + 1][msy + 1])\n\t\t) + GROUND_MIN_Y - cameraY;\n\n\t\tint radius \u003d 96; // ~ 64 * sqrt(2)\n\n\t\tint zoom \u003d client.get3dZoom();\n\t\tint Rasterizer3D_clipMidX2 \u003d client.getRasterizer3D_clipMidX2();\n\t\tint Rasterizer3D_clipNegativeMidX \u003d client.getRasterizer3D_clipNegativeMidX();\n\t\tint Rasterizer3D_clipNegativeMidY \u003d client.getRasterizer3D_clipNegativeMidY();\n\n\t\tfloat var11 \u003d yawCos * z - yawSin * x;\n\t\tfloat var12 \u003d pitchSin * y + pitchCos * var11;\n\t\tfloat var13 \u003d pitchCos * radius;\n\t\tfloat depth \u003d var12 + var13;\n\t\tif (depth \u003e 50)\n\t\t{\n\t\t\tfloat rx \u003d z * yawSin + yawCos * x;\n\t\t\tfloat var16 \u003d (rx - radius) * zoom;\n\t\t\tfloat var17 \u003d (rx + radius) * zoom;\n\t\t\t// left \u0026\u0026 right\n\t\t\tif (var16 \u003c Rasterizer3D_clipMidX2 * depth \u0026\u0026 var17 \u003e Rasterizer3D_clipNegativeMidX * depth)\n\t\t\t{\n\t\t\t\tfloat ry \u003d pitchCos * y - var11 * pitchSin;\n\t\t\t\tfloat ybottom \u003d pitchSin * radius;\n\t\t\t\tfloat var20 \u003d (ry + ybottom) * zoom;\n\t\t\t\t// top\n\t\t\t\tif (var20 \u003e Rasterizer3D_clipNegativeMidY * depth)\n\t\t\t\t{\n\t\t\t\t\t// we don\u0027t test the bottom so we don\u0027t have to find the height of all the models on the tile\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Check is a model is visible and should be drawn.\n\t */\n\tprivate boolean isVisible(Model model, float pitchSin, float pitchCos, float yawSin, float yawCos, int x, int y, int z)\n\t{\n\t\tfinal int xzMag \u003d model.getXYZMag();\n\t\tfinal int bottomY \u003d model.getBottomY();\n\t\tfinal int zoom \u003d client.get3dZoom();\n\t\tfinal int modelHeight \u003d model.getModelHeight();\n\n\t\tint Rasterizer3D_clipMidX2 \u003d client.getRasterizer3D_clipMidX2(); // width / 2\n\t\tint Rasterizer3D_clipNegativeMidX \u003d client.getRasterizer3D_clipNegativeMidX(); // -width / 2\n\t\tint Rasterizer3D_clipNegativeMidY \u003d client.getRasterizer3D_clipNegativeMidY(); // -height / 2\n\t\tint Rasterizer3D_clipMidY2 \u003d client.getRasterizer3D_clipMidY2(); // height / 2\n\n\t\tfloat var11 \u003d yawCos * z - yawSin * x;\n\t\tfloat var12 \u003d pitchSin * y + pitchCos * var11;\n\t\tfloat var13 \u003d pitchCos * xzMag;\n\t\tfloat depth \u003d var12 + var13;\n\t\tif (depth \u003e 50)\n\t\t{\n\t\t\tfloat rx \u003d z * yawSin + yawCos * x;\n\t\t\tfloat var16 \u003d (rx - xzMag) * zoom;\n\t\t\tif (var16 / depth \u003c Rasterizer3D_clipMidX2)\n\t\t\t{\n\t\t\t\tfloat var17 \u003d (rx + xzMag) * zoom;\n\t\t\t\tif (var17 / depth \u003e Rasterizer3D_clipNegativeMidX)\n\t\t\t\t{\n\t\t\t\t\tfloat ry \u003d pitchCos * y - var11 * pitchSin;\n\t\t\t\t\tfloat yheight \u003d pitchSin * xzMag;\n\t\t\t\t\tfloat ybottom \u003d (pitchCos * bottomY) + yheight; // use bottom height instead of y pos for height\n\t\t\t\t\tfloat var20 \u003d (ry + ybottom) * zoom;\n\t\t\t\t\tif (var20 / depth \u003e Rasterizer3D_clipNegativeMidY)\n\t\t\t\t\t{\n\t\t\t\t\t\tfloat ytop \u003d (pitchCos * modelHeight) + yheight;\n\t\t\t\t\t\tfloat var22 \u003d (ry - ytop) * zoom;\n\t\t\t\t\t\treturn var22 / depth \u003c Rasterizer3D_clipMidY2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Draw a renderable in the scene\n\t */\n\t@Override\n\tpublic void draw(Projection projection, Scene scene, Renderable renderable, int orientation, int x, int y, int z, long hash)\n\t{\n\t\tModel model, offsetModel;\n\t\tif (renderable instanceof Model)\n\t\t{\n\t\t\tmodel \u003d (Model) renderable;\n\t\t\toffsetModel \u003d model.getUnskewedModel();\n\t\t\tif (offsetModel \u003d\u003d null)\n\t\t\t{\n\t\t\t\toffsetModel \u003d model;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodel \u003d renderable.getModel();\n\t\t\tif (model \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\toffsetModel \u003d model;\n\t\t}\n\n\t\tif (computeMode \u003d\u003d ComputeMode.NONE)\n\t\t{\n\t\t\t// Apply height to renderable from the model\n\t\t\tif (model !\u003d renderable)\n\t\t\t{\n\t\t\t\trenderable.setModelHeight(model.getModelHeight());\n\t\t\t}\n\n\t\t\tmodel.calculateBoundsCylinder();\n\n\t\t\tif (projection instanceof IntProjection)\n\t\t\t{\n\t\t\t\tIntProjection p \u003d (IntProjection) projection;\n\t\t\t\tif (!isVisible(model, p.getPitchSin(), p.getPitchCos(), p.getYawSin(), p.getYawCos(), x - p.getCameraX(), y - p.getCameraY(), z - p.getCameraZ()))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.checkClickbox(projection, model, orientation, x, y, z, hash);\n\n\t\t\ttargetBufferOffset +\u003d sceneUploader.pushSortedModel(\n\t\t\t\tprojection,\n\t\t\t\tmodel, orientation,\n\t\t\t\tx, y, z,\n\t\t\t\tvertexBuffer, uvBuffer);\n\t\t}\n\t\t// Model may be in the scene buffer\n\t\telse if (offsetModel.getSceneId() \u003d\u003d sceneId)\n\t\t{\n\t\t\tassert model \u003d\u003d renderable;\n\n\t\t\tmodel.calculateBoundsCylinder();\n\n\t\t\tif (projection instanceof IntProjection)\n\t\t\t{\n\t\t\t\tIntProjection p \u003d (IntProjection) projection;\n\t\t\t\tif (!isVisible(model, p.getPitchSin(), p.getPitchCos(), p.getYawSin(), p.getYawCos(), x - p.getCameraX(), y - p.getCameraY(), z - p.getCameraZ()))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.checkClickbox(projection, model, orientation, x, y, z, hash);\n\n\t\t\tint tc \u003d Math.min(MAX_TRIANGLE, offsetModel.getFaceCount());\n\t\t\tint uvOffset \u003d offsetModel.getUvBufferOffset();\n\t\t\tint plane \u003d (int) ((hash \u003e\u003e TileObject.HASH_PLANE_SHIFT) \u0026 3);\n\t\t\tboolean hillskew \u003d offsetModel !\u003d model;\n\n\t\t\tGpuIntBuffer b \u003d bufferForTriangles(tc);\n\n\t\t\tb.ensureCapacity(8);\n\t\t\tIntBuffer buffer \u003d b.getBuffer();\n\t\t\tbuffer.put(offsetModel.getBufferOffset());\n\t\t\tbuffer.put(uvOffset);\n\t\t\tbuffer.put(tc);\n\t\t\tbuffer.put(targetBufferOffset);\n\t\t\tbuffer.put(FLAG_SCENE_BUFFER | (hillskew ? (1 \u003c\u003c 26) : 0) | (plane \u003c\u003c 24) | orientation);\n\t\t\tbuffer.put(x).put(y).put(z);\n\n\t\t\ttargetBufferOffset +\u003d tc * 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Temporary model (animated or otherwise not a static Model on the scene)\n\n\t\t\t// Apply height to renderable from the model\n\t\t\tif (model !\u003d renderable)\n\t\t\t{\n\t\t\t\trenderable.setModelHeight(model.getModelHeight());\n\t\t\t}\n\n\t\t\tmodel.calculateBoundsCylinder();\n\n\t\t\tif (projection instanceof IntProjection)\n\t\t\t{\n\t\t\t\tIntProjection p \u003d (IntProjection) projection;\n\t\t\t\tif (!isVisible(model, p.getPitchSin(), p.getPitchCos(), p.getYawSin(), p.getYawCos(), x - p.getCameraX(), y - p.getCameraY(), z - p.getCameraZ()))\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.checkClickbox(projection, model, orientation, x, y, z, hash);\n\n\t\t\tboolean hasUv \u003d model.getFaceTextures() !\u003d null;\n\n\t\t\tint len \u003d sceneUploader.pushModel(model, vertexBuffer, uvBuffer);\n\n\t\t\tGpuIntBuffer b \u003d bufferForTriangles(len / 3);\n\n\t\t\tb.ensureCapacity(8);\n\t\t\tIntBuffer buffer \u003d b.getBuffer();\n\t\t\tbuffer.put(tempOffset);\n\t\t\tbuffer.put(hasUv ? tempUvOffset : -1);\n\t\t\tbuffer.put(len / 3);\n\t\t\tbuffer.put(targetBufferOffset);\n\t\t\tbuffer.put(orientation);\n\t\t\tbuffer.put(x).put(y).put(z);\n\n\t\t\ttempOffset +\u003d len;\n\t\t\tif (hasUv)\n\t\t\t{\n\t\t\t\ttempUvOffset +\u003d len;\n\t\t\t}\n\n\t\t\ttargetBufferOffset +\u003d len;\n\t\t}\n\t}\n\n\t/**\n\t * returns the correct buffer based on triangle count and updates model count\n\t *\n\t * @param triangles\n\t * @return\n\t */\n\tprivate GpuIntBuffer bufferForTriangles(int triangles)\n\t{\n\t\tif (triangles \u003c\u003d SMALL_TRIANGLE_COUNT)\n\t\t{\n\t\t\t++smallModels;\n\t\t\treturn modelBufferSmall;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t++largeModels;\n\t\t\treturn modelBuffer;\n\t\t}\n\t}\n\n\tprivate int getScaledValue(final double scale, final int value)\n\t{\n\t\treturn (int) (value * scale);\n\t}\n\n\tprivate void glDpiAwareViewport(final int x, final int y, final int width, final int height)\n\t{\n\t\tfinal GraphicsConfiguration graphicsConfiguration \u003d clientUI.getGraphicsConfiguration();\n\t\tfinal AffineTransform t \u003d graphicsConfiguration.getDefaultTransform();\n\t\tGL43C.glViewport(\n\t\t\tgetScaledValue(t.getScaleX(), x),\n\t\t\tgetScaledValue(t.getScaleY(), y),\n\t\t\tgetScaledValue(t.getScaleX(), width),\n\t\t\tgetScaledValue(t.getScaleY(), height));\n\t}\n\n\tprivate int getDrawDistance()\n\t{\n\t\treturn Ints.constrainToRange(config.drawDistance(), 0, MAX_DISTANCE);\n\t}\n\n\tprivate void updateBuffer(@Nonnull GLBuffer glBuffer, int target, @Nonnull IntBuffer data, int usage, long clFlags)\n\t{\n\t\tint size \u003d data.remaining() \u003c\u003c 2;\n\t\tupdateBuffer(glBuffer, target, size, usage, clFlags);\n\t\tGL43C.glBufferSubData(target, 0, data);\n\t}\n\n\tprivate void updateBuffer(@Nonnull GLBuffer glBuffer, int target, @Nonnull FloatBuffer data, int usage, long clFlags)\n\t{\n\t\tint size \u003d data.remaining() \u003c\u003c 2;\n\t\tupdateBuffer(glBuffer, target, size, usage, clFlags);\n\t\tGL43C.glBufferSubData(target, 0, data);\n\t}\n\n\tprivate void updateBuffer(@Nonnull GLBuffer glBuffer, int target, int size, int usage, long clFlags)\n\t{\n\t\tGL43C.glBindBuffer(target, glBuffer.glBufferId);\n\t\tif (glCapabilities.glInvalidateBufferData !\u003d 0L)\n\t\t{\n\t\t\t// https://www.khronos.org/opengl/wiki/Buffer_Object_Streaming suggests buffer re-specification is useful\n\t\t\t// to avoid implicit synching. We always need to trash the whole buffer anyway so this can\u0027t hurt.\n\t\t\tGL43C.glInvalidateBufferData(glBuffer.glBufferId);\n\t\t}\n\t\tif (size \u003e glBuffer.size)\n\t\t{\n\t\t\tint newSize \u003d Math.max(1024, nextPowerOfTwo(size));\n\t\t\tlog.trace(\"Buffer resize: {} {} -\u003e {}\", glBuffer.name, glBuffer.size, newSize);\n\n\t\t\tglBuffer.size \u003d newSize;\n\t\t\tGL43C.glBufferData(target, newSize, usage);\n\t\t\trecreateCLBuffer(glBuffer, clFlags);\n\t\t}\n\t}\n\n\tprivate static int nextPowerOfTwo(int v)\n\t{\n\t\tv--;\n\t\tv |\u003d v \u003e\u003e 1;\n\t\tv |\u003d v \u003e\u003e 2;\n\t\tv |\u003d v \u003e\u003e 4;\n\t\tv |\u003d v \u003e\u003e 8;\n\t\tv |\u003d v \u003e\u003e 16;\n\t\tv++;\n\t\treturn v;\n\t}\n\n\tprivate void recreateCLBuffer(GLBuffer glBuffer, long clFlags)\n\t{\n\t\tif (computeMode \u003d\u003d ComputeMode.OPENCL)\n\t\t{\n\t\t\tif (glBuffer.clBuffer !\u003d -1)\n\t\t\t{\n\t\t\t\tCL10.clReleaseMemObject(glBuffer.clBuffer);\n\t\t\t}\n\t\t\tif (glBuffer.size \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tglBuffer.clBuffer \u003d -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tglBuffer.clBuffer \u003d CL10GL.clCreateFromGLBuffer(openCLManager.context, clFlags, glBuffer.glBufferId, (int[]) null);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void checkGLErrors()\n\t{\n\t\tif (!log.isDebugEnabled())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (; ; )\n\t\t{\n\t\t\tint err \u003d GL43C.glGetError();\n\t\t\tif (err \u003d\u003d GL43C.GL_NO_ERROR)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString errStr;\n\t\t\tswitch (err)\n\t\t\t{\n\t\t\t\tcase GL43C.GL_INVALID_ENUM:\n\t\t\t\t\terrStr \u003d \"INVALID_ENUM\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase GL43C.GL_INVALID_VALUE:\n\t\t\t\t\terrStr \u003d \"INVALID_VALUE\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase GL43C.GL_INVALID_OPERATION:\n\t\t\t\t\terrStr \u003d \"INVALID_OPERATION\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase GL43C.GL_INVALID_FRAMEBUFFER_OPERATION:\n\t\t\t\t\terrStr \u003d \"INVALID_FRAMEBUFFER_OPERATION\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\terrStr \u003d \"\" + err;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlog.debug(\"glGetError:\", new Exception(errStr));\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\GpuPlugin.java"},{"fileName":"GpuPluginConfig.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport info.sigterm.plugins.gpulegacy.config.ColorBlindMode;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.Range;\nimport info.sigterm.plugins.gpulegacy.config.AntiAliasingMode;\nimport info.sigterm.plugins.gpulegacy.config.UIScalingMode;\n\n@ConfigGroup(GpuPluginConfig.GROUP)\npublic interface GpuPluginConfig extends Config\n{\n\tString GROUP \u003d \"gpu\";\n\n\t@Range(\n\t\tmax \u003d GpuPlugin.MAX_DISTANCE\n\t)\n\t@ConfigItem(\n\t\tkeyName \u003d \"drawDistance\",\n\t\tname \u003d \"Draw distance\",\n\t\tdescription \u003d \"Draw distance.\",\n\t\tposition \u003d 1\n\t)\n\tdefault int drawDistance()\n\t{\n\t\treturn 50;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"hideUnrelatedMaps\",\n\t\tname \u003d \"Hide unrelated maps\",\n\t\tdescription \u003d \"Hide unrelated map areas you shouldn\u0027t see.\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean hideUnrelatedMaps()\n\t{\n\t\treturn true;\n\t}\n\n\t@Range(\n\t\tmax \u003d 5\n\t)\n\t@ConfigItem(\n\t\tkeyName \u003d \"expandedMapLoadingChunks\",\n\t\tname \u003d \"Extended map loading\",\n\t\tdescription \u003d \"Extra map area to load, in 8 tile chunks.\",\n\t\tposition \u003d 1\n\t)\n\tdefault int expandedMapLoadingChunks()\n\t{\n\t\treturn 3;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"smoothBanding\",\n\t\tname \u003d \"Remove color banding\",\n\t\tdescription \u003d \"Smooths out the color banding that is present in the CPU renderer.\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean smoothBanding()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"antiAliasingMode\",\n\t\tname \u003d \"Anti aliasing\",\n\t\tdescription \u003d \"Configures the anti-aliasing mode.\",\n\t\tposition \u003d 3\n\t)\n\tdefault AntiAliasingMode antiAliasingMode()\n\t{\n\t\treturn AntiAliasingMode.MSAA_2;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"uiScalingMode\",\n\t\tname \u003d \"UI scaling mode\",\n\t\tdescription \u003d \"Sampling function to use for the UI in stretched mode.\",\n\t\tposition \u003d 4\n\t)\n\tdefault UIScalingMode uiScalingMode()\n\t{\n\t\treturn UIScalingMode.LINEAR;\n\t}\n\n\t@Range(\n\t\tmax \u003d GpuPlugin.MAX_FOG_DEPTH\n\t)\n\t@ConfigItem(\n\t\tkeyName \u003d \"fogDepth\",\n\t\tname \u003d \"Fog depth\",\n\t\tdescription \u003d \"Distance from the scene edge the fog starts.\",\n\t\tposition \u003d 5\n\t)\n\tdefault int fogDepth()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"useComputeShaders\",\n\t\tname \u003d \"Compute shaders\",\n\t\tdescription \u003d \"Offloads face sorting to GPU. Requires plugin restart.\",\n\t\twarning \u003d \"This feature requires OpenGL 4.3 to use. Please check that your GPU supports this.\\nRestart the plugin for changes to take effect.\",\n\t\tposition \u003d 6\n\t)\n\tdefault boolean useComputeShaders()\n\t{\n\t\treturn true;\n\t}\n\n\t@Range(\n\t\tmin \u003d 0,\n\t\tmax \u003d 16\n\t)\n\t@ConfigItem(\n\t\tkeyName \u003d \"anisotropicFilteringLevel\",\n\t\tname \u003d \"Anisotropic filtering\",\n\t\tdescription \u003d \"Configures the anisotropic filtering level.\",\n\t\tposition \u003d 7\n\t)\n\tdefault int anisotropicFilteringLevel()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"colorBlindMode\",\n\t\tname \u003d \"Colorblindness correction\",\n\t\tdescription \u003d \"Adjusts colors to account for colorblindness.\",\n\t\tposition \u003d 8\n\t)\n\tdefault ColorBlindMode colorBlindMode()\n\t{\n\t\treturn ColorBlindMode.NONE;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"brightTextures\",\n\t\tname \u003d \"Bright textures\",\n\t\tdescription \u003d \"Use old texture lighting method which results in brighter game textures.\",\n\t\tposition \u003d 9\n\t)\n\tdefault boolean brightTextures()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"unlockFps\",\n\t\tname \u003d \"Unlock FPS\",\n\t\tdescription \u003d \"Removes the 50 FPS cap for camera movement.\",\n\t\tposition \u003d 10\n\t)\n\tdefault boolean unlockFps()\n\t{\n\t\treturn true;\n\t}\n\n\tenum SyncMode\n\t{\n\t\tOFF,\n\t\tON,\n\t\tADAPTIVE\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"vsyncMode\",\n\t\tname \u003d \"Vsync mode\",\n\t\tdescription \u003d \"Method to synchronize frame rate with refresh rate.\",\n\t\tposition \u003d 11\n\t)\n\tdefault SyncMode syncMode()\n\t{\n\t\treturn SyncMode.OFF;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"fpsTarget\",\n\t\tname \u003d \"FPS target\",\n\t\tdescription \u003d \"Target FPS when \u0027Unlock FPS\u0027 is enabled and \u0027Vsync mode\u0027 is off.\",\n\t\tposition \u003d 12\n\t)\n\t@Range(\n\t\tmin \u003d 1,\n\t\tmax \u003d 999\n\t)\n\tdefault int fpsTarget()\n\t{\n\t\treturn 60;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"removeVertexSnapping\",\n\t\tname \u003d \"Remove vertex snapping\",\n\t\tdescription \u003d \"Removes vertex snapping from most animations.\",\n\t\tposition \u003d 13\n\t)\n\tdefault boolean removeVertexSnapping()\n\t{\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\GpuPluginConfig.java"},{"fileName":"Mat4.java","content":"/*\n * Copyright (c) 2022 Abex\n * Copyright 2010 JogAmp Community.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\npublic class Mat4\n{\n\tprivate Mat4()\n\t{\n\t}\n\n\tpublic static float[] identity()\n\t{\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t};\n\t}\n\n\tpublic static float[] scale(float sx, float sy, float sz)\n\t{\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\tsx, 0, 0, 0,\n\t\t\t\t0, sy, 0, 0,\n\t\t\t\t0, 0, sz, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t};\n\t}\n\n\tpublic static float[] translate(float tx, float ty, float tz)\n\t{\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\t0, 0, 1, 0,\n\t\t\t\ttx, ty, tz, 1,\n\t\t\t};\n\t}\n\n\tpublic static float[] rotateX(float rx)\n\t{\n\t\tfloat s \u003d (float) Math.sin(rx);\n\t\tfloat c \u003d (float) Math.cos(rx);\n\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\t1, 0, 0, 0,\n\t\t\t\t0, c, s, 0,\n\t\t\t\t0, -s, c, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t};\n\t}\n\n\tpublic static float[] rotateY(float ry)\n\t{\n\t\tfloat s \u003d (float) Math.sin(ry);\n\t\tfloat c \u003d (float) Math.cos(ry);\n\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\tc, 0, -s, 0,\n\t\t\t\t0, 1, 0, 0,\n\t\t\t\ts, 0, c, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t};\n\t}\n\n\tpublic static float[] projection(float w, float h, float n)\n\t{\n\t\treturn new float[]\n\t\t\t{\n\t\t\t\t2 / w, 0, 0, 0,\n\t\t\t\t0, -2 / h, 0, 0,\n\t\t\t\t0, 0, 0, 1,\n\t\t\t\t0, 0, 2 * n, 0\n\t\t\t};\n\t}\n\n\tpublic static void mul(final float[] a, final float[] b)\n\t{\n\t\tfinal float b00 \u003d b[0 + 0 * 4];\n\t\tfinal float b10 \u003d b[1 + 0 * 4];\n\t\tfinal float b20 \u003d b[2 + 0 * 4];\n\t\tfinal float b30 \u003d b[3 + 0 * 4];\n\t\tfinal float b01 \u003d b[0 + 1 * 4];\n\t\tfinal float b11 \u003d b[1 + 1 * 4];\n\t\tfinal float b21 \u003d b[2 + 1 * 4];\n\t\tfinal float b31 \u003d b[3 + 1 * 4];\n\t\tfinal float b02 \u003d b[0 + 2 * 4];\n\t\tfinal float b12 \u003d b[1 + 2 * 4];\n\t\tfinal float b22 \u003d b[2 + 2 * 4];\n\t\tfinal float b32 \u003d b[3 + 2 * 4];\n\t\tfinal float b03 \u003d b[0 + 3 * 4];\n\t\tfinal float b13 \u003d b[1 + 3 * 4];\n\t\tfinal float b23 \u003d b[2 + 3 * 4];\n\t\tfinal float b33 \u003d b[3 + 3 * 4];\n\n\t\tfloat ai0 \u003d a[0 * 4]; // row-0 of a\n\t\tfloat ai1 \u003d a[1 * 4];\n\t\tfloat ai2 \u003d a[2 * 4];\n\t\tfloat ai3 \u003d a[3 * 4];\n\t\ta[0 * 4] \u003d ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;\n\t\ta[1 * 4] \u003d ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;\n\t\ta[2 * 4] \u003d ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;\n\t\ta[3 * 4] \u003d ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;\n\n\t\tai0 \u003d a[1 + 0 * 4]; // row-1 of a\n\t\tai1 \u003d a[1 + 1 * 4];\n\t\tai2 \u003d a[1 + 2 * 4];\n\t\tai3 \u003d a[1 + 3 * 4];\n\t\ta[1 + 0 * 4] \u003d ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;\n\t\ta[1 + 1 * 4] \u003d ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;\n\t\ta[1 + 2 * 4] \u003d ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;\n\t\ta[1 + 3 * 4] \u003d ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;\n\n\t\tai0 \u003d a[2 + 0 * 4]; // row-2 of a\n\t\tai1 \u003d a[2 + 1 * 4];\n\t\tai2 \u003d a[2 + 2 * 4];\n\t\tai3 \u003d a[2 + 3 * 4];\n\t\ta[2 + 0 * 4] \u003d ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;\n\t\ta[2 + 1 * 4] \u003d ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;\n\t\ta[2 + 2 * 4] \u003d ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;\n\t\ta[2 + 3 * 4] \u003d ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;\n\n\t\tai0 \u003d a[3 + 0 * 4]; // row-3 of a\n\t\tai1 \u003d a[3 + 1 * 4];\n\t\tai2 \u003d a[3 + 2 * 4];\n\t\tai3 \u003d a[3 + 3 * 4];\n\t\ta[3 + 0 * 4] \u003d ai0 * b00 + ai1 * b10 + ai2 * b20 + ai3 * b30;\n\t\ta[3 + 1 * 4] \u003d ai0 * b01 + ai1 * b11 + ai2 * b21 + ai3 * b31;\n\t\ta[3 + 2 * 4] \u003d ai0 * b02 + ai1 * b12 + ai2 * b22 + ai3 * b32;\n\t\ta[3 + 3 * 4] \u003d ai0 * b03 + ai1 * b13 + ai2 * b23 + ai3 * b33;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\Mat4.java"},{"fileName":"OpenCLManager.java","content":"/*\n * Copyright (c) 2021, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport java.nio.ByteBuffer;\nimport java.nio.IntBuffer;\nimport java.nio.LongBuffer;\nimport java.nio.ShortBuffer;\nimport javax.inject.Singleton;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Constants;\nimport net.runelite.api.Scene;\nimport info.sigterm.plugins.gpulegacy.template.Template;\nimport net.runelite.client.util.OSType;\nimport net.runelite.rlawt.AWTContext;\nimport org.lwjgl.PointerBuffer;\nimport org.lwjgl.opencl.APPLEGLSharing;\nimport static org.lwjgl.opencl.APPLEGLSharing.CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE;\nimport static org.lwjgl.opencl.APPLEGLSharing.clGetGLContextInfoAPPLE;\nimport org.lwjgl.opencl.CL;\nimport static org.lwjgl.opencl.CL10.CL_CONTEXT_PLATFORM;\nimport static org.lwjgl.opencl.CL10.CL_DEVICE_EXTENSIONS;\nimport static org.lwjgl.opencl.CL10.CL_DEVICE_NAME;\nimport static org.lwjgl.opencl.CL10.CL_DEVICE_PROFILE;\nimport static org.lwjgl.opencl.CL10.CL_DEVICE_VENDOR;\nimport static org.lwjgl.opencl.CL10.CL_DEVICE_VERSION;\nimport static org.lwjgl.opencl.CL10.CL_DRIVER_VERSION;\nimport static org.lwjgl.opencl.CL10.CL_PROGRAM_BUILD_LOG;\nimport static org.lwjgl.opencl.CL10.CL_PROGRAM_BUILD_OPTIONS;\nimport static org.lwjgl.opencl.CL10.CL_PROGRAM_BUILD_STATUS;\nimport static org.lwjgl.opencl.CL10.CL_SUCCESS;\nimport static org.lwjgl.opencl.CL10.clGetPlatformInfo;\nimport static org.lwjgl.opencl.CL10.clGetProgramBuildInfo;\nimport org.lwjgl.opencl.CL10GL;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_ADDRESS_BITS;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_AVAILABLE;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_COMPILER_AVAILABLE;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_MAX_CLOCK_FREQUENCY;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_MAX_COMPUTE_UNITS;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_MAX_WORK_GROUP_SIZE;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_QUEUE_PROPERTIES;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_TYPE;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_TYPE_GPU;\nimport static org.lwjgl.opencl.CL11.CL_DEVICE_VENDOR_ID;\nimport static org.lwjgl.opencl.CL11.CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;\nimport static org.lwjgl.opencl.CL11.clCreateContext;\nimport static org.lwjgl.opencl.CL11.clGetDeviceIDs;\nimport static org.lwjgl.opencl.CL11.clGetDeviceInfo;\nimport static org.lwjgl.opencl.CL11.clGetPlatformIDs;\nimport org.lwjgl.opencl.CL12;\nimport static org.lwjgl.opencl.CL12.CL_PROGRAM_BINARY_TYPE;\nimport org.lwjgl.opencl.CLCapabilities;\nimport org.lwjgl.opencl.CLContextCallback;\nimport org.lwjgl.opencl.CLImageFormat;\nimport static org.lwjgl.opencl.KHRGLSharing.CL_GLX_DISPLAY_KHR;\nimport static org.lwjgl.opencl.KHRGLSharing.CL_GL_CONTEXT_KHR;\nimport static org.lwjgl.opencl.KHRGLSharing.CL_WGL_HDC_KHR;\nimport org.lwjgl.system.Configuration;\nimport org.lwjgl.system.MemoryStack;\nimport org.lwjgl.system.MemoryUtil;\nimport static org.lwjgl.system.MemoryUtil.NULL;\nimport static org.lwjgl.system.MemoryUtil.memASCII;\nimport static org.lwjgl.system.MemoryUtil.memUTF8;\n\n@Singleton\n@Slf4j\nclass OpenCLManager\n{\n\tprivate static final String KERNEL_NAME_UNORDERED \u003d \"computeUnordered\";\n\tprivate static final String KERNEL_NAME_LARGE \u003d \"computeLarge\";\n\n\tprivate static final int MIN_WORK_GROUP_SIZE \u003d 256;\n\tprivate static final int SMALL_SIZE \u003d GpuPlugin.SMALL_TRIANGLE_COUNT;\n\tprivate static final int LARGE_SIZE \u003d GpuPlugin.MAX_TRIANGLE;\n\t//  struct shared_data {\n\t//      int totalNum[12];\n\t//      int totalDistance[12];\n\t//      int totalMappedNum[18];\n\t//      int min10;\n\t//      int renderPris[0];\n\t//  };\n\tprivate static final int SHARED_SIZE \u003d 12 + 12 + 18 + 1; // in ints\n\n\tprivate boolean initialized;\n\n\t// The number of faces each worker processes in the two kernels\n\tprivate int largeFaceCount;\n\tprivate int smallFaceCount;\n\n\tprivate long device;\n\tlong context;\n\tprivate long commandQueue;\n\n\tprivate long programUnordered;\n\tprivate long programSmall;\n\tprivate long programLarge;\n\n\tprivate long kernelUnordered;\n\tprivate long kernelSmall;\n\tprivate long kernelLarge;\n\n\tprivate long tileHeightImage;\n\n\tstatic\n\t{\n\t\tConfiguration.OPENCL_EXPLICIT_INIT.set(true);\n\t}\n\n\tvoid init(AWTContext awtContext)\n\t{\n\t\tdevice \u003d context \u003d commandQueue \u003d 0L;\n\t\tprogramUnordered \u003d programSmall \u003d programLarge \u003d 0L;\n\t\tkernelUnordered \u003d kernelSmall \u003d kernelLarge \u003d 0L;\n\t\ttileHeightImage \u003d 0L;\n\n\t\tCL.create();\n\t\tinitialized \u003d true;\n\n\t\ttry (var stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tif (OSType.getOSType() \u003d\u003d OSType.MacOS)\n\t\t\t{\n\t\t\t\tinitContextMacOS(awtContext, stack);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinitContext(awtContext, stack);\n\t\t\t}\n\n\t\t\tensureMinWorkGroupSize();\n\t\t\tinitQueue();\n\t\t\tcompilePrograms(stack);\n\t\t}\n\t}\n\n\tvoid cleanup()\n\t{\n\t\tif (!initialized)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tif (tileHeightImage !\u003d 0L)\n\t\t\t{\n\t\t\t\tCL12.clReleaseMemObject(tileHeightImage);\n\t\t\t}\n\n\t\t\tCL12.clReleaseKernel(kernelUnordered);\n\t\t\tCL12.clReleaseKernel(kernelSmall);\n\t\t\tCL12.clReleaseKernel(kernelLarge);\n\n\t\t\tCL12.clReleaseProgram(programUnordered);\n\t\t\tCL12.clReleaseProgram(programSmall);\n\t\t\tCL12.clReleaseProgram(programLarge);\n\n\t\t\tCL12.clReleaseCommandQueue(commandQueue);\n\n\t\t\tCL12.clReleaseContext(context);\n\n\t\t\tCL12.clReleaseDevice(device);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tCL.destroy();\n\t\t\tinitialized \u003d false;\n\t\t}\n\t}\n\n\tprivate void initContext(AWTContext awtContext, MemoryStack stack)\n\t{\n\t\tIntBuffer pi \u003d stack.mallocInt(1);\n\t\tcheckCLError(clGetPlatformIDs(null, pi));\n\t\tif (pi.get(0) \u003d\u003d 0)\n\t\t{\n\t\t\tthrow new RuntimeException(\"No OpenCL platforms found.\");\n\t\t}\n\n\t\tPointerBuffer platforms \u003d stack.mallocPointer(pi.get(0));\n\t\tcheckCLError(clGetPlatformIDs(platforms, (IntBuffer) null));\n\n\t\tPointerBuffer ctxProps \u003d stack.mallocPointer(7);\n\t\tif (OSType.getOSType() \u003d\u003d OSType.Windows)\n\t\t{\n\t\t\tctxProps\n\t\t\t\t.put(CL_CONTEXT_PLATFORM)\n\t\t\t\t.put(0)\n\t\t\t\t.put(CL_GL_CONTEXT_KHR)\n\t\t\t\t.put(awtContext.getGLContext())\n\t\t\t\t.put(CL_WGL_HDC_KHR)\n\t\t\t\t.put(awtContext.getWGLHDC())\n\t\t\t\t.put(0)\n\t\t\t\t.flip();\n\t\t}\n\t\telse if (OSType.getOSType() \u003d\u003d OSType.Linux)\n\t\t{\n\t\t\tctxProps\n\t\t\t\t.put(CL_CONTEXT_PLATFORM)\n\t\t\t\t.put(0)\n\t\t\t\t.put(CL_GL_CONTEXT_KHR)\n\t\t\t\t.put(awtContext.getGLContext())\n\t\t\t\t.put(CL_GLX_DISPLAY_KHR)\n\t\t\t\t.put(awtContext.getGLXDisplay())\n\t\t\t\t.put(0)\n\t\t\t\t.flip();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new RuntimeException(\"unsupported platform\");\n\t\t}\n\n\t\tfor (int p \u003d 0; p \u003c platforms.capacity(); p++)\n\t\t{\n\t\t\tlong platform \u003d platforms.get(p);\n\t\t\tctxProps.put(1, platform);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tCLCapabilities platformCaps \u003d CL.createPlatformCapabilities(platform);\n\n\t\t\t\tlog.debug(\"Platform profile: {}\", getPlatformInfoStringUTF8(platform, CL12.CL_PLATFORM_PROFILE));\n\t\t\t\tlog.debug(\"Platform version: {}\", getPlatformInfoStringUTF8(platform, CL12.CL_PLATFORM_VERSION));\n\t\t\t\tlog.debug(\"Platform name: {}\", getPlatformInfoStringUTF8(platform, CL12.CL_PLATFORM_NAME));\n\t\t\t\tlog.debug(\"Platform vendor: {}\", getPlatformInfoStringUTF8(platform, CL12.CL_PLATFORM_VENDOR));\n\t\t\t\tlog.debug(\"Platform extensions: {}\", getPlatformInfoStringUTF8(platform, CL12.CL_PLATFORM_EXTENSIONS));\n\n\t\t\t\tcheckCLError(clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, null, pi));\n\n\t\t\t\tPointerBuffer devices \u003d stack.mallocPointer(pi.get(0));\n\t\t\t\tcheckCLError(clGetDeviceIDs(platform, CL_DEVICE_TYPE_GPU, devices, (IntBuffer) null));\n\n\t\t\t\tfor (int d \u003d 0; d \u003c devices.capacity(); d++)\n\t\t\t\t{\n\t\t\t\t\tlong device \u003d devices.get(d);\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tCLCapabilities deviceCaps \u003d CL.createDeviceCapabilities(device, platformCaps);\n\n\t\t\t\t\t\tlog.debug(\"Device id {}\", device);\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_NAME: {}\", getDeviceInfoStringUTF8(device, CL_DEVICE_NAME));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_VENDOR: {}\", getDeviceInfoStringUTF8(device, CL_DEVICE_VENDOR));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DRIVER_VERSION: {}\", getDeviceInfoStringUTF8(device, CL_DRIVER_VERSION));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_PROFILE: {}\", getDeviceInfoStringUTF8(device, CL_DEVICE_PROFILE));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_VERSION: {}\", getDeviceInfoStringUTF8(device, CL_DEVICE_VERSION));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_EXTENSIONS: {}\", getDeviceInfoStringUTF8(device, CL_DEVICE_EXTENSIONS));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_TYPE: {}\", getDeviceInfoLong(device, CL_DEVICE_TYPE));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_VENDOR_ID: {}\", getDeviceInfoInt(device, CL_DEVICE_VENDOR_ID));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_MAX_COMPUTE_UNITS: {}\", getDeviceInfoInt(device, CL_DEVICE_MAX_COMPUTE_UNITS));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: {}\", getDeviceInfoInt(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_MAX_WORK_GROUP_SIZE: {}\", getDeviceInfoPointer(device, CL_DEVICE_MAX_WORK_GROUP_SIZE));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_MAX_CLOCK_FREQUENCY: {}\", getDeviceInfoInt(device, CL_DEVICE_MAX_CLOCK_FREQUENCY));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_ADDRESS_BITS: {}\", getDeviceInfoInt(device, CL_DEVICE_ADDRESS_BITS));\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_AVAILABLE: {}\", getDeviceInfoInt(device, CL_DEVICE_AVAILABLE) !\u003d 0);\n\t\t\t\t\t\tlog.debug(\"\\tCL_DEVICE_COMPILER_AVAILABLE: {}\", getDeviceInfoInt(device, CL_DEVICE_COMPILER_AVAILABLE) !\u003d 0);\n\n\t\t\t\t\t\tif (!deviceCaps.cl_khr_gl_sharing \u0026\u0026 !deviceCaps.cl_APPLE_gl_sharing)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tIntBuffer errcode_ret \u003d stack.callocInt(1);\n\t\t\t\t\t\tlong context \u003d clCreateContext(ctxProps, device, CLContextCallback.create((errinfo, private_info, cb, user_data) -\u003e\n\t\t\t\t\t\t\tlog.error(\"[LWJGL] cl_context_callback: {}\", memUTF8(errinfo))), NULL, errcode_ret);\n\t\t\t\t\t\tcheckCLError(errcode_ret);\n\n\t\t\t\t\t\tthis.device \u003d device;\n\t\t\t\t\t\tthis.context \u003d context;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"error checking device\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex)\n\t\t\t{\n\t\t\t\tlog.error(\"error checking platform\", ex);\n\t\t\t}\n\t\t}\n\n\t\tthrow new RuntimeException(\"Unable to find compute platform\");\n\t}\n\n\tprivate void initContextMacOS(AWTContext awtContext, MemoryStack stack)\n\t{\n\t\tPointerBuffer ctxProps \u003d stack.mallocPointer(3);\n\t\tctxProps\n\t\t\t.put(APPLEGLSharing.CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE)\n\t\t\t.put(awtContext.getCGLShareGroup())\n\t\t\t.put(0)\n\t\t\t.flip();\n\n\t\tIntBuffer errcode_ret \u003d stack.callocInt(1);\n\t\tvar devices \u003d stack.mallocPointer(0);\n\t\tlong context \u003d clCreateContext(ctxProps, devices, CLContextCallback.create((errinfo, private_info, cb, user_data) -\u003e\n\t\t\tlog.error(\"[LWJGL] cl_context_callback: {}\", memUTF8(errinfo))), NULL, errcode_ret);\n\t\tcheckCLError(errcode_ret);\n\n\t\tvar deviceBuf \u003d stack.mallocPointer(1);\n\t\tcheckCLError(clGetGLContextInfoAPPLE(context, awtContext.getGLContext(), CL_CGL_DEVICE_FOR_CURRENT_VIRTUAL_SCREEN_APPLE, deviceBuf, null));\n\t\tlong device \u003d deviceBuf.get(0);\n\n\t\tlog.debug(\"Got macOS CLGL compute device {}\", device);\n\t\tthis.context \u003d context;\n\t\tthis.device \u003d device;\n\t}\n\n\tprivate void ensureMinWorkGroupSize()\n\t{\n\t\tlong[] maxWorkGroupSize \u003d new long[1];\n\t\tCL12.clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_GROUP_SIZE, maxWorkGroupSize, null);\n\t\tlog.debug(\"Device CL_DEVICE_MAX_WORK_GROUP_SIZE: {}\", maxWorkGroupSize[0]);\n\n\t\tif (maxWorkGroupSize[0] \u003c MIN_WORK_GROUP_SIZE)\n\t\t{\n\t\t\tthrow new RuntimeException(\"Compute device does not support min work group size \" + MIN_WORK_GROUP_SIZE);\n\t\t}\n\n\t\t// Largest power of 2 less than or equal to maxWorkGroupSize\n\t\tint groupSize \u003d 0x80000000 \u003e\u003e\u003e Integer.numberOfLeadingZeros((int) maxWorkGroupSize[0]);\n\t\tlargeFaceCount \u003d LARGE_SIZE / (Math.min(groupSize, LARGE_SIZE));\n\t\tsmallFaceCount \u003d SMALL_SIZE / (Math.min(groupSize, SMALL_SIZE));\n\n\t\tlog.debug(\"Face counts: small: {}, large: {}\", smallFaceCount, largeFaceCount);\n\t}\n\n\tprivate void initQueue()\n\t{\n\t\tlong[] l \u003d new long[1];\n\t\tCL12.clGetDeviceInfo(device, CL_DEVICE_QUEUE_PROPERTIES, l, null);\n\n\t\tcommandQueue \u003d CL12.clCreateCommandQueue(context, device, l[0] \u0026 CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, (int[]) null);\n\t\tlog.debug(\"Created command_queue {}, properties {}\", commandQueue, l[0] \u0026 CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE);\n\t}\n\n\tprivate long compileProgram(MemoryStack stack, String programSource)\n\t{\n\t\tlog.trace(\"Compiling program:\\n {}\", programSource);\n\t\tIntBuffer errcode_ret \u003d stack.callocInt(1);\n\t\tlong program \u003d CL12.clCreateProgramWithSource(context, programSource, errcode_ret);\n\t\tcheckCLError(errcode_ret);\n\n\t\tint err \u003d CL12.clBuildProgram(program, device, \"\", null, 0);\n\t\tif (err !\u003d CL_SUCCESS)\n\t\t{\n\t\t\tString errstr \u003d getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG);\n\t\t\tthrow new RuntimeException(errstr);\n\t\t}\n\n\t\tlog.debug(\"Build status: {}\", getProgramBuildInfoInt(program, device, CL_PROGRAM_BUILD_STATUS));\n\t\tlog.debug(\"Binary type: {}\", getProgramBuildInfoInt(program, device, CL_PROGRAM_BINARY_TYPE));\n\t\tlog.debug(\"Build options: {}\", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_OPTIONS));\n\t\tlog.debug(\"Build log: {}\", getProgramBuildInfoStringASCII(program, device, CL_PROGRAM_BUILD_LOG));\n\t\treturn program;\n\t}\n\n\tprivate long getKernel(MemoryStack stack, long program, String kernelName)\n\t{\n\t\tIntBuffer errcode_ret \u003d stack.callocInt(1);\n\t\tlong kernel \u003d CL12.clCreateKernel(program, kernelName, errcode_ret);\n\t\tcheckCLError(errcode_ret);\n\t\tlog.debug(\"Loaded kernel {} for program {}\", kernelName, program);\n\t\treturn kernel;\n\t}\n\n\tprivate void compilePrograms(MemoryStack stack)\n\t{\n\t\tTemplate templateSmall \u003d new Template()\n\t\t\t.addInclude(OpenCLManager.class)\n\t\t\t.add(key -\u003e key.equals(\"FACE_COUNT\") ? (\"#define FACE_COUNT \" + smallFaceCount) : null);\n\t\tTemplate templateLarge \u003d new Template()\n\t\t\t.addInclude(OpenCLManager.class)\n\t\t\t.add(key -\u003e key.equals(\"FACE_COUNT\") ? (\"#define FACE_COUNT \" + largeFaceCount) : null);\n\n\t\tString unordered \u003d new Template()\n\t\t\t.addInclude(OpenCLManager.class)\n\t\t\t.load(\"comp_unordered.cl\");\n\t\tString small \u003d templateSmall.load(\"comp.cl\");\n\t\tString large \u003d templateLarge.load(\"comp.cl\");\n\n\t\tprogramUnordered \u003d compileProgram(stack, unordered);\n\t\tprogramSmall \u003d compileProgram(stack, small);\n\t\tprogramLarge \u003d compileProgram(stack, large);\n\n\t\tkernelUnordered \u003d getKernel(stack, programUnordered, KERNEL_NAME_UNORDERED);\n\t\tkernelSmall \u003d getKernel(stack, programSmall, KERNEL_NAME_LARGE);\n\t\tkernelLarge \u003d getKernel(stack, programLarge, KERNEL_NAME_LARGE);\n\t}\n\n\tvoid uploadTileHeights(Scene scene)\n\t{\n\t\tif (tileHeightImage !\u003d 0L)\n\t\t{\n\t\t\tCL12.clReleaseMemObject(tileHeightImage);\n\t\t\ttileHeightImage \u003d 0L;\n\t\t}\n\n\t\tfinal int TILEHEIGHT_BUFFER_SIZE \u003d Constants.MAX_Z * Constants.EXTENDED_SCENE_SIZE * Constants.EXTENDED_SCENE_SIZE * Short.BYTES;\n\t\tShortBuffer tileBuffer \u003d MemoryUtil.memAllocShort(TILEHEIGHT_BUFFER_SIZE);\n\t\tint[][][] tileHeights \u003d scene.getTileHeights();\n\t\tfor (int z \u003d 0; z \u003c Constants.MAX_Z; ++z)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c Constants.EXTENDED_SCENE_SIZE; ++y)\n\t\t\t{\n\t\t\t\tfor (int x \u003d 0; x \u003c Constants.EXTENDED_SCENE_SIZE; ++x)\n\t\t\t\t{\n\t\t\t\t\tint h \u003d tileHeights[z][x][y];\n\t\t\t\t\tassert (h \u0026 0b111) \u003d\u003d 0;\n\t\t\t\t\th \u003e\u003e\u003d 3;\n\t\t\t\t\ttileBuffer.put((short) h);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttileBuffer.flip();\n\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tCLImageFormat imageFormat \u003d CLImageFormat.calloc(stack);\n\t\t\timageFormat.image_channel_order(CL12.CL_R);\n\t\t\timageFormat.image_channel_data_type(CL12.CL_SIGNED_INT16);\n\n\t\t\tIntBuffer errcode_ret \u003d stack.callocInt(1);\n\t\t\ttileHeightImage \u003d CL12.clCreateImage3D(context, CL12.CL_MEM_READ_ONLY | CL12.CL_MEM_COPY_HOST_PTR, imageFormat,\n\t\t\t\tConstants.EXTENDED_SCENE_SIZE, Constants.EXTENDED_SCENE_SIZE, Constants.MAX_Z,\n\t\t\t\t0L, 0L,\n\t\t\t\ttileBuffer,\n\t\t\t\terrcode_ret);\n\t\t\tcheckCLError(errcode_ret);\n\t\t}\n\n\t\tMemoryUtil.memFree(tileBuffer);\n\t}\n\n\tvoid compute(int unorderedModels, int smallModels, int largeModels,\n\t\tGLBuffer sceneVertexBuffer,\n\t\tGLBuffer sceneUvBuffer,\n\t\tGLBuffer vertexBuffer,\n\t\tGLBuffer uvBuffer,\n\t\tGLBuffer unorderedBuffer,\n\t\tGLBuffer smallBuffer,\n\t\tGLBuffer largeBuffer,\n\t\tGLBuffer outVertexBuffer,\n\t\tGLBuffer outUvBuffer,\n\t\tGLBuffer uniformBuffer\n\t)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tPointerBuffer glBuffers \u003d stack.mallocPointer(10);\n\t\t\tglBuffers.put(sceneVertexBuffer.clBuffer);\n\t\t\tglBuffers.put(sceneUvBuffer.clBuffer);\n\t\t\tglBuffers.put(unorderedBuffer.clBuffer);\n\t\t\tglBuffers.put(smallBuffer.clBuffer);\n\t\t\tglBuffers.put(largeBuffer.clBuffer);\n\t\t\tglBuffers.put(vertexBuffer.clBuffer);\n\t\t\tglBuffers.put(uvBuffer.clBuffer);\n\t\t\tglBuffers.put(outVertexBuffer.clBuffer);\n\t\t\tglBuffers.put(outUvBuffer.clBuffer);\n\t\t\tglBuffers.put(uniformBuffer.clBuffer);\n\t\t\tglBuffers.flip();\n\n\t\t\tPointerBuffer acquireEvent \u003d stack.mallocPointer(1);\n\t\t\tCL10GL.clEnqueueAcquireGLObjects(commandQueue, glBuffers, null, acquireEvent);\n\n\t\t\tvar computeEvents \u003d stack.mallocPointer(3);\n\t\t\tif (unorderedModels \u003e 0)\n\t\t\t{\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 0, unorderedBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 1, sceneVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 2, vertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 3, sceneUvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 4, uvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 5, outVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelUnordered, 6, outUvBuffer.clBuffer);\n\n\t\t\t\t// queue compute call after acquireGLBuffers\n\t\t\t\tCL12.clEnqueueNDRangeKernel(commandQueue, kernelUnordered, 1, null,\n\t\t\t\t\tstack.pointers(unorderedModels * 6L), stack.pointers(6),\n\t\t\t\t\tacquireEvent, computeEvents);\n\t\t\t\tcomputeEvents.position(computeEvents.position() + 1);\n\t\t\t}\n\n\t\t\tif (smallModels \u003e 0)\n\t\t\t{\n\t\t\t\tCL12.clSetKernelArg(kernelSmall, 0, (SHARED_SIZE + SMALL_SIZE) * Integer.BYTES);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 1, smallBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 2, sceneVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 3, vertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 4, sceneUvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 5, uvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 6, outVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 7, outUvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelSmall, 8, uniformBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1l(kernelSmall, 9, tileHeightImage);\n\n\t\t\t\tCL12.clEnqueueNDRangeKernel(commandQueue, kernelSmall, 1, null,\n\t\t\t\t\tstack.pointers(smallModels * (SMALL_SIZE / smallFaceCount)), stack.pointers(SMALL_SIZE / smallFaceCount),\n\t\t\t\t\tacquireEvent, computeEvents);\n\t\t\t\tcomputeEvents.position(computeEvents.position() + 1);\n\t\t\t}\n\n\t\t\tif (largeModels \u003e 0)\n\t\t\t{\n\t\t\t\tCL12.clSetKernelArg(kernelLarge, 0, (SHARED_SIZE + LARGE_SIZE) * Integer.BYTES);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 1, largeBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 2, sceneVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 3, vertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 4, sceneUvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 5, uvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 6, outVertexBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 7, outUvBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1p(kernelLarge, 8, uniformBuffer.clBuffer);\n\t\t\t\tCL12.clSetKernelArg1l(kernelLarge, 9, tileHeightImage);\n\n\t\t\t\tCL12.clEnqueueNDRangeKernel(commandQueue, kernelLarge, 1, null,\n\t\t\t\t\tstack.pointers(largeModels * (LARGE_SIZE / largeFaceCount)), stack.pointers(LARGE_SIZE / largeFaceCount),\n\t\t\t\t\tacquireEvent, computeEvents);\n\t\t\t\tcomputeEvents.position(computeEvents.position() + 1);\n\t\t\t}\n\n\t\t\tif (computeEvents.position() \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tCL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, null, null);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcomputeEvents.flip();\n\t\t\t\tCL10GL.clEnqueueReleaseGLObjects(commandQueue, glBuffers, computeEvents, null);\n\t\t\t}\n//\n//\t\t\tlong ptr \u003d acquireEvent.get(0);\n//\t\t\tif (ptr !\u003d 0L)\n//\t\t\t{\n//\t\t\t\tCL12.clReleaseEvent(ptr);\n//\t\t\t}\n//\n//\t\t\tfor (int i \u003d 0; i \u003c computeEvents.limit(); ++i)\n//\t\t\t{\n//\t\t\t\tptr \u003d computeEvents.get(i);\n//\t\t\t\tif (ptr !\u003d 0L)\n//\t\t\t\t{\n//\t\t\t\t\tCL12.clReleaseEvent(ptr);\n//\t\t\t\t}\n//\t\t\t}\n\t\t}\n\t}\n\n\tvoid finish()\n\t{\n\t\tCL12.clFinish(commandQueue);\n\t}\n\n\tprivate static String getPlatformInfoStringUTF8(long cl_platform_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tPointerBuffer pp \u003d stack.mallocPointer(1);\n\t\t\tcheckCLError(clGetPlatformInfo(cl_platform_id, param_name, (ByteBuffer) null, pp));\n\t\t\tint bytes \u003d (int) pp.get(0);\n\n\t\t\tByteBuffer buffer \u003d stack.malloc(bytes);\n\t\t\tcheckCLError(clGetPlatformInfo(cl_platform_id, param_name, buffer, null));\n\n\t\t\treturn memUTF8(buffer, bytes - 1);\n\t\t}\n\t}\n\n\tprivate static long getDeviceInfoLong(long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tLongBuffer pl \u003d stack.mallocLong(1);\n\t\t\tcheckCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));\n\t\t\treturn pl.get(0);\n\t\t}\n\t}\n\n\tprivate static int getDeviceInfoInt(long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tIntBuffer pl \u003d stack.mallocInt(1);\n\t\t\tcheckCLError(clGetDeviceInfo(cl_device_id, param_name, pl, null));\n\t\t\treturn pl.get(0);\n\t\t}\n\t}\n\n\tprivate static long getDeviceInfoPointer(long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tPointerBuffer pp \u003d stack.mallocPointer(1);\n\t\t\tcheckCLError(clGetDeviceInfo(cl_device_id, param_name, pp, null));\n\t\t\treturn pp.get(0);\n\t\t}\n\t}\n\n\tprivate static String getDeviceInfoStringUTF8(long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tPointerBuffer pp \u003d stack.mallocPointer(1);\n\t\t\tcheckCLError(clGetDeviceInfo(cl_device_id, param_name, (ByteBuffer) null, pp));\n\t\t\tint bytes \u003d (int) pp.get(0);\n\n\t\t\tByteBuffer buffer \u003d stack.malloc(bytes);\n\t\t\tcheckCLError(clGetDeviceInfo(cl_device_id, param_name, buffer, null));\n\n\t\t\treturn memUTF8(buffer, bytes - 1);\n\t\t}\n\t}\n\n\tprivate static int getProgramBuildInfoInt(long cl_program_id, long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tIntBuffer pl \u003d stack.mallocInt(1);\n\t\t\tcheckCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, pl, null));\n\t\t\treturn pl.get(0);\n\t\t}\n\t}\n\n\tprivate static String getProgramBuildInfoStringASCII(long cl_program_id, long cl_device_id, int param_name)\n\t{\n\t\ttry (MemoryStack stack \u003d MemoryStack.stackPush())\n\t\t{\n\t\t\tPointerBuffer pp \u003d stack.mallocPointer(1);\n\t\t\tcheckCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, (ByteBuffer) null, pp));\n\t\t\tint bytes \u003d (int) pp.get(0);\n\n\t\t\tByteBuffer buffer \u003d stack.malloc(bytes);\n\t\t\tcheckCLError(clGetProgramBuildInfo(cl_program_id, cl_device_id, param_name, buffer, null));\n\n\t\t\treturn memASCII(buffer, bytes - 1);\n\t\t}\n\t}\n\n\tprivate static void checkCLError(IntBuffer errcode)\n\t{\n\t\tcheckCLError(errcode.get(errcode.position()));\n\t}\n\n\tprivate static void checkCLError(int errcode)\n\t{\n\t\tif (errcode !\u003d CL_SUCCESS)\n\t\t{\n\t\t\tthrow new RuntimeException(String.format(\"OpenCL error [%d]\", errcode));\n\t\t}\n\t}\n}","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\OpenCLManager.java"},{"fileName":"Region.java","content":"/*\n * Copyright (c) 2023, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.regions;\n\nclass Region\n{\n\tint id;\n\tint cx1;\n\tint cy1;\n\tint cx2;\n\tint cy2;\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\regions\\Region.java"},{"fileName":"Regions.java","content":"/*\n * Copyright (c) 2023, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.regions;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport lombok.AccessLevel;\nimport lombok.Getter;\n\npublic class Regions\n{\n\tprivate static final Pattern PATTERN \u003d Pattern.compile(\"^[ \\\\t]*(?\u003cexpr\u003e\" +\n\t\t\"//.*$|\" + // //comment\n\t\t\"n|\" +\n\t\t\"m[ \\\\t]*(?\u003cmrx\u003e[0-9]+)[ \\\\t]+(?\u003cmry\u003e[0-9]+)|\" + // m \u003crx\u003e \u003cry\u003e\n\t\t\"r[ \\\\t]*(?\u003crx\u003e[0-9]+)[ \\\\t]+(?\u003cry\u003e[0-9]+)|\" + // r \u003crx\u003e \u003cry\u003e\n\t\t\"R[ \\\\t]*(?\u003crx1\u003e[0-9]+)[ \\\\t]+(?\u003cry1\u003e[0-9]+)[ \\\\t]+(?\u003crx2\u003e[0-9]+)[ \\\\t]+(?\u003cry2\u003e[0-9]+)|\" + // R \u003crx1\u003e \u003cry1\u003e \u003crx2\u003e \u003cry2\u003e\n\t\t\"c[ \\\\t]*(?\u003ccx\u003e[0-9-]+)[ \\\\t]+(?\u003ccy\u003e[0-9-]+)|\" + // c \u003ccx\u003e \u003ccy\u003e\n\t\t\"C[ \\\\t]*(?\u003ccx1\u003e[0-9-]+)[ \\\\t]+(?\u003ccy1\u003e[0-9-]+)[ \\\\t]+(?\u003ccx2\u003e[0-9-]+)[ \\\\t]+(?\u003ccy2\u003e[0-9-]+)|\" + // C \u003ccx1\u003e \u003ccy1\u003e \u003ccx2\u003e \u003ccy2\u003e\n\t\t\")[ \\\\t]*\");\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final List\u003cRegion\u003e regions \u003d new ArrayList\u003c\u003e();\n\n\tprivate static final int REGION_MAP_SIZE \u003d 70 * 200 / 8;\n\tprivate final byte[] regionMap \u003d new byte[REGION_MAP_SIZE];\n\n\tprivate Region last;\n\n\tpublic Regions(InputStream is, String filename) throws IOException\n\t{\n\t\tthis(new InputStreamReader(is, StandardCharsets.UTF_8), filename);\n\t}\n\n\tpublic Regions(Reader reader, String filename) throws IOException\n\t{\n\t\tBufferedReader br \u003d new BufferedReader(reader);\n\t\tint lineNo \u003d 1;\n\t\tint rx1 \u003d 0, ry1 \u003d 0, rx2 \u003d 0, ry2 \u003d 0;\n\t\tint rid \u003d 0;\n\t\tMatcher m \u003d PATTERN.matcher(\"\");\n\t\tfor (String line; (line \u003d br.readLine()) !\u003d null; lineNo++)\n\t\t{\n\t\t\tm.reset(line);\n\t\t\tint end \u003d 0;\n\t\t\twhile (end \u003c line.length())\n\t\t\t{\n\t\t\t\tm.region(end, line.length());\n\t\t\t\tif (!m.find())\n\t\t\t\t{\n\t\t\t\t\tthrow new IllegalArgumentException(\"Unexpected: \\\"\" + line.substring(end) + \"\\\" (\" + filename + \":\" + lineNo + \")\");\n\t\t\t\t}\n\t\t\t\tend \u003d m.end();\n\n\t\t\t\tString expr \u003d m.group(\"expr\");\n\t\t\t\tif (expr \u003d\u003d null || expr.length() \u003c\u003d 0 || expr.startsWith(\"//\"))\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tchar cha \u003d expr.charAt(0);\n\t\t\t\tswitch (cha)\n\t\t\t\t{\n\t\t\t\t\tcase \u0027n\u0027:\n\t\t\t\t\t\trid++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \u0027m\u0027:\n\t\t\t\t\t\trx2 \u003d rx1 \u003d Integer.parseInt(m.group(\"mrx\"));\n\t\t\t\t\t\try2 \u003d ry1 \u003d Integer.parseInt(m.group(\"mry\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \u0027r\u0027:\n\t\t\t\t\tcase \u0027R\u0027:\n\t\t\t\t\t\tif (cha \u003d\u003d \u0027r\u0027)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trx2 \u003d rx1 \u003d Integer.parseInt(m.group(\"rx\"));\n\t\t\t\t\t\t\try2 \u003d ry1 \u003d Integer.parseInt(m.group(\"ry\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trx1 \u003d Integer.parseInt(m.group(\"rx1\"));\n\t\t\t\t\t\t\try1 \u003d Integer.parseInt(m.group(\"ry1\"));\n\t\t\t\t\t\t\trx2 \u003d Integer.parseInt(m.group(\"rx2\"));\n\t\t\t\t\t\t\try2 \u003d Integer.parseInt(m.group(\"ry2\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// fallthrough\n\t\t\t\t\tcase \u0027c\u0027:\n\t\t\t\t\tcase \u0027C\u0027:\n\t\t\t\t\t\tint cx1 \u003d rx1 * 8;\n\t\t\t\t\t\tint cy1 \u003d ry1 * 8;\n\t\t\t\t\t\tint cx2 \u003d rx2 * 8 + 7;\n\t\t\t\t\t\tint cy2 \u003d ry2 * 8 + 7;\n\t\t\t\t\t\tif (cha \u003d\u003d \u0027c\u0027)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcx2 \u003d cx1 \u003d cx1 + Integer.parseInt(m.group(\"cx\"));\n\t\t\t\t\t\t\tcy2 \u003d cy1 \u003d cy1 + Integer.parseInt(m.group(\"cy\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (cha \u003d\u003d \u0027C\u0027)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcx2 \u003d cx1 + Integer.parseInt(m.group(\"cx2\"));\n\t\t\t\t\t\t\tcy2 \u003d cy1 + Integer.parseInt(m.group(\"cy2\"));\n\t\t\t\t\t\t\tcx1 \u003d cx1 + Integer.parseInt(m.group(\"cx1\"));\n\t\t\t\t\t\t\tcy1 \u003d cy1 + Integer.parseInt(m.group(\"cy1\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (cx1 \u003e cx2 || cy1 \u003e cy2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new IllegalArgumentException(\"First coord must be before second (\" + filename + \":\" + lineNo + \")\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tRegion r \u003d new Region();\n\t\t\t\t\t\tr.id \u003d rid;\n\t\t\t\t\t\tr.cx1 \u003d cx1;\n\t\t\t\t\t\tr.cy1 \u003d cy1;\n\t\t\t\t\t\tr.cx2 \u003d cx2;\n\t\t\t\t\t\tr.cy2 \u003d cy2;\n\t\t\t\t\t\tregions.add(r);\n\n\t\t\t\t\t\t// mark the affected regions as in uses\n\t\t\t\t\t\tfor (int rx \u003d rx1; rx \u003c\u003d rx2; ++rx)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int ry \u003d ry1; ry \u003c\u003d ry2; ++ry)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmarkRegion(rx, ry);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic int getRegionId(int cx, int cy)\n\t{\n\t\tint rx \u003d cx / 8;\n\t\tint ry \u003d cy / 8;\n\t\tif (!isMarked(rx, ry))\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (last !\u003d null \u0026\u0026 intersects(cx, cy, last))\n\t\t{\n\t\t\treturn last.id;\n\t\t}\n\n\t\tfor (Region r : regions)\n\t\t{\n\t\t\tif (intersects(cx, cy, r))\n\t\t\t{\n\t\t\t\tlast \u003d r;\n\t\t\t\treturn r.id;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprivate static boolean intersects(int cx, int cy, Region r)\n\t{\n\t\treturn cx \u003e\u003d r.cx1 \u0026\u0026 cy \u003e\u003d r.cy1 \u0026\u0026 cx \u003c\u003d r.cx2 \u0026\u0026 cy \u003c\u003d r.cy2;\n\t}\n\n\tprivate void markRegion(int rx, int ry)\n\t{\n\t\tint id \u003d (rx \u003c\u003c 8) | ry;\n\t\tint idx \u003d id / 8;\n\t\tif (idx \u003c regionMap.length)\n\t\t{\n\t\t\tregionMap[idx] |\u003d 1 \u003c\u003c (idx % 8);\n\t\t}\n\t}\n\n\tprivate boolean isMarked(int rx, int ry)\n\t{\n\t\tint id \u003d (rx \u003c\u003c 8) | ry;\n\t\tint idx \u003d id / 8;\n\t\tif (idx \u003c regionMap.length)\n\t\t{\n\t\t\treturn (regionMap[idx] \u0026 (1 \u003c\u003c (idx % 8))) !\u003d 0;\n\t\t}\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\regions\\Regions.java"},{"fileName":"SceneUploader.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport com.google.common.base.Stopwatch;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.DecorativeObject;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.GroundObject;\nimport net.runelite.api.Model;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.Projection;\nimport net.runelite.api.Renderable;\nimport net.runelite.api.Scene;\nimport net.runelite.api.SceneTileModel;\nimport net.runelite.api.SceneTilePaint;\nimport net.runelite.api.Tile;\nimport net.runelite.api.WallObject;\nimport info.sigterm.plugins.gpulegacy.regions.Regions;\n\n@Singleton\n@Slf4j\nclass SceneUploader\n{\n\tprivate final Client client;\n\tprivate final GpuPluginConfig gpuConfig;\n\n\tprivate final Regions regions;\n\n\tint sceneId \u003d (int) System.nanoTime();\n\tprivate int offset;\n\tprivate int uvoffset;\n\tprivate int uniqueModels;\n\n\t@Inject\n\tSceneUploader(\n\t\tClient client,\n\t\tGpuPluginConfig config\n\t)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.gpuConfig \u003d config;\n\n\t\ttry (var in \u003d SceneUploader.class.getResourceAsStream(\"regions/regions.txt\"))\n\t\t{\n\t\t\tregions \u003d new Regions(in, \"regions.txt\");\n\t\t}\n\t\tcatch (IOException ex)\n\t\t{\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}\n\n\tvoid upload(Scene scene, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\t++sceneId;\n\t\toffset \u003d 0;\n\t\tuvoffset \u003d 0;\n\t\tuniqueModels \u003d 0;\n\t\tvertexBuffer.clear();\n\t\tuvBuffer.clear();\n\n\t\tStopwatch stopwatch \u003d Stopwatch.createStarted();\n\t\tprepare(scene);\n\t\tstopwatch.stop();\n\t\tlog.debug(\"Scene preparation time: {}\", stopwatch);\n\n\t\tstopwatch \u003d Stopwatch.createStarted();\n\t\tfor (int z \u003d 0; z \u003c Constants.MAX_Z; ++z)\n\t\t{\n\t\t\tfor (int x \u003d 0; x \u003c Constants.EXTENDED_SCENE_SIZE; ++x)\n\t\t\t{\n\t\t\t\tfor (int y \u003d 0; y \u003c Constants.EXTENDED_SCENE_SIZE; ++y)\n\t\t\t\t{\n\t\t\t\t\tTile tile \u003d scene.getExtendedTiles()[z][x][y];\n\t\t\t\t\tif (tile !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tupload(scene, tile, vertexBuffer, uvBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstopwatch.stop();\n\t\tlog.debug(\"Scene upload time: {} unique models: {} length: {}KB\", stopwatch, uniqueModels, (offset * 16) / 1024);\n\t}\n\n\tprivate void upload(Scene scene, Tile tile, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\tTile bridge \u003d tile.getBridge();\n\t\tif (bridge !\u003d null)\n\t\t{\n\t\t\tupload(scene, bridge, vertexBuffer, uvBuffer);\n\t\t}\n\n\t\tSceneTilePaint sceneTilePaint \u003d tile.getSceneTilePaint();\n\t\tif (sceneTilePaint !\u003d null)\n\t\t{\n\t\t\tsceneTilePaint.setBufferOffset(offset);\n\t\t\tif (sceneTilePaint.getTexture() !\u003d -1)\n\t\t\t{\n\t\t\t\tsceneTilePaint.setUvBufferOffset(uvoffset);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsceneTilePaint.setUvBufferOffset(-1);\n\t\t\t}\n\t\t\tPoint tilePoint \u003d tile.getSceneLocation();\n\t\t\tint len \u003d upload(scene, sceneTilePaint,\n\t\t\t\ttile.getRenderLevel(), tilePoint.getX(), tilePoint.getY(),\n\t\t\t\tvertexBuffer, uvBuffer,\n\t\t\t\t0, 0, false);\n\t\t\tsceneTilePaint.setBufferLen(len);\n\t\t\toffset +\u003d len;\n\t\t\tif (sceneTilePaint.getTexture() !\u003d -1)\n\t\t\t{\n\t\t\t\tuvoffset +\u003d len;\n\t\t\t}\n\t\t}\n\n\t\tSceneTileModel sceneTileModel \u003d tile.getSceneTileModel();\n\t\tif (sceneTileModel !\u003d null)\n\t\t{\n\t\t\tsceneTileModel.setBufferOffset(offset);\n\t\t\tif (sceneTileModel.getTriangleTextureId() !\u003d null)\n\t\t\t{\n\t\t\t\tsceneTileModel.setUvBufferOffset(uvoffset);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsceneTileModel.setUvBufferOffset(-1);\n\t\t\t}\n\t\t\tPoint tilePoint \u003d tile.getSceneLocation();\n\t\t\tint len \u003d upload(sceneTileModel,\n\t\t\t\ttilePoint.getX() \u003c\u003c Perspective.LOCAL_COORD_BITS, tilePoint.getY() \u003c\u003c Perspective.LOCAL_COORD_BITS,\n\t\t\t\tvertexBuffer, uvBuffer, false);\n\t\t\tsceneTileModel.setBufferLen(len);\n\t\t\toffset +\u003d len;\n\t\t\tif (sceneTileModel.getTriangleTextureId() !\u003d null)\n\t\t\t{\n\t\t\t\tuvoffset +\u003d len;\n\t\t\t}\n\t\t}\n\n\t\tWallObject wallObject \u003d tile.getWallObject();\n\t\tif (wallObject !\u003d null)\n\t\t{\n\t\t\tRenderable renderable1 \u003d wallObject.getRenderable1();\n\t\t\tif (renderable1 instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) renderable1, vertexBuffer, uvBuffer);\n\t\t\t}\n\n\t\t\tRenderable renderable2 \u003d wallObject.getRenderable2();\n\t\t\tif (renderable2 instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) renderable2, vertexBuffer, uvBuffer);\n\t\t\t}\n\t\t}\n\n\t\tGroundObject groundObject \u003d tile.getGroundObject();\n\t\tif (groundObject !\u003d null)\n\t\t{\n\t\t\tRenderable renderable \u003d groundObject.getRenderable();\n\t\t\tif (renderable instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) renderable, vertexBuffer, uvBuffer);\n\t\t\t}\n\t\t}\n\n\t\tDecorativeObject decorativeObject \u003d tile.getDecorativeObject();\n\t\tif (decorativeObject !\u003d null)\n\t\t{\n\t\t\tRenderable renderable \u003d decorativeObject.getRenderable();\n\t\t\tif (renderable instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) renderable, vertexBuffer, uvBuffer);\n\t\t\t}\n\n\t\t\tRenderable renderable2 \u003d decorativeObject.getRenderable2();\n\t\t\tif (renderable2 instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) renderable2, vertexBuffer, uvBuffer);\n\t\t\t}\n\t\t}\n\n\t\tGameObject[] gameObjects \u003d tile.getGameObjects();\n\t\tfor (GameObject gameObject : gameObjects)\n\t\t{\n\t\t\tif (gameObject \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRenderable renderable \u003d gameObject.getRenderable();\n\t\t\tif (renderable instanceof Model)\n\t\t\t{\n\t\t\t\tuploadSceneModel((Model) gameObject.getRenderable(), vertexBuffer, uvBuffer);\n\t\t\t}\n\t\t}\n\t}\n\n\tint upload(Scene scene, SceneTilePaint tile, int tileZ, int tileX, int tileY, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer,\n\t\t\t   int lx, int lz, boolean stream)\n\t{\n\t\ttileX +\u003d GpuPlugin.SCENE_OFFSET;\n\t\ttileY +\u003d GpuPlugin.SCENE_OFFSET;\n\n\t\tfinal int[][][] tileHeights \u003d scene.getTileHeights();\n\t\tfinal int swHeight \u003d tileHeights[tileZ][tileX][tileY];\n\t\tfinal int seHeight \u003d tileHeights[tileZ][tileX + 1][tileY];\n\t\tfinal int neHeight \u003d tileHeights[tileZ][tileX + 1][tileY + 1];\n\t\tfinal int nwHeight \u003d tileHeights[tileZ][tileX][tileY + 1];\n\n\t\tfinal int swColor \u003d tile.getSwColor();\n\t\tfinal int seColor \u003d tile.getSeColor();\n\t\tfinal int neColor \u003d tile.getNeColor();\n\t\tfinal int nwColor \u003d tile.getNwColor();\n\n\t\tif (neColor \u003d\u003d 12345678)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvertexBuffer.ensureCapacity(24);\n\t\tuvBuffer.ensureCapacity(24);\n\n\t\t// 0,0\n\t\tfinal int lx0 \u003d lx;\n\t\tfinal int ly0 \u003d swHeight;\n\t\tfinal int lz0 \u003d lz;\n\t\tfinal int hsl0 \u003d swColor;\n\n\t\t// 1,0\n\t\tfinal int lx1 \u003d lx + Perspective.LOCAL_TILE_SIZE;\n\t\tfinal int ly1 \u003d seHeight;\n\t\tfinal int lz1 \u003d lz;\n\t\tfinal int hsl1 \u003d seColor;\n\n\t\t// 1,1\n\t\tfinal int lx2 \u003d lx + Perspective.LOCAL_TILE_SIZE;\n\t\tfinal int ly2 \u003d neHeight;\n\t\tfinal int lz2 \u003d lz + Perspective.LOCAL_TILE_SIZE;\n\t\tfinal int hsl2 \u003d neColor;\n\n\t\t// 0,1\n\t\tfinal int lx3 \u003d lx;\n\t\tfinal int ly3 \u003d nwHeight;\n\t\tfinal int lz3 \u003d lz + Perspective.LOCAL_TILE_SIZE;\n\t\tfinal int hsl3 \u003d nwColor;\n\n\t\tvertexBuffer.put((float) lx2, ly2, lz2, hsl2);\n\t\tvertexBuffer.put((float) lx3, ly3, lz3, hsl3);\n\t\tvertexBuffer.put((float) lx1, ly1, lz1, hsl1);\n\n\t\tvertexBuffer.put((float) lx0, ly0, lz0, hsl0);\n\t\tvertexBuffer.put((float) lx1, ly1, lz1, hsl1);\n\t\tvertexBuffer.put((float) lx3, ly3, lz3, hsl3);\n\n\t\tif (stream || tile.getTexture() !\u003d -1)\n\t\t{\n\t\t\tint tex \u003d tile.getTexture() + 1;\n\t\t\tif (tile.isFlat())\n\t\t\t{\n\t\t\t\tuvBuffer.put(tex, lx0, ly0, lz0);\n\t\t\t\tuvBuffer.put(tex, lx1, ly1, lz1);\n\t\t\t\tuvBuffer.put(tex, lx3, ly3, lz3);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tuvBuffer.put(tex, lx2, ly2, lz2);\n\t\t\t\tuvBuffer.put(tex, lx3, ly3, lz3);\n\t\t\t\tuvBuffer.put(tex, lx1, ly1, lz1);\n\t\t\t}\n\n\t\t\tuvBuffer.put(tex, lx0, ly0, lz0);\n\t\t\tuvBuffer.put(tex, lx1, ly1, lz1);\n\t\t\tuvBuffer.put(tex, lx3, ly3, lz3);\n\t\t}\n\n\t\treturn 6;\n\t}\n\n\tint upload(SceneTileModel sceneTileModel, int lx, int lz,\n\t\t\t   GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer, boolean stream)\n\t{\n\t\tfinal int[] faceX \u003d sceneTileModel.getFaceX();\n\t\tfinal int[] faceY \u003d sceneTileModel.getFaceY();\n\t\tfinal int[] faceZ \u003d sceneTileModel.getFaceZ();\n\n\t\tfinal int[] vertexX \u003d sceneTileModel.getVertexX();\n\t\tfinal int[] vertexY \u003d sceneTileModel.getVertexY();\n\t\tfinal int[] vertexZ \u003d sceneTileModel.getVertexZ();\n\n\t\tfinal int[] triangleColorA \u003d sceneTileModel.getTriangleColorA();\n\t\tfinal int[] triangleColorB \u003d sceneTileModel.getTriangleColorB();\n\t\tfinal int[] triangleColorC \u003d sceneTileModel.getTriangleColorC();\n\n\t\tfinal int[] triangleTextures \u003d sceneTileModel.getTriangleTextureId();\n\n\t\tfinal int faceCount \u003d faceX.length;\n\n\t\tvertexBuffer.ensureCapacity(faceCount * 12);\n\t\tuvBuffer.ensureCapacity(faceCount * 12);\n\n\t\tint cnt \u003d 0;\n\t\tfor (int i \u003d 0; i \u003c faceCount; ++i)\n\t\t{\n\t\t\tfinal int vertex0 \u003d faceX[i];\n\t\t\tfinal int vertex1 \u003d faceY[i];\n\t\t\tfinal int vertex2 \u003d faceZ[i];\n\n\t\t\tfinal int hsl0 \u003d triangleColorA[i];\n\t\t\tfinal int hsl1 \u003d triangleColorB[i];\n\t\t\tfinal int hsl2 \u003d triangleColorC[i];\n\n\t\t\tif (hsl0 \u003d\u003d 12345678)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcnt +\u003d 3;\n\n\t\t\t// vertexes are stored in scene local, convert to tile local\n\t\t\tint lx0 \u003d vertexX[vertex0] - lx;\n\t\t\tint ly0 \u003d vertexY[vertex0];\n\t\t\tint lz0 \u003d vertexZ[vertex0] - lz;\n\n\t\t\tint lx1 \u003d vertexX[vertex1] - lx;\n\t\t\tint ly1 \u003d vertexY[vertex1];\n\t\t\tint lz1 \u003d vertexZ[vertex1] - lz;\n\n\t\t\tint lx2 \u003d vertexX[vertex2] - lx;\n\t\t\tint ly2 \u003d vertexY[vertex2];\n\t\t\tint lz2 \u003d vertexZ[vertex2] - lz;\n\n\t\t\tvertexBuffer.put((float) lx0, ly0, lz0, hsl0);\n\t\t\tvertexBuffer.put((float) lx1, ly1, lz1, hsl1);\n\t\t\tvertexBuffer.put((float) lx2, ly2, lz2, hsl2);\n\n\t\t\tif (stream || triangleTextures !\u003d null)\n\t\t\t{\n\t\t\t\tif (triangleTextures !\u003d null \u0026\u0026 triangleTextures[i] !\u003d -1)\n\t\t\t\t{\n\t\t\t\t\tint tex \u003d triangleTextures[i] + 1;\n\t\t\t\t\tif (sceneTileModel.isFlat())\n\t\t\t\t\t{\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[0] - lx, vertexY[0], vertexZ[0] - lz);\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[1] - lx, vertexY[1], vertexZ[1] - lz);\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[3] - lx, vertexY[3], vertexZ[3] - lz);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[vertex0] - lx, vertexY[vertex0], vertexZ[vertex0] - lz);\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[vertex1] - lx, vertexY[vertex1], vertexZ[vertex1] - lz);\n\t\t\t\t\t\tuvBuffer.put(tex, vertexX[vertex2] - lx, vertexY[vertex2], vertexZ[vertex2] - lz);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn cnt;\n\t}\n\n\tprivate void uploadSceneModel(Model model, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\t// deduplicate hillskewed models\n\t\tif (model.getUnskewedModel() !\u003d null)\n\t\t{\n\t\t\tmodel \u003d model.getUnskewedModel();\n\t\t}\n\n\t\tif (model.getSceneId() \u003d\u003d sceneId)\n\t\t{\n\t\t\treturn; // model has already been uploaded\n\t\t}\n\n\t\tmodel.setBufferOffset(offset);\n\t\tif (model.getFaceTextures() !\u003d null)\n\t\t{\n\t\t\tmodel.setUvBufferOffset(uvoffset);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmodel.setUvBufferOffset(-1);\n\t\t}\n\t\tmodel.setSceneId(sceneId);\n\t\t++uniqueModels;\n\n\t\tint len \u003d pushModel(model, vertexBuffer, uvBuffer);\n\n\t\toffset +\u003d len;\n\t\tif (model.getFaceTextures() !\u003d null)\n\t\t{\n\t\t\tuvoffset +\u003d len;\n\t\t}\n\t}\n\n\tpublic int pushModel(Model model, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\tfinal int triangleCount \u003d Math.min(model.getFaceCount(), GpuPlugin.MAX_TRIANGLE);\n\n\t\tvertexBuffer.ensureCapacity(triangleCount * 12);\n\t\tuvBuffer.ensureCapacity(triangleCount * 12);\n\n\t\tfinal float[] vertexX \u003d model.getVerticesX();\n\t\tfinal float[] vertexY \u003d model.getVerticesY();\n\t\tfinal float[] vertexZ \u003d model.getVerticesZ();\n\n\t\tfinal int[] indices1 \u003d model.getFaceIndices1();\n\t\tfinal int[] indices2 \u003d model.getFaceIndices2();\n\t\tfinal int[] indices3 \u003d model.getFaceIndices3();\n\n\t\tfinal int[] color1s \u003d model.getFaceColors1();\n\t\tfinal int[] color2s \u003d model.getFaceColors2();\n\t\tfinal int[] color3s \u003d model.getFaceColors3();\n\n\t\tfinal short[] faceTextures \u003d model.getFaceTextures();\n\t\tfinal byte[] textureFaces \u003d model.getTextureFaces();\n\t\tfinal int[] texIndices1 \u003d model.getTexIndices1();\n\t\tfinal int[] texIndices2 \u003d model.getTexIndices2();\n\t\tfinal int[] texIndices3 \u003d model.getTexIndices3();\n\n\t\tfinal byte[] transparencies \u003d model.getFaceTransparencies();\n\t\tfinal byte[] facePriorities \u003d model.getFaceRenderPriorities();\n\n\t\tfinal byte overrideAmount \u003d model.getOverrideAmount();\n\t\tfinal byte overrideHue \u003d model.getOverrideHue();\n\t\tfinal byte overrideSat \u003d model.getOverrideSaturation();\n\t\tfinal byte overrideLum \u003d model.getOverrideLuminance();\n\n\t\tint len \u003d 0;\n\t\tfor (int face \u003d 0; face \u003c triangleCount; ++face)\n\t\t{\n\t\t\tint color1 \u003d color1s[face];\n\t\t\tint color2 \u003d color2s[face];\n\t\t\tint color3 \u003d color3s[face];\n\n\t\t\tif (color3 \u003d\u003d -1)\n\t\t\t{\n\t\t\t\tcolor2 \u003d color3 \u003d color1;\n\t\t\t}\n\t\t\telse if (color3 \u003d\u003d -2)\n\t\t\t{\n\t\t\t\tvertexBuffer.put(0, 0, 0, 0);\n\t\t\t\tvertexBuffer.put(0, 0, 0, 0);\n\t\t\t\tvertexBuffer.put(0, 0, 0, 0);\n\n\t\t\t\tif (faceTextures !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t}\n\n\t\t\t\tlen +\u003d 3;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// HSL override is not applied to textured faces\n\t\t\tif (faceTextures \u003d\u003d null || faceTextures[face] \u003d\u003d -1)\n\t\t\t{\n\t\t\t\tif (overrideAmount \u003e 0)\n\t\t\t\t{\n\t\t\t\t\tcolor1 \u003d interpolateHSL(color1, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t\t\tcolor2 \u003d interpolateHSL(color2, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t\t\tcolor3 \u003d interpolateHSL(color3, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint packAlphaPriority \u003d packAlphaPriority(faceTextures, transparencies, facePriorities, face);\n\n\t\t\tint triangleA \u003d indices1[face];\n\t\t\tint triangleB \u003d indices2[face];\n\t\t\tint triangleC \u003d indices3[face];\n\n\t\t\tvertexBuffer.put(vertexX[triangleA], vertexY[triangleA], vertexZ[triangleA], packAlphaPriority | color1);\n\t\t\tvertexBuffer.put(vertexX[triangleB], vertexY[triangleB], vertexZ[triangleB], packAlphaPriority | color2);\n\t\t\tvertexBuffer.put(vertexX[triangleC], vertexY[triangleC], vertexZ[triangleC], packAlphaPriority | color3);\n\n\t\t\tif (faceTextures !\u003d null)\n\t\t\t{\n\t\t\t\tif (faceTextures[face] !\u003d -1)\n\t\t\t\t{\n\t\t\t\t\tint texA, texB, texC;\n\n\t\t\t\t\tif (textureFaces !\u003d null \u0026\u0026 textureFaces[face] !\u003d -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint tface \u003d textureFaces[face] \u0026 0xff;\n\t\t\t\t\t\ttexA \u003d texIndices1[tface];\n\t\t\t\t\t\ttexB \u003d texIndices2[tface];\n\t\t\t\t\t\ttexC \u003d texIndices3[tface];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ttexA \u003d triangleA;\n\t\t\t\t\t\ttexB \u003d triangleB;\n\t\t\t\t\t\ttexC \u003d triangleC;\n\t\t\t\t\t}\n\n\t\t\t\t\tint texture \u003d faceTextures[face] + 1;\n\t\t\t\t\tuvBuffer.put(texture, vertexX[texA], vertexY[texA], vertexZ[texA]);\n\t\t\t\t\tuvBuffer.put(texture, vertexX[texB], vertexY[texB], vertexZ[texB]);\n\t\t\t\t\tuvBuffer.put(texture, vertexX[texC], vertexY[texC], vertexZ[texC]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlen +\u003d 3;\n\t\t}\n\n\t\treturn len;\n\t}\n\n\tprivate static int[] distances;\n\tprivate static char[] distanceFaceCount;\n\tprivate static char[][] distanceToFaces;\n\n\tprivate static float[] modelCanvasX;\n\tprivate static float[] modelCanvasY;\n\n\tprivate static float[] modelLocalX;\n\tprivate static float[] modelLocalY;\n\tprivate static float[] modelLocalZ;\n\n\tprivate static int[] numOfPriority;\n\tprivate static int[] eq10;\n\tprivate static int[] eq11;\n\tprivate static int[] lt10;\n\tprivate static int[][] orderedFaces;\n\n\tvoid initSortingBuffers()\n\t{\n\t\tint MAX_VERTEX_COUNT \u003d 6500;\n\t\tint MAX_DIAMETER \u003d 6000;\n\t\tint ZSORT_GROUP_SIZE \u003d 1024; // was 512\n\t\tint MAX_FACES_PER_PRIORITY \u003d 4000; // was 2000\n\n\t\tdistances \u003d new int[MAX_VERTEX_COUNT];\n\t\tdistanceFaceCount \u003d new char[MAX_DIAMETER];\n\t\tdistanceToFaces \u003d new char[MAX_DIAMETER][ZSORT_GROUP_SIZE];\n\n\t\tmodelCanvasX \u003d new float[MAX_VERTEX_COUNT];\n\t\tmodelCanvasY \u003d new float[MAX_VERTEX_COUNT];\n\n\t\tmodelLocalX \u003d new float[MAX_VERTEX_COUNT];\n\t\tmodelLocalY \u003d new float[MAX_VERTEX_COUNT];\n\t\tmodelLocalZ \u003d new float[MAX_VERTEX_COUNT];\n\n\t\tnumOfPriority \u003d new int[12];\n\t\teq10 \u003d new int[MAX_FACES_PER_PRIORITY];\n\t\teq11 \u003d new int[MAX_FACES_PER_PRIORITY];\n\t\tlt10 \u003d new int[12];\n\t\torderedFaces \u003d new int[12][MAX_FACES_PER_PRIORITY];\n\t}\n\n\tvoid releaseSortingBuffers()\n\t{\n\t\tdistances \u003d null;\n\t\tdistanceFaceCount \u003d null;\n\t\tdistanceToFaces \u003d null;\n\n\t\tmodelCanvasX \u003d null;\n\t\tmodelCanvasY \u003d null;\n\n\t\tmodelLocalX \u003d null;\n\t\tmodelLocalY \u003d null;\n\t\tmodelLocalZ \u003d null;\n\n\t\tnumOfPriority \u003d null;\n\t\teq10 \u003d null;\n\t\teq11 \u003d null;\n\t\tlt10 \u003d null;\n\t\torderedFaces \u003d null;\n\t}\n\n\tint pushSortedModel(Projection proj, Model model, int orientation, int x, int y, int z, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\tfinal int vertexCount \u003d model.getVerticesCount();\n\t\tfinal float[] verticesX \u003d model.getVerticesX();\n\t\tfinal float[] verticesY \u003d model.getVerticesY();\n\t\tfinal float[] verticesZ \u003d model.getVerticesZ();\n\n\t\tfinal int faceCount \u003d model.getFaceCount();\n\t\tfinal int[] indices1 \u003d model.getFaceIndices1();\n\t\tfinal int[] indices2 \u003d model.getFaceIndices2();\n\t\tfinal int[] indices3 \u003d model.getFaceIndices3();\n\n\t\tfinal int[] faceColors3 \u003d model.getFaceColors3();\n\t\tfinal byte[] faceRenderPriorities \u003d model.getFaceRenderPriorities();\n\n\t\tfinal int centerX \u003d client.getCenterX();\n\t\tfinal int centerY \u003d client.getCenterY();\n\t\tfinal int zoom \u003d client.get3dZoom();\n\n\t\tfloat orientSine \u003d 0;\n\t\tfloat orientCosine \u003d 0;\n\t\tif (orientation !\u003d 0)\n\t\t{\n\t\t\torientSine \u003d Perspective.SINE[orientation] / 65536f;\n\t\t\torientCosine \u003d Perspective.COSINE[orientation] / 65536f;\n\t\t}\n\n\t\tfloat[] p \u003d proj.project(x, y, z);\n\t\tint zero \u003d (int) p[2];\n\n\t\tfor (int v \u003d 0; v \u003c vertexCount; ++v)\n\t\t{\n\t\t\tfloat vertexX \u003d verticesX[v];\n\t\t\tfloat vertexY \u003d verticesY[v];\n\t\t\tfloat vertexZ \u003d verticesZ[v];\n\n\t\t\tif (orientation !\u003d 0)\n\t\t\t{\n\t\t\t\tfloat x0 \u003d vertexX;\n\t\t\t\tvertexX \u003d vertexZ * orientSine + x0 * orientCosine;\n\t\t\t\tvertexZ \u003d vertexZ * orientCosine - x0 * orientSine;\n\t\t\t}\n\n\t\t\t// move to local position\n\t\t\tvertexX +\u003d x;\n\t\t\tvertexY +\u003d y;\n\t\t\tvertexZ +\u003d z;\n\n\t\t\tmodelLocalX[v] \u003d vertexX;\n\t\t\tmodelLocalY[v] \u003d vertexY;\n\t\t\tmodelLocalZ[v] \u003d vertexZ;\n\n\t\t\tp \u003d proj.project(vertexX, vertexY, vertexZ);\n\t\t\tmodelCanvasX[v] \u003d centerX + p[0] * zoom / p[2];\n\t\t\tmodelCanvasY[v] \u003d centerY + p[1] * zoom / p[2];\n\t\t\tdistances[v] \u003d (int) p[2] - zero;\n\t\t}\n\n\t\tfinal int diameter \u003d model.getDiameter();\n\t\tfinal int radius \u003d model.getRadius();\n\t\tif (diameter \u003e\u003d 6000)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\n\t\tArrays.fill(distanceFaceCount, 0, diameter, (char) 0);\n\n\t\tfor (char i \u003d 0; i \u003c faceCount; ++i)\n\t\t{\n\t\t\tif (faceColors3[i] !\u003d -2)\n\t\t\t{\n\t\t\t\tfinal int v1 \u003d indices1[i];\n\t\t\t\tfinal int v2 \u003d indices2[i];\n\t\t\t\tfinal int v3 \u003d indices3[i];\n\n\t\t\t\tfinal float\n\t\t\t\t\taX \u003d modelCanvasX[v1],\n\t\t\t\t\taY \u003d modelCanvasY[v1],\n\t\t\t\t\tbX \u003d modelCanvasX[v2],\n\t\t\t\t\tbY \u003d modelCanvasY[v2],\n\t\t\t\t\tcX \u003d modelCanvasX[v3],\n\t\t\t\t\tcY \u003d modelCanvasY[v3];\n\n\t\t\t\tif ((aX - bX) * (cY - bY) - (cX - bX) * (aY - bY) \u003e 0)\n\t\t\t\t{\n\t\t\t\t\tint distance \u003d radius + (distances[v1] + distances[v2] + distances[v3]) / 3;\n\t\t\t\t\tassert distance \u003e\u003d 0 \u0026\u0026 distance \u003c diameter;\n\t\t\t\t\tdistanceToFaces[distance][distanceFaceCount[distance]++] \u003d i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvertexBuffer.ensureCapacity(12 * faceCount);\n\t\tuvBuffer.ensureCapacity(12 * faceCount);\n\n\t\tint len \u003d 0;\n\t\tif (faceRenderPriorities \u003d\u003d null)\n\t\t{\n\t\t\tfor (int i \u003d diameter - 1; i \u003e\u003d 0; --i)\n\t\t\t{\n\t\t\t\tfinal int cnt \u003d distanceFaceCount[i];\n\t\t\t\tif (cnt \u003e 0)\n\t\t\t\t{\n\t\t\t\t\tfinal char[] faces \u003d distanceToFaces[i];\n\n\t\t\t\t\tfor (int faceIdx \u003d 0; faceIdx \u003c cnt; ++faceIdx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal int face \u003d faces[faceIdx];\n\t\t\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tArrays.fill(numOfPriority, 0);\n\t\t\tArrays.fill(lt10, 0);\n\n\t\t\tfor (int i \u003d diameter - 1; i \u003e\u003d 0; --i)\n\t\t\t{\n\t\t\t\tfinal int cnt \u003d distanceFaceCount[i];\n\t\t\t\tif (cnt \u003e 0)\n\t\t\t\t{\n\t\t\t\t\tfinal char[] faces \u003d distanceToFaces[i];\n\n\t\t\t\t\tfor (int faceIdx \u003d 0; faceIdx \u003c cnt; ++faceIdx)\n\t\t\t\t\t{\n\t\t\t\t\t\tfinal int face \u003d faces[faceIdx];\n\t\t\t\t\t\tfinal byte pri \u003d faceRenderPriorities[face];\n\t\t\t\t\t\tfinal int distIdx \u003d numOfPriority[pri]++;\n\n\t\t\t\t\t\torderedFaces[pri][distIdx] \u003d face;\n\t\t\t\t\t\tif (pri \u003c 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlt10[pri] +\u003d i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (pri \u003d\u003d 10)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teq10[distIdx] \u003d i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\teq11[distIdx] \u003d i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint avg12 \u003d 0;\n\t\t\tif (numOfPriority[1] \u003e 0 || numOfPriority[2] \u003e 0)\n\t\t\t{\n\t\t\t\tavg12 \u003d (lt10[1] + lt10[2]) / (numOfPriority[1] + numOfPriority[2]);\n\t\t\t}\n\n\t\t\tint avg34 \u003d 0;\n\t\t\tif (numOfPriority[3] \u003e 0 || numOfPriority[4] \u003e 0)\n\t\t\t{\n\t\t\t\tavg34 \u003d (lt10[3] + lt10[4]) / (numOfPriority[3] + numOfPriority[4]);\n\t\t\t}\n\n\t\t\tint avg68 \u003d 0;\n\t\t\tif (numOfPriority[6] \u003e 0 || numOfPriority[8] \u003e 0)\n\t\t\t{\n\t\t\t\tavg68 \u003d (lt10[8] + lt10[6]) / (numOfPriority[8] + numOfPriority[6]);\n\t\t\t}\n\n\t\t\tint drawnFaces \u003d 0;\n\t\t\tint numDynFaces \u003d numOfPriority[10];\n\t\t\tint[] dynFaces \u003d orderedFaces[10];\n\t\t\tint[] dynFaceDistances \u003d eq10;\n\t\t\tif (drawnFaces \u003d\u003d numDynFaces)\n\t\t\t{\n\t\t\t\tdrawnFaces \u003d 0;\n\t\t\t\tnumDynFaces \u003d numOfPriority[11];\n\t\t\t\tdynFaces \u003d orderedFaces[11];\n\t\t\t\tdynFaceDistances \u003d eq11;\n\t\t\t}\n\n\t\t\tint currFaceDistance;\n\t\t\tif (drawnFaces \u003c numDynFaces)\n\t\t\t{\n\t\t\t\tcurrFaceDistance \u003d dynFaceDistances[drawnFaces];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcurrFaceDistance \u003d -1000;\n\t\t\t}\n\n\t\t\tfor (int pri \u003d 0; pri \u003c 10; ++pri)\n\t\t\t{\n\t\t\t\twhile (pri \u003d\u003d 0 \u0026\u0026 currFaceDistance \u003e avg12)\n\t\t\t\t{\n\t\t\t\t\tfinal int face \u003d dynFaces[drawnFaces++];\n\t\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\n\t\t\t\t\tif (drawnFaces \u003d\u003d numDynFaces \u0026\u0026 dynFaces !\u003d orderedFaces[11])\n\t\t\t\t\t{\n\t\t\t\t\t\tdrawnFaces \u003d 0;\n\t\t\t\t\t\tnumDynFaces \u003d numOfPriority[11];\n\t\t\t\t\t\tdynFaces \u003d orderedFaces[11];\n\t\t\t\t\t\tdynFaceDistances \u003d eq11;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (drawnFaces \u003c numDynFaces)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d dynFaceDistances[drawnFaces];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d -1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (pri \u003d\u003d 3 \u0026\u0026 currFaceDistance \u003e avg34)\n\t\t\t\t{\n\t\t\t\t\tfinal int face \u003d dynFaces[drawnFaces++];\n\t\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\n\t\t\t\t\tif (drawnFaces \u003d\u003d numDynFaces \u0026\u0026 dynFaces !\u003d orderedFaces[11])\n\t\t\t\t\t{\n\t\t\t\t\t\tdrawnFaces \u003d 0;\n\t\t\t\t\t\tnumDynFaces \u003d numOfPriority[11];\n\t\t\t\t\t\tdynFaces \u003d orderedFaces[11];\n\t\t\t\t\t\tdynFaceDistances \u003d eq11;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (drawnFaces \u003c numDynFaces)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d dynFaceDistances[drawnFaces];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d -1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (pri \u003d\u003d 5 \u0026\u0026 currFaceDistance \u003e avg68)\n\t\t\t\t{\n\t\t\t\t\tfinal int face \u003d dynFaces[drawnFaces++];\n\t\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\n\t\t\t\t\tif (drawnFaces \u003d\u003d numDynFaces \u0026\u0026 dynFaces !\u003d orderedFaces[11])\n\t\t\t\t\t{\n\t\t\t\t\t\tdrawnFaces \u003d 0;\n\t\t\t\t\t\tnumDynFaces \u003d numOfPriority[11];\n\t\t\t\t\t\tdynFaces \u003d orderedFaces[11];\n\t\t\t\t\t\tdynFaceDistances \u003d eq11;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (drawnFaces \u003c numDynFaces)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d dynFaceDistances[drawnFaces];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrFaceDistance \u003d -1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfinal int priNum \u003d numOfPriority[pri];\n\t\t\t\tfinal int[] priFaces \u003d orderedFaces[pri];\n\n\t\t\t\tfor (int faceIdx \u003d 0; faceIdx \u003c priNum; ++faceIdx)\n\t\t\t\t{\n\t\t\t\t\tfinal int face \u003d priFaces[faceIdx];\n\t\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (currFaceDistance !\u003d -1000)\n\t\t\t{\n\t\t\t\tfinal int face \u003d dynFaces[drawnFaces++];\n\t\t\t\tlen +\u003d pushFace(model, face, vertexBuffer, uvBuffer);\n\n\t\t\t\tif (drawnFaces \u003d\u003d numDynFaces \u0026\u0026 dynFaces !\u003d orderedFaces[11])\n\t\t\t\t{\n\t\t\t\t\tdrawnFaces \u003d 0;\n\t\t\t\t\tdynFaces \u003d orderedFaces[11];\n\t\t\t\t\tnumDynFaces \u003d numOfPriority[11];\n\t\t\t\t\tdynFaceDistances \u003d eq11;\n\t\t\t\t}\n\n\t\t\t\tif (drawnFaces \u003c numDynFaces)\n\t\t\t\t{\n\t\t\t\t\tcurrFaceDistance \u003d dynFaceDistances[drawnFaces];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurrFaceDistance \u003d -1000;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn len;\n\t}\n\n\tprivate int pushFace(Model model, int face, GpuIntBuffer vertexBuffer, GpuFloatBuffer uvBuffer)\n\t{\n\t\tfinal int[] indices1 \u003d model.getFaceIndices1();\n\t\tfinal int[] indices2 \u003d model.getFaceIndices2();\n\t\tfinal int[] indices3 \u003d model.getFaceIndices3();\n\n\t\tfinal int[] faceColors1 \u003d model.getFaceColors1();\n\t\tfinal int[] faceColors2 \u003d model.getFaceColors2();\n\t\tfinal int[] faceColors3 \u003d model.getFaceColors3();\n\n\t\tfinal byte overrideAmount \u003d model.getOverrideAmount();\n\t\tfinal byte overrideHue \u003d model.getOverrideHue();\n\t\tfinal byte overrideSat \u003d model.getOverrideSaturation();\n\t\tfinal byte overrideLum \u003d model.getOverrideLuminance();\n\n\t\tfinal short[] faceTextures \u003d model.getFaceTextures();\n\t\tfinal byte[] textureFaces \u003d model.getTextureFaces();\n\t\tfinal int[] texIndices1 \u003d model.getTexIndices1();\n\t\tfinal int[] texIndices2 \u003d model.getTexIndices2();\n\t\tfinal int[] texIndices3 \u003d model.getTexIndices3();\n\n\t\tfinal byte[] faceRenderPriorities \u003d model.getFaceRenderPriorities();\n\t\tfinal byte[] transparencies \u003d model.getFaceTransparencies();\n\n\t\tfinal int packAlphaPriority \u003d packAlphaPriority(faceTextures, transparencies, faceRenderPriorities, face);\n\n\t\tfinal int triangleA \u003d indices1[face];\n\t\tfinal int triangleB \u003d indices2[face];\n\t\tfinal int triangleC \u003d indices3[face];\n\n\t\tint color1 \u003d faceColors1[face];\n\t\tint color2 \u003d faceColors2[face];\n\t\tint color3 \u003d faceColors3[face];\n\n\t\tif (color3 \u003d\u003d -1)\n\t\t{\n\t\t\tcolor2 \u003d color3 \u003d color1;\n\t\t}\n\n\t\t// HSL override is not applied to textured faces\n\t\tif (faceTextures \u003d\u003d null || faceTextures[face] \u003d\u003d -1)\n\t\t{\n\t\t\tif (overrideAmount \u003e 0)\n\t\t\t{\n\t\t\t\tcolor1 \u003d interpolateHSL(color1, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t\tcolor2 \u003d interpolateHSL(color2, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t\tcolor3 \u003d interpolateHSL(color3, overrideHue, overrideSat, overrideLum, overrideAmount);\n\t\t\t}\n\t\t}\n\n\t\tvertexBuffer.put(modelLocalX[triangleA], modelLocalY[triangleA], modelLocalZ[triangleA], packAlphaPriority | color1);\n\t\tvertexBuffer.put(modelLocalX[triangleB], modelLocalY[triangleB], modelLocalZ[triangleB], packAlphaPriority | color2);\n\t\tvertexBuffer.put(modelLocalX[triangleC], modelLocalY[triangleC], modelLocalZ[triangleC], packAlphaPriority | color3);\n\n\t\tif (faceTextures !\u003d null \u0026\u0026 faceTextures[face] !\u003d -1)\n\t\t{\n\t\t\tint texA, texB, texC;\n\n\t\t\tif (textureFaces !\u003d null \u0026\u0026 textureFaces[face] !\u003d -1)\n\t\t\t{\n\t\t\t\tint tfaceIdx \u003d textureFaces[face] \u0026 0xff;\n\t\t\t\ttexA \u003d texIndices1[tfaceIdx];\n\t\t\t\ttexB \u003d texIndices2[tfaceIdx];\n\t\t\t\ttexC \u003d texIndices3[tfaceIdx];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttexA \u003d triangleA;\n\t\t\t\ttexB \u003d triangleB;\n\t\t\t\ttexC \u003d triangleC;\n\t\t\t}\n\n\t\t\tint texture \u003d faceTextures[face] + 1;\n\t\t\tuvBuffer.put(texture, modelLocalX[texA], modelLocalY[texA], modelLocalZ[texA]);\n\t\t\tuvBuffer.put(texture, modelLocalX[texB], modelLocalY[texB], modelLocalZ[texB]);\n\t\t\tuvBuffer.put(texture, modelLocalX[texC], modelLocalY[texC], modelLocalZ[texC]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t\tuvBuffer.put(0, 0, 0, 0);\n\t\t}\n\n\t\treturn 3;\n\t}\n\n\tprivate static int packAlphaPriority(short[] faceTextures, byte[] faceTransparencies, byte[] facePriorities, int face)\n\t{\n\t\tint alpha \u003d 0;\n\t\tif (faceTransparencies !\u003d null)\n\t\t{\n\t\t\talpha \u003d (faceTransparencies[face] \u0026 0xFF) \u003c\u003c 24;\n\t\t}\n\t\tint priority \u003d 0;\n\t\tif (facePriorities !\u003d null)\n\t\t{\n\t\t\tpriority \u003d (facePriorities[face] \u0026 0xff) \u003c\u003c 16;\n\t\t}\n\t\treturn alpha | priority;\n\t}\n\n\tprivate static int interpolateHSL(int hsl, byte hue2, byte sat2, byte lum2, byte lerp)\n\t{\n\t\tint hue \u003d hsl \u003e\u003e 10 \u0026 63;\n\t\tint sat \u003d hsl \u003e\u003e 7 \u0026 7;\n\t\tint lum \u003d hsl \u0026 127;\n\t\tint var9 \u003d lerp \u0026 255;\n\t\tif (hue2 !\u003d -1)\n\t\t{\n\t\t\thue +\u003d var9 * (hue2 - hue) \u003e\u003e 7;\n\t\t}\n\n\t\tif (sat2 !\u003d -1)\n\t\t{\n\t\t\tsat +\u003d var9 * (sat2 - sat) \u003e\u003e 7;\n\t\t}\n\n\t\tif (lum2 !\u003d -1)\n\t\t{\n\t\t\tlum +\u003d var9 * (lum2 - lum) \u003e\u003e 7;\n\t\t}\n\n\t\treturn (hue \u003c\u003c 10 | sat \u003c\u003c 7 | lum) \u0026 65535;\n\t}\n\n\t// remove tiles from the scene that are outside the current region\n\tprivate void prepare(Scene scene)\n\t{\n\t\tif (scene.isInstance() || !gpuConfig.hideUnrelatedMaps())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint baseX \u003d scene.getBaseX() / 8;\n\t\tint baseY \u003d scene.getBaseY() / 8;\n\t\tint centerX \u003d baseX + 6;\n\t\tint centerY \u003d baseY + 6;\n\t\tint centerId \u003d regions.getRegionId(centerX, centerY);\n\n\t\tint r \u003d Constants.EXTENDED_SCENE_SIZE / 16;\n\t\tfor (int offx \u003d -r; offx \u003c\u003d r; ++offx)\n\t\t{\n\t\t\tfor (int offy \u003d -r; offy \u003c\u003d r; ++offy)\n\t\t\t{\n\t\t\t\tint cx \u003d centerX + offx;\n\t\t\t\tint cy \u003d centerY + offy;\n\t\t\t\tint id \u003d regions.getRegionId(cx, cy);\n\t\t\t\tif (id !\u003d centerId)\n\t\t\t\t{\n\t\t\t\t\tremoveChunk(scene, cx, cy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void removeChunk(Scene scene, int cx, int cy)\n\t{\n\t\tint wx \u003d cx * 8;\n\t\tint wy \u003d cy * 8;\n\t\tint sx \u003d wx - scene.getBaseX();\n\t\tint sy \u003d wy - scene.getBaseY();\n\t\tint cmsx \u003d sx + GpuPlugin.SCENE_OFFSET;\n\t\tint cmsy \u003d sy + GpuPlugin.SCENE_OFFSET;\n\t\tTile[][][] tiles \u003d scene.getExtendedTiles();\n\t\tfor (int x \u003d 0; x \u003c 8; ++x)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c 8; ++y)\n\t\t\t{\n\t\t\t\tint msx \u003d cmsx + x;\n\t\t\t\tint msy \u003d cmsy + y;\n\t\t\t\tif (msx \u003e\u003d 0 \u0026\u0026 msx \u003c Constants.EXTENDED_SCENE_SIZE \u0026\u0026 msy \u003e\u003d 0 \u0026\u0026 msy \u003c Constants.EXTENDED_SCENE_SIZE)\n\t\t\t\t{\n\t\t\t\t\tfor (int z \u003d 0; z \u003c Constants.MAX_Z; ++z)\n\t\t\t\t\t{\n\t\t\t\t\t\tTile tile \u003d tiles[z][msx][msy];\n\t\t\t\t\t\tif (tile !\u003d null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tscene.removeTile(tile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\SceneUploader.java"},{"fileName":"Shader.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * Copyright (c) 2020 Abex\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport java.util.ArrayList;\nimport java.util.List;\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\nimport info.sigterm.plugins.gpulegacy.template.Template;\nimport org.lwjgl.opengl.GL43C;\n\npublic class Shader\n{\n\t@VisibleForTesting\n\tfinal List\u003cUnit\u003e units \u003d new ArrayList\u003c\u003e();\n\n\t@RequiredArgsConstructor\n\t@VisibleForTesting\n\tstatic class Unit\n\t{\n\t\t@Getter\n\t\tprivate final int type;\n\n\t\t@Getter\n\t\tprivate final String filename;\n\t}\n\n\tpublic Shader add(int type, String name)\n\t{\n\t\tunits.add(new Unit(type, name));\n\t\treturn this;\n\t}\n\n\tpublic int compile(Template template) throws ShaderException\n\t{\n\t\tint program \u003d GL43C.glCreateProgram();\n\t\tint[] shaders \u003d new int[units.size()];\n\t\tint i \u003d 0;\n\t\tboolean ok \u003d false;\n\t\ttry\n\t\t{\n\t\t\twhile (i \u003c shaders.length)\n\t\t\t{\n\t\t\t\tUnit unit \u003d units.get(i);\n\t\t\t\tint shader \u003d GL43C.glCreateShader(unit.type);\n\t\t\t\tif (shader \u003d\u003d 0)\n\t\t\t\t{\n\t\t\t\t\tthrow new ShaderException(\"Unable to create shader of type \" + unit.type);\n\t\t\t\t}\n\n\t\t\t\tString source \u003d template.load(unit.filename);\n\t\t\t\tGL43C.glShaderSource(shader, source);\n\t\t\t\tGL43C.glCompileShader(shader);\n\n\t\t\t\tif (GL43C.glGetShaderi(shader, GL43C.GL_COMPILE_STATUS) !\u003d GL43C.GL_TRUE)\n\t\t\t\t{\n\t\t\t\t\tString err \u003d GL43C.glGetShaderInfoLog(shader);\n\t\t\t\t\tGL43C.glDeleteShader(shader);\n\t\t\t\t\tthrow new ShaderException(err);\n\t\t\t\t}\n\t\t\t\tGL43C.glAttachShader(program, shader);\n\t\t\t\tshaders[i++] \u003d shader;\n\t\t\t}\n\n\t\t\tGL43C.glLinkProgram(program);\n\n\t\t\tif (GL43C.glGetProgrami(program, GL43C.GL_LINK_STATUS) \u003d\u003d GL43C.GL_FALSE)\n\t\t\t{\n\t\t\t\tString err \u003d GL43C.glGetProgramInfoLog(program);\n\t\t\t\tthrow new ShaderException(err);\n\t\t\t}\n\n\t\t\tGL43C.glValidateProgram(program);\n\n\t\t\tif (GL43C.glGetProgrami(program, GL43C.GL_VALIDATE_STATUS) \u003d\u003d GL43C.GL_FALSE)\n\t\t\t{\n\t\t\t\tString err \u003d GL43C.glGetProgramInfoLog(program);\n\t\t\t\tthrow new ShaderException(err);\n\t\t\t}\n\n\t\t\tok \u003d true;\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\twhile (i \u003e 0)\n\t\t\t{\n\t\t\t\tint shader \u003d shaders[--i];\n\t\t\t\tGL43C.glDetachShader(program, shader);\n\t\t\t\tGL43C.glDeleteShader(shader);\n\t\t\t}\n\n\t\t\tif (!ok)\n\t\t\t{\n\t\t\t\tGL43C.glDeleteProgram(program);\n\t\t\t}\n\t\t}\n\n\t\treturn program;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\Shader.java"},{"fileName":"ShaderException.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nclass ShaderException extends Exception\n{\n\tShaderException(String message)\n\t{\n\t\tsuper(message);\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\ShaderException.java"},{"fileName":"Template.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy.template;\n\nimport com.google.common.io.CharStreams;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Function;\nimport lombok.extern.slf4j.Slf4j;\n\n@Slf4j\npublic class Template\n{\n\tprivate final List\u003cFunction\u003cString, String\u003e\u003e resourceLoaders \u003d new ArrayList\u003c\u003e();\n\n\tpublic String process(String str)\n\t{\n\t\tStringBuilder sb \u003d new StringBuilder();\n\t\tfor (String line : str.split(\"\\r?\\n\"))\n\t\t{\n\t\t\tif (line.startsWith(\"#include \"))\n\t\t\t{\n\t\t\t\tString resource \u003d line.substring(9);\n\t\t\t\tif (resource.startsWith(\"\\\"\") \u0026\u0026 resource.endsWith(\"\\\"\"))\n\t\t\t\t{\n\t\t\t\t\tresource \u003d resource.substring(1, resource.length() - 1);\n\t\t\t\t}\n\n\t\t\t\tString resourceStr \u003d load(resource);\n\t\t\t\tsb.append(resourceStr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsb.append(line).append(\u0027\\n\u0027);\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic String load(String filename)\n\t{\n\t\tfor (Function\u003cString, String\u003e loader : resourceLoaders)\n\t\t{\n\t\t\tString value \u003d loader.apply(filename);\n\t\t\tif (value !\u003d null)\n\t\t\t{\n\t\t\t\treturn process(value);\n\t\t\t}\n\t\t}\n\n\t\treturn \"\";\n\t}\n\n\tpublic Template add(Function\u003cString, String\u003e fn)\n\t{\n\t\tresourceLoaders.add(fn);\n\t\treturn this;\n\t}\n\n\tpublic Template addInclude(Class\u003c?\u003e clazz)\n\t{\n\t\treturn add(f -\u003e\n\t\t{\n\t\t\ttry (InputStream is \u003d clazz.getResourceAsStream(f))\n\t\t\t{\n\t\t\t\tif (is !\u003d null)\n\t\t\t\t{\n\t\t\t\t\treturn inputStreamToString(is);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex)\n\t\t\t{\n\t\t\t\tlog.warn(null, ex);\n\t\t\t}\n\t\t\treturn null;\n\t\t});\n\t}\n\n\tprivate static String inputStreamToString(InputStream in)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn CharStreams.toString(new InputStreamReader(in, StandardCharsets.UTF_8));\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\template\\Template.java"},{"fileName":"TextureManager.java","content":"/*\n * Copyright (c) 2018, Adam \u003cAdam@sigterm.info\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage info.sigterm.plugins.gpulegacy;\n\nimport java.nio.ByteBuffer;\nimport javax.inject.Singleton;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Texture;\nimport net.runelite.api.TextureProvider;\nimport org.lwjgl.opengl.EXTTextureFilterAnisotropic;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GL43C;\n\n@Singleton\n@Slf4j\nclass TextureManager\n{\n\tstatic final int TEXTURE_COUNT \u003d 256;\n\tprivate static final int TEXTURE_SIZE \u003d 128;\n\n\tint initTextureArray(TextureProvider textureProvider)\n\t{\n\t\tif (!allTexturesLoaded(textureProvider))\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\n\t\tTexture[] textures \u003d textureProvider.getTextures();\n\n\t\tint textureArrayId \u003d GL43C.glGenTextures();\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D_ARRAY, textureArrayId);\n\t\tif (GL.getCapabilities().glTexStorage3D !\u003d 0)\n\t\t{\n\t\t\tGL43C.glTexStorage3D(GL43C.GL_TEXTURE_2D_ARRAY, 8, GL43C.GL_RGBA8, TEXTURE_SIZE, TEXTURE_SIZE, textures.length);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint size \u003d TEXTURE_SIZE;\n\t\t\tfor (int i \u003d 0; i \u003c 8; i++)\n\t\t\t{\n\t\t\t\tGL43C.glTexImage3D(GL43C.GL_TEXTURE_2D_ARRAY, i, GL43C.GL_RGBA8, size, size, textures.length, 0, GL43C.GL_RGBA, GL43C.GL_UNSIGNED_BYTE, 0);\n\t\t\t\tsize /\u003d 2;\n\t\t\t}\n\t\t}\n\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D_ARRAY, GL43C.GL_TEXTURE_MIN_FILTER, GL43C.GL_NEAREST);\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D_ARRAY, GL43C.GL_TEXTURE_MAG_FILTER, GL43C.GL_NEAREST);\n\n\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D_ARRAY, GL43C.GL_TEXTURE_WRAP_S, GL43C.GL_CLAMP_TO_EDGE);\n\n\t\t// Set brightness to 1.0d to upload unmodified textures to GPU\n\t\tdouble save \u003d textureProvider.getBrightness();\n\t\ttextureProvider.setBrightness(1.0d);\n\n\t\tupdateTextures(textureProvider, textureArrayId);\n\n\t\ttextureProvider.setBrightness(save);\n\n\t\tGL43C.glActiveTexture(GL43C.GL_TEXTURE1);\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D_ARRAY, textureArrayId);\n\t\tGL43C.glGenerateMipmap(GL43C.GL_TEXTURE_2D_ARRAY);\n\t\tGL43C.glActiveTexture(GL43C.GL_TEXTURE0);\n\n\t\treturn textureArrayId;\n\t}\n\n\tvoid setAnisotropicFilteringLevel(int textureArrayId, int level)\n\t{\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D_ARRAY, textureArrayId);\n\n\t\t//level \u003d 0 means no mipmaps and no anisotropic filtering\n\t\tif (level \u003d\u003d 0)\n\t\t{\n\t\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D_ARRAY, GL43C.GL_TEXTURE_MIN_FILTER, GL43C.GL_NEAREST);\n\t\t}\n\t\t//level \u003d 1 means with mipmaps but without anisotropic filtering GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT defaults to 1.0 which is off\n\t\t//level \u003e 1 enables anisotropic filtering. It\u0027s up to the vendor what the values mean\n\t\t//Even if anisotropic filtering isn\u0027t supported, mipmaps will be enabled with any level \u003e\u003d 1\n\t\telse\n\t\t{\n\t\t\t// Set on GL_NEAREST_MIPMAP_LINEAR (bilinear filtering with mipmaps) since the pixel nature of the game means that nearest filtering\n\t\t\t// looks best for objects up close but allows linear filtering to resolve possible aliasing and noise with mipmaps from far away objects.\n\t\t\tGL43C.glTexParameteri(GL43C.GL_TEXTURE_2D_ARRAY, GL43C.GL_TEXTURE_MIN_FILTER, GL43C.GL_NEAREST_MIPMAP_LINEAR);\n\t\t}\n\n\t\tif (GL.getCapabilities().GL_EXT_texture_filter_anisotropic)\n\t\t{\n\t\t\tfinal float maxSamples \u003d GL43C.glGetFloat(EXTTextureFilterAnisotropic.GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n\t\t\t//Clamp from 1 to max GL says it supports.\n\t\t\tfinal float anisoLevel \u003d Math.max(1, Math.min(maxSamples, level));\n\t\t\tGL43C.glTexParameterf(GL43C.GL_TEXTURE_2D_ARRAY, EXTTextureFilterAnisotropic.GL_TEXTURE_MAX_ANISOTROPY_EXT, anisoLevel);\n\t\t}\n\t}\n\n\tvoid freeTextureArray(int textureArrayId)\n\t{\n\t\tGL43C.glDeleteTextures(textureArrayId);\n\t}\n\n\t/**\n\t * Check if all textures have been loaded and cached yet.\n\t *\n\t * @param textureProvider\n\t * @return\n\t */\n\tprivate boolean allTexturesLoaded(TextureProvider textureProvider)\n\t{\n\t\tTexture[] textures \u003d textureProvider.getTextures();\n\t\tif (textures \u003d\u003d null || textures.length \u003d\u003d 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int textureId \u003d 0; textureId \u003c textures.length; textureId++)\n\t\t{\n\t\t\tTexture texture \u003d textures[textureId];\n\t\t\tif (texture !\u003d null)\n\t\t\t{\n\t\t\t\tint[] pixels \u003d textureProvider.load(textureId);\n\t\t\t\tif (pixels \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprivate void updateTextures(TextureProvider textureProvider, int textureArrayId)\n\t{\n\t\tTexture[] textures \u003d textureProvider.getTextures();\n\n\t\tGL43C.glBindTexture(GL43C.GL_TEXTURE_2D_ARRAY, textureArrayId);\n\n\t\tint cnt \u003d 0;\n\t\tfor (int textureId \u003d 0; textureId \u003c textures.length; textureId++)\n\t\t{\n\t\t\tTexture texture \u003d textures[textureId];\n\t\t\tif (texture !\u003d null)\n\t\t\t{\n\t\t\t\tint[] srcPixels \u003d textureProvider.load(textureId);\n\t\t\t\tif (srcPixels \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"No pixels for texture {}!\", textureId);\n\t\t\t\t\tcontinue; // this can\u0027t happen\n\t\t\t\t}\n\n\t\t\t\t++cnt;\n\n\t\t\t\tif (srcPixels.length !\u003d TEXTURE_SIZE * TEXTURE_SIZE)\n\t\t\t\t{\n\t\t\t\t\t// The texture storage is 128x128 bytes, and will only work correctly with the\n\t\t\t\t\t// 128x128 textures from high detail mode\n\t\t\t\t\tlog.warn(\"Texture size for {} is {}!\", textureId, srcPixels.length);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbyte[] pixels \u003d convertPixels(srcPixels, TEXTURE_SIZE, TEXTURE_SIZE, TEXTURE_SIZE, TEXTURE_SIZE);\n\t\t\t\tByteBuffer pixelBuffer \u003d ByteBuffer.allocateDirect(pixels.length);\n\t\t\t\tpixelBuffer.put(pixels);\n\t\t\t\tpixelBuffer.flip();\n\t\t\t\tGL43C.glTexSubImage3D(GL43C.GL_TEXTURE_2D_ARRAY, 0, 0, 0, textureId, TEXTURE_SIZE, TEXTURE_SIZE,\n\t\t\t\t\t1, GL43C.GL_RGBA, GL43C.GL_UNSIGNED_BYTE, pixelBuffer);\n\t\t\t}\n\t\t}\n\n\t\tlog.debug(\"Uploaded textures {}\", cnt);\n\t}\n\n\tprivate static byte[] convertPixels(int[] srcPixels, int width, int height, int textureWidth, int textureHeight)\n\t{\n\t\tbyte[] pixels \u003d new byte[textureWidth * textureHeight * 4];\n\n\t\tint pixelIdx \u003d 0;\n\t\tint srcPixelIdx \u003d 0;\n\n\t\tint offset \u003d (textureWidth - width) * 4;\n\n\t\tfor (int y \u003d 0; y \u003c height; y++)\n\t\t{\n\t\t\tfor (int x \u003d 0; x \u003c width; x++)\n\t\t\t{\n\t\t\t\tint rgb \u003d srcPixels[srcPixelIdx++];\n\t\t\t\tif (rgb !\u003d 0)\n\t\t\t\t{\n\t\t\t\t\tpixels[pixelIdx++] \u003d (byte) (rgb \u003e\u003e 16);\n\t\t\t\t\tpixels[pixelIdx++] \u003d (byte) (rgb \u003e\u003e 8);\n\t\t\t\t\tpixels[pixelIdx++] \u003d (byte) rgb;\n\t\t\t\t\tpixels[pixelIdx++] \u003d (byte) -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpixelIdx +\u003d 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpixelIdx +\u003d offset;\n\t\t}\n\t\treturn pixels;\n\t}\n\n\tfloat[] computeTextureAnimations(TextureProvider textureProvider)\n\t{\n\t\tTexture[] textures \u003d textureProvider.getTextures();\n\n\t\tif (textures.length \u003e TEXTURE_COUNT)\n\t\t{\n\t\t\tlog.warn(\"texture limit exceeded: {} \u003e {}\", textures.length, TEXTURE_COUNT);\n\t\t}\n\n\t\tfloat[] anims \u003d new float[TEXTURE_COUNT * 2];\n\t\tfor (int i \u003d 0; i \u003c Math.min(TEXTURE_COUNT, textures.length); ++i)\n\t\t{\n\t\t\tTexture texture \u003d textures[i];\n\t\t\tif (texture \u003d\u003d null)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfloat u \u003d 0f, v \u003d 0f;\n\t\t\tswitch (texture.getAnimationDirection())\n\t\t\t{\n\t\t\t\tcase 1:\n\t\t\t\t\tv \u003d -1f;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tv \u003d 1f;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tu \u003d -1f;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tu \u003d 1f;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint speed \u003d texture.getAnimationSpeed();\n\t\t\tu *\u003d speed;\n\t\t\tv *\u003d speed;\n\n\t\t\tanims[i * 2] \u003d u;\n\t\t\tanims[i * 2 + 1] \u003d v;\n\t\t}\n\t\treturn anims;\n\t}\n}\n","filePath":"src\\main\\java\\info\\sigterm\\plugins\\gpulegacy\\TextureManager.java"},{"fileName":"ExamplePluginTest.java","content":"package com.example;\n\nimport info.sigterm.plugins.gpulegacy.GpuPlugin;\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ExamplePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(GpuPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\example\\ExamplePluginTest.java"}]},{"commit":"b288ac5c94b385f8fe0250b70bfa89256002c288","repository":"https://github.com/NorbsCode/item-link.git","internalName":"item-link","files":[{"fileName":"ItemLinkConfig.java","content":"/*\n * Copyright (c) 2025, LordStrange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.itemlink;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"itemlink\")\npublic interface ItemLinkConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"colorByRarity\",\n\t\tname \u003d \"Color by rarity\",\n\t\tdescription \u003d \"Color item links based on GE value (WoW-style rarity colors)\",\n\t\tposition \u003d 0\n\t)\n\tdefault boolean colorByRarity()\n\t{\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\com\\itemlink\\ItemLinkConfig.java"},{"fileName":"ItemLinkOverlay.java","content":"/*\n * Copyright (c) 2025, LordStrange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.itemlink;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.ItemComposition;\nimport net.runelite.api.Point;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.client.game.ItemEquipmentStats;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.game.ItemStats;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.tooltip.Tooltip;\nimport net.runelite.client.ui.overlay.tooltip.TooltipManager;\nimport net.runelite.client.util.QuantityFormatter;\n\npublic class ItemLinkOverlay extends Overlay\n{\n\tprivate static final int MAX_CACHED_ITEMS \u003d 50;\n\tprivate static final int MOUSE_MOVE_THRESHOLD \u003d 2; // Minimum pixels to trigger re-scan\n\n\t// Pattern to detect colored item names in chat: \u003ccol\u003dXXXXXX\u003e[ItemName]\u003c/col\u003e or \u003ccol\u003dXXXXXX\u003e[ItemName x123]\u003c/col\u003e\n\tprivate static final Pattern COLORED_ITEM_PATTERN \u003d Pattern.compile(\"\u003ccol\u003d[0-9a-fA-F]+\u003e\\\\[([^\\\\]]+?)(?:\\\\s+x(\\\\d+))?\\\\]\u003c/col\u003e\");\n\n\t// Rarity colors (WoW-style)\n\tprivate static final String COLOR_COMMON \u003d \"ffffff\";      // White\n\tprivate static final String COLOR_UNCOMMON \u003d \"1eff00\";    // Green\n\tprivate static final String COLOR_RARE \u003d \"0070dd\";        // Blue\n\tprivate static final String COLOR_EPIC \u003d \"a335ee\";        // Purple\n\tprivate static final String COLOR_LEGENDARY \u003d \"ff8000\";   // Orange\n\n\t// UI colors\n\tprivate static final String COLOR_LABEL \u003d \"999999\";\n\tprivate static final String COLOR_VALUE_POSITIVE \u003d \"00ff00\";\n\tprivate static final String COLOR_VALUE_NEGATIVE \u003d \"ff0000\";\n\tprivate static final String COLOR_VALUE_NEUTRAL \u003d \"ffff00\";\n\tprivate static final String COLOR_GOLD \u003d \"ffd700\";\n\tprivate static final String COLOR_ALCH \u003d \"ff9040\";\n\tprivate static final String COLOR_SEPARATOR \u003d \"444444\";\n\n\t// Mouse position caching to avoid re-scanning every frame\n\tprivate int lastMouseX \u003d -1;\n\tprivate int lastMouseY \u003d -1;\n\tprivate Widget cachedHoveredWidget \u003d null;\n\tprivate String cachedWidgetText \u003d null;\n\tprivate List\u003cItemLinkInfo\u003e cachedFoundItems \u003d null;\n\tprivate String cachedTooltipText \u003d null;\n\n\t// Cache of item info by item ID\n\tprivate final Map\u003cInteger, ItemLinkInfo\u003e recentItems \u003d new LinkedHashMap\u003cInteger, ItemLinkInfo\u003e()\n\t{\n\t\t@Override\n\t\tprotected boolean removeEldestEntry(Map.Entry\u003cInteger, ItemLinkInfo\u003e eldest)\n\t\t{\n\t\t\treturn size() \u003e MAX_CACHED_ITEMS;\n\t\t}\n\t};\n\n\t// Cache of item info by item name (lowercase for case-insensitive lookup)\n\tprivate final Map\u003cString, ItemLinkInfo\u003e itemsByName \u003d new LinkedHashMap\u003cString, ItemLinkInfo\u003e()\n\t{\n\t\t@Override\n\t\tprotected boolean removeEldestEntry(Map.Entry\u003cString, ItemLinkInfo\u003e eldest)\n\t\t{\n\t\t\treturn size() \u003e MAX_CACHED_ITEMS;\n\t\t}\n\t};\n\n\tprivate final Client client;\n\tprivate final ItemLinkConfig config;\n\tprivate final ItemManager itemManager;\n\tprivate final TooltipManager tooltipManager;\n\n\t@Inject\n\tprivate ItemLinkOverlay(Client client, ItemLinkPlugin plugin, ItemLinkConfig config,\n\t\t\t\t\t\t\tItemManager itemManager, TooltipManager tooltipManager)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.config \u003d config;\n\t\tthis.itemManager \u003d itemManager;\n\t\tthis.tooltipManager \u003d tooltipManager;\n\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_WIDGETS);\n\t\tsetPriority(OverlayPriority.HIGH);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (itemsByName.isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tPoint mousePos \u003d client.getMouseCanvasPosition();\n\t\tif (mousePos \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tint mouseX \u003d mousePos.getX();\n\t\tint mouseY \u003d mousePos.getY();\n\n\t\t// Check if mouse has moved significantly\n\t\tboolean mouseMovedSignificantly \u003d Math.abs(mouseX - lastMouseX) \u003e MOUSE_MOVE_THRESHOLD ||\n\t\t\t\t\t\t\t\t\t\t  Math.abs(mouseY - lastMouseY) \u003e MOUSE_MOVE_THRESHOLD;\n\n\t\t// Fast path: if mouse hasn\u0027t moved and we have a cached tooltip, just show it\n\t\tif (!mouseMovedSignificantly \u0026\u0026 cachedTooltipText !\u003d null)\n\t\t{\n\t\t\t// Quick bounds check on cached widget\n\t\t\tif (cachedHoveredWidget !\u003d null)\n\t\t\t{\n\t\t\t\tRectangle bounds \u003d cachedHoveredWidget.getBounds();\n\t\t\t\tif (bounds !\u003d null \u0026\u0026 bounds.contains(mouseX, mouseY))\n\t\t\t\t{\n\t\t\t\t\ttooltipManager.add(new Tooltip(cachedTooltipText));\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Bounds check failed, clear cache\n\t\t\tclearTooltipCache();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Mouse moved - update position\n\t\tlastMouseX \u003d mouseX;\n\t\tlastMouseY \u003d mouseY;\n\n\t\t// Find hovered widget\n\t\tWidget hoveredChatLine \u003d findHoveredChatLine(mousePos);\n\t\tif (hoveredChatLine \u003d\u003d null)\n\t\t{\n\t\t\tclearTooltipCache();\n\t\t\treturn null;\n\t\t}\n\n\t\tString text \u003d hoveredChatLine.getText();\n\t\tif (text \u003d\u003d null || !text.contains(\"\u003ccol\u003d\"))\n\t\t{\n\t\t\tclearTooltipCache();\n\t\t\treturn null;\n\t\t}\n\n\t\t// Check if text changed - if not, reuse cached tooltip\n\t\tif (text.equals(cachedWidgetText) \u0026\u0026 cachedTooltipText !\u003d null)\n\t\t{\n\t\t\tcachedHoveredWidget \u003d hoveredChatLine;\n\t\t\ttooltipManager.add(new Tooltip(cachedTooltipText));\n\t\t\treturn null;\n\t\t}\n\n\t\t// Text changed, need to rebuild tooltip\n\t\tcachedHoveredWidget \u003d hoveredChatLine;\n\t\tcachedWidgetText \u003d text;\n\n\t\t// Find colored item names in the text\n\t\tList\u003cItemLinkInfo\u003e foundItems \u003d new ArrayList\u003c\u003e();\n\t\tMatcher matcher \u003d COLORED_ITEM_PATTERN.matcher(text);\n\n\t\twhile (matcher.find())\n\t\t{\n\t\t\tString itemName \u003d matcher.group(1);\n\t\t\tString quantityStr \u003d matcher.group(2);\n\t\t\tint quantity \u003d quantityStr !\u003d null ? Integer.parseInt(quantityStr) : 1;\n\n\t\t\tItemLinkInfo info \u003d itemsByName.get(itemName.toLowerCase());\n\t\t\tif (info !\u003d null)\n\t\t\t{\n\t\t\t\tfoundItems.add(copyWithQuantity(info, quantity));\n\t\t\t}\n\t\t}\n\n\t\tif (!foundItems.isEmpty())\n\t\t{\n\t\t\tcachedFoundItems \u003d foundItems;\n\t\t\tcachedTooltipText \u003d buildTooltipText(foundItems);\n\t\t\ttooltipManager.add(new Tooltip(cachedTooltipText));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tclearTooltipCache();\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate void clearTooltipCache()\n\t{\n\t\tcachedHoveredWidget \u003d null;\n\t\tcachedWidgetText \u003d null;\n\t\tcachedFoundItems \u003d null;\n\t\tcachedTooltipText \u003d null;\n\t}\n\n\t/**\n\t * Find the chat line widget the mouse is hovering over.\n\t * Optimized to check bounds FIRST before running expensive regex.\n\t */\n\tprivate Widget findHoveredChatLine(Point mousePos)\n\t{\n\t\tint mx \u003d mousePos.getX();\n\t\tint my \u003d mousePos.getY();\n\n\t\t// Check chat line widgets (162, 58-149) - bounds first\n\t\tfor (int lineId \u003d 58; lineId \u003c 150; lineId++)\n\t\t{\n\t\t\tWidget lineWidget \u003d client.getWidget(162, lineId);\n\t\t\tWidget found \u003d checkWidgetForItemLink(lineWidget, mx, my);\n\t\t\tif (found !\u003d null) return found;\n\t\t}\n\n\t\t// Try scroll area children (162, 57)\n\t\tWidget scrollArea \u003d client.getWidget(162, 57);\n\t\tif (scrollArea !\u003d null \u0026\u0026 !scrollArea.isHidden())\n\t\t{\n\t\t\tWidget found \u003d checkChildrenForItemLink(scrollArea, mx, my);\n\t\t\tif (found !\u003d null) return found;\n\t\t}\n\n\t\t// Try chat display for transparent chatbox (162, 55)\n\t\tWidget chatDisplay \u003d client.getWidget(162, 55);\n\t\tif (chatDisplay !\u003d null \u0026\u0026 !chatDisplay.isHidden())\n\t\t{\n\t\t\tWidget found \u003d checkChildrenForItemLink(chatDisplay, mx, my);\n\t\t\tif (found !\u003d null) return found;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if a widget contains an item link and mouse is over it.\n\t * Returns the widget if found, null otherwise.\n\t */\n\tprivate Widget checkWidgetForItemLink(Widget widget, int mx, int my)\n\t{\n\t\tif (widget \u003d\u003d null || widget.isHidden())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tRectangle bounds \u003d widget.getBounds();\n\t\tif (bounds \u003d\u003d null || !bounds.contains(mx, my))\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\t// Mouse is over this widget - check if it has item links\n\t\tString text \u003d widget.getText();\n\t\tif (text !\u003d null \u0026\u0026 text.contains(\"[\") \u0026\u0026 COLORED_ITEM_PATTERN.matcher(text).find())\n\t\t{\n\t\t\treturn widget;\n\t\t}\n\n\t\t// Check dynamic children\n\t\tWidget[] children \u003d widget.getDynamicChildren();\n\t\tif (children !\u003d null)\n\t\t{\n\t\t\tfor (Widget child : children)\n\t\t\t{\n\t\t\t\tWidget found \u003d checkWidgetForItemLink(child, mx, my);\n\t\t\t\tif (found !\u003d null) return found;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check children of a container widget for item links.\n\t */\n\tprivate Widget checkChildrenForItemLink(Widget parent, int mx, int my)\n\t{\n\t\tif (parent \u003d\u003d null || parent.isHidden())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tWidget[] children \u003d parent.getDynamicChildren();\n\t\tif (children !\u003d null)\n\t\t{\n\t\t\tfor (Widget child : children)\n\t\t\t{\n\t\t\t\tWidget found \u003d checkWidgetForItemLink(child, mx, my);\n\t\t\t\tif (found !\u003d null) return found;\n\t\t\t}\n\t\t}\n\n\t\tchildren \u003d parent.getStaticChildren();\n\t\tif (children !\u003d null)\n\t\t{\n\t\t\tfor (Widget child : children)\n\t\t\t{\n\t\t\t\tWidget found \u003d checkWidgetForItemLink(child, mx, my);\n\t\t\t\tif (found !\u003d null) return found;\n\t\t\t}\n\t\t}\n\n\t\tchildren \u003d parent.getNestedChildren();\n\t\tif (children !\u003d null)\n\t\t{\n\t\t\tfor (Widget child : children)\n\t\t\t{\n\t\t\t\tWidget found \u003d checkWidgetForItemLink(child, mx, my);\n\t\t\t\tif (found !\u003d null) return found;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic void addRecentItem(int itemId, int quantity)\n\t{\n\t\tItemComposition itemComp \u003d itemManager.getItemComposition(itemId);\n\t\tif (itemComp \u003d\u003d null || itemComp.getName() \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString itemName \u003d itemComp.getName();\n\t\tif (itemName.equals(\"null\"))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tItemLinkInfo info \u003d new ItemLinkInfo();\n\t\tinfo.itemId \u003d itemId;\n\t\tinfo.quantity \u003d quantity;\n\t\tinfo.name \u003d itemName;\n\t\tinfo.timestamp \u003d System.currentTimeMillis();\n\t\tinfo.gePrice \u003d itemManager.getItemPrice(itemId);\n\t\tinfo.haPrice \u003d itemComp.getHaPrice();\n\n\t\tItemStats stats \u003d itemManager.getItemStats(itemId);\n\t\tif (stats !\u003d null)\n\t\t{\n\t\t\tinfo.weight \u003d stats.getWeight();\n\t\t\tinfo.isEquipable \u003d stats.isEquipable();\n\t\t\tinfo.geLimit \u003d stats.getGeLimit();\n\t\t\tinfo.equipmentStats \u003d stats.getEquipment();\n\t\t}\n\n\t\trecentItems.put(itemId, info);\n\t\titemsByName.put(itemName.toLowerCase(), info);\n\t}\n\n\tprivate String formatStat(String name, int value)\n\t{\n\t\treturn formatStat(name, value, \"\");\n\t}\n\n\tprivate String formatStat(String name, int value, String suffix)\n\t{\n\t\tString color \u003d value \u003e 0 ? COLOR_VALUE_POSITIVE : (value \u003c 0 ? COLOR_VALUE_NEGATIVE : COLOR_LABEL);\n\t\tString sign \u003d value \u003e 0 ? \"+\" : \"\";\n\t\treturn \"\u003ccol\u003d\" + COLOR_LABEL + \"\u003e\" + name + \":\u003c/col\u003e \u003ccol\u003d\" + color + \"\u003e\" + sign + value + suffix + \"\u003c/col\u003e\u003c/br\u003e\";\n\t}\n\n\tprivate boolean hasAttackBonuses(ItemEquipmentStats eq)\n\t{\n\t\treturn eq.getAstab() !\u003d 0 || eq.getAslash() !\u003d 0 || eq.getAcrush() !\u003d 0 ||\n\t\t\t   eq.getAmagic() !\u003d 0 || eq.getArange() !\u003d 0;\n\t}\n\n\tprivate boolean hasDefenceBonuses(ItemEquipmentStats eq)\n\t{\n\t\treturn eq.getDstab() !\u003d 0 || eq.getDslash() !\u003d 0 || eq.getDcrush() !\u003d 0 ||\n\t\t\t   eq.getDmagic() !\u003d 0 || eq.getDrange() !\u003d 0;\n\t}\n\n\tprivate boolean hasOtherBonuses(ItemEquipmentStats eq)\n\t{\n\t\treturn eq.getStr() !\u003d 0 || eq.getRstr() !\u003d 0 || eq.getMdmg() !\u003d 0 || eq.getPrayer() !\u003d 0;\n\t}\n\n\tprivate String getSlotName(int slot)\n\t{\n\t\tswitch (slot)\n\t\t{\n\t\t\tcase 0: return \"Head\";\n\t\t\tcase 1: return \"Cape\";\n\t\t\tcase 2: return \"Neck\";\n\t\t\tcase 3: return \"Weapon\";\n\t\t\tcase 4: return \"Body\";\n\t\t\tcase 5: return \"Shield\";\n\t\t\tcase 7: return \"Legs\";\n\t\t\tcase 9: return \"Gloves\";\n\t\t\tcase 10: return \"Boots\";\n\t\t\tcase 12: return \"Ring\";\n\t\t\tcase 13: return \"Ammo\";\n\t\t\tdefault: return \"Equipment\";\n\t\t}\n\t}\n\n\tprivate String getRarityColor(int gePrice)\n\t{\n\t\tif (gePrice \u003e\u003d 10000000) return COLOR_LEGENDARY;\n\t\tif (gePrice \u003e\u003d 1000000) return COLOR_EPIC;\n\t\tif (gePrice \u003e\u003d 100000) return COLOR_RARE;\n\t\tif (gePrice \u003e\u003d 10000) return COLOR_UNCOMMON;\n\t\treturn COLOR_COMMON;\n\t}\n\n\tpublic void clearRecentItems()\n\t{\n\t\trecentItems.clear();\n\t\titemsByName.clear();\n\t\tclearTooltipCache();\n\t\tlastMouseX \u003d -1;\n\t\tlastMouseY \u003d -1;\n\t}\n\n\tprivate String buildTooltipText(List\u003cItemLinkInfo\u003e items)\n\t{\n\t\tStringBuilder tooltip \u003d new StringBuilder();\n\t\tboolean first \u003d true;\n\n\t\tfor (ItemLinkInfo info : items)\n\t\t{\n\t\t\tif (!first)\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003c/br\u003e\u003ccol\u003d\").append(COLOR_SEPARATOR).append(\"\u003e\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t}\n\t\t\tfirst \u003d false;\n\n\t\t\tappendItemTooltip(tooltip, info);\n\t\t}\n\n\t\treturn tooltip.toString();\n\t}\n\n\tprivate ItemLinkInfo copyWithQuantity(ItemLinkInfo original, int newQuantity)\n\t{\n\t\tItemLinkInfo copy \u003d new ItemLinkInfo();\n\t\tcopy.itemId \u003d original.itemId;\n\t\tcopy.quantity \u003d newQuantity;\n\t\tcopy.name \u003d original.name;\n\t\tcopy.timestamp \u003d original.timestamp;\n\t\tcopy.gePrice \u003d original.gePrice;\n\t\tcopy.haPrice \u003d original.haPrice;\n\t\tcopy.weight \u003d original.weight;\n\t\tcopy.isEquipable \u003d original.isEquipable;\n\t\tcopy.geLimit \u003d original.geLimit;\n\t\tcopy.equipmentStats \u003d original.equipmentStats;\n\t\treturn copy;\n\t}\n\n\tprivate void appendItemTooltip(StringBuilder tooltip, ItemLinkInfo info)\n\t{\n\t\tString rarityColor \u003d getRarityColor(info.gePrice);\n\n\t\t// ITEM NAME\n\t\ttooltip.append(\"\u003ccol\u003d\").append(rarityColor).append(\"\u003e\").append(info.name).append(\"\u003c/col\u003e\");\n\t\tif (info.quantity \u003e 1)\n\t\t{\n\t\t\ttooltip.append(\" \u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003ex\").append(QuantityFormatter.formatNumber(info.quantity)).append(\"\u003c/col\u003e\");\n\t\t}\n\t\ttooltip.append(\"\u003c/br\u003e\");\n\n\t\t// Separator\n\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_SEPARATOR).append(\"\u003e\u003c/col\u003e\u003c/br\u003e\");\n\n\t\t// PRICE INFORMATION\n\t\tboolean hasPriceInfo \u003d false;\n\n\t\tif (info.gePrice \u003e 0)\n\t\t{\n\t\t\thasPriceInfo \u003d true;\n\t\t\tlong totalGe \u003d (long) info.gePrice * info.quantity;\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_GOLD).append(\"\u003eGE Price:\u003c/col\u003e \");\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_VALUE_NEUTRAL).append(\"\u003e\");\n\t\t\ttooltip.append(QuantityFormatter.quantityToStackSize(totalGe)).append(\" gp\");\n\t\t\tif (info.quantity \u003e 1)\n\t\t\t{\n\t\t\t\ttooltip.append(\" (\").append(QuantityFormatter.quantityToStackSize(info.gePrice)).append(\" ea)\");\n\t\t\t}\n\t\t\ttooltip.append(\"\u003c/col\u003e\u003c/br\u003e\");\n\n\t\t\tif (info.geLimit \u003e 0)\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eBuy Limit:\u003c/col\u003e \");\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_VALUE_NEUTRAL).append(\"\u003e\");\n\t\t\t\ttooltip.append(QuantityFormatter.formatNumber(info.geLimit));\n\t\t\t\ttooltip.append(\"\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t}\n\t\t}\n\n\t\tif (info.haPrice \u003e 0)\n\t\t{\n\t\t\thasPriceInfo \u003d true;\n\t\t\tlong totalHa \u003d (long) info.haPrice * info.quantity;\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_ALCH).append(\"\u003eHA Value:\u003c/col\u003e \");\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_VALUE_NEUTRAL).append(\"\u003e\");\n\t\t\ttooltip.append(QuantityFormatter.quantityToStackSize(totalHa)).append(\" gp\");\n\t\t\tif (info.quantity \u003e 1)\n\t\t\t{\n\t\t\t\ttooltip.append(\" (\").append(QuantityFormatter.quantityToStackSize(info.haPrice)).append(\" ea)\");\n\t\t\t}\n\t\t\ttooltip.append(\"\u003c/col\u003e\u003c/br\u003e\");\n\t\t}\n\n\t\t// EQUIPMENT STATS\n\t\tif (info.isEquipable \u0026\u0026 info.equipmentStats !\u003d null)\n\t\t{\n\t\t\tItemEquipmentStats eq \u003d info.equipmentStats;\n\n\t\t\tif (hasPriceInfo)\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_SEPARATOR).append(\"\u003e\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t}\n\n\t\t\tString slotName \u003d getSlotName(eq.getSlot());\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eSlot:\u003c/col\u003e \");\n\t\t\ttooltip.append(\"\u003ccol\u003dffffff\u003e\").append(slotName);\n\t\t\tif (eq.isTwoHanded())\n\t\t\t{\n\t\t\t\ttooltip.append(\" (Two-handed)\");\n\t\t\t}\n\t\t\ttooltip.append(\"\u003c/col\u003e\u003c/br\u003e\");\n\n\t\t\tif (hasAttackBonuses(eq))\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eAttack Bonuses\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t\tif (eq.getAstab() !\u003d 0) tooltip.append(formatStat(\"  Stab\", eq.getAstab()));\n\t\t\t\tif (eq.getAslash() !\u003d 0) tooltip.append(formatStat(\"  Slash\", eq.getAslash()));\n\t\t\t\tif (eq.getAcrush() !\u003d 0) tooltip.append(formatStat(\"  Crush\", eq.getAcrush()));\n\t\t\t\tif (eq.getAmagic() !\u003d 0) tooltip.append(formatStat(\"  Magic\", eq.getAmagic()));\n\t\t\t\tif (eq.getArange() !\u003d 0) tooltip.append(formatStat(\"  Ranged\", eq.getArange()));\n\t\t\t}\n\n\t\t\tif (hasDefenceBonuses(eq))\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eDefence Bonuses\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t\tif (eq.getDstab() !\u003d 0) tooltip.append(formatStat(\"  Stab\", eq.getDstab()));\n\t\t\t\tif (eq.getDslash() !\u003d 0) tooltip.append(formatStat(\"  Slash\", eq.getDslash()));\n\t\t\t\tif (eq.getDcrush() !\u003d 0) tooltip.append(formatStat(\"  Crush\", eq.getDcrush()));\n\t\t\t\tif (eq.getDmagic() !\u003d 0) tooltip.append(formatStat(\"  Magic\", eq.getDmagic()));\n\t\t\t\tif (eq.getDrange() !\u003d 0) tooltip.append(formatStat(\"  Ranged\", eq.getDrange()));\n\t\t\t}\n\n\t\t\tif (hasOtherBonuses(eq))\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eOther Bonuses\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t\tif (eq.getStr() !\u003d 0) tooltip.append(formatStat(\"  Melee Str\", eq.getStr()));\n\t\t\t\tif (eq.getRstr() !\u003d 0) tooltip.append(formatStat(\"  Ranged Str\", eq.getRstr()));\n\t\t\t\tif (eq.getMdmg() !\u003d 0) tooltip.append(formatStat(\"  Magic Dmg\", (int) eq.getMdmg(), \"%\"));\n\t\t\t\tif (eq.getPrayer() !\u003d 0) tooltip.append(formatStat(\"  Prayer\", eq.getPrayer()));\n\t\t\t}\n\n\t\t\tif (eq.getAspeed() \u003e 0)\n\t\t\t{\n\t\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eAttack Speed:\u003c/col\u003e \");\n\t\t\t\ttooltip.append(\"\u003ccol\u003dffffff\u003e\").append(eq.getAspeed()).append(\"\u003c/col\u003e\u003c/br\u003e\");\n\t\t\t}\n\t\t}\n\n\t\t// WEIGHT\n\t\tif (info.weight !\u003d 0)\n\t\t{\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(COLOR_LABEL).append(\"\u003eWeight:\u003c/col\u003e \");\n\t\t\tString weightColor \u003d info.weight \u003c 0 ? COLOR_VALUE_POSITIVE : (info.weight \u003e 0 ? COLOR_VALUE_NEUTRAL : COLOR_LABEL);\n\t\t\ttooltip.append(\"\u003ccol\u003d\").append(weightColor).append(\"\u003e\");\n\t\t\ttooltip.append(String.format(\"%.2f kg\", info.weight));\n\t\t\ttooltip.append(\"\u003c/col\u003e\");\n\t\t}\n\t}\n\n\tprivate static class ItemLinkInfo\n\t{\n\t\tint itemId;\n\t\tint quantity;\n\t\tString name;\n\t\tint gePrice;\n\t\tint haPrice;\n\t\tlong timestamp;\n\t\tboolean isEquipable;\n\t\tdouble weight;\n\t\tint geLimit;\n\t\tItemEquipmentStats equipmentStats;\n\t}\n}\n","filePath":"src\\main\\java\\com\\itemlink\\ItemLinkOverlay.java"},{"fileName":"ItemLinkPlugin.java","content":"/*\n * Copyright (c) 2025, LordStrange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.itemlink;\n\nimport com.google.inject.Provides;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Actor;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.ItemComposition;\nimport net.runelite.api.Player;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.OverheadTextChanged;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n/**\n * ItemLink Plugin - WoW-style item linking for OSRS chat\n *\n * This plugin automatically detects item names in chat messages and highlights them\n * with colored text based on their GE value (rarity). Just type naturally!\n *\n * Examples:\n *   - \"I just got an Abyssal whip!\" -\u003e \"I just got an [Abyssal whip]!\"\n *   - \"Selling Dragon scimitar 100k\" -\u003e \"Selling [Dragon scimitar] 100k\"\n *\n * Items are colored by their GE value (WoW-style rarity colors).\n * Hover over linked items to see detailed stats and prices.\n * Other players with this plugin will also see the highlighted items.\n */\n@PluginDescriptor(\n\tname \u003d \"Item Link\",\n\tdescription \u003d \"Automatically highlights item names in chat with rarity colors and tooltips\",\n\ttags \u003d {\"item\", \"link\", \"chat\", \"share\", \"wow\", \"highlight\", \"tooltip\", \"price\"}\n)\n@Slf4j\npublic class ItemLinkPlugin extends Plugin\n{\n\t// Rarity colors (WoW-style)\n\tprivate static final String COLOR_COMMON \u003d \"ffffff\";      // White\n\tprivate static final String COLOR_UNCOMMON \u003d \"1eff00\";    // Green\n\tprivate static final String COLOR_RARE \u003d \"0070dd\";        // Blue\n\tprivate static final String COLOR_EPIC \u003d \"a335ee\";        // Purple\n\tprivate static final String COLOR_LEGENDARY \u003d \"ff8000\";   // Orange\n\tprivate static final String COLOR_DEFAULT \u003d \"ff8000\";     // Orange (default)\n\n\t// Default chat colors for restoration after item highlight\n\t// These are used in transparent chatbox mode\n\tprivate static final String COLOR_PUBLIC_CHAT \u003d \"9090ff\";     // Light blue (public chat)\n\tprivate static final String COLOR_FC_CHAT \u003d \"ef5050\";         // Salmon red (friends/clan chat)\n\n\t// Minimum item name length to avoid false positives\n\tprivate static final int MIN_ITEM_NAME_LENGTH \u003d 5;\n\n\t// Map of lowercase item name -\u003e item ID\n\tprivate final Map\u003cString, Integer\u003e itemNameToId \u003d new HashMap\u003c\u003e();\n\n\t// List of item names sorted by length (longest first) for matching\n\tprivate final List\u003cString\u003e sortedItemNames \u003d new ArrayList\u003c\u003e();\n\n\t// Set of all single-word item names for O(1) lookup\n\tprivate final Set\u003cString\u003e singleWordItems \u003d new HashSet\u003c\u003e();\n\n\t// Map of first word -\u003e list of multi-word item names starting with that word (sorted by length, longest first)\n\tprivate final Map\u003cString, List\u003cString\u003e\u003e multiWordItemsByFirstWord \u003d new HashMap\u003c\u003e();\n\n\tprivate boolean itemsLoaded \u003d false;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate ItemManager itemManager;\n\n\t@Inject\n\tprivate ItemLinkConfig config;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ItemLinkOverlay itemLinkOverlay;\n\n\t@Provides\n\tItemLinkConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(ItemLinkConfig.class);\n\t}\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tlog.info(\"ItemLink plugin started\");\n\t\toverlayManager.add(itemLinkOverlay);\n\n\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tloadItemNames();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tlog.info(\"ItemLink plugin stopped\");\n\t\toverlayManager.remove(itemLinkOverlay);\n\t\titemLinkOverlay.clearRecentItems();\n\t\titemNameToId.clear();\n\t\tsortedItemNames.clear();\n\t\tsingleWordItems.clear();\n\t\tmultiWordItemsByFirstWord.clear();\n\t\titemsLoaded \u003d false;\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged event)\n\t{\n\t\tif (event.getGameState() \u003d\u003d GameState.LOGGED_IN \u0026\u0026 !itemsLoaded)\n\t\t{\n\t\t\tloadItemNames();\n\t\t}\n\t}\n\n\t// Number of items to process per chunk to avoid blocking the game\n\tprivate static final int ITEMS_PER_CHUNK \u003d 2000;\n\tprivate static final int MAX_ITEM_ID \u003d 30000;\n\n\t/**\n\t * Load all item names into the lookup map.\n\t * Uses chunked loading to avoid blocking the game client.\n\t */\n\tprivate void loadItemNames()\n\t{\n\t\titemNameToId.clear();\n\t\tsortedItemNames.clear();\n\t\tsingleWordItems.clear();\n\t\tmultiWordItemsByFirstWord.clear();\n\n\t\t// Start loading from the first chunk\n\t\tloadItemChunk(0);\n\t}\n\n\t/**\n\t * Load a chunk of items starting at the given ID.\n\t */\n\tprivate void loadItemChunk(final int startId)\n\t{\n\t\tclientThread.invokeLater(() -\u003e\n\t\t{\n\t\t\tint endId \u003d Math.min(startId + ITEMS_PER_CHUNK, MAX_ITEM_ID);\n\n\t\t\tfor (int itemId \u003d startId; itemId \u003c endId; itemId++)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tItemComposition itemComp \u003d itemManager.getItemComposition(itemId);\n\t\t\t\t\tif (itemComp \u003d\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString name \u003d itemComp.getName();\n\t\t\t\t\tif (name \u003d\u003d null || name.equals(\"null\") || name.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip very short names to avoid false positives\n\t\t\t\t\tif (name.length() \u003c MIN_ITEM_NAME_LENGTH)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Skip noted items and placeholders\n\t\t\t\t\tif (itemComp.getNote() !\u003d -1 || itemComp.getPlaceholderTemplateId() !\u003d -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tString lowerName \u003d name.toLowerCase();\n\n\t\t\t\t\t// Only store first occurrence (base item)\n\t\t\t\t\tif (!itemNameToId.containsKey(lowerName))\n\t\t\t\t\t{\n\t\t\t\t\t\titemNameToId.put(lowerName, itemId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\t// Skip problematic items\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (endId \u003c MAX_ITEM_ID)\n\t\t\t{\n\t\t\t\t// Schedule next chunk\n\t\t\t\tloadItemChunk(endId);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// All chunks loaded, finalize\n\t\t\t\tfinalizeItemLoading();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Finalize item loading by building optimized lookup structures.\n\t */\n\tprivate void finalizeItemLoading()\n\t{\n\t\t// Sort item names by length (longest first) for greedy matching\n\t\tsortedItemNames.addAll(itemNameToId.keySet());\n\t\tsortedItemNames.sort((a, b) -\u003e Integer.compare(b.length(), a.length()));\n\n\t\t// Build optimized lookup structures\n\t\tfor (String itemName : sortedItemNames)\n\t\t{\n\t\t\tint spaceIndex \u003d itemName.indexOf(\u0027 \u0027);\n\t\t\tif (spaceIndex \u003d\u003d -1)\n\t\t\t{\n\t\t\t\t// Single-word item\n\t\t\t\tsingleWordItems.add(itemName);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Multi-word item - index by first word\n\t\t\t\tString firstWord \u003d itemName.substring(0, spaceIndex);\n\t\t\t\tmultiWordItemsByFirstWord\n\t\t\t\t\t.computeIfAbsent(firstWord, k -\u003e new ArrayList\u003c\u003e())\n\t\t\t\t\t.add(itemName);\n\t\t\t}\n\t\t}\n\n\t\titemsLoaded \u003d true;\n\t\tlog.info(\"Loaded {} item names for Item Link ({} single-word, {} multi-word prefixes)\",\n\t\t\titemNameToId.size(), singleWordItems.size(), multiWordItemsByFirstWord.size());\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage event)\n\t{\n\t\tif (!itemsLoaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// Only process player chat messages, not system/game messages\n\t\tChatMessageType type \u003d event.getType();\n\t\tswitch (type)\n\t\t{\n\t\t\tcase PUBLICCHAT:\n\t\t\tcase MODCHAT:\n\t\t\tcase PRIVATECHAT:\n\t\t\tcase PRIVATECHATOUT:\n\t\t\tcase FRIENDSCHAT:\n\t\t\tcase CLAN_CHAT:\n\t\t\tcase CLAN_GUEST_CHAT:\n\t\t\tcase CLAN_GIM_CHAT:\n\t\t\tcase AUTOTYPER:\n\t\t\tcase MODAUTOTYPER:\n\t\t\tcase TRADEREQ:\n\t\t\tcase CHALREQ_TRADE:\n\t\t\t\t// These are player messages - process them\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Skip system messages, examine text, NPC dialogue, etc.\n\t\t\t\treturn;\n\t\t}\n\n\t\tString message \u003d event.getMessage();\n\t\tif (message \u003d\u003d null || message.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString processed \u003d highlightItemNames(message);\n\t\tif (!processed.equals(message))\n\t\t{\n\t\t\tevent.getMessageNode().setValue(processed);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onOverheadTextChanged(OverheadTextChanged event)\n\t{\n\t\tif (!itemsLoaded)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tActor actor \u003d event.getActor();\n\t\tif (!(actor instanceof Player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString text \u003d event.getOverheadText();\n\t\tif (text \u003d\u003d null || text.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tString formatted \u003d highlightItemNames(text);\n\t\tif (!formatted.equals(text))\n\t\t{\n\t\t\tactor.setOverheadText(formatted);\n\t\t}\n\t}\n\n\t/**\n\t * Scan message for item names and highlight them.\n\t * Uses optimized word-boundary scanning with HashSet lookups.\n\t */\n\tprivate String highlightItemNames(String message)\n\t{\n\t\tString lowerMessage \u003d message.toLowerCase();\n\t\tStringBuilder result \u003d new StringBuilder();\n\n\t\tint i \u003d 0;\n\t\twhile (i \u003c message.length())\n\t\t{\n\t\t\t// Only check at word boundaries (start of message or after non-letter/digit)\n\t\t\tboolean atWordBoundary \u003d (i \u003d\u003d 0 || !Character.isLetterOrDigit(lowerMessage.charAt(i - 1)));\n\n\t\t\tif (!atWordBoundary || !Character.isLetterOrDigit(lowerMessage.charAt(i)))\n\t\t\t{\n\t\t\t\tresult.append(message.charAt(i));\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Extract the current word\n\t\t\tint wordEnd \u003d i;\n\t\t\twhile (wordEnd \u003c lowerMessage.length() \u0026\u0026 Character.isLetterOrDigit(lowerMessage.charAt(wordEnd)))\n\t\t\t{\n\t\t\t\twordEnd++;\n\t\t\t}\n\t\t\tString currentWord \u003d lowerMessage.substring(i, wordEnd);\n\n\t\t\tString matchedItemName \u003d null;\n\n\t\t\t// First, check for multi-word items starting with this word (longest first)\n\t\t\tList\u003cString\u003e multiWordCandidates \u003d multiWordItemsByFirstWord.get(currentWord);\n\t\t\tif (multiWordCandidates !\u003d null)\n\t\t\t{\n\t\t\t\tfor (String candidate : multiWordCandidates)\n\t\t\t\t{\n\t\t\t\t\tif (i + candidate.length() \u003e lowerMessage.length())\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if full item name matches\n\t\t\t\t\tif (!lowerMessage.regionMatches(i, candidate, 0, candidate.length()))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check end boundary\n\t\t\t\t\tint endPos \u003d i + candidate.length();\n\t\t\t\t\tif (endPos \u003c lowerMessage.length() \u0026\u0026 Character.isLetterOrDigit(lowerMessage.charAt(endPos)))\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tmatchedItemName \u003d candidate;\n\t\t\t\t\tbreak; // Multi-word candidates are already sorted longest-first\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If no multi-word match, check for single-word item\n\t\t\tif (matchedItemName \u003d\u003d null \u0026\u0026 singleWordItems.contains(currentWord))\n\t\t\t{\n\t\t\t\tmatchedItemName \u003d currentWord;\n\t\t\t}\n\n\t\t\tif (matchedItemName !\u003d null)\n\t\t\t{\n\t\t\t\t// Found a match! Get original case from message\n\t\t\t\tString originalName \u003d message.substring(i, i + matchedItemName.length());\n\t\t\t\tint itemId \u003d itemNameToId.get(matchedItemName);\n\t\t\t\tString color \u003d getItemColor(itemId);\n\n\t\t\t\tresult.append(String.format(\"\u003ccol\u003d%s\u003e[%s]\u003c/col\u003e\u003ccol\u003d%s\u003e\", color, originalName, COLOR_PUBLIC_CHAT));\n\n\t\t\t\t// Add to overlay for tooltip\n\t\t\t\titemLinkOverlay.addRecentItem(itemId, 1);\n\n\t\t\t\ti +\u003d matchedItemName.length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tresult.append(message.charAt(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Determines the color for an item based on its GE value.\n\t */\n\tprivate String getItemColor(int itemId)\n\t{\n\t\tif (!config.colorByRarity())\n\t\t{\n\t\t\treturn COLOR_DEFAULT;\n\t\t}\n\n\t\tint gePrice \u003d itemManager.getItemPrice(itemId);\n\n\t\tif (gePrice \u003e\u003d 10000000)\n\t\t{\n\t\t\treturn COLOR_LEGENDARY;\n\t\t}\n\t\telse if (gePrice \u003e\u003d 1000000)\n\t\t{\n\t\t\treturn COLOR_EPIC;\n\t\t}\n\t\telse if (gePrice \u003e\u003d 100000)\n\t\t{\n\t\t\treturn COLOR_RARE;\n\t\t}\n\t\telse if (gePrice \u003e\u003d 10000)\n\t\t{\n\t\t\treturn COLOR_UNCOMMON;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn COLOR_COMMON;\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\itemlink\\ItemLinkPlugin.java"}]},{"commit":"f7c351b9f36baf210aeef3034bc6155177a326b9","repository":"https://github.com/molgoatkirby/InfernoAutoSplitter.git","internalName":"inferno-autosplitter","files":[{"fileName":"InfernoAutoSplitterConfig.java","content":"package com.InfernoAutoSplitter;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"autosplitter\")\npublic interface InfernoAutoSplitterConfig extends Config {\n\n    @ConfigItem(position \u003d 2, keyName \u003d \"port\", name \u003d \"Port\", description \u003d \"Port for the LiveSplit server. (Restart required)\")\n    default int port() {\n        return 16834;\n    }\n\n}\n","filePath":"src\\main\\java\\com\\InfernoAutoSplitter\\InfernoAutoSplitterConfig.java"},{"fileName":"InfernoAutoSplitterPanel.java","content":"package com.InfernoAutoSplitter;\n\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.PluginPanel;\n\nimport javax.inject.Inject;\nimport javax.swing.*;\nimport javax.swing.border.LineBorder;\nimport java.awt.*;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class InfernoAutoSplitterPanel extends PluginPanel\n{\n    private final Client client;\n    private final InfernoAutoSplitterConfig config;\n    private final InfernoAutoSplitterPlugin splitter;\n    private PrintWriter writer;\n    private Socket socket;\n    private JLabel status;\n\n    @Inject\n    InfernoAutoSplitterPanel(Client client, PrintWriter writer, InfernoAutoSplitterConfig config, InfernoAutoSplitterPlugin splitter){\n        this.client \u003d client;\n        this.writer \u003d writer;\n        this.config \u003d config;\n        this.splitter \u003d splitter;\n    }\n\n    private void connect(){\n        try {\n            socket \u003d new Socket(\"localhost\", config.port());\n            writer \u003d new PrintWriter(socket.getOutputStream());\n            splitter.writer \u003d writer;\n\n            set_connected();\n\n            if (client.getGameState() \u003d\u003d GameState.LOGGED_IN) {\n                String message \u003d \"Socket started at port \u003ccol\u003dff0000\u003e\" + config.port() + \"\u003c/col\u003e.\";\n                client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", message, null);\n            }\n\n        } catch (Exception e) {\n            if (client.getGameState() \u003d\u003d GameState.LOGGED_IN) {\n                String message \u003d \"Could not start socket, did you start the LiveSplit server?\";\n                client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", message, null);\n            }\n        }\n    }\n\n    public void disconnect(){\n        try {\n            socket.close();\n            set_disconnected();\n\n            if (client.getGameState() \u003d\u003d GameState.LOGGED_IN) {\n                client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Socket closed.\", null);\n            }\n        } catch (Exception ignored) {}\n    }\n\n    private void control(String cmd){\n        try {\n            writer.write(cmd + \"\\r\\n\");\n            writer.flush();\n        } catch (Exception ignored) { }\n    }\n\n    public void startPanel(){\n        getParent().setLayout(new BorderLayout());\n        getParent().add(this, BorderLayout.CENTER);\n\n        setLayout(new BorderLayout());\n        setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n        setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n        final JPanel layout \u003d new JPanel();\n        BoxLayout boxLayout \u003d new BoxLayout(layout, BoxLayout.Y_AXIS);\n        layout.setLayout(boxLayout);\n        add(layout, BorderLayout.NORTH);\n\n        JPanel statusFrame \u003d new JPanel();\n        statusFrame.setLayout(new GridBagLayout());\n        statusFrame.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.CYAN), \"Status\"));\n\n        status \u003d new JLabel(\"Not connected\");\n        status.setForeground(Color.RED);\n        statusFrame.add(status);\n\n\n        JPanel connectionFrame \u003d new JPanel();\n        connectionFrame.setLayout(new GridLayout(2, 1));\n        connectionFrame.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.CYAN), \"Connection\"));\n\n        JButton b_connect \u003d new JButton(\"Connect\");\n        JButton b_disconnect \u003d new JButton(\"Disconnect\");\n        b_connect.setFocusable(false);\n        b_disconnect.setFocusable(false);\n\n        b_connect.addActionListener(e -\u003e connect());\n        b_disconnect.addActionListener(e -\u003e disconnect());\n\n        connectionFrame.add(b_connect);\n        connectionFrame.add(b_disconnect);\n\n\n        JPanel controllerFrame \u003d new JPanel();\n        controllerFrame.setLayout(new GridLayout(6, 1));\n        controllerFrame.setBorder(BorderFactory.createTitledBorder(new LineBorder(Color.CYAN), \"LiveSplit Controller\"));\n\n        JButton[] controllerButtons \u003d {new JButton(\"Split\"), new JButton(\"Reset\"), new JButton(\"Undo split\"),\n                new JButton(\"Skip split\"), new JButton(\"Pause\"), new JButton(\"Resume\")};\n        String[] controls \u003d {\"startorsplit\", \"reset\", \"unsplit\", \"skipsplit\", \"pause\", \"resume\"};\n\n        for (int i \u003d 0; i \u003c controllerButtons.length; i++){\n            int finalI \u003d i; // because lambda forces my hand\n            controllerButtons[i].addActionListener(e -\u003e control(controls[finalI]));\n\n            controllerButtons[i].setFocusable(false);\n            controllerFrame.add(controllerButtons[i], BorderLayout.CENTER);\n        }\n\n        layout.add(statusFrame);\n        layout.add(Box.createRigidArea(new Dimension(0, 15)));\n        layout.add(connectionFrame);\n        layout.add(Box.createRigidArea(new Dimension(0, 15)));\n        layout.add(controllerFrame);\n    }\n\n    public void set_connected(){\n        status.setText(\"Connected\");\n        status.setForeground(Color.GREEN);\n    }\n\n    public void set_disconnected(){\n        status.setText(\"Not connected\");\n        status.setForeground(Color.RED);\n    }\n}\n","filePath":"src\\main\\java\\com\\InfernoAutoSplitter\\InfernoAutoSplitterPanel.java"},{"fileName":"InfernoAutoSplitterPlugin.java","content":"/*\nInfernoAutoSplitterPlugin\nConnects to LiveSplit Server and automatically does the splits for the Inferno\nCreated by Molgoatkirby and Naabe\nCredit to SkyBouncer\u0027s CM AutoSplitter, the code for the panel and config comes largely from that\nInitial date: 10/28/2021\n */\n\npackage com.InfernoAutoSplitter;\n\nimport com.google.inject.Provides;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.ImageUtil;\n\nimport javax.inject.Inject;\nimport java.awt.image.BufferedImage;\nimport java.io.PrintWriter;\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"Inferno AutoSplitter\",\n        enabledByDefault \u003d false,\n        description \u003d \"Automatically splits for LiveSplit in Inferno\"\n)\npublic class InfernoAutoSplitterPlugin extends Plugin {\n\n    // The tick we entered the instance\n    private int lastTick \u003d 0;\n\n    // The variables to interact with livesplit\n    PrintWriter writer;\n\n    // The waves we have splits for\n    private final int[] SPLIT_WAVES \u003d new int[] {9, 18, 25, 35, 42, 50, 57, 60, 63, 66, 67, 68, 69};\n\n    @Inject\n    public Client client;\n\n    @Inject\n    private InfernoAutoSplitterConfig config;\n\n    @Inject\n    private ClientToolbar clientToolbar;\n\n    // side panel\n    private NavigationButton navButton;\n    private InfernoAutoSplitterPanel panel;\n\n    @Provides\n    InfernoAutoSplitterConfig provideConfig(ConfigManager configManager) {\n        return configManager.getConfig(InfernoAutoSplitterConfig.class);\n    }\n\n\n    /*\n    void startUp\n    The function is called when Runelite loads the plugin or is enabled by the user. We create the panel and give it\n    access to what it needs\n    Parameters:\n        None\n    Returns:\n        None\n     */\n    @Override\n    protected void startUp()\n    {\n        final BufferedImage icon \u003d ImageUtil.loadImageResource(getClass(), \"/inferno_split_icon.png\");\n        panel \u003d new InfernoAutoSplitterPanel(client, writer, config, this);\n        navButton \u003d NavigationButton.builder().tooltip(\"Inferno Autosplit\")\n                .icon(icon).priority(6).panel(panel).build();\n        clientToolbar.addNavigation(navButton);\n\n        panel.startPanel();\n    }\n\n    /*\n    void shutDown\n    Called when the user disables the plugin. We disconnect from the LiveSplit Server\n    Parameters:\n        None\n    Returns:\n        None\n     */\n    @Override\n    protected void shutDown()\n    {\n        clientToolbar.removeNavigation(navButton);\n        panel.disconnect();  // terminates active socket\n    }\n\n    /*\n    void onChatMessage\n    Called every time the client receives a message in the chat box. For each message we check to see if the text contains what wave we\u0027re on in the inferno\n    Parameters:\n        event (ChatMessage): The object that contains the chat message text\n    Returns:\n        None\n     */\n    @Subscribe\n    public void onChatMessage(ChatMessage event) {\n\n        // Does the message received show\n        if (event.getMessage().contains(\"Wave:\")) {\n\n            boolean foundWave \u003d false;\n            int i \u003d 0;\n\n            while (i \u003c SPLIT_WAVES.length \u0026\u0026 !foundWave) {\n\n                if (event.getMessage().contains(\"Wave: \" + SPLIT_WAVES[i])) {\n\n                    foundWave \u003d true;\n                    sendMessage(\"split\");\n                }\n                i++;\n            }\n        } else if (event.getMessage().contains(\"Your TzKal-Zuk\")) {\n            sendMessage(\"split\");\n        }\n    }\n\n    /*\n    void onGameTick\n    Called each game tick. We check to see if we\u0027re in the inferno and if it has been 10 ticks since entering, we tell LiveSplit to start the timer\n    Parameters:\n        None\n    Returns:\n        None\n     */\n    @Subscribe\n    public void onGameTick(GameTick event) {\n\n        // Are we in the inferno?\n        if (lastTick !\u003d -1 \u0026\u0026 isInCaves()) {\n\n            // Get the time since entering the instance\n            int currTick \u003d client.getTickCount() - lastTick;\n\n            // If the time since is 10, we tell livesplit to reset and then start the timer\n            if (currTick \u003d\u003d 11) {\n                sendMessage(\"reset\");\n                sendMessage(\"starttimer\");\n            }\n        }\n    }\n\n    /*\n    void onGameStateChanged\n    Called when the game state of the client changes. This event fires when we jump into the inferno and some other non related reasons\n    Parameters:\n        event (GameStateChanged): The object which contains the value of the current game state. We want LOGGED_IN\n    Returns:\n        None\n     */\n    @Subscribe\n    public void onGameStateChanged(GameStateChanged event) {\n\n        if (!event.getGameState().equals(GameState.LOGGED_IN)) {\n\n            if (client.getTickCount() \u003d\u003d 0) {\n                lastTick \u003d -1;\n            } else {\n                lastTick \u003d client.getTickCount();\n            }\n\n        }\n    }\n\n    /*\n    boolean isInCaves\n    Lets us know if we are in the inferno\n    Parameters:\n        None\n    Returns:\n        True if we are in the inferno, false otherwise\n     */\n    public boolean isInCaves() {\n        return client.getVarbitValue(11878) \u003d\u003d 1;\n    }\n\n    /*\n    void sendMessage\n    Sends a message to the LiveSplit server\n    Parameters:\n        message (String): The message we are sending\n    Returns:\n        None\n     */\n    private void sendMessage(String message) {\n\n        if (writer !\u003d null) {\n            writer.write(message + \"\\r\\n\");\n            writer.flush();\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\InfernoAutoSplitter\\InfernoAutoSplitterPlugin.java"},{"fileName":"InfernoAutoSplitterTest.java","content":"package com.InfernoAutoSplitter;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class InfernoAutoSplitterTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(InfernoAutoSplitterPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\InfernoAutoSplitter\\InfernoAutoSplitterTest.java"}]},{"commit":"10f4ceda7fb044f006d0aecc449afcf2339acfa0","repository":"https://github.com/hex-agon/mastering-mixology.git","internalName":"mastering-mixology","files":[{"fileName":"MasteringMixologyConfig.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Notification;\nimport net.runelite.client.config.Range;\n\nimport java.awt.Color;\n\nimport static work.fking.masteringmixology.MasteringMixologyConfig.CONFIG_GROUP;\n\n@ConfigGroup(CONFIG_GROUP)\npublic interface MasteringMixologyConfig extends Config {\n\n    String CONFIG_GROUP \u003d \"masteringmixology\";\n\n    @ConfigSection(\n            name \u003d \"Highlights\",\n            description \u003d \"Highlighting related configuration\",\n            position \u003d 10\n    )\n    String HIGHLIGHTS \u003d \"Highlights\";\n\n    @ConfigItem(\n            keyName \u003d \"inventoryPotionTags\",\n            name \u003d \"Inventory Potion Tags\",\n            description \u003d \"How potions should be tagged in the inventory\",\n            position \u003d 1\n    )\n    default InventoryPotionTagType inventoryPotionTagType() {\n        return InventoryPotionTagType.WHITE;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"potionOrderSorting\",\n            name \u003d \"Order sorting\",\n            description \u003d \"Determines how potion orders are sorted in the interface\",\n            position \u003d 1\n    )\n    default PotionOrderSorting potionOrderSorting() {\n        return PotionOrderSorting.VANILLA;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"highlightLevers\",\n            name \u003d \"Highlight levers\",\n            description \u003d \"Highlight levers\",\n            position \u003d 2\n    )\n    default boolean highlightLevers() {\n        return true;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"highlightStations\",\n            name \u003d \"Highlight stations\",\n            description \u003d \"Toggles alchemical station highlighting on or off\",\n            position \u003d 2\n    )\n    default boolean highlightStations() {\n        return true;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"highlightQuickActionEvents\",\n            name \u003d \"Highlight quick-action events\",\n            description \u003d \"Toggles station quick-action events highlighting on or off\",\n            position \u003d 2\n    )\n    default boolean highlightQuickActionEvents() {\n        return true;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"displayResin\",\n            name \u003d \"Display resin amount\",\n            description \u003d \"Display total resin amounts\",\n            position \u003d 2\n    )\n    default boolean displayResin() {\n        return false;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"stationHighlightColor\",\n            name \u003d \"Station color\",\n            description \u003d \"Configures the default station highlight color\",\n            position \u003d 3\n    )\n    default Color stationHighlightColor() {\n        return Color.MAGENTA;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"stationQuickActionHighlightColor\",\n            name \u003d \"Quick-action color\",\n            description \u003d \"Configures the station quick-action highlight color\",\n            position \u003d 4\n    )\n    default Color stationQuickActionHighlightColor() {\n        return Color.GREEN;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"notifyDigweed\",\n            name \u003d \"Notify DigWeed\",\n            description \u003d \"Toggles digweed notifications on or off\",\n            position \u003d 5\n    )\n    default Notification notifyDigWeed() {\n        return Notification.ON;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"highlightDigweed\",\n            name \u003d \"Highlight DigWeed\",\n            description \u003d \"Toggles digweed highlighting on or off\",\n            position \u003d 6\n    )\n    default boolean highlightDigWeed() {\n        return true;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"digweedHighlightColor\",\n            name \u003d \"DigWeed color\",\n            description \u003d \"Configures the digweed highlight color\",\n            position \u003d 7\n    )\n    default Color digweedHighlightColor() {\n        return Color.GREEN;\n    }\n\n    @ConfigItem(\n            keyName \u003d \"soundEffectAlembic\",\n            name \u003d \"Fix Alembic quick-action sound effect\",\n            description \u003d \"Fixes the Alembic quick-action sound effect to play at the correct time\",\n            position \u003d 8\n    )\n    default boolean soundEffectAlembic() {\n        return true;\n    }\n\n    @ConfigItem(\n            section \u003d HIGHLIGHTS,\n            keyName \u003d \"highlightBorderWidth\",\n            name \u003d \"Border width\",\n            description \u003d \"Configures the border width of the object highlights\"\n    )\n    default int highlightBorderWidth() {\n        return 2;\n    }\n\n    @ConfigItem(\n            section \u003d HIGHLIGHTS,\n            keyName \u003d \"highlightFeather\",\n            name \u003d \"Feather\",\n            description \u003d \"Configures the amount of \u0027feathering\u0027 to be applied to the object highlights\"\n    )\n    default int highlightFeather() {\n        return 1;\n    }\n\n    @ConfigSection(\n            name \u003d \"Reward Tracking\",\n            description \u003d \"Track your progress towards rewards\",\n            position \u003d 13\n    )\n    String REWARD_TRACKING \u003d \"RewardTracking\";\n\n    @ConfigItem(\n            section \u003d REWARD_TRACKING,\n            keyName \u003d \"selectedReward\",\n            name \u003d \"Selected Reward\",\n            description \u003d \"Select a reward to track resin for\",\n            position \u003d 1\n    )\n    default RewardItem selectedReward() {\n        return RewardItem.NONE;\n    }\n\n    @ConfigItem(\n            section \u003d REWARD_TRACKING,\n            keyName \u003d \"rewardQuantity\",\n            name \u003d \"Reward Quantity\",\n            description \u003d \"Set the quantity for repeatable rewards\",\n            position \u003d 2\n    )\n    @Range(\n            min \u003d 1,\n            max \u003d 100000\n    )\n    default int rewardQuantity() {\n        return 1;\n    }\n\n    @ConfigItem(\n            section \u003d REWARD_TRACKING,\n            keyName \u003d \"showResinBars\",\n            name \u003d \"Show Resin Bars\",\n            description \u003d \"Toggle to display or hide the resin progress bars\",\n            position \u003d 3\n    )\n    default boolean showResinBars() {\n        return true;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/MasteringMixologyConfig.java"},{"fileName":"RewardItem.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.api.gameval.ItemID;\nimport static work.fking.masteringmixology.PotionComponent.AGA;\nimport static work.fking.masteringmixology.PotionComponent.LYE;\nimport static work.fking.masteringmixology.PotionComponent.MOX;\n\npublic enum RewardItem {\n    NONE(\"None\", 0, false, 0, 0, 0),\n    APPRENTICE_POTION_PACK(\"Apprentice Potion Pack\", ItemID.MM_POTION_PACK_LOW, true, 420, 70, 30),\n    ADEPT_POTION_PACK(\"Adept Potion Pack\", ItemID.MM_POTION_PACK_MED, true, 180, 440, 70),\n    EXPERT_POTION_PACK(\"Expert Potion Pack\", ItemID.MM_POTION_PACK_HIGH, true, 410, 320, 480),\n    PRESCRIPTION_GOGGLES(\"Prescription Goggles\", ItemID.MM_ALCHEMIST_HAT, false, 8600, 7000, 9350),\n    ALCHEMIST_LABCOAT(\"Alchemist Labcoat\", ItemID.MM_ALCHEMIST_BODY, false, 2250, 2800, 3700),\n    ALCHEMIST_PANTS(\"Alchemist Pants\", ItemID.MM_ALCHEMIST_LEGS, false, 2250, 2800, 3700),\n    ALCHEMIST_GLOVES(\"Alchemist Gloves\", ItemID.MM_ALCHEMIST_GLOVES, false, 2250, 2800, 3700),\n    REAGENT_POUCH(\"Reagent Pouch\", ItemID.MM_SECONDARY_POUCH, false, 13800, 11200, 15100),\n    POTION_STORAGE(\"Potion Storage\", ItemID.MM_POTION_STORAGE_UNLOCK_DUMMY, false, 7750, 6300, 8950),\n    CHUGGING_BARREL(\"Chugging Barrel\", ItemID.MM_PREPOT_DEVICE, false, 17250, 14000, 18600),\n    ALCHEMISTS_AMULET(\"Alchemist\u0027s Amulet\", ItemID.AMULET_OF_CHEMISTRY_IMBUED_UNCHARGED, false, 6900, 5650, 7400),\n    ALDARIUM(\"Aldarium\", ItemID.ALDARIUM, true, 80, 60, 90);\n\n    private final String itemName;\n    private final int itemId;\n    private final boolean repeatable;\n    private final int[] componentCost \u003d new int[PotionComponent.ENTRIES.length];\n\n    RewardItem(String itemName, int itemId, boolean repeatable, int moxResinCost, int agaResinCost, int lyeResinCost) {\n        this.itemName \u003d itemName;\n        this.itemId \u003d itemId;\n        this.repeatable \u003d repeatable;\n        this.componentCost[MOX.ordinal()] \u003d moxResinCost;\n        this.componentCost[AGA.ordinal()] \u003d agaResinCost;\n        this.componentCost[LYE.ordinal()] \u003d lyeResinCost;\n    }\n\n    public String itemName() {\n        return itemName;\n    }\n\n    public int itemId() {\n        return itemId;\n    }\n\n    public boolean isRepeatable() {\n        return repeatable;\n    }\n\n    public int componentCost(PotionComponent component) {\n        return componentCost[component.ordinal()];\n    }\n}","filePath":"src/main/java/work/fking/masteringmixology/RewardItem.java"},{"fileName":"MasteringMixologyOverlay.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\n\nimport javax.inject.Inject;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\n\npublic class MasteringMixologyOverlay extends Overlay {\n\n    private final MasteringMixologyPlugin plugin;\n    private final ModelOutlineRenderer modelOutlineRenderer;\n\n    @Inject\n    MasteringMixologyOverlay(MasteringMixologyPlugin plugin, ModelOutlineRenderer modelOutlineRenderer) {\n        this.plugin \u003d plugin;\n        this.modelOutlineRenderer \u003d modelOutlineRenderer;\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        for (var highlightedObject : plugin.highlightedObjects().values()) {\n            modelOutlineRenderer.drawOutline(highlightedObject.object(), highlightedObject.outlineWidth(), highlightedObject.color(), highlightedObject.feather());\n        }\n        return null;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/MasteringMixologyOverlay.java"},{"fileName":"MasteringMixologyPlugin.java","content":"package work.fking.masteringmixology;\n\nimport com.google.inject.Provides;\nimport net.runelite.api.Client;\nimport net.runelite.api.FontID;\nimport net.runelite.api.GameState;\nimport net.runelite.api.Player;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GraphicsObjectCreated;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.ScriptPostFired;\nimport net.runelite.api.events.SoundEffectPlayed;\nimport net.runelite.api.events.VarbitChanged;\nimport net.runelite.api.events.WidgetClosed;\nimport net.runelite.api.events.WidgetLoaded;\nimport net.runelite.api.gameval.InterfaceID;\nimport net.runelite.api.gameval.InventoryID;\nimport net.runelite.api.gameval.SpotanimID;\nimport net.runelite.api.gameval.VarPlayerID;\nimport net.runelite.api.gameval.VarbitID;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.api.widgets.WidgetPositionMode;\nimport net.runelite.api.widgets.WidgetTextAlignment;\nimport net.runelite.api.widgets.WidgetType;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.inject.Inject;\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport static work.fking.masteringmixology.AlchemyObject.AGA_LEVER;\nimport static work.fking.masteringmixology.AlchemyObject.LYE_LEVER;\nimport static work.fking.masteringmixology.AlchemyObject.MOX_LEVER;\nimport static work.fking.masteringmixology.PotionComponent.AGA;\nimport static work.fking.masteringmixology.PotionComponent.LYE;\nimport static work.fking.masteringmixology.PotionComponent.MOX;\n\n@PluginDescriptor(name \u003d \"Mastering Mixology\")\npublic class MasteringMixologyPlugin extends Plugin {\n\n    private static final Logger LOGGER \u003d LoggerFactory.getLogger(MasteringMixologyPlugin.class);\n\n    private static final int PROC_MASTERING_MIXOLOGY_BUILD_POTION_ORDERS \u003d 7063;\n    private static final int PROC_MASTERING_MIXOLOGY_BUILD_REAGENTS \u003d 7064;\n\n    private static final int VARBIT_POTION_ORDER_1 \u003d VarbitID.MM_LAB_ORDER_1_TYPE;\n    private static final int VARBIT_POTION_MODIFIER_1 \u003d VarbitID.MM_LAB_ORDER_1_MODIFIER;\n    private static final int VARBIT_POTION_ORDER_2 \u003d VarbitID.MM_LAB_ORDER_2_TYPE;\n    private static final int VARBIT_POTION_MODIFIER_2 \u003d VarbitID.MM_LAB_ORDER_2_MODIFIER;\n    private static final int VARBIT_POTION_ORDER_3 \u003d VarbitID.MM_LAB_ORDER_3_TYPE;\n    private static final int VARBIT_POTION_MODIFIER_3 \u003d VarbitID.MM_LAB_ORDER_3_MODIFIER;\n\n    static final int VARP_LYE_RESIN \u003d VarPlayerID.MIXOLOGY_LYE_POINTS;\n    static final int VARP_AGA_RESIN \u003d VarPlayerID.MIXOLOGY_AGA_POINTS;\n    static final int VARP_MOX_RESIN \u003d VarPlayerID.MIXOLOGY_MOX_POINTS;\n\n    private static final int VARBIT_ALEMBIC_PROGRESS \u003d VarbitID.MM_ALEMBIC_PROGRESS;\n    private static final int VARBIT_AGITATOR_PROGRESS \u003d VarbitID.MM_AGITATOR_PROGRESS;\n\n    private static final int VARBIT_AGITATOR_QUICKACTION \u003d VarbitID.MM_LAB_HIT_SKILLSHOT_AGITATOR;\n    private static final int VARBIT_ALEMBIC_QUICKACTION \u003d VarbitID.MM_LAB_HIT_SKILLSHOT_ALEMBIC;\n\n    private static final int VARBIT_MIXING_VESSEL_POTION \u003d VarbitID.MM_LAB_VESSEL_READY;\n    private static final int VARBIT_AGITATOR_POTION \u003d VarbitID.MM_LAB_AGITATOR_POTION;\n    private static final int VARBIT_RETORT_POTION \u003d VarbitID.MM_LAB_RETORT_POTION;\n    private static final int VARBIT_ALEMBIC_POTION \u003d VarbitID.MM_LAB_ALEMBIC_POTION;\n\n    private static final int VARBIT_DIGWEED_NORTH_EAST \u003d VarbitID.MM_HERB_READY_1;\n    private static final int VARBIT_DIGWEED_SOUTH_EAST \u003d VarbitID.MM_HERB_READY_2;\n    private static final int VARBIT_DIGWEED_SOUTH_WEST \u003d VarbitID.MM_HERB_READY_3;\n    private static final int VARBIT_DIGWEED_NORTH_WEST \u003d VarbitID.MM_HERB_READY_4;\n\n    private static final int SPOT_ANIM_AGITATOR \u003d SpotanimID.VFX_MACHINERY_ALCHEMY01_AGITATOR01;\n    private static final int SPOT_ANIM_ALEMBIC \u003d SpotanimID.VFX_MACHINERY_ALCHEMY01_ALEMBIC01;\n\n    private static final int COMPONENT_POTION_ORDERS_GROUP_ID \u003d InterfaceID.MM_OVERLAY;\n    private static final int COMPONENT_POTION_ORDERS \u003d InterfaceID.MmOverlay.CONTENT;\n\n    private static final int LABS_REGION_ID \u003d 5521;\n    private static final int LABS_REGION_PLANE \u003d 0;\n\n    private static final int FOUND_GEM \u003d 2655;\n\n    @Inject\n    private Client client;\n\n    @Inject\n    private MasteringMixologyConfig config;\n\n    @Inject\n    private OverlayManager overlayManager;\n\n    @Inject\n    private Notifier notifier;\n\n    @Inject\n    private ClientThread clientThread;\n\n    @Inject\n    private MasteringMixologyOverlay overlay;\n\n    @Inject\n    private InventoryPotionOverlay potionOverlay;\n\n    @Inject\n    private GoalInfoBoxOverlay goalInfoBoxOverlay;\n\n    private final Map\u003cAlchemyObject, HighlightedObject\u003e highlightedObjects \u003d new LinkedHashMap\u003c\u003e();\n    private List\u003cPotionOrder\u003e potionOrders \u003d Collections.emptyList();\n    private boolean inLab \u003d false;\n\n    private PotionType alembicPotionType;\n    private PotionType agitatorPotionType;\n    private PotionType retortPotionType;\n\n    private int previousAgitatorProgess;\n    private int previousAlembicProgress;\n\n    private int agitatorQuickActionTicks \u003d 0;\n    private int alembicQuickActionTicks \u003d 0;\n\n    private final Goal goal \u003d new Goal(RewardItem.NONE);\n\n    public Map\u003cAlchemyObject, HighlightedObject\u003e highlightedObjects() {\n        return highlightedObjects;\n    }\n\n    public boolean isInLab() {\n        return inLab;\n    }\n\n    /**\n     * @return true if the player is in the labs region (the area where the minigame takes place)\n     * the isInlab method only checks if they are inside the actual lab room where the UI is active\n     */\n    public boolean isInLabRegion() {\n        Player player \u003d client.getLocalPlayer();\n        return player !\u003d null \u0026\u0026 player.getWorldLocation().getRegionID() \u003d\u003d LABS_REGION_ID\n                \u0026\u0026 player.getWorldLocation().getPlane() \u003d\u003d LABS_REGION_PLANE;\n    }\n\n    @Provides\n    MasteringMixologyConfig provideConfig(ConfigManager configManager) {\n        return configManager.getConfig(MasteringMixologyConfig.class);\n    }\n\n    @Override\n    protected void startUp() {\n        overlayManager.add(overlay);\n        overlayManager.add(potionOverlay);\n        overlayManager.add(goalInfoBoxOverlay);\n\n        if (client.getGameState() \u003d\u003d GameState.LOGGED_IN) {\n            clientThread.invokeLater(this::initialize);\n        }\n    }\n\n    @Override\n    protected void shutDown() {\n        overlayManager.remove(overlay);\n        overlayManager.remove(potionOverlay);\n        overlayManager.remove(goalInfoBoxOverlay);\n        inLab \u003d false;\n    }\n\n    @Subscribe\n    public void onGameStateChanged(GameStateChanged event) {\n        if (event.getGameState() \u003d\u003d GameState.LOGIN_SCREEN || event.getGameState() \u003d\u003d GameState.HOPPING) {\n            highlightedObjects.clear();\n        }\n    }\n\n    @Subscribe\n    public void onWidgetLoaded(WidgetLoaded event) {\n        if (event.getGroupId() !\u003d COMPONENT_POTION_ORDERS_GROUP_ID) {\n            return;\n        }\n        initialize();\n    }\n\n    @Subscribe\n    public void onWidgetClosed(WidgetClosed event) {\n        if (event.getGroupId() !\u003d COMPONENT_POTION_ORDERS_GROUP_ID) {\n            return;\n        }\n\n        highlightedObjects.clear();\n        inLab \u003d false;\n    }\n\n    @Subscribe\n    public void onConfigChanged(ConfigChanged event) {\n        if (!event.getGroup().equals(MasteringMixologyConfig.CONFIG_GROUP)) {\n            return;\n        }\n\n        if (event.getKey().equals(\"potionOrderSorting\")) {\n            clientThread.invokeLater(this::updatePotionOrders);\n        }\n\n        if (event.getKey().equals(\"highlightStations\")) {\n            if (!config.highlightStations()) {\n                unHighlightAllStations();\n            } else {\n                clientThread.invokeLater(this::tryHighlightNextStation);\n            }\n        }\n\n        if (event.getKey().equals(\"displayResin\")) {\n            // Trigger the potion order update to refresh the resin display\n            clientThread.invokeLater(this::triggerPotionOrderUpdate);\n        }\n\n        if (!config.highlightDigWeed()) {\n            unHighlightObject(AlchemyObject.DIGWEED_NORTH_EAST);\n            unHighlightObject(AlchemyObject.DIGWEED_SOUTH_EAST);\n            unHighlightObject(AlchemyObject.DIGWEED_SOUTH_WEST);\n            unHighlightObject(AlchemyObject.DIGWEED_NORTH_WEST);\n        }\n\n        if (event.getKey().equals(\"selectedReward\") || event.getKey().equals(\"rewardQuantity\") || event.getKey().equals(\"showResinBars\")) {\n            recalculateGoalData();\n        }\n\n        if (config.highlightLevers()) {\n            highlightLevers();\n        } else {\n            unHighlightLevers();\n        }\n    }\n\n    @Subscribe\n    public void onItemContainerChanged(ItemContainerChanged event) {\n        if (!inLab || !config.highlightStations() || event.getContainerId() !\u003d InventoryID.INV) {\n            return;\n        }\n        // Do not update the highlight if there\u0027s a potion in a station\n        if (alembicPotionType !\u003d null || agitatorPotionType !\u003d null || retortPotionType !\u003d null) {\n            return;\n        }\n        var inventory \u003d event.getItemContainer();\n\n        // Find the first potion item and highlight its station\n        for (var item : inventory.getItems()) {\n            var potionType \u003d PotionType.fromItemId(item.getId());\n\n            if (potionType \u003d\u003d null || potionType.modifiedItemId() \u003d\u003d item.getId()) {\n                continue;\n            }\n            for (var order : potionOrders) {\n                if (order.potionType() \u003d\u003d potionType \u0026\u0026 !order.fulfilled()) {\n                    unHighlightAllStations();\n                    highlightObject(order.potionModifier().alchemyObject(), config.stationHighlightColor());\n                    return;\n                }\n            }\n        }\n    }\n\n    @Subscribe\n    public void onVarbitChanged(VarbitChanged event) {\n        var varbitId \u003d event.getVarbitId();\n        var varpId \u003d event.getVarpId();\n        var value \u003d event.getValue();\n\n        // Whenever a potion is delivered, all the potion order related varbits are reset to 0 first then\n        // set to the new values. We can use this to clear all the stations.\n        if (varbitId \u003d\u003d VARBIT_POTION_ORDER_1) {\n            if (value \u003d\u003d 0) {\n                unHighlightAllStations();\n            } else {\n                clientThread.invokeAtTickEnd(this::updatePotionOrders);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_ALEMBIC_POTION) {\n            if (value \u003d\u003d 0) {\n                // Finished crystalising\n                unHighlightObject(AlchemyObject.ALEMBIC);\n                tryFulfillOrder(alembicPotionType, PotionModifier.CRYSTALISED);\n                tryHighlightNextStation();\n                LOGGER.debug(\"Finished crystalising {}\", alembicPotionType);\n                alembicPotionType \u003d null;\n            } else {\n                alembicPotionType \u003d PotionType.fromIdx(value - 1);\n                LOGGER.debug(\"Alembic potion type: {}\", alembicPotionType);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_AGITATOR_POTION) {\n            if (value \u003d\u003d 0) {\n                // Finished homogenising\n                unHighlightObject(AlchemyObject.AGITATOR);\n                tryFulfillOrder(agitatorPotionType, PotionModifier.HOMOGENOUS);\n                tryHighlightNextStation();\n                LOGGER.debug(\"Finished homogenising {}\", agitatorPotionType);\n                agitatorPotionType \u003d null;\n            } else {\n                agitatorPotionType \u003d PotionType.fromIdx(value - 1);\n                LOGGER.debug(\"Agitator potion type: {}\", agitatorPotionType);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_RETORT_POTION) {\n            if (value \u003d\u003d 0) {\n                // Finished concentrating\n                unHighlightObject(AlchemyObject.RETORT);\n                tryFulfillOrder(retortPotionType, PotionModifier.CONCENTRATED);\n                tryHighlightNextStation();\n                LOGGER.debug(\"Finished concentrating {}\", retortPotionType);\n                retortPotionType \u003d null;\n            } else {\n                retortPotionType \u003d PotionType.fromIdx(value - 1);\n                LOGGER.debug(\"Retort potion type: {}\", retortPotionType);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_DIGWEED_NORTH_EAST) {\n            if (value \u003d\u003d 1) {\n                if (config.highlightDigWeed()) {\n                    highlightObject(AlchemyObject.DIGWEED_NORTH_EAST, config.digweedHighlightColor());\n                }\n                notifier.notify(config.notifyDigWeed(), \"A digweed has spawned north east.\");\n            } else {\n                unHighlightObject(AlchemyObject.DIGWEED_NORTH_EAST);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_DIGWEED_SOUTH_EAST) {\n            if (value \u003d\u003d 1) {\n                if (config.highlightDigWeed()) {\n                    highlightObject(AlchemyObject.DIGWEED_SOUTH_EAST, config.digweedHighlightColor());\n                }\n                notifier.notify(config.notifyDigWeed(), \"A digweed has spawned south east.\");\n            } else {\n                unHighlightObject(AlchemyObject.DIGWEED_SOUTH_EAST);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_DIGWEED_SOUTH_WEST) {\n            if (value \u003d\u003d 1) {\n                if (config.highlightDigWeed()) {\n                    highlightObject(AlchemyObject.DIGWEED_SOUTH_WEST, config.digweedHighlightColor());\n                }\n                notifier.notify(config.notifyDigWeed(), \"A digweed has spawned south west.\");\n            } else {\n                unHighlightObject(AlchemyObject.DIGWEED_SOUTH_WEST);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_DIGWEED_NORTH_WEST) {\n            if (value \u003d\u003d 1) {\n                if (config.highlightDigWeed()) {\n                    highlightObject(AlchemyObject.DIGWEED_NORTH_WEST, config.digweedHighlightColor());\n                }\n                notifier.notify(config.notifyDigWeed(), \"A digweed has spawned north west.\");\n            } else {\n                unHighlightObject(AlchemyObject.DIGWEED_NORTH_WEST);\n            }\n        } else if (varbitId \u003d\u003d VARBIT_AGITATOR_PROGRESS) {\n            if (agitatorQuickActionTicks \u003d\u003d 2) {\n                // quick action was triggered two ticks ago, so it\u0027s now too late\n                resetStationHighlight(AlchemyObject.AGITATOR);\n                agitatorQuickActionTicks \u003d 0;\n            }\n            if (agitatorQuickActionTicks \u003d\u003d 1) {\n                agitatorQuickActionTicks \u003d 2;\n            }\n            if (value \u003c previousAgitatorProgess) {\n                // progress was set back due to a quick action failure\n                resetStationHighlight(AlchemyObject.AGITATOR);\n            }\n            previousAgitatorProgess \u003d value;\n        } else if (varbitId \u003d\u003d VARBIT_ALEMBIC_PROGRESS) {\n            if (alembicQuickActionTicks \u003d\u003d 1) {\n                // quick action was triggered last tick, so it\u0027s now too late\n                resetStationHighlight(AlchemyObject.ALEMBIC);\n                alembicQuickActionTicks \u003d 0;\n            }\n            if (value \u003c previousAlembicProgress) {\n                // progress was set back due to a quick action failure\n                resetStationHighlight(AlchemyObject.ALEMBIC);\n            }\n            previousAlembicProgress \u003d value;\n        } else if (varbitId \u003d\u003d VARBIT_AGITATOR_QUICKACTION) {\n            // agitator quick action was just successfully popped\n            resetStationHighlight(AlchemyObject.AGITATOR);\n        } else if (varbitId \u003d\u003d VARBIT_ALEMBIC_QUICKACTION) {\n            // alembic quick action was just successfully popped\n            resetStationHighlight(AlchemyObject.ALEMBIC);\n        } else if (varpId \u003d\u003d VARP_MOX_RESIN || varpId \u003d\u003d VARP_AGA_RESIN || varpId \u003d\u003d VARP_LYE_RESIN) {\n            recalculateGoalData();\n        }\n    }\n\n    @Subscribe\n    public void onSoundEffectPlayed(SoundEffectPlayed event) {\n        if (inLab \u0026\u0026 alembicPotionType !\u003d null \u0026\u0026 event.getSoundId() \u003d\u003d FOUND_GEM \u0026\u0026 event.getDelay() \u003e 0 \u0026\u0026 config.soundEffectAlembic()) {\n            LOGGER.debug(\"client found_gem sound effect detected during Alembic, blocking\");\n            event.consume();\n        }\n    }\n\n    @Subscribe\n    public void onGraphicsObjectCreated(GraphicsObjectCreated event) {\n        var spotAnimId \u003d event.getGraphicsObject().getId();\n\n        if (!config.highlightQuickActionEvents()) {\n            return;\n        }\n        if (spotAnimId \u003d\u003d SPOT_ANIM_ALEMBIC \u0026\u0026 alembicPotionType !\u003d null) {\n            highlightObject(AlchemyObject.ALEMBIC, config.stationQuickActionHighlightColor());\n\n            if (config.soundEffectAlembic()) {\n                LOGGER.debug(\"Playing manual found_gem sound effect\");\n                client.playSoundEffect(FOUND_GEM);\n            }\n\n            // start counting ticks for alembic so we know to un-highlight on the next alembic varbit update\n            // note this quick action has a 1 tick window, so we use an int that goes 0 -\u003e 1 -\u003e unhighlight\n            alembicQuickActionTicks \u003d 1;\n        }\n\n        if (spotAnimId \u003d\u003d SPOT_ANIM_AGITATOR \u0026\u0026 agitatorPotionType !\u003d null) {\n            highlightObject(AlchemyObject.AGITATOR, config.stationQuickActionHighlightColor());\n            // start counting ticks for agitator so we know to un-highlight on the next agitator varbit update\n            // note this quick action has a 2-tick window, so we use an int that goes 0 -\u003e 1 -\u003e 2 -\u003e unhighlight\n            agitatorQuickActionTicks \u003d 1;\n        }\n    }\n\n    @Subscribe\n    public void onScriptPostFired(ScriptPostFired event) {\n        var scriptId \u003d event.getScriptId();\n        if (scriptId !\u003d PROC_MASTERING_MIXOLOGY_BUILD_POTION_ORDERS \u0026\u0026 scriptId !\u003d PROC_MASTERING_MIXOLOGY_BUILD_REAGENTS) {\n            return;\n        }\n        var baseWidget \u003d client.getWidget(COMPONENT_POTION_ORDERS);\n\n        if (baseWidget \u003d\u003d null) {\n            return;\n        }\n        if (scriptId \u003d\u003d PROC_MASTERING_MIXOLOGY_BUILD_POTION_ORDERS) {\n            updatePotionOrdersComponent(baseWidget);\n        } else {\n            appendResins(baseWidget);\n        }\n    }\n\n    private void updatePotionOrdersComponent(Widget baseWidget) {\n        // https://github.com/Joshua-F/cs2-scripts/blob/7cc261be62a40a6390de3e1f770259038660af10/scripts/%5Bproc%2Cscript7063%5D.cs2#L26\n        var children \u003d selectChildren(baseWidget, widget -\u003e widget.getType() \u003d\u003d WidgetType.GRAPHIC || widget.getType() \u003d\u003d WidgetType.TEXT);\n\n        if (children.isEmpty()) {\n            return;\n        }\n        /*\n         * Filtered children layout:\n         * TEXT - Potion Orders\n         * GRAPHIC - 5673\n         * TEXT - Mammoth-might mix\n         * GRAPHIC - 5672\n         * TEXT - \u003cstr\u003eMixalot\u003c/str\u003e\n         * GRAPHIC - 5673\n         * TEXT - Marley\u0027s moonlight\n         */\n        for (int i \u003d 0; i \u003c potionOrders.size(); i++) {\n            var order \u003d potionOrders.get(i);\n            LOGGER.debug(\"Updating component for order {}\", order);\n            var orderGraphic \u003d children.get(order.idx() * 2 + 1);\n            var orderText \u003d children.get(order.idx() * 2 + 2);\n\n            if (orderGraphic.getType() !\u003d WidgetType.GRAPHIC || orderText.getType() !\u003d WidgetType.TEXT) {\n                LOGGER.debug(\"Eep Eep! Selected the wrong components!\");\n                continue;\n            }\n            var builder \u003d new StringBuilder(orderText.getText());\n\n            if (order.fulfilled()) {\n                builder.append(\" (\u003ccol\u003d00ff00\u003edone!\u003c/col\u003e)\");\n            } else {\n                builder.append(\" (\").append(order.potionType().recipe()).append(\")\");\n            }\n            orderText.setText(builder.toString());\n\n            if (i !\u003d order.idx()) {\n                LOGGER.debug(\"Updating order {} position from {} to {}\", order, order.idx(), i);\n                // update component position\n                var y \u003d 20 + (i * 26) + 3;\n                orderGraphic.setOriginalY(y);\n                orderText.setOriginalY(y);\n\n                orderGraphic.revalidate();\n                orderText.revalidate();\n            }\n        }\n    }\n\n    private List\u003cWidget\u003e selectChildren(Widget parent, Predicate\u003cWidget\u003e filter) {\n        var children \u003d parent.getChildren();\n\n        if (children \u003d\u003d null) {\n            return List.of();\n        }\n        return Arrays.stream(children)\n                     .filter(filter)\n                     .collect(Collectors.toUnmodifiableList());\n    }\n\n    private void appendResins(Widget baseWidget) {\n        if (!config.displayResin()) {\n            return;\n        }\n        var parentWidth \u003d baseWidget.getWidth();\n        var dx \u003d parentWidth / 3;\n        int x \u003d dx / 2;\n\n        addResinText(baseWidget.createChild(-1, WidgetType.TEXT), x, VARP_MOX_RESIN, MOX);\n        addResinText(baseWidget.createChild(-1, WidgetType.TEXT), x + dx, VARP_AGA_RESIN, AGA);\n        addResinText(baseWidget.createChild(-1, WidgetType.TEXT), x + dx * 2, VARP_LYE_RESIN, LYE);\n    }\n\n    private void initialize() {\n        var ordersLayer \u003d client.getWidget(COMPONENT_POTION_ORDERS_GROUP_ID, 0);\n        if (ordersLayer \u003d\u003d null || ordersLayer.isSelfHidden()) {\n            return;\n        }\n\n        LOGGER.debug(\"initialize plugin\");\n        inLab \u003d true;\n        updatePotionOrders();\n        highlightLevers();\n        tryHighlightNextStation();\n    }\n\n    public void highlightObject(AlchemyObject alchemyObject, Color color) {\n        var worldView \u003d client.getTopLevelWorldView();\n\n        if (worldView \u003d\u003d null) {\n            return;\n        }\n        var localPoint \u003d LocalPoint.fromWorld(worldView, alchemyObject.coordinate());\n\n        if (localPoint \u003d\u003d null) {\n            return;\n        }\n        var tiles \u003d worldView.getScene().getTiles();\n        var tile \u003d tiles[worldView.getPlane()][localPoint.getSceneX()][localPoint.getSceneY()];\n\n        for (var gameObject : tile.getGameObjects()) {\n            if (gameObject \u003d\u003d null) {\n                continue;\n            }\n\n            if (gameObject.getId() \u003d\u003d alchemyObject.objectId()) {\n                highlightedObjects.put(alchemyObject, new HighlightedObject(gameObject, color, config.highlightBorderWidth(), config.highlightFeather()));\n                return;\n            }\n        }\n        // The aga lever is actually a wall decoration, not a scenery object\n        var decorativeObject \u003d tile.getDecorativeObject();\n\n        if (decorativeObject !\u003d null \u0026\u0026 decorativeObject.getId() \u003d\u003d alchemyObject.objectId()) {\n            highlightedObjects.put(alchemyObject, new HighlightedObject(decorativeObject, color, config.highlightBorderWidth(), config.highlightFeather()));\n        }\n    }\n\n    public void resetStationHighlight(AlchemyObject alchemyObject) {\n        if (config.highlightStations()) {\n            highlightObject(alchemyObject, config.stationHighlightColor());\n        }\n    }\n\n    public void unHighlightObject(AlchemyObject alchemyObject) {\n        highlightedObjects.remove(alchemyObject);\n    }\n\n    private void unHighlightAllStations() {\n        unHighlightObject(AlchemyObject.RETORT);\n        unHighlightObject(AlchemyObject.ALEMBIC);\n        unHighlightObject(AlchemyObject.AGITATOR);\n    }\n\n    private void highlightLevers() {\n        if (!config.highlightLevers()) {\n            return;\n        }\n\n        highlightObject(LYE_LEVER, LYE.color());\n        highlightObject(AGA_LEVER, AGA.color());\n        highlightObject(MOX_LEVER, MOX.color());\n    }\n\n    private void unHighlightLevers() {\n        unHighlightObject(LYE_LEVER);\n        unHighlightObject(AGA_LEVER);\n        unHighlightObject(MOX_LEVER);\n    }\n\n    private void updatePotionOrders() {\n        LOGGER.debug(\"Updating potion orders\");\n        potionOrders \u003d getPotionOrders();\n\n        var potionOrderSorting \u003d config.potionOrderSorting();\n\n        if (potionOrderSorting !\u003d PotionOrderSorting.VANILLA) {\n            LOGGER.debug(\"Orders pre-sort: {}\", potionOrders);\n            potionOrders.sort(potionOrderSorting.comparator());\n            LOGGER.debug(\"Sorted orders: {}\", potionOrders);\n        }\n\n        triggerPotionOrderUpdate();\n    }\n\n    public void triggerPotionOrderUpdate() {\n        // Trigger a fake varbit update to force run the clientscript proc\n        var varbitType \u003d client.getVarbit(VARBIT_POTION_ORDER_1);\n\n        if (varbitType !\u003d null) {\n            client.queueChangedVarp(varbitType.getIndex());\n        }\n    }\n\n    private void addResinText(Widget widget, int x, int varp, PotionComponent component) {\n        var amount \u003d client.getVarpValue(varp);\n        var color \u003d component.color().getRGB();\n\n        widget.setText(amount + \"\")\n              .setTextShadowed(true)\n              .setTextColor(color)\n              .setOriginalWidth(20)\n              .setOriginalHeight(15)\n              .setFontId(FontID.QUILL_8)\n              .setOriginalY(0)\n              .setOriginalX(x)\n              .setYPositionMode(WidgetPositionMode.ABSOLUTE_BOTTOM)\n              .setXTextAlignment(WidgetTextAlignment.CENTER)\n              .setYTextAlignment(WidgetTextAlignment.CENTER);\n\n        widget.revalidate();\n        LOGGER.debug(\"adding resin text {} at {} with color {}\", amount, x, color);\n    }\n\n    private void tryFulfillOrder(PotionType potionType, PotionModifier modifier) {\n        for (var order : potionOrders) {\n            if (order.potionType() \u003d\u003d potionType \u0026\u0026 order.potionModifier() \u003d\u003d modifier \u0026\u0026 !order.fulfilled()) {\n                LOGGER.debug(\"Order {} has been fulfilled\", order);\n                order.setFulfilled(true);\n                break;\n            }\n        }\n    }\n\n    private void tryHighlightNextStation() {\n        if (!config.highlightStations()) {\n            return;\n        }\n        var inventory \u003d client.getItemContainer(InventoryID.INV);\n\n        if (inventory \u003d\u003d null) {\n            return;\n        }\n\n        for (var order : potionOrders) {\n            if (order.fulfilled()) {\n                continue;\n            }\n            if (inventory.contains(order.potionType().itemId())) {\n                LOGGER.debug(\"Highlighting station for order {}\", order);\n                highlightObject(order.potionModifier().alchemyObject(), config.stationHighlightColor());\n                break;\n            }\n        }\n    }\n\n    private List\u003cPotionOrder\u003e getPotionOrders() {\n        var potionOrders \u003d new ArrayList\u003cPotionOrder\u003e(3);\n\n        for (int orderIdx \u003d 0; orderIdx \u003c 3; orderIdx++) {\n            var potionType \u003d getPotionType(orderIdx);\n            var potionModifier \u003d getPotionModifier(orderIdx);\n\n            if (potionType \u003d\u003d null || potionModifier \u003d\u003d null) {\n                continue;\n            }\n            potionOrders.add(new PotionOrder(orderIdx, potionType, potionModifier));\n        }\n        return potionOrders;\n    }\n\n    private PotionType getPotionType(int orderIdx) {\n        if (orderIdx \u003d\u003d 0) {\n            return PotionType.fromIdx(client.getVarbitValue(VARBIT_POTION_ORDER_1) - 1);\n        } else if (orderIdx \u003d\u003d 1) {\n            return PotionType.fromIdx(client.getVarbitValue(VARBIT_POTION_ORDER_2) - 1);\n        } else if (orderIdx \u003d\u003d 2) {\n            return PotionType.fromIdx(client.getVarbitValue(VARBIT_POTION_ORDER_3) - 1);\n        } else {\n            return null;\n        }\n    }\n\n    private PotionModifier getPotionModifier(int orderIdx) {\n        if (orderIdx \u003d\u003d 0) {\n            return PotionModifier.from(client.getVarbitValue(VARBIT_POTION_MODIFIER_1) - 1);\n        } else if (orderIdx \u003d\u003d 1) {\n            return PotionModifier.from(client.getVarbitValue(VARBIT_POTION_MODIFIER_2) - 1);\n        } else if (orderIdx \u003d\u003d 2) {\n            return PotionModifier.from(client.getVarbitValue(VARBIT_POTION_MODIFIER_3) - 1);\n        } else {\n            return null;\n        }\n    }\n\n    public Goal getGoal() {\n        return goal;\n    }\n\n    private void recalculateGoalData() {\n        goal.recalculate(config, client);\n    }\n\n    public static class HighlightedObject {\n\n        private final TileObject object;\n        private final Color color;\n        private final int outlineWidth;\n        private final int feather;\n\n        private HighlightedObject(TileObject object, Color color, int outlineWidth, int feather) {\n            this.object \u003d object;\n            this.color \u003d color;\n            this.outlineWidth \u003d outlineWidth;\n            this.feather \u003d feather;\n        }\n\n        public TileObject object() {\n            return object;\n        }\n\n        public Color color() {\n            return color;\n        }\n\n        public int outlineWidth() {\n            return outlineWidth;\n        }\n\n        public int feather() {\n            return feather;\n        }\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/MasteringMixologyPlugin.java"},{"fileName":"PotionModifier.java","content":"package work.fking.masteringmixology;\n\npublic enum PotionModifier {\n    // Clicking the quick-time event on the Agitator gives 14 experience, this event can happen 1-2 times\n    HOMOGENOUS(AlchemyObject.AGITATOR, 21),\n    // Each click on the Retort gives 2 experience for a max of 10 clicks\n    CONCENTRATED(AlchemyObject.RETORT, 20),\n    // Clicking the quick-time event on the Alembic gives 14 experience\n    CRYSTALISED(AlchemyObject.ALEMBIC, 14);\n\n    private static final PotionModifier[] TYPES \u003d PotionModifier.values();\n\n    private final AlchemyObject alchemyObject;\n    private final int quickActionExperience;\n\n    PotionModifier(AlchemyObject alchemyObject, int quickActionExperience) {\n        this.alchemyObject \u003d alchemyObject;\n        this.quickActionExperience \u003d quickActionExperience;\n    }\n\n    public static PotionModifier from(int potionModifierId) {\n        if (potionModifierId \u003c 0 || potionModifierId \u003e\u003d TYPES.length) {\n            return null;\n        }\n        return TYPES[potionModifierId];\n    }\n\n    public AlchemyObject alchemyObject() {\n        return alchemyObject;\n    }\n\n    public int quickActionExperience() {\n        return quickActionExperience;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionModifier.java"},{"fileName":"PotionOrder.java","content":"package work.fking.masteringmixology;\n\npublic class PotionOrder {\n\n    private final int idx;\n    private final PotionType potionType;\n    private final PotionModifier potionModifier;\n\n    private boolean fulfilled;\n\n    public PotionOrder(int idx, PotionType potionType, PotionModifier potionModifier) {\n        this.idx \u003d idx;\n        this.potionType \u003d potionType;\n        this.potionModifier \u003d potionModifier;\n    }\n\n    public int idx() {\n        return idx;\n    }\n\n    public PotionType potionType() {\n        return potionType;\n    }\n\n    public PotionModifier potionModifier() {\n        return potionModifier;\n    }\n\n    public void setFulfilled(boolean fulfilled) {\n        this.fulfilled \u003d fulfilled;\n    }\n\n    public boolean fulfilled() {\n        return fulfilled;\n    }\n\n    @Override\n    public String toString() {\n        return \"PotionOrder{\" +\n                \"idx\u003d\" + idx +\n                \", potionType\u003d\" + potionType +\n                \", potionModifier\u003d\" + potionModifier +\n                \u0027}\u0027;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionOrder.java"},{"fileName":"InventoryPotionTagType.java","content":"package work.fking.masteringmixology;\n\npublic enum InventoryPotionTagType {\n    NONE,\n    COLORED,\n    WHITE,\n}\n","filePath":"src/main/java/work/fking/masteringmixology/InventoryPotionTagType.java"},{"fileName":"AlchemyObject.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.gameval.ObjectID;\n\npublic enum AlchemyObject {\n    MOX_LEVER(ObjectID.MM_LAB_SWITCH_MOX, new WorldPoint(1395, 9324, 0)),\n    AGA_LEVER(ObjectID.MM_LAB_SWITCH_AGA, new WorldPoint(1394, 9324, 0)),\n    LYE_LEVER(ObjectID.MM_LAB_SWITCH_LYE, new WorldPoint(1393, 9324, 0)),\n    MIXING_VESSEL(ObjectID.MM_LAB_VESSEL, new WorldPoint(1394, 9326, 0)),\n    ALEMBIC(ObjectID.MM_LAB_MACHINE_ALEMBIC, new WorldPoint(1391, 9325, 0)),\n    AGITATOR(ObjectID.MM_LAB_MACHINE_AGITATOR, new WorldPoint(1393, 9329, 0)),\n    RETORT(ObjectID.MM_LAB_MACHINE_RETORT, new WorldPoint(1397, 9325, 0)),\n    CONVEYOR_BELT(ObjectID.MM_LAB_CONVEYOR, new WorldPoint(1394, 9331, 0)),\n    HOPPER(ObjectID.MM_LAB_HOPPER, new WorldPoint(1394, 9322, 0)),\n    DIGWEED_NORTH_EAST(ObjectID.MM_HERB_1, new WorldPoint(1399, 9331, 0)),\n    DIGWEED_SOUTH_EAST(ObjectID.MM_HERB_2, new WorldPoint(1399, 9322, 0)),\n    DIGWEED_SOUTH_WEST(ObjectID.MM_HERB_3, new WorldPoint(1389, 9322, 0)),\n    DIGWEED_NORTH_WEST(ObjectID.MM_HERB_4, new WorldPoint(1389, 9331, 0));\n\n    private final int objectId;\n    private final WorldPoint coordinate;\n\n    AlchemyObject(int objectId, WorldPoint coordinate) {\n        this.objectId \u003d objectId;\n        this.coordinate \u003d coordinate;\n    }\n\n    public int objectId() {\n        return objectId;\n    }\n\n    public WorldPoint coordinate() {\n        return coordinate;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/AlchemyObject.java"},{"fileName":"PotionComponent.java","content":"package work.fking.masteringmixology;\n\nimport java.awt.Color;\nimport net.runelite.api.gameval.SpriteID;\n\npublic enum PotionComponent {\n    MOX(\u0027M\u0027, \"03a9f4\", SpriteID.IconAlchemyChemicals01_20x20._0, MasteringMixologyPlugin.VARP_MOX_RESIN),\n    AGA(\u0027A\u0027, \"00e676\", SpriteID.IconAlchemyChemicals01_20x20._1, MasteringMixologyPlugin.VARP_AGA_RESIN),\n    LYE(\u0027L\u0027, \"e91e63\", SpriteID.IconAlchemyChemicals01_20x20._2, MasteringMixologyPlugin.VARP_LYE_RESIN);\n\n    public static final PotionComponent[] ENTRIES \u003d values();\n\n    private final char character;\n    private final String colorCode;\n    private final Color color;\n    private final int spriteId;\n    private final int resinVarpId;\n\n    PotionComponent(char character, String colorCode, int spriteId, int resinVarpId) {\n        this.character \u003d character;\n        this.colorCode \u003d colorCode;\n        this.color \u003d Color.decode(\"#\" + colorCode);\n        this.spriteId \u003d spriteId;\n        this.resinVarpId \u003d resinVarpId;\n    }\n\n    public char character() {\n        return character;\n    }\n\n    public String colorCode() {\n        return colorCode;\n    }\n\n    public Color color() {\n        return color;\n    }\n\n    public int spriteId() {\n        return spriteId;\n    }\n\n    public int resinVarpId() {\n        return resinVarpId;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionComponent.java"},{"fileName":"PotionComparators.java","content":"package work.fking.masteringmixology;\n\nimport java.util.Comparator;\n\npublic class PotionComparators {\n    // Sort by modifier, in the order CRYSTALISED \u003e HOMOGENOUS \u003e CONCENTRATED\n    // And then by PotionType name alphabetically\n    public static Comparator\u003cPotionOrder\u003e byStation() {\n        return Comparator.comparingInt((PotionOrder order) -\u003e {\n                    switch (order.potionModifier()) {\n                        case CRYSTALISED:\n                            return 0;\n                        case HOMOGENOUS:\n                            return 1;\n                        case CONCENTRATED:\n                            return 2;\n                        default:\n                            return Integer.MAX_VALUE;\n                    }\n                })\n                .thenComparing(order -\u003e order.potionType().name());\n    }\n\n    public static Comparator\u003cPotionOrder\u003e shortestPath() {\n        return Comparator.comparing(order -\u003e {\n            switch (order.potionModifier()) {\n                case CRYSTALISED:\n                    return 1;\n                case CONCENTRATED:\n                    return 2;\n                case HOMOGENOUS:\n                    return 3;\n                default:\n                    throw new IllegalStateException(\"Unexpected value: \" + order.potionModifier().toString());\n            }\n        });\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionComparators.java"},{"fileName":"GoalInfoBoxOverlay.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.game.SpriteManager;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.ComponentOrientation;\nimport net.runelite.client.ui.overlay.components.ImageComponent;\nimport net.runelite.client.ui.overlay.components.LineComponent;\nimport net.runelite.client.ui.overlay.components.PanelComponent;\nimport net.runelite.client.ui.overlay.components.ProgressBarComponent;\nimport net.runelite.client.ui.overlay.components.SplitComponent;\nimport net.runelite.client.util.ImageUtil;\nimport net.runelite.client.util.QuantityFormatter;\n\nimport javax.inject.Inject;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.Rectangle;\nimport java.awt.image.BufferedImage;\nimport java.text.DecimalFormat;\n\nclass GoalInfoBoxOverlay extends OverlayPanel {\n\n    private static final DecimalFormat DECIMAL_FORMAT \u003d new DecimalFormat(\"0.0\");\n    private static final int BORDER_SIZE \u003d 3;\n    private static final int VERTICAL_GAP \u003d 2;\n    private static final int ICON_AND_GOAL_GAP \u003d 5;\n    private static final Rectangle TOP_PANEL_BORDER \u003d new Rectangle(2, 0, 4, 4);\n    private static final int COMPONENT_SPRITE_SIZE \u003d 16;\n    private static final Color PROGRESS_BAR_BACKGROUND_COLOR \u003d new Color(61, 56, 49);\n\n    private final MasteringMixologyPlugin plugin;\n    private final MasteringMixologyConfig config;\n    private final ItemManager itemManager;\n    private final SpriteManager spriteManager;\n\n    private final PanelComponent topPanel \u003d new PanelComponent();\n\n    // Caching\n    private BufferedImage cachedRewardIcon;\n    private RewardItem cachedRewardItem;\n\n    private final BufferedImage[] componentSprites \u003d new BufferedImage[PotionComponent.ENTRIES.length];\n\n    @Inject\n    GoalInfoBoxOverlay(\n            MasteringMixologyPlugin plugin,\n            MasteringMixologyConfig config,\n            ItemManager itemManager,\n            SpriteManager spriteManager\n    ) {\n        super(plugin);\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n        this.itemManager \u003d itemManager;\n        this.spriteManager \u003d spriteManager;\n\n        setPosition(OverlayPosition.TOP_RIGHT);\n        setPriority(PRIORITY_MED);\n        panelComponent.setPreferredSize(new Dimension(250, 0));\n        panelComponent.setBorder(new Rectangle(BORDER_SIZE, BORDER_SIZE, BORDER_SIZE, BORDER_SIZE));\n        panelComponent.setGap(new Point(0, VERTICAL_GAP));\n\n        topPanel.setBorder(TOP_PANEL_BORDER);\n        topPanel.setBackgroundColor(null);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics) {\n        var goal \u003d plugin.getGoal();\n        var rewardItem \u003d goal.getRewardItem();\n\n        if (rewardItem \u003d\u003d RewardItem.NONE || !plugin.isInLabRegion()) {\n            return null;\n        }\n        topPanel.getChildren().clear();\n        graphics.setFont(FontManager.getRunescapeSmallFont());\n\n        // Build the top display with the affordable amount / goal amount\n        String goalAmountText \u003d \"\";\n        if (rewardItem.isRepeatable() \u0026\u0026 goal.getRewardQuantity() \u003e 1) {\n            goalAmountText \u003d QuantityFormatter.quantityToStackSize(goal.getItemsAffordable())\n                    + \"/\" + QuantityFormatter.quantityToStackSize(goal.getRewardQuantity());\n        }\n\n        var topLine \u003d LineComponent.builder()\n                                   .left(rewardItem.itemName())\n                                   .leftFont(FontManager.getRunescapeFont())\n                                   .right(goalAmountText)\n                                   .rightFont(FontManager.getRunescapeBoldFont())\n                                   .build();\n\n        // Build the bottom line with the overall progress percentage\n        var bottomLine \u003d LineComponent.builder()\n                                      .left(\"Progress:\")\n                                      .leftFont(FontManager.getRunescapeFont())\n                                      .right(DECIMAL_FORMAT.format(goal.getOverallProgress() * 100) + \"%\")\n                                      .rightFont(FontManager.getRunescapeFont())\n                                      .rightColor(goal.getOverallProgress() \u003e\u003d 1 ? Color.GREEN : Color.WHITE)\n                                      .build();\n\n        var textSplit \u003d SplitComponent.builder()\n                                      .first(topLine)\n                                      .second(bottomLine)\n                                      .orientation(ComponentOrientation.VERTICAL)\n                                      .build();\n\n        var rewardImageComponent \u003d new ImageComponent(getRewardImage(rewardItem));\n        var topInfoSplit \u003d SplitComponent.builder()\n                                         .first(rewardImageComponent)\n                                         .second(textSplit)\n                                         .orientation(ComponentOrientation.HORIZONTAL)\n                                         .gap(new Point(ICON_AND_GOAL_GAP, 0))\n                                         .build();\n\n        topPanel.getChildren().add(topInfoSplit);\n        panelComponent.getChildren().add(topPanel);\n\n        // Add a progress bar for each component\n        if (config.showResinBars()) {\n            for (var component : PotionComponent.ENTRIES) {\n                createProgressBar(goal, component);\n            }\n        }\n\n        return super.render(graphics);\n    }\n\n    private void createProgressBar(Goal goal, PotionComponent component) {\n        var data \u003d goal.getComponentData(component);\n        var componentSprite \u003d getComponentSprite(component);\n\n        if (componentSprite \u003d\u003d null) {\n            return;\n        }\n        var imageComponent \u003d new ImageComponent(componentSprite);\n        var progressBarComponent \u003d new ProgressBarComponent();\n\n        progressBarComponent.setForegroundColor(component.color());\n        progressBarComponent.setBackgroundColor(PROGRESS_BAR_BACKGROUND_COLOR);\n        progressBarComponent.setValue(data.percentageToGoal * 100);\n        progressBarComponent.setLeftLabel(QuantityFormatter.quantityToStackSize(data.currentAmount));\n        progressBarComponent.setRightLabel(QuantityFormatter.quantityToStackSize(data.goalAmount));\n\n        var progressBarSplit \u003d SplitComponent.builder()\n                                             .first(imageComponent)\n                                             .second(progressBarComponent)\n                                             .orientation(ComponentOrientation.HORIZONTAL)\n                                             .gap(new Point(ICON_AND_GOAL_GAP, 0))\n                                             .build();\n\n        panelComponent.getChildren().add(progressBarSplit);\n    }\n\n    private BufferedImage getRewardImage(RewardItem rewardItem) {\n        if (cachedRewardItem !\u003d rewardItem) {\n            cachedRewardItem \u003d rewardItem;\n            cachedRewardIcon \u003d itemManager.getImage(rewardItem.itemId());\n        }\n        return cachedRewardIcon;\n    }\n\n    private BufferedImage getComponentSprite(PotionComponent component) {\n        var sprite \u003d componentSprites[component.ordinal()];\n\n        if (sprite \u003d\u003d null) {\n            sprite \u003d componentSprites[component.ordinal()] \u003d createComponentSprite(component);\n        }\n        return sprite;\n    }\n\n    private BufferedImage createComponentSprite(PotionComponent component) {\n        var sprite \u003d spriteManager.getSprite(component.spriteId(), 0);\n        if (sprite !\u003d null) {\n            // Resize and center the sprite\n            var resizedImage \u003d ImageUtil.resizeImage(sprite, COMPONENT_SPRITE_SIZE, COMPONENT_SPRITE_SIZE, true);\n            return ImageUtil.resizeCanvas(resizedImage, COMPONENT_SPRITE_SIZE, COMPONENT_SPRITE_SIZE);\n        }\n        return null;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/GoalInfoBoxOverlay.java"},{"fileName":"PotionType.java","content":"package work.fking.masteringmixology;\n\nimport com.google.common.collect.ImmutableMap;\n\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport net.runelite.api.gameval.ItemID;\nimport static work.fking.masteringmixology.PotionComponent.AGA;\nimport static work.fking.masteringmixology.PotionComponent.LYE;\nimport static work.fking.masteringmixology.PotionComponent.MOX;\n\npublic enum PotionType {\n    MAMMOTH_MIGHT_MIX(ItemID.MM_POTION_MMM_UNFINISHED, ItemID.MM_POTION_MMM_FINISHED, 1900, MOX, MOX, MOX),\n    MYSTIC_MANA_AMALGAM(ItemID.MM_POTION_MMA_UNFINISHED, ItemID.MM_POTION_MMA_FINISHED, 2150, MOX, MOX, AGA),\n    MARLEYS_MOONLIGHT(ItemID.MM_POTION_MML_UNFINISHED, ItemID.MM_POTION_MML_FINISHED, 2400, MOX, MOX, LYE),\n    ALCO_AUGMENTATOR(ItemID.MM_POTION_AAA_UNFINISHED, ItemID.MM_POTION_AAA_FINISHED, 1900, AGA, AGA, AGA),\n    AZURE_AURA_MIX(ItemID.MM_POTION_AAM_UNFINISHED, ItemID.MM_POTION_AAM_FINISHED, 2650, AGA, AGA, MOX),\n    AQUALUX_AMALGAM(ItemID.MM_POTION_AAL_UNFINISHED, ItemID.MM_POTION_AAL_FINISHED, 2900, AGA, LYE, AGA),\n    LIPLACK_LIQUOR(ItemID.MM_POTION_LLL_UNFINISHED, ItemID.MM_POTION_LLL_FINISHED, 1900, LYE, LYE, LYE),\n    MEGALITE_LIQUID(ItemID.MM_POTION_LLM_UNFINISHED, ItemID.MM_POTION_LLM_FINISHED, 3150, MOX, LYE, LYE),\n    ANTI_LEECH_LOTION(ItemID.MM_POTION_LLA_UNFINISHED, ItemID.MM_POTION_LLA_FINISHED, 3400, AGA, LYE, LYE),\n    MIXALOT(ItemID.MM_POTION_MAL_UNFINISHED, ItemID.MM_POTION_MAL_FINISHED, 3650, MOX, AGA, LYE);\n\n    public static final PotionType[] TYPES \u003d PotionType.values();\n\n    private static final Map\u003cInteger, PotionType\u003e ITEM_MAP;\n\n    static {\n        var builder \u003d new ImmutableMap.Builder\u003cInteger, PotionType\u003e();\n        for (var p : PotionType.values()) {\n            builder.put(p.itemId(), p);\n            builder.put(p.modifiedItemId(), p);\n        }\n        ITEM_MAP \u003d builder.build();\n    }\n\n    private final int itemId;\n    private final int modifiedItemId;\n    private final String recipe;\n    private final String abbreviation;\n    private final int experience;\n    private final PotionComponent[] components;\n\n\n    PotionType(int itemId, int modifiedItemId, int experience, PotionComponent... components) {\n        this.itemId \u003d itemId;\n        this.modifiedItemId \u003d modifiedItemId;\n        this.recipe \u003d colorizeRecipe(components);\n        this.experience \u003d experience;\n        this.components \u003d components;\n        this.abbreviation \u003d \"\" + components[0].character() + components[1].character() + components[2].character();\n    }\n\n    public static PotionType fromItemId(int itemId) {\n        return ITEM_MAP.get(itemId);\n    }\n\n    public static PotionType fromIdx(int potionTypeId) {\n        if (potionTypeId \u003c 0 || potionTypeId \u003e\u003d TYPES.length) {\n            return null;\n        }\n        return TYPES[potionTypeId];\n    }\n\n    private static String colorizeRecipe(PotionComponent[] components) {\n        if (components.length !\u003d 3) {\n            throw new IllegalArgumentException(\"Invalid potion components: \" + Arrays.toString(components));\n        }\n        return colorizeRecipeComponent(components[0])\n                + colorizeRecipeComponent(components[1])\n                + colorizeRecipeComponent(components[2]);\n    }\n\n    private static String colorizeRecipeComponent(PotionComponent component) {\n        return \"\u003ccol\u003d\" + component.colorCode() + \"\u003e\" + component.character() + \"\u003c/col\u003e\";\n    }\n\n    public int itemId() {\n        return itemId;\n    }\n\n    public int modifiedItemId() {\n        return modifiedItemId;\n    }\n\n    public String recipe() {\n        return recipe;\n    }\n\n    public int experience() {\n        return experience;\n    }\n\n    public PotionComponent[] components() {\n        return components;\n    }\n\n    public String abbreviation() {\n        return abbreviation;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionType.java"},{"fileName":"Goal.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.api.Client;\n\nimport java.util.EnumMap;\nimport java.util.Map;\n\npublic class Goal {\n    private RewardItem rewardItem;\n    private double overallProgress \u003d 0.0;\n    private int itemsAffordable \u003d 0;\n    private int rewardQuantity \u003d 1;\n\n    /*\n     * Whenever we recalculate the goal, we will create a new ComponentData object for each component for caching\n     */\n    private final Map\u003cPotionComponent, ComponentData\u003e componentDataMap \u003d new EnumMap\u003c\u003e(PotionComponent.class);\n\n    public Goal(RewardItem rewardItem) {\n        this.rewardItem \u003d rewardItem;\n    }\n\n    public RewardItem getRewardItem() {\n        return rewardItem;\n    }\n\n    public double getOverallProgress() {\n        return overallProgress;\n    }\n\n    public int getItemsAffordable() {\n        return itemsAffordable;\n    }\n\n    public int getRewardQuantity() {\n        return rewardQuantity;\n    }\n\n    public ComponentData getComponentData(PotionComponent component) {\n        return componentDataMap.get(component);\n    }\n\n    public void recalculate(MasteringMixologyConfig config, Client client) {\n        rewardItem \u003d config.selectedReward();\n        rewardQuantity \u003d rewardItem.isRepeatable() ? config.rewardQuantity() : 1;\n\n        // Create the component data for each component\n        for (var component : PotionComponent.ENTRIES) {\n            int currentAmount \u003d client.getVarpValue(component.resinVarpId());\n            int baseGoalAmount \u003d rewardItem.componentCost(component);\n            componentDataMap.put(component, new ComponentData(currentAmount, baseGoalAmount, rewardQuantity));\n        }\n\n        // Calculate the amount of items affordable based on the component with the lowest affordable amount\n        int minAffordable \u003d componentDataMap.values().stream()\n                .mapToInt(data -\u003e data.affordableAmount)\n                .min()\n                .orElse(0);\n        itemsAffordable \u003d Math.min(minAffordable, rewardQuantity);\n\n        // Overall progress is the average of all component progress\n        overallProgress \u003d componentDataMap.values().stream()\n                .mapToDouble(data -\u003e data.percentageToGoal)\n                .average()\n                .orElse(0.0);\n    }\n\n    public static class ComponentData {\n        final int currentAmount;\n        final int goalAmount;\n        final double percentageToGoal;\n        final int affordableAmount;\n\n        ComponentData(int currentAmount, int baseGoalAmount, int rewardQuantity) {\n            this.currentAmount \u003d currentAmount;\n            this.goalAmount \u003d baseGoalAmount * rewardQuantity;\n\n            if (goalAmount \u003d\u003d 0) {\n                this.percentageToGoal \u003d 1.0;\n                this.affordableAmount \u003d rewardQuantity;\n            } else {\n                this.percentageToGoal \u003d Math.min((double) currentAmount / goalAmount, 1.0);\n                this.affordableAmount \u003d currentAmount / baseGoalAmount;\n            }\n        }\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/Goal.java"},{"fileName":"PotionOrderSorting.java","content":"package work.fking.masteringmixology;\n\nimport java.util.Comparator;\n\npublic enum PotionOrderSorting {\n    VANILLA(\"Vanilla (random)\", null),\n    BY_STATION(\"By station\", PotionComparators.byStation()),\n    SHORTEST_PATH(\"Shortest Path\", PotionComparators.shortestPath());\n\n    private final String name;\n    private final Comparator\u003cPotionOrder\u003e comparator;\n\n    PotionOrderSorting(String name, Comparator\u003cPotionOrder\u003e comparator) {\n        this.name \u003d name;\n        this.comparator \u003d comparator;\n    }\n\n    public Comparator\u003cPotionOrder\u003e comparator() {\n        return comparator;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/PotionOrderSorting.java"},{"fileName":"InventoryPotionOverlay.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.api.widgets.WidgetItem;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.WidgetItemOverlay;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\n\npublic class InventoryPotionOverlay extends WidgetItemOverlay {\n    private final MasteringMixologyPlugin plugin;\n    private final MasteringMixologyConfig config;\n\n    @Inject\n    InventoryPotionOverlay(MasteringMixologyPlugin plugin, MasteringMixologyConfig config) {\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n        showOnInventory();\n    }\n\n    @Override\n    public void renderItemOverlay(Graphics2D graphics2D, int itemId, WidgetItem widgetItem) {\n        if (!plugin.isInLab() || config.inventoryPotionTagType() \u003d\u003d InventoryPotionTagType.NONE) {\n            return;\n        }\n\n        var potion \u003d PotionType.fromItemId(itemId);\n\n        if (potion \u003d\u003d null) {\n            return;\n        }\n\n        var bounds \u003d widgetItem.getCanvasBounds();\n        var x \u003d bounds.x + 5;\n        var y \u003d bounds.y + 30;\n\n        drawRecipe(graphics2D, potion, x + 1, y + 1, Color.BLACK); // Drop shadow\n\n        if (config.inventoryPotionTagType() \u003d\u003d InventoryPotionTagType.COLORED) {\n            drawRecipe(graphics2D, potion, x, y, null);\n            return;\n        }\n\n        drawRecipe(graphics2D, potion, x, y, Color.WHITE);\n    }\n\n    private void drawRecipe(Graphics2D graphics2D, PotionType potion, int x, int y, @Nullable Color color) {\n        graphics2D.setFont(FontManager.getRunescapeSmallFont());\n\n        if (color !\u003d null) {\n            graphics2D.setColor(color);\n            graphics2D.drawString(potion.abbreviation(), x, y);\n            return;\n        }\n\n        for (var component : potion.components()) {\n            graphics2D.setColor(component.color());\n            graphics2D.drawString(String.valueOf(component.character()), x, y);\n            x +\u003d graphics2D.getFontMetrics().charWidth(component.character());\n        }\n    }\n}\n","filePath":"src/main/java/work/fking/masteringmixology/InventoryPotionOverlay.java"},{"fileName":"RunRuneLite.java","content":"package work.fking.masteringmixology;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class RunRuneLite {\n\n    public static void main(String[] args) throws Exception {\n        ExternalPluginManager.loadBuiltin(MasteringMixologyPlugin.class);\n        RuneLite.main(args);\n    }\n}","filePath":"src/test/java/work/fking/masteringmixology/RunRuneLite.java"}]},{"commit":"317e075b37a8a9f971e43ef07006974141e1f7bf","repository":"https://github.com/UserD40/Runelite07Flip.git","internalName":"07flip","files":[{"fileName":"O7FlipPlugin.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip;\n\nimport com.google.inject.Provides;\nimport com.o7flip.model.BarrowsSet;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.ImageUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport javax.inject.Inject;\nimport javax.swing.SwingUtilities;\nimport java.awt.image.BufferedImage;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\n@PluginDescriptor(\n\tname \u003d \"07Flip - GE Flip Finder\",\n\tdescription \u003d \"Live GE flips, price dump signals, Barrows/Moon repair profits, decanting, and price alerts from 07flip.com\",\n\ttags \u003d {\"flipping\", \"grand exchange\", \"ge\", \"money making\", \"merching\", \"barrows\", \"decanting\", \"07flip\"}\n)\npublic class O7FlipPlugin extends Plugin\n{\n\tprivate static final Logger log \u003d LoggerFactory.getLogger(O7FlipPlugin.class);\n\n\t@Inject\n\tprivate ClientToolbar clientToolbar;\n\n\t@Inject\n\tprivate O7FlipConfig config;\n\n\t@Inject\n\tprivate O7FlipApiClient apiClient;\n\n\tprivate O7FlipPanel panel;\n\tprivate NavigationButton navButton;\n\tprivate ScheduledExecutorService executor;\n\tprivate ScheduledFuture\u003c?\u003e refreshTask;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tpanel \u003d injector.getInstance(O7FlipPanel.class);\n\n\t\tfinal BufferedImage icon \u003d ImageUtil.loadImageResource(getClass(), \"/icon.png\");\n\t\tnavButton \u003d NavigationButton.builder()\n\t\t\t.tooltip(\"07Flip - GE Flip Finder\")\n\t\t\t.icon(icon)\n\t\t\t.priority(5)\n\t\t\t.panel(panel)\n\t\t\t.build();\n\n\t\tclientToolbar.addNavigation(navButton);\n\n\t\texecutor \u003d Executors.newSingleThreadScheduledExecutor();\n\t\tfetchAuthStatus();\n\t\tfetchAll();\n\t\trefreshTask \u003d executor.scheduleAtFixedRate(\n\t\t\tthis::fetchAll,\n\t\t\tconfig.refreshIntervalSeconds(),\n\t\t\tconfig.refreshIntervalSeconds(),\n\t\t\tTimeUnit.SECONDS\n\t\t);\n\t\tlog.info(\"[07Flip] Started, refreshing every {}s\", config.refreshIntervalSeconds());\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tif (refreshTask !\u003d null)\n\t\t{\n\t\t\trefreshTask.cancel(true);\n\t\t}\n\t\tif (executor !\u003d null)\n\t\t{\n\t\t\texecutor.shutdown();\n\t\t}\n\t\tclientToolbar.removeNavigation(navButton);\n\t\tlog.info(\"[07Flip] Stopped\");\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Auth\n\t// -------------------------------------------------------------------------\n\n\tvoid fetchAuthStatus()\n\t{\n\t\tString key \u003d config.apiKey();\n\t\tif (key \u003d\u003d null || key.trim().isEmpty())\n\t\t{\n\t\t\tSwingUtilities.invokeLater(() -\u003e panel.updateAuthStatus(false, false));\n\t\t\treturn;\n\t\t}\n\t\tapiClient.fetchAuthStatus(status -\u003e\n\t\t\tSwingUtilities.invokeLater(() -\u003e panel.updateAuthStatus(status.authenticated, status.premium)));\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Full refresh (scheduled + on startup)\n\t// -------------------------------------------------------------------------\n\n\tvoid fetchAll()\n\t{\n\t\tSwingUtilities.invokeLater(() -\u003e panel.setLoading(true));\n\t\tfetchAuthStatus();\n\n\t\tapiClient.fetchFlips(panel.getSelectedPreset(),\n\t\t\tpanel.getFlipsMinProfit(), panel.getFlipsPriceMin(), panel.getFlipsPriceMax(),\n\t\t\tpanel.getFlipsPage(),\n\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateFlips(items, total, panel.getFlipsPage())));\n\n\t\tapiClient.fetchSpikes(panel.getSpikesSortKey(), panel.getSpikesPage(),\n\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateSpikes(items, total, panel.getSpikesPage())));\n\n\t\tapiClient.fetchDips(panel.getDipsSortKey(), panel.getDipsPage(),\n\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDips(items, total, panel.getDipsPage())));\n\n\t\tapiClient.fetchDumps(panel.getDumpsSortKey(),\n\t\t\tpanel.getDumpsMinProfit(), panel.getDumpsPriceMin(), panel.getDumpsPriceMax(),\n\t\t\tpanel.getDumpsPage(),\n\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDumps(items, total, panel.getDumpsPage())));\n\n\t\tapiClient.fetchAlerts(panel.getAlertsPage(),\n\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateAlerts(items, total, panel.getAlertsPage())));\n\n\t\tapiClient.fetchBarrows(config.smithingLevel(),\n\t\t\tsets -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateBarrows(sets)));\n\n\t\tapiClient.fetchMoon(config.smithingLevel(),\n\t\t\tsets -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateMoon(sets)));\n\n\t\tapiClient.fetchDecanting(\n\t\t\tdecants -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDecanting(decants)));\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Page navigation (each call re-fetches that page from the server)\n\t// -------------------------------------------------------------------------\n\n\tvoid onFlipsPageChanged(int page)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchFlips(panel.getSelectedPreset(),\n\t\t\t\tpanel.getFlipsMinProfit(), panel.getFlipsPriceMin(), panel.getFlipsPriceMax(),\n\t\t\t\tpage,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateFlips(items, total, page))));\n\t}\n\n\tvoid onSpikesPageChanged(int page)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchSpikes(panel.getSpikesSortKey(), page,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateSpikes(items, total, page))));\n\t}\n\n\tvoid onDipsPageChanged(int page)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchDips(panel.getDipsSortKey(), page,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDips(items, total, page))));\n\t}\n\n\tvoid onDipsSortChanged(String sort)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchDips(sort, 0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDips(items, total, 0))));\n\t}\n\n\tvoid onDumpsPageChanged(int page)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchDumps(panel.getDumpsSortKey(),\n\t\t\t\tpanel.getDumpsMinProfit(), panel.getDumpsPriceMin(), panel.getDumpsPriceMax(),\n\t\t\t\tpage,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDumps(items, total, page))));\n\t}\n\n\tvoid onAlertsPageChanged(int page)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchAlerts(page,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateAlerts(items, total, page))));\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Sort / filter / preset changes (always reset to page 0)\n\t// -------------------------------------------------------------------------\n\n\tvoid onSpikesSortChanged(String sort)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchSpikes(sort, 0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateSpikes(items, total, 0))));\n\t}\n\n\tvoid onDumpsSortChanged(String sort)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchDumps(sort,\n\t\t\t\tpanel.getDumpsMinProfit(), panel.getDumpsPriceMin(), panel.getDumpsPriceMax(),\n\t\t\t\t0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDumps(items, total, 0))));\n\t}\n\n\tvoid onFlipsFilterChanged()\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchFlips(panel.getSelectedPreset(),\n\t\t\t\tpanel.getFlipsMinProfit(), panel.getFlipsPriceMin(), panel.getFlipsPriceMax(),\n\t\t\t\t0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateFlips(items, total, 0))));\n\t}\n\n\tvoid onDumpsFilterChanged()\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchDumps(panel.getDumpsSortKey(),\n\t\t\t\tpanel.getDumpsMinProfit(), panel.getDumpsPriceMin(), panel.getDumpsPriceMax(),\n\t\t\t\t0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateDumps(items, total, 0))));\n\t}\n\n\tvoid onPresetChanged()\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchFlips(panel.getSelectedPreset(),\n\t\t\t\tpanel.getFlipsMinProfit(), panel.getFlipsPriceMin(), panel.getFlipsPriceMax(),\n\t\t\t\t0,\n\t\t\t\t(items, total) -\u003e SwingUtilities.invokeLater(() -\u003e panel.updateFlips(items, total, 0))));\n\t}\n\n\tvoid onBarrowsSetClicked(BarrowsSet set)\n\t{\n\t\texecutor.execute(() -\u003e\n\t\t\tapiClient.fetchBarrowsDetail(set.setParam, config.smithingLevel(),\n\t\t\t\tfullSet -\u003e SwingUtilities.invokeLater(() -\u003e\n\t\t\t\t{\n\t\t\t\t\tif (fullSet !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpanel.showBarrowsDetail(fullSet);\n\t\t\t\t\t}\n\t\t\t\t})));\n\t}\n\n\tvoid searchItems(String query)\n\t{\n\t\tapiClient.fetchSearch(query,\n\t\t\titems -\u003e SwingUtilities.invokeLater(() -\u003e panel.showSearchResults(items, query)));\n\t}\n\n\t@Provides\n\tO7FlipConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(O7FlipConfig.class);\n\t}\n}\n","filePath":"src/main/java/com/o7flip/O7FlipPlugin.java"},{"fileName":"Fonts.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.util;\n\nimport java.awt.Font;\n\n/**\n * Shared font constants. Dialog maps to the OS system sans-serif font\n * (Segoe UI on Windows), which is anti-aliased and much more readable\n * than the RuneScape bitmap pixel fonts.\n */\npublic final class Fonts\n{\n\tpublic static final Font TITLE   \u003d new Font(\"Dialog\", Font.BOLD,  14);\n\tpublic static final Font BOLD    \u003d new Font(\"Dialog\", Font.BOLD,  12);\n\tpublic static final Font REG     \u003d new Font(\"Dialog\", Font.PLAIN, 12);\n\tpublic static final Font SM      \u003d new Font(\"Dialog\", Font.PLAIN, 11);\n\tpublic static final Font SM_BOLD \u003d new Font(\"Dialog\", Font.BOLD,  11);\n\n\tprivate Fonts() {}\n}\n","filePath":"src/main/java/com/o7flip/util/Fonts.java"},{"fileName":"ItemIds.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.util;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Fallback item ID mappings for sections whose API endpoints do not yet\n * return an item_id field. When the API is updated to return item_id these\n * lookups become unused and can be removed.\n *\n * Potion IDs sourced from the OSRS Wiki live mapping API (all 337 dose items).\n * Keys are the base item name in lowercase, exactly matching the OSRS Wiki name\n * without dose notation (e.g. \"prayer potion\", not \"prayer potion(4)\").\n */\npublic final class ItemIds\n{\n\t// Barrows set representative item IDs (helm / coif / hood)\n\tprivate static final Map\u003cString, Integer\u003e BARROWS \u003d new HashMap\u003c\u003e();\n\n\t// Moon armour set representative item IDs (helm)\n\tprivate static final Map\u003cString, Integer\u003e MOON \u003d new HashMap\u003c\u003e();\n\n\t// Potion base-name (lowercase, no dose)  int[4] {1-dose, 2-dose, 3-dose, 4-dose} item IDs.\n\t// Keys are the exact OSRS Wiki base names in lowercase.\n\t// forPotion() tries exact match first, then a startsWith fallback (longest key wins)\n\t// so server names with a trailing \" potion\" or similar still resolve correctly.\n\tprivate static final Map\u003cString, int[]\u003e POTIONS \u003d new HashMap\u003c\u003e();\n\n\tstatic\n\t{\n\t\tBARROWS.put(\"Ahrim\u0027s\",  4708);  // Ahrim\u0027s hood\n\t\tBARROWS.put(\"Dharok\u0027s\", 4716);  // Dharok\u0027s helm\n\t\tBARROWS.put(\"Guthan\u0027s\", 4724);  // Guthan\u0027s helm\n\t\tBARROWS.put(\"Karil\u0027s\",  4732);  // Karil\u0027s coif\n\t\tBARROWS.put(\"Torag\u0027s\",  4745);  // Torag\u0027s helm\n\t\tBARROWS.put(\"Verac\u0027s\",  4753);  // Verac\u0027s helm\n\n\t\tMOON.put(\"Blood Moon\",   29028); // Blood moon helm (repaired)\n\t\tMOON.put(\"Blue Moon\",    29019); // Blue moon helm (repaired)\n\t\tMOON.put(\"Eclipse Moon\", 29010); // Eclipse moon helm (repaired)\n\n\t\t// All values: {1-dose, 2-dose, 3-dose, 4-dose}\n\t\t// Keys are exact OSRS Wiki base names (lowercase), verified against the\n\t\t// live Wiki mapping API.  Note: classic RS2-era potions have non-sequential\n\t\t// IDs  the 4-dose was added later at a completely different ID range.\n\n\t\t//  Basic attack/str/def \n\t\tPOTIONS.put(\"attack potion\",           new int[]{125,   123,   121,   2428});\n\t\tPOTIONS.put(\"strength potion\",         new int[]{119,   117,   115,    113});\n\t\tPOTIONS.put(\"defence potion\",          new int[]{137,   135,   133,   2432});\n\t\tPOTIONS.put(\"ranging potion\",          new int[]{173,   171,   169,   2444});\n\t\tPOTIONS.put(\"magic potion\",            new int[]{3046,  3044,  3042,  3040});\n\t\tPOTIONS.put(\"fishing potion\",          new int[]{155,   153,   151,   2438});\n\t\tPOTIONS.put(\"combat potion\",           new int[]{9745,  9743,  9741,  9739});\n\n\t\t//  Super attack/str/def/combat \n\t\t// Wiki names have no \"potion\" suffix for these\n\t\tPOTIONS.put(\"super attack\",            new int[]{149,   147,   145,   2436});\n\t\tPOTIONS.put(\"super strength\",          new int[]{161,   159,   157,   2440});\n\t\tPOTIONS.put(\"super defence\",           new int[]{167,   165,   163,   2442});\n\t\tPOTIONS.put(\"super combat potion\",     new int[]{12701, 12699, 12697, 12695});\n\n\t\t//  Ranging / magic boosters \n\t\tPOTIONS.put(\"bastion potion\",          new int[]{22470, 22467, 22464, 22461});\n\t\tPOTIONS.put(\"battlemage potion\",       new int[]{22458, 22455, 22452, 22449});\n\n\t\t//  Restore / prayer \n\t\tPOTIONS.put(\"restore potion\",          new int[]{131,   129,   127,   2430});\n\t\tPOTIONS.put(\"prayer potion\",           new int[]{143,   141,   139,   2434});\n\t\tPOTIONS.put(\"super restore\",           new int[]{3030,  3028,  3026,  3024});\n\t\tPOTIONS.put(\"sanfew serum\",            new int[]{10931, 10929, 10927, 10925});\n\t\tPOTIONS.put(\"prayer regeneration potion\", new int[]{30134, 30131, 30128, 30125});\n\n\t\t//  Brews \n\t\tPOTIONS.put(\"saradomin brew\",          new int[]{6691,  6689,  6687,  6685});\n\t\tPOTIONS.put(\"zamorak brew\",            new int[]{193,   191,   189,   2450});\n\t\tPOTIONS.put(\"ancient brew\",            new int[]{26346, 26344, 26342, 26340});\n\t\tPOTIONS.put(\"armadyl brew\",            new int[]{31659, 31656, 31653, 31650});\n\t\tPOTIONS.put(\"forgotten brew\",          new int[]{27638, 27635, 27632, 27629});\n\t\tPOTIONS.put(\"guthix balance\",          new int[]{7666,  7664,  7662,  7660});\n\n\t\t//  Energy / stamina / agility \n\t\tPOTIONS.put(\"energy potion\",           new int[]{3014,  3012,  3010,  3008});\n\t\tPOTIONS.put(\"super energy\",            new int[]{3022,  3020,  3018,  3016});\n\t\tPOTIONS.put(\"agility potion\",          new int[]{3038,  3036,  3034,  3032});\n\t\tPOTIONS.put(\"stamina potion\",          new int[]{12631, 12629, 12627, 12625});\n\t\tPOTIONS.put(\"extended stamina\",        new int[]{31647, 31644, 31641, 31638});\n\t\tPOTIONS.put(\"extreme energy potion\",   new int[]{31623, 31620, 31617, 31614});\n\n\t\t//  Antifire \n\t\tPOTIONS.put(\"antifire potion\",         new int[]{2458,  2456,  2454,  2452});\n\t\tPOTIONS.put(\"extended antifire\",       new int[]{11957, 11955, 11953, 11951});\n\t\t// Wiki name is \"Super antifire potion\" (with \"potion\")\n\t\tPOTIONS.put(\"super antifire potion\",   new int[]{21987, 21984, 21981, 21978});\n\t\tPOTIONS.put(\"extended super antifire\", new int[]{22218, 22215, 22212, 22209});\n\n\t\t//  Antipoison / antivenom \n\t\tPOTIONS.put(\"antipoison\",              new int[]{179,   177,   175,   2446});\n\t\tPOTIONS.put(\"superantipoison\",         new int[]{185,   183,   181,   2448});\n\t\tPOTIONS.put(\"antidote+\",               new int[]{5949,  5947,  5945,  5943});\n\t\tPOTIONS.put(\"antidote++\",              new int[]{5958,  5956,  5954,  5952});\n\t\tPOTIONS.put(\"anti-venom\",              new int[]{12911, 12909, 12907, 12905});\n\t\tPOTIONS.put(\"anti-venom+\",             new int[]{12919, 12917, 12915, 12913});\n\t\tPOTIONS.put(\"extended anti-venom+\",    new int[]{29833, 29830, 29827, 29824});\n\n\t\t//  Divine variants \n\t\t// Wiki names: \"Divine super attack\", \"Divine bastion potion\", etc.\n\t\tPOTIONS.put(\"divine super attack\",     new int[]{23706, 23703, 23700, 23697});\n\t\tPOTIONS.put(\"divine super strength\",   new int[]{23718, 23715, 23712, 23709});\n\t\tPOTIONS.put(\"divine super defence\",    new int[]{23730, 23727, 23724, 23721});\n\t\tPOTIONS.put(\"divine super combat\",     new int[]{23694, 23691, 23688, 23685});\n\t\tPOTIONS.put(\"divine ranging potion\",   new int[]{23742, 23739, 23736, 23733});\n\t\tPOTIONS.put(\"divine magic potion\",     new int[]{23754, 23751, 23748, 23745});\n\t\tPOTIONS.put(\"divine bastion potion\",   new int[]{24644, 24641, 24638, 24635});\n\t\tPOTIONS.put(\"divine battlemage potion\",new int[]{24632, 24629, 24626, 24623});\n\n\t\t//  Hunting / fishing \n\t\tPOTIONS.put(\"hunter potion\",           new int[]{10004, 10002, 10000, 9998});\n\t\tPOTIONS.put(\"super hunter potion\",     new int[]{31635, 31632, 31629, 31626});\n\t\tPOTIONS.put(\"super fishing potion\",    new int[]{31611, 31608, 31605, 31602});\n\n\t\t//  Other tradeable potions \n\t\tPOTIONS.put(\"goading potion\",          new int[]{30146, 30143, 30140, 30137});\n\t\tPOTIONS.put(\"menaphite remedy\",        new int[]{27211, 27208, 27205, 27202});\n\t\tPOTIONS.put(\"relicym\u0027s balm\",          new int[]{4848,  4846,  4844,  4842});\n\t\tPOTIONS.put(\"blighted overload\",       new int[]{29640, 29637, 29634, 29631});\n\t\tPOTIONS.put(\"haemostatic dressing\",    new int[]{31599, 31596, 31593, 31590});\n\t}\n\n\tprivate ItemIds() {}\n\n\t/** Returns a Barrows helm/coif item ID for the given shortName, or 0. */\n\tpublic static int forBarrows(String shortName)\n\t{\n\t\tif (shortName \u003d\u003d null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tfor (Map.Entry\u003cString, Integer\u003e entry : BARROWS.entrySet())\n\t\t{\n\t\t\tif (shortName.startsWith(entry.getKey()))\n\t\t\t{\n\t\t\t\treturn entry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/** Returns a Moon armour helm item ID for the given shortName, or 0. */\n\tpublic static int forMoon(String shortName)\n\t{\n\t\tif (shortName \u003d\u003d null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tString lower \u003d shortName.toLowerCase();\n\t\tfor (Map.Entry\u003cString, Integer\u003e entry : MOON.entrySet())\n\t\t{\n\t\t\tif (lower.contains(entry.getKey().toLowerCase()))\n\t\t\t{\n\t\t\t\treturn entry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Returns the item ID for the given potion name at the specified dose (1-4).\n\t * Returns 0 if the potion name is unknown.\n\t *\n\t * Matching strategy (in order):\n\t * 1. Exact match (O(1))  handles names that precisely equal a map key.\n\t * 2. startsWith fallback  handles names where the server appends extra text\n\t *    after the base wiki name (e.g. \"Prayer regen potion (e)\"). Uses the\n\t *    longest-matching key so that \"divine super combat\" always wins over\n\t *    \"super combat potion\" when the name starts with \"divine super combat\".\n\t *    startsWith (vs contains) prevents \"super strength\" from spuriously\n\t *    matching \"divine super strength\".\n\t */\n\tpublic static int forPotion(String potionName, int dose)\n\t{\n\t\tif (potionName \u003d\u003d null)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tint d \u003d (dose \u003e\u003d 1 \u0026\u0026 dose \u003c\u003d 4) ? dose : 4;\n\t\tString lower \u003d potionName.toLowerCase();\n\t\t// 1. Exact match\n\t\tint[] doses \u003d POTIONS.get(lower);\n\t\tif (doses !\u003d null)\n\t\t{\n\t\t\treturn doses[d - 1];\n\t\t}\n\t\t// 2. startsWith fallback  longest key wins\n\t\tint[] best \u003d null;\n\t\tint bestLen \u003d 0;\n\t\tfor (Map.Entry\u003cString, int[]\u003e entry : POTIONS.entrySet())\n\t\t{\n\t\t\tString key \u003d entry.getKey();\n\t\t\tif (lower.startsWith(key) \u0026\u0026 key.length() \u003e bestLen)\n\t\t\t{\n\t\t\t\tbest \u003d entry.getValue();\n\t\t\t\tbestLen \u003d key.length();\n\t\t\t}\n\t\t}\n\t\treturn best !\u003d null ? best[d - 1] : 0;\n\t}\n\n\t/** Returns a 4-dose potion item ID for the given potion name, or 0. */\n\tpublic static int forPotion(String potionName)\n\t{\n\t\treturn forPotion(potionName, 4);\n\t}\n}\n","filePath":"src/main/java/com/o7flip/util/ItemIds.java"},{"fileName":"O7FlipConfig.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.Range;\n\n@ConfigGroup(\"o7flip\")\npublic interface O7FlipConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"apiKey\",\n\t\tname \u003d \"API Key\",\n\t\tdescription \u003d \"Your 07flip.com API key for premium features. Get it from 07flip.com/settings after signing in with Discord. No player data is sent to external servers.\",\n\t\tsecret \u003d true,\n\t\tposition \u003d 0\n\t)\n\tdefault String apiKey()\n\t{\n\t\treturn \"\";\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"refreshInterval\",\n\t\tname \u003d \"Refresh Interval (seconds)\",\n\t\tdescription \u003d \"How often to fetch data from 07flip.com. Minimum 60 seconds.\",\n\t\tposition \u003d 1\n\t)\n\t@Range(min \u003d 60, max \u003d 600)\n\tdefault int refreshIntervalSeconds()\n\t{\n\t\treturn 60;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"smithingLevel\",\n\t\tname \u003d \"Smithing Level\",\n\t\tdescription \u003d \"Your Smithing level, used to calculate PoH repair costs for Barrows and Moon.\",\n\t\tposition \u003d 2\n\t)\n\t@Range(min \u003d 1, max \u003d 99)\n\tdefault int smithingLevel()\n\t{\n\t\treturn 99;\n\t}\n}\n","filePath":"src/main/java/com/o7flip/O7FlipConfig.java"},{"fileName":"SearchResultItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class SearchResultItem\n{\n\tpublic int     itemId;\n\tpublic String  name;\n\tpublic Long    buyPrice;\n\tpublic Long    sellPrice;\n\tpublic Long    margin;\n\tpublic Long    profit;\n\tpublic Double  roi;\n\tpublic Integer hourlyVolume;\n\tpublic Integer dailyVolume;\n\tpublic int     buyLimit;\n\tpublic boolean members;\n\tpublic Integer highAlch;\n\tpublic String  lastUpdated;\n\tpublic Integer dataAgeMinutes;\n}\n","filePath":"src/main/java/com/o7flip/model/SearchResultItem.java"},{"fileName":"AlertItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class AlertItem\n{\n\tpublic int itemId;\n\tpublic String name;\n\tpublic long currentPrice;\n\tpublic long sellTarget;\n\tpublic double upsidePct;\n\tpublic String holdTime;\n\tpublic long high90d;\n\tpublic long low90d;\n\tpublic double drawdownPct;\n\tpublic String detectedAt;\n}\n","filePath":"src/main/java/com/o7flip/model/AlertItem.java"},{"fileName":"FlipItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class FlipItem\n{\n\tpublic int itemId;\n\tpublic String name;\n\tpublic long buyPrice;\n\tpublic long sellPrice;\n\tpublic long profit;\n\tpublic double roiPct;\n\tpublic long potentialProfit;\n\tpublic int buyLimit;\n\tpublic boolean members;\n}\n","filePath":"src/main/java/com/o7flip/model/FlipItem.java"},{"fileName":"MoonItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class MoonItem\n{\n\tpublic int     itemIdBroken;   // 0 when weapon (no broken form)\n\tpublic int     itemIdRepaired;\n\tpublic String  name;\n\tpublic String  slot;           // \"helm\", \"chestplate\", \"tassets\", \"weapon\"\n\tpublic boolean degrades;\n\tpublic long    brokenBuyPrice; // buy cost of broken piece (or full buy for weapon)\n\tpublic long    repairedSellPrice;\n\tpublic long    repairedAfterTax;\n\tpublic long    npcRepairCost;\n\tpublic long    pohRepairCost;\n\tpublic long    npcProfit;\n\tpublic long    pohProfit;\n\tpublic double  npcRoiPct;\n\tpublic double  pohRoiPct;\n}\n","filePath":"src/main/java/com/o7flip/model/MoonItem.java"},{"fileName":"BarrowsSet.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BarrowsSet\n{\n\tpublic int    iconItemId;\n\tpublic String setName;\n\tpublic String shortName;\n\tpublic String setParam;\n\tpublic long   totalBrokenCost;\n\tpublic long   totalNpcRepairCost;\n\tpublic long   totalPohRepairCost;\n\tpublic long   npcProfit;\n\tpublic long   pohProfit;\n\tpublic long   setProfit;\n\tpublic long   bestProfit;\n\tpublic String bestStrategy;\n\tpublic int    dailyVolume;\n\n\tpublic List\u003cBarrowsItem\u003e items \u003d new ArrayList\u003c\u003e();\n}\n","filePath":"src/main/java/com/o7flip/model/BarrowsSet.java"},{"fileName":"AuthStatus.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class AuthStatus\n{\n\tpublic boolean authenticated;\n\tpublic boolean premium;\n}\n","filePath":"src/main/java/com/o7flip/model/AuthStatus.java"},{"fileName":"DumpItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class DumpItem\n{\n\tpublic int     itemId;\n\tpublic String  name;\n\tpublic long    buyPrice;\n\tpublic long    sellPrice;\n\tpublic long    profit;\n\tpublic int     dumpScore;\n\tpublic double  dumpPct;\n\tpublic String  dumpStatus;\n\tpublic Double  lastDumpHoursAgo;\n\tpublic Double  nextDumpHours;\n\tpublic Integer burstCount;\n\tpublic int     hourlyVolume;\n\tpublic int     buyLimit;\n\tpublic boolean members;\n}\n","filePath":"src/main/java/com/o7flip/model/DumpItem.java"},{"fileName":"MoonSet.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MoonSet\n{\n\tpublic String  setName;\n\tpublic String  shortName;\n\tpublic String  combatStyle;\n\tpublic int     setId;          // set box item ID (e.g. 31136 for Blood Moon)\n\tpublic int     iconItemId;     // repaired helm ID used as icon\n\n\tpublic List\u003cMoonItem\u003e items \u003d new ArrayList\u003c\u003e();\n\n\tpublic long    totalBrokenCost;\n\tpublic long    totalNpcRepairCost;\n\tpublic long    totalPohRepairCost;\n\tpublic long    npcProfit;\n\tpublic long    pohProfit;\n\tpublic long    setPrice;\n\tpublic long    setProfit;\n\tpublic String  bestStrategy;   // \"sell_individual\" or \"sell_set\"\n\tpublic long    bestProfit;\n}\n","filePath":"src/main/java/com/o7flip/model/MoonSet.java"},{"fileName":"DecantItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class DecantItem\n{\n\tpublic int    itemId;\n\tpublic String potionName;\n\tpublic String strategy;\n\tpublic long   profitPer4dose;\n\tpublic long   profitPerDose;\n\tpublic double roiPct;\n\tpublic int    minHourlyVolume;\n\tpublic int    dailyVolume;\n\tpublic int    buyDose;\n\tpublic int    sellDose;\n}\n","filePath":"src/main/java/com/o7flip/model/DecantItem.java"},{"fileName":"DipItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class DipItem\n{\n\tpublic int     itemId;\n\tpublic String  name;\n\tpublic long    buyPrice;\n\tpublic long    avg24hBuy;\n\tpublic double  dipPct;\n\tpublic int     hourlyVolume;\n\tpublic int     dailyVolume;\n\tpublic int     buyLimit;\n\tpublic boolean members;\n\tpublic String  lastUpdated;\n}\n","filePath":"src/main/java/com/o7flip/model/DipItem.java"},{"fileName":"BarrowsItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class BarrowsItem\n{\n\tpublic int    itemIdBroken;\n\tpublic int    itemIdRepaired;\n\tpublic String name;\n\tpublic String slot;\n\tpublic long   brokenBuyPrice;\n\tpublic long   repairedSellPrice;\n\tpublic long   repairedAfterTax;\n\tpublic long   npcRepairCost;\n\tpublic long   pohRepairCost;\n\tpublic long   npcProfit;\n\tpublic long   pohProfit;\n\tpublic double npcRoiPct;\n\tpublic double pohRoiPct;\n\tpublic int    dailyVolume;\n}\n","filePath":"src/main/java/com/o7flip/model/BarrowsItem.java"},{"fileName":"SpikeItem.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.model;\n\npublic class SpikeItem\n{\n\tpublic int     itemId;\n\tpublic String  name;\n\tpublic long    buyPrice;\n\tpublic long    avg24hBuy;\n\tpublic double  spikePct;\n\tpublic int     hourlyVolume;\n\tpublic int     dailyVolume;\n\tpublic int     buyLimit;\n\tpublic boolean members;\n\tpublic String  lastUpdated;\n}\n","filePath":"src/main/java/com/o7flip/model/SpikeItem.java"},{"fileName":"O7FlipPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip;\n\nimport com.o7flip.model.AlertItem;\nimport com.o7flip.model.BarrowsSet;\nimport com.o7flip.model.DecantItem;\nimport com.o7flip.model.DipItem;\nimport com.o7flip.model.DumpItem;\nimport com.o7flip.model.FlipItem;\nimport com.o7flip.model.MoonSet;\nimport com.o7flip.model.SearchResultItem;\nimport com.o7flip.model.SpikeItem;\nimport com.o7flip.ui.AlertItemPanel;\nimport com.o7flip.ui.BarrowsItemPanel;\nimport com.o7flip.ui.BarrowsSetPanel;\nimport com.o7flip.ui.DecantItemPanel;\nimport com.o7flip.ui.DipItemPanel;\nimport com.o7flip.ui.DumpItemPanel;\nimport com.o7flip.ui.FlipItemPanel;\nimport com.o7flip.ui.MoonSetPanel;\nimport com.o7flip.ui.SearchResultPanel;\nimport com.o7flip.ui.SpikeItemPanel;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.PluginPanel;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.swing.BorderFactory;\nimport javax.swing.BoxLayout;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JComponent;\nimport javax.swing.JLabel;\nimport javax.swing.JList;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTabbedPane;\nimport javax.swing.JTextField;\nimport javax.swing.ListCellRenderer;\nimport javax.swing.Scrollable;\nimport javax.swing.SwingConstants;\nimport javax.swing.Timer;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.border.MatteBorder;\nimport javax.swing.event.DocumentEvent;\nimport javax.swing.event.DocumentListener;\nimport javax.swing.plaf.basic.BasicComboBoxRenderer;\nimport java.awt.BorderLayout;\nimport java.awt.CardLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Desktop;\nimport java.awt.Dimension;\nimport java.awt.FlowLayout;\nimport java.awt.FontMetrics;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.GridLayout;\nimport java.awt.Insets;\nimport java.awt.Rectangle;\nimport java.awt.RenderingHints;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@Singleton\npublic class O7FlipPanel extends PluginPanel\n{\n\t// -------------------------------------------------------------------------\n\t// Colours / sizing\n\t// -------------------------------------------------------------------------\n\tprivate static final String WEBSITE_URL  \u003d \"https://07flip.com\";\n\tprivate static final String DISCORD_URL  \u003d \"https://discord.gg/xQaYM9TaMr\";\n\tprivate static final String PREMIUM_URL  \u003d \"https://07flip.com/premium\";\n\tprivate static final Color  ORANGE       \u003d new Color(0xFF981F);\n\tprivate static final Color  GREEN        \u003d new Color(0x00C27A);\n\tprivate static final int    PAGE_SIZE    \u003d 10;\n\tprivate static final int    FREE_ROWS    \u003d 5;\n\n\t// -------------------------------------------------------------------------\n\t// Preset definitions  true \u003d premium required\n\t// -------------------------------------------------------------------------\n\tprivate static final String[][] PRESETS \u003d {\n\t\t{\"\",            \"All Flips\"},\n\t\t{\"highVolume\",  \"High Volume\"},\n\t\t{\"highMargin\",  \"High Margin\"},\n\t\t{\"priceDip\",    \"Price Dip\"},\n\t\t{\"stableFlips\", \"Stable\"},\n\t\t{\"f2p\",         \"F2P Only\"},\n\t};\n\tprivate static final boolean[] PREMIUM_PRESET \u003d {false, true, false, true, true, false};\n\n\t// -------------------------------------------------------------------------\n\t// Client-side Flips filters\n\t// -------------------------------------------------------------------------\n\tprivate static final long[]   MIN_PROFITS       \u003d {0, 100_000, 500_000, 1_000_000, 5_000_000};\n\tprivate static final String[] MIN_PROFIT_LABELS \u003d {\"Any Profit\", \"100K+\", \"500K+\", \"1M+\", \"5M+\"};\n\n\t// Dumps profit thresholds  flip margin per item, much smaller than flip potential profit\n\tprivate static final long[]   DUMP_MIN_PROFITS       \u003d {0, 1_000, 5_000, 25_000, 100_000};\n\tprivate static final String[] DUMP_MIN_PROFIT_LABELS \u003d {\"Any Profit\", \"1K+\", \"5K+\", \"25K+\", \"100K+\"};\n\n\t// Price range: each entry is {lowerInclusive, upperExclusive}\n\tprivate static final long[][] PRICE_RANGES \u003d {\n\t\t{0,               Long.MAX_VALUE},  // Any Price\n\t\t{0,               10_000},          // 0  10K\n\t\t{10_000,          50_000},          // 10K  50K\n\t\t{50_000,          100_000},         // 50K  100K\n\t\t{100_000,         500_000},         // 100K  500K\n\t\t{500_000,         1_000_000},       // 500K  1M\n\t\t{1_000_000,       5_000_000},       // 1M  5M\n\t\t{5_000_000,       10_000_000},      // 5M  10M\n\t\t{10_000_000,      25_000_000},      // 10M  25M\n\t\t{25_000_000,      50_000_000},      // 25M  50M\n\t\t{50_000_000,      100_000_000},     // 50M  100M\n\t\t{100_000_000,     Long.MAX_VALUE},  // 100M+\n\t};\n\tprivate static final String[] PRICE_RANGE_LABELS \u003d {\n\t\t\"Any Price\",\n\t\t\"0 \\u2013 10K\",\n\t\t\"10K \\u2013 50K\",\n\t\t\"50K \\u2013 100K\",\n\t\t\"100K \\u2013 500K\",\n\t\t\"500K \\u2013 1M\",\n\t\t\"1M \\u2013 5M\",\n\t\t\"5M \\u2013 10M\",\n\t\t\"10M \\u2013 25M\",\n\t\t\"25M \\u2013 50M\",\n\t\t\"50M \\u2013 100M\",\n\t\t\"100M+\",\n\t};\n\n\tprivate int flipsMinProfitIdx  \u003d 0;\n\tprivate int flipsPriceRangeIdx \u003d 0;\n\tprivate int dumpsMinProfitIdx  \u003d 0;\n\tprivate int dumpsPriceRangeIdx \u003d 0;\n\n\t// -------------------------------------------------------------------------\n\t// Server-side sort keys for spikes / dumps\n\t// -------------------------------------------------------------------------\n\tprivate String spikesSortKey \u003d \"recent\";\n\tprivate String dipsSortKey   \u003d \"recent\";\n\tprivate String dumpsSortKey  \u003d \"recent\";\n\n\t// -------------------------------------------------------------------------\n\t// Auth state\n\t// -------------------------------------------------------------------------\n\tprivate boolean isSignedIn \u003d false;\n\tprivate boolean isPremium  \u003d false;\n\n\t// -------------------------------------------------------------------------\n\t// Stored data\n\t// -------------------------------------------------------------------------\n\tprivate List\u003cFlipItem\u003e    allFlips   \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cSpikeItem\u003e   allSpikes  \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cDipItem\u003e     allDips    \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cDumpItem\u003e    allDumps   \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cBarrowsSet\u003e  allBarrows \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cMoonSet\u003e     allMoon    \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cDecantItem\u003e  allDecants \u003d new ArrayList\u003c\u003e();\n\tprivate List\u003cAlertItem\u003e   allAlerts  \u003d new ArrayList\u003c\u003e();\n\n\t// -------------------------------------------------------------------------\n\t// Sort state\n\t// -------------------------------------------------------------------------\n\tprivate int flipsSortIdx   \u003d 0;\n\tprivate int spikesSortIdx  \u003d 0;\n\tprivate int dipsSortIdx    \u003d 0;\n\tprivate int dumpsSortIdx   \u003d 0;\n\tprivate int barrowsSortIdx \u003d 0;\n\tprivate int moonFilterIdx  \u003d 0;  // 0\u003dBlood 1\u003dBlue 2\u003dEclipse\n\tprivate int decantSortIdx  \u003d 0;\n\tprivate int alertsSortIdx  \u003d 0;\n\n\t// -------------------------------------------------------------------------\n\t// Page state (server-paginated tabs track total from server)\n\t// -------------------------------------------------------------------------\n\tprivate int flipsPage   \u003d 0;  private int flipsTotal  \u003d 0;\n\tprivate int spikesPage  \u003d 0;  private int spikesTotal \u003d 0;\n\tprivate int dipsPage    \u003d 0;  private int dipsTotal   \u003d 0;\n\tprivate int dumpsPage   \u003d 0;  private int dumpsTotal  \u003d 0;\n\tprivate int barrowsPage \u003d 0;\n\tprivate int moonPage    \u003d 0;\n\tprivate int decantPage  \u003d 0;\n\tprivate int alertsPage  \u003d 0;  private int alertsTotal \u003d 0;\n\n\t// -------------------------------------------------------------------------\n\t// List panels\n\t// -------------------------------------------------------------------------\n\tprivate JPanel flipsListPanel;\n\tprivate JPanel spikesListPanel;\n\tprivate JPanel dipsListPanel;\n\tprivate JPanel dumpsListPanel;\n\tprivate JPanel barrowsListPanel;\n\tprivate JPanel barrowsDetailPanel;\n\tprivate JPanel barrowsTabCard;\n\tprivate JLabel barrowsDetailTitle;\n\tprivate JPanel moonListPanel;\n\tprivate JPanel decantListPanel;\n\tprivate JPanel alertsListPanel;\n\tprivate JPanel searchResultsPanel;\n\tprivate JScrollPane searchScrollPane;\n\n\t// -------------------------------------------------------------------------\n\t// Sort buttons\n\t// -------------------------------------------------------------------------\n\tprivate JButton[] flipsSortBtns;\n\tprivate JButton[] spikesSortBtns;\n\tprivate JButton[] dipsSortBtns;\n\tprivate JButton[] dumpsSortBtns;\n\tprivate JButton[] barrowsSortBtns;\n\tprivate JButton[] moonFilterBtns;\n\tprivate JButton[] decantSortBtns;\n\tprivate JButton[] alertsSortBtns;\n\n\t// -------------------------------------------------------------------------\n\t// Page controls\n\t// -------------------------------------------------------------------------\n\tprivate JLabel  flipsPageLabel;   private JButton flipsPrev,    flipsNext;\n\tprivate JLabel  spikesPageLabel;  private JButton spikesPrev,   spikesNext;\n\tprivate JLabel  dipsPageLabel;    private JButton dipsPrev,     dipsNext;\n\tprivate JLabel  dumpsPageLabel;   private JButton dumpsPrev,    dumpsNext;\n\tprivate JLabel  barrowsPageLabel; private JButton barrowsPrev,  barrowsNext;\n\tprivate JLabel  moonPageLabel;    private JButton moonPrev,     moonNext;\n\tprivate JLabel  decantPageLabel;  private JButton decantPrev,   decantNext;\n\tprivate JLabel  alertsPageLabel;  private JButton alertsPrev,   alertsNext;\n\n\t// -------------------------------------------------------------------------\n\t// Other UI\n\t// -------------------------------------------------------------------------\n\tprivate final JComboBox\u003cString\u003e presetSelector;\n\tprivate JTextField searchField;\n\tprivate JLabel statusLabel;\n\tprivate JLabel lastUpdatedLabel;\n\tprivate JPanel mainArea;\n\tprivate Timer  searchDebounce;\n\n\t// -------------------------------------------------------------------------\n\t// Injected\n\t// -------------------------------------------------------------------------\n\t@Inject\n\tprivate O7FlipPlugin plugin;\n\t@Inject\n\tprivate ItemManager itemManager;\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Constructor\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\tpublic O7FlipPanel()\n\t{\n\t\tsuper(false);\n\t\tsetLayout(new BorderLayout());\n\t\tsetBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tString[] labels \u003d new String[PRESETS.length];\n\t\tfor (int i \u003d 0; i \u003c PRESETS.length; i++)\n\t\t{\n\t\t\tlabels[i] \u003d PRESETS[i][1];\n\t\t}\n\t\tpresetSelector \u003d styledCombo(labels);\n\t\tpresetSelector.setRenderer(buildPresetRenderer());\n\t\tpresetSelector.addActionListener(e -\u003e\n\t\t{\n\t\t\tint idx \u003d presetSelector.getSelectedIndex();\n\t\t\tif (idx \u003e\u003d 0 \u0026\u0026 idx \u003c PREMIUM_PRESET.length \u0026\u0026 PREMIUM_PRESET[idx] \u0026\u0026 !isPremium)\n\t\t\t{\n\t\t\t\tpresetSelector.setSelectedIndex(0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onPresetChanged();\n\t\t\t}\n\t\t});\n\n\t\tmainArea \u003d new JPanel(new CardLayout());\n\t\tmainArea.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tmainArea.add(buildTabs(),       \"tabs\");\n\t\tmainArea.add(buildSearchView(), \"search\");\n\n\t\tadd(buildTopPanel(), BorderLayout.NORTH);\n\t\tadd(mainArea,        BorderLayout.CENTER);\n\t\tadd(buildFooter(),   BorderLayout.SOUTH);\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Auth update\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tpublic void updateAuthStatus(boolean signedIn, boolean premium)\n\t{\n\t\tthis.isSignedIn \u003d signedIn;\n\t\tthis.isPremium  \u003d premium;\n\t\tpresetSelector.repaint();\n\t\tString q \u003d filtered();\n\t\trenderFlips(q);\n\t\trenderSpikes(q);\n\t\trenderDips(q);\n\t\trenderDumps(q);\n\t\trenderBarrows(q);\n\t\trenderMoon(q);\n\t\trenderDecants(q);\n\t\trenderAlerts(q);\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Public update methods\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tpublic String getSelectedPreset()\n\t{\n\t\tint i \u003d presetSelector.getSelectedIndex();\n\t\treturn i \u003e\u003d 0 ? PRESETS[i][0] : \"\";\n\t}\n\n\tpublic String getSpikesSortKey()\n\t{\n\t\treturn spikesSortKey;\n\t}\n\n\tpublic String getDipsSortKey()\n\t{\n\t\treturn dipsSortKey;\n\t}\n\n\tpublic String getDumpsSortKey()\n\t{\n\t\treturn dumpsSortKey;\n\t}\n\n\tpublic long getFlipsMinProfit()\n\t{\n\t\treturn flipsMinProfitIdx \u003e 0 ? MIN_PROFITS[flipsMinProfitIdx] : 0;\n\t}\n\n\tpublic long getFlipsPriceMin()\n\t{\n\t\treturn flipsPriceRangeIdx \u003e 0 ? PRICE_RANGES[flipsPriceRangeIdx][0] : 0;\n\t}\n\n\tpublic long getFlipsPriceMax()\n\t{\n\t\treturn flipsPriceRangeIdx \u003e 0 ? PRICE_RANGES[flipsPriceRangeIdx][1] : Long.MAX_VALUE;\n\t}\n\n\tpublic long getDumpsMinProfit()\n\t{\n\t\treturn dumpsMinProfitIdx \u003e 0 ? DUMP_MIN_PROFITS[dumpsMinProfitIdx] : 0;\n\t}\n\n\tpublic long getDumpsPriceMin()\n\t{\n\t\treturn dumpsPriceRangeIdx \u003e 0 ? PRICE_RANGES[dumpsPriceRangeIdx][0] : 0;\n\t}\n\n\tpublic long getDumpsPriceMax()\n\t{\n\t\treturn dumpsPriceRangeIdx \u003e 0 ? PRICE_RANGES[dumpsPriceRangeIdx][1] : Long.MAX_VALUE;\n\t}\n\n\tpublic int getFlipsPage()\n\t{\n\t\treturn flipsPage;\n\t}\n\n\tpublic int getSpikesPage()\n\t{\n\t\treturn spikesPage;\n\t}\n\n\tpublic int getDipsPage()\n\t{\n\t\treturn dipsPage;\n\t}\n\n\tpublic int getDumpsPage()\n\t{\n\t\treturn dumpsPage;\n\t}\n\n\tpublic int getAlertsPage()\n\t{\n\t\treturn alertsPage;\n\t}\n\n\tpublic void setLoading(boolean loading)\n\t{\n\t\tstatusLabel.setText(loading ? \"\\u25CF Fetching...\" : \"\\u25CF Live\");\n\t\tstatusLabel.setForeground(loading ? new Color(0xFFAA00) : GREEN);\n\t}\n\n\tpublic void updateFlips(List\u003cFlipItem\u003e items, int total, int page)\n\t{\n\t\tallFlips \u003d items;\n\t\tflipsTotal \u003d total;\n\t\tflipsPage \u003d page;\n\t\trenderFlips(filtered());\n\t\tupdateTimestamp();\n\t\tsetLoading(false);\n\t}\n\n\tpublic void updateSpikes(List\u003cSpikeItem\u003e items, int total, int page)\n\t{\n\t\tallSpikes \u003d items;\n\t\tspikesTotal \u003d total;\n\t\tspikesPage \u003d page;\n\t\trenderSpikes(filtered());\n\t}\n\n\tpublic void updateDips(List\u003cDipItem\u003e items, int total, int page)\n\t{\n\t\tallDips \u003d items;\n\t\tdipsTotal \u003d total;\n\t\tdipsPage \u003d page;\n\t\trenderDips(filtered());\n\t}\n\n\tpublic void updateDumps(List\u003cDumpItem\u003e items, int total, int page)\n\t{\n\t\tallDumps \u003d items;\n\t\tdumpsTotal \u003d total;\n\t\tdumpsPage \u003d page;\n\t\trenderDumps(filtered());\n\t}\n\n\tpublic void updateAlerts(List\u003cAlertItem\u003e items, int total, int page)\n\t{\n\t\tallAlerts \u003d items;\n\t\talertsTotal \u003d total;\n\t\talertsPage \u003d page;\n\t\trenderAlerts(filtered());\n\t\tsetLoading(false);\n\t}\n\n\tpublic void updateBarrows(List\u003cBarrowsSet\u003e i)\n\t{\n\t\tallBarrows \u003d i;\n\t\tbarrowsPage \u003d 0;\n\t\trenderBarrows(filtered());\n\t}\n\n\tpublic void updateMoon(List\u003cMoonSet\u003e i)\n\t{\n\t\tallMoon \u003d i;\n\t\tmoonPage \u003d 0;\n\t\trenderMoon(filtered());\n\t}\n\n\tpublic void updateDecanting(List\u003cDecantItem\u003e i)\n\t{\n\t\tallDecants \u003d i;\n\t\tdecantPage \u003d 0;\n\t\trenderDecants(filtered());\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Search\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate String filtered()\n\t{\n\t\treturn searchField \u003d\u003d null ? \"\" : searchField.getText().trim();\n\t}\n\n\tprivate void onSearchChanged()\n\t{\n\t\tString q \u003d filtered();\n\t\tCardLayout cl \u003d (CardLayout) mainArea.getLayout();\n\n\t\tif (searchDebounce !\u003d null)\n\t\t{\n\t\t\tsearchDebounce.stop();\n\t\t}\n\n\t\tif (q.isEmpty())\n\t\t{\n\t\t\tcl.show(mainArea, \"tabs\");\n\t\t\trenderFlips(\"\");\n\t\t\trenderSpikes(\"\");\n\t\t\trenderDips(\"\");\n\t\t\trenderDumps(\"\");\n\t\t\trenderBarrows(\"\");\n\t\t\trenderMoon(\"\");\n\t\t\trenderDecants(\"\");\n\t\t\trenderAlerts(\"\");\n\t\t\treturn;\n\t\t}\n\n\t\tcl.show(mainArea, \"search\");\n\n\t\tif (q.length() \u003c 2)\n\t\t{\n\t\t\trenderSearchMessage(\"Type at least 2 characters\\u2026\");\n\t\t\treturn;\n\t\t}\n\n\t\trenderSearchMessage(\"Searching\\u2026\");\n\t\tsearchDebounce \u003d new Timer(300, e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.searchItems(q);\n\t\t\t}\n\t\t});\n\t\tsearchDebounce.setRepeats(false);\n\t\tsearchDebounce.start();\n\t}\n\n\t/**\n\t * Multi-word, order-independent match.\n\t * Every space-separated token must appear somewhere in the text.\n\t * e.g. \"hat party\" matches \"Blue party hat\".\n\t */\n\tprivate static boolean matches(String text, String query)\n\t{\n\t\tif (text \u003d\u003d null || text.isEmpty())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tString lower \u003d text.toLowerCase();\n\t\tfor (String token : query.toLowerCase().split(\"\\\\s+\"))\n\t\t{\n\t\t\tif (!token.isEmpty() \u0026\u0026 !lower.contains(token))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t// Per-tab filter helpers\n\tprivate List\u003cFlipItem\u003e   fFlips(String q)\n\t{\n\t\treturn q.isEmpty() ? allFlips : allFlips.stream().filter(i -\u003e matches(i.name, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cSpikeItem\u003e  fSpikes(String q)\n\t{\n\t\treturn q.isEmpty() ? allSpikes : allSpikes.stream().filter(i -\u003e matches(i.name, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cDipItem\u003e    fDips(String q)\n\t{\n\t\treturn q.isEmpty() ? allDips : allDips.stream().filter(i -\u003e matches(i.name, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cDumpItem\u003e   fDumps(String q)\n\t{\n\t\treturn q.isEmpty() ? allDumps : allDumps.stream().filter(i -\u003e matches(i.name, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cBarrowsSet\u003e fBarrows(String q)\n\t{\n\t\treturn q.isEmpty() ? allBarrows : allBarrows.stream().filter(i -\u003e matches(i.setName + \" \" + i.shortName, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cMoonSet\u003e fMoon(String q)\n\t{\n\t\tList\u003cMoonSet\u003e base \u003d allMoon;\n\t\tif (moonFilterIdx \u003d\u003d 0)\n\t\t{\n\t\t\tbase \u003d base.stream().filter(s -\u003e s.setName.contains(\"Blood\")).collect(Collectors.toList());\n\t\t}\n\t\telse if (moonFilterIdx \u003d\u003d 1)\n\t\t{\n\t\t\tbase \u003d base.stream().filter(s -\u003e s.setName.contains(\"Blue\")).collect(Collectors.toList());\n\t\t}\n\t\telse if (moonFilterIdx \u003d\u003d 2)\n\t\t{\n\t\t\tbase \u003d base.stream().filter(s -\u003e s.setName.contains(\"Eclipse\")).collect(Collectors.toList());\n\t\t}\n\t\tif (!q.isEmpty())\n\t\t{\n\t\t\tbase \u003d base.stream().filter(s -\u003e matches(s.setName, q)).collect(Collectors.toList());\n\t\t}\n\t\treturn base;\n\t}\n\n\tprivate List\u003cDecantItem\u003e fDecants(String q)\n\t{\n\t\treturn q.isEmpty() ? allDecants : allDecants.stream().filter(i -\u003e matches(i.potionName, q)).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cAlertItem\u003e  fAlerts(String q)\n\t{\n\t\treturn q.isEmpty() ? allAlerts : allAlerts.stream().filter(i -\u003e matches(i.name, q)).collect(Collectors.toList());\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Sort helpers\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate List\u003cFlipItem\u003e sortFlips(List\u003cFlipItem\u003e items)\n\t{\n\t\tComparator\u003cFlipItem\u003e c \u003d flipsSortIdx \u003d\u003d 1\n\t\t\t? Comparator.comparingDouble((FlipItem x) -\u003e x.roiPct)\n\t\t\t: Comparator.comparingLong((FlipItem x) -\u003e x.profit);\n\t\treturn items.stream().sorted(c.reversed()).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cDumpItem\u003e sortDumps(List\u003cDumpItem\u003e items)\n\t{\n\t\tif (dumpsSortIdx \u003d\u003d 1)  // Score\n\t\t{\n\t\t\treturn items.stream().sorted(Comparator.comparingInt((DumpItem x) -\u003e x.dumpScore).reversed())\n\t\t\t\t.collect(Collectors.toList());\n\t\t}\n\t\t// Default idx \u003d\u003d 0: Recent  smallest lastDumpHoursAgo first, nulls last\n\t\treturn items.stream().sorted((a, b) -\u003e\n\t\t{\n\t\t\tif (a.lastDumpHoursAgo \u003d\u003d null \u0026\u0026 b.lastDumpHoursAgo \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (a.lastDumpHoursAgo \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (b.lastDumpHoursAgo \u003d\u003d null)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn Double.compare(a.lastDumpHoursAgo, b.lastDumpHoursAgo);\n\t\t}).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cBarrowsSet\u003e sortBarrows(List\u003cBarrowsSet\u003e items)\n\t{\n\t\tComparator\u003cBarrowsSet\u003e c \u003d barrowsSortIdx \u003d\u003d 1 ? Comparator.comparingLong((BarrowsSet x) -\u003e x.totalBrokenCost)\n\t\t\t: Comparator.comparingLong((BarrowsSet x) -\u003e x.bestProfit);\n\t\treturn barrowsSortIdx \u003d\u003d 1 ? items.stream().sorted(c).collect(Collectors.toList())\n\t\t\t: items.stream().sorted(c.reversed()).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cDecantItem\u003e sortDecants(List\u003cDecantItem\u003e items)\n\t{\n\t\tComparator\u003cDecantItem\u003e c \u003d decantSortIdx \u003d\u003d 1 ? Comparator.comparingDouble((DecantItem x) -\u003e x.roiPct)\n\t\t\t: decantSortIdx \u003d\u003d 2 ? Comparator.comparingInt((DecantItem x) -\u003e x.dailyVolume)\n\t\t\t: Comparator.comparingLong((DecantItem x) -\u003e x.profitPer4dose);\n\t\treturn items.stream().sorted(c.reversed()).collect(Collectors.toList());\n\t}\n\n\tprivate List\u003cAlertItem\u003e sortAlerts(List\u003cAlertItem\u003e items)\n\t{\n\t\tComparator\u003cAlertItem\u003e c \u003d alertsSortIdx \u003d\u003d 1 ? Comparator.comparingDouble((AlertItem x) -\u003e x.drawdownPct)\n\t\t\t: Comparator.comparingDouble((AlertItem x) -\u003e x.upsidePct);\n\t\treturn items.stream().sorted(c.reversed()).collect(Collectors.toList());\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Tab renderers\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate void renderFlips(String q)\n\t{\n\t\tList\u003cFlipItem\u003e list \u003d sortFlips(fFlips(q));\n\t\tfillListPaged(flipsListPanel, list, flipsPage, flipsTotal,\n\t\t\tflipsPageLabel, flipsPrev, flipsNext,\n\t\t\t(item, odd) -\u003e new FlipItemPanel(item, itemManager, odd),\n\t\t\t\"No flips found\", \"Try a different preset or filter\");\n\t\thilite(flipsSortBtns, flipsSortIdx);\n\t}\n\n\tprivate void renderSpikes(String q)\n\t{\n\t\tfillListPaged(spikesListPanel, fSpikes(q), spikesPage, spikesTotal,\n\t\t\tspikesPageLabel, spikesPrev, spikesNext,\n\t\t\t(item, odd) -\u003e new SpikeItemPanel(item, itemManager, odd),\n\t\t\t\"No spike signals\", \"Check back soon\");\n\t\thilite(spikesSortBtns, spikesSortIdx);\n\t}\n\n\tprivate void renderDips(String q)\n\t{\n\t\tfillListPaged(dipsListPanel, fDips(q), dipsPage, dipsTotal,\n\t\t\tdipsPageLabel, dipsPrev, dipsNext,\n\t\t\t(item, odd) -\u003e new DipItemPanel(item, itemManager, odd),\n\t\t\t\"No dip signals\", \"Check back soon\");\n\t\thilite(dipsSortBtns, dipsSortIdx);\n\t}\n\n\tprivate void renderDumps(String q)\n\t{\n\t\tfillListPaged(dumpsListPanel, sortDumps(fDumps(q)), dumpsPage, dumpsTotal,\n\t\t\tdumpsPageLabel, dumpsPrev, dumpsNext,\n\t\t\t(item, odd) -\u003e new DumpItemPanel(item, itemManager, odd),\n\t\t\t\"No dump signals\", \"Check back soon\");\n\t\thiliteFilter(dumpsSortBtns, dumpsSortIdx);\n\t}\n\n\tprivate void renderBarrows(String q)\n\t{\n\t\tfillList(barrowsListPanel, sortBarrows(fBarrows(q)), barrowsPage, barrowsPageLabel, barrowsPrev, barrowsNext,\n\t\t\t(item, odd) -\u003e new BarrowsSetPanel(item, itemManager, odd,\n\t\t\t\t() -\u003e\n\t\t\t\t{\n\t\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplugin.onBarrowsSetClicked(item);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\"No Barrows data\", \"\");\n\t\thilite(barrowsSortBtns, barrowsSortIdx);\n\t}\n\n\t/** Switches the Barrows tab to the detail view and renders per-item rows. */\n\tpublic void showBarrowsDetail(BarrowsSet set)\n\t{\n\t\tbarrowsDetailTitle.setText(set.setName !\u003d null \u0026\u0026 !set.setName.isEmpty() ? set.setName : set.shortName);\n\t\tbarrowsDetailPanel.removeAll();\n\n\t\t// Set summary strip\n\t\tbarrowsDetailPanel.add(buildBarrowsDetailSummary(set));\n\t\tbarrowsDetailPanel.add(sep());\n\n\t\t// Per-item rows\n\t\tfor (int i \u003d 0; i \u003c set.items.size(); i++)\n\t\t{\n\t\t\tbarrowsDetailPanel.add(new BarrowsItemPanel(set.items.get(i), itemManager, i % 2 !\u003d 0));\n\t\t\tbarrowsDetailPanel.add(sep());\n\t\t}\n\n\t\tbarrowsDetailPanel.revalidate();\n\t\tbarrowsDetailPanel.repaint();\n\n\t\t((CardLayout) barrowsTabCard.getLayout()).show(barrowsTabCard, \"detail\");\n\t}\n\n\t/** Switches the Barrows tab back to the list view. */\n\tprivate void showBarrowsList()\n\t{\n\t\t((CardLayout) barrowsTabCard.getLayout()).show(barrowsTabCard, \"list\");\n\t}\n\n\t/** Small summary panel shown at the top of the drill-down detail view. */\n\tprivate JPanel buildBarrowsDetailSummary(BarrowsSet set)\n\t{\n\t\tJPanel p \u003d new JPanel(new GridLayout(2, 2, 8, 2));\n\t\tp.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tp.setBorder(new EmptyBorder(8, 10, 8, 10));\n\t\tp.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tboolean profitable \u003d set.bestProfit \u003e 0;\n\t\tString profitColor \u003d profitable ? \"#00C27A\" : \"#FF5555\";\n\t\tString profitSign  \u003d profitable ? \"+\" : \"\";\n\t\tString strat \u003d \"sell_set\".equals(set.bestStrategy) ? \"sell as set\" : \"sell individual\";\n\n\t\tp.add(detailCell(\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eBuy all: \u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#FF7070\u0027\u003e\" + FlipItemPanel.formatGp(set.totalBrokenCost) + \"\u003c/font\u003e\u003c/html\u003e\"));\n\t\tp.add(detailCell(\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eNPC rpr: \u003c/font\u003e\"\n\t\t\t+ FlipItemPanel.formatGp(set.totalNpcRepairCost) + \"\u003c/html\u003e\"));\n\t\tp.add(detailCell(\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eBest: \u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027\" + profitColor + \"\u0027\u003e\u003cb\u003e\" + profitSign + FlipItemPanel.formatGp(set.bestProfit) + \"\u003c/b\u003e\u003c/font\u003e\u003c/html\u003e\"));\n\t\tp.add(detailCell(\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003ePOH rpr: \u003c/font\u003e\"\n\t\t\t+ FlipItemPanel.formatGp(set.totalPohRepairCost) + \"\u003c/html\u003e\"));\n\n\t\treturn p;\n\t}\n\n\tprivate static JLabel detailCell(String html)\n\t{\n\t\tJLabel l \u003d new JLabel(html);\n\t\tl.setFont(Fonts.SM);\n\t\treturn l;\n\t}\n\n\tprivate void renderMoon(String q)\n\t{\n\t\tfillList(moonListPanel, fMoon(q), moonPage, moonPageLabel, moonPrev, moonNext,\n\t\t\t(item, odd) -\u003e new MoonSetPanel(item, itemManager, odd),\n\t\t\t\"No Moon armour data\", \"\");\n\t\thiliteFilter(moonFilterBtns, moonFilterIdx);\n\t}\n\n\tprivate void renderDecants(String q)\n\t{\n\t\tfillList(decantListPanel, sortDecants(fDecants(q)), decantPage, decantPageLabel, decantPrev, decantNext,\n\t\t\t(item, odd) -\u003e new DecantItemPanel(item, itemManager, odd),\n\t\t\t\"No decanting opportunities\", \"\");\n\t\thilite(decantSortBtns, decantSortIdx);\n\t}\n\n\tprivate void renderAlerts(String q)\n\t{\n\t\tfillListPaged(alertsListPanel, sortAlerts(fAlerts(q)), alertsPage, alertsTotal,\n\t\t\talertsPageLabel, alertsPrev, alertsNext,\n\t\t\t(item, odd) -\u003e new AlertItemPanel(item, itemManager, odd),\n\t\t\t\"No active price alerts\", \"Alerts posted twice daily\");\n\t\thilite(alertsSortBtns, alertsSortIdx);\n\t}\n\n\t/** Shows a plain status/placeholder message in the search panel. */\n\tprivate void renderSearchMessage(String message)\n\t{\n\t\tsearchResultsPanel.removeAll();\n\t\tJLabel lbl \u003d new JLabel(message);\n\t\tlbl.setFont(Fonts.SM);\n\t\tlbl.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\tlbl.setBorder(new EmptyBorder(16, 12, 16, 12));\n\t\tlbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tsearchResultsPanel.add(lbl);\n\t\tsearchResultsPanel.revalidate();\n\t\tsearchResultsPanel.repaint();\n\t}\n\n\t/** Called by the plugin when the API search returns results. */\n\tpublic void showSearchResults(List\u003cSearchResultItem\u003e items, String query)\n\t{\n\t\t// Ignore stale callbacks if the user has already changed the query\n\t\tif (!query.equals(filtered()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tsearchResultsPanel.removeAll();\n\n\t\tif (items.isEmpty())\n\t\t{\n\t\t\tJLabel none \u003d new JLabel(\"No results for \\u201C\" + query + \"\\u201D\");\n\t\t\tnone.setFont(Fonts.SM);\n\t\t\tnone.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\t\tnone.setBorder(new EmptyBorder(16, 12, 16, 12));\n\t\t\tnone.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\t\tsearchResultsPanel.add(none);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i \u003d 0; i \u003c items.size(); i++)\n\t\t\t{\n\t\t\t\tsearchResultsPanel.add(new SearchResultPanel(items.get(i), itemManager, i % 2 !\u003d 0));\n\t\t\t\tsearchResultsPanel.add(sep());\n\t\t\t}\n\t\t}\n\n\t\tsearchResultsPanel.revalidate();\n\t\tsearchResultsPanel.repaint();\n\t\tsearchScrollPane.revalidate();\n\t\tsearchScrollPane.repaint();\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Locked panel (premium feature)\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate void renderLocked(JPanel panel, String title, String sub)\n\t{\n\t\tpanel.removeAll();\n\n\t\tJPanel inner \u003d new JPanel();\n\t\tinner.setLayout(new BoxLayout(inner, BoxLayout.Y_AXIS));\n\t\tinner.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tinner.setBorder(new EmptyBorder(20, 14, 20, 14));\n\t\tinner.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel icon \u003d new JLabel(\"\\uD83D\\uDD12 \" + title);\n\t\ticon.setFont(Fonts.BOLD);\n\t\ticon.setForeground(ORANGE);\n\t\ticon.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel desc \u003d new JLabel(\"\u003chtml\u003e\" + sub + \"\u003cbr\u003e\u003cbr\u003eGet premium at \u003cb\u003e07flip.com/premium\u003c/b\u003e.\u003c/html\u003e\");\n\t\tdesc.setFont(Fonts.SM);\n\t\tdesc.setForeground(new Color(0x888888));\n\t\tdesc.setBorder(new EmptyBorder(6, 0, 14, 0));\n\t\tdesc.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJButton btn \u003d pillButton(\"Get Premium\");\n\t\tbtn.setBackground(ORANGE);\n\t\tbtn.setForeground(Color.BLACK);\n\t\tbtn.addActionListener(e -\u003e openUrl(PREMIUM_URL));\n\n\t\tinner.add(icon);\n\t\tinner.add(desc);\n\t\tinner.add(btn);\n\n\t\tpanel.add(inner);\n\t\tpanel.revalidate();\n\t\tpanel.repaint();\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Generic list filler with pagination and auth-gating\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\t@FunctionalInterface\n\tprivate interface RowFactory\u003cT\u003e\n\t{\n\t\tJComponent build(T item, boolean odd);\n\t}\n\n\t@FunctionalInterface\n\tinterface IntSupplier\n\t{\n\t\tint get();\n\t}\n\n\t@FunctionalInterface\n\tinterface IntConsumer\n\t{\n\t\tvoid accept(int v);\n\t}\n\n\t/**\n\t * Server-paginated variant: items is exactly one page from the server.\n\t * serverTotal is the total item count across all pages.\n\t * page/prev/next are for display and navigation only.\n\t */\n\tprivate \u003cT\u003e void fillListPaged(JPanel panel, List\u003cT\u003e items, int page, int serverTotal,\n\t\tJLabel pageLabel, JButton prev, JButton next,\n\t\tRowFactory\u003cT\u003e factory, String emptyTitle, String emptySub)\n\t{\n\t\tpanel.removeAll();\n\t\tint ps    \u003d isSignedIn ? PAGE_SIZE : FREE_ROWS;\n\t\tint total \u003d Math.max(serverTotal, items.size());\n\t\tint pages \u003d Math.max(1, (int) Math.ceil(total / (double) PAGE_SIZE));\n\t\tint end   \u003d Math.min(items.size(), ps);\n\n\t\tif (total \u003d\u003d 0 || items.isEmpty())\n\t\t{\n\t\t\tpanel.add(emptyLabel(emptyTitle, emptySub));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i \u003d 0; i \u003c end; i++)\n\t\t\t{\n\t\t\t\tpanel.add(factory.build(items.get(i), i % 2 !\u003d 0));\n\t\t\t\tpanel.add(sep());\n\t\t\t}\n\t\t\tif (!isSignedIn \u0026\u0026 total \u003e FREE_ROWS)\n\t\t\t{\n\t\t\t\tpanel.add(signInPrompt(total - FREE_ROWS));\n\t\t\t}\n\t\t}\n\n\t\tpageLabel.setText(isSignedIn \u0026\u0026 total \u003e 0 ? (page + 1) + \" / \" + pages : \"\");\n\t\tprev.setEnabled(isSignedIn \u0026\u0026 page \u003e 0);\n\t\tnext.setEnabled(isSignedIn \u0026\u0026 page \u003c pages - 1);\n\t\tpanel.revalidate();\n\t\tpanel.repaint();\n\t}\n\n\tprivate \u003cT\u003e void fillList(JPanel panel, List\u003cT\u003e items, int page,\n\t\tJLabel pageLabel, JButton prev, JButton next,\n\t\tRowFactory\u003cT\u003e factory, String emptyTitle, String emptySub)\n\t{\n\t\tpanel.removeAll();\n\t\tint ps    \u003d isSignedIn ? PAGE_SIZE : FREE_ROWS;\n\t\tint total \u003d items.size();\n\t\tint pages \u003d Math.max(1, (int) Math.ceil(total / (double) ps));\n\t\tint safe  \u003d isSignedIn ? Math.min(page, pages - 1) : 0;\n\t\tint start \u003d safe * ps;\n\t\tint end   \u003d Math.min(start + ps, total);\n\n\t\tif (total \u003d\u003d 0)\n\t\t{\n\t\t\tpanel.add(emptyLabel(emptyTitle, emptySub));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i \u003d start; i \u003c end; i++)\n\t\t\t{\n\t\t\t\tpanel.add(factory.build(items.get(i), i % 2 !\u003d 0));\n\t\t\t\tpanel.add(sep());\n\t\t\t}\n\t\t\tif (!isSignedIn \u0026\u0026 total \u003e FREE_ROWS)\n\t\t\t{\n\t\t\t\tpanel.add(signInPrompt(total - FREE_ROWS));\n\t\t\t}\n\t\t}\n\n\t\tpageLabel.setText(isSignedIn \u0026\u0026 total \u003e 0 ? (safe + 1) + \" / \" + pages : \"\");\n\t\tprev.setEnabled(isSignedIn \u0026\u0026 safe \u003e 0);\n\t\tnext.setEnabled(isSignedIn \u0026\u0026 safe \u003c pages - 1);\n\t\tpanel.revalidate();\n\t\tpanel.repaint();\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Build top panel\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel buildTopPanel()\n\t{\n\t\tJPanel header \u003d new JPanel(new BorderLayout());\n\t\theader.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\theader.setBorder(new EmptyBorder(10, 12, 6, 12));\n\n\t\tJLabel title \u003d new JLabel(\"07Flip\");\n\t\ttitle.setFont(Fonts.TITLE);\n\t\ttitle.setForeground(ORANGE);\n\n\t\tstatusLabel \u003d new JLabel(\"\\u25CF Loading\");\n\t\tstatusLabel.setFont(Fonts.SM);\n\t\tstatusLabel.setForeground(new Color(0xFFAA00));\n\n\t\theader.add(title,       BorderLayout.WEST);\n\t\theader.add(statusLabel, BorderLayout.EAST);\n\n\t\t// Search field with placeholder\n\t\tsearchField \u003d new JTextField()\n\t\t{\n\t\t\tprivate static final String HINT \u003d \"Search all items\\u2026\";\n\n\t\t\t@Override\n\t\t\tprotected void paintComponent(Graphics g)\n\t\t\t{\n\t\t\t\tsuper.paintComponent(g);\n\t\t\t\tif (getText().isEmpty() \u0026\u0026 !isFocusOwner())\n\t\t\t\t{\n\t\t\t\t\tGraphics2D g2 \u003d (Graphics2D) g.create();\n\t\t\t\t\tg2.setColor(new Color(0x555555));\n\t\t\t\t\tg2.setFont(getFont());\n\t\t\t\t\tFontMetrics fm \u003d g2.getFontMetrics();\n\t\t\t\t\tInsets ins \u003d getInsets();\n\t\t\t\t\tg2.drawString(HINT, ins.left, ins.top + fm.getAscent() + (getHeight() - ins.top - ins.bottom - fm.getHeight()) / 2);\n\t\t\t\t\tg2.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsearchField.setBackground(new Color(0x1E1E1E));\n\t\tsearchField.setForeground(Color.WHITE);\n\t\tsearchField.setCaretColor(Color.WHITE);\n\t\tsearchField.setFont(Fonts.SM);\n\t\tsearchField.setBorder(new EmptyBorder(5, 8, 5, 4));\n\n\t\t//  Clear () button  shown only when the field has text \n\t\tJLabel clearBtn \u003d new JLabel(\"\\u00D7\");\n\t\tclearBtn.setFont(Fonts.SM);\n\t\tclearBtn.setForeground(new Color(0x666666));\n\t\tclearBtn.setBorder(new EmptyBorder(0, 2, 0, 8));\n\t\tclearBtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tclearBtn.setVisible(false);\n\t\tclearBtn.addMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tsearchField.setText(\"\");\n\t\t\t\tsearchField.requestFocus();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tclearBtn.setForeground(Color.WHITE);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tclearBtn.setForeground(new Color(0x666666));\n\t\t\t}\n\t\t});\n\n\t\t//  Wrapper panel provides the outer border around field + button \n\t\tJPanel searchBox \u003d new JPanel(new BorderLayout());\n\t\tsearchBox.setBackground(new Color(0x1E1E1E));\n\t\tsearchBox.setBorder(BorderFactory.createCompoundBorder(\n\t\t\tnew MatteBorder(1, 1, 1, 1, new Color(0x4A4A4A)),\n\t\t\tBorderFactory.createEmptyBorder()));\n\t\tsearchBox.add(searchField, BorderLayout.CENTER);\n\t\tsearchBox.add(clearBtn,    BorderLayout.EAST);\n\n\t\tsearchField.getDocument().addDocumentListener(new DocumentListener()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void insertUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tclearBtn.setVisible(!searchField.getText().isEmpty());\n\t\t\t\tonSearchChanged();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void removeUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tclearBtn.setVisible(!searchField.getText().isEmpty());\n\t\t\t\tonSearchChanged();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void changedUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tclearBtn.setVisible(!searchField.getText().isEmpty());\n\t\t\t\tonSearchChanged();\n\t\t\t}\n\t\t});\n\n\t\tJPanel searchRow \u003d new JPanel(new BorderLayout());\n\t\tsearchRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsearchRow.setBorder(new EmptyBorder(0, 12, 8, 12));\n\t\tsearchRow.add(searchBox, BorderLayout.CENTER);\n\n\t\tJPanel top \u003d new JPanel(new BorderLayout());\n\t\ttop.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\ttop.setBorder(new MatteBorder(0, 0, 1, 0, new Color(0x3A3A3A)));\n\t\ttop.add(header,    BorderLayout.NORTH);\n\t\ttop.add(searchRow, BorderLayout.SOUTH);\n\t\treturn top;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Build tabs\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JTabbedPane buildTabs()\n\t{\n\t\tJTabbedPane tabs \u003d new JTabbedPane(JTabbedPane.TOP, JTabbedPane.SCROLL_TAB_LAYOUT);\n\t\ttabs.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\ttabs.setForeground(Color.WHITE);\n\t\ttabs.setFont(Fonts.SM);\n\n\t\ttabs.addTab(\"Flips\",   buildFlipsTab());\n\t\ttabs.addTab(\"Dumps\",   buildDumpsTab());\n\t\ttabs.addTab(\"Spikes\",  buildSpikesTab());\n\t\ttabs.addTab(\"Dips\",    buildDipsTab());\n\t\ttabs.addTab(\"Alerts\",  buildGenericTab(\"Merch\"));\n\t\ttabs.addTab(\"Moon\",    buildMoonTab());\n\t\ttabs.addTab(\"Barrows\", buildGenericTab(\"Barrows\"));\n\t\ttabs.addTab(\"Decant\",  buildGenericTab(\"Decant\"));\n\t\treturn tabs;\n\t}\n\n\tprivate JPanel buildFlipsTab()\n\t{\n\t\tJPanel presetRow \u003d new JPanel(new BorderLayout(4, 0));\n\t\tpresetRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tpresetRow.setBorder(new EmptyBorder(4, 8, 0, 8));\n\t\tpresetRow.add(presetSelector, BorderLayout.CENTER);\n\n\t\tJComboBox\u003cString\u003e minProfitCb \u003d styledCombo(MIN_PROFIT_LABELS);\n\t\tminProfitCb.addActionListener(e -\u003e\n\t\t{\n\t\t\tflipsMinProfitIdx \u003d minProfitCb.getSelectedIndex();\n\t\t\tflipsPage \u003d 0;\n\t\t\trenderFlips(filtered());\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onFlipsFilterChanged();\n\t\t\t}\n\t\t});\n\n\t\tJComboBox\u003cString\u003e priceRangeCb \u003d styledCombo(PRICE_RANGE_LABELS);\n\t\tpriceRangeCb.addActionListener(e -\u003e\n\t\t{\n\t\t\tflipsPriceRangeIdx \u003d priceRangeCb.getSelectedIndex();\n\t\t\tflipsPage \u003d 0;\n\t\t\trenderFlips(filtered());\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onFlipsFilterChanged();\n\t\t\t}\n\t\t});\n\n\t\tJPanel filterRow \u003d new JPanel(new GridLayout(1, 2, 4, 0));\n\t\tfilterRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfilterRow.setBorder(new EmptyBorder(4, 8, 0, 8));\n\t\tfilterRow.add(minProfitCb);\n\t\tfilterRow.add(priceRangeCb);\n\n\t\tflipsSortBtns \u003d new JButton[2];\n\t\tJPanel sortRow \u003d buildSortBar(flipsSortBtns, new String[]{\"Profit\", \"ROI %\"},\n\t\t\t() -\u003e flipsSortIdx, i -\u003e\n\t\t\t{\n\t\t\t\tflipsSortIdx \u003d i;\n\t\t\t\tflipsPage \u003d 0;\n\t\t\t\trenderFlips(filtered());\n\t\t\t});\n\n\t\tJPanel topBar \u003d new JPanel(new BorderLayout());\n\t\ttopBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\ttopBar.add(presetRow,  BorderLayout.NORTH);\n\t\ttopBar.add(filterRow,  BorderLayout.CENTER);\n\t\ttopBar.add(sortRow,    BorderLayout.SOUTH);\n\n\t\tflipsListPanel \u003d listPanel();\n\t\tflipsPageLabel \u003d pageLabel();\n\t\tflipsPrev      \u003d pageBtn(\"\\u2039\");\n\t\tflipsNext      \u003d pageBtn(\"\\u203A\");\n\t\tflipsPrev.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onFlipsPageChanged(--flipsPage);\n\t\t\t}\n\t\t});\n\t\tflipsNext.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onFlipsPageChanged(++flipsPage);\n\t\t\t}\n\t\t});\n\n\t\treturn assembleTab(topBar, flipsListPanel, buildPageBar(flipsPageLabel, flipsPrev, flipsNext));\n\t}\n\n\tprivate JPanel buildMoonTab()\n\t{\n\t\t// Filter bar: Blood Moon | Blue Moon | Eclipse Moon\n\t\tmoonFilterBtns \u003d new JButton[3];\n\t\tString[] labels \u003d {\"Blood\", \"Blue\", \"Eclipse\"};\n\t\tJPanel filterBar \u003d new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 4));\n\t\tfilterBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfilterBar.setBorder(new MatteBorder(0, 0, 1, 0, new Color(0x3A3A3A)));\n\t\tfor (int i \u003d 0; i \u003c labels.length; i++)\n\t\t{\n\t\t\tfinal int idx \u003d i;\n\t\t\tJButton btn \u003d pillButton(labels[i]);\n\t\t\tapplySortStyle(btn, idx \u003d\u003d moonFilterIdx);\n\t\t\tbtn.addActionListener(e -\u003e\n\t\t\t{\n\t\t\t\tmoonFilterIdx \u003d idx;\n\t\t\t\thiliteFilter(moonFilterBtns, moonFilterIdx);\n\t\t\t\tmoonPage \u003d 0;\n\t\t\t\trenderMoon(filtered());\n\t\t\t});\n\t\t\tmoonFilterBtns[i] \u003d btn;\n\t\t\tfilterBar.add(btn);\n\t\t}\n\n\t\tmoonListPanel \u003d listPanel();\n\t\tmoonPageLabel \u003d pageLabel();\n\t\tmoonPrev      \u003d pageBtn(\"\\u2039\");\n\t\tmoonNext      \u003d pageBtn(\"\\u203A\");\n\t\tmoonPrev.addActionListener(e -\u003e\n\t\t{\n\t\t\tmoonPage--;\n\t\t\trenderMoon(filtered());\n\t\t});\n\t\tmoonNext.addActionListener(e -\u003e\n\t\t{\n\t\t\tmoonPage++;\n\t\t\trenderMoon(filtered());\n\t\t});\n\n\t\treturn assembleTab(filterBar, moonListPanel, buildPageBar(moonPageLabel, moonPrev, moonNext));\n\t}\n\n\tprivate JPanel buildSpikesTab()\n\t{\n\t\tspikesSortBtns \u003d new JButton[2];\n\t\tJPanel sortRow \u003d buildSortBar(spikesSortBtns, new String[]{\"Recent\", \"Spike %\"},\n\t\t\t() -\u003e spikesSortIdx, i -\u003e\n\t\t\t{\n\t\t\t\tspikesSortIdx \u003d i;\n\t\t\t\tspikesSortKey \u003d i \u003d\u003d 0 ? \"recent\" : \"spike_pct\";\n\t\t\t\tspikesPage    \u003d 0;\n\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tplugin.onSpikesSortChanged(spikesSortKey);\n\t\t\t\t}\n\t\t\t});\n\n\t\tspikesListPanel \u003d listPanel();\n\t\tspikesPageLabel \u003d pageLabel();\n\t\tspikesPrev      \u003d pageBtn(\"\\u2039\");\n\t\tspikesNext      \u003d pageBtn(\"\\u203A\");\n\t\tspikesPrev.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onSpikesPageChanged(--spikesPage);\n\t\t\t}\n\t\t});\n\t\tspikesNext.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onSpikesPageChanged(++spikesPage);\n\t\t\t}\n\t\t});\n\n\t\treturn assembleTab(sortRow, spikesListPanel, buildPageBar(spikesPageLabel, spikesPrev, spikesNext));\n\t}\n\n\tprivate JPanel buildDipsTab()\n\t{\n\t\tdipsSortBtns \u003d new JButton[2];\n\t\tJPanel sortRow \u003d buildSortBar(dipsSortBtns, new String[]{\"Recent\", \"Biggest Dip\"},\n\t\t\t() -\u003e dipsSortIdx, i -\u003e\n\t\t\t{\n\t\t\t\tdipsSortIdx \u003d i;\n\t\t\t\tdipsSortKey \u003d i \u003d\u003d 0 ? \"recent\" : \"dip_pct\";\n\t\t\t\tdipsPage    \u003d 0;\n\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tplugin.onDipsSortChanged(dipsSortKey);\n\t\t\t\t}\n\t\t\t});\n\n\t\tdipsListPanel \u003d listPanel();\n\t\tdipsPageLabel \u003d pageLabel();\n\t\tdipsPrev      \u003d pageBtn(\"\\u2039\");\n\t\tdipsNext      \u003d pageBtn(\"\\u203A\");\n\t\tdipsPrev.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDipsPageChanged(--dipsPage);\n\t\t\t}\n\t\t});\n\t\tdipsNext.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDipsPageChanged(++dipsPage);\n\t\t\t}\n\t\t});\n\n\t\treturn assembleTab(sortRow, dipsListPanel, buildPageBar(dipsPageLabel, dipsPrev, dipsNext));\n\t}\n\n\tprivate JPanel buildDumpsTab()\n\t{\n\t\t// Sort bar  no sign-in gate (server-side sort, useful to all users)\n\t\tdumpsSortBtns \u003d new JButton[2];\n\t\tString[] sortLabels \u003d {\"Recent\", \"Score\"};\n\t\tJPanel sortRow \u003d new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 4));\n\t\tsortRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsortRow.setBorder(new MatteBorder(0, 0, 1, 0, new Color(0x3A3A3A)));\n\t\tfor (int i \u003d 0; i \u003c sortLabels.length; i++)\n\t\t{\n\t\t\tfinal int idx \u003d i;\n\t\t\tJButton btn \u003d pillButton(sortLabels[i]);\n\t\t\tapplySortStyle(btn, idx \u003d\u003d dumpsSortIdx);\n\t\t\tbtn.addActionListener(e -\u003e\n\t\t\t{\n\t\t\t\tdumpsSortIdx \u003d idx;\n\t\t\t\tdumpsSortKey \u003d idx \u003d\u003d 0 ? \"recent\" : \"dump_pct\";\n\t\t\t\tdumpsPage    \u003d 0;\n\t\t\t\thiliteFilter(dumpsSortBtns, dumpsSortIdx);\n\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tplugin.onDumpsSortChanged(dumpsSortKey);\n\t\t\t\t}\n\t\t\t});\n\t\t\tdumpsSortBtns[i] \u003d btn;\n\t\t\tsortRow.add(btn);\n\t\t}\n\n\t\t// Client-side filters\n\t\tJComboBox\u003cString\u003e minProfitCb \u003d styledCombo(DUMP_MIN_PROFIT_LABELS);\n\t\tminProfitCb.addActionListener(e -\u003e\n\t\t{\n\t\t\tdumpsMinProfitIdx \u003d minProfitCb.getSelectedIndex();\n\t\t\tdumpsPage \u003d 0;\n\t\t\trenderDumps(filtered());\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDumpsFilterChanged();\n\t\t\t}\n\t\t});\n\n\t\tJComboBox\u003cString\u003e priceRangeCb \u003d styledCombo(PRICE_RANGE_LABELS);\n\t\tpriceRangeCb.addActionListener(e -\u003e\n\t\t{\n\t\t\tdumpsPriceRangeIdx \u003d priceRangeCb.getSelectedIndex();\n\t\t\tdumpsPage \u003d 0;\n\t\t\trenderDumps(filtered());\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDumpsFilterChanged();\n\t\t\t}\n\t\t});\n\n\t\tJPanel filterRow \u003d new JPanel(new GridLayout(1, 2, 4, 0));\n\t\tfilterRow.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfilterRow.setBorder(new EmptyBorder(4, 8, 4, 8));\n\t\tfilterRow.add(minProfitCb);\n\t\tfilterRow.add(priceRangeCb);\n\n\t\tJPanel topBar \u003d new JPanel(new BorderLayout());\n\t\ttopBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\ttopBar.add(filterRow, BorderLayout.NORTH);\n\t\ttopBar.add(sortRow,   BorderLayout.SOUTH);\n\n\t\tdumpsListPanel \u003d listPanel();\n\t\tdumpsPageLabel \u003d pageLabel();\n\t\tdumpsPrev      \u003d pageBtn(\"\\u2039\");\n\t\tdumpsNext      \u003d pageBtn(\"\\u203A\");\n\t\tdumpsPrev.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDumpsPageChanged(--dumpsPage);\n\t\t\t}\n\t\t});\n\t\tdumpsNext.addActionListener(e -\u003e\n\t\t{\n\t\t\tif (plugin !\u003d null)\n\t\t\t{\n\t\t\t\tplugin.onDumpsPageChanged(++dumpsPage);\n\t\t\t}\n\t\t});\n\n\t\treturn assembleTab(topBar, dumpsListPanel, buildPageBar(dumpsPageLabel, dumpsPrev, dumpsNext));\n\t}\n\n\tprivate JPanel buildGenericTab(String name)\n\t{\n\t\tswitch (name)\n\t\t{\n\t\t\tcase \"Barrows\":\n\t\t\t{\n\t\t\t\t//  List view \n\t\t\t\tbarrowsSortBtns  \u003d new JButton[2];\n\t\t\t\tbarrowsListPanel \u003d listPanel();\n\t\t\t\tbarrowsPageLabel \u003d pageLabel();\n\t\t\t\tbarrowsPrev      \u003d pageBtn(\"\\u2039\");\n\t\t\t\tbarrowsNext      \u003d pageBtn(\"\\u203A\");\n\t\t\t\tbarrowsPrev.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tbarrowsPage--;\n\t\t\t\t\trenderBarrows(filtered());\n\t\t\t\t});\n\t\t\t\tbarrowsNext.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tbarrowsPage++;\n\t\t\t\t\trenderBarrows(filtered());\n\t\t\t\t});\n\t\t\t\tJPanel barrowsListView \u003d assembleTab(\n\t\t\t\t\tbuildSortBar(barrowsSortBtns, new String[]{\"Best Profit\", \"Cost\"},\n\t\t\t\t\t\t() -\u003e barrowsSortIdx, i -\u003e\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbarrowsSortIdx \u003d i;\n\t\t\t\t\t\t\tbarrowsPage \u003d 0;\n\t\t\t\t\t\t\trenderBarrows(filtered());\n\t\t\t\t\t\t}),\n\t\t\t\t\tbarrowsListPanel,\n\t\t\t\t\tbuildPageBar(barrowsPageLabel, barrowsPrev, barrowsNext));\n\n\t\t\t\t//  Detail view \n\t\t\t\tbarrowsDetailPanel \u003d listPanel();\n\t\t\t\tbarrowsDetailTitle \u003d new JLabel(\"\");\n\t\t\t\tbarrowsDetailTitle.setFont(Fonts.BOLD);\n\t\t\t\tbarrowsDetailTitle.setForeground(Color.WHITE);\n\n\t\t\t\tJButton backBtn \u003d pillButton(\"\\u2190 Back\");\n\t\t\t\tbackBtn.setBackground(new Color(0x3E3E3E));\n\t\t\t\tbackBtn.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\t\t\tbackBtn.addActionListener(e -\u003e showBarrowsList());\n\n\t\t\t\tJPanel detailHeader \u003d new JPanel(new BorderLayout(8, 0));\n\t\t\t\tdetailHeader.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\t\t\tdetailHeader.setBorder(new EmptyBorder(6, 8, 6, 8));\n\t\t\t\tdetailHeader.add(backBtn,            BorderLayout.WEST);\n\t\t\t\tdetailHeader.add(barrowsDetailTitle, BorderLayout.CENTER);\n\n\t\t\t\tListWrapperPanel detailWrapper \u003d new ListWrapperPanel(barrowsDetailPanel);\n\t\t\t\tdetailWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\t\t\tJScrollPane detailSp \u003d new JScrollPane(detailWrapper);\n\t\t\t\tdetailSp.setBorder(BorderFactory.createEmptyBorder());\n\t\t\t\tdetailSp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t\t\tdetailSp.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\t\t\tdetailSp.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));\n\n\t\t\t\tJPanel barrowsDetailView \u003d new JPanel(new BorderLayout());\n\t\t\t\tbarrowsDetailView.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\t\t\tbarrowsDetailView.add(detailHeader, BorderLayout.NORTH);\n\t\t\t\tbarrowsDetailView.add(detailSp,     BorderLayout.CENTER);\n\n\t\t\t\t//  Card panel \n\t\t\t\tbarrowsTabCard \u003d new JPanel(new CardLayout());\n\t\t\t\tbarrowsTabCard.add(barrowsListView,   \"list\");\n\t\t\t\tbarrowsTabCard.add(barrowsDetailView, \"detail\");\n\t\t\t\treturn barrowsTabCard;\n\t\t\t}\n\n\t\t\tcase \"Decant\":\n\t\t\t\tdecantSortBtns  \u003d new JButton[3];\n\t\t\t\tdecantListPanel \u003d listPanel();\n\t\t\t\tdecantPageLabel \u003d pageLabel();\n\t\t\t\tdecantPrev      \u003d pageBtn(\"\\u2039\");\n\t\t\t\tdecantNext      \u003d pageBtn(\"\\u203A\");\n\t\t\t\tdecantPrev.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tdecantPage--;\n\t\t\t\t\trenderDecants(filtered());\n\t\t\t\t});\n\t\t\t\tdecantNext.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tdecantPage++;\n\t\t\t\t\trenderDecants(filtered());\n\t\t\t\t});\n\t\t\t\treturn assembleTab(buildSortBar(decantSortBtns, new String[]{\"Profit\", \"ROI %\", \"Volume\"},\n\t\t\t\t\t() -\u003e decantSortIdx, i -\u003e\n\t\t\t\t\t{\n\t\t\t\t\t\tdecantSortIdx \u003d i;\n\t\t\t\t\t\tdecantPage \u003d 0;\n\t\t\t\t\t\trenderDecants(filtered());\n\t\t\t\t\t}),\n\t\t\t\t\tdecantListPanel, buildPageBar(decantPageLabel, decantPrev, decantNext));\n\n\t\t\tdefault: // Merch / Price Alerts\n\t\t\t\talertsSortBtns  \u003d new JButton[2];\n\t\t\t\talertsListPanel \u003d listPanel();\n\t\t\t\talertsPageLabel \u003d pageLabel();\n\t\t\t\talertsPrev      \u003d pageBtn(\"\\u2039\");\n\t\t\t\talertsNext      \u003d pageBtn(\"\\u203A\");\n\t\t\t\talertsPrev.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplugin.onAlertsPageChanged(--alertsPage);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\talertsNext.addActionListener(e -\u003e\n\t\t\t\t{\n\t\t\t\t\tif (plugin !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tplugin.onAlertsPageChanged(++alertsPage);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn assembleTab(buildSortBar(alertsSortBtns, new String[]{\"Upside %\", \"Drawdown\"},\n\t\t\t\t\t() -\u003e alertsSortIdx, i -\u003e\n\t\t\t\t\t{\n\t\t\t\t\t\talertsSortIdx \u003d i;\n\t\t\t\t\t\talertsPage \u003d 0;\n\t\t\t\t\t\trenderAlerts(filtered());\n\t\t\t\t\t}),\n\t\t\t\t\talertsListPanel, buildPageBar(alertsPageLabel, alertsPrev, alertsNext));\n\t\t}\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Search view\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JScrollPane buildSearchView()\n\t{\n\t\tsearchResultsPanel \u003d new JPanel();\n\t\tsearchResultsPanel.setLayout(new BoxLayout(searchResultsPanel, BoxLayout.Y_AXIS));\n\t\tsearchResultsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tListWrapperPanel searchWrapper \u003d new ListWrapperPanel(searchResultsPanel);\n\t\tsearchWrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tsearchScrollPane \u003d new JScrollPane(searchWrapper);\n\t\tsearchScrollPane.setBorder(BorderFactory.createEmptyBorder());\n\t\tsearchScrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tsearchScrollPane.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tsearchScrollPane.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));\n\t\treturn searchScrollPane;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Preset dropdown renderer (premium items greyed + [P] tag)\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate ListCellRenderer\u003cObject\u003e buildPresetRenderer()\n\t{\n\t\treturn new BasicComboBoxRenderer()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic Component getListCellRendererComponent(JList\u003c?\u003e list, Object value,\n\t\t\t\tint index, boolean isSelected, boolean cellHasFocus)\n\t\t\t{\n\t\t\t\tJLabel lbl \u003d (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);\n\t\t\t\tlbl.setBackground(isSelected ? new Color(0x4A4A4A) : ColorScheme.DARKER_GRAY_COLOR);\n\t\t\t\tint i \u003d index \u003e\u003d 0 ? index : presetSelector.getSelectedIndex();\n\t\t\t\tif (i \u003e\u003d 0 \u0026\u0026 i \u003c PREMIUM_PRESET.length \u0026\u0026 PREMIUM_PRESET[i] \u0026\u0026 !isPremium)\n\t\t\t\t{\n\t\t\t\t\tlbl.setForeground(new Color(0x777777));\n\t\t\t\t\tlbl.setText(\"\u003chtml\u003e\" + value + \" \u003cfont color\u003d\u0027#FF981F\u0027\u003e\u003cb\u003e[P]\u003c/b\u003e\u003c/font\u003e\u003c/html\u003e\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlbl.setForeground(Color.WHITE);\n\t\t\t\t}\n\t\t\t\treturn lbl;\n\t\t\t}\n\t\t};\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Sort bar  pill buttons\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel buildSortBar(JButton[] store, String[] labels, IntSupplier get, IntConsumer set)\n\t{\n\t\tJPanel bar \u003d new JPanel(new FlowLayout(FlowLayout.LEFT, 4, 4));\n\t\tbar.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tbar.setBorder(new MatteBorder(0, 0, 1, 0, new Color(0x3A3A3A)));\n\t\tfor (int i \u003d 0; i \u003c labels.length; i++)\n\t\t{\n\t\t\tfinal int idx \u003d i;\n\t\t\tJButton btn \u003d pillButton(labels[i]);\n\t\t\tapplySortStyle(btn, i \u003d\u003d get.get());\n\t\t\tbtn.addActionListener(e -\u003e\n\t\t\t{\n\t\t\t\tif (!isSignedIn)\n\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tset.accept(idx);\n\t\t\t\thilite(store, idx);\n\t\t\t});\n\t\t\tstore[i] \u003d btn;\n\t\t\tbar.add(btn);\n\t\t}\n\t\treturn bar;\n\t}\n\n\tprivate static JButton pillButton(String label)\n\t{\n\t\tJButton btn \u003d new JButton(label)\n\t\t{\n\t\t\t@Override\n\t\t\tprotected void paintComponent(Graphics g)\n\t\t\t{\n\t\t\t\tGraphics2D g2 \u003d (Graphics2D) g.create();\n\t\t\t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\t\t\t\tColor bg \u003d isEnabled() ? getBackground() : new Color(0x2A2A2A);\n\t\t\t\tColor fg \u003d isEnabled() ? getForeground() : new Color(0x555555);\n\t\t\t\tint arc \u003d getHeight();\n\t\t\t\tg2.setColor(bg);\n\t\t\t\tg2.fillRoundRect(0, 0, getWidth(), getHeight(), arc, arc);\n\t\t\t\tg2.setColor(fg);\n\t\t\t\tg2.setFont(getFont());\n\t\t\t\tFontMetrics fm \u003d g2.getFontMetrics();\n\t\t\t\tg2.drawString(getText(), (getWidth() - fm.stringWidth(getText())) / 2,\n\t\t\t\t\t(getHeight() + fm.getAscent() - fm.getDescent()) / 2);\n\t\t\t\tg2.dispose();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void paintBorder(Graphics g)\n\t\t\t{\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isOpaque()\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\t\tbtn.setFont(Fonts.SM);\n\t\tbtn.setFocusPainted(false);\n\t\tbtn.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tbtn.setBorder(new EmptyBorder(3, 10, 3, 10));\n\t\treturn btn;\n\t}\n\n\tprivate void applySortStyle(JButton btn, boolean active)\n\t{\n\t\tbtn.setBackground(active ? ORANGE : new Color(0x3E3E3E));\n\t\tbtn.setForeground(active ? Color.BLACK : ColorScheme.LIGHT_GRAY_COLOR);\n\t}\n\n\tprivate void hilite(JButton[] btns, int active)\n\t{\n\t\tif (btns \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i \u003d 0; i \u003c btns.length; i++)\n\t\t{\n\t\t\tbtns[i].setEnabled(isSignedIn);\n\t\t\tapplySortStyle(btns[i], isSignedIn \u0026\u0026 i \u003d\u003d active);\n\t\t}\n\t}\n\n\t/** Filter buttons  always enabled, no sign-in gate. */\n\tprivate void hiliteFilter(JButton[] btns, int active)\n\t{\n\t\tif (btns \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfor (int i \u003d 0; i \u003c btns.length; i++)\n\t\t{\n\t\t\tapplySortStyle(btns[i], i \u003d\u003d active);\n\t\t}\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Page bar\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel buildPageBar(JLabel label, JButton prev, JButton next)\n\t{\n\t\tJPanel bar \u003d new JPanel(new FlowLayout(FlowLayout.CENTER, 8, 4));\n\t\tbar.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tbar.setBorder(new MatteBorder(1, 0, 0, 0, new Color(0x3A3A3A)));\n\t\tbar.add(prev);\n\t\tbar.add(label);\n\t\tbar.add(next);\n\t\treturn bar;\n\t}\n\n\tprivate JLabel pageLabel()\n\t{\n\t\tJLabel l \u003d new JLabel(\"\");\n\t\tl.setFont(Fonts.SM);\n\t\tl.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\tl.setPreferredSize(new Dimension(40, 18));\n\t\tl.setHorizontalAlignment(SwingConstants.CENTER);\n\t\treturn l;\n\t}\n\n\tprivate JButton pageBtn(String sym)\n\t{\n\t\tJButton b \u003d pillButton(sym);\n\t\tb.setBackground(new Color(0x3E3E3E));\n\t\tb.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\tb.setEnabled(false);\n\t\tb.setPreferredSize(new Dimension(26, 22));\n\t\treturn b;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Tab assembly\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel assembleTab(JPanel topBar, JPanel list, JPanel pageBar)\n\t{\n\t\tListWrapperPanel wrapper \u003d new ListWrapperPanel(list);\n\t\twrapper.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tJScrollPane sp \u003d new JScrollPane(wrapper);\n\t\tsp.setBorder(BorderFactory.createEmptyBorder());\n\t\tsp.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tsp.getViewport().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tsp.getVerticalScrollBar().setPreferredSize(new Dimension(6, 0));\n\n\t\tJPanel tab \u003d new JPanel(new BorderLayout());\n\t\ttab.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\ttab.add(topBar,  BorderLayout.NORTH);\n\t\ttab.add(sp,      BorderLayout.CENTER);\n\t\ttab.add(pageBar, BorderLayout.SOUTH);\n\t\treturn tab;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Footer\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel buildFooter()\n\t{\n\t\tlastUpdatedLabel \u003d new JLabel(\" \");\n\t\tlastUpdatedLabel.setFont(Fonts.SM);\n\t\tlastUpdatedLabel.setForeground(new Color(0x555555));\n\t\tlastUpdatedLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\tlastUpdatedLabel.setBorder(new EmptyBorder(2, 0, 4, 0));\n\n\t\tJButton wb \u003d pillButton(\"07flip.com\");\n\t\tJButton db \u003d pillButton(\"Discord\");\n\t\twb.setBackground(ORANGE);\n\t\twb.setForeground(Color.BLACK);\n\t\tdb.setBackground(new Color(0x5865F2));\n\t\tdb.setForeground(Color.WHITE);\n\t\twb.addActionListener(e -\u003e openUrl(WEBSITE_URL));\n\t\tdb.addActionListener(e -\u003e openUrl(DISCORD_URL));\n\n\t\tJPanel btns \u003d new JPanel(new GridLayout(1, 2, 6, 0));\n\t\tbtns.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tbtns.setBorder(new EmptyBorder(6, 10, 4, 10));\n\t\tbtns.add(wb);\n\t\tbtns.add(db);\n\n\t\tJPanel footer \u003d new JPanel(new BorderLayout());\n\t\tfooter.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfooter.setBorder(new MatteBorder(1, 0, 0, 0, new Color(0x3A3A3A)));\n\t\tfooter.add(btns,             BorderLayout.CENTER);\n\t\tfooter.add(lastUpdatedLabel, BorderLayout.SOUTH);\n\t\treturn footer;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Micro helpers\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate JPanel listPanel()\n\t{\n\t\tJPanel p \u003d new JPanel();\n\t\tp.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));\n\t\tp.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\treturn p;\n\t}\n\n\tprivate Component sep()\n\t{\n\t\tJPanel s \u003d new JPanel();\n\t\ts.setBackground(new Color(0x333333));\n\t\ts.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));\n\t\ts.setPreferredSize(new Dimension(0, 1));\n\t\ts.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\treturn s;\n\t}\n\n\tprivate JPanel signInPrompt(int hiddenCount)\n\t{\n\t\tJPanel p \u003d new JPanel();\n\t\tp.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));\n\t\tp.setBackground(new Color(0x1E1E1E));\n\t\tp.setBorder(new EmptyBorder(10, 12, 10, 12));\n\t\tp.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tp.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));\n\n\t\tJLabel t \u003d new JLabel(\"+\" + hiddenCount + \" results hidden\");\n\t\tt.setFont(Fonts.SM_BOLD);\n\t\tt.setForeground(ORANGE);\n\t\tt.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel sub \u003d new JLabel(\"Add your API key in plugin settings\");\n\t\tsub.setFont(Fonts.SM);\n\t\tsub.setForeground(new Color(0x666666));\n\t\tsub.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tp.add(t);\n\t\tp.add(sub);\n\t\treturn p;\n\t}\n\n\tprivate JPanel emptyLabel(String title, String sub)\n\t{\n\t\tJPanel p \u003d new JPanel();\n\t\tp.setLayout(new BoxLayout(p, BoxLayout.Y_AXIS));\n\t\tp.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tp.setBorder(new EmptyBorder(20, 14, 20, 14));\n\t\tp.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel t \u003d new JLabel(title);\n\t\tt.setForeground(ColorScheme.LIGHT_GRAY_COLOR);\n\t\tt.setFont(Fonts.SM);\n\t\tp.add(t);\n\t\tif (!sub.isEmpty())\n\t\t{\n\t\t\tJLabel s \u003d new JLabel(sub);\n\t\t\ts.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);\n\t\t\ts.setFont(Fonts.SM);\n\t\t\ts.setBorder(new EmptyBorder(4, 0, 0, 0));\n\t\t\tp.add(s);\n\t\t}\n\t\treturn p;\n\t}\n\n\tprivate static JComboBox\u003cString\u003e styledCombo(String[] items)\n\t{\n\t\tJComboBox\u003cString\u003e cb \u003d new JComboBox\u003c\u003e(items);\n\t\tcb.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tcb.setForeground(Color.WHITE);\n\t\tcb.setFont(Fonts.SM);\n\t\treturn cb;\n\t}\n\n\tprivate void updateTimestamp()\n\t{\n\t\tjava.time.LocalTime now \u003d java.time.LocalTime.now();\n\t\tlastUpdatedLabel.setText(String.format(\"Updated %02d:%02d\", now.getHour(), now.getMinute()));\n\t}\n\n\tprivate void openUrl(String url)\n\t{\n\t\ttry\n\t\t{\n\t\t\tDesktop.getDesktop().browse(new URI(url));\n\t\t}\n\t\tcatch (Exception ignored)\n\t\t{\n\t\t}\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Scrollable list wrapper  anchors content to top, tracks viewport width\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate static class ListWrapperPanel extends JPanel implements Scrollable\n\t{\n\t\tListWrapperPanel(JPanel list)\n\t\t{\n\t\t\tsuper(new BorderLayout());\n\t\t\tadd(list, BorderLayout.NORTH);\n\t\t}\n\n\t\t@Override\n\t\tpublic Dimension getPreferredScrollableViewportSize()\n\t\t{\n\t\t\treturn getPreferredSize();\n\t\t}\n\n\t\t@Override\n\t\tpublic int getScrollableUnitIncrement(Rectangle r, int o, int d)\n\t\t{\n\t\t\treturn 16;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getScrollableBlockIncrement(Rectangle r, int o, int d)\n\t\t{\n\t\t\treturn 100;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean getScrollableTracksViewportWidth()\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean getScrollableTracksViewportHeight()\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/o7flip/O7FlipPanel.java"},{"fileName":"SearchResultPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.SearchResultItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class SearchResultPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color GREEN    \u003d new Color(0x00C27A);\n\tprivate static final Color RED      \u003d new Color(0xFF5555);\n\tprivate static final Color ORANGE   \u003d new Color(0xFF981F);\n\tprivate static final int   STALE    \u003d 30;   // minutes\n\n\tpublic SearchResultPanel(SearchResultItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(8, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(8, 10, 8, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(item.itemId, itemManager);\n\n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tboolean stale    \u003d item.dataAgeMinutes !\u003d null \u0026\u0026 item.dataAgeMinutes \u003e STALE;\n\t\tboolean hasPrice \u003d item.buyPrice !\u003d null \u0026\u0026 item.sellPrice !\u003d null;\n\n\t\tJLabel priceLabel;\n\t\tif (!hasPrice)\n\t\t{\n\t\t\tpriceLabel \u003d new JLabel(\"No recent price data\");\n\t\t\tpriceLabel.setFont(Fonts.SM);\n\t\t\tpriceLabel.setForeground(new Color(0x555555));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tString buyColor  \u003d stale ? \"#666666\" : \"#FF7070\";\n\t\t\tString sellColor \u003d stale ? \"#666666\" : \"#00C27A\";\n\t\t\tpriceLabel \u003d new JLabel(\n\t\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027\" + buyColor  + \"\u0027\u003e\" + FlipItemPanel.formatGp(item.buyPrice)  + \"\u003c/font\u003e\"\n\t\t\t\t+ \"\u003cfont color\u003d\u0027#555555\u0027\u003e \\u2192 \u003c/font\u003e\"\n\t\t\t\t+ \"\u003cfont color\u003d\u0027\" + sellColor + \"\u0027\u003e\" + FlipItemPanel.formatGp(item.sellPrice) + \"\u003c/font\u003e\u003c/html\u003e\");\n\t\t\tpriceLabel.setFont(Fonts.SM);\n\t\t}\n\t\tpriceLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel profitLabel \u003d new JLabel(\"\");\n\t\tif (item.profit !\u003d null \u0026\u0026 hasPrice)\n\t\t{\n\t\t\tString sign   \u003d item.profit \u003e\u003d 0 ? \"+\" : \"\";\n\t\t\tColor  fg     \u003d item.profit \u003e\u003d 0 ? GREEN : RED;\n\t\t\tString roiStr \u003d item.roi !\u003d null ? \"  (\" + String.format(\"%.1f\", item.roi) + \"% ROI)\" : \"\";\n\t\t\tprofitLabel \u003d new JLabel(sign + FlipItemPanel.formatGp(item.profit) + roiStr);\n\t\t\tprofitLabel.setFont(Fonts.SM);\n\t\t\tprofitLabel.setForeground(fg);\n\t\t}\n\t\tprofitLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJLabel volLabel \u003d new JLabel(\"\");\n\t\tif (item.hourlyVolume !\u003d null \u0026\u0026 item.hourlyVolume \u003e 0)\n\t\t{\n\t\t\tvolLabel \u003d new JLabel(FlipItemPanel.formatGp(item.hourlyVolume) + \"/hr\");\n\t\t\tvolLabel.setFont(Fonts.SM);\n\t\t\tvolLabel.setForeground(new Color(0x666666));\n\t\t}\n\t\tvolLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJPanel textPanel \u003d new JPanel();\n\t\ttextPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n\t\ttextPanel.setBackground(bg);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(2));\n\t\ttextPanel.add(priceLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(2));\n\t\ttextPanel.add(profitLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(2));\n\t\ttextPanel.add(volLabel);\n\n\t\tString ageText  \u003d formatAge(item.dataAgeMinutes);\n\t\tColor  ageColor \u003d item.dataAgeMinutes \u003d\u003d null ? new Color(0x666666)\n\t\t\t: item.dataAgeMinutes \u003e STALE ? ORANGE : GREEN;\n\t\tJLabel ageBadge \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003ccenter\u003e\u003cb\u003e\" + ageText + \"\u003c/b\u003e\u003cbr\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eago\u003c/font\u003e\u003c/center\u003e\u003c/html\u003e\");\n\t\tageBadge.setFont(Fonts.SM);\n\t\tageBadge.setForeground(ageColor);\n\t\tageBadge.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\tageBadge.setPreferredSize(new Dimension(40, 0));\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\t\tadd(ageBadge,  BorderLayout.EAST);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n\n\tprivate static String formatAge(Integer minutes)\n\t{\n\t\tif (minutes \u003d\u003d null)\n\t\t{\n\t\t\treturn \"?\";\n\t\t}\n\t\tif (minutes \u003c 60)\n\t\t{\n\t\t\treturn minutes + \"m\";\n\t\t}\n\t\treturn (minutes / 60) + \"h\";\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/SearchResultPanel.java"},{"fileName":"BarrowsSetPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.BarrowsSet;\nimport com.o7flip.util.Fonts;\nimport com.o7flip.util.ItemIds;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class BarrowsSetPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color GREEN    \u003d new Color(0x00C27A);\n\tprivate static final Color RED      \u003d new Color(0xFF5555);\n\n\tpublic BarrowsSetPanel(BarrowsSet set, ItemManager itemManager, boolean odd, Runnable onDrillDown)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(8, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(10, 10, 10, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tint iconId \u003d set.iconItemId \u003e 0 ? set.iconItemId : ItemIds.forBarrows(set.shortName);\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(iconId, itemManager);\n\n\t\t//  Text panel (Y_AXIS) \n\t\tJPanel textPanel \u003d new JPanel();\n\t\ttextPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n\t\ttextPanel.setBackground(bg);\n\n\t\tJLabel nameLabel \u003d new JLabel(set.shortName);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\tJLabel buyLbl \u003d new JLabel(\"Buy: \" + FlipItemPanel.formatGp(set.totalBrokenCost));\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setForeground(new Color(0xFF7070));\n\t\tbuyLbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(buyLbl);\n\t\ttextPanel.add(Box.createVerticalStrut(2));\n\n\t\tJLabel repairLbl \u003d new JLabel(\"Repair: \" + FlipItemPanel.formatGp(set.totalPohRepairCost));\n\t\trepairLbl.setFont(Fonts.SM);\n\t\trepairLbl.setForeground(new Color(0x888888));\n\t\trepairLbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(repairLbl);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\tString stratText \u003d \"sell_set\".equals(set.bestStrategy) ? \"Sell as set\" : \"Sell individual\";\n\t\tString volText   \u003d set.dailyVolume \u003e 0 ? \"  \\u00B7  \" + set.dailyVolume + \"/day\" : \"\";\n\t\tJLabel stratLabel \u003d new JLabel(stratText + volText + \"  \\u203A\");\n\t\tstratLabel.setFont(Fonts.SM);\n\t\tstratLabel.setForeground(new Color(0xAAAAAA));\n\t\tstratLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(stratLabel);\n\n\t\t//  Right badge: best profit \n\t\tboolean profitable \u003d set.bestProfit \u003e 0;\n\t\tJLabel profitLabel \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003ccenter\u003e\u003cb\u003e\" + (profitable ? \"+\" : \"\") + FlipItemPanel.formatGp(set.bestProfit)\n\t\t\t+ \"\u003c/b\u003e\u003cbr\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eprofit\u003c/font\u003e\u003c/center\u003e\u003c/html\u003e\");\n\t\tprofitLabel.setFont(Fonts.SM);\n\t\tprofitLabel.setForeground(profitable ? GREEN : RED);\n\t\tprofitLabel.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\tprofitLabel.setPreferredSize(new Dimension(56, 0));\n\n\t\tadd(iconLabel,   BorderLayout.WEST);\n\t\tadd(textPanel,   BorderLayout.CENTER);\n\t\tadd(profitLabel, BorderLayout.EAST);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tif (onDrillDown !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tonDrillDown.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/BarrowsSetPanel.java"},{"fileName":"SpikeItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.SpikeItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class SpikeItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color GREEN    \u003d new Color(0x00C27A);\n\n\tpublic SpikeItemPanel(SpikeItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(6, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(13, 10, 13, 8));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\t//  Icon \n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(item.itemId, itemManager);\n\n\t\t//  Name \n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\n\t\t//  Prices \n\t\tJLabel buyLbl \u003d new JLabel(\"Buy: \" + FlipItemPanel.formatGp(item.buyPrice));\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setForeground(new Color(0xFF7070));\n\n\t\tJLabel avgLbl \u003d new JLabel(\"  24h avg: \" + FlipItemPanel.formatGp(item.avg24hBuy));\n\t\tavgLbl.setFont(Fonts.SM);\n\t\tavgLbl.setForeground(new Color(0x666666));\n\n\t\tJPanel priceRow \u003d new JPanel();\n\t\tpriceRow.setLayout(new BoxLayout(priceRow, BoxLayout.X_AXIS));\n\t\tpriceRow.setBackground(bg);\n\t\tpriceRow.add(buyLbl);\n\t\tpriceRow.add(avgLbl);\n\t\tpriceRow.add(Box.createHorizontalGlue());\n\n\t\t//  Volume \n\t\tString volStr   \u003d item.hourlyVolume \u003e 0 ? \"Vol: \" + FlipItemPanel.formatGp(item.hourlyVolume) + \"/hr\" : \"\";\n\t\tString limitStr \u003d item.buyLimit \u003e 0 ? (volStr.isEmpty() ? \"\" : \"  \") + \"Limit: \" + FlipItemPanel.formatGp(item.buyLimit) : \"\";\n\t\tJLabel volLabel \u003d new JLabel(volStr + limitStr);\n\t\tvolLabel.setFont(Fonts.SM);\n\t\tvolLabel.setForeground(new Color(0x888888));\n\n\t\tJPanel textPanel \u003d new JPanel(new GridLayout(3, 1, 0, 6));\n\t\ttextPanel.setBackground(bg);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(priceRow);\n\t\ttextPanel.add(volLabel);\n\n\t\t//  Spike badge \n\t\tJLabel spikeBadge \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003ccenter\u003e\u003cb\u003e\u003cfont color\u003d\u0027#00C27A\u0027\u003e+\"\n\t\t\t+ String.format(\"%.1f%%\", item.spikePct)\n\t\t\t+ \"\u003c/font\u003e\u003c/b\u003e\u003cbr\u003e\u003cfont color\u003d\u0027#888888\u0027\u003espike\u003c/font\u003e\u003c/center\u003e\u003c/html\u003e\");\n\t\tspikeBadge.setFont(Fonts.SM);\n\t\tspikeBadge.setForeground(GREEN);\n\t\tspikeBadge.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\tspikeBadge.setPreferredSize(new Dimension(52, 0));\n\n\t\tadd(iconLabel,  BorderLayout.WEST);\n\t\tadd(textPanel,  BorderLayout.CENTER);\n\t\tadd(spikeBadge, BorderLayout.EAST);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t\tpriceRow.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t\tpriceRow.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/SpikeItemPanel.java"},{"fileName":"DecantItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.DecantItem;\nimport com.o7flip.util.Fonts;\nimport com.o7flip.util.ItemIds;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class DecantItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color ORANGE   \u003d new Color(0xFF981F);\n\n\tpublic DecantItemPanel(DecantItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(8, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(8, 10, 8, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tint dose   \u003d item.buyDose \u003e 0 ? item.buyDose : 4;\n\t\tint iconId \u003d ItemIds.forPotion(item.potionName, dose);\n\t\tif (iconId \u003d\u003d 0 \u0026\u0026 item.itemId \u003e 0)\n\t\t{\n\t\t\ticonId \u003d item.itemId;\n\t\t}\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(iconId, itemManager);\n\n\t\tJLabel nameLabel \u003d new JLabel(item.potionName);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tString buyText \u003d item.buyDose \u003e 0 ? \"Buy \" + item.buyDose + \"-dose\" : item.strategy;\n\t\tJLabel buyLabel \u003d new JLabel(buyText);\n\t\tbuyLabel.setFont(Fonts.SM);\n\t\tbuyLabel.setForeground(new Color(0xFF7070));\n\t\tbuyLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tString sellText \u003d item.sellDose \u003e 0 ? \"Sell \" + item.sellDose + \"-dose\" : \"\";\n\t\tJLabel sellLabel \u003d new JLabel(sellText);\n\t\tsellLabel.setFont(Fonts.SM);\n\t\tsellLabel.setForeground(new Color(0x00C27A));\n\t\tsellLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tJPanel textPanel \u003d new JPanel();\n\t\ttextPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n\t\ttextPanel.setBackground(bg);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\t\ttextPanel.add(buyLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\t\ttextPanel.add(sellLabel);\n\n\t\tJLabel roiLabel \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003ccenter\u003e\u003cb\u003e\" + String.format(\"%.1f\", item.roiPct) + \"%\u003c/b\u003e\"\n\t\t\t+ \"\u003cbr\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eROI\u003c/font\u003e\u003c/center\u003e\u003c/html\u003e\");\n\t\troiLabel.setFont(Fonts.SM);\n\t\troiLabel.setForeground(ORANGE);\n\t\troiLabel.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\troiLabel.setPreferredSize(new Dimension(48, 0));\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\t\tadd(roiLabel,  BorderLayout.EAST);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/DecantItemPanel.java"},{"fileName":"MoonSetPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.MoonItem;\nimport com.o7flip.model.MoonSet;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.CompoundBorder;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.border.MatteBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class MoonSetPanel extends JPanel\n{\n\tprivate static final Color BLOOD_BG    \u003d new Color(0x231212);\n\tprivate static final Color BLOOD_ACC   \u003d new Color(0x5C2A2A);\n\tprivate static final Color BLUE_BG     \u003d new Color(0x0C1624);\n\tprivate static final Color BLUE_ACC    \u003d new Color(0x1E3E60);\n\tprivate static final Color ECLIPSE_BG  \u003d new Color(0x1C1808);\n\tprivate static final Color ECLIPSE_ACC \u003d new Color(0x524418);\n\n\tprivate static final Color GREEN  \u003d new Color(0x00C27A);\n\tprivate static final Color ORANGE \u003d new Color(0xFF981F);\n\tprivate static final Color WHITE  \u003d Color.WHITE;\n\n\tpublic MoonSetPanel(MoonSet set, ItemManager itemManager, boolean ignored)\n\t{\n\t\tColor bg  \u003d bgFor(set.setName);\n\t\tColor acc \u003d accFor(set.setName);\n\n\t\tsetLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n\t\tsetBackground(bg);\n\t\tsetBorder(new CompoundBorder(\n\t\t\tnew MatteBorder(0, 3, 0, 0, acc),\n\t\t\tnew EmptyBorder(8, 10, 20, 10)));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tadd(buildHeader(set, itemManager, bg, acc));\n\t\tadd(Box.createVerticalStrut(6));\n\n\t\tboolean sellSet \u003d \"sell_set\".equals(set.bestStrategy);\n\t\tJLabel bestLine \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eBest profit: \u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#00C27A\u0027\u003e\u003cb\u003e+\" + FlipItemPanel.formatGp(set.bestProfit) + \" gp\u003c/b\u003e\u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#555555\u0027\u003e  (\" + (sellSet ? \"sell as set\" : \"sell individual\") + \")\u003c/font\u003e\u003c/html\u003e\");\n\t\tbestLine.setFont(Fonts.SM);\n\t\tbestLine.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tadd(bestLine);\n\t\tadd(Box.createVerticalStrut(8));\n\n\t\tadd(divider(acc));\n\t\tadd(Box.createVerticalStrut(6));\n\n\t\tJLabel piecesHdr \u003d new JLabel(\"PIECES\");\n\t\tpiecesHdr.setFont(Fonts.SM);\n\t\tpiecesHdr.setForeground(new Color(0x777777));\n\t\tpiecesHdr.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tadd(piecesHdr);\n\t\tadd(Box.createVerticalStrut(4));\n\n\t\tfor (MoonItem item : set.items)\n\t\t{\n\t\t\tadd(buildItemRow(item, itemManager, bg));\n\t\t\tadd(Box.createVerticalStrut(6));\n\t\t}\n\n\t\tadd(divider(acc));\n\t\tadd(Box.createVerticalStrut(6));\n\n\t\tlong weaponCost \u003d 0;\n\t\tfor (MoonItem mi : set.items)\n\t\t{\n\t\t\tif (mi.itemIdBroken \u003d\u003d 0)\n\t\t\t{\n\t\t\t\tweaponCost \u003d mi.brokenBuyPrice;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tadd(buildTotals(set, weaponCost));\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n\n\tprivate JPanel buildHeader(MoonSet set, ItemManager itemManager, Color bg, Color acc)\n\t{\n\t\tJPanel header \u003d new JPanel(new BorderLayout(8, 0));\n\t\theader.setBackground(bg);\n\t\theader.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\theader.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));\n\n\t\tJLabel icon \u003d FlipItemPanel.buildIcon(set.iconItemId, itemManager);\n\t\theader.add(icon, BorderLayout.WEST);\n\n\t\tJPanel namePanel \u003d new JPanel(new GridLayout(2, 1, 0, 1));\n\t\tnamePanel.setBackground(bg);\n\t\tJLabel nameLabel \u003d new JLabel(set.setName);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(WHITE);\n\t\tJLabel styleLabel \u003d new JLabel(set.combatStyle);\n\t\tstyleLabel.setFont(Fonts.SM);\n\t\tstyleLabel.setForeground(new Color(0x888888));\n\t\tnamePanel.add(nameLabel);\n\t\tnamePanel.add(styleLabel);\n\t\theader.add(namePanel, BorderLayout.CENTER);\n\n\t\tboolean isSellSet \u003d \"sell_set\".equals(set.bestStrategy);\n\t\tJLabel badge \u003d new JLabel(isSellSet ? \"SELL AS SET\" : \"SELL PIECES\");\n\t\tbadge.setFont(Fonts.SM);\n\t\tbadge.setForeground(WHITE);\n\t\tbadge.setOpaque(true);\n\t\tbadge.setBackground(isSellSet ? ORANGE : GREEN);\n\t\tbadge.setBorder(new EmptyBorder(2, 6, 2, 6));\n\t\theader.add(badge, BorderLayout.EAST);\n\n\t\treturn header;\n\t}\n\n\tprivate JPanel buildItemRow(MoonItem item, ItemManager itemManager, Color bg)\n\t{\n\t\tboolean isWeapon \u003d item.itemIdBroken \u003d\u003d 0;\n\n\t\tJPanel row \u003d new JPanel(new BorderLayout(6, 0));\n\t\trow.setBackground(bg);\n\t\trow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tint iconId \u003d isWeapon ? item.itemIdRepaired : item.itemIdBroken;\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(iconId, itemManager);\n\t\ticonLabel.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\ticonLabel.addMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemIdRepaired);\n\t\t\t}\n\t\t});\n\t\trow.add(iconLabel, BorderLayout.WEST);\n\n\t\tJPanel text \u003d new JPanel();\n\t\ttext.setLayout(new BoxLayout(text, BoxLayout.Y_AXIS));\n\t\ttext.setBackground(bg);\n\t\ttext.setBorder(new EmptyBorder(0, 0, 6, 0));\n\n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttext.add(nameLabel);\n\t\ttext.add(Box.createVerticalStrut(2));\n\n\t\tJLabel buyLbl \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#FF7070\u0027\u003eBuy: \" + FlipItemPanel.formatGp(item.brokenBuyPrice) + \"\u003c/font\u003e\u003c/html\u003e\");\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttext.add(buyLbl);\n\t\ttext.add(Box.createVerticalStrut(2));\n\n\t\tJLabel repairLabel;\n\t\tif (item.npcRepairCost \u003e 0 || item.pohRepairCost \u003e 0)\n\t\t{\n\t\t\trepairLabel \u003d new JLabel(\n\t\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eNPC: \u003c/font\u003e\" + FlipItemPanel.formatGp(item.npcRepairCost)\n\t\t\t\t+ \"  \u003cfont color\u003d\u0027#888888\u0027\u003ePOH: \u003c/font\u003e\" + FlipItemPanel.formatGp(item.pohRepairCost) + \"\u003c/html\u003e\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\trepairLabel \u003d new JLabel(\"\u003chtml\u003e\u003cfont color\u003d\u0027#555555\u0027\u003eNo repair needed\u003c/font\u003e\u003c/html\u003e\");\n\t\t}\n\t\trepairLabel.setFont(Fonts.SM);\n\t\trepairLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttext.add(repairLabel);\n\t\ttext.add(Box.createVerticalStrut(2));\n\n\t\tJLabel sellLbl \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eSell: \u003c/font\u003e\" + FlipItemPanel.formatGp(item.repairedAfterTax)\n\t\t\t+ \"\u003cfont color\u003d\u0027#555555\u0027\u003e  (after 2% tax)\u003c/font\u003e\u003c/html\u003e\");\n\t\tsellLbl.setFont(Fonts.SM);\n\t\tsellLbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttext.add(sellLbl);\n\t\ttext.add(Box.createVerticalStrut(2));\n\n\t\tString profitColor \u003d item.pohProfit \u003e\u003d 0 ? \"#00C27A\" : \"#FF5555\";\n\t\tString profitSign  \u003d item.pohProfit \u003e\u003d 0 ? \"+\" : \"\";\n\t\tString profitLabel \u003d isWeapon ? \"Profit: \" : \"Profit (POH): \";\n\t\tJLabel profitLbl \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003e\" + profitLabel + \"\u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027\" + profitColor + \"\u0027\u003e\" + profitSign + FlipItemPanel.formatGp(item.pohProfit) + \"\u003c/font\u003e\u003c/html\u003e\");\n\t\tprofitLbl.setFont(Fonts.SM);\n\t\tprofitLbl.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttext.add(profitLbl);\n\n\t\trow.add(text, BorderLayout.CENTER);\n\t\trow.setMaximumSize(new Dimension(Integer.MAX_VALUE, row.getPreferredSize().height));\n\t\treturn row;\n\t}\n\n\tprivate JPanel buildTotals(MoonSet set, long weaponCost)\n\t{\n\t\tColor bg \u003d bgFor(set.setName);\n\t\tboolean hasSellSet \u003d \"sell_set\".equals(set.bestStrategy) \u0026\u0026 set.setProfit \u003e 0;\n\n\t\tJPanel panel \u003d new JPanel();\n\t\tpanel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));\n\t\tpanel.setBackground(bg);\n\t\tpanel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tpanel.add(totalsRow(bg,\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eArmour buy: \u003c/font\u003e\u003cfont color\u003d\u0027#FF7070\u0027\u003e\" + FlipItemPanel.formatGp(set.totalBrokenCost) + \"\u003c/font\u003e\u003c/html\u003e\",\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eNPC repair: \u003c/font\u003e\" + FlipItemPanel.formatGp(set.totalNpcRepairCost) + \"\u003c/html\u003e\"));\n\t\tpanel.add(Box.createVerticalStrut(4));\n\n\t\tpanel.add(totalsRow(bg,\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eNPC profit: \u003c/font\u003e\u003cfont color\u003d\u0027#00C27A\u0027\u003e+\" + FlipItemPanel.formatGp(set.npcProfit) + \"\u003c/font\u003e\u003c/html\u003e\",\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003ePOH repair: \u003c/font\u003e\" + FlipItemPanel.formatGp(set.totalPohRepairCost) + \"\u003c/html\u003e\"));\n\t\tpanel.add(Box.createVerticalStrut(4));\n\n\t\tString weaponHtml \u003d weaponCost \u003e 0\n\t\t\t? \"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eWeapon buy: \u003c/font\u003e\u003cfont color\u003d\u0027#FF7070\u0027\u003e\" + FlipItemPanel.formatGp(weaponCost) + \"\u003c/font\u003e\u003c/html\u003e\"\n\t\t\t: \"\";\n\t\tpanel.add(totalsRow(bg,\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003ePOH profit: \u003c/font\u003e\u003cfont color\u003d\u0027#00C27A\u0027\u003e+\" + FlipItemPanel.formatGp(set.pohProfit) + \"\u003c/font\u003e\u003c/html\u003e\",\n\t\t\tweaponHtml));\n\t\tpanel.add(Box.createVerticalStrut(10));\n\n\t\tif (hasSellSet)\n\t\t{\n\t\t\tpanel.add(totalsRow(bg,\n\t\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#888888\u0027\u003eSet profit: \u003c/font\u003e\u003cfont color\u003d\u0027#FF981F\u0027\u003e\u003cb\u003e+\" + FlipItemPanel.formatGp(set.setProfit) + \"\u003c/b\u003e\u003c/font\u003e\u003c/html\u003e\",\n\t\t\t\t\"\"));\n\t\t}\n\n\t\treturn panel;\n\t}\n\n\tprivate static JPanel totalsRow(Color bg, String leftHtml, String rightHtml)\n\t{\n\t\tJPanel row \u003d new JPanel(new GridLayout(1, 2, 8, 0));\n\t\trow.setBackground(bg);\n\t\trow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\trow.add(cell(leftHtml));\n\t\trow.add(cell(rightHtml.isEmpty() ? \" \" : rightHtml));\n\t\treturn row;\n\t}\n\n\tprivate static JLabel cell(String html)\n\t{\n\t\tJLabel l \u003d new JLabel(html);\n\t\tl.setFont(Fonts.SM);\n\t\treturn l;\n\t}\n\n\tprivate static Color bgFor(String name)\n\t{\n\t\tif (name \u003d\u003d null)\n\t\t{\n\t\t\treturn ColorScheme.DARK_GRAY_COLOR;\n\t\t}\n\t\tif (name.contains(\"Blood\"))\n\t\t{\n\t\t\treturn BLOOD_BG;\n\t\t}\n\t\tif (name.contains(\"Blue\"))\n\t\t{\n\t\t\treturn BLUE_BG;\n\t\t}\n\t\tif (name.contains(\"Eclipse\"))\n\t\t{\n\t\t\treturn ECLIPSE_BG;\n\t\t}\n\t\treturn ColorScheme.DARK_GRAY_COLOR;\n\t}\n\n\tprivate static Color accFor(String name)\n\t{\n\t\tif (name \u003d\u003d null)\n\t\t{\n\t\t\treturn new Color(0x4A4A4A);\n\t\t}\n\t\tif (name.contains(\"Blood\"))\n\t\t{\n\t\t\treturn BLOOD_ACC;\n\t\t}\n\t\tif (name.contains(\"Blue\"))\n\t\t{\n\t\t\treturn BLUE_ACC;\n\t\t}\n\t\tif (name.contains(\"Eclipse\"))\n\t\t{\n\t\t\treturn ECLIPSE_ACC;\n\t\t}\n\t\treturn new Color(0x4A4A4A);\n\t}\n\n\tprivate static Component divider(Color color)\n\t{\n\t\tJPanel line \u003d new JPanel();\n\t\tline.setBackground(color);\n\t\tline.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));\n\t\tline.setPreferredSize(new Dimension(0, 1));\n\t\tline.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\treturn line;\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/MoonSetPanel.java"},{"fileName":"FlipItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.FlipItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.util.AsyncBufferedImage;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.net.URI;\n\npublic class FlipItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color GREEN    \u003d new Color(0x00C27A);\n\n\tpublic FlipItemPanel(FlipItem flip, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(8, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(8, 10, 8, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\t//  ICON \n\t\tJLabel iconLabel \u003d buildIcon(flip.itemId, itemManager);\n\n\t\t//  NAME \n\t\tJLabel nameLabel \u003d new JLabel(flip.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\n\t\t//  PRICE: buy (red)  sell (green) \n\t\tJLabel priceLabel \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003cfont color\u003d\u0027#FF7070\u0027\u003e\" + formatGp(flip.buyPrice) + \"\u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#666666\u0027\u003e \\u2192 \u003c/font\u003e\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#00C27A\u0027\u003e\" + formatGp(flip.sellPrice) + \"\u003c/font\u003e\u003c/html\u003e\");\n\t\tpriceLabel.setFont(Fonts.SM);\n\n\t\t//  PROFIT + ROI \n\t\tString limitText \u003d flip.buyLimit \u003e 0 ? \"  \\u00B7  Limit \" + flip.buyLimit : \"\";\n\t\tJLabel profitLabel \u003d new JLabel(\n\t\t\t\"+\" + formatGp(flip.profit) + \"  (\" + String.format(\"%.1f\", flip.roiPct) + \"% ROI)\" + limitText);\n\t\tprofitLabel.setFont(Fonts.SM);\n\t\tprofitLabel.setForeground(GREEN);\n\n\t\tJPanel textPanel \u003d new JPanel(new GridLayout(3, 1, 0, 2));\n\t\ttextPanel.setBackground(bg);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(priceLabel);\n\t\ttextPanel.add(profitLabel);\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\topenUrl(\"https://07flip.com/item/\" + flip.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Static helpers shared by all item panels\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tstatic JLabel buildIcon(int itemId, ItemManager itemManager)\n\t{\n\t\tJLabel lbl \u003d new JLabel();\n\t\tlbl.setPreferredSize(new Dimension(32, 32));\n\t\tlbl.setHorizontalAlignment(SwingConstants.CENTER);\n\t\tif (itemManager !\u003d null \u0026\u0026 itemId \u003e 0)\n\t\t{\n\t\t\tAsyncBufferedImage img \u003d itemManager.getImage(itemId);\n\t\t\timg.addTo(lbl);\n\t\t}\n\t\treturn lbl;\n\t}\n\n\tpublic static String formatGp(long amount)\n\t{\n\t\tif (amount \u003e\u003d 1_000_000_000)\n\t\t{\n\t\t\treturn String.format(\"%.1fB\", amount / 1_000_000_000.0);\n\t\t}\n\t\tif (amount \u003e\u003d 1_000_000)\n\t\t{\n\t\t\treturn String.format(\"%.1fM\", amount / 1_000_000.0);\n\t\t}\n\t\treturn String.format(\"%,d\", amount);\n\t}\n\n\tstatic void openUrl(String url)\n\t{\n\t\ttry\n\t\t{\n\t\t\tjava.awt.Desktop.getDesktop().browse(new URI(url));\n\t\t}\n\t\tcatch (Exception ignored)\n\t\t{\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/FlipItemPanel.java"},{"fileName":"DumpItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.DumpItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class DumpItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color HIGH     \u003d new Color(0xFF4444);  // score \u003e\u003d 70\n\tprivate static final Color MID      \u003d new Color(0xFFAA00);  // score \u003e\u003d 30\n\tprivate static final Color LOW      \u003d new Color(0x888888);  // score \u003c 30\n\n\tpublic DumpItemPanel(DumpItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(6, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(10, 10, 10, 8));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\t//  Icon \n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(item.itemId, itemManager);\n\n\t\t//  Text panel (Y_AXIS) \n\t\tJPanel textPanel \u003d new JPanel();\n\t\ttextPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n\t\ttextPanel.setBackground(bg);\n\n\t\t// Row 1: Name\n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\t// Row 2: Buy price (red)  Profit (green)\n\t\tJLabel buyLbl \u003d new JLabel(\"Buy: \" + FlipItemPanel.formatGp(item.buyPrice));\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setForeground(new Color(0xFF7070));\n\n\t\tJLabel profitLbl \u003d new JLabel(\"  \\u00B7  +\" + FlipItemPanel.formatGp(item.profit) + \" profit\");\n\t\tprofitLbl.setFont(Fonts.SM);\n\t\tprofitLbl.setForeground(new Color(0x00C27A));\n\n\t\tJPanel buyRow \u003d new JPanel();\n\t\tbuyRow.setLayout(new BoxLayout(buyRow, BoxLayout.X_AXIS));\n\t\tbuyRow.setBackground(bg);\n\t\tbuyRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tbuyRow.add(buyLbl);\n\t\tbuyRow.add(profitLbl);\n\t\tbuyRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(buyRow);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\t// Row 3: Score  Next dump  Volume\n\t\tColor scoreColor \u003d item.dumpScore \u003e\u003d 70 ? HIGH : item.dumpScore \u003e\u003d 30 ? MID : LOW;\n\n\t\tJLabel scoreHdrLbl \u003d new JLabel(\"Score: \");\n\t\tscoreHdrLbl.setFont(Fonts.SM);\n\t\tscoreHdrLbl.setForeground(new Color(0x666666));\n\n\t\tJLabel scoreValLbl \u003d new JLabel(String.valueOf(item.dumpScore));\n\t\tscoreValLbl.setFont(Fonts.SM);\n\t\tscoreValLbl.setForeground(scoreColor);\n\n\t\tString nextStr \u003d item.nextDumpHours !\u003d null ? \"  \\u00B7  Next: \" + formatNext(item.nextDumpHours) : \"\";\n\t\tJLabel nextLbl \u003d new JLabel(nextStr);\n\t\tnextLbl.setFont(Fonts.SM);\n\t\tnextLbl.setForeground(new Color(0x666666));\n\n\t\tString volStr \u003d item.hourlyVolume \u003e 0 ? \"  \\u00B7  \" + FlipItemPanel.formatGp(item.hourlyVolume) + \"/hr\" : \"\";\n\t\tJLabel volLbl \u003d new JLabel(volStr);\n\t\tvolLbl.setFont(Fonts.SM);\n\t\tvolLbl.setForeground(new Color(0x666666));\n\n\t\tJPanel scoreRow \u003d new JPanel();\n\t\tscoreRow.setLayout(new BoxLayout(scoreRow, BoxLayout.X_AXIS));\n\t\tscoreRow.setBackground(bg);\n\t\tscoreRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tscoreRow.add(scoreHdrLbl);\n\t\tscoreRow.add(scoreValLbl);\n\t\tscoreRow.add(nextLbl);\n\t\tscoreRow.add(volLbl);\n\t\tscoreRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(scoreRow);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\t// Row 4: Status  Last dump time\n\t\tString lastStr \u003d item.lastDumpHoursAgo !\u003d null\n\t\t\t? formatAgo(item.lastDumpHoursAgo) + \" ago\"\n\t\t\t: \"unknown\";\n\n\t\tJLabel statusLbl \u003d new JLabel(formatStatus(item.dumpStatus));\n\t\tstatusLbl.setFont(Fonts.SM);\n\t\tstatusLbl.setForeground(statusColor(item.dumpStatus));\n\n\t\tJLabel lastLbl \u003d new JLabel(\"  \\u00B7  \" + lastStr);\n\t\tlastLbl.setFont(Fonts.SM);\n\t\tlastLbl.setForeground(new Color(0x666666));\n\n\t\tJPanel statusRow \u003d new JPanel();\n\t\tstatusRow.setLayout(new BoxLayout(statusRow, BoxLayout.X_AXIS));\n\t\tstatusRow.setBackground(bg);\n\t\tstatusRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tstatusRow.add(statusLbl);\n\t\tstatusRow.add(lastLbl);\n\t\tstatusRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(statusRow);\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t\tbuyRow.setBackground(HOVER_BG);\n\t\t\t\tscoreRow.setBackground(HOVER_BG);\n\t\t\t\tstatusRow.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t\tbuyRow.setBackground(bg);\n\t\t\t\tscoreRow.setBackground(bg);\n\t\t\t\tstatusRow.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n\n\tprivate static String formatStatus(String status)\n\t{\n\t\tif (status \u003d\u003d null)\n\t\t{\n\t\t\treturn \"Pattern\";\n\t\t}\n\t\tswitch (status)\n\t\t{\n\t\t\tcase \"dumping\":  return \"Dumping now\";\n\t\t\tcase \"due_soon\": return \"Due soon\";\n\t\t\tcase \"pattern\":  return \"Pattern\";\n\t\t\tdefault:         return \"Watching\";\n\t\t}\n\t}\n\n\tprivate static Color statusColor(String status)\n\t{\n\t\tif (status \u003d\u003d null)\n\t\t{\n\t\t\treturn new Color(0x888888);\n\t\t}\n\t\tswitch (status)\n\t\t{\n\t\t\tcase \"dumping\":  return new Color(0xFF5555);\n\t\t\tcase \"due_soon\": return new Color(0xFF981F);\n\t\t\tcase \"pattern\":  return new Color(0x888888);\n\t\t\tdefault:         return new Color(0x666666);\n\t\t}\n\t}\n\n\tprivate static String formatAgo(double hours)\n\t{\n\t\tif (hours \u003c 2.0)\n\t\t{\n\t\t\treturn (int) Math.round(hours * 60) + \" min\";\n\t\t}\n\t\tif (hours \u003c 24.0)\n\t\t{\n\t\t\treturn String.format(\"%.1fh\", hours);\n\t\t}\n\t\treturn String.format(\"%.1fd\", hours / 24.0);\n\t}\n\n\tprivate static String formatNext(double hours)\n\t{\n\t\tif (hours \u003c 2.0)\n\t\t{\n\t\t\treturn (int) Math.round(hours * 60) + \"m\";\n\t\t}\n\t\tif (hours \u003c 24.0)\n\t\t{\n\t\t\treturn String.format(\"%.1fh\", hours);\n\t\t}\n\t\treturn String.format(\"%.1fd\", hours / 24.0);\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/DumpItemPanel.java"},{"fileName":"BarrowsItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.BarrowsItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class BarrowsItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\n\tpublic BarrowsItemPanel(BarrowsItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(6, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(10, 10, 10, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\tint iconId \u003d item.itemIdBroken \u003e 0 ? item.itemIdBroken : item.itemIdRepaired;\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(iconId, itemManager);\n\n\t\tJPanel textPanel \u003d new JPanel();\n\t\ttextPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));\n\t\ttextPanel.setBackground(bg);\n\n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\t\tnameLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(Box.createVerticalStrut(4));\n\n\t\tJLabel buyLbl  \u003d new JLabel(\"Buy: \" + FlipItemPanel.formatGp(item.brokenBuyPrice));\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setForeground(new Color(0xFF7070));\n\n\t\tJLabel sellLbl \u003d new JLabel(\"  \\u2192  Sell: \" + FlipItemPanel.formatGp(item.repairedAfterTax));\n\t\tsellLbl.setFont(Fonts.SM);\n\t\tsellLbl.setForeground(new Color(0x00C27A));\n\n\t\tJPanel buySellRow \u003d new JPanel();\n\t\tbuySellRow.setLayout(new BoxLayout(buySellRow, BoxLayout.X_AXIS));\n\t\tbuySellRow.setBackground(bg);\n\t\tbuySellRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tbuySellRow.add(buyLbl);\n\t\tbuySellRow.add(sellLbl);\n\t\tbuySellRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(buySellRow);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\tJLabel npcRprLbl \u003d new JLabel(\"NPC: \" + FlipItemPanel.formatGp(item.npcRepairCost));\n\t\tnpcRprLbl.setFont(Fonts.SM);\n\t\tnpcRprLbl.setForeground(new Color(0x888888));\n\n\t\tJLabel pohRprLbl \u003d new JLabel(\"  \\u00B7  POH: \" + FlipItemPanel.formatGp(item.pohRepairCost));\n\t\tpohRprLbl.setFont(Fonts.SM);\n\t\tpohRprLbl.setForeground(new Color(0x888888));\n\n\t\tJPanel repairRow \u003d new JPanel();\n\t\trepairRow.setLayout(new BoxLayout(repairRow, BoxLayout.X_AXIS));\n\t\trepairRow.setBackground(bg);\n\t\trepairRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\trepairRow.add(npcRprLbl);\n\t\trepairRow.add(pohRprLbl);\n\t\trepairRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(repairRow);\n\t\ttextPanel.add(Box.createVerticalStrut(3));\n\n\t\tString npcSign \u003d item.npcProfit \u003e\u003d 0 ? \"+\" : \"\";\n\t\tString pohSign \u003d item.pohProfit \u003e\u003d 0 ? \"+\" : \"\";\n\t\tColor  npcCol  \u003d item.npcProfit \u003e\u003d 0 ? new Color(0x00C27A) : new Color(0xFF5555);\n\t\tColor  pohCol  \u003d item.pohProfit \u003e\u003d 0 ? new Color(0x00C27A) : new Color(0xFF5555);\n\n\t\tJLabel profHdrLbl \u003d new JLabel(\"Profit: \");\n\t\tprofHdrLbl.setFont(Fonts.SM);\n\t\tprofHdrLbl.setForeground(new Color(0x888888));\n\n\t\tJLabel npcProfLbl \u003d new JLabel(\"NPC \" + npcSign + FlipItemPanel.formatGp(item.npcProfit));\n\t\tnpcProfLbl.setFont(Fonts.SM);\n\t\tnpcProfLbl.setForeground(npcCol);\n\n\t\tJLabel pohProfLbl \u003d new JLabel(\"  \\u00B7  POH \" + pohSign + FlipItemPanel.formatGp(item.pohProfit));\n\t\tpohProfLbl.setFont(Fonts.SM);\n\t\tpohProfLbl.setForeground(pohCol);\n\n\t\tJPanel profitRow \u003d new JPanel();\n\t\tprofitRow.setLayout(new BoxLayout(profitRow, BoxLayout.X_AXIS));\n\t\tprofitRow.setBackground(bg);\n\t\tprofitRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tprofitRow.add(profHdrLbl);\n\t\tprofitRow.add(npcProfLbl);\n\t\tprofitRow.add(pohProfLbl);\n\t\tprofitRow.add(Box.createHorizontalGlue());\n\t\ttextPanel.add(profitRow);\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t\tbuySellRow.setBackground(HOVER_BG);\n\t\t\t\trepairRow.setBackground(HOVER_BG);\n\t\t\t\tprofitRow.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t\tbuySellRow.setBackground(bg);\n\t\t\t\trepairRow.setBackground(bg);\n\t\t\t\tprofitRow.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemIdRepaired);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/BarrowsItemPanel.java"},{"fileName":"DipItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.DipItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.Box;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.SwingConstants;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.BorderLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class DipItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color GREEN    \u003d new Color(0x00C27A);\n\tprivate static final Color RED      \u003d new Color(0xFF5555);\n\n\tpublic DipItemPanel(DipItem item, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BorderLayout(6, 0));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(13, 10, 13, 8));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\t//  Icon \n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(item.itemId, itemManager);\n\n\t\t//  Name \n\t\tJLabel nameLabel \u003d new JLabel(item.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\n\t\t//  Prices \n\t\tJLabel buyLbl \u003d new JLabel(\"Buy: \" + FlipItemPanel.formatGp(item.buyPrice));\n\t\tbuyLbl.setFont(Fonts.SM);\n\t\tbuyLbl.setForeground(GREEN);\n\n\t\tJLabel avgLbl \u003d new JLabel(\"  24h avg: \" + FlipItemPanel.formatGp(item.avg24hBuy));\n\t\tavgLbl.setFont(Fonts.SM);\n\t\tavgLbl.setForeground(new Color(0x666666));\n\n\t\tJPanel priceRow \u003d new JPanel();\n\t\tpriceRow.setLayout(new BoxLayout(priceRow, BoxLayout.X_AXIS));\n\t\tpriceRow.setBackground(bg);\n\t\tpriceRow.add(buyLbl);\n\t\tpriceRow.add(avgLbl);\n\t\tpriceRow.add(Box.createHorizontalGlue());\n\n\t\t//  Volume / Limit \n\t\tString volStr   \u003d item.hourlyVolume \u003e 0 ? \"Vol: \" + FlipItemPanel.formatGp(item.hourlyVolume) + \"/hr\" : \"\";\n\t\tString limitStr \u003d item.buyLimit \u003e 0 ? (volStr.isEmpty() ? \"\" : \"  \") + \"Limit: \" + FlipItemPanel.formatGp(item.buyLimit) : \"\";\n\t\tJLabel volLabel \u003d new JLabel(volStr + limitStr);\n\t\tvolLabel.setFont(Fonts.SM);\n\t\tvolLabel.setForeground(new Color(0x888888));\n\n\t\tJPanel textPanel \u003d new JPanel(new GridLayout(3, 1, 0, 6));\n\t\ttextPanel.setBackground(bg);\n\t\ttextPanel.add(nameLabel);\n\t\ttextPanel.add(priceRow);\n\t\ttextPanel.add(volLabel);\n\n\t\t//  Dip badge \n\t\tJLabel dipBadge \u003d new JLabel(\n\t\t\t\"\u003chtml\u003e\u003ccenter\u003e\u003cb\u003e\u003cfont color\u003d\u0027#FF5555\u0027\u003e\"\n\t\t\t+ String.format(\"%.1f%%\", item.dipPct)\n\t\t\t+ \"\u003c/font\u003e\u003c/b\u003e\u003cbr\u003e\u003cfont color\u003d\u0027#888888\u0027\u003edip\u003c/font\u003e\u003c/center\u003e\u003c/html\u003e\");\n\t\tdipBadge.setFont(Fonts.SM);\n\t\tdipBadge.setForeground(RED);\n\t\tdipBadge.setHorizontalAlignment(SwingConstants.RIGHT);\n\t\tdipBadge.setPreferredSize(new Dimension(52, 0));\n\n\t\tadd(iconLabel, BorderLayout.WEST);\n\t\tadd(textPanel, BorderLayout.CENTER);\n\t\tadd(dipBadge,  BorderLayout.EAST);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\ttextPanel.setBackground(HOVER_BG);\n\t\t\t\tpriceRow.setBackground(HOVER_BG);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\ttextPanel.setBackground(bg);\n\t\t\t\tpriceRow.setBackground(bg);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + item.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/DipItemPanel.java"},{"fileName":"AlertItemPanel.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip.ui;\n\nimport com.o7flip.model.AlertItem;\nimport com.o7flip.util.Fonts;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.ColorScheme;\nimport javax.swing.BoxLayout;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Cursor;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.GridLayout;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\n\npublic class AlertItemPanel extends JPanel\n{\n\tprivate static final Color ODD_BG   \u003d new Color(0x272727);\n\tprivate static final Color HOVER_BG \u003d new Color(0x3A3A3A);\n\tprivate static final Color ORANGE   \u003d new Color(0xFF981F);\n\tprivate static final Color GRAY_LBL \u003d new Color(0x888888);\n\tprivate static final Color SEP_COL  \u003d new Color(0x3A3A3A);\n\n\tpublic AlertItemPanel(AlertItem alert, ItemManager itemManager, boolean odd)\n\t{\n\t\tColor bg \u003d odd ? ODD_BG : ColorScheme.DARK_GRAY_COLOR;\n\n\t\tsetLayout(new BoxLayout(this, BoxLayout.Y_AXIS));\n\t\tsetBackground(bg);\n\t\tsetBorder(new EmptyBorder(10, 10, 10, 10));\n\t\tsetCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));\n\t\tsetAlignmentX(Component.LEFT_ALIGNMENT);\n\n\t\t//  Row 1: Icon + Name + link arrow \n\t\tJPanel headerRow \u003d new JPanel(new java.awt.BorderLayout(8, 0));\n\t\theaderRow.setOpaque(false);\n\t\theaderRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\theaderRow.setMaximumSize(new Dimension(Integer.MAX_VALUE, 36));\n\n\t\tJLabel iconLabel \u003d FlipItemPanel.buildIcon(alert.itemId, itemManager);\n\n\t\tJLabel nameLabel \u003d new JLabel(alert.name);\n\t\tnameLabel.setFont(Fonts.BOLD);\n\t\tnameLabel.setForeground(Color.WHITE);\n\n\t\tJLabel linkLabel \u003d new JLabel(\"\\u2197\");\n\t\tlinkLabel.setFont(Fonts.SM_BOLD);\n\t\tlinkLabel.setForeground(ORANGE);\n\n\t\theaderRow.add(iconLabel, java.awt.BorderLayout.WEST);\n\t\theaderRow.add(nameLabel, java.awt.BorderLayout.CENTER);\n\t\theaderRow.add(linkLabel, java.awt.BorderLayout.EAST);\n\n\t\t//  Price section: Current Price | Est. Sell Target \n\t\tJPanel priceLabels \u003d row2();\n\t\tpriceLabels.setBorder(new EmptyBorder(6, 0, 1, 0));\n\t\tpriceLabels.add(lbl(\"Current Price\",    Fonts.SM, GRAY_LBL));\n\t\tpriceLabels.add(lbl(\"Est. Sell Target\", Fonts.SM, GRAY_LBL));\n\n\t\tJPanel priceValues \u003d row2();\n\t\tpriceValues.setBorder(new EmptyBorder(0, 0, 4, 0));\n\t\tpriceValues.add(lbl(formatGpFull(alert.currentPrice), Fonts.SM, Color.WHITE));\n\t\tJLabel targetLbl \u003d new JLabel(\"\u003chtml\u003e\u003cfont color\u003d\u0027#00C27A\u0027\u003e\u003cb\u003e\"\n\t\t\t+ formatGpFull(alert.sellTarget) + \"\u003c/b\u003e\"\n\t\t\t+ \" (+\" + String.format(\"%.1f\", alert.upsidePct) + \"%)\u003c/font\u003e\u003c/html\u003e\");\n\t\ttargetLbl.setFont(Fonts.SM);\n\t\tpriceValues.add(targetLbl);\n\n\t\t//  90d stats section: High | Low \n\t\tJPanel statsLabels \u003d row2();\n\t\tstatsLabels.setBorder(new EmptyBorder(4, 0, 1, 0));\n\t\tstatsLabels.add(lbl(\"90d High\", Fonts.SM, GRAY_LBL));\n\t\tstatsLabels.add(lbl(\"90d Low\",  Fonts.SM, GRAY_LBL));\n\n\t\tJPanel statsValues \u003d row2();\n\t\tstatsValues.setBorder(new EmptyBorder(0, 0, 2, 0));\n\t\tstatsValues.add(lbl(formatGpFull(alert.high90d), Fonts.SM, Color.WHITE));\n\t\tstatsValues.add(lbl(formatGpFull(alert.low90d),  Fonts.SM, Color.WHITE));\n\n\t\t//  Hold time + drawdown \n\t\tJLabel holdRow \u003d new JLabel(\"\u003chtml\u003e\u003cb\u003e\" + alert.holdTime + \"\u003c/b\u003e\"\n\t\t\t+ \"\u0026nbsp;\u0026nbsp;\u003cfont color\u003d\u0027#888888\u0027\u003e\\u00B7\u003c/font\u003e\u0026nbsp;\u0026nbsp;\"\n\t\t\t+ \"\u003cfont color\u003d\u0027#FF981F\u0027\u003eDrawdown \" + String.format(\"%.1f\", alert.drawdownPct) + \"%\u003c/font\u003e\u003c/html\u003e\");\n\t\tholdRow.setFont(Fonts.SM);\n\t\tholdRow.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tholdRow.setBorder(new EmptyBorder(0, 0, 4, 0));\n\n\t\t//  Timestamp \n\t\tJLabel timeLabel \u003d lbl(\"Detected \" + formatTimestamp(alert.detectedAt), Fonts.SM, new Color(0x555555));\n\t\ttimeLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\ttimeLabel.setBorder(new EmptyBorder(4, 0, 0, 0));\n\n\t\t//  Assemble \n\t\tadd(headerRow);\n\t\tadd(cardSep());\n\t\tadd(priceLabels);\n\t\tadd(priceValues);\n\t\tadd(cardSep());\n\t\tadd(statsLabels);\n\t\tadd(statsValues);\n\t\tadd(holdRow);\n\t\tadd(cardSep());\n\t\tadd(timeLabel);\n\n\t\taddMouseListener(new MouseAdapter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(HOVER_BG);\n\t\t\t\trepaint();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent e)\n\t\t\t{\n\t\t\t\tsetBackground(bg);\n\t\t\t\trepaint();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent e)\n\t\t\t{\n\t\t\t\tFlipItemPanel.openUrl(\"https://07flip.com/item/\" + alert.itemId);\n\t\t\t}\n\t\t});\n\t\tsetMaximumSize(new Dimension(Integer.MAX_VALUE, getPreferredSize().height));\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Layout helpers\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate static JPanel row2()\n\t{\n\t\tJPanel p \u003d new JPanel(new GridLayout(1, 2, 6, 0));\n\t\tp.setOpaque(false);\n\t\tp.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tp.setMaximumSize(new Dimension(Integer.MAX_VALUE, 18));\n\t\treturn p;\n\t}\n\n\tprivate static JLabel lbl(String text, Font font, Color fg)\n\t{\n\t\tJLabel l \u003d new JLabel(text);\n\t\tl.setFont(font);\n\t\tl.setForeground(fg);\n\t\treturn l;\n\t}\n\n\tprivate static JPanel cardSep()\n\t{\n\t\tJPanel sep \u003d new JPanel();\n\t\tsep.setBackground(SEP_COL);\n\t\tsep.setMaximumSize(new Dimension(Integer.MAX_VALUE, 1));\n\t\tsep.setPreferredSize(new Dimension(0, 1));\n\t\tsep.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\treturn sep;\n\t}\n\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\t// Formatting\n\t// \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\tprivate static String formatGpFull(long amount)\n\t{\n\t\tif (amount \u003e\u003d 1_000_000_000)\n\t\t{\n\t\t\treturn String.format(\"%.1fB gp\", amount / 1_000_000_000.0);\n\t\t}\n\t\tif (amount \u003e\u003d 1_000_000)\n\t\t{\n\t\t\treturn String.format(\"%.2fM gp\", amount / 1_000_000.0);\n\t\t}\n\t\treturn String.format(\"%,d gp\", amount);\n\t}\n\n\t/** \"2026-02-14T20:30:00.000Z\"  \"Feb 14  20:30\" */\n\tprivate static String formatTimestamp(String iso)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString[] parts  \u003d iso.split(\"T\");\n\t\t\tString[] date   \u003d parts[0].split(\"-\");\n\t\t\tString[] months \u003d {\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n\t\t\tint month \u003d Integer.parseInt(date[1]);\n\t\t\tint day   \u003d Integer.parseInt(date[2]);\n\t\t\tString time \u003d parts[1].substring(0, 5);\n\t\t\treturn months[month - 1] + \" \" + day + \" \\u00B7 \" + time;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\treturn iso;\n\t\t}\n\t}\n}\n","filePath":"src/main/java/com/o7flip/ui/AlertItemPanel.java"},{"fileName":"O7FlipApiClient.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonArray;\nimport com.google.gson.JsonElement;\nimport com.google.gson.JsonObject;\nimport com.o7flip.model.AlertItem;\nimport com.o7flip.model.AuthStatus;\nimport com.o7flip.model.BarrowsItem;\nimport com.o7flip.model.BarrowsSet;\nimport com.o7flip.model.DecantItem;\nimport com.o7flip.model.DipItem;\nimport com.o7flip.model.DumpItem;\nimport com.o7flip.model.FlipItem;\nimport com.o7flip.model.MoonItem;\nimport com.o7flip.model.MoonSet;\nimport com.o7flip.model.SearchResultItem;\nimport com.o7flip.model.SpikeItem;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport okhttp3.Call;\nimport okhttp3.Callback;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.BiConsumer;\nimport java.util.function.Consumer;\n\n@Singleton\npublic class O7FlipApiClient\n{\n\tprivate static final Logger log \u003d LoggerFactory.getLogger(O7FlipApiClient.class);\n\n\tprivate static final String BASE_URL    \u003d \"https://07flip.com/api/runelite\";\n\tprivate static final String USER_AGENT  \u003d \"07Flip-RuneLite/1.0\";\n\tprivate static final int    PAGE_LIMIT  \u003d 10;   // items per page  must match O7FlipPanel.PAGE_SIZE\n\n\t@Inject\n\tprivate OkHttpClient okHttpClient;\n\n\t@Inject\n\tprivate Gson gson;\n\n\t@Inject\n\tprivate O7FlipConfig config;\n\n\tprivate void fetch(String url, Callback callback)\n\t{\n\t\tRequest.Builder builder \u003d new Request.Builder()\n\t\t\t.url(url)\n\t\t\t.header(\"User-Agent\", USER_AGENT);\n\t\tString key \u003d config !\u003d null ? config.apiKey() : null;\n\t\tif (key !\u003d null \u0026\u0026 !key.trim().isEmpty())\n\t\t{\n\t\t\tbuilder.header(\"Authorization\", \"Bearer \" + key.trim());\n\t\t}\n\t\tokHttpClient.newCall(builder.build()).enqueue(callback);\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Search\n\t// -------------------------------------------------------------------------\n\n\tpublic void fetchSearch(String query, Consumer\u003cList\u003cSearchResultItem\u003e\u003e callback)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString encoded \u003d java.net.URLEncoder.encode(query.trim(), \"UTF-8\");\n\t\t\tfetch(BASE_URL + \"/search?q\u003d\" + encoded + \"\u0026limit\u003d10\", new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"[07Flip] fetchSearch failed: {}\", e.getMessage());\n\t\t\t\t\tcallback.accept(new ArrayList\u003c\u003e());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t\t{\n\t\t\t\t\tcallback.accept(parseArray(response, \"items\", obj -\u003e\n\t\t\t\t\t{\n\t\t\t\t\t\tSearchResultItem item \u003d new SearchResultItem();\n\t\t\t\t\t\titem.itemId         \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\t\titem.name           \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\t\titem.buyPrice       \u003d getLongOrNull(obj, \"buy_price\");\n\t\t\t\t\t\titem.sellPrice      \u003d getLongOrNull(obj, \"sell_price\");\n\t\t\t\t\t\titem.margin         \u003d getLongOrNull(obj, \"margin\");\n\t\t\t\t\t\titem.profit         \u003d getLongOrNull(obj, \"profit\");\n\t\t\t\t\t\titem.roi            \u003d getDoubleOrNull(obj, \"roi\");\n\t\t\t\t\t\titem.hourlyVolume   \u003d getIntOrNull(obj, \"hourly_volume\");\n\t\t\t\t\t\titem.dailyVolume    \u003d getIntOrNull(obj, \"daily_volume\");\n\t\t\t\t\t\titem.buyLimit       \u003d getInt(obj, \"buy_limit\", 0);\n\t\t\t\t\t\titem.members        \u003d getBool(obj, \"members\", false);\n\t\t\t\t\t\titem.highAlch       \u003d getIntOrNull(obj, \"high_alch\");\n\t\t\t\t\t\titem.lastUpdated    \u003d getString(obj, \"last_updated\", \"\");\n\t\t\t\t\t\titem.dataAgeMinutes \u003d getIntOrNull(obj, \"data_age_minutes\");\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.warn(\"[07Flip] fetchSearch encode error: {}\", e.getMessage());\n\t\t\tcallback.accept(new ArrayList\u003c\u003e());\n\t\t}\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Auth\n\t// -------------------------------------------------------------------------\n\n\tpublic void fetchAuthStatus(Consumer\u003cAuthStatus\u003e callback)\n\t{\n\t\tfetch(BASE_URL + \"/auth\", new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchAuthStatus failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new AuthStatus());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tAuthStatus status \u003d new AuthStatus();\n\t\t\t\tif (response.isSuccessful() \u0026\u0026 response.body() !\u003d null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tJsonObject json \u003d gson.fromJson(response.body().string(), JsonObject.class);\n\t\t\t\t\t\tstatus.authenticated \u003d getBool(json, \"authenticated\", false);\n\t\t\t\t\t\tstatus.premium       \u003d getBool(json, \"premium\",       false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.warn(\"[07Flip] Auth parse error: {}\", e.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback.accept(status);\n\t\t\t}\n\t\t});\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Paginated endpoints  callback receives (items, serverTotal)\n\t// serverTotal defaults to items.size() when the server does not return \"total\"\n\t// -------------------------------------------------------------------------\n\n\tpublic void fetchFlips(String preset, long minProfit, long priceMin, long priceMax,\n\t                       int page, BiConsumer\u003cList\u003cFlipItem\u003e, Integer\u003e callback)\n\t{\n\t\tStringBuilder url \u003d new StringBuilder(BASE_URL + \"/flips?limit\u003d\").append(PAGE_LIMIT)\n\t\t\t.append(\"\u0026page\u003d\").append(page);\n\t\tif (preset !\u003d null \u0026\u0026 !preset.isEmpty())\n\t\t{\n\t\t\turl.append(\"\u0026preset\u003d\").append(preset);\n\t\t}\n\t\tif (minProfit \u003e 0)\n\t\t{\n\t\t\turl.append(\"\u0026minProfit\u003d\").append(minProfit);\n\t\t}\n\t\tif (priceMin \u003e 0)\n\t\t{\n\t\t\turl.append(\"\u0026priceMin\u003d\").append(priceMin);\n\t\t}\n\t\tif (priceMax \u003c Long.MAX_VALUE)\n\t\t{\n\t\t\turl.append(\"\u0026priceMax\u003d\").append(priceMax);\n\t\t}\n\t\tfetch(url.toString(), new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchFlips failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tparsePagedResponse(response, \"flips\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tFlipItem item \u003d new FlipItem();\n\t\t\t\t\titem.itemId          \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\titem.name            \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\titem.buyPrice        \u003d getLong(obj, \"buy_price\", 0);\n\t\t\t\t\titem.sellPrice       \u003d getLong(obj, \"sell_price\", 0);\n\t\t\t\t\titem.profit          \u003d getLong(obj, \"profit\", 0);\n\t\t\t\t\titem.roiPct          \u003d getDouble(obj, \"roi_pct\", 0);\n\t\t\t\t\titem.potentialProfit \u003d getLong(obj, \"potential_profit\", 0);\n\t\t\t\t\titem.buyLimit        \u003d getInt(obj, \"buy_limit\", 0);\n\t\t\t\t\titem.members         \u003d getBool(obj, \"members\", true);\n\t\t\t\t\treturn item;\n\t\t\t\t}, callback);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchSpikes(String sort, int page, BiConsumer\u003cList\u003cSpikeItem\u003e, Integer\u003e callback)\n\t{\n\t\tStringBuilder url \u003d new StringBuilder(BASE_URL + \"/spikes?limit\u003d\").append(PAGE_LIMIT)\n\t\t\t.append(\"\u0026page\u003d\").append(page);\n\t\tif (sort !\u003d null \u0026\u0026 !sort.isEmpty())\n\t\t{\n\t\t\turl.append(\"\u0026sort\u003d\").append(sort);\n\t\t}\n\t\tfetch(url.toString(), new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchSpikes failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tparsePagedResponse(response, \"spikes\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tSpikeItem item \u003d new SpikeItem();\n\t\t\t\t\titem.itemId       \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\titem.name         \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\titem.buyPrice     \u003d getLong(obj, \"buy_price\", 0);\n\t\t\t\t\titem.avg24hBuy    \u003d getLong(obj, \"avg_24h_buy\", 0);\n\t\t\t\t\titem.spikePct     \u003d getDouble(obj, \"spike_pct\", 0);\n\t\t\t\t\titem.hourlyVolume \u003d getInt(obj, \"hourly_volume\", 0);\n\t\t\t\t\titem.dailyVolume  \u003d getInt(obj, \"daily_volume\", 0);\n\t\t\t\t\titem.buyLimit     \u003d getInt(obj, \"buy_limit\", 0);\n\t\t\t\t\titem.members      \u003d getBool(obj, \"members\", true);\n\t\t\t\t\titem.lastUpdated  \u003d getString(obj, \"last_updated\", \"\");\n\t\t\t\t\treturn item;\n\t\t\t\t}, callback);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchDips(String sort, int page, BiConsumer\u003cList\u003cDipItem\u003e, Integer\u003e callback)\n\t{\n\t\tStringBuilder url \u003d new StringBuilder(BASE_URL + \"/dips?limit\u003d\").append(PAGE_LIMIT)\n\t\t\t.append(\"\u0026page\u003d\").append(page);\n\t\tif (sort !\u003d null \u0026\u0026 !sort.isEmpty())\n\t\t{\n\t\t\turl.append(\"\u0026sort\u003d\").append(sort);\n\t\t}\n\t\tfetch(url.toString(), new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchDips failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tparsePagedResponse(response, \"dips\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tDipItem item \u003d new DipItem();\n\t\t\t\t\titem.itemId       \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\titem.name         \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\titem.buyPrice     \u003d getLong(obj, \"buy_price\", 0);\n\t\t\t\t\titem.avg24hBuy    \u003d getLong(obj, \"avg_24h_buy\", 0);\n\t\t\t\t\titem.dipPct       \u003d getDouble(obj, \"dip_pct\", 0);\n\t\t\t\t\titem.hourlyVolume \u003d getInt(obj, \"hourly_volume\", 0);\n\t\t\t\t\titem.dailyVolume  \u003d getInt(obj, \"daily_volume\", 0);\n\t\t\t\t\titem.buyLimit     \u003d getInt(obj, \"buy_limit\", 0);\n\t\t\t\t\titem.members      \u003d getBool(obj, \"members\", true);\n\t\t\t\t\titem.lastUpdated  \u003d getString(obj, \"last_updated\", \"\");\n\t\t\t\t\treturn item;\n\t\t\t\t}, callback);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchDumps(String sort, long minProfit, long priceMin, long priceMax,\n\t                       int page, BiConsumer\u003cList\u003cDumpItem\u003e, Integer\u003e callback)\n\t{\n\t\tStringBuilder url \u003d new StringBuilder(BASE_URL + \"/dumps?limit\u003d\").append(PAGE_LIMIT)\n\t\t\t.append(\"\u0026page\u003d\").append(page);\n\t\tif (sort !\u003d null \u0026\u0026 !sort.isEmpty())\n\t\t{\n\t\t\turl.append(\"\u0026sort\u003d\").append(sort);\n\t\t}\n\t\tif (minProfit \u003e 0)\n\t\t{\n\t\t\turl.append(\"\u0026minProfit\u003d\").append(minProfit);\n\t\t}\n\t\tif (priceMin \u003e 0)\n\t\t{\n\t\t\turl.append(\"\u0026priceMin\u003d\").append(priceMin);\n\t\t}\n\t\tif (priceMax \u003c Long.MAX_VALUE)\n\t\t{\n\t\t\turl.append(\"\u0026priceMax\u003d\").append(priceMax);\n\t\t}\n\t\tfetch(url.toString(), new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchDumps failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tparsePagedResponse(response, \"dumps\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tDumpItem item \u003d new DumpItem();\n\t\t\t\t\titem.itemId           \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\titem.name             \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\titem.buyPrice         \u003d getLong(obj, \"buy_price\", 0);\n\t\t\t\t\titem.sellPrice        \u003d getLong(obj, \"sell_price\", 0);\n\t\t\t\t\titem.profit           \u003d getLong(obj, \"profit\", 0);\n\t\t\t\t\t// Fallback: older API versions use current_price instead of buy_price\n\t\t\t\t\tif (item.buyPrice \u003d\u003d 0)\n\t\t\t\t\t{\n\t\t\t\t\t\titem.buyPrice \u003d getLong(obj, \"current_price\", 0);\n\t\t\t\t\t}\n\t\t\t\t\titem.dumpScore        \u003d getInt(obj, \"dump_score\", 0);\n\t\t\t\t\titem.dumpPct          \u003d getDouble(obj, \"dump_pct\", 0);\n\t\t\t\t\titem.dumpStatus       \u003d getString(obj, \"dump_status\", \"none\");\n\t\t\t\t\titem.lastDumpHoursAgo \u003d getDoubleOrNull(obj, \"last_dump_hours_ago\");\n\t\t\t\t\titem.nextDumpHours    \u003d getDoubleOrNull(obj, \"next_dump_hours\");\n\t\t\t\t\titem.burstCount       \u003d getIntOrNull(obj, \"burst_count\");\n\t\t\t\t\titem.hourlyVolume     \u003d getInt(obj, \"hourly_volume\", 0);\n\t\t\t\t\titem.buyLimit         \u003d getInt(obj, \"buy_limit\", 0);\n\t\t\t\t\titem.members          \u003d getBool(obj, \"members\", true);\n\t\t\t\t\treturn item;\n\t\t\t\t}, callback);\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchAlerts(int page, BiConsumer\u003cList\u003cAlertItem\u003e, Integer\u003e callback)\n\t{\n\t\tString url \u003d BASE_URL + \"/alerts?limit\u003d\" + PAGE_LIMIT + \"\u0026page\u003d\" + page;\n\t\tfetch(url, new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchAlerts failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tparsePagedResponse(response, \"alerts\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tAlertItem alert \u003d new AlertItem();\n\t\t\t\t\talert.itemId       \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\talert.name         \u003d getString(obj, \"name\", \"Unknown\");\n\t\t\t\t\talert.currentPrice \u003d getLong(obj, \"current_price\", 0);\n\t\t\t\t\talert.sellTarget   \u003d getLong(obj, \"sell_target\", 0);\n\t\t\t\t\talert.upsidePct    \u003d getDouble(obj, \"upside_pct\", 0);\n\t\t\t\t\talert.holdTime     \u003d getString(obj, \"hold_time\", \"\");\n\t\t\t\t\talert.high90d      \u003d getLong(obj, \"high_90d\", 0);\n\t\t\t\t\talert.low90d       \u003d getLong(obj, \"low_90d\", 0);\n\t\t\t\t\talert.drawdownPct  \u003d getDouble(obj, \"drawdown_pct\", 0);\n\t\t\t\t\talert.detectedAt   \u003d getString(obj, \"detected_at\", \"\");\n\t\t\t\t\treturn alert;\n\t\t\t\t}, callback);\n\t\t\t}\n\t\t});\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Non-paginated endpoints (full dataset loaded once, client-side pagination)\n\t// -------------------------------------------------------------------------\n\n\tpublic void fetchBarrows(int smithingLevel, Consumer\u003cList\u003cBarrowsSet\u003e\u003e callback)\n\t{\n\t\tfetch(BASE_URL + \"/barrows?set\u003dall\u0026smithingLevel\u003d\" + smithingLevel, new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchBarrows failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tcallback.accept(parseArray(response, \"sets\", O7FlipApiClient.this::parseBarrowsSet));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchBarrowsDetail(String setParam, int smithingLevel, Consumer\u003cBarrowsSet\u003e callback)\n\t{\n\t\tfetch(BASE_URL + \"/barrows?set\u003d\" + setParam + \"\u0026smithingLevel\u003d\" + smithingLevel, new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchBarrowsDetail failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(null);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tList\u003cBarrowsSet\u003e sets \u003d parseArray(response, \"sets\", O7FlipApiClient.this::parseBarrowsSet);\n\t\t\t\tcallback.accept(sets.isEmpty() ? null : sets.get(0));\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate BarrowsSet parseBarrowsSet(JsonObject obj)\n\t{\n\t\tBarrowsSet s \u003d new BarrowsSet();\n\t\ts.iconItemId         \u003d getInt(obj, \"icon_item_id\", 0);\n\t\ts.setName            \u003d getString(obj, \"set_name\", \"\");\n\t\ts.shortName          \u003d getString(obj, \"short_name\", \"\");\n\t\ts.setParam           \u003d getString(obj, \"set_param\", \"\");\n\t\ts.totalBrokenCost    \u003d getLong(obj, \"total_broken_cost\", 0);\n\t\ts.totalNpcRepairCost \u003d getLong(obj, \"total_npc_repair_cost\", 0);\n\t\ts.totalPohRepairCost \u003d getLong(obj, \"total_poh_repair_cost\", 0);\n\t\ts.npcProfit          \u003d getLong(obj, \"npc_profit\", 0);\n\t\ts.pohProfit          \u003d getLong(obj, \"poh_profit\", 0);\n\t\ts.setProfit          \u003d getLong(obj, \"set_profit\", 0);\n\t\ts.bestProfit         \u003d getLong(obj, \"best_profit\", 0);\n\t\ts.bestStrategy       \u003d getString(obj, \"best_strategy\", \"sell_individual\");\n\t\ts.dailyVolume        \u003d getInt(obj, \"daily_volume\", 0);\n\n\t\t// Derive setParam if server did not return it\n\t\tif (s.setParam.isEmpty() \u0026\u0026 !s.shortName.isEmpty())\n\t\t{\n\t\t\ts.setParam \u003d s.shortName.replace(\"\u0027s\", \"\").toLowerCase() + \"s\";\n\t\t}\n\n\t\t// Items  present in detail response (?set\u003dX), absent in list response (?set\u003dall)\n\t\tJsonArray itemsArr \u003d obj.getAsJsonArray(\"items\");\n\t\tif (itemsArr !\u003d null)\n\t\t{\n\t\t\tfor (int i \u003d 0; i \u003c itemsArr.size(); i++)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tJsonObject io \u003d itemsArr.get(i).getAsJsonObject();\n\t\t\t\t\tBarrowsItem item \u003d new BarrowsItem();\n\t\t\t\t\titem.itemIdBroken      \u003d getInt(io, \"item_id_broken\", 0);\n\t\t\t\t\titem.itemIdRepaired    \u003d getInt(io, \"item_id_repaired\", 0);\n\t\t\t\t\titem.name              \u003d getString(io, \"name\", \"\");\n\t\t\t\t\titem.slot              \u003d getString(io, \"slot\", \"\");\n\t\t\t\t\titem.brokenBuyPrice    \u003d getLong(io, \"broken_buy_price\", 0);\n\t\t\t\t\titem.repairedSellPrice \u003d getLong(io, \"repaired_sell_price\", 0);\n\t\t\t\t\titem.repairedAfterTax  \u003d getLong(io, \"repaired_after_tax\", 0);\n\t\t\t\t\titem.npcRepairCost     \u003d getLong(io, \"npc_repair_cost\", 0);\n\t\t\t\t\titem.pohRepairCost     \u003d getLong(io, \"poh_repair_cost\", 0);\n\t\t\t\t\titem.npcProfit         \u003d getLong(io, \"npc_profit\", 0);\n\t\t\t\t\titem.pohProfit         \u003d getLong(io, \"poh_profit\", 0);\n\t\t\t\t\titem.npcRoiPct         \u003d getDouble(io, \"npc_roi_pct\", 0);\n\t\t\t\t\titem.pohRoiPct         \u003d getDouble(io, \"poh_roi_pct\", 0);\n\t\t\t\t\titem.dailyVolume       \u003d getInt(io, \"daily_volume\", 0);\n\t\t\t\t\ts.items.add(item);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"[07Flip] Skipping malformed barrows item at index {}: {}\", i, e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\n\tpublic void fetchMoon(int smithingLevel, Consumer\u003cList\u003cMoonSet\u003e\u003e callback)\n\t{\n\t\tfetch(BASE_URL + \"/moon?smithingLevel\u003d\" + smithingLevel, new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchMoon failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tcallback.accept(parseArray(response, \"sets\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tMoonSet s \u003d new MoonSet();\n\t\t\t\t\ts.setName             \u003d getString(obj, \"set_name\", \"\");\n\t\t\t\t\ts.shortName           \u003d getString(obj, \"short_name\", \"\");\n\t\t\t\t\ts.combatStyle         \u003d getString(obj, \"combat_style\", \"\");\n\t\t\t\t\ts.setId               \u003d getInt(obj, \"set_id\", 0);\n\t\t\t\t\ts.iconItemId          \u003d getInt(obj, \"icon_item_id\", 0);\n\t\t\t\t\ts.totalBrokenCost     \u003d getLong(obj, \"total_broken_cost\", 0);\n\t\t\t\t\ts.totalNpcRepairCost  \u003d getLong(obj, \"total_npc_repair_cost\", 0);\n\t\t\t\t\ts.totalPohRepairCost  \u003d getLong(obj, \"total_poh_repair_cost\", 0);\n\t\t\t\t\ts.npcProfit           \u003d getLong(obj, \"npc_profit\", 0);\n\t\t\t\t\ts.pohProfit           \u003d getLong(obj, \"poh_profit\", 0);\n\t\t\t\t\ts.setPrice            \u003d getLong(obj, \"set_price\", 0);\n\t\t\t\t\ts.setProfit           \u003d getLong(obj, \"set_profit\", 0);\n\t\t\t\t\ts.bestStrategy        \u003d getString(obj, \"best_strategy\", \"sell_individual\");\n\t\t\t\t\ts.bestProfit          \u003d getLong(obj, \"best_profit\", 0);\n\t\t\t\t\tJsonArray itemsArr \u003d obj.getAsJsonArray(\"items\");\n\t\t\t\t\tif (itemsArr !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i \u003d 0; i \u003c itemsArr.size(); i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tJsonObject io \u003d itemsArr.get(i).getAsJsonObject();\n\t\t\t\t\t\t\t\tMoonItem mi \u003d new MoonItem();\n\t\t\t\t\t\t\t\tmi.itemIdBroken      \u003d getInt(io, \"item_id_broken\", 0);\n\t\t\t\t\t\t\t\tmi.itemIdRepaired    \u003d getInt(io, \"item_id_repaired\", 0);\n\t\t\t\t\t\t\t\tmi.name              \u003d getString(io, \"name\", \"\");\n\t\t\t\t\t\t\t\tmi.slot              \u003d getString(io, \"slot\", \"\");\n\t\t\t\t\t\t\t\tmi.degrades          \u003d getBool(io, \"degrades\", false);\n\t\t\t\t\t\t\t\tmi.brokenBuyPrice    \u003d getLong(io, \"broken_buy_price\", 0);\n\t\t\t\t\t\t\t\tmi.repairedSellPrice \u003d getLong(io, \"repaired_sell_price\", 0);\n\t\t\t\t\t\t\t\tmi.repairedAfterTax  \u003d getLong(io, \"repaired_after_tax\", 0);\n\t\t\t\t\t\t\t\tmi.npcRepairCost     \u003d getLong(io, \"npc_repair_cost\", 0);\n\t\t\t\t\t\t\t\tmi.pohRepairCost     \u003d getLong(io, \"poh_repair_cost\", 0);\n\t\t\t\t\t\t\t\tmi.npcProfit         \u003d getLong(io, \"npc_profit\", 0);\n\t\t\t\t\t\t\t\tmi.pohProfit         \u003d getLong(io, \"poh_profit\", 0);\n\t\t\t\t\t\t\t\tmi.npcRoiPct         \u003d getDouble(io, \"npc_roi_pct\", 0);\n\t\t\t\t\t\t\t\tmi.pohRoiPct         \u003d getDouble(io, \"poh_roi_pct\", 0);\n\t\t\t\t\t\t\t\ts.items.add(mi);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.warn(\"[07Flip] Skipping malformed moon item at index {}: {}\", i, e.getMessage());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn s;\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void fetchDecanting(Consumer\u003cList\u003cDecantItem\u003e\u003e callback)\n\t{\n\t\tfetch(BASE_URL + \"/decanting\", new Callback()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] fetchDecanting failed: {}\", e.getMessage());\n\t\t\t\tcallback.accept(new ArrayList\u003c\u003e());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onResponse(Call call, Response response) throws IOException\n\t\t\t{\n\t\t\t\tcallback.accept(parseArray(response, \"decants\", obj -\u003e\n\t\t\t\t{\n\t\t\t\t\tDecantItem item \u003d new DecantItem();\n\t\t\t\t\titem.itemId           \u003d getInt(obj, \"item_id\", 0);\n\t\t\t\t\titem.potionName       \u003d getString(obj, \"potion_name\", \"Unknown\");\n\t\t\t\t\titem.strategy         \u003d getString(obj, \"strategy\", \"\");\n\t\t\t\t\titem.profitPer4dose   \u003d getLong(obj, \"profit_per_4dose\", 0);\n\t\t\t\t\titem.profitPerDose    \u003d getLong(obj, \"profit_per_dose\", 0);\n\t\t\t\t\titem.roiPct           \u003d getDouble(obj, \"roi_pct\", 0);\n\t\t\t\t\titem.minHourlyVolume  \u003d getInt(obj, \"min_hourly_volume\", 0);\n\t\t\t\t\titem.dailyVolume      \u003d getInt(obj, \"daily_volume\", 0);\n\t\t\t\t\titem.buyDose          \u003d getInt(obj, \"buy_dose\", 0);\n\t\t\t\t\titem.sellDose         \u003d getInt(obj, \"sell_dose\", 0);\n\t\t\t\t\treturn item;\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}\n\n\t// -------------------------------------------------------------------------\n\t// Internal helpers\n\t// -------------------------------------------------------------------------\n\n\t@FunctionalInterface\n\tprivate interface JsonMapper\u003cT\u003e\n\t{\n\t\tT map(JsonObject obj);\n\t}\n\n\t/**\n\t * Parses a paginated response. Extracts the items array and the \"total\" field.\n\t * If the server does not include \"total\", falls back to items.size().\n\t */\n\tprivate \u003cT\u003e void parsePagedResponse(Response response, String arrayKey,\n\t                                    JsonMapper\u003cT\u003e mapper,\n\t                                    BiConsumer\u003cList\u003cT\u003e, Integer\u003e callback)\n\t{\n\t\tif (!response.isSuccessful() || response.body() \u003d\u003d null)\n\t\t{\n\t\t\tlog.warn(\"[07Flip] HTTP {} for \u0027{}\u0027\", response.code(), arrayKey);\n\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t\treturn;\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tJsonObject json \u003d gson.fromJson(response.body().string(), JsonObject.class);\n\t\t\tList\u003cT\u003e items \u003d parseArray(json, arrayKey, mapper);\n\t\t\tint total \u003d getInt(json, \"total\", items.size());\n\t\t\tcallback.accept(items, total);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.warn(\"[07Flip] Parse error for \u0027{}\u0027: {}\", arrayKey, e.getMessage());\n\t\t\tcallback.accept(new ArrayList\u003c\u003e(), 0);\n\t\t}\n\t}\n\n\t/** Parses an array from an already-decoded JsonObject. */\n\tprivate \u003cT\u003e List\u003cT\u003e parseArray(JsonObject json, String arrayKey, JsonMapper\u003cT\u003e mapper)\n\t{\n\t\tList\u003cT\u003e result \u003d new ArrayList\u003c\u003e();\n\t\tJsonArray arr \u003d json.getAsJsonArray(arrayKey);\n\t\tif (arr \u003d\u003d null)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\tfor (int i \u003d 0; i \u003c arr.size(); i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tresult.add(mapper.map(arr.get(i).getAsJsonObject()));\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tlog.warn(\"[07Flip] Skipping malformed item at index {}: {}\", i, e.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/** Parses an array from an HTTP response (used by non-paginated endpoints). */\n\tprivate \u003cT\u003e List\u003cT\u003e parseArray(Response response, String arrayKey, JsonMapper\u003cT\u003e mapper)\n\t{\n\t\tif (!response.isSuccessful() || response.body() \u003d\u003d null)\n\t\t{\n\t\t\tlog.warn(\"[07Flip] HTTP {} for key \u0027{}\u0027\", response.code(), arrayKey);\n\t\t\treturn new ArrayList\u003c\u003e();\n\t\t}\n\t\ttry\n\t\t{\n\t\t\tJsonObject json \u003d gson.fromJson(response.body().string(), JsonObject.class);\n\t\t\treturn parseArray(json, arrayKey, mapper);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.warn(\"[07Flip] Parse error for \u0027{}\u0027: {}\", arrayKey, e.getMessage());\n\t\t\treturn new ArrayList\u003c\u003e();\n\t\t}\n\t}\n\n\tprivate String getString(JsonObject obj, String key, String def)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? def : el.getAsString();\n\t}\n\n\tprivate long getLong(JsonObject obj, String key, long def)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? def : el.getAsLong();\n\t}\n\n\tprivate int getInt(JsonObject obj, String key, int def)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? def : el.getAsInt();\n\t}\n\n\tprivate double getDouble(JsonObject obj, String key, double def)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? def : el.getAsDouble();\n\t}\n\n\tprivate boolean getBool(JsonObject obj, String key, boolean def)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? def : el.getAsBoolean();\n\t}\n\n\tprivate Double getDoubleOrNull(JsonObject obj, String key)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? null : el.getAsDouble();\n\t}\n\n\tprivate Integer getIntOrNull(JsonObject obj, String key)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? null : el.getAsInt();\n\t}\n\n\tprivate Long getLongOrNull(JsonObject obj, String key)\n\t{\n\t\tJsonElement el \u003d obj.get(key);\n\t\treturn (el \u003d\u003d null || el.isJsonNull()) ? null : el.getAsLong();\n\t}\n}\n","filePath":"src/main/java/com/o7flip/O7FlipApiClient.java"},{"fileName":"O7FlipLauncher.java","content":"/*\n * Copyright (c) 2026, 07Flip\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.o7flip;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class O7FlipLauncher\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(O7FlipPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}\n","filePath":"src/test/java/com/o7flip/O7FlipLauncher.java"}]},{"commit":"e2f1de2103548b05464c0c73998e52de1e482f83","repository":"https://github.com/SoaresPT/clue-scroll-notifier.git","internalName":"clue-scroll-notifier","files":[{"fileName":"ClueScrollNotifierConfig.java","content":"package com.cluescrollnotifier;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Range;\n\n@ConfigGroup(\"ClueScrollNotifier\")\npublic interface ClueScrollNotifierConfig extends Config {\n\n\t@ConfigSection(\n\t\t\tname \u003d \"General Settings\",\n\t\t\tdescription \u003d \"General configuration settings\",\n\t\t\tposition \u003d 0\n\t)\n\tString generalSettings \u003d \"generalSettings\";\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Notification Settings\",\n\t\t\tdescription \u003d \"Notification configuration settings\",\n\t\t\tposition \u003d 1\n\t)\n\tString notificationSettings \u003d \"notificationSettings\";\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Debug\",\n\t\t\tdescription \u003d \"Debug and testing options\",\n\t\t\tposition \u003d 2,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString debugSettings \u003d \"debugSettings\";\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"playSound\",\n\t\t\tname \u003d \"Play Sound\",\n\t\t\tdescription \u003d \"Toggle to play sound on clue scroll found.\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d generalSettings\n\t)\n\tdefault boolean playSound() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"customSoundFile\",\n\t\t\tname \u003d \"Custom Sound File\",\n\t\t\tdescription \u003d \"Select a custom sound file to play for notifications\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d generalSettings\n\t)\n\tdefault Sound customSoundFile() {\n\t\treturn Sound.CLUE1;\n\t}\n\n\t@Range(min \u003d 0, max \u003d 200)\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"announcementVolume\",\n\t\t\tname \u003d \"Sound Volume\",\n\t\t\tdescription \u003d \"Adjust how loud the sounds are played.\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d generalSettings\n\t)\n\tdefault int announcementVolume() {\n\t\treturn 100;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showNotification\",\n\t\t\tname \u003d \"Show Notification\",\n\t\t\tdescription \u003d \"Toggle to send a notification on clue scroll found.\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d generalSettings\n\t)\n\tdefault boolean showNotification() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifyClueNests\",\n\t\t\tname \u003d \"Notify on Clue Nests\",\n\t\t\tdescription \u003d \"Toggle to notify on clue nests falling from trees.\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d notificationSettings\n\t)\n\tdefault boolean notifyClueNests() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifyClueScrollDrops\",\n\t\t\tname \u003d \"Notify on Clue Scroll Drops\",\n\t\t\tdescription \u003d \"Toggle to notify on clue scroll drops. Make sure Untradeable loot notifications is enabled on the game settings.\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d notificationSettings\n\t)\n\tdefault boolean notifyClueScrollDrops() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifyPickpockets\",\n\t\t\tname \u003d \"Notify on Pickpockets\",\n\t\t\tdescription \u003d \"Toggle to notify on pickpocketing clues.\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d notificationSettings\n\t)\n\tdefault boolean notifyPickpockets() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifyFishing\",\n\t\t\tname \u003d \"Notify on Fishing\",\n\t\t\tdescription \u003d \"Toggle to notify on getting a clue bottle while fishing.\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d notificationSettings\n\t)\n\tdefault boolean notifyFishing() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifyMining\",\n\t\t\tname \u003d \"Notify on Mining\",\n\t\t\tdescription \u003d \"Toggle to notify on getting a clue geode while mining.\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d notificationSettings\n\t)\n\tdefault boolean notifyMining() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"notifySalvaging\",\n\t\t\tname \u003d \"Notify on Salvaging\",\n\t\t\tdescription \u003d \"Toggle to notify on getting a scroll box or clue scroll while sorting salvage.\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d notificationSettings\n\t\t)\n\tdefault boolean notifySalvaging() {\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"testSound\",\n\t\t\tname \u003d \"Test Sound\",\n\t\t\tdescription \u003d \"Click to test the selected sound and volume\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d debugSettings\n\t)\n\tdefault boolean testSound() {\n\t\treturn false;\n\t}\n}","filePath":"src\\main\\java\\com\\cluescrollnotifier\\ClueScrollNotifierConfig.java"},{"fileName":"ClueScrollNotifierPlugin.java","content":"package com.cluescrollnotifier;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.gameval.ItemID;\nimport net.runelite.api.TileItem;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.ItemSpawned;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.audio.AudioPlayer;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.concurrent.ScheduledExecutorService;\nimport net.runelite.client.events.ConfigChanged;\n\n@Slf4j\n@PluginDescriptor(\n\t\tname \u003d \"Clue Scroll Notifier\"\n)\npublic class ClueScrollNotifierPlugin extends Plugin {\n\n\t@Inject\n\tprivate Client client;\n\t@Inject\n\tprivate ClueScrollNotifierConfig config;\n\t@Inject\n\tprivate SoundEngine soundEngine;\n\t@Inject\n\tprivate ScheduledExecutorService executor;\n\t@Inject\n\tprivate Notifier notifier;\n\n\tprivate static final List\u003cInteger\u003e CLUE_ITEM_IDS \u003d Arrays.asList(\n\t\t\tItemID.WC_CLUE_NEST_BEGINNER,\n\t\t\tItemID.WC_CLUE_NEST_EASY,\n\t\t\tItemID.WC_CLUE_NEST_MEDIUM,\n\t\t\tItemID.WC_CLUE_NEST_HARD,\n\t\t\tItemID.WC_CLUE_NEST_ELITE\n\t);\n\n\t@Override\n\tprotected void startUp() throws Exception {\n\t\texecutor.submit(FileManager::initialize);\n\t\tlog.info(\"ClueScrollNotifier started!\");\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception {\n\t\tlog.info(\"ClueScrollNotifier stopped!\");\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage chatMessage) {\n\t\tChatMessageType type \u003d chatMessage.getType();\n\t\tString message \u003d chatMessage.getMessage().toLowerCase();\n\n\t\t// Global type check: only handle messages that are SPAM or GAMEMESSAGE.\n\t\tboolean isSpamOrGame \u003d type \u003d\u003d ChatMessageType.SPAM || type \u003d\u003d ChatMessageType.GAMEMESSAGE;\n\t\tif (!isSpamOrGame) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.contains(\"untradeable drop: clue scroll\") || message.contains(\"untradeable drop: scroll box\")) {\n\t\t\tif (config.notifyClueScrollDrops()) {\n\t\t\t\tnotify(\"Clue scroll drop!\");\n\t\t\t}\n\t\t}\n\n\t\tif (message.contains(\"you steal a clue scroll\")) {\n\t\t\tif (config.notifyPickpockets()) {\n\t\t\t\tnotify(\"You stole a clue scroll!\");\n\t\t\t}\n\t\t}\n\n\t\tif (message.contains(\"you catch a clue bottle\") || message.contains(\"you catch a scroll box\")) {\n\t\t\tif (config.notifyFishing()) {\n\t\t\t\tnotify(\"You caught a clue scroll!\");\n\t\t\t}\n\t\t}\n\n\t\tif (message.contains(\"you find a clue geode\") || message.contains(\"you find a scroll box\")) {\n\t\t\tif (config.notifyMining()) {\n\t\t\t\tnotify(\"You found a clue scroll!\");\n\t\t\t}\n\t\t}\n\n\t\tif (message.contains(\"you sort through the\") \u0026\u0026 message.contains(\"salvage and find\") \u0026\u0026 (message.contains(\"scroll box\") || message.contains(\"clue scroll\"))) {\n\t\t\tif (config.notifySalvaging()) {\n\t\t\t\tnotify(\"You found a clue while salvaging!\");\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onItemSpawned(ItemSpawned itemSpawned) {\n\t\tTileItem item \u003d itemSpawned.getItem();\n\t\tif (config.notifyClueNests() \u0026\u0026 CLUE_ITEM_IDS.contains(item.getId())) {\n\t\t\tnotify(\"A bird\u0027s nest with a clue has fallen out of the tree!\");\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged event) {\n\t\tif (!event.getGroup().equals(\"ClueScrollNotifier\")) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (event.getKey().equals(\"testSound\")) {\n\t\t\t// Play the test sound with current settings\n\t\t\tif (config.playSound()) {\n\t\t\t\tsoundEngine.playClip(config.customSoundFile());\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void notify(String message) {\n\t\tif (config.playSound()) {\n\t\t\tsoundEngine.playClip(config.customSoundFile());\n\t\t}\n\t\tif (config.showNotification()) {\n\t\t\tnotifier.notify(message);\n\t\t}\n\t}\n\n\t@Provides\n\tClueScrollNotifierConfig provideConfig(ConfigManager configManager) {\n\t\treturn configManager.getConfig(ClueScrollNotifierConfig.class);\n\t}\n}","filePath":"src\\main\\java\\com\\cluescrollnotifier\\ClueScrollNotifierPlugin.java"},{"fileName":"FileManager.java","content":"package com.cluescrollnotifier;\n\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.RuneLite;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardCopyOption;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n@Slf4j\npublic class FileManager {\n    private static final Path DOWNLOAD_DIR \u003d Paths.get(RuneLite.RUNELITE_DIR.getPath(), \"clue-scroll-notifier\");\n\n    public static void initialize() {\n        createDownloadDirectory();\n        Set\u003cString\u003e filesPresent \u003d getFilesPresent();\n        Set\u003cString\u003e desiredFiles \u003d getDesiredSoundList().stream()\n                .map(Sound::getFileName)\n                .collect(Collectors.toSet());\n\n        copyMissingFiles(filesPresent, desiredFiles);\n        deleteExtraFiles(filesPresent);\n    }\n\n    private static void createDownloadDirectory() {\n        try {\n            Files.createDirectories(DOWNLOAD_DIR);\n        } catch (IOException e) {\n            log.error(\"Could not create download directory\", e);\n        }\n    }\n\n    private static Set\u003cString\u003e getFilesPresent() {\n        try (Stream\u003cPath\u003e paths \u003d Files.list(DOWNLOAD_DIR)) {\n            return paths\n                    .filter(Files::isRegularFile)\n                    .map(path -\u003e path.getFileName().toString())\n                    .collect(Collectors.toSet());\n        } catch (IOException e) {\n            log.error(\"Error listing files in download directory\", e);\n            return new HashSet\u003c\u003e();\n        }\n    }\n\n    private static Set\u003cSound\u003e getDesiredSoundList() {\n        return Arrays.stream(Sound.values()).collect(Collectors.toSet());\n    }\n\n    private static void copyMissingFiles(Set\u003cString\u003e filesPresent, Set\u003cString\u003e desiredFiles) {\n        for (String fileName : desiredFiles) {\n            Path outputPath \u003d DOWNLOAD_DIR.resolve(fileName);\n            if (Files.exists(outputPath)) {\n                filesPresent.remove(fileName);\n                continue;\n            }\n\n            try (InputStream resourceStream \u003d FileManager.class.getResourceAsStream(\"/\" + fileName)) {\n                if (resourceStream !\u003d null) {\n                    Files.copy(resourceStream, outputPath, StandardCopyOption.REPLACE_EXISTING);\n                } else {\n                    log.error(\"Clue Scroll Notifier could not find resource: {}\", fileName);\n                }\n            } catch (IOException e) {\n                log.error(\"Clue Scroll Notifier could not copy sound: {}\", fileName, e);\n            }\n        }\n    }\n\n    private static void deleteExtraFiles(Set\u003cString\u003e filesPresent) {\n        for (String filename : filesPresent) {\n            try {\n                Files.delete(DOWNLOAD_DIR.resolve(filename));\n            } catch (IOException e) {\n                log.warn(\"Failed to delete file: {}\", filename, e);\n            }\n        }\n    }\n\n    public static InputStream getSoundStream(Sound sound) throws FileNotFoundException {\n        return new FileInputStream(DOWNLOAD_DIR.resolve(sound.getFileName()).toFile());\n    }\n}","filePath":"src\\main\\java\\com\\cluescrollnotifier\\FileManager.java"},{"fileName":"Sound.java","content":"package com.cluescrollnotifier;\n\npublic enum Sound {\n    CLUE1(\"clue1.wav\"),\n    CLUE2(\"clue2.wav\"),\n    CLUE3(\"clue3.wav\"),\n    CLUE4(\"clue4.wav\"),\n    CLUE5(\"clue5.wav\");\n\n    private final String fileName;\n\n    Sound(String fileName) {\n        this.fileName \u003d fileName;\n    }\n\n    public String getFileName() {\n        return fileName;\n    }\n}","filePath":"src\\main\\java\\com\\cluescrollnotifier\\Sound.java"},{"fileName":"SoundEngine.java","content":"package com.cluescrollnotifier;\n\nimport java.io.BufferedInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.audio.AudioPlayer;\n\n@Singleton\n@Slf4j\npublic class SoundEngine {\n\n    @Inject\n    private ClueScrollNotifierConfig config;\n\n    @Inject\n    private AudioPlayer audioPlayer;\n\n    public void playClip(Sound sound) {\n        float gain \u003d 20f * (float) Math.log10(config.announcementVolume() / 100f);\n\n        try (InputStream stream \u003d new BufferedInputStream(FileManager.getSoundStream(sound))) {\n            audioPlayer.play(stream, gain);\n        } catch (FileNotFoundException e) {\n            log.warn(\"Sound file not found for {}\", sound, e);\n        } catch (IOException | UnsupportedAudioFileException | LineUnavailableException e) {\n            log.warn(\"Failed to play sound {}\", sound, e);\n        }\n    }\n}","filePath":"src\\main\\java\\com\\cluescrollnotifier\\SoundEngine.java"},{"fileName":"ClueScrollNotifierPluginTest.java","content":"package com.cluescrollnotifier;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ClueScrollNotifierPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(ClueScrollNotifierPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\cluescrollnotifier\\ClueScrollNotifierPluginTest.java"}]},{"commit":"3ece9e0401f5ebac9da2762015449d5e68bb0bfc","repository":"https://github.com/nightfirecat/plugin-hub-plugins.git","internalName":"rogues-den","files":[{"fileName":"Obstacles.java","content":"/*\n * Copyright (c) 2018, Shaun Dreclin \u003cshaundreclin@gmail.com\u003e\n * Copyright (c) 2021, Jordan Atwood \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage at.nightfirec.roguesden;\n\nimport java.awt.Color;\nimport java.util.HashMap;\nimport java.util.Map;\nimport lombok.Getter;\nimport net.runelite.api.coords.WorldPoint;\nimport static net.runelite.api.ObjectID.*;\n\nclass Obstacles\n{\n\tstatic final Map\u003cWorldPoint, Obstacle\u003e TILE_MAP \u003d new HashMap\u003c\u003e();\n\tstatic final Obstacle[] OBSTACLES \u003d\n\t\t{\n\t\t\tnew Obstacle(3050, 4997, \"Enter\"),\n\t\t\tnew Obstacle(3049, 4997, CONTORTION_BARS),\n\t\t\tnew Obstacle(3039, 4999, \"Stand\"),\n\t\t\tnew Obstacle(3029, 5003, \"Run\"),\n\t\t\tnew Obstacle(3024, 5001, \"Open\", GRILL_7255),\n\t\t\tnew Obstacle(3011, 5005, \"Run\"),\n\t\t\tnew Obstacle(3004, 5003, \"Run\"),\n\n\t\t\tnew Obstacle(2994, 5004, \"Climb\"),\n\t\t\tnew Obstacle(2993, 5004, LEDGE_7240),\n\t\t\tnew Obstacle(2994, 5005, \"Climb\"),\n\t\t\tnew Obstacle(2993, 5005, LEDGE_7240),\n\n\t\t\tnew Obstacle(2969, 5016, \"Stand\"),\n\t\t\tnew Obstacle(2969, 5017, \"Stand\"),\n\t\t\tnew Obstacle(2969, 5018, \"Stand\"),\n\t\t\tnew Obstacle(2969, 5019, \"Stand\"),\n\n\t\t\tnew Obstacle(2958, 5031, \"Cross\"),\n\t\t\tnew Obstacle(2962, 5050, \"Stand\"),\n\t\t\tnew Obstacle(2963, 5056, \"Run\"),\n\n\t\t\tnew Obstacle(2957, 5068, \"Enter\"),\n\t\t\tnew Obstacle(2957, 5069, PASSAGEWAY),\n\n\t\t\tnew Obstacle(2955, 5094, \"Enter\"),\n\t\t\tnew Obstacle(2955, 5095, PASSAGEWAY),\n\n\t\t\tnew Obstacle(2963, 5105, \"Stand\"),\n\n\t\t\tnew Obstacle(2972, 5098, \"Enter\"),\n\t\t\tnew Obstacle(2972, 5097, PASSAGEWAY),\n\n\t\t\tnew Obstacle(2972, 5094, \"Open\"),\n\t\t\tnew Obstacle(2972, 5094, GRILL_7255),\n\n\t\t\tnew Obstacle(2982, 5087, \"Climb\"),\n\t\t\tnew Obstacle(2983, 5087, LEDGE_7240),\n\n\t\t\tnew Obstacle(2982, 5090, \"Climb\"),\n\t\t\tnew Obstacle(2983, 5090, LEDGE_7240),\n\n\t\t\tnew Obstacle(2993, 5088, \"Search\"),\n\t\t\tnew Obstacle(2993, 5087, WALL_7249),\n\t\t\tnew Obstacle(2997, 5088, \"Run\"),\n\n\t\t\tnew Obstacle(2993, 5089, \"Search\"),\n\t\t\tnew Obstacle(2993, 5089, WALL_7249),\n\t\t\tnew Obstacle(2997, 5089, \"Run\"),\n\n\t\t\tnew Obstacle(3006, 5088, \"Run\"),\n\t\t\tnew Obstacle(3018, 5080, \"Take\"),\n\t\t\tnew Obstacle(3023, 5082, \"Open\", DOOR_7234),\n\n\t\t\t// Maze\n\t\t\tnew Obstacle(3030, 5079, GRILL_7255),\n\t\t\tnew Obstacle(3032, 5078, GRILL_7255),\n\t\t\tnew Obstacle(3036, 5076, GRILL_7255),\n\t\t\tnew Obstacle(3039, 5079, GRILL_7255),\n\t\t\tnew Obstacle(3042, 5076, GRILL_7255),\n\t\t\tnew Obstacle(3044, 5069, GRILL_7255),\n\t\t\tnew Obstacle(3041, 5068, GRILL_7255),\n\t\t\tnew Obstacle(3040, 5070, GRILL_7255),\n\t\t\tnew Obstacle(3038, 5069, GRILL_7255),\n\n\t\t\tnew Obstacle(3028, 5033, \"Stand\"),\n\t\t\tnew Obstacle(3024, 5033, \"Run\"),\n\t\t\tnew Obstacle(3028, 5034, \"Stand\"),\n\t\t\tnew Obstacle(3024, 5034, \"Run\"),\n\n\t\t\tnew Obstacle(3015, 5033, \"Open\", GRILL_7255),\n\t\t\tnew Obstacle(3010, 5033, \"Run/Open\", GRILL_7255),\n\n\t\t\tnew Obstacle(3000, 5034, \"Run\"),\n\n\t\t\tnew Obstacle(2992, 5045, \"Stand\"),\n\t\t\tnew Obstacle(2992, 5053, \"Run\"),\n\n\t\t\tnew Obstacle(2992, 5067, \"Stand\"),\n\t\t\tnew Obstacle(2992, 5075, \"Run\"),\n\t\t\tnew Obstacle(3009, 5063, \"Take\"),\n\t\t\tnew Obstacle(3028, 5056, \"Run\"),\n\t\t\tnew Obstacle(3028, 5047, \"Walk\"),\n\n\t\t\tnew Obstacle(3018, 5047, \"Crack\", WALL_SAFE_7237),\n\n\t\t\t// Start of 80+ thieving shortcut\n\t\t\tnew Obstacle(2967, 5061, \"80 Thieving\", DOOR_7246),\n\t\t\tnew Obstacle(2967, 5066, \"80 Thieving\", DOOR_7246),\n\t\t\tnew Obstacle(2974, 5061, \"Enter\"),\n\t\t\tnew Obstacle(2974, 5060, CONTORTION_BARS),\n\t\t\tnew Obstacle(2989, 5057, \"Open\", GRILL_7255),\n\t\t\tnew Obstacle(2989, 5058, \"Open\", GRILL_7255),\n\n\t\t\t// The 3x3 square around the spinning blade in the middle of the maze\n\t\t\tnew AvoidObstacle(2977, 5090), new AvoidObstacle(2978, 5090), new AvoidObstacle(2979, 5090),\n\t\t\tnew AvoidObstacle(2977, 5089), new AvoidObstacle(2978, 5089), new AvoidObstacle(2979, 5089),\n\t\t\tnew AvoidObstacle(2977, 5088), new AvoidObstacle(2978, 5088), new AvoidObstacle(2979, 5088),\n\n\t\t\tnew TipObstacle(3014, 5063, \"Stun NPC\"),\n\t\t\tnew TipObstacle(2992, 5057, \"Continue North\"),  // Hint for 80 thieving shortcut\n\t\t};\n\n\t@Getter\n\tstatic class Obstacle\n\t{\n\t\tprivate final WorldPoint tile;\n\t\tprivate final String hint;\n\t\tprivate final int objectId;\n\t\tprivate final Color tileColor \u003d Color.GREEN;\n\n\t\t// Highlights tile and shows a hint\n\t\tprivate Obstacle(int x, int y, String hint)\n\t\t{\n\t\t\tthis(x, y, hint, -1);\n\t\t}\n\n\t\t// Doesn\u0027t highlight tile, but instead highlights object of objectId found on tile\n\t\tprivate Obstacle(int x, int y, int objectId)\n\t\t{\n\t\t\tthis(x, y, \"\", objectId);\n\t\t}\n\n\t\t// Doesn\u0027t highlight tile, but instead highlights object of objectId found on tile and shows a hint\n\t\tprivate Obstacle(int x, int y, String hint, int objectId)\n\t\t{\n\t\t\ttile \u003d new WorldPoint(x, y, 1);\n\t\t\tthis.hint \u003d hint;\n\t\t\tthis.objectId \u003d objectId;\n\n\t\t\tif (objectId !\u003d -1)\n\t\t\t{\n\t\t\t\tTILE_MAP.put(new WorldPoint(x, y, 1), this);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class AvoidObstacle extends Obstacle\n\t{\n\t\t@Getter\n\t\tprivate final Color tileColor \u003d Color.RED;\n\n\t\tprivate AvoidObstacle(int x, int y)\n\t\t{\n\t\t\tsuper(x, y, \"AVOID\");\n\t\t}\n\t}\n\n\tprivate static class TipObstacle extends Obstacle\n\t{\n\t\t@Getter\n\t\tprivate final Color tileColor \u003d Color.ORANGE;\n\n\t\tprivate TipObstacle(int x, int y, String hint)\n\t\t{\n\t\t\tsuper(x, y, hint);\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\at\\nightfirec\\roguesden\\Obstacles.java"},{"fileName":"RoguesDenMinimapOverlay.java","content":"/*\n * Copyright (c) 2021, Jordan Atwood \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage at.nightfirec.roguesden;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport javax.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\n\nclass RoguesDenMinimapOverlay extends Overlay\n{\n\tprivate final Client client;\n\tprivate final RoguesDenPlugin plugin;\n\n\t@Inject\n\tpublic RoguesDenMinimapOverlay(Client client, RoguesDenPlugin plugin)\n\t{\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_WIDGETS);\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (!plugin.isHasGem())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (Obstacles.Obstacle obstacle : Obstacles.OBSTACLES)\n\t\t{\n\t\t\tfinal LocalPoint localPoint \u003d LocalPoint.fromWorld(client, obstacle.getTile());\n\n\t\t\tif (localPoint \u003d\u003d null || obstacle.getTile().getPlane() !\u003d client.getPlane())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfinal Point minimapPoint \u003d Perspective.localToMinimap(client, localPoint);\n\n\t\t\tif (minimapPoint !\u003d null)\n\t\t\t{\n\t\t\t\tOverlayUtil.renderMinimapLocation(graphics, minimapPoint, obstacle.getObjectId() \u003d\u003d -1 ? Color.GREEN : Color.RED);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","filePath":"src\\main\\java\\at\\nightfirec\\roguesden\\RoguesDenMinimapOverlay.java"},{"fileName":"RoguesDenOverlay.java","content":"/*\n * Copyright (c) 2018, Shaun Dreclin \u003cshaundreclin@gmail.com\u003e\n * Copyright (c) 2021, Jordan Atwood \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage at.nightfirec.roguesden;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Shape;\nimport javax.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\n\npublic class RoguesDenOverlay extends Overlay\n{\n\tprivate static final Color OBJECT_BORDER_COLOR \u003d Color.RED;\n\tprivate static final Color OBJECT_COLOR \u003d new Color(OBJECT_BORDER_COLOR.getRed(), OBJECT_BORDER_COLOR.getGreen(), OBJECT_BORDER_COLOR.getBlue(), 50);\n\tprivate static final Color OBJECT_BORDER_HOVER_COLOR \u003d OBJECT_BORDER_COLOR.darker();\n\n\tprivate final Client client;\n\tprivate final RoguesDenPlugin plugin;\n\n\t@Inject\n\tpublic RoguesDenOverlay(Client client, RoguesDenPlugin plugin)\n\t{\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (!plugin.isHasGem())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tplugin.getObstaclesHull().forEach((obstacle, tile) -\u003e\n\t\t{\n\t\t\tif (tile.getPlane() \u003d\u003d client.getPlane())\n\t\t\t{\n\t\t\t\tfinal Shape clickBox \u003d obstacle.getClickbox();\n\t\t\t\tif (clickBox !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tfinal Point mouse \u003d client.getMouseCanvasPosition();\n\t\t\t\t\tif (clickBox.contains(mouse.getX(), mouse.getY()))\n\t\t\t\t\t{\n\t\t\t\t\t\tgraphics.setColor(OBJECT_BORDER_HOVER_COLOR);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tgraphics.setColor(OBJECT_BORDER_COLOR);\n\t\t\t\t\t}\n\n\t\t\t\t\tgraphics.draw(clickBox);\n\t\t\t\t\tgraphics.setColor(OBJECT_COLOR);\n\t\t\t\t\tgraphics.fill(clickBox);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tShape p;\n\t\t\t\t\tif (obstacle instanceof GameObject)\n\t\t\t\t\t{\n\t\t\t\t\t\tp \u003d ((GameObject) obstacle).getConvexHull();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp \u003d obstacle.getCanvasTilePoly();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (p !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tgraphics.setColor(OBJECT_COLOR);\n\t\t\t\t\t\tgraphics.draw(p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfor (Obstacles.Obstacle obstacle : Obstacles.OBSTACLES)\n\t\t{\n\t\t\tfinal LocalPoint localPoint \u003d LocalPoint.fromWorld(client, obstacle.getTile());\n\n\t\t\tif (localPoint \u003d\u003d null || obstacle.getTile().getPlane() !\u003d client.getPlane())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!obstacle.getHint().isEmpty())\n\t\t\t{\n\t\t\t\tfinal Polygon polygon \u003d Perspective.getCanvasTilePoly(client, localPoint);\n\t\t\t\tif (polygon !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tgraphics.setColor(obstacle.getTileColor());\n\t\t\t\t\tgraphics.drawPolygon(polygon);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal Point textLocation \u003d Perspective.getCanvasTextLocation(client, graphics, localPoint, obstacle.getHint(), 0);\n\t\t\tif (textLocation !\u003d null)\n\t\t\t{\n\t\t\t\tgraphics.setColor(Color.LIGHT_GRAY);\n\t\t\t\tgraphics.drawString(obstacle.getHint(), textLocation.getX(), textLocation.getY());\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","filePath":"src\\main\\java\\at\\nightfirec\\roguesden\\RoguesDenOverlay.java"},{"fileName":"RoguesDenPlugin.java","content":"/*\n * Copyright (c) 2018-2019, Shaun Dreclin \u003chttps://github.com/ShaunDreclin\u003e\n * Copyright (c) 2021, Jordan \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage at.nightfirec.roguesden;\n\nimport java.util.HashMap;\nimport javax.inject.Inject;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.Item;\nimport net.runelite.api.ItemID;\nimport net.runelite.api.Tile;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.DecorativeObjectDespawned;\nimport net.runelite.api.events.DecorativeObjectSpawned;\nimport net.runelite.api.events.GameObjectDespawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GroundObjectDespawned;\nimport net.runelite.api.events.GroundObjectSpawned;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.WallObjectDespawned;\nimport net.runelite.api.events.WallObjectSpawned;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n@PluginDescriptor(\n\tname \u003d \"Rogues\u0027 Den\",\n\tdescription \u003d \"Mark tiles and clickboxes to help traverse the maze\",\n\ttags \u003d {\"agility\", \"maze\", \"minigame\", \"overlay\", \"thieving\"}\n)\npublic class RoguesDenPlugin extends Plugin\n{\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final HashMap\u003cTileObject, Tile\u003e obstaclesHull \u003d new HashMap\u003c\u003e();\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate final HashMap\u003cTileObject, Tile\u003e obstaclesTile \u003d new HashMap\u003c\u003e();\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate boolean hasGem;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate RoguesDenOverlay overlay;\n\n\t@Inject\n\tprivate RoguesDenMinimapOverlay minimapOverlay;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\toverlayManager.add(overlay);\n\t\toverlayManager.add(minimapOverlay);\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\toverlayManager.remove(overlay);\n\t\toverlayManager.remove(minimapOverlay);\n\t\tobstaclesHull.clear();\n\t\tobstaclesTile.clear();\n\t\thasGem \u003d false;\n\t}\n\n\t@Subscribe\n\tpublic void onItemContainerChanged(ItemContainerChanged event)\n\t{\n\t\tif (event.getItemContainer() !\u003d client.getItemContainer(InventoryID.INVENTORY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (Item item : event.getItemContainer().getItems())\n\t\t{\n\t\t\tif (item.getId() \u003d\u003d ItemID.MYSTIC_JEWEL)\n\t\t\t{\n\t\t\t\thasGem \u003d true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\thasGem \u003d false;\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged event)\n\t{\n\t\tif (event.getGameState() \u003d\u003d GameState.LOADING)\n\t\t{\n\t\t\tobstaclesHull.clear();\n\t\t\tobstaclesTile.clear();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectSpawned(GameObjectSpawned event)\n\t{\n\t\tonTileObject(event.getTile(), null, event.getGameObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGameObjectDespawned(GameObjectDespawned event)\n\t{\n\t\tonTileObject(event.getTile(), event.getGameObject(), null);\n\t}\n\n\t@Subscribe\n\tpublic void onGroundObjectSpawned(GroundObjectSpawned event)\n\t{\n\t\tonTileObject(event.getTile(), null, event.getGroundObject());\n\t}\n\n\t@Subscribe\n\tpublic void onGroundObjectDespawned(GroundObjectDespawned event)\n\t{\n\t\tonTileObject(event.getTile(), event.getGroundObject(), null);\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectSpawned(WallObjectSpawned event)\n\t{\n\t\tonTileObject(event.getTile(), null, event.getWallObject());\n\t}\n\n\t@Subscribe\n\tpublic void onWallObjectDespawned(WallObjectDespawned event)\n\t{\n\t\tonTileObject(event.getTile(), event.getWallObject(), null);\n\t}\n\n\t@Subscribe\n\tpublic void onDecorativeObjectSpawned(DecorativeObjectSpawned event)\n\t{\n\t\tonTileObject(event.getTile(), null, event.getDecorativeObject());\n\t}\n\n\t@Subscribe\n\tpublic void onDecorativeObjectDespawned(DecorativeObjectDespawned event)\n\t{\n\t\tonTileObject(event.getTile(), event.getDecorativeObject(), null);\n\t}\n\n\tprivate void onTileObject(final Tile tile, final TileObject oldObject, final TileObject newObject)\n\t{\n\t\tobstaclesHull.remove(oldObject);\n\t\tif (newObject !\u003d null)\n\t\t{\n\t\t\tWorldPoint point \u003d tile.getWorldLocation();\n\n\t\t\tObstacles.Obstacle obstacle \u003d Obstacles.TILE_MAP.get(point);\n\t\t\tif (obstacle !\u003d null \u0026\u0026 obstacle.getObjectId() \u003d\u003d newObject.getId())\n\t\t\t{\n\t\t\t\tobstaclesHull.put(newObject, tile);\n\t\t\t}\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\at\\nightfirec\\roguesden\\RoguesDenPlugin.java"},{"fileName":"RoguesDenPluginTest.java","content":"/*\n * Copyright (c) 2021, Jordan \u003cnightfirecat@protonmail.com\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage at.nightfirec.roguesden;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class RoguesDenPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(RoguesDenPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}\n","filePath":"src\\test\\java\\at\\nightfirec\\roguesden\\RoguesDenPluginTest.java"}]},{"commit":"d53217cc14f35d60cc73ec868ffdaacac61b7ac1","repository":"https://github.com/dekvall/bronzeman-mode.git","internalName":"dekvall-bronzeman-mode","files":[{"fileName":"BronzemanModeConfig.java","content":"/*\n * Copyright (c) 2019, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage dekvall.bronzeman;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(BronzemanModePlugin.CONFIG_GROUP)\npublic interface BronzemanModeConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"sendNotification\",\n\t\tname \u003d \"Notify on unlock\",\n\t\tdescription \u003d \"Send a notification when a new item is unlocked\"\n\t)\n\tdefault boolean sendNotification()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"sendChaMessage\",\n\t\tname \u003d \"Chat message on unlock\",\n\t\tdescription \u003d \"Send a chat message when a new item is unlocked\"\n\t)\n\tdefault boolean sendChatMessage()\n\t{\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\dekvall\\bronzeman\\BronzemanModeConfig.java"},{"fileName":"BronzemanModeOverlay.java","content":"/*\n * Copyright (c) 2019, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage dekvall.bronzeman;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport javax.inject.Inject;\nimport net.runelite.api.Constants;\nimport java.awt.Point;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.ComponentOrientation;\nimport net.runelite.client.ui.overlay.components.ImageComponent;\nimport net.runelite.client.ui.overlay.components.LineComponent;\nimport net.runelite.client.ui.overlay.components.PanelComponent;\nimport net.runelite.client.ui.overlay.components.TitleComponent;\n\npublic class BronzemanModeOverlay extends OverlayPanel\n{\n\tprivate static final int WIDTH \u003d 2*Constants.ITEM_SPRITE_WIDTH;\n\n\tprivate final BronzemanModePlugin plugin;\n\tprivate final PanelComponent panelComponent \u003d new PanelComponent();\n\n\t@Inject\n\tpublic BronzemanModeOverlay(BronzemanModePlugin plugin)\n\t{\n\t\tsuper(plugin);\n\t\tthis.plugin \u003d plugin;\n\t\tsetPosition(OverlayPosition.TOP_CENTER);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tpanelComponent.getChildren().clear();\n\t\tif (!plugin.isItemsRecentlyUnlocked() || plugin.getRecentUnlockedImages().isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tpanelComponent.setOrientation(ComponentOrientation.VERTICAL);\n\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t.left(\"Unlocked:\")\n\t\t\t.leftColor(Color.GREEN)\n\t\t\t.build());\n\n\t\tpanelComponent.setPreferredSize(new Dimension(WIDTH, 0));\n\n\t\tfor (BufferedImage image : plugin.getRecentUnlockedImages())\n\t\t{\n\t\t\tpanelComponent.getChildren().add(new ImageComponent(image));\n\t\t}\n\n\t\treturn panelComponent.render(graphics);\n\t}\n}\n","filePath":"src\\main\\java\\dekvall\\bronzeman\\BronzemanModeOverlay.java"},{"fileName":"BronzemanModePlugin.java","content":"/*\n * Copyright (c) 2019, dekvall \u003chttps://github.com/dekvall\u003e\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage dekvall.bronzeman;\n\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Sets;\nimport com.google.gson.reflect.TypeToken;\nimport com.google.inject.Provides;\nimport java.awt.image.BufferedImage;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport javax.inject.Inject;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.Item;\nimport net.runelite.api.ItemID;\nimport net.runelite.api.MessageNode;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.ScriptPostFired;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.chat.ChatColorType;\nimport net.runelite.client.chat.ChatCommandManager;\nimport net.runelite.client.chat.ChatMessageBuilder;\nimport net.runelite.client.chat.ChatMessageManager;\nimport net.runelite.client.chat.QueuedMessage;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport static net.runelite.http.api.RuneLiteAPI.GSON;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Bronzeman Mode\",\n\tdescription \u003d \"Unlock items as you acquire them (by dekvall)\"\n)\npublic class BronzemanModePlugin extends Plugin\n{\n\tstatic final String CONFIG_GROUP \u003d \"bronzemanmode\";\n\tpublic static final String CONFIG_KEY \u003d \"unlockeditems\";\n\tprivate static final int AMOUNT_OF_TICKS_TO_SHOW_OVERLAY \u003d 8;\n\tprivate static final int GE_SEARCH_BUILD_SCRIPT \u003d 751;\n\n\tprivate static final String UNLOCKED_ITEMS_STRING \u003d \"!bronzemanunlocks\";\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate Notifier notifier;\n\n\t@Inject\n\tprivate BronzemanModeConfig config;\n\n\t@Inject\n\tprivate BronzemanModeOverlay overlay;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Inject\n\tprivate ChatMessageManager chatMessageManager;\n\n\t@Inject\n\tprivate ChatCommandManager chatCommandManager;\n\n\t@Inject\n\tItemManager itemManager;\n\n\tprivate final Set\u003cInteger\u003e unlockedItems \u003d Sets.newHashSet();\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate List\u003cBufferedImage\u003e recentUnlockedImages;\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate boolean itemsRecentlyUnlocked;\n\tprivate int ticksToLastUnlock;\n\n\t@Provides\n\tBronzemanModeConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(BronzemanModeConfig.class);\n\t}\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\toverlayManager.add(overlay);\n\t\tchatCommandManager.registerCommand(UNLOCKED_ITEMS_STRING, this::unlockedItemsLookup);\n\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tloadUnlockedItems();\n\t\t\tunlockBond();\n\t\t}\n\n\t\tlog.info(\"Bronzeman Mode started!\");\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\toverlayManager.remove(overlay);\n\t\tchatCommandManager.unregisterCommand(UNLOCKED_ITEMS_STRING);\n\t\tunlockedItems.clear();\n\t\tlog.info(\"Bronzeman Mode stopped!\");\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tloadUnlockedItems();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onItemContainerChanged(ItemContainerChanged event)\n\t{\n\t\tif (event.getItemContainer() !\u003d client.getItemContainer(InventoryID.INVENTORY))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tSet\u003cInteger\u003e recentUnlocks \u003d Arrays.stream(client.getItemContainer(InventoryID.INVENTORY).getItems())\n\t\t\t.map(Item::getId)\n\t\t\t.map(itemManager::canonicalize)\n\t\t\t.filter(id -\u003e id !\u003d -1\n\t\t\t\t\u0026\u0026 client.getItemDefinition(id).isTradeable()\n\t\t\t\t\u0026\u0026 !unlockedItems.contains(id))\n\t\t\t.collect(Collectors.toSet());\n\n\t\tif (recentUnlocks.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tlog.info(\"Unlocked {} item(s), the id(s) were {}\", recentUnlocks.size(), recentUnlocks);\n\t\tunlockedItems.addAll(recentUnlocks);\n\t\trecentUnlockedImages \u003d recentUnlocks.stream().map(itemManager::getImage).collect(Collectors.toList());\n\t\tticksToLastUnlock \u003d 0;\n\t\titemsRecentlyUnlocked \u003d true;\n\t\tsaveUnlockedItems();\n\n\t\tif (config.sendNotification())\n\t\t{\n\t\t\tnotifier.notify(\"New bronzeman unlock!\");\n\t\t}\n\n\t\tif (config.sendChatMessage())\n\t\t{\n\t\t\tfor (int id : recentUnlocks)\n\t\t\t{\n\t\t\t\tsendChatMessage(\"You have unlocked a new item: \" + client.getItemDefinition(id).getName() + \".\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void saveUnlockedItems()\n\t{\n\t\tString key \u003d client.getUsername() + \".\" + CONFIG_KEY;\n\n\t\tif (unlockedItems \u003d\u003d null || unlockedItems.isEmpty())\n\t\t{\n\t\t\tconfigManager.unsetConfiguration(CONFIG_GROUP, key);\n\t\t\treturn;\n\t\t}\n\n\t\tString json \u003d GSON.toJson(unlockedItems);\n\t\tconfigManager.setConfiguration(CONFIG_GROUP, key, json);\n\t}\n\n\tprivate void loadUnlockedItems()\n\t{\n\t\tString key \u003d client.getUsername() + \".\" + CONFIG_KEY;\n\n\t\tString json \u003d configManager.getConfiguration(CONFIG_GROUP, key);\n\t\tunlockedItems.clear();\n\n\t\tif (!Strings.isNullOrEmpty(json))\n\t\t{\n\t\t\t// CHECKSTYLE:OFF\n\t\t\tunlockedItems.addAll(GSON.fromJson(json, new TypeToken\u003cList\u003cInteger\u003e\u003e(){}.getType()));\n\t\t\t// CHECKSTYLE:ON\n\t\t}\n\t}\n\n\tprivate void unlockBond()\n\t{\n\t\tunlockedItems.add(ItemID.OLD_SCHOOL_BOND);\n\t}\n\n\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick event)\n\t{\n\t\tif (ticksToLastUnlock \u003e AMOUNT_OF_TICKS_TO_SHOW_OVERLAY)\n\t\t{\n\t\t\titemsRecentlyUnlocked \u003d false;\n\t\t}\n\t\tticksToLastUnlock +\u003d 1;\n\t}\n\n\t@Subscribe\n\tpublic void onScriptPostFired(ScriptPostFired event)\n\t{\n\t\tif (event.getScriptId() \u003d\u003d GE_SEARCH_BUILD_SCRIPT)\n\t\t{\n\t\t\tkillSearchResults();\n\t\t}\n\t}\n\n\tvoid killSearchResults()\n\t{\n\t\tWidget grandExchangeSearchResults \u003d client.getWidget(162, 53);\n\n\t\tif (grandExchangeSearchResults \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tWidget[] children \u003d grandExchangeSearchResults.getDynamicChildren();\n\n\t\tif (children \u003d\u003d null || children.length \u003c 2)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfor (int i \u003d 0; i \u003c children.length; i+\u003d 3) {\n\t\t\tif (!unlockedItems.contains(children[i + 2].getItemId()))\n\t\t\t{\n\t\t\t\tchildren[i].setHidden(true);\n\t\t\t\tchildren[i + 1].setOpacity(170);\n\t\t\t\tchildren[i + 2].setOpacity(170);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void sendChatMessage(String chatMessage)\n\t{\n\t\tfinal String message \u003d new ChatMessageBuilder()\n\t\t\t.append(ChatColorType.HIGHLIGHT)\n\t\t\t.append(chatMessage)\n\t\t\t.build();\n\n\t\tchatMessageManager.queue(\n\t\t\tQueuedMessage.builder()\n\t\t\t\t.type(ChatMessageType.CONSOLE)\n\t\t\t\t.runeLiteFormattedMessage(message)\n\t\t\t\t.build());\n\t}\n\n\tprivate void unlockedItemsLookup(ChatMessage chatMessage, String message)\n\t{\n\t\tMessageNode messageNode \u003d chatMessage.getMessageNode();\n\n\t\tif (!messageNode.getName().equals(client.getLocalPlayer().getName()))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tfinal ChatMessageBuilder builder \u003d new ChatMessageBuilder()\n\t\t\t.append(ChatColorType.HIGHLIGHT)\n\t\t\t.append(\"You have unlocked \")\n\t\t\t.append(ChatColorType.NORMAL)\n\t\t\t.append(Integer.toString(unlockedItems.size()))\n\t\t\t.append(ChatColorType.HIGHLIGHT)\n\t\t\t.append(\" items.\");\n\n\t\tString response \u003d builder.build();\n\n\t\tmessageNode.setRuneLiteFormatMessage(response);\n\t\tchatMessageManager.update(messageNode);\n\t\tclient.refreshChat();\n\t}\n}\n","filePath":"src\\main\\java\\dekvall\\bronzeman\\BronzemanModePlugin.java"},{"fileName":"BronzemanModePluginTest.java","content":"package dekvall.bronzeman;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class BronzemanModePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(BronzemanModePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\dekvall\\bronzeman\\BronzemanModePluginTest.java"}]},{"commit":"d66a7075d6d2b7d3d21f82dad6de40f73a76c7fc","repository":"https://github.com/capslock13/AdvancedRaidTracker.git","internalName":"advanced-raid-tracker","files":[{"fileName":"AdvancedRaidTrackerConfig.java","content":"package com.advancedraidtracker;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\nimport java.awt.*;\n\n@ConfigGroup(\"Advanced Raid Tracker\")\n\npublic interface AdvancedRaidTrackerConfig extends Config\n{\n    @ConfigItem(\n            position \u003d 0,\n            keyName \u003d \"chatSplts\",\n            name \u003d \"Chat Splits\",\n            description \u003d \"Display room splits in chatbox.\"\n    )\n    default boolean chatSplits()\n    {\n        return false;\n    }\n\n    @ConfigItem(\n            position \u003d 1,\n            keyName \u003d \"writeToLog\",\n            name \u003d \"Track Raid Data\",\n            description \u003d \"Tracks data about the raids you spectate and participate in.\"\n    )\n    default boolean writeToLog()\n    {\n        return true;\n    }\n\n    @ConfigItem(\n            position \u003d 2,\n            keyName \u003d \"showMistakesInChat\",\n            name \u003d \"Show mistakes in chat?\",\n            description \u003d \"Shows mistakes (hammer bop, etc) in chat box when they occur.\"\n    )\n    default boolean showMistakesInChat()\n    {\n        return true;\n    }\n\n    @ConfigItem(\n            position \u003d 3,\n            keyName \u003d \"chartScaleSize\",\n            name \u003d \"Chart Scale Size\",\n            description \u003d \"Adjusts box size in chart\"\n    )\n    default int chartScaleSize()\n    {\n        return 26;\n    }\n\n    @ConfigItem(\n            position \u003d 5,\n            keyName \u003d \"useIconsOnChart\",\n            name \u003d \"Use icons on chart\",\n            description \u003d \"Replaced letter/colors with icons\"\n    )\n    default boolean useIconsOnChart() { return true;}\n\n    @ConfigItem(\n            position \u003d 6,\n            keyName \u003d \"primaryDark\",\n            name \u003d \"Chart Dark Color\",\n            description \u003d \"Color to use as darkest on chart\"\n    )\n    default Color primaryDark() { return new Color(20, 20, 20);}\n\n    @ConfigItem(\n            position \u003d 7,\n            keyName \u003d \"primaryMiddle\",\n            name \u003d \"Chart Middle Color\",\n            description \u003d \"Color to use as Middle on chart\"\n    )\n    default Color primaryMiddle() { return new Color(30, 30, 30);}\n\n    @ConfigItem(\n            position \u003d 8,\n            keyName \u003d \"primaryLight\",\n            name \u003d \"Chart Light Color\",\n            description \u003d \"Color to use as lightest on chart\"\n    )\n    default Color primaryLight() { return new Color(40, 40, 40);}\n\n    @ConfigItem(\n            position \u003d 9,\n            keyName \u003d \"letterBackgroundOpacity\",\n            name \u003d \"Letter BG Opacity\",\n            description \u003d \"Opacity of letter background color on chart\"\n    )\n    default int letterBackgroundOpacity() { return 180;}\n\n    @ConfigItem(\n            position \u003d 9,\n            keyName \u003d \"iconBackgroundOpacity\",\n            name \u003d \"Icon BG Opacity\",\n            description \u003d \"Opacity of icon background color on chart\"\n    )\n    default int iconBackgroundOpacity() { return 180;}\n\n    @ConfigItem(\n            position \u003d 10,\n            keyName \u003d \"useUnkitted\",\n            name \u003d \"Use unkitted icons\",\n            description \u003d \"Replaces kitted items with unkitted variants on chart icons\"\n    )\n    default boolean useUnkitted(){return false;}\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\AdvancedRaidTrackerConfig.java"},{"fileName":"AdvancedRaidTrackerPlugin.java","content":"package com.advancedraidtracker;\n\nimport com.advancedraidtracker.constants.TobIDs;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.rooms.tob.*;\nimport com.advancedraidtracker.ui.charts.LiveChart;\nimport com.advancedraidtracker.ui.RaidTrackerSidePanel;\nimport com.advancedraidtracker.utility.*;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.thrallvengtracking.*;\nimport com.advancedraidtracker.utility.wrappers.PlayerCopy;\nimport com.advancedraidtracker.utility.wrappers.PlayerDidAttack;\nimport com.advancedraidtracker.utility.wrappers.QueuedPlayerAttackLessProjectiles;\nimport com.advancedraidtracker.utility.wrappers.ThrallOutlineBox;\nimport com.google.inject.Inject;\nimport com.google.inject.Provides;\nimport javax.swing.SwingUtilities;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.*;\nimport net.runelite.api.kit.KitType;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.EventBus;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.events.PartyChanged;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.party.PartyMember;\nimport net.runelite.client.party.PartyService;\nimport net.runelite.client.party.WSClient;\nimport net.runelite.client.party.events.UserJoin;\nimport net.runelite.client.party.events.UserPart;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.plugins.PluginManager;\nimport net.runelite.client.plugins.specialcounter.SpecialCounterUpdate;\nimport net.runelite.client.plugins.specialcounter.SpecialWeapon;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.ImageUtil;\nimport net.runelite.client.util.Text;\n\nimport java.awt.image.BufferedImage;\nimport java.util.*;\nimport java.util.List;\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.constants.TOBRoom.*;\nimport static com.advancedraidtracker.utility.RoomUtil.inRegion;\nimport static com.advancedraidtracker.utility.datautility.LegacyFileUtility.splitLegacyFiles;\n\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"Advanced Raid Tracker\",\n        description \u003d \"Tracking and statistics for Theatre of Blood\",\n        tags \u003d {\"timers\", \"tob\", \"tracker\", \"time\", \"theatre\", \"analytics\"}\n)\npublic class AdvancedRaidTrackerPlugin extends Plugin\n{\n    private NavigationButton navButtonPrimary;\n    public DataWriter clog;\n\n    private boolean partyIntact \u003d false;\n\n    @Inject\n    private AdvancedRaidTrackerConfig config;\n\n    @Inject\n    private ItemManager itemManager;\n\n    public AdvancedRaidTrackerPlugin()\n    {\n    }\n\n    @Provides\n    AdvancedRaidTrackerConfig getConfig(ConfigManager configManager)\n    {\n        return configManager.getConfig(AdvancedRaidTrackerConfig.class);\n    }\n\n    @Inject\n    private ClientToolbar clientToolbar;\n\n    @Inject\n    public ClientThread clientThread;\n\n    @Inject\n    private PartyService party;\n\n    @Inject\n    private Client client;\n\n    private LobbyHandler lobby;\n    private MaidenHandler maiden;\n    private BloatHandler bloat;\n    private NyloHandler nylo;\n    private SotetsegHandler sote;\n    private XarpusHandler xarpus;\n    private VerzikHandler verzik;\n\n    private ArrayList\u003cDamageQueueShell\u003e queuedThrallDamage;\n\n    private ArrayList\u003cQueuedPlayerAttackLessProjectiles\u003e playersAttacked;\n\n\n    private boolean inTheatre;\n    private boolean wasInTheatre;\n    private RoomHandler currentRoom;\n    int deferredTick;\n    public ArrayList\u003cString\u003e currentPlayers;\n    public static int scale \u003d -1;\n    public boolean verzShieldActive \u003d false;\n    public boolean loggingIn \u003d false;\n\n    private ThrallTracker thrallTracker;\n    private VengTracker vengTracker;\n    private List\u003cPlayerShell\u003e localPlayers;\n    private List\u003cProjectileQueue\u003e activeProjectiles;\n    private List\u003cVengDamageQueue\u003e activeVenges;\n\n    @Inject\n    private PluginManager pluginManager;\n\n    @Inject\n    private EventBus eventBus;\n\n    @Inject\n    private WSClient wsClient;\n\n    @Inject\n    private ConfigManager configManager;\n\n    Map\u003cPlayer, Integer\u003e activelyPiping;\n    public LiveChart liveFrame;\n\n    @Override\n    protected void shutDown()\n    {\n        partyIntact \u003d false;\n        clog.addLine(LEFT_TOB, String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());\n        clientToolbar.removeNavigation(navButtonPrimary);\n    }\n\n    public void openLiveFrame()\n    {\n        liveFrame.open();\n    }\n\n    public int getTick()\n    {\n        return client.getTickCount();\n    }\n\n    public boolean isVerzP2()\n    {\n        if (currentRoom instanceof VerzikHandler)\n        {\n            VerzikHandler room \u003d (VerzikHandler) currentRoom;\n            return room.roomState \u003d\u003d RoomState.VerzikRoomState.PHASE_2 || room.roomState \u003d\u003d RoomState.VerzikRoomState.PHASE_2_REDS;\n        }\n        return false;\n    }\n\n    @Override\n    protected void startUp() throws Exception\n    {\n        super.startUp();\n        splitLegacyFiles();\n        localPlayers \u003d new ArrayList\u003c\u003e();\n        thrallTracker \u003d new ThrallTracker(this);\n        vengTracker \u003d new VengTracker(this);\n        activeProjectiles \u003d new ArrayList\u003c\u003e();\n        activeVenges \u003d new ArrayList\u003c\u003e();\n        queuedThrallDamage \u003d new ArrayList\u003c\u003e();\n        RaidTrackerSidePanel timersPanelPrimary \u003d injector.getInstance(RaidTrackerSidePanel.class);\n        partyIntact \u003d false;\n        activelyPiping \u003d new LinkedHashMap\u003c\u003e();\n        liveFrame \u003d new LiveChart(config, clientThread, configManager);\n        playersTextChanged \u003d new ArrayList\u003c\u003e();\n        clog \u003d new DataWriter(config);\n\n        final BufferedImage icon \u003d ImageUtil.loadImageResource(AdvancedRaidTrackerPlugin.class, \"/com/advancedraidtracker/icon.png\");\n        navButtonPrimary \u003d NavigationButton.builder().tooltip(\"Advanced Raid Tracker\").icon(icon).priority(10).panel(timersPanelPrimary).build();\n\n        clientToolbar.addNavigation(navButtonPrimary);\n\n        lobby \u003d new LobbyHandler(client, clog, config);\n        maiden \u003d new MaidenHandler(client, clog, config, this, itemManager);\n        bloat \u003d new BloatHandler(client, clog, config, this);\n        nylo \u003d new NyloHandler(client, clog, config, this);\n        sote \u003d new SotetsegHandler(client, clog, config, this);\n        xarpus \u003d new XarpusHandler(client, clog, config, this);\n        verzik \u003d new VerzikHandler(client, clog, config, this, itemManager);\n        inTheatre \u003d false;\n        wasInTheatre \u003d false;\n        deferredTick \u003d 0;\n        currentPlayers \u003d new ArrayList\u003c\u003e();\n        playersAttacked \u003d new ArrayList\u003c\u003e();\n    }\n\n    @Subscribe\n    public void onGameStateChanged(GameStateChanged gameStateChanged)\n    {\n        if(gameStateChanged.getGameState().equals(GameState.LOGGED_IN))\n        {\n            try\n            {\n                loggingIn \u003d true;\n            }\n            catch (Exception e)\n            {\n                log.info(\"Failed to set name: \" + client.getLocalPlayer().getName());\n            }\n        }\n    }\n\n    /**\n     * @return Room as int if inside TOB (0 indexed), -1 otherwise\n     */\n    private int getRoom()\n    {\n        if (inRegion(client, LOBBY_REGION))\n            return -1;\n        else if (inRegion(client, MAIDEN_REGION))\n            return 0;\n        else if (inRegion(client, BLOAT_REGION))\n            return 1;\n        else if (inRegion(client, NYLO_REGION))\n            return 2;\n        else if (inRegion(client, SOTETSEG_REGION) || inRegion(client, SOTETSEG_UNDER_REGION))\n            return 3;\n        else if (inRegion(client, XARPUS_REGION))\n            return 4;\n        else if (inRegion(client, VERZIK_REGION))\n            return 5;\n        return -1;\n    }\n\n    private void updateRoom()\n    {\n        RoomHandler previous \u003d currentRoom;\n        int currentRegion \u003d getRoom();\n        boolean activeState \u003d false;\n        if (inRegion(client, LOBBY_REGION))\n        {\n            currentRoom \u003d lobby;\n        } else if (previous \u003d\u003d lobby \u0026\u0026 inRegion(client, BLOAT_REGION, NYLO_REGION, SOTETSEG_REGION, XARPUS_REGION, VERZIK_REGION))\n        {\n            deferredTick \u003d client.getTickCount() + 2; //Check two ticks from now for player names in orbs\n            clog.checkForEndFlag();\n            clog.migrateToNewRaid();\n            clog.addLine(ENTERED_TOB);\n            clog.addLine(SPECTATE);\n            clog.addLine(LATE_START, String.valueOf(currentRegion));\n            liveFrame.resetAll();\n        }\n        if (inRegion(client, MAIDEN_REGION))\n        {\n            if (previous !\u003d maiden)\n            {\n                currentRoom \u003d maiden;\n                enteredMaiden();\n                liveFrame.resetAll();\n            }\n            activeState \u003d true;\n        } else if (inRegion(client, BLOAT_REGION))\n        {\n            if (previous !\u003d bloat)\n            {\n                currentRoom \u003d bloat;\n                enteredBloat();\n            }\n            activeState \u003d true;\n        } else if (inRegion(client, NYLO_REGION))\n        {\n            if (previous !\u003d nylo)\n            {\n                currentRoom \u003d nylo;\n                enteredNylo();\n            }\n            activeState \u003d true;\n        } else if (inRegion(client, SOTETSEG_REGION, SOTETSEG_UNDER_REGION))\n        {\n            if (previous !\u003d sote)\n            {\n                currentRoom \u003d sote;\n                enteredSote();\n            }\n            activeState \u003d true;\n        } else if (inRegion(client, XARPUS_REGION))\n        {\n            if (previous !\u003d xarpus)\n            {\n                currentRoom \u003d xarpus;\n                enteredXarpus();\n            }\n            activeState \u003d true;\n        } else if (inRegion(client, VERZIK_REGION))\n        {\n            if (previous !\u003d verzik)\n            {\n                currentRoom \u003d verzik;\n                enteredVerzik();\n            }\n            activeState \u003d true;\n        }\n        inTheatre \u003d activeState;\n    }\n\n    private void enteredMaiden()\n    {\n        clog.checkForEndFlag();\n        clog.migrateToNewRaid();\n        clog.addLine(ENTERED_TOB);\n        deferredTick \u003d client.getTickCount() + 2;\n        maiden.reset();\n        liveFrame.tabbedPane.setSelectedIndex(0);\n    }\n\n    private void enteredBloat()\n    {\n        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(TOBRoom.BLOAT.ordinal()));\n        maiden.reset();\n        bloat.reset();\n        liveFrame.tabbedPane.setSelectedIndex(1);\n    }\n\n    private void enteredNylo()\n    {\n        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(NYLOCAS.ordinal()));\n        bloat.reset();\n        nylo.reset();\n        liveFrame.tabbedPane.setSelectedIndex(2);\n    }\n\n    private void enteredSote()\n    {\n        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(SOTETSEG.ordinal()));\n        nylo.reset();\n        sote.reset();\n        liveFrame.tabbedPane.setSelectedIndex(3);\n    }\n\n    private void enteredXarpus()\n    {\n        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(XARPUS.ordinal()));\n        sote.reset();\n        xarpus.reset();\n        liveFrame.tabbedPane.setSelectedIndex(4);\n    }\n\n    private void enteredVerzik()\n    {\n        clog.addLine(ENTERED_NEW_TOB_REGION, String.valueOf(VERZIK.ordinal()));\n        xarpus.reset();\n        verzik.reset();\n        liveFrame.tabbedPane.setSelectedIndex(5);\n    }\n\n    @Subscribe\n    public void onSpecialCounterUpdate(SpecialCounterUpdate event)\n    {\n        if (inTheatre)\n        {\n            String name \u003d party.getMemberById(event.getMemberId()).getDisplayName();\n            if (name \u003d\u003d null)\n            {\n                return;\n            }\n            boolean playerInRaid \u003d false;\n            // Ensures correct names across encodings\n            for (String player : currentPlayers)\n            {\n                if (name.equals(player.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32))))\n                {\n                    playerInRaid \u003d true;\n                    break;\n                }\n            }\n            if (playerInRaid)\n            {\n                if (event.getWeapon().equals(SpecialWeapon.BANDOS_GODSWORD))\n                {\n                    clog.addLine(BGS, name, String.valueOf(event.getHit()), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));\n                }\n                if (event.getWeapon().equals(SpecialWeapon.DRAGON_WARHAMMER))\n                {\n                    clog.addLine(DWH, name, String.valueOf(client.getTickCount() - currentRoom.roomStartTick));\n                }\n            }\n        }\n    }\n\n    private String cleanString(String s1)\n    {\n        return s1.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32));\n    }\n\n    private boolean isPartyComplete()\n    {\n        if (currentPlayers.size() \u003e party.getMembers().size())\n        {\n            return false;\n        }\n        for (String raidPlayer : currentPlayers)\n        {\n            boolean currentPlayerMatched \u003d false;\n            for (PartyMember partyPlayer : party.getMembers())\n            {\n                if (cleanString(raidPlayer).equals(partyPlayer.getDisplayName()))\n                {\n                    currentPlayerMatched \u003d true;\n                }\n            }\n            if (!currentPlayerMatched)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private void checkPartyUpdate()\n    {\n        if (inTheatre)\n        {\n            if (partyIntact)\n            {\n                if (!isPartyComplete())\n                {\n                    partyIntact \u003d false;\n                    clog.addLine(PARTY_INCOMPLETE);\n                }\n            } else\n            {\n                if (isPartyComplete())\n                {\n                    partyIntact \u003d true;\n                    clog.addLine(PARTY_COMPLETE);\n                }\n            }\n        }\n\n    }\n\n    @Subscribe\n    public void onPartyChanged(final PartyChanged party)\n    {\n\n        checkPartyUpdate();\n    }\n\n    @Subscribe\n    public void onUserPart(final UserPart event)\n    {\n        checkPartyUpdate();\n    }\n\n    @Subscribe\n    public void onUserJoin(final UserJoin event)\n    {\n        checkPartyUpdate();\n    }\n\n    public void addQueuedThrallDamage(int targetIndex, int sourceIndex, int offset, String source)\n    {\n        queuedThrallDamage.add(new DamageQueueShell(targetIndex, sourceIndex, offset, source, client.getTickCount()));\n    }\n\n    public void removeDeadProjectiles()\n    {\n        activeProjectiles.removeIf(projectileQueue -\u003e projectileQueue.finalTick \u003c\u003d client.getTickCount());\n    }\n\n    public void removeDeadVenges()\n    {\n        activeVenges.removeIf(vengDamageQueue -\u003e vengDamageQueue.appliedTick \u003c\u003d client.getTickCount());\n    }\n\n    public void addDelayedLine(TOBRoom room, int value, String description)\n    {\n        switch (TOBRoom.valueOf(room.value))\n        {\n            case MAIDEN:\n                liveFrame.addMaidenLine(value, description);\n                break;\n            case BLOAT:\n                liveFrame.addBloatLine(value, description);\n                break;\n            case NYLOCAS:\n                liveFrame.addNyloLine(value, description);\n                break;\n            case SOTETSEG:\n                liveFrame.addSoteLine(value, description);\n                break;\n            case XARPUS:\n                liveFrame.addXarpLine(value, description);\n                break;\n            case VERZIK:\n                liveFrame.addVerzikLine(value, description);\n                break;\n        }\n    }\n\n    public void thrallAttackedP2VerzikShield(int tickOffset)\n    {\n        if (currentRoom instanceof VerzikHandler)\n        {\n            VerzikHandler room \u003d (VerzikHandler) currentRoom;\n            room.thrallAttackedShield(client.getTickCount() + tickOffset);\n        }\n    }\n\n    public void removeThrallBox(Thrall thrall)\n    {\n        clog.addLine(THRALL_DESPAWN, thrall.getOwner(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));\n    }\n\n    public void addThrallOutlineBox(ThrallOutlineBox outlineBox)\n    {\n        clog.addLine(THRALL_SPAWN, outlineBox.owner, String.valueOf(outlineBox.spawnTick), String.valueOf(outlineBox.id));\n        liveFrame.getPanel(currentRoom.getName()).addThrallBox(outlineBox);\n    }\n\n    public Map\u003cString, PlayerCopy\u003e lastTickPlayer \u003d new HashMap\u003c\u003e();\n    public int getRoomTick()\n    {\n        return client.getTickCount() - currentRoom.roomStartTick;\n    }\n\n    @Subscribe\n    public void onGameTick(GameTick event)\n    {\n        if(loggingIn)\n        {\n            try\n            {\n                clog.setName(client.getLocalPlayer().getName());\n            }\n            catch (Exception e)\n            {\n                log.info(\"failed to set name?\");\n            }\n            loggingIn \u003d false;\n        }\n        checkAnimationsThatChanged();\n        checkOverheadTextsThatChanged();\n\n        for (Player p : activelyPiping.keySet())\n        {\n            if ((client.getTickCount() \u003e (activelyPiping.get(p) + 1)) \u0026\u0026 ((client.getTickCount() - activelyPiping.get(p)-1) % 2 \u003d\u003d 0))\n            {\n                if (p.getAnimation() \u003d\u003d BLOWPIPE_ANIMATION || p.getAnimation() \u003d\u003d BLOWPIPE_ANIMATION_OR)\n                {\n                    PlayerCopy previous \u003d lastTickPlayer.get(p.getName());\n                    if(previous !\u003d null)\n                    {\n                        clog.addLine(PLAYER_ATTACK,\n                                previous.name + \":\" + (client.getTickCount() - currentRoom.roomStartTick - 1),\n                                previous.animation + \":\" + previous.wornItems,\n                                \"\",\n                                previous.weapon + \":\" + previous.interactingIndex + \":\" + previous.interactingID,\n                                \"-1:\" + previous.interactingName);\n                        liveFrame.addAttack(new PlayerDidAttack(itemManager,\n                                previous.name,\n                                String.valueOf(previous.animation),\n                                -1,\n                                previous.weapon,\n                                \"-1\",\n                                \"\",\n                                previous.interactingIndex,\n                                previous.interactingID,\n                                previous.interactingName,\n                                previous.wornItems\n                        ), currentRoom.getName());\n                    }\n                }\n            }\n            int interactedIndex \u003d -1;\n            int interactedID \u003d -1;\n            String targetName \u003d \"\";\n            Actor interacted \u003d p.getInteracting();\n            if (interacted instanceof NPC)\n            {\n                NPC npc \u003d (NPC) interacted;\n                interactedID \u003d npc.getId();\n                interactedIndex \u003d npc.getIndex();\n                targetName \u003d npc.getName();\n            }\n            if (interacted instanceof Player)\n            {\n                Player player \u003d (Player) interacted;\n                targetName \u003d player.getName();\n            }\n            lastTickPlayer.put(p.getName(), new PlayerCopy(\n                    p.getName(), interactedIndex, interactedID, targetName, p.getAnimation(), PlayerWornItems.getStringFromComposition(p.getPlayerComposition()\n            ), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON))));\n        }\n\n        for (QueuedPlayerAttackLessProjectiles playerAttackQueuedItem : playersAttacked)\n        {\n            playerAttackQueuedItem.tick--;\n            if (playerAttackQueuedItem.tick \u003d\u003d 0)\n            {\n                for (Projectile projectile : client.getProjectiles())\n                {\n                    int offset \u003d 41; //zcb\n                    if (projectile.getId() \u003d\u003d DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() \u003d\u003d DAWNBRINGER_SPEC_PROJECTILE)\n                    {\n                        offset \u003d 51; //dawnbringer\n                    }\n                    if (projectile.getStartCycle() \u003d\u003d client.getGameCycle() + offset)\n                    {\n                        WorldPoint position \u003d WorldPoint.fromLocal(client, new LocalPoint(projectile.getX1(), projectile.getY1()));\n                        if (position.distanceTo(playerAttackQueuedItem.player.getWorldLocation()) \u003d\u003d 0)\n                        {\n                            if (projectile.getId() \u003d\u003d DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() \u003d\u003d DAWNBRINGER_SPEC_PROJECTILE)\n                            {\n                                int projectileHitTick \u003d projectile.getRemainingCycles();\n                                projectileHitTick \u003d (projectileHitTick / 30);\n                                clog.addLine(DAWN_SPEC, playerAttackQueuedItem.player.getName(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick + projectileHitTick + 1));\n\n                            }\n                            if (projectile.getId() \u003d\u003d DAWNBRINGER_AUTO_PROJECTILE || projectile.getId() \u003d\u003d ZCB_PROJECTILE || projectile.getId() \u003d\u003d ZCB_SPEC_PROJECTILE || projectile.getId() \u003d\u003d DAWNBRINGER_SPEC_PROJECTILE)\n                            {\n                                int interactedIndex \u003d -1;\n                                int interactedID \u003d -1;\n                                Actor interacted \u003d playerAttackQueuedItem.player.getInteracting();\n                                String targetName \u003d \"\";\n                                if (interacted instanceof NPC)\n                                {\n                                    NPC npc \u003d (NPC) interacted;\n                                    interactedID \u003d npc.getId();\n                                    interactedIndex \u003d npc.getIndex();\n                                    targetName \u003d npc.getName();\n                                }\n                                if (interacted instanceof Player)\n                                {\n                                    Player player \u003d (Player) interacted;\n                                    targetName \u003d player.getName();\n                                }\n                                clog.addLine(PLAYER_ATTACK,\n                                        playerAttackQueuedItem.player.getName() + \":\" + (client.getTickCount() - currentRoom.roomStartTick),\n                                        playerAttackQueuedItem.animation+\":\"+PlayerWornItems.getStringFromComposition(playerAttackQueuedItem.player.getPlayerComposition()),\n                                        playerAttackQueuedItem.spotAnims,\n                                        playerAttackQueuedItem.weapon + \":\" + interactedIndex + \":\" + interactedID,\n                                        projectile.getId() + \":\" + targetName);\n                                liveFrame.addAttack(new PlayerDidAttack(itemManager,\n                                                playerAttackQueuedItem.player.getName(),\n                                                playerAttackQueuedItem.animation,\n                                                0,\n                                                playerAttackQueuedItem.weapon,\n                                                String.valueOf(projectile.getId()),\n                                                playerAttackQueuedItem.spotAnims,\n                                                interactedIndex,\n                                                interactedID,\n                                                targetName,\n                                                PlayerWornItems.getStringFromComposition(playerAttackQueuedItem.player.getPlayerComposition()))\n                                        , currentRoom.getName());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        playersAttacked.removeIf(p -\u003e p.tick \u003d\u003d 0);\n        removeDeadProjectiles();\n        removeDeadVenges();\n        playersTextChanged.clear();\n        localPlayers.clear();\n        for (Player p : client.getPlayers())\n        {\n            localPlayers.add(new PlayerShell(p.getWorldLocation(), p.getName()));\n            thrallTracker.updatePlayerInteracting(p.getName(), p.getInteracting());\n        }\n        for (DamageQueueShell damage : queuedThrallDamage)\n        {\n            damage.offset--;\n        }\n        thrallTracker.updateTick();\n        vengTracker.updateTick();\n        updateRoom();\n        if (inTheatre)\n        {\n            wasInTheatre \u003d true;\n            currentRoom.updateGameTick(event);\n\n            if (currentRoom.isActive())\n            {\n\t\t\t\tSwingUtilities.invokeLater(() -\u003e\n\t\t\t\t\tliveFrame.incrementTick(currentRoom.getName()));\n                int HP_VARBIT \u003d 6448;\n                liveFrame.getPanel(currentRoom.getName()).addRoomHP(client.getTickCount() - currentRoom.roomStartTick, client.getVarbitValue(HP_VARBIT));\n                clog.addLine(UPDATE_HP, String.valueOf(client.getVarbitValue(HP_VARBIT)), String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());\n            }\n\n            if (client.getTickCount() \u003d\u003d deferredTick)\n            {\n                String[] players \u003d {\"\", \"\", \"\", \"\", \"\"};\n                int varcStrID \u003d 330; // Widget for player names\n                for (int i \u003d varcStrID; i \u003c varcStrID + 5; i++)\n                {\n                    if (client.getVarcStrValue(i) !\u003d null \u0026\u0026 !client.getVarcStrValue(i).isEmpty())\n                    {\n                        players[i - varcStrID] \u003d Text.escapeJagex(client.getVarcStrValue(i));\n                    }\n                }\n                for (String s : players)\n                {\n                    if (!s.isEmpty())\n                    {\n                        currentPlayers.add(s.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)));\n                    }\n                }\n                liveFrame.setPlayers(currentPlayers);\n                checkPartyUpdate();\n                boolean flag \u003d false;\n                for (String p : players)\n                {\n                    if (p.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).equals(Objects.requireNonNull(client.getLocalPlayer().getName()).replaceAll(String.valueOf((char) 160), String.valueOf((char) 32))))\n                    {\n                        flag \u003d true;\n                    }\n                }\n                deferredTick \u003d 0;\n                if (!flag)\n                {\n                    clog.addLine(SPECTATE);\n                }\n                clog.addLine(PARTY_MEMBERS, players[0], players[1], players[2], players[3], players[4]);\n                maiden.setScale((int) Arrays.stream(players).filter(x -\u003e !x.isEmpty()).count());\n                scale \u003d currentPlayers.size();\n            }\n        } else\n        {\n            if (wasInTheatre)\n            {\n                leftRaid();\n                wasInTheatre \u003d false;\n                return;\n            }\n        }\n        clog.writeFile();\n    }\n\n    private void checkOverheadTextsThatChanged()\n    {\n        for (String player : playersWhoHaveOverheadText)\n        {\n            for (VengPair vp : playersTextChanged)\n            {\n                if (vp.player.equals(player))\n                {\n                    activeVenges.add(new VengDamageQueue(vp.player, vp.hitsplat, client.getTickCount() + 1));\n                }\n            }\n        }\n        playersWhoHaveOverheadText.clear();\n    }\n\n    private void checkAnimationsThatChanged()\n    {\n        for(Player p : deferredAnimations)\n        {\n            checkAnimation(p);\n        }\n        deferredAnimations.clear();\n    }\n\n    private void checkAnimation(Player p)\n    {\n        if (inTheatre)\n        {\n            if (p.getPlayerComposition() !\u003d null)\n            {\n                int id \u003d p.getPlayerComposition().getEquipmentId(KitType.WEAPON);\n                if (p.getAnimation() \u003d\u003d SCYTHE_ANIMATION)\n                {\n                    if (id \u003d\u003d UNCHARGED_SCYTHE || id \u003d\u003d UNCHARGED_BLOOD_SCYTHE || id \u003d\u003d UNCHARGED_HOLY_SCYTHE)\n                    {\n                        if (config.showMistakesInChat())\n                        {\n                            sendChatMessage(p.getName() + \" is using an uncharged scythe\");\n                        }\n                    }\n                } else if (p.getAnimation() \u003d\u003d BOP_ANIMATION)\n                {\n                    if (id \u003d\u003d DRAGON_WARHAMMER || id \u003d\u003d DRAGON_WARHAMMER_ALTERNATE)\n                    {\n                        if (config.showMistakesInChat())\n                        {\n                            sendChatMessage(p.getName() + \" hammer bopped (bad rng)\");\n                        }\n                        clog.addLine(DWH_BOP, p.getName());\n                    }\n                } else if (p.getAnimation() \u003d\u003d WHACK_ANIMATION)\n                {\n                    if (id \u003d\u003d KODAI_WAND || id \u003d\u003d KODAI_WAND_ALTERNATE)\n                    {\n                        if (config.showMistakesInChat())\n                        {\n                            sendChatMessage(p.getName() + \" kodai bopped (nothing they could\u0027ve done to prevent it)\");\n                        }\n                        clog.addLine(KODAI_BOP, p.getName());\n                    }\n                } else if (p.getAnimation() \u003d\u003d STAB_ANIMATION)\n                {\n                    if (id \u003d\u003d CHALLY)\n                    {\n                        if (config.showMistakesInChat())\n                        {\n                            sendChatMessage(p.getName() + \" chally poked\");\n                        }\n                        clog.addLine(CHALLY_POKE, p.getName());\n                    }\n                } else if (p.getAnimation() \u003d\u003d TWO_HAND_SWORD_SWING)\n                {\n                    if(id \u003d\u003d BANDOS_GODSWORD || id \u003d\u003d BANDOS_GODSWORD_OR)\n                    {\n                        if (config.showMistakesInChat())\n                        {\n                            sendChatMessage(p.getName() + \" swung BGS without speccing\");\n                        }\n                        clog.addLine(BGS_WHACK, p.getName());\n                    }\n                }\n                StringBuilder animations \u003d new StringBuilder();\n                for (ActorSpotAnim anim : p.getSpotAnims())\n                {\n                    animations.append(anim.getId());\n                    animations.append(\":\");\n                }\n                if (p.getAnimation() \u003d\u003d POWERED_STAFF_ANIMATION || p.getAnimation() \u003d\u003d CROSSBOW_ANIMATION)\n                {\n                    if (p.getAnimation() !\u003d POWERED_STAFF_ANIMATION || p.getPlayerComposition().getEquipmentId(KitType.WEAPON) \u003d\u003d DAWNBRINGER_ITEM)\n                    { //Can be ZCB, Sang, or Dawnbringer. We only care about projectile for dawnbringer or ZCB. Sang \u0026 dawnbringer share animation\n                        //so this filters powered staves unless it\u0027s dawnbringer\n                        WorldPoint worldPoint \u003d p.getWorldLocation();\n                        playersAttacked.add(new QueuedPlayerAttackLessProjectiles(p, worldPoint, 1, animations.toString(), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON)), String.valueOf(p.getAnimation())));\n                    }\n                    else\n                    {\n                        int interactedIndex \u003d -1;\n                        int interactedID \u003d -1;\n                        Actor interacted \u003d p.getInteracting();\n                        String targetName \u003d \"\";\n                        if (interacted instanceof NPC)\n                        {\n                            NPC npc \u003d (NPC) interacted;\n                            interactedID \u003d npc.getId();\n                            interactedIndex \u003d npc.getIndex();\n                            targetName \u003d npc.getName();\n                        }\n                        generatePlayerAttackInfo(p, animations.toString(), interactedIndex, interactedID, interacted, targetName);\n                    }\n                }\n                else if (p.getAnimation() !\u003d -1)\n                {\n                    int interactedIndex \u003d -1;\n                    int interactedID \u003d -1;\n                    Actor interacted \u003d p.getInteracting();\n                    String targetName \u003d \"\";\n                    if (interacted instanceof NPC)\n                    {\n                        NPC npc \u003d (NPC) interacted;\n                        interactedID \u003d npc.getId();\n                        interactedIndex \u003d npc.getIndex();\n                    }\n                    generatePlayerAttackInfo(p, animations.toString(), interactedIndex, interactedID, interacted, targetName);\n                    if (p.getAnimation() \u003d\u003d BLOWPIPE_ANIMATION || p.getAnimation() \u003d\u003d BLOWPIPE_ANIMATION_OR)\n                    {\n                        activelyPiping.put(p, client.getTickCount());\n                        interactedIndex \u003d -1;\n                        interactedID \u003d -1;\n                        targetName \u003d \"\";\n                        interacted \u003d p.getInteracting();\n                        if (interacted instanceof NPC)\n                        {\n                            NPC npc \u003d (NPC) interacted;\n                            interactedID \u003d npc.getId();\n                            interactedIndex \u003d npc.getIndex();\n                            targetName \u003d npc.getName();\n                        }\n                        if (interacted instanceof Player)\n                        {\n                            Player player \u003d (Player) interacted;\n                            targetName \u003d player.getName();\n                        }\n                        lastTickPlayer.put(p.getName(), new PlayerCopy(\n                                p.getName(), interactedIndex, interactedID, targetName, p.getAnimation(), PlayerWornItems.getStringFromComposition(p.getPlayerComposition()\n                        ), String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON))));\n                    }\n                    else\n                    {\n                        activelyPiping.remove(p);\n                        lastTickPlayer.remove(p.getName());\n                    }\n                }\n                else\n                {\n                    activelyPiping.remove(p);\n                    lastTickPlayer.remove(p.getName());\n                }\n\n            }\n        }\n    }\n\n    public void leftRaid()\n    {\n        lastTickPlayer.clear();\n        partyIntact \u003d false;\n        currentPlayers.clear();\n        clog.addLine(LEFT_TOB, String.valueOf(client.getTickCount() - currentRoom.roomStartTick), currentRoom.getName());\n        clog.writeFile();\n        clog.migrateToNewRaid();\n        currentRoom \u003d null;\n        activelyPiping.clear();\n        deferredAnimations.clear();\n    }\n\n    @Subscribe\n    public void onActorDeath(ActorDeath event)\n    {\n        if (inTheatre)\n        {\n            Actor a \u003d event.getActor();\n            if (a instanceof Player)\n            {\n                clog.addLine(PLAYER_DIED, event.getActor().getName(), String.valueOf(client.getTickCount() - currentRoom.roomStartTick));\n            }\n        }\n    }\n\n    @Subscribe\n    public void onGroundObjectSpawned(GroundObjectSpawned event)\n    {\n        if(inTheatre)\n        {\n            currentRoom.updateGroundObjectSpawned(event);\n        }\n    }\n\n    @Subscribe\n    public void onGraphicChanged(GraphicChanged event)\n    {\n        if (event.getActor() instanceof Player)\n        {\n            int id \u003d -1;\n            if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_MAGE))\n            {\n                id \u003d THRALL_CAST_GRAPHIC_MAGE;\n            } else if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_MELEE))\n            {\n                id \u003d THRALL_CAST_GRAPHIC_MELEE;\n            } else if (event.getActor().hasSpotAnim(THRALL_CAST_GRAPHIC_RANGE))\n            {\n                id \u003d THRALL_CAST_GRAPHIC_RANGE;\n            } else if (event.getActor().hasSpotAnim(VENG_GRAPHIC))\n            {\n                vengTracker.vengSelfGraphicApplied((Player) event.getActor());\n            } else if (event.getActor().hasSpotAnim(VENG_OTHER_GRAPHIC))\n            {\n                vengTracker.vengOtherGraphicApplied((Player) event.getActor());\n            }\n            if (id !\u003d -1)\n            {\n                thrallTracker.playerHasThrallCastSpotAnim((Player) event.getActor(), id);\n            }\n\n        }\n        if (inTheatre)\n        {\n            currentRoom.updateGraphicChanged(event);\n        }\n    }\n\n    @Subscribe\n    public void onGraphicsObjectCreated(GraphicsObjectCreated event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.updateGraphicsObjectCreated(event);\n        }\n    }\n\n    @Subscribe\n    public void onGameObjectSpawned(GameObjectSpawned event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.updateGameObjectSpawned(event);\n        }\n    }\n\n    @Subscribe\n    public void onGameObjectDespawned(GameObjectDespawned event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.updateGameObjectDespawned(event);\n        }\n    }\n\n    @Subscribe\n    public void onItemSpawned(ItemSpawned event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.updateItemSpawned(event);\n        }\n    }\n\n    @Subscribe\n    public void onProjectileMoved(ProjectileMoved event)\n    {\n        if (inTheatre)\n        {\n            int id \u003d event.getProjectile().getId();\n            if (id \u003d\u003d THRALL_PROJECTILE_RANGE || id \u003d\u003d THRALL_PROJECTILE_MAGE)\n            {\n                if (event.getProjectile().getStartCycle() \u003d\u003d client.getGameCycle())\n                {\n                    thrallTracker.projectileCreated(event.getProjectile(), WorldPoint.fromLocal(client, new LocalPoint(event.getProjectile().getX1(), event.getProjectile().getY1())));\n                }\n            }\n            //Thrall hitsplats come before damage hitsplits unless the source is a projectile that was spawned on a tick before the thrall projectile spawned\n            else if (event.getProjectile().getStartCycle() \u003d\u003d client.getGameCycle())\n            { //Thrall projectiles move slower and the only time this situation occurs in TOB is max distance TBOW/ZCB during maiden\n                if (id \u003d\u003d TBOW_PROJECTILE || id \u003d\u003d ZCB_PROJECTILE || id \u003d\u003d ZCB_SPEC_PROJECTILE)\n                { //Not sure why 10 is correct instead of 19 (60 - 41 tick delay) but extensive trial and error shows this to be accurate\n                    int projectileHitTick \u003d 10 + event.getProjectile().getRemainingCycles();\n                    projectileHitTick \u003d (projectileHitTick / 30);\n                    if (event.getProjectile().getInteracting() instanceof NPC)\n                    {\n                        int index \u003d ((NPC) event.getProjectile().getInteracting()).getIndex();\n                        activeProjectiles.add(new ProjectileQueue(client.getTickCount(), projectileHitTick + client.getTickCount(), index));\n                    }\n                }\n            }\n            if (inTheatre)\n            {\n                currentRoom.updateProjectileMoved(event);\n            }\n        }\n    }\n\n    public void sendChatMessage(String msg)\n    {\n        clientThread.invoke(() -\u003e client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", msg, null, false));\n    }\n\n    private final ArrayList\u003cPlayer\u003e deferredAnimations \u003d new ArrayList\u003c\u003e();\n\n    @Subscribe\n    public void onConfigChanged(ConfigChanged event)\n    {\n        if(event.getGroup().equals(\"Advanced Raid Tracker\") \u0026\u0026 event.getKey().contains(\"primary\"))\n        {\n            liveFrame.redrawAll();\n        }\n    }\n\n    @Subscribe\n    public void onAnimationChanged(AnimationChanged event)\n    {\n        if(event.getActor() instanceof Player)\n        {\n            Player p \u003d (Player) event.getActor();\n            if(event.getActor().getAnimation() \u003d\u003d 6294 || event.getActor().getAnimation() \u003d\u003d 722 || event.getActor().getAnimation() \u003d\u003d 6299 || event.getActor().getAnimation() \u003d\u003d -1)\n            {\n                checkAnimation(p);\n            }\n            else\n            {\n                deferredAnimations.add(p);\n            }\n        }\n        if (inTheatre)\n        {\n            int id \u003d event.getActor().getAnimation();\n            if (event.getActor().getAnimation() \u003d\u003d THRALL_CAST_ANIMATION)\n            {\n                thrallTracker.castThrallAnimation((Player) event.getActor());\n            } else if (event.getActor().getAnimation() \u003d\u003d MELEE_THRALL_ATTACK_ANIMATION \u0026\u0026 event.getActor() instanceof NPC)\n            {\n                thrallTracker.meleeThrallAttacked((NPC) event.getActor());\n            } else if (event.getActor().getAnimation() \u003d\u003d VENG_CAST)\n            {\n                vengTracker.vengSelfCast((Player) event.getActor());\n            } else if (event.getActor().getAnimation() \u003d\u003d VENG_OTHER_CAST)\n            {\n                vengTracker.vengOtherCast((Player) event.getActor());\n            } else if (id \u003d\u003d DWH_SPEC)\n            {\n                clog.addLine(HAMMER_ATTEMPTED, event.getActor().getName());\n            } else if (event.getActor().getName() !\u003d null \u0026\u0026 event.getActor().getName().contains(\"Maiden\") \u0026\u0026 id \u003d\u003d MAIDEN_BLOOD_THROW_ANIM)\n            {\n                clog.addLine(BLOOD_THROWN);\n            }\n            if (inTheatre)\n            {\n                currentRoom.updateAnimationChanged(event);\n            }\n        }\n    }\n\n    private void generatePlayerAttackInfo(Player p, String animations, int interactedIndex, int interactedID, Actor interacted, String targetName)\n    {\n        if (interacted instanceof Player)\n        {\n            Player player \u003d (Player) interacted;\n            targetName \u003d player.getName();\n        }\n        clog.addLine(PLAYER_ATTACK,\n                p.getName() + \":\" + (client.getTickCount() - currentRoom.roomStartTick),\n                p.getAnimation()+\":\"+PlayerWornItems.getStringFromComposition(p.getPlayerComposition()),\n                animations,\n                p.getPlayerComposition().getEquipmentId(KitType.WEAPON) + \":\" + interactedIndex + \":\" + interactedID,\n                \"-1:\" + targetName);\n        liveFrame.addAttack(new PlayerDidAttack(itemManager,\n                String.valueOf(p.getName()),\n                String.valueOf(p.getAnimation()),\n                0,\n                String.valueOf(p.getPlayerComposition().getEquipmentId(KitType.WEAPON)),\n                \"-1\",\n                animations,\n                interactedIndex,\n                interactedID,\n                targetName,\n                PlayerWornItems.getStringFromComposition(p.getPlayerComposition())\n        ), currentRoom.getName());\n    }\n\n    @Subscribe\n    public void onInteractingChanged(InteractingChanged event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.updateInteractingChanged(event);\n        }\n    }\n\n    @Subscribe\n    public void onNpcChanged(NpcChanged event)\n    {\n        if (inTheatre)\n        {\n            currentRoom.handleNPCChanged(event.getNpc().getId());\n        }\n    }\n\n    private void handleThrallSpawn(NPC npc)\n    {\n        ArrayList\u003cPlayerShell\u003e potentialPlayers \u003d new ArrayList\u003c\u003e();\n        for (PlayerShell p : localPlayers)\n        {\n            if (p.worldLocation.distanceTo(npc.getWorldLocation()) \u003d\u003d 1)\n            {\n                potentialPlayers.add(p);\n            }\n        }\n        thrallTracker.thrallSpawned(npc, potentialPlayers);\n    }\n\n    @Subscribe\n    public void onNpcSpawned(NpcSpawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d MELEE_THRALL || id \u003d\u003d RANGE_THRALL || id \u003d\u003d MAGE_THRALL)\n        {\n            handleThrallSpawn(event.getNpc());\n        }\n        switch (event.getNpc().getId())\n        {\n            case TobIDs.MAIDEN_P0:\n            case TobIDs.MAIDEN_P1:\n            case TobIDs.MAIDEN_P2:\n            case TobIDs.MAIDEN_P3:\n            case TobIDs.MAIDEN_PRE_DEAD:\n            case TobIDs.MAIDEN_DEAD:\n            case TobIDs.MAIDEN_MATOMENOS:\n            case TobIDs.MAIDEN_P0_HM:\n            case TobIDs.MAIDEN_P1_HM:\n            case TobIDs.MAIDEN_P2_HM:\n            case TobIDs.MAIDEN_P3_HM:\n            case TobIDs.MAIDEN_PRE_DEAD_HM:\n            case TobIDs.MAIDEN_DEAD_HM:\n            case TobIDs.MAIDEN_MATOMENOS_HM:\n            case TobIDs.MAIDEN_P0_SM:\n            case TobIDs.MAIDEN_P1_SM:\n            case TobIDs.MAIDEN_P2_SM:\n            case TobIDs.MAIDEN_P3_SM:\n            case TobIDs.MAIDEN_PRE_DEAD_SM:\n            case TobIDs.MAIDEN_DEAD_SM:\n            case TobIDs.MAIDEN_MATOMENOS_SM:\n            case TobIDs.MAIDEN_BLOOD:\n            case TobIDs.MAIDEN_BLOOD_HM:\n            case TobIDs.MAIDEN_BLOOD_SM:\n            {\n                maiden.updateNpcSpawned(event);\n            }\n            break;\n            case TobIDs.BLOAT:\n            case TobIDs.BLOAT_HM:\n            case TobIDs.BLOAT_SM:\n                bloat.updateNpcSpawned(event);\n                break;\n            case TobIDs.NYLO_MELEE_SMALL:\n            case TobIDs.NYLO_MELEE_SMALL_AGRO:\n            case TobIDs.NYLO_RANGE_SMALL:\n            case TobIDs.NYLO_RANGE_SMALL_AGRO:\n            case TobIDs.NYLO_MAGE_SMALL:\n            case TobIDs.NYLO_MAGE_SMALL_AGRO:\n            case TobIDs.NYLO_MELEE_BIG:\n            case TobIDs.NYLO_MELEE_BIG_AGRO:\n            case TobIDs.NYLO_RANGE_BIG:\n            case TobIDs.NYLO_RANGE_BIG_AGRO:\n            case TobIDs.NYLO_MAGE_BIG:\n            case TobIDs.NYLO_MAGE_BIG_AGRO:\n            case TobIDs.NYLO_MELEE_SMALL_HM:\n            case TobIDs.NYLO_MELEE_SMALL_AGRO_HM:\n            case TobIDs.NYLO_RANGE_SMALL_HM:\n            case TobIDs.NYLO_RANGE_SMALL_AGRO_HM:\n            case TobIDs.NYLO_MAGE_SMALL_HM:\n            case TobIDs.NYLO_MAGE_SMALL_AGRO_HM:\n            case TobIDs.NYLO_MELEE_BIG_HM:\n            case TobIDs.NYLO_MELEE_BIG_AGRO_HM:\n            case TobIDs.NYLO_RANGE_BIG_HM:\n            case TobIDs.NYLO_RANGE_BIG_AGRO_HM:\n            case TobIDs.NYLO_MAGE_BIG_HM:\n            case TobIDs.NYLO_MAGE_BIG_AGRO_HM:\n            case TobIDs.NYLO_MELEE_SMALL_SM:\n            case TobIDs.NYLO_MELEE_SMALL_AGRO_SM:\n            case TobIDs.NYLO_RANGE_SMALL_SM:\n            case TobIDs.NYLO_RANGE_SMALL_AGRO_SM:\n            case TobIDs.NYLO_MAGE_SMALL_SM:\n            case TobIDs.NYLO_MAGE_SMALL_AGRO_SM:\n            case TobIDs.NYLO_MELEE_BIG_SM:\n            case TobIDs.NYLO_MELEE_BIG_AGRO_SM:\n            case TobIDs.NYLO_RANGE_BIG_SM:\n            case TobIDs.NYLO_RANGE_BIG_AGRO_SM:\n            case TobIDs.NYLO_MAGE_BIG_SM:\n            case TobIDs.NYLO_MAGE_BIG_AGRO_SM:\n            case TobIDs.NYLO_BOSS_DROPPING:\n            case TobIDs.NYLO_BOSS_DROPPING_HM:\n            case TobIDs.NYLO_BOSS_DROPING_SM:\n            case TobIDs.NYLO_BOSS_MELEE:\n            case TobIDs.NYLO_BOSS_MELEE_HM:\n            case TobIDs.NYLO_BOSS_MELEE_SM:\n            case TobIDs.NYLO_BOSS_MAGE:\n            case TobIDs.NYLO_BOSS_MAGE_HM:\n            case TobIDs.NYLO_BOSS_MAGE_SM:\n            case TobIDs.NYLO_BOSS_RANGE:\n            case TobIDs.NYLO_BOSS_RANGE_HM:\n            case TobIDs.NYLO_BOSS_RANGE_SM:\n            case TobIDs.NYLO_PRINKIPAS_DROPPING:\n            case TobIDs.NYLO_PRINKIPAS_MELEE:\n            case TobIDs.NYLO_PRINKIPAS_MAGIC:\n            case TobIDs.NYLO_PRINKIPAS_RANGE:\n                nylo.updateNpcSpawned(event);\n                break;\n            case TobIDs.SOTETSEG_ACTIVE:\n            case TobIDs.SOTETSEG_ACTIVE_HM:\n            case TobIDs.SOTETSEG_ACTIVE_SM:\n            case TobIDs.SOTETSEG_INACTIVE:\n            case TobIDs.SOTETSEG_INACTIVE_HM:\n            case TobIDs.SOTETSEG_INACTIVE_SM:\n                sote.updateNpcSpawned(event);\n                break;\n            case TobIDs.XARPUS_INACTIVE:\n            case TobIDs.XARPUS_P1:\n            case TobIDs.XARPUS_P23:\n            case TobIDs.XARPUS_DEAD:\n            case TobIDs.XARPUS_INACTIVE_HM:\n            case TobIDs.XARPUS_P1_HM:\n            case TobIDs.XARPUS_P23_HM:\n            case TobIDs.XARPUS_DEAD_HM:\n            case TobIDs.XARPUS_INACTIVE_SM:\n            case TobIDs.XARPUS_P1_SM:\n            case TobIDs.XARPUS_P23_SM:\n            case TobIDs.XARPUS_DEAD_SM:\n                xarpus.updateNpcSpawned(event);\n                break;\n            case TobIDs.VERZIK_P1_INACTIVE:\n            case TobIDs.VERZIK_P1:\n            case TobIDs.VERZIK_P2_INACTIVE:\n            case TobIDs.VERZIK_P2:\n            case TobIDs.VERZIK_P3_INACTIVE:\n            case TobIDs.VERZIK_P3:\n            case TobIDs.VERZIK_DEAD:\n            case TobIDs.VERZIK_P1_INACTIVE_HM:\n            case TobIDs.VERZIK_P1_HM:\n            case TobIDs.VERZIK_P2_INACTIVE_HM:\n            case TobIDs.VERZIK_P2_HM:\n            case TobIDs.VERZIK_P3_INACTIVE_HM:\n            case TobIDs.VERZIK_P3_HM:\n            case TobIDs.VERZIK_DEAD_HM:\n            case TobIDs.VERZIK_P1_INACTIVE_SM:\n            case TobIDs.VERZIK_P1_SM:\n            case TobIDs.VERZIK_P2_INACTIVE_SM:\n            case TobIDs.VERZIK_P2_SM:\n            case TobIDs.VERZIK_P3_INACTIVE_SM:\n            case TobIDs.VERZIK_P3_SM:\n            case TobIDs.VERZIK_DEAD_SM:\n                verzik.updateNpcSpawned(event);\n                break;\n            default:\n                if (currentRoom !\u003d null)\n                {\n                    currentRoom.updateNpcSpawned(event);\n                }\n                break;\n        }\n    }\n\n    @Subscribe\n    public void onNpcDespawned(NpcDespawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d MELEE_THRALL || id \u003d\u003d RANGE_THRALL || id \u003d\u003d MAGE_THRALL)\n        {\n            thrallTracker.removeThrall(event.getNpc());\n        }\n        if (inTheatre)\n        {\n            currentRoom.updateNpcDespawned(event);\n        }\n    }\n\n    @Subscribe\n    public void onHitsplatApplied(HitsplatApplied event)\n    {\n        if (inTheatre)\n        {\n            if (event.getActor() instanceof Player \u0026\u0026 inTheatre)\n            {\n                playersTextChanged.add(new VengPair(event.getActor().getName(), event.getHitsplat().getAmount()));\n            }\n            queuedThrallDamage.sort(Comparator.comparing(DamageQueueShell::getSourceIndex));\n            int index \u003d -1;\n            if (event.getActor() instanceof NPC \u0026\u0026 event.getHitsplat().getHitsplatType() !\u003d HitsplatID.HEAL)\n            {\n                for (int i \u003d 0; i \u003c queuedThrallDamage.size(); i++)\n                {\n                    int altIndex \u003d 0;\n                    int matchedIndex \u003d -1;\n                    boolean postponeThrallHit \u003d false;\n                    for (ProjectileQueue projectile : activeProjectiles)\n                    {\n                        if (projectile.targetIndex \u003d\u003d ((NPC) event.getActor()).getIndex())\n                        {\n                            if (client.getTickCount() \u003d\u003d projectile.finalTick)\n                            {\n                                if (projectile.originTick \u003c queuedThrallDamage.get(i).originTick)\n                                {\n                                    postponeThrallHit \u003d true;\n                                    matchedIndex \u003d altIndex;\n                                }\n                            }\n                        }\n                        altIndex++;\n                    }\n                    if (queuedThrallDamage.get(i).offset \u003d\u003d 0 \u0026\u0026 queuedThrallDamage.get(i).targetIndex \u003d\u003d ((NPC) event.getActor()).getIndex())\n                    {\n                        if (postponeThrallHit)\n                        {\n                            activeProjectiles.remove(matchedIndex);\n                        } else\n                        {\n                            if (event.getHitsplat().getAmount() \u003c\u003d 3)\n                            {\n                                index \u003d i;\n                                clog.addLine(THRALL_DAMAGED, queuedThrallDamage.get(i).source, String.valueOf(event.getHitsplat().getAmount()));\n\n                            }\n                        }\n                        if (index !\u003d -1)\n                        {\n                            queuedThrallDamage.remove(index);\n                        }\n                        if (inTheatre)\n                        {\n                            currentRoom.updateHitsplatApplied(event);\n                        }\n                        return;\n                    }\n                }\n                for (VengDamageQueue veng : activeVenges)\n                {\n                    int expectedDamage \u003d (int) (0.75 * veng.damage);\n                    if (event.getHitsplat().getAmount() \u003d\u003d expectedDamage)\n                    {\n                        //todo can be wrong if splat would overkill\n                        clog.addLine(VENG_WAS_PROCCED, veng.target, String.valueOf(expectedDamage));\n                        if (inTheatre)\n                        {\n                            currentRoom.updateHitsplatApplied(event);\n                        }\n                        return;\n                    }\n                }\n            }\n\n            if (inTheatre)\n            {\n                currentRoom.updateHitsplatApplied(event);\n            }\n        }\n    }\n\n\n    private ArrayList\u003cVengPair\u003e playersTextChanged;\n\n    private final ArrayList\u003cString\u003e playersWhoHaveOverheadText \u003d new ArrayList\u003c\u003e();\n\n    @Subscribe\n    public void onOverheadTextChanged(OverheadTextChanged event)\n    {\n        if (inTheatre)\n        {\n            if (event.getOverheadText().equals(\"Taste vengeance!\"))\n            {\n                playersWhoHaveOverheadText.add(event.getActor().getName());\n            }\n            if (currentRoom instanceof XarpusHandler)\n            {\n                xarpus.updateOverheadText(event);\n            }\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\AdvancedRaidTrackerPlugin.java"},{"fileName":"AdvancedTOBData.java","content":"package com.advancedraidtracker;\n\nimport com.advancedraidtracker.constants.LogID;\nimport com.advancedraidtracker.utility.wrappers.PlayerDidAttack;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.game.ItemManager;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\nimport static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;\nimport static com.advancedraidtracker.constants.TobIDs.SPECTATE_FLAG;\n\n@Slf4j\npublic class AdvancedTOBData\n{\n    public final ArrayList\u003cPlayerDidAttack\u003e maidenAttacks \u003d new ArrayList\u003c\u003e();\n    public final ArrayList\u003cPlayerDidAttack\u003e bloatAttacks \u003d new ArrayList\u003c\u003e();\n    public final ArrayList\u003cPlayerDidAttack\u003e nyloAttacks \u003d new ArrayList\u003c\u003e();\n    public final ArrayList\u003cPlayerDidAttack\u003e soteAttacks \u003d new ArrayList\u003c\u003e();\n    public final ArrayList\u003cPlayerDidAttack\u003e xarpAttacks \u003d new ArrayList\u003c\u003e();\n    public final ArrayList\u003cPlayerDidAttack\u003e verzikAttacks \u003d new ArrayList\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e maidenHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e bloatHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e nyloHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e soteHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e xarpHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e verzikHP \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, String\u003e maidenNPCMapping \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, String\u003e nyloNPCMapping \u003d new HashMap\u003c\u003e();\n    public Map\u003cInteger, String\u003e verzikNPCMapping \u003d new HashMap\u003c\u003e();\n    private ArrayList\u003cString\u003e globalData;\n    private final ItemManager itemManager;\n\n    public static ArrayList\u003cString\u003e getRaidStrings(String path)\n    {\n        ArrayList\u003cString\u003e lines \u003d new ArrayList\u003c\u003e();\n        File file \u003d new File(path);\n        try\n        {\n            Scanner scanner \u003d new Scanner(Files.newInputStream(file.toPath()));\n            while(scanner.hasNextLine())\n            {\n                lines.add(scanner.nextLine());\n            }\n        }\n        catch(Exception ignored)\n        {\n\n        }\n        return lines;\n    }\n    public AdvancedTOBData(ArrayList\u003cString\u003e globalData, ItemManager itemManager)\n    {\n        this.itemManager \u003d itemManager;\n        this.globalData \u003d globalData;\n        int room \u003d -1;\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\");\n            int key \u003d Integer.parseInt(subData[3]);\n            if (key \u003d\u003d SPECTATE_FLAG)\n            {\n                room \u003d Integer.parseInt(subData[4]);\n            }\n        }\n        if (room \u003e 0)\n        {\n            switch (room)\n            {\n                case 1:\n                    if (!(checkExit() \u0026\u0026 parseBloat()))\n                        break;\n                case 2:\n                    if (!(checkExit() \u0026\u0026 parseNylo()))\n                        break;\n                case 3:\n                    if (!(checkExit() \u0026\u0026 parseSotetseg()))\n                        break;\n                case 4:\n                    if (!(checkExit() \u0026\u0026 parseXarpus()))\n                        break;\n                case 5:\n                    if (checkExit())\n                    {\n                        parseVerzik();\n                    }\n            }\n        } else\n        {\n            try\n            {\n                if (parseMaiden())\n                {\n                    if (checkExit() \u0026\u0026 parseBloat())\n                    {\n                        if (checkExit() \u0026\u0026 parseNylo())\n                        {\n                            if (checkExit() \u0026\u0026 parseSotetseg())\n                            {\n                                if (checkExit() \u0026\u0026 parseXarpus())\n                                {\n                                    if (checkExit())\n                                    {\n                                        parseVerzik();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (Exception ignored)\n            {\n            }\n        }\n    }\n\n    PlayerDidAttack getPlayerDidAttack(String[] subData)\n    {\n        String player \u003d subData[4].split(\":\")[0];\n        int tick \u003d Integer.parseInt(subData[4].split(\":\")[1]);\n        String wornItems \u003d \"\";\n        String [] animationAndWorn \u003d subData[5].split(\":\");\n        String animation \u003d animationAndWorn[0];\n        if(animationAndWorn.length \u003d\u003d 2)\n        {\n            wornItems \u003d animationAndWorn[1];\n        }\n        String spotAnims \u003d subData[6];\n        String[] subsubData \u003d subData[7].split(\":\");\n        String weapon \u003d subsubData[0];\n        int interactedIndex \u003d -1;\n        int interactedID \u003d -1;\n        if (subsubData.length \u003e 2)\n        {\n            interactedIndex \u003d Integer.parseInt(subsubData[1]);\n            interactedID \u003d Integer.parseInt(subsubData[2]);\n        }\n        String[] projectileAndTargetData \u003d subData[8].split(\":\");\n        String projectile \u003d projectileAndTargetData[0];\n        String targetName \u003d \"\";\n        if (projectileAndTargetData.length \u003e 1)\n        {\n            targetName \u003d projectileAndTargetData[1];\n        }\n        return (new PlayerDidAttack(itemManager, player, animation, tick, weapon, projectile, spotAnims, interactedIndex, interactedID, targetName, wornItems));\n    }\n\n    private boolean parseMaiden()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return false;\n                    case MAIDEN_0HP:\n                    case BLOAT_SPAWNED:\n                    case MAIDEN_DESPAWNED:\n                        break loop;\n                    case PLAYER_ATTACK:\n                        maidenAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        maidenHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                    case ADD_NPC_MAPPING:\n                        maidenNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);\n                        break;\n                }\n            }\n            catch(Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseBloat()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return false;\n                    case BLOAT_DESPAWN:\n                        break loop;\n                    case PLAYER_ATTACK:\n                        bloatAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        bloatHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                }\n            }\n            catch(Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseNylo()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return false;\n                    case NYLO_DESPAWNED:\n                        break loop;\n                    case PLAYER_ATTACK:\n                        nyloAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        nyloHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                    case ADD_NPC_MAPPING:\n                        nyloNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);\n                        break;\n                }\n            }\n            catch(Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseSotetseg()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return false;\n                    case SOTETSEG_ENDED:\n                        break loop;\n                    case PLAYER_ATTACK:\n                        soteAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        soteHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n\n                }\n            }\n            catch(Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseXarpus()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return false;\n                    case XARPUS_DESPAWNED:\n                        break loop;\n                    case PLAYER_ATTACK:\n                        xarpAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        xarpHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                }\n            }\n            catch(Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private void parseVerzik()\n    {\n        int activeIndex \u003d 0;\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        return;\n                    case PLAYER_ATTACK:\n                        verzikAttacks.add(getPlayerDidAttack(subData));\n                        break;\n                    case UPDATE_HP:\n                        verzikHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                    case ADD_NPC_MAPPING:\n                        verzikNPCMapping.put(Integer.parseInt(subData[4]), subData[5]);\n                        break;\n                    case VERZIK_BOUNCE:\n                        if (!subData[5].equalsIgnoreCase(\"\"))\n                        { //use fake animation ID when bounce occurs\n                            verzikAttacks.add(new PlayerDidAttack(itemManager, subData[4], \"100000\", Integer.parseInt(subData[5]), \"-1\", \"-1\", \"-1\", -1, -1, \"\", \"\"));\n                        }\n                        break;\n\n                }\n            } catch (Exception ignored)\n            {\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n    }\n\n    public boolean checkExit()\n    {\n        return !(globalData.isEmpty() || globalData.get(0).split(\",\", -1)[3].equals(EXIT_FLAG));\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\AdvancedTOBData.java"},{"fileName":"LogID.java","content":"package com.advancedraidtracker.constants;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.Optional;\n\nimport static com.advancedraidtracker.constants.TOBRoom.*;\n\n/**\n * Convenience class for the possible keys used to log events. The parameters each of these events should include can be found in\n * RoomData.\n */\n@Getter\npublic enum LogID\n{\n    ENTERED_TOB(0, true, ANY, \"Entered TOB\"),\n    PARTY_MEMBERS(1, true, ANY, \"Party Members\"),\n    DWH(2, true, ANY,\"DWH Hit\"),\n    BGS(3, true, ANY,\"BGS Hit\"),\n    LEFT_TOB(4, true, ANY,\"Left TOB\"),\n    PLAYER_DIED(5, true, ANY,\"Played Died\"),\n    ENTERED_NEW_TOB_REGION(6, true, ANY,\"Entered New TOB Region\"),\n    HAMMER_ATTEMPTED(7, true, ANY,\"DWH Attempted\"),\n    DAWN_DROPPED(800, false, VERZIK,\"Dawnbringer appeared\"),\n    WEBS_STARTED(901, false, VERZIK,\"Webs Thrown\"),\n    PLAYER_ATTACK(801, false, ANY,\"Player Animation\"),\n    BLOOD_THROWN(9, true, MAIDEN,\"Maiden blood thrown\"),\n    BLOOD_SPAWNED(10, true, MAIDEN, \"Blood Spawned\"),\n    CRAB_LEAK(11, true, MAIDEN, \"Crab Leaked\"),\n    MAIDEN_SPAWNED(12, true, MAIDEN, \"Spawned\"),\n    MAIDEN_70S(13, true, MAIDEN, \"70s\"),\n    MAIDEN_50S(14, true, MAIDEN, \"50s\"),\n    MAIDEN_30S(15, true, MAIDEN, \"30s\"),\n    MAIDEN_0HP(16, true, MAIDEN, \"0 HP\"),\n    MAIDEN_DESPAWNED(17, true, MAIDEN, \"Despawned\"),\n    MATOMENOS_SPAWNED(18, true, MAIDEN, \"Crab Spawned\"),\n    MAIDEN_SCUFFED(19, true, MAIDEN, \"Scuffed\"),\n    BLOAT_SPAWNED(20, true, BLOAT, \"Spawned\"),\n    BLOAT_DOWN(21, true, BLOAT, \"Down\"),\n    BLOAT_0HP(22, true, BLOAT, \"0 HP\"),\n    BLOAT_DESPAWN(23, true, BLOAT, \"Despawned\"),\n    BLOAT_HP_1ST_DOWN(24, true, BLOAT, \"HP at First Down\"),\n    BLOAT_SCYTHE_1ST_WALK(25, true, BLOAT, \"First Walk Scythes\"),\n\n    NYLO_PILLAR_SPAWN(30, true, NYLOCAS, \"Pillar Spawn\"),\n    NYLO_STALL(31, true, NYLOCAS, \"Stall\"),\n    RANGE_SPLIT(32, true, NYLOCAS, \"Range Split\"),\n    MAGE_SPLIT(33, true, NYLOCAS, \"Mage Split\"),\n    MELEE_SPLIT(34, true, NYLOCAS, \"Melee Split\"),\n    LAST_WAVE(35, true, NYLOCAS, \"Last Wave\"),\n    LAST_DEAD(36, true, NYLOCAS, \"Last Dead\"),\n    NYLO_WAVE(37, true, NYLOCAS, \"Wave\"),\n    BOSS_SPAWN(40, true, NYLOCAS, \"Boss Spawn\"),\n    MELEE_PHASE(41, true, NYLOCAS, \"Melee Phase\"),\n    MAGE_PHASE(42, true, NYLOCAS, \"Mage Phase\"),\n    RANGE_PHASE(43, true, NYLOCAS, \"Range Phase\"),\n    NYLO_0HP(44, true, NYLOCAS, \"0 HP\"),\n    NYLO_DESPAWNED(45, true, NYLOCAS, \"Despawn\"),\n    NYLO_PILLAR_DESPAWNED(46, true, NYLOCAS, \"Pillar Despawn\"), //tick\n    SOTETSEG_STARTED(51, true, SOTETSEG, \"Started\"),\n    SOTETSEG_FIRST_MAZE_STARTED(52, true, SOTETSEG, \"First Maze Start\"),\n    SOTETSEG_FIRST_MAZE_ENDED(53, true, SOTETSEG, \"First Maze End\"),\n    SOTETSEG_SECOND_MAZE_STARTED(54, true, SOTETSEG, \"Second Maze Start\"),\n    SOTETSEG_SECOND_MAZE_ENDED(55, true, SOTETSEG, \"Second Maze End\"),\n    SOTETSEG_ENDED(57, true, SOTETSEG, \"Room End\"),\n    XARPUS_SPAWNED(60, true, XARPUS, \"Spawned\"),\n    XARPUS_STARTED(61, true, XARPUS, \"Started\"),\n    XARPUS_HEAL(62, true, XARPUS, \"Heal\"),\n    XARPUS_SCREECH(63, true, XARPUS, \"Screech\"),\n    XARPUS_0HP(64, true, XARPUS, \"0 HP\"),\n    XARPUS_DESPAWNED(65, true, XARPUS, \"Despawned\"),\n    VERZIK_SPAWNED(70, true, VERZIK, \"Spawned\"),\n    VERZIK_P1_START(71, true, VERZIK, \"P1 Start\"),\n    VERZIK_P1_0HP(72, true, VERZIK, \"P1 0 HP\"),\n    VERZIK_P1_DESPAWNED(73, true, VERZIK, \"P1 Despawned\"),\n    VERZIK_P2_END(74, true, VERZIK, \"P2 End\"),\n    VERZIK_P3_0HP(75, true, VERZIK, \"P2 0 HP\"),\n    VERZIK_P3_DESPAWNED(76, true, VERZIK, \"P3 Despawned\"),\n    VERZIK_BOUNCE(77, true, VERZIK, \"Bounce\"),\n    VERZIK_CRAB_SPAWNED(78, true, VERZIK, \"Crab Spawned\"),\n    VERZIK_P2_REDS_PROC(80, true, VERZIK, \"Reds Proc\"),\n\n    LATE_START(98, true, ANY, \"Joined Raid After Start\"),\n    SPECTATE(99, true, ANY, \"Is Spectating\"),\n    NOT_118(998, true, ANY, \"Not 118\"),\n    NO_PIETY(999, true, ANY, \"No Piety\"),\n    RANDOM_TRACKER(1000, true, ANY, \"Random Tracker\"),\n    RANDOM_TRACKER_2(1001, true, ANY, \"Random Tracker2\"),\n    BLOAT_HAND(975, false, BLOAT, \"Bloat Hand\"),\n    BLOAT_DIRECTION(976, false, BLOAT, \"Bloat Direction\"),\n\n    PARTY_COMPLETE(100, true, ANY, \"Party Is Complete\"),\n    PARTY_INCOMPLETE(101, true, ANY, \"Party Is Not Complete\"),\n    PARTY_ACCURATE_PREMAIDEN(102, true, ANY, \"Party Is Complete Prior To Maiden\"),\n\n    MAIDEN_DINHS_SPEC(111, true, MAIDEN, \"Dinhs Spec\"), //Player, tick, primary target:primary target hp, targets~hp:,stats:stats\n    MAIDEN_DINHS_TARGET(112, true, MAIDEN, \"Dinhs Target\"), //\n\n    MAIDEN_CHIN_THROWN(113, true, MAIDEN, \"Chin Thrown\"), //player, distance\n\n    ACCURATE_MAIDEN_START(201, true, MAIDEN, \"Accurate Maiden Start\"),\n    ACCURATE_BLOAT_START(202, true, BLOAT, \"Accurate Bloat Start\"),\n    ACCURATE_NYLO_START(203, true, NYLOCAS, \"Accurate Nylo Start\"),\n    ACCURATE_SOTE_START(204, true, SOTETSEG, \"Accurate Sote Start\"),\n    ACCURATE_XARP_START(205, true, XARPUS, \"Accurate Xarpus Start\"),\n    ACCURATE_VERZIK_START(206, true, VERZIK, \"Accurate Verzik Start\"),\n\n    ACCURATE_MAIDEN_END(301, true, MAIDEN, \"Accurate Maiden End\"),\n    ACCURATE_BLOAT_END(302, true, BLOAT, \"Accurate Bloat End\"),\n    ACCURATE_NYLO_END(303, true, NYLOCAS, \"Accurate Nylo End\"),\n    ACCURATE_SOTE_END(304, true, SOTETSEG, \"Accurate Sote End\"),\n    ACCURATE_XARP_END(305, true, XARPUS, \"Accurate Xarpus End\"),\n    ACCURATE_VERZIK_END(306, true, VERZIK, \"Accurate Verzik End\"),\n    IS_HARD_MODE(401, true, ANY, \"Is Hard Mode\"),\n    IS_STORY_MODE(402, true, ANY, \"Is Story Mode\"),\n\n    THRALL_ATTACKED(403, false, ANY, \"Thrall Attacked\"), // player, type\n\n    THRALL_DAMAGED(404, false, ANY, \"Thrall Damaged\"), // player, damage\n\n    VENG_WAS_CAST(405, false, ANY, \"Veng Cast\"), //target, source\n\n    VENG_WAS_PROCCED(406, false, ANY, \"Veng Procced\"), //player, source of veng, damage\n\n    PLAYER_STOOD_IN_THROWN_BLOOD(411, true, MAIDEN, \"Player Stood In Thrown Blood\"), //player, damage, blood tick\n    PLAYER_STOOD_IN_SPAWNED_BLOOD(412, true, MAIDEN, \"Player Stood In Spawned Blood\"),  //player, damage\n    CRAB_HEALED_MAIDEN(413, true, MAIDEN, \"Crab Healed Maiden\"), //damage\n    VERZIK_PURPLE_HEAL(701, true, VERZIK, \"Purple Heal\"),\n    VERZIK_RED_AUTO(702, true, VERZIK, \"Red Auto\"),\n    VERZIK_THRALL_HEAL(703, true, VERZIK, \"Thrall Heal\"),\n    VERZIK_PLAYER_HEAL(704, true, VERZIK, \"Player Heal\"),\n\n    KODAI_BOP(501, true, ANY, \"Kodai Bop\"),\n    DWH_BOP(502, true, ANY, \"DWH Bop\"),\n    BGS_WHACK(503, true, ANY, \"BGS Whack\"),\n    CHALLY_POKE(504, true, ANY, \"Chally Poke\"),\n    THRALL_SPAWN(410, false, ANY, \"Thrall Spawn\"),\n    THRALL_DESPAWN(498, false, ANY, \"Thrall Despawn\"),\n    DAWN_SPEC(487, false, VERZIK, \"Dawn Spec\"),\n    DAWN_DAMAGE(488, false, VERZIK, \"Dawn Damage\"),\n    MAIDEN_PLAYER_DRAINED(530, true, MAIDEN, \"Player Drained\"),\n    MAIDEN_AUTO(531, true, MAIDEN, \"Maiden Auto\"),\n\n    UPDATE_HP(576, false, ANY, \"Update Boss HP\"),\n    ADD_NPC_MAPPING(587, false, ANY, \"Update NPC Mappings\"),\n    UNKNOWN(-1, false, ANY, \"Unknown\");\n\n    final int id;\n    final String commonName;\n    final TOBRoom room;\n    final boolean simple;\n\n    LogID(int id, boolean simple, TOBRoom room, String commonName)\n    {\n        this.id \u003d id;\n        this.commonName \u003d commonName;\n        this.room \u003d room;\n        this.simple \u003d simple;\n    }\n    public static LogID valueOf(int value)\n    {\n        Optional\u003cLogID\u003e o \u003d Arrays.stream(values()).filter(logid -\u003e logid.getId() \u003d\u003d value).findFirst();\n        return o.orElse(UNKNOWN);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\constants\\LogID.java"},{"fileName":"TobIDs.java","content":"package com.advancedraidtracker.constants;\n\npublic class TobIDs\n{\n    public static final int ROOM_ACTIVE_VARBIT \u003d 6447;\n\n    public static final int HP_VARBIT \u003d 6448;\n    public static final int SCYTHE_ANIMATION \u003d 8056;\n    public final static int CHINCHOMPA_THROWN_ANIMATION \u003d 7618;\n\n    public final static int DINHS_BULWARK_ANIMATION \u003d 7511;\n\n    public final static int BLOOD_ON_GROUND \u003d 32984;\n\n    public final static int VERZIK_CRAB_HEAL_PROJECTILE \u003d 1587;\n    public final static int VERZIK_RED_MAGE_AUTO_PROJECTILE \u003d 1591;\n    public final static int VERZIK_WEB_PROJECTILE \u003d 1601;\n    public final static int VERZIK_DEATH_ANIMATION_LENGTH \u003d 6;\n\n    public final static int VERZIK_SHIELD_LENGTH \u003d 11;\n    public final static int DAWNBRINGER_ITEM \u003d 22516;\n    public final static String VERZIK_BOUNCE_ANIMATION \u003d \"100000\"; //fake number used due to poor design of how attacks are presented on the chart\n\n    public final static int DAWNBRINGER_MINIMUM_HIT \u003d 75;\n\n    public final static int XARPUS_DEATH_ANIMATION_LENGTH \u003d 3;\n\n    public final static int SOTETSEG_DEATH_ANIMATION_LENGTH \u003d 3;\n    public final static int MAIDEN_DEATH_ANIMATION_LENGTH \u003d 7;\n\n    public static final int FULL_HP \u003d 1000;\n    public final static int LOBBY_REGION \u003d 14642;\n    public final static int MAIDEN_REGION \u003d 12613;\n    public final static int  BLOAT_REGION \u003d 13125;\n    public final static int  NYLO_REGION \u003d 13122;\n    public final static int  SOTETSEG_REGION \u003d 13123;\n    public final static int  SOTETSEG_UNDER_REGION \u003d 13379;\n    public final static int  XARPUS_REGION \u003d 12612;\n    public final static int  VERZIK_REGION \u003d 12611;\n    public final static int MAIDEN_THROWN_BLOOD_GRAPHIC_OBJECT \u003d 1579;\n    public final static int MAIDEN_BLOOD_THROW_ANIM \u003d 8091;\n    public final static int TBOW_PROJECTILE \u003d 1120;\n    public final static int ZCB_PROJECTILE \u003d 1468;\n    public final static int ZCB_SPEC_PROJECTILE \u003d 1995;\n    public final static int VENG_CAST \u003d 8316;\n    public final static int VENG_OTHER_CAST \u003d 4411;\n    public final static int VENG_GRAPHIC \u003d 726;\n    public final static int VENG_OTHER_GRAPHIC \u003d 725;\n\n    public final static int DWH_SPEC \u003d 1378;\n    //veng other 725\n\n    public final static int MELEE_THRALL \u003d 10886;\n    public final static int RANGE_THRALL \u003d 10883;\n    public final static int MAGE_THRALL \u003d 10880;\n    public static final String EXIT_FLAG \u003d \"4\";\n    public static final int SPECTATE_FLAG \u003d 98;\n\n\n\n    public final static int MELEE_THRALL_ATTACK_ANIMATION \u003d 5568;\n    public final static int THRALL_CAST_ANIMATION \u003d 8973;\n    public final static int THRALL_CAST_GRAPHIC_MAGE \u003d 1873;\n    public final static int THRALL_CAST_GRAPHIC_RANGE \u003d 1874;\n    public final static int THRALL_CAST_GRAPHIC_MELEE \u003d 1875;\n\n    public final static int THRALL_PROJECTILE_RANGE \u003d 1906;\n    public final static int THRALL_PROJECTILE_MAGE \u003d 1907;\n\n    public final static int MAIDEN_P0 \u003d 8360; // 8362 30-50 //8363 30-end //8360 start\n    public final static int MAIDEN_P0_HM \u003d 10822;\n    public final static int MAIDEN_P0_SM \u003d 10814;\n    public final static int MAIDEN_P1 \u003d 8361;\n    public final static int MAIDEN_P1_HM \u003d 10823;\n    public final static int MAIDEN_P1_SM \u003d 10815;\n    public final static int MAIDEN_P2 \u003d 8362;\n    public final static int MAIDEN_P2_HM \u003d 10824;\n    public final static int MAIDEN_P2_SM \u003d 10816;\n    public final static int MAIDEN_P3 \u003d 8363;\n    public final static int MAIDEN_P3_HM \u003d 10825;\n    public final static int MAIDEN_P3_SM \u003d 10817;\n\n    public final static int MAIDEN_PRE_DEAD \u003d 8364;\n    public final static int MAIDEN_PRE_DEAD_HM \u003d 10826;\n    public final static int MAIDEN_PRE_DEAD_SM \u003d 10818;\n    public final static int MAIDEN_DEAD \u003d 8365;\n    public final static int MAIDEN_DEAD_HM \u003d 10827;\n    public final static int MAIDEN_DEAD_SM \u003d 10819;\n    public final static int MAIDEN_MATOMENOS \u003d 8366;\n    public final static int MAIDEN_MATOMENOS_HM \u003d 10828;\n    public final static int MAIDEN_MATOMENOS_SM \u003d 10820;\n\n    public final static int MAIDEN_BLOOD \u003d 8367;\n    public final static int MAIDEN_BLOOD_HM \u003d 10829;\n    public final static int MAIDEN_BLOOD_SM \u003d 10821;\n\n    public final static int MAIDEN_DEATH_ANIMATION \u003d 8093;\n    public final static int BLOAT \u003d 8359;\n    public final static int BLOAT_HM \u003d 10813;\n    public final static int BLOAT_SM \u003d 10812;\n    public final static int BLOAT_DEATH_ANIMATION_LENGTH \u003d 3;\n\n    public final static int BLOAT_DOWN_ANIMATION \u003d 8082;\n    public final static int BLOAT_DEATH_ANIMATION \u003d 8085;\n\n    public final static int POWERED_STAFF_ANIMATION \u003d 1167;\n    public final static int DAWNBRINGER_AUTO_PROJECTILE \u003d 1544;\n    public final static int DAWNBRINGER_SPEC_PROJECTILE \u003d 1547;\n    public final static int NYLO_PILLAR \u003d 8358;\n    public final static int NYLO_PILLAR_HM \u003d 10811;\n    public final static int NYLO_PILLAR_SM \u003d 10790;\n    public final static int NYLO_MELEE_SMALL \u003d 8342;\n    public final static int NYLO_MELEE_SMALL_HM \u003d 10791;\n    public final static int NYLO_MELEE_SMALL_SM \u003d 10774;\n    public final static int UNCHARGED_SCYTHE \u003d 22486;\n    public final static int UNCHARGED_BLOOD_SCYTHE \u003d 25738;\n    public final static int UNCHARGED_HOLY_SCYTHE \u003d 25741;\n\n    public final static int SOTETSEG_RAGGED_TILE \u003d 505;\n    public final static int SOTETSEG_RED_TILE \u003d 33035;\n    public final static int MAIDEN_AUTO_ANIMATION \u003d 8092;\n    public final static int DRAGON_WARHAMMER \u003d 13576;\n    public final static int DRAGON_WARHAMMER_ALTERNATE \u003d 20785;\n    public final static int BOP_ANIMATION \u003d 401;\n    public final static int WHACK_ANIMATION \u003d 414;\n    public final static int KODAI_WAND \u003d 21006;\n    public final static int KODAI_WAND_ALTERNATE \u003d 23626;\n    public final static int STAB_ANIMATION \u003d 440;\n    public final static int CHALLY \u003d 23987;\n    public final static int TWO_HAND_SWORD_SWING \u003d 7045;\n    public final static int BANDOS_GODSWORD \u003d 11804;\n    public final static int BANDOS_GODSWORD_OR \u003d 20370;\n    public final static int CROSSBOW_ANIMATION \u003d 9168;\n    public final static int BLOWPIPE_ANIMATION \u003d 5061;\n    public final static int BLOWPIPE_ANIMATION_OR \u003d 10656;\n\n    public final static int NYLO_MELEE_SMALL_AGRO \u003d 8348;\n    public final static int NYLO_MELEE_SMALL_AGRO_HM \u003d 10797;\n    public final static int NYLO_MELEE_SMALL_AGRO_SM \u003d 10780;\n\n    public final static int NYLO_RANGE_SMALL \u003d 8343;\n    public final static int NYLO_RANGE_SMALL_HM \u003d 10792;\n    public final static int NYLO_RANGE_SMALL_SM \u003d 10775;\n\n    public final static int NYLO_RANGE_SMALL_AGRO \u003d 8349;\n    public final static int NYLO_RANGE_SMALL_AGRO_HM \u003d 10798;\n    public final static int NYLO_RANGE_SMALL_AGRO_SM \u003d 10781;\n\n    public final static int NYLO_MAGE_SMALL \u003d 8344;\n    public final static int NYLO_MAGE_SMALL_HM \u003d 10793;\n    public final static int NYLO_MAGE_SMALL_SM \u003d 10776;\n\n    public final static int NYLO_MAGE_SMALL_AGRO \u003d 8350;\n    public final static int NYLO_MAGE_SMALL_AGRO_HM \u003d 10799;\n    public final static int NYLO_MAGE_SMALL_AGRO_SM \u003d 10782;\n\n    public final static int NYLO_MELEE_BIG \u003d 8345;\n    public final static int NYLO_MELEE_BIG_HM \u003d 10794;\n    public final static int NYLO_MELEE_BIG_SM \u003d 10777;\n\n    public final static int NYLO_MELEE_BIG_AGRO \u003d 8351;\n    public final static int NYLO_MELEE_BIG_AGRO_HM \u003d 10800;\n    public final static int NYLO_MELEE_BIG_AGRO_SM \u003d 10783;\n\n    public final static int NYLO_RANGE_BIG \u003d 8346;\n    public final static int NYLO_RANGE_BIG_HM \u003d 10795;\n    public final static int NYLO_RANGE_BIG_SM \u003d 10778;\n\n    public final static int NYLO_RANGE_BIG_AGRO \u003d 8352;\n    public final static int NYLO_RANGE_BIG_AGRO_HM \u003d 10801;\n    public final static int NYLO_RANGE_BIG_AGRO_SM \u003d 10784;\n\n    public final static int NYLO_MAGE_BIG \u003d 8347;\n    public final static int NYLO_MAGE_BIG_HM \u003d 10796;\n    public final static int NYLO_MAGE_BIG_SM \u003d 10779;\n\n    public final static int NYLO_MAGE_BIG_AGRO \u003d 8353;\n    public final static int NYLO_MAGE_BIG_AGRO_HM \u003d 10802;\n    public final static int NYLO_MAGE_BIG_AGRO_SM \u003d 10785;\n\n    public final static int NYLO_BOSS_DROPPING \u003d 8354;\n    public final static int NYLO_BOSS_DROPPING_HM \u003d 10807;\n    public final static int NYLO_BOSS_DROPING_SM \u003d 10786;\n\n    public final static int NYLO_BOSS_MELEE \u003d 8355;\n    public final static int NYLO_BOSS_MELEE_HM \u003d 10808;\n    public final static int NYLO_BOSS_MELEE_SM \u003d 10787;\n\n    public final static int NYLO_BOSS_MAGE \u003d 8356;\n    public final static int NYLO_BOSS_MAGE_HM \u003d 10809;\n    public final static int NYLO_BOSS_MAGE_SM \u003d 10788;\n\n    public final static int NYLO_BOSS_RANGE \u003d 8357;\n    public final static int NYLO_BOSS_RANGE_HM \u003d 10810;\n    public final static int NYLO_BOSS_RANGE_SM \u003d 10789;\n\n    public final static int NYLO_PRINKIPAS_DROPPING \u003d 10803;\n    public final static int NYLO_PRINKIPAS_MELEE \u003d 10804;\n    public final static int NYLO_PRINKIPAS_MAGIC \u003d 10805;\n    public final static int NYLO_PRINKIPAS_RANGE \u003d 10806;\n\n    public final static int SOTETSEG_OVERWORLD \u003d 13123;\n    public final static int SOTETSEG_UNDERWORLD \u003d 13379;\n    public final static int SOTETSEG_DEATH_ANIMATION \u003d 8140;\n\n    public final static int SOTETSEG_ACTIVE \u003d 8388;\n    public final static int SOTETSEG_ACTIVE_HM \u003d 10868;\n    public final static int SOTETSEG_ACTIVE_SM \u003d 10865;\n\n    public final static int SOTETSEG_INACTIVE \u003d 8387;\n    public final static int SOTETSEG_INACTIVE_HM \u003d 10867;\n    public final static int SOTETSEG_INACTIVE_SM \u003d 10864;\n\n    public final static int XARPUS_AWAKENS \u003d 8061;\n    public final static int XARPUS_DEATH_ANIMATION \u003d 8063;\n    public final static int XARPUS_EXHUMED_PROJECTILE \u003d 1550;\n\n    public final static int XARPUS_INACTIVE \u003d 8338;\n    public final static int XARPUS_INACTIVE_HM \u003d 10770;\n    public final static int XARPUS_INACTIVE_SM \u003d 10766;\n\n    public final static int XARPUS_P1 \u003d 8339;\n    public final static int XARPUS_P1_HM \u003d 10771;\n    public final static int XARPUS_P1_SM \u003d 10767;\n\n    public final static int XARPUS_P23 \u003d 8340;\n    public final static int XARPUS_P23_HM \u003d 10772;\n    public final static int XARPUS_P23_SM \u003d 10768;\n\n    public final static int XARPUS_DEAD \u003d 8341;\n    public final static int XARPUS_DEAD_HM \u003d 10773;\n    public final static int XARPUS_DEAD_SM \u003d 10769;\n\n    public final static int VERZIK_MATOMENOS \u003d 8385;\n    public final static int VERZIK_MATOMENOS_HM \u003d 10862;\n    public final static int VERZIK_MATOMENOS_SM \u003d 10845;\n\n    public final static int VERZIK_MELEE_NYLO \u003d 8381;\n    public final static int VERZIK_MELEE_NYLO_HM \u003d 10858;\n    public final static int VERZIK_MELEE_NYLO_SM \u003d 10841;\n\n    public final static int VERZIK_RANGE_NYLO \u003d 8382;\n    public final static int VERZIK_RANGE_NYLO_HM \u003d 10859;\n    public final static int VERZIK_RANGE_NYLO_SM \u003d 10842;\n\n    public final static int VERZIK_MAGE_NYLO \u003d 8383;\n    public final static int VERZIK_MAGE_NYLO_HM \u003d 10860;\n    public final static int VERZIK_MAGE_NYLO_SM \u003d 10843;\n\n    public final static int VERZIK_BOUNCE_SPOT_ANIMATION \u003d 245;\n    public final static int VERZIK_BECOMES_SPIDER \u003d 8128;\n\n    public final static int VERZIK_P1_INACTIVE \u003d 8369;\n    public final static int VERZIK_P1_INACTIVE_HM \u003d 10847;\n    public final static int VERZIK_P1_INACTIVE_SM \u003d 10830;\n\n    public final static int VERZIK_P1 \u003d 8370;\n    public final static int VERZIK_P1_HM \u003d 10848;\n    public final static int VERZIK_P1_SM \u003d 10831;\n\n    public final static int VERZIK_P2_INACTIVE \u003d 8371;\n    public final static int VERZIK_P2_INACTIVE_HM \u003d 10849;\n    public final static int VERZIK_P2_INACTIVE_SM \u003d 10832;\n\n    public final static int VERZIK_P2 \u003d 8372;\n    public final static int VERZIK_P2_HM \u003d 10850;\n    public final static int VERZIK_P2_SM \u003d 10833;\n\n    public final static int VERZIK_P3_INACTIVE \u003d 8373;\n    public final static int VERZIK_P3_INACTIVE_HM \u003d 10851;\n    public final static int VERZIK_P3_INACTIVE_SM \u003d 10834;\n\n    public final static int VERZIK_P3 \u003d 8374;\n    public final static int VERZIK_P3_HM \u003d 10852;\n    public final static int VERZIK_P3_SM \u003d 10835;\n    public final static int VERZIK_DEAD \u003d 8375;\n    public final static int VERZIK_DEAD_HM \u003d 10853;\n    public final static int VERZIK_DEAD_SM \u003d 10836;\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\constants\\TobIDs.java"},{"fileName":"TOBRoom.java","content":"package com.advancedraidtracker.constants;\n\nimport java.util.Arrays;\nimport java.util.Optional;\n\npublic enum TOBRoom\n{\n    MAIDEN(0), BLOAT(1), NYLOCAS(2), SOTETSEG(3), XARPUS(4), VERZIK(5), UNKNOWN(-1), ANY(6);\n\n    public final int value;\n    TOBRoom(int value)\n    {\n        this.value \u003d value;\n    }\n\n    public static TOBRoom valueOf(int number)\n    {\n        Optional\u003cTOBRoom\u003e o \u003d Arrays.stream(values()).filter(room -\u003e room.value \u003d\u003d number).findFirst();\n        return o.orElse(UNKNOWN);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\constants\\TOBRoom.java"},{"fileName":"Filter.java","content":"package com.advancedraidtracker.filters;\n\nimport lombok.Getter;\n\n@Getter\npublic class Filter\n{\n    private final String name;\n    private final String[] filters;\n\n    public Filter(String name, String[] filters)\n    {\n        this.filters \u003d filters;\n        this.name \u003d name;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\Filter.java"},{"fileName":"FilterCondition.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\npublic abstract class FilterCondition\n{\n    public abstract boolean evaluate(SimpleTOBData data);\n\n    public abstract String getFilterCSV();\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterCondition.java"},{"fileName":"FilterDate.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class FilterDate extends FilterCondition\n{\n    private final Date date;\n    private final int qualifier;\n    private final String stringValue;\n\n    public FilterDate(Date date, int qualifier, String val)\n    {\n        this.date \u003d date;\n        this.qualifier \u003d qualifier;\n        stringValue \u003d val;\n    }\n\n    @Override\n    public String toString()\n    {\n        return stringValue;\n    }\n\n    @Override\n    public boolean evaluate(SimpleTOBData data)\n    {\n        Calendar cal \u003d Calendar.getInstance();\n        Calendar cal2 \u003d Calendar.getInstance();\n        cal.setTime(data.raidStarted);\n        cal2.setTime(date);\n        switch (qualifier)\n        {\n            case 0:\n                return (cal.get(Calendar.MONTH) \u003d\u003d cal2.get(Calendar.MONTH) \u0026\u0026\n                        cal.get(Calendar.DAY_OF_MONTH) \u003d\u003d cal2.get(Calendar.DAY_OF_MONTH) \u0026\u0026\n                        cal.get(Calendar.YEAR) \u003d\u003d cal2.get(Calendar.YEAR));\n            case 1:\n                return data.raidStarted.before(date);\n            case 2:\n                return data.raidStarted.after(date);\n            default:\n                throw new IllegalStateException(\"Unexpected value: \" + qualifier);\n        }\n    }\n\n    public String getFilterCSV()\n    {\n        return \"4-\" + date.getTime() + \"-\" + qualifier + \"-\" + stringValue;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterDate.java"},{"fileName":"FilterManager.java","content":"package com.advancedraidtracker.filters;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Scanner;\n@Slf4j\npublic class FilterManager\n{\n    private static final String filterFolder \u003d System.getProperty(\"user.home\").replace(\"\\\\\", \"/\") + \"/.runelite/advancedraidtracker/misc-dir/filters/\";\n\n    public static ArrayList\u003cFilter\u003e getFilters()\n    {\n        ArrayList\u003cFilter\u003e currentFilters \u003d new ArrayList\u003c\u003e();\n        File folder \u003d new File(filterFolder);\n        try\n        {\n            for (File entry : Objects.requireNonNull(folder.listFiles()))\n            {\n                ArrayList\u003cString\u003e activeFileFilters \u003d new ArrayList\u003c\u003e();\n                if (entry.isFile())\n                {\n                    if (entry.getAbsolutePath().endsWith(\".filter\"))\n                    {\n                        try\n                        {\n                            Scanner filterReader \u003d new Scanner(Files.newInputStream(entry.toPath()));\n                            while (filterReader.hasNextLine())\n                            {\n                                activeFileFilters.add(filterReader.nextLine());\n                            }\n                            filterReader.close();\n                            if (!activeFileFilters.isEmpty())\n                            {\n                                currentFilters.add(new Filter(entry.getName(), activeFileFilters.toArray(new String[0])));\n                            }\n                        } catch (Exception e)\n                        {\n                            log.info(\"Failed to read filter filter\");\n                        }\n                    }\n                }\n            }\n        } catch (Exception e)\n        {\n            log.info(\"Failed retrieving filters\");\n        }\n        return currentFilters;\n    }\n\n    public static boolean doesFilterExist(String name)\n    {\n        File folder \u003d new File(filterFolder);\n        try\n        {\n            for (File entry : Objects.requireNonNull(folder.listFiles()))\n            {\n                if (entry.getName().equals(name + \".filter\"))\n                {\n                    return true;\n                }\n            }\n        } catch (Exception e)\n        {\n            log.info(\"Failed to find filter\");\n        }\n        return false;\n    }\n\n    public static void saveOverwriteFilter(String name, ArrayList\u003cImplicitFilter\u003e filters)\n    {\n        try\n        {\n            File directory \u003d new File(filterFolder);\n            if (!directory.exists())\n            {\n                if(!directory.mkdirs())\n                {\n                    log.info(\"Could not make directories to save filter\");\n                }\n            }\n            File filterFile \u003d new File(filterFolder + name + \".filter\");\n\n            if (filterFile.exists())\n            {\n                if(!filterFile.delete())\n                {\n                    log.info(\"Could not delete old filter\");\n                }\n            }\n            if(!filterFile.createNewFile())\n            {\n                log.info(\"Could not create new filter filter\");\n            }\n            BufferedWriter filterWriter \u003d new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + \".filter\"))));\n            for (ImplicitFilter s : filters)\n            {\n                filterWriter.write(s.getFilterDescription());\n                filterWriter.newLine();\n            }\n            filterWriter.close();\n        } catch (Exception ignored)\n        {\n        }\n    }\n\n    public static void saveFilter(String name, ArrayList\u003cImplicitFilter\u003e filters)\n    {\n        try\n        {\n            File directory \u003d new File(filterFolder);\n            if (!directory.exists())\n            {\n                if(!directory.mkdirs())\n                {\n                    log.info(\"Could not make directory to save filter\");\n                }\n            }\n            File filterFile \u003d new File(filterFolder + name + \".filter\");\n            if (!filterFile.exists())\n            {\n                if(!filterFile.createNewFile())\n                {\n                    log.info(\"Could not create new filter file\");\n                }\n            }\n            BufferedWriter filterWriter \u003d new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + \".filter\"))));\n            for (ImplicitFilter filter : filters)\n            {\n                filterWriter.write(filter.getFilterCSV());\n                filterWriter.newLine();\n            }\n            filterWriter.close();\n        } catch (Exception ignored)\n        {\n        }\n    }\n\n    public static void saveFilter(String name, ArrayList\u003cImplicitFilter\u003e filters, ArrayList\u003cString\u003e quickFiltersState)\n    {\n        try\n        {\n            File directory \u003d new File(filterFolder);\n            if (!directory.exists())\n            {\n                if(!directory.mkdirs())\n                {\n                    log.info(\"Could not make folder to save filters\");\n                }\n            }\n            File filterFile \u003d new File(filterFolder + name + \".filter\");\n            if (!filterFile.exists())\n            {\n                if(!filterFile.createNewFile())\n                {\n                    log.info(\"Could not create new filter file\");\n                }\n            }\n            BufferedWriter filterWriter \u003d new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(Paths.get(filterFolder + name + \".filter\"))));\n            for (ImplicitFilter filter : filters)\n            {\n                filterWriter.write(filter.getFilterCSV());\n                filterWriter.newLine();\n            }\n            for(String s : quickFiltersState)\n            {\n                filterWriter.write(s);\n                filterWriter.newLine();\n            }\n            filterWriter.close();\n        } catch (Exception ignored)\n        {\n        }\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterManager.java"},{"fileName":"FilterOtherBool.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\npublic class FilterOtherBool extends FilterCondition\n{\n    boolean value;\n    int param;\n    String stringValue;\n\n    public FilterOtherBool(int param, boolean value, String val)\n    {\n        this.param \u003d param;\n        this.value \u003d value;\n        stringValue \u003d val;\n    }\n\n    @Override\n    public String toString()\n    {\n        return stringValue;\n    }\n\n    @Override\n    public boolean evaluate(SimpleTOBData data)\n    {\n        switch (param)\n        {\n            case 0:\n                return data.maidenSkip \u003d\u003d value;\n            case 1:\n                return data.maidenReset \u003d\u003d value;\n            case 2:\n                return data.maidenWipe \u003d\u003d value;\n            case 3:\n                return data.bloatReset \u003d\u003d value;\n            case 4:\n                return data.bloatWipe \u003d\u003d value;\n            case 5:\n                return data.nyloReset \u003d\u003d value;\n            case 6:\n                return data.nyloWipe \u003d\u003d value;\n            case 7:\n                return data.soteReset \u003d\u003d value;\n            case 8:\n                return data.soteWipe \u003d\u003d value;\n            case 9:\n                return data.xarpReset \u003d\u003d value;\n            case 10:\n                return data.xarpWipe \u003d\u003d value;\n            case 11:\n                return data.verzikWipe \u003d\u003d value;\n            case 12:\n                return data.maidenScuffed \u003d\u003d value;\n        }\n        return false;\n    }\n\n    public String getFilterCSV()\n    {\n        return \"3-\" + param + \"-\" + ((value) ? 1 : 0) + \"-\" + stringValue;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterOtherBool.java"},{"fileName":"FilterOtherInt.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\n\npublic class FilterOtherInt extends FilterCondition\n{\n    DataPoint param;\n    int qualifier;\n    int value;\n    public String stringValue;\n\n    public FilterOtherInt(DataPoint param, int qualifier, int value, String val)\n    {\n        this.param \u003d param;\n        this.qualifier \u003d qualifier;\n        this.value \u003d value;\n        stringValue \u003d val;\n    }\n\n    @Override\n    public String toString()\n    {\n        return stringValue;\n    }\n\n    @Override\n    public boolean evaluate(SimpleTOBData data)\n    {\n        int checkValue \u003d data.getValue(param);\n        if (data.getTimeAccurate(param) \u0026\u0026 value !\u003d -1)\n        {\n            return FilterUtil.compare(qualifier, value, checkValue);\n\n        } else\n        {\n            return false;\n        }\n    }\n\n    public String getFilterCSV()\n    {\n        return \"1-\" + param.name + \"-\" + qualifier + \"-\" + value + \"-\" + stringValue;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterOtherInt.java"},{"fileName":"FilterPlayers.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.ArrayList;\n\n@Slf4j\npublic class FilterPlayers extends FilterCondition\n{\n    private final ArrayList\u003cString\u003e players;\n    private final int operator;\n    private final String stringValue;\n\n    public FilterPlayers(String players, int operator, String val)\n    {\n        this.players \u003d new ArrayList\u003cString\u003e();\n        String[] playerNames \u003d players.split(\",\");\n        for (String playerName : playerNames)\n        {\n            this.players.add(playerName.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).toLowerCase());\n        }\n        this.operator \u003d operator;\n        stringValue \u003d val;\n    }\n\n    private boolean cleanContains(SimpleTOBData data, String player)\n    {\n        for (String p : data.players.keySet())\n        {\n            if (p.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)).toLowerCase().equals(player))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public String toString()\n    {\n        return stringValue;\n    }\n\n    @Override\n    public boolean evaluate(SimpleTOBData data)\n    {\n        switch (operator)\n        {\n            case 0:\n                if (data.players.size() \u003d\u003d players.size())\n                {\n                    for (String p : players)\n                    {\n                        if (!cleanContains(data, p))\n                        {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            case 1:\n                boolean flag \u003d true;\n                for (String p : players)\n                {\n                    if (!cleanContains(data, p))\n                    {\n                        flag \u003d false;\n                    }\n                }\n                return flag;\n            case 2:\n                for (String p : players)\n                {\n                    if (cleanContains(data, p))\n                    {\n                        return true;\n                    }\n                }\n                return false;\n            case 3:\n                for (String p : players)\n                {\n                    if (!cleanContains(data, p))\n                    {\n                        return true;\n                    }\n                }\n                return false;\n            case 4:\n                for (String p : players)\n                {\n                    if (cleanContains(data, p))\n                    {\n                        return false;\n                    }\n                }\n                return true;\n        }\n        return false;\n    }\n\n    public String getFilterCSV()\n    {\n        StringBuilder playerStr \u003d new StringBuilder();\n        for (String s : players)\n        {\n            playerStr.append(s);\n            playerStr.append(\",\");\n        }\n        playerStr \u003d new StringBuilder(StringUtils.substring(playerStr.toString(), 0, playerStr.length() - 1));\n        return \"2-\" + operator + \"-\" + playerStr + \"-\" + stringValue;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterPlayers.java"},{"fileName":"FilterTime.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport lombok.extern.slf4j.Slf4j;\nimport com.advancedraidtracker.SimpleTOBData;\n\n@Slf4j\npublic class FilterTime extends FilterCondition\n{\n    private final DataPoint split;\n    private final int compare;\n    private final int time;\n    private final String stringValue;\n\n    public FilterTime(DataPoint split, int compare1, int time1, String str)\n    {\n        this.split \u003d split;\n        this.compare \u003d compare1;\n        this.time \u003d time1;\n        stringValue \u003d str;\n    }\n\n    @Override\n    public String toString()\n    {\n        return stringValue;\n    }\n\n    @Override\n    public boolean evaluate(SimpleTOBData data)\n    {\n        int checkValue \u003d data.getValue(split);\n        return FilterUtil.compare(compare, time, checkValue);\n    }\n\n    public String getFilterCSV()\n    {\n        return \"0-\" + split.name + \"-\" + compare + \"-\" + time + \"-\" + stringValue;\n    }\n}\n\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterTime.java"},{"fileName":"FilterUtil.java","content":"package com.advancedraidtracker.filters;\n\npublic class FilterUtil\n{\n    public static boolean compare(int operator, int value, int compareValue)\n    {\n        switch (operator)\n        {\n            case 0:\n                return compareValue \u003d\u003d value;\n            case 1:\n                return compareValue \u003c value;\n            case 2:\n                return compareValue \u003e value;\n            case 3:\n                return compareValue \u003c\u003d value;\n            case 4:\n                return compareValue \u003e\u003d value;\n            default:\n                return false;\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\FilterUtil.java"},{"fileName":"ImplicitFilter.java","content":"package com.advancedraidtracker.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\n\npublic class ImplicitFilter\n{\n    private FilterCondition filter;\n\n    public ImplicitFilter(FilterDate filterDate)\n    {\n        filter \u003d filterDate;\n    }\n\n    public ImplicitFilter(FilterTime filterTime)\n    {\n        filter \u003d filterTime;\n    }\n\n    public ImplicitFilter(FilterPlayers filterPlayers)\n    {\n        filter \u003d filterPlayers;\n    }\n\n    public ImplicitFilter(FilterOtherBool filterBool)\n    {\n        filter \u003d filterBool;\n    }\n\n    public ImplicitFilter(FilterOtherInt filterInt)\n    {\n        filter \u003d filterInt;\n    }\n\n    public ImplicitFilter(String s)\n    {\n        filter \u003d null;\n        if (!s.isEmpty())\n        {\n            int filterType \u003d Integer.parseInt(s.substring(0, 1));\n            ArrayList\u003cString\u003e parse \u003d new ArrayList\u003cString\u003e(Arrays.asList(s.split(\"-\")));\n            switch (filterType)\n            {\n                case 0:\n                    if (parse.size() \u003d\u003d 5)\n                    {\n                        filter \u003d new FilterTime(\n                                DataPoint.getValue(parse.get(1)),\n                                Integer.parseInt(parse.get(2)),\n                                Integer.parseInt(parse.get(3)),\n                                parse.get(4));\n                    }\n                    break;\n                case 1:\n                    if (parse.size() \u003d\u003d 5)\n                    {\n                        filter \u003d new FilterOtherInt(\n                                DataPoint.getValue(parse.get(1)),\n                                Integer.parseInt(parse.get(2)),\n                                Integer.parseInt(parse.get(3)),\n                                parse.get(4));\n                    }\n                    break;\n                case 2:\n                    if (parse.size() \u003d\u003d 4)\n                    {\n                        filter \u003d new FilterPlayers(\n                                parse.get(2),\n                                Integer.parseInt(parse.get(1)),\n                                parse.get(3));\n                    }\n                    break;\n                case 3:\n                    if (parse.size() \u003d\u003d 4)\n                    {\n                        filter \u003d new FilterOtherBool(\n                                Integer.parseInt(parse.get(1)),\n                                (Integer.parseInt(parse.get(2)) \u003d\u003d 1),\n                                parse.get(3));\n                    }\n                    break;\n                case 4:\n                    if (parse.size() \u003d\u003d 4)\n                    {\n                        filter \u003d new FilterDate(\n                                new Date(Long.parseLong(parse.get(1))),\n                                Integer.parseInt(parse.get(2)),\n                                parse.get(3));\n                    }\n            }\n        }\n    }\n\n    public String getFilterCSV()\n    {\n        return filter.getFilterCSV();\n    }\n\n    public String getFilterDescription()\n    {\n        return filter.toString();\n    }\n\n    public boolean evaluate(SimpleTOBData data)\n    {\n        return filter.evaluate(data);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\filters\\ImplicitFilter.java"},{"fileName":"BloatHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.*;\nimport com.advancedraidtracker.utility.Point;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\n\nimport java.util.ArrayList;\n\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.utility.RoomState.*;\nimport static com.advancedraidtracker.utility.RoomState.BloatRoomState.*;\n\n@Slf4j\npublic class BloatHandler extends RoomHandler\n{\n    public BloatRoomState roomState;\n\n    private final ArrayList\u003cInteger\u003e walks \u003d new ArrayList\u003c\u003e();\n    private final ArrayList\u003cInteger\u003e downs \u003d new ArrayList\u003c\u003e();\n    private int bloatStartTick \u003d -1;\n    private int bloatDeferTick \u003d -1;\n    private int bloatDeathTick \u003d -1;\n    private final AdvancedRaidTrackerPlugin plugin;\n\n    public BloatHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n        roomState \u003d NOT_STARTED;\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d NOT_STARTED || roomState \u003d\u003d FINISHED);\n    }\n\n    public String getName()\n    {\n        return \"Bloat\";\n    }\n\n    public void reset()\n    {\n        roomState \u003d NOT_STARTED;\n        bloatDeferTick \u003d -1;\n        accurateEntry \u003d true;\n        bloatStartTick \u003d -1;\n        bloatDeathTick \u003d -1;\n        walks.clear();\n        downs.clear();\n        super.reset();\n    }\n\n    public void endBloat()\n    {\n        roomState \u003d FINISHED;\n        bloatDeathTick \u003d client.getTickCount() + BLOAT_DEATH_ANIMATION_LENGTH;\n        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, \"Dead\");\n        clog.addLine(ACCURATE_BLOAT_END);\n        plugin.liveFrame.setBloatFinished(bloatDeathTick - bloatStartTick);\n        if (bloatStartTick !\u003d -1)\n        {\n            sendTimeMessage(\"Wave \u0027Bloat last down\u0027 complete! Duration: \", splitLastDown(), \" Room time: \", bloatDeathTick - bloatStartTick, true);\n        }\n    }\n\n    public int splitLastDown()\n    {\n        if (bloatDeathTick !\u003d -1)\n        {\n            if (walks.size() \u003d\u003d downs.size() + 1)\n            {\n                return bloatDeathTick - walks.get(walks.size() - 1);\n            } else if (walks.size() \u003d\u003d downs.size())\n            {\n                return bloatDeathTick - downs.get(walks.size() - 1);\n            } else\n            {\n                return -1;\n            }\n        } else\n        {\n            return -1;\n        }\n    }\n\n    public void start()\n    {\n        bloatStartTick \u003d client.getTickCount();\n        roomStartTick \u003d client.getTickCount();\n        roomState \u003d WALKING;\n    }\n\n    private int getLastWalk()\n    {\n        if (!downs.isEmpty() \u0026\u0026 !walks.isEmpty() \u0026\u0026 downs.size() \u003d\u003d walks.size())\n        {\n            return downs.get(downs.size() - 1) - walks.get(walks.size() - 1);\n        } else\n        {\n            return -1;\n        }\n    }\n\n    private int getLastDownTime()\n    {\n        if (!downs.isEmpty())\n        {\n            return downs.get(downs.size() - 1) - bloatStartTick;\n        } else\n        {\n            return -1;\n        }\n    }\n\n    private double deferHP \u003d -1;\n\n    public void down()\n    {\n        clog.addLine(BLOAT_DOWN, String.valueOf(client.getTickCount() - bloatStartTick));\n        if (downs.isEmpty())\n        {\n            int currentBloatHP \u003d client.getVarbitValue(HP_VARBIT);\n            clog.addLine(BLOAT_HP_1ST_DOWN, String.valueOf(currentBloatHP));\n        }\n        downs.add(client.getTickCount());\n        roomState \u003d DOWN;\n        if (bloatStartTick !\u003d -1)\n        {\n            deferHP \u003d client.getVarbitValue(HP_VARBIT) / 10.0;\n            bloatDeferTick \u003d client.getTickCount() + 5; //delay so that the chat message can\u0027t be used to know immediately know when bloat has gone down\n        }\n        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, \"Down\");\n    }\n\n    public void walk()\n    {\n        walks.add(client.getTickCount());\n        plugin.addDelayedLine(TOBRoom.BLOAT, client.getTickCount() - bloatStartTick, \"Moving\");\n        roomState \u003d WALKING;\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n        if (bloatDeferTick !\u003d -1 \u0026\u0026 bloatDeferTick \u003d\u003d client.getTickCount())\n        {\n            sendTimeMessage(\"Wave \u0027Bloat walk\u0027 complete! Duration: \", getLastWalk(), getLastDownTime(), true, \", HP: \" + deferHP + \"%\");\n            bloatDeferTick \u003d -1;\n        }\n        if (bloatStartTick \u003d\u003d -1)\n        { //room time starts when player enters either gate in the bloat region\n            if (RoomUtil.crossedLine(BLOAT_REGION, new Point(39, 30), new Point(39, 33), true, client)\n                    || RoomUtil.crossedLine(BLOAT_REGION, new Point(24, 30), new Point(24, 33), true, client))\n            {\n                start();\n                walk();\n            }\n        }\n\n        if (NyloHandler.instanceStart \u003d\u003d -1)\n        { //Nylo instance timer is started when the first player crosses the unreachable line by the bloat chest\n            if (RoomUtil.crossedLine(BLOAT_REGION, new Point(4, 31), new Point(4, 32), true, client))\n            {\n                NyloHandler.instanceStart \u003d client.getTickCount();\n            }\n        }\n    }\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n        if (event.getActor().getAnimation() \u003d\u003d BLOAT_DOWN_ANIMATION)\n        {\n            down();\n        } else if (event.getActor().getName() !\u003d null \u0026\u0026 event.getActor().getAnimation() \u003d\u003d -1 \u0026\u0026 event.getActor().getName().contains(\"Bloat\"))\n        {\n            walk();\n        }\n        if (event.getActor().getAnimation() \u003d\u003d BLOAT_DEATH_ANIMATION)\n        {\n            endBloat();\n        }\n        if (event.getActor().getAnimation() \u003d\u003d SCYTHE_ANIMATION)\n        {\n            if (event.getActor() instanceof Player)\n            {\n                Player p \u003d (Player) event.getActor();\n                clog.addLine(BLOAT_SCYTHE_1ST_WALK, p.getName(), String.valueOf(client.getTickCount() - bloatStartTick));\n            }\n        }\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        boolean story \u003d false;\n        switch (event.getNpc().getId())\n        {\n            case BLOAT_SM:\n                story \u003d true;\n                clog.addLine(IS_STORY_MODE);\n            case BLOAT_HM:\n                if (!story)\n                    clog.addLine(IS_HARD_MODE);\n            case BLOAT:\n                clog.addLine(BLOAT_SPAWNED);\n                if (client.getVarbitValue(ROOM_ACTIVE_VARBIT) !\u003d 0)\n                {\n                    accurateEntry \u003d false;\n                } else\n                {\n                    clog.addLine(ACCURATE_BLOAT_START);\n                    clog.addLine(BLOAT_DIRECTION, String.valueOf(event.getNpc().getCurrentOrientation()), String.valueOf(event.getNpc().getIndex()));\n                }\n                break;\n        }\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d BLOAT || id \u003d\u003d BLOAT_HM || id \u003d\u003d BLOAT_SM)\n        {\n            clog.addLine(BLOAT_DESPAWN, String.valueOf(client.getTickCount() - bloatStartTick));\n        }\n    }\n\n    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)\n    {\n        int id \u003d event.getGraphicsObject().getId();\n        if(id \u003d\u003d 1570 || id \u003d\u003d 1571 || id \u003d\u003d 1572 || id \u003d\u003d 1573) //various bloat hands\n        {\n            WorldPoint wp \u003d WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation());\n            clog.addLine(BLOAT_HAND, String.valueOf(id), String.valueOf(wp.getRegionX()), String.valueOf(wp.getRegionY()), String.valueOf(client.getTickCount()-roomStartTick));\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\BloatHandler.java"},{"fileName":"LobbyHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport net.runelite.api.Client;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\n\npublic class LobbyHandler extends RoomHandler\n{\n    public LobbyHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config)\n    {\n        super(client, clog, config);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\LobbyHandler.java"},{"fileName":"MaidenHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\n\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.constants.TobIDs;\nimport com.advancedraidtracker.utility.*;\n\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.maidenbloodtracking.BloodDamageToBeApplied;\nimport com.advancedraidtracker.utility.maidenbloodtracking.BloodPositionWrapper;\nimport com.advancedraidtracker.utility.wrappers.NPCTimeInChunkShell;\nimport com.advancedraidtracker.utility.wrappers.PlayerHitsWrapper;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.*;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.utility.ItemReference.*;\nimport static com.advancedraidtracker.utility.RoomUtil.crossedLine;\n\nimport com.advancedraidtracker.utility.wrappers.MaidenCrab;\nimport net.runelite.api.kit.KitType;\nimport net.runelite.client.game.ItemEquipmentStats;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.game.ItemStats;\n\n@Slf4j\npublic class MaidenHandler extends RoomHandler\n{\n    public RoomState.MaidenRoomState roomState;\n\n    int maidenStartTick;\n    int p70;\n    int p50;\n    int p30;\n    int maidenDeathTick;\n    NPC maidenNPC;\n    int bloodHeals \u003d 0;\n\n    private final com.advancedraidtracker.utility.Point MAIDEN_GATE_START \u003d new com.advancedraidtracker.utility.Point(32 , 29);\n    private final com.advancedraidtracker.utility.Point MAIDEN_GATE_END \u003d new com.advancedraidtracker.utility.Point(32, 32);\n\n    public int deferVarbitCheck \u003d -1;\n    ArrayList\u003cMaidenCrab\u003e maidenCrabs \u003d new ArrayList\u003c\u003e();\n    ArrayList\u003cMaidenCrab\u003e deferredCrabs \u003d new ArrayList\u003c\u003e();\n\n    ArrayList\u003cPlayerHitsWrapper\u003e hitsplatsPerPlayer;\n    ArrayList\u003cBloodPositionWrapper\u003e thrownBloodLocations;\n    ArrayList\u003cWorldPoint\u003e spawnedBloodLocations;\n    ArrayList\u003cInteger\u003e maidenHeals;\n    ArrayList\u003cBloodDamageToBeApplied\u003e queuedBloodDamage;\n\n    ArrayList\u003cPlayer\u003e dinhsers;\n\n\n    ArrayList\u003cNPCTimeInChunkShell\u003e npcs;\n\n\n    AdvancedRaidTrackerConfig config;\n    AdvancedRaidTrackerPlugin plugin;\n\n    private final ItemManager itemManager;\n\n    public MaidenHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin, ItemManager itemManager)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n        this.itemManager \u003d itemManager;\n        roomState \u003d RoomState.MaidenRoomState.NOT_STARTED;\n        p70 \u003d -1;\n        p50 \u003d -1;\n        p30 \u003d -1;\n        maidenStartTick \u003d -1;\n        maidenDeathTick \u003d -1;\n        accurateEntry \u003d true;\n        hitsplatsPerPlayer \u003d new ArrayList\u003c\u003e();\n        thrownBloodLocations \u003d new ArrayList\u003c\u003e();\n        spawnedBloodLocations \u003d new ArrayList\u003c\u003e();\n        maidenHeals \u003d new ArrayList\u003c\u003e();\n        queuedBloodDamage \u003d new ArrayList\u003c\u003e();\n        npcs \u003d new ArrayList\u003c\u003e();\n        dinhsers \u003d new ArrayList\u003c\u003e();\n        this.config \u003d config;\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d RoomState.MaidenRoomState.NOT_STARTED || roomState \u003d\u003d RoomState.MaidenRoomState.FINISHED);\n    }\n\n    public String getName()\n    {\n        return \"Maiden\";\n    }\n\n    public void reset()\n    {\n        roomState \u003d RoomState.MaidenRoomState.NOT_STARTED;\n        accurateEntry \u003d true;\n        p70 \u003d -1;\n        p50 \u003d -1;\n        p30 \u003d -1;\n        maidenStartTick \u003d -1;\n        maidenDeathTick \u003d -1;\n        hitsplatsPerPlayer.clear();\n        thrownBloodLocations.clear();\n        maidenHeals.clear();\n        queuedBloodDamage.clear();\n        deferredCrabs.clear();\n        bloodHeals \u003d 0;\n        npcs.clear();\n        dinhsers.clear();\n        super.reset();\n    }\n\n    public void startMaiden()\n    {\n        // Room already started, ignore request.\n        if (maidenStartTick !\u003d -1)\n            return;\n\n        maidenStartTick \u003d client.getTickCount();\n        roomStartTick \u003d client.getTickCount();\n        deferVarbitCheck \u003d maidenStartTick + 2;\n    }\n\n    public void proc70()\n    {\n        p70 \u003d super.client.getTickCount();\n        roomState \u003d RoomState.MaidenRoomState.PHASE_2;\n        if (maidenStartTick !\u003d -1)\n            sendTimeMessage(\"Wave \u0027Maiden phase 1\u0027 complete! Duration: \", p70 - maidenStartTick);\n        clog.addLine(MAIDEN_70S, String.valueOf(p70 - maidenStartTick));\n        plugin.addDelayedLine(TOBRoom.MAIDEN, p70 - maidenStartTick - 2, \"70s\");\n\n    }\n\n    public void proc50()\n    {\n        p50 \u003d super.client.getTickCount();\n        roomState \u003d RoomState.MaidenRoomState.PHASE_3;\n        if (maidenStartTick !\u003d -1)\n            sendTimeMessage(\"Wave \u0027Maiden phase 2\u0027 complete! Duration: \", p50 - maidenStartTick, p50 - p70);\n        clog.addLine(MAIDEN_50S, String.valueOf(p50 - maidenStartTick));\n        plugin.addDelayedLine(TOBRoom.MAIDEN, p50 - maidenStartTick - 2, \"50s\");\n    }\n\n    public void proc30()\n    {\n        p30 \u003d super.client.getTickCount();\n        roomState \u003d RoomState.MaidenRoomState.PHASE_4;\n        if (maidenStartTick !\u003d -1)\n            sendTimeMessage(\"Wave \u0027Maiden phase 3\u0027 complete! Duration: \", p30 - maidenStartTick, p30 - p50);\n        clog.addLine(MAIDEN_30S, String.valueOf(p30 - maidenStartTick));\n        plugin.addDelayedLine(TOBRoom.MAIDEN, p30 - maidenStartTick - 2, \"30s\");\n    }\n\n    public void endMaiden()\n    {\n        roomState \u003d RoomState.MaidenRoomState.FINISHED;\n        maidenDeathTick \u003d client.getTickCount() + MAIDEN_DEATH_ANIMATION_LENGTH;\n        if (maidenStartTick !\u003d -1)\n            sendTimeMessage(\"Wave \u0027Maiden Skip\u0027 complete! Duration: \", maidenDeathTick - maidenStartTick, maidenDeathTick - p30, false);\n        clog.addLine(ACCURATE_MAIDEN_END);\n        clog.addLine(MAIDEN_0HP, String.valueOf(client.getTickCount() - maidenStartTick));\n        plugin.addDelayedLine(TOBRoom.MAIDEN, client.getTickCount() - maidenStartTick, \"Dead\");\n        plugin.liveFrame.setMaidenFinished(maidenDeathTick - maidenStartTick);\n    }\n\n    private boolean didAuto \u003d false;\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n        if (event.getActor().getAnimation() \u003d\u003d MAIDEN_DEATH_ANIMATION)\n        {\n            endMaiden();\n        } else if (event.getActor().getAnimation() \u003d\u003d CHINCHOMPA_THROWN_ANIMATION)\n        {\n            if (event.getActor() instanceof Player)\n            {\n                Player player \u003d (Player) event.getActor();\n                Actor target \u003d player.getInteracting();\n                int distance \u003d target.getWorldArea().distanceTo(player.getWorldLocation());\n                clog.addLine(MAIDEN_CHIN_THROWN, player.getName(), String.valueOf(distance));\n                if (distance \u003c 4 || distance \u003e 6)\n                {\n                    if (config.showMistakesInChat())\n                    {\n                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", player.getName() + \" chinned from \" + distance + \" tiles away.\", null, false);\n                    }\n                }\n            }\n        } else if (event.getActor().getAnimation() \u003d\u003d DINHS_BULWARK_ANIMATION)\n        {\n            dinhsers.add((Player) event.getActor());\n        }\n        else if(event.getActor().getAnimation() \u003d\u003d MAIDEN_AUTO_ANIMATION)\n        {\n            didAuto \u003d true;\n        }\n    }\n\n    public int getDrainedStat(Player player) //Assumes berserker/ultor\n    {\n        if(player \u003d\u003d null)\n        {\n            return NONE;\n        }\n        int stab \u003d 0;\n        int slash \u003d 0;\n        int crush \u003d 0;\n        int magic \u003d 0;\n        int range \u003d 0;\n        PlayerComposition pc \u003d player.getPlayerComposition();\n        int[] wornItems \u003d {\n                pc.getEquipmentId(KitType.HEAD),\n                pc.getEquipmentId(KitType.CAPE),\n                pc.getEquipmentId(KitType.AMULET),\n                pc.getEquipmentId(KitType.WEAPON),\n                pc.getEquipmentId(KitType.TORSO),\n                pc.getEquipmentId(KitType.SHIELD),\n                pc.getEquipmentId(KitType.LEGS),\n                pc.getEquipmentId(KitType.HANDS),\n                pc.getEquipmentId(KitType.BOOTS)\n        };\n        for(int item : wornItems)\n        {\n            ItemStats itemStats \u003d itemManager.getItemStats(item);\n            if(itemStats !\u003d null)\n            {\n                ItemEquipmentStats itemEquipmentStats \u003d itemStats.getEquipment();\n                stab +\u003d itemEquipmentStats.getAstab();\n                slash +\u003d itemEquipmentStats.getAslash();\n                crush +\u003d itemEquipmentStats.getAcrush();\n                magic +\u003d itemEquipmentStats.getAmagic();\n                range +\u003d itemEquipmentStats.getArange();\n            }\n        }\n        if((stab \u003e\u003d magic \u0026\u0026 stab \u003e\u003d range) || (slash \u003e\u003d magic \u0026\u0026 slash \u003e\u003d range) || (crush \u003e\u003d magic \u0026\u0026 crush \u003e\u003d range))\n        {\n            return MELEE;\n        }\n        else if(magic \u003e range)\n        {\n            return MAGE;\n        }\n        else\n        {\n            return RANGE;\n        }\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n        NPC npc \u003d event.getNpc();\n        switch (npc.getId())\n        {\n            case TobIDs.MAIDEN_P0:\n            case TobIDs.MAIDEN_P1:\n            case TobIDs.MAIDEN_P2:\n            case TobIDs.MAIDEN_P3:\n            case TobIDs.MAIDEN_PRE_DEAD:\n            case TobIDs.MAIDEN_DEAD:\n            case TobIDs.MAIDEN_P0_HM:\n            case TobIDs.MAIDEN_P1_HM:\n            case TobIDs.MAIDEN_P2_HM:\n            case TobIDs.MAIDEN_P3_HM:\n            case TobIDs.MAIDEN_PRE_DEAD_HM:\n            case TobIDs.MAIDEN_DEAD_HM:\n            case TobIDs.MAIDEN_P0_SM:\n            case TobIDs.MAIDEN_P1_SM:\n            case TobIDs.MAIDEN_P2_SM:\n            case TobIDs.MAIDEN_P3_SM:\n            case TobIDs.MAIDEN_PRE_DEAD_SM:\n            case TobIDs.MAIDEN_DEAD_SM:\n                clog.addLine(MAIDEN_DESPAWNED, String.valueOf(client.getTickCount() - maidenStartTick));\n                break;\n            case MAIDEN_MATOMENOS:\n            case MAIDEN_MATOMENOS_HM:\n            case MAIDEN_MATOMENOS_SM:\n                maidenCrabs.removeIf(x -\u003e x.crab.equals(event.getNpc()));\n            default:\n                break;\n        }\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        NPC npc \u003d event.getNpc();\n        boolean story \u003d false;\n        switch (npc.getId())\n        {\n            case MAIDEN_P0_SM:\n            case MAIDEN_P1_SM:\n            case MAIDEN_P2_SM:\n            case MAIDEN_P3_SM:\n            case MAIDEN_PRE_DEAD_SM:\n            case MAIDEN_DEAD_SM:\n                story \u003d true;\n                clog.addLine(IS_STORY_MODE);\n            case MAIDEN_P0_HM:\n            case MAIDEN_P1_HM:\n            case MAIDEN_P2_HM:\n            case MAIDEN_P3_HM:\n            case MAIDEN_PRE_DEAD_HM:\n            case MAIDEN_DEAD_HM:\n                if (!story)\n                    clog.addLine(IS_HARD_MODE);\n            case MAIDEN_P0:\n            case MAIDEN_P1:\n            case MAIDEN_P2:\n            case MAIDEN_P3:\n            case MAIDEN_DEAD:\n                clog.addLine(MAIDEN_SPAWNED);\n                maidenNPC \u003d npc;\n                startMaiden();\n                break;\n            case MAIDEN_MATOMENOS:\n            case MAIDEN_MATOMENOS_HM:\n            case MAIDEN_MATOMENOS_SM:\n                String crabName \u003d identifySpawn(npc);\n                clog.addLine(ADD_NPC_MAPPING, String.valueOf(npc.getIndex()), crabName);\n                plugin.liveFrame.getPanel(getName()).addNPCMapping(npc.getIndex(), crabName);\n                plugin.liveFrame.getPanel(getName()).addMaidenCrab(crabName);\n                MaidenCrab crab \u003d new MaidenCrab(npc, AdvancedRaidTrackerPlugin.scale, crabName);\n                logCrabSpawn(crab.description);\n                maidenCrabs.add(crab);\n                break;\n            case TobIDs.MAIDEN_BLOOD:\n            case TobIDs.MAIDEN_BLOOD_HM:\n            case TobIDs.MAIDEN_BLOOD_SM:\n                clog.addLine(BLOOD_SPAWNED);\n                break;\n        }\n    }\n\n    public void handleNPCChanged(int id)\n    {\n        switch (id)\n        {\n            case MAIDEN_P1:\n            case MAIDEN_P1_HM:\n            case MAIDEN_P1_SM:\n                proc70();\n                break;\n            case MAIDEN_P2:\n            case MAIDEN_P2_HM:\n            case MAIDEN_P2_SM:\n                proc50();\n                break;\n            case MAIDEN_P3:\n            case MAIDEN_P3_HM:\n            case MAIDEN_P3_SM:\n                proc30();\n                break;\n            case MAIDEN_DEAD:\n            case MAIDEN_DEAD_HM:\n            case MAIDEN_DEAD_SM:\n                break;\n        }\n    }\n\n    private void logCrabSpawn(String description)\n    {\n        clog.addLine(MATOMENOS_SPAWNED, description);\n    }\n\n    private void applyBlood()\n    {\n        for (BloodDamageToBeApplied p : queuedBloodDamage)\n        {\n            int bloodDamage \u003d -1;\n            Optional\u003cPlayerHitsWrapper\u003e hits \u003d hitsplatsPerPlayer.stream().filter(playerHitsWrapper -\u003e playerHitsWrapper.name.equals(p.playerName)).findAny();\n            if (hits.isPresent())\n            {\n                bloodDamage \u003d hits.get().hitsplats.get(hits.get().hitsplats.size() - 1); //Last hitsplat is blood\n            }\n            if (bloodDamage !\u003d -1)\n            {\n                if (p.bloodTicksAlive \u003d\u003d -1)\n                {\n                    clog.addLine(PLAYER_STOOD_IN_SPAWNED_BLOOD, p.playerName, String.valueOf(bloodDamage)); //player, dmg\n                } else\n                {\n                    clog.addLine(PLAYER_STOOD_IN_THROWN_BLOOD, p.playerName, String.valueOf(bloodDamage), String.valueOf(p.bloodTicksAlive)); //player, dmg, blood tick\n                }\n                bloodHeals++;\n            }\n        }\n    }\n\n    private void assessBloodForNextTick()\n    {\n        queuedBloodDamage.clear();\n        for (Player p : client.getPlayers())\n        {\n            for (BloodPositionWrapper blood : thrownBloodLocations)\n            {\n                if (blood.initialTick \u003c\u003d client.getTickCount() \u0026\u0026 p.getWorldLocation().distanceTo(blood.location) \u003d\u003d 0)\n                {\n                    queuedBloodDamage.add(new BloodDamageToBeApplied(p.getName(), 10 - (blood.finalTick - client.getTickCount())));\n                }\n            }\n            for (WorldPoint blood : spawnedBloodLocations)\n            {\n                if (p.getWorldLocation().distanceTo(blood) \u003d\u003d 0)\n                {\n                    queuedBloodDamage.add(new BloodDamageToBeApplied(p.getName(), -1));\n                }\n            }\n        }\n\n        thrownBloodLocations.removeIf(bloodPositionWrapper -\u003e bloodPositionWrapper.finalTick \u003c\u003d client.getTickCount());\n    }\n\n    private void handleCrabHeals()\n    {\n        for (int i \u003d 0; i \u003c maidenHeals.size() - bloodHeals; i++)\n        {\n            clog.addLine(CRAB_HEALED_MAIDEN, String.valueOf(maidenHeals.get(i)));\n        }\n        bloodHeals \u003d 0;\n    }\n\n    private int findChunk(int x, int y)\n    {\n        int chunkX \u003d 3 - ((x - 8) / 8);\n        int chunkY \u003d 3 - ((y - 16) / 8);\n        return (4 * chunkX) + chunkY;\n    }\n\n    private void trackNPCMovements()\n    {\n        ArrayList\u003cNPCTimeInChunkShell\u003e merge \u003d new ArrayList\u003c\u003e();\n        for (NPC npc : client.getNpcs())\n        {\n            if (npcs.stream().noneMatch(o -\u003e o.npc.getIndex() \u003d\u003d npc.getIndex()))\n            {\n                merge.add(new NPCTimeInChunkShell(npc, findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY()), 0));\n            } else\n            {\n                int index \u003d -1;\n                for (int i \u003d 0; i \u003c npcs.size(); i++)\n                {\n                    if (npc.getIndex() \u003d\u003d npcs.get(i).npc.getIndex())\n                    {\n                        index \u003d i;\n                    }\n                }\n                if (index !\u003d -1)\n                {\n                    npcs.get(index).marked \u003d true;\n                    if (npcs.get(index).chunk \u003d\u003d findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY()))\n                    {\n                        npcs.get(index).timeInChunk++;\n                    } else\n                    {\n                        npcs.get(index).chunk \u003d findChunk(npc.getWorldLocation().getRegionX(), npc.getWorldLocation().getRegionY());\n                        npcs.get(index).timeInChunk \u003d 0;\n                    }\n                }\n\n            }\n        }\n        npcs.removeIf(o -\u003e !o.marked);\n        for (NPCTimeInChunkShell npc : npcs)\n        {\n            npc.marked \u003d false;\n        }\n        npcs.addAll(merge);\n    }\n\n    /*\n    Dinhs spec targets are picked in order of chunk relative to the player where they use the spec at, this grid:\n    7 4 1\n    8 5 2\n    9 6 3\n    is always centered around the player being in chunk 5, and the check starts in chunk 1, then moves to chunk 2, all the way to 9\n    if it will cross over 9 NPCs while checking a chunk, the NPCs are chosen on a last in first selected basis based on when\n    that NPC entered that chunk. The NPC must also be in a 11x11 area centered around the player to be targeted.\n\n    If multiple NPCs enter the chunk on the same tick, they are chosen by lowest NPC index first\n     */\n\n    private void analyzeDinhs()\n    {\n        for (Player p : dinhsers)\n        {\n            ArrayList\u003cNPC\u003e targets \u003d new ArrayList\u003c\u003e();\n            if (p.getInteracting() instanceof NPC)\n            {\n                NPC primaryTarget \u003d (NPC) p.getInteracting();\n                int primaryIndex \u003d primaryTarget.getIndex();\n                int centerX \u003d p.getWorldLocation().getRegionX();\n                int centerY \u003d p.getWorldLocation().getRegionY();\n                int centerChunk \u003d findChunk(centerX, centerY);\n                int minChunk \u003d centerChunk - 4;\n                int maxChunk \u003d centerChunk + 4;\n                for (int i \u003d minChunk; i \u003c\u003d maxChunk; i++)\n                {\n                    ArrayList\u003cNPCTimeInChunkShell\u003e potentialTargets \u003d new ArrayList\u003c\u003e();\n                    int maxToInclude \u003d 9 - targets.size();\n                    if (maxToInclude \u003e 0)\n                    {\n                        for (NPCTimeInChunkShell npc : npcs)\n                        {\n                            if (npc.chunk \u003d\u003d i)\n                            { //For some reason Maiden is NEVER targeted by additional dinhs hitsplat. Related to large non-moving NPCs\n                                if (!Objects.requireNonNull(npc.npc.getName()).contains(\"Maiden\") \u0026\u0026 !npc.npc.getName().contains(\"null\") \u0026\u0026 npc.npc.getHealthRatio() !\u003d 0)\n                                {\n                                    if (npc.npc.getWorldLocation().getRegionX() \u003c\u003d centerX + 5 \u0026\u0026\n                                            npc.npc.getWorldLocation().getRegionX() \u003e\u003d centerX - 5 \u0026\u0026\n                                            npc.npc.getWorldLocation().getRegionY() \u003c\u003d centerY + 5 \u0026\u0026\n                                            npc.npc.getWorldLocation().getRegionY() \u003e\u003d centerY - 5)\n                                    {\n                                        potentialTargets.add(npc);\n                                    }\n                                }\n                            }\n                        }\n                        if (potentialTargets.size() \u003e maxToInclude) //DO NOT REPLACE SORT METHODS WITH LIST.SORT OR WILL HAVE UNDEFINED RESULTS\n                        {\n                            Collections.sort(potentialTargets, Comparator.comparing(NPCTimeInChunkShell::getIndex));\n                            Collections.sort(potentialTargets, Comparator.comparing(NPCTimeInChunkShell::getTimeInChunk));\n                            for (int j \u003d 0; j \u003c maxToInclude; j++)\n                            {\n                                targets.add(potentialTargets.get(j).npc);\n                            }\n\n                        } else\n                        {\n                            for (NPCTimeInChunkShell npc : potentialTargets)\n                            {\n                                targets.add(npc.npc);\n                            }\n                        }\n                    }\n                }\n                String whichCrab \u003d \"\";\n                int primaryHP \u003d 0;\n                boolean didDoubleHit \u003d false;\n                for (MaidenCrab crab : maidenCrabs)\n                {\n                    if (primaryTarget.getIndex() \u003d\u003d crab.crab.getIndex())\n                    {\n                        whichCrab \u003d crab.description;\n                        primaryHP \u003d crab.health;\n                    }\n                }\n                String value3 \u003d primaryTarget.getName() + \"(\" + whichCrab + \")\" + \":\" + primaryHP;\n                StringBuilder value4 \u003d new StringBuilder();\n                if (targets.size() \u003c 9)\n                {\n                    if (config.showMistakesInChat())\n                    {\n                        client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", p.getName() + \" only targeted \" + targets.size() + \" additional NPCs with dinhs spec.\", null, false);\n                    }\n                }\n                ArrayList\u003cInteger\u003e healths \u003d new ArrayList\u003c\u003e();\n                for (NPC npc : targets)\n                {\n                    if (npc.getIndex() \u003d\u003d primaryIndex)\n                    {\n                        didDoubleHit \u003d true;\n                    }\n                    String additionalDescription \u003d \"^\";\n                    int hp \u003d -1;\n                    for (MaidenCrab crab : maidenCrabs)\n                    {\n                        if (crab.crab.getIndex() \u003d\u003d npc.getIndex())\n                        {\n                            additionalDescription \u003d crab.description;\n                            hp \u003d crab.health;\n                            healths.add(hp);\n                        }\n                    }\n                    value4.append(npc.getName()).append(\"~\").append(additionalDescription).append(\"~\").append(hp).append(\":\");\n                }\n                String value5 \u003d getTargetsBelow27(healths, targets, didDoubleHit);\n                clog.addLine(MAIDEN_DINHS_SPEC, p.getName(), value3, value4.toString(), value5);\n            }\n        }\n        dinhsers.clear();\n    }\n\n    private static String getTargetsBelow27(ArrayList\u003cInteger\u003e healths, ArrayList\u003cNPC\u003e targets, boolean didDoubleHit)\n    {\n        double total \u003d 0;\n        double count \u003d healths.size();\n        int belowThreshold \u003d 0;\n        for (Integer i : healths)\n        {\n            total +\u003d i;\n            if (i \u003c 27)\n            {\n                belowThreshold++;\n            }\n        }\n        double average \u003d total / healths.size();\n        return ((int) average) + \":\" + belowThreshold + \":\" + ((int) count) + \":\" + targets.size() + \":\" + didDoubleHit;\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n        if (roomStartTick \u003d\u003d -1 \u0026\u0026 crossedLine(12613, MAIDEN_GATE_START, MAIDEN_GATE_END, true, client)) {\n            clog.addLine(MAIDEN_SPAWNED);\n            startMaiden();\n        }\n        trackNPCMovements();\n        analyzeDinhs();\n\n        applyBlood();\n        handleCrabHeals();\n        assessBloodForNextTick();\n        hitsplatsPerPlayer.clear();\n        maidenHeals.clear();\n        if(didAuto)\n        {\n            Actor drained \u003d maidenNPC.getInteracting();\n            if (drained instanceof Player)\n            {\n                clog.addLine(MAIDEN_AUTO, drained.getName(), String.valueOf(client.getTickCount() - roomStartTick));\n                int statDrained \u003d getDrainedStat((Player) drained);\n                if (statDrained \u003d\u003d MELEE)\n                {\n                    if (config.showMistakesInChat())\n                    {\n                        plugin.sendChatMessage(\"Maiden drained \" + drained.getName() + \"\u0027s melee stats.\");\n                    }\n                    clog.addLine(MAIDEN_PLAYER_DRAINED, drained.getName(), String.valueOf((client.getTickCount() - roomStartTick)));\n                }\n            }\n            didAuto \u003d false;\n        }\n\n        for (MaidenCrab crab : deferredCrabs)\n        {\n            clog.addLine(CRAB_LEAK, crab.description, String.valueOf(crab.health));\n        }\n        maidenCrabs.removeAll(deferredCrabs);\n        deferredCrabs.clear();\n\n        if (client.getTickCount() \u003d\u003d deferVarbitCheck)\n        {\n            deferVarbitCheck \u003d -1;\n            if (client.getVarbitValue(HP_VARBIT) !\u003d FULL_HP)\n            {\n                accurateEntry \u003d false;\n            } else\n            {\n                accurateEntry \u003d true;\n                roomState \u003d RoomState.MaidenRoomState.PHASE_1;\n                clog.addLine(ACCURATE_MAIDEN_START);\n            }\n        }\n        for (MaidenCrab crab : maidenCrabs)\n        {\n            int distance \u003d crab.crab.getWorldArea().distanceTo2D(maidenNPC.getWorldArea());\n            if (distance \u003d\u003d 1 \u0026\u0026 crab.health \u003e 0)\n            {\n                deferredCrabs.add(crab);\n            }\n        }\n    }\n\n    /**\n     * Tracks crab hps\n     */\n    public void updateHitsplatApplied(HitsplatApplied event)\n    {\n        if (event.getActor() instanceof NPC) //getHealthRatio doesn\u0027t give fine enough increments so we manually track the HP\n        {\n            if (maidenCrabs.stream().map(x -\u003e x.crab).collect(Collectors.toList()).contains((NPC) event.getActor()))\n            {\n                MaidenCrab crab \u003d maidenCrabs.stream().filter(x -\u003e x.crab.equals(event.getActor())).collect(Collectors.toList()).get(0);\n                crab.health -\u003d event.getHitsplat().getAmount();\n            }\n        }\n        if (event.getActor() instanceof Player) //Heal tracking\n        {\n            if (hitsplatsPerPlayer.stream().noneMatch(playerHPWrapper -\u003e playerHPWrapper.name.equals(event.getActor().getName())))\n            {\n                hitsplatsPerPlayer.add(new PlayerHitsWrapper(event.getActor().getName(), event.getHitsplat().getAmount()));\n            } else\n            {\n                for (PlayerHitsWrapper playerHitsWrapper : hitsplatsPerPlayer)\n                {\n                    if (playerHitsWrapper.name.equals(event.getActor().getName()))\n                    {\n                        playerHitsWrapper.hitsplats.add(event.getHitsplat().getAmount());\n                    }\n                }\n            }\n        } else if (event.getActor().getName() !\u003d null \u0026\u0026 event.getActor().getName().contains(\"Maiden\"))\n        {\n            if (event.getHitsplat().getHitsplatType() \u003d\u003d HitsplatID.HEAL)\n            {\n                maidenHeals.add(event.getHitsplat().getAmount());\n            }\n        }\n    }\n\n    public void updateGameObjectSpawned(GameObjectSpawned event)\n    {\n        if (event.getGameObject().getId() \u003d\u003d BLOOD_ON_GROUND)\n        {\n            spawnedBloodLocations.add(event.getGameObject().getWorldLocation());\n        }\n    }\n\n    public void updateGameObjectDespawned(GameObjectDespawned event)\n    {\n        if (event.getGameObject().getId() \u003d\u003d BLOOD_ON_GROUND)\n        {\n            spawnedBloodLocations.removeIf(worldPoint -\u003e worldPoint.getRegionX() \u003d\u003d event.getGameObject().getWorldLocation().getRegionX() \u0026\u0026\n                    worldPoint.getRegionY() \u003d\u003d event.getGameObject().getWorldLocation().getRegionY());\n\n        }\n    }\n\n    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)\n    {\n        if (event.getGraphicsObject().getId() \u003d\u003d MAIDEN_THROWN_BLOOD_GRAPHIC_OBJECT)\n        {\n            thrownBloodLocations.add(new BloodPositionWrapper(WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation()), ((((event.getGraphicsObject().getStartCycle() - client.getGameCycle() + 1) / 30)) + client.getTickCount() - 1)));\n        }\n    }\n\n    /**\n     * Returns a string describing the spawn position of a maiden crab\n     *\n     */\n    private String identifySpawn(NPC npc)\n    {\n\n        int x \u003d npc.getWorldLocation().getRegionX();\n        int y \u003d npc.getWorldLocation().getRegionY();\n        String proc \u003d getProc();\n        if (x \u003d\u003d 21 \u0026\u0026 y \u003d\u003d 40)\n        {\n            return \"N1\" + proc;\n        }\n        if (x \u003d\u003d 22 \u0026\u0026 y \u003d\u003d 41)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"N1\");\n            return \"N1\" + proc;\n        }\n        if (x \u003d\u003d 25 \u0026\u0026 y \u003d\u003d 40)\n        {\n            return \"N2\" + proc;\n        }\n        if (x \u003d\u003d 26 \u0026\u0026 y \u003d\u003d 41)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"N2\");\n            return \"N2\" + proc;\n        }\n        if (x \u003d\u003d 29 \u0026\u0026 y \u003d\u003d 40)\n        {\n            return \"N3\" + proc;\n        }\n        if (x \u003d\u003d 30 \u0026\u0026 y \u003d\u003d 41)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"N3\");\n            return \"N3\" + proc;\n        }\n        if (x \u003d\u003d 33 \u0026\u0026 y \u003d\u003d 40)\n        {\n            return \"N4 (1)\" + proc;\n        }\n        if (x \u003d\u003d 34 \u0026\u0026 y \u003d\u003d 41)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"N4 (1)\");\n            return \"N4 (1)\" + proc;\n        }\n        if (x \u003d\u003d 33 \u0026\u0026 y \u003d\u003d 38)\n        {\n            return \"N4 (2)\" + proc;\n        }\n        if (x \u003d\u003d 34 \u0026\u0026 y \u003d\u003d 39)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"N4 (2)\");\n            return \"N4 (2)\" + proc;\n        }\n        //\n        if (x \u003d\u003d 21 \u0026\u0026 y \u003d\u003d 20)\n        {\n            return \"S1\" + proc;\n        }\n        if (x \u003d\u003d 22 \u0026\u0026 y \u003d\u003d 19)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"S1\");\n            return \"S1\" + proc;\n        }\n        if (x \u003d\u003d 25 \u0026\u0026 y \u003d\u003d 20)\n        {\n            return \"S2\" + proc;\n        }\n        if (x \u003d\u003d 26 \u0026\u0026 y \u003d\u003d 19)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"S2\");\n            return \"S2\" + proc;\n        }\n        if (x \u003d\u003d 29 \u0026\u0026 y \u003d\u003d 20)\n        {\n            return \"S3\" + proc;\n        }\n        if (x \u003d\u003d 30 \u0026\u0026 y \u003d\u003d 19)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"S3\");\n            return \"S3\" + proc;\n        }\n        if (x \u003d\u003d 33 \u0026\u0026 y \u003d\u003d 20)\n        {\n            return \"S4 (1)\" + proc;\n        }\n        if (x \u003d\u003d 34 \u0026\u0026 y \u003d\u003d 19)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"S4 (1)\");\n            return \"S4 (1)\" + proc;\n        }\n        if (x \u003d\u003d 33 \u0026\u0026 y \u003d\u003d 22)\n        {\n            return \"S4 (2)\" + proc;\n        }\n        if (x \u003d\u003d 34 \u0026\u0026 y \u003d\u003d 21)\n        {\n            clog.addLine(MAIDEN_SCUFFED, \"S4 (2)\");\n            return \"S4 (2)\" + proc;\n        } else\n        {\n            return \"Unknown\";\n        }\n    }\n\n    private String getProc()\n    {\n        String proc \u003d \"\";\n        if (maidenNPC.getId() \u003d\u003d MAIDEN_P1 || maidenNPC.getId() \u003d\u003d MAIDEN_P1_HM || maidenNPC.getId() \u003d\u003d MAIDEN_P1_SM)\n        {\n            proc \u003d \" 70s\";\n        } else if (maidenNPC.getId() \u003d\u003d MAIDEN_P2 || maidenNPC.getId() \u003d\u003d MAIDEN_P2_HM || maidenNPC.getId() \u003d\u003d MAIDEN_P2_SM)\n        {\n            proc \u003d \" 50s\";\n        } else if (maidenNPC.getId() \u003d\u003d MAIDEN_P3 || maidenNPC.getId() \u003d\u003d MAIDEN_P3_HM || maidenNPC.getId() \u003d\u003d MAIDEN_P3_SM)\n        {\n            proc \u003d \" 30s\";\n        }\n        return proc;\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\MaidenHandler.java"},{"fileName":"NyloHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.NPC;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.NpcDespawned;\nimport net.runelite.api.events.NpcSpawned;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.RoomState;\nimport com.advancedraidtracker.utility.nyloutility.NylocasData;\nimport com.advancedraidtracker.utility.nyloutility.NylocasShell;\nimport com.advancedraidtracker.utility.nyloutility.NylocasWave;\nimport com.advancedraidtracker.utility.nyloutility.NylocasWaveMatcher;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.utility.RoomState.NyloRoomState.*;\n\n@Slf4j\npublic class NyloHandler extends RoomHandler\n{\n    public RoomState.NyloRoomState roomState;\n    private final ArrayList\u003cNylocasShell\u003e buildWave;\n\n    public NyloHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n        buildWave \u003d new ArrayList\u003c\u003e();\n        nylosAlive \u003d new ArrayList\u003c\u003e();\n        roomState \u003d NOT_STARTED;\n    }\n\n    public static int instanceStart \u003d -1;\n    private int pillarsSpawnedTick \u003d -1;\n    private int instanceReference \u003d -1;\n    private int bossSpawn \u003d -1;\n    private int lastDead \u003d -1;\n    private int entryTickOffset \u003d -1;\n    private int wave31 \u003d -1;\n    private final ArrayList\u003cNPC\u003e nylosAlive;\n    int currentWave \u003d 0;\n    boolean hard \u003d false;\n    boolean story \u003d false;\n    private final AdvancedRaidTrackerPlugin plugin;\n    ArrayList\u003cNPC\u003e bigsDeadThisTick \u003d new ArrayList\u003c\u003e();\n    Map\u003cInteger, String\u003e bigDescription \u003d new HashMap\u003c\u003e();\n\n    public void reset()\n    {\n        currentWave \u003d 0;\n        roomState \u003d NOT_STARTED;\n        pillarsSpawnedTick \u003d -1;\n        instanceReference \u003d -1;\n        instanceStart \u003d -1;\n        bossSpawn \u003d -1;\n        lastDead \u003d -1;\n        accurateEntry \u003d true;\n        entryTickOffset \u003d -1;\n        hard \u003d false;\n        story \u003d false;\n        wave31 \u003d -1;\n        bigsDeadThisTick.clear();\n        bigDescription.clear();\n        super.reset();\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d NOT_STARTED || roomState \u003d\u003d FINISHED);\n    }\n\n    public String getName()\n    {\n        return \"Nylocas\";\n    }\n\n    private int expectedWaveTick;\n\n    public void updateGameTick(GameTick event)\n    {\n        bigsDeadThisTick.clear();\n        if (!buildWave.isEmpty())\n        {\n            if (NylocasWaveMatcher.isWave(buildWave))\n            {\n                NylocasWave wave \u003d NylocasWaveMatcher.getWave();\n                if (wave.getWave() \u003d\u003d 1)\n                {\n                    wave1Spawn();\n                }\n                if (wave.getWave() \u003d\u003d 31)\n                {\n                    wave31Spawn();\n                } else\n                {\n                    expectedWaveTick \u003d client.getTickCount() + ((hard \u0026\u0026 wave.getWave() % 10 \u003d\u003d 0) ? 16 : NylocasWave.waves[wave.getWave()].getDelay());\n                    if (hard \u0026\u0026 (wave.getWave() % 10 \u003d\u003d 0)) //in hard mode each wave a prinkipas comes out on (10, 20, 30) has been changed to a 4 cycle natural delay\n                    {\n                        expectedWaveTick \u003d client.getTickCount() + 16;\n                    }\n                }\n                currentWave \u003d wave.getWave();\n                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, \"W\" + currentWave);\n                clog.addLine(NYLO_WAVE, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n            }\n            buildWave.clear();\n        }\n        if (client.getTickCount() \u003d\u003d expectedWaveTick \u0026\u0026 currentWave !\u003d 31)\n        {\n            clog.addLine(NYLO_STALL, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick), String.valueOf(nylosAlive.size()));\n            plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, \"Stall\");\n            expectedWaveTick +\u003d 4;\n        }\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        switch (event.getNpc().getId())\n        {\n            case NYLO_MELEE_SMALL_HM:\n            case NYLO_MELEE_SMALL_AGRO_HM:\n            case NYLO_MELEE_BIG_HM:\n            case NYLO_MELEE_BIG_AGRO_HM:\n            case NYLO_RANGE_SMALL_HM:\n            case NYLO_RANGE_SMALL_AGRO_HM:\n            case NYLO_RANGE_BIG_HM:\n            case NYLO_RANGE_BIG_AGRO_HM:\n            case NYLO_MAGE_SMALL_HM:\n            case NYLO_MAGE_SMALL_AGRO_HM:\n            case NYLO_MAGE_BIG_HM:\n            case NYLO_MAGE_BIG_AGRO_HM:\n                if (!hard)\n                {\n                    clog.addLine(IS_HARD_MODE);\n                }\n                hard \u003d true;\n            case NYLO_MELEE_SMALL_SM:\n            case NYLO_MELEE_SMALL_AGRO_SM:\n            case NYLO_MELEE_BIG_SM:\n            case NYLO_MELEE_BIG_AGRO_SM:\n            case NYLO_RANGE_SMALL_SM:\n            case NYLO_RANGE_SMALL_AGRO_SM:\n            case NYLO_RANGE_BIG_SM:\n            case NYLO_RANGE_BIG_AGRO_SM:\n            case NYLO_MAGE_SMALL_SM:\n            case NYLO_MAGE_SMALL_AGRO_SM:\n            case NYLO_MAGE_BIG_SM:\n            case NYLO_MAGE_BIG_AGRO_SM:\n                if (!hard)\n                {\n                    if (!story)\n                    {\n                        clog.addLine(IS_STORY_MODE);\n                    }\n                }\n                story \u003d true;\n            case NYLO_MELEE_BIG:\n            case NYLO_MELEE_BIG_AGRO:\n            case NYLO_RANGE_BIG:\n            case NYLO_RANGE_BIG_AGRO:\n            case NYLO_MAGE_BIG:\n            case NYLO_MAGE_BIG_AGRO:\n            case NYLO_MELEE_SMALL:\n            case NYLO_MELEE_SMALL_AGRO:\n            case NYLO_RANGE_SMALL:\n            case NYLO_RANGE_SMALL_AGRO:\n            case NYLO_MAGE_SMALL:\n            case NYLO_MAGE_SMALL_AGRO:\n                if(pillarsSpawnedTick \u003d\u003d -1)\n                {\n                    startNylo();\n                }\n                NylocasShell cShell \u003d new NylocasShell(event.getNpc().getId(), event.getNpc().getWorldLocation().getRegionX(), event.getNpc().getWorldLocation().getRegionY());\n                if (cShell.isBig())\n                {\n                    bigDescription.put(event.getNpc().getIndex(), \"W\" + (currentWave + 1) + \" \" + cShell.getDescription());\n                }\n                if (cShell.position !\u003d NylocasData.NyloPosition.ROOM)\n                {\n                    buildWave.add(cShell);\n                    plugin.liveFrame.getPanel(getName()).addNPCMapping(event.getNpc().getIndex(), \"W\" + (currentWave + 1) + \" \" + cShell.getDescription());\n                    clog.addLine(ADD_NPC_MAPPING, String.valueOf(event.getNpc().getIndex()), \"W\" + (currentWave + 1) + \" \" + cShell.getDescription());\n                } else\n                {\n                    int matches \u003d 0;\n                    String lastMatchedDescription \u003d \"\";\n                    for (NPC npc : bigsDeadThisTick)\n                    {\n                        int bigX \u003d npc.getWorldLocation().getRegionX();\n                        int bigY \u003d npc.getWorldLocation().getRegionY();\n                        int littleX \u003d event.getNpc().getWorldLocation().getRegionX();\n                        int littleY \u003d event.getNpc().getWorldLocation().getRegionY();\n                        if ((bigX \u003d\u003d littleX \u0026\u0026 bigY \u003d\u003d littleY) || (littleX - 1 \u003d\u003d bigX || littleY - 1 \u003d\u003d bigY))\n                        {\n                            matches++;\n                            lastMatchedDescription \u003d bigDescription.get(npc.getIndex());\n                        }\n                    }\n                    if (matches \u003d\u003d 1)\n                    {\n                        clog.addLine(ADD_NPC_MAPPING, String.valueOf(event.getNpc().getIndex()), NylocasShell.getTypeName(event.getNpc().getId()) + \" split from \" + lastMatchedDescription + \"(on w\" + currentWave + \")\");\n                        plugin.liveFrame.getPanel(getName()).addNPCMapping(event.getNpc().getIndex(), NylocasShell.getTypeName(event.getNpc().getId()) + \" split from \" + lastMatchedDescription + \"(on w\" + currentWave + \")\");\n                    }\n                    switch (event.getNpc().getId())\n                    {\n                        case NYLO_MELEE_SMALL:\n                        case NYLO_MELEE_SMALL_AGRO:\n                        case NYLO_MELEE_SMALL_HM:\n                        case NYLO_MELEE_SMALL_AGRO_HM:\n                        case NYLO_MELEE_SMALL_SM:\n                        case NYLO_MELEE_SMALL_AGRO_SM:\n                            clog.addLine(MELEE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                            break;\n                        case NYLO_RANGE_SMALL:\n                        case NYLO_RANGE_SMALL_AGRO:\n                        case NYLO_RANGE_SMALL_HM:\n                        case NYLO_RANGE_SMALL_AGRO_HM:\n                        case NYLO_RANGE_SMALL_SM:\n                        case NYLO_RANGE_SMALL_AGRO_SM:\n                            clog.addLine(RANGE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                            break;\n                        case NYLO_MAGE_SMALL:\n                        case NYLO_MAGE_SMALL_AGRO:\n                        case NYLO_MAGE_SMALL_HM:\n                        case NYLO_MAGE_SMALL_AGRO_HM:\n                        case NYLO_MAGE_SMALL_SM:\n                        case NYLO_MAGE_SMALL_AGRO_SM:\n                            clog.addLine(MAGE_SPLIT, String.valueOf(currentWave), String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                            break;\n                    }\n                }\n                nylosAlive.add(event.getNpc());\n                break;\n            case NYLO_BOSS_MELEE:\n            case NYLO_BOSS_RANGE:\n            case NYLO_BOSS_MAGE:\n            case NYLO_BOSS_MELEE_HM:\n            case NYLO_BOSS_RANGE_HM:\n            case NYLO_BOSS_MAGE_HM:\n            case NYLO_BOSS_MELEE_SM:\n            case NYLO_BOSS_RANGE_SM:\n            case NYLO_BOSS_MAGE_SM:\n                bossSpawned();\n                if(pillarsSpawnedTick \u003d\u003d -1)\n                {\n                    startNylo();\n                }\n                break;\n            case NYLO_PILLAR:\n            case NYLO_PILLAR_HM:\n            case NYLO_PILLAR_SM:\n                if (pillarsSpawnedTick \u003d\u003d -1)\n                {\n                    startNylo();\n                }\n                break;\n            case NYLO_PRINKIPAS_DROPPING:\n                break;\n            case NYLO_PRINKIPAS_MELEE:\n            case NYLO_PRINKIPAS_MAGIC:\n            case NYLO_PRINKIPAS_RANGE:\n                nylosAlive.add(event.getNpc());\n                break;\n\n        }\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n        switch (event.getNpc().getId())\n        {\n            case NYLO_PILLAR:\n            case NYLO_PILLAR_HM:\n            case NYLO_PILLAR_SM:\n                clog.addLine(NYLO_PILLAR_DESPAWNED, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                break;\n            case NYLO_BOSS_MELEE:\n            case NYLO_BOSS_RANGE:\n            case NYLO_BOSS_MAGE:\n            case NYLO_BOSS_MELEE_HM:\n            case NYLO_BOSS_RANGE_HM:\n            case NYLO_BOSS_MAGE_HM:\n            case NYLO_BOSS_MELEE_SM:\n            case NYLO_BOSS_RANGE_SM:\n            case NYLO_BOSS_MAGE_SM:\n            {\n                bossKilled();\n            }\n            break;\n            case NYLO_MELEE_BIG:\n            case NYLO_MELEE_BIG_AGRO:\n            case NYLO_MAGE_BIG:\n            case NYLO_MAGE_BIG_AGRO:\n            case NYLO_RANGE_BIG:\n            case NYLO_RANGE_BIG_AGRO:\n            case NYLO_MELEE_BIG_HM:\n            case NYLO_MELEE_BIG_AGRO_HM:\n            case NYLO_RANGE_BIG_HM:\n            case NYLO_RANGE_BIG_AGRO_HM:\n            case NYLO_MAGE_BIG_HM:\n            case NYLO_MAGE_BIG_AGRO_HM:\n            case NYLO_MELEE_BIG_SM:\n            case NYLO_MELEE_BIG_AGRO_SM:\n            case NYLO_RANGE_BIG_SM:\n            case NYLO_RANGE_BIG_AGRO_SM:\n            case NYLO_MAGE_BIG_SM:\n            case NYLO_MAGE_BIG_AGRO_SM:\n                bigsDeadThisTick.add(event.getNpc());\n            case NYLO_MELEE_SMALL_HM:\n            case NYLO_MELEE_SMALL_AGRO_HM:\n            case NYLO_RANGE_SMALL_HM:\n            case NYLO_RANGE_SMALL_AGRO_HM:\n            case NYLO_MAGE_SMALL_HM:\n            case NYLO_MAGE_SMALL_AGRO_HM:\n            case NYLO_MELEE_SMALL_SM:\n            case NYLO_MELEE_SMALL_AGRO_SM:\n            case NYLO_RANGE_SMALL_SM:\n            case NYLO_RANGE_SMALL_AGRO_SM:\n            case NYLO_MAGE_SMALL_SM:\n            case NYLO_MAGE_SMALL_AGRO_SM:\n            case NYLO_MELEE_SMALL:\n            case NYLO_MELEE_SMALL_AGRO:\n            case NYLO_RANGE_SMALL:\n            case NYLO_RANGE_SMALL_AGRO:\n            case NYLO_MAGE_SMALL:\n            case NYLO_MAGE_SMALL_AGRO:\n            case NYLO_PRINKIPAS_DROPPING:\n            case NYLO_PRINKIPAS_MELEE:\n            case NYLO_PRINKIPAS_MAGIC:\n            case NYLO_PRINKIPAS_RANGE:\n                nylosAlive.remove(event.getNpc());\n                if (nylosAlive.isEmpty() \u0026\u0026 NylocasWaveMatcher.getWave().getWave() \u003d\u003d 31)\n                {\n                    cleanupOver();\n                }\n                break;\n            default:\n                break;\n        }\n    }\n\n    /**\n     * Handles saving data about boss phases.\n     *\n     * @param id ID of new form\n     */\n    public void handleNPCChanged(int id)\n    {\n        switch (id)\n        {\n            case NYLO_BOSS_MELEE:\n            case NYLO_BOSS_MELEE_HM:\n            case NYLO_BOSS_MELEE_SM:\n                clog.addLine(MELEE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, \"Phase\");\n                break;\n            case NYLO_BOSS_MAGE:\n            case NYLO_BOSS_MAGE_HM:\n            case NYLO_BOSS_MAGE_SM:\n                clog.addLine(MAGE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, \"Phase\");\n                break;\n            case NYLO_BOSS_RANGE:\n            case NYLO_BOSS_RANGE_HM:\n            case NYLO_BOSS_RANGE_SM:\n                clog.addLine(RANGE_PHASE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n                plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick, \"Phase\");\n                break;\n        }\n    }\n\n    private void startNylo()\n    {\n        if (client.getNpcs().stream().anyMatch(p -\u003e Objects.requireNonNull(p.getName()).toLowerCase().contains(\"nylo\")))\n        {\n            accurateEntry \u003d false;\n        }\n        else\n        {\n            clog.addLine(ACCURATE_NYLO_START);\n        }\n        clog.addLine(NYLO_PILLAR_SPAWN);\n        roomState \u003d WAVES;\n        pillarsSpawnedTick \u003d client.getTickCount();\n        roomStartTick \u003d client.getTickCount();\n    }\n\n    private void wave1Spawn()\n    {\n        instanceReference \u003d client.getTickCount();\n        entryTickOffset \u003d (instanceReference - pillarsSpawnedTick - 4);\n    }\n\n    private void wave31Spawn()\n    {\n        clog.addLine(LAST_WAVE, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n        roomState \u003d CLEANUP;\n        int stalls \u003d (client.getTickCount() - pillarsSpawnedTick - entryTickOffset - 236) / 4;\n        wave31 \u003d client.getTickCount();\n        sendTimeMessage(\"Wave \u0027Nylocas last wave\u0027 complete! Duration: \", wave31 - pillarsSpawnedTick, \" Stalls: \", stalls);\n    }\n\n    private void cleanupOver()\n    {\n        roomState \u003d WAITING_FOR_BOSS;\n        lastDead \u003d client.getTickCount();\n        clog.addLine(ACCURATE_NYLO_END);\n        clog.addLine(LAST_DEAD, String.valueOf(lastDead - pillarsSpawnedTick));\n        sendTimeMessage(\"Wave \u0027Nylocas waves and cleanup\u0027 complete! Duration: \", lastDead - pillarsSpawnedTick, lastDead - wave31);\n    }\n\n    private void bossSpawned()\n    {\n        clog.addLine(BOSS_SPAWN, String.valueOf(client.getTickCount() - pillarsSpawnedTick));\n        roomState \u003d BOSS;\n        bossSpawn \u003d client.getTickCount() - 2;\n        plugin.addDelayedLine(TOBRoom.NYLOCAS, client.getTickCount() - pillarsSpawnedTick - 2, \"W\" + currentWave);\n        sendTimeMessage(\"Wave \u0027Nylocas boss spawn\u0027 complete! Duration: \", bossSpawn - pillarsSpawnedTick, bossSpawn - lastDead);\n    }\n\n    private void bossKilled()\n    {\n        roomState \u003d FINISHED;\n        int deathTick \u003d client.getTickCount();\n        int offset1 \u003d 4 - ((deathTick - instanceReference) % 4);\n        if ((4 - ((deathTick - instanceReference) % 4) \u003d\u003d 4))\n        {\n            offset1 \u003d 0;\n        }\n        plugin.liveFrame.setNyloFinished(deathTick - pillarsSpawnedTick + offset1);\n        sendTimeMessage(\"Wave \u0027Nylocas boss\u0027 complete! Duration: \", deathTick - pillarsSpawnedTick + offset1, deathTick + offset1 - bossSpawn, false);\n        clog.addLine(NYLO_DESPAWNED, String.valueOf(deathTick - pillarsSpawnedTick + offset1));\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\NyloHandler.java"},{"fileName":"RoomHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport lombok.Getter;\nimport lombok.Setter;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.events.*;\nimport com.advancedraidtracker.utility.RoomUtil;\n\npublic class RoomHandler\n{\n    protected Client client;\n    protected DataWriter clog;\n    public int roomStartTick \u003d -1;\n\n    private final AdvancedRaidTrackerConfig config;\n    protected boolean accurateTimer \u003d true;\n    protected boolean accurateEntry \u003d true;\n    @Getter\n    @Setter\n    int scale;\n\n    protected String defaultColor()\n    {\n        return (client.isResized()) ? \"\u003ccol\u003dFFFFFF\u003e\" : \"\u003ccol\u003d000000\u003e\";\n    }\n\n    protected String timeColor()\n    {\n        return \"\u003ccol\u003dEF1020\u003e\";\n    }\n\n    public RoomHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config)\n    {\n        this.client \u003d client;\n        this.clog \u003d clog;\n        this.config \u003d config;\n    }\n\n    private String accuracy()\n    {\n        return (accurateTimer) ? \"\" : \"**\";\n    }\n\n    private String entry()\n    {\n        return (accurateEntry) ? \"\" : \"*\";\n    }\n\n    protected void sendTimeMessage(String message, int duration)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage \u003d message + timeColor() + RoomUtil.time(duration) + entry() + accuracy();\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n    protected void sendTimeMessage(String message, int duration, int split)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage \u003d message + timeColor() + RoomUtil.time(duration) + entry() + accuracy() + \" (\" + RoomUtil.time(split) + \")\";\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n    protected void sendTimeMessage(String message, int duration, int split, boolean bloat)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage;\n            if (bloat)\n            {\n                splitMessage \u003d message + timeColor() + duration + entry() + accuracy() + \" (\" + RoomUtil.time(split) + \")\";\n            } else\n            {\n                splitMessage \u003d message + timeColor() + RoomUtil.time(split) + entry() + accuracy() + defaultColor() + \" Room time: \" + timeColor() + RoomUtil.time(duration);\n            }\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n    protected void sendTimeMessage(String message, int duration, int split, boolean bloat, String alternate)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage;\n            if (bloat)\n            {\n                splitMessage \u003d message + timeColor() + duration + entry() + accuracy() + \" (\" + RoomUtil.time(split) + \")\" + defaultColor() + alternate;\n            } else\n            {\n                splitMessage \u003d message + timeColor() + RoomUtil.time(split) + entry() + accuracy() + defaultColor() + \" Room time: \" + timeColor() + RoomUtil.time(duration) + defaultColor() + alternate;\n            }\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n    protected void sendTimeMessage(String message, int duration, String alternateText, int alternateNumber)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage \u003d message + timeColor() + RoomUtil.time(duration) + entry() + accuracy() + defaultColor() + alternateText + timeColor() + alternateNumber;\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n\n    protected void sendTimeMessage(String message, int duration, String alternateText, int alternateNumber, boolean bloat)\n    {\n        if (config.chatSplits())\n        {\n            String splitMessage \u003d message + timeColor() + duration + entry() + accuracy() + alternateText + RoomUtil.time(alternateNumber);\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        }\n    }\n\n    public void handleNPCChanged(int id)\n    {\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n    }\n\n    public void updateOverheadText(OverheadTextChanged event)\n    {\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n    }\n\n    public void updateItemSpawned(ItemSpawned event)\n    {\n\n    }\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n    }\n\n    public void updateInteractingChanged(InteractingChanged event)\n    {\n    }\n\n    public void updateHitsplatApplied(HitsplatApplied event)\n    {\n    }\n\n    public void updateGraphicChanged(GraphicChanged event)\n    {\n    }\n\n    public void updateProjectileMoved(ProjectileMoved event)\n    {\n    }\n\n    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)\n    {\n    }\n\n    public void updateGameObjectSpawned(GameObjectSpawned event)\n    {\n    }\n\n    public void updateGameObjectDespawned(GameObjectDespawned event)\n    {\n    }\n\n    public void updateGroundObjectSpawned(GroundObjectSpawned event)\n    {\n\n    }\n\n    public String getName()\n    {\n        return \"\";\n    }\n\n    public boolean isActive()\n    {\n        return false;\n    }\n\n    public void reset()\n    {\n        roomStartTick \u003d -1;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\RoomHandler.java"},{"fileName":"SotetsegHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.constants.LogID;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.utility.Point;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.api.events.*;\nimport com.advancedraidtracker.utility.RoomState;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.advancedraidtracker.constants.TobIDs.*;\n\n@Slf4j\npublic class SotetsegHandler extends RoomHandler\n{\n    public RoomState.SotetsegRoomState roomState \u003d RoomState.SotetsegRoomState.NOT_STARTED;\n    private int soteEntryTick \u003d -1;\n    private int soteFirstMazeStart \u003d -1;\n    private int soteSecondMazeStart \u003d -1;\n    private int soteFirstMazeEnd \u003d -1;\n    private int soteSecondMazeEnd \u003d -1;\n    private int soteDeathTick \u003d -1;\n    private int deferTick \u003d -1;\n    private int lastRegion \u003d -1;\n    private final AdvancedRaidTrackerPlugin plugin;\n    private boolean hasSteppedOnMaze \u003d false;\n    private String firstMazeChosen \u003d \"\";\n    private String secondMazeChosen \u003d \"\";\n    private String lastChosen \u003d \"\";\n    private final Map\u003cString, ArrayList\u003cPoint\u003e\u003e playerTiles \u003d new HashMap\u003c\u003e();\n\n    private ArrayList\u003cPoint\u003e excludedTiles \u003d new ArrayList\u003c\u003e();\n    private final AdvancedRaidTrackerConfig config;\n\n    public SotetsegHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n        this.config \u003d config;\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d RoomState.SotetsegRoomState.NOT_STARTED || roomState \u003d\u003d RoomState.SotetsegRoomState.FINISHED);\n    }\n\n    public String getName()\n    {\n        return \"Sotetseg\";\n    }\n\n    public void reset()\n    {\n        super.reset();\n        playerTiles.clear();\n        lastChosen \u003d \"\";\n        excludedTiles.clear();\n        accurateTimer \u003d true;\n        soteEntryTick \u003d -1;\n        roomState \u003d RoomState.SotetsegRoomState.NOT_STARTED;\n        soteFirstMazeStart \u003d -1;\n        soteSecondMazeStart \u003d -1;\n        soteFirstMazeEnd \u003d -1;\n        soteSecondMazeEnd \u003d -1;\n        soteDeathTick \u003d -1;\n        lastRegion \u003d -1;\n        hasSteppedOnMaze \u003d false;\n        firstMazeChosen \u003d \"\";\n        secondMazeChosen \u003d \"\";\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d SOTETSEG_ACTIVE || id \u003d\u003d SOTETSEG_ACTIVE_HM || id \u003d\u003d SOTETSEG_ACTIVE_SM)\n        {\n            if (lastRegion \u003d\u003d SOTETSEG_UNDERWORLD)\n            {\n                if (roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_1)\n                {\n                    endFirstMaze();\n                } else if (roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_2)\n                {\n                    endSecondMaze();\n                }\n            }\n        }\n    }\n\n    private ArrayList\u003cPoint\u003e currentMaze \u003d new ArrayList\u003c\u003e();\n\n    public void updateGroundObjectSpawned(GroundObjectSpawned event)\n    {\n        if(!hasSteppedOnMaze)\n        {\n            if (event.getGroundObject().getId() \u003d\u003d SOTETSEG_RED_TILE \u0026\u0026 lastRegion \u003d\u003d SOTETSEG_OVERWORLD)\n            {\n                hasSteppedOnMaze \u003d true;\n                int ticksSinceLastProc \u003d -1;\n                if(roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_1)\n                {\n                    ticksSinceLastProc \u003d client.getTickCount()-soteFirstMazeStart;\n                }\n                else\n                {\n                    if(roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_2)\n                    {\n                        ticksSinceLastProc \u003d client.getTickCount()-soteSecondMazeStart;\n                    }\n                }\n                if(ticksSinceLastProc !\u003d -1 \u0026\u0026 lastRegion \u003d\u003d SOTETSEG_OVERWORLD)\n                {\n                    int distance \u003d Math.abs(event.getGroundObject().getWorldLocation().getRegionX()-15);\n                    int stallDuration \u003d 5;\n                    int tickOffset \u003d 1 + stallDuration + (int)((distance-0.5)/2.0);\n                    if(ticksSinceLastProc \u003e tickOffset \u0026\u0026 config.showMistakesInChat())\n                    {\n                        String mazeRunner \u003d (roomState\u003d\u003d RoomState.SotetsegRoomState.MAZE_1) ? firstMazeChosen : secondMazeChosen;\n                        plugin.sendChatMessage(mazeRunner + \" was late to first tile by \" + (ticksSinceLastProc-tickOffset) + \" ticks\");\n                    }\n                }\n            }\n        }\n        if (event.getGroundObject().getId() \u003d\u003d SOTETSEG_RED_TILE \u0026\u0026 lastRegion \u003d\u003d SOTETSEG_OVERWORLD)\n        {\n            int currentTileX \u003d event.getGroundObject().getWorldLocation().getRegionX();\n            int currentTileY \u003d event.getGroundObject().getWorldLocation().getRegionY();\n            currentMaze.add(new Point(currentTileX, currentTileY));\n        }\n    }\n\n    private static ArrayList\u003cPoint\u003e removeDuplicatePoints(ArrayList\u003cPoint\u003e tiles)\n    {\n        ArrayList\u003cPoint\u003e newTiles \u003d new ArrayList\u003c\u003e();\n        Point old \u003d null;\n        for(Point p : tiles)\n        {\n            if(old !\u003d null)\n            {\n                if(!(p.getX() \u003d\u003d old.getX() \u0026\u0026 p.getY() \u003d\u003d old.getY()))\n                {\n                    newTiles.add(p);\n                }\n            }\n            else\n            {\n                newTiles.add(p);\n            }\n            old \u003d p;\n        }\n        return newTiles;\n    }\n\n    private ArrayList\u003cPoint\u003e addEveryTileBetween(ArrayList\u003cPoint\u003e tiles)\n    {\n        ArrayList\u003cPoint\u003e allTiles \u003d new ArrayList\u003c\u003e();\n        Point previous \u003d null;\n        for(Point p : tiles)\n        {\n            if(previous !\u003d null)\n            {\n                allTiles.addAll(everyTileBetween(previous, p));\n            }\n            previous \u003d p;\n        }\n        return removeDuplicatePoints(allTiles);\n    }\n    public static ArrayList\u003cPoint\u003e everyTileBetween(Point start, Point end)\n    {\n        if(end.getY() \u003c start.getY())\n        {\n            return new ArrayList\u003c\u003e();\n        }\n        ArrayList\u003cPoint\u003e crossTiles \u003d new ArrayList\u003c\u003e();\n        crossTiles.add(start);\n        while (Math.abs(end.getX() - crossTiles.get(crossTiles.size() - 1).getX()) !\u003d end.getY() - crossTiles.get(crossTiles.size() - 1).getY())\n        {\n            if(crossTiles.size() \u003e 1000)\n            {\n                return new ArrayList\u003c\u003e();\n            }\n            if (Math.abs(end.getX() - start.getX()) \u003e end.getY() - start.getY())\n            {\n                int offset \u003d (end.getX() - start.getX() \u003e 0) ? 1 : -1;\n                crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX() + offset, crossTiles.get(crossTiles.size() - 1).getY()));\n            } else if (end.getY() - start.getY() \u003e Math.abs(end.getX() - start.getX()))\n            {\n                crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX(), crossTiles.get(crossTiles.size() - 1).getY() + 1));\n            }\n        }\n        while (end.getX() !\u003d crossTiles.get(crossTiles.size() - 1).getX() \u0026\u0026 end.getY() !\u003d crossTiles.get(crossTiles.size() - 1).getY())\n        {\n            int offset \u003d (end.getX() - crossTiles.get(crossTiles.size()-1).getX() \u003e 0) ? 1 : -1;\n            crossTiles.add(new Point(crossTiles.get(crossTiles.size() - 1).getX() + offset, crossTiles.get(crossTiles.size() - 1).getY() + 1));\n        }\n        return crossTiles;\n    }\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n        if (event.getActor().getAnimation() \u003d\u003d SOTETSEG_DEATH_ANIMATION)\n        {\n            endSotetseg();\n        }\n    }\n\n    public void startSotetseg()\n    {\n        soteEntryTick \u003d client.getTickCount();\n        roomStartTick \u003d client.getTickCount();\n        deferTick \u003d soteEntryTick + 2;\n        roomState \u003d RoomState.SotetsegRoomState.PHASE_1;\n        clog.addLine(LogID.SOTETSEG_STARTED);\n    }\n\n    public void endSotetseg()\n    {\n        plugin.addDelayedLine(TOBRoom.SOTETSEG, client.getTickCount() - soteEntryTick, \"Dead\");\n        soteDeathTick \u003d client.getTickCount() + SOTETSEG_DEATH_ANIMATION_LENGTH;\n        roomState \u003d RoomState.SotetsegRoomState.FINISHED;\n        clog.addLine(LogID.ACCURATE_SOTE_END);\n        clog.addLine(LogID.SOTETSEG_ENDED, String.valueOf(soteDeathTick - soteEntryTick));\n        plugin.liveFrame.setSoteFinished(soteDeathTick - soteEntryTick);\n        sendTimeMessage(\"Wave \u0027Sotetseg phase 3\u0027 complete. Duration: \", soteDeathTick - soteEntryTick, soteDeathTick - soteSecondMazeEnd, false);\n    }\n\n    public void startFirstMaze()\n    {\n        startEitherMaze();\n        lastChosen \u003d \"\";\n        excludedTiles.clear();\n        currentMaze.clear();\n        firstMazeChosen \u003d \"\";\n        hasSteppedOnMaze \u003d false;\n        soteFirstMazeStart \u003d client.getTickCount();\n        clog.addLine(LogID.SOTETSEG_FIRST_MAZE_STARTED, String.valueOf(soteFirstMazeStart - soteEntryTick));\n        roomState \u003d RoomState.SotetsegRoomState.MAZE_1;\n        sendTimeMessage(\"Wave \u0027Sotetseg phase 1\u0027 complete. Duration: \", soteFirstMazeStart - soteEntryTick);\n        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteFirstMazeStart - soteEntryTick, \"Maze1 Start\");\n    }\n\n    public void startEitherMaze()\n    {\n        playerTiles.clear();\n        for(String s : plugin.currentPlayers)\n        {\n            playerTiles.put(s, new ArrayList\u003c\u003e());\n        }\n    }\n\n    public void endFirstMaze()\n    {\n        endEitherMaze();\n        soteFirstMazeEnd \u003d client.getTickCount();\n        clog.addLine(LogID.SOTETSEG_FIRST_MAZE_ENDED, String.valueOf(soteFirstMazeEnd - soteEntryTick));\n        roomState \u003d RoomState.SotetsegRoomState.PHASE_2;\n        sendTimeMessage(\"Wave \u0027Sotetseg maze 1\u0027 complete. Duration: \", soteFirstMazeEnd - soteEntryTick, soteFirstMazeEnd - soteFirstMazeStart);\n        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteFirstMazeEnd - soteEntryTick, \"Maze1 End\");\n    }\n\n    public void startSecondMaze()\n    {\n        startEitherMaze();\n        lastChosen \u003d \"\";\n        excludedTiles.clear();\n        currentMaze.clear();\n        secondMazeChosen \u003d \"\";\n        hasSteppedOnMaze \u003d false;\n        soteSecondMazeStart \u003d client.getTickCount();\n        clog.addLine(LogID.SOTETSEG_SECOND_MAZE_STARTED, String.valueOf(soteSecondMazeStart - soteEntryTick));\n        roomState \u003d RoomState.SotetsegRoomState.MAZE_2;\n        sendTimeMessage(\"Wave \u0027Sotetseg phase 2\u0027 complete. Duration: \", soteSecondMazeStart - soteEntryTick, soteSecondMazeStart - soteFirstMazeEnd);\n        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteSecondMazeStart - soteEntryTick, \"Maze2 Start\");\n    }\n    private static ArrayList\u003cPoint\u003e filterMaze(ArrayList\u003cPoint\u003e tiles)\n    {\n        ArrayList\u003cPoint\u003e filteredTiles \u003d new ArrayList\u003c\u003e();\n        for (Point p : tiles)\n        {\n            if (p.getY() % 2 \u003d\u003d 0)\n            {\n                filteredTiles.add(p);\n            }\n        }\n        return filteredTiles;\n    }\n\n    public ArrayList\u003cPoint\u003e findOverlappingTiles(ArrayList\u003cPoint\u003e tiles1, ArrayList\u003cPoint\u003e tiles2)\n    {\n        ArrayList\u003cPoint\u003e overlap \u003d new ArrayList\u003c\u003e();\n        for(Point p1 : tiles1)\n        {\n            for(Point p2 : tiles2)\n            {\n                if(p1.getX() \u003d\u003d p2.getX() \u0026\u0026 p1.getY() \u003d\u003d p2.getY())\n                {\n                    overlap.add(p1);\n                }\n            }\n        }\n        return overlap;\n    }\n\n    public ArrayList\u003cPoint\u003e findNonOverlappingTiles(ArrayList\u003cPoint\u003e tiles1, ArrayList\u003cPoint\u003e tiles2)\n    {\n        ArrayList\u003cPoint\u003e nonOverlappedTiles \u003d new ArrayList\u003c\u003e();\n        for(Point p1 : tiles1)\n        {\n            boolean found \u003d false;\n            for(Point p2 : tiles2)\n            {\n                if (p2.getX() \u003d\u003d p1.getX() \u0026\u0026 p2.getY() \u003d\u003d p1.getY())\n                {\n                    found \u003d true;\n                    break;\n                }\n            }\n            if(!found)\n            {\n                nonOverlappedTiles.add(p1);\n            }\n        }\n        return nonOverlappedTiles;\n    }\n\n    public void endEitherMaze()\n    {\n        if(!currentMaze.isEmpty())\n        {\n            if(currentMaze.get(currentMaze.size()-1).getY() \u003d\u003d 35)\n            {\n                currentMaze.add(new Point(currentMaze.get(currentMaze.size()-1).getX(), 37));\n            }\n        }\n        currentMaze \u003d removeDuplicatePoints(currentMaze);\n        currentMaze \u003d addEveryTileBetween(currentMaze);\n        ArrayList\u003cPoint\u003e overlap \u003d removeDuplicatePoints(findOverlappingTiles(currentMaze, excludedTiles));\n        ArrayList\u003cPoint\u003e nonoverlap \u003d removeDuplicatePoints(findNonOverlappingTiles(excludedTiles, currentMaze));\n        if(!overlap.isEmpty() \u0026\u0026 config.showMistakesInChat())\n        {\n            plugin.sendChatMessage(lastChosen + \" ragged \" + overlap.size() + \" while running the maze\");\n        }\n        if(!nonoverlap.isEmpty() \u0026\u0026 config.showMistakesInChat())\n        {\n            plugin.sendChatMessage(\"Players following the maze ragged \" + nonoverlap.size() + \" tiles\");\n        }\n        currentMaze \u003d filterMaze(currentMaze);\n        excludedTiles \u003d removeDuplicatePoints(excludedTiles);\n        playerTiles.replaceAll((s, v) -\u003e addEveryTileBetween(removeDuplicatePoints(v)));\n        for(String s : playerTiles.keySet())\n        {\n            int ragged \u003d 0;\n            for(Point tile : playerTiles.get(s))\n            {\n                for(Point raggedTile : nonoverlap)\n                {\n                    if(tile.getX() \u003d\u003d raggedTile.getX() \u0026\u0026 tile.getY() \u003d\u003d raggedTile.getY())\n                    {\n                        ragged++;\n                    }\n                }\n            }\n            if(ragged \u003e 0)\n            {\n                plugin.sendChatMessage(s + \" ragged \" + ragged + \" tiles\");\n            }\n        }\n    }\n\n    public void endSecondMaze()\n    {\n        endEitherMaze();\n        soteSecondMazeEnd \u003d client.getTickCount();\n        clog.addLine(LogID.SOTETSEG_SECOND_MAZE_ENDED, String.valueOf(soteSecondMazeEnd - soteEntryTick));\n        roomState \u003d RoomState.SotetsegRoomState.PHASE_3;\n        sendTimeMessage(\"Wave \u0027Sotetseg maze 2\u0027 complete. Duration: \", soteSecondMazeEnd - soteEntryTick, soteSecondMazeEnd - soteSecondMazeStart);\n        plugin.addDelayedLine(TOBRoom.SOTETSEG, soteSecondMazeEnd - soteEntryTick, \"Maze2 End\");\n    }\n\n    public String getAboveWorldChosen()\n    {\n        for(String playerName : plugin.currentPlayers)\n        {\n            boolean found \u003d false;\n            for(Player player : client.getPlayers())\n            {\n                if(playerName.equals(player.getName()))\n                {\n                    found \u003d true;\n                }\n            }\n            if(!found)\n            {\n                return playerName;\n            }\n        }\n        return \"\";\n    }\n\n    public void updateGraphicsObjectCreated(GraphicsObjectCreated event)\n    {\n        if(event.getGraphicsObject().getId() \u003d\u003d SOTETSEG_RAGGED_TILE)\n        {\n            WorldPoint wp \u003d WorldPoint.fromLocal(client, event.getGraphicsObject().getLocation());\n            excludedTiles.add(new Point(wp.getRegionX(), wp.getRegionY()));\n        }\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n        lastRegion \u003d client.isInInstancedRegion() ? WorldPoint.fromLocalInstance(client, client.getLocalPlayer().getLocalLocation()).getRegionID() : client.getLocalPlayer().getWorldLocation().getRegionID();\n        if(roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_1 || roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_2)\n        {\n            int ticksSinceLastProc;\n            if(roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_1)\n            {\n                ticksSinceLastProc \u003d client.getTickCount()-soteFirstMazeStart;\n            }\n            else\n            {\n                ticksSinceLastProc \u003d client.getTickCount() - soteSecondMazeStart;\n            }\n            if(ticksSinceLastProc \u003e 5)\n            {\n                for (Player player : client.getPlayers())\n                {\n                    WorldPoint location \u003d player.getWorldLocation();\n                    if (location.getRegionX() \u003c\u003d 22 \u0026\u0026 location.getRegionX() \u003e\u003d 9)\n                    {\n                        if (location.getRegionY() \u003e\u003d 21 \u0026\u0026 location.getRegionY() \u003c\u003d 37)\n                        {\n                            if (playerTiles.containsKey(player.getName()))\n                            {\n                                playerTiles.get(player.getName()).add(new Point(location.getRegionX(), location.getRegionY()));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (client.getTickCount() \u003d\u003d deferTick)\n        {\n            deferTick \u003d -1;\n            if (client.getVarbitValue(HP_VARBIT) \u003d\u003d FULL_HP)\n            {\n                clog.addLine(LogID.ACCURATE_SOTE_START);\n            }\n        }\n        if(client.getTickCount() \u003d\u003d soteFirstMazeStart+5)\n        {\n            if(lastRegion \u003d\u003d SOTETSEG_UNDERWORLD)\n            {\n                firstMazeChosen \u003d client.getLocalPlayer().getName();\n            }\n            else\n            {\n                firstMazeChosen \u003d getAboveWorldChosen();\n            }\n            lastChosen \u003d firstMazeChosen;\n        }\n        else if(client.getTickCount() \u003d\u003d soteSecondMazeStart+5)\n        {\n            if(lastRegion \u003d\u003d SOTETSEG_UNDERWORLD)\n            {\n                secondMazeChosen \u003d client.getLocalPlayer().getName();\n            }\n            else\n            {\n                secondMazeChosen \u003d getAboveWorldChosen();\n            }\n            lastChosen \u003d secondMazeChosen;\n        }\n    }\n\n    public void handleNPCChanged(int id)\n    {\n        if (id \u003d\u003d SOTETSEG_ACTIVE || id \u003d\u003d SOTETSEG_ACTIVE_HM || id \u003d\u003d SOTETSEG_ACTIVE_SM)\n        {\n            if (roomState \u003d\u003d RoomState.SotetsegRoomState.NOT_STARTED)\n            {\n                if (id \u003d\u003d SOTETSEG_ACTIVE_HM)\n                {\n                    clog.addLine(LogID.IS_HARD_MODE);\n                } else if (id \u003d\u003d SOTETSEG_ACTIVE_SM)\n                {\n                    clog.addLine(LogID.IS_STORY_MODE);\n                }\n                startSotetseg();\n            } else if (roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_1)\n            {\n                endFirstMaze();\n            } else if (roomState \u003d\u003d RoomState.SotetsegRoomState.MAZE_2)\n            {\n                endSecondMaze();\n            }\n        } else if (id \u003d\u003d SOTETSEG_INACTIVE || id \u003d\u003d SOTETSEG_INACTIVE_HM || id \u003d\u003d SOTETSEG_INACTIVE_SM)\n        {\n            if (roomState \u003d\u003d RoomState.SotetsegRoomState.PHASE_1)\n            {\n                startFirstMaze();\n            } else if (roomState \u003d\u003d RoomState.SotetsegRoomState.PHASE_2)\n            {\n                startSecondMaze();\n            }\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\SotetsegHandler.java"},{"fileName":"VerzikHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.constants.LogID;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.wrappers.PlayerDidAttack;\nimport com.advancedraidtracker.utility.wrappers.DawnSpec;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.events.*;\nimport com.advancedraidtracker.utility.RoomState;\nimport net.runelite.client.game.ItemManager;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.TobIDs.*;\n\n@Slf4j\npublic class VerzikHandler extends RoomHandler\n{\n    public RoomState.VerzikRoomState roomState;\n    private final AdvancedRaidTrackerPlugin plugin;\n    private int healingEndTick \u003d -1;\n    private final ItemManager itemManager;\n\n    public VerzikHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin, ItemManager itemManager)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n        this.itemManager \u003d itemManager;\n        currentHits \u003d new ArrayList\u003c\u003e();\n        lastHits \u003d new ArrayList\u003c\u003e();\n        roomState \u003d RoomState.VerzikRoomState.NOT_STARTED;\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d RoomState.VerzikRoomState.NOT_STARTED || roomState \u003d\u003d RoomState.VerzikRoomState.FINISHED);\n    }\n\n    public String getName()\n    {\n        return \"Verzik\";\n    }\n\n    private int verzikEntryTick \u003d -1;\n    private int verzikP1EndTick \u003d -1;\n    private int verzikRedsTick \u003d -1;\n    private int verzikP2EndTick \u003d -1;\n    private int verzikP3EndTick \u003d -1;\n    private boolean redsThisTick \u003d false;\n\n    private boolean hasWebbed \u003d false;\n    private int webTick \u003d -1;\n\n    private final ArrayList\u003cInteger\u003e currentHits;\n    private ArrayList\u003cInteger\u003e lastHits;\n    private NPC verzNPC;\n    Map\u003cInteger, Integer\u003e shieldActives \u003d new HashMap\u003c\u003e();\n\n    public void reset()\n    {\n        super.reset();\n        roomState \u003d RoomState.VerzikRoomState.NOT_STARTED;\n        currentHits.clear();\n        lastHits.clear();\n        verzikEntryTick \u003d -1;\n        verzikP1EndTick \u003d -1;\n        verzikRedsTick \u003d -1;\n        verzikP2EndTick \u003d -1;\n        verzikP3EndTick \u003d -1;\n        redsThisTick \u003d false;\n        hasWebbed \u003d false;\n        healingEndTick \u003d -1;\n        webTick \u003d -1;\n        queuedAutoHits.clear();\n        shieldActives.clear();\n    }\n\n    public void thrallAttackedShield(int tick)\n    {\n        //todo finish p2 heal tracking\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n        for (Projectile projectile : client.getProjectiles())\n        {\n            if (projectile.getId() \u003d\u003d VERZIK_CRAB_HEAL_PROJECTILE)\n            {\n                //todo finish p2 heal tracking\n            }\n        }\n        if (client.getTickCount() \u003d\u003d healingEndTick)\n        {\n            plugin.verzShieldActive \u003d false;\n        }\n        int playersHit \u003d 1;\n        for (Player p : queuedAutoHits.keySet())\n        {\n            if (queuedAutoHits.get(p) \u003d\u003d client.getTickCount())\n            {\n                for (Player p2 : client.getPlayers())\n                {\n                    if (p2.getWorldLocation().distanceTo(p.getWorldLocation()) \u003c\u003d 1)\n                    {\n                        playersHit++;\n                        //todo finish p2 heal tracking\n                    }\n                }\n            }\n        }\n        queuedAutoHits.clear();\n        currentHits.clear();\n        if (healingEndTick \u003d\u003d client.getTickCount())\n        {\n            healingEndTick \u003d -1;\n        }\n        redsThisTick \u003d false;\n        if (webTick !\u003d -1)\n        {\n            webTick++;\n            if (webTick \u003e 50) //non-specific large number \u003e web length but \u003c time before next webs could happen again\n            {\n                hasWebbed \u003d false;\n                webTick \u003d -1;\n            }\n        }\n        lastHits \u003d currentHits;\n    }\n\n    private final Map\u003cPlayer, Integer\u003e queuedAutoHits \u003d new HashMap\u003c\u003e();\n\n    public void updateProjectileMoved(ProjectileMoved event)\n    {\n        if (event.getProjectile().getId() \u003d\u003d VERZIK_CRAB_HEAL_PROJECTILE)\n        {\n            if (event.getProjectile().getRemainingCycles() \u003d\u003d client.getGameCycle())\n            {\n                //todo finish p2 heal tracking\n            }\n        }\n        if (event.getProjectile().getId() \u003d\u003d VERZIK_RED_MAGE_AUTO_PROJECTILE)\n        {\n            if (event.getProjectile().getRemainingCycles() \u003d\u003d 0)\n            {\n                if (verzNPC.getInteracting() instanceof Player)\n                {\n                    Player p \u003d (Player) verzNPC;\n                    queuedAutoHits.put(p, client.getTickCount() + 2);\n                }\n            }\n        } else if (event.getProjectile().getId() \u003d\u003d VERZIK_WEB_PROJECTILE)\n        {\n            if (!hasWebbed)\n            {\n                hasWebbed \u003d true;\n                clog.addLine(WEBS_STARTED, String.valueOf(client.getTickCount() - verzikEntryTick));\n                webTick \u003d client.getTickCount();\n                if ((webTick - verzikEntryTick) % 2 \u003d\u003d 0)\n                {\n                    plugin.addDelayedLine(TOBRoom.VERZIK, webTick - verzikEntryTick, \"Webs\");\n                }\n            }\n        }\n    }\n\n    public void updateHitsplatApplied(HitsplatApplied event)\n    {\n        if (event.getActor().getName() !\u003d null)\n        {\n            if (event.getActor().getName().contains(\"Verzik\") \u0026\u0026 event.getHitsplat().getHitsplatType() \u003d\u003d HitsplatID.HEAL)\n            {\n                currentHits.add(event.getHitsplat().getAmount());\n            }\n            if (roomState \u003d\u003d RoomState.VerzikRoomState.PHASE_1 \u0026\u0026 event.getActor().getName().contains(\"Verzik\"))\n            {\n                if (event.getHitsplat().getAmount() \u003e\u003d DAWNBRINGER_MINIMUM_HIT)\n                {\n                    clog.addLine(DAWN_DAMAGE, String.valueOf(event.getHitsplat().getAmount()), String.valueOf(client.getTickCount() - roomStartTick));\n                    DawnSpec dawnSpec \u003d new DawnSpec(\"\", client.getTickCount() - roomStartTick);\n                    dawnSpec.setDamage(event.getHitsplat().getAmount());\n                    plugin.liveFrame.getPanel(getName()).addDawnSpec(dawnSpec);\n                }\n            }\n        }\n    }\n\n    public void updateGraphicChanged(GraphicChanged event)\n    {\n        if (event.getActor().hasSpotAnim(VERZIK_BOUNCE_SPOT_ANIMATION))\n        {\n            clog.addLine(LogID.VERZIK_BOUNCE, event.getActor().getName(), String.valueOf(client.getTickCount() - verzikEntryTick));\n            plugin.liveFrame.addAttack(new PlayerDidAttack(itemManager, event.getActor().getName(), VERZIK_BOUNCE_ANIMATION, client.getTickCount() - verzikEntryTick, \"-1\", \"-1\", \"-1\", -1, -1, \"\", \"\"), \"Verzik\");\n\n        }\n    }\n\n    public void updateItemSpawned(ItemSpawned event)\n    {\n        if (event.getItem().getId() \u003d\u003d DAWNBRINGER_ITEM)\n        {\n            clog.addLine(DAWN_DROPPED, String.valueOf(client.getTickCount() - verzikEntryTick));\n            plugin.liveFrame.getPanel(getName()).addRoomSpecificData(client.getTickCount() - verzikEntryTick, \"X\");\n        }\n    }\n\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n        int id \u003d event.getActor().getAnimation();\n        if (roomState \u003d\u003d RoomState.VerzikRoomState.PHASE_2 || roomState \u003d\u003d RoomState.VerzikRoomState.PHASE_2_REDS)\n        {\n            if (plugin.verzShieldActive)\n            {\n                if (event.getActor() instanceof Player)\n                {\n                    Player p \u003d (Player) event.getActor();\n                    if (p.getInteracting() instanceof NPC)\n                    {\n                        NPC interacting \u003d (NPC) p.getInteracting();\n                        if (interacting.getId() \u003d\u003d VERZIK_P2 || interacting.getId() \u003d\u003d VERZIK_P2_HM || interacting.getId() \u003d\u003d VERZIK_P2_SM)\n                        {\n                            //TODO: P2 Healing\n                        }\n                    }\n                }\n            }\n        }\n\n        if (event.getActor().getAnimation() \u003d\u003d VERZIK_BECOMES_SPIDER)\n        {\n            endP3();\n        }\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d VERZIK_MATOMENOS || id \u003d\u003d VERZIK_MATOMENOS_HM || id \u003d\u003d VERZIK_MATOMENOS_SM)\n        {\n            if (!redsThisTick)\n            {\n                clog.addLine(VERZIK_P2_REDS_PROC, String.valueOf(client.getTickCount() - verzikEntryTick));\n                plugin.addDelayedLine(TOBRoom.VERZIK, client.getTickCount() - verzikEntryTick, \"Reds\");\n                healingEndTick \u003d client.getTickCount() + VERZIK_SHIELD_LENGTH;\n                plugin.addDelayedLine(TOBRoom.VERZIK, healingEndTick - verzikEntryTick, \"Shield End\");\n                redsThisTick \u003d true;\n                plugin.verzShieldActive \u003d true;\n            }\n            if (roomState !\u003d RoomState.VerzikRoomState.PHASE_2_REDS)\n            {\n                procReds();\n            }\n        }\n        switch (id)\n        {\n            case VERZIK_MELEE_NYLO:\n            case VERZIK_RANGE_NYLO:\n            case VERZIK_MAGE_NYLO:\n            case VERZIK_MELEE_NYLO_HM:\n            case VERZIK_RANGE_NYLO_HM:\n            case VERZIK_MAGE_NYLO_HM:\n            case VERZIK_MELEE_NYLO_SM:\n            case VERZIK_RANGE_NYLO_SM:\n            case VERZIK_MAGE_NYLO_SM:\n                clog.addLine(VERZIK_CRAB_SPAWNED, String.valueOf(client.getTickCount() - roomStartTick));\n                break;\n            case VERZIK_P1_INACTIVE:\n            case VERZIK_P1_INACTIVE_SM:\n            case VERZIK_P1_INACTIVE_HM:\n            case VERZIK_P1:\n            case VERZIK_P2:\n            case VERZIK_P3:\n            case VERZIK_P1_HM:\n            case VERZIK_P2_HM:\n            case VERZIK_P3_HM:\n            case VERZIK_P1_SM:\n            case VERZIK_P2_SM:\n            case VERZIK_P3_SM:\n                verzNPC \u003d event.getNpc();\n                break;\n        }\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n        int id \u003d event.getNpc().getId();\n        if (id \u003d\u003d VERZIK_P1 || id \u003d\u003d VERZIK_P1_HM || id \u003d\u003d VERZIK_P1_SM)\n        {\n            endP1();\n        } else if (id \u003d\u003d VERZIK_P2 || id \u003d\u003d VERZIK_P2_HM || id \u003d\u003d VERZIK_P2_SM)\n        {\n            endP2();\n        }\n    }\n\n    public void handleNPCChanged(int id)\n    {\n        if (id \u003d\u003d VERZIK_P1 || id \u003d\u003d VERZIK_P1_HM || id \u003d\u003d VERZIK_P1_SM)\n        {\n            if (id \u003d\u003d VERZIK_P1_HM)\n            {\n                clog.addLine(IS_HARD_MODE);\n            } else if (id \u003d\u003d VERZIK_P1_SM)\n            {\n                clog.addLine(IS_STORY_MODE);\n            }\n            startVerzik();\n        } else if (id \u003d\u003d VERZIK_P2 || id \u003d\u003d VERZIK_P2_HM || id \u003d\u003d VERZIK_P2_SM)\n        {\n            endP1();\n        } else if (id \u003d\u003d VERZIK_P3 || id \u003d\u003d VERZIK_P3_HM || id \u003d\u003d VERZIK_P3_SM)\n        {\n            endP2();\n        } else if (id \u003d\u003d VERZIK_DEAD || id \u003d\u003d VERZIK_DEAD_HM || id \u003d\u003d VERZIK_DEAD_SM)\n        {\n            endP3();\n        }\n    }\n\n    private void startVerzik()\n    {\n        roomState \u003d RoomState.VerzikRoomState.PHASE_1;\n        verzikEntryTick \u003d client.getTickCount();\n        clog.addLine(VERZIK_P1_START);\n        clog.addLine(ACCURATE_VERZIK_START);\n        roomStartTick \u003d client.getTickCount();\n    }\n\n    private void endP1()\n    {\n        roomState \u003d RoomState.VerzikRoomState.PHASE_2;\n        verzikP1EndTick \u003d client.getTickCount();\n        sendTimeMessage(\"Wave \u0027Verzik phase 1\u0027 complete. Duration: \", verzikP1EndTick - verzikEntryTick);\n        clog.addLine(VERZIK_P1_DESPAWNED, String.valueOf(verzikP1EndTick - verzikEntryTick));\n        plugin.addDelayedLine(TOBRoom.VERZIK, verzikP1EndTick - verzikEntryTick, \"P1 End\");\n\n    }\n\n    private void procReds()\n    {\n        roomState \u003d RoomState.VerzikRoomState.PHASE_2_REDS;\n        verzikRedsTick \u003d client.getTickCount();\n        sendTimeMessage(\"Red Crabs Spawned. Duration: \", verzikRedsTick - verzikEntryTick);\n    }\n\n    private void endP2()\n    {\n        roomState \u003d RoomState.VerzikRoomState.PHASE_3;\n        verzikP2EndTick \u003d client.getTickCount();\n        sendTimeMessage(\"Wave \u0027Verzik phase 2\u0027 complete. Duration: \", verzikP2EndTick - verzikEntryTick, verzikP2EndTick - verzikP1EndTick);\n        clog.addLine(VERZIK_P2_END, String.valueOf(verzikP2EndTick - verzikEntryTick));\n        plugin.addDelayedLine(TOBRoom.VERZIK, verzikP2EndTick - verzikEntryTick, \"P2 End\");\n\n    }\n\n    private void endP3()\n    {\n        //todo incorrect doubles sometimes\n        roomState \u003d RoomState.VerzikRoomState.FINISHED;\n        verzikP3EndTick \u003d client.getTickCount() + VERZIK_DEATH_ANIMATION_LENGTH;\n        clog.addLine(ACCURATE_VERZIK_END);\n        sendTimeMessage(\"Wave \u0027Verzik phase 3\u0027 complete. Duration: \", verzikP3EndTick - verzikEntryTick, verzikP3EndTick - verzikP2EndTick);\n        clog.addLine(VERZIK_P3_DESPAWNED, String.valueOf(verzikP3EndTick - verzikEntryTick));\n        plugin.addDelayedLine(TOBRoom.VERZIK, client.getTickCount() - verzikEntryTick, \"Dead\");\n        plugin.liveFrame.setVerzFinished(verzikP3EndTick - verzikEntryTick);\n\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\VerzikHandler.java"},{"fileName":"XarpusHandler.java","content":"package com.advancedraidtracker.rooms.tob;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.constants.TobIDs;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.NPC;\nimport net.runelite.api.events.*;\nimport com.advancedraidtracker.utility.Point;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.RoomState;\n\nimport static com.advancedraidtracker.constants.LogID.*;\nimport static com.advancedraidtracker.constants.LogID.ACCURATE_XARP_END;\nimport static com.advancedraidtracker.constants.LogID.XARPUS_STARTED;\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.utility.RoomState.XarpusRoomState.FINISHED;\n@Slf4j\npublic class XarpusHandler extends RoomHandler\n{\n    public RoomState.XarpusRoomState roomState \u003d RoomState.XarpusRoomState.NOT_STARTED;\n    private final AdvancedRaidTrackerPlugin plugin;\n\n    public XarpusHandler(Client client, DataWriter clog, AdvancedRaidTrackerConfig config, AdvancedRaidTrackerPlugin plugin)\n    {\n        super(client, clog, config);\n        this.plugin \u003d plugin;\n    }\n\n    private int xarpusEntryTick \u003d -1;\n    private int xarpusExhumedsEnd \u003d -1;\n    private int xarpusScreechTick \u003d -1;\n    private int xarpusEndTick \u003d -1;\n\n    public String getName()\n    {\n        return \"Xarpus\";\n    }\n\n    public boolean isActive()\n    {\n        return !(roomState \u003d\u003d RoomState.XarpusRoomState.NOT_STARTED || roomState \u003d\u003d FINISHED);\n    }\n\n    public void reset()\n    {\n        super.reset();\n        xarpusEntryTick \u003d -1;\n        xarpusExhumedsEnd \u003d -1;\n        xarpusScreechTick \u003d -1;\n        xarpusEndTick \u003d -1;\n        roomState \u003d RoomState.XarpusRoomState.NOT_STARTED;\n    }\n\n    public void updateAnimationChanged(AnimationChanged event)\n    {\n        if (event.getActor().getAnimation() \u003d\u003d XARPUS_AWAKENS)\n        {\n            endExhumeds();\n        }\n        if (event.getActor().getAnimation() \u003d\u003d XARPUS_DEATH_ANIMATION)\n        {\n            endXarpus();\n        }\n    }\n\n    public void updateProjectileMoved(ProjectileMoved event)\n    {\n        if (event.getProjectile().getEndCycle() - event.getProjectile().getStartCycle() \u003d\u003d event.getProjectile().getRemainingCycles())\n        {\n            if (event.getProjectile().getId() \u003d\u003d XARPUS_EXHUMED_PROJECTILE)\n            {\n                clog.addLine(XARPUS_HEAL);\n            }\n        }\n    }\n\n    public void updateOverheadText(OverheadTextChanged event)\n    {\n        if (event.getActor() instanceof NPC)\n        {\n            NPC npc \u003d (NPC) event.getActor();\n            int id \u003d npc.getId();\n            if (id \u003d\u003d XARPUS_P23 || id \u003d\u003d XARPUS_P23_HM || id \u003d\u003d XARPUS_P23_SM)\n            {\n                startScreech();\n            }\n        }\n    }\n\n    public void updateNpcDespawned(NpcDespawned event)\n    {\n        switch (event.getNpc().getId())\n        {\n            case XARPUS_INACTIVE:\n            case XARPUS_P1:\n            case XARPUS_P23:\n            case XARPUS_DEAD:\n            case XARPUS_INACTIVE_HM:\n            case XARPUS_P1_HM:\n            case XARPUS_P23_HM:\n            case XARPUS_DEAD_HM:\n            case XARPUS_INACTIVE_SM:\n            case XARPUS_P1_SM:\n            case XARPUS_P23_SM:\n            case XARPUS_DEAD_SM:\n                clog.addLine(XARPUS_DESPAWNED, String.valueOf(xarpusEndTick - xarpusEntryTick));\n        }\n    }\n\n    public void updateNpcSpawned(NpcSpawned event)\n    {\n        boolean story \u003d false;\n        switch (event.getNpc().getId())\n        {\n            case TobIDs.XARPUS_INACTIVE_SM:\n            case TobIDs.XARPUS_P1_SM:\n            case TobIDs.XARPUS_P23_SM:\n            case TobIDs.XARPUS_DEAD_SM:\n                story \u003d true;\n                clog.addLine(IS_STORY_MODE);\n            case TobIDs.XARPUS_INACTIVE_HM:\n            case TobIDs.XARPUS_P1_HM:\n            case TobIDs.XARPUS_P23_HM:\n            case TobIDs.XARPUS_DEAD_HM:\n                if (!story)\n                    clog.addLine(IS_HARD_MODE);\n            case TobIDs.XARPUS_INACTIVE:\n            case TobIDs.XARPUS_P1:\n            case TobIDs.XARPUS_P23:\n            case TobIDs.XARPUS_DEAD:\n                clog.addLine(XARPUS_SPAWNED);\n        }\n    }\n\n    public void updateGameTick(GameTick event)\n    {\n        if (roomState \u003d\u003d RoomState.XarpusRoomState.NOT_STARTED)\n        { //Xarpus timer starts when player crosses into region\n            if (RoomUtil.crossedLine(XARPUS_REGION, new Point(25, 12), new Point(27, 12), false, client))\n            {\n                startXarpus();\n            }\n        }\n        if (xarpusScreechTick !\u003d -1 \u0026\u0026 xarpusScreechTick !\u003d 0 \u0026\u0026 client.getTickCount() !\u003d xarpusScreechTick \u0026\u0026 (client.getTickCount() - xarpusScreechTick) % 8 \u003d\u003d 0 \u0026\u0026 isActive())\n        {\n            plugin.addDelayedLine(TOBRoom.XARPUS, client.getTickCount() - xarpusEntryTick, \"Turn\");\n        }\n    }\n\n    private void startScreech()\n    {\n        clog.addLine(XARPUS_SCREECH, String.valueOf(client.getTickCount() - xarpusEntryTick));\n        roomState \u003d RoomState.XarpusRoomState.POSTSCREECH;\n        xarpusScreechTick \u003d client.getTickCount();\n        String splitMessage \u003d \"Wave \u0027Xarpus phase 2\u0027 complete. Duration: \" + timeColor() + RoomUtil.time(xarpusScreechTick - xarpusEntryTick) + \" (\" + RoomUtil.time(xarpusScreechTick - xarpusExhumedsEnd) + \")\";\n        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        plugin.addDelayedLine(TOBRoom.XARPUS, xarpusScreechTick - xarpusEntryTick, \"SCREECH\");\n    }\n\n    private void startXarpus()\n    {\n        roomState \u003d RoomState.XarpusRoomState.EXHUMEDS;\n        xarpusEntryTick \u003d client.getTickCount();\n        roomStartTick \u003d client.getTickCount();\n        clog.addLine(XARPUS_STARTED);\n        clog.addLine(ACCURATE_XARP_START);\n    }\n\n    private void endExhumeds()\n    {\n        roomState \u003d RoomState.XarpusRoomState.PRESCREECH;\n        xarpusExhumedsEnd \u003d client.getTickCount();\n        String splitMessage \u003d \"Wave \u0027Xarpus phase 1\u0027 complete. Duration: \" + timeColor() + RoomUtil.time(xarpusExhumedsEnd - xarpusEntryTick);\n        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n        plugin.addDelayedLine(TOBRoom.XARPUS, client.getTickCount() - xarpusEntryTick + 1, \"Exhumeds End\");\n    }\n\n    private void endXarpus()\n    {\n\n        roomState \u003d FINISHED;\n        xarpusEndTick \u003d client.getTickCount() + XARPUS_DEATH_ANIMATION_LENGTH;\n        clog.addLine(ACCURATE_XARP_END);\n        plugin.liveFrame.setXarpFinished(xarpusEndTick - xarpusEntryTick);\n        String splitMessage \u003d \"Wave \u0027Xarpus phase 3\u0027 complete. Duration: \" + timeColor() + RoomUtil.time(xarpusEndTick - xarpusEntryTick) + \" (\" + RoomUtil.time(xarpusEndTick - xarpusScreechTick) + \")\";\n        this.client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", splitMessage, null, false);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\rooms\\tob\\XarpusHandler.java"},{"fileName":"SimpleTOBData.java","content":"package com.advancedraidtracker;\n\nimport com.advancedraidtracker.constants.LogID;\nimport com.advancedraidtracker.constants.TOBRoom;\nimport com.advancedraidtracker.utility.datautility.DataManager;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport com.advancedraidtracker.utility.wrappers.*;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.*;\nimport static com.advancedraidtracker.constants.TOBRoom.*;\nimport static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;\nimport static com.advancedraidtracker.constants.TobIDs.SPECTATE_FLAG;\nimport static com.advancedraidtracker.utility.datautility.DataPoint.*;\n\n@Slf4j\npublic class SimpleTOBData\n{\n    public boolean maidenStartAccurate \u003d false;\n    public boolean bloatStartAccurate \u003d false;\n    public boolean nyloStartAccurate \u003d false;\n    public boolean soteStartAccurate \u003d false;\n    public boolean xarpStartAccurate \u003d false;\n    public boolean verzikStartAccurate \u003d false;\n\n    public boolean maidenEndAccurate \u003d false;\n    public boolean bloatEndAccurate \u003d false;\n    public boolean nyloEndAccurate \u003d false;\n    public boolean soteEndAccurate \u003d false;\n    public boolean xarpEndAccurate \u003d false;\n    public boolean verzikEndAccurate \u003d false;\n    public boolean resetBeforeMaiden;\n\n    public boolean spectated \u003d false;\n    public boolean partyComplete;\n    public boolean hardMode;\n    public boolean storyMode;\n    public boolean raidCompleted;\n    public Date raidStarted;\n    private ArrayList\u003cString\u003e globalData;\n    public LinkedHashMap\u003cString, Integer\u003e players;\n    public String filePath;\n    public String fileName;\n    public String activeValue \u003d \"\";\n    // Maiden tracking\n    public boolean maidenTimeAccurate;\n    public boolean maidenDefenseAccurate;\n    public boolean maidenScuffed \u003d false;\n    public String firstMaidenCrabScuffed \u003d \"\";\n    public ArrayList\u003cStringInt\u003e maidenCrabs \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cString\u003e maidenCrabSpawn \u003d new ArrayList\u003c\u003e();\n    public boolean maidenSpawned \u003d false;\n    public boolean maidenSkip;\n    public boolean maidenReset;\n    public boolean maidenWipe;\n    // Bloat tracking\n    public ArrayList\u003cInteger\u003e bloatDowns \u003d new ArrayList\u003c\u003e();\n    public boolean bloatTimeAccurate;\n    public boolean bloatDefenseAccurate;\n    public boolean bloatStarted;\n    public boolean bloatReset;\n    public boolean bloatWipe;\n    // Nylo tracking\n    public boolean nyloTimeAccurate;\n    public boolean nyloDefenseAccurate;\n    public boolean nyloWipe;\n    public boolean nyloReset;\n    public boolean nyloStarted;\n    public ArrayList\u003cInteger\u003e nyloWaveStalled \u003d new ArrayList\u003c\u003e();\n    public Map\u003cInteger, Integer\u003e waveSpawns \u003d new HashMap\u003c\u003e();\n    // Sotetseg tracking\n    public boolean soteTimeAccurate;\n    public boolean soteDefenseAccurate;\n    public boolean soteStarted;\n    public boolean soteWipe;\n    public boolean soteReset;\n    // Xarpus tracking\n    public boolean xarpTimeAccurate;\n    public boolean xarpDefenseAccurate;\n    public boolean xarpWipe;\n    public boolean xarpReset;\n    public boolean xarpStarted;\n    // Verzik tracking\n    public boolean verzikWipe;\n    public boolean verzikStarted;\n    public boolean verzikTimeAccurate;\n    public ArrayList\u003cInteger\u003e websStart \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cDawnSpec\u003e dawnSpecs \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cInteger\u003e p2Crabs \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cInteger\u003e p3Crabs \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cInteger\u003e redsProc \u003d new ArrayList\u003c\u003e();\n    public ArrayList\u003cInteger\u003e dawnDrops;\n    public ArrayList\u003cPlayerDidAttack\u003e attacksP1;\n\n\n\n\n    // Thrall tracking\n    public ArrayList\u003cThrallOutlineBox\u003e maidenThrallSpawns;\n    public ArrayList\u003cThrallOutlineBox\u003e bloatThrallSpawns;\n    public ArrayList\u003cThrallOutlineBox\u003e nyloThrallSpawns;\n    public ArrayList\u003cThrallOutlineBox\u003e soteThrallSpawns;\n    public ArrayList\u003cThrallOutlineBox\u003e xarpusThrallSpawns;\n    public ArrayList\u003cThrallOutlineBox\u003e verzikThrallSpawns;\n\n    public Map\u003cInteger, Integer\u003e verzikHP \u003d new HashMap\u003c\u003e();\n\n    public Date getDate()\n    {\n        return raidStarted;\n    }\n\n    public int getScale()\n    {\n        return dataManager.get(PARTY_SIZE);\n    }\n\n    public boolean getTimeAccurate(DataPoint param)\n    {\n        switch (param.room)\n        {\n            case MAIDEN:\n                return maidenStartAccurate \u0026\u0026 maidenEndAccurate;\n            case BLOAT:\n                return bloatStartAccurate \u0026\u0026 bloatEndAccurate;\n            case NYLOCAS:\n                return nyloStartAccurate \u0026\u0026 nyloEndAccurate;\n            case SOTETSEG:\n                return soteStartAccurate \u0026\u0026 soteEndAccurate;\n            case XARPUS:\n                return xarpStartAccurate \u0026\u0026 xarpEndAccurate;\n            case VERZIK:\n                return verzikStartAccurate \u0026\u0026 verzikEndAccurate;\n            case ANY:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    public void setIndex(int index)\n    {\n        dataManager.set(RAID_INDEX, index);\n    }\n\n    public String getPlayerList(ArrayList\u003cMap\u003cString, ArrayList\u003cString\u003e\u003e\u003e aliases)\n    {\n        StringBuilder list \u003d new StringBuilder();\n        ArrayList\u003cString\u003e names \u003d new ArrayList\u003c\u003e();\n        for (String s : players.keySet())\n        {\n            String name \u003d s;\n            for (Map\u003cString, ArrayList\u003cString\u003e\u003e alternateNames : aliases)\n            {\n                for (String alias : alternateNames.keySet())\n                {\n                    for (String potentialName : alternateNames.get(alias))\n                    {\n                        if (name.equalsIgnoreCase(potentialName))\n                        {\n                            name \u003d alias;\n                            break;\n                        }\n                    }\n                }\n            }\n            names.add(name);\n        }\n        names.sort(String::compareToIgnoreCase);\n        for (String s : names)\n        {\n            list.append(s);\n            list.append(\",\");\n        }\n        if (list.length() \u003e 0)\n        {\n            return list.substring(0, list.length() - 1);\n        } else\n        {\n            return \"\";\n        }\n    }\n\n    public PlayerCorrelatedPointData getSpecificTimeInactiveCorrelated(String inactive)\n    {\n        if (inactive.contains(\"Player: \"))\n        {\n            return dataManager.getHighest(DataPoint.getValue(inactive.substring(8)));\n        } else\n        {\n            return null;\n        }\n    }\n\n    public int getSpecificTimeInactive(String inactive)\n    {\n        if (inactive.contains(\"Player: \"))\n        {\n            return dataManager.getHighest(DataPoint.getValue(inactive.substring(8))).value;\n        }\n        if (inactive.equals(\"Challenge Time\"))\n        {\n            return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();\n        }\n        return getValue(DataPoint.getValue(inactive));\n    }\n\n    public int getSpecificTime()\n    {\n        if (activeValue.contains(\"Player: \"))\n        {\n            return dataManager.getHighest(DataPoint.getValue(activeValue.substring(8))).value;\n        }\n        if (activeValue.equals(\"Challenge Time\"))\n        {\n            return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();\n        }\n        if(getTimeAccurate(Objects.requireNonNull(DataPoint.getValue(activeValue))))\n        {\n            return getValue(DataPoint.getValue(activeValue));\n        }\n        else\n        {\n            return Integer.MAX_VALUE;\n        }\n    }\n\n    public void setOverallTime()\n    {\n        int overallTime \u003d getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();\n        dataManager.set(DataPoint.CHALLENGE_TIME, overallTime);\n    }\n\n    public int getMaidenTime()\n    {\n        return (maidenStartAccurate \u0026\u0026 maidenEndAccurate) ? getValue(DataPoint.MAIDEN_TOTAL_TIME) : 0;\n    }\n\n    public int getBloatTime()\n    {\n        return (bloatStartAccurate \u0026\u0026 bloatEndAccurate) ? getValue(DataPoint.BLOAT_TOTAL_TIME) : 0;\n    }\n\n    public int getNyloTime()\n    {\n        return (nyloStartAccurate \u0026\u0026 nyloEndAccurate) ? getValue(DataPoint.NYLO_TOTAL_TIME) : 0;\n    }\n\n    public int getSoteTime()\n    {\n        return (soteStartAccurate \u0026\u0026 soteEndAccurate) ? getValue(DataPoint.SOTE_TOTAL_TIME) : 0;\n    }\n\n    public int getXarpTime()\n    {\n        return (xarpStartAccurate \u0026\u0026 xarpEndAccurate) ? getValue(DataPoint.XARP_TOTAL_TIME) : 0;\n    }\n\n    public int getVerzikTime()\n    {\n        return (verzikStartAccurate \u0026\u0026 verzikEndAccurate) ? getValue(DataPoint.VERZIK_TOTAL_TIME) : 0;\n    }\n\n    public boolean getOverallTimeAccurate()\n    {\n        return maidenStartAccurate \u0026\u0026 maidenEndAccurate\n                \u0026\u0026 bloatStartAccurate \u0026\u0026 bloatEndAccurate\n                \u0026\u0026 nyloStartAccurate \u0026\u0026 nyloEndAccurate\n                \u0026\u0026 soteStartAccurate \u0026\u0026 soteEndAccurate\n                \u0026\u0026 xarpStartAccurate \u0026\u0026 xarpEndAccurate\n                \u0026\u0026 verzikStartAccurate \u0026\u0026 verzikEndAccurate;\n    }\n\n    public boolean checkExit(TOBRoom room)\n    {\n        if (globalData.isEmpty() || globalData.get(0).split(\",\", -1)[3].equals(EXIT_FLAG))\n        {\n            switch (room)\n            {\n                case MAIDEN:\n                    maidenReset \u003d true;\n                    break;\n                case BLOAT:\n                    if (!bloatEndAccurate)\n                    {\n                        bloatWipe \u003d true;\n                    } else\n                    {\n                        bloatReset \u003d true;\n                    }\n                    break;\n                case NYLOCAS:\n                    nyloReset \u003d true;\n                    break;\n                case SOTETSEG:\n                    soteReset \u003d true;\n                    break;\n                case XARPUS:\n                    xarpReset \u003d true;\n                    break;\n            }\n            return false;\n        }\n        return true;\n    }\n\n    private final DataManager dataManager;\n\n    public int getValue(String name)\n    {\n        return dataManager.get(name);\n    }\n\n    public int getValue(DataPoint point)\n    {\n        return dataManager.get(point);\n    }\n\n    public int getTimeSum()\n    {\n        return getMaidenTime() + getBloatTime() + getNyloTime() + getSoteTime() + getXarpTime() + getVerzikTime();\n    }\n    public SimpleTOBData(String[] parameters, String filePath, String fileName) throws Exception\n    {\n        this.filePath \u003d filePath;\n        this.fileName \u003d fileName;\n        dataManager \u003d new DataManager();\n        partyComplete \u003d false;\n        maidenDefenseAccurate \u003d false;\n        bloatDefenseAccurate \u003d false;\n        nyloDefenseAccurate \u003d false;\n        soteDefenseAccurate \u003d false;\n        xarpDefenseAccurate \u003d false;\n\n        maidenThrallSpawns \u003d new ArrayList\u003c\u003e();\n        bloatThrallSpawns \u003d new ArrayList\u003c\u003e();\n        nyloThrallSpawns \u003d new ArrayList\u003c\u003e();\n        soteThrallSpawns \u003d new ArrayList\u003c\u003e();\n        xarpusThrallSpawns \u003d new ArrayList\u003c\u003e();\n        verzikThrallSpawns \u003d new ArrayList\u003c\u003e();\n\n        hardMode \u003d false;\n        storyMode \u003d false;\n        attacksP1 \u003d new ArrayList\u003c\u003e();\n        dawnDrops \u003d new ArrayList\u003c\u003e();\n\n        players \u003d new LinkedHashMap\u003c\u003e();\n        globalData \u003d new ArrayList\u003c\u003e(Arrays.asList(parameters));\n        Date endTime \u003d null;\n        int room \u003d -1;\n        for (String s : globalData)\n        {\n            try\n            {\n                String[] subData \u003d s.split(\",\");\n                int key \u003d Integer.parseInt(subData[3]);\n                if (key \u003d\u003d SPECTATE_FLAG)\n                {\n                    room \u003d Integer.parseInt(subData[4]);\n                    spectated \u003d true;\n                }\n                if (String.valueOf(key).equals(EXIT_FLAG))\n                {\n                    endTime \u003d new Date(Long.parseLong(subData[1]));\n                }\n            }\n            catch (Exception e)\n            {\n            }\n        }\n        if (room \u003e 0)\n        {\n            switch (room)\n            {\n                case 1:\n                    if (!(checkExit(MAIDEN) \u0026\u0026 parseBloat()))\n                        break;\n                case 2:\n                    if (!(checkExit(BLOAT) \u0026\u0026 parseNylo()))\n                        break;\n                case 3:\n                    if (!(checkExit(NYLOCAS) \u0026\u0026 parseSotetseg()))\n                        break;\n                case 4:\n                    if (!(checkExit(SOTETSEG) \u0026\u0026 parseXarpus()))\n                        break;\n                case 5:\n                    if (checkExit(XARPUS) \u0026\u0026 parseVerzik())\n                    {\n                        finishRaid();\n                    }\n            }\n        } else\n        {\n            try\n            {\n                if (parseMaiden())\n                {\n                    if (checkExit(MAIDEN) \u0026\u0026 parseBloat())\n                    {\n                        if (checkExit(BLOAT) \u0026\u0026 parseNylo())\n                        {\n                            if (checkExit(NYLOCAS) \u0026\u0026 parseSotetseg())\n                            {\n                                if (checkExit(SOTETSEG) \u0026\u0026 parseXarpus())\n                                {\n                                    if (checkExit(XARPUS) \u0026\u0026 parseVerzik())\n                                    {\n                                        finishRaid();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (Exception ignored)\n            {\n            }\n        }\n        setOverallTime();\n        if (raidStarted !\u003d null \u0026\u0026 endTime !\u003d null)\n        {\n            long difference \u003d endTime.getTime() - raidStarted.getTime();\n            int ticks \u003d (int) (difference / 600);\n            dataManager.set(DataPoint.OVERALL_TIME, ticks);\n            dataManager.set(DataPoint.TIME_OUTSIDE_ROOMS, dataManager.get(DataPoint.OVERALL_TIME) - dataManager.get(DataPoint.CHALLENGE_TIME));\n        }\n        globalData.clear();\n    }\n\n    private void parseGeneric(String room, String[] subData)\n    {\n        try\n        {\n            switch (LogID.valueOf(Integer.parseInt(subData[3])))\n            {\n                case ENTERED_TOB:\n                    raidStarted \u003d new Date(Long.parseLong(subData[1]));\n                    break;\n                case PARTY_MEMBERS:\n                    for (int i \u003d 4; i \u003c 9; i++)\n                    {\n                        if (!subData[i].isEmpty())\n                        {\n                            dataManager.increment(PARTY_SIZE);\n                            players.put(subData[i].replaceAll(\"[^\\\\p{ASCII}]\", \" \").replaceAll(\" +\", \" \"), 0);\n                        }\n                    }\n                    break;\n                case DWH:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" hit hammers\")));\n                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + \" hit hammers\"), subData[4]);\n                    if(!room.equals(\"Verzik\"))\n                    {\n                        dataManager.hammer(Objects.requireNonNull(DataPoint.getValue(room + \" defense\")));\n                    }\n                    break;\n                case BGS:\n                    if (!room.equals(\"Bloat\") || dataManager.get(DataPoint.BLOAT_DOWNS) \u003d\u003d 0)\n                    {\n                        dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" attempted BGS\")));\n                        dataManager.incrementPlayerSpecific(DataPoint.getValue(room + \" attempted BGS\"), subData[4]);\n                    }\n                    if(!room.equals(\"Verzik\"))\n                    {\n                        dataManager.bgs(Objects.requireNonNull(DataPoint.getValue(room + \" defense\")), Integer.parseInt(subData[5]));\n                    }\n                    break;\n                case PLAYER_DIED:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" deaths\")));\n                    dataManager.increment(DataPoint.TOTAL_DEATHS);\n                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + \" deaths\"), subData[4]);\n                    dataManager.incrementPlayerSpecific(DataPoint.TOTAL_DEATHS, subData[4]);\n                    if (players.get(subData[4]) !\u003d null)\n                    {\n                        players.put(subData[4], players.get(subData[4]) + 1);\n                    }\n                    break;\n                case HAMMER_ATTEMPTED:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" attempted hammers\")));\n                    dataManager.incrementPlayerSpecific(DataPoint.getValue(room + \" attempted hammers\"), subData[4]);\n                    break;\n                case IS_HARD_MODE:\n                    hardMode \u003d true;\n                    break;\n                case IS_STORY_MODE:\n                    storyMode \u003d true;\n                    break;\n                case THRALL_ATTACKED:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" thrall attacks\")));\n                    dataManager.increment(DataPoint.THRALL_ATTACKS_TOTAL);\n                    break;\n                case THRALL_DAMAGED:\n                    int amount \u003d Integer.parseInt(subData[5]);\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" thrall damage\")), amount);\n                    dataManager.increment(DataPoint.THRALL_DAMAGE_TOTAL, amount);\n                    break;\n                case VENG_WAS_CAST:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" veng casts\")));\n                    dataManager.increment(DataPoint.VENG_CASTS_TOTAL);\n                    break;\n                case VENG_WAS_PROCCED:\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" veng procs\")));\n                    dataManager.increment(DataPoint.VENG_PROCS_TOTAL);\n                    dataManager.increment(Objects.requireNonNull(DataPoint.getValue(room + \" veng damage\")), Integer.parseInt(subData[5]));\n                    dataManager.increment(DataPoint.VENG_DAMAGE_TOTAL, Integer.parseInt(subData[5]));\n                    break;\n                case KODAI_BOP:\n                    dataManager.increment(DataPoint.KODAI_BOPS);\n                    dataManager.incrementPlayerSpecific(DataPoint.KODAI_BOPS, subData[4]);\n                    break;\n                case DWH_BOP:\n                    dataManager.increment(DataPoint.DWH_BOPS);\n                    dataManager.incrementPlayerSpecific(DataPoint.DWH_BOPS, subData[4]);\n                    break;\n                case BGS_WHACK:\n                    dataManager.increment(DataPoint.BGS_WHACKS);\n                    dataManager.incrementPlayerSpecific(DataPoint.BGS_WHACKS, subData[4]);\n                    break;\n                case CHALLY_POKE:\n                    dataManager.increment(DataPoint.CHALLY_POKE);\n                    dataManager.incrementPlayerSpecific(DataPoint.CHALLY_POKE, subData[4]);\n                    break;\n            }\n        }\n        catch(Exception ignored)\n        {\n\n        }\n    }\n\n    private boolean parseVerzik()\n    {\n        int activeIndex \u003d 0;\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Verzik\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        if (dataManager.get(DataPoint.VERZIK_TOTAL_TIME) \u003d\u003d 0)\n                        {\n                            if (!verzikStarted)\n                            {\n                                xarpReset \u003d true;\n                            } else\n                            {\n                                verzikWipe \u003d true;\n                            }\n                        } else\n                        {\n                            return true;\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case DAWN_DROPPED:\n                        if (verzikStarted)\n                        {\n                            dawnDrops.add(Integer.parseInt(subData[4]));\n                        }\n                        break;\n                    case VERZIK_P1_START:\n                        verzikStarted \u003d true;\n                        break;\n                    case VERZIK_P1_DESPAWNED:\n                        dataManager.set(DataPoint.VERZIK_P1_SPLIT, Integer.parseInt(subData[4]) - 13);\n                        break;\n                    case VERZIK_P2_END:\n                        dataManager.set(DataPoint.VERZIK_P2_SPLIT, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.VERZIK_P2_DURATION, dataManager.get(DataPoint.VERZIK_P2_SPLIT) - dataManager.get(DataPoint.VERZIK_P1_SPLIT));\n                        dataManager.set(DataPoint.VERZIK_REDS_DURATION, dataManager.get(DataPoint.VERZIK_P2_SPLIT)-dataManager.get(VERZIK_REDS_SPLIT));\n                        try\n                        {\n                            int hp \u003d verzikHP.get(dataManager.get(VERZIK_REDS_SPLIT));\n                            dataManager.set(DataPoint.VERZIK_REDS_PROC_PERCENT, (hp));\n                        } catch\n                        (Exception ignored)\n                        {\n\n                        }\n                        break;\n                    case VERZIK_P3_DESPAWNED:\n                        dataManager.set(DataPoint.VERZIK_TOTAL_TIME, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.VERZIK_P3_DURATION, dataManager.get(DataPoint.VERZIK_TOTAL_TIME) - dataManager.get(DataPoint.VERZIK_P2_SPLIT));\n                        dataManager.set(DataPoint.CHALLENGE_TIME, (Integer.parseInt(subData[4]) + dataManager.get(DataPoint.VERZIK_ENTRY)));\n                        break;\n                    case VERZIK_CRAB_SPAWNED:\n                        if (!subData[4].equalsIgnoreCase(\"\"))\n                        {\n                            if (dataManager.get(DataPoint.VERZIK_P2_SPLIT) \u003e 1)\n                            {\n                                if (!p3Crabs.contains(Integer.parseInt(subData[4])))\n                                {\n                                    p3Crabs.add(Integer.parseInt(subData[4]));\n                                }\n                            } else\n                            {\n                                if (!p2Crabs.contains(Integer.parseInt(subData[4])))\n                                {\n                                    p2Crabs.add(Integer.parseInt(subData[4]));\n                                }\n                            }\n                        }\n                        dataManager.increment(VERZIK_CRABS_SPAWNED);\n                        break;\n                    case VERZIK_P2_REDS_PROC:\n                        if (dataManager.get(VERZIK_REDS_SPLIT) \u003d\u003d 0)\n                        {\n                            dataManager.set(VERZIK_REDS_SPLIT, Integer.parseInt(subData[4]));\n                            dataManager.set(VERZIK_P2_TILL_REDS, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.VERZIK_P1_SPLIT));\n                        }\n                        redsProc.add(Integer.parseInt(subData[4]));\n                        dataManager.increment(DataPoint.VERZIK_REDS_SETS);\n                        break;\n                    case ACCURATE_VERZIK_START:\n                        verzikStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_VERZIK_END:\n                        verzikEndAccurate \u003d true;\n                        verzikTimeAccurate \u003d verzikStartAccurate;\n                        break;\n                    case DAWN_SPEC:\n                        dawnSpecs.add(new DawnSpec(subData[4], Integer.parseInt(subData[5])));\n                        break;\n                    case DAWN_DAMAGE:\n                        for (DawnSpec dawnSpec : dawnSpecs)\n                        {\n                            if (dawnSpec.tick \u003d\u003d Integer.parseInt(subData[5]))\n                            {\n                                dawnSpec.setDamage(Integer.parseInt(subData[4]));\n                            }\n                        }\n                        break;\n                    case UPDATE_HP:\n                        verzikHP.put(Integer.parseInt(subData[5]), Integer.parseInt(subData[4]));\n                        break;\n                    case WEBS_STARTED:\n                        try\n                        {\n                            websStart.add(Integer.parseInt(subData[4]));\n                            if (dataManager.get(DataPoint.VERZIK_HP_AT_WEBS) \u003d\u003d -1)\n                            {\n                                int hp \u003d verzikHP.get(Integer.parseInt(subData[4]) - 1);\n                                hp /\u003d 10;\n                                dataManager.set(DataPoint.VERZIK_HP_AT_WEBS, hp);\n                            }\n                        }\n                        catch(Exception ignored)\n                        {\n\n                        }\n                        break;\n                    case THRALL_SPAWN:\n                        verzikThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n                }\n            } catch (Exception e)\n            {\n                log.info(\"Failed: \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean isTimeAccurateThroughRoom(TOBRoom room)\n    {\n        switch (room)\n        {\n            case VERZIK:\n                if (!verzikTimeAccurate)\n                {\n                    return false;\n                }\n            case XARPUS:\n                if (!xarpTimeAccurate)\n                {\n                    return false;\n                }\n            case SOTETSEG:\n                if (!soteTimeAccurate)\n                {\n                    return false;\n                }\n            case NYLOCAS:\n                if (!nyloTimeAccurate)\n                {\n                    return false;\n                }\n            case BLOAT:\n                if (!bloatTimeAccurate)\n                {\n                    return false;\n                }\n            case MAIDEN:\n                return maidenTimeAccurate;\n        }\n        return false;\n    }\n\n    private boolean parseXarpus()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Xarp\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        if (dataManager.get(DataPoint.XARP_TOTAL_TIME) !\u003d 0)\n                        {\n                            xarpReset \u003d true;\n                        } else\n                        {\n                            if (!xarpStarted)\n                            {\n                                soteReset \u003d true;\n                            } else\n                            {\n                                xarpWipe \u003d true;\n                            }\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case XARPUS_STARTED:\n                        xarpStarted \u003d true;\n                        if (partyComplete)\n                        {\n                            xarpDefenseAccurate \u003d true;\n                        }\n                        break;\n                    case XARPUS_HEAL:\n                        dataManager.increment(DataPoint.XARP_HEALING, getXarpusHealAmount());\n                        break;\n                    case XARPUS_SCREECH:\n                        dataManager.set(DataPoint.XARP_SCREECH, Integer.parseInt(subData[4]));\n                        break;\n                    case XARPUS_DESPAWNED:\n                        dataManager.set(DataPoint.XARP_TOTAL_TIME, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.XARP_POST_SCREECH, dataManager.get(DataPoint.XARP_TOTAL_TIME) - dataManager.get(DataPoint.XARP_SCREECH));\n                        if (isTimeAccurateThroughRoom(SOTETSEG))\n                            dataManager.set(DataPoint.VERZIK_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.XARP_ENTRY));\n                        break loop;\n                    case ACCURATE_XARP_START:\n                        xarpStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_XARP_END:\n                        xarpTimeAccurate \u003d xarpStartAccurate;\n                        xarpEndAccurate \u003d true;\n                        break;\n                    case THRALL_SPAWN:\n                        xarpusThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n                }\n            }\n            catch(Exception e)\n            {\n                log.info(\"Failed on \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private int getXarpusHealAmount()\n    {\n        int amount \u003d 0;\n        switch (getScale())\n        {\n            case 5:\n                amount \u003d 8;\n                break;\n            case 4:\n                amount \u003d 9;\n                break;\n            case 3:\n                amount \u003d 12;\n                break;\n            case 2:\n                amount \u003d 16;\n                break;\n            case 1:\n                amount \u003d 20;\n                break;\n        }\n        return amount;\n    }\n\n    private boolean parseSotetseg()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Sote\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case DWH:\n                        if (dataManager.get(DataPoint.SOTE_P1_SPLIT) \u003d\u003d 0)\n                        {\n                            dataManager.increment(DataPoint.SOTE_SPECS_P1);\n                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);\n                        } else if (dataManager.get(DataPoint.SOTE_P2_SPLIT) \u003d\u003d 0)\n                        {\n                            dataManager.increment(DataPoint.SOTE_SPECS_P2);\n                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);\n                        } else\n                        {\n                            dataManager.increment(DataPoint.SOTE_SPECS_P3);\n                            dataManager.increment(DataPoint.SOTE_SPECS_TOTAL);\n                        }\n                        break;\n                    case LEFT_TOB:\n                        if (dataManager.get(DataPoint.SOTE_TOTAL_TIME) !\u003d 0)\n                        {\n                            soteReset \u003d true;\n                        } else\n                        {\n                            if (!soteStarted)\n                            {\n                                nyloReset \u003d true;\n                            } else\n                            {\n                                soteWipe \u003d true;\n                            }\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case SOTETSEG_STARTED:\n                        soteStarted \u003d true;\n                        if (partyComplete)\n                        {\n                            soteDefenseAccurate \u003d true;\n                        }\n                        break;\n                    case SOTETSEG_FIRST_MAZE_STARTED:\n                        dataManager.set(DataPoint.SOTE_P1_SPLIT, Integer.parseInt(subData[4]));\n                        break;\n                    case SOTETSEG_FIRST_MAZE_ENDED:\n                        dataManager.set(DataPoint.SOTE_M1_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_P1_SPLIT));\n                        dataManager.set(DataPoint.SOTE_M1_SPLIT, Integer.parseInt(subData[4]));\n                        break;\n                    case SOTETSEG_SECOND_MAZE_STARTED:\n                        dataManager.set(DataPoint.SOTE_P2_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_M1_SPLIT));\n                        dataManager.set(DataPoint.SOTE_P2_SPLIT, Integer.parseInt(subData[4]));\n                        break;\n                    case SOTETSEG_SECOND_MAZE_ENDED:\n                        dataManager.set(DataPoint.SOTE_M2_DURATION, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.SOTE_P2_SPLIT));\n                        dataManager.set(DataPoint.SOTE_M2_SPLIT, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.SOTE_MAZE_SUM, dataManager.get(DataPoint.SOTE_M1_DURATION) + dataManager.get(DataPoint.SOTE_M2_DURATION));\n                        break;\n                    case SOTETSEG_ENDED:\n                        dataManager.set(DataPoint.SOTE_TOTAL_TIME, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.SOTE_P3_DURATION, dataManager.get(DataPoint.SOTE_TOTAL_TIME) - dataManager.get(DataPoint.SOTE_M2_SPLIT));\n                        if (isTimeAccurateThroughRoom(NYLOCAS))\n                            dataManager.set(DataPoint.XARP_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.SOTE_ENTRY));\n                        break loop;\n                    case ACCURATE_SOTE_START:\n                        soteStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_SOTE_END:\n                        soteEndAccurate \u003d true;\n                        soteTimeAccurate \u003d soteStartAccurate;\n                        if (soteTimeAccurate \u0026\u0026 bloatTimeAccurate \u0026\u0026 !spectated)\n                        {\n                            nyloStartAccurate \u003d true;\n                            nyloEndAccurate \u003d true;\n                            nyloTimeAccurate \u003d true;\n                        }\n                        break;\n                    case THRALL_SPAWN:\n                        soteThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n\n                }\n            }\n            catch(Exception e)\n            {\n                log.info(\"Failed on \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseNylo()\n    {\n        int activeIndex \u003d 0;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Nylo\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        if (dataManager.get(NYLOCAS_PILLAR_DESPAWN_TICK) - 5 \u003c dataManager.get(DataPoint.NYLO_BOSS_SPAWN))\n                        {\n                            dataManager.set(DataPoint.NYLO_BOSS_SPAWN, 0);\n                            dataManager.set(DataPoint.NYLO_TOTAL_TIME, 0);\n                        }\n                        if (dataManager.get(DataPoint.NYLO_TOTAL_TIME) !\u003d 0)\n                        {\n                            nyloReset \u003d true;\n                        } else\n                        {\n                            if (!nyloStarted)\n                            {\n                                if (!bloatEndAccurate)\n                                {\n                                    bloatWipe \u003d true;\n                                } else\n                                {\n                                    bloatReset \u003d true;\n                                }\n                            } else\n                            {\n                                nyloWipe \u003d true;\n                            }\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case NYLO_PILLAR_SPAWN:\n                        nyloStarted \u003d true;\n                        break;\n                    case NYLO_STALL:\n                        nyloWaveStalled.add(Integer.parseInt(subData[5]));\n                        dataManager.increment(DataPoint.NYLO_STALLS_TOTAL);\n                        if (Integer.parseInt(subData[4]) \u003e 19)\n                        {\n                            dataManager.increment(DataPoint.NYLO_STALLS_POST_20);\n                        } else\n                        {\n                            dataManager.increment(DataPoint.NYLO_STALLS_PRE_20);\n                        }\n                        break;\n                    case RANGE_SPLIT:\n                        dataManager.increment(DataPoint.NYLO_SPLITS_RANGE);\n                        break;\n                    case MAGE_SPLIT:\n                        dataManager.increment(DataPoint.NYLO_SPLITS_MAGE);\n                        break;\n                    case MELEE_SPLIT:\n                        dataManager.increment(DataPoint.NYLO_SPLITS_MELEE);\n                        break;\n                    case LAST_WAVE:\n                        dataManager.set(DataPoint.NYLO_LAST_WAVE, Integer.parseInt(subData[4]));\n                        break;\n                    case LAST_DEAD:\n                        int nyloLastDead \u003d Integer.parseInt(subData[4]);\n                        dataManager.set(NYLO_LAST_DEAD, nyloLastDead);\n                        int offset \u003d 20 - (nyloLastDead % 4); //4 cycle (16 tick) delay for boss + difference to cycle (4-time%instance reference)\n                        dataManager.set(DataPoint.NYLO_BOSS_SPAWN, nyloLastDead + offset);\n                        dataManager.set(DataPoint.NYLO_CLEANUP, nyloLastDead - dataManager.get(DataPoint.NYLO_LAST_WAVE));\n                        break;\n                    case NYLO_WAVE:\n                        waveSpawns.put(Integer.parseInt(subData[4]), Integer.parseInt(subData[5]));\n                        break;\n                    case BOSS_SPAWN: //The number people are used to seeing on timers for boss spawn is actually 2 ticks prior to the spawn call for the boss\n                        dataManager.set(DataPoint.NYLO_BOSS_SPAWN, Integer.parseInt(subData[4]) - 2);\n                        if (partyComplete)\n                        {\n                            nyloDefenseAccurate \u003d true;\n                        }\n                        break;\n                    case MELEE_PHASE:\n                        dataManager.increment(DataPoint.NYLO_ROTATIONS_MELEE);\n                        break;\n                    case MAGE_PHASE:\n                        dataManager.increment(DataPoint.NYLO_ROTATIONS_MAGE);\n                        break;\n                    case RANGE_PHASE:\n                        dataManager.increment(DataPoint.NYLO_ROTATIONS_RANGE);\n                        break;\n                    case NYLO_DESPAWNED:\n                        if (Integer.parseInt(subData[4]) - dataManager.get(DataPoint.NYLO_BOSS_SPAWN) \u003e 30)\n                        {\n                            dataManager.set(DataPoint.NYLO_TOTAL_TIME, Integer.parseInt(subData[4]));\n                            dataManager.set(DataPoint.NYLO_BOSS_DURATION, dataManager.get(DataPoint.NYLO_TOTAL_TIME) - dataManager.get(DataPoint.NYLO_BOSS_SPAWN));\n                            if (isTimeAccurateThroughRoom(BLOAT))\n                                dataManager.set(DataPoint.SOTE_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.NYLO_ENTRY));\n                        }\n                        break loop;\n                    case NYLO_PILLAR_DESPAWNED:\n                        dataManager.set(NYLOCAS_PILLAR_DESPAWN_TICK, Integer.parseInt(subData[4]));\n                        break;\n                    case ACCURATE_NYLO_START:\n                        nyloStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_NYLO_END:\n                        nyloEndAccurate \u003d true;\n                        nyloTimeAccurate \u003d nyloStartAccurate;\n                        break;\n                    case THRALL_SPAWN:\n                        nyloThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n                }\n            }\n            catch(Exception e)\n            {\n                log.info(\"Failed on \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseBloat()\n    {\n        int activeIndex \u003d 0;\n        bloatDefenseAccurate \u003d maidenDefenseAccurate;\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Bloat\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case BLOAT_HP_1ST_DOWN:\n                        dataManager.set(DataPoint.BLOAT_HP_FIRST_DOWN, Integer.parseInt(subData[4]) / 10);\n                        break;\n                    case BLOAT_SCYTHE_1ST_WALK:\n                        if (dataManager.get(DataPoint.BLOAT_DOWNS) \u003d\u003d 0)\n                        {\n                            dataManager.increment(DataPoint.BLOAT_FIRST_WALK_SCYTHES);\n                            dataManager.incrementPlayerSpecific(DataPoint.BLOAT_FIRST_WALK_SCYTHES, subData[4]);\n                        }\n                        break;\n                    case LEFT_TOB:\n                        if (bloatEndAccurate)\n                        {\n                            bloatReset \u003d true;\n                        } else\n                        {\n                            if (!bloatStarted)\n                            {\n                                maidenReset \u003d true;\n                            } else\n                            {\n                                bloatWipe \u003d true;\n                            }\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case PLAYER_DIED:\n                        if (dataManager.get(DataPoint.BLOAT_DOWNS) \u003d\u003d 0)\n                        {\n                            dataManager.increment(DataPoint.BLOAT_FIRST_WALK_DEATHS);\n                            dataManager.incrementPlayerSpecific(DataPoint.BLOAT_FIRST_WALK_DEATHS, subData[4]);\n                        }\n                        break;\n                    case BLOAT_SPAWNED:\n                        bloatStarted \u003d true;\n                        if (partyComplete)\n                        {\n                            bloatDefenseAccurate \u003d true;\n                        }\n                        break;\n                    case BLOAT_DOWN:\n                        if (dataManager.get(DataPoint.BLOAT_DOWNS) \u003d\u003d 0)\n                        {\n                            dataManager.set(DataPoint.BLOAT_FIRST_DOWN_TIME, Integer.parseInt(subData[4]));\n                        }\n                        dataManager.increment(DataPoint.BLOAT_DOWNS);\n                        bloatDowns.add(Integer.parseInt(subData[4]));\n                        break;\n                    case BLOAT_DESPAWN:\n                        dataManager.set(DataPoint.BLOAT_TOTAL_TIME, Integer.parseInt(subData[4]));\n                        if (isTimeAccurateThroughRoom(MAIDEN))\n                            dataManager.set(DataPoint.NYLO_ENTRY, Integer.parseInt(subData[4]) + dataManager.get(DataPoint.MAIDEN_TOTAL_TIME));\n                        break loop;\n                    case ACCURATE_BLOAT_START:\n                        bloatStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_BLOAT_END:\n                        bloatEndAccurate \u003d true;\n                        bloatTimeAccurate \u003d bloatStartAccurate;\n                        break;\n                    case THRALL_SPAWN:\n                        bloatThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n                }\n            }\n            catch(Exception e)\n            {\n                log.info(\"Failed on \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private boolean parseMaiden()\n    {\n        int activeIndex \u003d 0;\n        String lastProc \u003d \" 70s\";\n        loop:\n        for (String s : globalData)\n        {\n            String[] subData \u003d s.split(\",\", -1);\n            parseGeneric(\"Maiden\", subData);\n            try\n            {\n                switch (LogID.valueOf(Integer.parseInt(subData[3])))\n                {\n                    case LEFT_TOB:\n                        int percent \u003d 100;\n                        if (dataManager.get(DataPoint.MAIDEN_CHINS_THROWN) !\u003d 0)\n                        {\n                            double percentDouble \u003d ((double) (dataManager.get(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE)) / dataManager.get(DataPoint.MAIDEN_CHINS_THROWN)) * 100;\n                            percent \u003d (int) percentDouble;\n                        }\n                        dataManager.set(DataPoint.MAIDEN_CHIN_CORRECT_DISTANCE_PERCENT, percent);\n                        if (dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) !\u003d 0)\n                        {\n                            maidenReset \u003d true;\n                        } else\n                        {\n                            if (!maidenSpawned)\n                            {\n                                maidenReset \u003d true;\n                                resetBeforeMaiden \u003d true;\n                            } else\n                            {\n                                maidenWipe \u003d true;\n                            }\n                        }\n                        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n                        Date endTime \u003d new Date(Long.parseLong(subData[1]));\n                        long difference \u003d endTime.getTime() - raidStarted.getTime();\n                        int ticks \u003d (int) (difference / 600);\n                        dataManager.set(DataPoint.OVERALL_TIME, ticks);\n                        return false;\n                    case BLOOD_THROWN:\n                        dataManager.increment(DataPoint.MAIDEN_BLOOD_THROWN);\n                        break;\n                    case BLOOD_SPAWNED:\n                        dataManager.increment(DataPoint.MAIDEN_BLOOD_SPAWNED);\n                        break;\n                    case CRAB_LEAK:\n                        if (dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) \u003d\u003d 0) //TODO: see case 16 fix\n                        {\n                            dataManager.increment(DataPoint.MAIDEN_CRABS_LEAKED);\n                            int crabHP \u003d -1;\n                            try\n                            {\n                                crabHP \u003d Integer.parseInt(subData[5]);\n\n                                maidenCrabs.add(new StringInt(subData[4], crabHP));\n                            } catch (Exception ignored)\n                            {\n                            }\n                            dataManager.increment(DataPoint.MAIDEN_HP_HEALED, crabHP * 2);\n                            int maxCrabHP \u003d 100;\n                            switch (players.size())\n                            {\n                                case 1:\n                                case 2:\n                                case 3:\n                                    maxCrabHP \u003d 75;\n                                    break;\n                                case 4:\n                                    maxCrabHP \u003d 87;\n                                    break;\n                            }\n                            if (crabHP \u003d\u003d maxCrabHP)\n                            {\n                                dataManager.increment(DataPoint.MAIDEN_CRABS_LEAKED_FULL_HP);\n                            }\n\n                            if (subData[4].contains(\"30\"))\n                            {\n                                maidenSkip \u003d false;\n                            }\n                        }\n                        break;\n                    case MAIDEN_PLAYER_DRAINED:\n                        dataManager.increment(DataPoint.MAIDEN_MELEE_DRAINS);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_MELEE_DRAINS, subData[4]);\n                        break;\n                    case MAIDEN_SPAWNED:\n                        maidenSpawned \u003d true;\n                        if (partyComplete)\n                        {\n                            maidenDefenseAccurate \u003d true;\n                        }\n                        break;\n                    case MAIDEN_70S:\n                        dataManager.set(DataPoint.MAIDEN_70_SPLIT, Integer.parseInt(subData[4]));\n                        lastProc \u003d \" 70s\";\n                        break;\n                    case MAIDEN_50S:\n                        dataManager.set(DataPoint.MAIDEN_50_SPLIT, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.MAIDEN_7050_SPLIT, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.MAIDEN_70_SPLIT));\n                        lastProc \u003d \" 50s\";\n                        break;\n                    case MAIDEN_30S:\n                        dataManager.set(DataPoint.MAIDEN_30_SPLIT, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.MAIDEN_5030_SPLIT, Integer.parseInt(subData[4]) - dataManager.get(DataPoint.MAIDEN_50_SPLIT));\n                        lastProc \u003d \" 30s\";\n                        break;\n                    case MAIDEN_0HP:\n                        dataManager.set(DataPoint.MAIDEN_TOTAL_TIME, Integer.parseInt(subData[4]) + 7);\n                        dataManager.set(DataPoint.MAIDEN_SKIP_SPLIT, dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) - dataManager.get(DataPoint.MAIDEN_30_SPLIT));\n                        if (globalData.get(activeIndex + 1).split(\",\", -1)[3].equals(\"4\"))\n                            maidenReset \u003d true;\n                        break loop;\n                    case MAIDEN_DESPAWNED:\n                        dataManager.set(DataPoint.MAIDEN_TOTAL_TIME, Integer.parseInt(subData[4]));\n                        dataManager.set(DataPoint.MAIDEN_SKIP_SPLIT, dataManager.get(DataPoint.MAIDEN_TOTAL_TIME) - dataManager.get(DataPoint.MAIDEN_30_SPLIT));\n                        if (globalData.get(activeIndex + 1).split(\",\", -1)[3].equals(\"4\"))\n                            maidenReset \u003d true;\n                        break loop;\n                    case MATOMENOS_SPAWNED:\n                        maidenCrabSpawn.add(subData[4]);\n                        break;\n                    case MAIDEN_SCUFFED:\n                        if (!maidenScuffed)\n                        {\n                            firstMaidenCrabScuffed \u003d lastProc;\n                            if(!maidenCrabSpawn.isEmpty())\n                            {\n                                firstMaidenCrabScuffed \u003d maidenCrabSpawn.get(maidenCrabSpawn.size()-1);\n                            }\n                        }\n                        maidenScuffed \u003d true;\n                        break;\n                    case BLOAT_SPAWNED:\n                        //todo: joined after maiden was kill. mark this somehow?\n                        maidenReset \u003d true; //TODO remove\n                        break loop;\n                    case SPECTATE:\n                        spectated \u003d true;\n                        break;\n                    case MAIDEN_DINHS_SPEC:\n                        dataManager.increment(DataPoint.MAIDEN_DINHS_SPECS);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_DINHS_SPECS, subData[4]);\n                        String[] targets \u003d subData[6].split(\":\");\n                        int targetCountThisSpec \u003d 0;\n                        int crabCountThisSpec \u003d 0;\n                        String[] specData \u003d subData[7].split(\":\");\n                        if (specData.length !\u003d 5)\n                        {\n                            break;\n                        }\n                        for (String target : targets)\n                        {\n                            String[] targetData \u003d target.split(\"~\");\n                            if (targetData.length \u003d\u003d 3)\n                            {\n                                targetCountThisSpec++;\n                                String spawnID \u003d targetData[1];\n                                if (!spawnID.equals(\"^\")) //Target is crab\n                                {\n                                    crabCountThisSpec++;\n                                }\n                            }\n                        }\n                        int averageHP \u003d Integer.parseInt(specData[0]);\n                        int belowThreshold \u003d Integer.parseInt(specData[1]);\n                        if (dataManager.get(DataPoint.MAIDEN_DINHS_SPECS) \u003d\u003d 0)\n                        {\n                            int percentCrabsTargeted \u003d (int) ((((double) crabCountThisSpec) / targetCountThisSpec) * 100);\n                            int percentCrabsUnder27Targeted \u003d (int) ((((double) belowThreshold) / crabCountThisSpec) * 100);\n\n                            dataManager.set(DataPoint.MAIDEN_DINHS_TARGETS_HIT, targetCountThisSpec);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_HIT, crabCountThisSpec);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT, averageHP);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED, belowThreshold);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_PERCENT_TARGETS_CRAB, percentCrabsTargeted);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT, percentCrabsUnder27Targeted);\n                        } else\n                        {\n                            int previousAverage \u003d dataManager.get(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT);\n                            int previousCrabsHit \u003d dataManager.get(DataPoint.MAIDEN_DINHS_CRABS_HIT);\n                            int previousTotalHit \u003d dataManager.get(DataPoint.MAIDEN_DINHS_TARGETS_HIT);\n                            int previousBelow27Hit \u003d dataManager.get(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED);\n\n                            dataManager.set(DataPoint.MAIDEN_DINHS_TARGETS_HIT, previousTotalHit + targetCountThisSpec);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_HIT, previousCrabsHit + crabCountThisSpec);\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED, previousBelow27Hit + belowThreshold);\n\n                            int roundedAverageSum \u003d ((previousAverage * previousCrabsHit) + (averageHP * crabCountThisSpec));\n                            int roundedAverageCumulative \u003d (int) (((double) roundedAverageSum) / (previousCrabsHit + crabCountThisSpec));\n\n                            dataManager.set(DataPoint.MAIDEN_DINHS_AVERAGE_HP_HIT, roundedAverageCumulative);\n\n                            int percentTargetedCumulative \u003d (int) (((double) (previousCrabsHit + crabCountThisSpec) / (previousTotalHit + targetCountThisSpec)) * 100);\n\n                            dataManager.set(DataPoint.MAIDEN_DINHS_PERCENT_TARGETS_CRAB, percentTargetedCumulative);\n\n                            int percentBelow27Cumulative \u003d (int) ((double) (previousBelow27Hit + belowThreshold) / (previousCrabsHit + crabCountThisSpec));\n\n                            dataManager.set(DataPoint.MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT, percentBelow27Cumulative);\n                        }\n                        break;\n                    case MAIDEN_CHIN_THROWN:\n                        dataManager.increment(DataPoint.MAIDEN_CHINS_THROWN);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_CHINS_THROWN, subData[4]);\n                        if (Integer.parseInt(subData[5]) \u003c 4 || Integer.parseInt(subData[5]) \u003e 6)\n                        {\n                            dataManager.increment(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE);\n                            dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_CHINS_THROWN_WRONG_DISTANCE, subData[4]);\n                        }\n                        break;\n                    case ACCURATE_MAIDEN_START:\n                        maidenStartAccurate \u003d true;\n                        break;\n                    case ACCURATE_MAIDEN_END:\n                        maidenEndAccurate \u003d true;\n                        maidenTimeAccurate \u003d maidenStartAccurate;\n                        break;\n                    case THRALL_SPAWN:\n                        maidenThrallSpawns.add(new ThrallOutlineBox(subData[4], Integer.parseInt(subData[5]), Integer.parseInt(subData[6])));\n                        break;\n                    case PLAYER_STOOD_IN_THROWN_BLOOD:\n                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD);\n                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_THROWN_BLOOD, Integer.parseInt(subData[5]));\n\n                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD);\n                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, Integer.parseInt(subData[5]));\n\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD, subData[4]);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_THROWN_BLOOD, subData[4], Integer.parseInt(subData[5]));\n\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD, subData[4]);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, subData[4], Integer.parseInt(subData[5]));\n                        break;\n                    case PLAYER_STOOD_IN_SPAWNED_BLOOD:\n                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD);\n                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_SPAWNED_BLOOD, Integer.parseInt(subData[5]));\n\n                        dataManager.increment(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD);\n                        dataManager.increment(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, Integer.parseInt(subData[5]));\n\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD, subData[4]);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_SPAWNED_BLOOD, subData[4], Integer.parseInt(subData[5]));\n\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_PLAYER_STOOD_IN_BLOOD, subData[4]);\n                        dataManager.incrementPlayerSpecific(DataPoint.MAIDEN_HEALS_FROM_ANY_BLOOD, subData[4], Integer.parseInt(subData[5]));\n                        break;\n                }\n            }\n            catch(Exception e)\n            {\n                log.info(\"Failed on \" + s);\n            }\n            activeIndex++;\n        }\n        globalData \u003d new ArrayList\u003c\u003e(globalData.subList(activeIndex + 1, globalData.size()));\n        return true;\n    }\n\n    private void finishRaid()\n    {\n        raidCompleted \u003d true;\n    }\n\n\n    public String getScaleString()\n    {\n        String scaleString \u003d \"\";\n        switch (players.size())\n        {\n            case 1:\n                scaleString \u003d \"Solo\";\n                break;\n            case 2:\n                scaleString \u003d \"Duo\";\n                break;\n            case 3:\n                scaleString \u003d \"Trio\";\n                break;\n            case 4:\n                scaleString \u003d \"4 Man\";\n                break;\n            case 5:\n                scaleString \u003d \"5 Man\";\n                break;\n        }\n        if (storyMode)\n        {\n            scaleString +\u003d \" (Story)\";\n        }\n        if (hardMode)\n        {\n            scaleString +\u003d \" (Hard)\";\n        }\n        return scaleString;\n    }\n\n    public String getRoomStatus()\n    {\n        String raidStatusString;\n        if (maidenWipe)\n        {\n            raidStatusString \u003d \"Maiden Wipe\";\n        } else if (maidenReset)\n        {\n            raidStatusString \u003d \"Maiden Reset\";\n            if (!maidenSpawned)\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        } else if (bloatWipe)\n        {\n            raidStatusString \u003d \"Bloat Wipe\";\n        } else if (bloatReset)\n        {\n            raidStatusString \u003d \"Bloat Reset\";\n            if (getBloatTime() \u003d\u003d 0)\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        } else if (nyloWipe)\n        {\n            raidStatusString \u003d \"Nylo Wipe\";\n        } else if (nyloReset)\n        {\n            raidStatusString \u003d \"Nylo Reset\";\n            if (getNyloTime() \u003d\u003d 0)\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        } else if (soteWipe)\n        {\n            raidStatusString \u003d \"Sotetseg Wipe\";\n        } else if (soteReset)\n        {\n            raidStatusString \u003d \"Sotetseg Reset\";\n            if (getSoteTime() \u003d\u003d 0)\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        } else if (xarpWipe)\n        {\n            raidStatusString \u003d \"Xarpus Wipe\";\n        } else if (xarpReset)\n        {\n            raidStatusString \u003d \"Xarpus Reset\";\n            if (getXarpTime() \u003d\u003d 0)\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        } else if (verzikWipe)\n        {\n            raidStatusString \u003d \"Verzik Wipe\";\n        } else\n        {\n            raidStatusString \u003d \"Completion\";\n            if (!getOverallTimeAccurate())\n            {\n                raidStatusString +\u003d \"*\";\n            }\n        }\n        String red \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#FF0000\u0027\u003e\";\n        String green \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#44AF33\u0027\u003e\";\n        String yellow \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#EEEE44\u0027\u003e\";\n        if (raidStatusString.contains(\"Completion\"))\n        {\n            raidStatusString \u003d green + raidStatusString;\n        } else if (raidStatusString.contains(\"Reset\"))\n        {\n            raidStatusString \u003d yellow + raidStatusString;\n        } else\n        {\n            raidStatusString \u003d red + raidStatusString;\n        }\n        return raidStatusString;\n    }\n}\n\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\SimpleTOBData.java"},{"fileName":"BaseFrame.java","content":"package com.advancedraidtracker.ui;\n\n\nimport com.formdev.flatlaf.FlatClientProperties;\n\nimport com.formdev.flatlaf.ui.FlatNativeWindowBorder;\n\n\nimport javax.swing.*;\n\npublic class BaseFrame extends JFrame\n{\n    public BaseFrame()\n    {\n        JRootPane rp \u003d getRootPane();\n        if (FlatNativeWindowBorder.isSupported())\n        {\n            rp.putClientProperty(FlatClientProperties.USE_WINDOW_DECORATIONS, true);\n        }\n        setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n    }\n\n    public void open()\n    {\n        setVisible(true);\n        toFront();\n        repaint();\n    }\n\n    public void close()\n    {\n        setVisible(false);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\BaseFrame.java"},{"fileName":"ButtonEditorComparisonData.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport com.advancedraidtracker.ui.Raids;\n\nimport javax.swing.*;\nimport java.awt.*;\npublic class ButtonEditorComparisonData extends DefaultCellEditor\n{\n    protected JButton button;\n    private String label;\n    private boolean isPushed;\n    private final Raids frame;\n    int row;\n\n    public ButtonEditorComparisonData(JCheckBox checkBox, Raids raidsFrame)\n    {\n        super(checkBox);\n        frame \u003d raidsFrame;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    @Override\n    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)\n    {\n        if (isSelected)\n        {\n            button.setForeground(table.getSelectionForeground());\n            button.setBackground(table.getSelectionBackground());\n        } else\n        {\n            button.setForeground(table.getForeground());\n            button.setBackground(table.getBackground());\n        }\n        label \u003d (value \u003d\u003d null) ? \"\" : value.toString();\n        button.setText(label);\n        isPushed \u003d true;\n        this.row \u003d row;\n        return button;\n    }\n\n    @Override\n    public Object getCellEditorValue()\n    {\n        if (isPushed)\n        {\n            frame.removeComparisonRow(row);\n        }\n        isPushed \u003d false;\n        return label;\n    }\n\n    @Override\n    public boolean stopCellEditing()\n    {\n        isPushed \u003d false;\n        return super.stopCellEditing();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonEditorComparisonData.java"},{"fileName":"ButtonEditorFilterData.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport com.advancedraidtracker.ui.Raids;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class ButtonEditorFilterData extends DefaultCellEditor\n{\n    protected JButton button;\n    private String label;\n    private boolean isPushed;\n    private final Raids frame;\n    int row;\n\n    public ButtonEditorFilterData(JCheckBox checkBox, Raids raidsFrame)\n    {\n        super(checkBox);\n        frame \u003d raidsFrame;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    @Override\n    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)\n    {\n        if (isSelected)\n        {\n            button.setForeground(table.getSelectionForeground());\n            button.setBackground(table.getSelectionBackground());\n        } else\n        {\n            button.setForeground(table.getForeground());\n            button.setBackground(table.getBackground());\n        }\n        label \u003d (value \u003d\u003d null) ? \"\" : value.toString();\n        button.setText(label);\n        isPushed \u003d true;\n        this.row \u003d row;\n        return button;\n    }\n\n    @Override\n    public Object getCellEditorValue()\n    {\n        if (isPushed)\n        {\n            frame.removeFilterRow(row);\n        }\n        isPushed \u003d false;\n        return label;\n    }\n\n    @Override\n    public boolean stopCellEditing()\n    {\n        isPushed \u003d false;\n        return super.stopCellEditing();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonEditorFilterData.java"},{"fileName":"ButtonEditorLoadFilters.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport com.advancedraidtracker.filters.Filter;\nimport com.advancedraidtracker.filters.ImplicitFilter;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.ui.Raids;\nimport com.advancedraidtracker.ui.filters.LoadFilter;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\n@Slf4j\npublic class ButtonEditorLoadFilters extends DefaultCellEditor\n{\n\n    protected JButton button;\n    private String label;\n    private boolean isPushed;\n    private final boolean replace;\n    int row;\n    private final ArrayList\u003cFilter\u003e data;\n    private final BaseFrame closeBaseFrame;\n    private final Raids filteredRaidsFrame;\n\n    public ButtonEditorLoadFilters(JCheckBox checkBox, Raids filteredRaidsFrame, ArrayList\u003cFilter\u003e data, LoadFilter loadFrame)\n    {\n        super(checkBox);\n        this.data \u003d data;\n        this.replace \u003d true;\n        this.filteredRaidsFrame \u003d filteredRaidsFrame;\n        this.closeBaseFrame \u003d loadFrame;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    public ButtonEditorLoadFilters(JCheckBox checkBox, Raids filteredRaidsFrame, ArrayList\u003cFilter\u003e data, LoadFilter loadFrame, boolean replace)\n    {\n        super(checkBox);\n        this.data \u003d data;\n        this.filteredRaidsFrame \u003d filteredRaidsFrame;\n        this.closeBaseFrame \u003d loadFrame;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        this.replace \u003d replace;\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    @Override\n    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)\n    {\n        if (isSelected)\n        {\n            button.setForeground(table.getSelectionForeground());\n            button.setBackground(table.getSelectionBackground());\n        } else\n        {\n            button.setForeground(table.getForeground());\n            button.setBackground(table.getBackground());\n        }\n        label \u003d (value \u003d\u003d null) ? \"\" : value.toString();\n        button.setText(label);\n        isPushed \u003d true;\n        this.row \u003d row;\n        return button;\n    }\n\n    @Override\n    public Object getCellEditorValue()\n    {\n        if (isPushed)\n        {\n\n            if (replace)\n                filteredRaidsFrame.activeFilters.clear();\n            for (String s : data.get(row).getFilters())\n            {\n                if(!s.startsWith(\"QF-\"))\n                {\n                    filteredRaidsFrame.activeFilters.add(new ImplicitFilter(s));\n                }\n                else\n                {\n                    filteredRaidsFrame.setFilterState(s.substring(3));\n                }\n            }\n            filteredRaidsFrame.updateFilterTable();\n            closeBaseFrame.close();\n        }\n        isPushed \u003d false;\n        return label;\n    }\n\n    @Override\n    public boolean stopCellEditing()\n    {\n        isPushed \u003d false;\n        return super.stopCellEditing();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonEditorLoadFilters.java"},{"fileName":"ButtonEditorRoomData.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.ui.viewraid.ViewTOBRaid;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class ButtonEditorRoomData extends DefaultCellEditor\n{\n\n    protected JButton button;\n    private String label;\n    private boolean isPushed;\n    private final ArrayList\u003cSimpleTOBData\u003e data;\n    int row;\n\n    public ButtonEditorRoomData(JCheckBox checkBox, ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        super(checkBox);\n        this.data \u003d data;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    @Override\n    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)\n    {\n        if (isSelected)\n        {\n            button.setForeground(table.getSelectionForeground());\n            button.setBackground(table.getSelectionBackground());\n        } else\n        {\n            button.setForeground(table.getForeground());\n            button.setBackground(table.getBackground());\n        }\n        label \u003d (value \u003d\u003d null) ? \"\" : value.toString();\n        button.setText(label);\n        isPushed \u003d true;\n        this.row \u003d row;\n        return button;\n    }\n\n    @Override\n    public Object getCellEditorValue()\n    {\n        if (isPushed)\n        {\n            ViewTOBRaid raid \u003d new ViewTOBRaid(data.get(row));\n            //ViewRaidFrame raid \u003d new ViewRaidFrame(data.get(row));\n            raid.open();\n        }\n        isPushed \u003d false;\n        return label;\n    }\n\n    @Override\n    public boolean stopCellEditing()\n    {\n        isPushed \u003d false;\n        return super.stopCellEditing();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonEditorRoomData.java"},{"fileName":"ButtonEditorViewFilters.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport com.advancedraidtracker.filters.Filter;\nimport com.advancedraidtracker.ui.filters.ViewFilter;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class ButtonEditorViewFilters extends DefaultCellEditor\n{\n\n    protected JButton button;\n    private String label;\n    private boolean isPushed;\n    int row;\n    private final ArrayList\u003cFilter\u003e data;\n\n    public ButtonEditorViewFilters(JCheckBox checkBox, ArrayList\u003cFilter\u003e data)\n    {\n        super(checkBox);\n        this.data \u003d data;\n        button \u003d new JButton();\n        button.setOpaque(true);\n        button.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    @Override\n    public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column)\n    {\n        if (isSelected)\n        {\n            button.setForeground(table.getSelectionForeground());\n            button.setBackground(table.getSelectionBackground());\n        } else\n        {\n            button.setForeground(table.getForeground());\n            button.setBackground(table.getBackground());\n        }\n        label \u003d (value \u003d\u003d null) ? \"\" : value.toString();\n        button.setText(label);\n        isPushed \u003d true;\n        this.row \u003d row;\n        return button;\n    }\n\n\n    @Override\n    public Object getCellEditorValue()\n    {\n        if (isPushed)\n        {\n            ViewFilter frame \u003d new ViewFilter(data.get(row));\n            frame.open();\n        }\n        isPushed \u003d false;\n        return label;\n    }\n\n    @Override\n    public boolean stopCellEditing()\n    {\n        isPushed \u003d false;\n        return super.stopCellEditing();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonEditorViewFilters.java"},{"fileName":"ButtonRenderer.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport javax.swing.*;\nimport javax.swing.table.TableCellRenderer;\nimport java.awt.*;\n\npublic class ButtonRenderer extends JButton implements TableCellRenderer\n{\n\n    public ButtonRenderer()\n    {\n        setOpaque(true);\n    }\n\n    @Override\n    public Component getTableCellRendererComponent(JTable table, Object value,\n                                                   boolean isSelected, boolean hasFocus, int row, int column)\n    {\n        if (isSelected)\n        {\n            setForeground(table.getSelectionForeground());\n            setBackground(table.getSelectionBackground());\n        } else\n        {\n            setForeground(table.getForeground());\n        }\n        setText((value \u003d\u003d null) ? \"\" : value.toString());\n        return this;\n    }\n}\n\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\ButtonRenderer.java"},{"fileName":"NonEditableCell.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport javax.swing.*;\nimport java.util.EventObject;\n\npublic class NonEditableCell extends DefaultCellEditor\n{\n    public NonEditableCell(JTextField textField)\n    {\n        super(textField);\n        textField.addActionListener(e -\u003e fireEditingStopped());\n    }\n\n    protected void fireEditingStopped()\n    {\n        super.fireEditingStopped();\n    }\n\n    @Override\n    public boolean isCellEditable(EventObject anEvent)\n    {\n        return false;\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\NonEditableCell.java"},{"fileName":"StripedTableRowCellRenderer.java","content":"package com.advancedraidtracker.ui.buttons;\n\nimport javax.swing.*;\nimport javax.swing.table.DefaultTableCellRenderer;\nimport java.awt.*;\n\npublic class StripedTableRowCellRenderer extends DefaultTableCellRenderer\n{\n    @Override\n    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)\n    {\n        Component cell \u003d new DefaultTableCellRenderer().getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n        if(row % 2 \u003d\u003d 0 \u0026\u0026 !isSelected)\n        {\n            cell.setBackground(new Color(20, 20, 20));\n        }\n        return cell;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\buttons\\StripedTableRowCellRenderer.java"},{"fileName":"ChartFrame.java","content":"package com.advancedraidtracker.ui.charts;\n\nimport com.advancedraidtracker.AdvancedTOBData;\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport javax.swing.Timer;\nimport java.awt.*;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.util.*;\n\n@Slf4j\npublic class ChartFrame extends BaseFrame\n{\n    private int frameX \u003d this.getWidth();\n    private int frameY \u003d this.getHeight();\n    public ChartFrame(ArrayList\u003cSimpleTOBData\u003e roomData, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        JTabbedPane basepane \u003d new JTabbedPane();\n\n        JPanel maidenTab \u003d new JPanel();\n        JPanel bloatTab \u003d new JPanel();\n        JPanel nyloTab \u003d new JPanel();\n        JPanel soteTab \u003d new JPanel();\n        JPanel xarpTab \u003d new JPanel();\n        JPanel verzP1Tab \u003d new JPanel();\n        JPanel verzP2Tab \u003d new JPanel();\n        JPanel verzP3Tab \u003d new JPanel();\n\n        maidenTab.setLayout(new GridLayout(1, 2));\n        bloatTab.setLayout(new GridLayout(1, 2));\n        nyloTab.setLayout(new GridLayout(1, 2));\n        soteTab.setLayout(new GridLayout(1, 2));\n        xarpTab.setLayout(new GridLayout(1, 2));\n        verzP1Tab.setLayout(new GridLayout(1, 2));\n        verzP2Tab.setLayout(new GridLayout(1, 2));\n        verzP3Tab.setLayout(new GridLayout(1, 2));\n\n        JPanel maidenCharts \u003d new JPanel();\n        JPanel bloatCharts \u003d new JPanel();\n        JPanel nyloCharts \u003d new JPanel();\n        JPanel soteCharts \u003d new JPanel();\n        JPanel xarpCharts \u003d new JPanel();\n        JPanel verzp1Charts \u003d new JPanel();\n        JPanel verzp2Charts \u003d new JPanel();\n        JPanel verzp3Charts \u003d new JPanel();\n\n        maidenCharts.setLayout(new BoxLayout(maidenCharts, BoxLayout.Y_AXIS));\n        bloatCharts.setLayout(new BoxLayout(bloatCharts, BoxLayout.Y_AXIS));\n        nyloCharts.setLayout(new BoxLayout(nyloCharts, BoxLayout.Y_AXIS));\n        soteCharts.setLayout(new BoxLayout(soteCharts, BoxLayout.Y_AXIS));\n        xarpCharts.setLayout(new BoxLayout(xarpCharts, BoxLayout.Y_AXIS));\n        verzp1Charts.setLayout(new BoxLayout(verzp1Charts, BoxLayout.Y_AXIS));\n        verzp2Charts.setLayout(new BoxLayout(verzp2Charts, BoxLayout.Y_AXIS));\n        verzp3Charts.setLayout(new BoxLayout(verzp3Charts, BoxLayout.Y_AXIS));\n\n\n\n        for (SimpleTOBData data : roomData)\n        {\n            AdvancedTOBData advancedData \u003d new AdvancedTOBData(AdvancedTOBData.getRaidStrings(data.filePath), itemManager);\n            Map\u003cInteger, String\u003e maidenLines \u003d new LinkedHashMap\u003c\u003e();\n            maidenLines.put(data.getValue(DataPoint.MAIDEN_70_SPLIT), \"70s\");\n            maidenLines.put(data.getValue(DataPoint.MAIDEN_50_SPLIT), \"50s\");\n            maidenLines.put(data.getValue(DataPoint.MAIDEN_30_SPLIT), \"30s\");\n            maidenLines.put(data.getValue(DataPoint.MAIDEN_TOTAL_TIME), \"Dead\");\n\n            Map\u003cInteger, String\u003e bloatLines \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer i : data.bloatDowns)\n            {\n                bloatLines.put(i, \"Down\");\n                bloatLines.put(i + 33, \"Moving\");\n            }\n\n            Map\u003cInteger, String\u003e nyloLines \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer i : data.nyloWaveStalled)\n            {\n                nyloLines.put(i, \"Stall\");\n            }\n            nyloLines.put(data.getValue(DataPoint.NYLO_LAST_WAVE), \"Last Wave\");\n            nyloLines.put(data.getValue(DataPoint.NYLO_BOSS_SPAWN), \"Boss Spawn\");\n            for (int i \u003d data.getValue(DataPoint.NYLO_BOSS_SPAWN) + 11; i \u003c data.getNyloTime(); i +\u003d 10)\n            {\n                nyloLines.put(i, \"Phase\");\n            }\n\n            for (Integer i : data.waveSpawns.keySet())\n            {\n                nyloLines.put(data.waveSpawns.get(i), \"W\" + i);\n            }\n\n            Map\u003cInteger, String\u003e soteLines \u003d new LinkedHashMap\u003c\u003e();\n            soteLines.put(data.getValue(DataPoint.SOTE_P1_SPLIT), \"Maze1 Start\");\n            soteLines.put(data.getValue(DataPoint.SOTE_M1_SPLIT), \"Maze1 End\");\n\n            soteLines.put(data.getValue(DataPoint.SOTE_P2_SPLIT), \"Maze2 Start\");\n            soteLines.put(data.getValue(DataPoint.SOTE_M2_SPLIT), \"Maze2 End\");\n\n\n            Map\u003cInteger, String\u003e xarpLines \u003d new LinkedHashMap\u003c\u003e();\n            xarpLines.put(data.getValue(DataPoint.XARP_SCREECH), \"SCREECH\");\n            for (int i \u003d data.getValue(DataPoint.XARP_SCREECH) + 8; i \u003c data.getXarpTime(); i +\u003d 8)\n            {\n                xarpLines.put(i, \"Turn\");\n            }\n\n            Map\u003cInteger, String\u003e verzikP2Lines \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer i : data.redsProc)\n            {\n                verzikP2Lines.put(i, \"Reds\");\n                verzikP2Lines.put(i + 10, \"Shield End\");\n            }\n\n            for (Integer i : data.p2Crabs)\n            {\n                verzikP2Lines.put(i, \"Crabs\");\n            }\n\n            Map\u003cInteger, String\u003e verzikP3Lines \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer i : data.websStart)\n            {\n                if (i % 2 \u003d\u003d 0)\n                    verzikP3Lines.put(i, \"Webs\");\n            }\n\n            for (Integer i : data.p3Crabs)\n            {\n                verzikP3Lines.put(i, \"Crabs\");\n            }\n\n            Map\u003cInteger, String\u003e dawnDropsMap \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer i : data.dawnDrops)\n            {\n                dawnDropsMap.put(i, \"X\");\n            }\n            ArrayList\u003cInteger\u003e p2autos \u003d new ArrayList\u003c\u003e();\n            int lastreset \u003d data.getValue(DataPoint.VERZIK_P1_SPLIT) + 11;\n            for (int i \u003d lastreset; i \u003c data.getValue(DataPoint.VERZIK_P2_SPLIT); i++)\n            {\n                boolean wasNextTick \u003d false;\n                for (Integer j : data.redsProc)\n                {\n                    if (i \u003d\u003d j)\n                    {\n                        lastreset \u003d i + 11;\n                    } else if (i \u003d\u003d (j - 5) || i \u003d\u003d (j - 1))\n                    {\n                        wasNextTick \u003d true;\n                    }\n                }\n                if ((i - lastreset) % 4 \u003d\u003d 0 \u0026\u0026 i \u003e\u003d lastreset \u0026\u0026 !wasNextTick)\n                {\n                    p2autos.add(i);\n                }\n            }\n            int maidenTime \u003d data.getMaidenTime();\n            int bloatTime \u003d data.getBloatTime();\n            int nyloTime \u003d data.getNyloTime();\n            int soteTime \u003d data.getSoteTime();\n            int xarpTime \u003d data.getXarpTime();\n            int verzP1Time \u003d data.getValue(DataPoint.VERZIK_P1_SPLIT);\n            int verzP2Start \u003d data.getValue(DataPoint.VERZIK_P1_SPLIT) + 1;\n            int verzP2Time \u003d data.getValue(DataPoint.VERZIK_P2_SPLIT);\n            int verzP3Start \u003d verzP2Time + 1;\n            int verzP3Time \u003d data.getVerzikTime();\n\n\n            ArrayList\u003cInteger\u003e p1autos \u003d new ArrayList\u003c\u003e();\n            for (int i \u003d 19; i \u003c verzP1Time; i++)\n            {\n                if (i \u003d\u003d 19 || (i - 19) % 14 \u003d\u003d 0)\n                {\n                    p1autos.add(i);\n                }\n            }\n\n            ChartPanel maidenRCP \u003d new ChartPanel(\"Maiden\", false, config, clientThread, configManager);\n            maidenRCP.setNPCMappings(advancedData.maidenNPCMapping);\n            maidenRCP.setRoomHP(advancedData.maidenHP);\n            maidenRCP.addAttacks(advancedData.maidenAttacks);\n            maidenRCP.addMaidenCrabs(data.maidenCrabSpawn);\n            maidenRCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                maidenRCP.enableWrap();\n            }\n            maidenRCP.setStartTick(1);\n            maidenRCP.setTick(maidenTime);\n            maidenRCP.addLines(maidenLines);\n            maidenRCP.addThrallBoxes(data.maidenThrallSpawns);\n\n            ChartPanel bloatRCP \u003d new ChartPanel(\"Bloat\", false, config, clientThread, configManager);\n            bloatRCP.setRoomHP(advancedData.bloatHP);\n            bloatRCP.addAttacks(advancedData.bloatAttacks);\n            bloatRCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                bloatRCP.enableWrap();\n            }\n            bloatRCP.setStartTick(1);\n            bloatRCP.setTick(bloatTime);\n            bloatRCP.addLines(bloatLines);\n            bloatRCP.addThrallBoxes(data.bloatThrallSpawns);\n\n            ChartPanel nyloRCP \u003d new ChartPanel(\"Nylocas\", false, config, clientThread, configManager);\n            nyloRCP.setNPCMappings(advancedData.nyloNPCMapping);\n            nyloRCP.setRoomHP(advancedData.nyloHP);\n            nyloRCP.addAttacks(advancedData.nyloAttacks);\n            nyloRCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                nyloRCP.enableWrap();\n            }\n            nyloRCP.setStartTick(1);\n            nyloRCP.setTick(nyloTime);\n            nyloRCP.addLines(nyloLines);\n            nyloRCP.addThrallBoxes(data.nyloThrallSpawns);\n\n            ChartPanel soteRCP \u003d new ChartPanel(\"Sotetseg\", false, config, clientThread, configManager);\n            soteRCP.setRoomHP(advancedData.soteHP);\n            soteRCP.addAttacks(advancedData.soteAttacks);\n            soteRCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                soteRCP.enableWrap();\n            }\n            soteRCP.setStartTick(1);\n            soteRCP.setTick(soteTime);\n            soteRCP.addLines(soteLines);\n            soteRCP.addThrallBoxes(data.soteThrallSpawns);\n\n            ChartPanel xarpRCP \u003d new ChartPanel(\"Xarpus\", false, config, clientThread, configManager);\n            xarpRCP.setRoomHP(advancedData.xarpHP);\n            xarpRCP.addAttacks(advancedData.xarpAttacks);\n            xarpRCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                xarpRCP.enableWrap();\n            }\n            xarpRCP.setStartTick(1);\n            xarpRCP.setTick(xarpTime);\n            xarpRCP.addLines(xarpLines);\n            xarpRCP.addThrallBoxes(data.xarpusThrallSpawns);\n\n            ChartPanel verzP1RCP \u003d new ChartPanel(\"Verzik P1\", false, config, clientThread, configManager);\n            verzP1RCP.setNPCMappings(advancedData.verzikNPCMapping);\n            verzP1RCP.setRoomHP(advancedData.verzikHP);\n            verzP1RCP.addAttacks(advancedData.verzikAttacks);\n            verzP1RCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                verzP1RCP.enableWrap();\n            }\n            verzP1RCP.setStartTick(1);\n            verzP1RCP.setTick(verzP1Time);\n            verzP1RCP.addRoomSpecificDatum(dawnDropsMap);\n            verzP1RCP.addThrallBoxes(data.verzikThrallSpawns);\n            verzP1RCP.setRoomSpecificText(\"Dawn Appears\");\n            verzP1RCP.addAutos(p1autos);\n\n            ChartPanel verzP2RCP \u003d new ChartPanel(\"Verzik P2\", false, config, clientThread, configManager);\n            verzP2RCP.setNPCMappings(advancedData.verzikNPCMapping);\n            verzP2RCP.setRoomHP(advancedData.verzikHP);\n            verzP2RCP.addAttacks(advancedData.verzikAttacks);\n            verzP2RCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                verzP2RCP.enableWrap();\n            }\n            verzP2RCP.setStartTick(verzP2Start);\n            verzP2RCP.setTick(verzP2Time);\n            verzP2RCP.addLines(verzikP2Lines);\n            verzP2RCP.addThrallBoxes(data.verzikThrallSpawns);\n\n            ChartPanel verzP3RCP \u003d new ChartPanel(\"Verzik P3\", false, config, clientThread, configManager);\n            verzP3RCP.setNPCMappings(advancedData.verzikNPCMapping);\n            verzP3RCP.setRoomHP(advancedData.verzikHP);\n\n            verzP3RCP.addAttacks(advancedData.verzikAttacks);\n            verzP3RCP.setPlayers(new ArrayList\u003c\u003e(data.players.keySet()));\n            if (roomData.size() \u003d\u003d 1)\n            {\n                verzP3RCP.enableWrap();\n            }\n            verzP3RCP.setStartTick(verzP3Start);\n            verzP3RCP.setTick(verzP3Time);\n            verzP3RCP.addLines(verzikP3Lines);\n            verzP3RCP.addThrallBoxes(data.verzikThrallSpawns);\n            verzP2RCP.addAutos(p2autos);\n            verzP1RCP.addDawnSpecs(data.dawnSpecs);\n\n            maidenRCP.redraw();\n            bloatRCP.redraw();\n            nyloRCP.redraw();\n            soteRCP.redraw();\n            xarpRCP.redraw();\n            verzP1RCP.redraw();\n            verzP2RCP.redraw();\n            verzP3RCP.redraw();\n\n\t\t\taddWindowListener(new WindowAdapter()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void windowClosing(WindowEvent e)\n\t\t\t\t{\n\t\t\t\t\tsuper.windowClosing(e);\n\t\t\t\t\tmaidenRCP.release();\n\t\t\t\t\tbloatRCP.release();\n\t\t\t\t\tnyloRCP.release();\n\t\t\t\t\tsoteRCP.release();\n\t\t\t\t\txarpRCP.release();\n\t\t\t\t\tverzP1RCP.release();\n\t\t\t\t\tverzP2RCP.release();\n\t\t\t\t\tverzP3RCP.release();\n\t\t\t\t}\n\t\t\t});\n\n            Timer resizeTimer \u003d new Timer(20, e -\u003e\n            {\n                maidenRCP.setSize(frameX, frameY);\n                bloatRCP.setSize(frameX, frameY);\n                nyloRCP.setSize(frameX, frameY);\n                soteRCP.setSize(frameX, frameY);\n                xarpRCP.setSize(frameX, frameY);\n                verzP1RCP.setSize(frameX, frameY);\n                verzP2RCP.setSize(frameX, frameY);\n                verzP3RCP.setSize(frameX, frameY);\n            });\n\n            resizeTimer.setRepeats(false);\n\n            addComponentListener(new ComponentAdapter()\n            {\n                @Override\n                public void componentResized(ComponentEvent e)\n                {\n                    super.componentResized(e);\n                    if(resizeTimer.isRunning())\n                    {\n                        resizeTimer.restart();\n                    }\n                    else\n                    {\n                        resizeTimer.start();\n                    }\n                    Component c \u003d (Component) e.getSource();\n                    frameX \u003d c.getWidth();\n                    frameY \u003d c.getHeight();\n                }\n            });\n\n            basepane.addChangeListener(cl-\u003e\n            {\n                maidenRCP.redraw();\n                bloatRCP.redraw();\n                nyloRCP.redraw();\n                soteRCP.redraw();\n                xarpRCP.redraw();\n                verzP1RCP.redraw();\n                verzP2RCP.redraw();\n                verzP3RCP.redraw();\n            });\n\n\n            maidenCharts.add(maidenRCP);\n            bloatCharts.add(bloatRCP);\n            nyloCharts.add(nyloRCP);\n            soteCharts.add(soteRCP);\n            xarpCharts.add(xarpRCP);\n            verzp1Charts.add(verzP1RCP);\n            verzp2Charts.add(verzP2RCP);\n            verzp3Charts.add(verzP3RCP);\n\n\n\n        }\n\n        maidenTab.add(new JScrollPane(maidenCharts));\n        bloatTab.add(new JScrollPane(bloatCharts));\n        nyloTab.add(new JScrollPane(nyloCharts));\n        soteTab.add(new JScrollPane(soteCharts));\n        xarpTab.add(new JScrollPane(xarpCharts));\n        verzP1Tab.add(new JScrollPane(verzp1Charts));\n        verzP2Tab.add(new JScrollPane(verzp2Charts));\n        verzP3Tab.add(new JScrollPane(verzp3Charts));\n\n        basepane.addTab(\"Maiden\", maidenTab);\n        basepane.addTab(\"Bloat\", bloatTab);\n        basepane.addTab(\"Nylocas\", nyloTab);\n        basepane.addTab(\"Sotetseg\", soteTab);\n        basepane.addTab(\"Xarpus\", xarpTab);\n        basepane.addTab(\"Verzik P1\", verzP1Tab);\n        basepane.addTab(\"Verzik P2\", verzP2Tab);\n        basepane.addTab(\"Verzik P3\", verzP3Tab);\n\n        add(basepane);\n        pack();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\charts\\ChartFrame.java"},{"fileName":"ChartPanel.java","content":"package com.advancedraidtracker.ui.charts;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.constants.TobIDs;\nimport com.advancedraidtracker.utility.*;\nimport com.advancedraidtracker.utility.Point;\nimport com.advancedraidtracker.utility.weapons.WeaponAttack;\nimport com.advancedraidtracker.utility.weapons.WeaponDecider;\nimport com.advancedraidtracker.utility.wrappers.*;\nimport lombok.Setter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.ui.FontManager;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.GlyphVector;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.AffineTransformOp;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n@Slf4j\npublic class ChartPanel extends JPanel implements MouseListener, MouseMotionListener, MouseWheelListener\n{\n    private final int TITLE_BAR_PLUS_TAB_HEIGHT \u003d 63; //todo figure this out dynamically in the future\n    private boolean shouldWrap;\n    private BufferedImage img;\n    int scale;\n    int boxCount;\n    int boxHeight;\n    int boxWidth;\n    private int windowHeight \u003d 600;\n\n    int selectedTick \u003d -1;\n    String selectedPlayer \u003d \"\";\n\n    int selectedRow \u003d -1;\n    boolean checkBoxHovered \u003d false;\n\n    int startTick;\n    public int endTick;\n    @Setter\n    ArrayList\u003cString\u003e players \u003d new ArrayList\u003c\u003e();\n    String room;\n    @Setter\n    String roomSpecificText \u003d \"\";\n    private int fontHeight;\n    public boolean finished \u003d false;\n    private final boolean live;\n    private final ArrayList\u003cInteger\u003e autos \u003d new ArrayList\u003c\u003e();\n    private Map\u003cInteger, String\u003e NPCMap \u003d new HashMap\u003c\u003e();\n    private final ArrayList\u003cDawnSpec\u003e dawnSpecs \u003d new ArrayList\u003c\u003e();\n    private final ArrayList\u003cThrallOutlineBox\u003e thrallOutlineBoxes \u003d new ArrayList\u003c\u003e();\n    private final ArrayList\u003cOutlineBox\u003e outlineBoxes \u003d new ArrayList\u003c\u003e();\n    private final Map\u003cInteger, String\u003e specific \u003d new HashMap\u003c\u003e();\n    private final Map\u003cInteger, String\u003e lines \u003d new HashMap\u003c\u003e();\n    private final ArrayList\u003cString\u003e crabDescriptions \u003d new ArrayList\u003c\u003e();\n\n    @Setter\n    private Map\u003cInteger, Integer\u003e roomHP \u003d new HashMap\u003c\u003e();\n    Map\u003cString, Integer\u003e playerOffsets \u003d new LinkedHashMap\u003c\u003e();\n    private final Map\u003cPlayerDidAttack, String\u003e actions \u003d new HashMap\u003c\u003e();\n\n    private final ConfigManager configManager;\n    private boolean isActive \u003d false;\n\n    public void setActive(Boolean state)\n    {\n        isActive \u003d state;\n    }\n\n    public boolean shouldDraw()\n    {\n        return !live || isActive;\n    }\n\n    public void enableWrap()\n    {\n        shouldWrap \u003d true;\n        recalculateSize();\n    }\n    private int boxesToShow \u003d 1;\n\n    public void setSize(int x, int y)\n    {\n        windowHeight \u003d y;\n        if(isActive || !live)\n        {\n            boxesToShow \u003d Math.min(1+((y-TITLE_BAR_PLUS_TAB_HEIGHT-scale)/boxHeight), boxCount);\n            if (img !\u003d null)\n            {\n                img.flush();\n            }\n            img \u003d new BufferedImage(x, y, BufferedImage.TYPE_INT_ARGB);\n            recalculateSize();\n        }\n    }\n\n\tpublic void release()\n\t{\n\t\tresetGraph();\n\t\timg \u003d null;\n\t\tremoveMouseListener(this);\n\t\tremoveMouseWheelListener(this);\n\t\tremoveMouseMotionListener(this);\n\t}\n\n    private final AdvancedRaidTrackerConfig config;\n\n    public void addRoomSpecificData(int tick, String data)\n    {\n        specific.put(tick, data);\n    }\n\n    public void addRoomSpecificDatum(Map\u003cInteger, String\u003e specificData)\n    {\n        specific.putAll(specificData);\n    }\n\n    public void addLine(int tick, String lineInfo)\n    {\n        lines.put(tick, lineInfo);\n    }\n\n    public void addLines(Map\u003cInteger, String\u003e lineData)\n    {\n        lines.putAll(lineData);\n    }\n\n    public void addRoomHP(int tick, int hp)\n    {\n        roomHP.put(tick, hp);\n    }\n\n    public void addAutos(ArrayList\u003cInteger\u003e autos)\n    {\n        this.autos.addAll(autos);\n    }\n\n    public void addThrallBox(ThrallOutlineBox thrallOutlineBox)\n    {\n        thrallOutlineBoxes.add(thrallOutlineBox);\n    }\n\n    public void addThrallBoxes(ArrayList\u003cThrallOutlineBox\u003e outlineBoxes)\n    {\n        thrallOutlineBoxes.addAll(outlineBoxes);\n    }\n\n    public void addDawnSpec(DawnSpec dawnSpec)\n    {\n        this.dawnSpecs.add(dawnSpec);\n    }\n\n    public void addDawnSpecs(ArrayList\u003cDawnSpec\u003e dawnSpecs)\n    {\n        this.dawnSpecs.addAll(dawnSpecs);\n        drawGraph();\n    }\n\n    public void setRoomFinished(int tick)\n    {\n        finished \u003d true;\n        if (tick - endTick \u003c 10)\n        {\n            endTick \u003d tick;\n        }\n        drawGraph();\n    }\n\n    public void resetGraph()\n    {\n        currentBox \u003d 0;\n        currentScrollOffset \u003d 0;\n        endTick \u003d 0;\n        startTick \u003d 0;\n        selectedRow \u003d -1;\n        selectedTick \u003d -1;\n        selectedPlayer \u003d \"\";\n        outlineBoxes.clear();\n        autos.clear();\n        lines.clear();\n        specific.clear();\n        dawnSpecs.clear();\n        thrallOutlineBoxes.clear();\n        players.clear();\n        playerOffsets.clear();\n        crabDescriptions.clear();\n        actions.clear();\n        roomHP.clear();\n        NPCMap.clear();\n        finished \u003d false;\n        recalculateSize();\n    }\n\n    public void addMaidenCrabs(ArrayList\u003cString\u003e crabDescriptions)\n    {\n        this.crabDescriptions.addAll(crabDescriptions);\n    }\n\n    public void addMaidenCrab(String description)\n    {\n        crabDescriptions.add(description);\n    }\n\n    public void addNPCMapping(int index, String name)\n    {\n        NPCMap.put(index, name);\n    }\n\n    public void setNPCMappings(Map\u003cInteger, String\u003e mapping)\n    {\n        this.NPCMap \u003d mapping;\n    }\n\n    public void redraw()\n    {\n        recalculateSize();\n    }\n\n    public void addAttack(PlayerDidAttack attack)\n    {\n        if(clientThread !\u003d null)\n        {\n            if(config.useUnkitted())\n            {\n                attack.useUnkitted();\n            }\n            clientThread.invoke(attack::setIcons);\n            clientThread.invoke(attack::setWornNames);\n        }\n        WeaponAttack weaponAttack \u003d WeaponDecider.getWeapon(attack.animation, attack.spotAnims, attack.projectile, attack.weapon);\n        if (weaponAttack !\u003d WeaponAttack.UNDECIDED)\n        {\n            boolean isTarget \u003d RoomUtil.isPrimaryBoss(attack.targetedID) \u0026\u0026 attack.targetedID !\u003d -1;\n            String targetString \u003d weaponAttack.name + \": \";\n            String targetName \u003d getBossName(attack.targetedID, attack.targetedIndex, attack.tick);\n            if (targetName.equals(\"?\"))\n            {\n                targetString +\u003d attack.targetName;\n            } else\n            {\n                targetString +\u003d targetName;\n            }\n            actions.put(attack, targetString);\n            String additionalText \u003d \"\";\n            if (targetString.contains(\"(on w\"))\n            {\n                additionalText \u003d targetString.substring(targetString.indexOf(\"(on w\") + 5);\n                additionalText \u003d \"s\" + additionalText.substring(0, additionalText.indexOf(\")\"));\n            } else if (targetString.contains(\"small\") || targetString.contains(\"big\"))\n            {\n                additionalText \u003d getShortenedString(targetString, weaponAttack.name.length());\n            } else if (targetString.contains(\"70s\") || targetString.contains(\"50s\") || targetString.contains(\"30s\"))\n            {\n                String shortenedString \u003d targetString.substring(weaponAttack.name.length()+2);\n                shortenedString \u003d shortenedString.substring(0, 2);\n                String proc \u003d targetString.substring(targetString.indexOf(\"0s\") - 1, targetString.indexOf(\"0s\") + 1);\n\n                additionalText \u003d proc + shortenedString;\n            }\n            outlineBoxes.add(new OutlineBox(attack, weaponAttack.shorthand, weaponAttack.color, isTarget, additionalText, weaponAttack));\n        }\n    }\n\n    private static String getShortenedString(String targetString, int index)\n    {\n        String shortenedString \u003d targetString.substring(index+3);\n        shortenedString \u003d shortenedString.substring(0, shortenedString.indexOf(\" \"));\n        if (targetString.contains(\"east small\"))\n        {\n            shortenedString +\u003d \"e\";\n        } else if (targetString.contains(\"south small\"))\n        {\n            shortenedString +\u003d \"s\";\n        } else if (targetString.contains(\"west small\"))\n        {\n            shortenedString +\u003d \"w\";\n        } else if (targetString.contains(\"east big\"))\n        {\n            shortenedString +\u003d \"E\";\n        } else if (targetString.contains(\"south big\"))\n        {\n            shortenedString +\u003d \"S\";\n        } else if (targetString.contains(\"west big\"))\n        {\n            shortenedString +\u003d \"W\";\n        }\n        return shortenedString;\n    }\n\n    public void addLiveAttack(PlayerDidAttack attack)\n    {\n        attack.tick +\u003d endTick;\n        addAttack(new PlayerDidAttack(attack.itemManager, attack.player, attack.animation, attack.tick, attack.weapon, attack.projectile, attack.spotAnims, attack.targetedIndex, attack.targetedID, attack.targetName, attack.wornItems));\n    }\n\n    public void addAttacks(ArrayList\u003cPlayerDidAttack\u003e attacks)\n    {\n        for (PlayerDidAttack attack : attacks)\n        {\n            addAttack(attack);\n        }\n    }\n\n    public void incrementTick()\n    {\n        endTick++;\n        if (endTick % 50 \u003d\u003d 0 || endTick \u003d\u003d 1)\n        {\n            recalculateSize();\n        } else\n        {\n            drawGraph();\n        }\n    }\n\n    public void setTick(int tick)\n    {\n        endTick \u003d tick;\n        recalculateSize();\n    }\n\n    public void setStartTick(int tick)\n    {\n        startTick \u003d tick;\n        recalculateSize();\n    }\n\n    public void recalculateSize()\n    {\n        if(!shouldDraw())\n        {\n            return;\n        }\n        try\n        {\n            scale \u003d config.chartScaleSize();\n            setBackground(config.primaryDark());\n        } catch (Exception ignored)\n        {\n\n        }\n        int length \u003d endTick - startTick;\n        boxCount \u003d (length / 50);\n        if (boxCount % 50 !\u003d 0)\n        {\n            boxCount++;\n        }\n        if (boxCount \u003c 1)\n        {\n            boxCount \u003d 1;\n        }\n        boxHeight \u003d ((players.size() + 3) * scale);\n        boxWidth \u003d (100 + (scale * 51));\n\n        boxesToShow \u003d Math.min(1+((windowHeight-TITLE_BAR_PLUS_TAB_HEIGHT-scale)/boxHeight), boxCount);\n\n        drawGraph();\n\n    }\n\n    public void sendToBottom()\n    {\n        recalculateSize();\n        if(TITLE_BAR_PLUS_TAB_HEIGHT+scale+boxCount*boxHeight \u003e img.getHeight())\n        {\n            currentBox \u003d boxCount - 1 - boxesToShow + 1;\n            int lastBoxEnd \u003d (boxesToShow * boxHeight) + scale + TITLE_BAR_PLUS_TAB_HEIGHT;\n            currentScrollOffset \u003d (currentBox * boxHeight) + (lastBoxEnd - img.getHeight());\n        }\n    }\n\n    private final ClientThread clientThread;\n    public ChartPanel(String room, boolean isLive, AdvancedRaidTrackerConfig config, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        this.config \u003d config;\n        this.clientThread \u003d clientThread;\n        scale \u003d 26;\n        live \u003d isLive;\n        this.room \u003d room;\n        startTick \u003d 0;\n        endTick \u003d 0;\n        shouldWrap \u003d true;\n        boxWidth \u003d 100 + scale * 51;\n        img \u003d new BufferedImage(boxWidth + 10, 600, BufferedImage.TYPE_INT_ARGB);\n        recalculateSize();\n        addMouseListener(this);\n        addMouseMotionListener(this);\n        addMouseWheelListener(this);\n    }\n\n    @Override\n    protected void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n        if (img !\u003d null)\n        {\n            g.drawImage(img, 0, 0, null);\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize()\n    {\n        return new Dimension(img.getWidth(), img.getHeight());\n    }\n\n    private Rectangle getStringBounds(Graphics2D g2, String str)\n    {\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        GlyphVector gv \u003d g2.getFont().createGlyphVector(frc, str);\n        return gv.getPixelBounds(null, (float) 0, (float) 0);\n    }\n\n    private int getStringWidth(Graphics2D g, String str)\n    {\n        FontRenderContext frc \u003d g.getFontRenderContext();\n        GlyphVector gv \u003d g.getFont().createGlyphVector(frc, str);\n        return gv.getPixelBounds(null, 0, 0).width;\n    }\n\n    int getYOffset(int tick)\n    {\n        return ((((tick - startTick) / 50) * boxHeight) + 20)-(currentScrollOffset);\n    }\n\n    int getXOffset(int tick)\n    {\n        return (shouldWrap) ? ((tick - startTick) % 50) * scale : tick * scale;\n    }\n\n    private void drawTicks(Graphics2D g)\n    {\n        for (int i \u003d startTick; i \u003c endTick; i++)\n        {\n            if(shouldTickBeDrawn(i))\n            {\n                int xOffset \u003d getXOffset(i);\n                int yOffset \u003d getYOffset(i);\n                yOffset +\u003d scale;\n                g.setColor(Color.DARK_GRAY);\n                g.setColor(new Color(220, 220, 220));\n                Font oldFont \u003d g.getFont();\n                g.setFont(oldFont.deriveFont(10.0f));\n                int strWidth \u003d getStringBounds(g, String.valueOf(i)).width;\n                g.drawString(String.valueOf(i), 100 + xOffset + (scale / 2) - (strWidth / 2), yOffset + (fontHeight / 2));\n                g.setFont(oldFont);\n            }\n        }\n    }\n\n    private void drawAutos(Graphics2D g)\n    {\n        for (Integer i : autos)\n        {\n            if(shouldTickBeDrawn(i))\n            {\n                g.setColor(new Color(255, 80, 80, 60));\n                int xOffset \u003d getXOffset(i);\n                int yOffset \u003d getYOffset(i);\n                g.fillRoundRect(xOffset + 100, yOffset + 10, scale, boxHeight - scale, 7, 7);\n            }\n        }\n    }\n\n    private void drawGraphBoxes(Graphics2D g)\n    {\n        for (int i \u003d 0; i \u003c boxesToShow; i++)\n        {\n            int startX \u003d 100;\n            int startY \u003d boxHeight * i + 30 - (currentScrollOffset-(currentBox*boxHeight));\n            int endX \u003d boxWidth - scale;\n            int endY \u003d startY + boxHeight;\n            g.setColor(new Color(100, 100, 100));\n\n            if(startY \u003e 5)\n            {\n                g.drawLine(startX, startY + scale, endX, startY + scale);\n            }\n            g.drawLine(startX, (startY \u003e 5) ? startY + scale : scale+5, startX, endY - scale);\n            if(endY-scale \u003e 5 + scale)\n            {\n                g.drawLine(startX, endY - scale, endX, endY - scale);\n            }\n            g.drawLine(endX, endY - scale, endX, (startY \u003e 5) ? startY + scale : scale+5);\n        }\n    }\n\n    public static BufferedImage getScaledImage(BufferedImage image, int width, int height)\n    {\n        int imageWidth  \u003d image.getWidth();\n        int imageHeight \u003d image.getHeight();\n\n        double scaleX \u003d (double)width/imageWidth;\n        double scaleY \u003d (double)height/imageHeight;\n        AffineTransform scaleTransform \u003d AffineTransform.getScaleInstance(scaleX, scaleY);\n        AffineTransformOp bilinearScaleOp \u003d new AffineTransformOp(scaleTransform, AffineTransformOp.TYPE_BILINEAR);\n\n        return bilinearScaleOp.filter(\n                image,\n                new BufferedImage(width, height, image.getType()));\n    }\n\n    private void drawYChartColumn(Graphics2D g)\n    {\n        g.setColor(Color.WHITE);\n        for (int i \u003d 0; i \u003c players.size(); i++)\n        {\n            playerOffsets.put(players.get(i), i);\n            for (int j \u003d currentBox; j \u003c boxesToShow+currentBox; j++)\n            {\n                g.setColor(Color.DARK_GRAY);\n                g.setColor(config.primaryLight());\n                int nameRectsY \u003d (j*boxHeight)+((i+2)*scale)+10-3-currentScrollOffset;\n                if(nameRectsY \u003e scale + 5)\n                {\n                    g.fillRoundRect(5, nameRectsY, 90, scale - 6, 10, 10);\n                }\n                g.setColor(Color.WHITE);\n                Font oldFont \u003d g.getFont();\n                g.setFont(FontManager.getRunescapeBoldFont());\n                int width \u003d getStringWidth(g, players.get(i));\n                int margin \u003d 5;\n                int subBoxWidth \u003d 90;\n                int textPosition \u003d margin + (subBoxWidth-width)/2;\n                int yPosition \u003d ((j * boxHeight) + ((i + 2) * scale) + (fontHeight) / 2) + (scale/2) + 8-(currentScrollOffset);\n                if(yPosition \u003e scale+5)\n                {\n                    g.drawString(players.get(i), textPosition, yPosition);\n                }\n\n                if (i \u003d\u003d 0)\n                {\n                    int textYPosition \u003d j * boxHeight + ((players.size() + 2) * scale) + (fontHeight / 2) + 20 - currentScrollOffset;\n                    if(textYPosition \u003e scale + 5)\n                    {\n                        g.drawString(roomSpecificText, 5, textYPosition);\n                    }\n                }\n                g.setFont(oldFont);\n            }\n        }\n\n    }\n\n    private void drawRoomSpecificData(Graphics2D g)\n    {\n        for (Integer i : specific.keySet())\n        {\n            int xOffset \u003d getXOffset(i);\n            int yOffset \u003d getYOffset(i);\n            xOffset +\u003d 100;\n            yOffset +\u003d (playerOffsets.size() + 2) * scale - 10 - currentScrollOffset;\n            g.setColor(Color.WHITE);\n            int strWidth \u003d getStringBounds(g, \"X\").width;\n            if(yOffset \u003e scale + 5)\n            {\n                g.drawString(\"X\", xOffset + (scale / 2) - (strWidth / 2), yOffset + (fontHeight / 2) + 10);\n            }\n        }\n    }\n\n    private void drawDawnSpecs(Graphics2D g)\n    {\n        for (DawnSpec dawnSpec : dawnSpecs)\n        {\n            String damage \u003d String.valueOf(dawnSpec.getDamage());\n            if (dawnSpec.getDamage() !\u003d -1)\n            {\n                int xOffset \u003d (shouldWrap) ? ((dawnSpec.tick - startTick - 2) % 50) * scale : (dawnSpec.tick + 2) * scale;\n                int yOffset \u003d getYOffset(dawnSpec.tick);\n                xOffset +\u003d 100;\n                yOffset +\u003d (playerOffsets.size() + 3) * scale - 10;\n                g.setColor(Color.WHITE);\n                int textOffset \u003d (scale / 2) - (getStringBounds(g, damage).width) / 2;\n                if(yOffset \u003e scale + 5)\n                {\n                    g.drawString(damage, xOffset + textOffset, yOffset + (fontHeight / 2) + 10);\n                }\n            }\n        }\n    }\n\n    public static BufferedImage createDropShadow(BufferedImage image)\n    {\n        BufferedImage shadow \u003d new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_INT_ARGB);\n\n        Graphics2D g2 \u003d shadow.createGraphics();\n        g2.drawImage(image, 0, 0, null);\n\n        g2.setComposite(AlphaComposite.SrcIn);\n        g2.setColor(new Color(0, 0, 0, 128));\n        g2.fillRect(0, 0, shadow.getWidth(), shadow.getHeight());\n\n        g2.dispose();\n        return shadow;\n    }\n\n    private void drawPrimaryBoxes(Graphics2D g)\n    {\n        for (OutlineBox box : outlineBoxes)\n        {\n            if (shouldTickBeDrawn(box.tick))\n            {\n                int xOffset \u003d 100 + ((shouldWrap) ? ((box.tick - startTick) % 50) * scale : box.tick * scale);\n                if(playerOffsets.get(box.player) \u003d\u003d null)\n                {\n                    continue;\n                }\n                int yOffset \u003d ((playerOffsets.get(box.player) + 1) * scale + 30) + (((shouldWrap) ? ((box.tick - startTick) / 50) * boxHeight : 30)-currentScrollOffset);\n                if(yOffset \u003e scale + 5)\n                {\n                    if (config !\u003d null \u0026\u0026 config.useIconsOnChart())\n                    {\n                        try\n                        {\n                            if (box.weaponAttack.attackTicks !\u003d -1)\n                            {\n                                int opacity \u003d config.iconBackgroundOpacity();\n                                opacity \u003d Math.min(255, opacity);\n                                opacity \u003d Math.max(0, opacity);\n                                g.setColor(new Color(box.color.getRed(), box.color.getGreen(), box.color.getBlue(), opacity));\n                                g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);\n                                BufferedImage scaled \u003d getScaledImage(box.attack.img, scale - 2, scale - 2);\n                                g.drawImage(createDropShadow(scaled), xOffset + 3, yOffset + 3, null);\n                                g.drawImage(scaled, xOffset + 2, yOffset + 1, null);\n                            }\n                        } catch (Exception ignored)\n                        {\n\n                        }\n                    } else\n                    {\n                        int opacity \u003d 100;\n                        if (config !\u003d null)\n                        {\n                            opacity \u003d config.letterBackgroundOpacity();\n                            opacity \u003d Math.min(255, opacity);\n                            opacity \u003d Math.max(0, opacity);\n                        }\n                        g.setColor(new Color(box.color.getRed(), box.color.getGreen(), box.color.getBlue(), opacity));\n                        g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);\n                        g.setColor((box.primaryTarget) ? Color.WHITE : new Color(0, 190, 255));\n                        int textOffset \u003d (scale / 2) - (getStringWidth(g, box.letter) / 2);\n                        int primaryOffset \u003d yOffset + (box.additionalText.isEmpty() ? (fontHeight / 2) : 0);\n                        g.drawString(box.letter, xOffset + textOffset - 1, primaryOffset + (scale / 2) + 1);\n                        if (!box.additionalText.isEmpty())\n                        {\n                            Font f \u003d g.getFont();\n                            g.setFont(f.deriveFont(10.0f));\n                            textOffset \u003d (scale / 2) - (getStringWidth(g, box.additionalText) / 2);\n                            g.setColor(Color.WHITE);\n                            g.drawString(box.additionalText, xOffset + textOffset, yOffset + scale - 3);\n                            g.setFont(f);\n                        }\n                    }\n                    box.createOutline();\n                    g.setColor(box.outlineColor);\n                    g.drawRoundRect(xOffset + 1, yOffset + 1, scale - 2, scale - 2, 5, 5);\n                }\n            }\n        }\n    }\n\n    private void drawMarkerLines(Graphics2D g)\n    {\n        if (!live || finished)\n        {\n            for (Integer i : lines.keySet())\n            {\n                if(shouldTickBeDrawn(i))\n                {\n                    int xOffset \u003d getXOffset(i);\n                    int yOffset \u003d getYOffset(i);\n                    xOffset +\u003d 100;\n                    yOffset +\u003d (scale / 2);\n                    g.setColor(new Color(255, 0, 0));\n                    g.drawLine(xOffset, Math.max(yOffset, scale + 5), xOffset, yOffset + boxHeight - 20);\n                    int stringLength \u003d getStringBounds(g, lines.get(i)).width;\n                    g.setColor(Color.WHITE);\n                    if(yOffset \u003e scale + 5 )\n                    {\n                    g.drawString(lines.get(i), xOffset - (stringLength / 2), yOffset - 1);\n                    }\n                }\n            }\n        }\n    }\n\n    private void drawThrallBoxes(Graphics2D g)\n    {\n        for (ThrallOutlineBox box : thrallOutlineBoxes)\n        {\n            g.setColor(new Color(box.getColor().getRed(), box.getColor().getGreen(), box.getColor().getBlue(), 30));\n\n            int maxTick \u003d getMaxTick(box);\n            int lastEndTick \u003d box.spawnTick;\n            while (lastEndTick \u003c maxTick \u0026\u0026 shouldTickBeDrawn(lastEndTick))\n            {\n                    int yOffset \u003d getYOffset(lastEndTick);\n                    try\n                    {\n                        yOffset +\u003d (playerOffsets.get(box.owner) + 1) * scale + 10;\n                    } catch (Exception e)\n                    {\n                        break;\n                    }\n                    int currentEndTick \u003d (shouldWrap) ? lastEndTick + (50 - (lastEndTick % 50) + (startTick % 50)) : maxTick;\n                    if (currentEndTick \u003e maxTick)\n                    {\n                        currentEndTick \u003d maxTick;\n                    }\n                    int xOffsetStart \u003d (shouldWrap) ? ((lastEndTick - startTick) % 50) * scale : (lastEndTick - 1) * scale;\n                    xOffsetStart +\u003d 100;\n                    int xOffsetEnd \u003d (shouldWrap) ? ((currentEndTick - startTick - 1) % 50) * scale : (currentEndTick - 1) * scale;\n                    xOffsetEnd +\u003d 100;\n                    lastEndTick \u003d currentEndTick;\n                    if(yOffset \u003e scale + 5)\n                    {\n                        g.fillRect(xOffsetStart, yOffset + 1, xOffsetEnd - xOffsetStart + scale, scale - 2);\n                    }\n            }\n        }\n    }\n\n    private int getMaxTick(ThrallOutlineBox box)\n    {\n        int maxTick \u003d box.spawnTick + 99;\n        for (ThrallOutlineBox boxCompare : thrallOutlineBoxes)\n        {\n            if (box.owner.equalsIgnoreCase(boxCompare.owner))\n            {\n                if (boxCompare.spawnTick \u003e box.spawnTick \u0026\u0026 boxCompare.spawnTick \u003c (box.spawnTick + 99))\n                {\n                    maxTick \u003d boxCompare.spawnTick;\n                }\n            }\n        }\n        if (endTick \u003c maxTick)\n        {\n            maxTick \u003d endTick;\n        }\n        return maxTick;\n    }\n\n    private void drawSelectedOutlineBox(Graphics2D g)\n    {\n        if (selectedTick !\u003d -1 \u0026\u0026 !selectedPlayer.equalsIgnoreCase(\"\"))\n        {\n            g.setColor(new Color(255, 255, 255));\n            int xOffset \u003d 100 + ((shouldWrap) ? ((selectedTick - startTick) % 50) * scale : selectedTick * scale);\n            int yOffset \u003d ((playerOffsets.get(selectedPlayer) + 1) * scale + 30) + (((shouldWrap) ? ((selectedTick - startTick) / 50) * boxHeight : 30)-currentScrollOffset);\n            if(yOffset \u003e scale + 5)\n            {\n                g.drawRect(xOffset, yOffset, scale, scale);\n            }\n        }\n    }\n\n    private Point getPoint(int tick, String player)\n    {\n        return new Point(\n                100 + ((shouldWrap) ? ((tick - startTick) % 50) * scale : tick * scale),\n                ((playerOffsets.get(player) + 1) * scale + 10) + (((shouldWrap) ? ((tick - startTick) / 50) * boxHeight : 0)-currentScrollOffset));\n    }\n\n    private void drawSelectedRow(Graphics2D g)\n    {\n        if (selectedRow !\u003d -1)\n        {\n            g.setColor(new Color(255, 255, 255));\n            int xOffset \u003d 100 + getXOffset(selectedRow);\n            int yOffset \u003d 10 + getYOffset(selectedRow);\n            g.drawRect(xOffset, yOffset, scale, scale * (players.size() + 2));\n\n            int selectedTickHP \u003d -1;\n            try\n            {\n                selectedTickHP \u003d roomHP.get(selectedRow + 1);\n            } catch (Exception ignored)\n            {\n\n            }\n            int offset \u003d -1;\n            switch (room)\n            {\n                case \"Maiden\":\n                case \"Verzik P3\":\n                    offset \u003d 7;\n                    break;\n                case \"Bloat\":\n                case \"Sotetseg\":\n                case \"Xarpus\":\n                    offset \u003d 3;\n                    break;\n                case \"Nylocas\":\n                    offset \u003d 5;\n                    offset +\u003d (4 - ((offset + selectedRow) % 4));\n                    offset -\u003d 2;\n                    break;\n            }\n            String bossWouldHaveDied \u003d (offset !\u003d -1) ? \"Melee attack on this tick killing would result in: \" + RoomUtil.time(selectedRow + 1 + offset + 1) + \" (Quick death: \" + RoomUtil.time(selectedRow + offset + 1) + \")\" : \"\";\n            String HPString \u003d \"Boss HP: \" + ((selectedTickHP \u003d\u003d -1) ? \"-\" : RoomUtil.varbitHPtoReadable(selectedTickHP));\n            HoverBox hoverBox \u003d new HoverBox(HPString, config);\n            if (offset !\u003d -1)\n            {\n                hoverBox.addString(bossWouldHaveDied);\n            }\n            int xPosition \u003d xOffset+scale;\n            if(xPosition+hoverBox.getWidth(g) \u003e img.getWidth())\n            {\n                xPosition \u003d xPosition-hoverBox.getWidth(g)-3*scale;\n            }\n            hoverBox.setPosition(xPosition, yOffset);\n            hoverBox.draw(g);\n        }\n    }\n\n\n    private void drawHoverBox(Graphics2D g)\n    {\n        for (PlayerDidAttack action : actions.keySet())\n        {\n            if (action.tick \u003d\u003d selectedTick \u0026\u0026 action.player.equals(selectedPlayer))\n            {\n                if(shouldTickBeDrawn(action.tick))\n                {\n                    Point location \u003d getPoint(action.tick, action.player);\n                    HoverBox hoverBox \u003d new HoverBox(actions.get(action), config);\n                    hoverBox.addString(\"\");\n                    for (String item : action.wornItemNames)\n                    {\n                        hoverBox.addString(\".\" + item);\n                    }\n                    int xPosition \u003d location.getX() + 10;\n                    if (xPosition + hoverBox.getWidth(g) \u003e img.getWidth())\n                    {\n                        xPosition \u003d xPosition - hoverBox.getWidth(g) - scale * 2;\n                    }\n                    hoverBox.setPosition(xPosition, location.getY() - 10);\n                    hoverBox.draw(g);\n                }\n            }\n        }\n    }\n\n    private void drawMaidenCrabs(Graphics2D g)\n    {\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n        g.setColor(new Color(230, 20, 20, 200));\n        if (room.equals(\"Maiden\"))\n        {\n            for (Integer tick : lines.keySet())\n            {\n                if(lines.get(tick).equals(\"Dead\"))\n                {\n                    continue;\n                }\n                String proc \u003d lines.get(tick);\n                int xOffset \u003d 100 + getXOffset(tick + 1);\n                int yOffset \u003d 10 + getYOffset(tick + 1);\n                if(yOffset \u003e scale + 5)\n                {\n                    continue;\n                }\n                yOffset -\u003d scale;\n                int crabOffsetX \u003d 0;\n                int crabOffsetY;\n\n                crabOffsetY \u003d 11;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 20;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetX \u003d 9;\n                crabOffsetY \u003d 11;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 20;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetX \u003d 18;\n                crabOffsetY \u003d 11;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 20;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetX \u003d 27;\n                crabOffsetY \u003d 2;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 20;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 11;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n                crabOffsetY \u003d 29;\n                g.drawOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n\n\n                for (String crab : crabDescriptions)\n                {\n                    if (crab.contains(proc))\n                    {\n                        xOffset \u003d 100 + getXOffset(tick + 1);\n                        yOffset \u003d 10 + getYOffset(tick + 1);\n                        crabOffsetX \u003d 0;\n                        crabOffsetY \u003d 0;\n                        if (crab.contains(\"N1\"))\n                        {\n                            crabOffsetY \u003d 11;\n                        } else if (crab.contains(\"S1\"))\n                        {\n                            crabOffsetY \u003d 20;\n                        } else if (crab.contains(\"N2\"))\n                        {\n                            crabOffsetX \u003d 9;\n                            crabOffsetY \u003d 11;\n                        } else if (crab.contains(\"S2\"))\n                        {\n                            crabOffsetX \u003d 9;\n                            crabOffsetY \u003d 20;\n                        } else if (crab.contains(\"N3\"))\n                        {\n                            crabOffsetX \u003d 18;\n                            crabOffsetY \u003d 11;\n                        } else if (crab.contains(\"S3\"))\n                        {\n                            crabOffsetX \u003d 18;\n                            crabOffsetY \u003d 20;\n                        } else if (crab.contains(\"N4 (1)\"))\n                        {\n                            crabOffsetX \u003d 27;\n                            crabOffsetY \u003d 2;\n                        } else if (crab.contains(\"S4 (1)\"))\n                        {\n                            crabOffsetX \u003d 27;\n                            crabOffsetY \u003d 20;\n                        } else if (crab.contains(\"N4 (2)\"))\n                        {\n                            crabOffsetX \u003d 27;\n                            crabOffsetY \u003d 11;\n                        } else if (crab.contains(\"S4 (2)\"))\n                        {\n                            crabOffsetX \u003d 27;\n                            crabOffsetY \u003d 29;\n                        }\n                        crabOffsetY -\u003d scale;\n                        g.setColor(new Color(230, 20, 20, 200));\n                        g.fillOval(xOffset + crabOffsetX, yOffset + crabOffsetY, 7, 7);\n                    }\n                }\n            }\n        }\n    }\n\n    private void drawRoomTime(Graphics2D g)\n    {\n        g.setColor(Color.WHITE);\n        Font oldFont \u003d g.getFont();\n        g.setFont(FontManager.getRunescapeBoldFont());\n        g.drawString(\"Time \" + RoomUtil.time(endTick), 5, 20);\n        g.setFont(oldFont);\n    }\n\n    private void drawCheckBox(Graphics2D g)\n    {\n        g.setColor(Color.WHITE);\n        Font oldFont \u003d g.getFont();\n        g.setFont(FontManager.getRunescapeBoldFont());\n        g.drawString(\"Use Icons? \", 100, 20);\n        if(!checkBoxHovered)\n        {\n            g.setColor(new Color(140, 140, 140));\n        }\n\n        g.drawRect(180, 2, 20, 20);\n        if(checkBoxHovered)\n        {\n            g.setColor(new Color(140, 140, 140));\n            g.fillRect(181, 3, 19, 19);\n        }\n        g.setColor(Color.WHITE);\n        if(config.useIconsOnChart())\n        {\n            g.drawString(\"x\", 186, 17);\n        }\n        g.setFont(oldFont);\n    }\n\n    private void drawBaseBoxes(Graphics2D g)\n    {\n        for(int i \u003d startTick; i \u003c endTick; i++)\n        {\n            if(shouldTickBeDrawn(i))\n            {\n                for (int j \u003d 0; j \u003c playerOffsets.size(); j++)\n                {\n                    int xOffset \u003d 100 + ((shouldWrap) ? ((i - startTick) % 50) * scale : i * scale);\n                    if (playerOffsets.get(players.get(j)) \u003d\u003d null)\n                    {\n                        continue;\n                    }\n                    shouldWrap \u003d true;\n                    int yOffset \u003d ((playerOffsets.get(players.get(j)) + 1) * scale + 30) + ((((i - startTick) / 50) * boxHeight)-currentScrollOffset);\n                    g.setColor(config.primaryMiddle());\n                    if(yOffset \u003e scale + 5)\n                    {\n                        g.fillRoundRect(xOffset + 2, yOffset + 2, scale - 3, scale - 3, 5, 5);\n                    }\n                }\n            }\n        }\n    }\n\n    private void drawGraph()\n    {\n        if(!shouldDraw())\n        {\n            return;\n        }\n        Graphics2D g \u003d (Graphics2D) img.getGraphics();\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n        RenderingHints qualityHints \u003d new RenderingHints(\n                RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON );\n        qualityHints.put(\n                RenderingHints.KEY_RENDERING,\n                RenderingHints.VALUE_RENDER_QUALITY );\n        g.setRenderingHints( qualityHints);\n        Color oldColor \u003d g.getColor();\n\n        g.setColor(config.primaryDark());\n        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n\n\n        fontHeight \u003d getStringBounds(g, \"a\").height;\n        g.setColor(Color.WHITE);\n\n        drawTicks(g);\n        drawGraphBoxes(g);\n        drawBaseBoxes(g);\n        drawYChartColumn(g);\n        drawRoomSpecificData(g);\n        drawDawnSpecs(g);\n        drawPrimaryBoxes(g);\n        drawAutos(g);\n        drawMarkerLines(g);\n        drawThrallBoxes(g);\n        drawMaidenCrabs(g);\n        drawSelectedOutlineBox(g);\n        drawSelectedRow(g);\n        drawHoverBox(g);\n        drawRoomTime(g);\n        drawCheckBox(g);\n\n        g.setColor(oldColor);\n        g.dispose();\n        repaint();\n    }\n\n    public boolean shouldTickBeDrawn(int tick)\n    {\n        return tick \u003e\u003d (startTick + currentBox*50) \u0026\u0026 tick \u003c (startTick + ((currentBox+boxesToShow)*50));\n    }\n\n    public void getTickHovered(int x, int y)\n    {\n        y \u003d y + currentScrollOffset;\n        if (y \u003e 20)\n        {\n            int boxNumber \u003d (y - 20) / boxHeight;\n            if (x \u003e 100)\n            {\n                int tick \u003d startTick + (50 * boxNumber + ((x - 100) / scale));\n                int playerOffsetPosition \u003d (((y - 30 - scale) % boxHeight) / scale);\n                if (playerOffsetPosition \u003e\u003d 0 \u0026\u0026 playerOffsetPosition \u003c players.size() \u0026\u0026 (y - 30 - scale \u003e 0))\n                {\n                    selectedTick \u003d tick;\n                    selectedPlayer \u003d players.get(playerOffsetPosition);\n                    selectedRow \u003d -1;\n                } else if (y % boxHeight \u003c 30 + scale)\n                {\n                    selectedRow \u003d tick;\n                    selectedPlayer \u003d \"\";\n                    selectedTick \u003d -1;\n                } else\n                {\n                    selectedPlayer \u003d \"\";\n                    selectedTick \u003d -1;\n                    selectedRow \u003d -1;\n                }\n            } else\n            {\n                selectedPlayer \u003d \"\";\n                selectedTick \u003d -1;\n                selectedRow \u003d -1;\n            }\n            drawGraph();\n        }\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e)\n    {\n        if(checkBoxHovered)\n        {\n            configManager.setConfiguration(\"Advanced Raid Tracker\", \"useIconsOnChart\", !config.useIconsOnChart());\n            drawGraph();\n        }\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e)\n    {\n\n    }\n\n\n    @Override\n    public void mouseReleased(MouseEvent e)\n    {\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e)\n    {\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e)\n    {\n        selectedPlayer \u003d \"\";\n        selectedTick \u003d -1;\n        selectedRow \u003d -1;\n        drawGraph();\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e)\n    {\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e)\n    {\n        checkBoxHovered \u003d e.getX() \u003e\u003d 180 \u0026\u0026 e.getX() \u003c\u003d 200 \u0026\u0026 e.getY() \u003e\u003d 2 \u0026\u0026 e.getY() \u003c\u003d 22;\n        getTickHovered(e.getX(), e.getY());\n        drawGraph();\n    }\n\n    public String getBossName(int id, int index, int tick)\n    {\n        try\n        {\n            switch (id)\n            {\n                case TobIDs.MAIDEN_P0:\n                case TobIDs.MAIDEN_P1:\n                case TobIDs.MAIDEN_P2:\n                case TobIDs.MAIDEN_P3:\n                case TobIDs.MAIDEN_PRE_DEAD:\n                case TobIDs.MAIDEN_P0_HM:\n                case TobIDs.MAIDEN_P1_HM:\n                case TobIDs.MAIDEN_P2_HM:\n                case TobIDs.MAIDEN_P3_HM:\n                case TobIDs.MAIDEN_PRE_DEAD_HM:\n                case TobIDs.MAIDEN_P0_SM:\n                case TobIDs.MAIDEN_P1_SM:\n                case TobIDs.MAIDEN_P2_SM:\n                case TobIDs.MAIDEN_P3_SM:\n                case TobIDs.MAIDEN_PRE_DEAD_SM:\n                    return \"Maiden (\" + RoomUtil.varbitHPtoReadable(roomHP.get(tick + 1)) + \")\";\n                case TobIDs.BLOAT:\n                case TobIDs.BLOAT_HM:\n                case TobIDs.BLOAT_SM:\n                    return \"Bloat (\" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + \")\";\n                case TobIDs.NYLO_BOSS_MELEE:\n                case TobIDs.NYLO_BOSS_RANGE:\n                case TobIDs.NYLO_BOSS_MAGE:\n                case TobIDs.NYLO_BOSS_MELEE_HM:\n                case TobIDs.NYLO_BOSS_RANGE_HM:\n                case TobIDs.NYLO_BOSS_MAGE_HM:\n                case TobIDs.NYLO_BOSS_MELEE_SM:\n                case TobIDs.NYLO_BOSS_RANGE_SM:\n                case TobIDs.NYLO_BOSS_MAGE_SM:\n                    return \"Nylo Boss (\" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + \")\";\n                case TobIDs.XARPUS_P23:\n                case TobIDs.XARPUS_P23_HM:\n                case TobIDs.XARPUS_P23_SM:\n                    return \"Xarpus (\" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + \")\";\n                case TobIDs.VERZIK_P1:\n                case TobIDs.VERZIK_P2:\n                case TobIDs.VERZIK_P3:\n                case TobIDs.VERZIK_P1_HM:\n                case TobIDs.VERZIK_P2_HM:\n                case TobIDs.VERZIK_P3_HM:\n                case TobIDs.VERZIK_P1_SM:\n                case TobIDs.VERZIK_P2_SM:\n                case TobIDs.VERZIK_P3_SM:\n                    return \"Verzik (\" + RoomUtil.varbitHPtoReadable(roomHP.get(tick)) + \")\";\n            }\n            for (Integer i : NPCMap.keySet())\n            {\n                if (i \u003d\u003d index)\n                {\n                    String hp \u003d \"-1\";\n                    try\n                    {\n                        hp \u003d RoomUtil.varbitHPtoReadable(roomHP.get(tick));\n                    } catch (Exception ignored\n                    )\n                    {\n                    }\n                    return NPCMap.get(i) + \" (Boss: \" + hp + \")\";\n                }\n            }\n            return \"?\";\n        } catch (Exception e)\n        {\n            return \"?\";\n        }\n    }\n    private int currentBox \u003d 0;\n    private int currentScrollOffset \u003d 0;\n    @Override\n    public void mouseWheelMoved(MouseWheelEvent e) //manually implement scrolling\n    {\n        if(e.getWheelRotation() \u003c 0) //top of the first box aligns to top if you scroll up\n        {\n            currentBox \u003d Math.max(0, currentBox-1);\n            currentScrollOffset \u003d currentBox*boxHeight;\n        }\n        else //bottom of the bottom box aligns to the bottom if you scroll down\n        {\n            if(TITLE_BAR_PLUS_TAB_HEIGHT+scale+boxCount*boxHeight \u003e img.getHeight()) //no need to scroll at all if all boxes fit on screen, boxes would jump to bottom and leave dead space\n            {\n                int lastBox \u003d currentBox + boxesToShow - 1;\n                lastBox \u003d Math.min(lastBox + 1, boxCount - 1);\n                currentBox \u003d lastBox - boxesToShow + 1;\n                int lastBoxEnd \u003d (boxesToShow * boxHeight) + scale + TITLE_BAR_PLUS_TAB_HEIGHT;\n                currentScrollOffset \u003d (currentBox * boxHeight) + (lastBoxEnd - img.getHeight());\n            }\n        }\n        recalculateSize();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\charts\\ChartPanel.java"},{"fileName":"HoverBox.java","content":"package com.advancedraidtracker.ui.charts;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.utility.ItemReference;\nimport com.advancedraidtracker.utility.Point;\nimport net.runelite.client.ui.FontManager;\nimport java.awt.*;\nimport java.awt.font.FontRenderContext;\nimport java.awt.font.GlyphVector;\nimport java.util.ArrayList;\n\nimport static com.advancedraidtracker.utility.ItemReference.*;\n\npublic class HoverBox\n{\n    ArrayList\u003cString\u003e info;\n    Point location \u003d new Point(0,0);\n    private final AdvancedRaidTrackerConfig config;\n    public HoverBox(String s, AdvancedRaidTrackerConfig config)\n    {\n        this.config \u003d config;\n        info \u003d new ArrayList\u003c\u003e();\n        addString(s);\n    }\n\n    public void addString(String s)\n    {\n        info.add(s);\n        if(s.toLowerCase().startsWith(\".weapon\"))\n        {\n            setStyle(s);\n        }\n    }\n\n    public void setPosition(int x, int y)\n    {\n        location \u003d new Point(x+config.chartScaleSize(), y);\n    }\n\n    int style \u003d NONE;\n\n    private void setStyle(String weapon)\n    {\n        if(anyMatch(weapon, ItemReference.ITEMS[MELEE]))\n        {\n            style \u003d MELEE;\n        }\n        else if(anyMatch(weapon, ItemReference.ITEMS[RANGE]))\n        {\n            style \u003d RANGE;\n        }\n        else if(anyMatch(weapon, ItemReference.ITEMS[MAGE]))\n        {\n            style \u003d MAGE;\n        }\n    }\n    private boolean anyMatch(String item, String[] items)\n    {\n        for(String s : items)\n        {\n            if(item.toLowerCase().contains(s))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public int getWidth(Graphics2D g)\n    {\n        Font oldFont \u003d g.getFont();\n        g.setFont(FontManager.getRunescapeBoldFont());\n        int longestString \u003d 0;\n        for(String s : info)\n        {\n            int stringLength \u003d getStringWidth(g, s);\n            if (stringLength \u003e longestString)\n            {\n                longestString \u003d stringLength;\n            }\n        }\n        g.setFont(oldFont);\n        return longestString+10;\n    }\n\n    public void draw(Graphics2D g)\n    {\n        Font oldFont \u003d g.getFont();\n        g.setFont(FontManager.getRunescapeBoldFont());\n        int fontHeight \u003d getStringBounds(g).height;\n        g.setColor(config.primaryDark());\n        int boxHeight \u003d 10 + (fontHeight+7)*info.size();\n        g.fillRoundRect(location.getX(), location.getY(), getWidth(g), boxHeight, 10, 10);\n        g.setColor(new Color(200, 200, 200));\n        g.drawRoundRect(location.getX(), location.getY(), getWidth(g), boxHeight, 10, 10);\n\n        for(int i \u003d 0; i \u003c info.size(); i++)\n        {\n            String label \u003d info.get(i);\n            if(label.startsWith(\".\") \u0026\u0026 label.length() \u003e 1)\n            {\n                label \u003d label.substring(1);\n                if(anyMatch(label, ItemReference.ITEMS[style]))\n                {\n                    g.setColor(new Color(60, 190, 60));\n                }\n                else if(anyMatch(label, ItemReference.ITEMS[0]))\n                {\n                    g.setColor(new Color(120, 120, 120));\n                }\n                else\n                {\n                    g.setColor(new Color(190, 30, 30));\n                }\n            }\n            g.drawString(label, location.getX()+5, location.getY() + 5 + (fontHeight+7)*(i+1));\n        }\n        g.setFont(oldFont);\n    }\n\n    private int getStringWidth(Graphics2D g, String str)\n    {\n        FontRenderContext frc \u003d g.getFontRenderContext();\n        GlyphVector gv \u003d g.getFont().createGlyphVector(frc, str);\n        return gv.getPixelBounds(null, 0, 0).width;\n    }\n\n    private Rectangle getStringBounds(Graphics2D g2)\n    {\n        FontRenderContext frc \u003d g2.getFontRenderContext();\n        GlyphVector gv \u003d g2.getFont().createGlyphVector(frc, \"a\");\n        return gv.getPixelBounds(null, (float) 0, (float) 0);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\charts\\HoverBox.java"},{"fileName":"LiveChart.java","content":"package com.advancedraidtracker.ui.charts;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.utility.wrappers.PlayerDidAttack;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ComponentAdapter;\nimport java.awt.event.ComponentEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\n@Slf4j\npublic class LiveChart extends BaseFrame\n{\n    public JTabbedPane tabbedPane;\n\n    private final AdvancedRaidTrackerConfig config;\n    private final ClientThread clientThread;\n    private final ConfigManager configManager;\n    Map\u003cString, ChartPanel\u003e tobPanels;\n\n\n    private final String[] names \u003d {\"Maiden\", \"Bloat\", \"Nylocas\", \"Sotetseg\", \"Xarpus\", \"Verzik\"};\n    public LiveChart(AdvancedRaidTrackerConfig config, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        this.clientThread \u003d clientThread;\n        this.config \u003d config;\n        tobPanels \u003d new LinkedHashMap\u003c\u003e();\n        for(String name : names)\n        {\n            tobPanels.put(name, new ChartPanel(name, true, config, clientThread, configManager));\n        }\n\n        tabbedPane \u003d new JTabbedPane();\n        tabbedPane.addChangeListener(cl-\u003e\n        {\n            String activePanel \u003d names[tabbedPane.getSelectedIndex()];\n            for(String panelNames : names)\n            {\n                if(activePanel.equals(panelNames) \u0026\u0026 this.isShowing())\n                {\n                    getPanel(panelNames).setActive(true);\n                    getPanel(panelNames).redraw();\n                }\n                else\n                {\n                    getPanel(panelNames).setActive(false);\n                }\n            }\n        });\n        for(String panelName : tobPanels.keySet())\n        {\n            tabbedPane.add(panelName, tobPanels.get(panelName));\n        }\n        addWindowListener(new WindowAdapter()\n        {\n            @Override\n            public void windowClosing(WindowEvent e)\n            {\n                super.windowClosing(e);\n                for(String panelNames : names)\n                {\n                    getPanel(panelNames).setActive(false);\n                }\n            }\n\n            @Override\n            public void windowOpened(WindowEvent e)\n            {\n                super.windowOpened(e);\n                String activePanel \u003d names[tabbedPane.getSelectedIndex()];\n                getPanel(activePanel).setActive(true);\n                getPanel(activePanel).redraw();\n                pack();\n            }\n        });\n\n        addComponentListener(new ComponentAdapter()\n        {\n            @Override\n            public void componentResized(ComponentEvent e)\n            {\n                super.componentResized(e);\n                Component c \u003d (Component) e.getSource();\n                for(ChartPanel p : tobPanels.values())\n                {\n                    p.setSize(c.getWidth(), c.getHeight());\n                }\n            }\n        });\n\n\n        add(tabbedPane);\n        pack();\n    }\n\n    @Override\n    public void close()\n    {\n        super.close();\n    }\n\n    public ChartPanel getPanel(String room)\n    {\n\t\tif(tobPanels.containsKey(room)) //do not use getOrDefault because it will allocate a BufferedImage every call even if the map does contain the key value\n\t\t{\n\t\t\treturn tobPanels.get(room);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn new ChartPanel(\"\", true, config, clientThread, configManager);\n\t\t}\n    }\n\n    public void incrementTick(String room)\n    {\n        getPanel(room).incrementTick();\n        if (getPanel(room).endTick % 50 \u003d\u003d 0)\n        {\n            for(ChartPanel panel : tobPanels.values())\n            {\n                panel.sendToBottom();\n            }\n        }\n    }\n\n\n    public void addAttack(PlayerDidAttack attack, String room)\n    {\n        getPanel(room).addLiveAttack(attack);\n    }\n\n    public void addMaidenLine(int value, String description)\n    {\n        tobPanels.get(\"Maiden\").addLine(value, description);\n    }\n\n    public void addBloatLine(int value, String description)\n    {\n        tobPanels.get(\"Bloat\").addLine(value, description);\n    }\n\n    public void addNyloLine(int value, String description)\n    {\n        tobPanels.get(\"Nylocas\").addLine(value, description);\n    }\n\n    public void addSoteLine(int value, String description)\n    {\n        tobPanels.get(\"Sotetseg\").addLine(value, description);\n    }\n\n    public void addXarpLine(int value, String description)\n    {\n        tobPanels.get(\"Xarpus\").addLine(value, description);\n    }\n\n    public void addVerzikLine(int value, String description)\n    {\n        tobPanels.get(\"Verzik\").addLine(value, description);\n    }\n\n    public void setMaidenFinished(int tick)\n    {\n        tobPanels.get(\"Maiden\").setRoomFinished(tick);\n    }\n\n    public void setBloatFinished(int tick)\n    {\n        tobPanels.get(\"Bloat\").setRoomFinished(tick);\n    }\n\n    public void setNyloFinished(int tick)\n    {\n        tobPanels.get(\"Nylocas\").setRoomFinished(tick);\n    }\n\n    public void setSoteFinished(int tick)\n    {\n        tobPanels.get(\"Sotetseg\").setRoomFinished(tick);\n    }\n\n    public void setXarpFinished(int tick)\n    {\n        tobPanels.get(\"Xarpus\").setRoomFinished(tick);\n    }\n\n    public void setVerzFinished(int tick)\n    {\n        tobPanels.get(\"Verzik\").setRoomFinished(tick);\n    }\n\n    public void resetAll()\n    {\n        for(ChartPanel panel : tobPanels.values())\n        {\n            panel.resetGraph();\n        }\n    }\n\n    public void redrawAll()\n    {\n        for(ChartPanel panel : tobPanels.values())\n        {\n            panel.redraw();\n        }\n    }\n\n    public void setPlayers(ArrayList\u003cString\u003e players)\n    {\n        ArrayList\u003cString\u003e cleanedPlayers \u003d new ArrayList\u003c\u003e();\n        for (String s : players)\n        {\n            cleanedPlayers.add(s.replaceAll(String.valueOf((char) 160), String.valueOf((char) 32)));\n        }\n        for(ChartPanel panel : tobPanels.values())\n        {\n            panel.setPlayers(cleanedPlayers);\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\charts\\LiveChart.java"},{"fileName":"ComparisonViewFrame.java","content":"package com.advancedraidtracker.ui.comparisonview;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Map;\n\n@Slf4j\npublic class ComparisonViewFrame extends BaseFrame\n{\n    public ComparisonViewFrame(ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e data, ArrayList\u003cString\u003e labels)\n    {\n        add(new ComparisonViewPanel(data, labels, config, itemManager, clientThread, configManager));\n        pack();\n    }\n\n    private AdvancedRaidTrackerConfig config;\n    private ItemManager itemManager;\n    private ClientThread clientThread;\n    private ConfigManager configManager;\n\n    public ComparisonViewFrame(Map\u003cInteger, ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e\u003e dataSets, ArrayList\u003cArrayList\u003cString\u003e\u003e labelSets, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        this.clientThread \u003d clientThread;\n        this.itemManager \u003d itemManager;\n        this.config \u003d config;\n        JTabbedPane pane \u003d new JTabbedPane();\n        pane.setBackground(Color.BLACK);\n        pane.setOpaque(true);\n        int index \u003d 0;\n        for (Integer i : dataSets.keySet())\n        {\n            String tabName \u003d \"\";\n            if (i \u003d\u003d 1)\n                tabName \u003d \"Solo\";\n            if (i \u003d\u003d 2)\n                tabName \u003d \"Duo\";\n            if (i \u003d\u003d 3)\n                tabName \u003d \"Trio\";\n            if (i \u003d\u003d 4)\n                tabName \u003d \"4-Man\";\n            if (i \u003d\u003d 5)\n                tabName \u003d \"5-Man\";\n            pane.addTab(tabName, new ComparisonViewPanel(dataSets.get(i), labelSets.get(index), config, itemManager, clientThread, configManager));\n            index++;\n        }\n        add(pane);\n        pack();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\ComparisonViewFrame.java"},{"fileName":"ComparisonViewPanel.java","content":"package com.advancedraidtracker.ui.comparisonview;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.ui.comparisonview.graph.GraphPanel;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport com.advancedraidtracker.utility.StatisticGatherer;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport javax.swing.border.MatteBorder;\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.util.*;\n\n@Slf4j\npublic class ComparisonViewPanel extends JPanel\n{\n    private final JPanel container;\n    private final JSlider leftCutOff;\n    private final JSlider rightCutOff;\n    private final JSlider threshold;\n\n    private final JTextField leftLabel;\n    private final JTextField rightLabel;\n    private final JTextField thresholdLabel;\n\n    private final JLabel graph1Average;\n    private final JLabel graph1Median;\n    private final JLabel graph1Maximum;\n    private final JLabel graph1Minimum;\n    private final JLabel graph1Mode;\n    private final JPanel otherPanel \u003d new JPanel();\n    private final JLabel graph2Average;\n    private final JLabel graph2Median;\n    private final JLabel graph2Maximum;\n    private final JLabel graph2Minimum;\n    private final JLabel graph2Mode;\n\n    private final JLabel graph1PercentThreshold;\n    private final JLabel graph2PercentThreshold;\n\n    private String panelName \u003d \"Other\";\n    private JPanel otherTopLeft;\n    private JPanel otherTopRight;\n    private JPanel otherBottomLeft;\n    private JPanel otherBottomRight;\n    private final JTabbedPane topGraphTabs;\n    private final JTabbedPane bottomGraphTabs;\n    private final JCheckBox matchYScales;\n\n    private final JCheckBox matchXScales;\n\n    private final JComboBox\u003cString\u003e compareByComboBox;\n    private final JComboBox\u003cString\u003e graphTypeComboBox;\n    private boolean time \u003d false;\n    ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e data;\n\n    JPanel scrollTopPanel;\n    JPanel scrollBottomPanel;\n    JScrollPane scrollTopGraphData;\n    JScrollPane scrollBottomGraphData;\n    ArrayList\u003cGraphPanel\u003e topGraphs;\n    ArrayList\u003cGraphPanel\u003e bottomGraphs;\n    ArrayList\u003cString\u003e labels;\n\n    JSpinner groupSizeSpinner;\n    SpinnerNumberModel spinnerSizeModel;\n    SpinnerNumberModel spinnerOffsetModel;\n    JSpinner groupOffsetSpinner;\n    JLabel leftThresholdLabel;\n    JLabel rightThresholdLabel;\n\n    JCheckBox groupingEnabled;\n\n    private final AdvancedRaidTrackerConfig config;\n    private final ItemManager itemManager;\n    private final ConfigManager configManager;\n\n    private final ClientThread clientThread;\n    public ComparisonViewPanel(ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e raidData, ArrayList\u003cString\u003e names, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        this.clientThread \u003d clientThread;\n        this.itemManager \u003d itemManager;\n        this.config \u003d config;\n        leftLabel \u003d new JTextField(\"Min cutoff: \");\n        rightLabel \u003d new JTextField(\"Max cutoff: \");\n        leftThresholdLabel \u003d new JLabel(\"% \u003c\u003d \");\n        rightThresholdLabel \u003d new JLabel(\"% \u003c\u003d \");\n        thresholdLabel \u003d new JTextField(\"Threshold: \");\n        thresholdLabel.setEditable(false);\n        leftLabel.setEditable(false);\n        rightLabel.setEditable(false);\n        leftCutOff \u003d new JSlider();\n        rightCutOff \u003d new JSlider();\n        threshold \u003d new JSlider();\n        topGraphs \u003d new ArrayList\u003c\u003e();\n        bottomGraphs \u003d new ArrayList\u003c\u003e();\n        data \u003d raidData;\n        matchYScales \u003d new JCheckBox(\"Match Y-Axis\", true);\n        matchXScales \u003d new JCheckBox(\"Match X-Axis\", true);\n\n        spinnerSizeModel \u003d new SpinnerNumberModel(1, 1, 100, 1);\n        groupSizeSpinner \u003d new JSpinner(spinnerSizeModel);\n\n        spinnerOffsetModel \u003d new SpinnerNumberModel(0, 0, 0, 1);\n        groupOffsetSpinner \u003d new JSpinner(spinnerOffsetModel);\n\n        groupingEnabled \u003d new JCheckBox(\"Enable Grouping?\");\n        groupingEnabled.setSelected(false);\n        groupOffsetSpinner.setEnabled(false);\n        groupSizeSpinner.setEnabled(false);\n\n        graphTypeComboBox \u003d new JComboBox\u003c\u003e(new String[]{\"Bar Graph\", \"Pie Chart\", \"Line Plot\"});\n\n        graphTypeComboBox.addActionListener(e -\u003e\n        {\n            for (GraphPanel panel : topGraphs)\n            {\n                panel.setGraphType(graphTypeComboBox.getSelectedIndex());\n            }\n            for (GraphPanel panel : bottomGraphs)\n            {\n                panel.setGraphType(graphTypeComboBox.getSelectedIndex());\n            }\n        });\n        groupingEnabled.addActionListener(e -\u003e\n        {\n            for (GraphPanel panel : topGraphs)\n            {\n                panel.setGroupingEnabled(groupingEnabled.isSelected());\n                panel.updateGroupOffset((Integer) groupOffsetSpinner.getValue());\n                panel.updateGroupSize((Integer) groupSizeSpinner.getValue());\n\n            }\n            for (GraphPanel panel : bottomGraphs)\n            {\n                panel.setGroupingEnabled(groupingEnabled.isSelected());\n                panel.updateGroupOffset((Integer) groupOffsetSpinner.getValue());\n                panel.updateGroupSize((Integer) groupSizeSpinner.getValue());\n\n\n            }\n            groupSizeSpinner.setEnabled(groupingEnabled.isSelected());\n            groupOffsetSpinner.setEnabled(groupingEnabled.isSelected());\n\n        });\n\n        groupSizeSpinner.addChangeListener(e -\u003e\n        {\n            for (GraphPanel panel : topGraphs)\n            {\n                panel.updateGroupSize((int) groupSizeSpinner.getValue());\n            }\n            for (GraphPanel panel : bottomGraphs)\n            {\n                panel.updateGroupSize((int) groupSizeSpinner.getValue());\n            }\n            spinnerOffsetModel.setMaximum((int) groupSizeSpinner.getValue() - 1);\n        });\n\n        groupOffsetSpinner.addChangeListener(e -\u003e\n        {\n            for (GraphPanel panel : topGraphs)\n            {\n                panel.updateGroupOffset((int) groupOffsetSpinner.getValue());\n            }\n            for (GraphPanel panel : bottomGraphs)\n            {\n                panel.updateGroupOffset((int) groupOffsetSpinner.getValue());\n            }\n            spinnerSizeModel.setMinimum((int) groupOffsetSpinner.getValue() + 1);\n        });\n\n\n        labels \u003d names;\n\n        scrollTopPanel \u003d new JPanel();\n        scrollBottomPanel \u003d new JPanel();\n\n        scrollBottomGraphData \u003d new JScrollPane(scrollBottomPanel);\n        scrollTopGraphData \u003d new JScrollPane(scrollTopPanel);\n\n        graph1Average \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph1Median \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph1Mode \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph1Maximum \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph1Minimum \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph1PercentThreshold \u003d new JLabel(\"\", SwingConstants.RIGHT);\n\n        graph2Average \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph2Median \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph2Mode \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph2Maximum \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph2Minimum \u003d new JLabel(\"\", SwingConstants.RIGHT);\n        graph2PercentThreshold \u003d new JLabel(\"\", SwingConstants.RIGHT);\n\n        topGraphTabs \u003d new JTabbedPane();\n        topGraphTabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n        topGraphTabs.addChangeListener(cl -\u003e\n        {\n            switchGraphData();\n            updateOtherPanels();\n        });\n        bottomGraphTabs \u003d new JTabbedPane();\n        bottomGraphTabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n        bottomGraphTabs.addChangeListener(cl -\u003e\n        {\n            switchGraphData();\n            updateOtherPanels();\n        });\n\n        Map\u003cString, String[]\u003e comboPopupData \u003d new LinkedHashMap\u003c\u003e();\n        comboPopupData.put(\"Room Times\", DataPoint.getRoomTimes());\n        comboPopupData.put(\"Maiden\", DataPoint.getMaidenNames());\n        comboPopupData.put(\"Bloat\", DataPoint.getBloatNames());\n        comboPopupData.put(\"Nylocas\", DataPoint.getNyloNames());\n        comboPopupData.put(\"Sotetseg\", DataPoint.getSoteNames());\n        comboPopupData.put(\"Xarpus\", DataPoint.getXarpNames());\n        comboPopupData.put(\"Verzik\", DataPoint.getVerzikNames());\n        comboPopupData.put(\"Any\", DataPoint.getAnyRoomNames());\n\n        comboPopupMenu \u003d new JPopupMenu();\n        comboPopupMenu.setBorder(new MatteBorder(1, 1, 1, 1, Color.DARK_GRAY));\n\n        ArrayList\u003cString\u003e allComboValues \u003d new ArrayList\u003c\u003e(comboPopupData.keySet());\n\n        comboStrictData \u003d new ArrayList\u003c\u003e();\n\n        for (String category : allComboValues)\n        {\n            JMenu menu \u003d new JMenu(category);\n            menu.setBackground(Color.BLACK);\n            menu.setOpaque(true);\n            if (!category.equals(\"Room Times\") \u0026\u0026 !category.equals(\"Any\"))\n            {\n                JMenu timeMenu \u003d new JMenu(\"Time\");\n                timeMenu.setBackground(Color.BLACK);\n                timeMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))\n                {\n                    timeMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu countMenu \u003d new JMenu(\"Misc\");\n                countMenu.setBackground(Color.BLACK);\n                countMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))\n                {\n                    countMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu thrallMenu \u003d new JMenu(\"Thrall\");\n                thrallMenu.setBackground(Color.BLACK);\n                thrallMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))\n                {\n                    thrallMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu vengMenu \u003d new JMenu(\"Veng\");\n                vengMenu.setBackground(Color.BLACK);\n                vengMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))\n                {\n                    vengMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                JMenu specMenu \u003d new JMenu(\"Spec\");\n                specMenu.setBackground(Color.BLACK);\n                specMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))\n                {\n                    specMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                menu.add(timeMenu);\n                menu.add(countMenu);\n                menu.add(thrallMenu);\n                menu.add(vengMenu);\n                menu.add(specMenu);\n            } else\n            {\n                for (String itemName : comboPopupData.get(category))\n                {\n                    menu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n            }\n            comboPopupMenu.add(menu);\n        }\n        compareByComboBox \u003d new JComboBox\u003c\u003e();\n        compareByComboBox.setEditable(true);\n        compareByComboBox.setPrototypeDisplayValue(\"Maiden Time\");\n        compareByComboBox.setSelectedItem(\"Maiden Time\");\n        compareByComboBox.setEditable(false);\n        for (Component comp : compareByComboBox.getComponents())\n        {\n            if (comp instanceof AbstractButton)\n            {\n                arrowButton \u003d (AbstractButton) comp;\n                arrowButton.setBackground(Color.BLACK);\n            }\n        }\n\n        arrowButton.addActionListener(e -\u003e setPopupVisible(!comboPopupMenu.isVisible()));\n\n        compareByComboBox.addMouseListener(new MouseAdapter()\n        {\n            @Override\n            public void mouseClicked(MouseEvent e)\n            {\n                setPopupVisible(!comboPopupMenu.isVisible());\n            }\n        });\n\n        compareByComboBox.addActionListener(al -\u003e\n        {\n            switchGraphData();\n            updateOtherPanels();\n        });\n\n        matchYScales.addActionListener(al -\u003e\n                switchGraphData());\n\n        matchXScales.addActionListener(al -\u003e\n        {\n            switchGraphData();\n            leftCutOff.setEnabled(matchXScales.isSelected());\n            rightCutOff.setEnabled(matchXScales.isSelected());\n        });\n\n        container \u003d new JPanel();\n        container.setPreferredSize(new Dimension(1000, 730));\n        container.setLayout(new BoxLayout(container, BoxLayout.X_AXIS));\n\n        buildUI();\n        add(container);\n    }\n\n    private int valX \u003d 0;\n\n    private final JPopupMenu comboPopupMenu;\n    private final ArrayList\u003cString\u003e comboStrictData;\n    private AbstractButton arrowButton;\n\n    private void setComboSelection(String name)\n    {\n        Vector\u003cString\u003e items \u003d new Vector\u003c\u003e();\n\n        addComboItems(name, items, comboStrictData, compareByComboBox);\n    }\n\n    public static void addComboItems(String name, Vector\u003cString\u003e items, ArrayList\u003cString\u003e comboStrictData, JComboBox\u003cString\u003e compareByComboBox)\n    {\n        for (String item : comboStrictData)\n        {\n            if (item.endsWith(name))\n            {\n                items.add(item);\n                break;\n            }\n        }\n\n        compareByComboBox.setModel(new DefaultComboBoxModel\u003c\u003e(items));\n\n        if (items.size() \u003d\u003d 1)\n        {\n            compareByComboBox.setSelectedIndex(0);\n        }\n    }\n\n    private JMenuItem createMenuItem(final String name)\n    {\n        JMenuItem item \u003d new JMenuItem(name);\n        item.setBackground(Color.BLACK);\n        item.setOpaque(true);\n\n        item.addActionListener(event -\u003e setComboSelection(name));\n        return item;\n    }\n\n    private void setPopupVisible(boolean visible)\n    {\n        if (visible)\n        {\n            comboPopupMenu.show(compareByComboBox, 0, compareByComboBox.getSize().height);\n        } else\n        {\n            comboPopupMenu.setVisible(false);\n        }\n    }\n\n    private void switchGraphData()\n    {\n        if (topGraphs.size() !\u003d bottomGraphs.size())\n        {\n            return;\n        }\n        int xHigh \u003d 0;\n        int xLow \u003d Integer.MAX_VALUE;\n        int yHigh \u003d 0;\n        if (!Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString().contains(\"Player:\"))\n        {\n            time \u003d Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())).type \u003d\u003d DataPoint.types.TIME;\n        } else\n        {\n            time \u003d false;\n        }\n\n        for (int i \u003d 0; i \u003c topGraphs.size(); i++)\n        {\n            topGraphs.get(i).switchKey(Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())));\n            bottomGraphs.get(i).switchKey(Objects.requireNonNull(DataPoint.getValue(Objects.requireNonNull(compareByComboBox.getSelectedItem()).toString())));\n\n            topGraphs.get(i).generateScales();\n            bottomGraphs.get(i).generateScales();\n\n            xHigh \u003d Math.max(xHigh, topGraphs.get(i).getScaleXHigh());\n            xHigh \u003d Math.max(xHigh, bottomGraphs.get(i).getScaleXHigh());\n\n            yHigh \u003d Math.max(yHigh, topGraphs.get(i).getScaleYHigh());\n            yHigh \u003d Math.max(yHigh, bottomGraphs.get(i).getScaleYHigh());\n\n            xLow \u003d Math.min(xLow, topGraphs.get(i).getScaleXLow());\n            xLow \u003d Math.min(xLow, bottomGraphs.get(i).getScaleXLow());\n        }\n\n\n        leftCutOff.setMaximum(xHigh);\n        leftCutOff.setMinimum(xLow);\n        rightCutOff.setMaximum(xHigh);\n        rightCutOff.setMinimum(xLow);\n\n        threshold.setMaximum(xHigh);\n        threshold.setMinimum(xLow);\n        threshold.setValue(((xHigh - xLow) / 2) + xLow);\n        setThresholdTimes();\n\n        leftCutOff.setValue(xLow);\n        rightCutOff.setValue(xLow);\n\n        updateSliders();\n        container.repaint();\n        valX \u003d xHigh;\n        if (matchYScales.isSelected())\n        {\n            setYScales(yHigh);\n        }\n        if (matchXScales.isSelected())\n        {\n            setXScales(xLow, xHigh);\n        }\n\n        redrawGraphs();\n\n    }\n\n    private void setThresholdTimes()\n    {\n        thresholdLabel.setText(\"Threshold: \" + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));\n        leftThresholdLabel.setText(\"% \u003c\u003d \" + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));\n        rightThresholdLabel.setText(\"% \u003c\u003d \" + ((time) ? RoomUtil.time(threshold.getValue()) : threshold.getValue()));\n    }\n\n    private void setXScales(int xLow, int xHigh)\n    {\n        for (int i \u003d 0; i \u003c topGraphs.size(); i++)\n        {\n            topGraphs.get(i).setScales(xLow, xHigh, topGraphs.get(i).getScaleYHigh());\n            bottomGraphs.get(i).setScales(xLow, xHigh, bottomGraphs.get(i).getScaleYHigh());\n        }\n    }\n\n    private void setYScales(int yHigh)\n    {\n        for (int i \u003d 0; i \u003c topGraphs.size(); i++)\n        {\n            topGraphs.get(i).setScales(topGraphs.get(i).getScaleXLow(), topGraphs.get(i).getScaleXHigh(), yHigh);\n            bottomGraphs.get(i).setScales(bottomGraphs.get(i).getScaleXLow(), bottomGraphs.get(i).getScaleXHigh(), yHigh);\n        }\n    }\n\n    private void redrawGraphs(int xLow, int xHigh)\n    {\n        for (int i \u003d 0; i \u003c topGraphs.size(); i++)\n        {\n            topGraphs.get(i).setScales(xLow, xHigh, topGraphs.get(i).getScaleYHigh());\n            bottomGraphs.get(i).setScales(xLow, xHigh, bottomGraphs.get(i).getScaleYHigh());\n            topGraphs.get(i).setBounds();\n            topGraphs.get(i).drawGraph();\n            bottomGraphs.get(i).setBounds();\n            bottomGraphs.get(i).drawGraph();\n        }\n    }\n\n\n    private void redrawGraphs()\n    {\n        for (int i \u003d 0; i \u003c topGraphs.size(); i++)\n        {\n            topGraphs.get(i).setBounds();\n            topGraphs.get(i).drawGraph();\n            bottomGraphs.get(i).setBounds();\n            bottomGraphs.get(i).drawGraph();\n        }\n    }\n\n    private void updateCutoffs()\n    {\n        if (matchXScales.isSelected())\n        {\n            redrawGraphs(leftCutOff.getValue(), rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum());\n\n        }\n    }\n\n    private void updateSliders()\n    {\n        int leftExtent \u003d rightCutOff.getValue() - rightCutOff.getMinimum();\n        int rightExtent \u003d leftCutOff.getValue() - leftCutOff.getMinimum();\n        rightCutOff.setExtent(rightExtent);\n        leftCutOff.setExtent(leftExtent);\n\n        //For some unbelievably bizarre reasons extents can only be set for the upper bound so we have to inverse it\n\n        leftLabel.setText(\"Min cutoff: \" + ((time) ? RoomUtil.time(leftCutOff.getValue()) : leftCutOff.getValue()));\n        rightLabel.setText(\"Max cutoff: \" + ((time) ? RoomUtil.time(rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum()) : rightCutOff.getMaximum() - rightCutOff.getValue() + rightCutOff.getMinimum()));\n        updateCutoffs();\n    }\n\n    GraphPanel getGraphPanel(ArrayList\u003cSimpleTOBData\u003e points)\n    {\n        return new GraphPanel(points, config, itemManager, clientThread, configManager);\n    }\n\n    private ArrayList\u003cInteger\u003e getArrayForStatistics(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        ArrayList\u003cInteger\u003e arrayToPass \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData raidData : data)\n        {\n            int value \u003d raidData.getValue(DataPoint.getValue(String.valueOf(compareByComboBox.getSelectedItem())));\n            if (value \u003e -1)\n            {\n                if (!time || value !\u003d 0)\n                {\n                    switch ((Objects.requireNonNull(DataPoint.getValue(String.valueOf(compareByComboBox.getSelectedItem())))).room)\n                    {\n                        case MAIDEN:\n                            if (!raidData.maidenStartAccurate || !raidData.maidenEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                        case BLOAT:\n                            if (!raidData.bloatStartAccurate || !raidData.bloatEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                        case NYLOCAS:\n                            if (!raidData.nyloStartAccurate || !raidData.nyloEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                        case SOTETSEG:\n                            if (!raidData.soteStartAccurate || !raidData.soteEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                        case XARPUS:\n                            if (!raidData.xarpStartAccurate || !raidData.xarpEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                        case VERZIK:\n                            if (!raidData.verzikStartAccurate || !raidData.verzikEndAccurate)\n                            {\n                                continue;\n                            }\n                            break;\n                    }\n                    arrayToPass.add(value);\n                }\n            }\n        }\n        return arrayToPass;\n    }\n\n    private String getString(double val)\n    {\n        return (time) ? RoomUtil.time(val) : String.valueOf(Math.round(val * 100.0) / 100.0);\n    }\n\n    private void updateOtherPanels()\n    {\n        panelName \u003d \"Other - \" + compareByComboBox.getSelectedItem();\n        otherPanel.setBorder(BorderFactory.createTitledBorder(panelName));\n        if (topGraphTabs.getSelectedIndex() !\u003d -1 \u0026\u0026 bottomGraphTabs.getSelectedIndex() !\u003d -1 \u0026\u0026 built)\n        {\n            otherTopLeft.setBorder(BorderFactory.createTitledBorder(topGraphTabs.getTitleAt(topGraphTabs.getSelectedIndex())));\n            otherTopRight.setBorder(BorderFactory.createTitledBorder(bottomGraphTabs.getTitleAt(bottomGraphTabs.getSelectedIndex())));\n\n            otherBottomLeft.setBorder(BorderFactory.createTitledBorder(topGraphTabs.getTitleAt(topGraphTabs.getSelectedIndex()) + \" values\"));\n            otherBottomRight.setBorder(BorderFactory.createTitledBorder(bottomGraphTabs.getTitleAt(bottomGraphTabs.getSelectedIndex()) + \" values\"));\n\n            ArrayList\u003cSimpleTOBData\u003e topGraphData \u003d (data.get(topGraphTabs.getSelectedIndex()));\n            ArrayList\u003cSimpleTOBData\u003e bottomGraphData \u003d data.get(bottomGraphTabs.getSelectedIndex());\n\n            String worse \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#F63131\u0027\u003e\";\n            String better \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#99E622\u0027\u003e\";\n            String even \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#CCCCF6\u0027\u003e\";\n\n            double g1a \u003d StatisticGatherer.getGenericAverage(getArrayForStatistics(topGraphData));\n            double g1med \u003d StatisticGatherer.getGenericMedian(getArrayForStatistics(topGraphData));\n            double g1mod \u003d StatisticGatherer.getGenericMode(getArrayForStatistics(topGraphData));\n            double g1max \u003d StatisticGatherer.getGenericMax(getArrayForStatistics(topGraphData));\n            double g1min \u003d StatisticGatherer.getGenericMin(getArrayForStatistics(topGraphData));\n            double g1percent \u003d StatisticGatherer.getGenericPercent(getArrayForStatistics(topGraphData), threshold.getValue());\n\n            double g2a \u003d StatisticGatherer.getGenericAverage(getArrayForStatistics(bottomGraphData));\n            double g2med \u003d StatisticGatherer.getGenericMedian(getArrayForStatistics(bottomGraphData));\n            double g2mod \u003d StatisticGatherer.getGenericMode(getArrayForStatistics(bottomGraphData));\n            double g2max \u003d StatisticGatherer.getGenericMax(getArrayForStatistics(bottomGraphData));\n            double g2min \u003d StatisticGatherer.getGenericMin(getArrayForStatistics(bottomGraphData));\n            double g2percent \u003d StatisticGatherer.getGenericPercent(getArrayForStatistics(bottomGraphData), threshold.getValue());\n\n            String g1as \u003d (g1a \u003c g2a) ? better : g2a \u003d\u003d g1a ? even : worse;\n            String g1meds \u003d (g1med \u003c g2med) ? better : g2med \u003d\u003d g1med ? even : worse;\n            String g1mods \u003d (g1mod \u003c g2mod) ? better : g2mod \u003d\u003d g1mod ? even : worse;\n            String g1maxs \u003d (g1max \u003c g2max) ? better : g2max \u003d\u003d g1max ? even : worse;\n            String g1mins \u003d (g1min \u003c g2min) ? better : g2min \u003d\u003d g1min ? even : worse;\n            String g1perc \u003d (g1percent \u003e g2percent) ? better : g1percent \u003d\u003d g2percent ? even : worse;\n\n            String g2as \u003d (g1a \u003e g2a) ? better : g2a \u003d\u003d g1a ? even : worse;\n            String g2meds \u003d (g1med \u003e g2med) ? better : g2med \u003d\u003d g1med ? even : worse;\n            String g2mods \u003d (g1mod \u003e g2mod) ? better : g2mod \u003d\u003d g1mod ? even : worse;\n            String g2maxs \u003d (g1max \u003e g2max) ? better : g2max \u003d\u003d g1max ? even : worse;\n            String g2mins \u003d (g1min \u003e g2min) ? better : g2min \u003d\u003d g1min ? even : worse;\n            String g2perc \u003d (g2percent \u003e g1percent) ? better : g1percent \u003d\u003d g2percent ? even : worse;\n\n\n            graph1Average.setText(g1as + getString(g1a));\n            graph1Median.setText(g1meds + getString(g1med));\n            graph1Mode.setText(g1mods + getString(g1mod));\n            graph1Maximum.setText(g1maxs + getString(g1max));\n            graph1Minimum.setText(g1mins + getString(g1min));\n            graph1PercentThreshold.setText(g1perc + (g1percent) + \"%\");\n\n            graph2Average.setText(g2as + getString(g2a));\n            graph2Median.setText(g2meds + getString(g2med));\n            graph2Mode.setText(g2mods + getString(g2mod));\n            graph2Maximum.setText(g2maxs + getString(g2max));\n            graph2Minimum.setText(g2mins + getString(g2min));\n            graph2PercentThreshold.setText(g2perc + (g2percent) + \"%\");\n\n\n            ArrayList\u003cInteger\u003e topSet \u003d GraphPanel.getCounts(getArrayForStatistics(topGraphData), valX);\n            ArrayList\u003cInteger\u003e bottomSet \u003d GraphPanel.getCounts(getArrayForStatistics(bottomGraphData), valX);\n\n            scrollTopPanel.removeAll();\n            scrollBottomPanel.removeAll();\n\n            scrollTopPanel.add(new JLabel(\"Value\", SwingConstants.LEFT));\n            scrollTopPanel.add(new JLabel(\"Count\", SwingConstants.RIGHT));\n\n            int total \u003d GraphPanel.getCountedTotal(topSet);\n            int count \u003d 0;\n            count \u003d getCount(topSet, total, count, scrollTopPanel);\n\n            int altCount \u003d 0;\n            for (int i \u003d count; i \u003c 16; i++)\n            {\n                scrollTopPanel.add(new JLabel());\n                scrollTopPanel.add(new JLabel());\n                altCount++;\n            }\n            scrollTopPanel.setLayout(new GridLayout(count + 1 + altCount, 2));\n            count \u003d 0;\n\n            scrollBottomPanel.add(new JLabel(\"Value\", SwingConstants.LEFT));\n            scrollBottomPanel.add(new JLabel(\"Count\", SwingConstants.RIGHT));\n\n            total \u003d GraphPanel.getCountedTotal(bottomSet);\n\n            count \u003d getCount(bottomSet, total, count, scrollBottomPanel);\n            altCount \u003d 0;\n            for (int i \u003d count; i \u003c 16; i++)\n            {\n                scrollBottomPanel.add(new JLabel());\n                scrollBottomPanel.add(new JLabel());\n                altCount++;\n            }\n            scrollBottomPanel.setLayout(new GridLayout(count + 1 + altCount, 2));\n\n            scrollTopPanel.validate();\n            scrollBottomPanel.validate();\n        }\n        container.repaint();\n    }\n\n    private int getCount(ArrayList\u003cInteger\u003e topSet, double total, int count, JPanel scrollTopPanel)\n    {\n        for (int i \u003d 0; i \u003c topSet.size(); i++)\n        {\n            if (topSet.get(i) \u003e 0)\n            {\n                String percent \u003d Math.round((100.0 * topSet.get(i) / total) * 100.0) / 100.0 + \"%\";\n                scrollTopPanel.add(new JLabel(getString(i), SwingConstants.LEFT));\n                scrollTopPanel.add(new JLabel(topSet.get(i) + \" (\" + percent + \")\", SwingConstants.RIGHT));\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private boolean built \u003d false;\n\n    private void buildUI()\n    {\n        for (int i \u003d 0; i \u003c data.size(); i++)\n        {\n            GraphPanel topGraph \u003d getGraphPanel(data.get(i));\n            GraphPanel bottomGraph \u003d getGraphPanel(data.get(i));\n            topGraphTabs.addTab(labels.get(i), topGraph);\n            bottomGraphTabs.addTab(labels.get(i), bottomGraph);\n            topGraphs.add(topGraph);\n            bottomGraphs.add(bottomGraph);\n        }\n        switchGraphData();\n\n        JPanel leftContainer \u003d new JPanel();\n        leftContainer.setLayout(new BoxLayout(leftContainer, BoxLayout.Y_AXIS));\n\n        leftContainer.add(topGraphTabs);\n        leftContainer.add(bottomGraphTabs);\n\n        container.add(leftContainer);\n\n        JPanel sidebar \u003d new JPanel();\n        sidebar.setPreferredSize(new Dimension(390, 730));\n\n        JPanel graphOptionsPanel \u003d new JPanel();\n        graphOptionsPanel.setBorder(BorderFactory.createTitledBorder(\"Graph Options\"));\n        graphOptionsPanel.setPreferredSize(new Dimension(210, 215));\n\n        threshold.setPaintLabels(true);\n        threshold.setPaintTicks(true);\n        threshold.setPaintTrack(true);\n        threshold.addChangeListener(cl -\u003e\n        {\n            Object source \u003d cl.getSource();\n            if (source instanceof JSlider)\n            {\n                if (((JSlider) source).getValueIsAdjusting())\n                {\n                    setThresholdTimes();\n                    updateOtherPanels();\n                }\n            }\n        });\n        threshold.setPreferredSize(new Dimension(180, threshold.getPreferredSize().height));\n        leftCutOff.setPaintLabels(true);\n        leftCutOff.setPaintTicks(true);\n        leftCutOff.setPaintTrack(true);\n\n        leftCutOff.addChangeListener(cl -\u003e\n        {\n            Object source \u003d cl.getSource();\n            if (source instanceof JSlider)\n            {\n                if (((JSlider) source).getValueIsAdjusting())\n                {\n                    updateSliders();\n                }\n            }\n        });\n\n        rightCutOff.addChangeListener(cl -\u003e\n        {\n            Object source \u003d cl.getSource();\n            if (source instanceof JSlider)\n            {\n                if (((JSlider) source).getValueIsAdjusting())\n                {\n                    updateSliders();\n                }\n            }\n        });\n\n        leftCutOff.setPreferredSize(new Dimension(180, leftCutOff.getPreferredSize().height));\n\n\n        rightCutOff.setPaintTrack(true);\n        rightCutOff.setPaintTicks(true);\n        rightCutOff.setPaintLabels(true);\n\n        rightCutOff.setInverted(true);\n\n        rightCutOff.setPreferredSize(new Dimension(180, rightCutOff.getPreferredSize().height));\n\n\n        graphOptionsPanel.add(leftCutOff);\n        graphOptionsPanel.add(leftLabel);\n        graphOptionsPanel.add(rightCutOff);\n        graphOptionsPanel.add(rightLabel);\n        graphOptionsPanel.add(matchXScales);\n        graphOptionsPanel.add(matchYScales);\n\n        graphOptionsPanel.add(new JLabel(\"\"));\n\n        graphOptionsPanel.add(groupingEnabled);\n        graphOptionsPanel.add(new JLabel(\"Group Size: \"));\n        graphOptionsPanel.add(groupSizeSpinner);\n        graphOptionsPanel.add(new JLabel(\"Group Offset: \"));\n        graphOptionsPanel.add(groupOffsetSpinner);\n\n        graphOptionsPanel.add(new JCheckBox(\"Show Chronological\"));\n        graphOptionsPanel.add(new JCheckBox(\"Rotate 90\"));\n\n        graphOptionsPanel.add(graphTypeComboBox);\n\n        graphOptionsPanel.add(threshold);\n        thresholdLabel.setPreferredSize(new Dimension(140, thresholdLabel.getPreferredSize().height));\n        graphOptionsPanel.add(thresholdLabel);\n\n        JPanel compareByPanel \u003d new JPanel();\n        compareByPanel.setBorder(BorderFactory.createTitledBorder(\"Compare by\"));\n        compareByPanel.setPreferredSize(new Dimension(190, 60));\n        compareByPanel.add(compareByComboBox);\n\n\n        otherPanel.setBorder(BorderFactory.createTitledBorder(panelName));\n        otherPanel.setPreferredSize(new Dimension(190, 455));\n        otherPanel.setLayout(new BoxLayout(otherPanel, BoxLayout.Y_AXIS));\n\n\n        JPanel otherTop \u003d new JPanel();\n        otherTop.setLayout(new BoxLayout(otherTop, BoxLayout.X_AXIS));\n\n        JPanel otherBottom \u003d new JPanel();\n        otherBottom.setLayout(new BoxLayout(otherBottom, BoxLayout.X_AXIS));\n\n        otherTopLeft \u003d new JPanel();\n        otherTopLeft.setBorder(BorderFactory.createTitledBorder(\"Set 0\"));\n        otherTopLeft.setPreferredSize(new Dimension(100, 125));\n\n        otherTopRight \u003d new JPanel();\n        otherTopRight.setBorder(BorderFactory.createTitledBorder(\"Set 1\"));\n        otherTopRight.setPreferredSize(new Dimension(100, 125));\n\n        otherTop.add(otherTopLeft);\n        otherTop.add(otherTopRight);\n\n        otherBottomLeft \u003d new JPanel();\n        otherBottomLeft.setBorder(BorderFactory.createTitledBorder(\"Values\"));\n\n        otherTopLeft.setLayout(new GridLayout(6, 2));\n        otherTopRight.setLayout(new GridLayout(6, 2));\n\n\n        otherTopLeft.add(new JLabel(\"Average \", SwingConstants.LEFT));\n        otherTopLeft.add(graph1Average);\n        otherTopLeft.add(new JLabel(\"Median \", SwingConstants.LEFT));\n        otherTopLeft.add(graph1Median);\n        otherTopLeft.add(new JLabel(\"Mode \", SwingConstants.LEFT));\n        otherTopLeft.add(graph1Mode);\n        otherTopLeft.add(new JLabel(\"Maximum \", SwingConstants.LEFT));\n        otherTopLeft.add(graph1Maximum);\n        otherTopLeft.add(new JLabel(\"Minimum \", SwingConstants.LEFT));\n        otherTopLeft.add(graph1Minimum);\n        otherTopLeft.add(leftThresholdLabel);\n        otherTopLeft.add(graph1PercentThreshold);\n\n        otherTopRight.add(new JLabel(\"Average \", SwingConstants.LEFT));\n        otherTopRight.add(graph2Average);\n        otherTopRight.add(new JLabel(\"Median \", SwingConstants.LEFT));\n        otherTopRight.add(graph2Median);\n        otherTopRight.add(new JLabel(\"Mode \", SwingConstants.LEFT));\n        otherTopRight.add(graph2Mode);\n        otherTopRight.add(new JLabel(\"Maximum \", SwingConstants.LEFT));\n        otherTopRight.add(graph2Maximum);\n        otherTopRight.add(new JLabel(\"Minimum \", SwingConstants.LEFT));\n        otherTopRight.add(graph2Minimum);\n        otherTopRight.add(rightThresholdLabel);\n        otherTopRight.add(graph2PercentThreshold);\n\n        otherBottomRight \u003d new JPanel();\n        otherBottomRight.setBorder(BorderFactory.createTitledBorder(\"Values\"));\n\n        scrollTopGraphData.setPreferredSize(new Dimension(150, 250));\n        scrollBottomGraphData.setPreferredSize(new Dimension(150, 250));\n\n        scrollTopGraphData.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n        scrollBottomGraphData.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\n        otherBottomLeft.add(scrollTopGraphData);\n        otherBottomRight.add(scrollBottomGraphData);\n\n\n        otherBottom.add(otherBottomLeft);\n        otherBottom.add(otherBottomRight);\n\n        scrollTopPanel.validate();\n        scrollBottomPanel.validate();\n\n\n        otherPanel.add(otherTop);\n        otherPanel.add(otherBottom);\n\n        sidebar.setLayout(new BoxLayout(sidebar, BoxLayout.Y_AXIS));\n\n        sidebar.add(compareByPanel);\n        sidebar.add(graphOptionsPanel);\n        sidebar.add(otherPanel);\n\n        built \u003d true;\n        updateOtherPanels();\n\n        container.add(sidebar);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\ComparisonViewPanel.java"},{"fileName":"Bounds.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport lombok.Getter;\n\nimport java.util.ArrayList;\n\npublic class Bounds\n{\n    @Getter\n    private int left;\n    @Getter\n    private int right;\n    @Getter\n    private int bottom;\n    @Getter\n    private int top;\n\n    public ArrayList\u003cSimpleTOBData\u003e raids;\n\n    public Bounds(int l, int r, int b, int t, ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        this.raids \u003d raids;\n        left \u003d l;\n        right \u003d r;\n        bottom \u003d b;\n        top \u003d t;\n    }\n\n    public void reset()\n    {\n        left \u003d -1;\n        bottom \u003d -1;\n        top \u003d -1;\n        right \u003d -1;\n    }\n\n    public boolean matches(Bounds match)\n    {\n        return (match.getLeft() \u003d\u003d left \u0026\u0026 match.getRight() \u003d\u003d right \u0026\u0026 match.getTop() \u003d\u003d top \u0026\u0026 match.getBottom() \u003d\u003d bottom);\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\Bounds.java"},{"fileName":"GraphInternalBoundMatchedContainer.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\nimport java.util.ArrayList;\n\npublic class GraphInternalBoundMatchedContainer\n{\n    public ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e fullData;\n    public ArrayList\u003cInteger\u003e intData;\n\n    public GraphInternalBoundMatchedContainer(ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e fullData, ArrayList\u003cInteger\u003e intData)\n    {\n        this.fullData \u003d fullData;\n        this.intData \u003d intData;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\GraphInternalBoundMatchedContainer.java"},{"fileName":"GraphInternalDataContainer.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\nimport java.util.ArrayList;\n\npublic class GraphInternalDataContainer\n{\n    public ArrayList\u003cSimpleTOBData\u003e fullData;\n    public ArrayList\u003cInteger\u003e intData;\n\n    public GraphInternalDataContainer(ArrayList\u003cSimpleTOBData\u003e fullData, ArrayList\u003cInteger\u003e intData)\n    {\n        this.fullData \u003d fullData;\n        this.intData \u003d intData;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\GraphInternalDataContainer.java"},{"fileName":"GraphPanel.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.Objects;\n\n@Slf4j\npublic class GraphPanel extends JPanel implements MouseMotionListener, MouseListener, KeyListener\n{\n    public static final int IMG_WIDTH \u003d 600;\n    public static final int IMG_HEIGHT \u003d 300;\n    public static final int GRAPH_WIDTH \u003d 500;\n    public static final int GRAPH_HEIGHT \u003d 250;\n    public static final int GRAPH_XS \u003d 50;\n    public static final int GRAPH_XE \u003d 550;\n    public static final int GRAPH_YS \u003d 25;\n    public static final int GRAPH_YE \u003d 225;\n\n    private final Color[] pieChartColors \u003d {\n            Color.decode(\"#ebdc78\"),\n            Color.decode(\"#8be04e\"),\n            Color.decode(\"#5ad45a\"),\n            Color.decode(\"#00b7c7\"),\n            Color.decode(\"#0d88e6\"),\n            Color.decode(\"#1a53ff\"),\n            Color.decode(\"#4421af\"),\n            Color.decode(\"#7c1158\"),\n            Color.decode(\"#b30000\"),\n    };\n\n    private final Color gridColor \u003d new Color(110, 110, 110);\n    private ToolTipData activeToolTip;\n    private boolean shouldDrawToolTip \u003d false;\n\n    private boolean groupingEnabled \u003d true;\n\n    private int graphType;\n    private final ArrayList\u003cBounds\u003e selectedBounds;\n    private Bounds activeBound \u003d new Bounds(-1, -1, -1, -1, null);\n    private final ArrayList\u003cBounds\u003e bounds;\n    private final Color gradientStart;\n    private final Color gradientEnd;\n    private final Color gradientStartHighlighted;\n    private final Color gradientEndHighlighted;\n    private final Color gradientStartSelected;\n    private final Color gradientEndSelected;\n    private final Color gradientStartSelectedAndHighlighted;\n    private final Color gradientEndSelectedAndHighlighted;\n    private DataPoint activeKey;\n    private boolean time \u003d false;\n    private final BufferedImage img \u003d new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_ARGB);\n    private final ArrayList\u003cSimpleTOBData\u003e internalData;\n    private final AdvancedRaidTrackerConfig config;\n\n    private final ItemManager itemManager;\n\n    private final ClientThread clientThread;\n    private final ConfigManager configManager;\n    public GraphPanel(ArrayList\u003cSimpleTOBData\u003e data, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        this.clientThread \u003d clientThread;\n        this.itemManager \u003d itemManager;\n        selectedBounds \u003d new ArrayList\u003c\u003e();\n        gradientStart \u003d new Color(100, 170, 230, 90);\n        gradientEnd \u003d new Color(200, 240, 255, 90);\n\n        gradientStartHighlighted \u003d new Color(100, 170, 230, 215);\n        gradientEndHighlighted \u003d new Color(200, 240, 255, 215);\n\n        gradientStartSelected \u003d new Color(100, 170, 230, 190);\n        gradientEndSelected \u003d new Color(200, 240, 255, 190);\n\n        gradientStartSelectedAndHighlighted \u003d new Color(100, 170, 230, 240);\n        gradientEndSelectedAndHighlighted \u003d new Color(200, 240, 255, 240);\n        graphType \u003d 0;\n        internalData \u003d data;\n        drawBlankBarGraph();\n        addMouseMotionListener(this);\n        addMouseListener(this);\n        addKeyListener(this);\n        this.config \u003d config;\n        bounds \u003d new ArrayList\u003c\u003e();\n    }\n\n    @Override\n    protected void paintComponent(Graphics g)\n    {\n        super.paintComponent(g);\n        if (img !\u003d null)\n        {\n            g.drawImage(img, 0, 0, null);\n        }\n    }\n\n    @Override\n    public Dimension getPreferredSize()\n    {\n        return new Dimension(IMG_WIDTH, IMG_HEIGHT);\n    }\n\n\n    public void switchKey(DataPoint key)\n    {\n        time \u003d key.type \u003d\u003d DataPoint.types.TIME;\n        activeKey \u003d key;\n    }\n\n\n    private ArrayList\u003cInteger\u003e filterForTime(ArrayList\u003cInteger\u003e data)\n    {\n        ArrayList\u003cInteger\u003e arrayToPass \u003d new ArrayList\u003c\u003e();\n        for (Integer i : data)\n        {\n            if (!time || i !\u003d 0)\n            {\n                arrayToPass.add(i);\n            }\n        }\n        return arrayToPass;\n    }\n\n    public static ArrayList\u003cInteger\u003e getCounts(ArrayList\u003cInteger\u003e data, int highestValue)\n    {\n        ArrayList\u003cInteger\u003e countedData \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c highestValue + 1; i++)\n        {\n            countedData.add(0);\n        }\n        for (Integer i : data)\n        {\n            if (countedData.size() \u003e i \u0026\u0026 i \u003e -1)\n            {\n                int incrementedValue \u003d countedData.get(i) + 1;\n                countedData.set(i, incrementedValue);\n            }\n        }\n        return countedData;\n    }\n\n    public static int getCountedTotal(ArrayList\u003cInteger\u003e data)\n    {\n        int count \u003d 0;\n        for (Integer i : data)\n        {\n            count +\u003d i;\n        }\n        return count;\n    }\n\n    boolean isBarSelected(int left, int right, int top, int bottom)\n    {\n        for (Bounds b : selectedBounds)\n        {\n            if (b.getLeft() \u003d\u003d left \u0026\u0026 b.getRight() \u003d\u003d right \u0026\u0026 b.getTop() \u003d\u003d top \u0026\u0026 b.getBottom() \u003d\u003d bottom)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void drawBar(Graphics2D g, int width, int height, int left, int count, int total, String value)\n    {\n        Color oldColor \u003d g.getColor();\n        if (height \u003d\u003d 0)\n        {\n            return;\n        }\n        if (width \u003d\u003d 1)\n        {\n            g.drawLine(left, GRAPH_HEIGHT - GRAPH_YS, left, GRAPH_HEIGHT - GRAPH_YS - height);\n        }\n\n        int right \u003d left + width;\n        int top \u003d GRAPH_HEIGHT - GRAPH_YS - height;\n        int bottom \u003d GRAPH_HEIGHT - GRAPH_YS;\n\n        g.setColor(new Color(100, 170, 230));\n        g.drawLine(left, bottom, right, bottom);\n        g.drawLine(left, bottom, left, top);\n        g.drawLine(left, top, right, top);\n        g.drawLine(right, bottom, right, top);\n\n        boolean highlight \u003d (left \u003d\u003d activeBound.getLeft() \u0026\u0026 right \u003d\u003d activeBound.getRight() \u0026\u0026 top \u003d\u003d activeBound.getTop() \u0026\u0026 activeBound.getBottom() \u003d\u003d bottom);\n        boolean selected \u003d isBarSelected(left, right, top, bottom);\n\n\n        Paint oldPaint \u003d g.getPaint();\n        GradientPaint gradient \u003d new GradientPaint(left, bottom, (highlight \u0026\u0026 selected) ? gradientStartSelectedAndHighlighted : (highlight) ? gradientStartHighlighted : (selected) ? gradientStartSelected : gradientStart, left, top, (highlight \u0026\u0026 selected) ? gradientEndSelectedAndHighlighted : (highlight) ? gradientEndHighlighted : (selected) ? gradientEndSelected : gradientEnd);\n\n        g.setPaint(gradient);\n        g.fillRect(left, top, width, height);\n\n        if (highlight \u0026\u0026 selectedBounds.isEmpty())\n        {\n            String percent \u003d Math.round((100.0 * count / (double) total) * 100.0) / 100.0 + \"%\";\n            String message \u003d value + \": \" + count + \"/\" + total + \" (\" + percent + \")\";\n            int msgWidth \u003d g.getFontMetrics().stringWidth(message);\n            int msgHeight \u003d g.getFontMetrics().getHeight();\n\n            int ml \u003d left + width / 2 - msgWidth / 2;\n            int mb \u003d top - msgHeight / 2;\n\n            activeToolTip \u003d new ToolTipData(ml, mb, message);\n            shouldDrawToolTip \u003d true;\n        }\n        g.setPaint(oldPaint);\n        g.setColor(oldColor);\n    }\n\n    private int getHighestCount(ArrayList\u003cInteger\u003e data)\n    {\n        int max \u003d 0;\n        int index \u003d 0;\n        for (Integer i : data)\n        {\n            if (time \u0026\u0026 index \u003d\u003d 0)\n            {\n                index++;\n                continue;\n            }\n            if (i \u003e max)\n            {\n                max \u003d i;\n            }\n            index++;\n        }\n        return max;\n    }\n\n    public BufferedImage createStringImage(Graphics g, String s)\n    {\n        int w \u003d g.getFontMetrics().stringWidth(s) + 5;\n        int h \u003d g.getFontMetrics().getHeight();\n        BufferedImage image \u003d new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        Graphics2D imageGraphics \u003d image.createGraphics();\n        imageGraphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        imageGraphics.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n        imageGraphics.setColor(Color.WHITE);\n        imageGraphics.setFont(new Font(\"SansSerif\", Font.PLAIN, 12)); //HEIGHT 16\n        imageGraphics.drawString(s, 0, h - g.getFontMetrics().getDescent());\n        imageGraphics.dispose();\n        return image;\n    }\n\n    private void drawStringRotated(Graphics g, String s, int tx, int ty)\n    {\n        int angle \u003d (s.length() \u003d\u003d 1) ? 0 : -45;\n        AffineTransform aff \u003d AffineTransform.getRotateInstance(Math.toRadians(angle), tx, ty);\n        aff.translate(tx, ty);\n\n        Graphics2D g2D \u003d ((Graphics2D) g);\n        g2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n        g2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);\n        g2D.drawImage(createStringImage(g, s), aff, this);\n    }\n\n    private String getString(int s)\n    {\n        return (time) ? RoomUtil.time(s) : String.valueOf(s);\n    }\n\n    private int xScaleLow \u003d 0;\n    private int xScaleHigh \u003d 0;\n    private int yScaleHigh \u003d 0;\n\n    public int getScaleXLow()\n    {\n        return xScaleLow;\n    }\n\n    public int getScaleXHigh()\n    {\n        return xScaleHigh;\n    }\n\n    public int getScaleYHigh()\n    {\n        return yScaleHigh;\n    }\n\n    public void generateScales()\n    {\n        ArrayList\u003cInteger\u003e data \u003d filterInvalid(getInternalDataSet(activeKey).intData);\n        int lowestValue \u003d Integer.MAX_VALUE;\n        int highestValue \u003d 0;\n\n        for (Integer i : data)\n        {\n            if (time \u0026\u0026 i \u003d\u003d 0)\n            {\n                continue;\n            }\n            if (i \u003c lowestValue)\n            {\n                lowestValue \u003d i;\n            }\n            if (i \u003e highestValue)\n            {\n                highestValue \u003d i;\n            }\n        }\n        ArrayList\u003cInteger\u003e countedDataSet \u003d getCounts(data, highestValue);\n        int highestCount \u003d getHighestCount(countedDataSet);\n\n        xScaleLow \u003d lowestValue;\n        xScaleHigh \u003d highestValue;\n        yScaleHigh \u003d highestCount;\n    }\n\n    public void setScales(int xl, int xh, int yh)\n    {\n        xScaleLow \u003d xl;\n        xScaleHigh \u003d xh;\n        yScaleHigh \u003d yh;\n    }\n\n    public static GraphInternalBoundMatchedContainer getCounts(GraphInternalDataContainer data, int highestValue)\n    {\n        ArrayList\u003cInteger\u003e countedIntData \u003d new ArrayList\u003c\u003e();\n        ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e countedFullData \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c highestValue + 1; i++)\n        {\n            countedIntData.add(0);\n            countedFullData.add(new ArrayList\u003c\u003e());\n        }\n        for (int i \u003d 0; i \u003c data.intData.size(); i++)\n        {\n            if (countedIntData.size() \u003e data.intData.get(i) \u0026\u0026 data.intData.get(i) \u003e -1)\n            {\n                int incrementedValue \u003d countedIntData.get(data.intData.get(i)) + 1;\n                countedIntData.set(data.intData.get(i), incrementedValue);\n                countedFullData.get(data.intData.get(i)).add(data.fullData.get(i));\n            }\n        }\n        return new GraphInternalBoundMatchedContainer(countedFullData, countedIntData);\n    }\n\n    private int getAlternateYScale(GraphInternalBoundMatchedContainer sets)\n    {\n        int max \u003d 0;\n        for (int i \u003d 0; i \u003c sets.intData.size(); i++)\n        {\n            int partialSum \u003d 0;\n            for (int j \u003d i; j \u003c i + groupSize; j++)\n            {\n                if (j \u003c sets.intData.size())\n                {\n                    partialSum +\u003d sets.intData.get(j);\n                }\n            }\n            if (partialSum \u003e max)\n            {\n                max \u003d partialSum;\n            }\n        }\n        return max;\n    }\n\n    public void setBounds()\n    {\n        bounds.clear();\n        if (graphType \u003d\u003d 0)\n        {\n            GraphInternalDataContainer graphData \u003d getInternalDataSet(activeKey);\n            GraphInternalBoundMatchedContainer countedDataSet \u003d getCounts(graphData, xScaleHigh);\n            int highestCount \u003d (groupingEnabled) ? getAlternateYScale(countedDataSet) : yScaleHigh;\n            int firstGroupCount \u003d (groupOffset \u003d\u003d 0) ? groupSize : groupOffset;\n            int bars \u003d (groupingEnabled) ? ((int) (1 + Math.ceil(((double) (1 + xScaleHigh - firstGroupCount - xScaleLow)) / ((double) groupSize)))) : xScaleHigh - xScaleLow + 1;\n            int barWidth \u003d GRAPH_WIDTH / (bars);\n            int usedWidth \u003d barWidth * bars;\n            int startX \u003d GRAPH_XS + (GRAPH_WIDTH / 2) - (usedWidth / 2);\n            double scale \u003d (highestCount \u003d\u003d 0) ? (GRAPH_HEIGHT * .75) : ((GRAPH_HEIGHT * .75) / highestCount);\n\n            for (int i \u003d Math.max(0, xScaleLow); i \u003c xScaleHigh + 1; i++)\n            {\n                if (groupingEnabled)\n                {\n                    if ((i - xScaleLow) % groupSize \u003d\u003d groupOffset || i \u003d\u003d xScaleLow + groupOffset || i \u003d\u003d xScaleLow)\n                    {\n                        int barOffset \u003d 0;\n                        if (i !\u003d xScaleLow \u0026\u0026 groupOffset !\u003d 0)\n                        {\n                            barOffset \u003d 1;\n                        }\n                        int summedRegion \u003d (groupOffset \u003d\u003d 0 || i !\u003d xScaleLow) ? sumRegion(countedDataSet, i, groupSize) : sumRegion(countedDataSet, i - groupSize + groupOffset, groupSize);\n                        int height \u003d (int) (summedRegion * scale);\n                        int barsToDraw \u003d (i - Math.max(0, xScaleLow)) / groupSize;\n                        int left \u003d startX + ((barsToDraw + barOffset) * (barWidth));\n                        int right \u003d left + barWidth;\n                        int top \u003d GRAPH_HEIGHT - GRAPH_YS - height;\n                        int bottom \u003d GRAPH_HEIGHT - GRAPH_YS;\n                        ArrayList\u003cSimpleTOBData\u003e summedRegionData;\n                        if (groupOffset \u003d\u003d 0 || i !\u003d xScaleLow)\n                        {\n                            summedRegionData \u003d sumRegionRaidData(countedDataSet, i, groupSize);\n                        } else\n                        {\n                            summedRegionData \u003d sumRegionRaidData(countedDataSet, i - groupSize + groupOffset, groupSize);\n                        }\n                        bounds.add(new Bounds(left, right, bottom, top, summedRegionData));\n                    }\n                } else\n                {\n                    int height \u003d (int) (countedDataSet.intData.get(i) * scale);\n                    int left \u003d startX + ((i - xScaleLow) * (barWidth));\n                    int right \u003d left + barWidth;\n                    int top \u003d GRAPH_HEIGHT - GRAPH_YS - height;\n                    int bottom \u003d GRAPH_HEIGHT - GRAPH_YS;\n                    bounds.add(new Bounds(left, right, bottom, top, countedDataSet.fullData.get(i)));\n                }\n            }\n        }\n    }\n\n    public void setGroupingEnabled(boolean enabled)\n    {\n        groupingEnabled \u003d enabled;\n        setBounds();\n        drawGraph();\n    }\n\n    public void setGraphType(int type)\n    {\n        graphType \u003d type;\n        setBounds();\n        drawGraph();\n    }\n\n    public void updateGroupSize(int groupSize)\n    {\n        this.groupSize \u003d groupSize;\n        setBounds();\n        drawGraph();\n    }\n\n    public void updateGroupOffset(int groupOffset)\n    {\n        this.groupOffset \u003d groupOffset;\n        setBounds();\n        drawGraph();\n    }\n\n    private int sumRegion(GraphInternalBoundMatchedContainer data, int index, int length)\n    {\n        int sum \u003d 0;\n        for (int i \u003d index; i \u003c index + length; i++)\n        {\n            if (i \u003c data.intData.size() \u0026\u0026 i \u003e -1)\n            {\n                sum +\u003d data.intData.get(i);\n            }\n        }\n        return sum;\n    }\n\n    private ArrayList\u003cSimpleTOBData\u003e sumRegionRaidData(GraphInternalBoundMatchedContainer data, int index, int length)\n    {\n        ArrayList\u003cSimpleTOBData\u003e summedData \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d index; i \u003c index + length; i++)\n        {\n            if (i \u003c data.fullData.size() \u0026\u0026 i \u003e -1)\n            {\n                summedData.addAll(data.fullData.get(i));\n            }\n        }\n        return summedData;\n    }\n\n    private int groupSize \u003d 1;\n    private int groupOffset \u003d 0;\n\n    private void drawDragArea()\n    {\n        if (dragCurrentX !\u003d -1 \u0026\u0026 dragCurrentY !\u003d -1)\n        {\n            int startX \u003d Math.min(dragStartX, dragCurrentX);\n            int startY \u003d Math.min(dragStartY, dragCurrentY);\n            int endX \u003d Math.max(dragStartX, dragCurrentX);\n            int endY \u003d Math.max(dragStartY, dragCurrentY);\n            Graphics2D g \u003d (Graphics2D) img.getGraphics();\n            Color oldColor \u003d g.getColor();\n            g.setColor(new Color(200, 200, 100, 180));\n            g.drawRect(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY));\n            g.setColor(new Color(200, 200, 100, 70));\n            g.fillRect(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY));\n            g.setColor(oldColor);\n        }\n\n    }\n\n    private void drawToolTip()\n    {\n        if (shouldDrawToolTip \u0026\u0026 selectedBounds.isEmpty())\n        {\n            shouldDrawToolTip \u003d false;\n            Graphics2D g \u003d (Graphics2D) img.getGraphics();\n            Font oldFont \u003d g.getFont();\n            Color oldColor \u003d g.getColor();\n            g.setFont(new Font(\"SansSerif\", Font.PLAIN, 14));\n\n            int msgWidth \u003d g.getFontMetrics().stringWidth(activeToolTip.message);\n            int msgHeight \u003d g.getFontMetrics().getHeight();\n\n\n            int left \u003d activeToolTip.messageLeft - 5;\n            int bottom \u003d activeToolTip.messageBottom - msgHeight;\n\n            g.setColor(new Color(30, 30, 30, 255));\n            g.fillRect(activeToolTip.messageLeft - 5, activeToolTip.messageBottom - msgHeight, msgWidth + 10, msgHeight + 10);\n            g.setColor(new Color(100, 100, 100));\n            g.drawRect(left, bottom, msgWidth + 10, msgHeight + 10);\n            g.setColor(new Color(240, 240, 240));\n            g.drawString(activeToolTip.message, activeToolTip.messageLeft, activeToolTip.messageBottom);\n            g.setFont(oldFont);\n            g.setColor(oldColor);\n        }\n    }\n\n    public static ArrayList\u003cInteger\u003e filterInvalid(ArrayList\u003cInteger\u003e data)\n    {\n        ArrayList\u003cInteger\u003e filteredData \u003d new ArrayList\u003c\u003e();\n        for (Integer i : data)\n        {\n            if (i \u003e -1)\n            {\n                filteredData.add(i);\n            }\n        }\n        return filteredData;\n    }\n\n    public void drawGraphTitle(Graphics2D g, int totalCount)\n    {\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n        Font oldFont \u003d g.getFont();\n        Font font \u003d new Font(\"SansSerif\", Font.PLAIN, 14);\n        g.setFont(font);\n        String title \u003d activeKey.name + \" (Based on \" + totalCount + \" raids)\";\n        g.drawString(title, 300 - g.getFontMetrics().stringWidth(title) / 2, 16);\n        g.setFont(oldFont);\n    }\n\n    public void drawGraph()\n    {\n        Graphics2D g \u003d (Graphics2D) img.getGraphics();\n        Stroke oldStroke \u003d g.getStroke();\n\n        drawBlankPanel();\n        int lowestValue \u003d xScaleLow;\n        int highestValue \u003d xScaleHigh;\n        GraphInternalBoundMatchedContainer countedDataSet \u003d getCounts(getInternalDataSet(activeKey), highestValue);\n        int totalCount \u003d getCountedTotal(countedDataSet.intData);\n        drawGraphTitle(g, totalCount);\n        if (graphType \u003d\u003d 0)\n        {\n            drawBlankBarGraph();\n\n            int highestCount \u003d getAlternateYScale(countedDataSet);\n            int firstGroupCount \u003d (groupOffset \u003d\u003d 0) ? groupSize : groupOffset;\n            int bars \u003d ((int) (1 + Math.ceil(((double) (1 + xScaleHigh - firstGroupCount - xScaleLow)) / ((double) groupSize))));\n            int barWidth \u003d GRAPH_WIDTH / (bars);\n            if (barWidth \u003d\u003d 0)\n            {\n                barWidth \u003d 1;\n            }\n            int usedWidth \u003d barWidth * bars;\n            int startX \u003d GRAPH_XS + (GRAPH_WIDTH / 2) - (usedWidth / 2);\n            double scale \u003d ((highestCount \u003d\u003d 0) ? (GRAPH_HEIGHT * .75) : ((GRAPH_HEIGHT * .75) / (double) highestCount));\n            int horizontalScaleToUse \u003d (highestValue - lowestValue \u003e 100) ? 25 : (highestValue - lowestValue \u003e 50) ? 10 : (highestValue - lowestValue \u003e 10) ? 5 : 1;\n            if (barWidth \u003e 16)\n            {\n                horizontalScaleToUse \u003d 1;\n            }\n\n            int verticalScaleToUse \u003d (highestCount \u003e 250) ? 50 : (highestCount \u003e 100) ? 25 : (highestCount \u003e 50) ? 10 : (highestCount \u003e 10) ? 5 : 1;\n            if (groupingEnabled)\n            {\n\n                drawGraphVerticals(g, highestCount, scale, verticalScaleToUse);\n\n                for (int i \u003d Math.max(lowestValue, 0); i \u003c highestValue + 1; i++)\n                {\n                    if ((i - lowestValue) % groupSize \u003d\u003d groupOffset || i \u003d\u003d lowestValue + groupOffset || i \u003d\u003d lowestValue)\n                    {\n                        int barOffset \u003d 0;\n                        if (i !\u003d lowestValue \u0026\u0026 groupOffset !\u003d 0)\n                        {\n                            barOffset \u003d 1;\n                        }\n                        int currentBarCenter \u003d startX + (((i - Math.max(0, xScaleLow)) / groupSize) + barOffset) * (barWidth);\n                        int summedRegion \u003d (groupOffset \u003d\u003d 0 || i !\u003d lowestValue) ? sumRegion(countedDataSet, i, groupSize) : sumRegion(countedDataSet, i - groupSize + groupOffset, groupSize);\n                        int height \u003d (int) (summedRegion * scale);\n                        int stringOffset \u003d 16 + barWidth / 2 - 8;\n                        String axisValue \u003d \"\";\n                        if (i \u003d\u003d lowestValue || i \u003d\u003d highestValue || i % horizontalScaleToUse \u003d\u003d 0)\n                        {\n                            axisValue \u003d (i \u003d\u003d lowestValue \u0026\u0026 groupOffset !\u003d 0) ? getString(i - groupSize + groupOffset) : getString(i);\n                            if (groupSize !\u003d 1)\n                            {\n                                if (i !\u003d lowestValue || groupOffset \u003d\u003d 0)\n                                {\n                                    axisValue +\u003d \"-\" + getString(i + groupSize - 1);\n                                } else\n                                {\n                                    axisValue +\u003d \"-\" + getString(i);\n                                }\n                            }\n                            FontMetrics m \u003d g.getFontMetrics();\n                            int yOffset \u003d (int) (500 - GRAPH_HEIGHT - GRAPH_YS + 10 + (.5 * m.stringWidth(axisValue)));\n                            stringOffset -\u003d m.stringWidth(axisValue) - 5;\n                            drawStringRotated(g, axisValue, startX + stringOffset + ((((i - Math.max(0, xScaleLow)) / groupSize) + barOffset) * barWidth), yOffset);\n                        }\n                        drawBar(g, barWidth, height, currentBarCenter, summedRegion, totalCount, axisValue);\n                    }\n                }\n\n            } else\n            {\n                ArrayList\u003cInteger\u003e data \u003d filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));\n\n                ArrayList\u003cInteger\u003e intCountedDataSet \u003d getCounts(data, highestValue);\n                totalCount \u003d getCountedTotal(intCountedDataSet);\n\n                drawGraphVerticals(g, highestCount, scale, verticalScaleToUse);\n\n                for (int i \u003d Math.max(lowestValue, 0); i \u003c highestValue + 1; i++)\n                {\n                    int currentBarCenter \u003d startX + ((i - lowestValue) * (barWidth));\n                    int height \u003d (int) (intCountedDataSet.get(i) * scale);\n                    drawBar(g, barWidth, height, currentBarCenter, intCountedDataSet.get(i), totalCount, getString(i));\n                    int stringOffset \u003d 16 + barWidth / 2 - 8;\n                    if (i \u003d\u003d lowestValue || i \u003d\u003d highestValue || i % horizontalScaleToUse \u003d\u003d 0)\n                    {\n                        FontMetrics m \u003d g.getFontMetrics();\n                        int yOffset \u003d (int) (500 - GRAPH_HEIGHT - GRAPH_YS + 10 + (.5 * m.stringWidth(getString(i))));\n                        stringOffset -\u003d m.stringWidth(getString(i)) - 5;\n                        drawStringRotated(g, getString(i), startX + stringOffset + ((i - lowestValue) * barWidth), yOffset);\n                    }\n                }\n\n            }\n            drawToolTip();\n            drawDragArea();\n            g.setStroke(oldStroke);\n            g.dispose();\n            repaint();\n        } else if (graphType \u003d\u003d 1)\n        {\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n            ArrayList\u003cInteger\u003e data \u003d filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));\n\n            ArrayList\u003cInteger\u003e intCountedDataSet \u003d getCounts(data, highestValue);\n            totalCount \u003d getCountedTotal(intCountedDataSet);\n            int nonZeroCount \u003d getNonZeroCount(intCountedDataSet);\n            if (nonZeroCount \u003e 9)\n            {\n                g.setColor(Color.WHITE);\n                g.drawString(\"Cannot draw pie chart for this data due to too many values\", 50, 50);\n                return;\n            }\n            ArrayList\u003cPieChartData\u003e sortedData \u003d createSortedPieChartData(intCountedDataSet, totalCount);\n\n            int position \u003d 90;\n            for (int i \u003d 0; i \u003c sortedData.size(); i++)\n            {\n                Color c \u003d pieChartColors[i];\n                Color opacityAdjusted \u003d new Color(c.getRed(), c.getGreen(), c.getBlue(), 150);\n                g.setColor(opacityAdjusted);\n                g.fillArc(100, 30, 250, 250, position - sortedData.get(i).sections, sortedData.get(i).sections);\n                position -\u003d sortedData.get(i).sections;\n            }\n\n            //Draw Plot\n\n            int offset \u003d 50;\n            for (int i \u003d 0; i \u003c sortedData.size(); i++)\n            {\n                Color c \u003d pieChartColors[i];\n                Color opacityAdjusted \u003d new Color(c.getRed(), c.getGreen(), c.getBlue(), 150);\n                g.setColor(opacityAdjusted);\n                g.fillRect(375, offset, 50, 18);\n                g.setColor(Color.BLACK);\n                g.drawRect(375, offset, 50, 18);\n                g.setColor(new Color(200, 200, 200, 200));\n                Font oldFont \u003d g.getFont();\n                g.setFont(oldFont.deriveFont(18f));\n                g.drawString(getString(sortedData.get(i).value), 435, offset + 16);\n                g.setFont(oldFont);\n                offset +\u003d 28;\n            }\n\n        } else if (graphType \u003d\u003d 2)\n        {\n            drawBlankBarGraph();\n            int yMax \u003d 0;\n            int yMin \u003d Integer.MAX_VALUE;\n            ArrayList\u003cInteger\u003e data \u003d filterForTime(filterInvalid(getInternalDataSet(activeKey).intData));\n\n            ArrayList\u003cInteger\u003e intCountedDataSet \u003d getCounts(data, highestValue);\n            for (int i \u003d 0; i \u003c intCountedDataSet.size(); i++)\n            {\n                if (intCountedDataSet.get(i) !\u003d 0)\n                {\n                    if (i \u003c yMin)\n                    {\n                        yMin \u003d i;\n                    }\n                    if (i \u003e yMax)\n                    {\n                        yMax \u003d i;\n                    }\n                }\n            }\n            int horizontalScale \u003d GRAPH_WIDTH / (totalCount - 1);\n            int verticalScale \u003d 200 / (yMax - yMin);\n            g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\n            //draw horizontal lines\n            g.setColor(new Color(100, 100, 100, 150));\n            for (int i \u003d 0; i \u003c yMax - yMin; i++)\n            {\n                if (yMax - yMin \u003e 6)\n                {\n                    if (i % ((yMax - yMin) / 6) \u003d\u003d 0)\n                    {\n                        g.drawLine(GRAPH_XS, GRAPH_YE - (i * verticalScale), GRAPH_XE, GRAPH_YE - (i * verticalScale));\n\n                        Color oldColor \u003d g.getColor();\n                        g.setColor(new Color(200, 200, 200, 220));\n                        g.drawString(getString(i + yMin), GRAPH_XS - g.getFontMetrics().stringWidth(getString(i + yMin)) - 10, GRAPH_YE - (i * verticalScale));\n                        g.setColor(oldColor);\n                    }\n                } else\n                {\n                    g.drawLine(GRAPH_XS, GRAPH_YE - (i * verticalScale), GRAPH_XE, GRAPH_YE - (i * verticalScale));\n                }\n            }\n\n            g.setColor(new Color(120, 120, 240, 200));\n            for (int i \u003d 0; i \u003c data.size(); i++)\n            {\n                g.fillOval(GRAPH_XS + (i * horizontalScale) - 1, GRAPH_YE - ((data.get(i) - yMin) * verticalScale) - 2, 4, 4);\n                if (i !\u003d 0)\n                {\n                    int previousX \u003d GRAPH_XS + ((i - 1) * horizontalScale) + 1;\n                    int previousY \u003d GRAPH_YE - ((data.get(i - 1) - yMin) * verticalScale);\n                    g.drawLine(GRAPH_XS + (i * horizontalScale) + 1, GRAPH_YE - ((data.get(i) - yMin) * verticalScale), previousX, previousY);\n                }\n            }\n\n            //line plot\n        }\n    }\n\n    private void drawGraphVerticals(Graphics2D g, int highestCount, double scale, int verticalScaleToUse)\n    {\n        for (int i \u003d 0; i \u003c highestCount + 1; i++)\n        {\n            {\n                int stringOffset \u003d (int) (500 - GRAPH_HEIGHT - GRAPH_YS - scale * i + 8);\n                if (i \u003d\u003d 0 || i % verticalScaleToUse \u003d\u003d 0)\n                {\n                    Color oldColor \u003d g.getColor();\n                    g.setColor(new Color(100, 100, 100, 100));\n                    g.drawLine(GRAPH_XS, stringOffset - 8, GRAPH_XE, stringOffset - 8);\n                    g.setColor(oldColor);\n                    g.drawString(String.valueOf(i), GRAPH_XS - 20, stringOffset);\n                }\n            }\n        }\n    }\n\n    private ArrayList\u003cPieChartData\u003e createSortedPieChartData(ArrayList\u003cInteger\u003e data, int total)\n    {\n        ArrayList\u003cPieChartData\u003e fixedData \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c data.size(); i++)\n        {\n            if (data.get(i) !\u003d 0)\n            {\n                fixedData.add(new PieChartData(i, data.get(i), total));\n            }\n        }\n        fixedData.sort((o1, o2) -\u003e\n        {\n            if (Objects.equals(o1.occurrences, o2.occurrences))\n            {\n                return 0;\n            }\n            return o1.occurrences \u003e o2.occurrences ? -1 : 1;\n        });\n        return fixedData;\n    }\n\n    private int getNonZeroCount(ArrayList\u003cInteger\u003e data)\n    {\n        int count \u003d 0;\n        for (Integer i : data)\n        {\n            if (i !\u003d 0)\n            {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private GraphInternalDataContainer getInternalDataSet(DataPoint key)\n    {\n        ArrayList\u003cInteger\u003e intDataSet \u003d new ArrayList\u003c\u003e();\n        ArrayList\u003cSimpleTOBData\u003e fullDataSet \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData data : internalData)\n        {\n            if (data.getValue(key) !\u003d -1)\n            {\n                if (data.getTimeAccurate(key))\n                {\n                    intDataSet.add(data.getValue(key));\n                    fullDataSet.add(data);\n                }\n            }\n        }\n        return new GraphInternalDataContainer(fullDataSet, intDataSet);\n    }\n\n    private void drawGridLines()\n    {\n        Graphics g \u003d img.getGraphics();\n        g.setColor(gridColor);\n\n        g.drawLine(GRAPH_XS, GRAPH_YS, GRAPH_XE, GRAPH_YS);\n        g.drawLine(GRAPH_XS, GRAPH_YS, GRAPH_XS, GRAPH_YE);\n        g.drawLine(GRAPH_XS, GRAPH_YE, GRAPH_XE, GRAPH_YE);\n        g.drawLine(GRAPH_XE, GRAPH_YE, GRAPH_XE, GRAPH_YS);\n\n        g.dispose();\n    }\n\n    public void drawBlankPanel()\n    {\n        Graphics g \u003d img.getGraphics();\n        g.setColor(new Color(40, 40, 40));\n        g.fillRect(0, 0, img.getWidth(), img.getHeight());\n        g.dispose();\n\n        repaint();\n    }\n\n    public void drawBlankBarGraph()\n    {\n        drawGridLines();\n        repaint();\n    }\n\n    private boolean checkContains(Bounds bound)\n    {\n        for (Bounds b : selectedBounds)\n        {\n            if (b.getBottom() \u003d\u003d bound.getBottom() \u0026\u0026 b.getTop() \u003d\u003d bound.getTop() \u0026\u0026 b.getLeft() \u003d\u003d bound.getLeft() \u0026\u0026 b.getRight() \u003d\u003d bound.getRight())\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean currentlyDragging \u003d false;\n    private boolean boundActive \u003d false;\n    private int dragStartX \u003d -1;\n    private int dragStartY \u003d -1;\n    private int dragCurrentX \u003d -1;\n    private int dragCurrentY \u003d -1;\n\n    private Bounds getBound(int x, int y)\n    {\n        for (Bounds bound : bounds)\n        {\n            if (x \u003e\u003d bound.getLeft() \u0026\u0026 x \u003c\u003d bound.getRight() \u0026\u0026 y \u003c\u003d bound.getBottom() \u0026\u0026 y \u003e\u003d bound.getTop())\n            {\n                return bound;\n            }\n        }\n        return null;\n    }\n\n    private boolean checkOverlap(int left1, int top1, int right1, int bottom1, int left2, int top2, int right2, int bottom2)\n    {\n        int leftA \u003d Math.min(left1, right1);\n        int rightA \u003d Math.max(left1, right1);\n        int bottomA \u003d Math.min(top1, bottom1);\n        int topA \u003d Math.max(top1, bottom1);\n\n        int leftB \u003d Math.min(left2, right2);\n        int rightB \u003d Math.max(left2, right2);\n        int bottomB \u003d Math.min(top2, bottom2);\n        int topB \u003d Math.max(top2, bottom2);\n\n        return (leftA \u003c rightB \u0026\u0026 rightA \u003e leftB \u0026\u0026 topA \u003e bottomB \u0026\u0026 bottomA \u003c topB);\n    }\n\n    private void checkIntersectingBounds()\n    {\n        ArrayList\u003cBounds\u003e currentlyIntersecting \u003d new ArrayList\u003c\u003e();\n        for (Bounds b : bounds)\n        {\n            if (checkOverlap(dragStartX, dragStartY, dragCurrentX, dragCurrentY, b.getLeft(), b.getTop(), b.getRight(), b.getBottom()))\n            {\n                currentlyIntersecting.add(b);\n            }\n        }\n        selectedBounds.clear();\n        selectedBounds.addAll(currentlyIntersecting);\n    }\n\n    private boolean checkBounds(int x, int y)\n    {\n        for (Bounds bound : bounds)\n        {\n            if (x \u003e\u003d bound.getLeft() \u0026\u0026 x \u003c\u003d bound.getRight() \u0026\u0026 y \u003c\u003d bound.getBottom() \u0026\u0026 y \u003e\u003d bound.getTop())\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void checkBoundsAndHighlight(int x, int y)\n    {\n        for (Bounds bound : bounds)\n        {\n            if (x \u003e\u003d bound.getLeft() \u0026\u0026 x \u003c\u003d bound.getRight() \u0026\u0026 y \u003c\u003d bound.getBottom() \u0026\u0026 y \u003e\u003d bound.getTop())\n            {\n                if (!boundActive)\n                {\n                    requestFocusInWindow();\n                    activeBound \u003d new Bounds(bound.getLeft(), bound.getRight(), bound.getBottom(), bound.getTop(), bound.raids);\n                    boundActive \u003d true;\n                    drawGraph();\n                }\n\n            } else if (boundActive)\n            {\n                if (bound.matches(activeBound))\n                {\n                    activeBound.reset();\n                    boundActive \u003d false;\n                    drawGraph();\n                }\n            }\n        }\n    }\n\n    private ArrayList\u003cSimpleTOBData\u003e mergeSelectedData()\n    {\n        ArrayList\u003cSimpleTOBData\u003e mergedData \u003d new ArrayList\u003c\u003e();\n        for (Bounds b : selectedBounds)\n        {\n            mergedData.addAll(b.raids);\n        }\n        return mergedData;\n    }\n\n    @Override\n    public void mouseDragged(MouseEvent e)\n    {\n        if (e.isShiftDown() \u0026\u0026 currentlyDragging)\n        {\n            dragCurrentX \u003d e.getX();\n            dragCurrentY \u003d e.getY();\n            checkIntersectingBounds();\n            drawGraph();\n        }\n    }\n\n    @Override\n    public void mouseMoved(MouseEvent e)\n    {\n        checkBoundsAndHighlight(e.getX(), e.getY());\n    }\n\n    @Override\n    public void mouseClicked(MouseEvent e)\n    {\n        if (e.isShiftDown() \u0026\u0026 SwingUtilities.isLeftMouseButton(e) \u0026\u0026 selectedBounds.isEmpty())\n        {\n            if (checkBounds(e.getX(), e.getY()))\n            {\n                selectedBounds.add(getBound(e.getX(), e.getY()));\n                drawGraph();\n            }\n        } else if (e.isShiftDown() \u0026\u0026 SwingUtilities.isLeftMouseButton(e))\n        {\n            if (checkBounds(e.getX(), e.getY()))\n            {\n                Bounds lastBound \u003d selectedBounds.get(selectedBounds.size() - 1);\n                addAllBoundsBetween(lastBound, getBound(e.getX(), e.getY()));\n                drawGraph();\n            }\n        } else if (SwingUtilities.isLeftMouseButton(e) \u0026\u0026 !e.isControlDown())\n        {\n            selectedBounds.clear();\n            if (checkBounds(e.getX(), e.getY()))\n            {\n                selectedBounds.add(getBound(e.getX(), e.getY()));\n\n                drawGraph();\n            }\n        }\n    }\n\n    private void addAllBoundsBetween(Bounds lastBound, Bounds bound)\n    {\n        for (Bounds b : bounds)\n        {\n            if ((b.getLeft() \u003e lastBound.getLeft() \u0026\u0026 b.getLeft() \u003c bound.getLeft()) || (b.getLeft() \u003c lastBound.getLeft() \u0026\u0026 b.getLeft() \u003e bound.getLeft()))\n            {\n                if (!checkContains(b))\n                {\n                    selectedBounds.add(b);\n                }\n            }\n        }\n        selectedBounds.add(bound);\n    }\n\n    @Override\n    public void mousePressed(MouseEvent e)\n    {\n        if (SwingUtilities.isRightMouseButton(e))\n        {\n            if (selectedBounds.isEmpty())\n            {\n                for (Bounds bound : bounds)\n                {\n                    if (e.getX() \u003e\u003d bound.getLeft() \u0026\u0026 e.getX() \u003c\u003d bound.getRight() \u0026\u0026 e.getY() \u003c\u003d bound.getBottom() \u0026\u0026 e.getY() \u003e\u003d bound.getTop())\n                    {\n                        GraphRightClickContextMenu menu \u003d new GraphRightClickContextMenu(bound.raids, config, itemManager, clientThread, configManager);\n                        menu.show(e.getComponent(), e.getX(), e.getY());\n                    }\n                }\n            } else\n            {\n                GraphRightClickContextMenu menu \u003d new GraphRightClickContextMenu(mergeSelectedData(), config, itemManager, clientThread, configManager);\n                menu.show(e.getComponent(), e.getX(), e.getY());\n            }\n        }\n        if (SwingUtilities.isLeftMouseButton(e) \u0026\u0026 e.isShiftDown())\n        {\n            if (!currentlyDragging)\n            {\n                dragStartX \u003d e.getX();\n                dragStartY \u003d e.getY();\n                currentlyDragging \u003d true;\n            }\n        }\n        if (SwingUtilities.isLeftMouseButton(e) \u0026\u0026 e.isControlDown())\n        {\n            if (checkBounds(e.getX(), e.getY()))\n            {\n                Bounds clicked \u003d getBound(e.getX(), e.getY());\n                if (checkContains(clicked) \u0026\u0026 clicked !\u003d null)\n                {\n                    selectedBounds.removeIf(b -\u003e (b.getLeft() \u003d\u003d clicked.getLeft() \u0026\u0026 b.getRight() \u003d\u003d clicked.getRight() \u0026\u0026 b.getTop() \u003d\u003d clicked.getTop() \u0026\u0026 b.getBottom() \u003d\u003d clicked.getBottom()));\n                } else\n                {\n                    selectedBounds.add(getBound(e.getX(), e.getY()));\n                }\n                drawGraph();\n            }\n        }\n        if (SwingUtilities.isLeftMouseButton(e))\n        {\n            if (!checkBounds(e.getX(), e.getY()))\n            {\n                selectedBounds.clear();\n                drawGraph();\n            }\n        }\n    }\n\n    @Override\n    public void mouseReleased(MouseEvent e)\n    {\n        if (SwingUtilities.isLeftMouseButton(e))\n        {\n            if (currentlyDragging)\n            {\n                currentlyDragging \u003d false;\n                dragStartX \u003d -1;\n                dragStartY \u003d -1;\n                dragCurrentX \u003d -1;\n                dragCurrentY \u003d -1;\n                drawGraph();\n            }\n        }\n    }\n\n    @Override\n    public void mouseEntered(MouseEvent e)\n    {\n\n    }\n\n    @Override\n    public void mouseExited(MouseEvent e)\n    {\n\n    }\n\n    @Override\n    public void keyTyped(KeyEvent e)\n    {\n\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e)\n    {\n        if (e.isShiftDown())\n        {\n            setCursor(Cursor.getPredefinedCursor(Cursor.CROSSHAIR_CURSOR));\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e)\n    {\n        if (!e.isShiftDown())\n        {\n            setCursor(Cursor.getDefaultCursor());\n            if (currentlyDragging)\n            {\n                currentlyDragging \u003d false;\n                dragStartX \u003d -1;\n                dragStartY \u003d -1;\n                dragCurrentX \u003d -1;\n                dragCurrentY \u003d -1;\n                drawGraph();\n            }\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\GraphPanel.java"},{"fileName":"GraphRightClickContextMenu.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.ui.Raids;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport java.util.ArrayList;\n\n@Slf4j\npublic class GraphRightClickContextMenu extends JPopupMenu\n{\n    JMenuItem item;\n\n    public GraphRightClickContextMenu(ArrayList\u003cSimpleTOBData\u003e raids, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        item \u003d new JMenuItem(\"Show Represented Raids In New Window\");\n        item.addActionListener(al -\u003e\n        {\n            Raids raidFrame \u003d new Raids(config, itemManager, clientThread, configManager);\n            raidFrame.createFrame(raids);\n            raidFrame.repaint();\n            raidFrame.open();\n        });\n        add(item);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\GraphRightClickContextMenu.java"},{"fileName":"PieChartData.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\npublic class PieChartData\n{\n    public int value;\n    public int occurrences;\n    public int sections;\n\n    public PieChartData(int value, int occurrences, int total)\n    {\n        this.value \u003d value;\n        this.occurrences \u003d occurrences;\n        double percent \u003d (double) occurrences / total;\n        this.sections \u003d (int) (percent * 360);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\PieChartData.java"},{"fileName":"ToolTipData.java","content":"package com.advancedraidtracker.ui.comparisonview.graph;\n\npublic class ToolTipData\n{\n    public int messageLeft;\n    public int messageBottom;\n    public String message;\n\n    public ToolTipData(int ml, int mb, String msg)\n    {\n        messageLeft \u003d ml;\n        messageBottom \u003d mb;\n        message \u003d msg;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\graph\\ToolTipData.java"},{"fileName":"NoDataPopUp.java","content":"package com.advancedraidtracker.ui.comparisonview;\n\nimport com.advancedraidtracker.ui.BaseFrame;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class NoDataPopUp extends BaseFrame\n{\n    public NoDataPopUp()\n    {\n        setTitle(\"No Data\");\n        JPanel container \u003d new JPanel();\n        container.add(new JLabel(\"No data to compare. Add a data set by selecting raids in the table and using the right click context menu -\u003e \\\"Add set to comparison\\\"\\\"\"));\n        JButton okButton \u003d new JButton(\"Ok\");\n        okButton.addActionListener(e -\u003e\n        {\n            close();\n            rootPane.setVisible(false);\n        });\n        container.add(okButton);\n        setPreferredSize(new Dimension(800, 100));\n        add(container);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\comparisonview\\NoDataPopUp.java"},{"fileName":"CrabLeakInfo.java","content":"package com.advancedraidtracker.ui.crableaks;\n\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.wrappers.StringInt;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class CrabLeakInfo extends BaseFrame\n{\n\n    public CrabLeakInfo(ArrayList\u003cArrayList\u003cStringInt\u003e\u003e crabs)\n    {\n        JPanel primary \u003d new JPanel();\n        Map\u003cString, Integer\u003e crabLeakSums \u003d new LinkedHashMap\u003c\u003e();\n        primary.setBorder(BorderFactory.createTitledBorder(\"Crab Leak Info (Based on \" + crabs.size() + \" Raids)\"));\n        for (ArrayList\u003cStringInt\u003e crabData : crabs)\n        {\n            for (StringInt crab : crabData)\n            {\n                if (crabLeakSums.containsKey(crab.string))\n                {\n                    crabLeakSums.put(crab.string, crabLeakSums.get(crab.string) + crab.val);\n                } else\n                {\n                    crabLeakSums.put(crab.string, crab.val);\n                }\n            }\n        }\n\n        primary.setLayout(new GridLayout(1, 0, 2, 2));\n\n        JPanel panel70s \u003d new JPanel();\n        JPanel panel50s \u003d new JPanel();\n        JPanel panel30s \u003d new JPanel();\n        panel70s.setLayout(new GridLayout(0, 2, 2, 2));\n        panel50s.setLayout(new GridLayout(0, 2, 2, 2));\n        panel30s.setLayout(new GridLayout(0, 2, 2, 2));\n        panel70s.setBorder(BorderFactory.createTitledBorder(\"70s\"));\n        panel50s.setBorder(BorderFactory.createTitledBorder(\"50s\"));\n        panel30s.setBorder(BorderFactory.createTitledBorder(\"30s\"));\n\n        Color color \u003d new Color(30, 30, 30);\n        for (int i \u003d 0; i \u003c 3; i++)\n        {\n            JLabel test \u003d new JLabel(\"Crab\");\n            test.setOpaque(true);\n            test.setBackground(Color.BLACK);\n\n            JLabel test2 \u003d new JLabel(\"Average HP\", SwingConstants.RIGHT);\n            test2.setOpaque(true);\n            test2.setBackground(Color.BLACK);\n\n            JPanel currentPanel \u003d (i \u003d\u003d 0) ? panel70s : (i \u003d\u003d 1) ? panel50s : panel30s;\n\n            currentPanel.add(test);\n            currentPanel.add(test2);\n            for (int j \u003d 0; j \u003c 10; j++)\n            {\n                int averageTemp \u003d 0;\n                String crabDescription \u003d RoomUtil.MAIDEN_CRAB_NAMES[(i * 10) + j];\n                try\n                {\n                    averageTemp \u003d (int) ((crabLeakSums.get(RoomUtil.MAIDEN_CRAB_NAMES[(i * 10) + j]) / (double) crabs.size()) * 100);\n                } catch (Exception ignored)\n                {\n\n                }\n                double average \u003d averageTemp / 100.0;\n\n                JLabel desc \u003d new JLabel(crabDescription, SwingConstants.LEFT);\n                JLabel avg \u003d new JLabel(String.valueOf(average), SwingConstants.RIGHT);\n\n                if (j % 2 \u003d\u003d 0)\n                {\n                    desc.setOpaque(true);\n                    avg.setOpaque(true);\n                    avg.setBackground(color);\n                    desc.setBackground(color);\n                }\n                currentPanel.add(desc);\n                currentPanel.add(avg);\n            }\n        }\n        primary.add(panel70s);\n        primary.add(panel50s);\n        primary.add(panel30s);\n\n        add(primary);\n        pack();\n        open();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\crableaks\\CrabLeakInfo.java"},{"fileName":"SaveRaids.java","content":"package com.advancedraidtracker.ui.exportraids;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.ui.filters.ConfirmationDialog;\nimport com.advancedraidtracker.utility.datautility.RaidsManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class SaveRaids extends BaseFrame\n{\n    private final JTextField field;\n\n    public SaveRaids(ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        getContentPane().removeAll();\n        setTitle(\"Save Raids\");\n        JPanel borderPanel \u003d new JPanel(new BorderLayout());\n        borderPanel.setBorder(BorderFactory.createTitledBorder(\"Save Raids\"));\n        JPanel subPanel \u003d new JPanel();\n        subPanel.setLayout(new GridLayout(1, 4));\n        field \u003d new JTextField();\n        subPanel.add(new JLabel(\"Raids Name: \"));\n        subPanel.add(field);\n        JButton saveButton \u003d getSaveButton(raids);\n        subPanel.add(saveButton);\n        borderPanel.add(subPanel);\n        add(borderPanel);\n        pack();\n        setLocationRelativeTo(null);\n        repaint();\n    }\n\n    private JButton getSaveButton(ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        JButton saveButton \u003d new JButton(\"Save\");\n        saveButton.addActionListener(e -\u003e\n        {\n            if (RaidsManager.doesRaidExist(field.getText()))\n            {\n                ConfirmationDialog dialog \u003d new ConfirmationDialog(field.getText(), raids, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())), 1);\n                dialog.open();\n            } else\n            {\n                RaidsManager.saveRaids(field.getText(), raids);\n                close();\n            }\n        });\n        return saveButton;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\exportraids\\SaveRaids.java"},{"fileName":"ConfirmationDialog.java","content":"package com.advancedraidtracker.ui.filters;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.filters.ImplicitFilter;\nimport com.advancedraidtracker.filters.FilterManager;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.utility.datautility.RaidsManager;\n\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class ConfirmationDialog extends BaseFrame\n{\n    public ConfirmationDialog(String filterName, ArrayList\u003cImplicitFilter\u003e filters, JFrame root)\n    {\n        setTitle(\"Confirm\");\n        JPanel panelButtons \u003d new JPanel(new GridLayout(1, 2));\n        setLayout(new GridLayout(2, 1));\n        add(new JLabel(\"Are you sure you want to overwrite filter \" + filterName + \"?\"));\n        JButton yesButton \u003d new JButton(\"Yes\");\n        yesButton.addActionListener(e -\u003e\n        {\n            FilterManager.saveOverwriteFilter(filterName, filters);\n            close();\n            root.setVisible(false);\n        });\n        JButton noButton \u003d new JButton(\"No\");\n        noButton.addActionListener(e -\u003e close());\n        panelButtons.add(yesButton);\n        panelButtons.add(noButton);\n        add(panelButtons);\n        pack();\n        setLocationRelativeTo(null);\n    }\n\n    public ConfirmationDialog(String raidsName, ArrayList\u003cSimpleTOBData\u003e raids, JFrame root, int mark)\n    {\n        setTitle(\"Confirm\");\n        JPanel panelButtons \u003d new JPanel(new GridLayout(1, 2));\n        setLayout(new GridLayout(2, 1));\n        add(new JLabel(\"Are you sure you want to overwrite raids \" + raidsName + \"?\"));\n        JButton yesButton \u003d new JButton(\"Yes\");\n        yesButton.addActionListener(e -\u003e\n        {\n            RaidsManager.saveOverwriteRaids(raidsName, raids);\n            close();\n            root.setVisible(false);\n        });\n        JButton noButton \u003d new JButton(\"No\");\n        noButton.addActionListener(e -\u003e close());\n        panelButtons.add(yesButton);\n        panelButtons.add(noButton);\n        add(panelButtons);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\filters\\ConfirmationDialog.java"},{"fileName":"LoadFilter.java","content":"package com.advancedraidtracker.ui.filters;\n\nimport com.advancedraidtracker.ui.buttons.ButtonEditorLoadFilters;\nimport com.advancedraidtracker.ui.buttons.ButtonEditorViewFilters;\nimport com.advancedraidtracker.ui.buttons.ButtonRenderer;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.ui.Raids;\nimport com.advancedraidtracker.ui.buttons.NonEditableCell;\nimport lombok.extern.slf4j.Slf4j;\nimport com.advancedraidtracker.filters.Filter;\nimport com.advancedraidtracker.filters.FilterManager;\n\nimport javax.swing.*;\nimport javax.swing.table.TableCellRenderer;\nimport javax.swing.table.TableColumnModel;\nimport java.awt.*;\nimport java.util.ArrayList;\n\n@Slf4j\npublic class LoadFilter extends BaseFrame\n{\n    public void resizeColumnWidth(JTable table)\n    {\n        final TableColumnModel columnModel \u003d table.getColumnModel();\n        for (int column \u003d 0; column \u003c table.getColumnCount(); column++)\n        {\n            int width \u003d 30; // Min width\n            for (int row \u003d 0; row \u003c table.getRowCount(); row++)\n            {\n                TableCellRenderer renderer \u003d table.getCellRenderer(row, column);\n                Component comp \u003d table.prepareRenderer(renderer, row, column);\n                width \u003d Math.max(comp.getPreferredSize().width + 1, width);\n            }\n            if (width \u003e 400)\n            {\n                width \u003d 400;\n            }\n            columnModel.getColumn(column).setPreferredWidth(width);\n        }\n    }\n\n    public LoadFilter(Raids FilteredRaidsFrame)\n    {\n        setTitle(\"Load Filters\");\n        JPanel mainPanel \u003d new JPanel(new BorderLayout());\n        mainPanel.setBorder(BorderFactory.createTitledBorder(\"Filters\"));\n\n        String[] columnNames \u003d {\"Filter Name\", \"View\", \"Replace\", \"Add\"};\n        ArrayList\u003cObject[]\u003e tableBuilder \u003d new ArrayList\u003c\u003e();\n\n        ArrayList\u003cFilter\u003e filters \u003d FilterManager.getFilters();\n        for (Filter filter : filters)\n        {\n            Object[] row \u003d\n                    {\n                            filter.getName(),\n                            \"View Filter\",\n                            \"Replace Active\",\n                            \"Add to Active\"\n                    };\n            tableBuilder.add(row);\n        }\n        Object[][] tableObject \u003d new Object[filters.size()][4];\n        int count \u003d 0;\n        for (Object[] row : tableBuilder)\n        {\n            tableObject[count] \u003d row;\n            count++;\n        }\n        JPanel container \u003d new JPanel();\n        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));\n        JTable table \u003d new JTable(tableObject, columnNames);\n        table.getColumn(\"Filter Name\").setCellEditor(new NonEditableCell(new JTextField()));\n\n        table.getColumn(\"View\").setCellRenderer(new ButtonRenderer());\n        table.getColumn(\"View\").setCellEditor(new ButtonEditorViewFilters(new JCheckBox(), filters));\n\n        table.getColumn(\"Replace\").setCellRenderer(new ButtonRenderer());\n        table.getColumn(\"Replace\").setCellEditor(new ButtonEditorLoadFilters(new JCheckBox(), FilteredRaidsFrame, filters, this));\n\n        table.getColumn(\"Add\").setCellRenderer(new ButtonRenderer());\n        table.getColumn(\"Add\").setCellEditor(new ButtonEditorLoadFilters(new JCheckBox(), FilteredRaidsFrame, filters, this, false));\n\n        resizeColumnWidth(table);\n        JScrollPane pane \u003d new JScrollPane(table);\n        table.setFillsViewportHeight(true);\n        mainPanel.add(pane);\n        add(mainPanel);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\filters\\LoadFilter.java"},{"fileName":"SaveFilter.java","content":"package com.advancedraidtracker.ui.filters;\n\nimport com.advancedraidtracker.filters.ImplicitFilter;\nimport com.advancedraidtracker.filters.FilterManager;\nimport com.advancedraidtracker.ui.BaseFrame;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class SaveFilter extends BaseFrame\n{\n    private final JTextField field;\n\n    public SaveFilter(ArrayList\u003cImplicitFilter\u003e filters, ArrayList\u003cString\u003e quickFiltersState)\n    {\n        getContentPane().removeAll();\n        setTitle(\"Save Filter\");\n        JPanel borderPanel \u003d new JPanel(new BorderLayout());\n        borderPanel.setBorder(BorderFactory.createTitledBorder(\"Save Filter\"));\n        JPanel subPanel \u003d new JPanel();\n        subPanel.setLayout(new GridLayout(1, 0));\n        field \u003d new JTextField();\n        subPanel.add(new JLabel(\"Filter Name: \"));\n        subPanel.add(field);\n        JButton saveButton \u003d getSaveButton(filters, quickFiltersState);\n        subPanel.add(saveButton);\n        JButton saveButtonStrict \u003d getSaveButton(filters);\n        subPanel.add(saveButtonStrict);\n        borderPanel.add(subPanel);\n        add(borderPanel);\n        pack();\n        setLocationRelativeTo(null);\n        repaint();\n    }\n\n    private JButton getSaveButton(ArrayList\u003cImplicitFilter\u003e filters)\n    {\n        JButton saveButton \u003d new JButton(\"Save just filter\");\n        saveButton.addActionListener(e -\u003e\n        {\n            if (FilterManager.doesFilterExist(field.getText()))\n            {\n                ConfirmationDialog dialog \u003d new ConfirmationDialog(field.getText(), filters, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())));\n                dialog.open();\n            } else\n            {\n                FilterManager.saveFilter(field.getText(), filters);\n                close();\n            }\n        });\n        return saveButton;\n    }\n\n    private JButton getSaveButton(ArrayList\u003cImplicitFilter\u003e filters, ArrayList\u003cString\u003e quickFiltersState)\n    {\n        JButton saveButton \u003d new JButton(\"Save with quick filters\");\n        saveButton.addActionListener(e -\u003e\n        {\n            if (FilterManager.doesFilterExist(field.getText()))\n            {\n                ConfirmationDialog dialog \u003d new ConfirmationDialog(field.getText(), filters, (JFrame) (SwingUtilities.getRoot((Component) e.getSource())));\n                dialog.open();\n            } else\n            {\n                FilterManager.saveFilter(field.getText(), filters, quickFiltersState);\n                close();\n            }\n        });\n        return saveButton;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\filters\\SaveFilter.java"},{"fileName":"ViewFilter.java","content":"package com.advancedraidtracker.ui.filters;\n\nimport com.advancedraidtracker.ui.BaseFrame;\nimport lombok.extern.slf4j.Slf4j;\nimport com.advancedraidtracker.filters.Filter;\n\nimport javax.swing.*;\nimport java.awt.*;\n\n@Slf4j\npublic class ViewFilter extends BaseFrame\n{\n    public ViewFilter(Filter filter)\n    {\n        setTitle(\"View Filter\");\n        setPreferredSize(new Dimension(300, 300));\n        JPanel mainPanel \u003d new JPanel();\n        mainPanel.setLayout(new BorderLayout());\n        mainPanel.setBorder(BorderFactory.createTitledBorder(\"Filter Details\"));\n        JPanel pane \u003d new JPanel();\n        pane.setLayout(new GridLayout(10, 1));\n        for (String s : filter.getFilters())\n        {\n            String[] splitString \u003d s.split(\"-\");\n            if (splitString.length !\u003d 0)\n            {\n                JLabel label \u003d new JLabel(splitString[splitString.length - 1]);\n                pane.add(label);\n            }\n        }\n        mainPanel.add(pane);\n        add(mainPanel);\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\filters\\ViewFilter.java"},{"fileName":"Raids.java","content":"package com.advancedraidtracker.ui;\n\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.filters.*;\nimport com.advancedraidtracker.ui.buttons.*;\nimport com.advancedraidtracker.ui.charts.ChartFrame;\nimport com.advancedraidtracker.ui.comparisonview.ComparisonViewFrame;\nimport com.advancedraidtracker.ui.comparisonview.ComparisonViewPanel;\nimport com.advancedraidtracker.ui.comparisonview.NoDataPopUp;\nimport com.advancedraidtracker.ui.crableaks.CrabLeakInfo;\nimport com.advancedraidtracker.ui.exportraids.SaveRaids;\nimport com.advancedraidtracker.ui.filters.LoadFilter;\nimport com.advancedraidtracker.ui.filters.SaveFilter;\nimport com.advancedraidtracker.ui.statistics.StatisticTab;\nimport com.advancedraidtracker.utility.*;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport com.advancedraidtracker.utility.datautility.DataWriter;\nimport com.advancedraidtracker.utility.wrappers.PlayerCorrelatedPointData;\nimport com.advancedraidtracker.utility.wrappers.StringInt;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\n\nimport javax.swing.*;\nimport javax.swing.border.MatteBorder;\nimport javax.swing.event.DocumentEvent;\nimport javax.swing.event.DocumentListener;\nimport javax.swing.table.DefaultTableModel;\nimport javax.swing.table.TableCellRenderer;\nimport javax.swing.table.TableColumnModel;\nimport javax.swing.text.BadLocationException;\nimport java.awt.*;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.util.*;\nimport java.util.List;\n\nimport static com.advancedraidtracker.utility.UISwingUtility.*;\n\n@Slf4j\npublic class Raids extends BaseFrame\n{\n    private final ArrayList\u003cInteger\u003e filteredIndices;\n    private JTable comparisonTable;\n    private final ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e comparisons;\n\n    private final JTabbedPane tabbedPane \u003d new JTabbedPane();\n    public ArrayList\u003cImplicitFilter\u003e activeFilters;\n    private final JLabel raidsFoundLabel \u003d new JLabel(\"\", SwingConstants.LEFT);\n    private final JLabel completionsFound \u003d new JLabel(\"\", SwingConstants.LEFT);\n    private JComboBox\u003cString\u003e viewByRaidComboBox;\n\n    private JComboBox\u003cString\u003e sortOrderBox;\n    private JComboBox\u003cString\u003e sortOptionsBox;\n\n    Map\u003cString, JLabel\u003e averageLabels \u003d new LinkedHashMap\u003c\u003e();\n    Map\u003cString, JLabel\u003e medianLabels \u003d new LinkedHashMap\u003c\u003e();\n    Map\u003cString, JLabel\u003e minLabels \u003d new LinkedHashMap\u003c\u003e();\n    Map\u003cString, JLabel\u003e maxLabels \u003d new LinkedHashMap\u003c\u003e();\n    public JComboBox\u003cString\u003e statisticsBox;\n    public JLabel customAverageLabel \u003d new JLabel(\"\", SwingConstants.RIGHT);\n    public JLabel customMedianLabel \u003d new JLabel(\"\", SwingConstants.RIGHT);\n    public JLabel customModeLabel \u003d new JLabel(\"\", SwingConstants.RIGHT);\n    public JLabel customMinLabel \u003d new JLabel(\"\", SwingConstants.RIGHT);\n    public JLabel customMaxLabel \u003d new JLabel(\"\", SwingConstants.RIGHT);\n\n    private final ArrayList\u003cMap\u003cString, ArrayList\u003cString\u003e\u003e\u003e aliases;\n\n    private final JTextArea aliasText;\n\n    JTextField dateTextField;\n    JCheckBox filterSpectateOnly;\n    JCheckBox filterInRaidOnly;\n    JCheckBox filterCompletionOnly;\n    JCheckBox filterWipeResetOnly;\n    JComboBox\u003cString\u003e filterComboBoxScale;\n    JCheckBox filterCheckBoxScale;\n    JCheckBox filterTodayOnly;\n    JCheckBox filterPartyOnly;\n    JCheckBox filterPartialData;\n    JCheckBox filterPartialOnly;\n    JCheckBox filterNormalOnly;\n    JTable table;\n    JPanel container;\n    private JPanel filterTableContainer;\n    public ArrayList\u003cSimpleTOBData\u003e currentData;\n    private JComboBox\u003cString\u003e timeFilterChoice;\n    private JComboBox\u003cString\u003e timeFilterOperator;\n    private JTextField timeFilterValue;\n    private JTable filterTable;\n    private JComboBox\u003cString\u003e playerFilterOperator;\n    private JTextField playerFilterValue;\n    private JCheckBox timeFollowsTab;\n    private StatisticTab maidenTab;\n    private StatisticTab bloatTab;\n    private StatisticTab nyloTab;\n    private StatisticTab soteTab;\n    private StatisticTab xarpTab;\n    private StatisticTab verzikTab;\n    private boolean built \u003d false;\n    private JComboBox\u003cString\u003e dateFilterOperator;\n    private JComboBox\u003cString\u003e otherIntFilterChoice;\n    private JComboBox\u003cString\u003e otherIntFilterOperator;\n    private JTextField otherIntFilterValue;\n    private JComboBox\u003cString\u003e otherBoolFilterChoice;\n    private JComboBox\u003cString\u003e otherBoolFilterOperator;\n\n\n    private final AdvancedRaidTrackerConfig config;\n    private final ItemManager itemManager;\n    private final ClientThread clientThread;\n\n    public String[] rooms \u003d {\"Maiden\", \"Bloat\",\"Nylocas\",\"Sotetseg\",\"Xarpus\",\"Verzik\",\"Challenge\"};\n    private final ConfigManager configManager;\n\n    public Raids(AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        for(String s : rooms)\n        {\n            averageLabels.put(s, getDarkJLabel(\"\", SwingConstants.RIGHT));\n            medianLabels.put(s, getDarkJLabel(\"\", SwingConstants.RIGHT));\n            minLabels.put(s, getDarkJLabel(\"\", SwingConstants.RIGHT));\n            maxLabels.put(s, getDarkJLabel(\"\", SwingConstants.RIGHT));\n        }\n        this.clientThread \u003d clientThread;\n        this.itemManager \u003d itemManager;\n        this.configManager \u003d configManager;\n        columnHeaders \u003d new ArrayList\u003c\u003e();\n        for (String s : columnHeaderNames)\n        {\n            columnHeaders.add(getCheckBoxMenuItem(s));\n        }\n        aliases \u003d new ArrayList\u003c\u003e();\n        filteredIndices \u003d new ArrayList\u003c\u003e();\n        comparisons \u003d new ArrayList\u003c\u003e();\n        activeFilters \u003d new ArrayList\u003c\u003e();\n        aliasText \u003d new JTextArea();\n        this.config \u003d config;\n        this.setPreferredSize(new Dimension(1200, 820));\n    }\n\n    public void updateCustomStats(ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        DataPoint dataPoint \u003d DataPoint.ATTEMPTED_BGS_BLOAT;\n        boolean time \u003d dataPoint.type \u003d\u003d DataPoint.types.TIME;\n\n        double avg \u003d StatisticGatherer.getGenericAverage(raids, dataPoint);\n        double med \u003d StatisticGatherer.getGenericMedian(raids, dataPoint);\n        double mod \u003d StatisticGatherer.getGenericMode(raids, dataPoint);\n        double min \u003d StatisticGatherer.getGenericMin(raids, dataPoint);\n        double max \u003d StatisticGatherer.getGenericMax(raids, dataPoint);\n\n        String avgStr \u003d (time) ? RoomUtil.time(avg) : String.valueOf(avg);\n        String medStr \u003d (time) ? RoomUtil.time(med) : String.valueOf(med);\n        String modStr \u003d (time) ? RoomUtil.time(mod) : String.valueOf(mod);\n        String minStr \u003d (time) ? RoomUtil.time(min) : String.valueOf(min);\n        String maxStr \u003d (time) ? RoomUtil.time(max) : String.valueOf(max);\n\n        if (avg \u003d\u003d -1) avgStr \u003d \"-\";\n        if (med \u003d\u003d -1) medStr \u003d \"-\";\n        if (mod \u003d\u003d -1) modStr \u003d \"-\";\n        if (min \u003d\u003d -1) minStr \u003d \"-\";\n        if (max \u003d\u003d -1) maxStr \u003d \"-\";\n\n        customAverageLabel.setText(avgStr);\n        customMedianLabel.setText(medStr);\n        customModeLabel.setText(modStr);\n        customMinLabel.setText(minStr);\n        customMaxLabel.setText(maxStr);\n    }\n\n    private boolean evaluateAllFilters(SimpleTOBData data)\n    {\n        for (ImplicitFilter filter : activeFilters)\n        {\n            if (!filter.evaluate(data))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void updateTable()\n    {\n        int completions \u003d 0;\n        ArrayList\u003cSimpleTOBData\u003e tableData \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData data : currentData)\n        {\n            boolean shouldDataBeIncluded \u003d true;\n            if (filterSpectateOnly.isSelected())\n            {\n                if (!data.spectated)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterInRaidOnly.isSelected())\n            {\n                if (data.spectated)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterCompletionOnly.isSelected())\n            {\n                if (!data.raidCompleted || !data.getOverallTimeAccurate())\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterWipeResetOnly.isSelected())\n            {\n                if (data.raidCompleted)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterPartialData.isSelected())\n            {\n                if (!(data.maidenStartAccurate \u003d\u003d data.maidenEndAccurate \u0026\u0026\n                        data.bloatStartAccurate \u003d\u003d data.bloatEndAccurate \u0026\u0026\n                        data.nyloStartAccurate \u003d\u003d data.nyloEndAccurate \u0026\u0026\n                        data.soteStartAccurate \u003d\u003d data.soteEndAccurate \u0026\u0026\n                        data.xarpStartAccurate \u003d\u003d data.xarpEndAccurate \u0026\u0026\n                        data.verzikStartAccurate \u003d\u003d data.verzikEndAccurate))\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (shouldDataBeIncluded \u0026\u0026 filterTodayOnly.isSelected())\n            {\n                shouldDataBeIncluded \u003d false;\n                Calendar cal1 \u003d Calendar.getInstance();\n                Calendar cal2 \u003d Calendar.getInstance();\n                cal1.setTime(data.raidStarted);\n                cal2.setTime(new Date(System.currentTimeMillis()));\n                if (cal1.get(Calendar.MONTH) \u003d\u003d cal2.get(Calendar.MONTH) \u0026\u0026 cal1.get(Calendar.YEAR) \u003d\u003d cal2.get(Calendar.YEAR) \u0026\u0026 cal1.get(Calendar.DAY_OF_MONTH) \u003d\u003d cal2.get(Calendar.DAY_OF_MONTH))\n                {\n                    shouldDataBeIncluded \u003d true;\n                }\n            }\n            if (filterPartyOnly.isSelected())\n            {\n                if (!data.maidenDefenseAccurate || !data.bloatDefenseAccurate || !data.nyloDefenseAccurate || !data.soteDefenseAccurate || !data.xarpDefenseAccurate)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterNormalOnly.isSelected())\n            {\n                if (data.storyMode || data.hardMode)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (filterPartialOnly.isSelected())\n            {\n                switch (Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString())\n                {\n                    case \"Challenge Time\":\n                        if (!data.getOverallTimeAccurate())\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Maiden Time\":\n                        if (!data.maidenStartAccurate || !data.maidenEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Bloat Time\":\n                        if (!data.bloatStartAccurate || !data.bloatEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Nylocas Time\":\n                        if (!data.nyloStartAccurate || !data.nyloEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Sotetseg Time\":\n                        if (!data.soteStartAccurate || !data.soteEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Xarpus Time\":\n                        if (!data.xarpStartAccurate || !data.xarpEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                    case \"Verzik Time\":\n                        if (!data.verzikStartAccurate || !data.verzikEndAccurate)\n                        {\n                            shouldDataBeIncluded \u003d false;\n                        }\n                        break;\n                }\n            }\n            if (shouldDataBeIncluded \u0026\u0026 filterCheckBoxScale.isSelected())\n            {\n                shouldDataBeIncluded \u003d filterComboBoxScale.getSelectedIndex() + 1 \u003d\u003d data.getScale();\n            }\n            for (Integer i : filteredIndices)\n            {\n                if (data.getValue(DataPoint.RAID_INDEX) \u003d\u003d i)\n                {\n                    shouldDataBeIncluded \u003d false;\n                }\n            }\n            if (!evaluateAllFilters(data))\n            {\n                shouldDataBeIncluded \u003d false;\n            }\n            if (shouldDataBeIncluded)\n            {\n                tableData.add(data);\n                if (data.raidCompleted \u0026\u0026 data.getOverallTimeAccurate())\n                {\n                    completions++;\n                }\n            }\n        }\n        if (sortOptionsBox.getSelectedIndex() \u003d\u003d 0)\n        {\n            if (sortOrderBox.getSelectedIndex() \u003d\u003d 0)\n            {\n                tableData.sort(Comparator.comparing(SimpleTOBData::getDate));\n            } else\n            {\n                tableData.sort(Comparator.comparing(SimpleTOBData::getDate).reversed());\n            }\n        } else if (sortOptionsBox.getSelectedIndex() \u003d\u003d 1)\n        {\n            if (sortOrderBox.getSelectedIndex() \u003d\u003d 0)\n            {\n                for (SimpleTOBData data : tableData)\n                {\n                    data.activeValue \u003d Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString();\n                }\n                tableData.sort(Comparator.comparing(SimpleTOBData::getSpecificTime));\n            } else\n            {\n                for (SimpleTOBData data : tableData)\n                {\n                    data.activeValue \u003d Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString();\n                }\n                tableData.sort(Comparator.comparing(SimpleTOBData::getSpecificTime).reversed());\n            }\n        } else if (sortOptionsBox.getSelectedIndex() \u003d\u003d 2)\n        {\n            if (sortOrderBox.getSelectedIndex() \u003d\u003d 0)\n            {\n                tableData.sort(Comparator.comparing(SimpleTOBData::getScale));\n            } else\n            {\n                tableData.sort(Comparator.comparing(SimpleTOBData::getScale).reversed());\n            }\n        }\n\n        updateCustomStats(tableData);\n        raidsFoundLabel.setText(\"Raids Found: \" + tableData.size());\n        completionsFound.setText(\"Completions Found: \" + completions);\n        updateTabNames(tableData);\n\n        ArrayList\u003cString\u003e columnNamesDynamic \u003d new ArrayList\u003c\u003e();\n        columnNamesDynamic.add(\"\");\n        for (JCheckBoxMenuItem item : columnHeaders)\n        {\n            if (item.getState())\n            {\n                columnNamesDynamic.add(item.getText());\n            }\n            if (item.getText().equals(\"Status\"))\n            {\n                columnNamesDynamic.add(Objects.requireNonNull(viewByRaidComboBox.getSelectedItem()).toString());\n            }\n        }\n        ArrayList\u003cObject[]\u003e tableBuilder \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData raid : tableData)\n        {\n            ArrayList\u003cObject\u003e rowBuilder \u003d new ArrayList\u003c\u003e();\n            for (String column : columnNamesDynamic)\n            {\n                rowBuilder.add(getRowData(column, raid));\n            }\n            tableBuilder.add(rowBuilder.toArray());\n        }\n        int columns \u003d 0;\n        if (!tableBuilder.isEmpty())\n        {\n            columns \u003d tableBuilder.get(0).length;\n        }\n        Object[][] tableObject \u003d new Object[tableData.size()][columns];\n        int count \u003d 0;\n        for (Object[] row : tableBuilder)\n        {\n            tableObject[count] \u003d row;\n            count++;\n        }\n\n        table.setModel(new DefaultTableModel(tableObject, columnNamesDynamic.toArray()));\n        for (int i \u003d 0; i \u003c table.getColumnCount(); i++)\n        {\n            if (table.getColumnName(i).equals(\"View\"))\n            {\n                table.getColumn(table.getColumnName(i)).setCellEditor(new ButtonEditorRoomData(new JCheckBox(), tableData));\n                table.getColumn(table.getColumnName(i)).setCellRenderer(new ButtonRenderer());\n            } else\n            {\n                table.getColumn(table.getColumnName(i)).setCellEditor(new NonEditableCell(new JTextField()));\n                table.getColumn(table.getColumnName(i)).setCellRenderer(new StripedTableRowCellRenderer());\n            }\n        }\n\n        resizeColumnWidth(table);\n        table.setFillsViewportHeight(true);\n        setLabels(tableData);\n        container.validate();\n        container.repaint();\n    }\n\n    public Object getRowData(String column, SimpleTOBData raid)\n    {\n        switch (column)\n        {\n            case \"\":\n                return raid.getValue(DataPoint.RAID_INDEX);\n            case \"Date\":\n                Calendar cal \u003d Calendar.getInstance();\n                cal.setTime(raid.raidStarted);\n                return (cal.get(Calendar.MONTH) + 1) + \"-\" + cal.get(Calendar.DAY_OF_MONTH) + \"-\" + cal.get(Calendar.YEAR);\n            case \"Scale\":\n                return raid.getScaleString();\n            case \"Status\":\n                return raid.getRoomStatus();\n            case \"Players\":\n                StringBuilder players \u003d new StringBuilder();\n                for (String s : raid.players.keySet())\n                {\n                    players.append(s).append(\", \");\n                }\n                return (players.length() \u003e 2) ? players.substring(0, players.length() - 2) : \"\";\n            case \"Spectate\":\n                return (raid.spectated) ? \"Yes\" : \"No\";\n            case \"View\":\n                return \"View\";\n            case \"Time\":\n                Calendar cal2 \u003d Calendar.getInstance();\n                cal2.setTime(raid.raidStarted);\n                int hour \u003d cal2.get(Calendar.HOUR_OF_DAY);\n                int minute \u003d cal2.get(Calendar.MINUTE);\n                String minuteString \u003d (minute \u003c 10) ? \"0\" + minute : String.valueOf(minute);\n                String period \u003d (hour \u003e 11) ? \" PM\" : \" AM\";\n                if (hour \u003d\u003d 0)\n                {\n                    hour \u003d 12;\n                } else if (hour \u003e 12)\n                {\n                    hour -\u003d 12;\n                }\n                return hour + \":\" + minuteString + period;\n        }\n        String valueToDisplay \u003d \"(?)\";\n        try\n        {\n            PlayerCorrelatedPointData pointData \u003d raid.getSpecificTimeInactiveCorrelated(column);\n            if (pointData \u003d\u003d null)\n            {\n                valueToDisplay \u003d String.valueOf(raid.getSpecificTimeInactive(column));\n            } else\n            {\n                if (pointData.value \u003d\u003d 0)\n                {\n                    valueToDisplay \u003d \"0\";\n                } else\n                {\n                    valueToDisplay \u003d pointData.value + \" (\" + pointData.player + \")\";\n                }\n            }\n        } catch (Exception ignored)\n        {\n\n        }\n        return (isTime(column) ? RoomUtil.time(valueToDisplay) : valueToDisplay);\n    }\n\n    boolean isTime(String value)\n    {\n        try\n        {\n            if (!value.contains(\"Player:\"))\n            {\n                return DataPoint.getValue(value).type \u003d\u003d DataPoint.types.TIME;\n            }\n            else\n            {\n                return false;\n            }\n        } catch (Exception e)\n        {\n            return false;\n        }\n    }\n\n    private void updateTabNames(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        int maidenCount \u003d 0;\n        int bloatCount \u003d 0;\n        int nyloCount \u003d 0;\n        int soteCount \u003d 0;\n        int xarpCount \u003d 0;\n        int verzikCount \u003d 0;\n        for (SimpleTOBData d : data)\n        {\n            if (d.maidenStartAccurate \u0026\u0026 d.maidenEndAccurate)\n            {\n                maidenCount++;\n            }\n            if (d.bloatStartAccurate \u0026\u0026 d.bloatEndAccurate)\n            {\n                bloatCount++;\n            }\n            if (d.nyloStartAccurate \u0026\u0026 d.nyloEndAccurate)\n            {\n                nyloCount++;\n            }\n            if (d.soteStartAccurate \u0026\u0026 d.soteEndAccurate)\n            {\n                soteCount++;\n            }\n            if (d.xarpStartAccurate \u0026\u0026 d.xarpEndAccurate)\n            {\n                xarpCount++;\n            }\n            if (d.verzikStartAccurate \u0026\u0026 d.verzikEndAccurate)\n            {\n                verzikCount++;\n            }\n        }\n        tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);\n        tabbedPane.setTitleAt(1, \"Maiden (\" + maidenCount + \")\");\n        tabbedPane.setTitleAt(2, \"Bloat (\" + bloatCount + \")\");\n        tabbedPane.setTitleAt(3, \"Nylo (\" + nyloCount + \")\");\n        tabbedPane.setTitleAt(4, \"Sotetseg (\" + soteCount + \")\");\n        tabbedPane.setTitleAt(5, \"Xarpus (\" + xarpCount + \")\");\n        tabbedPane.setTitleAt(6, \"Verzik (\" + verzikCount + \")\");\n    }\n\n    public void resizeColumnWidthFilters(JTable table)\n    {\n        final TableColumnModel columnModel \u003d table.getColumnModel();\n        for (int column \u003d 0; column \u003c table.getColumnCount(); column++)\n        {\n            int width \u003d 25; // Min width\n            for (int row \u003d 0; row \u003c table.getRowCount(); row++)\n            {\n                TableCellRenderer renderer \u003d table.getCellRenderer(row, column);\n                Component comp \u003d table.prepareRenderer(renderer, row, column);\n                width \u003d Math.max(comp.getPreferredSize().width + 1, width);\n            }\n            if (width \u003e 300)\n            {\n                width \u003d 300;\n            }\n            columnModel.getColumn(column).setPreferredWidth(width);\n        }\n    }\n\n    public void resizeColumnWidth(JTable table)\n    {\n        final TableColumnModel columnModel \u003d table.getColumnModel();\n        for (int column \u003d 0; column \u003c table.getColumnCount(); column++)\n        {\n            int width \u003d 50; // Min width\n            for (int row \u003d 0; row \u003c table.getRowCount(); row++)\n            {\n                TableCellRenderer renderer \u003d table.getCellRenderer(row, column);\n                Component comp \u003d table.prepareRenderer(renderer, row, column);\n                width \u003d Math.max(comp.getPreferredSize().width + 1, width);\n            }\n            if (width \u003e 500)\n            {\n                width \u003d 500;\n            }\n            columnModel.getColumn(column).setPreferredWidth(width);\n        }\n    }\n\n    public void setLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        setOverallLabels(data);\n        maidenTab.updateTab(data);\n        bloatTab.updateTab(data);\n        nyloTab.updateTab(data);\n        soteTab.updateTab(data);\n        xarpTab.updateTab(data);\n        verzikTab.updateTab(data);\n    }\n\n    public void setOverallLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        setOverallAverageLabels(data);\n        setOverallMedianLabels(data);\n        setOverallMinLabels(data);\n        setOverallMaxLabels(data);\n    }\n\n    public void setOverallAverageLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for(String s : averageLabels.keySet())\n        {\n            averageLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericAverage(data, DataPoint.getValue(s + \" Time\"))));\n        }\n    }\n\n    public void setOverallMedianLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for(String s : medianLabels.keySet())\n        {\n            medianLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMedian(data, DataPoint.getValue(s + \" Time\"))));\n        }\n    }\n\n    public void setOverallMinLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for(String s : minLabels.keySet())\n        {\n            minLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMin(data, DataPoint.getValue(s + \" Time\"))));\n        }\n    }\n\n    private void setOverallMaxLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for(String s : maxLabels.keySet())\n        {\n            maxLabels.get(s).setText(RoomUtil.time(StatisticGatherer.getGenericMax(data, DataPoint.getValue(s + \" Time\"))));\n        }\n    }\n\n    private JPopupMenu comboPopupMenu;\n    private ArrayList\u003cString\u003e comboStrictData;\n    private AbstractButton arrowButton;\n    private boolean writing \u003d false;\n\n    private void updateAliases()\n    {\n        writing \u003d true;\n        aliases.clear();\n        aliasText.setText(\"\");\n        for (String s : DataWriter.readAliasFile())\n        {\n            aliasText.append(s + \"\\n\");\n            String[] split \u003d s.split(\":\");\n            if (split.length !\u003d 2)\n            {\n                continue;\n            }\n            String name \u003d split[0];\n            ArrayList\u003cString\u003e names \u003d new ArrayList\u003c\u003e(Arrays.asList(split[1].split(\",\")));\n            if (!names.isEmpty())\n            {\n                Map\u003cString, ArrayList\u003cString\u003e\u003e map \u003d new LinkedHashMap\u003c\u003e();\n                map.put(name, names);\n                aliases.add(map);\n            }\n        }\n        writing \u003d false;\n    }\n\n    private void setPopupVisible(boolean visible)\n    {\n        if (visible)\n        {\n            comboPopupMenu.show(viewByRaidComboBox, 0, viewByRaidComboBox.getSize().height);\n        } else\n        {\n            comboPopupMenu.setVisible(false);\n        }\n    }\n\n    private void setComboSelection(String name)\n    {\n        Vector\u003cString\u003e items \u003d new Vector\u003c\u003e();\n\n        ComparisonViewPanel.addComboItems(name, items, comboStrictData, viewByRaidComboBox);\n    }\n\n    private JMenuItem createMenuItemTableHeader(final String name)\n    {\n        JMenuItem item \u003d new JMenuItem(name);\n        item.setBackground(Color.BLACK);\n        item.setOpaque(true);\n        item.addActionListener(event -\u003e getUpdatedPopupMenu(name));\n        return item;\n    }\n\n    private JMenuItem createMenuItem(final String name)\n    {\n        JMenuItem item \u003d new JMenuItem(name);\n        item.setBackground(Color.BLACK);\n        item.setOpaque(true);\n        item.addActionListener(event -\u003e setComboSelection(name));\n        return item;\n    }\n\n\n    private final Map\u003cString, String[]\u003e comboPopupData \u003d new LinkedHashMap\u003c\u003e();\n\n\n    public  JPanel getOverallPanel(String title, Map\u003cString, JLabel\u003e labelMap)\n    {\n        JPanel panel \u003d new JPanel();\n        panel.setLayout(new BorderLayout());\n        panel.setBorder(BorderFactory.createTitledBorder(title));\n\n        JPanel subPanel \u003d new JPanel();\n        subPanel.setLayout(new GridLayout(7, 2));\n\n        for(String s : rooms)\n        {\n            JLabel leftLabel \u003d new JLabel(roomColor + s);\n            subPanel.add(leftLabel);\n            subPanel.add(labelMap.get(s));\n        }\n        panel.add(subPanel);\n        return panel;\n    }\n\n    public void clearData()\n    {\n        if(currentData !\u003d null)\n        {\n            currentData.clear();\n        }\n        if(comparisons !\u003d null)\n        {\n            comparisons.clear();\n        }\n        close();\n    }\n\n    public void createFrame(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        comboPopupData.put(\"Room Times\", DataPoint.getRoomTimes());\n        comboPopupData.put(\"Maiden\", DataPoint.getMaidenNames());\n        comboPopupData.put(\"Bloat\", DataPoint.getBloatNames());\n        comboPopupData.put(\"Nylocas\", DataPoint.getNyloNames());\n        comboPopupData.put(\"Sotetseg\", DataPoint.getSoteNames());\n        comboPopupData.put(\"Xarpus\", DataPoint.getXarpNames());\n        comboPopupData.put(\"Verzik\", DataPoint.getVerzikNames());\n        comboPopupData.put(\"Any\", DataPoint.getAnyRoomNames());\n        comboPopupMenu \u003d new JPopupMenu();\n        comboPopupMenu.setBorder(new MatteBorder(1, 1, 1, 1, Color.DARK_GRAY));\n\n        List\u003cString\u003e allComboValues \u003d new ArrayList\u003c\u003e(comboPopupData.keySet());\n\n        comboStrictData \u003d new ArrayList\u003c\u003e();\n\n        for (String category : allComboValues)\n        {\n            JMenu menu \u003d new JMenu(category);\n            menu.setBackground(Color.BLACK);\n            menu.setOpaque(true);\n            if (!category.equals(\"Room Times\") \u0026\u0026 !category.equals(\"Any\"))\n            {\n                JMenu timeMenu \u003d new JMenu(\"Time\");\n                timeMenu.setBackground(Color.BLACK);\n                timeMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))\n                {\n                    timeMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu countMenu \u003d new JMenu(\"Misc\");\n                countMenu.setBackground(Color.BLACK);\n                countMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))\n                {\n                    countMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu thrallMenu \u003d new JMenu(\"Thrall\");\n                thrallMenu.setBackground(Color.BLACK);\n                thrallMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))\n                {\n                    thrallMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu vengMenu \u003d new JMenu(\"Veng\");\n                vengMenu.setBackground(Color.BLACK);\n                vengMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))\n                {\n                    vengMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                JMenu specMenu \u003d new JMenu(\"Spec\");\n                specMenu.setBackground(Color.BLACK);\n                specMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))\n                {\n                    specMenu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                menu.add(timeMenu);\n                menu.add(countMenu);\n                menu.add(thrallMenu);\n                menu.add(vengMenu);\n                menu.add(specMenu);\n            } else\n            {\n                for (String itemName : comboPopupData.get(category))\n                {\n                    menu.add(createMenuItem(itemName));\n                    comboStrictData.add(itemName);\n                }\n            }\n            comboPopupMenu.add(menu);\n        }\n        JMenu playerSpecificMenu \u003d new JMenu(\"Player Specific\");\n        playerSpecificMenu.setBackground(Color.BLACK);\n        playerSpecificMenu.setOpaque(true);\n        String[] qualifiers \u003d new String[]{\"Maiden\", \"Bloat\", \"Nylo\", \"Sote\", \"Xarp\", \"Verz\", \"deaths\"};\n\n        for (String s : qualifiers)\n        {\n            JMenu room \u003d new JMenu(s);\n            room.setBackground(Color.BLACK);\n            room.setOpaque(true);\n            for (String qualified : DataPoint.getPlayerSpecific())\n            {\n                if (qualified.contains(s))\n                {\n                    room.add(createMenuItem(\"Player: \" + qualified));\n                    comboStrictData.add(\"Player: \" + qualified);\n                }\n            }\n            playerSpecificMenu.add(room);\n        }\n        JMenu room \u003d new JMenu(\"Other\");\n        room.setBackground(Color.BLACK);\n        room.setOpaque(true);\n        for (String qualified : DataPoint.getPlayerSpecific())\n        {\n            boolean anyFlagged \u003d false;\n            for (String s : qualifiers)\n            {\n                if (qualified.contains(s))\n                {\n                    anyFlagged \u003d true;\n                    break;\n                }\n            }\n            if (!anyFlagged)\n            {\n                room.add(createMenuItem(\"Player: \" + qualified));\n                comboStrictData.add(\"Player: \" + qualified);\n            }\n        }\n        playerSpecificMenu.add(room);\n\n        comboPopupMenu.add(playerSpecificMenu);\n\n        viewByRaidComboBox \u003d new JComboBox\u003c\u003e();\n        viewByRaidComboBox.setEditable(true);\n        viewByRaidComboBox.setPrototypeDisplayValue(\"Challenge Time\");\n        viewByRaidComboBox.setSelectedItem(\"Challenge Time\");\n        viewByRaidComboBox.setEditable(false);\n        for (Component comp : viewByRaidComboBox.getComponents())\n        {\n            if (comp instanceof AbstractButton)\n            {\n                arrowButton \u003d (AbstractButton) comp;\n                arrowButton.setBackground(Color.BLACK);\n            }\n        }\n\n        arrowButton.addActionListener(e -\u003e setPopupVisible(!comboPopupMenu.isVisible()));\n\n        viewByRaidComboBox.addMouseListener(new MouseAdapter()\n        {\n            @Override\n            public void mouseClicked(MouseEvent e)\n            {\n                setPopupVisible(!comboPopupMenu.isVisible());\n            }\n        });\n\n        timeFollowsTab \u003d new JCheckBox(\"Time Follows Tab\");\n        timeFollowsTab.setSelected(true);\n\n        for (int i \u003d 0; i \u003c data.size(); i++)\n        {\n            data.get(i).setIndex(i);\n        }\n\n        int completions \u003d 0;\n        currentData \u003d data;\n        setTitle(\"Raids\");\n\n        JPopupMenu tstMenu \u003d getjPopupMenu();\n\n\n        table \u003d new JTable();\n        table.getTableHeader().setComponentPopupMenu(tstMenu);\n        JScrollPane pane \u003d new JScrollPane(table);\n\n        JPanel tablePanel \u003d getTitledPanel(\"Raids\");\n        tablePanel.setLayout(new BorderLayout());\n        tablePanel.add(pane);\n\n\n        container \u003d new JPanel();\n        container.setLayout(new BoxLayout(container, BoxLayout.Y_AXIS));\n        tabbedPane.addChangeListener(e -\u003e\n        {\n            if (timeFollowsTab.isSelected())\n            {\n                if (built)\n                {\n                    viewByRaidComboBox.setEditable(true);\n                    switch (tabbedPane.getSelectedIndex())\n                    {\n                        case 0:\n                            viewByRaidComboBox.setSelectedItem(\"Challenge Time\");\n                            break;\n                        case 1:\n                            viewByRaidComboBox.setSelectedItem(\"Maiden Time\");\n                            break;\n                        case 2:\n                            viewByRaidComboBox.setSelectedItem(\"Bloat Time\");\n                            break;\n                        case 3:\n                            viewByRaidComboBox.setSelectedItem(\"Nylocas Time\");\n                            break;\n                        case 4:\n                            viewByRaidComboBox.setSelectedItem(\"Sotetseg Time\");\n                            break;\n                        case 5:\n                            viewByRaidComboBox.setSelectedItem(\"Xarpus Time\");\n                            break;\n                        case 6:\n                            viewByRaidComboBox.setSelectedItem(\"Verzik Time\");\n                            break;\n\n                    }\n                    viewByRaidComboBox.setEditable(false);\n                    updateTable();\n                }\n            }\n        });\n        JComponent overallPanel \u003d new JPanel();\n        tabbedPane.addTab(\"Overall\", overallPanel);\n        overallPanel.setLayout(new GridLayout(2, 3));\n\n        JPanel overallCustomPanel \u003d new JPanel();\n        overallCustomPanel.setLayout(new BorderLayout());\n        overallCustomPanel.setBorder(BorderFactory.createTitledBorder(\"\"));\n\n        JPanel customSubPanel \u003d new JPanel();\n        customSubPanel.setLayout(new GridLayout(1, 4));\n\n        JPanel chooseStatisticPanel \u003d getTitledPanel(\"Choose Statistic\");\n        chooseStatisticPanel.setLayout(new GridLayout(1, 1));\n\n        JPanel resultsPanel \u003d getTitledPanel(\"Results\");\n        resultsPanel.setLayout(new GridLayout(5, 2));\n\n        JPanel tableOptionsPanel \u003d getTitledPanel(\"Table Options\");\n\n        JPanel viewRaidByPanel \u003d getTitledPanel(\"View Raid By\");\n\n        sortOptionsBox \u003d new JComboBox\u003c\u003e(new String[]\n                {\n                        \"Date\",\n                        \"Value\",\n                        \"Scale\"\n                }\n        );\n\n        sortOrderBox \u003d new JComboBox\u003c\u003e(new String[]\n                {\n                        \"Ascending\",\n                        \"Descending\"\n                });\n\n        statisticsBox \u003d new JComboBox\u003c\u003e(DataPoint.getByNames());\n\n\n        statisticsBox.addActionListener(\n                al -\u003e\n                        updateTable());\n\n        sortOptionsBox.addActionListener(\n                al -\u003e\n                        updateTable()\n        );\n\n        sortOrderBox.addActionListener(\n                al -\u003e\n                        updateTable()\n        );\n\n        JLabel textCustomAverageLabel \u003d new JLabel(\"Average:\", SwingConstants.LEFT);\n        JLabel textCustomMedianLabel \u003d new JLabel(\"Median:\", SwingConstants.LEFT);\n        JLabel textCustomModeLabel \u003d new JLabel(\"Mode:\", SwingConstants.LEFT);\n        JLabel textCustomMinLabel \u003d new JLabel(\"Minimum:\", SwingConstants.LEFT);\n        JLabel textCustomMaxLabel \u003d new JLabel(\"Maximum:\", SwingConstants.LEFT);\n\n        resultsPanel.add(textCustomAverageLabel);\n        resultsPanel.add(customAverageLabel);\n\n        resultsPanel.add(textCustomMedianLabel);\n        resultsPanel.add(customMedianLabel);\n\n        resultsPanel.add(textCustomModeLabel);\n        resultsPanel.add(customModeLabel);\n\n        resultsPanel.add(textCustomMinLabel);\n        resultsPanel.add(customMinLabel);\n\n        resultsPanel.add(textCustomMaxLabel);\n        resultsPanel.add(customMaxLabel);\n\n        chooseStatisticPanel.add(statisticsBox);\n\n        JButton undoFilter \u003d new JButton(\"Clear manual filter\");\n        undoFilter.addActionListener(al -\u003e\n        {\n            filteredIndices.clear();\n            updateTable();\n        });\n\n        tableOptionsPanel.add(sortOptionsBox);\n        tableOptionsPanel.add(sortOrderBox);\n        tableOptionsPanel.add(undoFilter);\n        JPanel buttonLine \u003d new JPanel();\n        buttonLine.setLayout(new GridLayout(1, 2));\n        buttonLine.add(new JLabel(\"Config\"));\n\n        viewByRaidComboBox.addActionListener(\n                al -\u003e\n                        updateTable());\n\n        viewRaidByPanel.add(viewByRaidComboBox);\n\n        viewRaidByPanel.add(timeFollowsTab);\n\n        viewRaidByPanel.add(raidsFoundLabel);\n        viewRaidByPanel.add(completionsFound);\n        raidsFoundLabel.setText(\"Raids found: \" + data.size());\n        completionsFound.setText(\"Completions found: \" + completions);\n\n        customSubPanel.add(chooseStatisticPanel);\n        customSubPanel.add(resultsPanel);\n        customSubPanel.add(tableOptionsPanel);\n        customSubPanel.add(viewRaidByPanel);\n\n        overallCustomPanel.add(customSubPanel);\n\n        JPanel overallAveragePanel \u003d getOverallPanel(\"Average\", averageLabels);\n        JPanel overallMedianPanel \u003d getOverallPanel(\"Median\", medianLabels);\n        JPanel overallMinPanel \u003d getOverallPanel(\"Minimum\", minLabels);\n        JPanel overallMaxPanel \u003d getOverallPanel(\"Maximum\",maxLabels);\n\n        JPanel topStatPanel \u003d new JPanel();\n        topStatPanel.setLayout(new GridLayout(1, 4));\n\n        topStatPanel.add(overallAveragePanel);\n        topStatPanel.add(overallMedianPanel);\n        topStatPanel.add(overallMinPanel);\n        topStatPanel.add(overallMaxPanel);\n\n        overallPanel.add(topStatPanel);\n        overallPanel.add(overallCustomPanel);\n\n        maidenTab \u003d new StatisticTab(data, DataPoint.rooms.MAIDEN);\n        tabbedPane.addTab(\"Maiden\", maidenTab);\n        bloatTab \u003d new StatisticTab(data, DataPoint.rooms.BLOAT);\n        tabbedPane.addTab(\"Bloat\", bloatTab);\n        nyloTab \u003d new StatisticTab(data, DataPoint.rooms.NYLOCAS);\n        tabbedPane.addTab(\"Nylo\", nyloTab);\n        soteTab \u003d new StatisticTab(data, DataPoint.rooms.SOTETSEG);\n        tabbedPane.addTab(\"Sotetseg\", soteTab);\n        xarpTab \u003d new StatisticTab(data, DataPoint.rooms.XARPUS);\n        tabbedPane.addTab(\"Xarpus\", xarpTab);\n        verzikTab \u003d new StatisticTab(data, DataPoint.rooms.VERZIK);\n        tabbedPane.addTab(\"Verzik\", verzikTab);\n\n        tabbedPane.setMinimumSize(new Dimension(100, 300));\n\n        JPanel additionalFiltersPanel \u003d getTitledPanel(\"Quick Filters\");\n        additionalFiltersPanel.setLayout(new BorderLayout());\n        additionalFiltersPanel.setMinimumSize(new Dimension(200, 300));\n        additionalFiltersPanel.setPreferredSize(new Dimension(200, 300));\n\n        filterSpectateOnly \u003d getActionListenCheckBox(\"Spectate Only\", al-\u003e updateTable());\n        filterInRaidOnly \u003d getActionListenCheckBox(\"In Raid Only\", al-\u003e updateTable());\n        filterCompletionOnly \u003d getActionListenCheckBox(\"Completion Only\", al-\u003e updateTable());\n        filterWipeResetOnly \u003d getActionListenCheckBox(\"Wipe/Reset Only\", al-\u003e updateTable());\n        filterComboBoxScale \u003d UISwingUtility.getActionListenCheckBox(new String[]{\"Solo\", \"Duo\", \"Trio\", \"4-Man\", \"5-Man\"}, al -\u003e updateTable());\n        filterCheckBoxScale \u003d getActionListenCheckBox(\"Scale\", al -\u003e updateTable());\n        filterTodayOnly \u003d getActionListenCheckBox(\"Today Only\", al -\u003e updateTable());\n        filterPartyOnly \u003d getActionListenCheckBox(\"Party Only\", al -\u003e updateTable());\n        filterPartialData \u003d getActionListenCheckBox(\"Filter Partial Raids\", al -\u003e updateTable());\n        filterPartialOnly \u003d getActionListenCheckBox(\"Filter Partial Rooms\", al -\u003e updateTable());\n        filterPartialData.setToolTipText(\"Removes data sets that have any rooms that were partially completed\");\n        filterNormalOnly \u003d getActionListenCheckBox(\"Normal Mode Only\", true, al-\u003e updateTable());\n\n        JPanel scaleContainer \u003d new JPanel();\n        scaleContainer.setLayout(new BoxLayout(scaleContainer, BoxLayout.X_AXIS));\n\n        JPanel filterHolder \u003d new JPanel();\n        filterHolder.setLayout(new GridLayout(10, 1));\n        filterHolder.add(filterSpectateOnly);\n        filterHolder.add(filterInRaidOnly);\n        filterHolder.add(filterCompletionOnly);\n        filterHolder.add(filterWipeResetOnly);\n        filterHolder.add(filterTodayOnly);\n        filterHolder.add(filterPartyOnly);\n        filterHolder.add(filterPartialData);\n        filterHolder.add(filterPartialOnly);\n        filterHolder.add(filterNormalOnly);\n        scaleContainer.add(filterCheckBoxScale);\n        scaleContainer.add(filterComboBoxScale);\n        filterHolder.add(scaleContainer);\n\n        additionalFiltersPanel.add(filterHolder);\n\n        JPanel topContainer \u003d new JPanel();\n        topContainer.setLayout(new BoxLayout(topContainer, BoxLayout.X_AXIS));\n\n        topContainer.setPreferredSize(new Dimension(800, 300));\n        topContainer.add(tabbedPane);\n        topContainer.add(additionalFiltersPanel);\n        setLabels(data);\n        updateTable();\n        container.setPreferredSize(new Dimension(800, 700));\n\n        container.add(topContainer);\n        container.add(tablePanel);\n\n        JPanel splitLeftRight \u003d new JPanel();\n        splitLeftRight.setLayout(new BoxLayout(splitLeftRight, BoxLayout.X_AXIS));\n        splitLeftRight.add(container);\n\n        JPanel rightContainer \u003d new JPanel();\n        rightContainer.setPreferredSize(new Dimension(400, 700));\n        rightContainer.setLayout(new BoxLayout(rightContainer, BoxLayout.Y_AXIS));\n\n        JPanel rightTopContainer \u003d getTitledPanel(\"Advanced Filters\");\n        rightTopContainer.setLayout(new GridLayout(3, 2));\n\n        JPanel filterTimePanel \u003d getTitledPanel(\"Filter by room or split time\");\n        filterTimePanel.setLayout(new BoxLayout(filterTimePanel, BoxLayout.Y_AXIS));\n\n        JPanel filterPlayerPanel \u003d getTitledPanel(\"Filter by players in a raid\");\n        filterPlayerPanel.setLayout(new GridLayout(2, 2));\n\n        JPanel filterDatePanel \u003d getTitledPanel(\"Filter by date\");\n        filterDatePanel.setLayout(new GridLayout(2, 2));\n\n        JPanel filterOtherIntPanel \u003d getTitledPanel(\"Filter by other condition (int)\");\n        filterOtherIntPanel.setLayout(new GridLayout(2, 2));\n\n        JPanel filterOtherBoolPanel \u003d getTitledPanel(\"Filter by other condition (bool)\");\n        filterOtherBoolPanel.setLayout(new GridLayout(2, 2));\n\n\n        timeFilterChoice \u003d new JComboBox\u003c\u003e(DataPoint.getTimeNames());\n\n        String[] timeOperatorChoices \u003d\n                {\n                        \"\u003d\",\n                        \"\u003c\",\n                        \"\u003e\",\n                        \"\u003c\u003d\",\n                        \"\u003e\u003d\"\n                };\n\n        timeFilterOperator \u003d new JComboBox\u003c\u003e(timeOperatorChoices);\n\n\n        timeFilterValue \u003d new JTextField();\n\n        JButton timeFilterAdd \u003d new JButton(\"Add\");\n        timeFilterAdd.addActionListener(\n                al -\u003e\n                {\n                    String time \u003d timeFilterValue.getText();\n                    if (time.isEmpty())\n                    {\n                        return;\n                    }\n                    String timeStr \u003d Objects.requireNonNull(timeFilterChoice.getSelectedItem()) + \" \" + Objects.requireNonNull(timeFilterOperator.getSelectedItem()) + \" \" + time;\n                    activeFilters.add(new ImplicitFilter(new FilterTime(DataPoint.getValue(String.valueOf(timeFilterChoice.getSelectedItem())), timeFilterOperator.getSelectedIndex(), getTimeFromString(time), timeStr)));\n                    updateFilterTable();\n                });\n        timeFilterAdd.setPreferredSize(new Dimension(55, timeFilterAdd.getPreferredSize().height));\n        timeFilterOperator.setPreferredSize(new Dimension(50, timeFilterAdd.getPreferredSize().height));\n        timeFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));\n        timeFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));\n        timeFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, timeFilterAdd.getPreferredSize().height));\n        timeFilterValue.setPreferredSize(new Dimension(75, timeFilterAdd.getPreferredSize().height));\n\n\n        JPanel filterTimePanelTop \u003d new JPanel();\n        filterTimePanelTop.setLayout(new BoxLayout(filterTimePanelTop, BoxLayout.X_AXIS));\n        filterTimePanelTop.add(timeFilterChoice);\n\n        JPanel filterTimePanelBottom \u003d new JPanel();\n        filterTimePanelBottom.setLayout(new BoxLayout(filterTimePanelBottom, BoxLayout.X_AXIS));\n        filterTimePanelBottom.add(timeFilterOperator);\n        filterTimePanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        filterTimePanelBottom.add(timeFilterValue);\n        filterTimePanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        filterTimePanelBottom.add(timeFilterAdd);\n        filterTimePanel.add(filterTimePanelTop);\n        filterTimePanel.add(Box.createRigidArea(new Dimension(5, 5)));\n        filterTimePanel.add(filterTimePanelBottom);\n\n        String[] playersQualifier \u003d {\n                \"contains exactly\",\n                \"includes\",\n                \"includes any of\",\n                \"excludes\",\n                \"excludes all of\"\n        };\n\n        playerFilterOperator \u003d new JComboBox\u003c\u003e(playersQualifier);\n        playerFilterValue \u003d new JTextField();\n        JButton playerFilterAdd \u003d new JButton(\"Add\");\n        playerFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, playerFilterAdd.getPreferredSize().height));\n        playerFilterValue.setPreferredSize(new Dimension(75, playerFilterAdd.getPreferredSize().height));\n        playerFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, playerFilterAdd.getPreferredSize().height));\n        playerFilterAdd.setPreferredSize(new Dimension(55, playerFilterAdd.getPreferredSize().height));\n\n        playerFilterAdd.addActionListener(\n                al -\u003e\n                {\n                    String filterStr \u003d \"Raid \" + playerFilterOperator.getSelectedItem() + \" \" + playerFilterValue.getText();\n                    activeFilters.add(new ImplicitFilter(new FilterPlayers(playerFilterValue.getText(), playerFilterOperator.getSelectedIndex(), filterStr)));\n                    updateFilterTable();\n                });\n\n        JPanel filterPlayerPanelTop \u003d new JPanel();\n        filterPlayerPanelTop.setLayout(new BoxLayout(filterPlayerPanelTop, BoxLayout.X_AXIS));\n        JPanel filterPlayerPanelBottom \u003d new JPanel();\n        filterPlayerPanelBottom.setLayout(new BoxLayout(filterPlayerPanelBottom, BoxLayout.X_AXIS));\n\n        filterPlayerPanel.setLayout(new BoxLayout(filterPlayerPanel, BoxLayout.Y_AXIS));\n\n        filterPlayerPanelTop.add(playerFilterOperator);\n        filterPlayerPanelBottom.add(playerFilterValue);\n        filterPlayerPanelBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        filterPlayerPanelBottom.add(playerFilterAdd);\n\n        filterPlayerPanel.add(filterPlayerPanelTop);\n        filterPlayerPanel.add(Box.createRigidArea(new Dimension(5, 5)));\n        filterPlayerPanel.add(filterPlayerPanelBottom);\n        String[] choicesDate \u003d\n                {\n                        \"on\",\n                        \"before\",\n                        \"after\"\n                };\n\n        dateFilterOperator \u003d new JComboBox\u003c\u003e(choicesDate);\n        JTextField dateFilterValue \u003d new JTextField();\n        dateFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterValue.getPreferredSize().height));\n\n\n        JButton dateFilterAdd \u003d new JButton(\"Add\");\n        dateFilterAdd.addActionListener(\n                al -\u003e\n                {\n                    try\n                    {\n                        String dateString \u003d dateTextField.getText();\n                        String[] datePartial \u003d dateString.split(\"/\");\n                        int year \u003d Integer.parseInt(datePartial[0]);\n                        int month \u003d Integer.parseInt(datePartial[1]);\n                        int day \u003d Integer.parseInt(datePartial[2]);\n                        Date date \u003d new GregorianCalendar(year, month-1, day).getTime();\n                        String filterStr \u003d \"Raid was \" + dateFilterOperator.getSelectedItem() + \" \" + date;\n                        activeFilters.add(new ImplicitFilter(new FilterDate(date, dateFilterOperator.getSelectedIndex(), filterStr)));\n                    } catch (Exception ignored)\n                    {\n\n                    }\n                    updateFilterTable();\n                });\n\n        dateFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterAdd.getPreferredSize().height));\n        dateFilterValue.setPreferredSize(new Dimension(90, dateFilterAdd.getPreferredSize().height));\n\n        dateFilterAdd.setMaximumSize(new Dimension(Integer.MAX_VALUE, dateFilterAdd.getPreferredSize().height));\n        dateFilterAdd.setPreferredSize(new Dimension(55, dateFilterAdd.getPreferredSize().height));\n\n        JPanel dateTopRow \u003d new JPanel();\n        dateTopRow.setLayout(new BoxLayout(dateTopRow, BoxLayout.X_AXIS));\n\n        JPanel dateBottomRow \u003d new JPanel();\n        dateBottomRow.setLayout(new BoxLayout(dateBottomRow, BoxLayout.X_AXIS));\n\n        dateTopRow.add(dateFilterOperator);\n        dateTopRow.add(Box.createRigidArea(new Dimension(2, 2)));\n        dateTopRow.add(dateFilterAdd);\n        dateTextField \u003d new JTextField();\n        dateBottomRow.add(dateTextField);\n        dateBottomRow.add(Box.createRigidArea(new Dimension(5, 5)));\n        dateBottomRow.add(new JLabel(\"YYYY/MM/DD\"));\n        filterDatePanel.setLayout(new BoxLayout(filterDatePanel, BoxLayout.Y_AXIS));\n        filterDatePanel.add(dateTopRow);\n        filterDatePanel.add(Box.createRigidArea(new Dimension(5, 5)));\n        filterDatePanel.add(dateBottomRow);\n\n\n        String[] otherIntOperatorChoices \u003d {\n                \"\u003d\",\n                \"\u003c\",\n                \"\u003e\",\n                \"\u003c\u003d\",\n                \"\u003e\u003d\"\n        };\n\n\n        otherIntFilterChoice \u003d new JComboBox\u003c\u003e(DataPoint.getOtherIntNames());\n        otherIntFilterOperator \u003d new JComboBox\u003c\u003e(otherIntOperatorChoices);\n        otherIntFilterValue \u003d new JTextField();\n\n        JButton otherIntAdd \u003d new JButton(\"Add\");\n        otherIntAdd.addActionListener(\n                al -\u003e\n                {\n                    String filterStr \u003d Objects.requireNonNull(otherIntFilterChoice.getSelectedItem()) + \" \" + Objects.requireNonNull(otherIntFilterOperator.getSelectedItem()) + \" \" + otherIntFilterValue.getText() + \" \";\n                    activeFilters.add(new ImplicitFilter(new FilterOtherInt(DataPoint.getValue(String.valueOf(otherIntFilterChoice.getSelectedItem())), otherIntFilterOperator.getSelectedIndex(), Integer.parseInt(otherIntFilterValue.getText()), filterStr)));\n                    updateFilterTable();\n                }\n        );\n\n        otherIntFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));\n\n        otherIntFilterValue.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));\n        otherIntFilterValue.setPreferredSize(new Dimension(70, otherIntAdd.getPreferredSize().height));\n\n        otherIntAdd.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));\n        otherIntAdd.setPreferredSize(new Dimension(55, otherIntAdd.getPreferredSize().height));\n\n        otherIntFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherIntAdd.getPreferredSize().height));\n        otherIntFilterOperator.setPreferredSize(new Dimension(50, otherIntAdd.getPreferredSize().height));\n\n\n        JPanel otherIntTop \u003d new JPanel();\n        otherIntTop.setLayout(new BoxLayout(otherIntTop, BoxLayout.X_AXIS));\n        JPanel otherIntBottom \u003d new JPanel();\n        otherIntBottom.setLayout(new BoxLayout(otherIntBottom, BoxLayout.X_AXIS));\n\n        otherIntTop.add(otherIntFilterChoice);\n        otherIntBottom.add(otherIntFilterOperator);\n        otherIntBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        otherIntBottom.add(otherIntFilterValue);\n        otherIntBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        otherIntBottom.add(otherIntAdd);\n\n        filterOtherIntPanel.setLayout(new BoxLayout(filterOtherIntPanel, BoxLayout.Y_AXIS));\n        filterOtherIntPanel.add(otherIntTop);\n        filterOtherIntPanel.add(Box.createRigidArea(new Dimension(5, 5)));\n        filterOtherIntPanel.add(otherIntBottom);\n\n        String[] choicesOtherBool \u003d {\n                \"Maiden skip successful\",\n                \"Reset after maiden\",\n                \"Maiden wipe\",\n                \"Reset after bloat\",\n                \"Bloat wipe\",\n                \"Reset after nylo\",\n                \"Nylo wipe\",\n                \"Reset after sote\",\n                \"Sote wipe\",\n                \"Reset after xarp\",\n                \"Xarp wipe\",\n                \"Verzik  wipe\",\n                \"Maiden Scuffed\",\n        };\n\n        String[] qualifierOtherBool \u003d {\n                \"True\",\n                \"False\"\n        };\n\n        otherBoolFilterChoice \u003d new JComboBox\u003c\u003e(choicesOtherBool);\n        otherBoolFilterOperator \u003d new JComboBox\u003c\u003e(qualifierOtherBool);\n\n        JButton otherBoolAdd \u003d new JButton(\"Add Filter\");\n        otherBoolAdd.addActionListener(\n                al -\u003e\n                {\n                    String filterStr \u003d Objects.requireNonNull(otherBoolFilterChoice.getSelectedItem()) + \" \" + otherBoolFilterOperator.getSelectedItem();\n                    activeFilters.add(new ImplicitFilter(new FilterOtherBool(otherBoolFilterChoice.getSelectedIndex(), otherBoolFilterOperator.getSelectedIndex() \u003d\u003d 0, filterStr)));\n                    updateFilterTable();\n                }\n        );\n\n        otherBoolFilterOperator.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherBoolAdd.getPreferredSize().height));\n        otherBoolFilterChoice.setMaximumSize(new Dimension(Integer.MAX_VALUE, otherBoolAdd.getPreferredSize().height));\n\n        JPanel filterBoolTop \u003d new JPanel();\n        filterBoolTop.setLayout(new BoxLayout(filterBoolTop, BoxLayout.X_AXIS));\n        JPanel filterBoolBottom \u003d new JPanel();\n        filterBoolBottom.setLayout(new BoxLayout(filterBoolBottom, BoxLayout.X_AXIS));\n\n        filterBoolTop.add(otherBoolFilterChoice);\n        filterBoolBottom.add(otherBoolFilterOperator);\n        filterBoolBottom.add(Box.createRigidArea(new Dimension(2, 2)));\n        filterBoolBottom.add(otherBoolAdd);\n\n        filterOtherBoolPanel.setLayout(new BoxLayout(filterOtherBoolPanel, BoxLayout.Y_AXIS));\n\n        filterOtherBoolPanel.add(filterBoolTop);\n        filterOtherBoolPanel.add(Box.createRigidArea(new Dimension(5, 5)));\n        filterOtherBoolPanel.add(filterBoolBottom);\n\n        JPanel filterOptions \u003d getTitledPanel(\"Filter Options\");\n        rightTopContainer.setPreferredSize(new Dimension(400, 250));\n        rightTopContainer.add(filterTimePanel);\n        rightTopContainer.add(filterOtherIntPanel);\n        rightTopContainer.add(filterPlayerPanel);\n        rightTopContainer.add(filterOtherBoolPanel);\n        rightTopContainer.add(filterDatePanel);\n\n\n        JPanel rightBottomContainer \u003d getTitledPanel(\"Active Filters\");\n        rightBottomContainer.setPreferredSize(new Dimension(400, 200));\n\n        filterTableContainer \u003d new JPanel();\n\n        JPopupMenu raidPopup \u003d new JPopupMenu();\n\n        JMenuItem analyzeSessions \u003d new JMenuItem(\"Analyze Sessions\");\n        analyzeSessions.setBackground(Color.BLACK);\n        analyzeSessions.setOpaque(true);\n        analyzeSessions.addActionListener(e -\u003e\n        {\n            updateAliases();\n            ArrayList\u003cSimpleTOBData\u003e rows \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));\n            }\n            Map\u003cInteger, Map\u003cString, ArrayList\u003cSimpleTOBData\u003e\u003e\u003e sessions \u003d new LinkedHashMap\u003c\u003e();\n            for (SimpleTOBData data12 : rows)\n            {\n                if (!sessions.containsKey(data12.players.size()))\n                {\n                    Map\u003cString, ArrayList\u003cSimpleTOBData\u003e\u003e scale \u003d new LinkedHashMap\u003c\u003e();\n                    ArrayList\u003cSimpleTOBData\u003e list \u003d new ArrayList\u003c\u003e();\n                    list.add(data12);\n                    scale.put(data12.getPlayerList(aliases), list);\n                    sessions.put(data12.players.size(), scale);\n                } else\n                {\n                    if (!sessions.get(data12.players.size()).containsKey(data12.getPlayerList(aliases)))\n                    {\n                        ArrayList\u003cSimpleTOBData\u003e list \u003d new ArrayList\u003c\u003e();\n                        list.add(data12);\n                        sessions.get(data12.players.size()).put(data12.getPlayerList(aliases), list);\n                    } else\n                    {\n                        sessions.get(data12.players.size()).get(data12.getPlayerList(aliases)).add(data12);\n                    }\n                }\n            }\n            ArrayList\u003cArrayList\u003cString\u003e\u003e labelSets \u003d new ArrayList\u003c\u003e();\n            Map\u003cInteger, ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e\u003e dataSets \u003d new LinkedHashMap\u003c\u003e();\n            for (Integer scale : sessions.keySet())\n            {\n                ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e scaleData \u003d new ArrayList\u003c\u003e();\n                ArrayList\u003cString\u003e labels \u003d new ArrayList\u003c\u003e();\n                for (String playerList : sessions.get(scale).keySet())\n                {\n                    scaleData.add(sessions.get(scale).get(playerList));\n                    labels.add(playerList);\n                }\n                dataSets.put(scale, scaleData);\n                labelSets.add(labels);\n            }\n            ComparisonViewFrame graphView \u003d new ComparisonViewFrame(dataSets, labelSets, config, itemManager, clientThread, configManager);\n            graphView.open();\n        });\n\n\n        JMenuItem addToComparison \u003d new JMenuItem(\"Add set to comparison\");\n        addToComparison.setBackground(Color.BLACK);\n        addToComparison.setOpaque(true);\n\n        JMenuItem viewGraphs \u003d new JMenuItem(\"View Graphs\");\n        viewGraphs.setBackground(Color.BLACK);\n        viewGraphs.setOpaque(true);\n\n        JMenuItem viewCharts \u003d new JMenuItem(\"View Charts\");\n        viewCharts.setBackground(Color.BLACK);\n        viewCharts.setOpaque(true);\n\n        viewCharts.addActionListener(e -\u003e\n        {\n            ArrayList\u003cSimpleTOBData\u003e rows \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));\n            }\n            ChartFrame roomCharts \u003d new ChartFrame(rows, config, itemManager, clientThread, configManager);\n            roomCharts.open();\n        });\n\n        viewGraphs.addActionListener(e -\u003e\n        {\n            ArrayList\u003cString\u003e labels \u003d new ArrayList\u003c\u003e();\n            ArrayList\u003cSimpleTOBData\u003e rows \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));\n            }\n            if (rows.isEmpty())\n            {\n                new NoDataPopUp().open();\n            } else\n            {\n                labels.add(\"\");\n                ArrayList\u003cArrayList\u003cSimpleTOBData\u003e\u003e data1 \u003d new ArrayList\u003c\u003e();\n                data1.add(rows);\n                ComparisonViewFrame graphView \u003d new ComparisonViewFrame(data1, labels);\n                graphView.open();\n            }\n        });\n\n        addToComparison.addActionListener(e -\u003e\n        {\n            ArrayList\u003cSimpleTOBData\u003e rows \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));\n            }\n            comparisons.add(rows);\n            updateComparisonTable();\n        });\n        JMenuItem exportRaids \u003d new JMenuItem(\"Export Selected Raids to CSV\");\n        exportRaids.setBackground(Color.BLACK);\n        exportRaids.setOpaque(true);\n        exportRaids.addActionListener(e -\u003e\n        {\n            ArrayList\u003cSimpleTOBData\u003e rows \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                rows.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())));\n            }\n            new SaveRaids(rows).open();\n        });\n\n        JMenuItem filterRaids \u003d new JMenuItem(\"Filter Selected Raids\");\n        filterRaids.setBackground(Color.BLACK);\n        filterRaids.setOpaque(true);\n        filterRaids.addActionListener(e -\u003e\n        {\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                filteredIndices.add(Integer.parseInt(table.getModel().getValueAt(j, 0).toString()));\n            }\n\n            updateTable();\n        });\n\n        JMenuItem filterExclusiveRaids \u003d new JMenuItem(\"Filter All Except Selected Raids\");\n        filterExclusiveRaids.setBackground(Color.BLACK);\n        filterExclusiveRaids.setOpaque(true);\n        filterExclusiveRaids.addActionListener(e -\u003e\n        {\n            int[] toKeep \u003d table.getSelectedRows();\n            for (int i \u003d 0; i \u003c table.getRowCount(); i++)\n            {\n                boolean found \u003d false;\n                for (int k : toKeep)\n                {\n                    if (i \u003d\u003d k)\n                    {\n                        found \u003d true;\n                        break;\n                    }\n                }\n                if (!found)\n                {\n                    filteredIndices.add(Integer.parseInt(table.getModel().getValueAt(i, 0).toString()));\n                }\n            }\n\n            updateTable();\n        });\n        JMenuItem analyzeCrabs \u003d new JMenuItem(\"Analyze selection crab leaks\");\n        analyzeCrabs.setOpaque(true);\n        analyzeCrabs.setBackground(Color.BLACK);\n        analyzeCrabs.addActionListener(e -\u003e\n        {\n            ArrayList\u003cArrayList\u003cStringInt\u003e\u003e crabData \u003d new ArrayList\u003c\u003e();\n            int[] toRemove \u003d table.getSelectedRows();\n            for (int j : toRemove)\n            {\n                crabData.add(currentData.get(Integer.parseInt(table.getModel().getValueAt(j, 0).toString())).maidenCrabs);\n            }\n            new CrabLeakInfo(crabData);\n        });\n\n        raidPopup.add(analyzeCrabs);\n        raidPopup.add(exportRaids);\n        raidPopup.add(addToComparison);\n        raidPopup.add(filterRaids);\n        raidPopup.add(filterExclusiveRaids);\n        raidPopup.add(analyzeSessions);\n        raidPopup.add(viewCharts);\n        raidPopup.add(viewGraphs);\n        table.setComponentPopupMenu(raidPopup);\n\n        filterTable \u003d new JTable();\n        filterTable.setPreferredSize(new Dimension(380, 135));\n        JScrollPane tableScrollView \u003d new JScrollPane(filterTable);\n        tableScrollView.setPreferredSize(new Dimension(380, 140));\n        updateFilterTable();\n        filterTableContainer.add(tableScrollView);\n\n        rightBottomContainer.add(filterTableContainer);\n\n        JButton saveFiltersButton \u003d new JButton(\"Save\");\n        saveFiltersButton.addActionListener(\n                al -\u003e\n                {\n                    ArrayList\u003cString\u003e quickFiltersState \u003d new ArrayList\u003c\u003e();\n                    quickFiltersState.add(\"QF-Spectate Only:\"+filterSpectateOnly.isSelected());\n                    quickFiltersState.add(\"QF-In Raid Only:\"+filterInRaidOnly.isSelected());\n                    quickFiltersState.add(\"QF-Completion Only:\"+filterCompletionOnly.isSelected());\n                    quickFiltersState.add(\"QF-Wipe/Reset Only:\"+filterWipeResetOnly.isSelected());\n                    quickFiltersState.add(\"QF-Today Only:\"+filterTodayOnly.isSelected());\n                    quickFiltersState.add(\"QF-Party Only:\"+filterPartyOnly.isSelected());\n                    quickFiltersState.add(\"QF-Partial Raids:\"+filterPartialData.isSelected());\n                    quickFiltersState.add(\"QF-Partial Rooms:\"+filterPartialOnly.isSelected());\n                    quickFiltersState.add(\"QF-Normal Mode Only:\"+filterNormalOnly.isSelected());\n                    quickFiltersState.add(\"QF-Scale:\"+filterCheckBoxScale.isSelected()+\":\"+filterComboBoxScale.getSelectedIndex());\n                    quickFiltersState.add(\"QF-View Raid By:\"+viewByRaidComboBox.getItemAt(viewByRaidComboBox.getSelectedIndex()));\n                    quickFiltersState.add(\"QF-Table Sort By:\"+sortOptionsBox.getItemAt(sortOptionsBox.getSelectedIndex()));\n                    quickFiltersState.add(\"QF-Table Sort:\"+sortOrderBox.getItemAt(sortOrderBox.getSelectedIndex()));\n                    SaveFilter saveFilter \u003d new SaveFilter(activeFilters, quickFiltersState);\n                    saveFilter.open();\n                });\n        JButton loadFiltersButton \u003d new JButton(\"Load\");\n        loadFiltersButton.addActionListener(\n                al -\u003e\n                        new LoadFilter(this).open());\n        JButton clearFiltersButton \u003d new JButton(\"Clear\");\n        clearFiltersButton.addActionListener(\n                al -\u003e\n                {\n                    activeFilters.clear();\n                    updateFilterTable();\n                });\n        GridLayout layout \u003d new GridLayout(2, 2);\n        layout.setHgap(2);\n        layout.setVgap(2);\n        filterOptions.setLayout(layout);\n\n        filterOptions.add(saveFiltersButton);\n        filterOptions.add(loadFiltersButton);\n        filterOptions.add(clearFiltersButton);\n        rightTopContainer.add(filterOptions);\n\n        JPanel rightBottomBottomContainer \u003d getTitledPanel(\"Comparison Options\");\n        rightBottomBottomContainer.setPreferredSize(new Dimension(400, 250));\n\n        comparisonTable \u003d new JTable();\n        JScrollPane comparisonTableScroll \u003d new JScrollPane(comparisonTable);\n        comparisonTable.setPreferredSize(new Dimension(380, 170));\n        comparisonTableScroll.setPreferredSize(new Dimension(380, 155));\n        updateComparisonTable();\n\n        JPanel rightBottomMostContainer \u003d getTitledPanel(\"Alias Options\");\n\n        aliasText.setToolTipText(\"This applies to the tab names when you use the analyze sessions features. Syntax- Name to be displayed:oldname1,oldname2,oldname3\");\n        aliasText.getDocument().addDocumentListener(new DocumentListener()\n        {\n            @Override\n            public void insertUpdate(DocumentEvent e)\n            {\n                try\n                {\n                    if (!writing)\n                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll(\"\\n\", System.lineSeparator()));\n                } catch (BadLocationException ignored)\n                {\n                }\n            }\n\n            @Override\n            public void removeUpdate(DocumentEvent e)\n            {\n                try\n                {\n                    if (!writing)\n                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll(\"\\n\", System.lineSeparator()));\n                } catch (BadLocationException ignored)\n                {\n                }\n            }\n\n            @Override\n            public void changedUpdate(DocumentEvent e)\n            {\n                try\n                {\n                    if (!writing)\n                        DataWriter.writeAliasFile(e.getDocument().getText(0, e.getDocument().getLength()).replaceAll(\"\\n\", System.lineSeparator()));\n                } catch (BadLocationException ignored)\n                {\n                }\n            }\n        });\n\n        updateAliases();\n\n        JScrollPane aliasScrollPane \u003d new JScrollPane(aliasText);\n        aliasScrollPane.setPreferredSize(new Dimension(380, 70));\n        rightBottomMostContainer.add(aliasScrollPane);\n\n        rightBottomBottomContainer.add(comparisonTableScroll);\n        JButton viewComparisonsButton \u003d new JButton(\"View Comparisons\");\n        viewComparisonsButton.addActionListener(al -\u003e\n        {\n            if (comparisonTable.getModel().getRowCount() \u003d\u003d 0)\n            {\n                new NoDataPopUp().open();\n            } else\n            {\n                ArrayList\u003cString\u003e labels \u003d new ArrayList\u003c\u003e();\n                for (int i \u003d 0; i \u003c comparisonTable.getModel().getRowCount(); i++)\n                {\n                    labels.add(comparisonTable.getModel().getValueAt(i, 1).toString());\n                }\n                ComparisonViewFrame graphView \u003d new ComparisonViewFrame(comparisons, labels);\n                graphView.open();\n            }\n        });\n        rightBottomBottomContainer.add(viewComparisonsButton);\n\n        rightContainer.add(rightTopContainer);\n        rightContainer.add(rightBottomContainer);\n        rightContainer.add(rightBottomBottomContainer);\n        rightContainer.add(rightBottomMostContainer);\n        splitLeftRight.add(rightContainer);\n        sortOrderBox.setSelectedIndex(1);\n\n        add(splitLeftRight);\n        pack();\n        built \u003d true;\n    }\n\n    public String[] columnHeaderNames \u003d new String[]{\"Date\", \"Time\", \"Scale\", \"Status\", \"Players\", \"Spectate\", \"View\"};\n    public ArrayList\u003cJCheckBoxMenuItem\u003e columnHeaders;\n\n    private void getUpdatedPopupMenu(String newItem)\n    {\n        JCheckBoxMenuItem item \u003d new JCheckBoxMenuItem(newItem);\n        item.setOpaque(true);\n        item.setBackground(Color.BLACK);\n        item.setState(true);\n        item.addActionListener(al -\u003e\n                updateTable());\n        columnHeaders.add(item);\n        table.getTableHeader().setComponentPopupMenu(getjPopupMenu());\n        updateTable();\n    }\n\n    private JCheckBoxMenuItem getCheckBoxMenuItem(String name)\n    {\n        JCheckBoxMenuItem item \u003d new JCheckBoxMenuItem(name);\n        if (!name.equals(\"Time\"))\n        {\n            item.setState(true);\n        }\n        item.setOpaque(true);\n        item.setBackground(Color.BLACK);\n        item.addActionListener(al -\u003e\n        {\n            if (built)\n            {\n                updateTable();\n            }\n        });\n        return item;\n    }\n\n    private JPopupMenu getjPopupMenu()\n    {\n        JPopupMenu baseMenu \u003d new JPopupMenu();\n\n        for (JCheckBoxMenuItem item : columnHeaders)\n        {\n            baseMenu.add(item);\n        }\n\n        List\u003cString\u003e allComboValues \u003d new ArrayList\u003c\u003e(comboPopupData.keySet());\n\n        comboStrictData \u003d new ArrayList\u003c\u003e();\n\n        JMenu addCustom \u003d new JMenu(\"Add Custom\");\n\n        JMenuItem resetCustom \u003d new JMenuItem(\"Reset Custom Columns\");\n        resetCustom.setOpaque(true);\n        resetCustom.setBackground(Color.BLACK);\n\n        resetCustom.addActionListener(al -\u003e\n        {\n            columnHeaders.clear();\n            for (String column : columnHeaderNames)\n            {\n                columnHeaders.add(getCheckBoxMenuItem(column));\n            }\n            table.getTableHeader().setComponentPopupMenu(getjPopupMenu());\n            updateTable();\n        });\n\n        for (String category : allComboValues)\n        {\n            JMenu menu \u003d new JMenu(category);\n            menu.setBackground(Color.BLACK);\n            menu.setOpaque(true);\n            if (!category.equals(\"Room Times\") \u0026\u0026 !category.equals(\"Any\"))\n            {\n                JMenu timeMenu \u003d new JMenu(\"Time\");\n                timeMenu.setBackground(Color.BLACK);\n                timeMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterTimes(comboPopupData.get(category)))\n                {\n                    timeMenu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu countMenu \u003d new JMenu(\"Misc\");\n                countMenu.setBackground(Color.BLACK);\n                countMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterInt(comboPopupData.get(category)))\n                {\n                    countMenu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu thrallMenu \u003d new JMenu(\"Thrall\");\n                thrallMenu.setBackground(Color.BLACK);\n                thrallMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterThrall(comboPopupData.get(category)))\n                {\n                    thrallMenu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n                JMenu vengMenu \u003d new JMenu(\"Veng\");\n                vengMenu.setBackground(Color.BLACK);\n                vengMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterVeng(comboPopupData.get(category)))\n                {\n                    vengMenu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                JMenu specMenu \u003d new JMenu(\"Spec\");\n                specMenu.setBackground(Color.BLACK);\n                specMenu.setOpaque(true);\n                for (String itemName : DataPoint.filterSpecs(comboPopupData.get(category)))\n                {\n                    specMenu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n\n                menu.add(timeMenu);\n                menu.add(countMenu);\n                menu.add(thrallMenu);\n                menu.add(vengMenu);\n                menu.add(specMenu);\n            } else\n            {\n                for (String itemName : comboPopupData.get(category))\n                {\n                    menu.add(createMenuItemTableHeader(itemName));\n                    comboStrictData.add(itemName);\n                }\n            }\n            addCustom.add(menu);\n        }\n        JMenu playerSpecificMenu \u003d new JMenu(\"Player Specific\");\n        playerSpecificMenu.setBackground(Color.BLACK);\n        playerSpecificMenu.setOpaque(true);\n        String[] qualifiers \u003d new String[]{\"Maiden\", \"Bloat\", \"Nylo\", \"Sote\", \"Xarp\", \"Verz\", \"deaths\"};\n\n        for (String s : qualifiers)\n        {\n            JMenu room \u003d new JMenu(s);\n            room.setBackground(Color.BLACK);\n            room.setOpaque(true);\n            for (String qualified : DataPoint.getPlayerSpecific())\n            {\n                if (qualified.contains(s))\n                {\n                    room.add(createMenuItemTableHeader(\"Player: \" + qualified));\n                    comboStrictData.add(\"Player: \" + qualified);\n                }\n            }\n            playerSpecificMenu.add(room);\n        }\n        JMenu room \u003d new JMenu(\"Other\");\n        room.setBackground(Color.BLACK);\n        room.setOpaque(true);\n        for (String qualified : DataPoint.getPlayerSpecific())\n        {\n            boolean anyFlagged \u003d false;\n            for (String s : qualifiers)\n            {\n                if (qualified.contains(s))\n                {\n                    anyFlagged \u003d true;\n                    break;\n                }\n            }\n            if (!anyFlagged)\n            {\n                room.add(createMenuItemTableHeader(\"Player: \" + qualified));\n                comboStrictData.add(\"Player: \" + qualified);\n            }\n        }\n        playerSpecificMenu.add(room);\n\n        addCustom.setOpaque(true);\n        addCustom.setBackground(Color.BLACK);\n        addCustom.add(playerSpecificMenu);\n        baseMenu.add(addCustom);\n        baseMenu.add(resetCustom);\n\n        return baseMenu;\n    }\n\n    private int getTimeFromString(String text)\n    {\n        int ticks \u003d 0;\n        String sub \u003d text;\n        if (sub.contains(\":\"))\n        {\n            ticks +\u003d 100 * Integer.parseInt(sub.substring(0, sub.indexOf(\":\")));\n            sub \u003d text.substring(sub.indexOf(\":\") + 1);\n        }\n        ticks +\u003d (int) ((Double.parseDouble(sub) / 0.6));\n        return ticks;\n    }\n\n    public void removeFilterRow(int row)\n    {\n        activeFilters.remove(row);\n        updateFilterTable();\n    }\n\n    public void removeComparisonRow(int row)\n    {\n        comparisons.remove(row);\n        updateComparisonTable();\n    }\n\n    private void updateComparisonTable()\n    {\n        String[] columnNames \u003d {\"Sets\", \"Label\", \"\"};\n        ArrayList\u003cObject[]\u003e tableData \u003d new ArrayList\u003c\u003e();\n\n        int index \u003d 0;\n        for (ArrayList\u003cSimpleTOBData\u003e comparison : comparisons)\n        {\n            Object[] row \u003d {comparison.size() + \" raids averaging: \" + RoomUtil.time(StatisticGatherer.getOverallTimeAverage(comparison)), \"Set \" + index, \"Remove\"};\n            tableData.add(row);\n            index++;\n        }\n\n        Object[][] tableObject \u003d new Object[tableData.size()][2];\n        int count \u003d 0;\n        for (Object[] row : tableData)\n        {\n            tableObject[count] \u003d row;\n            count++;\n        }\n        comparisonTable.setModel(new DefaultTableModel(tableObject, columnNames));\n        comparisonTable.getColumn(\"Sets\").setCellEditor(new NonEditableCell(new JTextField()));\n        comparisonTable.getColumn(\"\").setCellRenderer(new ButtonRenderer());\n        comparisonTable.getColumn(\"\").setCellEditor(new ButtonEditorComparisonData(new JCheckBox(), this));\n        resizeColumnWidthFilters(comparisonTable);\n        comparisonTable.getColumn(\"\").setMaxWidth(100);\n        comparisonTable.setFillsViewportHeight(true);\n        comparisonTable.validate();\n        comparisonTable.repaint();\n    }\n\n    public void setFilterState(String state)\n    {\n        try\n        {\n            if (state.contains(\":\"))\n            {\n                String[] data \u003d state.split(\":\");\n                if (data.length \u003e 1)\n                {\n                    switch (data[0])\n                    {\n                        case \"Spectate Only\":\n                            filterSpectateOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"In Raid Only\":\n                            filterInRaidOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Completion Only\":\n                            filterCompletionOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Wipe/Reset Only\":\n                            filterWipeResetOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Today Only\":\n                            filterTodayOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Party Only\":\n                            filterPartyOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Partial Raids\":\n                            filterPartialOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Partial Rooms\":\n                            filterPartialData.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Normal Mode Only\":\n                            filterNormalOnly.setSelected(Boolean.parseBoolean(data[1]));\n                            break;\n                        case \"Scale\":\n                            if(data.length \u003e 2)\n                            {\n                                filterCheckBoxScale.setSelected(Boolean.parseBoolean(data[1]));\n                                filterComboBoxScale.setSelectedIndex(Integer.parseInt(data[2]));\n                            }\n                            break;\n                        case \"View Raid By\":\n                            viewByRaidComboBox.setEditable(true);\n                            if(!Objects.equals(data[1], \"null\"))\n                            {\n                                viewByRaidComboBox.setSelectedItem(data[1]);\n                            }\n                            else\n                            {\n                                viewByRaidComboBox.setSelectedItem(\"Challenge Time\");\n                            }\n                            viewByRaidComboBox.setEditable(false);\n                            break;\n                        case \"Table Sort By\":\n                            sortOptionsBox.setSelectedItem(data[1]);\n                            break;\n                        case \"Table Sort\":\n                            sortOrderBox.setSelectedItem(data[1]);\n                            break;\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            log.info(\"Failed to set filter state: \" + state);\n        }\n    }\n\n    public void updateFilterTable()\n    {\n        String[] columnNames \u003d {\"Filter Descriptions\", \"\"};\n        ArrayList\u003cObject[]\u003e tableData \u003d new ArrayList\u003c\u003e();\n\n        for (ImplicitFilter filter : activeFilters)\n        {\n            Object[] row \u003d {filter.getFilterDescription(), \"Remove\"};\n            tableData.add(row);\n        }\n\n        Object[][] tableObject \u003d new Object[tableData.size()][2];\n        int count \u003d 0;\n        for (Object[] row : tableData)\n        {\n            tableObject[count] \u003d row;\n            count++;\n        }\n        filterTable.setModel(new DefaultTableModel(tableObject, columnNames));\n        filterTable.setDefaultRenderer(Object.class, new StripedTableRowCellRenderer());\n        filterTable.getColumn(\"Filter Descriptions\").setCellEditor(new NonEditableCell(new JTextField()));\n        filterTable.getColumn(\"\").setCellRenderer(new ButtonRenderer());\n        filterTable.getColumn(\"\").setCellEditor(new ButtonEditorFilterData(new JCheckBox(), this));\n        resizeColumnWidthFilters(filterTable);\n        filterTable.getColumn(\"\").setMaxWidth(100);\n        filterTable.setFillsViewportHeight(true);\n        filterTableContainer.validate();\n        filterTableContainer.repaint();\n        updateTable();\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\Raids.java"},{"fileName":"RaidTrackerSidePanel.java","content":"package com.advancedraidtracker.ui;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport com.advancedraidtracker.utility.wrappers.RaidsArrayWrapper;\nimport com.advancedraidtracker.utility.datautility.RaidsManager;\nimport com.google.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.PluginPanel;\nimport javax.swing.*;\nimport javax.swing.table.DefaultTableModel;\nimport java.awt.*;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.util.*;\n\nimport static com.advancedraidtracker.utility.datautility.DataWriter.PLUGIN_DIRECTORY;\n\n@Slf4j\npublic class RaidTrackerSidePanel extends PluginPanel\n{\n    private JLabel raidCountLabel;\n    private ArrayList\u003cSimpleTOBData\u003e raidsData;\n    private JTable loadRaidsTable;\n    private ArrayList\u003cRaidsArrayWrapper\u003e raidSets;\n\n    private Raids raids;\n\n    private AdvancedRaidTrackerPlugin plugin;\n    private static AdvancedRaidTrackerConfig config;\n    private static ItemManager itemManager;\n    private final ConfigManager configManager;\n\n    private JLabel pleaseWait \u003d new JLabel(\"Parsing Files...\", SwingConstants.CENTER);\n\n    @Inject\n    RaidTrackerSidePanel(AdvancedRaidTrackerPlugin plugin, AdvancedRaidTrackerConfig config, ItemManager itemManager, ClientThread clientThread, ConfigManager configManager)\n    {\n        this.configManager \u003d configManager;\n        add(pleaseWait);\n        new Thread(() -\u003e\n        {\n            RaidTrackerSidePanel.config \u003d config;\n            this.plugin \u003d plugin;\n            RaidTrackerSidePanel.itemManager \u003d itemManager;\n            raidsData \u003d new ArrayList\u003c\u003e();\n            raidsData \u003d getAllRaids();\n            raids \u003d new Raids(config, itemManager, clientThread, configManager);\n            removeAll();\n            buildComponents();\n            updateUI();\n        }).start();\n    }\n\n    private ArrayList\u003cSimpleTOBData\u003e getAllRaids()\n    {\n        ArrayList\u003cSimpleTOBData\u003e raids \u003d new ArrayList\u003c\u003e();\n        try\n        {\n            File logDirectory \u003d new File(PLUGIN_DIRECTORY);\n            File[] logFiles \u003d logDirectory.listFiles();\n            int raidCount \u003d 0;\n            if(logFiles !\u003d null)\n            {\n                for(File file : logFiles)\n                {\n                    if(file.isDirectory())\n                    {\n                        File subDirectory \u003d new File(file.getAbsolutePath()+\"/primary/\");\n                        File[] subDirectoryFiles \u003d subDirectory.listFiles();\n                        if(subDirectoryFiles !\u003d null)\n                        {\n                            raidCount +\u003d subDirectoryFiles.length;\n                        }\n                    }\n                }\n            }\n            int index \u003d 0;\n            if (logFiles !\u003d null)\n            {\n                for (File file : logFiles)\n                {\n                    if (file.isDirectory())\n                    {\n                        File subDirectory \u003d new File(file.getAbsolutePath()+\"/primary/\");\n                        File[] subLogFiles \u003d subDirectory.listFiles();\n                        if(subLogFiles !\u003d null)\n                        {\n                            for (File dataFile : subLogFiles)\n                            {\n                                if (!dataFile.isDirectory())\n                                {\n                                    if (dataFile.getName().contains(\"tobdata\"))\n                                    {\n                                        File currentFile \u003d new File(subDirectory.getAbsolutePath() + \"/\" + dataFile.getName());\n                                        parseLogFile(raids, currentFile, subDirectory.getAbsolutePath() + \"/\" + dataFile.getName());\n                                        index++;\n                                        if(raidCountLabel !\u003d null)\n                                        {\n                                            raidCountLabel.setText(\"Refreshing...(\" + index + \"/\" + raidCount + \")\");\n                                        }\n                                        else if(pleaseWait !\u003d null)\n                                        {\n                                            pleaseWait.setText(\"Parsing Files...(\" + index + \"/\" + raidCount + \")\");\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            log.info(\"Could not retrieve raids\");\n            e.printStackTrace();\n        }\n        raids.sort(Comparator.comparing(SimpleTOBData::getDate));\n        return raids;\n    }\n\n    public static void parseLogFile(ArrayList\u003cSimpleTOBData\u003e raids, File currentFile, String filePath) throws Exception\n    {\n        Scanner logReader \u003d new Scanner(Files.newInputStream(currentFile.toPath()));\n        ArrayList\u003cString\u003e raid \u003d new ArrayList\u003c\u003e();\n        boolean raidActive \u003d false;\n        boolean spectate \u003d false;\n        boolean lateStart \u003d false;\n        while (logReader.hasNextLine())\n        {\n            String line \u003d logReader.nextLine();\n            String[] lineSplit \u003d line.split(\",\");\n            if (!raidActive)\n            {\n                if (lineSplit.length \u003e 3)\n                {\n                    if (Integer.parseInt(lineSplit[3]) \u003d\u003d 0)\n                    {\n                        raid.add(line);\n                        raidActive \u003d true;\n                        spectate \u003d false;\n                        lateStart \u003d false;\n                    }\n                }\n            } else\n            {\n                if (lineSplit.length \u003e 3)\n                {\n                    int value \u003d Integer.parseInt(lineSplit[3]);\n                    if(value !\u003d 0)\n                    {\n                        if(value !\u003d 801 \u0026\u0026 value !\u003d 576 \u0026\u0026 value !\u003d 587)\n                        {\n                            if (Integer.parseInt(lineSplit[3]) \u003d\u003d 99 \u0026\u0026 !spectate)\n                            {\n                                spectate \u003d true;\n                                raid.add(line);\n                            } else if (value \u003d\u003d 98 \u0026\u0026 !lateStart)\n                            {\n                                lateStart \u003d true;\n                                raid.add(line);\n                            } else if (Integer.parseInt(lineSplit[3]) \u003d\u003d 4)\n                            {\n                                raid.add(line);\n                                raidActive \u003d false;\n                                raids.add(new SimpleTOBData(raid.toArray(new String[0]), filePath, currentFile.getName()));\n                                raid.clear();\n                            } else if (value !\u003d 99 \u0026\u0026 value !\u003d 98)\n                            {\n                                raid.add(line);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        logReader.close();\n    }\n\n    private void buildComponents()\n    {\n        JPanel container \u003d new JPanel();\n        JPanel primaryContainer \u003d new JPanel();\n\n        primaryContainer.setLayout(new GridLayout(5, 1));\n\n        JButton viewRaidsButton \u003d new JButton(\"View All Raids\");\n        JButton refreshRaidsButton \u003d new JButton(\"Refresh\");\n\n        JButton tableRaidsButton \u003d new JButton(\"View Saved Raids From Table\");\n\n        viewRaidsButton.addActionListener(\n                al -\u003e\n                        new Thread(() -\u003e\n                        {\n                            raids \u003d new Raids(config, itemManager, plugin.clientThread, configManager);\n                            raids.createFrame(raidsData);\n                            raids.getContentPane().setBackground(Color.BLACK);\n                            raids.repaint();\n                            raids.open();\n                        }).start());\n\n        refreshRaidsButton.addActionListener(\n                al -\u003e\n                        new Thread(() -\u003e\n                        {\n                            viewRaidsButton.setEnabled(false);\n                            tableRaidsButton.setEnabled(false);\n                            raidCountLabel.setText(\"Refreshing, Please Wait...\");\n                            raidsData \u003d getAllRaids();\n                            DefaultTableModel model \u003d getTableModel();\n                            loadRaidsTable.setModel(model);\n                            if(raids !\u003d null)\n                            {\n                                raids.clearData();\n                                raids \u003d null;\n                            }\n                            viewRaidsButton.setEnabled(true);\n                            tableRaidsButton.setEnabled(true);\n                            updateRaidCountLabel();\n                        }).start());\n\n        tableRaidsButton.addActionListener(\n                al -\u003e\n                {\n                    raids \u003d new Raids(config, itemManager, plugin.clientThread, configManager);\n                    raids.createFrame(getTableData());\n                    raids.getContentPane().setBackground(Color.BLACK);\n                    raids.repaint();\n                    raids.open();\n                }\n        );\n\n        JButton livePanelButton \u003d new JButton(\"View Live Room\");\n        livePanelButton.addActionListener(al -\u003e\n                plugin.openLiveFrame());\n\n        raidCountLabel \u003d new JLabel(\"\", SwingConstants.CENTER);\n        updateRaidCountLabel();\n        primaryContainer.add(raidCountLabel);\n        primaryContainer.add(refreshRaidsButton);\n        primaryContainer.add(viewRaidsButton);\n        primaryContainer.add(tableRaidsButton);\n        primaryContainer.add(livePanelButton);\n\n        DefaultTableModel model \u003d getTableModel();\n        loadRaidsTable \u003d new JTable(model)\n        {\n            @Override\n            public Class\u003c?\u003e getColumnClass(int column)\n            {\n                if (column \u003d\u003d 0)\n                {\n                    return String.class;\n                }\n                return Boolean.class;\n            }\n        };\n\n        loadRaidsTable.setPreferredScrollableViewportSize(loadRaidsTable.getPreferredScrollableViewportSize());\n        JScrollPane scrollPane \u003d new JScrollPane(loadRaidsTable);\n        scrollPane.setPreferredSize(new Dimension(225, scrollPane.getPreferredSize().height));\n        container.add(primaryContainer);\n        container.add(scrollPane);\n        add(container);\n    }\n\n    private DefaultTableModel getTableModel()\n    {\n        Object[] columnNames \u003d {\"File Name\", \"Include?\"};\n        raidSets \u003d RaidsManager.getRaidsSets();\n        Object[][] tableData \u003d new Object[raidSets.size()][2];\n        for (int i \u003d 0; i \u003c raidSets.size(); i++)\n        {\n            tableData[i] \u003d new Object[]{raidSets.get(i).filename, false};\n        }\n        return new DefaultTableModel(tableData, columnNames);\n    }\n\n    private ArrayList\u003cSimpleTOBData\u003e getTableData()\n    {\n        ArrayList\u003cString\u003e includedSets \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c loadRaidsTable.getRowCount(); i++)\n        {\n            if ((boolean) loadRaidsTable.getValueAt(i, 1))\n            {\n                includedSets.add((String) loadRaidsTable.getValueAt(i, 0));\n            }\n        }\n        ArrayList\u003cSimpleTOBData\u003e collectedRaids \u003d new ArrayList\u003c\u003e();\n        for (RaidsArrayWrapper set : raidSets)\n        {\n            for (String s : includedSets)\n            {\n                if (s.equals(set.filename))\n                {\n                    collectedRaids.addAll(set.data);\n                }\n            }\n        }\n        return collectedRaids;\n    }\n\n    private void updateRaidCountLabel()\n    {\n        raidCountLabel.setText(\"Raids Found: \" + raidsData.size());\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\RaidTrackerSidePanel.java"},{"fileName":"StatisticRoomPanel.java","content":"package com.advancedraidtracker.ui.statistics;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport com.advancedraidtracker.utility.StatisticGatherer;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\nimport java.util.Objects;\n\nimport static com.advancedraidtracker.utility.UISwingUtility.getDarkJLabel;\n\n@Slf4j\npublic class StatisticRoomPanel extends JPanel\n{\n    public enum stat\n    {\n        AVERAGE,\n        MEDIAN,\n        MODE,\n        MINIMUM,\n        MAXIMUM\n    }\n\n    private final ArrayList\u003cJLabel\u003e timeLabels;\n    private final ArrayList\u003cString\u003e labelNames;\n    private final stat type;\n\n    public StatisticRoomPanel(ArrayList\u003cSimpleTOBData\u003e data, stat type, DataPoint.rooms room)\n    {\n        super();\n        JPanel subPanel \u003d new JPanel();\n        this.type \u003d type;\n        timeLabels \u003d new ArrayList\u003c\u003e();\n        ArrayList\u003cJLabel\u003e nameLabels \u003d new ArrayList\u003c\u003e();\n        labelNames \u003d DataPoint.getTimeNamesByRoom(room);\n        for (String s : labelNames)\n        {\n            nameLabels.add(getDarkJLabel(s.substring(s.indexOf(\u0027 \u0027) + 1), SwingConstants.LEFT));\n            timeLabels.add(getDarkJLabel(\"-\", SwingConstants.RIGHT));\n        }\n        String borderString \u003d \"\";\n        switch (type)\n        {\n            case AVERAGE:\n                borderString \u003d \"Average\";\n                break;\n            case MEDIAN:\n                borderString \u003d \"Median\";\n                break;\n            case MODE:\n                borderString \u003d \"Mode\";\n                break;\n            case MAXIMUM:\n                borderString \u003d \"Maximum\";\n                break;\n            case MINIMUM:\n                borderString \u003d \"Minimum\";\n                break;\n        }\n        setLayout(new BorderLayout());\n        setBorder(BorderFactory.createTitledBorder(borderString));\n        subPanel.setLayout(new GridLayout(0, 2));\n        for (int i \u003d 0; i \u003c labelNames.size(); i++)\n        {\n            subPanel.add(nameLabels.get(i));\n            subPanel.add(timeLabels.get(i));\n        }\n        for (int i \u003d labelNames.size(); i \u003c 14; i++)\n        {\n            subPanel.add(new JLabel(\"\"));\n            subPanel.add(new JLabel(\"\"));\n        }\n        subPanel.setPreferredSize(new Dimension(100, 200));\n        JScrollPane scrollPane \u003d new JScrollPane(subPanel);\n        scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);\n\n        add(scrollPane);\n        updateLabels(data);\n    }\n\n    public void updateLabels(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for (int i \u003d 0; i \u003c labelNames.size(); i++)\n        {\n            ArrayList\u003cInteger\u003e collectedData \u003d new ArrayList\u003c\u003e();\n            for (SimpleTOBData d : data)\n            {\n                if (d.getTimeAccurate(Objects.requireNonNull(DataPoint.getValue(labelNames.get(i)))))\n                {\n                    if (Objects.requireNonNull(DataPoint.getValue(labelNames.get(i))).type !\u003d DataPoint.types.TIME || d.getValue(labelNames.get(i)) !\u003d 0)\n                    {\n                        collectedData.add(d.getValue(labelNames.get(i)));\n                    }\n                }\n            }\n            double statistic \u003d 0;\n            switch (type)\n            {\n                case AVERAGE:\n                    statistic \u003d StatisticGatherer.getGenericAverage(collectedData);\n                    break;\n                case MEDIAN:\n                    statistic \u003d StatisticGatherer.getGenericMedian(collectedData);\n                    break;\n                case MODE:\n                    statistic \u003d StatisticGatherer.getGenericMode(collectedData);\n                    break;\n                case MINIMUM:\n                    statistic \u003d StatisticGatherer.getGenericMin(collectedData, true);\n                    break;\n                case MAXIMUM:\n                    statistic \u003d StatisticGatherer.getGenericMax(collectedData);\n                    break;\n            }\n            timeLabels.get(i).setText(RoomUtil.time(statistic));\n        }\n        validate();\n        repaint();\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\statistics\\StatisticRoomPanel.java"},{"fileName":"StatisticTab.java","content":"package com.advancedraidtracker.ui.statistics;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.ArrayList;\n\npublic class StatisticTab extends JPanel\n{\n    private final ArrayList\u003cStatisticRoomPanel\u003e panels;\n    DataPoint.rooms room;\n    ArrayList\u003cSimpleTOBData\u003e data;\n\n    public StatisticTab(ArrayList\u003cSimpleTOBData\u003e data, DataPoint.rooms room)\n    {\n        this.room \u003d room;\n        this.data \u003d data;\n        JPanel panel \u003d new JPanel();\n        panels \u003d new ArrayList\u003c\u003e();\n        panel.setLayout(new GridLayout(2, 3));\n        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.AVERAGE, room));\n        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MEDIAN, room));\n        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MODE, room));\n        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MINIMUM, room));\n        panels.add(new StatisticRoomPanel(data, StatisticRoomPanel.stat.MAXIMUM, room));\n        setLayout(new GridLayout(2, 3));\n        for (StatisticRoomPanel roomPanel : panels)\n        {\n            add(roomPanel);\n        }\n        JPanel statistics \u003d new JPanel();\n        statistics.setBorder(BorderFactory.createTitledBorder(\"Statistics\"));\n        add(statistics);\n\n        validate();\n        repaint();\n    }\n\n    public void updateTab(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        for (StatisticRoomPanel roomPanel : panels)\n        {\n            roomPanel.updateLabels(data);\n        }\n    }\n\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\statistics\\StatisticTab.java"},{"fileName":"ViewTOBRaid.java","content":"package com.advancedraidtracker.ui.viewraid;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.ui.BaseFrame;\nimport com.advancedraidtracker.utility.RoomUtil;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.util.Calendar;\n\nimport static com.advancedraidtracker.utility.datautility.DataPoint.NYLO_LAST_DEAD;\n\n@Slf4j\npublic class ViewTOBRaid extends BaseFrame\n{\n    String INCOMPLETE_MARKER \u003d \"-\";\n\n    public ViewTOBRaid(SimpleTOBData data)\n    {\n        String red \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#FF0000\u0027\u003e\";\n        String soft \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#666666\u0027\u003e\";\n        String dark \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#404040\u0027\u003e\";\n        String green \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#33FF33\u0027\u003e\";\n        String blue \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#6666DD\u0027\u003e\";\n        String white \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#BBBBBB\u0027\u003e\";\n\n        setTitle(\"View Raid\");\n        setLayout(new BoxLayout(getContentPane(), BoxLayout.Y_AXIS));\n\n        JPanel thisSubPanel \u003d new JPanel();\n        thisSubPanel.setLayout(new GridLayout(2, 3));\n\n        String maidenColor \u003d (data.maidenTimeAccurate) ? green : (data.maidenStartAccurate || data.maidenEndAccurate) ? blue : red;\n        String bloatColor \u003d (data.bloatTimeAccurate) ? green : (data.bloatStartAccurate || data.bloatEndAccurate) ? blue : red;\n        String nyloColor \u003d (data.nyloTimeAccurate) ? green : (data.nyloStartAccurate || data.nyloEndAccurate) ? blue : red;\n        String soteColor \u003d (data.soteTimeAccurate) ? green : (data.soteStartAccurate || data.soteEndAccurate) ? blue : red;\n        String xarpColor \u003d (data.xarpTimeAccurate) ? green : (data.xarpStartAccurate || data.xarpEndAccurate) ? blue : red;\n        String verzikColor \u003d (data.verzikTimeAccurate) ? green : (data.verzikStartAccurate || data.verzikEndAccurate) ? blue : red;\n\n        String maidenBodyColor \u003d (data.maidenTimeAccurate) ? white : (data.maidenStartAccurate || data.maidenEndAccurate) ? soft : dark;\n        String bloatBodyColor \u003d (data.bloatTimeAccurate) ? white : (data.bloatStartAccurate || data.bloatEndAccurate) ? soft : dark;\n        String nyloBodyColor \u003d (data.nyloTimeAccurate) ? white : (data.nyloStartAccurate || data.nyloEndAccurate) ? soft : dark;\n        String soteBodyColor \u003d (data.soteTimeAccurate) ? white : (data.soteStartAccurate || data.soteEndAccurate) ? soft : dark;\n        String xarpBodyColor \u003d (data.xarpTimeAccurate) ? white : (data.xarpStartAccurate || data.xarpEndAccurate) ? soft : dark;\n        String verzikBodyColor \u003d (data.verzikTimeAccurate) ? white : (data.verzikStartAccurate || data.verzikEndAccurate) ? soft : dark;\n\n        JPanel maidenPanel \u003d new JPanel();\n        maidenPanel.setLayout(new BorderLayout());\n\n        int maidenEntry \u003d 0;\n        int maidenSplit \u003d data.getMaidenTime();\n\n        int bloatEntry \u003d maidenEntry + maidenSplit;\n        int bloatSplit \u003d data.getBloatTime();\n\n        int nyloEntry \u003d bloatEntry + bloatSplit;\n        int nyloSplit \u003d data.getNyloTime();\n\n        int soteEntry \u003d nyloEntry + nyloSplit;\n        int soteSplit \u003d data.getSoteTime();\n\n        int xarpEntry \u003d soteEntry + soteSplit;\n        int xarpSplit \u003d data.getXarpTime();\n\n        int verzikEntry \u003d xarpEntry + xarpSplit;\n\n        String bloatSplitStr \u003d RoomUtil.time(bloatSplit);\n\n        String nyloEntryStr \u003d RoomUtil.time(nyloEntry);\n        String nyloSplitStr \u003d RoomUtil.time(nyloSplit);\n\n        String soteEntryStr \u003d RoomUtil.time(soteEntry);\n        String soteSplitStr \u003d RoomUtil.time(soteSplit);\n\n        String xarpEntryStr \u003d RoomUtil.time(xarpEntry);\n        String xarpSplitStr \u003d RoomUtil.time(xarpSplit);\n\n        String verzikEntryStr \u003d RoomUtil.time(verzikEntry);\n\n        maidenPanel.setBorder(BorderFactory.createTitledBorder(maidenColor + \"Maiden\" + ((data.maidenScuffed) ? \" (Scuffed after \" + data.firstMaidenCrabScuffed + \")\" : \"\")));\n\n        JPanel bloatPanel \u003d new JPanel();\n        bloatPanel.setLayout(new BorderLayout());\n        bloatPanel.setBorder(BorderFactory.createTitledBorder(bloatColor + \"Bloat - \" + bloatBodyColor + nyloEntryStr + \" (\" + bloatSplitStr + \")\"));\n\n        JPanel nylocasPanel \u003d new JPanel();\n        nylocasPanel.setLayout(new BorderLayout());\n        nylocasPanel.setBorder(BorderFactory.createTitledBorder(nyloColor + \"Nylocas - \" + nyloBodyColor + soteEntryStr + \" (\" + nyloSplitStr + \")\"));\n\n        JPanel sotetsegPanel \u003d new JPanel();\n        sotetsegPanel.setLayout(new BorderLayout());\n        sotetsegPanel.setBorder(BorderFactory.createTitledBorder(soteColor + \"Sotetseg - \" + soteBodyColor + xarpEntryStr + \" (\" + soteSplitStr + \")\"));\n\n        JPanel xarpusPanel \u003d new JPanel();\n        xarpusPanel.setLayout(new BorderLayout());\n        xarpusPanel.setBorder(BorderFactory.createTitledBorder(xarpColor + \"Xarpus - \" + xarpBodyColor + verzikEntryStr + \" (\" + xarpSplitStr + \")\"));\n\n        JPanel verzikPanel \u003d new JPanel();\n        verzikPanel.setLayout(new BorderLayout());\n        verzikPanel.setBorder(BorderFactory.createTitledBorder(verzikColor + \"Verzik\"));\n\n        JPanel maidenSubPanel \u003d new JPanel();\n        GridLayout gl \u003d new GridLayout(10, 2);\n        maidenSubPanel.setLayout(gl);\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Blood Spawned (thrown)\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_BLOOD_SPAWNED) + \" (\" + data.getValue(DataPoint.MAIDEN_BLOOD_THROWN) + \")\"));\n\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Defense\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + ((data.maidenDefenseAccurate) ? data.getValue(DataPoint.MAIDEN_DEFENSE) : INCOMPLETE_MARKER)));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Crabs leaked\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_CRABS_LEAKED) + \", HP: \" + data.getValue(DataPoint.MAIDEN_HP_HEALED)));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"100% leaked\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_CRABS_LEAKED_FULL_HP)));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Scuffed?\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + ((data.maidenScuffed) ? data.firstMaidenCrabScuffed : \"No\")));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Deaths\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + data.getValue(DataPoint.MAIDEN_DEATHS)));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"70s\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_70_SPLIT))));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"50s\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_50_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.MAIDEN_50_SPLIT) - data.getValue(DataPoint.MAIDEN_70_SPLIT)) + \")\"));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"30s\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getValue(DataPoint.MAIDEN_30_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.MAIDEN_30_SPLIT) - data.getValue(DataPoint.MAIDEN_50_SPLIT)) + \")\"));\n\n        maidenSubPanel.add(new JLabel(maidenBodyColor + \"Room time\"));\n        maidenSubPanel.add(new JLabel(maidenBodyColor + RoomUtil.time(data.getMaidenTime()) + \" (\" + RoomUtil.time(data.getMaidenTime() - data.getValue(DataPoint.MAIDEN_30_SPLIT)) + \")\"));\n\n        JPanel bloatSubPanel \u003d new JPanel();\n        bloatSubPanel.setLayout(new GridLayout(8, 2));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Downs\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_DOWNS)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Deaths (1st walk)\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_WALK_DEATHS)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Deaths (Total)\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_DEATHS)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Defense (1st walk)\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + ((data.bloatDefenseAccurate) ?String.valueOf(data.getValue(DataPoint.BLOAT_DEFENSE)) : INCOMPLETE_MARKER)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Scythes 1st walk\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_WALK_SCYTHES)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"HP % 1st down\"));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + (((double) data.getValue(DataPoint.BLOAT_HP_FIRST_DOWN))) + \"%\"));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"1st down time\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + data.getValue(DataPoint.BLOAT_FIRST_DOWN_TIME)));\n\n        bloatSubPanel.add(new JLabel(bloatBodyColor + \"Room time\"));\n        bloatSubPanel.add(new JLabel(bloatBodyColor + RoomUtil.time(data.getBloatTime())));\n\n\n        JPanel nylocasSubPanel \u003d new JPanel();\n        nylocasSubPanel.setLayout(new GridLayout(9, 2));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Stalls\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + data.getValue(DataPoint.NYLO_STALLS_PRE_20) + \" \" + data.getValue(DataPoint.NYLO_STALLS_POST_20) + \" (\" + (data.getValue(DataPoint.NYLO_STALLS_TOTAL)) + \")\"));\n\n        String nyloSplits \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#999999\u0027\u003e\"\n                + data.getValue(DataPoint.NYLO_SPLITS_MELEE)\n                + \"\u003cfont color\u003d\u0027#00AA00\u0027\u003e \"\n                + data.getValue(DataPoint.NYLO_SPLITS_RANGE)\n                + \"\u003cfont color \u003d\u0027#2299FF\u0027\u003e \"\n                + data.getValue(DataPoint.NYLO_SPLITS_MAGE);\n        if (nyloBodyColor.equals(dark))\n        {\n            nyloSplits \u003d nyloBodyColor\n                    + data.getValue(DataPoint.NYLO_SPLITS_MELEE) + \" \"\n                    + data.getValue(DataPoint.NYLO_SPLITS_RANGE) + \" \"\n                    + data.getValue(DataPoint.NYLO_SPLITS_MAGE);\n        } else if (nyloBodyColor.equals(soft))\n        {\n            nyloSplits \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#444444\u0027\u003e\"\n                    + data.getValue(DataPoint.NYLO_SPLITS_MELEE) + \"\u003cfont color\u003d\u0027#008800\u0027\u003e \"\n                    + data.getValue(DataPoint.NYLO_SPLITS_RANGE) + \"\u003cfont color \u003d\u0027#0066CC\u0027\u003e \"\n                    + data.getValue(DataPoint.NYLO_SPLITS_MAGE);\n        }\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Splits\"));\n        nylocasSubPanel.add(new JLabel(nyloSplits));\n\n        String nyloRotations \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#999999\u0027\u003e\"\n                + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + \"\u003cfont color\u003d\u0027#00AA00\u0027\u003e \"\n                + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + \"\u003cfont color \u003d\u0027#2299FF\u0027\u003e \"\n                + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);\n\n        if (nyloBodyColor.equals(dark))\n        {\n            nyloRotations \u003d nyloBodyColor\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + \" \"\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + \" \"\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);\n        } else if (nyloBodyColor.equals(soft))\n        {\n            nyloRotations \u003d \"\u003chtml\u003e\u003cfont color\u003d\u0027#444444\u0027\u003e\"\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_MELEE) + \"\u003cfont color\u003d\u0027#008800\u0027\u003e \"\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_RANGE) + \"\u003cfont color \u003d\u0027#0066CC\u0027\u003e \"\n                    + data.getValue(DataPoint.NYLO_ROTATIONS_MAGE);\n        }\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Rotations\"));\n        nylocasSubPanel.add(new JLabel(nyloRotations));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Defense\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + ((data.nyloDefenseAccurate) ? String.valueOf(data.getValue(DataPoint.NYLO_DEFENSE)) : INCOMPLETE_MARKER)));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Deaths\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + data.getValue(DataPoint.NYLO_DEATHS)));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Last wave\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(DataPoint.NYLO_LAST_WAVE))));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Clean up\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(NYLO_LAST_DEAD)) + \" (\" + RoomUtil.time(data.getValue(NYLO_LAST_DEAD) - data.getValue(DataPoint.NYLO_LAST_WAVE)) + \")\"));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Boss Spawn\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getValue(DataPoint.NYLO_BOSS_SPAWN)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.NYLO_BOSS_SPAWN) - data.getValue(NYLO_LAST_DEAD)) + \")\"));\n\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + \"Time\"));\n        nylocasSubPanel.add(new JLabel(nyloBodyColor + RoomUtil.time(data.getNyloTime()) + \" (\" + RoomUtil.time(data.getNyloTime() - data.getValue(DataPoint.NYLO_BOSS_SPAWN)) + \")\"));\n\n        JPanel sotetsegSubPanel \u003d new JPanel();\n        sotetsegSubPanel.setLayout(new GridLayout(8, 2));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"Hammers hit\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + ((data.soteDefenseAccurate) ? data.getValue(DataPoint.SOTE_SPECS_P1) + \" \" + data.getValue(DataPoint.SOTE_SPECS_P2) + \" \" + data.getValue(DataPoint.SOTE_SPECS_P3) + \" (\" + (data.getValue(DataPoint.SOTE_SPECS_TOTAL)) + \")\" : INCOMPLETE_MARKER)));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"Deaths\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + data.getValue(DataPoint.SOTE_DEATHS)));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"First Maze Start\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_P1_SPLIT))));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"First Maze End\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_M1_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.SOTE_M1_SPLIT) - data.getValue(DataPoint.SOTE_P1_SPLIT)) + \")\"));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"Second Maze Start\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_P2_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.SOTE_P2_SPLIT) - data.getValue(DataPoint.SOTE_M1_SPLIT)) + \")\"));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"Second Maze End\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getValue(DataPoint.SOTE_M2_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.SOTE_M2_SPLIT) - data.getValue(DataPoint.SOTE_P2_SPLIT)) + \")\"));\n\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + \"Time\"));\n        sotetsegSubPanel.add(new JLabel(soteBodyColor + RoomUtil.time(data.getSoteTime()) + \" (\" + RoomUtil.time(data.getSoteTime() - data.getValue(DataPoint.SOTE_M2_SPLIT)) + \")\"));\n\n        JPanel xarpusSubPanel \u003d new JPanel();\n        xarpusSubPanel.setLayout(new GridLayout(8, 2));\n\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + \"Defense\"));\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + ((data.xarpDefenseAccurate) ? data.getValue(DataPoint.XARP_DEFENSE) : INCOMPLETE_MARKER)));\n\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + \"Deaths\"));\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + data.getValue(DataPoint.XARP_DEATHS)));\n\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + \"Healing\"));\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + data.getValue(DataPoint.XARP_HEALING)));\n\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + \"Screech\"));\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + RoomUtil.time(data.getValue(DataPoint.XARP_SCREECH))));\n\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + \"Time\"));\n        xarpusSubPanel.add(new JLabel(xarpBodyColor + RoomUtil.time(data.getXarpTime()) + \" (\" + RoomUtil.time(data.getXarpTime() - data.getValue(DataPoint.XARP_SCREECH)) + \")\"));\n\n        xarpusSubPanel.add(new JLabel(\"\"));\n        xarpusSubPanel.add(new JLabel(\"\"));\n\n        xarpusSubPanel.add(new JLabel(\"\"));\n        xarpusSubPanel.add(new JLabel(\"\"));\n\n        xarpusSubPanel.add(new JLabel(\"\"));\n        xarpusSubPanel.add(new JLabel(\"\"));\n\n        JPanel verzikSubPanel \u003d new JPanel();\n        verzikSubPanel.setLayout(new GridLayout(8, 2));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Bounces\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_BOUNCES)));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Deaths\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_DEATHS)));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Crabs Spawned\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + data.getValue(DataPoint.VERZIK_CRABS_SPAWNED)));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Phase 1\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_P1_SPLIT))));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Reds Proc\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_REDS_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.VERZIK_REDS_SPLIT) - data.getValue(DataPoint.VERZIK_P1_SPLIT)) + \")\"));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Phase 2\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getValue(DataPoint.VERZIK_P2_SPLIT)) + \" (\" + RoomUtil.time(data.getValue(DataPoint.VERZIK_P2_SPLIT) - data.getValue(DataPoint.VERZIK_P1_SPLIT)) + \")\"));\n\n        verzikSubPanel.add(new JLabel(verzikBodyColor + \"Time\"));\n        verzikSubPanel.add(new JLabel(verzikBodyColor + RoomUtil.time(data.getVerzikTime()) + \" (\" + RoomUtil.time(data.getVerzikTime() - data.getValue(DataPoint.VERZIK_P2_SPLIT)) + \")\"));\n\n        maidenPanel.add(maidenSubPanel);\n        bloatPanel.add(bloatSubPanel);\n        nylocasPanel.add(nylocasSubPanel);\n        sotetsegPanel.add(sotetsegSubPanel);\n        xarpusPanel.add(xarpusSubPanel);\n        verzikPanel.add(verzikSubPanel);\n\n        thisSubPanel.add(maidenPanel);\n        thisSubPanel.add(bloatPanel);\n        thisSubPanel.add(nylocasPanel);\n        thisSubPanel.add(sotetsegPanel);\n        thisSubPanel.add(xarpusPanel);\n        thisSubPanel.add(verzikPanel);\n\n        JPanel summaryPanel \u003d new JPanel();\n        summaryPanel.setLayout(new BorderLayout());\n        summaryPanel.setBorder(BorderFactory.createTitledBorder(\"Summary\"));\n        summaryPanel.setMinimumSize(new Dimension(100, 30));\n        Calendar cal \u003d Calendar.getInstance();\n        cal.setTime(data.raidStarted);\n        String dateString \u003d (cal.get(Calendar.MONTH) + 1) + \"-\" + cal.get(Calendar.DAY_OF_MONTH) + \"-\" + cal.get(Calendar.YEAR);\n        JPanel summarySubPanel \u003d new JPanel(new GridLayout(10, 1));\n        summarySubPanel.add(new JLabel(\"Date: \" + dateString));\n        String scaleString \u003d \"\";\n        switch (data.getScale())\n        {\n            case 1:\n                scaleString \u003d \"Solo\";\n                break;\n            case 2:\n                scaleString \u003d \"Duo\";\n                break;\n            case 3:\n                scaleString \u003d \"Trio\";\n                break;\n            case 4:\n                scaleString \u003d \"4 Man\";\n                break;\n            case 5:\n                scaleString \u003d \"5 Man\";\n                break;\n        }\n        summarySubPanel.add(new JLabel(\"Scale: \" + scaleString));\n        setSummaryStatus(data, summarySubPanel);\n        summarySubPanel.add(new JLabel(\"Time: \" + RoomUtil.time(data.getTimeSum())));\n        summarySubPanel.add(new JLabel(\"Players:\"));\n        for (String player : data.players.keySet())\n        {\n            summarySubPanel.add(new JLabel(\"        \" + player + \" (\" + data.players.get(player) + \")\"));\n        }\n\n        summaryPanel.add(summarySubPanel);\n\n        JPanel topPanel \u003d new JPanel();\n        topPanel.setLayout(new GridLayout(1, 3));\n        topPanel.add(summaryPanel);\n\n        JPanel thrallsPanel \u003d new JPanel();\n        thrallsPanel.setBorder(BorderFactory.createTitledBorder(\"Thralls\"));\n        thrallsPanel.setLayout(new GridLayout(7, 2));\n\n        thrallsPanel.add(new JLabel(\"Total Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_TOTAL)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Maiden Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_MAIDEN)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Bloat Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_BLOAT)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Nylo Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_NYLO)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Sotetseg Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_SOTE)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Xarpus Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_XARP)), SwingConstants.RIGHT));\n\n        thrallsPanel.add(new JLabel(\"Verzik Thrall Hits: \"));\n        thrallsPanel.add(new JLabel(String.valueOf(data.getValue(DataPoint.THRALL_ATTACKS_VERZIK)), SwingConstants.RIGHT));\n\n\n        JPanel vengPanel \u003d new JPanel();\n        vengPanel.setBorder(BorderFactory.createTitledBorder(\"Venges\"));\n        vengPanel.setLayout(new GridLayout(8, 2));\n\n        vengPanel.add(new JLabel(\"Venges\"));\n        vengPanel.add(new JLabel(\"(Procced/Cast): Damage\"));\n\n        vengPanel.add(new JLabel(\"All Rooms\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_TOTAL) + \"/\" + data.getValue(DataPoint.VENG_CASTS_TOTAL) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_TOTAL), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Maiden\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_MAIDEN) + \"/\" + data.getValue(DataPoint.VENG_CASTS_MAIDEN) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_MAIDEN), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Bloat\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_BLOAT) + \"/\" + data.getValue(DataPoint.VENG_CASTS_BLOAT) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_BLOAT), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Nylo\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_NYLO) + \"/\" + data.getValue(DataPoint.VENG_CASTS_NYLO) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_NYLO), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Sote\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_SOTE) + \"/\" + data.getValue(DataPoint.VENG_CASTS_SOTE) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_SOTE), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Xarp\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_XARP) + \"/\" + data.getValue(DataPoint.VENG_CASTS_XARP) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_XARP), SwingConstants.RIGHT));\n\n        vengPanel.add(new JLabel(\"Verzik\"));\n        vengPanel.add(new JLabel(\"(\" + data.getValue(DataPoint.VENG_PROCS_VERZIK) + \"/\" + data.getValue(DataPoint.VENG_CASTS_VERZIK) + \"): \" + data.getValue(DataPoint.VENG_DAMAGE_VERZIK), SwingConstants.RIGHT));\n\n        topPanel.add(thrallsPanel);\n        topPanel.add(vengPanel);\n\n        add(topPanel);\n        add(thisSubPanel);\n\n        pack();\n    }\n\n    private static void setSummaryStatus(SimpleTOBData data, JPanel summarySubPanel)\n    {\n        String raidStatusString;\n        if (data.maidenWipe)\n        {\n            raidStatusString \u003d \"Maiden Wipe\";\n        } else if (data.maidenReset)\n        {\n            raidStatusString \u003d \"Maiden Reset\";\n        } else if (data.bloatWipe)\n        {\n            raidStatusString \u003d \"Bloat Wipe\";\n        } else if (data.bloatReset)\n        {\n            raidStatusString \u003d \"Bloat Reset\";\n        } else if (data.nyloWipe)\n        {\n            raidStatusString \u003d \"Nylo Wipe\";\n        } else if (data.nyloReset)\n        {\n            raidStatusString \u003d \"Nylo Reset\";\n        } else if (data.soteWipe)\n        {\n            raidStatusString \u003d \"Sotetseg Wipe\";\n        } else if (data.soteReset)\n        {\n            raidStatusString \u003d \"Sotetseg Reset\";\n        } else if (data.xarpWipe)\n        {\n            raidStatusString \u003d \"Xarpus Wipe\";\n        } else if (data.xarpReset)\n        {\n            raidStatusString \u003d \"Xarpus Reset\";\n        } else if (data.verzikWipe)\n        {\n            raidStatusString \u003d \"Verzik Wipe\";\n        } else\n        {\n            raidStatusString \u003d \"Completion\";\n        }\n        summarySubPanel.add(new JLabel(\"Raid Status: \" + raidStatusString));\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\ui\\viewraid\\ViewTOBRaid.java"},{"fileName":"DataManager.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport com.advancedraidtracker.utility.wrappers.PlayerCorrelatedPointData;\nimport lombok.extern.slf4j.Slf4j;\n@Slf4j\npublic class DataManager\n{\n\n    private final DataPointIntWrapper[] data;\n    private final DataPointPlayerData[] playerSpecificData;\n\n\n    public DataManager()\n    {\n        data \u003d new DataPointIntWrapper[DataPoint.values().length];\n        for (int i \u003d 0; i \u003c DataPoint.values().length; i++)\n        {\n            data[i] \u003d new DataPointIntWrapper(DataPoint.values()[i]);\n        }\n\n        playerSpecificData \u003d new DataPointPlayerData[DataPoint.getPlayerSpecific().length];\n        for (int i \u003d 0; i \u003c DataPoint.getPlayerSpecific().length; i++)\n        {\n            playerSpecificData[i] \u003d new DataPointPlayerData(DataPoint.getValue(DataPoint.getPlayerSpecific()[i]));\n        }\n    }\n\n    public PlayerCorrelatedPointData getHighest(DataPoint point)\n    {\n        int highest \u003d 0;\n        String name \u003d \"\";\n        int index \u003d getPlayerSpecificIndex(point);\n        for (String player : playerSpecificData[index].specificPlayerData.keySet())\n        {\n            if (playerSpecificData[index].specificPlayerData.get(player) \u003e highest)\n            {\n                highest \u003d playerSpecificData[index].specificPlayerData.get(player);\n                name \u003d player;\n            }\n        }\n        return new PlayerCorrelatedPointData(name, highest);\n    }\n\n    int getPlayerSpecificIndex(DataPoint point)\n    {\n        int index \u003d 0;\n        for (String datapoint : DataPoint.getPlayerSpecific())\n        {\n            if (datapoint.equalsIgnoreCase(point.name))\n            {\n                return index;\n            }\n            index++;\n        }\n        return index;\n    }\n\n    public void incrementPlayerSpecific(DataPoint dataPoint, String player)\n    {\n        playerSpecificData[getPlayerSpecificIndex(dataPoint)].increment(player);\n    }\n\n    public void incrementPlayerSpecific(DataPoint dataPoint, String player, int valueAdded)\n    {\n        playerSpecificData[getPlayerSpecificIndex(dataPoint)].increment(player, valueAdded);\n    }\n\n    public void set(DataPoint point, int value)\n    {\n        data[point.ordinal()].setValue(value);\n    }\n\n    public int get(DataPoint point)\n    {\n        if(point \u003d\u003d null)\n        {\n            return -1;\n        }\n        return data[point.ordinal()].value;\n    }\n\n    public int get(String point)\n    {\n        DataPoint dataPoint \u003d DataPoint.getValue(point);\n        if (dataPoint !\u003d null)\n        {\n            return data[dataPoint.ordinal()].value;\n        }\n        return 0;\n    }\n\n    public void increment(DataPoint point, int valueAdded)\n    {\n        data[point.ordinal()].increment(valueAdded);\n    }\n\n    public void increment(DataPoint point)\n    {\n        data[point.ordinal()].increment();\n    }\n\n    public void hammer(DataPoint point)\n    {\n        data[point.ordinal()].setValue((int) (data[point.ordinal()].value * 0.7));\n    }\n\n    public void bgs(DataPoint point, int damage)\n    {\n        data[point.ordinal()].setValue(Math.max(0, data[point.ordinal()].value - damage));\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\DataManager.java"},{"fileName":"DataPoint.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Objects;\n\npublic enum DataPoint\n{\n\n    CHALLENGE_TIME(\"Challenge Time\", types.TIME, rooms.ANY),\n    OVERALL_TIME(\"Overall Time\", types.TIME, rooms.ANY),\n    TIME_OUTSIDE_ROOMS(\"Time Outside Rooms\", types.TIME, rooms.ANY),\n    MAIDEN_TOTAL_TIME(\"Maiden Time\", types.TIME, rooms.MAIDEN),\n    BLOAT_TOTAL_TIME(\"Bloat Time\", types.TIME, rooms.BLOAT),\n    NYLO_TOTAL_TIME(\"Nylocas Time\", types.TIME, rooms.NYLOCAS),\n    XARP_TOTAL_TIME(\"Xarpus Time\", types.TIME, rooms.XARPUS),\n    SOTE_TOTAL_TIME(\"Sotetseg Time\", types.TIME, rooms.SOTETSEG),\n    VERZIK_TOTAL_TIME(\"Verzik Time\", types.TIME, rooms.VERZIK),\n    MAIDEN_BLOOD_SPAWNED(\"Maiden blood spawned\", types.OTHER_INT, rooms.MAIDEN),\n    MAIDEN_BLOOD_THROWN(\"Maiden blood thrown\", types.OTHER_INT, rooms.MAIDEN),\n    MAIDEN_PLAYER_STOOD_IN_THROWN_BLOOD(\"Maiden player stood in thrown blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_PLAYER_STOOD_IN_SPAWNED_BLOOD(\"Maiden player stood in spawned blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_HEALS_FROM_THROWN_BLOOD(\"Maiden heals from thrown blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_HEALS_FROM_SPAWNED_BLOOD(\"Maiden heals from spawned blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_PLAYER_STOOD_IN_BLOOD(\"Maiden player stood in any blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_HEALS_FROM_ANY_BLOOD(\"Maiden heals from any blood\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_MELEE_DRAINS(\"Maiden drained melee\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_CRABS_LEAKED(\"Maiden crabs leaked\", types.OTHER_INT, rooms.MAIDEN),\n    MAIDEN_CRABS_LEAKED_FULL_HP(\"Maiden crabs leaked full\", types.OTHER_INT, rooms.MAIDEN),\n    MAIDEN_HP_HEALED(\"Maiden HP healed\", types.OTHER_INT, rooms.MAIDEN),\n    MAIDEN_DEFENSE(\"Maiden defense\", types.OTHER_INT, rooms.MAIDEN, 200),\n    MAIDEN_DEATHS(\"Maiden deaths\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_SPECS(\"Maiden dinhs specs\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_CRABS_HIT(\"Maiden dinhs crabs Hit\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_TARGETS_HIT(\"Maiden dinhs targets hit\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_AVERAGE_HP_HIT(\"Maiden dinhs average HP crab\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_PERCENT_TARGETS_CRAB(\"Maiden dinhs % crabs targeted\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_CRABS_UNDER_27_TARGETED(\"Maiden dinhs crab \u003c 27hp targeted\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_DINHS_CRABS_UNDER_27_TARGETED_PERCENT(\"Maiden dinhs crabs \u003c27hp targeted %\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_CHINS_THROWN(\"Maiden chins thrown\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_CHINS_THROWN_WRONG_DISTANCE(\"Maiden chins thrown wrong distance\", types.OTHER_INT, rooms.MAIDEN, true),\n    MAIDEN_CHIN_CORRECT_DISTANCE_PERCENT(\"Maiden chins correct distance %\", types.OTHER_INT, rooms.MAIDEN, true),\n    RAID_INDEX(\"Raid Index\", types.OTHER_INT, rooms.ANY),\n    PARTY_SIZE(\"Party Size\", types.OTHER_INT, rooms.ANY),\n\n    BLOAT_DOWNS(\"Bloat downs\", types.OTHER_INT, rooms.BLOAT),\n    BLOAT_HP_FIRST_DOWN(\"Bloat HP% 1st down\", types.OTHER_INT, rooms.BLOAT),\n    BLOAT_FIRST_WALK_SCYTHES(\"Bloat 1st walk scythes\", types.OTHER_INT, rooms.BLOAT, true),\n    BLOAT_FIRST_WALK_DEATHS(\"Bloat 1st walk deaths\", types.OTHER_INT, rooms.BLOAT, true),\n    BLOAT_DEFENSE(\"Bloat defense\", types.OTHER_INT, rooms.BLOAT, 100),\n    BLOAT_DEATHS(\"Bloat deaths\", types.OTHER_INT, rooms.BLOAT, true),\n    NYLO_STALLS_PRE_20(\"Nylo stalls pre 20\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_STALLS_POST_20(\"Nylo stalls post 20\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_STALLS_TOTAL(\"Nylo stalls total\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_SPLITS_RANGE(\"Nylo splits range\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_SPLITS_MAGE(\"Nylo splits mage\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_SPLITS_MELEE(\"Nylo splits melee\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_ROTATIONS_RANGE(\"Nylo rotations range\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_ROTATIONS_MAGE(\"Nylo rotations mage\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_ROTATIONS_MELEE(\"Nylo rotations melee\", types.OTHER_INT, rooms.NYLOCAS),\n    NYLO_DEFENSE(\"Nylo defense\", types.OTHER_INT, rooms.NYLOCAS, 50),\n    NYLO_DEATHS(\"Nylo deaths\", types.OTHER_INT, rooms.NYLOCAS, true),\n    SOTE_SPECS_P1(\"Sote specs p1\", types.OTHER_INT, rooms.SOTETSEG),\n    SOTE_SPECS_P2(\"Sote specs p2\", types.OTHER_INT, rooms.SOTETSEG),\n    SOTE_SPECS_P3(\"Sote specs p3\", types.OTHER_INT, rooms.SOTETSEG),\n    SOTE_SPECS_TOTAL(\"Sote specs total\", types.OTHER_INT, rooms.SOTETSEG),\n    SOTE_DEATHS(\"Sote deaths\", types.OTHER_INT, rooms.SOTETSEG, true),\n    XARP_HEALING(\"Xarp Healing\", types.OTHER_INT, rooms.XARPUS),\n    XARP_DEFENSE(\"Xarp defense\", types.OTHER_INT, rooms.XARPUS, 250),\n    XARP_DEATHS(\"Xarp deaths\", types.OTHER_INT, rooms.XARPUS, true),\n    VERZIK_BOUNCES(\"Verzik bounces\", types.OTHER_INT, rooms.VERZIK, true),\n    VERZIK_CRABS_SPAWNED(\"Verzik crabs spawned\", types.OTHER_INT, rooms.VERZIK),\n    VERZIK_REDS_SETS(\"Verzik Red Sets\", types.OTHER_INT, rooms.VERZIK),\n    VERZIK_REDS_PROC_PERCENT(\"Verzik Red Proc Percent\", types.OTHER_INT, rooms.VERZIK),\n    VERZIK_DEATHS(\"Verzik deaths\", types.OTHER_INT, rooms.VERZIK, true),\n    VERZIK_HP_AT_WEBS(\"Verzik HP% at webs\", types.OTHER_INT, rooms.VERZIK),\n    MAIDEN_70_SPLIT(\"Maiden 70s split\", types.TIME, rooms.MAIDEN),\n    MAIDEN_7050_SPLIT(\"Maiden 70-50s split\", types.TIME, rooms.MAIDEN),\n    MAIDEN_50_SPLIT(\"Maiden 50s split\", types.TIME, rooms.MAIDEN),\n    MAIDEN_5030_SPLIT(\"Maiden 50-30s split\", types.TIME, rooms.MAIDEN),\n    MAIDEN_30_SPLIT(\"Maiden 30s split\", types.TIME, rooms.MAIDEN),\n    MAIDEN_SKIP_SPLIT(\"Maiden Skip split\", types.TIME, rooms.MAIDEN),\n    BLOAT_FIRST_DOWN_TIME(\"Bloat 1st down time\", types.OTHER_INT, rooms.BLOAT),\n    NYLO_BOSS_SPAWN(\"Nylo boss spawn\", types.TIME, rooms.NYLOCAS),\n    NYLO_BOSS_DURATION(\"Nylo boss duration\", types.TIME, rooms.NYLOCAS),\n    NYLO_LAST_WAVE(\"Nylo last wave\", types.TIME, rooms.NYLOCAS),\n    NYLO_LAST_DEAD(\"Nylo last dead\", types.TIME, rooms.NYLOCAS),\n    NYLO_CLEANUP(\"Nylo cleanup\", types.TIME, rooms.NYLOCAS),\n    NYLOCAS_PILLAR_DESPAWN_TICK(\"Nylo Pillar despawn tick\", types.TIME, rooms.NYLOCAS),\n    SOTE_P1_SPLIT(\"Sote P1 split\", types.TIME, rooms.SOTETSEG),\n    SOTE_P2_SPLIT(\"Sote P2 split\", types.TIME, rooms.SOTETSEG),\n    SOTE_P2_DURATION(\"Sote P2 duration\", types.TIME, rooms.SOTETSEG),\n\n    SOTE_P3_DURATION(\"Sote P3 duration\", types.TIME, rooms.SOTETSEG),\n    SOTE_M1_SPLIT(\"Sote maze1 split\", types.TIME, rooms.SOTETSEG),\n    SOTE_M1_DURATION(\"Sote maze1 Duration\", types.TIME, rooms.SOTETSEG),\n    SOTE_M2_SPLIT(\"Sote maze2 split\", types.TIME, rooms.SOTETSEG),\n    SOTE_M2_DURATION(\"Sote maze2 duration\", types.TIME, rooms.SOTETSEG),\n    SOTE_MAZE_SUM(\"Sote mazes combined\", types.TIME, rooms.SOTETSEG),\n    XARP_SCREECH(\"Xarp screech\", types.TIME, rooms.XARPUS),\n    XARP_POST_SCREECH(\"Xarp post screech\", types.TIME, rooms.XARPUS),\n    VERZIK_P1_SPLIT(\"Verzik P1 split\", types.TIME, rooms.VERZIK),\n\n    VERZIK_P2_TILL_REDS(\"Verzik P2 until reds split\", types.TIME, rooms.VERZIK),\n    VERZIK_REDS_SPLIT(\"Verzik reds split\", types.TIME, rooms.VERZIK),\n    VERZIK_REDS_DURATION(\"Verzik reds duration\", types.TIME, rooms.VERZIK),\n    VERZIK_P2_SPLIT(\"Verzik P2 split\", types.TIME, rooms.VERZIK),\n    VERZIK_P2_DURATION(\"Verzik P2 duration\", types.TIME, rooms.VERZIK),\n    VERZIK_P3_DURATION(\"Verzik P3 duration\", types.TIME, rooms.VERZIK),\n\n    NYLO_ENTRY(\"Nylo Entry\", types.TIME, rooms.NYLOCAS),\n    SOTE_ENTRY(\"Sote Entry\", types.TIME, rooms.SOTETSEG),\n    XARP_ENTRY(\"Xarp Entry\", types.TIME, rooms.XARPUS),\n    VERZIK_ENTRY(\"Verzik Entry\", types.TIME, rooms.VERZIK),\n\n    ATTEMPTED_HAMMERS_MAIDEN(\"Maiden attempted hammers\", types.OTHER_INT, rooms.MAIDEN, true),\n    ATTEMPTED_HAMMERS_BLOAT(\"Bloat attempted hammers\", types.OTHER_INT, rooms.BLOAT, true),\n    ATTEMPTED_HAMMERS_NYLO(\"Nylo attempted hammers\", types.OTHER_INT, rooms.NYLOCAS, true),\n    ATTEMPTED_HAMMERS_SOTE(\"Sote attempted hammers\", types.OTHER_INT, rooms.SOTETSEG, true),\n    ATTEMPTED_HAMMERS_XARP(\"Xarp attempted hammers\", types.OTHER_INT, rooms.XARPUS, true),\n    ATTEMPTED_HAMMERS_VERZIK(\"Verzik attempted hammers\", types.OTHER_INT, rooms.VERZIK, true),\n    HIT_HAMMERS_MAIDEN(\"Maiden hit hammers\", types.OTHER_INT, rooms.MAIDEN, true),\n    HIT_HAMMERS_BLOAT(\"Bloat hit hammers\", types.OTHER_INT, rooms.BLOAT, true),\n    HIT_HAMMERS_NYLO(\"Nylo hit hammers\", types.OTHER_INT, rooms.NYLOCAS, true),\n    HIT_HAMMERS_SOTE(\"Sote hit hammers\", types.OTHER_INT, rooms.SOTETSEG, true),\n    HIT_HAMMERS_XARP(\"Xarp hit hammers\", types.OTHER_INT, rooms.XARPUS, true),\n    HIT_HAMMERS_VERZIK(\"Verzik hit hammers\", types.OTHER_INT, rooms.VERZIK, true),\n\n    ATTEMPTED_BGS_MAIDEN(\"Maiden attempted BGS\", types.OTHER_INT, rooms.MAIDEN, true),\n    BGS_DAMAGE_MAIDEN(\"Maiden BGS damage\", types.OTHER_INT, rooms.MAIDEN, true),\n\n    ATTEMPTED_BGS_BLOAT(\"Bloat attempted BGS\", types.OTHER_INT, rooms.BLOAT, true),\n    BGS_DAMAGE_BLOAT(\"Bloat BGS damage\", types.OTHER_INT, rooms.BLOAT, true),\n\n    ATTEMPTED_BGS_NYLO(\"Nylo attempted BGS\", types.OTHER_INT, rooms.NYLOCAS, true),\n    BGS_DAMAGE_NYLO(\"Nylo BGS damage\", types.OTHER_INT, rooms.NYLOCAS, true),\n\n    ATTEMPTED_BGS_SOTE(\"Sote attempted BGS\", types.OTHER_INT, rooms.SOTETSEG, true),\n    BGS_DAMAGE_SOTE(\"Sote BGS damage\", types.OTHER_INT, rooms.SOTETSEG, true),\n\n    ATTEMPTED_BGS_XARP(\"Xarp attempted BGS\", types.OTHER_INT, rooms.XARPUS, true),\n    BGS_DAMAGE_XARP(\"Xarp BGS damage\", types.OTHER_INT, rooms.XARPUS, true),\n\n    ATTEMPTED_BGS_VERZ(\"Verzik attempted BGS\", types.OTHER_INT, rooms.VERZIK, true),\n    BGS_DAMAGE_VERZ(\"Verzik BGS damage\", types.OTHER_INT, rooms.VERZIK, true),\n\n    THRALL_ATTACKS_TOTAL(\"Total thrall attacks\", types.OTHER_INT, rooms.ANY, true),\n    THRALL_ATTACKS_MAIDEN(\"Maiden thrall attacks\", types.OTHER_INT, rooms.MAIDEN, true),\n    THRALL_ATTACKS_BLOAT(\"Bloat thrall attacks\", types.OTHER_INT, rooms.BLOAT, true),\n    THRALL_ATTACKS_NYLO(\"Nylo thrall attacks\", types.OTHER_INT, rooms.NYLOCAS, true),\n    THRALL_ATTACKS_SOTE(\"Sote thrall attacks\", types.OTHER_INT, rooms.SOTETSEG, true),\n    THRALL_ATTACKS_XARP(\"Xarp thrall attacks\", types.OTHER_INT, rooms.XARPUS, true),\n    THRALL_ATTACKS_VERZIK(\"Verzik thrall attacks\", types.OTHER_INT, rooms.VERZIK, true),\n\n    THRALL_DAMAGE_TOTAL(\"Total thrall damage\", types.OTHER_INT, rooms.ANY, true),\n    THRALL_DAMAGE_MAIDEN(\"Maiden thrall damage\", types.OTHER_INT, rooms.MAIDEN, true),\n    THRALL_DAMAGE_BLOAT(\"Bloat thrall damage\", types.OTHER_INT, rooms.BLOAT, true),\n    THRALL_DAMAGE_NYLO(\"Nylo thrall damage\", types.OTHER_INT, rooms.NYLOCAS, true),\n    THRALL_DAMAGE_SOTE(\"Sote thrall damage\", types.OTHER_INT, rooms.SOTETSEG, true),\n    THRALL_DAMAGE_XARP(\"Xarp thrall damage\", types.OTHER_INT, rooms.XARPUS, true),\n    THRALL_DAMAGE_VERZIK(\"Verzik thrall damage\", types.OTHER_INT, rooms.VERZIK, true),\n\n    VENG_DAMAGE_TOTAL(\"Total veng damage\", types.OTHER_INT, rooms.ANY),\n    VENG_DAMAGE_MAIDEN(\"Maiden veng damage\", types.OTHER_INT, rooms.MAIDEN),\n    VENG_DAMAGE_BLOAT(\"Bloat veng damage\", types.OTHER_INT, rooms.BLOAT),\n    VENG_DAMAGE_NYLO(\"Nylo veng damage\", types.OTHER_INT, rooms.NYLOCAS),\n    VENG_DAMAGE_SOTE(\"Sote veng damage\", types.OTHER_INT, rooms.SOTETSEG),\n    VENG_DAMAGE_XARP(\"Xarp veng damage\", types.OTHER_INT, rooms.XARPUS),\n    VENG_DAMAGE_VERZIK(\"Verzik veng damage\", types.OTHER_INT, rooms.VERZIK),\n\n    VENG_CASTS_TOTAL(\"Total veng casts\", types.OTHER_INT, rooms.ANY),\n    VENG_CASTS_MAIDEN(\"Maiden veng casts\", types.OTHER_INT, rooms.MAIDEN),\n    VENG_CASTS_BLOAT(\"Bloat veng casts\", types.OTHER_INT, rooms.BLOAT),\n    VENG_CASTS_NYLO(\"Nylo veng casts\", types.OTHER_INT, rooms.NYLOCAS),\n    VENG_CASTS_SOTE(\"Sote veng casts\", types.OTHER_INT, rooms.SOTETSEG),\n    VENG_CASTS_XARP(\"Xarp veng casts\", types.OTHER_INT, rooms.XARPUS),\n    VENG_CASTS_VERZIK(\"Verzik veng casts\", types.OTHER_INT, rooms.VERZIK),\n\n    VENG_PROCS_TOTAL(\"Total veng procs\", types.OTHER_INT, rooms.ANY),\n    VENG_PROCS_MAIDEN(\"Maiden veng procs\", types.OTHER_INT, rooms.MAIDEN),\n    VENG_PROCS_BLOAT(\"Bloat veng procs\", types.OTHER_INT, rooms.BLOAT),\n    VENG_PROCS_NYLO(\"Nylo veng procs\", types.OTHER_INT, rooms.NYLOCAS),\n    VENG_PROCS_SOTE(\"Sote veng procs\", types.OTHER_INT, rooms.SOTETSEG),\n    VENG_PROCS_XARP(\"Xarp veng procs\", types.OTHER_INT, rooms.XARPUS),\n    VENG_PROCS_VERZIK(\"Verzik veng procs\", types.OTHER_INT, rooms.VERZIK),\n    KODAI_BOPS(\"Kodai bops\", types.OTHER_INT, rooms.ANY, true),\n    DWH_BOPS(\"DWH bops\", types.OTHER_INT, rooms.ANY, true),\n    CHALLY_POKE(\"Chally pokes\", types.OTHER_INT, rooms.ANY, true),\n    BGS_WHACKS(\"BGS whacks\", types.OTHER_INT, rooms.ANY, true),\n    TOTAL_DEATHS(\"Total deaths\", types.OTHER_INT, rooms.ANY, true),\n    DEATHS(\"Alternate Deaths\", types.OTHER_INT, rooms.ALL, true),\n    UNKNOWN(\"Unknown\", types.OTHER_BOOL, rooms.ANY);\n\n\n\n    public static DataPoint getValue(String s)\n    {\n        for (DataPoint point : values())\n        {\n            if (point.name.equals(s))\n            {\n                return point;\n            }\n        }\n        return DataPoint.UNKNOWN;\n    }\n\n    public enum rooms\n    {\n        ANY,\n        MAIDEN,\n        BLOAT,\n        NYLOCAS,\n        SOTETSEG,\n        XARPUS,\n        VERZIK,\n        ALL\n    }\n\n    public enum types\n    {\n        OTHER_INT, OTHER_BOOL, TIME\n    }\n\n    public final String name;\n    public final int value;\n    public final types type;\n    public final rooms room;\n    public final boolean playerSpecific;\n\n\n    DataPoint(String name, types type, rooms room)\n    {\n        this.name \u003d name;\n        this.value \u003d 0;\n        this.type \u003d type;\n        this.room \u003d room;\n        this.playerSpecific \u003d false;\n    }\n\n    DataPoint(String name, types type, rooms room, int value)\n    {\n        this.name \u003d name;\n        this.value \u003d value;\n        this.type \u003d type;\n        this.room \u003d room;\n        this.playerSpecific \u003d false;\n    }\n\n    DataPoint(String name, types type, rooms room, boolean playerSpecific)\n    {\n        this.playerSpecific \u003d playerSpecific;\n        this.name \u003d name;\n        this.value \u003d 0;\n        this.type \u003d type;\n        this.room \u003d room;\n    }\n\n    public static String[] getPlayerSpecific()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.playerSpecific)\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getOtherIntNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.type.equals(types.OTHER_INT))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getByNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            valuesToGather.add(point.name);\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getTimeNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.type.equals(types.TIME))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] filterTimes(String[] data)\n    {\n        ArrayList\u003cString\u003e filtered \u003d new ArrayList\u003c\u003e();\n        for (String s : data)\n        {\n            if (Objects.requireNonNull(DataPoint.getValue(s)).type \u003d\u003d types.TIME)\n            {\n                filtered.add(s);\n            }\n        }\n        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);\n    }\n\n    public static String[] filterInt(String[] data)\n    {\n        ArrayList\u003cString\u003e filtered \u003d new ArrayList\u003c\u003e();\n        for (String s : data)\n        {\n            DataPoint dp \u003d DataPoint.getValue(s);\n            if (dp !\u003d null \u0026\u0026 dp.type \u003d\u003d types.OTHER_INT \u0026\u0026 !dp.name.contains(\"thrall\") \u0026\u0026 !dp.name.contains(\"veng\")\n                    \u0026\u0026 !dp.name.contains(\"BGS\") \u0026\u0026 !dp.name.contains(\"hammers\") \u0026\u0026 !dp.name.contains(\"dinhs\"))\n            {\n                filtered.add(s);\n            }\n        }\n        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);\n    }\n\n    public static String[] filterThrall(String[] data)\n    {\n        ArrayList\u003cString\u003e filtered \u003d new ArrayList\u003c\u003e();\n        for (String s : data)\n        {\n            if (Objects.requireNonNull(DataPoint.getValue(s)).name.contains(\"thrall\"))\n            {\n                filtered.add(s);\n            }\n        }\n        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);\n    }\n\n    public static String[] filterVeng(String[] data)\n    {\n        ArrayList\u003cString\u003e filtered \u003d new ArrayList\u003c\u003e();\n        for (String s : data)\n        {\n            if (Objects.requireNonNull(DataPoint.getValue(s)).name.contains(\"veng\"))\n            {\n                filtered.add(s);\n            }\n        }\n        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);\n    }\n\n    public static String[] filterSpecs(String[] data)\n    {\n        ArrayList\u003cString\u003e filtered \u003d new ArrayList\u003c\u003e();\n        for (String s : data)\n        {\n            String name \u003d Objects.requireNonNull(DataPoint.getValue(s)).name;\n            if (name.contains(\"BGS\") || name.contains(\"hammers\") || name.contains(\"dinhs\"))\n            {\n                filtered.add(s);\n            }\n        }\n        return Arrays.copyOf(filtered.toArray(), filtered.size(), String[].class);\n    }\n\n\n    public static String[] getMaidenNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.MAIDEN))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getBloatNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.BLOAT))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getNyloNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.NYLOCAS))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getSoteNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.SOTETSEG))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getXarpNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.XARPUS))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getVerzikNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.VERZIK))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getAnyRoomNames()\n    {\n        ArrayList\u003cString\u003e valuesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(rooms.ANY))\n            {\n                valuesToGather.add(point.name);\n            }\n        }\n        return Arrays.copyOf(valuesToGather.toArray(), valuesToGather.size(), String[].class);\n    }\n\n    public static String[] getRoomTimes()\n    {\n        return new String[]{\"Challenge Time\", \"Overall Time\", \"Time Outside Rooms\", \"Maiden Time\", \"Bloat Time\", \"Nylocas Time\", \"Sotetseg Time\", \"Xarpus Time\", \"Verzik Time\"};\n    }\n\n    public static ArrayList\u003cString\u003e getTimeNamesByRoom(rooms room)\n    {\n        ArrayList\u003cString\u003e timesToGather \u003d new ArrayList\u003c\u003e();\n        for (DataPoint point : DataPoint.values())\n        {\n            if (point.room.equals(room) \u0026\u0026 point.type.equals(types.TIME))\n            {\n                timesToGather.add(point.name);\n            }\n        }\n        return timesToGather;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\DataPoint.java"},{"fileName":"DataPointIntWrapper.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class DataPointIntWrapper\n{\n    @Setter\n    @Getter\n    public int value \u003d 0;\n    DataPoint dataPoint;\n\n    public DataPointIntWrapper(DataPoint point)\n    {\n        dataPoint \u003d point;\n        if (point.equals(DataPoint.MAIDEN_DEFENSE))\n        {\n            value \u003d 200;\n        } else if (point.equals(DataPoint.BLOAT_DEFENSE))\n        {\n            value \u003d 100;\n        } else if (point.equals(DataPoint.NYLO_DEFENSE))\n        {\n            value \u003d 50;\n        } else if (point.equals(DataPoint.XARP_DEFENSE))\n        {\n            value \u003d 250;\n        } else if (point.equals(DataPoint.VERZIK_HP_AT_WEBS))\n        {\n            value \u003d -1;\n        }\n    }\n\n    public void increment(int valueAdded)\n    {\n        value +\u003d valueAdded;\n    }\n\n    public void increment()\n    {\n        value++;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\DataPointIntWrapper.java"},{"fileName":"DataPointPlayerData.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class DataPointPlayerData\n{\n    public Map\u003cString, Integer\u003e specificPlayerData;\n    public DataPoint datapoint;\n\n    public DataPointPlayerData(DataPoint datapoint)\n    {\n        this.datapoint \u003d datapoint;\n        specificPlayerData \u003d new LinkedHashMap\u003c\u003e();\n    }\n\n    public void increment(String player)\n    {\n        if (specificPlayerData.containsKey(player))\n        {\n            specificPlayerData.put(player, specificPlayerData.get(player) + 1);\n        } else\n        {\n            specificPlayerData.put(player, 1);\n        }\n    }\n\n    public void increment(String player, int valueAdded)\n    {\n        if (specificPlayerData.containsKey(player))\n        {\n            specificPlayerData.put(player, specificPlayerData.get(player) + valueAdded);\n        } else\n        {\n            specificPlayerData.put(player, valueAdded);\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\DataPointPlayerData.java"},{"fileName":"DataWriter.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerConfig;\nimport lombok.extern.slf4j.Slf4j;\nimport com.advancedraidtracker.constants.LogID;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Objects;\n\n@Slf4j\npublic class DataWriter\n{\n    private final AdvancedRaidTrackerConfig config;\n    private String activeUsername \u003d \"\";\n    private final ArrayList\u003cString\u003e currentBuffer;\n\n    public final static String PLUGIN_DIRECTORY \u003d System.getProperty(\"user.home\").replace(\"\\\\\", \"/\") + \"/.runelite/advancedraidtracker/\";\n\n    public DataWriter(AdvancedRaidTrackerConfig config) throws IOException\n    {\n        this.config \u003d config;\n        currentBuffer \u003d new ArrayList\u003c\u003e();\n    }\n\n    public void setName(String name) throws IOException\n    {\n        activeUsername \u003d name;\n        File dirMain \u003d new File(PLUGIN_DIRECTORY + name + \"/primary/\");\n        File dirFilters \u003d new File(PLUGIN_DIRECTORY + \"misc-dir/filters/\");\n        File dirRaids \u003d new File(PLUGIN_DIRECTORY + \"misc-dir/raids/\");\n\n        if (!dirRaids.exists())\n        {\n            if (!dirRaids.mkdirs())\n            {\n                log.info(\"Failed to create raids directory for username \" + name);\n            }\n        }\n        if (!dirMain.exists())\n        {\n            if (!dirMain.mkdirs())\n            {\n                log.info(\"Failed to create main directory for username \" + name);\n            }\n        }\n        if (!dirFilters.exists())\n        {\n            if (!dirFilters.mkdirs())\n            {\n                log.info(\"Failed to create filter directory for username \" + name);\n            }\n        }\n\n        File logFile \u003d new File(PLUGIN_DIRECTORY + name + \"/primary/tobdata.log\");\n        if (!logFile.exists())\n        {\n            if (!logFile.createNewFile())\n            {\n                log.info(\"Failed to create log file\");\n            }\n        }\n    }\n\n    //If you X out client in the middle of a raid it does not record the flag that the raid ended, so this is called when you enter a tob to see\n    //if an active datafile and if so it adds an exit flag to the end\n    public void checkForEndFlag()\n    {\n        File logFile \u003d new File(PLUGIN_DIRECTORY + activeUsername + \"/primary/tobdata.log\");\n        if (logFile.exists())\n        {\n            if (logFile.length() \u003e 0)\n            {\n                currentBuffer.add(\",\" + System.currentTimeMillis() + \",1,\" + 4 + \",\" + \",\" + \",\" + \",\" + \",\");\n                writeFile();\n            }\n        }\n    }\n\n    public void migrateToNewRaid()\n    {\n        int highest \u003d getHighestLogNumber(activeUsername);\n        File logFile \u003d new File(PLUGIN_DIRECTORY + activeUsername + \"/primary/tobdata.log\");\n        if (!logFile.exists())\n        {\n            log.info(\"Could not migrate because file does not exist\");\n            return;\n        }\n        if (logFile.length() \u003d\u003d 0)\n        {\n            return;\n        } //Inject number to log file before the \u0027.log\u0027 e.g. tobdata.log -\u003e tobdata\u003cnumber\u003e.log\n        if (!logFile.renameTo(new File(logFile.getAbsolutePath().substring(0, logFile.getAbsolutePath().length() - 4) + (highest + 1) + \".log\")))\n        {\n            log.info(\"Could not rename primary log file\");\n        } else\n        {\n            logFile \u003d new File(PLUGIN_DIRECTORY + activeUsername + \"/primary/tobdata.log\");\n            if (!logFile.exists())\n            {\n                try\n                {\n                    if (!logFile.createNewFile())\n                    {\n                        log.info(\"Replacement file creation unsuccessful\");\n                    }\n                } catch (Exception e)\n                {\n                    log.info(\"Exception thrown when creating replacement log file: \" + logFile.getAbsolutePath());\n                }\n            }\n        }\n    }\n\n    public static int getHighestLogNumber(String name)\n    {\n        String directory \u003d PLUGIN_DIRECTORY;\n        if (!name.isEmpty())\n        {\n            directory +\u003d name + \"/primary/\";\n        } else\n        {\n            directory +\u003d \"primary/\";\n        }\n        File logDirectory \u003d new File(directory);\n        if(!logDirectory.exists())\n        {\n            if(!logDirectory.mkdirs())\n            {\n                log.info(\"Could not make directory to find log number\");\n            }\n        }\n        int highestLogNumber \u003d 0;\n        for (File file : Objects.requireNonNull(new File(directory).listFiles()))\n        {\n            if (file.getName().contains(\"tobdata\"))\n            {\n                int index \u003d file.getName().indexOf(\".log\");\n                if (index !\u003d -1)\n                {\n                    try\n                    {\n                        int logNumber \u003d Integer.parseInt(file.getName().substring(7, index));\n                        if (logNumber \u003e highestLogNumber)\n                        {\n                            highestLogNumber \u003d logNumber;\n                        }\n                    } catch\n                    (Exception ignored)\n                    {\n                    }\n                }\n            }\n        }\n        return highestLogNumber;\n    }\n\n    /**\n     * Writes a message to the log with the time, message ID, and up to 5 additional parameters\n     *\n     * @param id LogID of message\n     */\n    public void addLine(LogID id, String... params)\n    {\n        if (params.length \u003e 5)\n            throw new IllegalArgumentException(\"Too many values passed to DataWriter\");\n        String[] values \u003d {\"\", \"\", \"\", \"\", \"\"};\n        System.arraycopy(params, 0, values, 0, params.length);\n        addLine(id.getId(), values[0], values[1], values[2], values[3], values[4]);\n    }\n\n    public void addLine(int key, String v1, String v2, String v3, String v4, String v5)\n    {\n        int versionID \u003d 1;\n        currentBuffer.add(getUID() + \",\" + System.currentTimeMillis() + \",\" + versionID + \",\" + key + \",\" + v1 + \",\" + v2 + \",\" + v3 + \",\" + v4 + \",\" + v5);\n    }\n\n    public static void writeAliasFile(String aliasText)\n    {\n        try\n        {\n            File aliasFile \u003d new File(PLUGIN_DIRECTORY + \"alias/alias.log\");\n            if (!aliasFile.exists())\n            {\n                File directory \u003d new File(PLUGIN_DIRECTORY + \"alias/\");\n                if (!directory.exists())\n                {\n                    if (!directory.mkdirs())\n                    {\n                        log.info(\"Failed to create alias directory\");\n                    }\n                }\n                if (!aliasFile.createNewFile())\n                {\n                    log.info(\"Failed to create alias file\");\n                }\n            }\n            BufferedWriter logger \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(PLUGIN_DIRECTORY + \"alias/alias.log\", false), StandardCharsets.UTF_8));\n            logger.write(aliasText);\n            logger.close();\n        } catch (IOException e)\n        {\n            log.info(\"Failed writing to alias file\");\n        }\n    }\n\n    public static ArrayList\u003cString\u003e readAliasFile()\n    {\n        ArrayList\u003cString\u003e lines \u003d new ArrayList\u003c\u003e();\n        BufferedReader reader;\n        try\n        {\n            reader \u003d new BufferedReader(new FileReader(PLUGIN_DIRECTORY + \"alias/alias.log\"));\n            String line \u003d reader.readLine();\n            while (line !\u003d null)\n            {\n                lines.add(line);\n                line \u003d reader.readLine();\n            }\n        } catch (Exception e)\n        {\n            return lines;\n        }\n        return lines;\n    }\n\n    public void writeFile()\n    {\n        if (config.writeToLog())\n        {\n            try\n            {\n                File logFile \u003d new File(PLUGIN_DIRECTORY + activeUsername + \"/primary/tobdata.log\");\n                if (!logFile.exists())\n                {\n                    if (!logFile.createNewFile())\n                    {\n                        log.info(\"Failed to create log file\");\n                    }\n                }\n                BufferedWriter logger \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(PLUGIN_DIRECTORY + activeUsername + \"/primary/tobdata.log\", true), StandardCharsets.UTF_8));\n                for (String msg : currentBuffer)\n                {\n                    logger.write(msg);\n                    logger.newLine();\n                }\n                logger.close();\n            } catch (IOException e)\n            {\n                log.info(\"Failed clearing buffered tob data to log\");\n            }\n        }\n        currentBuffer.clear();\n    }\n\n    public static void writeFile(ArrayList\u003cString\u003e raid, String filePath)\n    {\n        try\n        {\n            File logFile \u003d new File(filePath);\n            if (!logFile.exists())\n            {\n                if (!logFile.createNewFile())\n                {\n                    log.info(\"Failed to create log file\");\n                }\n            }\n            BufferedWriter logger \u003d new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filePath, true), StandardCharsets.UTF_8));\n            for (String msg : raid)\n            {\n                logger.write(msg);\n                logger.newLine();\n            }\n            logger.close();\n        } catch (IOException e)\n        {\n            log.info(\"Failed clearing buffered tob data to log\");\n        }\n    }\n\n\n    private String getUID()\n    {\n        return \"\";\n    } //deprecated\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\DataWriter.java"},{"fileName":"LegacyFileUtility.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.*;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Scanner;\n\nimport static com.advancedraidtracker.constants.TobIDs.EXIT_FLAG;\nimport static com.advancedraidtracker.utility.datautility.DataWriter.*;\n\n@Slf4j\npublic class LegacyFileUtility //Older versions of the plugin during testing used a different file structure, this class contains methods used to migrate those\n{\n    public static void splitLegacyFiles()\n    {\n        try\n        {\n            String path \u003d System.getProperty(\"user.home\").replace(\"\\\\\", \"/\") + \"/.runelite/theatretracker/primary/\"; //old directory\n            File logDirectory \u003d new File(path);\n            if (!logDirectory.exists())\n            {\n                return;\n            }\n            ArrayList\u003cString\u003e currentRaid \u003d new ArrayList\u003c\u003e();\n            for (File file : Objects.requireNonNull(logDirectory.listFiles()))\n            {\n                if (file.getName().contains(\"tobdata\") \u0026\u0026 !file.getName().contains(\"archive\"))\n                {\n                    Scanner logReader \u003d new Scanner(Files.newInputStream(file.toPath()));\n                    while (logReader.hasNextLine())\n                    {\n                        String line \u003d logReader.nextLine();\n                        String[] lineSplit \u003d line.split(\",\");\n                        currentRaid.add(line);\n                        if (Objects.equals(lineSplit[3], EXIT_FLAG))\n                        {\n                            int highestLog \u003d getHighestLogNumber(\"legacy-files\");\n                            writeFile(currentRaid, PLUGIN_DIRECTORY + \"legacy-files/primary/\" + \"tobdata\" + (highestLog + 1) + \".log\");\n                            currentRaid.clear();\n                        }\n                    }\n                    if (!file.renameTo(new File(file.getAbsolutePath().substring(0, file.getAbsolutePath().length()-4)+\"-archive.log\")))\n                    {\n                        log.info(\"failed to rename old file\");\n                    }\n                }\n            }\n            path \u003d System.getProperty(\"user.home\").replace(\"\\\\\", \"/\") + \"/.runelite/theatretracker/\";\n            File oldDirectory \u003d new File(path);\n            if(oldDirectory.exists())\n            {\n                for(File folder : Objects.requireNonNull(oldDirectory.listFiles()))\n                {\n                    if(folder.isDirectory() \u0026\u0026 !folder.getName().equals(\"primary\"))\n                    {\n                        try\n                        {\n                            File newSubDirectory \u003d new File(PLUGIN_DIRECTORY + \"misc-dir/\");\n                            if(!newSubDirectory.exists())\n                            {\n                                if(!newSubDirectory.mkdirs())\n                                {\n                                    log.info(\"Failed to create folder: \" + newSubDirectory.getAbsolutePath());\n                                }\n                            }\n                            Files.move(folder.toPath(), (new File(PLUGIN_DIRECTORY + \"misc-dir/\" + folder.getName()).toPath()));\n                        }\n                        catch(Exception e)\n                        {\n                            log.info(\"Failed to move folder \" + folder.getAbsolutePath());\n                        }\n                    }\n                }\n            }\n        } catch (IOException e)\n        {\n            log.info(\"Failed splitting legacy file\");\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\LegacyFileUtility.java"},{"fileName":"RaidsManager.java","content":"package com.advancedraidtracker.utility.datautility;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.ui.RaidTrackerSidePanel;\nimport com.advancedraidtracker.utility.wrappers.RaidsArrayWrapper;\nimport lombok.extern.slf4j.Slf4j;\n\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Scanner;\n\nimport static com.advancedraidtracker.utility.datautility.DataWriter.PLUGIN_DIRECTORY;\n@Slf4j\npublic class RaidsManager\n{\n    private static final String raidsFolder \u003d PLUGIN_DIRECTORY + \"/misc-dir/raids/\";\n\n    public static ArrayList\u003cRaidsArrayWrapper\u003e getRaidsSets()\n    {\n        ArrayList\u003cRaidsArrayWrapper\u003e raidSets \u003d new ArrayList\u003c\u003e();\n        File folder \u003d new File(raidsFolder);\n        if (!folder.exists()) if(!folder.mkdirs()){log.info(\"Couldn\u0027t make misc dir\");}\n        try\n        {\n            for (File entry : Objects.requireNonNull(folder.listFiles()))\n            {\n                if (entry.isDirectory())\n                {\n                    ArrayList\u003cSimpleTOBData\u003e raids \u003d new ArrayList\u003c\u003e();\n                    for(File raid : Objects.requireNonNull(entry.listFiles()))\n                    {\n                        try\n                        {\n                            RaidTrackerSidePanel.parseLogFile(raids, raid, raid.getAbsolutePath());\n                        } catch (Exception e)\n                        {\n                            log.info(\"Failed to parse log file \" + raid.getAbsolutePath());\n                        }\n                    }\n                    raidSets.add(new RaidsArrayWrapper(raids, entry.getName()));\n                }\n            }\n        } catch (Exception e)\n        {\n            log.info(\"Failed parsing raid sets\");\n        }\n        return raidSets;\n    }\n\n    public static boolean doesRaidExist(String name)\n    {\n        File folder \u003d new File(raidsFolder);\n        try\n        {\n            for (File entry : Objects.requireNonNull(folder.listFiles()))\n            {\n                if (entry.getName().equals(name + \".raids\"))\n                {\n                    return true;\n                }\n            }\n        } catch (Exception e)\n        {\n            log.info(\"Could not determine if raid exists\");\n        }\n        return false;\n    }\n\n    public static void saveOverwriteRaids(String name, ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        try\n        {\n            File directory \u003d new File(raidsFolder);\n            if (!directory.exists())\n            {\n                if(!directory.mkdirs()) {log.info(\"Could not make overwrite dir\");}\n            }\n            File raidsFile \u003d new File(raidsFolder + name+\"/\");\n\n            if (raidsFile.exists())\n            {\n                if(!raidsFile.delete())\n                {\n                    log.info(\"Could not delete file during overwrite\");\n                }\n            }\n            if(!raidsFile.mkdirs())\n            {\n                log.info(\"Could not make directories during overwrite\");\n            }\n            writeRaid(name, raids);\n        } catch (Exception e)\n        {\n            log.info(\"Could not write overwrite raid\");\n        }\n    }\n\n    private static void writeRaid(String name, ArrayList\u003cSimpleTOBData\u003e raids) throws IOException\n    {\n        for (SimpleTOBData raid : raids)\n        {\n            File newEntry \u003d new File(raidsFolder + name + \"/\" + raid.fileName);\n            Files.createFile(newEntry.toPath());\n            BufferedWriter fileWriter \u003d new BufferedWriter(new OutputStreamWriter(Files.newOutputStream(newEntry.toPath())));\n            File file \u003d new File(raid.filePath);\n            Scanner logReader \u003d new Scanner(Files.newInputStream(file.toPath()));\n            while (logReader.hasNextLine())\n            {\n                fileWriter.write(logReader.nextLine());\n                fileWriter.newLine();\n            }\n            fileWriter.close();\n        }\n    }\n\n    public static void saveRaids(String name, ArrayList\u003cSimpleTOBData\u003e raids)\n    {\n        try\n        {\n            File directory \u003d new File(raidsFolder);\n            if (!directory.exists())\n            {\n                if(!directory.mkdirs())\n                {\n                    log.info(\"Could not make directory to save raid\");\n                }\n            }\n            File raidsFile \u003d new File(raidsFolder + name+\"/\");\n            if (!raidsFile.exists())\n            {\n                if(!raidsFile.mkdirs())\n                {\n                    log.info(\"Could not make directory for specific folder for raid\");\n                }\n            }\n            writeRaid(name, raids);\n        } catch (Exception e)\n        {\n            log.info(\"Could not write save file\");\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\datautility\\RaidsManager.java"},{"fileName":"ItemReference.java","content":"package com.advancedraidtracker.utility;\n\npublic class ItemReference\n{\n\n    public static String[][] ITEMS \u003d {\n            {\"none\", \"elite void\", \"void knight\", \"blood fury\"},\n            {\n                    \"torva\",\n                    \"defender\",\n                    \"scythe\",\n                    \"osmumten\",\n                    \"blade\",\n                    \"halberd\",\n                    \"melee\",\n                    \"dagger\",\n                    \"inquisitor\",\n                    \"claws\",\n                    \"rapier\",\n                    \"bulwark\",\n                    \"hammer\",\n                    \"primordial\",\n                    \"ferocious\",\n                    \"infernal\",\n                    \"fire cape\",\n                    \"bandos\",\n                    \"godsword\",\n                    \"dragon boots\",\n                    \"whip\",\n                    \"tentacle\",\n                    \"salve\",\n                    \"faceguard\",\n                    \"torso\",\n                    \"joint\",\n                    \"torture\",\n                    \"serpentine helm\",\n                    \"barrows\",\n                    \"rancour\",\n                    \"oathplate\",\n                    \"sulphur\",\n                    \"macuahuitl\",\n                    \"tacpatl\",\n                    \"avernic treads\"\n            },\n            {\n                    \"masori\",\n                    \"bow\",\n                    \"range\",\n                    \"blowpipe\",\n                    \"anguish\",\n                    \"assembler\",\n                    \"pegasian\",\n                    \"buckler\",\n                    \"chinchompa\",\n                    \"vambraces\",\n                    \"ralos\",\n                    \"dizana\",\n                    \"avernic treads\"\n            },\n            {\n                    \"ancestral\",\n                    \"virtus\",\n                    \"occult\",\n                    \"tormented\",\n                    \"tumeken\",\n                    \"staff\",\n                    \"mage\",\n                    \"eternal\",\n                    \"imbued\",\n                    \"trident\",\n                    \"kodai\",\n                    \"ice\",\n                    \"ward\",\n                    \"dawnbringer\",\n                    \"ancient sceptre\",\n                    \"ayak\",\n                    \"confliction\",\n                    \"avernic treads\"\n            }\n    };\n\n    public static final int MELEE \u003d 1;\n    public static final int RANGE \u003d 2;\n    public static final int MAGE \u003d 3;\n    public static final int NONE \u003d 0;\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\ItemReference.java"},{"fileName":"BloodDamageToBeApplied.java","content":"package com.advancedraidtracker.utility.maidenbloodtracking;\n\npublic class BloodDamageToBeApplied\n{\n    public String playerName;\n    public int bloodTicksAlive;\n\n    public BloodDamageToBeApplied(String playerName, int bloodTicksAlive)\n    {\n        this.playerName \u003d playerName;\n        this.bloodTicksAlive \u003d bloodTicksAlive;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\maidenbloodtracking\\BloodDamageToBeApplied.java"},{"fileName":"BloodPositionWrapper.java","content":"package com.advancedraidtracker.utility.maidenbloodtracking;\n\nimport net.runelite.api.coords.WorldPoint;\n\npublic class BloodPositionWrapper\n{\n    public int finalTick;\n    public int initialTick;\n    public WorldPoint location;\n\n    public BloodPositionWrapper(WorldPoint location, int initialTick)\n    {\n        this.initialTick \u003d initialTick;\n        this.location \u003d location;\n        this.finalTick \u003d initialTick + 10;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\maidenbloodtracking\\BloodPositionWrapper.java"},{"fileName":"NylocasData.java","content":"package com.advancedraidtracker.utility.nyloutility;\n\npublic class NylocasData\n{\n    public enum NylocasType\n    {\n        MELEE_BIG,\n        MELEE_SMALL,\n        RANGE_BIG,\n        RANGE_SMALL,\n        MAGE_BIG,\n        MAGE_SMALL,\n        MAGE_MELEE_RANGE_SMALL,\n        MELEE_MAGE_RANGE_SMALL,\n        RAMGE_MAGE_RANGE_SMALL,\n        MAGE_MELEE_MAGE_BIG,\n        RANGE_MAGE_RANGE_BIG,\n        MELEE_RANGE_MELEE_BIG,\n        MAGE_RANGE_MELEE_BIG,\n        RANGE_MELEE_RANGE_SMALL,\n        MELEE_MAGE_MELEE_SMALL,\n        MELEE_RANGE_MELEE_SMALL,\n        MAGE_RANGE_MAGE_SMALL,\n        RANGE_MAGE_MELEE_SMALL,\n        MAGE_RANGE_MELEE_SMALL,\n        RANGE_MAGE_MELEE_BIG,\n        RANGE_MAGE_RANGE_SMALL,\n        MELEE_MAGE_MELEE_BIG,\n        MELEE_MAGE_RANGE_BIG,\n        MAGE_MELEE_MAGE_SMALL,\n        RANGE_MELEE_MAGE_SMALL,\n        MELEE_RANGE_MAGE_SMALL,\n        RANGE_MELEE_RANGE_BIG,\n    }\n\n    public enum NyloPosition\n    {\n        EAST_NORTH,\n        EAST_SOUTH,\n        SOUTH_EAST,\n        SOUTH_WEST,\n        WEST_SOUTH,\n        WEST_NORTH,\n        EAST_BIG,\n        SOUTH_BIG,\n        WEST_BIG,\n        ROOM\n    }\n\n    public NylocasData(NyloPosition position, NylocasType type, boolean aggro)\n    {\n        this.position \u003d position;\n        this.type \u003d type;\n        this.aggro \u003d aggro;\n    }\n\n    public int getSpawnStyle()\n    {\n        switch (type)\n        {\n            case MELEE_SMALL:\n            case MELEE_MAGE_RANGE_SMALL:\n            case MELEE_MAGE_MELEE_SMALL:\n            case MELEE_RANGE_MELEE_SMALL:\n            case MELEE_RANGE_MAGE_SMALL:\n                return 0;\n            case MELEE_MAGE_MELEE_BIG:\n            case MELEE_MAGE_RANGE_BIG:\n            case MELEE_RANGE_MELEE_BIG:\n            case MELEE_BIG:\n                return 3;\n            case MAGE_BIG:\n            case MAGE_RANGE_MELEE_BIG:\n            case MAGE_MELEE_MAGE_BIG:\n                return 5;\n            case MAGE_SMALL:\n            case MAGE_MELEE_MAGE_SMALL:\n            case MAGE_MELEE_RANGE_SMALL:\n            case MAGE_RANGE_MAGE_SMALL:\n            case MAGE_RANGE_MELEE_SMALL:\n                return 2;\n            case RANGE_MAGE_MELEE_BIG:\n            case RANGE_BIG:\n            case RANGE_MAGE_RANGE_BIG:\n            case RANGE_MELEE_RANGE_BIG:\n                return 4;\n            case RANGE_MELEE_RANGE_SMALL:\n            case RANGE_MELEE_MAGE_SMALL:\n            case RANGE_MAGE_RANGE_SMALL:\n            case RANGE_MAGE_MELEE_SMALL:\n            case RANGE_SMALL:\n                return 1;\n        }\n        return -1;\n    }\n\n    public NyloPosition position;\n    public NylocasType type;\n    public boolean aggro;\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\nyloutility\\NylocasData.java"},{"fileName":"NylocasShell.java","content":"package com.advancedraidtracker.utility.nyloutility;\n\nimport static com.advancedraidtracker.constants.TobIDs.*;\nimport static com.advancedraidtracker.constants.TobIDs.NYLO_MELEE_SMALL_AGRO_SM;\n\npublic class NylocasShell\n{\n    public int style;\n    public NylocasData.NyloPosition position;\n\n    public boolean isBig()\n    {\n        return (style \u003e 2);\n    }\n\n    public static String getTypeName(int id)\n    {\n        switch (id)\n        {\n            case NYLO_MELEE_SMALL:\n            case NYLO_MELEE_SMALL_AGRO:\n            case NYLO_MELEE_SMALL_HM:\n            case NYLO_MELEE_SMALL_AGRO_HM:\n            case NYLO_MELEE_SMALL_SM:\n            case NYLO_MELEE_SMALL_AGRO_SM:\n                return \"melee\";\n            case NYLO_RANGE_SMALL:\n            case NYLO_RANGE_SMALL_AGRO:\n            case NYLO_RANGE_SMALL_HM:\n            case NYLO_RANGE_SMALL_AGRO_HM:\n            case NYLO_RANGE_SMALL_SM:\n            case NYLO_RANGE_SMALL_AGRO_SM:\n                return \"range\";\n            case NYLO_MAGE_SMALL:\n            case NYLO_MAGE_SMALL_AGRO:\n            case NYLO_MAGE_SMALL_HM:\n            case NYLO_MAGE_SMALL_AGRO_HM:\n            case NYLO_MAGE_SMALL_SM:\n            case NYLO_MAGE_SMALL_AGRO_SM:\n                return \"mage\";\n\n        }\n        return \"\";\n    }\n\n    public String getDescription()\n    {\n        String type \u003d \"\";\n        switch (style)\n        {\n            case 0:\n            case 3:\n                type \u003d \"melee\";\n                break;\n            case 1:\n            case 4:\n                type \u003d \"range\";\n                break;\n            case 2:\n            case 5:\n                type \u003d \"mage\";\n                break;\n        }\n        if (style \u003e 2)\n        {\n            switch (position) //spawn position for bigs is shared with littles on south/west, but southwest tile of east big is in unique spot\n            {\n                case EAST_BIG:\n                    return \"east big \" + type;\n                case SOUTH_WEST:\n                    return \"south big \" + type;\n                case WEST_SOUTH:\n                    return \"west big \" + type;\n            }\n        }\n        switch (position)\n        {\n            case EAST_NORTH:\n                return \"east small \" + type + \" (N)\";\n            case EAST_SOUTH:\n                return \"east small \" + type + \" (S)\";\n            case SOUTH_EAST:\n                return \"south small \" + type + \" (E)\";\n            case SOUTH_WEST:\n                return \"south small \" + type + \" (W)\";\n            case WEST_NORTH:\n                return \"west small \" + type + \" (N)\";\n            case WEST_SOUTH:\n                return \"west small \" + type + \" (S)\";\n        }\n        return \"\";\n    }\n\n    public NylocasShell(int id, int x, int y)\n    {\n        switch (id)\n        {\n            case NYLO_MELEE_SMALL_HM:\n            case NYLO_MELEE_SMALL_SM:\n            case NYLO_MELEE_SMALL:\n            case NYLO_MELEE_SMALL_AGRO_HM:\n            case NYLO_MELEE_SMALL_AGRO_SM:\n                style \u003d 0;\n                break;\n            case NYLO_RANGE_SMALL_HM:\n            case NYLO_RANGE_SMALL_SM:\n            case NYLO_RANGE_SMALL:\n            case NYLO_RANGE_SMALL_AGRO_HM:\n            case NYLO_RANGE_SMALL_AGRO_SM:\n            case NYLO_RANGE_SMALL_AGRO:\n                style \u003d 1;\n                break;\n            case NYLO_MAGE_SMALL_HM:\n            case NYLO_MAGE_SMALL_SM:\n            case NYLO_MAGE_SMALL:\n            case NYLO_MAGE_SMALL_AGRO_HM:\n            case NYLO_MAGE_SMALL_AGRO_SM:\n            case NYLO_MAGE_SMALL_AGRO:\n                style \u003d 2;\n                break;\n            case NYLO_MELEE_BIG:\n            case NYLO_MELEE_BIG_HM:\n            case NYLO_MELEE_BIG_SM:\n            case NYLO_MELEE_BIG_AGRO:\n            case NYLO_MELEE_BIG_AGRO_HM:\n            case NYLO_MELEE_BIG_AGRO_SM:\n                style \u003d 3;\n                break;\n            case NYLO_RANGE_BIG_HM:\n            case NYLO_RANGE_BIG_SM:\n            case NYLO_RANGE_BIG:\n            case NYLO_RANGE_BIG_AGRO_HM:\n            case NYLO_RANGE_BIG_AGRO_SM:\n            case NYLO_RANGE_BIG_AGRO:\n                style \u003d 4;\n                break;\n            case NYLO_MAGE_BIG:\n            case NYLO_MAGE_BIG_HM:\n            case NYLO_MAGE_BIG_SM:\n            case NYLO_MAGE_BIG_AGRO:\n            case NYLO_MAGE_BIG_AGRO_HM:\n            case NYLO_MAGE_BIG_AGRO_SM:\n                style \u003d 5;\n                break;\n        }\n        if (x \u003d\u003d 9 \u0026\u0026 y \u003d\u003d 25)\n        {\n            position \u003d NylocasData.NyloPosition.WEST_NORTH;\n        } else if (x \u003d\u003d 9 \u0026\u0026 y \u003d\u003d 24)\n        {\n            position \u003d NylocasData.NyloPosition.WEST_SOUTH;\n        } else if (x \u003d\u003d 23 \u0026\u0026 y \u003d\u003d 9)\n        {\n            position \u003d NylocasData.NyloPosition.SOUTH_WEST;\n        } else if (x \u003d\u003d 24 \u0026\u0026 y \u003d\u003d 9)\n        {\n            position \u003d NylocasData.NyloPosition.SOUTH_EAST;\n        } else if (x \u003d\u003d 38 \u0026\u0026 y \u003d\u003d 24)\n        {\n            position \u003d NylocasData.NyloPosition.EAST_SOUTH;\n        } else if (x \u003d\u003d 38 \u0026\u0026 y \u003d\u003d 25)\n        {\n            position \u003d NylocasData.NyloPosition.EAST_NORTH;\n        } else if (x \u003d\u003d 37 \u0026\u0026 y \u003d\u003d 24)\n        {\n            position \u003d NylocasData.NyloPosition.EAST_BIG;\n        } else\n        {\n            position \u003d NylocasData.NyloPosition.ROOM;\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\nyloutility\\NylocasShell.java"},{"fileName":"NylocasWave.java","content":"package com.advancedraidtracker.utility.nyloutility;\n\nimport lombok.Getter;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class NylocasWave\n{\n    @Getter\n    private final int wave;\n    @Getter\n    private final int delay;\n    private final NylocasData[] nylos;\n\n    public static NylocasWave[] waves \u003d\n            {\n                    new NylocasWave(1, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(2, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, true)\n                            }),\n                    new NylocasWave(3, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(4, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(5, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(6, 16,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, false)\n                            }),\n                    new NylocasWave(7, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(8, 12,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(9, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false)\n                            }),\n                    new NylocasWave(10, 16,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true)\n                            }),\n                    new NylocasWave(11, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),\n                            }),\n                    new NylocasWave(12, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MELEE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_BIG, false),\n                            }),\n                    new NylocasWave(13, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, true),\n                            }),\n                    new NylocasWave(14, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_BIG, true),\n                            }),\n                    new NylocasWave(15, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, false),\n                            }),\n                    new NylocasWave(16, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),\n                            }),\n                    new NylocasWave(17, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                            }),\n                    new NylocasWave(18, 12,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.RANGE_MAGE_RANGE_BIG, false),\n                            }),\n                    new NylocasWave(19, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                            }),\n                    new NylocasWave(20, 12,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_RANGE_MELEE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_MAGE_RANGE_BIG, false),\n                            }),\n                    new NylocasWave(21, 16,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_MAGE_MELEE_SMALL, false),\n                            }),\n                    new NylocasWave(22, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.RANGE_MAGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_RANGE_MELEE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, true),\n                            }),\n                    new NylocasWave(23, 12,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_MAGE_MELEE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_RANGE_MELEE_BIG, false),\n                            }),\n                    new NylocasWave(24, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_MELEE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MELEE_BIG, true),\n                            }),\n                    new NylocasWave(25, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MELEE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.RANGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                            }),\n                    new NylocasWave(26, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_MELEE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_BIG, false),\n                            }),\n                    new NylocasWave(27, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.MAGE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_MAGE_RANGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_BIG, NylocasData.NylocasType.MAGE_MELEE_MAGE_BIG, false),\n                            }),\n                    new NylocasWave(28, 8,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_MELEE_MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_MAGE_MELEE_SMALL, false),\n                            }),\n                    new NylocasWave(29, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_MAGE_SMALL, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MELEE_BIG, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_RANGE_MAGE_SMALL, true),\n                            }),\n                    new NylocasWave(30, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.MAGE_BIG, true),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_RANGE_MELEE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_BIG, false),\n                            }),\n\n                    new NylocasWave(31, 4,\n                            new NylocasData[]{\n                                    new NylocasData(NylocasData.NyloPosition.EAST_NORTH, NylocasData.NylocasType.MAGE_RANGE_MAGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.EAST_SOUTH, NylocasData.NylocasType.RANGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_EAST, NylocasData.NylocasType.MELEE_MAGE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.SOUTH_WEST, NylocasData.NylocasType.MAGE_MELEE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_SOUTH, NylocasData.NylocasType.RANGE_MAGE_RANGE_SMALL, false),\n                                    new NylocasData(NylocasData.NyloPosition.WEST_NORTH, NylocasData.NylocasType.MELEE_RANGE_MAGE_SMALL, false),\n                            }),\n            };\n\n    public NylocasWave(int wave, int delay, NylocasData[] nylos)\n    {\n        this.wave \u003d wave;\n        this.delay \u003d delay;\n        this.nylos \u003d nylos;\n    }\n\n    public int count()\n    {\n        return this.nylos.length;\n    }\n\n    public List\u003cNylocasData\u003e getNylos()\n    {\n        return Arrays.asList(nylos);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\nyloutility\\NylocasWave.java"},{"fileName":"NylocasWaveMatcher.java","content":"package com.advancedraidtracker.utility.nyloutility;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n@Slf4j\npublic class NylocasWaveMatcher\n{\n    private static boolean wave17Matched \u003d false;\n    private static boolean wave26Matched \u003d false;\n    private static boolean wave28Matched \u003d false;\n    private static NylocasWave lastWave \u003d null;\n\n    public static boolean isWave(ArrayList\u003cNylocasShell\u003e nylos)\n    {\n        ArrayList\u003cNylocasWave\u003e potentialWaves \u003d (ArrayList\u003cNylocasWave\u003e) Arrays.stream(NylocasWave.waves).filter(c -\u003e c.count() \u003d\u003d nylos.size()).collect(Collectors.toList());\n        if (!potentialWaves.isEmpty())\n        {\n            for (NylocasWave w : potentialWaves)\n            {\n                boolean waveFlag \u003d true;\n                for (NylocasData c : w.getNylos())\n                {\n                    if (waveFlag \u0026\u0026 !containsNylo(c, nylos))\n                    {\n                        waveFlag \u003d false;\n                    }\n                }\n                if (waveFlag) //waves 17, 26, and 28 are comprised of the exact same spawns\n                {\n                    if (wave17Matched \u0026\u0026 w.getWave() \u003d\u003d 17)\n                    {\n                        waveFlag \u003d false;\n                    } else if (wave26Matched \u0026\u0026 w.getWave() \u003d\u003d 26)\n                    {\n                        waveFlag \u003d false;\n\n                    } else if (wave28Matched \u0026\u0026 w.getWave() \u003d\u003d 28)\n                    {\n                        waveFlag \u003d false;\n                    } else if (w.getWave() \u003d\u003d 17)\n                    {\n                        wave17Matched \u003d true;\n                        wave26Matched \u003d false;\n                        wave28Matched \u003d false;\n                    } else if (w.getWave() \u003d\u003d 26)\n                    {\n                        wave26Matched \u003d true;\n                        wave28Matched \u003d false;\n                    } else if (w.getWave() \u003d\u003d 28)\n                    {\n                        wave28Matched \u003d true;\n                    } else if (w.getWave() \u003c 17)\n                    {\n                        wave17Matched \u003d false;\n                        wave26Matched \u003d false;\n                        wave28Matched \u003d false;\n                    } else if (w.getWave() \u003c 26)\n                    {\n                        wave26Matched \u003d false;\n                        wave28Matched \u003d false;\n                    } else if (w.getWave() \u003d\u003d 27)\n                    {\n                        wave28Matched \u003d false;\n                    }\n                }\n                if (waveFlag)\n                {\n                    lastWave \u003d w;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static NylocasWave getWave()\n    {\n        return lastWave;\n    }\n\n    public static boolean containsNylo(NylocasData c, ArrayList\u003cNylocasShell\u003e ns)\n    {\n        boolean flag \u003d false;\n        for (NylocasShell n : ns)\n        {\n            if (matchesNylo(c, n))\n            {\n                flag \u003d true;\n            }\n        }\n        return flag;\n    }\n\n    public static boolean matchesNylo(NylocasData c1, NylocasShell c2)\n    {\n        return (c1.getSpawnStyle() \u003d\u003d c2.style \u0026\u0026 c1.position \u003d\u003d c2.position);\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\nyloutility\\NylocasWaveMatcher.java"},{"fileName":"PlayerWornItems.java","content":"package com.advancedraidtracker.utility;\n\nimport net.runelite.api.PlayerComposition;\nimport net.runelite.api.kit.KitType;\nimport net.runelite.client.game.ItemManager;\n\npublic class PlayerWornItems\n{\n    public int helmet \u003d 0;\n    public int cape \u003d 0;\n    public int amulet \u003d 0;\n    public int weapon \u003d 0;\n    public int torso \u003d 0;\n    public int shield \u003d 0;\n    public int legs \u003d 0;\n    public int gloves \u003d 0;\n    public int boots \u003d 0;\n    private final ItemManager itemManager;\n    public PlayerWornItems(String s, ItemManager itemManager)\n    {\n        this.itemManager \u003d itemManager;\n        String[] items \u003d s.split(\"~\");\n        if(items.length \u003d\u003d 9)\n        {\n            helmet \u003d Integer.parseInt(items[0]);\n            cape \u003d Integer.parseInt(items[1]);\n            amulet \u003d Integer.parseInt(items[2]);\n            weapon \u003d Integer.parseInt(items[3]);\n            torso \u003d Integer.parseInt(items[4]);\n            shield \u003d Integer.parseInt(items[5]);\n            legs \u003d Integer.parseInt(items[6]);\n            gloves \u003d Integer.parseInt(items[7]);\n            boots \u003d Integer.parseInt(items[8]);\n        }\n    }\n\n    public static String getStringFromComposition(PlayerComposition pc)\n    {\n        return pc.getEquipmentId(KitType.HEAD) +\"~\"\n                    + pc.getEquipmentId(KitType.CAPE) +\"~\"\n                    +pc.getEquipmentId(KitType.AMULET) + \"~\"\n                    +pc.getEquipmentId(KitType.WEAPON) +\"~\"\n                    +pc.getEquipmentId(KitType.TORSO)+\"~\"\n                    +pc.getEquipmentId(KitType.SHIELD)+\"~\"\n                    +pc.getEquipmentId(KitType.LEGS)+\"~\"\n                    +pc.getEquipmentId(KitType.HANDS)+\"~\"\n                    +pc.getEquipmentId(KitType.BOOTS);\n    }\n\n    public String[] getAll()\n    {\n        if(helmet+cape+amulet+weapon+torso+shield+legs+gloves+boots \u003d\u003d 0)\n        {\n            return new String[]{};\n        }\n        else\n        {\n            return new String[]\n                    {\n                            \"Helmet: \" + getItemName(helmet),\n                            \"Cape: \" + getItemName(cape),\n                            \"Amulet: \" + getItemName(amulet),\n                            \"Weapon: \" + getItemName(weapon),\n                            \"Torso: \" + getItemName(torso),\n                            \"Shield: \" + getItemName(shield),\n                            \"Legs: \" + getItemName(legs),\n                            \"Gloves: \" + getItemName(gloves),\n                            \"Boots: \" + getItemName(boots),\n                    };\n        }\n    }\n\n    public String getItemName(int id)\n    {\n        if(id \u003d\u003d -1)\n        {\n            return \"None\";\n        }\n        else\n        {\n            return itemManager.getItemComposition(id).getName();\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\PlayerWornItems.java"},{"fileName":"Point.java","content":"package com.advancedraidtracker.utility;\n\n\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class Point\n{\n    private int x;\n    private int y;\n\n    public Point(int x, int y)\n    {\n        this.x \u003d x;\n        this.y \u003d y;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\Point.java"},{"fileName":"RoomState.java","content":"package com.advancedraidtracker.utility;\n\npublic class RoomState\n{\n    public enum MaidenRoomState\n    {\n        NOT_STARTED,\n        PHASE_1,\n        PHASE_2,\n        PHASE_3,\n        PHASE_4,\n        FINISHED\n    }\n\n    public enum BloatRoomState\n    {\n        NOT_STARTED,\n        WALKING,\n        DOWN,\n        FINISHED\n    }\n\n    public enum NyloRoomState\n    {\n        NOT_STARTED,\n        WAVES,\n        CLEANUP,\n        WAITING_FOR_BOSS,\n        BOSS,\n        FINISHED\n    }\n\n    public enum SotetsegRoomState\n    {\n        NOT_STARTED,\n        PHASE_1,\n        MAZE_1,\n        PHASE_2,\n        MAZE_2,\n        PHASE_3,\n        FINISHED\n    }\n\n    public enum XarpusRoomState\n    {\n        NOT_STARTED,\n        EXHUMEDS,\n        PRESCREECH,\n        POSTSCREECH,\n        FINISHED\n    }\n\n    public enum VerzikRoomState\n    {\n        NOT_STARTED,\n        PHASE_1,\n        PHASE_2,\n        PHASE_2_REDS,\n        PHASE_3,\n        FINISHED\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\RoomState.java"},{"fileName":"RoomUtil.java","content":"package com.advancedraidtracker.utility;\n\nimport com.advancedraidtracker.constants.TobIDs;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Arrays;\n\n\npublic class RoomUtil\n{\n    public final static String[] MAIDEN_CRAB_NAMES \u003d {\n            \"N1 70s\", \"N2 70s\", \"N3 70s\", \"N4 (1) 70s\", \"N4 (2) 70s\",\n            \"S1 70s\", \"S2 70s\", \"S3 70s\", \"S4 (1) 70s\", \"S4 (2) 70s\",\n            \"N1 50s\", \"N2 50s\", \"N3 50s\", \"N4 (1) 50s\", \"N4 (2) 50s\",\n            \"S1 50s\", \"S2 50s\", \"S3 50s\", \"S4 (1) 50s\", \"S4 (2) 50s\",\n            \"N1 30s\", \"N2 30s\", \"N3 30s\", \"N4 (1) 30s\", \"N4 (2) 30s\",\n            \"S1 30s\", \"S2 30s\", \"S3 30s\", \"S4 (1) 30s\", \"S4 (2) 30s\",\n    };\n\n    public static String time(String ticks)\n    {\n        try\n        {\n            return time(Integer.parseInt(ticks));\n        } catch (Exception e)\n        {\n            return ticks;\n        }\n    }\n\n    public static String varbitHPtoReadable(int varbitHP)\n    {\n        return (varbitHP / 10) + \".\" + (varbitHP % 10) + \"%\";\n    }\n\n\n    public static boolean isPrimaryBoss(int ID)\n    {\n        int[] bosses \u003d {\n                TobIDs.MAIDEN_P0,\n                TobIDs.MAIDEN_P1,\n                TobIDs.MAIDEN_P2,\n                TobIDs.MAIDEN_P3,\n                TobIDs.MAIDEN_PRE_DEAD,\n                TobIDs.MAIDEN_P0_HM,\n                TobIDs.MAIDEN_P1_HM,\n                TobIDs.MAIDEN_P2_HM,\n                TobIDs.MAIDEN_P3_HM,\n                TobIDs.MAIDEN_PRE_DEAD_HM,\n                TobIDs.MAIDEN_P0_SM,\n                TobIDs.MAIDEN_P1_SM,\n                TobIDs.MAIDEN_P2_SM,\n                TobIDs.MAIDEN_P3_SM,\n                TobIDs.MAIDEN_PRE_DEAD_SM,\n                TobIDs.BLOAT,\n                TobIDs.BLOAT_HM,\n                TobIDs.BLOAT_SM,\n                TobIDs.NYLO_BOSS_MELEE,\n                TobIDs.NYLO_BOSS_RANGE,\n                TobIDs.NYLO_BOSS_MAGE,\n                TobIDs.NYLO_BOSS_MELEE_HM,\n                TobIDs.NYLO_BOSS_RANGE_HM,\n                TobIDs.NYLO_BOSS_MAGE_HM,\n                TobIDs.NYLO_BOSS_MELEE_SM,\n                TobIDs.NYLO_BOSS_RANGE_SM,\n                TobIDs.NYLO_BOSS_MAGE_SM,\n                TobIDs.SOTETSEG_ACTIVE,\n                TobIDs.SOTETSEG_ACTIVE_HM,\n                TobIDs.SOTETSEG_ACTIVE_SM,\n                TobIDs.XARPUS_P23,\n                TobIDs.XARPUS_P23_HM,\n                TobIDs.XARPUS_P23_SM,\n                TobIDs.VERZIK_P1,\n                TobIDs.VERZIK_P2,\n                TobIDs.VERZIK_P3,\n                TobIDs.VERZIK_P1_HM,\n                TobIDs.VERZIK_P2_HM,\n                TobIDs.VERZIK_P3_HM,\n                TobIDs.VERZIK_P1_SM,\n                TobIDs.VERZIK_P2_SM,\n                TobIDs.VERZIK_P3_SM,\n        };\n        return (Arrays.stream(bosses).anyMatch(p -\u003e p \u003d\u003d ID));\n    }\n\n    public static String time(int ticks)\n    {\n        return time((double)ticks);\n    }\n\n    public static String time(double ticks)\n    {\n        if (ticks \u003d\u003d Integer.MAX_VALUE || ticks \u003c 1)\n        {\n            return \"-\";\n        }\n        String timeStr \u003d \"\";\n        double seconds \u003d ticks * .6;\n        int minutes \u003d ((int) seconds - ((int) seconds) % 60) / 60;\n        int onlySeconds \u003d (int) seconds - 60 * minutes;\n        String secondsString \u003d String.format(\"%.1f\", ticks * .6);\n        if (minutes !\u003d 0)\n            timeStr +\u003d minutes + \":\";\n        if (onlySeconds \u003c 10 \u0026\u0026 minutes !\u003d 0)\n        {\n            timeStr +\u003d \"0\";\n        }\n        timeStr +\u003d onlySeconds;\n        if (StringUtils.split(secondsString, \".\").length \u003d\u003d 2)\n        {\n            String[] subStr \u003d StringUtils.split(secondsString, \".\");\n            timeStr +\u003d \".\" + subStr[1];\n        } else\n        {\n            timeStr +\u003d \".0\";\n        }\n        if (minutes \u003d\u003d 0)\n        {\n            timeStr +\u003d \"s\";\n        }\n        return timeStr;\n    }\n\n    public static boolean crossedLine(int region, Point start, Point end, boolean vertical, Client client)\n    {\n        if (inRegion(client, region))\n        {\n            for (Player p : client.getPlayers())\n            {\n                WorldPoint wp \u003d p.getWorldLocation();\n                if (vertical)\n                {\n                    for (int i \u003d start.getY(); i \u003c end.getY() + 1; i++)\n                    {\n                        if (wp.getRegionY() \u003d\u003d i \u0026\u0026 wp.getRegionX() \u003d\u003d start.getX())\n                        {\n                            return true;\n                        }\n                    }\n                } else\n                {\n                    for (int i \u003d start.getX(); i \u003c end.getX() + 1; i++)\n                    {\n                        if (wp.getRegionX() \u003d\u003d i \u0026\u0026 wp.getRegionY() \u003d\u003d start.getY())\n                        {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    public static boolean inRegion(Client client, int... regions)\n    {\n        if (client.getMapRegions() !\u003d null)\n        {\n            for (int i : client.getMapRegions())\n            {\n                for (int j : regions)\n                {\n                    if (i \u003d\u003d j)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\RoomUtil.java"},{"fileName":"StatisticGatherer.java","content":"package com.advancedraidtracker.utility;\n\nimport com.advancedraidtracker.SimpleTOBData;\nimport com.advancedraidtracker.utility.datautility.DataPoint;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\n@Slf4j\npublic class StatisticGatherer\n{\n    public static double getOverallTimeAverage(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        data \u003d data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));\n        if (data.isEmpty())\n        {\n            return -1;\n        }\n        double total \u003d 0;\n        double count \u003d 0;\n        for (SimpleTOBData d : data)\n        {\n            total +\u003d d.getTimeSum();\n            count++;\n        }\n        return total / count;\n    }\n\n    public static double getOverallMedian(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        data \u003d data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));\n        if (data.isEmpty())\n        {\n            return -1;\n        }\n        double median;\n        List\u003cDouble\u003e values \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData d : data)\n        {\n            values.add((double) d.getTimeSum());\n        }\n        Collections.sort(values);\n        if (values.size() % 2 \u003d\u003d 0)\n        {\n            median \u003d ((double) values.get(values.size() / 2) + values.get(values.size() / 2 - 1)) / 2.0;\n        } else\n        {\n            median \u003d values.get(values.size() / 2);\n        }\n        return median;\n    }\n\n    public static double getOverallTimeMin(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        data \u003d data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));\n        int minValue \u003d Integer.MAX_VALUE;\n        for (SimpleTOBData d : data)\n        {\n            int split \u003d d.getTimeSum();\n            if (split \u003c minValue)\n            {\n                minValue \u003d split;\n            }\n        }\n        return minValue;\n    }\n\n    public static double getOverallMax(ArrayList\u003cSimpleTOBData\u003e data)\n    {\n        data \u003d data.stream().filter(SimpleTOBData::getOverallTimeAccurate).collect(Collectors.toCollection(ArrayList::new));\n        int maxValue \u003d 0;\n        for (SimpleTOBData d : data)\n        {\n            int split \u003d d.getTimeSum();\n            if (split \u003e maxValue)\n            {\n                maxValue \u003d split;\n            }\n        }\n        return maxValue;\n    }\n\n    public static double getGenericAverage(ArrayList\u003cInteger\u003e data)\n    {\n        double total \u003d 0;\n        double count \u003d 0;\n        for (int d : data)\n        {\n            if (d !\u003d -1)\n            {\n                total +\u003d d;\n                count++;\n            }\n        }\n        return total / count;\n    }\n\n    public static double getGenericAverage(ArrayList\u003cSimpleTOBData\u003e data, DataPoint parameter)\n    {\n        if(parameter \u003d\u003d DataPoint.CHALLENGE_TIME)\n        {\n            return getOverallTimeAverage(data);\n        }\n        double total \u003d 0;\n        double count \u003d 0;\n        for (SimpleTOBData room : data)\n        {\n            if (!room.getTimeAccurate(parameter))\n            {\n                continue;\n            }\n            int d \u003d room.getValue(parameter);\n            if (d !\u003d -1)\n            {\n                if (parameter.type !\u003d DataPoint.types.TIME || d !\u003d 0)\n                {\n                    total +\u003d d;\n                    count++;\n                }\n            }\n        }\n        return total / count;\n    }\n\n    public static double getGenericMedian(ArrayList\u003cInteger\u003e data)\n    {\n        if (data.isEmpty())\n        {\n            return -1;\n        }\n        List\u003cDouble\u003e values \u003d new ArrayList\u003c\u003e();\n        for (int d : data)\n        {\n            if (d !\u003d -1)\n                values.add((double) d);\n        }\n        Collections.sort(values);\n        return getMedian(values);\n    }\n\n    private static double getMedian(List\u003cDouble\u003e values)\n    {\n        double median;\n        if (values.size() % 2 \u003d\u003d 0)\n        {\n            median \u003d (values.get(values.size() / 2) + (double) values.get(values.size() / 2 - 1)) / 2.0;\n        } else\n        {\n            median \u003d values.get(values.size() / 2);\n        }\n        return median;\n    }\n\n    public static double getGenericMedian(ArrayList\u003cSimpleTOBData\u003e data, DataPoint param)\n    {\n        if(param \u003d\u003d DataPoint.OVERALL_TIME)\n        {\n            return getOverallMedian(data);\n        }\n        if (data.isEmpty())\n        {\n            return -1;\n        }\n        List\u003cDouble\u003e values \u003d new ArrayList\u003c\u003e();\n        for (SimpleTOBData room : data)\n        {\n            if (!room.getTimeAccurate(param))\n            {\n                continue;\n            }\n            int d \u003d room.getValue(param);\n            if (d !\u003d -1)\n                values.add((double) d);\n        }\n        Collections.sort(values);\n        if (!values.isEmpty())\n        {\n            return getMedian(values);\n        }\n        return -1;\n    }\n\n    public static double getGenericMin(ArrayList\u003cInteger\u003e data, boolean isTime)\n    {\n        int minValue \u003d Integer.MAX_VALUE;\n        for (int d : data)\n        {\n            if (d \u003c minValue \u0026\u0026 d !\u003d -1 \u0026\u0026 (!isTime || d !\u003d 0))\n            {\n                minValue \u003d d;\n            }\n        }\n        return minValue;\n    }\n\n    public static double getGenericMin(ArrayList\u003cInteger\u003e data)\n    {\n        return getGenericMin(data, false);\n    }\n\n    public static double getGenericMin(ArrayList\u003cSimpleTOBData\u003e data, DataPoint parameter)\n    {\n        if(parameter \u003d\u003d DataPoint.OVERALL_TIME)\n        {\n            return getOverallTimeMin(data);\n        }\n        int minValue \u003d Integer.MAX_VALUE;\n        for (SimpleTOBData room : data)\n        {\n            if (!room.getTimeAccurate(parameter))\n            {\n                continue;\n            }\n            int d \u003d room.getValue(parameter);\n            if (d \u003c minValue \u0026\u0026 d !\u003d -1)\n            {\n                if (parameter.type !\u003d DataPoint.types.TIME || room.getValue(parameter) !\u003d 0)\n                {\n                    minValue \u003d d;\n                }\n            }\n        }\n        return minValue;\n    }\n\n\n    public static double getGenericMax(ArrayList\u003cInteger\u003e data)\n    {\n        int maxValue \u003d 0;\n        for (int d : data)\n        {\n            if (d \u003e maxValue)\n            {\n                maxValue \u003d d;\n            }\n        }\n        return maxValue;\n    }\n\n    public static double getGenericMax(ArrayList\u003cSimpleTOBData\u003e data, DataPoint parameter)\n    {\n        if(parameter \u003d\u003d DataPoint.OVERALL_TIME)\n        {\n            return getOverallMax(data);\n        }\n        int maxValue \u003d 0;\n        for (SimpleTOBData room : data)\n        {\n            if (!room.getTimeAccurate(parameter))\n            {\n                continue;\n            }\n            int d \u003d room.getValue(parameter);\n            if (d \u003e maxValue)\n            {\n                maxValue \u003d d;\n            }\n        }\n        return maxValue;\n    }\n\n    public static double getGenericMode(ArrayList\u003cSimpleTOBData\u003e data, DataPoint parameter)\n    {\n        int maxCount \u003d 0;\n        int maxValue \u003d 0;\n        for (int i \u003d 0; i \u003c data.size(); i++)\n        {\n            if (!data.get(i).getTimeAccurate(parameter))\n            {\n                continue;\n            }\n            int iv \u003d data.get(i).getValue(parameter);\n            int count \u003d 0;\n            for (SimpleTOBData datum : data)\n            {\n                if (!datum.getTimeAccurate(parameter))\n                {\n                    continue;\n                }\n                int jv \u003d datum.getValue(parameter);\n                if (jv !\u003d -1 \u0026\u0026 iv !\u003d -1)\n                {\n                    if (Objects.equals(datum, data.get(i)))\n                    {\n                        count++;\n                    }\n                }\n            }\n            if (count \u003e maxCount)\n            {\n                maxValue \u003d iv;\n                maxCount \u003d count;\n            }\n        }\n        if (maxCount \u003e 1)\n        {\n            return maxValue;\n        } else\n        {\n            return -1;\n        }\n    }\n\n    public static double getGenericMode(ArrayList\u003cInteger\u003e data)\n    {\n        int maxCount \u003d 0;\n        int maxValue \u003d 0;\n        for (int i \u003d 0; i \u003c data.size(); i++)\n        {\n            int count \u003d 0;\n            for (Integer datum : data)\n            {\n                if (datum !\u003d -1 \u0026\u0026 data.get(i) !\u003d -1)\n                {\n                    if (Objects.equals(datum, data.get(i)))\n                    {\n                        count++;\n                    }\n                }\n            }\n            if (count \u003e maxCount)\n            {\n                maxValue \u003d data.get(i);\n                maxCount \u003d count;\n            }\n        }\n        if (maxCount \u003e 1)\n        {\n            return maxValue;\n        } else\n        {\n            return -1;\n        }\n    }\n\n\n    public static double getGenericPercent(ArrayList\u003cInteger\u003e arrayForStatistics, int threshold)\n    {\n        double count \u003d 0;\n        double total \u003d arrayForStatistics.size();\n        for (Integer i : arrayForStatistics)\n        {\n            if (i \u003c\u003d threshold)\n            {\n                count++;\n            }\n        }\n        double percent \u003d count / total;\n        int percentRounded \u003d (int) (percent * 1000);\n        percentRounded /\u003d 10;\n        return percentRounded;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\StatisticGatherer.java"},{"fileName":"DamageQueueShell.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\nimport lombok.Getter;\n\npublic class DamageQueueShell\n{\n    @Getter\n    public int sourceIndex;\n    public int offset;\n    public int targetIndex;\n    public int originTick;\n    public String source;\n\n    public DamageQueueShell(int targetIndex, int sourceIndex, int offset, String source, int originTick)\n    {\n        this.source \u003d source;\n        this.offset \u003d offset;\n        this.targetIndex \u003d targetIndex;\n        this.sourceIndex \u003d sourceIndex;\n        this.originTick \u003d originTick;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\DamageQueueShell.java"},{"fileName":"PlayerShell.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\nimport net.runelite.api.coords.WorldPoint;\n\npublic class PlayerShell\n{\n    public WorldPoint worldLocation;\n    public String name;\n\n    public PlayerShell(WorldPoint location, String name)\n    {\n        this.worldLocation \u003d location;\n        this.name \u003d name;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\PlayerShell.java"},{"fileName":"ProjectileQueue.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\npublic class ProjectileQueue\n{\n    public int originTick;\n    public int finalTick;\n    public int targetIndex;\n\n    public ProjectileQueue(int originTick, int finalTick, int targetIndex)\n    {\n        this.originTick \u003d originTick;\n        this.finalTick \u003d finalTick;\n        this.targetIndex \u003d targetIndex;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\ProjectileQueue.java"},{"fileName":"Thrall.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\nimport net.runelite.api.Actor;\nimport net.runelite.api.NPC;\nimport java.util.ArrayList;\n\nimport static com.advancedraidtracker.constants.TobIDs.*;\n\npublic class Thrall\n{\n    NPC npc;\n    PlayerShell player;\n    ArrayList\u003cPlayerShell\u003e potentialPlayers;\n\n    public Actor lastParentInteraction;\n    boolean isMelee;\n    public int spawnTick;\n\n    public Thrall(NPC npc, ArrayList\u003cPlayerShell\u003e potentialPlayers, int spawnTick)\n    {\n        this.potentialPlayers \u003d potentialPlayers;\n        this.npc \u003d npc;\n        isMelee \u003d npc.getId() \u003d\u003d MELEE_THRALL;\n        this.spawnTick \u003d spawnTick;\n    }\n\n    public boolean matchesGraphic(int animationID)\n    {\n        return (animationID \u003d\u003d THRALL_CAST_GRAPHIC_MAGE \u0026\u0026 npc.getId() \u003d\u003d MAGE_THRALL)\n                || (animationID \u003d\u003d THRALL_CAST_GRAPHIC_RANGE \u0026\u0026 npc.getId() \u003d\u003d RANGE_THRALL)\n                || (animationID \u003d\u003d THRALL_CAST_GRAPHIC_MELEE \u0026\u0026 npc.getId() \u003d\u003d MELEE_THRALL);\n    }\n\n    public void setOwner(PlayerShell player)\n    {\n        this.player \u003d player;\n    }\n\n    public String getOwner()\n    {\n        if (player !\u003d null)\n        {\n            return player.name;\n        } else\n        {\n            return \".unassigned\";\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\Thrall.java"},{"fileName":"ThrallTracker.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.constants.LogID;\nimport com.advancedraidtracker.utility.wrappers.ThrallOutlineBox;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Actor;\nimport net.runelite.api.NPC;\nimport net.runelite.api.Player;\nimport net.runelite.api.Projectile;\nimport net.runelite.api.coords.WorldPoint;\n\nimport java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport static com.advancedraidtracker.constants.TobIDs.*;\n\n@Slf4j\npublic class ThrallTracker\n{\n    private final ArrayList\u003cPlayer\u003e queuedCastAnimation;\n    private final ArrayList\u003cPlayer\u003e queuedMageCastGraphic;\n    private final ArrayList\u003cPlayer\u003e queuedRangeCastGraphic;\n    private final ArrayList\u003cPlayer\u003e queuedMeleeCastGraphic;\n    private final ArrayList\u003cThrall\u003e queuedThrallSpawn;\n\n    private final ArrayList\u003cThrall\u003e activeThralls;\n\n\n    private final AdvancedRaidTrackerPlugin plugin;\n\n    public ThrallTracker(AdvancedRaidTrackerPlugin plugin)\n    {\n        this.plugin \u003d plugin;\n        queuedCastAnimation \u003d new ArrayList\u003c\u003e();\n        queuedMageCastGraphic \u003d new ArrayList\u003c\u003e();\n        queuedMeleeCastGraphic \u003d new ArrayList\u003c\u003e();\n        queuedRangeCastGraphic \u003d new ArrayList\u003c\u003e();\n        queuedThrallSpawn \u003d new ArrayList\u003c\u003e();\n\n        activeThralls \u003d new ArrayList\u003c\u003e();\n    }\n\n    public void removeThrall(NPC npc)\n    {\n        Optional\u003cThrall\u003e thrall2 \u003d activeThralls.stream().filter(thrall1 -\u003e thrall1.npc.getIndex() \u003d\u003d npc.getIndex()).findAny();\n        if (thrall2.isPresent())\n        {\n            Thrall t \u003d thrall2.get();\n            plugin.removeThrallBox(t);\n        }\n        activeThralls.removeIf(thrall -\u003e thrall.npc.getIndex() \u003d\u003d npc.getIndex());\n    }\n\n    public void handleCasts()\n    {\n        if (queuedThrallSpawn.isEmpty())\n        {\n            return;\n        }\n        ArrayList\u003cPlayerShell\u003e assignedPlayers \u003d new ArrayList\u003c\u003e();\n        for (Thrall thrall : queuedThrallSpawn)\n        {\n            if (thrall.potentialPlayers.size() \u003d\u003d 1)\n            {\n                thrall.setOwner(thrall.potentialPlayers.get(0));\n                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));\n                activeThralls.add(thrall);\n\n                assignedPlayers.add(new PlayerShell(thrall.player.worldLocation, thrall.player.name));\n            }\n        }\n        removeQueuedThralls(assignedPlayers);\n\n        for (Thrall thrall : queuedThrallSpawn)\n        {\n            thrall.potentialPlayers.removeIf(p1 -\u003e queuedCastAnimation.stream().noneMatch(p2 -\u003e Objects.equals(p2.getName(), p1.name)));\n            if (thrall.potentialPlayers.size() \u003d\u003d 1)\n            {\n                thrall.setOwner(thrall.potentialPlayers.get(0));\n                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));\n                activeThralls.add(thrall);\n            }\n        }\n        removeQueuedThralls(assignedPlayers);\n\n        for (Thrall thrall : queuedThrallSpawn)\n        {\n            thrall.potentialPlayers.removeIf(p1 -\u003e\n                    queuedMageCastGraphic.stream().noneMatch(p2 -\u003e thrall.matchesGraphic(THRALL_CAST_GRAPHIC_MAGE))\n                            \u0026\u0026 queuedRangeCastGraphic.stream().noneMatch(p2 -\u003e thrall.matchesGraphic(THRALL_CAST_GRAPHIC_RANGE))\n                            \u0026\u0026 queuedMeleeCastGraphic.stream().noneMatch(p2 -\u003e thrall.matchesGraphic(THRALL_CAST_GRAPHIC_MELEE)));\n            if (thrall.potentialPlayers.size() \u003d\u003d 1)\n            {\n                thrall.setOwner(thrall.potentialPlayers.get(0));\n                plugin.addThrallOutlineBox(new ThrallOutlineBox(thrall.potentialPlayers.get(0).name, thrall.spawnTick, thrall.npc.getId()));\n                activeThralls.add(thrall);\n            }\n        }\n        removeQueuedThralls(assignedPlayers);\n\n        activeThralls.addAll(queuedThrallSpawn);\n        queuedThrallSpawn.clear();\n\n    }\n\n    private void removeQueuedThralls(ArrayList\u003cPlayerShell\u003e assignedPlayers)\n    {\n        queuedThrallSpawn.removeIf(thrall -\u003e thrall.potentialPlayers.size() \u003d\u003d 1);\n        queuedCastAnimation.removeIf(p -\u003e assignedPlayers.stream().anyMatch(p2 -\u003e Objects.equals(p2.name, p.getName())));\n        queuedMeleeCastGraphic.removeIf(p -\u003e assignedPlayers.stream().anyMatch(p2 -\u003e Objects.equals(p2.name, p.getName())));\n        queuedRangeCastGraphic.removeIf(p -\u003e assignedPlayers.stream().anyMatch(p2 -\u003e Objects.equals(p2.name, p.getName())));\n        queuedMageCastGraphic.removeIf(p -\u003e assignedPlayers.stream().anyMatch(p2 -\u003e Objects.equals(p2.name, p.getName())));\n    }\n\n    public void updatePlayerInteracting(String playerName, Actor interacting)\n    {\n        for (Thrall thrall : activeThralls)\n        {\n            if (thrall.getOwner().equals(playerName))\n            {\n                if (interacting !\u003d null)\n                {\n                    thrall.lastParentInteraction \u003d interacting;\n                }\n            }\n        }\n    }\n\n    public void updateTick()\n    {\n        handleCasts();\n    }\n\n    public void castThrallAnimation(Player player)\n    {\n        queuedCastAnimation.add(player);\n    }\n\n    public void meleeThrallAttacked(NPC npc)\n    {\n        for (Thrall thrall : activeThralls)\n        {\n            if (npc.getIndex() \u003d\u003d thrall.npc.getIndex() \u0026\u0026 thrall.isMelee \u0026\u0026 thrall.npc.getAnimation() \u003d\u003d MELEE_THRALL_ATTACK_ANIMATION)\n            {\n                if (thrall.lastParentInteraction instanceof NPC)\n                {\n                    if (thrall.lastParentInteraction.getWorldArea().distanceTo(thrall.npc.getWorldLocation()) \u003c 2)\n                    {\n                        plugin.clog.addLine(LogID.THRALL_ATTACKED, thrall.getOwner(), \"melee\");\n                        plugin.addQueuedThrallDamage(((((NPC) thrall.lastParentInteraction).getIndex())), thrall.npc.getIndex(), 1, thrall.getOwner());\n                    }\n                }\n            }\n        }\n    }\n\n    public void projectileCreated(Projectile projectile, WorldPoint origin)\n    {\n        if (projectile.getInteracting() instanceof NPC)\n        {\n            int hitOffset \u003d -1;\n\n            if (projectile.getId() \u003d\u003d THRALL_PROJECTILE_RANGE)\n            {\n                hitOffset \u003d (projectile.getRemainingCycles() \u003e 30) ? (projectile.getRemainingCycles() \u003e 60) ? 2 : 1 : 0;\n            } else if (projectile.getId() \u003d\u003d THRALL_PROJECTILE_MAGE)\n            {\n                hitOffset \u003d (projectile.getRemainingCycles() \u003e 40) ? 1 : 0;\n            }\n            for (Thrall t : activeThralls)\n            {\n                if (t.npc.getWorldLocation().distanceTo(origin) \u003d\u003d 0 \u0026\u0026 hitOffset !\u003d -1)\n                {\n                    plugin.clog.addLine(LogID.THRALL_ATTACKED, t.getOwner(), String.valueOf(projectile.getId()));\n                    plugin.addQueuedThrallDamage(((NPC) (projectile.getInteracting())).getIndex(), t.npc.getIndex(), hitOffset, t.getOwner());\n                    if (plugin.isVerzP2())\n                    {\n                        if (plugin.verzShieldActive)\n                        {\n                            NPC npc \u003d (NPC) projectile.getInteracting();\n                            if (npc.getId() \u003d\u003d VERZIK_P2 || npc.getId() \u003d\u003d VERZIK_P2_HM || npc.getId() \u003d\u003d VERZIK_P2_SM)\n                            {\n                                plugin.thrallAttackedP2VerzikShield(hitOffset);\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n\n    public void playerHasThrallCastSpotAnim(Player player, int id)\n    {\n        switch (id)\n        {\n            case THRALL_CAST_GRAPHIC_MELEE:\n                queuedMeleeCastGraphic.add(player);\n                break;\n            case THRALL_CAST_GRAPHIC_RANGE:\n                queuedRangeCastGraphic.add(player);\n                break;\n            case THRALL_CAST_GRAPHIC_MAGE:\n                queuedMageCastGraphic.add(player);\n                break;\n        }\n    }\n\n    public void thrallSpawned(NPC thrall, ArrayList\u003cPlayerShell\u003e adjacentPlayers)\n    {\n        queuedThrallSpawn.add(new Thrall(thrall, adjacentPlayers, plugin.getRoomTick()));\n    }\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\ThrallTracker.java"},{"fileName":"VengCastQueue.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\npublic class VengCastQueue\n{\n    public String target;\n    public String source;\n\n    public VengCastQueue(String target, String source)\n    {\n        this.target \u003d target;\n        this.source \u003d source;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\VengCastQueue.java"},{"fileName":"VengDamageQueue.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\npublic class VengDamageQueue\n{\n    public int appliedTick;\n    public int damage;\n    public String target;\n\n    public VengDamageQueue(String target, int damage, int appliedTick)\n    {\n        this.appliedTick \u003d appliedTick;\n        this.damage \u003d damage;\n        this.target \u003d target;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\VengDamageQueue.java"},{"fileName":"VengPair.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\npublic class VengPair\n{\n    public String player;\n    public int hitsplat;\n\n    public VengPair(String player, int hitsplat)\n    {\n        this.player \u003d player;\n        this.hitsplat \u003d hitsplat;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\VengPair.java"},{"fileName":"VengTracker.java","content":"package com.advancedraidtracker.utility.thrallvengtracking;\n\nimport com.advancedraidtracker.AdvancedRaidTrackerPlugin;\nimport com.advancedraidtracker.constants.LogID;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Player;\n\nimport java.util.ArrayList;\n\n@Slf4j\npublic class VengTracker\n{\n    public ArrayList\u003cVengCastQueue\u003e vengedPlayers;\n    private final AdvancedRaidTrackerPlugin plugin;\n\n    public VengTracker(AdvancedRaidTrackerPlugin plugin)\n    {\n        vengedPlayers \u003d new ArrayList\u003c\u003e();\n        this.plugin \u003d plugin;\n    }\n\n    private void handleApplyVeng()\n    {\n        ArrayList\u003cVengCastQueue\u003e temp \u003d new ArrayList\u003c\u003e();\n        for (VengCastQueue vcq : vengedPlayers)\n        {\n            boolean flag \u003d false;\n            for (VengCastQueue v : temp)\n            {\n                if (v.target !\u003d null \u0026\u0026 v.source !\u003d null)\n                {\n                    if (v.target.equals(vcq.target))\n                    {\n                        if (!v.source.equals(vcq.source))\n                        {\n                            vcq.source \u003d v.source;\n                        }\n                        flag \u003d true;\n                    }\n                }\n            }\n            if (!flag)\n            {\n                temp.add(vcq);\n            }\n        }\n        vengedPlayers.clear();\n        for (VengCastQueue vcq : temp)\n        {\n            plugin.clog.addLine(LogID.VENG_WAS_CAST, vcq.target, vcq.source);\n        }\n    }\n\n    public void updateTick()\n    {\n        handleApplyVeng();\n    }\n\n    public void vengSelfCast(Player player)\n    {\n        vengedPlayers.add(new VengCastQueue(player.getName(), player.getName()));\n    }\n\n    public void vengOtherCast(Player caster)\n    {\n        String nameTarget \u003d \"\";\n        String nameSource;\n        nameSource \u003d caster.getName();\n        if (caster.getInteracting() !\u003d null)\n        {\n            nameTarget \u003d caster.getInteracting().getName();\n        }\n        vengedPlayers.add(new VengCastQueue(nameTarget, nameSource));\n    }\n\n    public void vengOtherGraphicApplied(Player receiver)\n    {\n        vengedPlayers.add(new VengCastQueue(receiver.getName(), \".unknown\"));\n    }\n\n    public void vengSelfGraphicApplied(Player self)\n    {\n        vengedPlayers.add(new VengCastQueue(self.getName(), self.getName()));\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\thrallvengtracking\\VengTracker.java"},{"fileName":"UISwingUtility.java","content":"package com.advancedraidtracker.utility;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionListener;\n\npublic class UISwingUtility\n{\n    public static String colorStr(Color c)\n    {\n        return \"\u003chtml\u003e\u003cfont color\u003d\u0027#\" + Integer.toHexString(c.getRGB()).substring(2) + \"\u0027\u003e\";\n    }\n    public  final static String roomColor \u003d colorStr(new Color(200, 200, 200));\n    public static JLabel getDarkJLabel(String labelText)\n    {\n        return new JLabel(labelText);\n    }\n\n    public static JLabel getDarkJLabel(String labelText, int swingConstant)\n    {\n        return new JLabel(labelText, swingConstant);\n    }\n\n    public static JPanel getTitledPanel(String title)\n    {\n        JPanel panel \u003d new JPanel();\n        panel.setBorder(BorderFactory.createTitledBorder(title));\n        return panel;\n    }\n\n    public static JCheckBox getActionListenCheckBox(String name, ActionListener actionListener)\n    {\n        return getActionListenCheckBox(name, false, actionListener);\n    }\n\n    public static JCheckBox getActionListenCheckBox(String name, boolean state, ActionListener actionListener)\n    {\n        JCheckBox darkCheckBox \u003d new JCheckBox(name, state);\n        darkCheckBox.addActionListener(actionListener);\n        return darkCheckBox;\n    }\n\n    public static JComboBox\u003cString\u003e getActionListenCheckBox(String[] options, ActionListener actionListener)\n    {\n        JComboBox\u003cString\u003e dark \u003d new JComboBox\u003c\u003e(options);\n        dark.addActionListener(actionListener);\n        return dark;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\UISwingUtility.java"},{"fileName":"WeaponAttack.java","content":"package com.advancedraidtracker.utility.weapons;\n\nimport net.runelite.api.ItemID;\n\nimport java.awt.*;\n\npublic enum WeaponAttack\n{\n    UNDECIDED(\"Undecided\", \"?\", new Color(0, 0, 0), -1),\n    BLOWPIPE(\"Blowpipe\", \"BP\", new Color(100, 150, 200), 2),\n    BLOWPIPE_SPEC(\"Blowpipe spec\", \"bp\", new Color(100, 150, 200), 2),\n    HAMMER(\"DWH Spec\", \"H\", new Color(100, 100, 100), 6),\n    HAMMER_BOP(\"DWH Bop\", \"h\", new Color(50, 50, 50), 6),\n    SANG(\"Sang/Trident\", \"T\", new Color(30, 120, 130), 4),\n    CHALLY_SPEC(\"Chally spec\", \"CH\", new Color(150, 50, 50), 7),\n    CHALLY_WHACK(\"Chally whack\", \"ch\", new Color(150, 50, 50), 7),\n    SWIFT_BLADE(\"Swift Blade\", \"SB\", new Color(225, 50, 50), 3),\n    BGS_WHACK(\"BGS whack\", \"bg\", new Color(170, 20, 20), 6),\n    BGS_SPEC(\"BGS spec\", \"BG\", new Color(170, 20, 20, 0), 6),\n    TBOW(\"Tbow\", \"TB\", new Color(30, 120, 30), 5),\n    ZCB_AUTO(\"ZCB Auto\", \"zc\", new Color(10, 170, 50), 5),\n    ZCB_SPEC(\"ZCB Spec\", \"ZC\", new Color(10, 170, 50), 5),\n    SCYTHE(\"Scythe\", \"S\", new Color(230, 100, 100), 5),\n    DINHS_SPEC(\"Dinhs Spec\", \"BW\", new Color(20, 20, 20), 5),\n    DINHS_WHACK(\"Dinhs Whack\", \"bw\", new Color(20, 20, 20), 5),\n    CHIN(\"Chinchompa\", \"CC\", new Color(0, 130, 0), 3),\n    WHIP(\"Tent Whip\", \"TW\", new Color(10, 70, 80), 4),\n    FREEZE(\"Freeze\", \"F\", new Color(50, 50, 170), 5),\n    BLITZ(\"Blitz/Rush\", \"BR\", new Color(50, 50, 170), 5),\n    DAWN_SPEC(\"Dawnbringer Spec\", \"DB\", new Color(10, 100, 150), 4),\n    DAWN_AUTO(\"Dawnbringer Auto\", \"db\", new Color(10, 100, 150), 4),\n    CLAW_SCRATCH(\"Claw Scratch\", \"c\", new Color(76, 89, 1), 4),\n    CLAW_SPEC(\"Claw Spec\", \"C\", new Color(76, 89, 1), 4),\n    SHADOW(\"Shadow\", \"Sh\", new Color(20, 20, 60), 5),\n    DART(\"Dart\", \"Da\", new Color(10, 60, 60), 2),\n    SBS(\"Spellbook Swap\", \"SS\", new Color(10, 100, 60), -1),\n    BOUNCE(\"Bounce\", \"VB\", new Color(200, 10, 10), -1),\n    AID_OTHER(\"Aid other\", \"AO\", new Color(100, 100, 100), -1),\n    VENG_SELF(\"Veng Self\", \"VS\", new Color(160, 89, 13), -1),\n    HUMIDIFY(\"Humidify\", \"HU\", new Color(20, 20, 200), -1),\n    MAGIC_IMBUE(\"Magic Imbue\", \"MI\", new Color(60, 60, 150), -1),\n    WEB_WEAVER(\"Web Weaver\", \"WW\", new Color(240, 18, 119), 3),\n    DEATH(\"Death\", \"X\", new Color(0, 0, 0), -1),\n    TELEPORT(\"Teleport\", \"TP\", new Color(60, 70, 80), -1),\n    HEAL_GROUP(\"Heal Group\", \"HG\", new Color(50, 170, 100), -1),\n    CONSUME(\"Food/Drink Consumed\", \"CS\", new Color(110, 50, 60), -1),\n    THRALL_CAST(\"Thrall Cast\", \"TC\", new Color(20, 65, 187), -1),\n    BLADE_OF_SAELDOR(\"Blade of Saeldor\", \"BS\", new Color(67, 10, 45), 4),\n    FANG(\"Osmumten\u0027s Fang\", \"OF\", new Color(10, 10, 100), 5),\n\n    SULPHUR_BLADES(\"Sulphur Blades\", \"SUL\", new Color(180, 20, 40), 4),\n    ELDER_MAUL_SPEC(\"Elder Maul Spec\", \"EM\", new Color(100, 60, 60), 6),\n    ELDER_MAUL(\"Elder Maul\", \"EM\", new Color(100, 60, 60), 6),\n    GLAIVE_AUTO(\"Glaive Auto\", \"g\", new Color(0, 70, 0), 6),\n    GLAIVE_SPEC(\"Glaive Spec\", \"G\", new Color(0, 70, 0), 6),\n    DUAL_MAUCUAHUITL(\"Dual Maucuahuitl\", \"DMC\", new Color(180, 30, 60), 4),\n\n    EYE_OF_AYAK(\"Eye of Ayak\", \"AY\", new Color(30, 120, 130), 3),\n    EYE_OF_AYAK_SPEC(\"Eye of Ayak Spec\", \"AYS\", new Color(30, 120, 130), 5),\n    EARTHBOUND_TACPATL(\"Earthbound Tacpatl\", \"TAC\", new Color(180, 20, 40), 4),\n    \n    TSOTD(\"Toxic Staff of the Dead\", \"TS\", new Color(70, 10, 10), 4),\n\n\n\n    ;\n\n    public final String name;\n    public final String shorthand;\n    public final Color color;\n    public final int attackTicks;\n\n\n    WeaponAttack(String name, String shorthand, Color color, int attackTicks)\n    {\n        this.attackTicks \u003d attackTicks;\n        this.name \u003d name;\n        this.shorthand \u003d shorthand;\n        this.color \u003d color;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\weapons\\WeaponAttack.java"},{"fileName":"WeaponDecider.java","content":"package com.advancedraidtracker.utility.weapons;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class WeaponDecider\n{\n    public static WeaponAttack getWeapon(String animationS, String graphics, String projectileS, String weaponS)\n    { //todo redo all of this ** magic numbers will be fixed then too\n        WeaponAttack weaponUsed \u003d WeaponAttack.UNDECIDED;\n        List\u003cString\u003e spotAnims \u003d Arrays.asList(graphics.split(\":\"));\n        int projectile;\n        int weapon;\n        int animation;\n        try\n        {\n            projectile \u003d Integer.parseInt(projectileS);\n            weapon \u003d Integer.parseInt(weaponS);\n            animation \u003d Integer.parseInt(animationS);\n        } catch (Exception e)\n        {\n            return weaponUsed;\n        }\n        switch (animation)\n        {\n            case 5061:\n            case 10656:\n                if (projectile \u003d\u003d 1043 || projectile \u003d\u003d 2599)\n                {\n                    weaponUsed \u003d WeaponAttack.BLOWPIPE_SPEC;\n                } else\n                {\n                    weaponUsed \u003d WeaponAttack.BLOWPIPE;\n                }\n                break;\n            case 12397:\n                weaponUsed \u003d WeaponAttack.EYE_OF_AYAK;\n                break;\n            case 12394:\n                weaponUsed \u003d WeaponAttack.EYE_OF_AYAK_SPEC;\n                break;\n            case 12342:\n                weaponUsed \u003d WeaponAttack.EARTHBOUND_TACPATL;\n                break;\n            case 11430:\n            case 1167:\n                if (spotAnims.stream().anyMatch(p -\u003e p.equalsIgnoreCase(\"1540\")))\n                {\n                    weaponUsed \u003d WeaponAttack.SANG;\n                } else\n                {\n                    if (weapon \u003d\u003d 22516)\n                    {\n                        if (projectile \u003d\u003d 1547)\n                        {\n                            weaponUsed \u003d WeaponAttack.DAWN_SPEC;\n                        } else\n                        {\n                            weaponUsed \u003d WeaponAttack.DAWN_AUTO;\n                        }\n                    } else\n                    {\n                        weaponUsed \u003d WeaponAttack.SANG;\n                    }\n                }\n                break;\n            case 1979:\n            case 10092:\n                weaponUsed \u003d WeaponAttack.FREEZE; //todo add lowercase if bad weapon\n                break;\n            case 1978:\n            case 10091:\n                weaponUsed \u003d WeaponAttack.BLITZ;\n                break;\n            case 8056:\n                weaponUsed \u003d WeaponAttack.SCYTHE;\n                break;\n            case 7511:\n                weaponUsed \u003d WeaponAttack.DINHS_SPEC;\n                break;\n            case 7618:\n                weaponUsed \u003d WeaponAttack.CHIN;\n                break;\n            case 1658:\n                weaponUsed \u003d WeaponAttack.WHIP;\n                break;\n            case 401:\n                weaponUsed \u003d WeaponAttack.HAMMER_BOP;\n                break;\n            case 1378:\n                weaponUsed \u003d WeaponAttack.HAMMER;\n                break;\n            case 428:\n            case 419:\n            case 440:\n                if(weapon \u003d\u003d 12904)\n                {\n                    weaponUsed \u003d WeaponAttack.TSOTD;\n                    break;\n                }\n                weaponUsed \u003d WeaponAttack.CHALLY_WHACK;\n                break;\n            case 1203:\n                weaponUsed \u003d WeaponAttack.CHALLY_SPEC;\n                break;\n            case 390:\n            case 9471:\n                if(weapon \u003d\u003d 26219)\n                {\n                    weaponUsed \u003d WeaponAttack.FANG;\n                    break;\n                }\n            case 8288:\n            case 386:\n                if(weapon \u003d\u003d 23995 || weapon \u003d\u003d 24551)\n                {\n                    weaponUsed \u003d WeaponAttack.BLADE_OF_SAELDOR;\n                    break;\n                }\n                weaponUsed \u003d WeaponAttack.SWIFT_BLADE;\n                break;\n            case 7642:\n            case 7643:\n                weaponUsed \u003d WeaponAttack.BGS_SPEC;\n                break;\n            case 7045:\n                weaponUsed \u003d WeaponAttack.BGS_WHACK;\n                break;\n            case 426:\n                if (weapon \u003d\u003d 20997)\n                {\n                    weaponUsed \u003d WeaponAttack.TBOW;\n                } else if (weapon \u003d\u003d 27655)\n                {\n                    weaponUsed \u003d WeaponAttack.WEB_WEAVER;\n                } else\n                {\n                    weaponUsed \u003d WeaponAttack.TBOW;\n                }\n                break;\n            case 9168:\n                if (projectile \u003d\u003d 1468)\n                {\n                    weaponUsed \u003d WeaponAttack.ZCB_AUTO;\n                } else if (projectile \u003d\u003d 1995)\n                {\n                    weaponUsed \u003d WeaponAttack.ZCB_SPEC;\n                }\n                break;\n            case 2068:\n                weaponUsed \u003d WeaponAttack.SULPHUR_BLADES;\n                break;\n            case 10989:\n                weaponUsed \u003d WeaponAttack.DUAL_MAUCUAHUITL;\n                break;\n            case 7516:\n                weaponUsed \u003d WeaponAttack.ELDER_MAUL;\n                break;\n            case 11124:\n                weaponUsed \u003d WeaponAttack.ELDER_MAUL_SPEC;\n                break;\n            case 10923:\n                weaponUsed \u003d WeaponAttack.GLAIVE_AUTO;\n                break;\n            case 10914:\n                weaponUsed \u003d WeaponAttack.GLAIVE_SPEC;\n                break;\n            case 393:\n                weaponUsed \u003d WeaponAttack.CLAW_SCRATCH;\n                break;\n            case 7514:\n                weaponUsed \u003d WeaponAttack.CLAW_SPEC;\n                break;\n            case 9493:\n                weaponUsed \u003d WeaponAttack.SHADOW;\n                break;\n            case 7554:\n                weaponUsed \u003d WeaponAttack.DART;\n                break;\n            case 6299:\n                weaponUsed \u003d WeaponAttack.SBS;\n                break;\n            case 100000:\n                weaponUsed \u003d WeaponAttack.BOUNCE;\n                break;\n            case 4411:\n                weaponUsed \u003d WeaponAttack.AID_OTHER;\n                break;\n            case 8316:\n                weaponUsed \u003d WeaponAttack.VENG_SELF;\n                break;\n            case 6294:\n                weaponUsed \u003d WeaponAttack.HUMIDIFY;\n                break;\n            case 722:\n                weaponUsed \u003d WeaponAttack.MAGIC_IMBUE;\n                break;\n            case 10629:\n            case 836:\n                weaponUsed \u003d WeaponAttack.DEATH;\n                break;\n            case 8070:\n            case 1816:\n                weaponUsed \u003d WeaponAttack.TELEPORT;\n                break;\n            case 4409:\n                weaponUsed \u003d WeaponAttack.HEAL_GROUP;\n                break;\n        }\n        return weaponUsed;\n    }\n}","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\weapons\\WeaponDecider.java"},{"fileName":"DawnSpec.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\npublic class DawnSpec\n{\n    public String player;\n    public int tick;\n\n    public DawnSpec(String player, int tick)\n    {\n        this.player \u003d player;\n        this.tick \u003d tick;\n    }\n\n    @Getter\n    @Setter\n    int damage \u003d -1;\n\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\DawnSpec.java"},{"fileName":"MaidenCrab.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport net.runelite.api.NPC;\n\npublic class MaidenCrab\n{\n    public NPC crab;\n    public int maxHealth;\n    public int health;\n    public String description;\n\n    public MaidenCrab(NPC crab, int scale, String description)\n    {\n        switch (scale)\n        {\n            case 5:\n                maxHealth \u003d 100;\n                break;\n            case 4:\n                maxHealth \u003d 87;\n                break;\n            default:\n                maxHealth \u003d 75;\n                break;\n        }\n        this.crab \u003d crab;\n        health \u003d maxHealth;\n        this.description \u003d description;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\MaidenCrab.java"},{"fileName":"NPCTimeInChunkShell.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport lombok.Getter;\nimport net.runelite.api.NPC;\n\npublic class NPCTimeInChunkShell\n{\n    @Getter\n    public int timeInChunk;\n    public int chunk;\n    public NPC npc;\n    public boolean marked;\n\n    public int getIndex()\n    {\n        return npc.getIndex();\n    }\n    public NPCTimeInChunkShell(NPC npc, int chunk, int timeInChunk)\n    {\n        this.npc \u003d npc;\n        this.chunk \u003d chunk;\n        this.timeInChunk \u003d timeInChunk;\n        marked \u003d false;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\NPCTimeInChunkShell.java"},{"fileName":"OutlineBox.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport com.advancedraidtracker.utility.ItemReference;\nimport com.advancedraidtracker.utility.weapons.WeaponAttack;\n\nimport java.awt.*;\n\npublic class OutlineBox\n{\n    public String player;\n    public int tick;\n    public String letter;\n    public Color color;\n    public boolean primaryTarget;\n    public WeaponAttack weaponAttack;\n\n    public String additionalText;\n    public PlayerDidAttack attack;\n\n    public OutlineBox(PlayerDidAttack attack, String letter, Color color, boolean primaryTarget, String additionalText, WeaponAttack weaponAttack)\n    {\n        this.weaponAttack \u003d weaponAttack;\n        this.attack \u003d attack;\n        this.player \u003d attack.player;\n        this.tick \u003d attack.tick;\n        this.letter \u003d letter;\n        this.color \u003d color;\n        this.primaryTarget \u003d primaryTarget;\n        this.additionalText \u003d additionalText;\n    }\n\n    public final int NONE \u003d 0;\n    public final int MELEE \u003d 1;\n    public final int RANGE \u003d 2;\n    public final int MAGE \u003d 3;\n    public int style \u003d NONE;\n    public Color outlineColor \u003d new Color(0, 0, 0, 0);\n\n    private boolean anyMatch(String item, String[] items)\n    {\n        for(String s : items)\n        {\n            if(item.toLowerCase().contains(s))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private void setStyle(String weapon)\n    {\n        if(anyMatch(weapon, ItemReference.ITEMS[MELEE]))\n        {\n            style \u003d MELEE;\n        }\n        else if(anyMatch(weapon, ItemReference.ITEMS[RANGE]))\n        {\n            style \u003d RANGE;\n        }\n        else if(anyMatch(weapon, ItemReference.ITEMS[MAGE]))\n        {\n            style \u003d MAGE;\n        }\n    }\n    public void createOutline()\n    {\n        if(letter.equals(\"VS\") || letter.equals(\"AO\") || letter.equals(\"HU\") || letter.equals(\"MI\") || letter.equals(\"DB\") || letter.equals(\"SS\"))\n        {\n            return;\n        }\n        int correctItems \u003d 0;\n        boolean voidHelmWorn \u003d false;\n        if(attack.wornItemNames.length \u003d\u003d 9)\n        {\n            setStyle(attack.wornItemNames[3]);\n            if(attack.wornItemNames[0].toLowerCase().contains(\"void\"))\n            {\n                voidHelmWorn \u003d true;\n            }\n            for(String s : attack.wornItemNames)\n            {\n                if(anyMatch(s, ItemReference.ITEMS[style]) || (voidHelmWorn \u0026\u0026 s.toLowerCase().contains(\"void\")))\n                {\n                    correctItems++;\n                }\n            }\n            if(attack.wornItemNames[2].toLowerCase().contains(\"blood fury\") \u0026\u0026 style \u003d\u003d MELEE)\n            {\n                correctItems++;\n            }\n        }\n        switch(style)\n        {\n            case MELEE:\n                if(correctItems \u003c 8)\n                {\n                    int opacity \u003d (int)((255)*((8-correctItems)/8.0));\n                    opacity \u003d Math.max(opacity, 150);\n                    outlineColor \u003d new Color(255, 255, 0, opacity);\n                }\n                break;\n            case RANGE:\n                if(correctItems \u003c 6)\n                {\n                    outlineColor \u003d new Color(255, 255, 0, (int)((255)*((6-correctItems)/6.0)));\n                }\n                break;\n            case MAGE:\n                if(correctItems \u003c 5)\n                {\n                    outlineColor \u003d new Color(255, 255, 0, (int)((255)*((5-correctItems)/5.0)));\n                }\n                break;\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\OutlineBox.java"},{"fileName":"PlayerCopy.java","content":"package com.advancedraidtracker.utility.wrappers;\n\npublic class PlayerCopy\n{\n    public String name;\n    public int interactingIndex;\n    public int interactingID;\n    public String interactingName;\n    public int animation;\n    public String wornItems;\n    public String weapon;\n    public PlayerCopy(String name, int interactingIndex, int interactingID, String interactingName, int animation, String wornItems, String weapon)\n    {\n        this.name \u003d name;\n        this.interactingIndex \u003d interactingIndex;\n        this.interactingID \u003d interactingID;\n        this.interactingName \u003d interactingName;\n        this.animation \u003d animation;\n        this.wornItems \u003d wornItems;\n        this.weapon \u003d weapon;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\PlayerCopy.java"},{"fileName":"PlayerCorrelatedPointData.java","content":"package com.advancedraidtracker.utility.wrappers;\n\npublic class PlayerCorrelatedPointData\n{\n    public int value;\n    public String player;\n\n    public PlayerCorrelatedPointData(String player, int value)\n    {\n        this.value \u003d value;\n        this.player \u003d player;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\PlayerCorrelatedPointData.java"},{"fileName":"PlayerDidAttack.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport com.advancedraidtracker.utility.PlayerWornItems;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ItemID;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.util.AsyncBufferedImage;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Slf4j\npublic class PlayerDidAttack\n{\n    public String player;\n    public String animation;\n    public int tick;\n    public String weapon;\n    public String projectile;\n    public String spotAnims;\n    public int targetedIndex;\n    public int targetedID;\n    public String targetName;\n    public String wornItems;\n    public String[] wornItemNames \u003d {};\n\n    public ItemManager itemManager;\n    public AsyncBufferedImage img \u003d null;\n    private boolean setUnkitted \u003d false;\n\n    private static final Set\u003cInteger\u003e scythe \u003d new HashSet\u003c\u003e(Arrays.asList(ItemID.HOLY_SCYTHE_OF_VITUR, ItemID.SANGUINE_SCYTHE_OF_VITUR));\n    private static final Set\u003cInteger\u003e bp \u003d new HashSet\u003c\u003e(Collections.singletonList(ItemID.BLAZING_BLOWPIPE));\n    private static final Set\u003cInteger\u003e sang \u003d new HashSet\u003c\u003e(Collections.singletonList(ItemID.HOLY_SANGUINESTI_STAFF));\n    private static final Set\u003cInteger\u003e bulwark \u003d new HashSet\u003c\u003e(Collections.singletonList(ItemID.DINHS_BLAZING_BULWARK));\n    private static final Set\u003cInteger\u003e claws \u003d new HashSet\u003c\u003e(Collections.singletonList(ItemID.CORRUPTED_DRAGON_CLAWS));\n    private static final Set\u003cInteger\u003e dwh \u003d new HashSet\u003c\u003e(Arrays.asList(ItemID.DRAGON_WARHAMMER_CR, ItemID.DRAGON_WARHAMMER_OR));\n\n    public PlayerDidAttack(ItemManager itemManager, String player, String animation, int tick, String weapon, String projectile, String spotAnims, int targetedIndex, int targetedID, String targetName, String worn)\n    {\n        this.itemManager \u003d itemManager;\n        this.player \u003d player;\n        this.animation \u003d animation;\n        this.tick \u003d tick;\n        this.weapon \u003d weapon;\n        this.projectile \u003d projectile;\n        this.spotAnims \u003d spotAnims;\n        this.targetedIndex \u003d targetedIndex;\n        this.targetedID \u003d targetedID;\n        this.targetName \u003d targetName;\n        this.wornItems \u003d worn;\n    }\n\n    public void setWornNames()\n    {\n        wornItemNames \u003d new PlayerWornItems(wornItems, itemManager).getAll();\n    }\n\n    public void useUnkitted()\n    {\n        setUnkitted \u003d true;\n    }\n\n    private int getReplacement(int original)\n    {\n        if(scythe.contains(original))\n        {\n            return ItemID.SCYTHE_OF_VITUR;\n        }\n        if(sang.contains(original))\n        {\n            return ItemID.SANGUINESTI_STAFF;\n        }\n        if(bp.contains(original))\n        {\n            return ItemID.TOXIC_BLOWPIPE;\n        }\n        if(bulwark.contains(original))\n        {\n            return ItemID.DINHS_BULWARK;\n        }\n        if(claws.contains(original))\n        {\n            return ItemID.DRAGON_CLAWS;\n        }\n        if(dwh.contains(original))\n        {\n            return ItemID.DRAGON_WARHAMMER;\n        }\n        return original;\n    }\n\n    public void setIcons()\n    {\n        int weaponID \u003d Integer.parseInt(this.weapon);\n        if(setUnkitted)\n        {\n            weaponID \u003d getReplacement(weaponID);\n        }\n        img \u003d itemManager.getImage(weaponID, 1, false);\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\PlayerDidAttack.java"},{"fileName":"PlayerHitsWrapper.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport java.util.ArrayList;\n\npublic class PlayerHitsWrapper\n{\n    public ArrayList\u003cInteger\u003e hitsplats;\n    public String name;\n    public int hits;\n\n    public PlayerHitsWrapper(String name, int initial)\n    {\n        this.name \u003d name;\n        hitsplats \u003d new ArrayList\u003c\u003e();\n        hitsplats.add(initial);\n        this.hits \u003d 0;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\PlayerHitsWrapper.java"},{"fileName":"QueuedPlayerAttackLessProjectiles.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\n\npublic class QueuedPlayerAttackLessProjectiles\n{\n    public Player player;\n    public String animation;\n    public int tick;\n    public String spotAnims;\n    public String weapon;\n\n    public WorldPoint location;\n\n    public QueuedPlayerAttackLessProjectiles(Player player, WorldPoint location, int tick, String spotAnims, String weapon, String animation)\n    {\n        this.player \u003d player;\n        this.animation \u003d animation;\n        this.tick \u003d tick;\n        this.spotAnims \u003d spotAnims;\n        this.weapon \u003d weapon;\n        this.location \u003d location;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\QueuedPlayerAttackLessProjectiles.java"},{"fileName":"RaidsArrayWrapper.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport com.advancedraidtracker.SimpleTOBData;\n\nimport java.util.ArrayList;\n\npublic class RaidsArrayWrapper\n{\n    public ArrayList\u003cSimpleTOBData\u003e data;\n    public String filename;\n\n    public RaidsArrayWrapper(ArrayList\u003cSimpleTOBData\u003e data, String filename)\n    {\n        this.data \u003d data;\n        this.filename \u003d filename;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\RaidsArrayWrapper.java"},{"fileName":"StringInt.java","content":"package com.advancedraidtracker.utility.wrappers;\n\npublic class StringInt\n{\n    public int val;\n    public String string;\n\n    public StringInt(String string, int val)\n    {\n        this.string \u003d string;\n        this.val \u003d val;\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\StringInt.java"},{"fileName":"ThrallOutlineBox.java","content":"package com.advancedraidtracker.utility.wrappers;\n\nimport java.awt.*;\n\nimport static com.advancedraidtracker.constants.TobIDs.*;\n\npublic class ThrallOutlineBox\n{\n    public int spawnTick;\n    public String owner;\n    public int id;\n\n    public ThrallOutlineBox(String owner, int spawnTick, int id)\n    {\n        this.spawnTick \u003d spawnTick;\n        this.owner \u003d owner;\n        this.id \u003d id;\n    }\n\n    public Color getColor()\n    {\n        switch (id)\n        {\n            case MELEE_THRALL:\n                return new Color(240, 30, 30);\n            case RANGE_THRALL:\n                return new Color(30, 240, 30);\n            case MAGE_THRALL:\n                return new Color(30, 30, 240);\n            default:\n                return new Color(30, 30, 30);\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\advancedraidtracker\\utility\\wrappers\\ThrallOutlineBox.java"},{"fileName":"AdvancedRaidTrackerPluginTest.java","content":"package com.advancedraidtracker;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class AdvancedRaidTrackerPluginTest\n{\n    public static void main(String[] args) throws Exception {\n        ExternalPluginManager.loadBuiltin(AdvancedRaidTrackerPlugin.class);\n        RuneLite.main(args);\n    }\n}","filePath":"src\\test\\java\\com\\advancedraidtracker\\AdvancedRaidTrackerPluginTest.java"}]},{"commit":"11b59828c801c3279f2f5e88ce3bfdf96b247010","repository":"https://github.com/vincent0955/Visual-metronome.git","internalName":"visual-metronome","files":[{"fileName":"FontTypes.java","content":"package com.visualmetronome;\n\nimport lombok.Getter;\nimport lombok.RequiredArgsConstructor;\n\n@RequiredArgsConstructor\n@Getter\npublic enum FontTypes\n{\n    REGULAR(\"RS Regular\"),\n    ARIAL(\"Arial\"),\n    CAMBRIA(\"Cambria\"),\n    ROCKWELL(\"Rockwell\"),\n    SEGOE_UI(\"Segoe Ui\"),\n    TIMES_NEW_ROMAN(\"Times New Roman\"),\n    VERDANA(\"Verdana\");\n\n    private final String name;\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n","filePath":"src\\main\\java\\com\\visualmetronome\\FontTypes.java"},{"fileName":"FullResizableVisualMetronomeOverlay.java","content":"package com.visualmetronome;\n\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Font;\nimport javax.inject.Inject;\nimport net.runelite.api.Point;\nimport net.runelite.client.ui.overlay.OverlayUtil;\n\npublic class FullResizableVisualMetronomeOverlay extends Overlay\n{\n\n    private final VisualMetronomeConfig config;\n    private final VisualMetronomePlugin plugin;\n\n    private static int TITLE_PADDING \u003d 10;\n    private static final int MINIMUM_SIZE \u003d 16; // too small and resizing becomes impossible, requiring a reset\n    private Point tickCounterCenter;\n\n    @Inject\n    public FullResizableVisualMetronomeOverlay(VisualMetronomeConfig config, VisualMetronomePlugin plugin)\n    {\n        super(plugin);\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.ABOVE_CHATBOX_RIGHT);\n        setMinimumSize(MINIMUM_SIZE);\n        setResizable(true);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        Dimension preferredSize \u003d getPreferredSize();\n\n        if (preferredSize \u003d\u003d null)\n        {\n            // if this happens, reset to default - should be rare, but eg. alt+rightclick will cause this\n            preferredSize \u003d plugin.DEFAULT_SIZE;\n            setPreferredSize(preferredSize);\n        }\n\n        if (config.enableMetronome())\n        {\n            graphics.setColor(plugin.currentColor);\n            graphics.fillRect(0, 0, preferredSize.width, preferredSize.height);\n            TITLE_PADDING \u003d (Math.min(preferredSize.width, preferredSize.height) / 2 - 4); // scales tick number position with box size\n\n            if (config.showTick())\n            {\n                if (config.disableFontScaling())\n                {\n                    graphics.setColor(config.NumberColor());\n                    if (config.tickCount() \u003d\u003d 1)\n                    {\n                        graphics.drawString(String.valueOf(plugin.currentColorIndex), TITLE_PADDING, preferredSize.height - TITLE_PADDING);\n                    }\n                    else\n                    {\n                        graphics.drawString(String.valueOf(plugin.tickCounter), TITLE_PADDING, preferredSize.height - TITLE_PADDING);\n                    }\n\n                }\n                else\n                {\n                    if (config.fontType() \u003d\u003d FontTypes.REGULAR)\n                    {\n                        graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.PLAIN, Math.min(preferredSize.width, preferredSize.height))); //scales font size based on the size of the metronome\n                        tickCounterCenter \u003d new Point(preferredSize.width / 4, preferredSize.height);\n                    }\n                    else\n                    {\n                        graphics.setFont(new Font(config.fontType().toString(), Font.PLAIN, Math.min(preferredSize.width, Math.min(preferredSize.width, preferredSize.height))));\n                        tickCounterCenter \u003d new Point(preferredSize.width / 4, preferredSize.height - (preferredSize.height / 8));\n                    }\n\n                    final Point tickCounterPoint \u003d tickCounterCenter;\n                    if (config.tickCount() \u003d\u003d 1)\n                    {\n                        OverlayUtil.renderTextLocation(graphics, tickCounterPoint, String.valueOf(plugin.currentColorIndex), config.NumberColor());\n                    }\n                    else\n                    {\n                        OverlayUtil.renderTextLocation(graphics, tickCounterPoint, String.valueOf(plugin.tickCounter), config.NumberColor());\n                    }\n                }\n            }\n        }\n\n        return preferredSize;\n    }\n}\n","filePath":"src\\main\\java\\com\\visualmetronome\\FullResizableVisualMetronomeOverlay.java"},{"fileName":"TickRequestMessage.java","content":"package com.visualmetronome.messages;\n\nimport net.runelite.client.party.messages.PartyMemberMessage;\n\npublic class TickRequestMessage extends PartyMemberMessage\n{\n    private String target;\n\n    public TickRequestMessage() {}\n\n    public TickRequestMessage(String target)\n    {\n        this.target \u003d target;\n    }\n\n    public String getTarget()\n    {\n        return target;\n    }\n\n    public void setTarget(String target)\n    {\n        this.target \u003d target;\n    }\n}\n","filePath":"src\\main\\java\\com\\visualmetronome\\messages\\TickRequestMessage.java"},{"fileName":"TickSyncMessage.java","content":"package com.visualmetronome.messages;\n\nimport net.runelite.client.party.messages.PartyMemberMessage;\n\npublic class TickSyncMessage extends PartyMemberMessage\n{\n    private int tickCounter;\n    private int tickCounter2;\n    private int tickCounter3;\n    private int colorIndex;\n    private int configColorIndex;\n    private int tickCount;\n    private int tickCount2;\n    private int tickCount3;\n\n    private String displayName;\n    private String localSender;\n\n    public TickSyncMessage() {}\n\n    public TickSyncMessage(int tickCounter, int tickCounter2, int tickCounter3, int colorIndex, int configColorIndex, int tickCount, int tickCount2, int tickCount3, String localSender)\n    {\n        this.tickCounter \u003d tickCounter;\n        this.tickCounter2 \u003d tickCounter2;\n        this.tickCounter3 \u003d tickCounter3;\n        this.colorIndex \u003d colorIndex;\n        this.configColorIndex \u003d configColorIndex;\n        this.tickCount \u003d tickCount;\n        this.tickCount2 \u003d tickCount2;\n        this.tickCount3 \u003d tickCount3;\n        this.localSender \u003d localSender;\n\n    }\n\n    public String getlocalSender()\n    {\n        return localSender;\n    }\n\n    public void setlocalSender(String localSender)\n    {\n        this.localSender \u003d localSender;\n    }\n\n    public String getDisplayName()\n    {\n        return displayName;\n    }\n\n    public void setDisplayName(String displayName)\n    {\n        this.displayName \u003d displayName;\n    }\n\n    public int getTickCount()\n    {\n        return tickCount;\n    }\n\n    public int getTickCount2()\n    {\n        return tickCount2;\n    }\n\n    public int getTickCount3()\n    {\n        return tickCount3;\n    }\n\n    public int getTickCounter()\n    {\n        return tickCounter;\n    }\n\n    public int getTickCounter2()\n    {\n        return tickCounter2;\n    }\n\n    public int getTickCounter3()\n    {\n        return tickCounter3;\n    }\n\n    public int getColorIndex()\n    {\n        return colorIndex;\n    }\n\n    public int getConfigColorIndex()\n    {\n        return configColorIndex;\n    }\n}\n","filePath":"src\\main\\java\\com\\visualmetronome\\messages\\TickSyncMessage.java"},{"fileName":"MouseFollowingOverlay.java","content":"package com.visualmetronome;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Point;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\n\nimport javax.inject.Inject;\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\n\npublic class MouseFollowingOverlay extends Overlay {\n    private final Client client;\n    private final VisualMetronomeConfig config;\n    private final VisualMetronomePlugin plugin;\n\n    @Inject\n    public MouseFollowingOverlay(Client client, VisualMetronomeConfig config, VisualMetronomePlugin plugin)\n    {\n        super(plugin);\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.ALWAYS_ON_TOP);\n        setPriority(OverlayPriority.HIGH);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        if (config.mouseFollowingTick())\n        {\n            Point mousePos \u003d client.getMouseCanvasPosition();\n            if (mousePos !\u003d null)\n            {\n                // Set font\n                Font font \u003d config.fontType() \u003d\u003d FontTypes.REGULAR\n                        ? FontManager.getRunescapeFont().deriveFont(Font.PLAIN, config.fontSize())\n                        : new Font(config.fontType().toString(), Font.PLAIN, config.fontSize());\n                graphics.setFont(font);\n\n                // Set text\n                String text \u003d config.tickCount() \u003d\u003d 1\n                        ? String.valueOf(plugin.currentColorIndex)\n                        : String.valueOf(plugin.tickCounter);\n\n                // Apply configurable offsets using getX()/getY()\n                Point textPosition \u003d new Point(\n                        (int)mousePos.getX() + config.mouseOffsetX(),\n                        (int)mousePos.getY() + config.mouseOffsetY()\n                );\n\n                // Set which color to use\n\n                Color numberColor;\n                if (config.overheadUseCurrentColor())\n                {\n                    numberColor \u003d plugin.currentColor;\n                }\n                else\n                {\n                    numberColor \u003d config.NumberColor();\n                }\n\n                // Render\n                OverlayUtil.renderTextLocation(graphics, textPosition, text, numberColor);\n            }\n        }\n        return null;\n    }\n}","filePath":"src\\main\\java\\com\\visualmetronome\\MouseFollowingOverlay.java"},{"fileName":"VisualMetronomeConfig.java","content":"package com.visualmetronome;\n\nimport net.runelite.client.config.Alpha;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.Range;\nimport net.runelite.client.config.ConfigSection;\nimport net.runelite.client.config.Keybind;\n\nimport java.awt.Color;\n\n@ConfigGroup(\"visualmetronome\")\npublic interface VisualMetronomeConfig extends Config\n{\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"enableMetronome\",\n\t\t\tname \u003d \"Visual Metronome\",\n\t\t\tdescription \u003d \"Enable visual metronome\"\n\t)\n\tdefault boolean enableMetronome()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"highlightCurrentTile\",\n\t\t\tname \u003d \"Enable True Tile Overlay\",\n\t\t\tdescription \u003d \"Highlights true player tile using the metronome colors (replacement for tile indicator plugin setting)\"\n\t)\n\tdefault boolean highlightCurrentTile()\n\t{\n\t\treturn false;\n\t}\n\n\n\t@Range(\n\t\t\tmin \u003d 16\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"boxWidth\",\n\t\t\tname \u003d \"Default Box Size (Alt + Right Click Box)\",\n\t\t\tdescription \u003d \"Configure the default length and width of the box. Use alt + right click on the box to reset to the size specified\"\n\t)\n\tdefault int boxWidth()\n\t{\n\t\treturn 25;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d 1\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"tickCount\",\n\t\t\tname \u003d \"Tick Count\",\n\t\t\tdescription \u003d \"The tick on which the color changes\"\n\t)\n\tdefault int tickCount()\n\t{\n\t\treturn 1;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Tick Number Settings\",\n\t\t\tdescription \u003d \"Change Tick Number settings\",\n\t\t\tposition \u003d 5\n\t)\n\tString TickNumberSettings \u003d \"Tick Number Settings\";\n\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"showTick\",\n\t\t\tname \u003d \"Show Metronome Tick Number\",\n\t\t\tdescription \u003d \"Shows current tick number on the metronome\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault boolean showTick()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"showPlayerTick\",\n\t\t\tname \u003d \"Show Tick Number Above Player\",\n\t\t\tdescription \u003d \"Shows current tick number above the player\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault boolean showPlayerTick()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"disableFontScaling\",\n\t\t\tname \u003d \"Disable Font Size Scaling (Metronome Tick Only)\",\n\t\t\tdescription \u003d \"Disables font size scaling for metronome tick number\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault boolean disableFontScaling()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d 8,\n\t\t\tmax \u003d 50\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"fontSize\",\n\t\t\tname \u003d \"Font Size (Overhead Tick Only)\",\n\t\t\tdescription \u003d \"Change the font size of the overhead Tick Number\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault int fontSize()\n\t{\n\t\treturn 15;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"countColor\",\n\t\t\tname \u003d \"Tick Number Color\",\n\t\t\tdescription \u003d \"Configures the color of tick number\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault Color NumberColor()\n\t{\n\t\treturn Color.CYAN;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"fontType\",\n\t\t\tname \u003d \"Font Type\",\n\t\t\tdescription \u003d \"Change the font of the Tick Number\",\n\t\t\tsection \u003d TickNumberSettings\n\t)\n\tdefault FontTypes fontType() { return FontTypes.REGULAR; }\n\n\t@ConfigSection(\n\t\t\tname \u003d \"True Tile Overlay Settings\",\n\t\t\tdescription \u003d \"Settings only applied to True Tile Overlay\",\n\t\t\tposition \u003d 6\n\t)\n\tString TileSettings \u003d \"True Tile Overlay Settings\";\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"currentTileFillColor\",\n\t\t\tname \u003d \"True Tile Fill Color\",\n\t\t\tdescription \u003d \"Fill color of the true tile overlay\",\n\t\t\tsection \u003d TileSettings\n\t)\n\tdefault Color currentTileFillColor()\n\t{\n\t\treturn new Color(0, 0, 0, 50);\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"currentTileBorderWidth\",\n\t\t\tname \u003d \"True Tile Border Width\",\n\t\t\tdescription \u003d \"Border size of the true tile overlay\",\n\t\t\tsection \u003d TileSettings\n\t)\n\tdefault double currentTileBorderWidth()\n\t{\n\t\treturn 2;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"changeFillColor\",\n\t\t\tname \u003d \"Enable Tile Fill Color Metronome\",\n\t\t\tdescription \u003d \"Makes the tile fill color change with the metronome\",\n\t\t\tsection \u003d TileSettings\n\t)\n\tdefault boolean changeFillColor()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d 0,\n\t\t\tmax \u003d 255\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"changeFillColorOpacity\",\n\t\t\tname \u003d \"Fill Color Metronome Opacity\",\n\t\t\tdescription \u003d \"Opacity of the tile fill metronome color if the option above is enabled. Otherwise, the opacity is determined by the True Tile Fill Color setting\",\n\t\t\tsection \u003d TileSettings\n\t)\n\tdefault int changeFillColorOpacity()\n\t{\n\t\treturn 50;\n\t}\n\n\n    @ConfigSection(\n            name \u003d \"Party Sync Settings\",\n            description \u003d \"Settings for syncing your metronome to a member of your party, this may modify the Tick Count and Number of Colors config settings\",\n            position \u003d 7\n    )\n\n    String PartySyncSettings \u003d \"Party Sync Settings\";\n\n    @ConfigItem(\n            position \u003d 1,\n            keyName \u003d \"enablePartySync\",\n            name \u003d \"Sync with Target\",\n            description \u003d \"Synchronize tick counters with a selected party member\",\n            section \u003d PartySyncSettings\n    )\n\n    default boolean enablePartySync()\n    {\n        return false;\n    }\n\n    @ConfigItem(\n            position \u003d 2,\n            keyName \u003d \"syncTarget\",\n            name \u003d \"Sync Target\",\n            description \u003d \"Choose which party member to sync ticks with\",\n            section \u003d PartySyncSettings\n    )\n    default String syncTarget()\n    {\n        return \"\";\n    }\n\n\n    @ConfigSection(\n\t\t\tname \u003d \"Color Settings\",\n\t\t\tdescription \u003d \"Change the colors and number of colors to cycle through\",\n\t\t\tposition \u003d 8\n\t)\n\tString ColorSettings \u003d \"Color Settings\";\n\n\n\t@Range(\n\t\t\tmin \u003d 2,\n\t\t\tmax \u003d 10\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"colorCycle\",\n\t\t\tname \u003d \"Number of Colors\",\n\t\t\tdescription \u003d \"The number of colors it cycles through\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault int colorCycle()\n\t{\n\t\treturn 2;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"tickColor\",\n\t\t\tname \u003d \"Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of tick\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTickColor()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"tockColor\",\n\t\t\tname \u003d \"Tock Color\",\n\t\t\tdescription \u003d \"Configures the color of tock\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTockColor()\n\t{\n\t\treturn Color.GRAY;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"tick3Color\",\n\t\t\tname \u003d \"3rd Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of 3rd tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick3Color()\n\t{\n\t\treturn Color.DARK_GRAY;\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"tick4Color\",\n\t\t\tname \u003d \"4th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 4th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick4Color()\n\t{\n\t\treturn Color.BLACK;\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"tick5Color\",\n\t\t\tname \u003d \"5th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 5th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick5Color()\n\t{\n\t\treturn new Color(112, 131, 255);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 7,\n\t\t\tkeyName \u003d \"tick6Color\",\n\t\t\tname \u003d \"6th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 6th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick6Color()\n\t{\n\t\treturn new Color(0, 23, 171);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 8,\n\t\t\tkeyName \u003d \"tick7Color\",\n\t\t\tname \u003d \"7th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 7th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick7Color()\n\t{\n\t\treturn new Color(107, 255, 124);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 9,\n\t\t\tkeyName \u003d \"tick8Color\",\n\t\t\tname \u003d \"8th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 8th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick8Color()\n\t{\n\t\treturn new Color(0, 191, 22);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 10,\n\t\t\tkeyName \u003d \"tick9Color\",\n\t\t\tname \u003d \"9th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 9th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick9Color()\n\t{\n\t\treturn new Color(255, 105, 94);\n\t}\n\t@Alpha\n\t@ConfigItem(\n\t\t\tposition \u003d 11,\n\t\t\tkeyName \u003d \"tick10Color\",\n\t\t\tname \u003d \"10th Tick Color\",\n\t\t\tdescription \u003d \"Configures the color of the 10th tick if enabled\",\n\t\t\tsection \u003d ColorSettings\n\t)\n\tdefault Color getTick10Color()\n\t{\n\t\treturn new Color(255, 17, 0);\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Hotkey Settings\",\n\t\t\tdescription \u003d \"Settings that use hotkeys\",\n\t\t\tposition \u003d 9\n\t)\n\tString HotkeySettings \u003d \"Hotkey Settings\";\n\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"tickResetHotkey\",\n\t\t\tname \u003d \"Tick Cycle Reset Hotkey\",\n\t\t\tdescription \u003d \"Hotkey to reset the tick cycle back to 0\",\n\t\t\tsection \u003d HotkeySettings\n\t)\n\tdefault Keybind tickResetHotkey() {\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@Range(\n\t\tmin \u003d 0\n\t)\n\t@ConfigItem(\n\t\tposition \u003d 2,\n\t\tkeyName \u003d \"tickResetStartTick\",\n\t\tname \u003d \"Reset to Tick\",\n\t\tdescription \u003d \"Choose which tick the hotkey resets the timer to\",\n\t\tsection \u003d HotkeySettings\n\t)\n\tdefault int tickResetStartTick()\n\t{\n\t\treturn 0;\n\t}\n\t@ConfigSection(\n\t\t\tname \u003d \"Mouse Following Settings\",\n\t\t\tdescription \u003d \"Settings for mouse-following tick counter\",\n\t\t\tposition \u003d 10,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString mouseFollowingSettings \u003d \"Mouse Following Settings\";\n\t@ConfigItem(\n\t\t\tposition \u003d 0,\n\t\t\tkeyName \u003d \"mouseFollowingTick\",\n\t\t\tname \u003d \"Tick Counter Follows Mouse\",\n\t\t\tdescription \u003d \"Makes the tick counter follow your mouse cursor. It uses the same settings as the Overhead Tick Number\",\n\t\t\tsection \u003d mouseFollowingSettings\n\t)\n\tdefault boolean mouseFollowingTick()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d -100,\n\t\t\tmax \u003d 100\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"mouseOffsetX\",\n\t\t\tname \u003d \"Mouse X Offset\",\n\t\t\tdescription \u003d \"X offset from mouse cursor for tick counter\",\n\t\t\tsection \u003d mouseFollowingSettings\n\t)\n\tdefault int mouseOffsetX()\n\t{\n\t\treturn 10;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d -100,\n\t\t\tmax \u003d 100\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"mouseOffsetY\",\n\t\t\tname \u003d \"Mouse Y Offset\",\n\t\t\tdescription \u003d \"Y offset from mouse cursor for tick counter\",\n\t\t\tsection \u003d mouseFollowingSettings\n\t)\n\tdefault int mouseOffsetY()\n\t{\n\t\treturn -10;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Additional Overhead Cycle Settings\",\n\t\t\tdescription \u003d \"Enable additional tick cycles to track\",\n\t\t\tposition \u003d 11,\n\t\t\tclosedByDefault \u003d true\n\t)\n\tString additionalOverheadSettings \u003d \"Additional Overhead Tick Settings\";\n\n\t@ConfigItem(\n\t\t\tposition \u003d 1,\n\t\t\tkeyName \u003d \"showSecondCycle\",\n\t\t\tname \u003d \"Enable Second Cycle\",\n\t\t\tdescription \u003d \"Enables second tick number above the player\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault boolean enableCycle2()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d 2\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 2,\n\t\t\tkeyName \u003d \"tickCount2\",\n\t\t\tname \u003d \"Second Cycle Length\",\n\t\t\tdescription \u003d \"Length for the second cycle in ticks\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault int tickCount2()\n\t{\n\t\treturn 2;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 3,\n\t\t\tkeyName \u003d \"cycle2Color\",\n\t\t\tname \u003d \"Second Cycle Color\",\n\t\t\tdescription \u003d \"Configures the color of second cycle\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault Color cycle2Color()\n\t{\n\t\treturn Color.CYAN;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 4,\n\t\t\tkeyName \u003d \"showThirdCycle\",\n\t\t\tname \u003d \"Enable Third Cycle\",\n\t\t\tdescription \u003d \"Enables third tick number above the player\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault boolean enableCycle3()\n\t{\n\t\treturn false;\n\t}\n\t@Range(\n\t\t\tmin \u003d 2\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 5,\n\t\t\tkeyName \u003d \"tickCount3\",\n\t\t\tname \u003d \"Third Cycle Length\",\n\t\t\tdescription \u003d \"Length for the third cycle in ticks\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault int tickCount3()\n\t{\n\t\treturn 2;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 6,\n\t\t\tkeyName \u003d \"cycle3Color\",\n\t\t\tname \u003d \"Third Cycle Color\",\n\t\t\tdescription \u003d \"Configures the color of third cycle\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault Color cycle3Color()\n\t{\n\t\treturn Color.CYAN;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 7,\n\t\t\tkeyName \u003d \"overheadCyclesGapDistance\",\n\t\t\tname \u003d \"Second and Third Tick Gap Distance\",\n\t\t\tdescription \u003d \"Configures the distance of the gap between the overhead ticks\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault int overheadCyclesGapDistance()\n\t{\n\t\treturn 20;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d -500,\n\t\t\tmax \u003d 500\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 8,\n\t\t\tkeyName \u003d \"overheadHeight\",\n\t\t\tname \u003d \"Overhead Tick Height\",\n\t\t\tdescription \u003d \"Configures the height of overhead ticks\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault int overheadHeight()\n\t{\n\t\treturn 20;\n\t}\n\n\t@Range(\n\t\t\tmin \u003d -50,\n\t\t\tmax \u003d 50\n\t)\n\t@ConfigItem(\n\t\t\tposition \u003d 9,\n\t\t\tkeyName \u003d \"overheadXCenterOffset\",\n\t\t\tname \u003d \"Overhead Tick X Center Offset\",\n\t\t\tdescription \u003d \"Configures the X offset of overhead ticks\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault int overheadXCenterOffset()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tposition \u003d 10,\n\t\t\tkeyName \u003d \"overheadUseCurrentColor\",\n\t\t\tname \u003d \"Use Metronome Color for Overhead\",\n\t\t\tdescription \u003d \"Uses the metronome color for the overhead tick color instead of Tick Number Color\",\n\t\t\tsection \u003d additionalOverheadSettings\n\t)\n\tdefault boolean overheadUseCurrentColor()\n\t{\n\t\treturn false;\n\t}\n\n}\n\n","filePath":"src\\main\\java\\com\\visualmetronome\\VisualMetronomeConfig.java"},{"fileName":"VisualMetronomeNumberOverlay.java","content":"package com.visualmetronome;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.Point;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport javax.inject.Inject;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Font;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport java.awt.Color;\n\n\npublic class VisualMetronomeNumberOverlay extends Overlay\n{\n\n    private final Client client;\n    private final VisualMetronomeConfig config;\n    private final VisualMetronomePlugin plugin;\n\n    @Inject\n    public VisualMetronomeNumberOverlay(Client client, VisualMetronomeConfig config, VisualMetronomePlugin plugin)\n    {\n        super(plugin);\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.UNDER_WIDGETS);\n        setPriority(OverlayPriority.MED);\n\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        if (config.showPlayerTick())\n        {\n            if (config.fontType() \u003d\u003d FontTypes.REGULAR)\n            {\n                graphics.setFont(new Font(FontManager.getRunescapeFont().getName(), Font.PLAIN, config.fontSize()));\n            }\n            else\n            {\n                graphics.setFont(new Font(config.fontType().toString(), Font.PLAIN, config.fontSize()));\n            }\n\n            // Set which color to use\n            Color numberColor;\n            if (config.overheadUseCurrentColor())\n            {\n                numberColor \u003d plugin.currentColor;\n            }\n            else\n            {\n                numberColor \u003d config.NumberColor();\n            }\n\n            final int height \u003d client.getLocalPlayer().getLogicalHeight() + config.overheadHeight();\n            final LocalPoint localLocation \u003d client.getLocalPlayer().getLocalLocation();\n            final Point playerPoint \u003d Perspective.localToCanvas(client, localLocation, client.getPlane(), height);\n            final int valueX \u003d playerPoint.getX() + config.overheadXCenterOffset();\n            final int valueY \u003d playerPoint.getY();\n            final Point tickPoint \u003d new Point(valueX,valueY);\n\n            if (config.tickCount() \u003d\u003d 1)\n            {\n                OverlayUtil.renderTextLocation(graphics, tickPoint, String.valueOf(plugin.currentColorIndex), numberColor);\n            }\n            else\n            {\n                OverlayUtil.renderTextLocation(graphics, tickPoint, String.valueOf(plugin.tickCounter), numberColor);\n            }\n\n            if (config.enableCycle2())\n            {\n                final int valueX2 \u003d valueX - config.overheadCyclesGapDistance();\n                final Point tick2Point \u003d new Point(valueX2,valueY);\n                OverlayUtil.renderTextLocation(graphics, tick2Point, String.valueOf(plugin.tickCounter2), config.cycle2Color());\n            }\n\n            if (config.enableCycle3())\n            {\n                final int valueX3 \u003d valueX + config.overheadCyclesGapDistance();\n                final Point tick3Point \u003d new Point(valueX3,valueY);\n                OverlayUtil.renderTextLocation(graphics, tick3Point, String.valueOf(plugin.tickCounter3), config.cycle3Color());\n            }\n\n        }\n        return null;\n    }\n\n}\n\n\n","filePath":"src\\main\\java\\com\\visualmetronome\\VisualMetronomeNumberOverlay.java"},{"fileName":"VisualMetronomePlugin.java","content":"package com.visualmetronome;\n\nimport com.google.inject.Provides;\nimport net.runelite.api.Point;\nimport net.runelite.api.Client;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport javax.inject.Inject;\nimport java.awt.event.KeyEvent;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport net.runelite.client.input.KeyListener;\nimport net.runelite.client.input.KeyManager;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport net.runelite.client.party.PartyService;\nimport net.runelite.client.party.WSClient;\nimport net.runelite.client.party.events.UserJoin;\nimport net.runelite.client.party.events.UserPart;\nimport com.visualmetronome.messages.TickSyncMessage;\nimport com.visualmetronome.messages.TickRequestMessage;\nimport net.runelite.client.party.PartyMember;\n\nimport java.util.Collections;\nimport java.util.List;\n\n\n@PluginDescriptor(\n        name \u003d \"Visual Metronome\",\n        description \u003d \"Shows a visual cue on an overlay every game tick to help timing based activities\",\n        tags \u003d {\"timers\", \"overlays\", \"tick\", \"skilling\"}\n)\npublic class VisualMetronomePlugin extends Plugin implements KeyListener\n{\n\n    @Inject\n    private OverlayManager overlayManager;\n\n    @Inject\n    private ConfigManager configManager;\n\n    @Inject\n    private VisualMetronomeTileOverlay tileOverlay;\n\n    @Inject\n    private VisualMetronomeNumberOverlay numberOverlay;\n\n    @Inject\n    private FullResizableVisualMetronomeOverlay overlay;\n\n    @Inject\n    private VisualMetronomeConfig config;\n\n    @Inject\n    private KeyManager keyManager;\n\n    @Inject\n    private Client client;\n\n    @Inject\n    private MouseFollowingOverlay mouseFollowingOverlay;\n\n    @Inject\n    private PartyService partyService;\n\n    @Inject\n    private WSClient wsClient;\n\n    List\u003cPartyMember\u003e members \u003d Collections.emptyList();\n    private boolean hasRespondedThisTick \u003d false;\n\n    private static final String CONFIG_GROUP \u003d \"visualmetronome\";\n    protected int currentColorIndex \u003d 0;\n    protected int tickCounter \u003d 0;\n    protected int tickCounter2 \u003d 0;\n    protected int tickCounter3 \u003d 0;\n    protected Color currentColor \u003d Color.WHITE;\n    protected Dimension DEFAULT_SIZE \u003d new Dimension(25, 25);\n\n    @Provides\n    VisualMetronomeConfig provideConfig(ConfigManager configManager)\n    {\n        return configManager.getConfig(VisualMetronomeConfig.class);\n    }\n\n    @Subscribe\n    public void onGameTick(GameTick tick)\n    {\n        if (tickCounter % config.tickCount() \u003d\u003d 0)\n        {\n            tickCounter \u003d 0;\n            if (currentColorIndex \u003d\u003d config.colorCycle())\n            {\n                currentColorIndex \u003d 0;\n            }\n            setCurrentColorByColorIndex(++currentColorIndex);\n        }\n        tickCounter++;\n        if (tickCounter2 % config.tickCount2() \u003d\u003d 0){\n            tickCounter2 \u003d 0;\n        }\n        tickCounter2++;\n        if (tickCounter3 % config.tickCount3() \u003d\u003d 0){\n            tickCounter3 \u003d 0;\n        }\n        tickCounter3++;\n\n        //party sync\n        hasRespondedThisTick \u003d false;\n        if (config.enablePartySync())\n        {\n            if (!members.isEmpty())\n            {\n                String targetName \u003d config.syncTarget();\n                partyService.send(new TickRequestMessage(targetName));\n            }\n        }\n\n    }\n\n    @Subscribe\n    public void onTickRequestMessage(TickRequestMessage target)\n    {\n        String syncTarget \u003d target.getTarget();\n        PartyMember localPlayer \u003d partyService.getLocalMember();\n\n        if (!localPlayer.getDisplayName().equalsIgnoreCase(syncTarget))\n        {\n            return;\n        }\n\n        if (hasRespondedThisTick)\n        {\n            return;\n        }\n        hasRespondedThisTick \u003d true;\n\n        TickSyncMessage msg \u003d new TickSyncMessage(\n                tickCounter,\n                tickCounter2,\n                tickCounter3,\n                currentColorIndex,\n                config.colorCycle(),\n                config.tickCount(),\n                config.tickCount2(),\n                config.tickCount3(),\n                localPlayer.getDisplayName()\n        );\n        partyService.send(msg);\n    }\n\n    @Subscribe\n    public void onTickSyncMessage(TickSyncMessage msg)\n    {\n        if (!config.enablePartySync())\n        {\n            return;\n        }\n\n        String Sender \u003d msg.getlocalSender();\n        String targetName \u003d config.syncTarget();\n\n        if (!Sender.equalsIgnoreCase(targetName))\n        {\n            return;\n        }\n\n        //  Apply received counters\n        this.tickCounter \u003d msg.getTickCounter();\n        this.tickCounter2 \u003d msg.getTickCounter2();\n        this.tickCounter3 \u003d msg.getTickCounter3();\n\n        this.currentColorIndex \u003d msg.getColorIndex();\n        setCurrentColorByColorIndex(this.currentColorIndex);\n\n        //  Update config so UI reflects remote tickCount\n        configManager.setConfiguration(\n                CONFIG_GROUP,\n                \"tickCount\",\n                msg.getTickCount()\n        );\n        configManager.setConfiguration(\n                CONFIG_GROUP,\n                \"tickCount2\",\n                msg.getTickCount2()\n        );\n        configManager.setConfiguration(\n                CONFIG_GROUP,\n                \"tickCount3\",\n                msg.getTickCount3()\n        );\n        configManager.setConfiguration(\n                CONFIG_GROUP,\n                \"colorCycle\",\n                msg.getConfigColorIndex()\n        );\n    }\n\n    @Subscribe\n    public void onUserJoin(UserJoin event)\n    {\n        members \u003d partyService.getMembers();\n    }\n\n    @Subscribe\n    public void onUserPart(UserPart event)\n    {\n        members \u003d partyService.getMembers();\n    }\n\n\n    @Subscribe\n    public void onConfigChanged(ConfigChanged event)\n    {\n        if (currentColorIndex \u003e config.colorCycle())\n        {\n            currentColorIndex \u003d 0;\n        }\n\n        if (tickCounter \u003e config.tickCount())\n        {\n            tickCounter \u003d 0;\n        }\n        if (tickCounter2 \u003e config.tickCount2())\n        {\n            tickCounter2 \u003d 0;\n        }\n        if (tickCounter3 \u003e config.tickCount3())\n        {\n            tickCounter3 \u003d 0;\n        }\n\n        DEFAULT_SIZE \u003d new Dimension(config.boxWidth(), config.boxWidth());\n    }\n\n    @Override\n    protected void startUp() throws Exception\n    {\n        DEFAULT_SIZE \u003d new Dimension(config.boxWidth(), config.boxWidth());\n        overlay.setPreferredSize(DEFAULT_SIZE);\n        overlayManager.add(overlay);\n        overlayManager.add(tileOverlay);\n        overlayManager.add(numberOverlay);\n        overlayManager.add(mouseFollowingOverlay);\n        keyManager.registerKeyListener(this);\n        wsClient.registerMessage(TickSyncMessage.class);\n        wsClient.registerMessage(TickRequestMessage.class);\n\n    }\n\n    @Override\n    protected void shutDown() throws Exception\n    {\n        overlayManager.remove(overlay);\n        overlayManager.remove(tileOverlay);\n        overlayManager.remove(numberOverlay);\n        tickCounter \u003d 0;\n        tickCounter2 \u003d 0;\n        tickCounter3 \u003d 0;\n        currentColorIndex \u003d 0;\n        currentColor \u003d config.getTickColor();\n        overlayManager.remove(mouseFollowingOverlay);\n        keyManager.unregisterKeyListener(this);\n        wsClient.unregisterMessage(TickSyncMessage.class);\n        wsClient.unregisterMessage(TickRequestMessage.class);\n\n    }\n\n    //hotkey settings\n    @Override\n    public void keyTyped(KeyEvent e)\n    {\n    }\n\n    @Override\n    public void keyPressed(KeyEvent e)\n    {\n        if (config.tickResetHotkey().matches(e))\n        {\n            int resetValue \u003d 0;\n\n            // Reset Cycle 1\n            if (config.tickCount() \u003e 1)\n            {\n                // Prevent out of bounds by setting to 0 if reset start is above tick count\n                resetValue \u003d (config.tickResetStartTick() \u003e\u003d config.tickCount()) ? 0 : config.tickResetStartTick();\n                // If resetting to 0, set color index to 0 as well so that the color is set to the first color next\n                // onGameTick\n                currentColorIndex \u003d resetValue \u003d\u003d 0 ? 0 : 1;\n            }\n            else\n            {\n                resetValue \u003d (config.tickResetStartTick() \u003e\u003d config.colorCycle()) ? 0 : config.tickResetStartTick();\n                currentColorIndex \u003d resetValue;\n            }\n            tickCounter \u003d resetValue;\n            setCurrentColorByColorIndex(currentColorIndex);\n\n            tickCounter2 \u003d (config.tickResetStartTick() \u003e\u003d config.tickCount2()) ? 0 : config.tickResetStartTick();\n            tickCounter3 \u003d (config.tickResetStartTick() \u003e\u003d config.tickCount3()) ? 0 : config.tickResetStartTick();\n        }\n    }\n\n    @Override\n    public void keyReleased(KeyEvent e)\n    {\n    }\n\n    private void setCurrentColorByColorIndex(int currentColorIndex)\n    {\n        switch (currentColorIndex)\n        {\n            case 1:\n                currentColor \u003d config.getTickColor();\n                break;\n            case 2:\n                currentColor \u003d config.getTockColor();\n                break;\n            case 3:\n                currentColor \u003d config.getTick3Color();\n                break;\n            case 4:\n                currentColor \u003d config.getTick4Color();\n                break;\n            case 5:\n                currentColor \u003d config.getTick5Color();\n                break;\n            case 6:\n                currentColor \u003d config.getTick6Color();\n                break;\n            case 7:\n                currentColor \u003d config.getTick7Color();\n                break;\n            case 8:\n                currentColor \u003d config.getTick8Color();\n                break;\n            case 9:\n                currentColor \u003d config.getTick9Color();\n                break;\n            case 10:\n                currentColor \u003d config.getTick10Color();\n        }\n    }\n}\n","filePath":"src\\main\\java\\com\\visualmetronome\\VisualMetronomePlugin.java"},{"fileName":"VisualMetronomeTileOverlay.java","content":"package com.visualmetronome;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.Perspective;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayUtil;\nimport javax.inject.Inject;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPriority;\n\n\npublic class VisualMetronomeTileOverlay extends Overlay\n{\n\n    private final Client client;\n    private final VisualMetronomeConfig config;\n    private final VisualMetronomePlugin plugin;\n\n    @Inject\n    public VisualMetronomeTileOverlay(Client client, VisualMetronomeConfig config, VisualMetronomePlugin plugin)\n    {\n        super(plugin);\n        this.client \u003d client;\n        this.config \u003d config;\n        this.plugin \u003d plugin;\n        setPosition(OverlayPosition.DYNAMIC);\n        setLayer(OverlayLayer.ABOVE_SCENE);\n        setPriority(OverlayPriority.MED);\n    }\n\n    @Override\n    public Dimension render(Graphics2D graphics)\n    {\n        if (config.highlightCurrentTile())\n        {\n            final WorldPoint playerPos \u003d client.getLocalPlayer().getWorldLocation();\n            if (playerPos \u003d\u003d null)\n            {\n                return null;\n            }\n\n            final LocalPoint playerPosLocal \u003d LocalPoint.fromWorld(client, playerPos);\n            if (playerPosLocal \u003d\u003d null)\n            {\n                return null;\n            }\n\n            if (config.changeFillColor())\n            {\n                final Color fillColor \u003d new Color(plugin.currentColor.getRed(), plugin.currentColor.getGreen(), plugin.currentColor.getBlue(), config.changeFillColorOpacity());\n                renderTile(graphics, playerPosLocal, plugin.currentColor, fillColor, config.currentTileBorderWidth());\n            }\n            else\n            {\n                renderTile(graphics, playerPosLocal, plugin.currentColor, config.currentTileFillColor(), config.currentTileBorderWidth());\n            }\n        }\n\n        return null;\n    }\n\n    private void renderTile(final Graphics2D graphics, final LocalPoint dest, final Color color, final Color fillColor, final double borderWidth)\n    {\n        if (dest \u003d\u003d null)\n        {\n            return;\n        }\n\n        final Polygon poly \u003d Perspective.getCanvasTilePoly(client, dest);\n\n        if (poly \u003d\u003d null)\n        {\n            return;\n        }\n\n        OverlayUtil.renderPolygon(graphics, poly, color, fillColor, new BasicStroke((float) borderWidth));\n    }\n}\n\n\n","filePath":"src\\main\\java\\com\\visualmetronome\\VisualMetronomeTileOverlay.java"},{"fileName":"VisualMetronomePluginTest.java","content":"package com.visualmetronome;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class VisualMetronomePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(VisualMetronomePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}\n","filePath":"src\\test\\java\\com\\visualmetronome\\VisualMetronomePluginTest.java"}]},{"commit":"9d1a72a8605633f89539c7d062fecfd806c22e51","repository":"https://github.com/JDrinkH2O/lennys-custom-clues.git","internalName":"lennys-custom-clues","files":[{"fileName":"AnimationTriggers.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.api.AnimationID;\n\npublic class AnimationTriggers\n{\n\tpublic static boolean isTriggerAnimation(int animationId)\n\t{\n\t\t// Check for digging animation\n\t\tif (animationId \u003d\u003d AnimationID.DIG) // 830\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\t// Check for supported emote animations\n\t\treturn EmoteData.getEmoteName(animationId) !\u003d null \u0026\u0026 !EmoteData.getEmoteName(animationId).equals(\"Unknown Emote\");\n\t}\n\n\tpublic static boolean isDigAnimation(int animationId)\n\t{\n\t\treturn animationId \u003d\u003d AnimationID.DIG;\n\t}\n\n\tpublic static boolean isEmoteAnimation(int animationId)\n\t{\n\t\tString emoteName \u003d EmoteData.getEmoteName(animationId);\n\t\treturn emoteName !\u003d null \u0026\u0026 !emoteName.equals(\"Unknown Emote\");\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\AnimationTriggers.java"},{"fileName":"AnswerBuilder.java","content":"package com.lennyscustomclues;\n\nimport com.lennyscustomclues.constraints.*;\nimport com.lennyscustomclues.ApiClient.GameStateSubmission;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AnswerBuilder\n{\n\tprivate String rewardText;\n\tprivate List\u003cConstraint\u003e constraints;\n\n\tpublic AnswerBuilder()\n\t{\n\t\tthis.constraints \u003d new ArrayList\u003c\u003e();\n\t\tthis.rewardText \u003d \"\";\n\t}\n\n\tpublic void addConstraint(Constraint constraint)\n\t{\n\t\tconstraints.add(constraint);\n\t}\n\n\tpublic void removeConstraint(int index)\n\t{\n\t\tif (index \u003e\u003d 0 \u0026\u0026 index \u003c constraints.size())\n\t\t{\n\t\t\tconstraints.remove(index);\n\t\t}\n\t}\n\n\tpublic String toJson()\n\t{\n\t\t// TODO: Convert answer structure to JSON for export/API submission\n\t\treturn \"{}\";\n\t}\n\n\tpublic void clear()\n\t{\n\t\tconstraints.clear();\n\t\trewardText \u003d \"\";\n\t}\n\n\t// Getters and setters\n\tpublic String getRewardText() { return rewardText; }\n\tpublic void setRewardText(String rewardText) { this.rewardText \u003d rewardText; }\n\tpublic List\u003cConstraint\u003e getConstraints() { return constraints; }\n\tpublic void setConstraints(List\u003cConstraint\u003e constraints) { this.constraints \u003d constraints; }\n\n\tpublic int getConstraintCount()\n\t{\n\t\treturn constraints.size();\n\t}\n\n\tpublic Constraint getConstraint(int index)\n\t{\n\t\tif (index \u003e\u003d 0 \u0026\u0026 index \u003c constraints.size())\n\t\t{\n\t\t\treturn constraints.get(index);\n\t\t}\n\t\treturn null;\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\AnswerBuilder.java"},{"fileName":"ApiClient.java","content":"package com.lennyscustomclues;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonSyntaxException;\nimport lombok.extern.slf4j.Slf4j;\nimport okhttp3.Call;\nimport okhttp3.Callback;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\n@Slf4j\n@Singleton\npublic class ApiClient\n{\n\tprivate static final String API_BASE_URL \u003d \"https://us-central1-spatial-cargo-409717.cloudfunctions.net/lennys-labyrinth-api\";\n\tprivate static final String SUBMIT_GUESS_ENDPOINT \u003d \"/submit-guess\";\n\tprivate static final String VALIDATE_KEY_ENDPOINT \u003d \"/validate-key\";\n\tprivate static final String CREATE_ANSWER_ENDPOINT \u003d \"/create-answer\";\n\tprivate static final String ANSWER_ENDPOINT \u003d \"/answer\";\n\tprivate static final MediaType JSON \u003d MediaType.get(\"application/json; charset\u003dutf-8\");\n\n\tprivate final OkHttpClient httpClient;\n\tprivate final Gson gson;\n\n\t@Inject\n\tpublic ApiClient(OkHttpClient okHttpClient, Gson gson)\n\t{\n\t\tthis.httpClient \u003d okHttpClient;\n\t\tthis.gson \u003d gson;\n\t}\n\n\tpublic CompletableFuture\u003cApiResponse\u003e submitGuess(GameStateSubmission gameState)\n\t{\n\t\tCompletableFuture\u003cApiResponse\u003e future \u003d new CompletableFuture\u003c\u003e();\n\n\t\ttry\n\t\t{\n\t\t\tString json \u003d gson.toJson(gameState);\n\t\t\tlog.debug(\"Submitting game state JSON: {}\", json);\n\n\t\t\tRequestBody body \u003d RequestBody.create(JSON, json);\n\t\t\tRequest request \u003d new Request.Builder()\n\t\t\t\t.url(API_BASE_URL + SUBMIT_GUESS_ENDPOINT)\n\t\t\t\t.post(body)\n\t\t\t\t.build();\n\n\t\t\thttpClient.newCall(request).enqueue(new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"API request failed\", e);\n\t\t\t\t\tfuture.complete(ApiResponse.error(\"Network error: \" + e.getMessage()));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response)\n\t\t\t\t{\n\t\t\t\t\ttry (response)\n\t\t\t\t\t{\n\t\t\t\t\t\tString responseBody \u003d response.body() !\u003d null ? response.body().string() : \"\";\n\t\t\t\t\t\tlog.debug(\"API response code: {}, body: {}\", response.code(), responseBody);\n\n\t\t\t\t\t\tif (response.isSuccessful())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.error(\"Failed to parse API response JSON\", e);\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.error(\"Invalid response format\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString errorMessage \u003d String.format(\"Server error %d: %s\", response.code(), responseBody);\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.error(errorMessage));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"Failed to read response body\", e);\n\t\t\t\t\t\tfuture.complete(ApiResponse.error(\"Failed to read server response\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to create API request\", e);\n\t\t\tfuture.complete(ApiResponse.error(\"Request creation failed: \" + e.getMessage()));\n\t\t}\n\n\t\treturn future;\n\t}\n\n\tpublic CompletableFuture\u003cApiResponse\u003e validateEventKey(String eventKey)\n\t{\n\t\tCompletableFuture\u003cApiResponse\u003e future \u003d new CompletableFuture\u003c\u003e();\n\n\t\ttry\n\t\t{\n\t\t\tlog.debug(\"Validating event key: {}\", eventKey);\n\n\t\t\tString encodedEventKey \u003d URLEncoder.encode(eventKey, StandardCharsets.UTF_8);\n\t\t\tRequest request \u003d new Request.Builder()\n\t\t\t\t.url(API_BASE_URL + VALIDATE_KEY_ENDPOINT + \"/\" + encodedEventKey)\n\t\t\t\t.get()\n\t\t\t\t.build();\n\n\t\t\thttpClient.newCall(request).enqueue(new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Event key validation request failed\", e);\n\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"NETWORK_ERROR\", \"Network error: \" + e.getMessage()));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response)\n\t\t\t\t{\n\t\t\t\t\ttry (response)\n\t\t\t\t\t{\n\t\t\t\t\t\tString responseBody \u003d response.body() !\u003d null ? response.body().string() : \"\";\n\t\t\t\t\t\tlog.debug(\"Event key validation response code: {}, body: {}\", response.code(), responseBody);\n\n\t\t\t\t\t\tif (response.isSuccessful())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.error(\"Failed to parse event key validation response JSON\", e);\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"PARSE_ERROR\", \"Invalid response format\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 404)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 404 means event key not found - this is expected for invalid keys\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"KEY_NOT_FOUND\", \"Event key not found\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Any other HTTP error (500, 503, etc.)\n\t\t\t\t\t\t\tlog.error(\"Server error response: {} - {}\", response.code(), responseBody);\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"SERVER_ERROR\", \"Server error: \" + response.code()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"Failed to read event key validation response body\", e);\n\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"IO_ERROR\", \"Failed to read server response\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to create event key validation request\", e);\n\t\t\tfuture.complete(ApiResponse.errorWithType(\"REQUEST_ERROR\", \"Request creation failed: \" + e.getMessage()));\n\t\t}\n\n\t\treturn future;\n\t}\n\n\tpublic CompletableFuture\u003cApiResponse\u003e createAnswer(String eventKey, String secretKey, AnswerBuilder answerBuilder)\n\t{\n\t\tCompletableFuture\u003cApiResponse\u003e future \u003d new CompletableFuture\u003c\u003e();\n\n\t\ttry\n\t\t{\n\t\t\t// Build the answer request\n\t\t\tCreateAnswerRequest request \u003d new CreateAnswerRequest();\n\t\t\trequest.event_key \u003d eventKey;\n\t\t\trequest.answer \u003d new AnswerData();\n\t\t\trequest.answer.reward_text \u003d answerBuilder.getRewardText();\n\t\t\trequest.answer.secret_key \u003d secretKey.isEmpty() ? null : secretKey;\n\n\t\t\t// Convert constraints to JSON\n\t\t\trequest.answer.constraints \u003d new java.util.ArrayList\u003c\u003e();\n\t\t\tfor (int i \u003d 0; i \u003c answerBuilder.getConstraintCount(); i++)\n\t\t\t{\n\t\t\t\tcom.lennyscustomclues.constraints.Constraint constraint \u003d answerBuilder.getConstraint(i);\n\t\t\t\t// Serialize each constraint as a map\n\t\t\t\tif (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)\n\t\t\t\t{\n\t\t\t\t\tcom.lennyscustomclues.constraints.LocationConstraint locConstraint \u003d (com.lennyscustomclues.constraints.LocationConstraint) constraint;\n\t\t\t\t\tjava.util.Map\u003cString, Object\u003e constraintMap \u003d new java.util.HashMap\u003c\u003e();\n\t\t\t\t\tconstraintMap.put(\"constraint_type\", locConstraint.getConstraintType());\n\t\t\t\t\tconstraintMap.put(\"type\", locConstraint.getType());\n\n\t\t\t\t\tif (locConstraint.getExactX() !\u003d null) constraintMap.put(\"exact_x\", locConstraint.getExactX());\n\t\t\t\t\tif (locConstraint.getExactY() !\u003d null) constraintMap.put(\"exact_y\", locConstraint.getExactY());\n\t\t\t\t\tif (locConstraint.getMinX() !\u003d null) constraintMap.put(\"min_x\", locConstraint.getMinX());\n\t\t\t\t\tif (locConstraint.getMaxX() !\u003d null) constraintMap.put(\"max_x\", locConstraint.getMaxX());\n\t\t\t\t\tif (locConstraint.getMinY() !\u003d null) constraintMap.put(\"min_y\", locConstraint.getMinY());\n\t\t\t\t\tif (locConstraint.getMaxY() !\u003d null) constraintMap.put(\"max_y\", locConstraint.getMaxY());\n\t\t\t\t\tif (locConstraint.getPlane() !\u003d null) constraintMap.put(\"plane\", locConstraint.getPlane());\n\t\t\t\t\tif (locConstraint.getTolerance() !\u003d null) constraintMap.put(\"tolerance\", locConstraint.getTolerance());\n\n\t\t\t\t\trequest.answer.constraints.add(constraintMap);\n\t\t\t\t}\n\t\t\t\telse if (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)\n\t\t\t\t{\n\t\t\t\t\tcom.lennyscustomclues.constraints.ActionConstraint actionConstraint \u003d (com.lennyscustomclues.constraints.ActionConstraint) constraint;\n\t\t\t\t\tjava.util.Map\u003cString, Object\u003e constraintMap \u003d new java.util.HashMap\u003c\u003e();\n\t\t\t\t\tconstraintMap.put(\"constraint_type\", actionConstraint.getConstraintType());\n\t\t\t\t\tconstraintMap.put(\"type\", actionConstraint.getType());\n\n\t\t\t\t\tif (actionConstraint.getEmoteId() !\u003d null) constraintMap.put(\"emote_id\", actionConstraint.getEmoteId());\n\t\t\t\t\tif (actionConstraint.getEmoteIds() !\u003d null) constraintMap.put(\"emote_ids\", actionConstraint.getEmoteIds());\n\t\t\t\t\tif (actionConstraint.getNpcId() !\u003d null) constraintMap.put(\"npc_id\", actionConstraint.getNpcId());\n\t\t\t\t\tif (actionConstraint.getNpcIds() !\u003d null) constraintMap.put(\"npc_ids\", actionConstraint.getNpcIds());\n\t\t\t\t\tif (actionConstraint.getInteractionType() !\u003d null) constraintMap.put(\"interaction_type\", actionConstraint.getInteractionType());\n\t\t\t\t\tif (actionConstraint.getInteractionTypes() !\u003d null) constraintMap.put(\"interaction_types\", actionConstraint.getInteractionTypes());\n\n\t\t\t\t\trequest.answer.constraints.add(constraintMap);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString json \u003d gson.toJson(request);\n\t\t\tlog.debug(\"Creating answer JSON: {}\", json);\n\n\t\t\tRequestBody body \u003d RequestBody.create(JSON, json);\n\t\t\tRequest httpRequest \u003d new Request.Builder()\n\t\t\t\t.url(API_BASE_URL + CREATE_ANSWER_ENDPOINT)\n\t\t\t\t.post(body)\n\t\t\t\t.build();\n\n\t\t\thttpClient.newCall(httpRequest).enqueue(new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Create answer request failed\", e);\n\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"NETWORK_ERROR\", \"Network error: \" + e.getMessage()));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response)\n\t\t\t\t{\n\t\t\t\t\ttry (response)\n\t\t\t\t\t{\n\t\t\t\t\t\tString responseBody \u003d response.body() !\u003d null ? response.body().string() : \"\";\n\t\t\t\t\t\tlog.debug(\"Create answer response code: {}, body: {}\", response.code(), responseBody);\n\n\t\t\t\t\t\tif (response.code() \u003d\u003d 201)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 201 Created - success\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.error(\"Failed to parse create answer response JSON\", e);\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.success(\"Answer created successfully\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 409)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 409 Conflict - key already exists\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"KEY_ALREADY_EXISTS\", \"Event key already exists\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 400)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// 400 Bad Request - validation error\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"VALIDATION_ERROR\", \"Invalid request: \" + responseBody));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Any other HTTP error (500, 503, etc.)\n\t\t\t\t\t\t\tlog.error(\"Server error response: {} - {}\", response.code(), responseBody);\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"SERVER_ERROR\", \"Server error: \" + response.code()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"Failed to read create answer response body\", e);\n\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"IO_ERROR\", \"Failed to read server response\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to create answer request\", e);\n\t\t\tfuture.complete(ApiResponse.errorWithType(\"REQUEST_ERROR\", \"Request creation failed: \" + e.getMessage()));\n\t\t}\n\n\t\treturn future;\n\t}\n\n\tpublic CompletableFuture\u003cGetAnswerResponse\u003e getAnswer(String eventKey, String secretKey)\n\t{\n\t\tCompletableFuture\u003cGetAnswerResponse\u003e future \u003d new CompletableFuture\u003c\u003e();\n\n\t\ttry\n\t\t{\n\t\t\tlog.debug(\"Getting answer for event key: {}\", eventKey);\n\n\t\t\tString encodedEventKey \u003d URLEncoder.encode(eventKey, StandardCharsets.UTF_8);\n\t\t\tString encodedSecretKey \u003d URLEncoder.encode(secretKey, StandardCharsets.UTF_8);\n\n\t\t\tRequest request \u003d new Request.Builder()\n\t\t\t\t.url(API_BASE_URL + ANSWER_ENDPOINT + \"/\" + encodedEventKey + \"?secret_key\u003d\" + encodedSecretKey)\n\t\t\t\t.get()\n\t\t\t\t.build();\n\n\t\t\thttpClient.newCall(request).enqueue(new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Get answer request failed\", e);\n\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"NETWORK_ERROR\", \"Network error: \" + e.getMessage()));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response)\n\t\t\t\t{\n\t\t\t\t\ttry (response)\n\t\t\t\t\t{\n\t\t\t\t\t\tString responseBody \u003d response.body() !\u003d null ? response.body().string() : \"\";\n\t\t\t\t\t\tlog.debug(\"Get answer response code: {}, body: {}\", response.code(), responseBody);\n\n\t\t\t\t\t\tif (response.isSuccessful())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tGetAnswerResponse apiResponse \u003d gson.fromJson(responseBody, GetAnswerResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.error(\"Failed to parse get answer response JSON\", e);\n\t\t\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"PARSE_ERROR\", \"Invalid response format\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 404)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"NOT_FOUND\", \"Event key not found\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 401)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"UNAUTHORIZED\", \"Invalid secret key\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 400)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"BAD_REQUEST\", \"Bad request\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.error(\"Server error response: {} - {}\", response.code(), responseBody);\n\t\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"SERVER_ERROR\", \"Server error: \" + response.code()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"Failed to read get answer response body\", e);\n\t\t\t\t\t\tfuture.complete(GetAnswerResponse.error(\"IO_ERROR\", \"Failed to read server response\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to create get answer request\", e);\n\t\t\tfuture.complete(GetAnswerResponse.error(\"REQUEST_ERROR\", \"Request creation failed: \" + e.getMessage()));\n\t\t}\n\n\t\treturn future;\n\t}\n\n\tpublic CompletableFuture\u003cApiResponse\u003e updateAnswer(String eventKey, String secretKey, AnswerBuilder answerBuilder)\n\t{\n\t\tCompletableFuture\u003cApiResponse\u003e future \u003d new CompletableFuture\u003c\u003e();\n\n\t\ttry\n\t\t{\n\t\t\t// Build the answer data\n\t\t\tAnswerData answerData \u003d new AnswerData();\n\t\t\tanswerData.reward_text \u003d answerBuilder.getRewardText();\n\n\t\t\t// Convert constraints to JSON\n\t\t\tanswerData.constraints \u003d new java.util.ArrayList\u003c\u003e();\n\t\t\tfor (int i \u003d 0; i \u003c answerBuilder.getConstraintCount(); i++)\n\t\t\t{\n\t\t\t\tcom.lennyscustomclues.constraints.Constraint constraint \u003d answerBuilder.getConstraint(i);\n\t\t\t\t// Serialize each constraint as a map\n\t\t\t\tif (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)\n\t\t\t\t{\n\t\t\t\t\tcom.lennyscustomclues.constraints.LocationConstraint locConstraint \u003d (com.lennyscustomclues.constraints.LocationConstraint) constraint;\n\t\t\t\t\tjava.util.Map\u003cString, Object\u003e constraintMap \u003d new java.util.HashMap\u003c\u003e();\n\t\t\t\t\tconstraintMap.put(\"constraint_type\", locConstraint.getConstraintType());\n\t\t\t\t\tconstraintMap.put(\"type\", locConstraint.getType());\n\n\t\t\t\t\tif (locConstraint.getExactX() !\u003d null) constraintMap.put(\"exact_x\", locConstraint.getExactX());\n\t\t\t\t\tif (locConstraint.getExactY() !\u003d null) constraintMap.put(\"exact_y\", locConstraint.getExactY());\n\t\t\t\t\tif (locConstraint.getMinX() !\u003d null) constraintMap.put(\"min_x\", locConstraint.getMinX());\n\t\t\t\t\tif (locConstraint.getMaxX() !\u003d null) constraintMap.put(\"max_x\", locConstraint.getMaxX());\n\t\t\t\t\tif (locConstraint.getMinY() !\u003d null) constraintMap.put(\"min_y\", locConstraint.getMinY());\n\t\t\t\t\tif (locConstraint.getMaxY() !\u003d null) constraintMap.put(\"max_y\", locConstraint.getMaxY());\n\t\t\t\t\tif (locConstraint.getPlane() !\u003d null) constraintMap.put(\"plane\", locConstraint.getPlane());\n\t\t\t\t\tif (locConstraint.getTolerance() !\u003d null) constraintMap.put(\"tolerance\", locConstraint.getTolerance());\n\n\t\t\t\t\tanswerData.constraints.add(constraintMap);\n\t\t\t\t}\n\t\t\t\telse if (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)\n\t\t\t\t{\n\t\t\t\t\tcom.lennyscustomclues.constraints.ActionConstraint actionConstraint \u003d (com.lennyscustomclues.constraints.ActionConstraint) constraint;\n\t\t\t\t\tjava.util.Map\u003cString, Object\u003e constraintMap \u003d new java.util.HashMap\u003c\u003e();\n\t\t\t\t\tconstraintMap.put(\"constraint_type\", actionConstraint.getConstraintType());\n\t\t\t\t\tconstraintMap.put(\"type\", actionConstraint.getType());\n\n\t\t\t\t\tif (actionConstraint.getEmoteId() !\u003d null) constraintMap.put(\"emote_id\", actionConstraint.getEmoteId());\n\t\t\t\t\tif (actionConstraint.getEmoteIds() !\u003d null) constraintMap.put(\"emote_ids\", actionConstraint.getEmoteIds());\n\t\t\t\t\tif (actionConstraint.getNpcId() !\u003d null) constraintMap.put(\"npc_id\", actionConstraint.getNpcId());\n\t\t\t\t\tif (actionConstraint.getNpcIds() !\u003d null) constraintMap.put(\"npc_ids\", actionConstraint.getNpcIds());\n\t\t\t\t\tif (actionConstraint.getInteractionType() !\u003d null) constraintMap.put(\"interaction_type\", actionConstraint.getInteractionType());\n\t\t\t\t\tif (actionConstraint.getInteractionTypes() !\u003d null) constraintMap.put(\"interaction_types\", actionConstraint.getInteractionTypes());\n\n\t\t\t\t\tanswerData.constraints.add(constraintMap);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString json \u003d gson.toJson(answerData);\n\t\t\tlog.debug(\"Updating answer JSON: {}\", json);\n\n\t\t\tString encodedEventKey \u003d URLEncoder.encode(eventKey, StandardCharsets.UTF_8);\n\t\t\tString encodedSecretKey \u003d URLEncoder.encode(secretKey, StandardCharsets.UTF_8);\n\n\t\t\tRequestBody body \u003d RequestBody.create(JSON, json);\n\t\t\tRequest httpRequest \u003d new Request.Builder()\n\t\t\t\t.url(API_BASE_URL + ANSWER_ENDPOINT + \"/\" + encodedEventKey + \"?secret_key\u003d\" + encodedSecretKey)\n\t\t\t\t.patch(body)\n\t\t\t\t.build();\n\n\t\t\thttpClient.newCall(httpRequest).enqueue(new Callback()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void onFailure(Call call, IOException e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Update answer request failed\", e);\n\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"NETWORK_ERROR\", \"Network error: \" + e.getMessage()));\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onResponse(Call call, Response response)\n\t\t\t\t{\n\t\t\t\t\ttry (response)\n\t\t\t\t\t{\n\t\t\t\t\t\tString responseBody \u003d response.body() !\u003d null ? response.body().string() : \"\";\n\t\t\t\t\t\tlog.debug(\"Update answer response code: {}, body: {}\", response.code(), responseBody);\n\n\t\t\t\t\t\tif (response.isSuccessful())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.error(\"Failed to parse update answer response JSON\", e);\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.success(\"Answer updated successfully\"));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 404)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"NOT_FOUND\", \"Event key not found\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 401)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"UNAUTHORIZED\", \"Invalid secret key\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (response.code() \u003d\u003d 400)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tApiResponse apiResponse \u003d gson.fromJson(responseBody, ApiResponse.class);\n\t\t\t\t\t\t\t\tfuture.complete(apiResponse);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcatch (JsonSyntaxException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"VALIDATION_ERROR\", \"Invalid request: \" + responseBody));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlog.error(\"Server error response: {} - {}\", response.code(), responseBody);\n\t\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"SERVER_ERROR\", \"Server error: \" + response.code()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"Failed to read update answer response body\", e);\n\t\t\t\t\t\tfuture.complete(ApiResponse.errorWithType(\"IO_ERROR\", \"Failed to read server response\"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.error(\"Failed to create update answer request\", e);\n\t\t\tfuture.complete(ApiResponse.errorWithType(\"REQUEST_ERROR\", \"Request creation failed: \" + e.getMessage()));\n\t\t}\n\n\t\treturn future;\n\t}\n\n\t// Inner classes for data structures matching the server API\n\tpublic static class GameStateSubmission\n\t{\n\t\tpublic LocationData location;\n\t\tpublic List\u003cItemData\u003e inventory;\n\t\tpublic List\u003cItemData\u003e worn_items;\n\t\tpublic Integer emote_id;\n\t\tpublic Integer npc_id;\n\t\tpublic String interaction_type;\n\t\tpublic String event_key;\n\t\tpublic String rsn;\n\n\t\tpublic GameStateSubmission(LocationData location, List\u003cItemData\u003e inventory, \n\t\t\tList\u003cItemData\u003e wornItems, Integer emoteId, Integer npcId, \n\t\t\tString interactionType, String eventKey, String rsn)\n\t\t{\n\t\t\tthis.location \u003d location;\n\t\t\tthis.inventory \u003d inventory;\n\t\t\tthis.worn_items \u003d wornItems;\n\t\t\tthis.emote_id \u003d emoteId;\n\t\t\tthis.npc_id \u003d npcId;\n\t\t\tthis.interaction_type \u003d interactionType;\n\t\t\tthis.event_key \u003d eventKey;\n\t\t\tthis.rsn \u003d rsn;\n\t\t}\n\t}\n\n\tpublic static class LocationData\n\t{\n\t\tpublic WorldCoords world;\n\t\tpublic LocalCoords local;\n\n\t\tpublic LocationData(WorldCoords world, LocalCoords local)\n\t\t{\n\t\t\tthis.world \u003d world;\n\t\t\tthis.local \u003d local;\n\t\t}\n\t}\n\n\tpublic static class WorldCoords\n\t{\n\t\tpublic int x;\n\t\tpublic int y;\n\t\tpublic int plane;\n\n\t\tpublic WorldCoords(int x, int y, int plane)\n\t\t{\n\t\t\tthis.x \u003d x;\n\t\t\tthis.y \u003d y;\n\t\t\tthis.plane \u003d plane;\n\t\t}\n\t}\n\n\tpublic static class LocalCoords\n\t{\n\t\tpublic int sceneX;\n\t\tpublic int sceneY;\n\n\t\tpublic LocalCoords(int sceneX, int sceneY)\n\t\t{\n\t\t\tthis.sceneX \u003d sceneX;\n\t\t\tthis.sceneY \u003d sceneY;\n\t\t}\n\t}\n\n\tpublic static class ItemData\n\t{\n\t\tpublic int slot;\n\t\tpublic int id;\n\t\tpublic int quantity;\n\n\t\tpublic ItemData(int slot, int id, int quantity)\n\t\t{\n\t\t\tthis.slot \u003d slot;\n\t\t\tthis.id \u003d id;\n\t\t\tthis.quantity \u003d quantity;\n\t\t}\n\t}\n\n\tpublic static class ApiResponse\n\t{\n\t\tpublic boolean success;\n\t\tpublic String message;\n\t\tpublic String errorType; // For client-side error handling\n\n\t\tpublic ApiResponse(boolean success, String message)\n\t\t{\n\t\t\tthis.success \u003d success;\n\t\t\tthis.message \u003d message;\n\t\t\tthis.errorType \u003d null;\n\t\t}\n\n\t\tprivate ApiResponse(boolean success, String message, String errorType)\n\t\t{\n\t\t\tthis.success \u003d success;\n\t\t\tthis.message \u003d message;\n\t\t\tthis.errorType \u003d errorType;\n\t\t}\n\n\t\tpublic static ApiResponse success(String message)\n\t\t{\n\t\t\treturn new ApiResponse(true, message);\n\t\t}\n\n\t\tpublic static ApiResponse error(String message)\n\t\t{\n\t\t\treturn new ApiResponse(false, message);\n\t\t}\n\n\t\tpublic static ApiResponse errorWithType(String errorType, String message)\n\t\t{\n\t\t\treturn new ApiResponse(false, message, errorType);\n\t\t}\n\t}\n\n\tpublic static class CreateAnswerRequest\n\t{\n\t\tpublic String event_key;\n\t\tpublic AnswerData answer;\n\t}\n\n\tpublic static class AnswerData\n\t{\n\t\tpublic String reward_text;\n\t\tpublic List\u003cjava.util.Map\u003cString, Object\u003e\u003e constraints;\n\t\tpublic String secret_key;\n\t}\n\n\tpublic static class GetAnswerResponse\n\t{\n\t\tpublic String reward_text;\n\t\tpublic List\u003cjava.util.Map\u003cString, Object\u003e\u003e constraints;\n\t\tpublic List\u003cPlayerCompletion\u003e completed_by;\n\t\tpublic String errorType;\n\t\tpublic String errorMessage;\n\n\t\tpublic boolean isSuccess()\n\t\t{\n\t\t\treturn errorType \u003d\u003d null;\n\t\t}\n\n\t\tpublic static GetAnswerResponse error(String errorType, String errorMessage)\n\t\t{\n\t\t\tGetAnswerResponse response \u003d new GetAnswerResponse();\n\t\t\tresponse.errorType \u003d errorType;\n\t\t\tresponse.errorMessage \u003d errorMessage;\n\t\t\treturn response;\n\t\t}\n\t}\n\n\tpublic static class PlayerCompletion\n\t{\n\t\tpublic String rsn;\n\t\tpublic String timestamp;\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\ApiClient.java"},{"fileName":"CelebrationManager.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.SoundEffectID;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.callback.ClientThread;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n@Slf4j\n@Singleton\npublic class CelebrationManager\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate LennysCustomCluesConfig config;\n\n\t@Inject\n\tprivate ScheduledExecutorService scheduledExecutorService;\n\n\tpublic void triggerVictoryCelebration(String puzzleName)\n\t{\n\t\tclientThread.invokeLater(() -\u003e {\n\t\t\tlog.info(\"Triggering victory celebration for puzzle: {}\", puzzleName);\n\n\t\t\tif (config.showCelebrationSound())\n\t\t\t{\n\t\t\t\tplayVictorySound();\n\t\t\t}\n\n\t\t\tif (config.showCelebrationFireworks())\n\t\t\t{\n\t\t\t\ttriggerFireworks();\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void playVictorySound()\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Play a celebratory sound - using the triumphant fanfare sound (ID 2930)\n\t\t\tclient.playSoundEffect(2930);\n\t\t\tlog.debug(\"Played victory sound effect\");\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.warn(\"Failed to play victory sound\", e);\n\t\t}\n\t}\n\n\tprivate void triggerFireworks()\n\t{\n\t\ttry\n\t\t{\n\t\t\tif (client.getLocalPlayer() !\u003d null)\n\t\t\t{\n\t\t\t\t// Create the vanilla OSRS level-up fireworks animation on the player\n\t\t\t\t// SpotAnim ID 199 is the standard fireworks that appear when leveling up\n\t\t\t\t// Height set to 100 to display above the player\u0027s head\n\t\t\t\tclient.getLocalPlayer().createSpotAnim(0, 199, 100, 0);\n\n\t\t\t\t// Also play the level-up sound effects for authenticity\n\t\t\t\tclient.playSoundEffect(2396); // Level up sound 1\n\n\t\t\t\t// Schedule the second sound effect with a delay using ScheduledExecutorService\n\t\t\t\t// to avoid blocking the client thread\n\t\t\t\tscheduledExecutorService.schedule(() -\u003e {\n\t\t\t\t\tclientThread.invokeLater(() -\u003e {\n\t\t\t\t\t\tclient.playSoundEffect(2384); // Level up sound 2\n\t\t\t\t\t});\n\t\t\t\t}, 583, TimeUnit.MILLISECONDS); // 35 game ticks delay (35 * 16.67ms \u003d ~583ms)\n\n\t\t\t\tlog.debug(\"Triggered vanilla fireworks animation (SpotAnim 199) on player\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tlog.warn(\"Failed to trigger fireworks\", e);\n\t\t}\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\CelebrationManager.java"},{"fileName":"ActionConstraint.java","content":"package com.lennyscustomclues.constraints;\n\nimport java.util.List;\n\npublic class ActionConstraint implements Constraint\n{\n\tprivate String type; // \"emote\", \"npc_interaction\", \"any_emote\", \"any_npc\"\n\tprivate Integer emoteId;\n\tprivate List\u003cInteger\u003e emoteIds;\n\tprivate Integer npcId;\n\tprivate List\u003cInteger\u003e npcIds;\n\tprivate String interactionType;\n\tprivate List\u003cString\u003e interactionTypes;\n\n\tpublic ActionConstraint()\n\t{\n\t\t// Default constructor for JSON deserialization\n\t}\n\n\tpublic ActionConstraint(String type)\n\t{\n\t\tthis.type \u003d type;\n\t}\n\n\n\t@Override\n\tpublic String description()\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"emote\":\n\t\t\t\treturn \"Must perform specific emote\";\n\t\t\tcase \"any_emote\":\n\t\t\t\treturn \"Must perform one of specified emotes\";\n\t\t\tcase \"npc_interaction\":\n\t\t\t\treturn \"Must interact with specified NPC\";\n\t\t\tcase \"any_npc\":\n\t\t\t\treturn \"Must interact with any NPC\";\n\t\t\tdefault:\n\t\t\t\treturn \"Action constraint\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getConstraintType()\n\t{\n\t\treturn \"action\";\n\t}\n\n\t// Getters and setters\n\tpublic String getType() { return type; }\n\tpublic void setType(String type) { this.type \u003d type; }\n\tpublic Integer getEmoteId() { return emoteId; }\n\tpublic void setEmoteId(Integer emoteId) { this.emoteId \u003d emoteId; }\n\tpublic List\u003cInteger\u003e getEmoteIds() { return emoteIds; }\n\tpublic void setEmoteIds(List\u003cInteger\u003e emoteIds) { this.emoteIds \u003d emoteIds; }\n\tpublic Integer getNpcId() { return npcId; }\n\tpublic void setNpcId(Integer npcId) { this.npcId \u003d npcId; }\n\tpublic List\u003cInteger\u003e getNpcIds() { return npcIds; }\n\tpublic void setNpcIds(List\u003cInteger\u003e npcIds) { this.npcIds \u003d npcIds; }\n\tpublic String getInteractionType() { return interactionType; }\n\tpublic void setInteractionType(String interactionType) { this.interactionType \u003d interactionType; }\n\tpublic List\u003cString\u003e getInteractionTypes() { return interactionTypes; }\n\tpublic void setInteractionTypes(List\u003cString\u003e interactionTypes) { this.interactionTypes \u003d interactionTypes; }\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\ActionConstraint.java"},{"fileName":"Constraint.java","content":"package com.lennyscustomclues.constraints;\n\npublic interface Constraint\n{\n\tString description();\n\tString getConstraintType();\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\Constraint.java"},{"fileName":"EquipmentConstraint.java","content":"package com.lennyscustomclues.constraints;\n\nimport java.util.List;\n\npublic class EquipmentConstraint implements Constraint\n{\n\tprivate String type; // \"contains\", \"exact_slot\", \"any_of\"\n\tprivate Integer itemId;\n\tprivate List\u003cInteger\u003e itemIds; // For \"any_of\" type\n\tprivate Integer slot;\n\tprivate Integer minQuantity;\n\n\tpublic EquipmentConstraint()\n\t{\n\t\t// Default constructor for JSON deserialization\n\t}\n\n\tpublic EquipmentConstraint(String type)\n\t{\n\t\tthis.type \u003d type;\n\t}\n\n\n\t@Override\n\tpublic String description()\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"contains\":\n\t\t\t\treturn \"Must have specified item equipped\";\n\t\t\tcase \"exact_slot\":\n\t\t\t\treturn \"Specific equipment slot must contain specified item\";\n\t\t\tcase \"any_of\":\n\t\t\t\treturn \"Must have at least one of specified items equipped\";\n\t\t\tdefault:\n\t\t\t\treturn \"Equipment constraint\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getConstraintType()\n\t{\n\t\treturn \"equipment\";\n\t}\n\n\t// Getters and setters\n\tpublic String getType() { return type; }\n\tpublic void setType(String type) { this.type \u003d type; }\n\tpublic Integer getItemId() { return itemId; }\n\tpublic void setItemId(Integer itemId) { this.itemId \u003d itemId; }\n\tpublic List\u003cInteger\u003e getItemIds() { return itemIds; }\n\tpublic void setItemIds(List\u003cInteger\u003e itemIds) { this.itemIds \u003d itemIds; }\n\tpublic Integer getSlot() { return slot; }\n\tpublic void setSlot(Integer slot) { this.slot \u003d slot; }\n\tpublic Integer getMinQuantity() { return minQuantity; }\n\tpublic void setMinQuantity(Integer minQuantity) { this.minQuantity \u003d minQuantity; }\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\EquipmentConstraint.java"},{"fileName":"EventKeyConstraint.java","content":"package com.lennyscustomclues.constraints;\n\nimport java.util.List;\n\npublic class EventKeyConstraint implements Constraint\n{\n\tprivate String type; // \"exact\", \"prefix\", \"suffix\", \"any_of\"\n\tprivate String exactKey;\n\tprivate String prefix;\n\tprivate String suffix;\n\tprivate List\u003cString\u003e allowedKeys;\n\n\tpublic EventKeyConstraint()\n\t{\n\t\t// Default constructor for JSON deserialization\n\t}\n\n\tpublic EventKeyConstraint(String type)\n\t{\n\t\tthis.type \u003d type;\n\t}\n\n\n\t@Override\n\tpublic String description()\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"exact\":\n\t\t\t\treturn \"Must have exact event key\";\n\t\t\tcase \"any_of\":\n\t\t\t\treturn \"Must have one of allowed event keys\";\n\t\t\tdefault:\n\t\t\t\treturn \"Event key constraint\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getConstraintType()\n\t{\n\t\treturn \"event_key\";\n\t}\n\n\t// Getters and setters\n\tpublic String getType() { return type; }\n\tpublic void setType(String type) { this.type \u003d type; }\n\tpublic String getExactKey() { return exactKey; }\n\tpublic void setExactKey(String exactKey) { this.exactKey \u003d exactKey; }\n\tpublic String getPrefix() { return prefix; }\n\tpublic void setPrefix(String prefix) { this.prefix \u003d prefix; }\n\tpublic String getSuffix() { return suffix; }\n\tpublic void setSuffix(String suffix) { this.suffix \u003d suffix; }\n\tpublic List\u003cString\u003e getAllowedKeys() { return allowedKeys; }\n\tpublic void setAllowedKeys(List\u003cString\u003e allowedKeys) { this.allowedKeys \u003d allowedKeys; }\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\EventKeyConstraint.java"},{"fileName":"InventoryConstraint.java","content":"package com.lennyscustomclues.constraints;\n\nimport java.util.List;\n\npublic class InventoryConstraint implements Constraint\n{\n\tprivate String type; // \"contains\", \"exact\", \"minimum_quantity\", \"any_of\"\n\tprivate Integer itemId;\n\tprivate List\u003cInteger\u003e itemIds; // For \"any_of\" type\n\tprivate Integer minQuantity;\n\tprivate Integer exactSlot;\n\tprivate Integer requiredSlot;\n\n\tpublic InventoryConstraint()\n\t{\n\t\t// Default constructor for JSON deserialization\n\t}\n\n\tpublic InventoryConstraint(String type)\n\t{\n\t\tthis.type \u003d type;\n\t}\n\n\n\t@Override\n\tpublic String description()\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"contains\":\n\t\t\t\treturn \"Inventory must contain specified item\";\n\t\t\tcase \"any_of\":\n\t\t\t\treturn \"Inventory must contain at least one of specified items\";\n\t\t\tcase \"exact\":\n\t\t\t\treturn \"Specific inventory slot must contain specified item\";\n\t\t\tdefault:\n\t\t\t\treturn \"Inventory constraint\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getConstraintType()\n\t{\n\t\treturn \"inventory\";\n\t}\n\n\t// Getters and setters\n\tpublic String getType() { return type; }\n\tpublic void setType(String type) { this.type \u003d type; }\n\tpublic Integer getItemId() { return itemId; }\n\tpublic void setItemId(Integer itemId) { this.itemId \u003d itemId; }\n\tpublic List\u003cInteger\u003e getItemIds() { return itemIds; }\n\tpublic void setItemIds(List\u003cInteger\u003e itemIds) { this.itemIds \u003d itemIds; }\n\tpublic Integer getMinQuantity() { return minQuantity; }\n\tpublic void setMinQuantity(Integer minQuantity) { this.minQuantity \u003d minQuantity; }\n\tpublic Integer getExactSlot() { return exactSlot; }\n\tpublic void setExactSlot(Integer exactSlot) { this.exactSlot \u003d exactSlot; }\n\tpublic Integer getRequiredSlot() { return requiredSlot; }\n\tpublic void setRequiredSlot(Integer requiredSlot) { this.requiredSlot \u003d requiredSlot; }\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\InventoryConstraint.java"},{"fileName":"LocationConstraint.java","content":"package com.lennyscustomclues.constraints;\n\npublic class LocationConstraint implements Constraint\n{\n\tprivate String type; // \"exact\", \"bounds\", \"tolerance\"\n\tprivate Integer minX;\n\tprivate Integer maxX;\n\tprivate Integer minY;\n\tprivate Integer maxY;\n\tprivate Integer exactX;\n\tprivate Integer exactY;\n\tprivate Integer plane;\n\tprivate Integer tolerance; // For tolerance type\n\n\tpublic LocationConstraint()\n\t{\n\t\t// Default constructor for JSON deserialization\n\t}\n\n\tpublic LocationConstraint(String type)\n\t{\n\t\tthis.type \u003d type;\n\t}\n\n\n\t@Override\n\tpublic String description()\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"exact\":\n\t\t\t\treturn \"Must be at exact coordinates\";\n\t\t\tcase \"bounds\":\n\t\t\t\treturn \"Must be within specified area bounds\";\n\t\t\tcase \"tolerance\":\n\t\t\t\treturn \"Must be within tolerance of target location\";\n\t\t\tdefault:\n\t\t\t\treturn \"Location constraint\";\n\t\t}\n\t}\n\n\t@Override\n\tpublic String getConstraintType()\n\t{\n\t\treturn \"location\";\n\t}\n\n\t// Getters and setters\n\tpublic String getType() { return type; }\n\tpublic void setType(String type) { this.type \u003d type; }\n\tpublic Integer getMinX() { return minX; }\n\tpublic void setMinX(Integer minX) { this.minX \u003d minX; }\n\tpublic Integer getMaxX() { return maxX; }\n\tpublic void setMaxX(Integer maxX) { this.maxX \u003d maxX; }\n\tpublic Integer getMinY() { return minY; }\n\tpublic void setMinY(Integer minY) { this.minY \u003d minY; }\n\tpublic Integer getMaxY() { return maxY; }\n\tpublic void setMaxY(Integer maxY) { this.maxY \u003d maxY; }\n\tpublic Integer getExactX() { return exactX; }\n\tpublic void setExactX(Integer exactX) { this.exactX \u003d exactX; }\n\tpublic Integer getExactY() { return exactY; }\n\tpublic void setExactY(Integer exactY) { this.exactY \u003d exactY; }\n\tpublic Integer getPlane() { return plane; }\n\tpublic void setPlane(Integer plane) { this.plane \u003d plane; }\n\tpublic Integer getTolerance() { return tolerance; }\n\tpublic void setTolerance(Integer tolerance) { this.tolerance \u003d tolerance; }\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\constraints\\LocationConstraint.java"},{"fileName":"AnswerBuilderDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.constraints.*;\nimport com.lennyscustomclues.AnswerBuilder;\nimport com.lennyscustomclues.ApiClient;\nimport com.lennyscustomclues.EmoteData;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.FontManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\npublic class AnswerBuilderDialog extends JDialog\n{\n\tprivate AnswerBuilder answerBuilder;\n\tprivate Client client;\n\tprivate ApiClient apiClient;\n\n\t// Fields for update mode\n\tprivate boolean isUpdateMode;\n\tprivate String eventKey;\n\tprivate String secretKey;\n\n\tprivate JTextArea rewardTextArea;\n\tprivate JLabel statusLabel;\n\n\t// Required Action section\n\tprivate JComboBox\u003cString\u003e requiredActionCombo;\n\n\t// Location Constraint section\n\tprivate JComboBox\u003cString\u003e locationTypeCombo;\n\tprivate JPanel locationFieldsPanel;\n\tprivate Map\u003cString, JTextField\u003e locationFields;\n\tprivate Map\u003cString, JLabel\u003e locationLabels;\n\tprivate JButton useCurrentLocationButton;\n\tprivate JLabel coordinatesLabel;\n\tprivate Timer coordinateUpdateTimer;\n\n\t// Emote Constraint section\n\tprivate JPanel emoteSelectionPanel;\n\tprivate JLabel emoteDisplayLabel;\n\tprivate JButton selectEmoteButton;\n\tprivate ActionConstraint emoteConstraint;\n\n\t// Buttons\n\tprivate JButton clearAnswerButton;\n\tprivate JButton submitAnswerButton;\n\tprivate JButton cancelButton;\n\n\t// Constructor for creating a new answer\n\tpublic AnswerBuilderDialog(JFrame parent, Client client, ApiClient apiClient)\n\t{\n\t\tthis(parent, client, apiClient, null, null, null, null);\n\t}\n\n\t// Constructor for updating an existing answer\n\tpublic AnswerBuilderDialog(JFrame parent, Client client, ApiClient apiClient,\n\t\tString eventKey, String secretKey, String rewardText, java.util.List\u003cjava.util.Map\u003cString, Object\u003e\u003e constraints)\n\t{\n\t\tsuper(parent, eventKey !\u003d null ? \"Update Answer\" : \"Create Answer\", false); // false \u003d non-modal\n\t\tthis.client \u003d client;\n\t\tthis.apiClient \u003d apiClient;\n\t\tthis.answerBuilder \u003d new AnswerBuilder();\n\t\tthis.locationFields \u003d new HashMap\u003c\u003e();\n\t\tthis.locationLabels \u003d new HashMap\u003c\u003e();\n\t\tthis.isUpdateMode \u003d eventKey !\u003d null;\n\t\tthis.eventKey \u003d eventKey;\n\t\tthis.secretKey \u003d secretKey;\n\n\t\tinitializeUI();\n\n\t\t// Pre-populate fields if in update mode\n\t\tif (isUpdateMode \u0026\u0026 rewardText !\u003d null)\n\t\t{\n\t\t\tprepopulateFields(rewardText, constraints);\n\t\t}\n\n\t\tstartCoordinateUpdates();\n\t\tpack();\n\t\tsetMinimumSize(new Dimension(500, 600));\n\t\tsetLocationRelativeTo(parent);\n\t\tsetAlwaysOnTop(true); // Keep dialog visible above game client\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Title\n\t\tJLabel titleLabel \u003d new JLabel(\"Answer Builder\");\n\t\ttitleLabel.setForeground(Color.WHITE);\n\t\ttitleLabel.setFont(FontManager.getRunescapeFont());\n\t\ttitleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\ttitleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// Main content panel - single column layout\n\t\tJPanel mainPanel \u003d new JPanel();\n\t\tmainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n\t\tmainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tmainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// 1. Reward text area\n\t\tJPanel rewardPanel \u003d new JPanel(new BorderLayout());\n\t\trewardPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\trewardPanel.setBorder(BorderFactory.createTitledBorder(\"Reward Text (Required)\"));\n\t\trewardPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 100));\n\n\t\trewardTextArea \u003d new JTextArea(3, 0);\n\t\trewardTextArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\trewardTextArea.setForeground(Color.WHITE);\n\t\trewardTextArea.setLineWrap(true);\n\t\trewardTextArea.setWrapStyleWord(true);\n\t\trewardTextArea.setToolTipText(\"This reward text will be shown to players that solve your puzzle!\");\n\t\trewardTextArea.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {\n\t\t\tpublic void insertUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }\n\t\t\tpublic void removeUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }\n\t\t\tpublic void changedUpdate(javax.swing.event.DocumentEvent e) { updateSubmitButtonState(); }\n\t\t});\n\t\tJScrollPane rewardScrollPane \u003d new JScrollPane(rewardTextArea);\n\t\trewardPanel.add(rewardScrollPane, BorderLayout.CENTER);\n\n\t\t// 2. Required Action section\n\t\tJPanel requiredActionPanel \u003d new JPanel();\n\t\trequiredActionPanel.setLayout(new BoxLayout(requiredActionPanel, BoxLayout.Y_AXIS));\n\t\trequiredActionPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\trequiredActionPanel.setBorder(BorderFactory.createTitledBorder(\"Required Action\"));\n\n\t\tJPanel actionTypePanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\n\t\tactionTypePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tJLabel actionLabel \u003d new JLabel(\"Action Type:\");\n\t\tactionLabel.setForeground(Color.WHITE);\n\t\tactionTypePanel.add(actionLabel);\n\n\t\trequiredActionCombo \u003d new JComboBox\u003c\u003e(new String[]{\"Dig with a spade\", \"Perform an Emote\"});\n\t\trequiredActionCombo.addActionListener(this::onActionTypeChanged);\n\t\tactionTypePanel.add(requiredActionCombo);\n\n\t\trequiredActionPanel.add(actionTypePanel);\n\n\t\t// Emote selection panel (initially hidden)\n\t\temoteSelectionPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\n\t\temoteSelectionPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\temoteSelectionPanel.setVisible(false);\n\n\t\temoteDisplayLabel \u003d new JLabel(\"No emote selected\");\n\t\temoteDisplayLabel.setForeground(Color.LIGHT_GRAY);\n\t\temoteSelectionPanel.add(emoteDisplayLabel);\n\n\t\tselectEmoteButton \u003d new JButton(\"Select Emote\");\n\t\tselectEmoteButton.addActionListener(this::onSelectEmote);\n\t\temoteSelectionPanel.add(selectEmoteButton);\n\n\t\tJButton clearEmoteButton \u003d new JButton(\"Clear\");\n\t\tclearEmoteButton.addActionListener(this::onClearEmote);\n\t\temoteSelectionPanel.add(clearEmoteButton);\n\n\t\trequiredActionPanel.add(emoteSelectionPanel);\n\n\t\t// 3. Location Constraint section\n\t\tJPanel locationConstraintPanel \u003d new JPanel();\n\t\tlocationConstraintPanel.setLayout(new BoxLayout(locationConstraintPanel, BoxLayout.Y_AXIS));\n\t\tlocationConstraintPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tlocationConstraintPanel.setBorder(BorderFactory.createTitledBorder(\"Location Constraint\"));\n\n\t\t// Location type dropdown and coordinates display\n\t\tJPanel locationTopPanel \u003d new JPanel(new BorderLayout());\n\t\tlocationTopPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tJPanel locationTypePanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\n\t\tlocationTypePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tJLabel locationTypeLabel \u003d new JLabel(\"Type:\");\n\t\tlocationTypeLabel.setForeground(Color.WHITE);\n\t\tlocationTypePanel.add(locationTypeLabel);\n\n\t\tlocationTypeCombo \u003d new JComboBox\u003c\u003e(new String[]{\"Exact Tile\", \"Near a Tile\", \"Within a Rectangle\", \"None\"});\n\t\tlocationTypeCombo.addActionListener(this::onLocationTypeChanged);\n\t\tlocationTypePanel.add(locationTypeCombo);\n\n\t\t// Coordinates display\n\t\tJPanel coordinatesPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\n\t\tcoordinatesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tcoordinatesLabel \u003d new JLabel(\"Current Location: Loading...\");\n\t\tcoordinatesLabel.setForeground(Color.CYAN);\n\t\tcoordinatesLabel.setFont(coordinatesLabel.getFont().deriveFont(Font.BOLD));\n\t\tcoordinatesPanel.add(coordinatesLabel);\n\n\t\tlocationTopPanel.add(locationTypePanel, BorderLayout.NORTH);\n\t\tlocationTopPanel.add(coordinatesPanel, BorderLayout.SOUTH);\n\n\t\t// Dynamic location fields panel\n\t\tlocationFieldsPanel \u003d new JPanel(new GridBagLayout());\n\t\tlocationFieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tcreateLocationFields();\n\n\t\tlocationConstraintPanel.add(locationTopPanel);\n\t\tlocationConstraintPanel.add(locationFieldsPanel);\n\n\t\t// 4. Required Worn Items section\n\t\tJPanel wornItemsPanel \u003d new JPanel(new FlowLayout(FlowLayout.LEFT));\n\t\twornItemsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\twornItemsPanel.setBorder(BorderFactory.createTitledBorder(\"Required Worn Items\"));\n\t\twornItemsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 60));\n\n\t\tJLabel wornItemsLabel \u003d new JLabel(\"Will be implemented soon!\");\n\t\twornItemsLabel.setForeground(Color.LIGHT_GRAY);\n\t\twornItemsPanel.add(wornItemsLabel);\n\n\t\t// 5. Clear button panel (centered)\n\t\tJPanel clearButtonPanel \u003d new JPanel(new FlowLayout(FlowLayout.CENTER));\n\t\tclearButtonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tclearButtonPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 40));\n\n\t\t// 6. Submit button panel\n\t\tJPanel submitPanel \u003d new JPanel(new FlowLayout());\n\t\tsubmitPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tsubmitPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));\n\n\t\tcreateButtons();\n\n\t\tclearButtonPanel.add(clearAnswerButton);\n\n\t\tsubmitPanel.add(submitAnswerButton);\n\t\tsubmitPanel.add(cancelButton);\n\n\t\t// Status label\n\t\tstatusLabel \u003d new JLabel(\"Ready to build answer\");\n\t\tstatusLabel.setForeground(Color.WHITE);\n\t\tstatusLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n\t\t// Add all sections to main panel\n\t\tmainPanel.add(rewardPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(requiredActionPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(locationConstraintPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(wornItemsPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(clearButtonPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(submitPanel);\n\n\t\tadd(titleLabel, BorderLayout.NORTH);\n\t\tadd(mainPanel, BorderLayout.CENTER);\n\t\tadd(statusLabel, BorderLayout.SOUTH);\n\n\t\tupdateLocationFieldsVisibility();\n\t}\n\n\tprivate void createButtons()\n\t{\n\t\tclearAnswerButton \u003d new JButton(\"Clear All\");\n\t\tclearAnswerButton.addActionListener(this::onClearAnswer);\n\n\t\tsubmitAnswerButton \u003d new JButton(isUpdateMode ? \"Update on Server\" : \"Submit to Server\");\n\t\tsubmitAnswerButton.addActionListener(this::onSubmitAnswer);\n\t\tsubmitAnswerButton.setEnabled(false); // Initially disabled\n\n\t\tcancelButton \u003d new JButton(\"Cancel and discard changes\");\n\t\tcancelButton.addActionListener(this::onCancel);\n\t}\n\n\tprivate void onCancel(ActionEvent e)\n\t{\n\t\tint result \u003d JOptionPane.showConfirmDialog(\n\t\t\tthis,\n\t\t\t\"Are you sure you want to cancel and discard all changes?\",\n\t\t\t\"Confirm Cancel\",\n\t\t\tJOptionPane.YES_NO_OPTION,\n\t\t\tJOptionPane.WARNING_MESSAGE\n\t\t);\n\n\t\tif (result \u003d\u003d JOptionPane.YES_OPTION)\n\t\t{\n\t\t\tdispose();\n\t\t}\n\t}\n\n\tprivate void createLocationFields()\n\t{\n\t\t// Create all possible fields\n\t\tlocationFields.put(\"exactX\", createNumberField());\n\t\tlocationFields.put(\"exactY\", createNumberField());\n\t\tlocationFields.put(\"point1X\", createNumberField());\n\t\tlocationFields.put(\"point1Y\", createNumberField());\n\t\tlocationFields.put(\"point2X\", createNumberField());\n\t\tlocationFields.put(\"point2Y\", createNumberField());\n\t\tlocationFields.put(\"plane\", createNumberField());\n\t\tlocationFields.put(\"tolerance\", createNumberField());\n\n\t\t// Create corresponding labels\n\t\tlocationLabels.put(\"exactX\", createLabel(\"Exact X:\"));\n\t\tlocationLabels.put(\"exactY\", createLabel(\"Exact Y:\"));\n\t\tlocationLabels.put(\"point1X\", createLabel(\"Point 1 X:\"));\n\t\tlocationLabels.put(\"point1Y\", createLabel(\"Point 1 Y:\"));\n\t\tlocationLabels.put(\"point2X\", createLabel(\"Point 2 X:\"));\n\t\tlocationLabels.put(\"point2Y\", createLabel(\"Point 2 Y:\"));\n\t\tlocationLabels.put(\"plane\", createLabel(\"Plane (optional):\"));\n\t\tlocationLabels.put(\"tolerance\", createLabel(\"Tolerance:\"));\n\t}\n\n\tprivate JTextField createNumberField()\n\t{\n\t\tJTextField field \u003d new JTextField(20);\n\t\tfield.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfield.setForeground(Color.WHITE);\n\t\treturn field;\n\t}\n\n\tprivate JLabel createLabel(String text)\n\t{\n\t\tJLabel label \u003d new JLabel(text);\n\t\tlabel.setForeground(Color.WHITE);\n\t\treturn label;\n\t}\n\n\tprivate void onActionTypeChanged(ActionEvent e)\n\t{\n\t\tString selectedAction \u003d (String) requiredActionCombo.getSelectedItem();\n\t\tboolean isEmoteAction \u003d \"Perform an Emote\".equals(selectedAction);\n\n\t\temoteSelectionPanel.setVisible(isEmoteAction);\n\t\tpack(); // Resize dialog to fit new content\n\t}\n\n\tprivate void onLocationTypeChanged(ActionEvent e)\n\t{\n\t\tupdateLocationFieldsVisibility();\n\t\tpack(); // Resize dialog to fit new content\n\t}\n\n\tprivate void updateLocationFieldsVisibility()\n\t{\n\t\tString selectedType \u003d (String) locationTypeCombo.getSelectedItem();\n\n\t\t// Clear the panel\n\t\tlocationFieldsPanel.removeAll();\n\n\t\tGridBagConstraints gbc \u003d new GridBagConstraints();\n\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\tgbc.anchor \u003d GridBagConstraints.WEST;\n\n\t\tint row \u003d 0;\n\n\t\t// Map UI labels to internal constraint types\n\t\tString constraintType;\n\t\tswitch (selectedType)\n\t\t{\n\t\t\tcase \"Exact Tile\":\n\t\t\t\tconstraintType \u003d \"exact\";\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactX\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactY\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"Within a Rectangle\":\n\t\t\t\tconstraintType \u003d \"bounds\";\n\t\t\t\taddFieldToPanel(gbc, row++, \"point1X\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"point1Y\");\n\n\t\t\t\t// Add \"Use Current Location\" button for Point 1\n\t\t\t\tJButton usePoint1Button \u003d new JButton(\"Use Current Location for Point 1\");\n\t\t\t\tusePoint1Button.addActionListener(e -\u003e onUseCurrentLocationForPoint(1));\n\t\t\t\tgbc.gridx \u003d 0;\n\t\t\t\tgbc.gridy \u003d row++;\n\t\t\t\tgbc.gridwidth \u003d 2;\n\t\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 10, 5);\n\t\t\t\tlocationFieldsPanel.add(usePoint1Button, gbc);\n\t\t\t\tgbc.gridwidth \u003d 1;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\n\t\t\t\taddFieldToPanel(gbc, row++, \"point2X\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"point2Y\");\n\n\t\t\t\t// Add \"Use Current Location\" button for Point 2\n\t\t\t\tJButton usePoint2Button \u003d new JButton(\"Use Current Location for Point 2\");\n\t\t\t\tusePoint2Button.addActionListener(e -\u003e onUseCurrentLocationForPoint(2));\n\t\t\t\tgbc.gridx \u003d 0;\n\t\t\t\tgbc.gridy \u003d row++;\n\t\t\t\tgbc.gridwidth \u003d 2;\n\t\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 10, 5);\n\t\t\t\tlocationFieldsPanel.add(usePoint2Button, gbc);\n\t\t\t\tgbc.gridwidth \u003d 1;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\t\t\tbreak;\n\n\t\t\tcase \"None\":\n\t\t\t\t// No location constraint fields needed\n\t\t\t\tconstraintType \u003d null;\n\t\t\t\tbreak;\n\n\t\t\tcase \"Near a Tile\":\n\t\t\tdefault:\n\t\t\t\tconstraintType \u003d \"tolerance\";\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactX\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactY\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"tolerance\");\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Always add plane field (optional for all types except None)\n\t\tif (!\"None\".equals(selectedType))\n\t\t{\n\t\t\taddFieldToPanel(gbc, row++, \"plane\");\n\t\t}\n\n\t\t// Add \"Use Current Location\" button for exact and tolerance types\n\t\tif (\"Exact Tile\".equals(selectedType) || \"Near a Tile\".equals(selectedType))\n\t\t{\n\t\t\tuseCurrentLocationButton \u003d new JButton(\"Use Current Location\");\n\t\t\tuseCurrentLocationButton.addActionListener(this::onUseCurrentLocation);\n\n\t\t\tgbc.gridx \u003d 0;\n\t\t\tgbc.gridy \u003d row;\n\t\t\tgbc.gridwidth \u003d 2;\n\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\tgbc.insets \u003d new Insets(10, 5, 5, 5);\n\t\t\tlocationFieldsPanel.add(useCurrentLocationButton, gbc);\n\t\t\tgbc.gridwidth \u003d 1;\n\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\t}\n\n\t\t// Refresh the panel\n\t\tlocationFieldsPanel.revalidate();\n\t\tlocationFieldsPanel.repaint();\n\t}\n\n\tprivate void addFieldToPanel(GridBagConstraints gbc, int row, String fieldName)\n\t{\n\t\tJLabel label \u003d locationLabels.get(fieldName);\n\t\tJTextField field \u003d locationFields.get(fieldName);\n\n\t\tif (label !\u003d null \u0026\u0026 field !\u003d null)\n\t\t{\n\t\t\t// Add label\n\t\t\tgbc.gridx \u003d 0;\n\t\t\tgbc.gridy \u003d row;\n\t\t\tgbc.fill \u003d GridBagConstraints.NONE;\n\t\t\tlocationFieldsPanel.add(label, gbc);\n\n\t\t\t// Add field\n\t\t\tgbc.gridx \u003d 1;\n\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\tgbc.weightx \u003d 1.0;\n\t\t\tlocationFieldsPanel.add(field, gbc);\n\t\t\tgbc.weightx \u003d 0.0;\n\t\t}\n\t}\n\n\tprivate void onUseCurrentLocation(ActionEvent e)\n\t{\n\t\tWorldPoint currentLocation \u003d getCurrentPlayerLocation();\n\t\tif (currentLocation !\u003d null)\n\t\t{\n\t\t\tJTextField exactXField \u003d locationFields.get(\"exactX\");\n\t\t\tJTextField exactYField \u003d locationFields.get(\"exactY\");\n\t\t\tJTextField planeField \u003d locationFields.get(\"plane\");\n\n\t\t\tif (exactXField !\u003d null) exactXField.setText(String.valueOf(currentLocation.getX()));\n\t\t\tif (exactYField !\u003d null) exactYField.setText(String.valueOf(currentLocation.getY()));\n\t\t\tif (planeField !\u003d null) planeField.setText(String.valueOf(currentLocation.getPlane()));\n\t\t}\n\t}\n\n\tprivate void onUseCurrentLocationForPoint(int pointNumber)\n\t{\n\t\tWorldPoint currentLocation \u003d getCurrentPlayerLocation();\n\t\tif (currentLocation !\u003d null)\n\t\t{\n\t\t\tString xFieldName \u003d \"point\" + pointNumber + \"X\";\n\t\t\tString yFieldName \u003d \"point\" + pointNumber + \"Y\";\n\n\t\t\tJTextField xField \u003d locationFields.get(xFieldName);\n\t\t\tJTextField yField \u003d locationFields.get(yFieldName);\n\t\t\tJTextField planeField \u003d locationFields.get(\"plane\");\n\n\t\t\tif (xField !\u003d null) xField.setText(String.valueOf(currentLocation.getX()));\n\t\t\tif (yField !\u003d null) yField.setText(String.valueOf(currentLocation.getY()));\n\t\t\tif (planeField !\u003d null) planeField.setText(String.valueOf(currentLocation.getPlane()));\n\t\t}\n\t}\n\n\tprivate void onSelectEmote(ActionEvent e)\n\t{\n\t\tWindow parentWindow \u003d SwingUtilities.getWindowAncestor(this);\n\t\tJFrame parentFrame \u003d (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;\n\n\t\tEmoteConstraintDialog dialog \u003d new EmoteConstraintDialog(\n\t\t\tparentFrame,\n\t\t\temoteConstraint,\n\t\t\tconstraint -\u003e {\n\t\t\t\temoteConstraint \u003d constraint;\n\t\t\t\tupdateEmoteDisplay();\n\t\t\t}\n\t\t);\n\n\t\tdialog.setVisible(true);\n\t}\n\n\tprivate void onClearEmote(ActionEvent e)\n\t{\n\t\temoteConstraint \u003d null;\n\t\tupdateEmoteDisplay();\n\t}\n\n\tprivate void updateEmoteDisplay()\n\t{\n\t\tif (emoteConstraint !\u003d null \u0026\u0026 emoteConstraint.getEmoteId() !\u003d null)\n\t\t{\n\t\t\tString emoteName \u003d EmoteData.getEmoteName(emoteConstraint.getEmoteId());\n\t\t\temoteDisplayLabel.setText(\"Selected: \" + emoteName);\n\t\t\temoteDisplayLabel.setForeground(Color.WHITE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\temoteDisplayLabel.setText(\"No emote selected\");\n\t\t\temoteDisplayLabel.setForeground(Color.LIGHT_GRAY);\n\t\t}\n\t}\n\n\tprivate void onSubmitAnswer(ActionEvent e)\n\t{\n\t\ttry\n\t\t{\n\t\t\t// Clear any existing data first\n\t\t\tanswerBuilder.clear();\n\n\t\t\t// Update the answer builder with current reward text\n\t\t\tanswerBuilder.setRewardText(rewardTextArea.getText().trim());\n\n\t\t\t// Build and add the location constraint (if not \"None\")\n\t\t\tLocationConstraint locationConstraint \u003d buildLocationConstraint();\n\t\t\tif (locationConstraint !\u003d null)\n\t\t\t{\n\t\t\t\tanswerBuilder.addConstraint(locationConstraint);\n\t\t\t}\n\n\t\t\t// Add the emote constraint if \"Perform an Emote\" is selected\n\t\t\tString selectedAction \u003d (String) requiredActionCombo.getSelectedItem();\n\t\t\tif (\"Perform an Emote\".equals(selectedAction))\n\t\t\t{\n\t\t\t\tif (emoteConstraint \u003d\u003d null || emoteConstraint.getEmoteId() \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\tJOptionPane.showMessageDialog(this, \"Please select an emote\", \"Emote Required\", JOptionPane.WARNING_MESSAGE);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tanswerBuilder.addConstraint(emoteConstraint);\n\t\t\t}\n\n\t\t\tif (isUpdateMode)\n\t\t\t{\n\t\t\t\t// Update mode - directly submit the update\n\t\t\t\tstatusLabel.setText(\"Updating answer on server...\");\n\t\t\t\tstatusLabel.setForeground(java.awt.Color.YELLOW);\n\n\t\t\t\tapiClient.updateAnswer(eventKey, secretKey, answerBuilder).thenAccept(response -\u003e {\n\t\t\t\t\tjavax.swing.SwingUtilities.invokeLater(() -\u003e {\n\t\t\t\t\t\tif (response.success)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Show success popup\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(\n\t\t\t\t\t\t\t\tAnswerBuilderDialog.this,\n\t\t\t\t\t\t\t\t\"Answer updated successfully\",\n\t\t\t\t\t\t\t\t\"Success\",\n\t\t\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Close the dialog\n\t\t\t\t\t\t\tAnswerBuilderDialog.this.dispose();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Handle different error types with appropriate messages\n\t\t\t\t\t\t\tString errorMessage \u003d \" Failed to update answer: \" + response.message;\n\t\t\t\t\t\t\tif (\"NOT_FOUND\".equals(response.errorType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessage \u003d \" Event key not found\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (\"UNAUTHORIZED\".equals(response.errorType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessage \u003d \" Invalid secret key\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (\"NETWORK_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessage \u003d \" Network error: \" + response.message;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (\"VALIDATION_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessage \u003d \" Validation error: \" + response.message;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (\"SERVER_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terrorMessage \u003d \" Server error: \" + response.message;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tstatusLabel.setText(errorMessage);\n\t\t\t\t\t\t\tstatusLabel.setForeground(java.awt.Color.RED);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create mode - show dialog to get event key and secret key\n\t\t\t\t// Find the parent frame\n\t\t\t\tWindow parentWindow \u003d SwingUtilities.getWindowAncestor(this);\n\t\t\t\tJFrame parentFrame \u003d (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;\n\n\t\t\t\tSubmitAnswerDialog dialog \u003d new SubmitAnswerDialog(\n\t\t\t\t\tparentFrame,\n\t\t\t\t\tanswerBuilder,\n\t\t\t\t\tapiClient,\n\t\t\t\t\t(eventKey, secretKey) -\u003e {\n\t\t\t\t\t\t// Handle the submission\n\t\t\t\t\t\tstatusLabel.setText(\"Submitting answer to server...\");\n\t\t\t\t\t\tstatusLabel.setForeground(java.awt.Color.YELLOW);\n\n\t\t\t\t\t\t// Actually submit the answer to the server\n\t\t\t\t\t\tapiClient.createAnswer(eventKey, secretKey, answerBuilder).thenAccept(response -\u003e {\n\t\t\t\t\t\t\tjavax.swing.SwingUtilities.invokeLater(() -\u003e {\n\t\t\t\t\t\t\t\tif (response.success)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Show success popup\n\t\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(\n\t\t\t\t\t\t\t\t\t\tAnswerBuilderDialog.this,\n\t\t\t\t\t\t\t\t\t\t\"Answer submitted successfully\",\n\t\t\t\t\t\t\t\t\t\t\"Success\",\n\t\t\t\t\t\t\t\t\t\tJOptionPane.INFORMATION_MESSAGE\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// Close both dialogs\n\t\t\t\t\t\t\t\t\tAnswerBuilderDialog.this.dispose();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Handle different error types with appropriate messages\n\t\t\t\t\t\t\t\t\tString errorMessage \u003d \" Failed to submit answer: \" + response.message;\n\t\t\t\t\t\t\t\t\tif (\"KEY_ALREADY_EXISTS\".equals(response.errorType))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\terrorMessage \u003d \" Event key \u0027\" + eventKey + \"\u0027 already exists\";\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (\"NETWORK_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\terrorMessage \u003d \" Network error: \" + response.message;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (\"VALIDATION_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\terrorMessage \u003d \" Validation error: \" + response.message;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (\"SERVER_ERROR\".equals(response.errorType))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\terrorMessage \u003d \" Server error: \" + response.message;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tstatusLabel.setText(errorMessage);\n\t\t\t\t\t\t\t\t\tstatusLabel.setForeground(java.awt.Color.RED);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tdialog.setVisible(true);\n\t\t\t}\n\t\t}\n\t\tcatch (NumberFormatException ex)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Please enter valid numbers for location fields\", \"Input Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t\tcatch (IllegalArgumentException ex)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, ex.getMessage(), \"Validation Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n\n\tprivate LocationConstraint buildLocationConstraint()\n\t{\n\t\tString selectedType \u003d (String) locationTypeCombo.getSelectedItem();\n\t\tString constraintType;\n\n\t\tswitch (selectedType)\n\t\t{\n\t\t\tcase \"Exact Tile\":\n\t\t\t\tconstraintType \u003d \"exact\";\n\t\t\t\tbreak;\n\t\t\tcase \"Within a Rectangle\":\n\t\t\t\tconstraintType \u003d \"bounds\";\n\t\t\t\tbreak;\n\t\t\tcase \"None\":\n\t\t\t\treturn null; // No location constraint\n\t\t\tcase \"Near a Tile\":\n\t\t\tdefault:\n\t\t\t\tconstraintType \u003d \"tolerance\";\n\t\t\t\tbreak;\n\t\t}\n\n\t\tLocationConstraint constraint \u003d new LocationConstraint(constraintType);\n\t\tconstraint.setExactX(parseInteger(\"exactX\"));\n\t\tconstraint.setExactY(parseInteger(\"exactY\"));\n\t\tconstraint.setPlane(parseInteger(\"plane\"));\n\t\tconstraint.setTolerance(parseInteger(\"tolerance\"));\n\n\t\t// For bounds type, calculate min/max from the two points\n\t\tif (\"bounds\".equals(constraintType))\n\t\t{\n\t\t\tInteger point1X \u003d parseInteger(\"point1X\");\n\t\t\tInteger point1Y \u003d parseInteger(\"point1Y\");\n\t\t\tInteger point2X \u003d parseInteger(\"point2X\");\n\t\t\tInteger point2Y \u003d parseInteger(\"point2Y\");\n\n\t\t\tif (point1X !\u003d null \u0026\u0026 point2X !\u003d null)\n\t\t\t{\n\t\t\t\tconstraint.setMinX(Math.min(point1X, point2X));\n\t\t\t\tconstraint.setMaxX(Math.max(point1X, point2X));\n\t\t\t}\n\n\t\t\tif (point1Y !\u003d null \u0026\u0026 point2Y !\u003d null)\n\t\t\t{\n\t\t\t\tconstraint.setMinY(Math.min(point1Y, point2Y));\n\t\t\t\tconstraint.setMaxY(Math.max(point1Y, point2Y));\n\t\t\t}\n\t\t}\n\n\t\treturn constraint;\n\t}\n\n\tprivate Integer parseInteger(String fieldName)\n\t{\n\t\tJTextField field \u003d locationFields.get(fieldName);\n\t\tif (field \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tString text \u003d field.getText();\n\t\tif (text \u003d\u003d null || text.trim().isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn Integer.parseInt(text.trim());\n\t}\n\n\tprivate void onClearAnswer(ActionEvent e)\n\t{\n\t\tint result \u003d JOptionPane.showConfirmDialog(\n\t\t\tthis,\n\t\t\t\"Are you sure you want to clear all drafted answer information?\",\n\t\t\t\"Confirm Clear\",\n\t\t\tJOptionPane.YES_NO_OPTION,\n\t\t\tJOptionPane.WARNING_MESSAGE\n\t\t);\n\n\t\tif (result \u003d\u003d JOptionPane.YES_OPTION)\n\t\t{\n\t\t\tanswerBuilder.clear();\n\t\t\trewardTextArea.setText(\"\");\n\t\t\trequiredActionCombo.setSelectedItem(\"Dig with a spade\");\n\t\t\tclearLocationFields();\n\t\t\temoteConstraint \u003d null;\n\t\t\tupdateEmoteDisplay();\n\t\t\tupdateSubmitButtonState();\n\t\t\tstatusLabel.setText(\"Answer cleared\");\n\t\t}\n\t}\n\n\tprivate void clearLocationFields()\n\t{\n\t\tfor (JTextField field : locationFields.values())\n\t\t{\n\t\t\tfield.setText(\"\");\n\t\t}\n\t}\n\n\tprivate void updateSubmitButtonState()\n\t{\n\t\tboolean hasRewardText \u003d rewardTextArea !\u003d null \u0026\u0026 !rewardTextArea.getText().trim().isEmpty();\n\n\t\tif (submitAnswerButton !\u003d null)\n\t\t{\n\t\t\tsubmitAnswerButton.setEnabled(hasRewardText);\n\t\t}\n\t}\n\n\tprivate void startCoordinateUpdates()\n\t{\n\t\t// Update coordinates every 500ms\n\t\tcoordinateUpdateTimer \u003d new Timer(500, e -\u003e updateCoordinatesDisplay());\n\t\tcoordinateUpdateTimer.start();\n\t\tupdateCoordinatesDisplay(); // Initial update\n\t}\n\n\tprivate void stopCoordinateUpdates()\n\t{\n\t\tif (coordinateUpdateTimer !\u003d null)\n\t\t{\n\t\t\tcoordinateUpdateTimer.stop();\n\t\t}\n\t}\n\n\tprivate void updateCoordinatesDisplay()\n\t{\n\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\tWorldPoint location \u003d getCurrentPlayerLocation();\n\t\t\tif (location !\u003d null)\n\t\t\t{\n\t\t\t\tcoordinatesLabel.setText(String.format(\"Current Location: X:%d Y:%d Plane:%d\",\n\t\t\t\t\tlocation.getX(), location.getY(), location.getPlane()));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcoordinatesLabel.setText(\"Current Location: Not available\");\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate WorldPoint getCurrentPlayerLocation()\n\t{\n\t\tif (client \u003d\u003d null) return null;\n\n\t\tPlayer player \u003d client.getLocalPlayer();\n\t\tif (player \u003d\u003d null) return null;\n\n\t\treturn player.getWorldLocation();\n\t}\n\n\tprivate void prepopulateFields(String rewardText, java.util.List\u003cjava.util.Map\u003cString, Object\u003e\u003e constraints)\n\t{\n\t\t// Set reward text\n\t\trewardTextArea.setText(rewardText);\n\n\t\t// Parse and set constraints if present\n\t\tif (constraints !\u003d null \u0026\u0026 !constraints.isEmpty())\n\t\t{\n\t\t\tfor (java.util.Map\u003cString, Object\u003e constraintMap : constraints)\n\t\t\t{\n\t\t\t\tString constraintType \u003d (String) constraintMap.get(\"constraint_type\");\n\n\t\t\t\tif (\"location\".equals(constraintType))\n\t\t\t\t{\n\t\t\t\t\tString type \u003d (String) constraintMap.get(\"type\");\n\n\t\t\t\t\t// Set the location type in the dropdown\n\t\t\t\t\tif (\"exact\".equals(type))\n\t\t\t\t\t{\n\t\t\t\t\t\tlocationTypeCombo.setSelectedItem(\"Exact Tile\");\n\t\t\t\t\t\tsetIntegerField(\"exactX\", constraintMap.get(\"exact_x\"));\n\t\t\t\t\t\tsetIntegerField(\"exactY\", constraintMap.get(\"exact_y\"));\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"tolerance\".equals(type))\n\t\t\t\t\t{\n\t\t\t\t\t\tlocationTypeCombo.setSelectedItem(\"Near a Tile\");\n\t\t\t\t\t\tsetIntegerField(\"exactX\", constraintMap.get(\"exact_x\"));\n\t\t\t\t\t\tsetIntegerField(\"exactY\", constraintMap.get(\"exact_y\"));\n\t\t\t\t\t\tsetIntegerField(\"tolerance\", constraintMap.get(\"tolerance\"));\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"bounds\".equals(type))\n\t\t\t\t\t{\n\t\t\t\t\t\tlocationTypeCombo.setSelectedItem(\"Within a Rectangle\");\n\t\t\t\t\t\t// Convert min/max back to point1/point2 for display\n\t\t\t\t\t\tsetIntegerField(\"point1X\", constraintMap.get(\"min_x\"));\n\t\t\t\t\t\tsetIntegerField(\"point1Y\", constraintMap.get(\"min_y\"));\n\t\t\t\t\t\tsetIntegerField(\"point2X\", constraintMap.get(\"max_x\"));\n\t\t\t\t\t\tsetIntegerField(\"point2Y\", constraintMap.get(\"max_y\"));\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set plane if present\n\t\t\t\t\tsetIntegerField(\"plane\", constraintMap.get(\"plane\"));\n\t\t\t\t}\n\t\t\t\telse if (\"action\".equals(constraintType))\n\t\t\t\t{\n\t\t\t\t\tString type \u003d (String) constraintMap.get(\"type\");\n\n\t\t\t\t\tif (\"emote\".equals(type))\n\t\t\t\t\t{\n\t\t\t\t\t\tObject emoteIdObj \u003d constraintMap.get(\"emote_id\");\n\t\t\t\t\t\tif (emoteIdObj !\u003d null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tInteger emoteId \u003d null;\n\t\t\t\t\t\t\tif (emoteIdObj instanceof Number)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\temoteId \u003d ((Number) emoteIdObj).intValue();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (emoteId !\u003d null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Set the action type to \"Perform an Emote\"\n\t\t\t\t\t\t\t\trequiredActionCombo.setSelectedItem(\"Perform an Emote\");\n\n\t\t\t\t\t\t\t\temoteConstraint \u003d new ActionConstraint(\"emote\");\n\t\t\t\t\t\t\t\temoteConstraint.setEmoteId(emoteId);\n\t\t\t\t\t\t\t\tupdateEmoteDisplay();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tupdateSubmitButtonState();\n\t}\n\n\tprivate void setIntegerField(String fieldName, Object value)\n\t{\n\t\tJTextField field \u003d locationFields.get(fieldName);\n\t\tif (field !\u003d null \u0026\u0026 value !\u003d null)\n\t\t{\n\t\t\t// Handle both Integer and Double from JSON parsing\n\t\t\tif (value instanceof Number)\n\t\t\t{\n\t\t\t\tfield.setText(String.valueOf(((Number) value).intValue()));\n\t\t\t}\n\t\t\telse if (value instanceof String)\n\t\t\t{\n\t\t\t\tfield.setText((String) value);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic void dispose()\n\t{\n\t\tstopCoordinateUpdates();\n\t\tsuper.dispose();\n\t}\n\n\tpublic AnswerBuilder getAnswerBuilder()\n\t{\n\t\treturn answerBuilder;\n\t}\n}\n","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\AnswerBuilderDialog.java"},{"fileName":"EmoteConstraintDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.EmoteData;\nimport com.lennyscustomclues.constraints.ActionConstraint;\nimport net.runelite.client.ui.ColorScheme;\n\nimport javax.swing.*;\nimport javax.swing.event.DocumentEvent;\nimport javax.swing.event.DocumentListener;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\npublic class EmoteConstraintDialog extends JDialog\n{\n\tprivate JTextField searchField;\n\tprivate JList\u003cString\u003e emoteList;\n\tprivate DefaultListModel\u003cString\u003e listModel;\n\tprivate List\u003cString\u003e allEmoteNames;\n\n\tprivate ActionConstraint constraint;\n\tprivate Consumer\u003cActionConstraint\u003e onSave;\n\tprivate boolean cancelled \u003d true;\n\n\tpublic EmoteConstraintDialog(JFrame parent, ActionConstraint existing, Consumer\u003cActionConstraint\u003e onSave)\n\t{\n\t\tsuper(parent, \"Emote Constraint\", false); // false \u003d non-modal\n\t\tthis.onSave \u003d onSave;\n\t\tthis.constraint \u003d existing !\u003d null ? existing : new ActionConstraint(\"emote\");\n\n\t\t// Get all emote names\n\t\tallEmoteNames \u003d new ArrayList\u003c\u003e(EmoteData.getEmotes().keySet());\n\n\t\tinitializeUI();\n\t\tpopulateFields();\n\t\tpack();\n\t\tsetLocationRelativeTo(parent);\n\t\tsetAlwaysOnTop(true);\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout(10, 10));\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Top panel with instructions and search\n\t\tJPanel topPanel \u003d new JPanel(new BorderLayout(5, 5));\n\t\ttopPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\ttopPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 0, 10));\n\n\t\tJLabel instructionLabel \u003d new JLabel(\"Select an emote:\");\n\t\tinstructionLabel.setForeground(Color.WHITE);\n\t\ttopPanel.add(instructionLabel, BorderLayout.NORTH);\n\n\t\t// Search field\n\t\tJPanel searchPanel \u003d new JPanel(new BorderLayout(5, 0));\n\t\tsearchPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tJLabel searchLabel \u003d new JLabel(\"Search:\");\n\t\tsearchLabel.setForeground(Color.WHITE);\n\t\tsearchPanel.add(searchLabel, BorderLayout.WEST);\n\n\t\tsearchField \u003d new JTextField(20);\n\t\tsearchField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsearchField.setForeground(Color.WHITE);\n\t\tsearchField.getDocument().addDocumentListener(new DocumentListener()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void insertUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tfilterEmotes();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void removeUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tfilterEmotes();\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void changedUpdate(DocumentEvent e)\n\t\t\t{\n\t\t\t\tfilterEmotes();\n\t\t\t}\n\t\t});\n\t\tsearchPanel.add(searchField, BorderLayout.CENTER);\n\n\t\ttopPanel.add(searchPanel, BorderLayout.SOUTH);\n\n\t\t// Center panel with emote list\n\t\tJPanel centerPanel \u003d new JPanel(new BorderLayout());\n\t\tcenterPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tcenterPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\tlistModel \u003d new DefaultListModel\u003c\u003e();\n\t\tfor (String emoteName : allEmoteNames)\n\t\t{\n\t\t\tlistModel.addElement(emoteName);\n\t\t}\n\n\t\temoteList \u003d new JList\u003c\u003e(listModel);\n\t\temoteList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\t\temoteList.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\temoteList.setForeground(Color.WHITE);\n\t\temoteList.setVisibleRowCount(15);\n\n\t\tJScrollPane scrollPane \u003d new JScrollPane(emoteList);\n\t\tscrollPane.setPreferredSize(new Dimension(300, 300));\n\t\tcenterPanel.add(scrollPane, BorderLayout.CENTER);\n\n\t\t// Buttons panel\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout());\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tbuttonPanel.setBorder(BorderFactory.createEmptyBorder(0, 10, 10, 10));\n\n\t\tJButton saveButton \u003d new JButton(\"Save\");\n\t\tJButton cancelButton \u003d new JButton(\"Cancel\");\n\n\t\tsaveButton.addActionListener(this::onSave);\n\t\tcancelButton.addActionListener(this::onCancel);\n\n\t\tbuttonPanel.add(saveButton);\n\t\tbuttonPanel.add(cancelButton);\n\n\t\tadd(topPanel, BorderLayout.NORTH);\n\t\tadd(centerPanel, BorderLayout.CENTER);\n\t\tadd(buttonPanel, BorderLayout.SOUTH);\n\t}\n\n\tprivate void populateFields()\n\t{\n\t\t// If editing an existing constraint, select the corresponding emote\n\t\tif (constraint.getEmoteId() !\u003d null)\n\t\t{\n\t\t\tString emoteName \u003d EmoteData.getEmoteName(constraint.getEmoteId());\n\t\t\tif (emoteName !\u003d null \u0026\u0026 !emoteName.equals(\"Unknown Emote\"))\n\t\t\t{\n\t\t\t\temoteList.setSelectedValue(emoteName, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void filterEmotes()\n\t{\n\t\tString searchText \u003d searchField.getText().toLowerCase();\n\t\tlistModel.clear();\n\n\t\tfor (String emoteName : allEmoteNames)\n\t\t{\n\t\t\tif (emoteName.toLowerCase().contains(searchText))\n\t\t\t{\n\t\t\t\tlistModel.addElement(emoteName);\n\t\t\t}\n\t\t}\n\n\t\t// If there\u0027s only one match, select it\n\t\tif (listModel.getSize() \u003d\u003d 1)\n\t\t{\n\t\t\temoteList.setSelectedIndex(0);\n\t\t}\n\t}\n\n\tprivate void onSave(ActionEvent e)\n\t{\n\t\tString selectedEmote \u003d emoteList.getSelectedValue();\n\t\tif (selectedEmote \u003d\u003d null)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Please select an emote\", \"Selection Required\", JOptionPane.WARNING_MESSAGE);\n\t\t\treturn;\n\t\t}\n\n\t\tInteger emoteId \u003d EmoteData.getEmoteId(selectedEmote);\n\t\tif (emoteId \u003d\u003d null)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Invalid emote selected\", \"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t\treturn;\n\t\t}\n\n\t\tconstraint.setType(\"emote\");\n\t\tconstraint.setEmoteId(emoteId);\n\n\t\tcancelled \u003d false;\n\t\tonSave.accept(constraint);\n\t\tdispose();\n\t}\n\n\tprivate void onCancel(ActionEvent e)\n\t{\n\t\tcancelled \u003d true;\n\t\tdispose();\n\t}\n\n\tpublic boolean wasCancelled()\n\t{\n\t\treturn cancelled;\n\t}\n}\n","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\EmoteConstraintDialog.java"},{"fileName":"EventInfoDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.ApiClient;\nimport com.lennyscustomclues.EmoteData;\nimport com.lennyscustomclues.constraints.LocationConstraint;\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.FontManager;\n\nimport javax.swing.*;\nimport javax.swing.table.DefaultTableCellRenderer;\nimport javax.swing.table.DefaultTableModel;\nimport java.awt.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\n\npublic class EventInfoDialog extends JDialog\n{\n\tprivate ApiClient apiClient;\n\tprivate Client client;\n\tprivate JFrame parentFrame;\n\tprivate String eventKey;\n\tprivate String secretKey;\n\tprivate String rewardText;\n\tprivate List\u003cMap\u003cString, Object\u003e\u003e constraints;\n\tprivate List\u003cApiClient.PlayerCompletion\u003e completedBy;\n\n\t// UI components that need to be refreshed\n\tprivate JPanel mainPanel;\n\tprivate JLabel statusLabel;\n\n\tpublic EventInfoDialog(JFrame parent, Client client, ApiClient apiClient,\n\t\tString eventKey, String secretKey, String rewardText,\n\t\tList\u003cMap\u003cString, Object\u003e\u003e constraints, List\u003cApiClient.PlayerCompletion\u003e completedBy)\n\t{\n\t\tsuper(parent, \"Event Information\", true);\n\t\tthis.parentFrame \u003d parent;\n\t\tthis.client \u003d client;\n\t\tthis.apiClient \u003d apiClient;\n\t\tthis.eventKey \u003d eventKey;\n\t\tthis.secretKey \u003d secretKey;\n\t\tthis.rewardText \u003d rewardText;\n\t\tthis.constraints \u003d constraints;\n\t\tthis.completedBy \u003d completedBy;\n\n\t\tinitializeUI();\n\t\tpack();\n\t\tsetMinimumSize(new Dimension(600, 500));\n\t\tsetLocationRelativeTo(parent);\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Title\n\t\tJLabel titleLabel \u003d new JLabel(\"Event: \" + eventKey);\n\t\ttitleLabel.setForeground(Color.WHITE);\n\t\ttitleLabel.setFont(FontManager.getRunescapeFont().deriveFont(Font.BOLD, 14f));\n\t\ttitleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\ttitleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// Main content panel\n\t\tmainPanel \u003d new JPanel();\n\t\tmainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n\t\tmainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tmainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// Answer summary panel\n\t\tJPanel summaryPanel \u003d createAnswerSummaryPanel();\n\n\t\t// Solvers panel\n\t\tJPanel solversPanel \u003d createSolversPanel();\n\n\t\tmainPanel.add(summaryPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(solversPanel);\n\n\t\t// Bottom panel with buttons and status\n\t\tJPanel bottomPanel \u003d new JPanel();\n\t\tbottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));\n\t\tbottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Buttons panel\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout(FlowLayout.CENTER));\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tJButton refreshButton \u003d new JButton(\"Refresh\");\n\t\trefreshButton.addActionListener(e -\u003e onRefresh());\n\t\tbuttonPanel.add(refreshButton);\n\n\t\tJButton editButton \u003d new JButton(\"Edit Answer\");\n\t\teditButton.addActionListener(e -\u003e onEditAnswer());\n\t\tbuttonPanel.add(editButton);\n\n\t\tJButton closeButton \u003d new JButton(\"Close\");\n\t\tcloseButton.addActionListener(e -\u003e dispose());\n\t\tbuttonPanel.add(closeButton);\n\n\t\t// Status label\n\t\tstatusLabel \u003d new JLabel(\" \");\n\t\tstatusLabel.setForeground(Color.WHITE);\n\t\tstatusLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\tstatusLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));\n\n\t\tbottomPanel.add(buttonPanel);\n\t\tbottomPanel.add(statusLabel);\n\n\t\tadd(titleLabel, BorderLayout.NORTH);\n\t\tadd(mainPanel, BorderLayout.CENTER);\n\t\tadd(bottomPanel, BorderLayout.SOUTH);\n\t}\n\n\tprivate JPanel createAnswerSummaryPanel()\n\t{\n\t\tJPanel panel \u003d new JPanel(new BorderLayout());\n\t\tpanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tpanel.setBorder(BorderFactory.createTitledBorder(\n\t\t\tBorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),\n\t\t\t\"Answer Summary\",\n\t\t\t0,\n\t\t\t0,\n\t\t\tFontManager.getRunescapeFont(),\n\t\t\tColor.WHITE\n\t\t));\n\n\t\t// Build the summary text\n\t\tStringBuilder summaryBuilder \u003d new StringBuilder();\n\t\tsummaryBuilder.append(\"Reward: \").append(rewardText !\u003d null \u0026\u0026 !rewardText.trim().isEmpty() ? rewardText : \"(No reward text specified)\").append(\"\\n\\n\");\n\n\t\tif (constraints \u003d\u003d null || constraints.isEmpty())\n\t\t{\n\t\t\tsummaryBuilder.append(\"No constraints defined\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Check if there\u0027s an emote constraint\n\t\t\tString requiredAction \u003d \"Dig with a spade\";\n\t\t\tfor (Map\u003cString, Object\u003e constraintMap : constraints)\n\t\t\t{\n\t\t\t\tString constraintType \u003d (String) constraintMap.get(\"constraint_type\");\n\t\t\t\tif (\"action\".equals(constraintType))\n\t\t\t\t{\n\t\t\t\t\tString type \u003d (String) constraintMap.get(\"type\");\n\t\t\t\t\tif (\"emote\".equals(type))\n\t\t\t\t\t{\n\t\t\t\t\t\tObject emoteIdObj \u003d constraintMap.get(\"emote_id\");\n\t\t\t\t\t\tif (emoteIdObj !\u003d null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tInteger emoteId \u003d null;\n\t\t\t\t\t\t\tif (emoteIdObj instanceof Number)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\temoteId \u003d ((Number) emoteIdObj).intValue();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (emoteId !\u003d null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString emoteName \u003d EmoteData.getEmoteName(emoteId);\n\t\t\t\t\t\t\t\trequiredAction \u003d \"Perform an Emote: \" + emoteName;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsummaryBuilder.append(\"Required Action: \").append(requiredAction).append(\"\\n\");\n\n\t\t\tfor (Map\u003cString, Object\u003e constraintMap : constraints)\n\t\t\t{\n\t\t\t\tString constraintType \u003d (String) constraintMap.get(\"constraint_type\");\n\t\t\t\tif (\"location\".equals(constraintType))\n\t\t\t\t{\n\t\t\t\t\tsummaryBuilder.append(getLocationConstraintDescription(constraintMap));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tJTextArea summaryArea \u003d new JTextArea(summaryBuilder.toString());\n\t\tsummaryArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsummaryArea.setForeground(Color.WHITE);\n\t\tsummaryArea.setFont(FontManager.getRunescapeSmallFont());\n\t\tsummaryArea.setEditable(false);\n\t\tsummaryArea.setLineWrap(true);\n\t\tsummaryArea.setWrapStyleWord(true);\n\n\t\tJScrollPane scrollPane \u003d new JScrollPane(summaryArea);\n\t\tscrollPane.setPreferredSize(new Dimension(0, 120));\n\t\tpanel.add(scrollPane, BorderLayout.CENTER);\n\n\t\treturn panel;\n\t}\n\n\tprivate JPanel createSolversPanel()\n\t{\n\t\tJPanel panel \u003d new JPanel(new BorderLayout());\n\t\tpanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tpanel.setBorder(BorderFactory.createTitledBorder(\n\t\t\tBorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),\n\t\t\t\"Players Who Solved This Event\",\n\t\t\t0,\n\t\t\t0,\n\t\t\tFontManager.getRunescapeFont(),\n\t\t\tColor.WHITE\n\t\t));\n\n\t\t// Create table\n\t\tString[] columnNames \u003d {\"Rank\", \"Player Name\", \"Completed At\"};\n\t\tDefaultTableModel tableModel \u003d new DefaultTableModel(columnNames, 0) {\n\t\t\t@Override\n\t\t\tpublic boolean isCellEditable(int row, int column) {\n\t\t\t\treturn false; // Make table non-editable\n\t\t\t}\n\t\t};\n\n\t\t// Add data to table\n\t\tif (completedBy !\u003d null \u0026\u0026 !completedBy.isEmpty())\n\t\t{\n\t\t\tSimpleDateFormat dateFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\tdateFormat.setTimeZone(TimeZone.getDefault());\n\n\t\t\tfor (int i \u003d 0; i \u003c completedBy.size(); i++)\n\t\t\t{\n\t\t\t\tApiClient.PlayerCompletion completion \u003d completedBy.get(i);\n\t\t\t\tString rank \u003d String.valueOf(i + 1);\n\t\t\t\tString playerName \u003d completion.rsn;\n\t\t\t\tString timestamp \u003d formatTimestamp(completion.timestamp);\n\n\t\t\t\ttableModel.addRow(new Object[]{rank, playerName, timestamp});\n\t\t\t}\n\t\t}\n\n\t\tJTable table \u003d new JTable(tableModel);\n\t\ttable.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\ttable.setForeground(Color.WHITE);\n\t\ttable.setFont(FontManager.getRunescapeSmallFont());\n\t\ttable.setSelectionBackground(ColorScheme.MEDIUM_GRAY_COLOR);\n\t\ttable.setSelectionForeground(Color.WHITE);\n\t\ttable.setGridColor(ColorScheme.MEDIUM_GRAY_COLOR);\n\t\ttable.setShowGrid(true);\n\t\ttable.setRowHeight(25);\n\n\t\t// Center align the Rank column\n\t\tDefaultTableCellRenderer centerRenderer \u003d new DefaultTableCellRenderer();\n\t\tcenterRenderer.setHorizontalAlignment(SwingConstants.CENTER);\n\t\ttable.getColumnModel().getColumn(0).setCellRenderer(centerRenderer);\n\t\ttable.getColumnModel().getColumn(0).setPreferredWidth(50);\n\t\ttable.getColumnModel().getColumn(1).setPreferredWidth(150);\n\t\ttable.getColumnModel().getColumn(2).setPreferredWidth(200);\n\n\t\t// Style table header\n\t\ttable.getTableHeader().setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\ttable.getTableHeader().setForeground(Color.WHITE);\n\t\ttable.getTableHeader().setFont(FontManager.getRunescapeFont());\n\n\t\tJScrollPane scrollPane \u003d new JScrollPane(table);\n\t\tscrollPane.setPreferredSize(new Dimension(0, 200));\n\n\t\t// Add message if no players have solved it yet\n\t\tif (completedBy \u003d\u003d null || completedBy.isEmpty())\n\t\t{\n\t\t\tJLabel noSolversLabel \u003d new JLabel(\"No players have solved this event yet\");\n\t\t\tnoSolversLabel.setForeground(Color.LIGHT_GRAY);\n\t\t\tnoSolversLabel.setFont(FontManager.getRunescapeSmallFont());\n\t\t\tnoSolversLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\t\tpanel.add(noSolversLabel, BorderLayout.CENTER);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpanel.add(scrollPane, BorderLayout.CENTER);\n\t\t}\n\n\t\treturn panel;\n\t}\n\n\tprivate String formatTimestamp(String timestamp)\n\t{\n\t\tif (timestamp \u003d\u003d null || timestamp.isEmpty())\n\t\t{\n\t\t\treturn \"Unknown\";\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\t// Parse ISO 8601 timestamp (e.g., \"2024-11-23T12:34:56.789Z\")\n\t\t\tSimpleDateFormat inputFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd\u0027T\u0027HH:mm:ss\");\n\t\t\tinputFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n\t\t\t// Handle both with and without milliseconds\n\t\t\tString cleanTimestamp \u003d timestamp.replace(\"Z\", \"\");\n\t\t\tif (cleanTimestamp.contains(\".\"))\n\t\t\t{\n\t\t\t\tcleanTimestamp \u003d cleanTimestamp.substring(0, cleanTimestamp.indexOf(\".\"));\n\t\t\t}\n\n\t\t\tDate date \u003d inputFormat.parse(cleanTimestamp);\n\n\t\t\t// Format to local time\n\t\t\tSimpleDateFormat outputFormat \u003d new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\t\t\toutputFormat.setTimeZone(TimeZone.getDefault());\n\t\t\treturn outputFormat.format(date);\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\t// If parsing fails, return the original timestamp\n\t\t\treturn timestamp;\n\t\t}\n\t}\n\n\tprivate String getLocationConstraintDescription(Map\u003cString, Object\u003e constraintMap)\n\t{\n\t\tStringBuilder desc \u003d new StringBuilder();\n\t\tString type \u003d (String) constraintMap.get(\"type\");\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"exact\":\n\t\t\t\tdesc.append(\"Location: Exact tile (\");\n\t\t\t\tdesc.append(\"X: \").append(getIntValue(constraintMap, \"exact_x\"));\n\t\t\t\tdesc.append(\", Y: \").append(getIntValue(constraintMap, \"exact_y\"));\n\t\t\t\tif (constraintMap.containsKey(\"plane\"))\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(getIntValue(constraintMap, \"plane\"));\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"bounds\":\n\t\t\t\tdesc.append(\"Location: Within rectangle (\");\n\t\t\t\tdesc.append(\"X: \").append(getIntValue(constraintMap, \"min_x\")).append(\"-\").append(getIntValue(constraintMap, \"max_x\"));\n\t\t\t\tdesc.append(\", Y: \").append(getIntValue(constraintMap, \"min_y\")).append(\"-\").append(getIntValue(constraintMap, \"max_y\"));\n\t\t\t\tif (constraintMap.containsKey(\"plane\"))\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(getIntValue(constraintMap, \"plane\"));\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"tolerance\":\n\t\t\t\tdesc.append(\"Location: Near tile (\");\n\t\t\t\tdesc.append(\"X: \").append(getIntValue(constraintMap, \"exact_x\"));\n\t\t\t\tdesc.append(\", Y: \").append(getIntValue(constraintMap, \"exact_y\"));\n\t\t\t\tif (constraintMap.containsKey(\"tolerance\"))\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", within \").append(getIntValue(constraintMap, \"tolerance\")).append(\" tiles\");\n\t\t\t\t}\n\t\t\t\tif (constraintMap.containsKey(\"plane\"))\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(getIntValue(constraintMap, \"plane\"));\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdesc.append(\"Location: \").append(type);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn desc.toString();\n\t}\n\n\tprivate int getIntValue(Map\u003cString, Object\u003e map, String key)\n\t{\n\t\tObject value \u003d map.get(key);\n\t\tif (value instanceof Number)\n\t\t{\n\t\t\treturn ((Number) value).intValue();\n\t\t}\n\t\treturn 0;\n\t}\n\n\tprivate void onEditAnswer()\n\t{\n\t\t// Close this dialog\n\t\tdispose();\n\n\t\t// Open the answer builder dialog in update mode\n\t\tAnswerBuilderDialog answerDialog \u003d new AnswerBuilderDialog(\n\t\t\tparentFrame,\n\t\t\tclient,\n\t\t\tapiClient,\n\t\t\teventKey,\n\t\t\tsecretKey,\n\t\t\trewardText,\n\t\t\tconstraints\n\t\t);\n\t\tanswerDialog.setVisible(true);\n\t}\n\n\tprivate void onRefresh()\n\t{\n\t\tstatusLabel.setText(\"Refreshing...\");\n\t\tstatusLabel.setForeground(Color.YELLOW);\n\n\t\t// Make API request to get the latest answer data\n\t\tapiClient.getAnswer(eventKey, secretKey).thenAccept(response -\u003e {\n\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\tif (response.isSuccess())\n\t\t\t\t{\n\t\t\t\t\t// Update the stored data\n\t\t\t\t\tthis.rewardText \u003d response.reward_text;\n\t\t\t\t\tthis.constraints \u003d response.constraints;\n\t\t\t\t\tthis.completedBy \u003d response.completed_by;\n\n\t\t\t\t\t// Rebuild the UI panels\n\t\t\t\t\tmainPanel.removeAll();\n\n\t\t\t\t\tJPanel summaryPanel \u003d createAnswerSummaryPanel();\n\t\t\t\t\tJPanel solversPanel \u003d createSolversPanel();\n\n\t\t\t\t\tmainPanel.add(summaryPanel);\n\t\t\t\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\t\t\t\tmainPanel.add(solversPanel);\n\n\t\t\t\t\t// Refresh the display\n\t\t\t\t\tmainPanel.revalidate();\n\t\t\t\t\tmainPanel.repaint();\n\n\t\t\t\t\tstatusLabel.setText(\"Refreshed successfully!\");\n\t\t\t\t\tstatusLabel.setForeground(Color.GREEN);\n\n\t\t\t\t\t// Clear status message after 3 seconds\n\t\t\t\t\tTimer timer \u003d new Timer(3000, e -\u003e {\n\t\t\t\t\t\tstatusLabel.setText(\" \");\n\t\t\t\t\t});\n\t\t\t\t\ttimer.setRepeats(false);\n\t\t\t\t\ttimer.start();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Handle error\n\t\t\t\t\tString errorMessage \u003d \"Refresh failed: \";\n\t\t\t\t\tif (\"NOT_FOUND\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Event key not found\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"UNAUTHORIZED\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Invalid secret key\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"NETWORK_ERROR\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Network error\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d response.errorMessage;\n\t\t\t\t\t}\n\n\t\t\t\t\tstatusLabel.setText(errorMessage);\n\t\t\t\t\tstatusLabel.setForeground(Color.RED);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\EventInfoDialog.java"},{"fileName":"LocationConstraintDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.constraints.LocationConstraint;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.ui.ColorScheme;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\npublic class LocationConstraintDialog extends JDialog\n{\n\tprivate JComboBox\u003cString\u003e typeCombo;\n\tprivate JPanel dynamicFieldsPanel;\n\tprivate Map\u003cString, JTextField\u003e fields;\n\tprivate Map\u003cString, JLabel\u003e labels;\n\tprivate JLabel coordinatesLabel;\n\tprivate JButton useCurrentLocationButton;\n\tprivate Timer coordinateUpdateTimer;\n\t\n\tprivate LocationConstraint constraint;\n\tprivate Consumer\u003cLocationConstraint\u003e onSave;\n\tprivate Client client;\n\tprivate boolean cancelled \u003d true;\n\n\tpublic LocationConstraintDialog(JFrame parent, LocationConstraint existing, Consumer\u003cLocationConstraint\u003e onSave, Client client)\n\t{\n\t\tsuper(parent, \"Location Constraint\", false); // false \u003d non-modal\n\t\tthis.onSave \u003d onSave;\n\t\tthis.client \u003d client;\n\t\tthis.constraint \u003d existing !\u003d null ? existing : new LocationConstraint(\"exact\");\n\t\tthis.fields \u003d new HashMap\u003c\u003e();\n\t\tthis.labels \u003d new HashMap\u003c\u003e();\n\t\t\n\t\tinitializeUI();\n\t\tpopulateFields();\n\t\tstartCoordinateUpdates();\n\t\tpack();\n\t\tsetLocationRelativeTo(parent);\n\t\tsetAlwaysOnTop(true); // Keep dialog visible above game client\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Top panel with type selection and coordinates\n\t\tJPanel topPanel \u003d new JPanel(new BorderLayout());\n\t\ttopPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Type selection\n\t\tJPanel typePanel \u003d new JPanel(new FlowLayout());\n\t\ttypePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tJLabel typeLabel \u003d new JLabel(\"Type:\");\n\t\ttypeLabel.setForeground(Color.WHITE);\n\t\ttypePanel.add(typeLabel);\n\t\ttypeCombo \u003d new JComboBox\u003c\u003e(new String[]{\"exact\", \"bounds\", \"tolerance\"});\n\t\ttypeCombo.addActionListener(this::onTypeChanged);\n\t\ttypePanel.add(typeCombo);\n\n\t\t// Coordinates display\n\t\tJPanel coordinatesPanel \u003d new JPanel(new FlowLayout());\n\t\tcoordinatesPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tcoordinatesLabel \u003d new JLabel(\"Current Location: Loading...\");\n\t\tcoordinatesLabel.setForeground(Color.CYAN);\n\t\tcoordinatesLabel.setFont(coordinatesLabel.getFont().deriveFont(Font.BOLD));\n\t\tcoordinatesPanel.add(coordinatesLabel);\n\n\t\ttopPanel.add(typePanel, BorderLayout.NORTH);\n\t\ttopPanel.add(coordinatesPanel, BorderLayout.SOUTH);\n\n\t\t// Dynamic fields panel\n\t\tdynamicFieldsPanel \u003d new JPanel(new GridBagLayout());\n\t\tdynamicFieldsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Create all possible fields\n\t\tcreateFields();\n\n\t\t// Buttons panel\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout());\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\t\n\t\tJButton saveButton \u003d new JButton(\"Save\");\n\t\tJButton cancelButton \u003d new JButton(\"Cancel\");\n\t\t\n\t\tsaveButton.addActionListener(this::onSave);\n\t\tcancelButton.addActionListener(this::onCancel);\n\t\t\n\t\tbuttonPanel.add(saveButton);\n\t\tbuttonPanel.add(cancelButton);\n\n\t\tadd(topPanel, BorderLayout.NORTH);\n\t\tadd(dynamicFieldsPanel, BorderLayout.CENTER);\n\t\tadd(buttonPanel, BorderLayout.SOUTH);\n\t}\n\n\tprivate void createFields()\n\t{\n\t\t// Create all possible fields\n\t\tfields.put(\"exactX\", createNumberField());\n\t\tfields.put(\"exactY\", createNumberField());\n\t\tfields.put(\"point1X\", createNumberField());\n\t\tfields.put(\"point1Y\", createNumberField());\n\t\tfields.put(\"point2X\", createNumberField());\n\t\tfields.put(\"point2Y\", createNumberField());\n\t\tfields.put(\"plane\", createNumberField());\n\t\tfields.put(\"tolerance\", createNumberField());\n\n\t\t// Create corresponding labels\n\t\tlabels.put(\"exactX\", createLabel(\"Exact X:\"));\n\t\tlabels.put(\"exactY\", createLabel(\"Exact Y:\"));\n\t\tlabels.put(\"point1X\", createLabel(\"Point 1 X:\"));\n\t\tlabels.put(\"point1Y\", createLabel(\"Point 1 Y:\"));\n\t\tlabels.put(\"point2X\", createLabel(\"Point 2 X:\"));\n\t\tlabels.put(\"point2Y\", createLabel(\"Point 2 Y:\"));\n\t\tlabels.put(\"plane\", createLabel(\"Plane (optional):\"));\n\t\tlabels.put(\"tolerance\", createLabel(\"Tolerance:\"));\n\t}\n\n\tprivate JTextField createNumberField()\n\t{\n\t\tJTextField field \u003d new JTextField(20); // Doubled from 10 to 20\n\t\tfield.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tfield.setForeground(Color.WHITE);\n\t\treturn field;\n\t}\n\n\tprivate JLabel createLabel(String text)\n\t{\n\t\tJLabel label \u003d new JLabel(text);\n\t\tlabel.setForeground(Color.WHITE);\n\t\treturn label;\n\t}\n\n\tprivate void populateFields()\n\t{\n\t\ttypeCombo.setSelectedItem(constraint.getType());\n\t\tsetIntegerField(\"exactX\", constraint.getExactX());\n\t\tsetIntegerField(\"exactY\", constraint.getExactY());\n\t\t// Convert min/max to point1/point2 for display\n\t\tsetIntegerField(\"point1X\", constraint.getMinX());\n\t\tsetIntegerField(\"point1Y\", constraint.getMinY());\n\t\tsetIntegerField(\"point2X\", constraint.getMaxX());\n\t\tsetIntegerField(\"point2Y\", constraint.getMaxY());\n\t\tsetIntegerField(\"plane\", constraint.getPlane());\n\t\tsetIntegerField(\"tolerance\", constraint.getTolerance());\n\t\tupdateFieldsVisibility();\n\t}\n\n\tprivate void setIntegerField(String fieldName, Integer value)\n\t{\n\t\tJTextField field \u003d fields.get(fieldName);\n\t\tif (field !\u003d null)\n\t\t{\n\t\t\tfield.setText(value !\u003d null ? value.toString() : \"\");\n\t\t}\n\t}\n\n\tprivate void onTypeChanged(ActionEvent e)\n\t{\n\t\tupdateFieldsVisibility();\n\t\tpack(); // Resize dialog to fit new content\n\t}\n\n\tprivate void updateFieldsVisibility()\n\t{\n\t\tString selectedType \u003d (String) typeCombo.getSelectedItem();\n\n\t\t// Clear the panel\n\t\tdynamicFieldsPanel.removeAll();\n\n\t\tGridBagConstraints gbc \u003d new GridBagConstraints();\n\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\tgbc.anchor \u003d GridBagConstraints.WEST;\n\n\t\tint row \u003d 0;\n\n\t\t// Add fields based on selected type\n\t\tswitch (selectedType)\n\t\t{\n\t\t\tcase \"exact\":\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactX\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactY\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"bounds\":\n\t\t\t\taddFieldToPanel(gbc, row++, \"point1X\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"point1Y\");\n\n\t\t\t\t// Add \"Use Current Location\" button for Point 1\n\t\t\t\tJButton usePoint1Button \u003d new JButton(\"Use Current Location for Point 1\");\n\t\t\t\tusePoint1Button.addActionListener(e -\u003e onUseCurrentLocationForPoint(1));\n\t\t\t\tgbc.gridx \u003d 0;\n\t\t\t\tgbc.gridy \u003d row++;\n\t\t\t\tgbc.gridwidth \u003d 2;\n\t\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 10, 5);\n\t\t\t\tdynamicFieldsPanel.add(usePoint1Button, gbc);\n\t\t\t\tgbc.gridwidth \u003d 1;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\n\t\t\t\taddFieldToPanel(gbc, row++, \"point2X\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"point2Y\");\n\n\t\t\t\t// Add \"Use Current Location\" button for Point 2\n\t\t\t\tJButton usePoint2Button \u003d new JButton(\"Use Current Location for Point 2\");\n\t\t\t\tusePoint2Button.addActionListener(e -\u003e onUseCurrentLocationForPoint(2));\n\t\t\t\tgbc.gridx \u003d 0;\n\t\t\t\tgbc.gridy \u003d row++;\n\t\t\t\tgbc.gridwidth \u003d 2;\n\t\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 10, 5);\n\t\t\t\tdynamicFieldsPanel.add(usePoint2Button, gbc);\n\t\t\t\tgbc.gridwidth \u003d 1;\n\t\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\t\t\tbreak;\n\n\t\t\tcase \"tolerance\":\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactX\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"exactY\");\n\t\t\t\taddFieldToPanel(gbc, row++, \"tolerance\");\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// Always add plane field (optional for all types)\n\t\taddFieldToPanel(gbc, row++, \"plane\");\n\n\t\t// Add \"Use Current Location\" button for exact and tolerance types\n\t\tif (\"exact\".equals(selectedType) || \"tolerance\".equals(selectedType))\n\t\t{\n\t\t\tuseCurrentLocationButton \u003d new JButton(\"Use Current Location\");\n\t\t\tuseCurrentLocationButton.addActionListener(this::onUseCurrentLocation);\n\n\t\t\tgbc.gridx \u003d 0;\n\t\t\tgbc.gridy \u003d row;\n\t\t\tgbc.gridwidth \u003d 2;\n\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\tgbc.insets \u003d new Insets(10, 5, 5, 5);\n\t\t\tdynamicFieldsPanel.add(useCurrentLocationButton, gbc);\n\t\t\tgbc.gridwidth \u003d 1;\n\t\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\t}\n\n\t\t// Refresh the panel\n\t\tdynamicFieldsPanel.revalidate();\n\t\tdynamicFieldsPanel.repaint();\n\t}\n\n\tprivate void addFieldToPanel(GridBagConstraints gbc, int row, String fieldName)\n\t{\n\t\tJLabel label \u003d labels.get(fieldName);\n\t\tJTextField field \u003d fields.get(fieldName);\n\t\t\n\t\tif (label !\u003d null \u0026\u0026 field !\u003d null)\n\t\t{\n\t\t\t// Add label\n\t\t\tgbc.gridx \u003d 0;\n\t\t\tgbc.gridy \u003d row;\n\t\t\tgbc.fill \u003d GridBagConstraints.NONE;\n\t\t\tdynamicFieldsPanel.add(label, gbc);\n\t\t\t\n\t\t\t// Add field\n\t\t\tgbc.gridx \u003d 1;\n\t\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\t\tgbc.weightx \u003d 1.0;\n\t\t\tdynamicFieldsPanel.add(field, gbc);\n\t\t\tgbc.weightx \u003d 0.0;\n\t\t}\n\t}\n\n\tprivate void onSave(ActionEvent e)\n\t{\n\t\ttry\n\t\t{\n\t\t\tString selectedType \u003d (String) typeCombo.getSelectedItem();\n\t\t\tconstraint.setType(selectedType);\n\t\t\tconstraint.setExactX(parseInteger(\"exactX\"));\n\t\t\tconstraint.setExactY(parseInteger(\"exactY\"));\n\t\t\tconstraint.setPlane(parseInteger(\"plane\"));\n\t\t\tconstraint.setTolerance(parseInteger(\"tolerance\"));\n\n\t\t\t// For bounds type, calculate min/max from the two points\n\t\t\tif (\"bounds\".equals(selectedType))\n\t\t\t{\n\t\t\t\tInteger point1X \u003d parseInteger(\"point1X\");\n\t\t\t\tInteger point1Y \u003d parseInteger(\"point1Y\");\n\t\t\t\tInteger point2X \u003d parseInteger(\"point2X\");\n\t\t\t\tInteger point2Y \u003d parseInteger(\"point2Y\");\n\n\t\t\t\tif (point1X !\u003d null \u0026\u0026 point2X !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tconstraint.setMinX(Math.min(point1X, point2X));\n\t\t\t\t\tconstraint.setMaxX(Math.max(point1X, point2X));\n\t\t\t\t}\n\n\t\t\t\tif (point1Y !\u003d null \u0026\u0026 point2Y !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tconstraint.setMinY(Math.min(point1Y, point2Y));\n\t\t\t\t\tconstraint.setMaxY(Math.max(point1Y, point2Y));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcancelled \u003d false;\n\t\t\tonSave.accept(constraint);\n\t\t\tstopCoordinateUpdates();\n\t\t\tdispose();\n\t\t}\n\t\tcatch (NumberFormatException ex)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Please enter valid numbers\", \"Input Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t}\n\n\tprivate void onCancel(ActionEvent e)\n\t{\n\t\tcancelled \u003d true;\n\t\tstopCoordinateUpdates();\n\t\tdispose();\n\t}\n\n\tprivate void onUseCurrentLocation(ActionEvent e)\n\t{\n\t\tWorldPoint currentLocation \u003d getCurrentPlayerLocation();\n\t\tif (currentLocation !\u003d null)\n\t\t{\n\t\t\tJTextField exactXField \u003d fields.get(\"exactX\");\n\t\t\tJTextField exactYField \u003d fields.get(\"exactY\");\n\t\t\tJTextField planeField \u003d fields.get(\"plane\");\n\n\t\t\tif (exactXField !\u003d null) exactXField.setText(String.valueOf(currentLocation.getX()));\n\t\t\tif (exactYField !\u003d null) exactYField.setText(String.valueOf(currentLocation.getY()));\n\t\t\tif (planeField !\u003d null) planeField.setText(String.valueOf(currentLocation.getPlane()));\n\t\t}\n\t}\n\n\tprivate void onUseCurrentLocationForPoint(int pointNumber)\n\t{\n\t\tWorldPoint currentLocation \u003d getCurrentPlayerLocation();\n\t\tif (currentLocation !\u003d null)\n\t\t{\n\t\t\tString xFieldName \u003d \"point\" + pointNumber + \"X\";\n\t\t\tString yFieldName \u003d \"point\" + pointNumber + \"Y\";\n\n\t\t\tJTextField xField \u003d fields.get(xFieldName);\n\t\t\tJTextField yField \u003d fields.get(yFieldName);\n\t\t\tJTextField planeField \u003d fields.get(\"plane\");\n\n\t\t\tif (xField !\u003d null) xField.setText(String.valueOf(currentLocation.getX()));\n\t\t\tif (yField !\u003d null) yField.setText(String.valueOf(currentLocation.getY()));\n\t\t\tif (planeField !\u003d null) planeField.setText(String.valueOf(currentLocation.getPlane()));\n\t\t}\n\t}\n\n\tprivate void startCoordinateUpdates()\n\t{\n\t\t// Update coordinates every 500ms\n\t\tcoordinateUpdateTimer \u003d new Timer(500, e -\u003e updateCoordinatesDisplay());\n\t\tcoordinateUpdateTimer.start();\n\t\tupdateCoordinatesDisplay(); // Initial update\n\t}\n\n\tprivate void stopCoordinateUpdates()\n\t{\n\t\tif (coordinateUpdateTimer !\u003d null)\n\t\t{\n\t\t\tcoordinateUpdateTimer.stop();\n\t\t}\n\t}\n\n\tprivate void updateCoordinatesDisplay()\n\t{\n\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\tWorldPoint location \u003d getCurrentPlayerLocation();\n\t\t\tif (location !\u003d null)\n\t\t\t{\n\t\t\t\tcoordinatesLabel.setText(String.format(\"Current Location: X:%d Y:%d Plane:%d\", \n\t\t\t\t\tlocation.getX(), location.getY(), location.getPlane()));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcoordinatesLabel.setText(\"Current Location: Not available\");\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate WorldPoint getCurrentPlayerLocation()\n\t{\n\t\tif (client \u003d\u003d null) return null;\n\t\t\n\t\tPlayer player \u003d client.getLocalPlayer();\n\t\tif (player \u003d\u003d null) return null;\n\t\t\n\t\treturn player.getWorldLocation();\n\t}\n\n\tprivate Integer parseInteger(String fieldName)\n\t{\n\t\tJTextField field \u003d fields.get(fieldName);\n\t\tif (field \u003d\u003d null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString text \u003d field.getText();\n\t\tif (text \u003d\u003d null || text.trim().isEmpty())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn Integer.parseInt(text.trim());\n\t}\n\n\tpublic boolean wasCancelled()\n\t{\n\t\treturn cancelled;\n\t}\n\n\t@Override\n\tpublic void dispose()\n\t{\n\t\tstopCoordinateUpdates();\n\t\tsuper.dispose();\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\LocationConstraintDialog.java"},{"fileName":"ManageEventDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.ApiClient;\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.FontManager;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class ManageEventDialog extends JDialog\n{\n\tprivate ApiClient apiClient;\n\tprivate Client client;\n\tprivate JFrame parentFrame;\n\n\tprivate JTextField eventKeyField;\n\tprivate JTextField secretKeyField;\n\tprivate JButton submitButton;\n\tprivate JButton cancelButton;\n\tprivate JLabel statusLabel;\n\n\tpublic ManageEventDialog(JFrame parent, Client client, ApiClient apiClient)\n\t{\n\t\tsuper(parent, \"Manage Existing Event\", true);\n\t\tthis.parentFrame \u003d parent;\n\t\tthis.client \u003d client;\n\t\tthis.apiClient \u003d apiClient;\n\n\t\tinitializeUI();\n\t\tpack();\n\t\tsetMinimumSize(new Dimension(400, 200));\n\t\tsetLocationRelativeTo(parent);\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Title\n\t\tJLabel titleLabel \u003d new JLabel(\"Enter Event Credentials\");\n\t\ttitleLabel.setForeground(Color.WHITE);\n\t\ttitleLabel.setFont(FontManager.getRunescapeFont());\n\t\ttitleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\ttitleLabel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// Main content panel\n\t\tJPanel mainPanel \u003d new JPanel(new GridBagLayout());\n\t\tmainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tmainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\tGridBagConstraints gbc \u003d new GridBagConstraints();\n\t\tgbc.insets \u003d new Insets(5, 5, 5, 5);\n\t\tgbc.anchor \u003d GridBagConstraints.WEST;\n\n\t\t// Event Key label and field\n\t\tJLabel eventKeyLabel \u003d new JLabel(\"Event Key:\");\n\t\teventKeyLabel.setForeground(Color.WHITE);\n\t\tgbc.gridx \u003d 0;\n\t\tgbc.gridy \u003d 0;\n\t\tgbc.fill \u003d GridBagConstraints.NONE;\n\t\tmainPanel.add(eventKeyLabel, gbc);\n\n\t\teventKeyField \u003d new JTextField(20);\n\t\teventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\teventKeyField.setForeground(Color.WHITE);\n\t\tgbc.gridx \u003d 1;\n\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\tgbc.weightx \u003d 1.0;\n\t\tmainPanel.add(eventKeyField, gbc);\n\n\t\t// Secret Key label and field\n\t\tJLabel secretKeyLabel \u003d new JLabel(\"Secret Key:\");\n\t\tsecretKeyLabel.setForeground(Color.WHITE);\n\t\tgbc.gridx \u003d 0;\n\t\tgbc.gridy \u003d 1;\n\t\tgbc.fill \u003d GridBagConstraints.NONE;\n\t\tgbc.weightx \u003d 0.0;\n\t\tmainPanel.add(secretKeyLabel, gbc);\n\n\t\tsecretKeyField \u003d new JTextField(20);\n\t\tsecretKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsecretKeyField.setForeground(Color.WHITE);\n\t\tgbc.gridx \u003d 1;\n\t\tgbc.fill \u003d GridBagConstraints.HORIZONTAL;\n\t\tgbc.weightx \u003d 1.0;\n\t\tmainPanel.add(secretKeyField, gbc);\n\n\t\t// Bottom panel containing buttons and status\n\t\tJPanel bottomPanel \u003d new JPanel();\n\t\tbottomPanel.setLayout(new BoxLayout(bottomPanel, BoxLayout.Y_AXIS));\n\t\tbottomPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Buttons panel\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout(FlowLayout.CENTER));\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tsubmitButton \u003d new JButton(\"Load Event\");\n\t\tsubmitButton.addActionListener(e -\u003e onSubmit());\n\t\tbuttonPanel.add(submitButton);\n\n\t\tcancelButton \u003d new JButton(\"Cancel\");\n\t\tcancelButton.addActionListener(e -\u003e dispose());\n\t\tbuttonPanel.add(cancelButton);\n\n\t\t// Status label\n\t\tstatusLabel \u003d new JLabel(\" \");\n\t\tstatusLabel.setForeground(Color.WHITE);\n\t\tstatusLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\t\tstatusLabel.setBorder(BorderFactory.createEmptyBorder(5, 10, 5, 10));\n\n\t\tbottomPanel.add(buttonPanel);\n\t\tbottomPanel.add(statusLabel);\n\n\t\tadd(titleLabel, BorderLayout.NORTH);\n\t\tadd(mainPanel, BorderLayout.CENTER);\n\t\tadd(bottomPanel, BorderLayout.SOUTH);\n\t}\n\n\tprivate void onSubmit()\n\t{\n\t\tString eventKey \u003d eventKeyField.getText().trim();\n\t\tString secretKey \u003d secretKeyField.getText().trim();\n\n\t\tif (eventKey.isEmpty())\n\t\t{\n\t\t\tstatusLabel.setText(\"Event key is required\");\n\t\t\tstatusLabel.setForeground(Color.RED);\n\t\t\treturn;\n\t\t}\n\n\t\tif (secretKey.isEmpty())\n\t\t{\n\t\t\tstatusLabel.setText(\"Secret key is required\");\n\t\t\tstatusLabel.setForeground(Color.RED);\n\t\t\treturn;\n\t\t}\n\n\t\t// Disable buttons while loading\n\t\tsubmitButton.setEnabled(false);\n\t\tstatusLabel.setText(\"Loading event...\");\n\t\tstatusLabel.setForeground(Color.YELLOW);\n\n\t\t// Make API request to get the answer\n\t\tapiClient.getAnswer(eventKey, secretKey).thenAccept(response -\u003e {\n\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\tsubmitButton.setEnabled(true);\n\n\t\t\t\tif (response.isSuccess())\n\t\t\t\t{\n\t\t\t\t\t// Successfully retrieved the answer - open the event info dialog\n\t\t\t\t\tstatusLabel.setText(\"Event loaded successfully!\");\n\t\t\t\t\tstatusLabel.setForeground(Color.GREEN);\n\n\t\t\t\t\t// Close this dialog\n\t\t\t\t\tdispose();\n\n\t\t\t\t\t// Open the event info dialog to show answer summary and solvers\n\t\t\t\t\tEventInfoDialog eventInfoDialog \u003d new EventInfoDialog(\n\t\t\t\t\t\tparentFrame,\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\tapiClient,\n\t\t\t\t\t\teventKey,\n\t\t\t\t\t\tsecretKey,\n\t\t\t\t\t\tresponse.reward_text,\n\t\t\t\t\t\tresponse.constraints,\n\t\t\t\t\t\tresponse.completed_by\n\t\t\t\t\t);\n\t\t\t\t\teventInfoDialog.setVisible(true);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Handle error\n\t\t\t\t\tString errorMessage \u003d \"Failed to load event: \";\n\t\t\t\t\tif (\"NOT_FOUND\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Event key not found\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"UNAUTHORIZED\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Invalid secret key\";\n\t\t\t\t\t}\n\t\t\t\t\telse if (\"NETWORK_ERROR\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d \"Network error\";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terrorMessage +\u003d response.errorMessage;\n\t\t\t\t\t}\n\n\t\t\t\t\tstatusLabel.setText(errorMessage);\n\t\t\t\t\tstatusLabel.setForeground(Color.RED);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\ManageEventDialog.java"},{"fileName":"SubmitAnswerDialog.java","content":"package com.lennyscustomclues.dialogs;\n\nimport com.lennyscustomclues.AnswerBuilder;\nimport com.lennyscustomclues.ApiClient;\nimport com.lennyscustomclues.EmoteData;\nimport net.runelite.client.ui.ColorScheme;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.util.function.BiConsumer;\n\npublic class SubmitAnswerDialog extends JDialog\n{\n\tprivate JTextField eventKeyField;\n\tprivate JTextField secretKeyField;\n\tprivate JButton validateKeyButton;\n\tprivate JButton submitButton;\n\tprivate JButton cancelButton;\n\tprivate JLabel validationStatusLabel;\n\n\tprivate AnswerBuilder answerBuilder;\n\tprivate ApiClient apiClient;\n\tprivate BiConsumer\u003cString, String\u003e onSubmit;\n\tprivate boolean cancelled \u003d true;\n\tprivate boolean keyValidated \u003d false;\n\n\tpublic SubmitAnswerDialog(JFrame parent, AnswerBuilder answerBuilder, ApiClient apiClient, BiConsumer\u003cString, String\u003e onSubmit)\n\t{\n\t\tsuper(parent, \"Submit Answer to Server\", false); // Non-modal\n\t\tthis.answerBuilder \u003d answerBuilder;\n\t\tthis.apiClient \u003d apiClient;\n\t\tthis.onSubmit \u003d onSubmit;\n\t\t\n\t\tinitializeUI();\n\t\tpack();\n\t\tsetLocationRelativeTo(parent);\n\t\tsetAlwaysOnTop(true);\n\t}\n\n\tprivate void initializeUI()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tgetContentPane().setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Main content panel\n\t\tJPanel mainPanel \u003d new JPanel();\n\t\tmainPanel.setLayout(new BoxLayout(mainPanel, BoxLayout.Y_AXIS));\n\t\tmainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tmainPanel.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));\n\n\t\t// Title/instructions\n\t\tJLabel titleLabel \u003d new JLabel(\"Submit Answer to Server\");\n\t\ttitleLabel.setForeground(Color.WHITE);\n\t\ttitleLabel.setFont(titleLabel.getFont().deriveFont(Font.BOLD, 14f));\n\t\ttitleLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n\n\t\tJLabel instructionLabel \u003d new JLabel(\"\u003chtml\u003e\u003cdiv style\u003d\u0027text-align: center;\u0027\u003eEnter an event key to associate with this answer.\u003cbr/\u003eThe key must be unique and not already in use.\u003c/div\u003e\u003c/html\u003e\");\n\t\tinstructionLabel.setForeground(Color.LIGHT_GRAY);\n\t\tinstructionLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n\n\t\t// Answer summary\n\t\tJPanel summaryPanel \u003d new JPanel(new BorderLayout());\n\t\tsummaryPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsummaryPanel.setBorder(BorderFactory.createTitledBorder(\"Answer Summary\"));\n\t\tsummaryPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 150));\n\n\t\tString rewardText \u003d answerBuilder.getRewardText();\n\t\tif (rewardText \u003d\u003d null || rewardText.trim().isEmpty())\n\t\t{\n\t\t\trewardText \u003d \"(No reward text specified)\";\n\t\t}\n\n\t\t// Build human-readable constraint descriptions\n\t\tStringBuilder summaryBuilder \u003d new StringBuilder();\n\t\tsummaryBuilder.append(\"Reward: \").append(rewardText).append(\"\\n\\n\");\n\n\t\tif (answerBuilder.getConstraintCount() \u003d\u003d 0)\n\t\t{\n\t\t\tsummaryBuilder.append(\"No constraints defined\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Check if there\u0027s an emote constraint\n\t\t\tString requiredAction \u003d \"Dig with a spade\";\n\t\t\tfor (int i \u003d 0; i \u003c answerBuilder.getConstraintCount(); i++)\n\t\t\t{\n\t\t\t\tcom.lennyscustomclues.constraints.Constraint constraint \u003d answerBuilder.getConstraint(i);\n\t\t\t\tif (constraint instanceof com.lennyscustomclues.constraints.ActionConstraint)\n\t\t\t\t{\n\t\t\t\t\tcom.lennyscustomclues.constraints.ActionConstraint actionConstraint \u003d\n\t\t\t\t\t\t(com.lennyscustomclues.constraints.ActionConstraint) constraint;\n\t\t\t\t\tif (\"emote\".equals(actionConstraint.getType()) \u0026\u0026 actionConstraint.getEmoteId() !\u003d null)\n\t\t\t\t\t{\n\t\t\t\t\t\tString emoteName \u003d EmoteData.getEmoteName(actionConstraint.getEmoteId());\n\t\t\t\t\t\trequiredAction \u003d \"Perform an Emote: \" + emoteName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsummaryBuilder.append(\"Required Action: \").append(requiredAction).append(\"\\n\");\n\n\t\t\tfor (int i \u003d 0; i \u003c answerBuilder.getConstraintCount(); i++)\n\t\t\t{\n\t\t\t\tcom.lennyscustomclues.constraints.Constraint constraint \u003d answerBuilder.getConstraint(i);\n\t\t\t\tif (constraint instanceof com.lennyscustomclues.constraints.LocationConstraint)\n\t\t\t\t{\n\t\t\t\t\tsummaryBuilder.append(getLocationConstraintDescription((com.lennyscustomclues.constraints.LocationConstraint) constraint));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tJTextArea summaryArea \u003d new JTextArea(summaryBuilder.toString());\n\t\tsummaryArea.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsummaryArea.setForeground(Color.WHITE);\n\t\tsummaryArea.setEditable(false);\n\t\tsummaryArea.setLineWrap(true);\n\t\tsummaryArea.setWrapStyleWord(true);\n\t\tJScrollPane summaryScroll \u003d new JScrollPane(summaryArea);\n\t\tsummaryPanel.add(summaryScroll, BorderLayout.CENTER);\n\n\t\t// Event key input panel\n\t\tJPanel eventKeyPanel \u003d new JPanel(new BorderLayout());\n\t\teventKeyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\teventKeyPanel.setBorder(BorderFactory.createTitledBorder(\"Event Key\"));\n\n\t\teventKeyField \u003d new JTextField(20);\n\t\teventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\teventKeyField.setForeground(Color.WHITE);\n\t\teventKeyField.getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {\n\t\t\tpublic void insertUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }\n\t\t\tpublic void removeUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }\n\t\t\tpublic void changedUpdate(javax.swing.event.DocumentEvent e) { onEventKeyChanged(); }\n\t\t});\n\n\t\tvalidateKeyButton \u003d new JButton(\"Validate Key\");\n\t\tvalidateKeyButton.addActionListener(this::onValidateKey);\n\t\tvalidateKeyButton.setEnabled(false);\n\n\t\tJPanel keyInputPanel \u003d new JPanel(new BorderLayout());\n\t\tkeyInputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tkeyInputPanel.add(eventKeyField, BorderLayout.CENTER);\n\t\tkeyInputPanel.add(validateKeyButton, BorderLayout.EAST);\n\n\t\tvalidationStatusLabel \u003d new JLabel(\" \");\n\t\tvalidationStatusLabel.setForeground(Color.GRAY);\n\n\t\teventKeyPanel.add(keyInputPanel, BorderLayout.NORTH);\n\t\teventKeyPanel.add(validationStatusLabel, BorderLayout.SOUTH);\n\n\t\t// Secret key input panel\n\t\tJPanel secretKeyPanel \u003d new JPanel(new BorderLayout());\n\t\tsecretKeyPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tsecretKeyPanel.setBorder(BorderFactory.createTitledBorder(\"Secret Key (Optional)\"));\n\n\t\tsecretKeyField \u003d new JTextField(20);\n\t\tsecretKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tsecretKeyField.setForeground(Color.WHITE);\n\n\t\tJLabel secretKeyInfoLabel \u003d new JLabel(\"\u003chtml\u003e\u003ci\u003eUsed to retrieve and update this answer later\u003c/i\u003e\u003c/html\u003e\");\n\t\tsecretKeyInfoLabel.setForeground(Color.LIGHT_GRAY);\n\t\tsecretKeyInfoLabel.setFont(secretKeyInfoLabel.getFont().deriveFont(11f));\n\n\t\tsecretKeyPanel.add(secretKeyField, BorderLayout.NORTH);\n\t\tsecretKeyPanel.add(secretKeyInfoLabel, BorderLayout.SOUTH);\n\n\t\t// Button panel\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout());\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tsubmitButton \u003d new JButton(\"Submit Answer\");\n\t\tsubmitButton.addActionListener(this::onSubmit);\n\t\tsubmitButton.setEnabled(false); // Initially disabled\n\n\t\tcancelButton \u003d new JButton(\"Cancel\");\n\t\tcancelButton.addActionListener(this::onCancel);\n\n\t\tbuttonPanel.add(submitButton);\n\t\tbuttonPanel.add(cancelButton);\n\n\t\t// Add all components\n\t\tmainPanel.add(titleLabel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(instructionLabel);\n\t\tmainPanel.add(Box.createVerticalStrut(15));\n\t\tmainPanel.add(summaryPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(15));\n\t\tmainPanel.add(eventKeyPanel);\n\t\tmainPanel.add(Box.createVerticalStrut(10));\n\t\tmainPanel.add(secretKeyPanel);\n\n\t\tadd(mainPanel, BorderLayout.CENTER);\n\t\tadd(buttonPanel, BorderLayout.SOUTH);\n\t}\n\n\tprivate void onEventKeyChanged()\n\t{\n\t\tString eventKey \u003d eventKeyField.getText().trim();\n\t\tkeyValidated \u003d false;\n\t\tvalidationStatusLabel.setText(\" \");\n\t\tvalidationStatusLabel.setForeground(Color.GRAY);\n\t\t\n\t\tvalidateKeyButton.setEnabled(!eventKey.isEmpty());\n\t\tsubmitButton.setEnabled(false);\n\t}\n\n\tprivate void onValidateKey(ActionEvent e)\n\t{\n\t\tString eventKey \u003d eventKeyField.getText().trim();\n\t\tif (eventKey.isEmpty())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tvalidateKeyButton.setEnabled(false);\n\t\tvalidationStatusLabel.setText(\"Validating key...\");\n\t\tvalidationStatusLabel.setForeground(Color.YELLOW);\n\n\t\t// Validate the key with the API\n\t\tapiClient.validateEventKey(eventKey).thenAccept(response -\u003e {\n\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\tif (response.success)\n\t\t\t\t{\n\t\t\t\t\t// 200 response means key already exists - NOT available for new answer\n\t\t\t\t\tkeyValidated \u003d false;\n\t\t\t\t\tvalidationStatusLabel.setText(\" Key already exists\");\n\t\t\t\t\tvalidationStatusLabel.setForeground(Color.RED);\n\t\t\t\t\tsubmitButton.setEnabled(false);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Non-success response\n\t\t\t\t\tif (\"KEY_NOT_FOUND\".equals(response.errorType))\n\t\t\t\t\t{\n\t\t\t\t\t\t// 404 means key doesn\u0027t exist - GOOD for creating new answer\n\t\t\t\t\t\tkeyValidated \u003d true;\n\t\t\t\t\t\tvalidationStatusLabel.setText(\" Key is available\");\n\t\t\t\t\t\tvalidationStatusLabel.setForeground(Color.GREEN);\n\t\t\t\t\t\tsubmitButton.setEnabled(true);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// Other error (server error, network error, etc.)\n\t\t\t\t\t\tkeyValidated \u003d false;\n\t\t\t\t\t\tvalidationStatusLabel.setText(\" \" + response.message);\n\t\t\t\t\t\tvalidationStatusLabel.setForeground(Color.RED);\n\t\t\t\t\t\tsubmitButton.setEnabled(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalidateKeyButton.setEnabled(true);\n\t\t\t});\n\t\t});\n\t}\n\n\tprivate void onSubmit(ActionEvent e)\n\t{\n\t\tif (!keyValidated)\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Please validate the event key first.\", \"Validation Required\", JOptionPane.WARNING_MESSAGE);\n\t\t\treturn;\n\t\t}\n\n\t\tString eventKey \u003d eventKeyField.getText().trim();\n\t\tif (eventKey.isEmpty())\n\t\t{\n\t\t\tJOptionPane.showMessageDialog(this, \"Please enter an event key.\", \"Event Key Required\", JOptionPane.WARNING_MESSAGE);\n\t\t\treturn;\n\t\t}\n\n\t\tString secretKey \u003d secretKeyField.getText().trim();\n\n\t\t// Warn if no secret key is provided\n\t\tif (secretKey.isEmpty())\n\t\t{\n\t\t\tint result \u003d JOptionPane.showConfirmDialog(\n\t\t\t\tthis,\n\t\t\t\t\"You have not set a secret key for this event, which means you won\u0027t be able to inspect or update the answer in any way after creation.\\n\\nAre you sure you don\u0027t want to set a secret key?\",\n\t\t\t\t\"No Secret Key Set\",\n\t\t\t\tJOptionPane.YES_NO_OPTION,\n\t\t\t\tJOptionPane.WARNING_MESSAGE\n\t\t\t);\n\n\t\t\tif (result !\u003d JOptionPane.YES_OPTION)\n\t\t\t{\n\t\t\t\treturn; // User chose not to proceed\n\t\t\t}\n\t\t}\n\n\t\tcancelled \u003d false;\n\t\tonSubmit.accept(eventKey, secretKey);\n\t\tdispose();\n\t}\n\n\tprivate void onCancel(ActionEvent e)\n\t{\n\t\tcancelled \u003d true;\n\t\tdispose();\n\t}\n\n\tpublic boolean wasCancelled()\n\t{\n\t\treturn cancelled;\n\t}\n\n\tprivate String getLocationConstraintDescription(com.lennyscustomclues.constraints.LocationConstraint constraint)\n\t{\n\t\tStringBuilder desc \u003d new StringBuilder();\n\t\tString type \u003d constraint.getType();\n\n\t\tswitch (type)\n\t\t{\n\t\t\tcase \"exact\":\n\t\t\t\tdesc.append(\"Location: Exact tile (\");\n\t\t\t\tdesc.append(\"X: \").append(constraint.getExactX());\n\t\t\t\tdesc.append(\", Y: \").append(constraint.getExactY());\n\t\t\t\tif (constraint.getPlane() !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(constraint.getPlane());\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"bounds\":\n\t\t\t\tdesc.append(\"Location: Within rectangle (\");\n\t\t\t\tdesc.append(\"X: \").append(constraint.getMinX()).append(\"-\").append(constraint.getMaxX());\n\t\t\t\tdesc.append(\", Y: \").append(constraint.getMinY()).append(\"-\").append(constraint.getMaxY());\n\t\t\t\tif (constraint.getPlane() !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(constraint.getPlane());\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tcase \"tolerance\":\n\t\t\t\tdesc.append(\"Location: Near tile (\");\n\t\t\t\tdesc.append(\"X: \").append(constraint.getExactX());\n\t\t\t\tdesc.append(\", Y: \").append(constraint.getExactY());\n\t\t\t\tif (constraint.getTolerance() !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", within \").append(constraint.getTolerance()).append(\" tiles\");\n\t\t\t\t}\n\t\t\t\tif (constraint.getPlane() !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tdesc.append(\", Plane: \").append(constraint.getPlane());\n\t\t\t\t}\n\t\t\t\tdesc.append(\")\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdesc.append(\"Location: \").append(constraint.description());\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn desc.toString();\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\dialogs\\SubmitAnswerDialog.java"},{"fileName":"EmoteData.java","content":"package com.lennyscustomclues;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class EmoteData\n{\n\tprivate static final Map\u003cString, Integer\u003e EMOTES \u003d new LinkedHashMap\u003c\u003e();\n\n\tstatic\n\t{\n\t\tEMOTES.put(\"Yes\", 855);\n\t\tEMOTES.put(\"No\", 856);\n\t\tEMOTES.put(\"Bow\", 858);\n\t\tEMOTES.put(\"Angry\", 859);\n\t\tEMOTES.put(\"Think\", 857);\n\t\tEMOTES.put(\"Wave\", 863);\n\t\tEMOTES.put(\"Shrug\", 2113);\n\t\tEMOTES.put(\"Cheer\", 862);\n\t\tEMOTES.put(\"Beckon\", 864);\n\t\tEMOTES.put(\"Laugh\", 861);\n\t\tEMOTES.put(\"Jump for Joy\", 2109);\n\t\tEMOTES.put(\"Yawn\", 2111);\n\t\tEMOTES.put(\"Dance\", 866);\n\t\tEMOTES.put(\"Jig\", 2106);\n\t\tEMOTES.put(\"Spin\", 2107);\n\t\tEMOTES.put(\"Headbang\", 2108);\n\t\tEMOTES.put(\"Cry\", 860);\n\t\tEMOTES.put(\"Blow Kiss\", 1374);\n\t\tEMOTES.put(\"Panic\", 2105);\n\t\tEMOTES.put(\"Raspberry\", 2110);\n\t\tEMOTES.put(\"Clap\", 865);\n\t\tEMOTES.put(\"Salute\", 2112);\n\t\tEMOTES.put(\"Goblin Bow\", 2127);\n\t\tEMOTES.put(\"Goblin Salute\", 2128);\n\t\tEMOTES.put(\"Glass Box\", 1131);\n\t\tEMOTES.put(\"Climb Rope\", 1130);\n\t\tEMOTES.put(\"Lean\", 1129);\n\t\tEMOTES.put(\"Glass Wall\", 1128);\n\t\tEMOTES.put(\"Idea\", 4276);\n\t\tEMOTES.put(\"Stamp\", 4278);\n\t\tEMOTES.put(\"Flap\", 4280);\n\t\tEMOTES.put(\"Slap Head\", 4275);\n\t\tEMOTES.put(\"Zombie Walk\", 3544);\n\t\tEMOTES.put(\"Zombie Dance\", 3543);\n\t\tEMOTES.put(\"Scared\", 2836);\n\t\tEMOTES.put(\"Rabbit Hop\", 6111);\n\t\tEMOTES.put(\"Sit up\", 874);\n\t\tEMOTES.put(\"Push up\", 872);\n\t\tEMOTES.put(\"Star jump\", 870);\n\t\tEMOTES.put(\"Jog\", 868);\n\t\tEMOTES.put(\"Flex\", 8917);\n\t\tEMOTES.put(\"Zombie Hand\", 1708);\n\t\tEMOTES.put(\"Hypermobile Drinker\", 7131);\n\t\tEMOTES.put(\"Smooth dance\", 7533);\n\t\tEMOTES.put(\"Crazy dance\", 7537);\n\t\tEMOTES.put(\"Premier Shield\", 7751);\n\t\tEMOTES.put(\"Party\", 10031);\n\t\tEMOTES.put(\"Trick\", 10503);\n\t\tEMOTES.put(\"Fortis Salute\", 10796);\n\t\tEMOTES.put(\"Sit down\", 10061);\n\t}\n\n\tpublic static Map\u003cString, Integer\u003e getEmotes()\n\t{\n\t\treturn EMOTES;\n\t}\n\n\tpublic static String getEmoteName(int emoteId)\n\t{\n\t\tfor (Map.Entry\u003cString, Integer\u003e entry : EMOTES.entrySet())\n\t\t{\n\t\t\tif (entry.getValue() \u003d\u003d emoteId)\n\t\t\t{\n\t\t\t\treturn entry.getKey();\n\t\t\t}\n\t\t}\n\t\treturn \"Unknown Emote\";\n\t}\n\n\tpublic static Integer getEmoteId(String emoteName)\n\t{\n\t\treturn EMOTES.get(emoteName);\n\t}\n}\n","filePath":"src\\main\\java\\com\\lennyscustomclues\\EmoteData.java"},{"fileName":"EventKeyDialog.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.FontManager;\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.KeyEvent;\nimport java.util.function.Consumer;\n\npublic class EventKeyDialog extends JDialog\n{\n\tprivate final JTextField eventKeyField;\n\tprivate final JButton submitButton;\n\tprivate final JButton cancelButton;\n\tprivate final JLabel statusLabel;\n\tprivate final Consumer\u003cString\u003e onEventKeySet;\n\tprivate final ApiClient apiClient;\n\tprivate boolean submitted \u003d false;\n\tprivate boolean validating \u003d false;\n\n\tpublic EventKeyDialog(JFrame parent, String currentEventKey, boolean isChanging, Consumer\u003cString\u003e onEventKeySet, ApiClient apiClient)\n\t{\n\t\tsuper(parent, isChanging ? \"Change Event Key\" : \"Set Event Key\", true);\n\t\tthis.onEventKeySet \u003d onEventKeySet;\n\t\tthis.apiClient \u003d apiClient;\n\n\t\t// Setup dialog properties\n\t\tsetDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\tsetResizable(false);\n\n\t\t// Create components\n\t\tJPanel mainPanel \u003d new JPanel();\n\t\tmainPanel.setLayout(new BorderLayout(10, 10));\n\t\tmainPanel.setBorder(BorderFactory.createEmptyBorder(15, 15, 15, 15));\n\t\tmainPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Title label\n\t\tJLabel titleLabel \u003d new JLabel(\"Enter event key:\");\n\t\ttitleLabel.setFont(FontManager.getRunescapeFont());\n\t\ttitleLabel.setForeground(Color.WHITE);\n\n\t\t// Text field\n\t\teventKeyField \u003d new JTextField(20);\n\t\teventKeyField.setFont(FontManager.getRunescapeFont());\n\t\teventKeyField.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\teventKeyField.setForeground(Color.WHITE);\n\t\teventKeyField.setCaretColor(Color.WHITE);\n\t\teventKeyField.setBorder(BorderFactory.createCompoundBorder(\n\t\t\tBorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),\n\t\t\tBorderFactory.createEmptyBorder(5, 5, 5, 5)\n\t\t));\n\n\t\t// Pre-fill if changing\n\t\tif (isChanging \u0026\u0026 currentEventKey !\u003d null)\n\t\t{\n\t\t\teventKeyField.setText(currentEventKey);\n\t\t\teventKeyField.selectAll();\n\t\t}\n\n\t\t// Status label for validation feedback\n\t\tstatusLabel \u003d new JLabel(\" \"); // Space to maintain height\n\t\tstatusLabel.setFont(FontManager.getRunescapeSmallFont());\n\t\tstatusLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n\t\t// Buttons\n\t\tJPanel buttonPanel \u003d new JPanel(new FlowLayout(FlowLayout.RIGHT, 10, 0));\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\tcancelButton \u003d new JButton(\"Cancel\");\n\t\tstyleButton(cancelButton);\n\t\tcancelButton.addActionListener(this::onCancelClick);\n\n\t\tsubmitButton \u003d new JButton(\"Submit\");\n\t\tstyleButton(submitButton);\n\t\tsubmitButton.addActionListener(this::onSubmitClick);\n\n\t\tbuttonPanel.add(cancelButton);\n\t\tbuttonPanel.add(submitButton);\n\n\t\t// Layout\n\t\tJPanel inputPanel \u003d new JPanel(new BorderLayout(0, 5));\n\t\tinputPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\t\tinputPanel.add(titleLabel, BorderLayout.NORTH);\n\t\tinputPanel.add(eventKeyField, BorderLayout.CENTER);\n\t\tinputPanel.add(statusLabel, BorderLayout.SOUTH);\n\n\t\tmainPanel.add(inputPanel, BorderLayout.CENTER);\n\t\tmainPanel.add(buttonPanel, BorderLayout.SOUTH);\n\n\t\tadd(mainPanel);\n\n\t\t// Setup keyboard shortcuts\n\t\tsetupKeyBindings();\n\n\t\t// Pack and center\n\t\tpack();\n\t\tsetLocationRelativeTo(parent);\n\n\t\t// Focus text field\n\t\tSwingUtilities.invokeLater(() -\u003e eventKeyField.requestFocusInWindow());\n\t}\n\n\tprivate void styleButton(JButton button)\n\t{\n\t\tbutton.setFont(FontManager.getRunescapeFont());\n\t\tbutton.setBackground(ColorScheme.DARKER_GRAY_COLOR);\n\t\tbutton.setForeground(Color.WHITE);\n\t\tbutton.setBorder(BorderFactory.createCompoundBorder(\n\t\t\tBorderFactory.createLineBorder(ColorScheme.MEDIUM_GRAY_COLOR),\n\t\t\tBorderFactory.createEmptyBorder(5, 15, 5, 15)\n\t\t));\n\t\tbutton.setFocusPainted(false);\n\t}\n\n\tprivate void setupKeyBindings()\n\t{\n\t\t// Enter key submits\n\t\teventKeyField.addActionListener(this::onSubmitClick);\n\n\t\t// Escape key cancels\n\t\tgetRootPane().registerKeyboardAction(\n\t\t\tthis::onCancelClick,\n\t\t\tKeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),\n\t\t\tJComponent.WHEN_IN_FOCUSED_WINDOW\n\t\t);\n\n\t\t// Make Submit the default button\n\t\tgetRootPane().setDefaultButton(submitButton);\n\t}\n\n\tprivate void onSubmitClick(ActionEvent e)\n\t{\n\t\tif (validating)\n\t\t{\n\t\t\treturn; // Ignore if already validating\n\t\t}\n\n\t\tString eventKey \u003d eventKeyField.getText().trim();\n\t\t\n\t\tif (eventKey.isEmpty())\n\t\t{\n\t\t\tsetStatusMessage(\"Event key cannot be empty.\", true);\n\t\t\teventKeyField.requestFocusInWindow();\n\t\t\treturn;\n\t\t}\n\n\t\t// Start validation\n\t\tvalidating \u003d true;\n\t\tsetButtonsEnabled(false);\n\t\tsetStatusMessage(\"Validating event key...\", false);\n\n\t\tapiClient.validateEventKey(eventKey).thenAccept(response -\u003e {\n\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\tvalidating \u003d false;\n\t\t\t\tsetButtonsEnabled(true);\n\n\t\t\t\tif (response.success)\n\t\t\t\t{\n\t\t\t\t\t// Key is valid, proceed\n\t\t\t\t\tsubmitted \u003d true;\n\t\t\t\t\tonEventKeySet.accept(eventKey);\n\t\t\t\t\tdispose();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Handle different error types with user-friendly messages\n\t\t\t\t\tString userMessage \u003d getUserFriendlyErrorMessage(response);\n\t\t\t\t\tsetStatusMessage(userMessage, true);\n\t\t\t\t\teventKeyField.requestFocusInWindow();\n\t\t\t\t\teventKeyField.selectAll();\n\t\t\t\t}\n\t\t\t});\n\t\t}).exceptionally(throwable -\u003e {\n\t\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\t\tvalidating \u003d false;\n\t\t\t\tsetButtonsEnabled(true);\n\t\t\t\tsetStatusMessage(\"Can\u0027t reach the server\", true);\n\t\t\t\teventKeyField.requestFocusInWindow();\n\t\t\t});\n\t\t\treturn null;\n\t\t});\n\t}\n\n\tprivate String getUserFriendlyErrorMessage(ApiClient.ApiResponse response)\n\t{\n\t\tif (response.errorType !\u003d null)\n\t\t{\n\t\t\tswitch (response.errorType)\n\t\t\t{\n\t\t\t\tcase \"KEY_NOT_FOUND\":\n\t\t\t\t\treturn \"Invalid event key\";\n\t\t\t\tcase \"NETWORK_ERROR\":\n\t\t\t\tcase \"IO_ERROR\":\n\t\t\t\tcase \"REQUEST_ERROR\":\n\t\t\t\t\treturn \"Can\u0027t reach the server\";\n\t\t\t\tcase \"SERVER_ERROR\":\n\t\t\t\tcase \"PARSE_ERROR\":\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"An unexpected error occurred\";\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Fallback for responses without error type\n\t\treturn \"Invalid event key\";\n\t}\n\n\tprivate void onCancelClick(ActionEvent e)\n\t{\n\t\tif (!validating)\n\t\t{\n\t\t\tdispose();\n\t\t}\n\t}\n\n\tprivate void setStatusMessage(String message, boolean isError)\n\t{\n\t\tif (isError)\n\t\t{\n\t\t\tstatusLabel.setForeground(Color.RED);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstatusLabel.setForeground(Color.LIGHT_GRAY);\n\t\t}\n\t\tstatusLabel.setText(message);\n\t}\n\n\tprivate void setButtonsEnabled(boolean enabled)\n\t{\n\t\tsubmitButton.setEnabled(enabled);\n\t\tcancelButton.setEnabled(enabled);\n\t\teventKeyField.setEnabled(enabled);\n\t\t\n\t\tif (enabled)\n\t\t{\n\t\t\tsubmitButton.setText(\"Submit\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsubmitButton.setText(\"Validating...\");\n\t\t}\n\t}\n\n\tpublic boolean wasSubmitted()\n\t{\n\t\treturn submitted;\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\EventKeyDialog.java"},{"fileName":"GameStateCapture.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.api.Client;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.Item;\nimport net.runelite.api.ItemContainer;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Singleton\npublic class GameStateCapture\n{\n\t@Inject\n\tprivate Client client;\n\n\tpublic List\u003cApiClient.ItemData\u003e getInventoryData()\n\t{\n\t\tList\u003cApiClient.ItemData\u003e inventoryItems \u003d new ArrayList\u003c\u003e();\n\t\tItemContainer inventory \u003d client.getItemContainer(InventoryID.INVENTORY);\n\n\t\tif (inventory \u003d\u003d null)\n\t\t{\n\t\t\treturn inventoryItems;\n\t\t}\n\n\t\tItem[] items \u003d inventory.getItems();\n\t\tfor (int i \u003d 0; i \u003c items.length; i++)\n\t\t{\n\t\t\tItem item \u003d items[i];\n\t\t\tif (item !\u003d null \u0026\u0026 item.getId() !\u003d -1)\n\t\t\t{\n\t\t\t\tinventoryItems.add(new ApiClient.ItemData(i, item.getId(), item.getQuantity()));\n\t\t\t}\n\t\t}\n\n\t\treturn inventoryItems;\n\t}\n\n\tpublic List\u003cApiClient.ItemData\u003e getWornItemsData()\n\t{\n\t\tList\u003cApiClient.ItemData\u003e wornItems \u003d new ArrayList\u003c\u003e();\n\t\tItemContainer equipment \u003d client.getItemContainer(InventoryID.EQUIPMENT);\n\n\t\tif (equipment \u003d\u003d null)\n\t\t{\n\t\t\treturn wornItems;\n\t\t}\n\n\t\tItem[] items \u003d equipment.getItems();\n\t\tfor (int i \u003d 0; i \u003c items.length; i++)\n\t\t{\n\t\t\tItem item \u003d items[i];\n\t\t\tif (item !\u003d null \u0026\u0026 item.getId() !\u003d -1)\n\t\t\t{\n\t\t\t\twornItems.add(new ApiClient.ItemData(i, item.getId(), item.getQuantity()));\n\t\t\t}\n\t\t}\n\n\t\treturn wornItems;\n\t}\n\n\tpublic ApiClient.LocationData getLocationData(WorldPoint worldLocation, LocalPoint localLocation)\n\t{\n\t\tApiClient.WorldCoords worldCoords \u003d new ApiClient.WorldCoords(\n\t\t\tworldLocation.getX(), worldLocation.getY(), worldLocation.getPlane());\n\t\t\n\t\tApiClient.LocalCoords localCoords \u003d new ApiClient.LocalCoords(\n\t\t\tlocalLocation.getSceneX(), localLocation.getSceneY());\n\t\t\n\t\treturn new ApiClient.LocationData(worldCoords, localCoords);\n\t}\n\n\tpublic ApiClient.GameStateSubmission createGameStateSubmission(ApiClient.LocationData locationData, \n\t\tList\u003cApiClient.ItemData\u003e inventoryData, List\u003cApiClient.ItemData\u003e wornItemsData, \n\t\tInteger emoteId, Integer npcId, String interactionType, String eventKey)\n\t{\n\t\t// Get player\u0027s RSN (RuneScape Name)\n\t\tPlayer localPlayer \u003d client.getLocalPlayer();\n\t\tString rsn \u003d (localPlayer !\u003d null) ? localPlayer.getName() : null;\n\t\t\n\t\treturn new ApiClient.GameStateSubmission(locationData, inventoryData, wornItemsData, \n\t\t\temoteId, npcId, interactionType, eventKey, rsn);\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\GameStateCapture.java"},{"fileName":"GameStateService.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.Player;\nimport net.runelite.api.coords.LocalPoint;\nimport net.runelite.api.coords.WorldPoint;\nimport net.runelite.client.callback.ClientThread;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\n\n@Slf4j\n@Singleton\npublic class GameStateService\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate LennysCustomCluesConfig config;\n\n\t@Inject\n\tprivate ApiClient apiClient;\n\n\t@Inject\n\tprivate GameStateCapture gameStateCapture;\n\n\t@Inject\n\tprivate CelebrationManager celebrationManager;\n\n\tprivate LennysCustomCluesPanel panel;\n\n\t// Event key management\n\tprivate String currentEventKey \u003d \"\";\n\n\tpublic void setPanel(LennysCustomCluesPanel panel)\n\t{\n\t\tthis.panel \u003d panel;\n\t}\n\n\tpublic String getEventKey()\n\t{\n\t\treturn currentEventKey;\n\t}\n\n\tpublic void setEventKey(String eventKey)\n\t{\n\t\tthis.currentEventKey \u003d (eventKey !\u003d null) ? eventKey.trim() : \"\";\n\t\tif (panel !\u003d null)\n\t\t{\n\t\t\tpanel.onEventKeyChanged();\n\t\t}\n\t}\n\n\tpublic void clearEventKey()\n\t{\n\t\tthis.currentEventKey \u003d \"\";\n\t\tif (panel !\u003d null)\n\t\t{\n\t\t\tpanel.onEventKeyChanged();\n\t\t}\n\t}\n\n\tpublic boolean hasEventKey()\n\t{\n\t\treturn !currentEventKey.isEmpty();\n\t}\n\n\tprivate boolean isEventKeyValid()\n\t{\n\t\treturn hasEventKey();\n\t}\n\n\tpublic void captureFromAnimation(int animationId)\n\t{\n\t\tclientThread.invokeLater(() -\u003e {\n\t\t\tif (!isEventKeyValid())\n\t\t\t{\n\t\t\t\tif (config.debug())\n\t\t\t\t{\n\t\t\t\t\tclient.addChatMessage(\n\t\t\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\"[LL-debug] Game state capture skipped - Event Key is empty (Animation ID: \" + animationId + \")\",\n\t\t\t\t\t\tnull\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString eventKey \u003d getEventKey();\n\n\t\t\t// Determine if this is a dig or emote animation\n\t\t\tif (AnimationTriggers.isDigAnimation(animationId))\n\t\t\t{\n\t\t\t\tcaptureGameState(\"dig\", \"Digging animation (ID: \" + animationId + \")\", null, null, null, eventKey);\n\t\t\t}\n\t\t\telse if (AnimationTriggers.isEmoteAnimation(animationId))\n\t\t\t{\n\t\t\t\tString emoteName \u003d EmoteData.getEmoteName(animationId);\n\t\t\t\tcaptureGameState(\"emote\", \"Emote: \" + emoteName + \" (ID: \" + animationId + \")\", animationId, null, null, eventKey);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void captureGameState(String trigger, String additionalInfo, Integer emoteId, Integer npcId, String interactionType, String eventKey)\n\t{\n\t\tPlayer player \u003d client.getLocalPlayer();\n\t\tif (player !\u003d null)\n\t\t{\n\t\t\tWorldPoint worldLocation \u003d player.getWorldLocation();\n\t\t\tLocalPoint localLocation \u003d player.getLocalLocation();\n\n\t\t\tApiClient.LocationData locationData \u003d gameStateCapture.getLocationData(worldLocation, localLocation);\n\t\t\tList\u003cApiClient.ItemData\u003e inventoryData \u003d gameStateCapture.getInventoryData();\n\t\t\tList\u003cApiClient.ItemData\u003e wornItemsData \u003d gameStateCapture.getWornItemsData();\n\t\t\t\n\t\t\tApiClient.GameStateSubmission gameStateSubmission \u003d gameStateCapture.createGameStateSubmission(\n\t\t\t\tlocationData, inventoryData, wornItemsData, emoteId, npcId, interactionType, eventKey);\n\n\t\t\t// Log submission info\n\t\t\tlog.info(\"\u003d\u003d\u003d Lenny\u0027s Custom Clues Game State Submission ({}) \u003d\u003d\u003d\", trigger);\n\t\t\tlog.info(\"Trigger info: {}\", additionalInfo);\n\t\t\tlog.info(\"Event Key: {}, Inventory: {} items, Worn: {} items\", \n\t\t\t\teventKey, inventoryData.size(), wornItemsData.size());\n\n\t\t\t// Update UI immediately\n\t\t\tif (panel !\u003d null)\n\t\t\t{\n\t\t\t\tpanel.updateStatusLabel(String.format(\n\t\t\t\t\t\"\u003chtml\u003e\u003cdiv style\u003d\u0027text-align: center;\u0027\u003eSubmitting...\u003cbr/\u003eTrigger: %s\u003cbr/\u003e%s\u003cbr/\u003eEvent: %s\u003c/div\u003e\u003c/html\u003e\",\n\t\t\t\t\ttrigger,\n\t\t\t\t\tadditionalInfo,\n\t\t\t\t\teventKey\n\t\t\t\t));\n\t\t\t}\n\n\t\t\t// Submit to API\n\t\t\tCompletableFuture\u003cApiClient.ApiResponse\u003e future \u003d apiClient.submitGuess(gameStateSubmission);\n\t\t\tfuture.thenAccept(this::handleApiResponse);\n\n\t\t\t// Show initial message in chat (debug mode only)\n\t\t\tif (config.debug())\n\t\t\t{\n\t\t\t\tclient.addChatMessage(\n\t\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\t\"\",\n\t\t\t\t\t\"[LL-debug] Submitting guess for \u0027\" + eventKey + \"\u0027...\",\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (panel !\u003d null)\n\t\t\t{\n\t\t\t\tpanel.updateStatusLabel(\"Player not found\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleApiResponse(ApiClient.ApiResponse response)\n\t{\n\t\t// Update UI\n\t\tif (panel !\u003d null)\n\t\t{\n\t\t\tString statusText;\n\t\t\tif (response.success)\n\t\t\t{\n\t\t\t\tstatusText \u003d String.format(\n\t\t\t\t\t\"\u003chtml\u003e\u003cdiv style\u003d\u0027text-align: center;\u0027\u003e\u003cfont color\u003d\u0027green\u0027\u003e CORRECT!\u003c/font\u003e\u003cbr/\u003e%s\u003c/div\u003e\u003c/html\u003e\",\n\t\t\t\t\tresponse.message\n\t\t\t\t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstatusText \u003d String.format(\n\t\t\t\t\t\"\u003chtml\u003e\u003cdiv style\u003d\u0027text-align: center;\u0027\u003e\u003cfont color\u003d\u0027red\u0027\u003e %s\u003c/font\u003e\u003cbr/\u003e%s\u003c/div\u003e\u003c/html\u003e\",\n\t\t\t\t\tresponse.success ? \"SUCCESS\" : \"FAILED\",\n\t\t\t\t\tresponse.message\n\t\t\t\t);\n\t\t\t}\n\t\t\tpanel.updateStatusLabel(statusText);\n\t\t}\n\n\t\t// Trigger victory celebration if successful\n\t\tif (response.success \u0026\u0026 celebrationManager !\u003d null)\n\t\t{\n\t\t\tcelebrationManager.triggerVictoryCelebration(currentEventKey);\n\t\t}\n\n\t\t// Add message to in-game chat on client thread\n\t\tclientThread.invokeLater(() -\u003e {\n\t\t\tif (response.success)\n\t\t\t{\n\t\t\t\t// Always show success messages\n\t\t\t\tString chatMessage \u003d \"[Lenny\u0027s Custom Clues] \" + response.message;\n\t\t\t\tclient.addChatMessage(\n\t\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\t\"\",\n\t\t\t\t\tchatMessage,\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if (config.debug())\n\t\t\t{\n\t\t\t\t// Only show failure messages in debug mode\n\t\t\t\tString chatMessage \u003d \"[LL-debug] \" + response.message;\n\t\t\t\tclient.addChatMessage(\n\t\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\t\"\",\n\t\t\t\t\tchatMessage,\n\t\t\t\t\tnull\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\GameStateService.java"},{"fileName":"LennysCustomCluesConfig.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"lennyscustomclues\")\npublic interface LennysCustomCluesConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"debug\",\n\t\tname \u003d \"Debug Mode\",\n\t\tdescription \u003d \"Show all animation IDs in chat when player performs animations\"\n\t)\n\tdefault boolean debug()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showCelebrationSound\",\n\t\tname \u003d \"Victory sound effects\",\n\t\tdescription \u003d \"Play a celebratory sound when you solve a puzzle correctly\"\n\t)\n\tdefault boolean showCelebrationSound()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showCelebrationFireworks\",\n\t\tname \u003d \"Victory fireworks\",\n\t\tdescription \u003d \"Show fireworks when you solve a puzzle correctly\"\n\t)\n\tdefault boolean showCelebrationFireworks()\n\t{\n\t\treturn true;\n\t}\n\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\LennysCustomCluesConfig.java"},{"fileName":"LennysCustomCluesPanel.java","content":"package com.lennyscustomclues;\n\nimport com.lennyscustomclues.dialogs.AnswerBuilderDialog;\nimport com.lennyscustomclues.dialogs.ManageEventDialog;\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.FontManager;\nimport net.runelite.client.ui.PluginPanel;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\n\n@Singleton\npublic class LennysCustomCluesPanel extends PluginPanel\n{\n\t@Inject\n\tprivate GameStateService gameStateService;\n\n\t@Inject\n\tprivate ApiClient apiClient;\n\n\t@Inject\n\tprivate Client client;\n\n\tprivate JLabel titleLabel;\n\tprivate JPanel buttonPanel;\n\tprivate JLabel statusLabel;\n\tprivate JLabel instructionalLabel;\n\tprivate JLabel resultLabel;\n\n\t// Buttons for different states\n\tprivate JButton setEventKeyButton;\n\tprivate JButton unsetEventKeyButton;\n\tprivate JButton changeEventKeyButton;\n\tprivate JButton createAnswerButton;\n\tprivate JButton manageEventButton;\n\n\tpublic LennysCustomCluesPanel()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tsetBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Title label\n\t\ttitleLabel \u003d new JLabel(\"Lenny\u0027s Custom Clues\");\n\t\ttitleLabel.setForeground(Color.WHITE);\n\t\ttitleLabel.setFont(FontManager.getRunescapeFont());\n\t\ttitleLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n\t\t// Button panel - will be dynamically populated\n\t\tbuttonPanel \u003d new JPanel();\n\t\tbuttonPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);\n\n\t\t// Status label\n\t\tstatusLabel \u003d new JLabel();\n\t\tstatusLabel.setForeground(Color.WHITE);\n\t\tstatusLabel.setHorizontalAlignment(SwingConstants.CENTER);\n\n\t\t// Create all buttons\n\t\tcreateButtons();\n\n\t\t// Layout\n\t\tadd(titleLabel, BorderLayout.NORTH);\n\t\tadd(buttonPanel, BorderLayout.CENTER);\n\t\tadd(statusLabel, BorderLayout.SOUTH);\n\n\t\t// UI state will be initialized in initialize() after injection\n\t}\n\n\tprivate void createButtons()\n\t{\n\t\tsetEventKeyButton \u003d new JButton(\"Set Event Key\");\n\t\tsetEventKeyButton.addActionListener(this::onSetEventKeyClick);\n\t\tsetEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tsetEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, setEventKeyButton.getPreferredSize().height));\n\n\t\tunsetEventKeyButton \u003d new JButton(\"Unset Event Key\");\n\t\tunsetEventKeyButton.addActionListener(this::onUnsetEventKeyClick);\n\t\tunsetEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tunsetEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, unsetEventKeyButton.getPreferredSize().height));\n\n\t\tchangeEventKeyButton \u003d new JButton(\"Change Event Key\");\n\t\tchangeEventKeyButton.addActionListener(this::onChangeEventKeyClick);\n\t\tchangeEventKeyButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tchangeEventKeyButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, changeEventKeyButton.getPreferredSize().height));\n\n\t\tcreateAnswerButton \u003d new JButton(\"Create a new event\");\n\t\tcreateAnswerButton.addActionListener(this::onCreateAnswerClick);\n\t\tcreateAnswerButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tcreateAnswerButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, createAnswerButton.getPreferredSize().height));\n\n\t\tmanageEventButton \u003d new JButton(\"Manage existing event\");\n\t\tmanageEventButton.addActionListener(this::onManageEventClick);\n\t\tmanageEventButton.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tmanageEventButton.setMaximumSize(new Dimension(Integer.MAX_VALUE, manageEventButton.getPreferredSize().height));\n\t}\n\n\t@Inject\n\tpublic void initialize()\n\t{\n\t\t// Set up the bidirectional reference with the service\n\t\tgameStateService.setPanel(this);\n\t\t\n\t\t// Initialize UI state now that injection is complete\n\t\tupdatePanelForEventKeyState();\n\t}\n\n\tpublic void onEventKeyChanged()\n\t{\n\t\tSwingUtilities.invokeLater(this::updatePanelForEventKeyState);\n\t}\n\n\tprivate void updatePanelForEventKeyState()\n\t{\n\t\tbuttonPanel.removeAll();\n\n\t\tif (gameStateService.hasEventKey())\n\t\t{\n\t\t\tshowEventKeySetState();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tshowNoEventKeyState();\n\t\t}\n\n\t\tbuttonPanel.revalidate();\n\t\tbuttonPanel.repaint();\n\t}\n\n\tprivate void showNoEventKeyState()\n\t{\n\t\tbuttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));\n\t\tbuttonPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\t// Play in an event section\n\t\tbuttonPanel.add(createSectionLabel(\"Play in an event\"));\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));\n\t\tbuttonPanel.add(setEventKeyButton);\n\n\t\t// Spacing between sections\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 15)));\n\n\t\t// Event management section\n\t\tbuttonPanel.add(createSectionLabel(\"Event management\"));\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));\n\t\tbuttonPanel.add(createAnswerButton);\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));\n\t\tbuttonPanel.add(manageEventButton);\n\n\t\tstatusLabel.setText(\"\");\n\t}\n\n\tprivate void showEventKeySetState()\n\t{\n\t\tbuttonPanel.setLayout(new BoxLayout(buttonPanel, BoxLayout.Y_AXIS));\n\t\tbuttonPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));\n\n\t\tString eventKey \u003d gameStateService.getEventKey();\n\n\t\t// Playing in event section\n\t\tbuttonPanel.add(createSectionLabel(\"Playing in: \" + eventKey));\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));\n\n\t\t// Instructional text\n\t\tinstructionalLabel \u003d new JLabel(\"\u003chtml\u003eTry and solve the clue!\u003cbr/\u003eGood luck!\u003c/html\u003e\");\n\t\tinstructionalLabel.setForeground(Color.WHITE);\n\t\tinstructionalLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tbuttonPanel.add(instructionalLabel);\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 10)));\n\n\t\t// Result text area\n\t\tresultLabel \u003d new JLabel(\"\");\n\t\tresultLabel.setForeground(Color.WHITE);\n\t\tresultLabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\tbuttonPanel.add(resultLabel);\n\n\t\t// Push buttons to bottom\n\t\tbuttonPanel.add(Box.createVerticalGlue());\n\n\t\t// Event key buttons\n\t\tbuttonPanel.add(changeEventKeyButton);\n\t\tbuttonPanel.add(Box.createRigidArea(new Dimension(0, 5)));\n\t\tbuttonPanel.add(unsetEventKeyButton);\n\n\t\tstatusLabel.setText(\"\");\n\t}\n\n\tprivate JLabel createSectionLabel(String text)\n\t{\n\t\tJLabel label \u003d new JLabel(text);\n\t\tlabel.setForeground(ColorScheme.BRAND_ORANGE);\n\t\tlabel.setFont(FontManager.getRunescapeBoldFont());\n\t\tlabel.setAlignmentX(Component.LEFT_ALIGNMENT);\n\t\treturn label;\n\t}\n\n\tprivate void onSetEventKeyClick(ActionEvent e)\n\t{\n\t\tshowEventKeyDialog(null, false);\n\t}\n\n\tprivate void onChangeEventKeyClick(ActionEvent e)\n\t{\n\t\tshowEventKeyDialog(gameStateService.getEventKey(), true);\n\t}\n\n\tprivate void onUnsetEventKeyClick(ActionEvent e)\n\t{\n\t\tgameStateService.clearEventKey();\n\t}\n\n\tprivate void showEventKeyDialog(String currentEventKey, boolean isChanging)\n\t{\n\t\t// Find the parent frame\n\t\tWindow parentWindow \u003d SwingUtilities.getWindowAncestor(this);\n\t\tJFrame parentFrame \u003d (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;\n\n\t\tEventKeyDialog dialog \u003d new EventKeyDialog(\n\t\t\tparentFrame,\n\t\t\tcurrentEventKey,\n\t\t\tisChanging,\n\t\t\teventKey -\u003e gameStateService.setEventKey(eventKey),\n\t\t\tapiClient\n\t\t);\n\n\t\tdialog.setVisible(true);\n\t}\n\n\tprivate void onCreateAnswerClick(ActionEvent e)\n\t{\n\t\t// Find the parent frame\n\t\tWindow parentWindow \u003d SwingUtilities.getWindowAncestor(this);\n\t\tJFrame parentFrame \u003d (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;\n\n\t\tAnswerBuilderDialog dialog \u003d new AnswerBuilderDialog(\n\t\t\tparentFrame,\n\t\t\tclient,\n\t\t\tapiClient\n\t\t);\n\n\t\tdialog.setVisible(true);\n\t}\n\n\tprivate void onManageEventClick(ActionEvent e)\n\t{\n\t\t// Find the parent frame\n\t\tWindow parentWindow \u003d SwingUtilities.getWindowAncestor(this);\n\t\tJFrame parentFrame \u003d (parentWindow instanceof JFrame) ? (JFrame) parentWindow : null;\n\n\t\tManageEventDialog dialog \u003d new ManageEventDialog(\n\t\t\tparentFrame,\n\t\t\tclient,\n\t\t\tapiClient\n\t\t);\n\n\t\tdialog.setVisible(true);\n\t}\n\n\tpublic void updateStatusLabel(String text)\n\t{\n\t\tSwingUtilities.invokeLater(() -\u003e {\n\t\t\tif (resultLabel !\u003d null)\n\t\t\t{\n\t\t\t\tresultLabel.setText(text);\n\t\t\t\tbuttonPanel.revalidate();\n\t\t\t\tbuttonPanel.repaint();\n\t\t\t}\n\t\t});\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\LennysCustomCluesPanel.java"},{"fileName":"LennysCustomCluesPlugin.java","content":"package com.lennyscustomclues;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.Player;\nimport net.runelite.api.events.AnimationChanged;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.ClientToolbar;\nimport net.runelite.client.ui.NavigationButton;\nimport net.runelite.client.util.ImageUtil;\n\nimport java.awt.image.BufferedImage;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Lenny\u0027s Custom Clues\"\n)\npublic class LennysCustomCluesPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate LennysCustomCluesConfig config;\n\n\t@Inject\n\tprivate ClientToolbar clientToolbar;\n\n\t@Inject\n\tprivate MainPanel mainPanel;\n\n\t@Inject\n\tprivate GameStateService gameStateService;\n\n\t@Inject\n\tprivate CelebrationManager celebrationManager;\n\n\tprivate NavigationButton navButton;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tlog.info(\"Lenny\u0027s Custom Clues started!\");\n\n\t\tfinal BufferedImage icon \u003d ImageUtil.loadImageResource(getClass(), \"/util/clue_arrow.png\");\n\n\t\tnavButton \u003d NavigationButton.builder()\n\t\t\t.tooltip(\"Lenny\u0027s Custom Clues\")\n\t\t\t.icon(icon)\n\t\t\t.priority(5)\n\t\t\t.panel(mainPanel)\n\t\t\t.build();\n\n\t\tclientToolbar.addNavigation(navButton);\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tlog.info(\"Lenny\u0027s Custom Clues stopped!\");\n\t\tclientToolbar.removeNavigation(navButton);\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\t// No chat message on login\n\t}\n\n\t@Subscribe\n\tpublic void onAnimationChanged(AnimationChanged event)\n\t{\n\t\t// Only process player animations\n\t\tif (!(event.getActor() instanceof Player))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tPlayer player \u003d (Player) event.getActor();\n\n\t\t// Only track local player animations\n\t\tif (player !\u003d client.getLocalPlayer())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint animationId \u003d player.getAnimation();\n\n\t\t// Debug mode: show all animation IDs in chat\n\t\tif (config.debug())\n\t\t{\n\t\t\tclient.addChatMessage(\n\t\t\t\tChatMessageType.GAMEMESSAGE,\n\t\t\t\t\"\",\n\t\t\t\t\"[LL-debug] Animation ID: \" + animationId,\n\t\t\t\tnull\n\t\t\t);\n\t\t}\n\n\t\t// Check for digging animation\n\t\tif (AnimationTriggers.isTriggerAnimation(animationId))\n\t\t{\n\t\t\tlog.info(\"Digging detected with animation ID: {}\", animationId);\n\t\t\tgameStateService.captureFromAnimation(animationId);\n\t\t}\n\t}\n\n\t@Provides\n\tLennysCustomCluesConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(LennysCustomCluesConfig.class);\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\LennysCustomCluesPlugin.java"},{"fileName":"MainPanel.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.client.ui.ColorScheme;\nimport net.runelite.client.ui.PluginPanel;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.awt.*;\n\n@Singleton\npublic class MainPanel extends PluginPanel\n{\n\t@Inject\n\tprivate LennysCustomCluesPanel normalPanel;\n\n\tpublic MainPanel()\n\t{\n\t\tsetLayout(new BorderLayout());\n\t\tsetBackground(ColorScheme.DARK_GRAY_COLOR);\n\t}\n\n\t@Inject\n\tpublic void initialize()\n\t{\n\t\t// Initialize child panel\n\t\tnormalPanel.initialize();\n\n\t\t// Add the normal panel\n\t\tadd(normalPanel, BorderLayout.CENTER);\n\t}\n}","filePath":"src\\main\\java\\com\\lennyscustomclues\\MainPanel.java"},{"fileName":"LennysCustomCluesPluginTest.java","content":"package com.lennyscustomclues;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class LennysCustomCluesPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(LennysCustomCluesPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\lennyscustomclues\\LennysCustomCluesPluginTest.java"}]},{"commit":"0907827d2440b270576713cbd84a749d9cb7e213","repository":"https://github.com/daanbom/Custom-Drop-Sounds.git","internalName":"custom-drop-sounds","files":[{"fileName":"AnimationIDs.java","content":"package org.CustomSounds;\n\npublic enum AnimationIDs\n{\n    BURN_CLAW(11140),\n    DRAGON_CLAW(7514),\n    HORN_HIT(12158),\n    HORN_MISS(12159),\n    ELDER_MAUL(11124),\n    VOIDWAKER(11275),\n    KERIS(9546),\n    BGS(7642),\n    CRYSTAL_HALLY(1203),\n    HOUSE_TABS(4071),\n    CAPES(714),\n    SCROLLS(3864);\n\n\n    public final int Id;\n\n    AnimationIDs(int id)\n    {\n        this.Id \u003d id;\n    }\n}\n\n","filePath":"src\\main\\java\\org\\CustomSounds\\AnimationIDs.java"},{"fileName":"CustomSoundsConfig.java","content":"package org.CustomSounds;\n\nimport net.runelite.client.config.*;\n\n@ConfigGroup(\"CustomDropSounds\")\npublic interface CustomSoundsConfig extends Config\n{\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Value drops\",\n\t\t\tdescription \u003d \"All the settings for drops\",\n\t\t\tposition \u003d 8\n\n\t)\n\tString valueDrops \u003d \"valueDrops\";\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Clue drops\",\n\t\t\tdescription \u003d \"All the settings for drops\",\n\t\t\tposition \u003d 7\n\n\t)\n\tString clueDrops \u003d \"clueDrops\";\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Spec weapon sounds\",\n\t\t\tdescription \u003d \"All the settings for Spec weapons\",\n\t\t\tposition \u003d 9\n\n\t)\n\tString specWeapon \u003d \"specWeapon\";\n\t@Range(max\u003d100)\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"masterVolume\",\n\t\t\tname \u003d \"Master Volume\",\n\t\t\tdescription \u003d \"Sets the master volume of all ground item sounds\",\n\t\t\tposition \u003d 0\n\t)\n\tdefault int masterVolume()\n\t{\n\t\treturn 50;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highlightSound\",\n\t\t\tname \u003d \"Highlight Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a highlighted (ground item plugin) item appears\",\n\t\t\tposition \u003d 1\n\t)\n\tdefault boolean highlightSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"petSound\",\n\t\t\tname \u003d \"Pet Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a pet item appears\",\n\t\t\tposition \u003d 2\n\t)\n\tdefault boolean petSound()\n\t{\n\t\treturn false;\n\t}\n\t\t@ConfigItem(\n\t\t\tkeyName \u003d \"maxHitBoolean\",\n\t\t\tname \u003d \"Maxhit\",\n\t\t\tdescription \u003d \"Enable/Disable Max Hit Sounds\",\n\t\t\tsection \u003d \"hitsplatToggleSection\",\n\t\t\tposition \u003d 3\n\t)\n\tdefault boolean maxHitBoolean() {return false;}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"announceDeath\",\n\t\t\tname \u003d \"Death sound\",\n\t\t\tdescription \u003d \"Enable/Disable Death Sound\",\n\t\t\tposition \u003d 4\n\t)\n\tdefault boolean announceDeath() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"announceCollectionLog\",\n\t\t\tname \u003d \"New collection log entry\",\n\t\t\tdescription \u003d \" This one relies on you having chat messages (included with the popup option) enabled in game settings!\",\n\t\t\tposition \u003d 5\n\t)\n\tdefault boolean announceCollectionLog() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"teleports\",\n\t\t\tname \u003d \"Teleport Sounds\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom sound for teleports (house tabs, capes, scrolls)\",\n\t\t\tposition \u003d 6\n\t)\n\tdefault boolean teleports() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"beginnerClueSound\",\n\t\t\tname \u003d \"Beginner Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a beginner clue item appears\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d clueDrops\n\t)\n\n\tdefault boolean beginnerClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"easyClueSound\",\n\t\t\tname \u003d \"Easy Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a easy clue item appears\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d clueDrops\n\t)\n\tdefault boolean easyClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"mediumClueSound\",\n\t\t\tname \u003d \"Medium Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a medium clue item appears\",\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d clueDrops\n\t)\n\tdefault boolean mediumClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"hardClueSound\",\n\t\t\tname \u003d \"Hard Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a hard clue item appears\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d clueDrops\n\t)\n\tdefault boolean hardClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"eliteClueSound\",\n\t\t\tname \u003d \"Elite Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a elite clue item appears\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d clueDrops\n\t)\n\tdefault boolean eliteClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"masterClueSound\",\n\t\t\tname \u003d \"Master Clue Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a master clue item appears\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d clueDrops\n\t)\n\tdefault boolean masterClueSound()\n\t{\n\t\treturn true;\n\t}\n\n\n\n\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowestValueSound\",\n\t\t\tname \u003d \"Lowest Value Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a lowest valued item appears\",\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault boolean lowestValueSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowestStart\",\n\t\t\tname \u003d \"Lowest Value starting GP\",\n\t\t\tdescription \u003d \"What is the starting gp you want to hear this sound\" ,\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int lowestStart() {\n\t\treturn 20000;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowestEnd\",\n\t\t\tname \u003d \"Lowest Value ending GP\",\n\t\t\tdescription \u003d \"What is the ending gp you want to hear this sound\" ,\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int lowestEnd() {\n\t\treturn 150000;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowValueSound\",\n\t\t\tname \u003d \"Low Value Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a low valued item appears\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault boolean lowValueSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowStart\",\n\t\t\tname \u003d \"Low Value starting GP\",\n\t\t\tdescription \u003d \"What is the starting gp you want to hear this sound\" ,\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int lowStart() {\n\t\treturn 150000;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lowEnd\",\n\t\t\tname \u003d \"Low Value ending GP\",\n\t\t\tdescription \u003d \"What is the ending gp you want to hear this sound\" ,\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int lowEnd() {\n\t\treturn 500000;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"mediumValueSound\",\n\t\t\tname \u003d \"Medium Value Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a medium valued item appears\",\n\t\t\tposition \u003d 6,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault boolean mediumValueSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"mediumStart\",\n\t\t\tname \u003d \"Medium Value starting GP\",\n\t\t\tdescription \u003d \"What is the starting gp you want to hear this sound\" ,\n\t\t\tposition \u003d 7,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int mediumStart() {\n\t\treturn 500000;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"mediumEnd\",\n\t\t\tname \u003d \"Medium Value ending GP\",\n\t\t\tdescription \u003d \"What is the ending gp you want to hear this sound\" ,\n\t\t\tposition \u003d 8,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int mediumEnd() {\n\t\treturn 1000000;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highValueSound\",\n\t\t\tname \u003d \"High Value Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a high valued item appears\",\n\t\t\tposition \u003d 9,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault boolean highValueSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highStart\",\n\t\t\tname \u003d \"High Value starting GP\",\n\t\t\tdescription \u003d \"What is the starting gp you want to hear this sound\" ,\n\t\t\tposition \u003d 10,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int highStart() {\n\t\treturn 1000000;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highEnd\",\n\t\t\tname \u003d \"High Value ending GP\",\n\t\t\tdescription \u003d \"What is the ending gp you want to hear this sound\" ,\n\t\t\tposition \u003d 11,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int highEnd() {\n\t\treturn 10000000;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highestValueSound\",\n\t\t\tname \u003d \"Highest Value Sound\",\n\t\t\tdescription \u003d \"Configure whether or not to play a sound when a highest valued item appears\",\n\t\t\tposition \u003d 12,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault boolean highestValueSound()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highestStart\",\n\t\t\tname \u003d \"Highest Value starting GP\",\n\t\t\tdescription \u003d \"What is the starting gp you want to hear this sound\" ,\n\t\t\tposition \u003d 13,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int highestStart() {\n\t\treturn 10000000;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"highestEnd\",\n\t\t\tname \u003d \"Highest Value ending GP\",\n\t\t\tdescription \u003d \"What is the ending gp you want to hear this sound\" ,\n\t\t\tposition \u003d 14,\n\t\t\tsection \u003d valueDrops\n\t)\n\tdefault int highestEnd() {\n\t\treturn 1000000000;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"zaryteCrossBow\",\n\t\t\tname \u003d \"Zaryte CrossBow Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Zaryte CrossBow spec sound\" ,\n\t\t\tposition \u003d 0,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean zaryteCrossBow() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"elderMaul\",\n\t\t\tname \u003d \"Elder Maul Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Elder Maul spec sound\" ,\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean elderMaul() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"dragonClaws\",\n\t\t\tname \u003d \"Dragon Claw Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Dragon Claw spec sound\" ,\n\t\t\tposition \u003d 2,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean dragonClaws() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"burnClaw\",\n\t\t\tname \u003d \"Burn Claw Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Burn Claw spec sound\",\n\t\t\tposition \u003d 3,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean burnClaw() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"horn\",\n\t\t\tname \u003d \"Horn Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Horn spec sound\",\n\t\t\tposition \u003d 4,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean horn() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"voidwaker\",\n\t\t\tname \u003d \"Voidwaker Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Voidwaker spec sound\",\n\t\t\tposition \u003d 5,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean voidwaker() {\n\t\treturn false;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"blowpipe\",\n\t\t\tname \u003d \"Blowpipe Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Blowpipe spec sound\",\n\t\t\tposition \u003d 6,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean blowpipe() {\n\t\treturn false;\n\t}\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"keris\",\n\t\t\tname \u003d \"Keris Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Keris spec sound\",\n\t\t\tposition \u003d 7,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean keris() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"bgs\",\n\t\t\tname \u003d \"BGS Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom BGS spec sound\",\n\t\t\tposition \u003d 8,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean bgs() {\n\t\treturn false;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"crystalHally\",\n\t\t\tname \u003d \"Crystal Halberd Spec\",\n\t\t\tdescription \u003d \"Configure whether or not you want to use a custom Crystal Halberd spec sound\",\n\t\t\tposition \u003d 9,\n\t\t\tsection \u003d specWeapon\n\t)\n\tdefault boolean crystalHally() {\n\t\treturn false;\n\t}\n\n\n}\n","filePath":"src\\main\\java\\org\\CustomSounds\\CustomSoundsConfig.java"},{"fileName":"CustomSoundsPlugin.java","content":"package org.CustomSounds;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.inject.Provides;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.events.*;\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.audio.AudioPlayer;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.game.ItemStack;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDependency;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.plugins.grounditems.GroundItemsConfig;\nimport net.runelite.client.plugins.grounditems.GroundItemsPlugin;\nimport net.runelite.client.plugins.loottracker.LootReceived;\nimport net.runelite.client.util.Text;\n\nimport javax.inject.Inject;\nimport javax.sound.sampled.Clip;\nimport javax.sound.sampled.FloatControl;\nimport javax.sound.sampled.LineUnavailableException;\nimport javax.sound.sampled.UnsupportedAudioFileException;\nimport java.io.*;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Pattern;\n\n@Slf4j\n@PluginDescriptor(\n\t\tname \u003d \"Custom Sounds\",\n\t\tdescription \u003d \"Play custom sound effects for item drops, pets, hits and more\",\n\t\ttags \u003d {\"sound\", \"effect\", \"item\", \"drop\", \"hit\", \"combat\"}\n)\n@PluginDependency(GroundItemsPlugin.class)\npublic class CustomSoundsPlugin extends Plugin\n{\n\t@Inject\n\tprivate CustomSoundsConfig config;\n\n\t@Inject\n\tprivate AudioPlayer audioPlayer;\n\n\n\t@Provides\n\tCustomSoundsConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(CustomSoundsConfig.class);\n\t}\n\n\t@Inject\n\tprivate GroundItemsConfig groundItemsConfig;\n\n\t@Inject\n\tprivate ScheduledExecutorService executor;\n\n\t@Inject\n\tprivate Client client;\n\t@Inject\n\tprivate ItemManager itemManager;\n\n\tprivate Map\u003cInteger, WeaponSound\u003e allWeapons \u003d new HashMap\u003c\u003e();\n\n\tprivate static final Pattern COLLECTION_LOG_ITEM_REGEX \u003d Pattern.compile(\"New item added to your collection log:.*\");\n\n\n\tprivate static final ImmutableList\u003cString\u003e PET_MESSAGES \u003d ImmutableList.of(\"You have a funny feeling like you\u0027re being followed\",\n\t\t\t\"You feel something weird sneaking into your backpack\",\n\t\t\t\"You have a funny feeling like you would have been followed\");\n\tprivate static final File CUSTOM_SOUNDS_DIR \u003d new File(RuneLite.RUNELITE_DIR.getPath() + File.separator + \"custom-drop-sounds\");\n\n\tprivate static final File HIGHLIGHTED_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"highlighted_sound.wav\");\n\tprivate static final File BEGINNER_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"beginner_clue_sound.wav\");\n\tprivate static final File EASY_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"easy_clue_sound.wav\");\n\tprivate static final File MEDIUM_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"medium_clue_sound.wav\");\n\tprivate static final File HARD_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"hard_clue_sound.wav\");\n\tprivate static final File ELITE_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"elite_clue_sound.wav\");\n\tprivate static final File MASTER_CLUE_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"master_clue_sound.wav\");\n\tprivate static final File LOW_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"low_sound.wav\");\n\tprivate static final File MEDIUM_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"medium_sound.wav\");\n\n\tprivate static final File PET_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"pet_sound.wav\");\n\tprivate static final File HIGH_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"high_sound.wav\");\n\tprivate static final File HIGHEST_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"highest_sound.wav\");\n\tprivate static final File LOWEST_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"lowest_sound.wav\");\n\tprivate static final File COLLECTIONLOG_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"CollectionLog.wav\");\n\tprivate static final File DIED_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"Died.wav\");\n\n\tprivate static final File MAX_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"Max.wav\");\n\n\tprivate static final File ZARYTE_CROSSBOW_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"zaryte_spec.wav\");\n\tprivate static final File ELDER_MAUL_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"elder_maul.wav\");\n\tprivate static final File DRAGON_CLAWS_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"dragon_claws.wav\");\n\tprivate static final File BURN_CLAW_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"burn_claws.wav\");\n\tprivate static final File HORN_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"horn_spec.wav\");\n\tprivate static final File VOIDWAKER_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"voidwaker.wav\");\n\tprivate static final File BLOWPIPE_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"blowpipe.wav\");\n\tprivate static final File KERIS_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"keris_spec.wav\");\n\tprivate static final File BGS_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"bgs_spec.wav\");\n\tprivate static final File CRYSTAL_HALLY_SPEC_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"crystal_hally_spec.wav\");\n\tprivate static final File TELEPORT_SOUND_FILE \u003d new File(CUSTOM_SOUNDS_DIR, \"teleport.wav\");\n\tprivate static final File[] SOUND_FILES \u003d new File[]{\n\t\t\tHIGHLIGHTED_SOUND_FILE,\n\t\t\tBEGINNER_CLUE_SOUND_FILE,\n\t\t\tEASY_CLUE_SOUND_FILE,\n\t\t\tMEDIUM_CLUE_SOUND_FILE,\n\t\t\tHARD_CLUE_SOUND_FILE,\n\t\t\tELITE_CLUE_SOUND_FILE,\n\t\t\tMASTER_CLUE_SOUND_FILE,\n\t\t\tLOW_SOUND_FILE,\n\t\t\tMEDIUM_SOUND_FILE,\n\t\t\tLOWEST_SOUND_FILE,\n\t\t\tHIGH_SOUND_FILE,\n\t\t\tHIGHEST_SOUND_FILE,\n\t\t\tPET_SOUND_FILE,\n\t\t\tMAX_SOUND_FILE,\n\t\t\tCOLLECTIONLOG_SOUND_FILE,\n\t\t\tDIED_SOUND_FILE,\n\t\t\tZARYTE_CROSSBOW_SPEC_SOUND_FILE,\n\t\t\tELDER_MAUL_SPEC_SOUND_FILE,\n\t\t\tDRAGON_CLAWS_SPEC_SOUND_FILE,\n\t\t\tBURN_CLAW_SPEC_SOUND_FILE,\n\t\t\tHORN_SPEC_SOUND_FILE,\n\t\t\tVOIDWAKER_SPEC_SOUND_FILE,\n\t\t\tBLOWPIPE_SPEC_SOUND_FILE,\n\t\t\tKERIS_SPEC_SOUND_FILE,\n\t\t\tBGS_SPEC_SOUND_FILE,\n\t\t\tCRYSTAL_HALLY_SPEC_SOUND_FILE,\n\t\t\tTELEPORT_SOUND_FILE\n\t};\n\n\n\tprivate List\u003cString\u003e highlightedItemsList \u003d new CopyOnWriteArrayList\u003c\u003e();\n\n\tprivate Clip clip \u003d null;\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\tinitSoundFiles();\n\t\tupdateHighlightedItemsList();\n\t\tinitAllWeapons();\n\t}\n\n\tprivate void initAllWeapons()\n\t{\n\t\t// Animation-based weapons\n\t\tallWeapons.put(AnimationIDs.ELDER_MAUL.Id,\n\t\t\t\tnew WeaponSound(ELDER_MAUL_SPEC_SOUND_FILE, () -\u003e config.elderMaul(), 2, true));\n\t\tallWeapons.put(AnimationIDs.DRAGON_CLAW.Id,\n\t\t\t\tnew WeaponSound(DRAGON_CLAWS_SPEC_SOUND_FILE, () -\u003e config.dragonClaws(), 1, true));\n\t\tallWeapons.put(AnimationIDs.HORN_HIT.Id,\n\t\t\t\tnew WeaponSound(HORN_SPEC_SOUND_FILE, () -\u003e config.horn(), 0, true));\n\t\tallWeapons.put(AnimationIDs.HORN_MISS.Id,\n\t\t\t\tnew WeaponSound(HORN_SPEC_SOUND_FILE, () -\u003e config.horn(), 0, true));\n\t\tallWeapons.put(AnimationIDs.BURN_CLAW.Id,\n\t\t\t\tnew WeaponSound(BURN_CLAW_SPEC_SOUND_FILE, () -\u003e config.burnClaw(), 0, true));\n\t\tallWeapons.put(AnimationIDs.VOIDWAKER.Id,\n\t\t\t\tnew WeaponSound(VOIDWAKER_SPEC_SOUND_FILE, () -\u003e config.voidwaker(), 1, true));\n\t\tallWeapons.put(AnimationIDs.KERIS.Id,\n\t\t\t\tnew WeaponSound(KERIS_SPEC_SOUND_FILE, () -\u003e config.keris(), 1, true));\n\t\tallWeapons.put(AnimationIDs.BGS.Id,\n\t\t\t\tnew WeaponSound(BGS_SPEC_SOUND_FILE, () -\u003e config.bgs(), 1, true));\n\t\tallWeapons.put(AnimationIDs.CRYSTAL_HALLY.Id,\n\t\t\t\tnew WeaponSound(CRYSTAL_HALLY_SPEC_SOUND_FILE, () -\u003e config.crystalHally(), 1, true));\n\n\t\t// Teleports - all use same sound and config\n\t\tallWeapons.put(AnimationIDs.HOUSE_TABS.Id,\n\t\t\t\tnew WeaponSound(TELEPORT_SOUND_FILE, () -\u003e config.teleports(), 1, true));\n\t\tallWeapons.put(AnimationIDs.CAPES.Id,\n\t\t\t\tnew WeaponSound(TELEPORT_SOUND_FILE, () -\u003e config.teleports(), 1, true));\n\t\tallWeapons.put(AnimationIDs.SCROLLS.Id,\n\t\t\t\tnew WeaponSound(TELEPORT_SOUND_FILE, () -\u003e config.teleports(), 1, true));\n\n\t\t// Sound-based weapons\n\t\tallWeapons.put(SoundIDs.BLOWPIPE.Id,\n\t\t\t\tnew WeaponSound(BLOWPIPE_SPEC_SOUND_FILE, () -\u003e config.blowpipe(), 1, false));\n\t\tallWeapons.put(SoundIDs.RUBY_BOLT.Id,\n\t\t\t\tnew WeaponSound(ZARYTE_CROSSBOW_SPEC_SOUND_FILE, () -\u003e config.zaryteCrossBow(), 1, false));\n\t}\n\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\thighlightedItemsList \u003d null;\n\t}\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged configChanged)\n\t{\n\n\t\tif (configChanged.getGroup().equals(\"grounditems\") \u0026\u0026 configChanged.getKey().equals(\"highlightedItems\"))\n\t\t{\n\t\t\tupdateHighlightedItemsList();\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onLootReceived(LootReceived lootReceived) {\n\t\tfor (ItemStack stack : lootReceived.getItems()) {\n\t\t\thandleItem(stack.getId(), stack.getQuantity());\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onHitsplatApplied(HitsplatApplied event)\n\t{\n\t\tActor actor \u003d event.getActor();\n\t\t// Skip if actor is null\n\t\tif (actor \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (config.maxHitBoolean() \u0026\u0026 event.getHitsplat().getHitsplatType()\u003d\u003dHitsplatID.DAMAGE_MAX_ME){\n\t\t\tplaySound(MAX_SOUND_FILE);\n\t\t}\n\n\t}\n\n\t@Subscribe\n\tpublic void onAnimationChanged(AnimationChanged event)\n\t{\n\t\tActor actor \u003d event.getActor();\n\n\t\tif (actor !\u003d client.getLocalPlayer())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint currentAnimationId \u003d actor.getAnimation();\n\n\t\tWeaponSound weapon \u003d allWeapons.get(currentAnimationId);\n\t\tif (weapon !\u003d null \u0026\u0026 weapon.isAnimationBased \u0026\u0026 weapon.configCheck.get())\n\t\t{\n\t\t\t// Schedule sound to play after specified delay\n\t\t\tscheduleDelayedSound(weapon.soundFile, weapon.delay);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onSoundEffectPlayed(SoundEffectPlayed event)\n\t{\n\t\tint soundId \u003d event.getSoundId();\n\n\t\tPlayer localPlayer \u003d client.getLocalPlayer();\n\t\tif (localPlayer \u003d\u003d null)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint currentAnimation \u003d localPlayer.getAnimation();\n\n\t\t// Check if this sound should be blocked (animation-based weapons)\n\t\tWeaponSound animationWeapon \u003d allWeapons.get(currentAnimation);\n\t\tif (animationWeapon !\u003d null \u0026\u0026 animationWeapon.isAnimationBased \u0026\u0026 animationWeapon.configCheck.get())\n\t\t{\n\t\t\tevent.consume(); // Block original sound\n\t\t\treturn;\n\t\t}\n\t\t// Check if this is a sound-based weapon\n\t\tWeaponSound soundWeapon \u003d allWeapons.get(soundId);\n\t\tif (soundWeapon !\u003d null \u0026\u0026 !soundWeapon.isAnimationBased \u0026\u0026 soundWeapon.configCheck.get())\n\t\t{\n\t\t\tevent.consume();\n\n\t\t\tif (soundWeapon.delay \u003e 0)\n\t\t\t{\n\t\t\t\tscheduleDelayedSound(soundWeapon.soundFile, soundWeapon.delay);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tplaySound(soundWeapon.soundFile);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void handleItem(int id, int quantity) {\n\t\tfinal ItemComposition itemComposition \u003d itemManager.getItemComposition(id);\n\t\tfinal String name \u003d itemComposition.getName().toLowerCase();\n\n\t\tif (config.highlightSound() \u0026\u0026 highlightedItemsList.contains(name))\n\t\t{\n\t\t\tplaySound(HIGHLIGHTED_SOUND_FILE);\n\t\t\treturn;\n\t\t}\n\n\t\tfinal int gePrice \u003d itemManager.getItemPrice(id) * quantity;\n\t\tfinal int haPrice \u003d itemComposition.getHaPrice() * quantity;\n\t\tfinal int value \u003d getValueByMode(gePrice, haPrice);\n\n\t\tif (config.beginnerClueSound() \u0026\u0026 name.contains(\"clue scroll (beginner)\")){\n\t\t\tplaySound(BEGINNER_CLUE_SOUND_FILE);\n\t\t}\n\t\tif (config.easyClueSound() \u0026\u0026 name.contains(\"clue scroll (easy)\")){\n\t\t\tplaySound(EASY_CLUE_SOUND_FILE);\n\t\t}\n\t\tif (config.mediumClueSound() \u0026\u0026 name.contains(\"clue scroll (medium)\")){\n\t\t\tplaySound(MEDIUM_CLUE_SOUND_FILE);\n\t\t}\n\t\tif (config.hardClueSound() \u0026\u0026 name.contains(\"clue scroll (hard)\")){\n\t\t\tplaySound(HARD_CLUE_SOUND_FILE);\n\t\t}\n\n\t\tif (config.eliteClueSound() \u0026\u0026 name.contains(\"clue scroll (elite)\")){\n\t\t\tplaySound(ELITE_CLUE_SOUND_FILE);\n\t\t}\n\t\tif (config.masterClueSound() \u0026\u0026 name.contains(\"clue scroll (master)\")){\n\t\t\tplaySound(MASTER_CLUE_SOUND_FILE);\n\t\t}\n\n\n\n\t\tif (config.lowestValueSound() \u0026\u0026 value \u003e\u003d config.lowestStart() \u0026\u0026 value \u003c config.lowestEnd())\n\t\t{\n\t\t\tplaySound(LOWEST_SOUND_FILE);\n\t\t}\n\t\tif (config.lowValueSound() \u0026\u0026 value \u003e\u003d config.lowStart() \u0026\u0026 value \u003c config.lowEnd())\n\t\t{\n\t\t\tplaySound(LOW_SOUND_FILE);\n\t\t}\n\t\tif (config.mediumValueSound() \u0026\u0026 value \u003e\u003d config.mediumStart() \u0026\u0026 value \u003c config.mediumEnd())\n\t\t{\n\t\t\tplaySound(MEDIUM_SOUND_FILE);\n\t\t}\n\t\tif (config.highValueSound() \u0026\u0026 value \u003e\u003d config.highStart() \u0026\u0026 value \u003c config.highEnd())\n\t\t{\n\t\t\tplaySound(HIGH_SOUND_FILE);\n\t\t}\n\t\tif (config.highestValueSound() \u0026\u0026 value \u003e\u003d config.highestStart() \u0026\u0026 value \u003c config.highestEnd())\n\t\t{\n\t\t\tplaySound(HIGHEST_SOUND_FILE);\n\t\t}\n\t}\n\n\tprivate void playSound(File f)\n\t{\n\t\tif (!f.exists()) {\n\t\t\tlog.warn(\"Sound file does not exist: {}\", f.getPath());\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\t// Convert percentage (0-100) to gain in dB\n\t\t\tfloat gainInDecibels \u003d convertToDecibels(config.masterVolume());\n\n\t\t\t// Call the instance method\n\t\t\taudioPlayer.play(f, gainInDecibels);\n\t\t} catch (IOException | UnsupportedAudioFileException | LineUnavailableException e) {\n\t\t\tlog.warn(\"Error playing sound {}: {}\", f.getName(), e.getMessage());\n\t\t}\n\n\t}\n\tprivate void scheduleDelayedSound(File soundFile, int delayTicks)\n\t{\n\t\t// Convert ticks to milliseconds (1 tick \u003d 600ms)\n\t\tint delayMs \u003d delayTicks * 600;\n\n\t\texecutor.schedule(() -\u003e {\n\t\t\tplaySound(soundFile); // Use your existing playSound method\n\t\t}, delayMs, TimeUnit.MILLISECONDS);\n\t}\n\n\n\n\tprivate float convertToDecibels(int volumePercentage) {\n\t\t// Avoid log(0)\n\t\tif (volumePercentage \u003c\u003d 0) {\n\t\t\treturn -80.0f; // Very quiet\n\t\t}\n\n\t\t// Convert percentage to a ratio (0.0 to 1.0)\n\t\tfloat ratio \u003d volumePercentage / 100.0f;\n\n\t\t// Convert ratio to decibels\n\t\treturn 20f * (float) Math.log10(ratio);\n\t}\n\n\t// sets volume using dB to linear conversion\n\tprivate void setVolume(int volume)\n\t{\n\t\tfloat vol \u003d volume/100.0f;\n\t\tvol *\u003d config.masterVolume()/100.0f;\n\t\tFloatControl gainControl \u003d (FloatControl)clip.getControl(FloatControl.Type.MASTER_GAIN);\n\t\tgainControl.setValue(20.0f * (float) Math.log10(vol));\n\t}\n\n\t// initialize sound files if they haven\u0027t been created yet\n\tprivate void initSoundFiles()\n\t{\n\t\tif (!CUSTOM_SOUNDS_DIR.exists())\n\t\t{\n\t\t\tCUSTOM_SOUNDS_DIR.mkdirs();\n\t\t}\n\n\t\tfor (File f : SOUND_FILES)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (f.exists()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tInputStream stream \u003d CustomSoundsPlugin.class.getClassLoader().getResourceAsStream(f.getName());\n\t\t\t\tOutputStream out \u003d new FileOutputStream(f);\n\t\t\t\tbyte[] buffer \u003d new byte[8 * 1024];\n\t\t\t\tint bytesRead;\n\t\t\t\twhile ((bytesRead \u003d stream.read(buffer)) !\u003d -1) {\n\t\t\t\t\tout.write(buffer, 0, bytesRead);\n\t\t\t\t}\n\t\t\t\tout.close();\n\t\t\t\tstream.close();\n\t\t\t}  catch (Exception e) {\n\t\t\t\tlog.debug(e + \": \" + f);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tprivate int getValueByMode(int gePrice, int haPrice)\n\t{\n\t\tswitch (groundItemsConfig.valueCalculationMode())\n\t\t{\n\t\t\tcase GE:\n\t\t\t\treturn gePrice;\n\t\t\tcase HA:\n\t\t\t\treturn haPrice;\n\t\t\tdefault: // Highest\n\t\t\t\treturn Math.max(gePrice, haPrice);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onActorDeath(ActorDeath actorDeath) {\n\t\tif (actorDeath.getActor() !\u003d client.getLocalPlayer()){\n\t\t\treturn;\n\t\t}\n\t\tif (config.announceDeath()) {\n\t\t\tplaySound(DIED_SOUND_FILE);\n\t\t}\n\t}\n\n\n\n\tprivate void updateHighlightedItemsList()\n\t{\n\t\tif (!groundItemsConfig.getHighlightItems().isEmpty())\n\t\t{\n\t\t\thighlightedItemsList \u003d Text.fromCSV(groundItemsConfig.getHighlightItems().toLowerCase());\n\t\t}\n\t}\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage event) {\n\t\tString chatMessage \u003d event.getMessage();\n\t\tif (event.getType() !\u003d ChatMessageType.GAMEMESSAGE\n\t\t\t\t\u0026\u0026 event.getType() !\u003d ChatMessageType.SPAM\n\t\t\t\t\u0026\u0026 event.getType() !\u003d ChatMessageType.TRADE\n\t\t\t\t\u0026\u0026 event.getType() !\u003d ChatMessageType.FRIENDSCHATNOTIFICATION)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (config.announceCollectionLog() \u0026\u0026 COLLECTION_LOG_ITEM_REGEX.matcher(event.getMessage()).matches()){\n\t\t\tplaySound(COLLECTIONLOG_SOUND_FILE);\n\t\t}\n\t\telse if (config.petSound() \u0026\u0026 PET_MESSAGES.stream().anyMatch(chatMessage::contains))\n\t\t{\n\t\t\tplaySound(PET_SOUND_FILE);\n\t\t}\n\n\t}\n\n}\n\n","filePath":"src\\main\\java\\org\\CustomSounds\\CustomSoundsPlugin.java"},{"fileName":"SoundIDs.java","content":"package org.CustomSounds;\n\npublic enum SoundIDs\n{\n    BLOWPIPE(800),\n    RUBY_BOLT(2911);\n\n    public final int Id;\n\n    SoundIDs(int id)\n    {\n        this.Id \u003d id;\n    }\n}\n","filePath":"src\\main\\java\\org\\CustomSounds\\SoundIDs.java"},{"fileName":"SoundManager.java","content":"package org.CustomSounds;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.sound.sampled.*;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Slf4j\npublic class SoundManager {\n    private final ExecutorService audioExecutor \u003d Executors.newSingleThreadExecutor();\n    private final Map\u003cFile, Clip\u003e clipCache \u003d new HashMap\u003c\u003e();\n    private final CustomSoundsConfig config;\n\n    public SoundManager(CustomSoundsConfig config) {\n        this.config \u003d config;\n    }\n\n    public void playSound(File soundFile) {\n        if (!soundFile.exists()) {\n            log.warn(\"Sound file does not exist: {}\", soundFile.getPath());\n            return;\n        }\n\n        audioExecutor.submit(() -\u003e {\n            try {\n                Clip audioClip \u003d getClip(soundFile);\n                if (audioClip.isRunning()) {\n                    audioClip.stop();\n                }\n                audioClip.setFramePosition(0);\n                setVolume(audioClip, config.masterVolume());\n                audioClip.start();\n            } catch (Exception e) {\n                log.warn(\"Error playing sound {}: {}\", soundFile.getName(), e.getMessage());\n            }\n        });\n    }\n\n    private Clip getClip(File soundFile) throws IOException, UnsupportedAudioFileException, LineUnavailableException {\n        // Check if we have a cached clip\n        if (clipCache.containsKey(soundFile)) {\n            return clipCache.get(soundFile);\n        }\n\n        // Create a new clip\n        try (AudioInputStream audioInputStream \u003d AudioSystem.getAudioInputStream(soundFile)) {\n            AudioFormat format \u003d audioInputStream.getFormat();\n            DataLine.Info info \u003d new DataLine.Info(Clip.class, format);\n            Clip clip \u003d (Clip) AudioSystem.getLine(info);\n            clip.open(audioInputStream);\n\n            // Cache the clip for future use\n            clipCache.put(soundFile, clip);\n\n            return clip;\n        }\n    }\n\n    private void setVolume(Clip clip, int volume) {\n        float vol \u003d volume / 100.0f;\n        if (clip.isControlSupported(FloatControl.Type.MASTER_GAIN)) {\n            FloatControl gainControl \u003d (FloatControl) clip.getControl(FloatControl.Type.MASTER_GAIN);\n            gainControl.setValue(20.0f * (float) Math.log10(vol));\n        }\n    }\n\n    public void shutdown() {\n        audioExecutor.shutdown();\n        // Clean up all cached clips\n        for (Clip clip : clipCache.values()) {\n            if (clip.isOpen()) {\n                clip.close();\n            }\n        }\n        clipCache.clear();\n    }\n}","filePath":"src\\main\\java\\org\\CustomSounds\\SoundManager.java"},{"fileName":"WeaponSound.java","content":"package org.CustomSounds;\n\nimport java.io.File;\nimport java.util.function.Supplier;\n\npublic class WeaponSound {\n    public final File soundFile;\n    public final Supplier\u003cBoolean\u003e configCheck;\n    public final int delay;\n    public final boolean isAnimationBased;\n\n    public WeaponSound(File soundFile, Supplier\u003cBoolean\u003e configCheck, int delay, boolean isAnimationBased) {\n        this.soundFile \u003d soundFile;\n        this.configCheck \u003d configCheck;\n        this.delay \u003d delay;\n        this.isAnimationBased \u003d isAnimationBased;\n    }\n}","filePath":"src\\main\\java\\org\\CustomSounds\\WeaponSound.java"},{"fileName":"PluginLauncher.java","content":"package org.CustomSounds;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class PluginLauncher\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(CustomSoundsPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\org\\CustomSounds\\PluginLauncher.java"}]},{"commit":"b4cd32e9dbffe4e9e989c3d4d46bbc25c741608d","repository":"https://github.com/kulcris/WOMSyncAPITrigger.git","internalName":"womsynctriggerscript","files":[{"fileName":"womsheetsbridgeconfig.java","content":"package com.womsheetsbridge;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"womsheetsbridge\")\npublic interface womsheetsbridgeconfig extends Config\n{\n    @ConfigItem(\n            keyName \u003d \"webAppUrl\",\n            name \u003d \"Apps Script Web App URL\",\n            description \u003d \"The Apps Script Web App deployment URL (the /exec link).\",\n            warning \u003d \"This plugin submits your IP address to a 3rd party website not controlled or verified by the RuneLite Developers.\"\n    )\n    default String webAppUrl()\n    {\n        return \"\";\n    }\n\n    @ConfigItem(\n            keyName \u003d \"enabled\",\n            name \u003d \"Enable bridge\",\n            description \u003d \"If disabled, no requests are sent.\"\n    )\n    default boolean enabled()\n    {\n        return true;\n    }\n    @ConfigItem(\n            keyName \u003d \"debug\",\n            name \u003d \"Debug logging\",\n            description \u003d \"Logs chat lines during pending WOM sync window and HTTP responses.\"\n    )\n    default boolean debug()\n    {\n        return false;\n    }\n}\n","filePath":"src\\main\\java\\com\\womsheetsbridge\\womsheetsbridgeconfig.java"},{"fileName":"womsheetsbridgeplugin.java","content":"package com.womsheetsbridge;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\n\nimport lombok.extern.slf4j.Slf4j;\n\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.events.ChatMessage;\nimport net.runelite.api.events.MenuOptionClicked;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.util.Text;\n\nimport okhttp3.Call;\nimport okhttp3.Callback;\nimport okhttp3.MediaType;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.Response;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"WOM  Sheets Bridge\",\n        description \u003d \"Triggers a Google Sheets Apps Script after the Wise Old Man \u0027Sync WOM Group\u0027 completes.\",\n        tags \u003d {\"wom\", \"wise old man\", \"google sheets\", \"apps script\"}\n)\npublic class womsheetsbridgeplugin extends Plugin\n{\n    private static final String SYNC_OPTION_TEXT \u003d \"Sync WOM Group\";\n    private static final long PENDING_WINDOW_MS \u003d 120_000; // 2 minutes\n    private static final long DEBOUNCE_MS \u003d 10_000;\n\n    private static final MediaType JSON \u003d MediaType.parse(\"application/json; charset\u003dutf-8\");\n\n    @Inject private womsheetsbridgeconfig config;\n    @Inject private Notifier notifier;\n\n    // Injected by RuneLite; do not construct your own OkHttpClient/Builder\n    @Inject private OkHttpClient okHttpClient;\n\n    // Kept, but no longer used for HTTP (enqueue is async). Safe to remove later if you want.\n    private final ExecutorService executor \u003d Executors.newSingleThreadExecutor();\n\n    private volatile boolean syncPending \u003d false;\n    private volatile long syncPendingUntilMs \u003d 0L;\n    private volatile long lastTriggerAtMs \u003d 0L;\n\n    @Provides\n    womsheetsbridgeconfig provideConfig(ConfigManager configManager)\n    {\n        return configManager.getConfig(womsheetsbridgeconfig.class);\n    }\n\n    @Override\n    protected void shutDown()\n    {\n        executor.shutdownNow();\n        syncPending \u003d false;\n        syncPendingUntilMs \u003d 0L;\n    }\n\n    @Subscribe\n    public void onMenuOptionClicked(MenuOptionClicked event)\n    {\n        if (!config.enabled())\n        {\n            return;\n        }\n\n        final String option \u003d event.getMenuOption();\n        if (option \u003d\u003d null || !option.contains(SYNC_OPTION_TEXT))\n        {\n            return;\n        }\n\n        syncPending \u003d true;\n        syncPendingUntilMs \u003d System.currentTimeMillis() + PENDING_WINDOW_MS;\n\n        if (config.debug())\n        {\n            log.info(\"[WOMSheetsBridge] Armed pending window for {}ms\", PENDING_WINDOW_MS);\n        }\n    }\n\n    @Subscribe\n    public void onChatMessage(ChatMessage event)\n    {\n        if (!config.enabled() || !syncPending)\n        {\n            return;\n        }\n\n        final long now \u003d System.currentTimeMillis();\n        if (now \u003e syncPendingUntilMs)\n        {\n            syncPending \u003d false;\n            syncPendingUntilMs \u003d 0L;\n\n            if (config.debug())\n            {\n                log.info(\"[WOMSheetsBridge] Pending window expired; disarmed\");\n            }\n            return;\n        }\n\n        final ChatMessageType type \u003d event.getType();\n        if (type !\u003d ChatMessageType.GAMEMESSAGE\n                \u0026\u0026 type !\u003d ChatMessageType.CONSOLE\n                \u0026\u0026 type !\u003d ChatMessageType.ENGINE\n                \u0026\u0026 type !\u003d ChatMessageType.MESBOX)\n        {\n            return;\n        }\n\n        final String raw \u003d event.getMessage();\n        final String msg \u003d raw \u003d\u003d null ? \"\" : Text.removeTags(raw).trim();\n        if (msg.isEmpty())\n        {\n            return;\n        }\n\n        if (config.debug() \u0026\u0026 msg.toLowerCase().startsWith(\"wom:\"))\n        {\n            log.info(\"[WOMSheetsBridge] pending chat: type\u003d{} msg\u003d{}\", type, msg);\n        }\n\n        // Check success match explicitly and log it\n        final boolean success \u003d looksLikeWomSyncSuccess(msg);\n        final boolean failure \u003d looksLikeWomSyncFailure(msg);\n\n        if (config.debug() \u0026\u0026 msg.toLowerCase().startsWith(\"wom:\"))\n        {\n            log.info(\"[WOMSheetsBridge] match check: success\u003d{} failure\u003d{}\", success, failure);\n        }\n\n        if (failure)\n        {\n            syncPending \u003d false;\n            syncPendingUntilMs \u003d 0L;\n\n            if (config.debug())\n            {\n                log.info(\"[WOMSheetsBridge] Detected WOM failure; disarmed. msg\u003d{}\", msg);\n            }\n            return;\n        }\n\n        if (!success)\n        {\n            return;\n        }\n\n        // Debounce\n        if (now - lastTriggerAtMs \u003c DEBOUNCE_MS)\n        {\n            if (config.debug())\n            {\n                log.info(\"[WOMSheetsBridge] Debounced success message ({}ms since last trigger)\", now - lastTriggerAtMs);\n            }\n            return;\n        }\n\n        final String webAppUrl \u003d config.webAppUrl();\n        if (webAppUrl \u003d\u003d null || webAppUrl.isBlank())\n        {\n            notifier.notify(\"WOM  Sheets Bridge: Configure Web App URL.\");\n            syncPending \u003d false;\n            syncPendingUntilMs \u003d 0L;\n            return;\n        }\n\n        syncPending \u003d false;\n        syncPendingUntilMs \u003d 0L;\n        lastTriggerAtMs \u003d now;\n\n        // enqueue() is async already; no executor needed here.\n        triggerAppsScript(webAppUrl);\n    }\n\n    private static boolean looksLikeWomSyncSuccess(String message)\n    {\n        // Example completion line:\n        // \"WOM: Synced 494 clan members. 0 added, 0 removed, 0 ranks changed, 0 ranks ignored.\"\n        final String lower \u003d message.trim().toLowerCase();\n        return lower.startsWith(\"wom:\")\n                \u0026\u0026 lower.contains(\"synced\")\n                \u0026\u0026 lower.contains(\"clan members\");\n    }\n\n    private static boolean looksLikeWomSyncFailure(String message)\n    {\n        final String lower \u003d message.trim().toLowerCase();\n        return lower.startsWith(\"wom:\")\n                \u0026\u0026 (lower.contains(\"failed\") || lower.contains(\"error\"));\n    }\n\n    private void triggerAppsScript(String webAppUrl)\n    {\n        // no secret, minimal payload\n        final String payload \u003d \"{}\";\n\n        try\n        {\n            // OkHttp 4+ prefers (String, MediaType). If your OkHttp is older, swap arg order.\n            final RequestBody body \u003d RequestBody.create(JSON, payload);\n\n            final Request request \u003d new Request.Builder()\n                    .url(webAppUrl)\n                    .post(body)\n                    .build();\n\n            if (config.debug())\n            {\n                log.info(\"[WOMSheetsBridge] HTTP POST (enqueue) -\u003e {}\", webAppUrl);\n            }\n\n            okHttpClient.newCall(request).enqueue(new Callback()\n            {\n                @Override\n                public void onFailure(Call call, IOException e)\n                {\n                    log.warn(\"[WOMSheetsBridge] Error calling Sheets endpoint\", e);\n                    notifier.notify(\"WOM  Sheets Bridge: Error calling Sheets endpoint.\");\n                }\n\n                @Override\n                public void onResponse(Call call, Response response) throws IOException\n                {\n                    try (Response r \u003d response)\n                    {\n                        final int code \u003d r.code();\n                        final String responseBody \u003d r.body() !\u003d null ? r.body().string() : \"\";\n\n                        if (config.debug())\n                        {\n                            log.info(\"[WOMSheetsBridge] HTTP \u003c- {} body\u003d{}\", code, responseBody);\n                        }\n\n                        if (code \u003c 200 || code \u003e\u003d 300)\n                        {\n                            notifier.notify(\"WOM  Sheets Bridge: Trigger failed (HTTP \" + code + \")\");\n                            return;\n                        }\n\n                        notifier.notify(\"WOM  Sheets Bridge: Sheets script triggered.\");\n                    }\n                }\n            });\n        }\n        catch (Exception e)\n        {\n            log.warn(\"[WOMSheetsBridge] Error building/requesting Sheets endpoint\", e);\n            notifier.notify(\"WOM  Sheets Bridge: Error calling Sheets endpoint.\");\n        }\n    }\n\n    // Unused currently, but kept since it was in your file\n    private static String escapeJson(String s)\n    {\n        return s.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n    }\n}\n","filePath":"src\\main\\java\\com\\womsheetsbridge\\womsheetsbridgeplugin.java"},{"fileName":"womsheetsbridgeplugintest.java","content":"package com.womsheetsbridge;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class womsheetsbridgeplugintest\n{\n    public static void main(String[] args) throws Exception\n    {\n        ExternalPluginManager.loadBuiltin(womsheetsbridgeplugin.class);\n        RuneLite.main(args);\n    }\n}","filePath":"src\\test\\java\\com\\womsheetsbridge\\womsheetsbridgeplugintest.java"}]},{"commit":"b9d65c7472e59224895ff13b05bd459c81661a32","repository":"https://github.com/Boredska/bank-item-stats-toggle.git","internalName":"item-stats-banking","files":[{"fileName":"BankItemStatsToggleConfig.java","content":"package com.toggleitemstats.banking;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"bankitemstatstoggle\")\npublic interface BankItemStatsToggleConfig extends Config\n{\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"consumableStats\",\n\t\t\tname \u003d \"Toggle consumable stats\",\n\t\t\tdescription \u003d \"Toggles tooltips for consumable items (food, boosts)\"\n\t)\n\tdefault boolean consumableStats()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"equipmentStats\",\n\t\t\tname \u003d \"Toggle equipment stats\",\n\t\t\tdescription \u003d \"Toggles tooltips for equipment items (combat bonuses, weight, prayer bonuses)\"\n\t)\n\tdefault boolean equipmentStats()\n\t{\n\t\treturn true;\n\t}\n}\n","filePath":"src\\main\\java\\com\\toggleitemstats\\banking\\BankItemStatsToggleConfig.java"},{"fileName":"BankItemStatsTogglePlugin.java","content":"package com.toggleitemstats.banking;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameState;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.WidgetClosed;\nimport net.runelite.api.events.WidgetLoaded;\nimport net.runelite.api.widgets.WidgetID;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Bank Item Stats Toggle\"\n)\npublic class BankItemStatsTogglePlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate BankItemStatsToggleConfig config;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tlog.info(\"Bank Item Stats Toggle started!\");\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tlog.info(\"Bank Item Stats Toggle stopped!\");\n\t}\n\n\t@Subscribe void onWidgetLoaded(WidgetLoaded event){\n\t\tif (event.getGroupId() \u003d\u003d WidgetID.BANK_GROUP_ID)\n\t\t{\n\t\t\tif (config.equipmentStats())\n\t\t\t{\n\t\t\t\tconfigManager.setConfiguration(\"itemstat\",\"equipmentStats\",true);\n\t\t\t}\n\n\t\t\tif (config.consumableStats())\n\t\t\t{\n\t\t\t\tconfigManager.setConfiguration(\"itemstat\",\"consumableStats\",true);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe void onWidgetClosed(WidgetClosed event){\n\t\tif(event.getGroupId() \u003d\u003d WidgetID.BANK_GROUP_ID){\n\t\t\tif (config.equipmentStats())\n\t\t\t{\n\t\t\t\tconfigManager.setConfiguration(\"itemstat\",\"equipmentStats\",false);\n\t\t\t}\n\n\t\t\tif (config.consumableStats())\n\t\t\t{\n\t\t\t\tconfigManager.setConfiguration(\"itemstat\",\"consumableStats\",false);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Provides\n\tBankItemStatsToggleConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(BankItemStatsToggleConfig.class);\n\t}\n}\n","filePath":"src\\main\\java\\com\\toggleitemstats\\banking\\BankItemStatsTogglePlugin.java"},{"fileName":"BankItemStatsTogglePluginTest.java","content":"package com.toggleitemstats.banking;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class BankItemStatsTogglePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(BankItemStatsTogglePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\toggleitemstats\\banking\\BankItemStatsTogglePluginTest.java"}]},{"commit":"13e1a7fea214cb04ff6dd7b0441f455f96f94d27","repository":"https://github.com/Krazune/LineOfSight.git","internalName":"line-of-sight","files":[{"fileName":"LineOfSightPlugin.java","content":"/*\n * BSD 2-Clause License\n *\n * Copyright (c) 2021, Miguel Sousa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.krazune.lineofsight;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\n\n@PluginDescriptor(\n\tname \u003d \"Line of Sight\",\n\tdescription \u003d \"Shows the player\u0027s line of sight.\",\n\ttags \u003d {\n\t\t\"line\",\n\t\t\"sight\",\n\t\t\"tiles\",\n\t\t\"markers\",\n\t\t\"range\"\n\t}\n)\npublic class LineOfSightPlugin extends Plugin\n{\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate TilesOverlay lineOfSightTilesOverlay;\n\n\t@Provides\n\tLineOfSightPluginConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(LineOfSightPluginConfig.class);\n\t}\n\n\t@Override\n\tprotected void startUp()\n\t{\n\t\toverlayManager.add(lineOfSightTilesOverlay);\n\t}\n\n\t@Override\n\tprotected void shutDown()\n\t{\n\t\toverlayManager.remove(lineOfSightTilesOverlay);\n\t}\n}\n","filePath":"src\\main\\java\\com\\krazune\\lineofsight\\LineOfSightPlugin.java"},{"fileName":"LineOfSightPluginConfig.java","content":"/*\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2021, Miguel Sousa\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice, this\r\n *    list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\npackage com.krazune.lineofsight;\r\n\r\nimport net.runelite.client.config.Alpha;\r\nimport net.runelite.client.config.Config;\r\nimport net.runelite.client.config.ConfigGroup;\r\nimport net.runelite.client.config.ConfigItem;\r\nimport net.runelite.client.config.ConfigSection;\r\nimport net.runelite.client.config.Range;\r\n\r\nimport java.awt.Color;\r\n\r\n@ConfigGroup(\"lineofsight\")\r\npublic interface LineOfSightPluginConfig extends Config\r\n{\r\n\t@ConfigSection(\r\n\t\tname \u003d \"General\",\r\n\t\tdescription \u003d \"General configurations\",\r\n\t\tposition \u003d 0\r\n\t)\r\n\tString generalSection \u003d \"General\";\r\n\r\n\t@ConfigSection(\r\n\t\tname \u003d \"Asymmetrical/PVP\",\r\n\t\tdescription \u003d \"Asymmetrical/PVP configurations\",\r\n\t\tposition \u003d 1,\r\n\t\tclosedByDefault \u003d true\r\n\t)\r\n\tString asymmetricalSection \u003d \"Asymmetrical/PVP\";\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 0,\r\n\t\tkeyName \u003d \"overlayRange\",\r\n\t\tname \u003d \"Range\",\r\n\t\tdescription \u003d \"Maximum range of the line of sight overlay.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\t@Range(\r\n\t\tmin \u003d 1,\r\n\t\tmax \u003d 10\r\n\t)\r\n\tdefault int overlayRange()\r\n\t{\r\n\t\treturn 10;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 1,\r\n\t\tkeyName \u003d \"outlineOnly\",\r\n\t\tname \u003d \"Outline only\",\r\n\t\tdescription \u003d \"Only show the outer borders.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\tdefault boolean outlineOnly()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 2,\r\n\t\tkeyName \u003d \"includePlayerTile\",\r\n\t\tname \u003d \"Include player tile\",\r\n\t\tdescription \u003d \"Include the current player\u0027s tile in the line of sight area. WARNING: You do not actually have line of sight in this tile.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\tdefault boolean includePlayerTile()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 3,\r\n\t\tkeyName \u003d \"borderColor\",\r\n\t\tname \u003d \"Border color\",\r\n\t\tdescription \u003d \"Color of the overlay\u0027s border.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\t@Alpha\r\n\tdefault Color borderColor()\r\n\t{\r\n\t\treturn Color.YELLOW;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 4,\r\n\t\tkeyName \u003d \"borderWidth\",\r\n\t\tname \u003d \"Border width\",\r\n\t\tdescription \u003d \"Width of the overlay\u0027s border.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\t@Range(\r\n\t\tmin \u003d 1\r\n\t)\r\n\tdefault int borderWidth()\r\n\t{\r\n\t\treturn 2;\r\n\t}\r\n\r\n\t// This is unnecessary, can be toggled based on fill alpha\r\n\t// Should be removed but might cause breaking changes (configurations) for current installations\r\n\t@ConfigItem(\r\n\t\tposition \u003d 5,\r\n\t\tkeyName \u003d \"showFill\",\r\n\t\tname \u003d \"Tile fill\",\r\n\t\tdescription \u003d \"Add fill color to tiles. WARNING: This is a costly feature that might lower your game\u0027s performance.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\tdefault boolean showFill()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 6,\r\n\t\tkeyName \u003d \"fillColor\",\r\n\t\tname \u003d \"Fill color\",\r\n\t\tdescription \u003d \"Color of the overlay\u0027s tiles.\",\r\n\t\tsection \u003d generalSection\r\n\t)\r\n\t@Alpha\r\n\tdefault Color fillColor()\r\n\t{\r\n\t\treturn new Color(255, 255, 0, 45);\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 0,\r\n\t\tkeyName \u003d \"includeAsymmetrical\",\r\n\t\tname \u003d \"Include asymmetrical/PVP tiles\",\r\n\t\tdescription \u003d \"Includes tiles that have line of sight to the player (this is how line of sight is calculated in PVP).\",\r\n\t\tsection \u003d asymmetricalSection\r\n\t)\r\n\tdefault boolean includeAsymmetrical()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 1,\r\n\t\tkeyName \u003d \"asymmetricalBorderColor\",\r\n\t\tname \u003d \"Border color\",\r\n\t\tdescription \u003d \"Color of the overlay\u0027s border.\",\r\n\t\tsection \u003d asymmetricalSection\r\n\t)\r\n\t@Alpha\r\n\tdefault Color asymmetricalBorderColor()\r\n\t{\r\n\t\treturn Color.RED;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 2,\r\n\t\tkeyName \u003d \"asymmetricalBorderWidth\",\r\n\t\tname \u003d \"Border width\",\r\n\t\tdescription \u003d \"Color of the overlay\u0027s border.\",\r\n\t\tsection \u003d asymmetricalSection\r\n\t)\r\n\t@Range(\r\n\t\t\tmin \u003d 1\r\n\t)\r\n\tdefault int asymmetricalBorderWidth()\r\n\t{\r\n\t\treturn 2;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 3,\r\n\t\tkeyName \u003d \"showAsymmetricalFill\",\r\n\t\tname \u003d \"Tile fill\",\r\n\t\tdescription \u003d \"Add fill color to tiles. WARNING: This is a costly feature that might lower your game\u0027s performance.\",\r\n\t\tsection \u003d asymmetricalSection\r\n\t)\r\n\tdefault boolean showAsymmetricalFill()\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\t@ConfigItem(\r\n\t\tposition \u003d 4,\r\n\t\tkeyName \u003d \"asymmetricalFillColor\",\r\n\t\tname \u003d \"Fill color\",\r\n\t\t\tdescription \u003d \"Color of the overlay\u0027s tiles.\",\r\n\t\tsection \u003d asymmetricalSection\r\n\t)\r\n\t@Alpha\r\n\tdefault Color asymmetricalFillColor()\r\n\t{\r\n\t\treturn new Color(255, 0, 0, 45);\r\n\t}\r\n}\r\n","filePath":"src\\main\\java\\com\\krazune\\lineofsight\\LineOfSightPluginConfig.java"},{"fileName":"TilesOverlay.java","content":"/*\r\n * BSD 2-Clause License\r\n *\r\n * Copyright (c) 2021, Miguel Sousa\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright notice, this\r\n *    list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\npackage com.krazune.lineofsight;\r\n\r\nimport java.awt.BasicStroke;\r\nimport java.awt.Color;\r\nimport java.awt.Dimension;\r\nimport java.awt.Graphics2D;\r\nimport java.awt.Polygon;\r\nimport java.awt.Stroke;\r\nimport javax.inject.Inject;\r\n\r\nimport net.runelite.api.Client;\r\nimport net.runelite.api.CollisionDataFlag;\r\nimport net.runelite.api.Perspective;\r\nimport net.runelite.api.Player;\r\nimport net.runelite.api.Point;\r\nimport net.runelite.api.WorldView;\r\nimport net.runelite.api.coords.LocalPoint;\r\nimport net.runelite.api.coords.WorldArea;\r\nimport net.runelite.api.coords.WorldPoint;\r\nimport net.runelite.client.ui.overlay.Overlay;\r\nimport net.runelite.client.ui.overlay.OverlayLayer;\r\nimport net.runelite.client.ui.overlay.OverlayPosition;\r\nimport net.runelite.client.ui.overlay.OverlayUtil;\r\n\r\n// One day I will refactor this mess but today is not that day\r\npublic class TilesOverlay extends Overlay\r\n{\r\n\tClient client;\r\n\r\n\tLineOfSightPluginConfig config;\r\n\r\n\t@Inject\r\n\tpublic TilesOverlay(Client client, LineOfSightPluginConfig config)\r\n\t{\r\n\t\tthis.client \u003d client;\r\n\t\tthis.config \u003d config;\r\n\r\n\t\tsetOverlayConfigurations();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Dimension render(Graphics2D graphics)\r\n\t{\r\n\t\tif (config.includeAsymmetrical())\r\n\t\t{\r\n\t\t\t// It\u0027s not efficient to render these separately from the regular LOS, but will do for now\r\n\t\t\trenderAsymmetricalLineOfSight(graphics);\r\n\t\t}\r\n\r\n\t\trenderLineOfSight(graphics);\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tprivate void setOverlayConfigurations()\r\n\t{\r\n\t\tsetPosition(OverlayPosition.DYNAMIC);\r\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\r\n\t}\r\n\r\n\tprivate void renderAsymmetricalLineOfSight(Graphics2D graphics)\r\n\t{\r\n\t\tWorldPoint[][] asymmetricalSightPoints \u003d getAsymmetricalSightWorldPoints();\r\n\r\n\t\trenderWorldPoints(\r\n\t\t\tgraphics,\r\n\t\t\tasymmetricalSightPoints,\r\n\t\t\tconfig.outlineOnly(),\r\n\t\t\tconfig.showAsymmetricalFill(),\r\n\t\t\tconfig.asymmetricalFillColor(),\r\n\t\t\tconfig.asymmetricalBorderColor(),\r\n\t\t\tconfig.asymmetricalBorderWidth()\r\n\t\t);\r\n\t}\r\n\r\n\tprivate void renderLineOfSight(Graphics2D graphics)\r\n\t{\r\n\t\tWorldPoint[][] sightPoints \u003d getSightWorldPoints(config.includePlayerTile());\r\n\r\n\t\trenderWorldPoints(\r\n\t\t\tgraphics,\r\n\t\t\tsightPoints,\r\n\t\t\tconfig.outlineOnly(),\r\n\t\t\tconfig.showFill(),\r\n\t\t\tconfig.fillColor(),\r\n\t\t\tconfig.borderColor(),\r\n\t\t\tconfig.borderWidth()\r\n\t\t);\r\n\t}\r\n\r\n\tprivate void renderWorldPoints(Graphics2D graphics, WorldPoint[][] sightPoints, boolean outlineOnly, boolean showFill, Color fillColor, Color borderColor, int borderWidth)\r\n\t{\r\n\t\tif (outlineOnly)\r\n\t\t{\r\n\t\t\trenderOutlineWorldPoints(graphics, sightPoints, showFill, fillColor, borderColor, borderWidth);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\trenderWorldPointsFullGrid(graphics, sightPoints, showFill, fillColor, borderColor, borderWidth);\r\n\t}\r\n\r\n\tprivate WorldPoint[][] getSightWorldPoints(boolean includePlayerTile)\r\n\t{\r\n\t\tint areaLength \u003d config.overlayRange() * 2 + 1;\r\n\t\tWorldPoint[][] worldPoints \u003d new WorldPoint[areaLength][areaLength];\r\n\r\n\t\tPlayer player \u003d client.getLocalPlayer();\r\n\r\n\t\tif (player \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn worldPoints;\r\n\t\t}\r\n\r\n\t\tWorldArea area \u003d player.getWorldArea();\r\n\r\n\t\tif (area \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn worldPoints;\r\n\t\t}\r\n\r\n\t\tint initialX \u003d area.getX() - config.overlayRange();\r\n\t\tint initialY \u003d area.getY() - config.overlayRange();\r\n\t\tint maxX \u003d area.getX() + config.overlayRange();\r\n\t\tint maxY \u003d area.getY() + config.overlayRange();\r\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\r\n\r\n\t\tfor (int x \u003d initialX, i \u003d 0; x \u003c\u003d maxX; ++x, ++i)\r\n\t\t{\r\n\t\t\tfor (int y \u003d initialY, j \u003d 0; y \u003c\u003d maxY; ++y, ++j)\r\n\t\t\t{\r\n\t\t\t\tWorldPoint newSightWorldPoint \u003d new WorldPoint(x, y, area.getPlane());\r\n\r\n\t\t\t\tif (area.hasLineOfSightTo(worldView, newSightWorldPoint) || (x \u003d\u003d area.getX() \u0026\u0026 y \u003d\u003d area.getY() \u0026\u0026 includePlayerTile))\r\n\t\t\t\t{\r\n\t\t\t\t\tworldPoints[i][j] \u003d newSightWorldPoint;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn worldPoints;\r\n\t}\r\n\r\n\tprivate WorldPoint[][] getAsymmetricalSightWorldPoints()\r\n\t{\r\n\t\tint areaLength \u003d config.overlayRange() * 2 + 1;\r\n\t\tWorldPoint[][] worldPoints \u003d new WorldPoint[areaLength][areaLength];\r\n\r\n\t\tPlayer player \u003d client.getLocalPlayer();\r\n\r\n\t\tif (player \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn worldPoints;\r\n\t\t}\r\n\r\n\t\tWorldArea area \u003d player.getWorldArea();\r\n\r\n\t\tif (area \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn worldPoints;\r\n\t\t}\r\n\r\n\t\tint initialX \u003d area.getX() - config.overlayRange();\r\n\t\tint initialY \u003d area.getY() - config.overlayRange();\r\n\t\tint maxX \u003d area.getX() + config.overlayRange();\r\n\t\tint maxY \u003d area.getY() + config.overlayRange();\r\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\r\n\t\tint[][] collisionFlags \u003d worldView.getCollisionMaps()[area.getPlane()].getFlags();\r\n\r\n\t\tfor (int x \u003d initialX, i \u003d 0; x \u003c\u003d maxX; ++x, ++i)\r\n\t\t{\r\n\t\t\tfor (int y \u003d initialY, j \u003d 0; y \u003c\u003d maxY; ++y, ++j)\r\n\t\t\t{\r\n\t\t\t\tif ((x \u003d\u003d area.getX() \u0026\u0026 y \u003d\u003d area.getY()))\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tWorldPoint newSightWorldPoint \u003d new WorldPoint(x, y, area.getPlane());\r\n\t\t\t\tboolean hasSight \u003d area.hasLineOfSightTo(worldView, newSightWorldPoint);\r\n\t\t\t\tboolean hasSightFromTarget \u003d newSightWorldPoint.toWorldArea().hasLineOfSightTo(worldView, area.toWorldPoint());\r\n\r\n\t\t\t\tif (!hasSight \u0026\u0026 hasSightFromTarget)\r\n\t\t\t\t{\r\n\t\t\t\t\tLocalPoint localPoint \u003d LocalPoint.fromWorld(worldView, newSightWorldPoint);\r\n\t\t\t\t\tint collisionFlag \u003d collisionFlags[localPoint.getSceneX()][localPoint.getSceneY()];\r\n\r\n\t\t\t\t\tif ((collisionFlag \u0026 CollisionDataFlag.BLOCK_LINE_OF_SIGHT_FULL) \u003d\u003d 0)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworldPoints[i][j] \u003d newSightWorldPoint;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn worldPoints;\r\n\t}\r\n\r\n\tprivate void renderOutlineWorldPoints(Graphics2D graphics, WorldPoint[][] sightPoints, boolean showFill, Color fillColor, Color borderColor, int borderWidth)\r\n\t{\r\n\t\tint areaLength \u003d config.overlayRange() * 2 + 1;\r\n\r\n\t\tfor (int x \u003d 0; x \u003c areaLength; ++x)\r\n\t\t{\r\n\t\t\tfor (int y \u003d 0; y \u003c areaLength; ++y)\r\n\t\t\t{\r\n\t\t\t\tif (sightPoints[x][y] \u003d\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (showFill)\r\n\t\t\t\t{\r\n\t\t\t\t\tPolygon tilePolygon \u003d generatePolygonFromWorldPoint(sightPoints[x][y]);\r\n\r\n\t\t\t\t\tif (tilePolygon !\u003d null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tgraphics.setColor(fillColor);\r\n\t\t\t\t\t\tgraphics.fill(tilePolygon);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboolean topBorder \u003d y \u003d\u003d areaLength - 1 || sightPoints[x][y + 1] \u003d\u003d null;\r\n\t\t\t\tboolean rightBorder \u003d x \u003d\u003d areaLength - 1 || sightPoints[x + 1][y] \u003d\u003d null;\r\n\t\t\t\tboolean bottomBorder \u003d y \u003d\u003d 0 || sightPoints[x][y - 1] \u003d\u003d null;\r\n\t\t\t\tboolean leftBorder \u003d x \u003d\u003d 0 || sightPoints[x - 1][y] \u003d\u003d null;\r\n\r\n\t\t\t\trenderWorldPointBorders(graphics, sightPoints[x][y], topBorder, rightBorder, bottomBorder, leftBorder, borderColor, borderWidth);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate Polygon generatePolygonFromWorldPoint(WorldPoint worldPoint)\r\n\t{\r\n\t\tLocalPoint localPoint \u003d LocalPoint.fromWorld(client.getTopLevelWorldView(), worldPoint);\r\n\r\n\t\tif (localPoint \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn Perspective.getCanvasTilePoly(client, localPoint);\r\n\t}\r\n\r\n\tprivate void renderWorldPointBorders(Graphics2D graphics, WorldPoint worldPoint, boolean topBorder, boolean rightBorder, boolean bottomBorder, boolean leftBorder, Color borderColor, int borderWidth)\r\n\t{\r\n\t\tWorldView worldView \u003d client.getTopLevelWorldView();\r\n\t\tLocalPoint localPoint \u003d LocalPoint.fromWorld(worldView, worldPoint);\r\n\r\n\t\tif (localPoint \u003d\u003d null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tint plane \u003d worldPoint.getPlane();\r\n\r\n\t\tgraphics.setColor(borderColor);\r\n\t\tgraphics.setStroke(new BasicStroke(borderWidth));\r\n\r\n\t\tif (topBorder)\r\n\t\t{\r\n\t\t\tPoint canvasPointA \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() - 64, localPoint.getY() + 64, worldView), plane);\r\n\r\n\t\t\tif (canvasPointA !\u003d null)\r\n\t\t\t{\r\n\t\t\t\tint x1 \u003d canvasPointA.getX();\r\n\t\t\t\tint y1 \u003d canvasPointA.getY();\r\n\r\n\t\t\t\tPoint canvasPointB \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() + 64, localPoint.getY() + 64, worldView), plane);\r\n\r\n\t\t\t\tif (canvasPointB !\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tint x2 \u003d canvasPointB.getX();\r\n\t\t\t\t\tint y2 \u003d canvasPointB.getY();\r\n\r\n\t\t\t\t\tgraphics.drawLine(x1, y1, x2, y2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (rightBorder)\r\n\t\t{\r\n\t\t\tPoint canvasPointA \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() + 64, localPoint.getY() - 64, worldView), plane);\r\n\r\n\t\t\tif (canvasPointA !\u003d null)\r\n\t\t\t{\r\n\t\t\t\tint x1 \u003d canvasPointA.getX();\r\n\t\t\t\tint y1 \u003d canvasPointA.getY();\r\n\r\n\t\t\t\tPoint canvasPointB \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() + 64, localPoint.getY() + 64, worldView), plane);\r\n\r\n\t\t\t\tif (canvasPointB !\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tint x2 \u003d canvasPointB.getX();\r\n\t\t\t\t\tint y2 \u003d canvasPointB.getY();\r\n\r\n\t\t\t\t\tgraphics.drawLine(x1, y1, x2, y2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (bottomBorder)\r\n\t\t{\r\n\t\t\tPoint canvasPointA \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() - 64, localPoint.getY() - 64, worldView), plane);\r\n\r\n\t\t\tif (canvasPointA !\u003d null)\r\n\t\t\t{\r\n\t\t\t\tint x1 \u003d canvasPointA.getX();\r\n\t\t\t\tint y1 \u003d canvasPointA.getY();\r\n\r\n\t\t\t\tPoint canvasPointB \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() + 64, localPoint.getY() - 64, worldView), plane);\r\n\r\n\t\t\t\tif (canvasPointB !\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tint x2 \u003d canvasPointB.getX();\r\n\t\t\t\t\tint y2 \u003d canvasPointB.getY();\r\n\r\n\t\t\t\t\tgraphics.drawLine(x1, y1, x2, y2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (leftBorder)\r\n\t\t{\r\n\t\t\tPoint canvasPointA \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() - 64, localPoint.getY() - 64, worldView), plane);\r\n\r\n\t\t\tif (canvasPointA !\u003d null)\r\n\t\t\t{\r\n\t\t\t\tint x1 \u003d canvasPointA.getX();\r\n\t\t\t\tint y1 \u003d canvasPointA.getY();\r\n\r\n\t\t\t\tPoint canvasPointB \u003d Perspective.localToCanvas(client, new LocalPoint(localPoint.getX() - 64, localPoint.getY() + 64, worldView), plane);\r\n\r\n\t\t\t\tif (canvasPointB !\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tint x2 \u003d canvasPointB.getX();\r\n\t\t\t\t\tint y2 \u003d canvasPointB.getY();\r\n\r\n\t\t\t\t\tgraphics.drawLine(x1, y1, x2, y2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void renderWorldPointsFullGrid(Graphics2D graphics, WorldPoint[][] sightPoints, boolean showFill, Color fillColor, Color borderColor, int borderWidth)\r\n\t{\r\n\t\tint areaLength \u003d config.overlayRange() * 2 + 1;\r\n\t\tColor transparent \u003d new Color(0, 0, 0, 0);\r\n\t\tStroke stroke \u003d new BasicStroke(borderWidth);\r\n\r\n\t\tfor (int x \u003d 0; x \u003c areaLength; ++x)\r\n\t\t{\r\n\t\t\tfor (int y \u003d 0; y \u003c areaLength; ++y)\r\n\t\t\t{\r\n\t\t\t\tif (sightPoints[x][y] \u003d\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tPolygon polygon \u003d generatePolygonFromWorldPoint(sightPoints[x][y]);\r\n\r\n\t\t\t\tif (polygon \u003d\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (showFill)\r\n\t\t\t\t{\r\n\t\t\t\t\tOverlayUtil.renderPolygon(graphics, polygon, borderColor, fillColor, stroke);\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (x \u003d\u003d 0 || x \u003d\u003d areaLength - 1 || y \u003d\u003d 0 || y \u003d\u003d areaLength - 1 || sightPoints[x + 1][y] \u003d\u003d null || sightPoints[x - 1][y] \u003d\u003d null || sightPoints[x][y + 1] \u003d\u003d null || sightPoints[x][y - 1] \u003d\u003d null)\r\n\t\t\t\t{\r\n\t\t\t\t\tOverlayUtil.renderPolygon(graphics, polygon, borderColor, transparent, stroke);\r\n\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsightPoints[x][y] \u003d null;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n","filePath":"src\\main\\java\\com\\krazune\\lineofsight\\TilesOverlay.java"},{"fileName":"LineOfSightPluginTest.java","content":"/*\n * BSD 2-Clause License\n *\n * Copyright (c) 2021, Miguel Sousa\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.krazune.lineofsight;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class LineOfSightPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(LineOfSightPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}\n","filePath":"src\\test\\java\\com\\krazune\\lineofsight\\LineOfSightPluginTest.java"}]},{"commit":"5a78264720b00e9e79f47f17e402953941c2b026","repository":"https://github.com/MarbleTurtle/FriendsExporter.git","internalName":"friends-exporter","files":[{"fileName":"FriendsExporterConfig.java","content":"package com.FriendsExporter;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\n\n@ConfigGroup(\"friendsexporter\")\npublic interface FriendsExporterConfig extends Config\n{\n\t@ConfigItem(\n\t\tkeyName \u003d \"lineStart\",\n\t\tname \u003d \"Line Start\",\n\t\tdescription \u003d \"What format to add at the beginning of a line.\",\n\t\tposition \u003d 1\n\t)\n\tdefault LineLeads lineLeads() {return LineLeads.None;}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"prev\",\n\t\tname \u003d \"Include Previous Names\",\n\t\tdescription \u003d \"Shows the previous name if available.\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean includePrevName() {return true;}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"note\",\n\t\tname \u003d \"Include Note\",\n\t\tdescription \u003d \"Includes note from Friend Notes plugin on Friends List export.\",\n\t\tposition \u003d 3\n\t)\n\tdefault boolean includeNote() {return true;}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"unrank\",\n\t\tname \u003d \"Show Unranked Players\",\n\t\tdescription \u003d \"Shows players that do not have a rank but are still friends in ranks export.\",\n\t\tposition \u003d 4\n\t)\n\tdefault boolean showUnranked() {return false;}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"separator\",\n\t\tname \u003d \"Separator\",\n\t\tdescription \u003d \"Separator between fields for a player.\",\n\t\tposition \u003d 5\n\t)\n\tdefault String getSeparator() {return \" - \";}\n}\n","filePath":"src\\main\\java\\com\\FriendsExporter\\FriendsExporterConfig.java"},{"fileName":"FriendsExporterPlugin.java","content":"package com.FriendsExporter;\n\nimport com.google.inject.Provides;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.ChatMessageType;\nimport net.runelite.api.Client;\nimport net.runelite.api.Friend;\nimport net.runelite.api.FriendsChatManager;\nimport net.runelite.api.FriendsChatMember;\nimport net.runelite.api.Ignore;\nimport net.runelite.api.Player;\nimport net.runelite.api.clan.ClanChannelMember;\nimport net.runelite.api.gameval.InterfaceID;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.menus.MenuManager;\nimport net.runelite.client.menus.WidgetMenuOption;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.util.Text;\nimport org.apache.commons.lang3.StringUtils;\n\nimport javax.inject.Inject;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.stream.Collectors;\n\nimport static net.runelite.client.RuneLite.RUNELITE_DIR;\n\n@Slf4j\n@PluginDescriptor(\n        name \u003d \"Friends Exporter\"\n)\npublic class FriendsExporterPlugin extends Plugin {\n\n    private static final String EXPORT \u003d \"Export\";\n    public static final File EXPORT_DIR \u003d new File(RUNELITE_DIR, \"player-exports\");\n\n    private static final WidgetMenuOption FRIENDS_LIST\n            \u003d new WidgetMenuOption(EXPORT, \"Friends List\", InterfaceID.Toplevel.STONE9, InterfaceID.ToplevelOsrsStretch.STONE9, InterfaceID.ToplevelPreEoc.STONE9);\n\n    private static final WidgetMenuOption IGNORE_LIST\n            \u003d new WidgetMenuOption(EXPORT, \"Ignore List\", InterfaceID.Toplevel.STONE9, InterfaceID.ToplevelOsrsStretch.STONE9, InterfaceID.ToplevelPreEoc.STONE9);\n\n    private static final WidgetMenuOption CHAT_CHANNEL_LIST\n            \u003d new WidgetMenuOption(EXPORT, \"Current Members\", InterfaceID.SideChannels.TAB_0);\n\n    private static final WidgetMenuOption CHAT_CHANNEL_RANKS\n            \u003d new WidgetMenuOption(EXPORT, \"Rank List\", InterfaceID.SideChannels.TAB_0);\n\n    private static final WidgetMenuOption CLAN_CHAT_MEMBERS\n            \u003d new WidgetMenuOption(EXPORT, \"Online Clan Members\", InterfaceID.SideChannels.TAB_1);\n\n    private static final WidgetMenuOption CLAN_CHAT_JOINS\n            \u003d new WidgetMenuOption(EXPORT, \"All Clan Members\", InterfaceID.SideChannels.TAB_1);\n\n    private static final WidgetMenuOption CLAN_CHAT_BANS\n            \u003d new WidgetMenuOption(EXPORT, \"Clan Bans\", InterfaceID.SideChannels.TAB_1);\n\n    private static final WidgetMenuOption CLAN_CHAT_EVENTS\n            \u003d new WidgetMenuOption(EXPORT, \"Clan Events\", InterfaceID.SideChannels.TAB_1);\n\n    private static final WidgetMenuOption EMOTES\n            \u003d new WidgetMenuOption(EXPORT, \"Local Players\", InterfaceID.Toplevel.STONE12, InterfaceID.ToplevelOsrsStretch.STONE12, InterfaceID.ToplevelPreEoc.STONE12);\n\n    private static final DateFormat TIME_FORMAT \u003d new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss\");\n    @Inject\n    private Client client;\n    @Inject\n    private MenuManager menuManager;\n    @Inject\n    private FriendsExporterConfig config;\n    @Inject\n    private ConfigManager configManager;\n    @Inject\n    private ScheduledExecutorService executor;\n\n    @Override\n    protected void startUp() throws Exception {\n        EXPORT_DIR.mkdirs();\n        addCustomOptions();\n    }\n\n    @Override\n    protected void shutDown() throws Exception {\n        removeCustomOptions();\n    }\n\n    static String format(Date date) {\n        synchronized(TIME_FORMAT) {\n            return TIME_FORMAT.format(date);\n        }\n    }\n\n    private void addCustomOptions() {\n        menuManager.addManagedCustomMenu(FRIENDS_LIST, e -\u003e exportFriendsList());\n        menuManager.addManagedCustomMenu(IGNORE_LIST, e -\u003e exportIgnoreList());\n        menuManager.addManagedCustomMenu(CHAT_CHANNEL_LIST, e -\u003e exportChatChannelMembers());\n        menuManager.addManagedCustomMenu(CHAT_CHANNEL_RANKS, e -\u003e exportChatChannelRankList());\n        menuManager.addManagedCustomMenu(CLAN_CHAT_MEMBERS, e -\u003e exportOnlineClanMembers());\n        menuManager.addManagedCustomMenu(CLAN_CHAT_JOINS, e -\u003e exportAllClanMembers());\n        menuManager.addManagedCustomMenu(CLAN_CHAT_BANS, e -\u003e exportClanBanList());\n        menuManager.addManagedCustomMenu(CLAN_CHAT_EVENTS, e -\u003e exportClanEventList());\n        menuManager.addManagedCustomMenu(EMOTES, e -\u003e exportLocalPlayers());\n    }\n\n    private void removeCustomOptions() {\n        menuManager.removeManagedCustomMenu(FRIENDS_LIST);\n        menuManager.removeManagedCustomMenu(IGNORE_LIST);\n        menuManager.removeManagedCustomMenu(CHAT_CHANNEL_LIST);\n        menuManager.removeManagedCustomMenu(CHAT_CHANNEL_RANKS);\n        menuManager.removeManagedCustomMenu(CLAN_CHAT_MEMBERS);\n        menuManager.removeManagedCustomMenu(CLAN_CHAT_JOINS);\n        menuManager.removeManagedCustomMenu(CLAN_CHAT_BANS);\n        menuManager.removeManagedCustomMenu(CLAN_CHAT_EVENTS);\n        menuManager.removeManagedCustomMenu(EMOTES);\n    }\n\n    /**\n     * Exports the player\u0027s Friends List.\n     */\n    private void exportFriendsList() {\n        String filename \u003d client.getLocalPlayer().getName() + \" Friends \" + format(new Date()) + \".txt\";\n        Friend[] array \u003d client.getFriendContainer().getMembers();\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d client.getFriendContainer().getMembers().length; ++i) {\n            PlayerListItem playerListItem \u003d new PlayerListItem();\n            playerListItem.setName(array[i].getName());\n            if (!StringUtils.isEmpty(array[i].getPrevName()) \u0026\u0026 config.includePrevName()) {\n                playerListItem.setPreviousName(array[i].getPrevName());\n            }\n            if (config.includeNote()) {\n                playerListItem.setNote(configManager.getConfiguration(\"friendNotes\", \"note_\" + playerListItem.getName()));\n            }\n            playerList.add(playerListItem);\n        }\n        exportList(filename, playerList);\n    }\n\n\n    /**\n     * Exports the player\u0027s Ignore List.\n     */\n    private void exportIgnoreList() {\n        String filename \u003d client.getLocalPlayer().getName() + \" Ignore \" + format(new Date()) + \".txt\";\n        Ignore[] array \u003d client.getIgnoreContainer().getMembers();\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d array.length; ++i) {\n            PlayerListItem playerListItem \u003d new PlayerListItem();\n            playerListItem.setName(array[i].getName());\n            if (!StringUtils.isEmpty(array[i].getPrevName()) \u0026\u0026 config.includePrevName()) {\n                playerListItem.setPreviousName(array[i].getPrevName());\n            }\n            if (config.includeNote()) {\n                playerListItem.setNote(configManager.getConfiguration(\"friendNotes\", \"note_\" + playerListItem.getName()));\n            }\n            playerList.add(playerListItem);\n        }\n        exportList(filename, playerList);\n    }\n\n\n    /**\n     * Exports all members of the player\u0027s own chat-channel. Requires the Chat-channel Setup widget to be open.\n     */\n    private void exportChatChannelRankList() {\n        Friend[] friendsList \u003d client.getFriendContainer().getMembers();\n        Widget channelSetupListWidget \u003d client.getWidget(InterfaceID.ChatchannelSetup.LIST);\n\n        if (channelSetupListWidget \u003d\u003d null) {\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Please open Chat-channel Setup found in the Chat-channel tab to export this list.\", \"\");\n            return;\n        }\n\n        Widget[] children \u003d channelSetupListWidget.getChildren();\n        if (children \u003d\u003d null) return;\n\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n\n        for (int i \u003d 0; i \u003c children.length/4; ++i) {\n            String rank \u003d children[(i * 4) + 1].getText();\n            if(!rank.equals(\"Not ranked\") || config.showUnranked()) {\n                String prevName \u003d \"\";\n                if (config.includePrevName()) {\n                    for (Friend friend : friendsList) {\n                        String friendName \u003d friend.getName();\n                        if (friendName.equals(children[(i * 4) + 2].getText())) {\n                            if (!StringUtils.isEmpty(friend.getPrevName())) {\n                                prevName \u003d friend.getPrevName();\n                            }\n                            break;\n                        }\n                    }\n                }\n\n                PlayerListItem playerListItem \u003d new PlayerListItem();\n                playerListItem.setName(children[(i * 4) + 2].getText());\n                playerListItem.setPreviousName(prevName);\n                playerListItem.setRank(!rank.equals(\"Not ranked\") ? rank : \"No Rank\");\n\n                playerList.add(playerListItem);\n            }\n        }\n        String filename \u003d client.getLocalPlayer().getName() + \" Ranks \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports players in the current Chat Channel. Player must be in a Chat Channel to have this available to them.\n     * Drops a message in the Game chat if the player is not currently in a Chat Channel.\n     *\n     * This was previously known as Friends Chat.\n     */\n    private void exportChatChannelMembers() {\n        FriendsChatManager manager \u003d client.getFriendsChatManager();\n        if (manager \u003d\u003d null) {\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Please join a Chat-channel to export this list.\", \"\");\n            return;\n        }\n\n        FriendsChatMember[] members \u003d manager.getMembers();\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d client.getFriendsChatManager().getMembers().length; ++i) {\n            String friendName \u003d members[i].getName();\n            PlayerListItem playerListItem \u003d new PlayerListItem();\n            playerListItem.setName(friendName);\n            playerList.add(playerListItem);\n        }\n        String filename \u003d manager.getOwner() + \" Members \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports loaded players around the user in-game.\n     */\n    private void exportLocalPlayers() {\n        List\u003cPlayer\u003e array \u003d client.getPlayers();\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d array.size(); ++i) {\n            String localName \u003d array.get(i).getName();\n            if(!localName.matches(client.getLocalPlayer().getName())) {\n                PlayerListItem playerListItem \u003d new PlayerListItem();\n                playerListItem.setName(localName);\n                playerList.add(playerListItem);\n            }\n        }\n        String filename \u003d client.getLocalPlayer().getName() + \" Local \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports currently online clan members.\n     */\n    private void exportOnlineClanMembers() {\n        List\u003cPlayerListItem\u003e playerList \u003d client.getClanChannel().getMembers().stream()\n                .sorted(Comparator.comparingInt((ClanChannelMember member) -\u003e member.getRank().getRank()).reversed()\n                        .thenComparing(ClanChannelMember::getName, String::compareToIgnoreCase))\n                .map((ClanChannelMember clanmate) -\u003e {\n                    PlayerListItem playerListItem \u003d new PlayerListItem();\n                    playerListItem.setName(clanmate.getName());\n                    playerListItem.setRank(client.getClanSettings().titleForRank(clanmate.getRank()).getName());\n                    return playerListItem;\n                })\n                .collect(Collectors.toList());\n        String filename \u003d client.getClanChannel().getName() + \" Members \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports the full list of current clan members, not just online. Requires the clan \"Members\" menu to be open.\n     * Drops a message into game chat if required Widget is not open.\n     */\n    private void exportAllClanMembers() {\n        Widget clanListWidget \u003d client.getWidget(InterfaceID.ClansMembers.NAME);\n        if (clanListWidget \u003d\u003d null) {\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Please open clan settings and navigate to the Members tab.\", \"\");\n            return;\n        }\n\n        Widget[] clanList \u003d clanListWidget.getChildren();\n\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 1; i \u003c clanList.length; i+\u003d3) {\n            PlayerListItem playerListItem \u003d new PlayerListItem();\n            playerListItem.setName(clanList[i].getText());\n            playerList.add(playerListItem);\n        }\n        String filename \u003d client.getClanChannel().getName() + \" Full Member List \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports the ban list for your clan. Drops a message in game chat if the Clan Banlist isn\u0027t open.\n     */\n    private void exportClanBanList() {\n        Widget clanBanListWidget \u003d client.getWidget(InterfaceID.ClansBanned.LIST_CONTENTS);\n        if (clanBanListWidget \u003d\u003d null) {\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Please open clan settings and navigate to the Bans tab.\", \"\");\n            return;\n        }\n\n        int banSize \u003d clanBanListWidget.getDynamicChildren().length/2;\n        List\u003cPlayerListItem\u003e playerList \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d banSize; ++i) {\n            String player \u003d clanBanListWidget.getDynamicChildren()[500+i].getText();\n            if (player.isEmpty()) {\n                break;\n            }\n            PlayerListItem playerListItem \u003d new PlayerListItem();\n            playerListItem.setName(player);\n            playerList.add(playerListItem);\n        }\n        String filename \u003d client.getClanChannel().getName() + \" Ban List \" + format(new Date()) + \".txt\";\n        exportList(filename, playerList);\n    }\n\n    /**\n     * Exports the clan event list. Drops a message in game chat if the clan events chat isn\u0027t open.\n     * This is the only function that does not currently use exportList and instead does everything in it.\n     */\n    private void exportClanEventList() {\n        Widget clanEventWidget \u003d client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_WORLD);\n        if (clanEventWidget \u003d\u003d null) {\n            client.addChatMessage(ChatMessageType.GAMEMESSAGE, \"\", \"Please open clan settings and navigate to the Events tab.\", \"\");\n            return;\n        }\n\n        int eventSize \u003d clanEventWidget.getDynamicChildren().length;\n        List\u003cString\u003e lines \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i !\u003d eventSize; ++i) {\n            String world \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_WORLD).getDynamicChildren()[i].getText());\n            String startDate \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_DATE).getDynamicChildren()[i].getText());\n            String startTime \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_TIME).getDynamicChildren()[i].getText());\n            String duration \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_DURATION).getDynamicChildren()[i].getText());\n            String type \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_TYPE).getDynamicChildren()[i].getText());\n            String focus \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_ACTIVITY).getDynamicChildren()[i].getText());\n            String subType \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_SUBTYPE).getDynamicChildren()[i].getText());\n            String ranks \u003d Text.removeTags(client.getWidget(InterfaceID.ClansEvents.LIST_CONTENTS_RANK_TO_VIEW).getDynamicChildren()[i].getText());\n\n            StringBuilder exportString \u003d new StringBuilder();\n            if (!config.lineLeads().equals(LineLeads.None)) {\n                exportString.append(i + config.lineLeads().getPunctuation());\n            }\n            exportString.append(\n                    focus + config.getSeparator() + type\n                            + config.getSeparator() + subType\n                            + config.getSeparator() + startDate + \" \" + startTime\n                            + config.getSeparator() + duration\n                            + config.getSeparator() + world\n                            + config.getSeparator() + ranks\n            );\n\n            lines.add(exportString.toString());\n        }\n        String filename \u003d client.getClanChannel().getName() + \" Events \" + format(new Date()) + \".txt\";\n        exportToFile(filename, lines);\n    }\n\n    /**\n     * Handles the exporting of a file for a list of {@link PlayerListItem}.\n     * @param filename The base filename\n     * @param playerList List of PlayerListItems containing relevant information for exporting\n     */\n    private void exportList(String filename, List\u003cPlayerListItem\u003e playerList) {\n        List\u003cString\u003e lines \u003d new ArrayList\u003c\u003e();\n        for (int i \u003d 0; i \u003c playerList.size(); i++) {\n            lines.add(getExportLineForPlayer(i + 1, playerList.get(i)));\n        }\n        exportToFile(filename, lines);\n    }\n\n    /**\n     * Writes a list of lines to a file using the injected executor.\n     */\n    private void exportToFile(String filename, List\u003cString\u003e lines) {\n        String filePath \u003d EXPORT_DIR + File.separator + filename;\n\n        executor.submit(() -\u003e {\n            File file \u003d new File(filePath);\n\n            if (file.exists() \u0026\u0026 !file.delete()) {\n                log.error(\"Failed to delete existing file: {}\", filePath);\n                return;\n            }\n\n            try (BufferedWriter writer \u003d new BufferedWriter(new FileWriter(file, true))) {\n                for (String line : lines) {\n                    writer.write(line);\n                    writer.newLine();\n                }\n            } catch (IOException e) {\n                log.error(\"Failed to write export file: {}\", filePath, e);\n            }\n        });\n    }\n\n\n    /**\n     * Puts together the text for one {@link PlayerListItem}.\n     *\n     * @param num the index to place as the front\n     * @param playerListItem the player wrapper with info\n     * @return the complete string to be exported for the player.\n     */\n    private String getExportLineForPlayer(int num, PlayerListItem playerListItem) {\n\n        String separator \u003d config.getSeparator();\n\n        StringBuilder exportString \u003d new StringBuilder();\n        if (!config.lineLeads().equals(LineLeads.None)) {\n            exportString.append(num).append(config.lineLeads().getPunctuation());\n        }\n\n        if (!playerListItem.getRank().isEmpty()) {\n            exportString.append(playerListItem.getRank()).append(separator);\n        }\n\n        exportString.append(playerListItem.getName());\n\n        if (!StringUtils.isEmpty(playerListItem.getPreviousName())) {\n            exportString.append(separator).append(playerListItem.getPreviousName());\n        }\n\n        if (!StringUtils.isEmpty(playerListItem.getNote())) {\n            exportString.append(separator).append(playerListItem.getNote());\n        }\n\n        return exportString.toString();\n    }\n\n    @Provides\n    FriendsExporterConfig provideConfig(ConfigManager configManager) {\n        return configManager.getConfig(FriendsExporterConfig.class);\n    }\n}","filePath":"src\\main\\java\\com\\FriendsExporter\\FriendsExporterPlugin.java"},{"fileName":"LineLeads.java","content":"package com.FriendsExporter;\n\npublic enum LineLeads {\n    None(\"None\", \"\"),\n    Number(\"[Number]\", \" \"),\n    Number1(\"[Number].\", \". \"),\n    Number2(\"[Number])\", \") \"),\n    Number3(\"[Number].)\", \".) \")\n    ;\n\n    private final String name;\n    private final String punctuation;\n\n    public String toString() {\n        return this.getName();\n    }\n\n    public String getName() {\n        return this.name;\n    }\n    public String getPunctuation() {return this.punctuation;}\n\n    private LineLeads(String name, String punctuation) {\n        this.name \u003d name;\n        this.punctuation \u003d punctuation;\n    }\n}\n","filePath":"src\\main\\java\\com\\FriendsExporter\\LineLeads.java"},{"fileName":"PlayerListItem.java","content":"package com.FriendsExporter;\n\n\nimport net.runelite.client.util.Text;\n\npublic class PlayerListItem {\n\n    private String name;\n    private String previousName;\n    private String note;\n    private String rank;\n\n\n    PlayerListItem() {\n        this.name \u003d \"\";\n        this.previousName \u003d \"\";\n        this.note \u003d \"\";\n        this.rank \u003d \"\";\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name \u003d Text.toJagexName(Text.removeTags(name));\n    }\n\n    public String getPreviousName() {\n        return previousName;\n    }\n\n    public void setPreviousName(String previousName) {\n        this.previousName \u003d Text.toJagexName(Text.removeTags(previousName));\n    }\n\n    public String getNote() {\n        return note;\n    }\n\n    public void setNote(String note) {\n        this.note \u003d note;\n    }\n\n    public String getRank() {\n        return rank;\n    }\n\n    public void setRank(String rank) {\n        this.rank \u003d rank;\n    }\n}\n","filePath":"src\\main\\java\\com\\FriendsExporter\\PlayerListItem.java"},{"fileName":"FriendsExporterPluginTest.java","content":"package com.FriendsExporter;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class FriendsExporterPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(FriendsExporterPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\FriendsExporter\\FriendsExporterPluginTest.java"}]},{"commit":"4cfd6848fa1f1f790a843bf461f7a4e9a9778427","repository":"https://github.com/tcpowell/interactable.git","internalName":"interactable","files":[{"fileName":"InteractableConfig.java","content":"package com.interactable;\n\nimport java.awt.Color;\nimport net.runelite.client.config.Alpha;\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.Keybind;\nimport net.runelite.client.config.Range;\n\n@ConfigGroup(InteractableConfig.GROUP)\npublic interface InteractableConfig extends Config\n{\n\tString GROUP \u003d \"interactableHints\";\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"toggleKeybind\",\n\t\tname \u003d \"Toggle Overlay\",\n\t\tdescription \u003d \"Binds a key (combination) to toggle the overlay.\",\n\t\tposition \u003d 0\n\t)\n\tdefault Keybind toggleKeybind()\n\t{\n\t\treturn Keybind.NOT_SET;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"autoHideTimeout\",\n\t\tname \u003d \"Auto Hide Timeout\",\n\t\tdescription \u003d \"Timeout (in seconds) where the overlay is hidden (0 \u003d do not auto hide)\",\n\t\tposition \u003d 1\n\t)\n\tdefault int autoHideTimeout()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showObject\",\n\t\tname \u003d \"Show Objects\",\n\t\tdescription \u003d \"Outline interactable Objects\",\n\t\tposition \u003d 2\n\t)\n\tdefault boolean showObject()\n\t{\n\t\treturn true;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tkeyName \u003d \"objectHighlightColor\",\n\t\tname \u003d \"Object Color\",\n\t\tdescription \u003d \"The color of the outline for Objects\",\n\t\tposition \u003d 3\n\t)\n\tdefault Color objectHighlightColor()\n\t{\n\t\treturn new Color(0, 255, 255, 160);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showAttackNpc\",\n\t\tname \u003d \"Show Attackable NPCs\",\n\t\tdescription \u003d \"Outline attackable NPCs\",\n\t\tposition \u003d 4\n\t)\n\tdefault boolean showAttackNpc()\n\t{\n\t\treturn true;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tkeyName \u003d \"attackNpcColor\",\n\t\tname \u003d \"Attackable NPC Color\",\n\t\tdescription \u003d \"The color of the outline for attackable NPCs\",\n\t\tposition \u003d 5\n\t)\n\tdefault Color attackNpcColor()\n\t{\n\t\treturn new Color(255, 10, 10, 160);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"showInteractableNpc\",\n\t\tname \u003d \"Show Interactable NPCs\",\n\t\tdescription \u003d \"Outline interactable NPCs\",\n\t\tposition \u003d 6\n\t)\n\tdefault boolean showInteractableNpc()\n\t{\n\t\treturn true;\n\t}\n\n\t@Alpha\n\t@ConfigItem(\n\t\tkeyName \u003d \"interactableNpcColor\",\n\t\tname \u003d \"Interactable NPC Color\",\n\t\tdescription \u003d \"The color of the outline for interactable NPCs\",\n\t\tposition \u003d 7\n\t)\n\tdefault Color interactableNpcColor()\n\t{\n\t\treturn new Color(255, 255, 10, 160);\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"borderWidth\",\n\t\tname \u003d \"Border Width\",\n\t\tdescription \u003d \"Width of the outlined border\",\n\t\tposition \u003d 8\n\t)\n\tdefault int borderWidth()\n\t{\n\t\treturn 4;\n\t}\n\n\t@ConfigItem(\n\t\tkeyName \u003d \"outlineFeather\",\n\t\tname \u003d \"Outline feather\",\n\t\tdescription \u003d \"Specify between 0-4 how much of the model outline should be faded\",\n\t\tposition \u003d 9\n\t)\n\t@Range(\n\t\tmax \u003d 4\n\t)\n\tdefault int outlineFeather()\n\t{\n\t\treturn 4;\n\t}\n\n}\n","filePath":"src\\main\\java\\com\\interactable\\InteractableConfig.java"},{"fileName":"InteractableOverlay.java","content":"package com.interactable;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport javax.inject.Inject;\nimport net.runelite.api.Client;\nimport net.runelite.api.NPC;\nimport net.runelite.api.TileObject;\nimport net.runelite.client.ui.overlay.Overlay;\nimport net.runelite.client.ui.overlay.OverlayLayer;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.OverlayPriority;\nimport net.runelite.client.ui.overlay.outline.ModelOutlineRenderer;\n\nclass InteractableOverlay extends Overlay\n{\n\tprivate final Client client;\n\tprivate final InteractablePlugin plugin;\n\tprivate final InteractableConfig config;\n\tprivate final ModelOutlineRenderer modelOutlineRenderer;\n\n\t@Inject\n\tprivate InteractableOverlay(Client client, InteractablePlugin plugin, InteractableConfig config, ModelOutlineRenderer modelOutlineRenderer)\n\t{\n\t\tthis.client \u003d client;\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\t\tthis.modelOutlineRenderer \u003d modelOutlineRenderer;\n\t\tsetPosition(OverlayPosition.DYNAMIC);\n\t\tsetLayer(OverlayLayer.ABOVE_SCENE);\n\t\tsetPriority(OverlayPriority.HIGH);\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (plugin.isShown())\n\t\t{\n\t\t\trenderObjects();\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tprivate void renderObjects()\n\t{\n\t\tplugin.generateObjectLists();\n\n\t\tif (config.showObject())\n\t\t{\n\t\t\tfor (TileObject object : plugin.getObjects())\n\t\t\t{\n\t\t\t\tif (object !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tmodelOutlineRenderer.drawOutline(object, config.borderWidth(), plugin.getCurrentObjectColor(), config.outlineFeather());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (config.showAttackNpc())\n\t\t{\n\t\t\tfor (NPC npc : plugin.getAttackNpcs())\n\t\t\t{\n\t\t\t\tif (npc !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tmodelOutlineRenderer.drawOutline(npc, config.borderWidth(), plugin.getCurrentNpcAttackColor(), config.outlineFeather());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (config.showInteractableNpc())\n\t\t{\n\t\t\tfor (NPC npc : plugin.getInteractNpcs())\n\t\t\t{\n\t\t\t\tif (npc !\u003d null)\n\t\t\t\t{\n\t\t\t\t\tmodelOutlineRenderer.drawOutline(npc, config.borderWidth(), plugin.getCurrentNpcInteractColor(), config.outlineFeather());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t}\n}","filePath":"src\\main\\java\\com\\interactable\\InteractableOverlay.java"},{"fileName":"InteractablePlugin.java","content":"package com.interactable;\n\nimport com.google.common.base.Strings;\nimport com.google.inject.Provides;\nimport java.awt.Color;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.inject.Inject;\nimport lombok.AccessLevel;\nimport lombok.Getter;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Constants;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.GroundObject;\nimport net.runelite.api.NPC;\nimport net.runelite.api.NPCComposition;\nimport net.runelite.api.ObjectComposition;\nimport net.runelite.api.Player;\nimport net.runelite.api.Scene;\nimport net.runelite.api.Tile;\nimport net.runelite.api.TileObject;\nimport net.runelite.api.WallObject;\nimport net.runelite.api.events.ClientTick;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.input.KeyManager;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.util.HotkeyListener;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Interactable Hints\"\n)\npublic class InteractablePlugin extends Plugin\n{\n\tprivate int MAX_DISTANCE \u003d 2350;\n\tprivate int remainingClientTicks \u003d -1;\n\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate boolean shown \u003d false;\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate Color currentObjectColor;\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate Color currentNpcAttackColor;\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate Color currentNpcInteractColor;\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate List\u003cTileObject\u003e objects \u003d new ArrayList\u003cTileObject\u003e();\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate List\u003cNPC\u003e attackNpcs \u003d new ArrayList\u003cNPC\u003e();\n\t@Getter(AccessLevel.PACKAGE)\n\tprivate List\u003cNPC\u003e interactNpcs \u003d new ArrayList\u003cNPC\u003e();\n\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate InteractableOverlay interactableOverlay;\n\n\t@Inject\n\tprivate InteractableConfig config;\n\n\t@Inject\n\tprivate KeyManager keyManager;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tshown \u003d false;\n\t\tkeyManager.registerKeyListener(hotkeyListener);\n\t\toverlayManager.add(interactableOverlay);\n\t\tobjects \u003d new ArrayList\u003cTileObject\u003e();\n\t\tattackNpcs \u003d new ArrayList\u003cNPC\u003e();\n\t\tinteractNpcs \u003d new ArrayList\u003cNPC\u003e();\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tshown \u003d false;\n\t\tkeyManager.unregisterKeyListener(hotkeyListener);\n\t\toverlayManager.remove(interactableOverlay);\n\t\tobjects \u003d null;\n\t\tattackNpcs \u003d null;\n\t\tinteractNpcs \u003d null;\n\t}\n\n\t@Subscribe\n\tpublic void onClientTick(ClientTick clientTick)\n\t{\n\t\tif (config.autoHideTimeout() \u003e 0 \u0026\u0026 shown)\n\t\t{\n\t\t\tif (remainingClientTicks \u003e 50)\n\t\t\t{\n\t\t\t\tremainingClientTicks--;\n\t\t\t}\n\t\t\telse if (remainingClientTicks \u003e 0)\n\t\t\t{\n\t\t\t\tfadeOut();\n\t\t\t\tremainingClientTicks--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tshown \u003d false;\n\t\t\t\tlog.debug(\"Interactable Hints auto-hide triggered\");\n\t\t\t\tcurrentObjectColor \u003d config.objectHighlightColor();\n\t\t\t\tcurrentNpcAttackColor \u003d config.attackNpcColor();\n\t\t\t\tcurrentNpcInteractColor \u003d config.interactableNpcColor();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void fadeOut()\n\t{\n\t\tint newObjectAlpha \u003d config.objectHighlightColor().getAlpha() * remainingClientTicks / 50;\n\t\tcurrentObjectColor \u003d new Color(config.objectHighlightColor().getRed(), config.objectHighlightColor().getGreen(), config.objectHighlightColor().getBlue(), newObjectAlpha);\n\n\t\tint newAttackAlpha \u003d config.attackNpcColor().getAlpha() * remainingClientTicks / 50;\n\t\tcurrentNpcAttackColor \u003d new Color(config.attackNpcColor().getRed(), config.attackNpcColor().getGreen(), config.attackNpcColor().getBlue(), newAttackAlpha);\n\n\t\tint newInteractAlpha \u003d config.interactableNpcColor().getAlpha() * remainingClientTicks / 50;\n\t\tcurrentNpcInteractColor \u003d new Color(config.interactableNpcColor().getRed(), config.interactableNpcColor().getGreen(), config.interactableNpcColor().getBlue(), newInteractAlpha);\n\t}\n\n\t@Provides\n\tInteractableConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(InteractableConfig.class);\n\t}\n\n\tprivate final HotkeyListener hotkeyListener \u003d new HotkeyListener(() -\u003e config.toggleKeybind())\n\t{\n\t\t@Override\n\t\tpublic void hotkeyPressed()\n\t\t{\n\t\t\tcurrentObjectColor \u003d config.objectHighlightColor();\n\t\t\tcurrentNpcAttackColor \u003d config.attackNpcColor();\n\t\t\tcurrentNpcInteractColor \u003d config.interactableNpcColor();\n\n\t\t\tshown \u003d !shown;\n\t\t\tlog.debug(\"Interactable Hints overlay toggled to \" + shown);\n\t\t\tif (shown)\n\t\t\t{\n\t\t\t\tremainingClientTicks \u003d config.autoHideTimeout() * 50;\n\t\t\t}\n\t\t}\n\t};\n\n\tvoid generateObjectLists()\n\t{\n\t\tobjects \u003d new ArrayList\u003cTileObject\u003e();\n\t\tattackNpcs \u003d new ArrayList\u003cNPC\u003e();\n\t\tinteractNpcs \u003d new ArrayList\u003cNPC\u003e();\n\n\t\tfor (NPC npc : client.getNpcs())\n\t\t{\n\t\t\tNPCComposition npcComp \u003d replaceNpcImposters(npc.getComposition());\n\n\t\t\tif (npcCompCheck(npcComp) \u0026\u0026 npcCheck(npc))\n\t\t\t{\n\t\t\t\tif (npcAttackable(npcComp))\n\t\t\t\t{\n\t\t\t\t\tattackNpcs.add(npc);\n\t\t\t\t}\n\t\t\t\telse if (npcInteractable(npcComp))\n\t\t\t\t{\n\t\t\t\t\tinteractNpcs.add(npc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tScene scene \u003d client.getScene();\n\t\tTile[][] tiles \u003d scene.getTiles()[client.getPlane()];\n\n\t\tfor (int x \u003d 0; x \u003c Constants.SCENE_SIZE; ++x)\n\t\t{\n\t\t\tfor (int y \u003d 0; y \u003c Constants.SCENE_SIZE; ++y)\n\t\t\t{\n\t\t\t\tTile tile \u003d tiles[x][y];\n\t\t\t\tif (tile \u003d\u003d null)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (GameObject gameObject : tile.getGameObjects())\n\t\t\t\t{\n\t\t\t\t\tif (gameObjectCheck(gameObject) \u0026\u0026 !(gameObject.getRenderable() instanceof Player) \u0026\u0026 !(gameObject.getRenderable() instanceof NPC))\n\t\t\t\t\t{\n\t\t\t\t\t\tint objectId \u003d gameObject.getId();\n\t\t\t\t\t\tObjectComposition comp \u003d replaceObjectImposters(client.getObjectDefinition(objectId));\n\n\t\t\t\t\t\tif (objectCompCheck(comp))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!objects.contains(gameObject))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tobjects.add(gameObject);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tWallObject wallObject \u003d tile.getWallObject();\n\n\t\t\t\tif (gameObjectCheck(wallObject))\n\t\t\t\t{\n\t\t\t\t\tint objectId \u003d wallObject.getId();\n\t\t\t\t\tObjectComposition comp \u003d replaceObjectImposters(client.getObjectDefinition(objectId));\n\n\t\t\t\t\tif (objectCompCheck(comp))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!objects.contains(wallObject))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobjects.add(wallObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tGroundObject groundObject \u003d tile.getGroundObject();\n\n\t\t\t\tif (gameObjectCheck(groundObject))\n\t\t\t\t{\n\t\t\t\t\tint objectId \u003d groundObject.getId();\n\t\t\t\t\tObjectComposition comp \u003d replaceObjectImposters(client.getObjectDefinition(objectId));\n\n\t\t\t\t\tif (objectCompCheck(comp))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!objects.contains(groundObject))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobjects.add(groundObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean objectCompCheck(ObjectComposition comp)\n\t{\n\t\treturn (comp !\u003d null \u0026\u0026 !Strings.isNullOrEmpty(comp.getName()) \u0026\u0026 !comp.getName().equals(\"null\") \u0026\u0026 objectActionCheck(comp));\n\t}\n\n\tprivate boolean npcCompCheck(NPCComposition comp)\n\t{\n\t\treturn (comp !\u003d null \u0026\u0026 !Strings.isNullOrEmpty(comp.getName()) \u0026\u0026 !comp.getName().equals(\"null\"));\n\t}\n\n\tprivate boolean gameObjectCheck(TileObject object)\n\t{\n\t\treturn object !\u003d null \u0026\u0026 object.getLocalLocation().distanceTo(client.getLocalPlayer().getLocalLocation()) \u003c\u003d MAX_DISTANCE;\n\t}\n\n\tprivate boolean npcCheck(NPC npc)\n\t{\n\t\treturn npc !\u003d null \u0026\u0026 npc.getLocalLocation().distanceTo(client.getLocalPlayer().getLocalLocation()) \u003c\u003d MAX_DISTANCE;\n\t}\n\n\tprivate ObjectComposition replaceObjectImposters(ObjectComposition comp)\n\t{\n\t\treturn comp.getImpostorIds() !\u003d null ? comp.getImpostor() : comp;\n\t}\n\n\tprivate NPCComposition replaceNpcImposters(NPCComposition comp)\n\t{\n\t\treturn comp.getConfigs() !\u003d null \u0026\u0026 comp.transform() !\u003d null ? comp.transform() : comp;\n\t}\n\n\tprivate boolean objectActionCheck(ObjectComposition comp)\n\t{\n\t\tfor (String action : comp.getActions())\n\t\t{\n\t\t\tif (!Strings.isNullOrEmpty(action) \u0026\u0026 !action.equals(\"null\"))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean npcAttackable(NPCComposition comp)\n\t{\n\t\tfor (String action : comp.getActions())\n\t\t{\n\t\t\tif (!Strings.isNullOrEmpty(action) \u0026\u0026 action.equals(\"Attack\") \u0026\u0026 client.getVarpValue(1306) !\u003d3)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean npcInteractable(NPCComposition comp)\n\t{\n\t\tfor (String action : comp.getActions())\n\t\t{\n\t\t\tif (!Strings.isNullOrEmpty(action) \u0026\u0026 !action.equals(\"null\") \u0026\u0026 !action.equals(\"Attack\"))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n","filePath":"src\\main\\java\\com\\interactable\\InteractablePlugin.java"},{"fileName":"InteractablePluginTest.java","content":"package com.interactable;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class InteractablePluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(InteractablePlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\interactable\\InteractablePluginTest.java"}]},{"commit":"d383983a88752621b6605cad55fd3dde8e3c5e14","repository":"https://github.com/IanMcNelly/maniacal-hunter.git","internalName":"maniacal-hunter","files":[{"fileName":"DisplayMode.java","content":"package com.maniacalhunter;\n\npublic enum DisplayMode\n{\n\tSESSION_ONLY,\n\tAGGREGATE_ONLY,\n\tBOTH\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\DisplayMode.java"},{"fileName":"ManiacalHunterConfig.java","content":"package com.maniacalhunter;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.ConfigSection;\n\n@ConfigGroup(\"maniacalhunter\")\npublic interface ManiacalHunterConfig extends Config\n{\n\t@ConfigSection(\n\t\t\tname \u003d \"Display\",\n\t\t\tdescription \u003d \"Configure which stats to display\",\n\t\t\tposition \u003d 0\n\t)\n\tString displaySection \u003d \"display\";\n\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"condensedMode\",\n\t\t\tname \u003d \"Condensed Mode\",\n\t\t\tdescription \u003d \"Display stats in an infobox.\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean condensedMode()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Auto Reset\",\n\t\t\tdescription \u003d \"Automatically reset the session\",\n\t\t\tposition \u003d 4\n\t)\n\tString autoResetSection \u003d \"autoReset\";\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"autoResetMode\",\n\t\t\tname \u003d \"Auto Reset Session\",\n\t\t\tdescription \u003d \"Automatically reset the session upon entering or leaving the area\",\n\t\t\tsection \u003d autoResetSection\n\t)\n\tdefault ResetMode autoResetMode()\n\t{\n\t\treturn ResetMode.NEVER;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showMonkeysCaught\",\n\t\t\tname \u003d \"Show Monkeys Caught\",\n\t\t\tdescription \u003d \"Show the total number of monkeys caught\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showMonkeysCaught()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showTrapsLaid\",\n\t\t\tname \u003d \"Show Traps Laid\",\n\t\t\tdescription \u003d \"Show the total number of traps laid\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showTrapsLaid()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showLastTrapStatus\",\n\t\t\tname \u003d \"Show Last Trap Status\",\n\t\t\tdescription \u003d \"Show the status of the last trap\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showLastTrapStatus()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showSuccessRate\",\n\t\t\tname \u003d \"Show Success Rate\",\n\t\t\tdescription \u003d \"Show the success rate of catching monkeys\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showSuccessRate()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showMonkeysPerHour\",\n\t\t\tname \u003d \"Show Monkeys/Hour\",\n\t\t\tdescription \u003d \"Show the number of monkeys caught per hour\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showMonkeysPerHour()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showPerfectTails\",\n\t\t\tname \u003d \"Show Perfect Tails\",\n\t\t\tdescription \u003d \"Show the number of perfect tails received\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showPerfectTails()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showDamagedTails\",\n\t\t\tname \u003d \"Show Damaged Tails\",\n\t\t\tdescription \u003d \"Show the number of damaged tails received\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showDamagedTails()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showLuck\",\n\t\t\tname \u003d \"Show Luck\",\n\t\t\tdescription \u003d \"Show your current luck in receiving a perfect tail\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showLuck()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"showAvgCatchTime\",\n\t\t\tname \u003d \"Show Avg. Catch Time\",\n\t\t\tdescription \u003d \"Show the average time to catch a monkey\",\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault boolean showAvgCatchTime()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"displayMode\",\n\t\t\tname \u003d \"Display Mode\",\n\t\t\tdescription \u003d \"Choose how to display stats in the overlay\",\n\t\t\tposition \u003d 1,\n\t\t\tsection \u003d displaySection\n\t)\n\tdefault DisplayMode displayMode()\n\t{\n\t\treturn DisplayMode.BOTH;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Actions\",\n\t\t\tdescription \u003d \"Perform actions on the session\",\n\t\t\tposition \u003d 2\n\t)\n\tString actionsSection \u003d \"actions\";\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"resetSessionButton\",\n\t\t\tname \u003d \"Reset Session\",\n\t\t\tdescription \u003d \"Reset the current session stats\",\n\t\t\tsection \u003d actionsSection\n\t)\n\tdefault boolean resetSession()\n\t{\n\t\treturn false;\n\t}\n\n\t@ConfigSection(\n\t\t\tname \u003d \"Notifications\",\n\t\t\tdescription \u003d \"Configure notifications for milestones\",\n\t\t\tposition \u003d 3\n\t)\n\tString notificationsSection \u003d \"notifications\";\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"milestoneNotification\",\n\t\t\tname \u003d \"Milestone Notification\",\n\t\t\tdescription \u003d \"Notify when you reach a milestone of monkeys caught\",\n\t\t\tsection \u003d notificationsSection\n\t)\n\tdefault boolean milestoneNotification()\n\t{\n\t\treturn true;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"milestoneInterval\",\n\t\t\tname \u003d \"Milestone Interval\",\n\t\t\tdescription \u003d \"The interval at which to send a milestone notification\",\n\t\t\tsection \u003d notificationsSection\n\t)\n\tdefault int milestoneInterval()\n\t{\n\t\treturn 100;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"sessionStartTime\",\n\t\t\tname \u003d \"Session Start Time\",\n\t\t\tdescription \u003d \"The time the session started\",\n\t\t\thidden \u003d true\n\t)\n\tdefault long getSessionStartTime()\n\t{\n\t\treturn 0L;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"sessionStartTime\",\n\t\t\tname \u003d \"Session Start Time\",\n\t\t\tdescription \u003d \"The time the session started\"\n\t)\n\tvoid setSessionStartTime(long time);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"duration\",\n\t\t\tname \u003d \"Duration\",\n\t\t\tdescription \u003d \"The session duration in milliseconds\",\n\t\t\thidden \u003d true\n\t)\n\tdefault long getDuration()\n\t{\n\t\treturn 0L;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"duration\",\n\t\t\tname \u003d \"Duration\",\n\t\t\tdescription \u003d \"The session duration in milliseconds\"\n\t)\n\tvoid setDuration(long time);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"monkeysCaught\",\n\t\t\tname \u003d \"Monkeys Caught\",\n\t\t\tdescription \u003d \"The number of monkeys caught\",\n\t\t\thidden \u003d true\n\t)\n\tdefault int getMonkeysCaught()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"monkeysCaught\",\n\t\t\tname \u003d \"Monkeys Caught\",\n\t\t\tdescription \u003d \"The number of monkeys caught\"\n\t)\n\tvoid setMonkeysCaught(int count);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"trapsLaid\",\n\t\t\tname \u003d \"Traps Laid\",\n\t\t\tdescription \u003d \"The number of traps laid\",\n\t\t\thidden \u003d true\n\t)\n\tdefault int getTrapsLaid()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"trapsLaid\",\n\t\t\tname \u003d \"Traps Laid\",\n\t\t\tdescription \u003d \"The number of traps laid\"\n\t)\n\tvoid setTrapsLaid(int count);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lastTrapStatus\",\n\t\t\tname \u003d \"Last Trap Status\",\n\t\t\tdescription \u003d \"The status of the last trap\",\n\t\t\thidden \u003d true\n\t)\n\tdefault String getLastTrapStatus()\n\t{\n\t\treturn \"N/A\";\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"lastTrapStatus\",\n\t\t\tname \u003d \"Last Trap Status\",\n\t\t\tdescription \u003d \"The status of the last trap\"\n\t)\n\tvoid setLastTrapStatus(String status);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"perfectTails\",\n\t\t\tname \u003d \"Perfect Tails\",\n\t\t\tdescription \u003d \"The number of perfect tails\",\n\t\t\thidden \u003d true\n\t)\n\tdefault int getPerfectTails()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"perfectTails\",\n\t\t\tname \u003d \"Perfect Tails\",\n\t\t\tdescription \u003d \"The number of perfect tails\"\n\t)\n\tvoid setPerfectTails(int count);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"damagedTails\",\n\t\t\tname \u003d \"Damaged Tails\",\n\t\t\tdescription \u003d \"The number of damaged tails\",\n\t\t\thidden \u003d true\n\t)\n\tdefault int getDamagedTails()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"damagedTails\",\n\t\t\tname \u003d \"Damaged Tails\",\n\t\t\tdescription \u003d \"The number of damaged tails\"\n\t)\n\tvoid setDamagedTails(int count);\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"damagedTailsSincePerfect\",\n\t\t\tname \u003d \"Damaged Tails Since Perfect\",\n\t\t\tdescription \u003d \"The number of damaged tails since the last perfect tail\",\n\t\t\thidden \u003d true\n\t)\n\tdefault int getDamagedTailsSincePerfect()\n\t{\n\t\treturn 0;\n\t}\n\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"damagedTailsSincePerfect\",\n\t\t\tname \u003d \"Damaged Tails Since Perfect\",\n\t\t\tdescription \u003d \"The number of damaged tails since the last perfect tail\"\n\t)\n\tvoid setDamagedTailsSincePerfect(int count);\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterConfig.java"},{"fileName":"ManiacalHunterConstants.java","content":"package com.maniacalhunter;\n\nimport com.google.common.collect.ImmutableSet;\nimport java.util.Set;\n\npublic class ManiacalHunterConstants\n{\n\t// Item IDs\n\tpublic static final int DAMAGED_MONKEY_TAIL \u003d 19665;\n\tpublic static final int PERFECT_MONKEY_TAIL \u003d 19610;\n\tpublic static final int MANIACAL_ITEM_ID \u003d 24864;\n\n\t// Object IDs\n\tpublic static final int UNSET_BOULDER_TRAP \u003d 28824;\n\tpublic static final int SETTING_BOULDER_TRAP \u003d 28825;\n\tpublic static final int SET_BOULDER_TRAP \u003d 28827;\n\tpublic static final int TRIGGERED_BOULDER_TRAP_1 \u003d 28828;\n\tpublic static final int TRIGGERED_BOULDER_TRAP_2 \u003d 28829;\n\tpublic static final int CAUGHT_MONKEY_BOULDER_1 \u003d 28830;\n\tpublic static final int CAUGHT_MONKEY_BOULDER_2 \u003d 28831;\n\tpublic static final int LIFTED_BOULDER \u003d 28833;\n\n\t// Region IDs\n\tpublic static final int MANIACAL_HUNTER_REGION \u003d 11662;\n\n\t// Other\n\tpublic static final int MANIACAL_MONKEY_XP \u003d 1000;\n\n\tpublic static final Set\u003cInteger\u003e BOULDER_TRAP_IDS \u003d ImmutableSet.of(\n\t\tUNSET_BOULDER_TRAP,\n\t\tSETTING_BOULDER_TRAP,\n\t\tSET_BOULDER_TRAP,\n\t\tTRIGGERED_BOULDER_TRAP_1,\n\t\tTRIGGERED_BOULDER_TRAP_2,\n\t\tCAUGHT_MONKEY_BOULDER_1,\n\t\tCAUGHT_MONKEY_BOULDER_2,\n\t\tLIFTED_BOULDER\n\t);\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterConstants.java"},{"fileName":"ManiacalHunterFormatting.java","content":"package com.maniacalhunter;\n\npublic final class ManiacalHunterFormatting\n{\n\tprivate ManiacalHunterFormatting()\n\t{\n\t}\n\n\tpublic static String formatStat(int session, int aggregate, DisplayMode displayMode)\n\t{\n\t\tswitch (displayMode)\n\t\t{\n\t\t\tcase SESSION_ONLY:\n\t\t\t\treturn String.valueOf(session);\n\t\t\tcase AGGREGATE_ONLY:\n\t\t\t\treturn String.valueOf(aggregate);\n\t\t\tcase BOTH:\n\t\t\tdefault:\n\t\t\t\treturn String.format(\"%d (%d)\", session, aggregate);\n\t\t}\n\t}\n\n\tpublic static String formatPercentage(double session, double aggregate, DisplayMode displayMode)\n\t{\n\t\tswitch (displayMode)\n\t\t{\n\t\t\tcase SESSION_ONLY:\n\t\t\t\treturn String.format(\"%.2f%%\", session);\n\t\t\tcase AGGREGATE_ONLY:\n\t\t\t\treturn String.format(\"%.2f%%\", aggregate);\n\t\t\tcase BOTH:\n\t\t\tdefault:\n\t\t\t\treturn String.format(\"%.2f%% (%.2f%%)\", session, aggregate);\n\t\t}\n\t}\n\n\tpublic static String formatDouble(double session, double aggregate, DisplayMode displayMode)\n\t{\n\t\tswitch (displayMode)\n\t\t{\n\t\t\tcase SESSION_ONLY:\n\t\t\t\treturn String.format(\"%.2f\", session);\n\t\t\tcase AGGREGATE_ONLY:\n\t\t\t\treturn String.format(\"%.2f\", aggregate);\n\t\t\tcase BOTH:\n\t\t\tdefault:\n\t\t\t\treturn String.format(\"%.2f (%.2f)\", session, aggregate);\n\t\t}\n\t}\n}","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterFormatting.java"},{"fileName":"ManiacalHunterInfoBox.java","content":"package com.maniacalhunter;\n\nimport java.awt.Color;\nimport java.awt.image.BufferedImage;\nimport net.runelite.client.ui.overlay.infobox.InfoBox;\n\npublic class ManiacalHunterInfoBox extends InfoBox\n{\n\tprivate final ManiacalHunterPlugin plugin;\n\tprivate final ManiacalHunterConfig config;\n\n\tpublic ManiacalHunterInfoBox(ManiacalHunterPlugin plugin, ManiacalHunterConfig config, BufferedImage image)\n\t{\n\t\tsuper(image, plugin);\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\t}\n\n\t@Override\n\tpublic String getText()\n\t{\n\t\treturn String.valueOf(plugin.getSession().getMonkeysCaught());\n\t}\n\n\t@Override\n\tpublic Color getTextColor()\n\t{\n\t\treturn Color.WHITE;\n\t}\n\n\t@Override\n\tpublic String getTooltip()\n\t{\n\t\tManiacalHunterSession session \u003d plugin.getSession();\n\t\tManiacalHunterSession aggregateSession \u003d plugin.getAggregateSession();\n\t\tStringBuilder sb \u003d new StringBuilder();\n\t\tsb.append(\"Maniacal Hunter\");\n\n\t\tif (config.showMonkeysCaught()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Monkeys Caught: \").append(ManiacalHunterFormatting.formatStat(session.getMonkeysCaught(), aggregateSession.getMonkeysCaught(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showTrapsLaid()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Traps Laid: \").append(ManiacalHunterFormatting.formatStat(session.getTrapsLaid(), aggregateSession.getTrapsLaid(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showLastTrapStatus()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Last Trap Status: \").append(session.getLastTrapStatus());\n\t\t}\n\n\t\tif (config.showSuccessRate()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Success Rate: \").append(ManiacalHunterFormatting.formatPercentage(session.getSuccessRate(), aggregateSession.getSuccessRate(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showMonkeysPerHour()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Monkeys/Hour: \").append(ManiacalHunterFormatting.formatDouble(session.getMonkeysPerHour(), aggregateSession.getMonkeysPerHour(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showPerfectTails()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Perfect Tails: \").append(ManiacalHunterFormatting.formatStat(session.getPerfectTails(), aggregateSession.getPerfectTails(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showDamagedTails()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Damaged Tails: \").append(ManiacalHunterFormatting.formatStat(session.getDamagedTails(), aggregateSession.getDamagedTails(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showLuck()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Luck: \").append(ManiacalHunterFormatting.formatPercentage(session.getLuckPercentage(), aggregateSession.getLuckPercentage(), config.displayMode()));\n\t\t}\n\n\t\tif (config.showAvgCatchTime()) {\n\t\t\tsb.append(\"\u003c/br\u003e\");\n\t\t\tsb.append(\"Avg. Catch Time: \").append(String.format(\"%.2fs\", session.getAverageTimePerCatch()));\n\t\t}\n\n\t\treturn sb.toString();\n\t}\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterInfoBox.java"},{"fileName":"ManiacalHunterOverlay.java","content":"package com.maniacalhunter;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport javax.inject.Inject;\n\nimport net.runelite.api.Client;\nimport net.runelite.client.ui.overlay.OverlayPanel;\nimport net.runelite.client.ui.overlay.OverlayPosition;\nimport net.runelite.client.ui.overlay.components.LineComponent;\nimport net.runelite.client.ui.overlay.components.TitleComponent;\n\npublic class ManiacalHunterOverlay extends OverlayPanel\n{\n\tprivate final ManiacalHunterPlugin plugin;\n\tprivate final ManiacalHunterConfig config;\n\tprivate final Client client;\n\n\t@Inject\n\tprivate ManiacalHunterOverlay(ManiacalHunterPlugin plugin, ManiacalHunterConfig config, Client client)\n\t{\n\t\tsuper(plugin);\n\t\tthis.plugin \u003d plugin;\n\t\tthis.config \u003d config;\n\t\tthis.client \u003d client;\n\t\tsetPosition(OverlayPosition.TOP_LEFT);\n\t}\n\n\tprivate boolean isInManiacalHunterArea()\n\t{\n\t\treturn client.getLocalPlayer() !\u003d null \u0026\u0026 client.getLocalPlayer().getWorldLocation().getRegionID() \u003d\u003d ManiacalHunterConstants.MANIACAL_HUNTER_REGION;\n\t}\n\n\t@Override\n\tpublic Dimension render(Graphics2D graphics)\n\t{\n\t\tif (!isInManiacalHunterArea())\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tManiacalHunterSession session \u003d plugin.getSession();\n\t\tManiacalHunterSession aggregateSession \u003d plugin.getAggregateSession();\n\n\t\tpanelComponent.getChildren().clear();\n\n\t\tpanelComponent.getChildren().add(TitleComponent.builder()\n\t\t\t.text(\"Maniacal Hunter\")\n\t\t\t.color(Color.WHITE)\n\t\t\t.build());\n\n\t\tif (config.showMonkeysCaught()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Monkeys Caught:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatStat(session.getMonkeysCaught(), aggregateSession.getMonkeysCaught(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showTrapsLaid()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Traps Laid:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatStat(session.getTrapsLaid(), aggregateSession.getTrapsLaid(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showLastTrapStatus()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Last Trap Status:\")\n\t\t\t\t.right(session.getLastTrapStatus())\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showSuccessRate()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Success Rate:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatPercentage(session.getSuccessRate(), aggregateSession.getSuccessRate(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showMonkeysPerHour()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Monkeys/Hour:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatDouble(session.getMonkeysPerHour(), aggregateSession.getMonkeysPerHour(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showPerfectTails()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Perfect Tails:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatStat(session.getPerfectTails(), aggregateSession.getPerfectTails(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showDamagedTails()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Damaged Tails:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatStat(session.getDamagedTails(), aggregateSession.getDamagedTails(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showLuck()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Luck:\")\n\t\t\t\t.right(ManiacalHunterFormatting.formatPercentage(session.getLuckPercentage(), aggregateSession.getLuckPercentage(), config.displayMode()))\n\t\t\t\t.build());\n\t\t}\n\n\t\tif (config.showAvgCatchTime()) {\n\t\t\tpanelComponent.getChildren().add(LineComponent.builder()\n\t\t\t\t.left(\"Avg. Catch Time:\")\n\t\t\t\t.right(String.format(\"%.2fs\", session.getAverageTimePerCatch()))\n\t\t\t\t.build());\n\t\t}\n\n\t\treturn super.render(graphics);\n\t}\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterOverlay.java"},{"fileName":"ManiacalHunterPlugin.java","content":"package com.maniacalhunter;\n\nimport com.google.inject.Provides;\nimport java.awt.image.BufferedImage;\nimport java.time.Duration;\nimport java.time.Instant;\nimport javax.inject.Inject;\n\nimport lombok.Getter;\nimport lombok.Setter;\nimport net.runelite.api.Client;\nimport net.runelite.api.GameObject;\nimport net.runelite.api.InventoryID;\nimport net.runelite.api.GameState;\nimport net.runelite.api.Skill;\nimport net.runelite.api.events.PlayerDespawned;\nimport net.runelite.api.events.PlayerSpawned;\nimport net.runelite.api.events.GameObjectSpawned;\nimport net.runelite.api.events.GameStateChanged;\nimport net.runelite.api.events.GameTick;\nimport net.runelite.api.events.ItemContainerChanged;\nimport net.runelite.api.events.StatChanged;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.ui.overlay.OverlayManager;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.Notifier;\nimport net.runelite.client.game.ItemManager;\nimport net.runelite.client.ui.overlay.infobox.InfoBoxManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@PluginDescriptor(\n\tname \u003d \"Maniacal Hunter\"\n)\npublic class ManiacalHunterPlugin extends Plugin\n{\n\tprivate static final Logger log \u003d LoggerFactory.getLogger(ManiacalHunterPlugin.class);\n\tprivate static final String CONFIG_GROUP \u003d \"maniacalhunter\";\n\tprivate static final String RESET_BUTTON_KEY \u003d \"resetSessionButton\";\n\tprivate static final String CONDENSED_MODE_KEY \u003d \"condensedMode\";\n\n\t@Getter\n    private BufferedImage icon;\n\n\t@Inject\n\tprivate Client client;\n\n\t@Setter\n    @Getter\n    @Inject\n\tprivate Notifier notifier;\n\n\t@Inject\n\tprivate ManiacalHunterConfig config;\n\n\t@Inject\n\tprivate ConfigManager configManager;\n\n    @Inject\n    private ItemManager itemManager;\n\n\t@Inject\n\tprivate InfoBoxManager infoBoxManager;\n\n\t@Getter\n\t@Inject\n\tprivate ManiacalHunterSession session;\n\n\t@Getter\n    private ManiacalHunterSession aggregateSession \u003d new ManiacalHunterSession();\n\n\t@Inject\n\tprivate OverlayManager overlayManager;\n\n\t@Inject\n\tprivate ManiacalHunterOverlay overlay;\n\n\tprivate ManiacalHunterInfoBox infoBox;\n\n\tprivate int lastPerfectTails \u003d 0;\n\tprivate int lastDamagedTails \u003d 0;\n\tprivate int catchesThisTick \u003d 0;\n\tprivate int lastTick \u003d 0;\n\tprivate int lastHunterXp \u003d -1;\n\tprivate boolean inHunterArea \u003d false;\n\n\tprivate void reset()\n\t{\n\t\tsession.reset();\n\t\tcatchesThisTick \u003d 0;\n\t\tlastTick \u003d 0;\n        lastPerfectTails \u003d 0;\n        lastDamagedTails \u003d 0;\n\n\t\tif (client.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tlastHunterXp \u003d client.getSkillExperience(Skill.HUNTER);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlastHunterXp \u003d -1;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\t\tlog.info(\"Maniacal Hunter started!\");\n\t\tloadSession();\n\t\ticon \u003d itemManager.getImage(ManiacalHunterConstants.MANIACAL_ITEM_ID);\n\t\tinfoBox \u003d new ManiacalHunterInfoBox(this, config, icon);\n\t\tupdateDisplayMode();\n\t}\n\n\t@Override\n\tprotected void shutDown() throws Exception\n\t{\n\t\tlog.info(\"Maniacal Hunter stopped!\");\n\t\tinfoBoxManager.removeInfoBox(infoBox);\n\t\toverlayManager.remove(overlay);\n\t}\n\n\tprivate void loadSession()\n\t{\n\t\taggregateSession.setSessionStartTimeMillis(config.getSessionStartTime());\n\t\taggregateSession.setDurationMillis(config.getDuration());\n\t\taggregateSession.setMonkeysCaught(config.getMonkeysCaught());\n\t\taggregateSession.setTrapsLaid(config.getTrapsLaid());\n\t\taggregateSession.setLastTrapStatus(config.getLastTrapStatus());\n\t\taggregateSession.setPerfectTails(config.getPerfectTails());\n\t\taggregateSession.setDamagedTails(config.getDamagedTails());\n\t\taggregateSession.setDamagedTailsSincePerfect(config.getDamagedTailsSincePerfect());\n\t}\n\n\t@Subscribe\n\tpublic void onGameStateChanged(GameStateChanged gameStateChanged)\n\t{\n\t\tif (gameStateChanged.getGameState() \u003d\u003d GameState.LOGGED_IN)\n\t\t{\n\t\t\tlastHunterXp \u003d client.getSkillExperience(Skill.HUNTER);\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onItemContainerChanged(ItemContainerChanged event)\n\t{\n\t\tif (!isInManiacalHunterArea() || event.getContainerId() !\u003d InventoryID.INVENTORY.getId())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tint currentPerfectTails \u003d event.getItemContainer().count(ManiacalHunterConstants.PERFECT_MONKEY_TAIL);\n\t\tint currentDamagedTails \u003d event.getItemContainer().count(ManiacalHunterConstants.DAMAGED_MONKEY_TAIL);\n\n\t\tint perfectTailsGained \u003d currentPerfectTails - lastPerfectTails;\n\t\tint damagedTailsGained \u003d currentDamagedTails - lastDamagedTails;\n\n\t\tif (catchesThisTick \u003e 0 \u0026\u0026 (perfectTailsGained \u003e 0 || damagedTailsGained \u003e 0))\n\t\t{\n\t\t\tif (perfectTailsGained \u003e 0)\n\t\t\t{\n\t\t\t\thandlePerfectTailGain();\n\t\t\t}\n\t\t\tif (damagedTailsGained \u003e 0)\n\t\t\t{\n\t\t\t\thandleDamagedTailGain();\n\t\t\t}\n\t\t\thandleMonkeyCatch();\n\t\t\tcatchesThisTick--;\n\t\t}\n\n\t\tlastPerfectTails \u003d currentPerfectTails;\n\t\tlastDamagedTails \u003d currentDamagedTails;\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick tick)\n\t{\n  \n        if (!isInManiacalHunterArea())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (client.getTickCount() !\u003d lastTick)\n\t\t{\n\t\t\tcatchesThisTick \u003d 0;\n\t\t\tlastTick \u003d client.getTickCount();\n        }\n\t\tif (session.getSessionStartTime() !\u003d null)\n\t\t{\n\t\t\tsession.setDuration(Duration.between(session.getSessionStartTime(), Instant.now()));\n\t\t}\n\t\tif (aggregateSession.getSessionStartTime() !\u003d null)\n\t\t{\n\t\t\taggregateSession.setDuration(Duration.between(aggregateSession.getSessionStartTime(), Instant.now()));\n\t\t\tconfig.setDuration(aggregateSession.getDurationMillis());\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onPlayerSpawned(PlayerSpawned event)\n\t{\n\t\tif (event.getPlayer() !\u003d client.getLocalPlayer())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tboolean currentlyInArea \u003d isInManiacalHunterArea();\n\t\tif (currentlyInArea)\n\t\t{\n\t\t\tinHunterArea \u003d true;\n\t\t\tif (config.autoResetMode() \u003d\u003d ResetMode.ON_ENTER_AREA)\n\t\t\t{\n\t\t\t\treset();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onPlayerDespawned(PlayerDespawned event)\n\t{\n\t\tif (event.getPlayer() !\u003d client.getLocalPlayer())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (inHunterArea)\n\t\t{\n\t\t\tif (config.autoResetMode() \u003d\u003d ResetMode.ON_LEAVE_AREA)\n\t\t\t{\n\t\t\t\treset();\n\t\t\t}\n\t\t\tinHunterArea \u003d false;\n\t\t}\n\t}\n\n\tprivate boolean isInManiacalHunterArea()\n\t{\n\t\treturn client.getLocalPlayer() !\u003d null \u0026\u0026 client.getLocalPlayer().getWorldLocation().getRegionID() \u003d\u003d ManiacalHunterConstants.MANIACAL_HUNTER_REGION;\n\t}\n\n\t@Subscribe\n\tpublic void onStatChanged(StatChanged statChanged)\n\t{\n\t\tif (statChanged.getSkill() !\u003d Skill.HUNTER || !isInManiacalHunterArea())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (lastHunterXp \u003d\u003d -1)\n\t\t{\n\t\t\tlastHunterXp \u003d statChanged.getXp();\n\t\t\treturn;\n\t\t}\n\n\t\tint currentXp \u003d statChanged.getXp();\n\t\tint gainedXp \u003d currentXp - lastHunterXp;\n\n\t\tif (gainedXp \u003e 0 \u0026\u0026 gainedXp % ManiacalHunterConstants.MANIACAL_MONKEY_XP \u003d\u003d 0)\n\t\t{\n\t\t\tcatchesThisTick +\u003d gainedXp / ManiacalHunterConstants.MANIACAL_MONKEY_XP;\n\t\t}\n\t\t\n\t\tlastHunterXp \u003d currentXp;\n\n\t\tif (gainedXp \u003e 0)\n\t\t{\n\t\t\tif (session.getSessionStartTime() \u003d\u003d null)\n\t\t\t{\n\t\t\t\tsession.startSession();\n\t\t\t}\n\n\t\t\tif (aggregateSession.getSessionStartTime() \u003d\u003d null)\n\t\t\t{\n\t\t\t\taggregateSession.startSession();\n\t\t\t\tconfig.setSessionStartTime(aggregateSession.getSessionStartTimeMillis());\n\t\t\t}\n\t\t}\n\t}\n  \n\tprivate static final int MAX_DISTANCE \u003d 2;\n\n\t@Subscribe\n\tpublic void onGameObjectSpawned(GameObjectSpawned event)\n\t{\n\t\tif (!isInManiacalHunterArea())\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tGameObject gameObject \u003d event.getGameObject();\n\t\tif (gameObject \u003d\u003d null\n\t\t\t|| !ManiacalHunterConstants.BOULDER_TRAP_IDS.contains(gameObject.getId())\n\t\t\t|| client.getLocalPlayer().getWorldLocation().distanceTo(gameObject.getWorldLocation()) \u003e MAX_DISTANCE)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tint id \u003d gameObject.getId();\n\n\t\tif (id \u003d\u003d ManiacalHunterConstants.SET_BOULDER_TRAP)\n\t\t{\n\t\t\thandleTrapLaid();\n\t\t}\n\t\telse if (id \u003d\u003d ManiacalHunterConstants.TRIGGERED_BOULDER_TRAP_1 || id \u003d\u003d ManiacalHunterConstants.TRIGGERED_BOULDER_TRAP_2)\n\t\t{\n\t\t\tupdateLastTrapStatus(\"Trap triggered\");\n\t\t}\n\t\telse if (id \u003d\u003d ManiacalHunterConstants.CAUGHT_MONKEY_BOULDER_1 || id \u003d\u003d ManiacalHunterConstants.CAUGHT_MONKEY_BOULDER_2)\n\t\t{\n\t\t\tupdateLastTrapStatus(\"Monkey caught\");\n\t\t}\n\t}\n\n\tprivate void handleMonkeyCatch()\n\t{\n\t\tsession.incrementMonkeysCaught();\n\t\taggregateSession.incrementMonkeysCaught();\n\t\tconfig.setMonkeysCaught(aggregateSession.getMonkeysCaught());\n\t\tif (config.milestoneNotification() \u0026\u0026 session.getMonkeysCaught() \u003e 0 \u0026\u0026 session.getMonkeysCaught() % config.milestoneInterval() \u003d\u003d 0)\n\t\t{\n\t\t\tnotifier.notify(\"Maniacal Hunter milestone: \" + session.getMonkeysCaught() + \" monkeys caught!\");\n\t\t}\n\t}\n\n\tprivate void handlePerfectTailGain() {\n\t\tsession.incrementPerfectTails();\n\t\taggregateSession.incrementPerfectTails();\n\t\tconfig.setPerfectTails(aggregateSession.getPerfectTails());\n\t\tconfig.setDamagedTailsSincePerfect(aggregateSession.getDamagedTailsSincePerfect());\n\t}\n\n\tprivate void handleDamagedTailGain() {\n\t\tsession.incrementDamagedTails();\n\t\taggregateSession.incrementDamagedTails();\n\t\tconfig.setDamagedTails(aggregateSession.getDamagedTails());\n\t\tconfig.setDamagedTailsSincePerfect(aggregateSession.getDamagedTailsSincePerfect());\n\t}\n\n\tprivate void handleTrapLaid() {\n\t\tsession.incrementTrapsLaid();\n\t\taggregateSession.incrementTrapsLaid();\n\t\tconfig.setTrapsLaid(aggregateSession.getTrapsLaid());\n\t\tupdateLastTrapStatus(\"Trap set\");\n\t}\n\n\tprivate void updateLastTrapStatus(String status) {\n\t\tsession.setLastTrapStatus(status);\n\t\taggregateSession.setLastTrapStatus(status);\n\t\tconfig.setLastTrapStatus(aggregateSession.getLastTrapStatus());\n\t}\n\n\t@Provides\n\tManiacalHunterConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(ManiacalHunterConfig.class);\n\t}\n\n\t@Provides\n\tManiacalHunterSession provideSession()\n\t{\n\t\treturn new ManiacalHunterSession();\n\t}\n\n    @Subscribe\n\tpublic void onConfigChanged(ConfigChanged event)\n\t{\n\t\tif (!event.getGroup().equals(CONFIG_GROUP))\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tif (event.getKey().equals(RESET_BUTTON_KEY))\n\t\t{\n\t\t\tif (config.resetSession())\n\t\t\t{\n\t\t\t\treset();\n\t\t\t\tconfigManager.setConfiguration(CONFIG_GROUP, RESET_BUTTON_KEY, false);\n\t\t\t}\n\t\t}\n\t\tif (event.getKey().equals(CONDENSED_MODE_KEY))\n\t\t{\n\t\t\tupdateDisplayMode();\n\t\t}\n\t}\n\n\tprivate void updateDisplayMode()\n\t{\n\t\tinfoBoxManager.removeInfoBox(infoBox);\n\t\toverlayManager.remove(overlay);\n\t\tif (config.condensedMode())\n\t\t{\n\t\t\tinfoBoxManager.addInfoBox(infoBox);\n\t\t}\n\t\telse\n\t\t{\n\t\t\toverlayManager.add(overlay);\n\t\t}\n\t}\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterPlugin.java"},{"fileName":"ManiacalHunterSession.java","content":"package com.maniacalhunter;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.time.Duration;\nimport java.time.Instant;\n\npublic class ManiacalHunterSession\n{\n\tprivate static final int PERFECT_TAIL_DROP_CHANCE \u003d 5000;\n\tprivate static final double PERFECT_TAIL_DROP_RATE \u003d 1.0 / PERFECT_TAIL_DROP_CHANCE;\n\tprivate static final double MILLIS_PER_HOUR \u003d 3_600_000.0;\n\tprivate static final double MILLIS_PER_SECOND \u003d 1_000.0;\n\n    @Getter\n\t@Setter\n    private long sessionStartTimeMillis;\n\t@Getter\n\t@Setter\n    private long durationMillis;\n\t@Getter\n\t@Setter\n    private int monkeysCaught;\n\t@Getter\n\t@Setter\n    private int trapsLaid;\n\t@Getter\n    @Setter\n    private String lastTrapStatus;\n\t@Getter\n\t@Setter\n    private int perfectTails;\n\t@Getter\n\t@Setter\n    private int damagedTails;\n\t@Getter\n\t@Setter\n\tprivate int damagedTailsSincePerfect;\n\n\tpublic void startSession()\n\t{\n\t\tthis.sessionStartTimeMillis \u003d Instant.now().toEpochMilli();\n\t}\n\n\tpublic void reset()\n\t{\n\t\tthis.sessionStartTimeMillis \u003d 0;\n\t\tthis.durationMillis \u003d 0;\n\t\tthis.monkeysCaught \u003d 0;\n\t\tthis.trapsLaid \u003d 0;\n\t\tthis.lastTrapStatus \u003d \"N/A\";\n\t\tthis.perfectTails \u003d 0;\n\t\tthis.damagedTails \u003d 0;\n\t\tthis.damagedTailsSincePerfect \u003d 0;\n\t}\n\n\tpublic void incrementMonkeysCaught()\n\t{\n\t\tthis.monkeysCaught++;\n\t}\n\n\tpublic void incrementTrapsLaid()\n\t{\n\t\tthis.trapsLaid++;\n\t}\n\n\tpublic void incrementPerfectTails()\n\t{\n\t\tthis.perfectTails++;\n\t\tthis.damagedTailsSincePerfect \u003d 0;\n\t}\n\n\tpublic void incrementDamagedTails()\n\t{\n\t\tthis.damagedTails++;\n\t\tthis.damagedTailsSincePerfect++;\n\t}\n\n\tpublic double getLuckPercentage()\n\t{\n\t\tif (damagedTailsSincePerfect \u003d\u003d 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t// This calculates the probability of getting at least one perfect tail in N trials,\n\t\t// which is 1 minus the probability of getting zero perfect tails.\n\t\treturn (1.0 - Math.pow(1.0 - PERFECT_TAIL_DROP_RATE, damagedTailsSincePerfect)) * 100;\n\t}\n\n\tpublic double getSuccessRate()\n\t{\n\t\tif (trapsLaid \u003d\u003d 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn (double) monkeysCaught / trapsLaid * 100;\n\t}\n\n\tpublic double getMonkeysPerHour()\n\t{\n\t\tif (durationMillis \u003d\u003d 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn (double) monkeysCaught / (durationMillis / MILLIS_PER_HOUR);\n\t}\n\n\tpublic double getAverageTimePerCatch()\n\t{\n\t\tif (monkeysCaught \u003d\u003d 0 || durationMillis \u003d\u003d 0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\treturn (double) durationMillis / monkeysCaught / MILLIS_PER_SECOND;\n\t}\n\n\tpublic Instant getSessionStartTime()\n\t{\n\t\treturn sessionStartTimeMillis \u003d\u003d 0 ? null : Instant.ofEpochMilli(sessionStartTimeMillis);\n\t}\n\n\tpublic Duration getDuration()\n\t{\n\t\treturn durationMillis \u003d\u003d 0 ? null : Duration.ofMillis(durationMillis);\n\t}\n\n\tpublic void setDuration(Duration duration)\n\t{\n\t\tthis.durationMillis \u003d duration.toMillis();\n\t}\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ManiacalHunterSession.java"},{"fileName":"ResetMode.java","content":"package com.maniacalhunter;\n\npublic enum ResetMode\n{\n\tON_ENTER_AREA,\n\tON_LEAVE_AREA,\n\tNEVER\n}\n","filePath":"src\\main\\java\\com\\maniacalhunter\\ResetMode.java"},{"fileName":"ManiacalHunterPluginTest.java","content":"package com.maniacalhunter;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class ManiacalHunterPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(ManiacalHunterPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src\\test\\java\\com\\maniacalhunter\\ManiacalHunterPluginTest.java"}]},{"commit":"1396d7db9515407518ca6a183d0a7d42498fb013","repository":"https://github.com/Droei/Droei-RuneLite-Plugins.git","internalName":"entity-masker","files":[{"fileName":"test.java","content":"this file does not actually exist, because the repo does not exist","filePath":"asker\\test.java"}]},{"commit":"255c772ef42d0f0802d43909b7fb8b1da31591c1","repository":"https://github.com/hootisman/muted_level_jingles.git","internalName":"unmutedjingles","files":[{"fileName":"UnmutedJinglesConfig.java","content":"package hootisman.unmutedjingles;\n\nimport net.runelite.client.config.Config;\nimport net.runelite.client.config.ConfigGroup;\nimport net.runelite.client.config.ConfigItem;\nimport net.runelite.client.config.Range;\n\n@ConfigGroup(\"unmutedjingles\")\npublic interface UnmutedJinglesConfig extends Config\n{\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"jingleTest\",\n\t\t\tname \u003d \"Jingle Test\",\n\t\t\tdescription \u003d \"When pressed, will play a jingle; Used to test volume\"\n\t)\n\tdefault boolean jingleTest()\n\t{\n\t\treturn false;\n\t}\n\n\t@Range(max\u003d100)\n\t@ConfigItem(\n\t\t\tkeyName \u003d \"jingleGain\",\n\t\t\tname \u003d \"Jingle Volume\",\n\t\t\tdescription \u003d \"Volume when jingles are played\"\n\t)\n\tdefault int jingleGain() {return 50;}\n}\n","filePath":"src/main/java/hootisman/unmutedjingles/UnmutedJinglesConfig.java"},{"fileName":"UnmutedJinglesPlugin.java","content":"package hootisman.unmutedjingles;\n\nimport com.google.inject.Provides;\nimport javax.inject.Inject;\n\nimport hootisman.unmutedjingles.jingles.JingleManager;\nimport javax.inject.Named;\n\n\nimport jaco.mp3.player.MP3Player;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.*;\nimport net.runelite.api.events.*;\nimport net.runelite.api.gameval.InterfaceID;\nimport net.runelite.api.gameval.VarbitID;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.config.ConfigManager;\nimport net.runelite.client.eventbus.Subscribe;\nimport net.runelite.client.events.ConfigChanged;\nimport net.runelite.client.events.PluginChanged;\nimport net.runelite.client.plugins.Plugin;\nimport net.runelite.client.plugins.PluginDependency;\nimport net.runelite.client.plugins.PluginDescriptor;\nimport net.runelite.client.plugins.PluginManager;\nimport net.runelite.client.plugins.music.MusicPlugin;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.io.File;\nimport java.util.regex.Matcher;\n\n@Slf4j\n@PluginDescriptor(\n\tname \u003d \"Unmuted Jingles\"\n)\n@PluginDependency(MusicPlugin.class)\npublic class UnmutedJinglesPlugin extends Plugin\n{\n\t@Inject\n\tprivate Client client;\n\n\t@Inject\n\tprivate ClientThread clientThread;\n\n\t@Inject\n\tprivate MusicPlugin musicPlugin;\n\n\t@Inject\n\tprivate PluginManager pluginManager;\n\n\t@Inject\n\tprivate UnmutedJinglesConfig config;\n\n\t@Inject\n\tprivate JingleManager jingleManager;\n\n\t@Inject\n\t@Named(\"developerMode\")\n\tboolean developerMode;\n\n\t@Override\n\tprotected void startUp() throws Exception\n\t{\n\n\t}\n\n\t@Subscribe\n\tpublic void onPluginChanged(PluginChanged e){\n\n\t}\n\n\n\t@Subscribe\n\tpublic void onConfigChanged(ConfigChanged e){\n\t\tlog.debug(getName());\n\t\tif (e.getGroup().equals(\"unmutedjingles\") \u0026\u0026 e.getKey().equals(\"jingleTest\")){\n\t\t\ttry{\n\t\t\t\tjingleManager.playJingle(\"woodcutting_unlocks\");\n\t\t\t}catch (Exception ex){\n\t\t\t\tlog.debug(\"Failed test audio\");\n\t\t\t}\n\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onGameTick(GameTick e){\n\t\tjingleManager.tickJingle();\n\t}\n\n\t@Subscribe\n\tpublic void onWidgetLoaded(WidgetLoaded e){\n\t\tif (client.getMusicVolume() !\u003d 0 || jingleManager.isLevelUpWidgetDisabled()) return;\n\n\t\t//If a level up display widget shows up, flag that it showed up; jingle queue handled in jinglemanager\n\t\tif (e.getGroupId() \u003d\u003d InterfaceID.LEVELUP_DISPLAY){\n\t\t\tjingleManager.widgetLevelUp \u003d true;\n\t\t}\n\t}\n\n\t@Subscribe\n\tpublic void onChatMessage(ChatMessage e){\n\t\tif(client.getMusicVolume() !\u003d 0 || !jingleManager.isLevelUpWidgetDisabled()) return;\n\n\t\t//If a level up chat message shows up, start queueing a jingle\n\t\tjingleManager.queueLevelJingle(e.getMessage());\n\t}\n\n\t@Provides\n\tUnmutedJinglesConfig provideConfig(ConfigManager configManager)\n\t{\n\t\treturn configManager.getConfig(UnmutedJinglesConfig.class);\n\t}\n\n\t//debugging commands\n\t@Subscribe\n\tpublic void onCommandExecuted(CommandExecuted e)\n\t{\n\t\tif (!developerMode) return;\n\n\t\tString task \u003d String.join(\" \", e.getArguments());\n\t\tString skill \u003d null;\n\t\tString skill2 \u003d null;\n\t\tint level \u003d 42;\n\t\tint level2 \u003d 42;\n\n\t\tswitch(e.getCommand()){\n\t\t\tcase \"qmlj\":\n\t\t\t\tskill \u003d StringUtils.capitalize(task.split(\" \")[0].toLowerCase());\n\t\t\t\tskill2 \u003d StringUtils.capitalize(task.split(\" \")[2].toLowerCase());\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlevel \u003d Integer.parseInt(task.split(\" \")[1]);\n\t\t\t\t\tlevel2 \u003d Integer.parseInt(task.split(\" \")[3]);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t\tString msgTest0 \u003d \"Congratulations, you\u0027ve just advanced your \" + skill + \" level. You are now level \" + level + \".\";\n\t\t\t\tString msgTest1 \u003d \"Congratulations, you\u0027ve just advanced your \" + skill2 + \" level. You are now level \" + level2 + \".\";\n\n\t\t\t\tjingleManager.queueLevelJingle(msgTest0);\n\t\t\t\tjingleManager.queueLevelJingle(msgTest1);\n\t\t\t\tbreak;\n\t\t\tcase \"qlj\":\n\t\t\t\tskill \u003d StringUtils.capitalize(task.split(\" \")[0].toLowerCase());\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tlevel \u003d Integer.parseInt(task.split(\" \")[1]);\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex)\n\t\t\t\t{\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\n\t\t\t\tString msgTest \u003d \"Congratulations, you\u0027ve just advanced your \" + skill + \" level. You are now level \" + level + \".\";\n\t\t\t\tlog.debug(msgTest);\n\t\t\t\tjingleManager.queueLevelJingle(msgTest);\n\n\t\t\t\tbreak;\n\n\t\t\tcase \"pj\":\n\t\t\t\tjingleManager.playJingle(task);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n}\n","filePath":"src/main/java/hootisman/unmutedjingles/UnmutedJinglesPlugin.java"},{"fileName":"JingleManager.java","content":"package hootisman.unmutedjingles.jingles;\n\nimport hootisman.unmutedjingles.UnmutedJinglesConfig;\nimport javax.inject.Named;\n\nimport jaco.mp3.player.MP3Player;\nimport lombok.*;\nimport lombok.extern.slf4j.Slf4j;\nimport net.runelite.api.Client;\nimport net.runelite.api.Skill;\nimport net.runelite.api.gameval.InterfaceID;\nimport net.runelite.api.gameval.VarbitID;\nimport net.runelite.api.widgets.Widget;\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.callback.ClientThread;\nimport net.runelite.client.util.Text;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport java.io.File;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n@Slf4j\n@Singleton\npublic class JingleManager {\n\n    @Inject\n    private Client client;\n\n    @Inject\n    private ClientThread clientThread;\n\n    @Inject\n    private UnmutedJinglesConfig config;\n\n\t@Inject\n\t@Named(\"developerMode\")\n\tboolean developerMode;\n\n    //Taken from the runelite screenshot plugin, thanks guys!\n    //widget level up message\n    public static final Pattern LEVEL_UP_PATTERN \u003d Pattern.compile(\".*Your ([a-zA-Z]+) (?:level is|are)? now (\\\\d+)\\\\.\");\n\n    //chat level up message\n    public static final Pattern LEVEL_UP_MESSAGE_PATTERN \u003d Pattern.compile(\"Congratulations, you\u0027ve (just advanced your (?\u003cskill\u003e[a-zA-Z]+) level\\\\. You are now level (?\u003clevel\u003e\\\\d+)|reached the highest possible (?\u003cskill99\u003e[a-zA-Z]+) level of 99)\\\\.\");\n    public static final Map\u003cString, URL\u003e SOUNDS_CACHE \u003d new HashMap\u003c\u003e();\n\n    //true when a level up widget shows up, otherwise false\n    public boolean widgetLevelUp;\n\n    private MP3Player player;\n\n    public JingleManager(){\n        widgetLevelUp \u003d false;\n    }\n\n    public void tickJingle(){\n        if (!widgetLevelUp || isLevelUpWidgetDisabled()) return;\n\n        //widgets enabled + detected level up\n        //Also from Screenshot Plugin\n        Widget levelUpWidget \u003d null;\n        if (client.getWidget(InterfaceID.LevelupDisplay.TEXT2) !\u003d null) {\n            levelUpWidget \u003d client.getWidget(InterfaceID.LevelupDisplay.TEXT2);\n        } else if (client.getWidget(InterfaceID.Objectbox.TEXT) !\u003d null \u0026\u0026\n                !Text.removeTags(client.getWidget(InterfaceID.Objectbox.TEXT).getText()).contains(\"High level gamble\")) {\n            //probably the combat level widget? idk\n            levelUpWidget \u003d client.getWidget(InterfaceID.Objectbox.TEXT);\n        }\n\n        if (levelUpWidget !\u003d null) {\n            queueLevelJingle(levelUpWidget.getText());\n        }\n        widgetLevelUp \u003d false;\n\n    }\n\n    //true if levelup widget is disabled, otherwise false\n    public boolean isLevelUpWidgetDisabled(){\n        return client.getVarbitValue(VarbitID.OPTION_LEVEL_UP_MESSAGE) \u003d\u003d 1;\n    }\n\n    //takes a chat/widget text, parses with regex, then tries to play a jingle\n    public void queueLevelJingle(String message){\n        Pattern regex \u003d (isLevelUpWidgetDisabled() ? JingleManager.LEVEL_UP_MESSAGE_PATTERN : JingleManager.LEVEL_UP_PATTERN);\n        Matcher m \u003d regex.matcher(message);\n        if (!m.matches()) return;\n\n        String skill \u003d (isLevelUpWidgetDisabled() ? m.group(\"skill\") : m.group(1)).toUpperCase();\n        String level \u003d isLevelUpWidgetDisabled() ? m.group(\"level\") : m.group(2);\n        log.debug(\"Skill \" + skill + \" Level \" + level);\n\n        try {\n            String fileName;\n            if (skill.equals(\"COMBAT\")){\n                fileName \u003d \"combat\";\n            }else {\n                Skill s \u003d Skill.valueOf(skill);\n                int l \u003d Integer.parseInt(level);\n                log.debug(\"Skill level parse successful\");\n                fileName \u003d skill.toLowerCase() + (JingleData.UNLOCK_LEVELS.get(s).contains(l) ? \"_unlocks\" : \"\");\n                log.debug(\"file name \" + fileName);\n            }\n            playJingle(fileName);\n        }catch (Exception ex){\n            log.debug(\"Failed to play level jingle\");\n        }\n    }\n    public URL loadAndCache(String fileName){\n        URL url \u003d SOUNDS_CACHE.get(fileName);\n        if (url \u003d\u003d null){\n            try {\n                url \u003d getClass().getResource(fileName);\n                SOUNDS_CACHE.put(fileName, url);\n            }catch (Exception ex){\n                log.debug(\"Failed to find sound \" + fileName);\n                url \u003d null;\n            }\n        }\n\n        return url;\n    }\n    public void playJingle(String fileName){\n        URL url \u003d loadAndCache(\"/jinglesounds/\" + fileName + \".mp3\");\n        if (url \u003d\u003d null){\n            log.debug(\"Failed to play jingle \" + fileName);\n            return;\n        }\n        if (player !\u003d null) player.stop();\n        player \u003d new MP3Player(url);\n        player.setRepeat(false);\n        player.setVolume(config.jingleGain());\n        player.play();\n    }\n}\n","filePath":"src/main/java/hootisman/unmutedjingles/jingles/JingleManager.java"},{"fileName":"JingleData.java","content":"package hootisman.unmutedjingles.jingles;\n\nimport net.runelite.api.Skill;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class JingleData {\n    // ***** Constants *****\n\n    static final Set\u003cInteger\u003e ATTACK_UNLOCKS \u003d\n            Stream.of(5, 10, 15, 20, 30, 40, 42, 50, 55,\n                    60, 65, 70, 75, 77, 78, 80, 82, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e COOKING_UNLOCKS \u003d\n            Stream.of(5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n                    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n                    37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,\n                    53, 54, 55, 57, 58, 59, 60, 62, 64, 65, 67, 68, 70, 72, 73, 75,\n                    80, 82, 84, 85, 88, 90, 91, 92, 95, 96, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e CRAFTING_UNLOCKS \u003d\n            Stream.of(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\n                    18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n                    34, 35, 36, 37, 38, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,\n                    51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,\n                    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82, 83,\n                    84, 85, 86, 87, 88, 89, 90, 92, 95, 98, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e DEFENCE_UNLOCKS \u003d\n            Stream.of(5, 10, 20, 25, 30, 35, 40, 42, 45, 50,\n                    55, 60, 65, 70, 75, 78, 80, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e FARMING_UNLOCKS \u003d\n            Stream.of(2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,\n                    19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,\n                    35, 36, 38, 39, 40, 42, 44, 45, 46, 47, 48, 49, 50, 51, 53, 54,\n                    55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 67, 68, 69, 70, 72,\n                    73, 74, 75, 76, 79, 81, 83, 84, 85, 90, 91, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e FIREMAKING_UNLOCKS \u003d\n            Stream.of(4, 5, 11, 12, 15, 16, 20, 21, 25, 26, 30, 33, 35, 40,\n                    42, 43, 45, 47, 49, 50, 52, 55, 60, 62, 65, 66, 70, 75, 80, 85, 90, 95, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e FISHING_UNLOCKS \u003d\n            Stream.of(5, 7, 10, 15, 16, 20, 23, 25, 28, 29, 30, 33, 34, 35,\n                    38, 39, 40, 43, 45, 46, 47, 48, 50, 53, 55, 56, 58, 60, 61, 62,\n                    65, 68, 70, 71, 73, 75, 76, 79, 80, 81, 82, 85, 87, 90, 91, 96, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e FLETCHING_UNLOCKS \u003d\n            Stream.of(3, 5, 7, 9, 10, 11, 15, 17, 18, 20, 22, 24, 25, 26,\n                    27, 30, 32, 33, 35, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48,\n                    49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 65, 67,\n                    69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 81, 82, 84, 85, 87,\n                    90, 92, 95, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e HERBLORE_UNLOCKS \u003d\n            Stream.of(3, 4, 5, 6, 8, 9, 10, 11, 12, 14, 15, 18, 19, 20, 22,\n                    24, 25, 26, 29, 30, 31, 33, 34, 36, 37, 38, 39, 40, 42, 44, 45,\n                    47, 48, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,\n                    81, 82, 83, 84, 85, 86, 87, 88, 90, 91, 92, 94, 97, 98, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e MAGIC_UNLOCKS \u003d\n            Stream.of(3, 4, 5, 6, 7, 9, 11, 13, 14, 15, 16, 17, 19, 20, 21,\n                    23, 24, 25, 27, 28, 29, 30, 31, 33, 34, 35, 37, 38, 39, 40, 41,\n                    42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,\n                    58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,\n                    74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,\n                    90, 91, 92, 93, 94, 95, 96, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e MINING_UNLOCKS \u003d\n            Stream.of(5, 6, 10, 11, 14, 15, 17, 20, 21, 22, 25, 30, 31, 35,\n                    37, 38, 39, 40, 41, 42, 43, 45, 50, 52, 55, 57, 60, 61, 64, 65,\n                    67, 68, 70, 71, 72, 75, 78, 80, 81, 82, 85, 90, 92, 97, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e PRAYER_UNLOCKS \u003d\n            Stream.of(3, 4, 7, 8, 9, 10, 12, 13, 16, 19, 20, 22, 24, 25, 26,\n                    27, 28, 30, 31, 32, 34, 36, 37, 40, 42, 43, 44, 45, 46, 47, 48,\n                    49, 50, 52, 54, 55, 56, 60, 62, 63, 64, 65, 68, 70, 72, 74, 75,\n                    76, 77, 80, 84, 85, 88, 90, 92, 96, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e RANGED_UNLOCKS \u003d\n            Stream.of(5, 10, 16, 19, 20, 21, 25, 26, 28, 30, 31, 35, 36, 37,\n                    39, 40, 42, 45, 46, 47, 50, 55, 60, 61, 62, 64, 65, 66, 70, 75, 77, 80, 85, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e RUNECRAFT_UNLOCKS \u003d\n            Stream.of(2, 5, 6, 9, 10, 11, 13, 14, 15, 19, 20, 22, 23, 25,\n                    26, 27, 28, 30, 33, 35, 38, 40, 42, 44, 46, 48, 49, 50, 52, 54,\n                    55, 56, 57, 59, 60, 65, 66, 70, 74, 75, 76, 77, 78, 79, 81, 82,\n                    84, 85, 88, 90, 91, 92, 95, 98, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e SLAYER_UNLOCKS \u003d\n            Stream.of(5, 7, 10, 15, 17, 18, 20, 22, 25, 30, 32, 33, 35, 37,\n                    38, 39, 40, 42, 44, 45, 47, 48, 50, 52, 55, 56, 57, 58, 60, 62,\n                    63, 65, 66, 68, 69, 70, 72, 75, 77, 80, 82, 83, 84, 85, 87, 90,\n                    91, 92, 93, 95, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e THIEVING_UNLOCKS \u003d\n            Stream.of(2, 5, 10, 13, 14, 15, 16, 17, 20, 21, 22, 23, 25, 27,\n                    28, 30, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,\n                    46, 47, 48, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 61, 62,\n                    64, 65, 66, 70, 71, 72, 75, 78, 80, 81, 82, 84, 85, 90, 91, 93, 94, 95, 99).collect(Collectors.toUnmodifiableSet());\n    static final Set\u003cInteger\u003e WOODCUTTING_UNLOCKS \u003d\n            Stream.of(6, 10, 11, 12, 15, 19, 20, 21, 24, 27, 29, 30, 31, 35,\n                    36, 40, 41, 42, 44, 45, 48, 50, 54, 55, 56, 57, 60, 61, 62, 65,\n                    68, 70, 71, 72, 75, 84, 90, 96, 99).collect(Collectors.toUnmodifiableSet());\n\n    static final Set\u003cInteger\u003e CONSTRUCTION_UNLOCKS \u003d\n            Stream.of(10, 20, 30, 40, 50, 60, 70, 80, 90)\n                    .collect(Collectors.toUnmodifiableSet());\n\n    static final Set\u003cInteger\u003e HITPOINTS_UNLOCKS \u003d\n            IntStream.rangeClosed(50, 99)\n                    .boxed()\n                    .collect(Collectors.toUnmodifiableSet());\n\n    static final Set\u003cInteger\u003e HUNTER_UNLOCKS \u003d\n            IntStream.rangeClosed(1, 99)\n                    .filter(n -\u003e n % 2 \u003d\u003d 1)\n                    .boxed()\n                    .collect(Collectors.toUnmodifiableSet());\n\n    static final Set\u003cInteger\u003e STRENGTH_UNLOCKS \u003d\n            IntStream.rangeClosed(50, 99)\n                    .boxed()\n                    .collect(Collectors.toUnmodifiableSet());\n\n\t// The real and awesomest unlock levels for sailing\n\tstatic final Set\u003cInteger\u003e SAILING_UNLOCKS \u003d\n\t\tStream.of(15, 42, 69, 99).collect(Collectors.toUnmodifiableSet());\n\n\n    public static Map\u003cSkill, Set\u003cInteger\u003e\u003e UNLOCK_LEVELS \u003d Map.ofEntries(\n            Map.entry(Skill.AGILITY, Set.of()),\n            Map.entry(Skill.ATTACK, ATTACK_UNLOCKS),\n            Map.entry(Skill.CONSTRUCTION, CONSTRUCTION_UNLOCKS),\n            Map.entry(Skill.COOKING, COOKING_UNLOCKS),\n            Map.entry(Skill.CRAFTING, CRAFTING_UNLOCKS),\n            Map.entry(Skill.DEFENCE, DEFENCE_UNLOCKS),\n            Map.entry(Skill.FARMING, FARMING_UNLOCKS),\n            Map.entry(Skill.FIREMAKING, FIREMAKING_UNLOCKS),\n            Map.entry(Skill.FISHING, FISHING_UNLOCKS),\n            Map.entry(Skill.FLETCHING, FLETCHING_UNLOCKS),\n            Map.entry(Skill.HERBLORE, HERBLORE_UNLOCKS),\n            Map.entry(Skill.HITPOINTS, HITPOINTS_UNLOCKS),\n            Map.entry(Skill.HUNTER, HUNTER_UNLOCKS),\n            Map.entry(Skill.MAGIC, MAGIC_UNLOCKS),\n            Map.entry(Skill.MINING, MINING_UNLOCKS),\n            Map.entry(Skill.PRAYER, PRAYER_UNLOCKS),\n            Map.entry(Skill.RANGED, RANGED_UNLOCKS),\n            Map.entry(Skill.RUNECRAFT, RUNECRAFT_UNLOCKS),\n            Map.entry(Skill.SLAYER, SLAYER_UNLOCKS),\n            Map.entry(Skill.SMITHING, Set.of()),     //every level is an unlock; smithing.wav is set to the unlock jingle, not the defualt level up sound\n            Map.entry(Skill.STRENGTH, STRENGTH_UNLOCKS),\n            Map.entry(Skill.THIEVING, THIEVING_UNLOCKS),\n            Map.entry(Skill.WOODCUTTING, WOODCUTTING_UNLOCKS),\n            Map.entry(Skill.SAILING, SAILING_UNLOCKS)\n    );\n\n}\n","filePath":"src/main/java/hootisman/unmutedjingles/jingles/JingleData.java"},{"fileName":"UnmutedJinglesPluginTest.java","content":"package hootisman.unmutedjingles;\n\nimport net.runelite.client.RuneLite;\nimport net.runelite.client.externalplugins.ExternalPluginManager;\n\npublic class UnmutedJinglesPluginTest\n{\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tExternalPluginManager.loadBuiltin(UnmutedJinglesPlugin.class);\n\t\tRuneLite.main(args);\n\t}\n}","filePath":"src/test/java/hootisman/unmutedjingles/UnmutedJinglesPluginTest.java"}]}]