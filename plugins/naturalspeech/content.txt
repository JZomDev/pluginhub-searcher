package dev.phyce.naturalspeech;
//package net.runelite.client.plugins.naturalspeech.src.test.java.dev.phyce.naturalspeech;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class NaturalSpeechPluginTest {
	public static void main(String[] args) throws Exception {

/*
		var repo = new VoiceRepository();
		VoiceRepository.PiperVoice piperVoice = repo.loadPiperVoice("en_US-libritts-high");
*/

		ExternalPluginManager.loadBuiltin(NaturalSpeechPlugin.class);
		RuneLite.main(args);
	}
}
package dev.phyce.naturalspeech.downloader;

import java.nio.file.Path;
import javax.inject.Inject;
import javax.inject.Singleton;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;

@Singleton
public class Downloader {
	@Inject
	private OkHttpClient httpClient;

	public DownloadTask create(HttpUrl url, Path destination) {
		return new DownloadTask(httpClient, destination, url, true);
	}
}
package dev.phyce.naturalspeech.downloader;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.util.Objects;
import java.util.function.Supplier;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

@Slf4j
public class DownloadTask implements Supplier<File> {
	@Getter
	private final Path destination;
	private final HttpUrl url;
	private final boolean overwrite;
	private final OkHttpClient httpClient;
	@Getter
	private volatile boolean downloading = false;
	@Getter
	private volatile boolean finished = false;
	@Getter
	private volatile float progress = 0;
	@Getter
	private volatile int error = 0;

	// TODO(Louis) Add a callback that updates the download progress
	public DownloadTask(OkHttpClient httpClient, Path destination, HttpUrl url, boolean overwrite) {
		this.destination = destination;
		this.url = url;
		this.overwrite = overwrite;
		this.httpClient = httpClient;
	}

	public void download(ProgressListener progressListener) {

		if (!destination.toFile().exists() || overwrite) {
			downloading = true;
			Request req = new Request.Builder().url(url).build();
			try (Response response = httpClient.newCall(req).execute()) {
				if (!response.isSuccessful()) {
					error = response.code();
					throw new IOException("Failed to download file: " + response.message());
				}

				int length = (int) Objects.requireNonNull(response.body()).contentLength();
				if (length < 0) {
					length = 3 * 1024 * 1024;
				}
				final int flength = length;

				// try-with-resources to ensure the input stream is closed
				try (InputStream in = response.body().byteStream();
					 OutputStream out = Files.newOutputStream(destination, StandardOpenOption.CREATE,
						 StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING)) {
					byte[] buffer = new byte[1024];
					int bytesRead;
					int totalRead = 0;
					while ((bytesRead = in.read(buffer)) != -1) {
						// check if the connection was closed
						if (bytesRead == 0) throw new IOException("Connection closed");

						out.write(buffer, 0, bytesRead);
						totalRead += bytesRead;
						progress = (float) totalRead / flength * 100;
						if (progressListener != null) progressListener.onProgress(progress);
					}
					progress = 100;
					finished = true;
					downloading = false;
				}
			} catch (IOException e) {
				log.error("Error downloading the file: {}", e.getMessage());
				progress = 0; // Reset progress if download fails
				error = 1;
				downloading = false;
			}
		}
	}

	@Override
	public synchronized File get() {
		if (!finished && !downloading && error == 0) download(null);
		if (error > 0) return null;

		return destination.toFile();
	}

	public interface ProgressListener {
		void onProgress(float progress);
	}
}


package dev.phyce.naturalspeech;

import com.google.inject.Inject;
import com.google.inject.Provider;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import dev.phyce.naturalspeech.exceptions.VoiceSelectionOutOfOption;
import dev.phyce.naturalspeech.tts.MuteManager;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.tts.VoiceID;
import dev.phyce.naturalspeech.tts.VoiceManager;
import dev.phyce.naturalspeech.ui.game.VoiceConfigChatboxTextInput;
import dev.phyce.naturalspeech.utils.TextUtil;
import java.util.List;
import java.util.Objects;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.KeyCode;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.WidgetUtil;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.game.ChatIconManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;

@Slf4j
public class MenuEventHandler {

	private final Client client;
	private final ChatIconManager chatIconManager;
	private final NaturalSpeechConfig config;

	private final TextToSpeech textToSpeech;
	private final Provider<VoiceConfigChatboxTextInput> voiceConfigChatboxTextInputProvider;
	private final VoiceManager voiceManager;
	private final MuteManager muteManager;

	private final int muteIconId;
	private final int unmuteIconId;


	private String getIconImgTag(int iconId) {
		int imgId = chatIconManager.chatIconIndex(iconId);
		return "<img=" + imgId + ">";
	}

	@Inject
	public MenuEventHandler(Client client, ChatIconManager chatIconManager, NaturalSpeechConfig config,
							TextToSpeech textToSpeech,
							Provider<VoiceConfigChatboxTextInput> voiceConfigChatboxTextInputProvider,
							VoiceManager voiceManager, MuteManager muteManager) {
		this.client = client;
		this.chatIconManager = chatIconManager;
		this.config = config;
		this.textToSpeech = textToSpeech;
		this.voiceConfigChatboxTextInputProvider = voiceConfigChatboxTextInputProvider;
		this.voiceManager = voiceManager;
		this.muteManager = muteManager;

		muteIconId =
			chatIconManager.registerChatIcon(ImageUtil.loadImageResource(NaturalSpeechPlugin.class, "mute.png"));
		unmuteIconId =
			chatIconManager.registerChatIcon(ImageUtil.loadImageResource(NaturalSpeechPlugin.class, "unmute.png"));

	}

	@Subscribe
	private void onMenuOpened(MenuOpened event) {
		if (config.holdShiftRightClickMenu() && !client.isKeyPressed(KeyCode.KC_SHIFT)) return;

		if (textToSpeech.activePiperProcessCount() < 1) return;
		final MenuEntry[] entries = event.getMenuEntries();

		List<Integer> interfaces = List.of(
			InterfaceID.FRIEND_LIST,
			InterfaceID.FRIENDS_CHAT,
			InterfaceID.CHATBOX,
			InterfaceID.PRIVATE_CHAT,
			InterfaceID.GROUP_IRON
		);

		List<String> detectableOptions = List.of("Message", "Add friend", "Remove friend");

		for (int index = entries.length - 1; index >= 0; index--) {
			MenuEntry entry = entries[index];

			final int componentId = entry.getParam1();
			final int groupId = WidgetUtil.componentToInterface(componentId);

			if (entry.getType() == MenuAction.PLAYER_EIGHTH_OPTION || entry.getType() == MenuAction.EXAMINE_NPC) {
				drawOptions(entry, index);
			}
			else if (interfaces.contains(groupId) && detectableOptions.contains(entry.getOption())) {
				drawOptions(entry, 1);
			}
		}
	}

	/**
	 * $1 name, $2 level text
	 */

	public void drawOptions(MenuEntry entry, int index) {
		Actor actor = entry.getActor();

		// if there are no targets for this menu entry, it should be a client ui menu entry.
		String standardActorName = actor != null
			// example: Dawncore (level-90)
			? Text.standardize(Objects.requireNonNull(actor.getName()))
			// example: <img=123><col=ffffff>Dawncore</col>
			: Text.standardize(Text.removeTags(entry.getTarget()));
		String targetName = TextUtil.removeLevelFromTargetName(entry.getTarget());

		NPC npc;
		boolean isUnmuted;
		boolean isListened;
		boolean isAllowed;
		if (actor instanceof NPC) {
			npc = Objects.requireNonNull(entry.getNpc());

			isUnmuted = muteManager.isNpcUnmuted(npc);
			isListened = muteManager.isNpcListened(npc);
			isAllowed = muteManager.isNpcAllowed(npc);
		}
		else if (actor instanceof Player) {
			npc = null;

			isUnmuted = muteManager.isUsernameUnmuted(standardActorName);
			isListened = muteManager.isUsernameListened(standardActorName);
			isAllowed = muteManager.isUsernameAllowed(standardActorName);
		}
		else {
			npc = null;
			isUnmuted = muteManager.isUsernameUnmuted(standardActorName);
			isListened = muteManager.isUsernameListened(standardActorName);
			isAllowed = muteManager.isUsernameAllowed(standardActorName);
		}

		String statusColorTag = isAllowed ? "<col=78B159>" : "<col=DD2E44>";
		String status = isAllowed ? getIconImgTag(unmuteIconId) : getIconImgTag(muteIconId);

		{
			VoiceID voiceID;
			if (npc != null) {
				try {
					voiceID = voiceManager.getVoiceIDFromNPCId(npc.getId(), npc.getName());
				} catch (VoiceSelectionOutOfOption ignored) {
					voiceID = null;
				}

				if (!voiceManager.containsNPC(npc.getId(), Objects.requireNonNull(npc.getName()))) {
					statusColorTag = "<col=888888>";
				}
			}
			else {
				try {
					voiceID = voiceManager.getVoiceIDFromUsername(standardActorName);
				} catch (VoiceSelectionOutOfOption ignored) {
					voiceID = null;
					log.error("Voice Selection Out of option for {}", standardActorName);
				}

				if (!voiceManager.containsUsername(standardActorName)) {
					statusColorTag = "<col=888888>";
				}
			}


			String target;
			if (voiceID != null) {
				target = String.format("%s %s(%s)</col>", targetName, statusColorTag, voiceID);
			}
			else {
				target = String.format("%s %s(voice-error)</col>", targetName, statusColorTag);
			}

			MenuEntry parent = client.createMenuEntry(index + 1)
				.setOption(status + " Voice")
				.setTarget(target)
				.setType(MenuAction.RUNELITE);

			Menu subMenu = parent.createSubMenu();

			if (isListened) {
				subMenu.createMenuEntry(0)
					.setOption("Unlisten")
					.setType(MenuAction.RUNELITE)
					.onClick(e -> {
						if (npc != null) {
							muteManager.unlistenNpc(npc);
						}
						else {
							muteManager.unlistenUsername(standardActorName);
						}
					});
			}
			else {
				subMenu.createMenuEntry(0)
					.setOption("Listen")
					.setType(MenuAction.RUNELITE)
					.onClick(e -> {
						if (npc != null) {
							muteManager.listenNpc(npc);
						}
						else {
							muteManager.listenUsername(standardActorName);
						}
						muteManager.setListenMode(true);
					});
			}

			{
				final String value = voiceID != null ? voiceID.toVoiceIDString() : "";
				subMenu.createMenuEntry(1)
					.setOption("Configure")
					.setType(MenuAction.RUNELITE)
					.onClick(e -> {
						voiceConfigChatboxTextInputProvider.get()
							.configNPC(npc) // can be null and will be ignored
							.configUsername(standardActorName)
							.value(value)
							.build();
					});
			}

			if (muteManager.isListenMode()) {
				subMenu.createMenuEntry(1)
					.setOption("Stop Listen Mode")
					.setType(MenuAction.RUNELITE)
					.onClick(e -> {
						muteManager.setListenMode(false);
						muteManager.clearListens();
					});
			}
			else {
				if (isUnmuted) {
					subMenu.createMenuEntry(1)
						.setOption("Mute")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> {
							if (npc != null) {
								muteManager.muteNpc(npc);
							}
							else {
								muteManager.muteUsername(standardActorName);
							}
						});

				}
				else {
					subMenu.createMenuEntry(1)
						.setOption("Unmute")
						.setType(MenuAction.RUNELITE)
						.onClick(e -> {
							if (npc != null) {
								muteManager.unmuteNpc(npc);
							}
							else {
								muteManager.unmuteUsername(standardActorName);
							}
						});
				}
			}
		}
	}
}

package dev.phyce.naturalspeech;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import com.google.inject.Binder;
import com.google.inject.Inject;
import com.google.inject.Provides;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import static dev.phyce.naturalspeech.configs.NaturalSpeechConfig.CONFIG_GROUP;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig.ConfigKeys;
import dev.phyce.naturalspeech.configs.NaturalSpeechRuntimeConfig;
import dev.phyce.naturalspeech.downloader.Downloader;
import dev.phyce.naturalspeech.helpers.PluginHelper;
import dev.phyce.naturalspeech.spamdetection.ChatFilterPluglet;
import dev.phyce.naturalspeech.spamdetection.SpamFilterPluglet;
import dev.phyce.naturalspeech.tts.MagicUsernames;
import dev.phyce.naturalspeech.tts.MuteManager;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.tts.VoiceID;
import dev.phyce.naturalspeech.tts.VoiceManager;
import dev.phyce.naturalspeech.ui.panels.TopLevelPanel;
import java.awt.image.BufferedImage;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ClientShutdown;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import org.slf4j.LoggerFactory;


@Slf4j
@PluginDescriptor(name=CONFIG_GROUP)
public class NaturalSpeechPlugin extends Plugin {
	//<editor-fold desc="> RuneLite Dependencies">
	@Inject
	private ClientToolbar clientToolbar;
	@Inject
	private ConfigManager configManager;
	@Inject
	private Client client;
	@Inject
	private NaturalSpeechConfig config;
	@Inject
	private EventBus eventBus;

	//</editor-fold>

	//<editor-fold desc="> Internal Dependencies">
	private NaturalSpeechRuntimeConfig runtimeConfig;
	private VoiceManager voiceManager;
	private MuteManager muteManager;
	private TextToSpeech textToSpeech;
	private SpamFilterPluglet spamFilterPluglet;
	private ChatFilterPluglet chatFilterPluglet;
	private SpamDetection spamDetection;
	private SpeechEventHandler speechEventHandler;
	private MenuEventHandler menuEventHandler;
	private CommandExecutedEventHandler commandExecutedEventHandler;

	//</editor-fold>

	//<editor-fold desc="> Runtime Variables">
	private NavigationButton navButton;
	//</editor-fold>

	static {

		final Logger logger = (Logger) LoggerFactory.getLogger(NaturalSpeechPlugin.class.getPackageName());

		String result = System.getProperty("nslogger");
		if (result != null) {
			log.info("nslogger VM property found, setting logger level to {}", result);
			logger.setLevel(Level.valueOf(result));
		}
		else {
			logger.setLevel(Level.INFO);
		}
	}

	private TopLevelPanel topLevelPanel;

	//<editor-fold desc="> Override Methods">
	@Override
	public void configure(Binder binder) {
		// Instantiate PluginHelper early, Plugin relies on static PluginHelper::Instance
		// No cycling-dependencies back at NaturalSpeechPlugin allowed
		// quality-of-life abstraction for coding
		binder.bind(PluginHelper.class).asEagerSingleton();
		// Downloader has all dependencies from RuneLite, eager load
		binder.bind(Downloader.class).asEagerSingleton();
	}

	@Override
	public void startUp() {

		runtimeConfig = injector.getInstance(NaturalSpeechRuntimeConfig.class);
		textToSpeech = injector.getInstance(TextToSpeech.class);
		voiceManager = injector.getInstance(VoiceManager.class);
		muteManager = injector.getInstance(MuteManager.class);
		spamFilterPluglet = injector.getInstance(SpamFilterPluglet.class);
		chatFilterPluglet = injector.getInstance(ChatFilterPluglet.class);
		spamDetection = injector.getInstance(SpamDetection.class);

		// Abstracting the massive client event handlers into their own files
		speechEventHandler = injector.getInstance(SpeechEventHandler.class);
		menuEventHandler = injector.getInstance(MenuEventHandler.class);
		commandExecutedEventHandler = injector.getInstance(CommandExecutedEventHandler.class);

		// registers to eventbus, make sure to unregister on shutdown()
		eventBus.register(speechEventHandler);
		eventBus.register(menuEventHandler);
		eventBus.register(commandExecutedEventHandler);
		eventBus.register(spamFilterPluglet);
		eventBus.register(chatFilterPluglet);

		// Build panel and navButton
		{
			topLevelPanel = injector.getInstance(TopLevelPanel.class);
			final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
			navButton = NavigationButton.builder()
				.tooltip("Natural Speech")
				.icon(icon)
				.priority(1)
				.panel(topLevelPanel)
				.build();
			clientToolbar.addNavigation(navButton);
		}

		// Load ShortenedPhrases is a method that can be called later when configs are changed
		textToSpeech.loadShortenedPhrases();


		if (config.autoStart()) {
			textToSpeech.start();
		}

		updateConfigVoice(ConfigKeys.PERSONAL_VOICE, config.personalVoiceID());
		updateConfigVoice(ConfigKeys.GLOBAL_NPC_VOICE, config.globalNpcVoice());
		updateConfigVoice(ConfigKeys.SYSTEM_VOICE, config.systemVoice());

		log.info("NaturalSpeech plugin has started");
	}

	@Override
	public void shutDown() {
		// unregister eventBus so handlers do not run after shutdown.
		eventBus.unregister(speechEventHandler);
		eventBus.unregister(menuEventHandler);
		eventBus.unregister(commandExecutedEventHandler);
		eventBus.unregister(spamFilterPluglet);
		eventBus.unregister(chatFilterPluglet);

		topLevelPanel.shutdown();

		if (textToSpeech != null) {
			textToSpeech.stop();
		}
		clientToolbar.removeNavigation(navButton);

		saveConfigs();

		log.info("NaturalSpeech plugin has shutDown");
	}

	@Subscribe
	private void onClientShutdown(ClientShutdown e) {
		// shutDown is not called on X button client exit, so we need to listen to clientShutdown
		saveConfigs();
	}

	private void saveConfigs() {
		voiceManager.saveVoiceConfig();
		textToSpeech.saveModelConfig();
		runtimeConfig.savePiperPath(runtimeConfig.getPiperPath());
		muteManager.saveConfig();
	}

	@Override
	public void resetConfiguration() {
		runtimeConfig.reset();
	}
	//</editor-fold>

	//<editor-fold desc="> Hooks">

	@Subscribe
	private void onConfigChanged(ConfigChanged event) {
		if (!event.getGroup().equals(CONFIG_GROUP)) return;

		if (textToSpeech.activePiperProcessCount() < 1) {
			switch (event.getKey()) {
				case ConfigKeys.MUTE_SELF:
					log.trace("Detected mute-self toggle, clearing audio queue.");
					textToSpeech.clearPlayerAudioQueue(MagicUsernames.LOCAL_USER);
					break;

				case ConfigKeys.MUTE_OTHERS:
					log.trace("Detected mute-others toggle, clearing audio queue.");
					textToSpeech.clearOtherPlayersAudioQueue(MagicUsernames.LOCAL_USER);
					break;

			}
		}

		switch (event.getKey()) {
			case ConfigKeys.SHORTENED_PHRASES:
				log.trace("Detected short phrase changes, reloading into TextToSpeech");
				textToSpeech.loadShortenedPhrases();
				break;

			case ConfigKeys.PERSONAL_VOICE:
			case ConfigKeys.GLOBAL_NPC_VOICE:
			case ConfigKeys.SYSTEM_VOICE:
				log.trace("Detected voice changes from config, loading in new voices");
				updateConfigVoice(event.getKey(), event.getNewValue());
				break;
		}

	}


	private void updateConfigVoice(String configKey, String voiceString) {
		VoiceID voiceID;
		voiceID = VoiceID.fromIDString(voiceString);

		switch (configKey) {
			case ConfigKeys.PERSONAL_VOICE:
				if (voiceID != null) {
					log.debug("Setting voice for {} to {}", MagicUsernames.LOCAL_USER, voiceID);
					voiceManager.setDefaultVoiceIDForUsername(MagicUsernames.LOCAL_USER, voiceID);
				}
				else {
					log.debug("Invalid voice for {}, resetting voices.", MagicUsernames.LOCAL_USER);
					voiceManager.resetForUsername(MagicUsernames.LOCAL_USER);
				}
				break;
			case ConfigKeys.GLOBAL_NPC_VOICE:
				if (voiceID != null) {
					log.debug("Setting voice for {} to {}", MagicUsernames.GLOBAL_NPC, voiceID);
					voiceManager.setDefaultVoiceIDForUsername(MagicUsernames.GLOBAL_NPC, voiceID);
				}
				else {
					log.debug("Invalid voice for {}, resetting voices.", MagicUsernames.GLOBAL_NPC);
					voiceManager.resetForUsername(MagicUsernames.GLOBAL_NPC);
				}
				break;
			case ConfigKeys.SYSTEM_VOICE:
				if (voiceID != null) {
					log.debug("Setting voice for {} to {}", MagicUsernames.SYSTEM, voiceID);
					voiceManager.setDefaultVoiceIDForUsername(MagicUsernames.SYSTEM, voiceID);
				}
				else {
					log.debug("Invalid voice for {}, resetting voices.", MagicUsernames.SYSTEM);
					voiceManager.resetForUsername(MagicUsernames.SYSTEM);
				}
				break;
		}
	}

	//</editor-fold>


	@Provides
	NaturalSpeechConfig provideConfig(ConfigManager configManager) {
		return configManager.getConfig(NaturalSpeechConfig.class);
	}


}

package dev.phyce.naturalspeech;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import com.google.inject.Inject;
import dev.phyce.naturalspeech.tts.MagicUsernames;
import dev.phyce.naturalspeech.tts.VoiceID;
import dev.phyce.naturalspeech.tts.VoiceManager;
import java.util.Arrays;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.CommandExecuted;
import net.runelite.client.eventbus.Subscribe;
import org.slf4j.LoggerFactory;

@Slf4j
public class CommandExecutedEventHandler {

	private final Client client;
	private final VoiceManager voiceManager;

	@Inject
	public CommandExecutedEventHandler(Client client, VoiceManager voiceManager) {
		this.client = client;
		this.voiceManager = voiceManager;
	}

	@Subscribe
	private void onCommandExecuted(CommandExecuted commandExecuted) {
		String[] args = commandExecuted.getArguments();

		//noinspection SwitchStatementWithTooFewBranches
		switch (commandExecuted.getCommand()) {
			case "nslogger": {
				final Logger logger = (Logger) LoggerFactory.getLogger(NaturalSpeechPlugin.class.getPackageName());
				String message;
				Level currentLoggerLevel = logger.getLevel();

				if (args.length < 1) {
					message = "Logger level is currently set to " + currentLoggerLevel;
				}
				else {
					Level newLoggerLevel = Level.toLevel(args[0], currentLoggerLevel);
					logger.setLevel(newLoggerLevel);
					message = "Logger level has been set to " + newLoggerLevel;
				}

				client.addChatMessage(ChatMessageType.CONSOLE, "", message, null);
				break;
			}
			case "setvoice": {
				if (args.length < 2) {
					client.addChatMessage(ChatMessageType.CONSOLE, "",
						"use ::setvoice model:id username, for example ::setvoice libritts:2 Zezima", null);
				}
				else {
					VoiceID voiceId = VoiceID.fromIDString(args[0]);
					String username = Arrays.stream(args).skip(1).reduce((a, b) -> a + " " + b).orElse(args[1]);
					if (voiceId == null) {
						client.addChatMessage(ChatMessageType.CONSOLE, "", "voice id " + args[1] + " is invalid.",
							null);
					}
					else {
						voiceManager.setDefaultVoiceIDForUsername(username, voiceId);
						client.addChatMessage(ChatMessageType.CONSOLE, "", username + " voice is set to " + args[0],
							null);
					}
				}
				break;
			}
			case "unsetvoice": {
				if (args.length < 1) {
					client.addChatMessage(ChatMessageType.CONSOLE, "",
						"use ::unsetvoice username, for example ::unsetvoice Zezima", null);
				}
				else {
					String username = Arrays.stream(args).reduce((a, b) -> a + " " + b).orElse(args[0]);
					voiceManager.resetForUsername(username);
					client.addChatMessage(ChatMessageType.CONSOLE, "",
						"All voices are removed for " + username, null);
				}
				break;
			}
			case "checkvoice": {
				String username;
				if (args.length < 1) {
					//					client.addChatMessage(ChatMessageType.CONSOLE, "",
					//						"use ::checkvoice username, for example ::checkvoice Zezima", null);
					username = MagicUsernames.LOCAL_USER;
				}
				else {
					username = Arrays.stream(args).reduce((a, b) -> a + " " + b).orElse(args[0]);
				}

				List<VoiceID> voiceIds = voiceManager.checkVoiceIDWithUsername(username);
				if (voiceIds == null) {
					client.addChatMessage(ChatMessageType.CONSOLE, "",
						"There are no voices set for " + username + ".", null);
				}
				else {
					String idStr = voiceIds.stream().map(VoiceID::toString).reduce((a, b) -> a + ", " + b)
						.orElse("No voice set");
					client.addChatMessage(ChatMessageType.CONSOLE, "", username + " voice is set to " + idStr, null);
				}
				break;
			}
		}
	}


}

package dev.phyce.naturalspeech.events;

import dev.phyce.naturalspeech.intruments.VoiceHistory;

public class TextToSpeechSpoke {
	public final VoiceHistory voiceHistory;

	public TextToSpeechSpoke(VoiceHistory voiceHistory) {
		this.voiceHistory = voiceHistory;
	}
}

package dev.phyce.naturalspeech.intruments;

import dev.phyce.naturalspeech.tts.VoiceID;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.Value;

@Data
public class VoiceHistory {
	String source;
	String text;
	List<Reason> history = new ArrayList<>();

	public VoiceHistory() {
	}

	public VoiceHistory(String source, String text) {
		this.source = source;
		this.text = text;
	}

	@Value
	public static class Reason {
		VoiceID voiceID;
		String reason;
	}
}

package dev.phyce.naturalspeech.intruments;

/*

import com.google.inject.Singleton;
import dev.phyce.naturalspeech.tts.VoiceID;
import lombok.extern.slf4j.Slf4j;

// Not currently being used anywhere
@Singleton
@Slf4j
public class VoiceLogger {

	private static VoiceLogger instance;

	public VoiceHistory current;

	public VoiceLogger() {
		instance = this;
	}

	public static void startRecord() {
		if (instance == null) {
			throw new RuntimeException("VoiceLogger was not initialized.");
		}
		instance._startRecord();
	}

	public static VoiceHistory stopRecord() {
		if (instance == null) {
			throw new RuntimeException("VoiceLogger was not initialized.");
		}
		return instance._stopRecord();
	}

	public static void addReason(VoiceID voiceID, String reason) {
		instance._addReason(voiceID, reason);
	}

	private void _addReason(VoiceID voiceID, String reason) {
		// silently ignore when not recording
		if (current == null) {
			return;
		}

		current.history.add(new VoiceHistory.Reason(voiceID, reason));
	}

	private void _startRecord() {
		// probably two threads fighting over the logger
		if (current != null) {
			throw new RuntimeException("VoiceLogger StartRecord called when already recording. " +
				"Might two threads fighting over the logger. (or called twice due to bug)");
		}
		current = new VoiceHistory();
	}

	private VoiceHistory _stopRecord() {
		// probably two threads fighting over the logger
		if (current == null) {
			throw new RuntimeException("VoiceLogger StartRecord called when already recording. " +
				"Might two threads fighting over the logger. (or called twice due to bug)");
		}

		VoiceHistory result = current;
		current = null;

		return result;
	}



}
*/
package dev.phyce.naturalspeech;

import com.google.inject.Inject;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import static dev.phyce.naturalspeech.enums.Locations.inGrandExchange;
import dev.phyce.naturalspeech.exceptions.ModelLocalUnavailableException;
import dev.phyce.naturalspeech.exceptions.VoiceSelectionOutOfOption;
import dev.phyce.naturalspeech.helpers.PluginHelper;
import static dev.phyce.naturalspeech.helpers.PluginHelper.*;
import dev.phyce.naturalspeech.tts.MagicUsernames;
import dev.phyce.naturalspeech.tts.MuteManager;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.tts.VoiceID;
import dev.phyce.naturalspeech.tts.VoiceManager;
import dev.phyce.naturalspeech.utils.TextUtil;
import java.util.Objects;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.OverheadTextChanged;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.util.Text;

@Slf4j
public class SpeechEventHandler {

	private final Client client;
	private final NaturalSpeechConfig config;
	private final TextToSpeech textToSpeech;
	private final VoiceManager voiceManager;
	private final MuteManager muteManager;
	private final SpamDetection spamDetection;

	private final ClientThread clientThread;

	@Inject
	public SpeechEventHandler(Client client, TextToSpeech textToSpeech, NaturalSpeechConfig config,
							  VoiceManager voiceManager, MuteManager muteManager, SpamDetection spamDetection, ClientThread clientThread) {
		this.client = client;
		this.textToSpeech = textToSpeech;
		this.config = config;
		this.voiceManager = voiceManager;
		this.muteManager = muteManager;
		this.spamDetection = spamDetection;

		this.clientThread = clientThread;
	}

	@Subscribe(priority=-100)
	private void onChatMessage(ChatMessage message) throws ModelLocalUnavailableException {
		if (textToSpeech.activePiperProcessCount() == 0) return;
		log.debug("Message received: " + message.toString());

		String username;
		int distance;
		VoiceID voiceId;
		username = Text.standardize(message.getName());
		message.setName(username);
		String text = message.getMessage()
			.replace("<lt>", "<")
			.replace("<gt>", ">");


		if (isChatMessageMuted(message)) return;

		try {
			if (isChatInnerVoice(message)) {
				username = MagicUsernames.LOCAL_USER;
				distance = 0;
				voiceId = voiceManager.getVoiceIDFromUsername(username);
				text = textToSpeech.expandShortenedPhrases(text);

				log.debug("Inner voice {} used for {} for {}. ", voiceId, message.getType(), username);
			}
			else if (isChatOtherPlayerVoice(message)) {
				distance = config.distanceFadeEnabled()? getDistance(username) : 0;
				voiceId = voiceManager.getVoiceIDFromUsername(username);
				text = textToSpeech.expandShortenedPhrases(text);

				log.debug("Player voice {} used for {} for {}. ", voiceId, message.getType(), username);
			}
			else if (isChatSystemVoice(message.getType())) {
				username = MagicUsernames.SYSTEM;
				distance = 0;
				text = Text.removeTags(text);
				text = Text.standardize(text);
				voiceId = voiceManager.getVoiceIDFromUsername(username);

				log.debug("System voice {} used for {} for {}. ", voiceId, message.getType(), username);
			}
			else {
				log.debug("ChatMessage ignored, didn't match innerVoice, otherPlayerVoice, or SystemVoice. name:{} type:{} message:{}",
					message.getName(), message.getType(), message.getMessage());
				return;
			}
		} catch (VoiceSelectionOutOfOption e) {
			log.error("Voice Selection ran out of options. No suitable active voice found name:{} type:{} message:{}",
				message.getName(), message.getType(), message.getMessage());
			return;
		}

		textToSpeech.speak(voiceId, text, distance, username);
	}

	@Subscribe(priority=-100)
	private void onWidgetLoaded(WidgetLoaded event) {
		if(!config.dialogEnabled())return;
		if (event.getGroupId() == InterfaceID.DIALOG_PLAYER) {
			// InvokeAtTickEnd to wait until the text has loaded in
			clientThread.invokeAtTickEnd(() -> {
				Widget textWidget = client.getWidget(ComponentID.DIALOG_PLAYER_TEXT);
				if (textWidget == null || textWidget.getText() == null) {
					log.error("Player dialog textWidget or textWidget.getText() is null");
					return;
				}
				log.trace("Player dialog textWidget detected:{}", textWidget.getText());
				String text = Text.sanitizeMultilineText(textWidget.getText());
				VoiceID voiceID;
				try {
					voiceID = voiceManager.getVoiceIDFromUsername(MagicUsernames.LOCAL_USER);
				} catch (VoiceSelectionOutOfOption e) {
					throw new RuntimeException(e);
				}
				textToSpeech.speak(voiceID, text, 0, MagicUsernames.LOCAL_USER);
			});
		} else if (event.getGroupId() == InterfaceID.DIALOG_NPC) {
			// InvokeAtTickEnd to wait until the text has loaded in
			clientThread.invokeAtTickEnd(() -> {
				Widget textWidget = client.getWidget(ComponentID.DIALOG_NPC_TEXT);
				Widget headModelWidget = client.getWidget(ComponentID.DIALOG_NPC_HEAD_MODEL);
				Widget npcNameWidget = client.getWidget(ComponentID.DIALOG_NPC_NAME);

				if (textWidget == null || textWidget.getText() == null) {
					log.error("NPC dialog textWidget or textWidget.getText() is null");
					return;
				}
				if (headModelWidget == null) {
					log.error("NPC head model textWidget is null");
					return;
				}
				if (npcNameWidget == null) {
					log.error("NPC name textWidget is null");
					return;
				}
				log.trace("NPC dialog textWidget detected:{}", textWidget.getText());

				String text = Text.sanitizeMultilineText(textWidget.getText());
				String npcName = npcNameWidget.getText();
				int npcCompId = headModelWidget.getModelId();

				if (!muteManager.isNpcIdAllowed(npcCompId)) {
					log.debug("NPC Dialogue is muted. CompId:{} NPC name:{}", npcCompId, npcName);
					return;
				}

				VoiceID voiceID;
				try { voiceID = voiceManager.getVoiceIDFromNPCId(npcCompId, npcName); }
				catch (VoiceSelectionOutOfOption e) { throw new RuntimeException(e); }

				textToSpeech.speak(voiceID, text, 0, npcName);
			});
		}
	}

	@Subscribe(priority=-1)
	private void onOverheadTextChanged(OverheadTextChanged event) {
		if (textToSpeech.activePiperProcessCount() < 1) return;

		if (event.getActor() instanceof NPC) {
			if (!config.npcOverheadEnabled()) return;
			NPC npc = (NPC) event.getActor();
			if (!muteManager.isNpcAllowed(npc)) return;

			int distance = PluginHelper.getActorDistance(event.getActor());

			VoiceID voiceID = null;
			try {
				voiceID = voiceManager.getVoiceIDFromNPCId(npc.getId(), npc.getName());
				textToSpeech.speak(voiceID, event.getOverheadText(), distance, npc.getName());
			} catch (VoiceSelectionOutOfOption e) {
				log.error(
					"Voice Selection ran out of options for NPC. No suitable active voice found NPC ID:{} NPC name:{}",
					npc.getId(), npc.getName());
			}
		}
	}

	public static boolean isChatInnerVoice(ChatMessage message) {
		switch (message.getType()) {
			case PUBLICCHAT:
				return Objects.equals(Text.standardize(message.getName()), getLocalPlayerUsername());
			case PRIVATECHATOUT:
			case MODPRIVATECHAT:
			case ITEM_EXAMINE:
			case NPC_EXAMINE:
			case OBJECT_EXAMINE:
			case TRADEREQ:
				return true;
			default:
				return false;
		}
	}

	public static boolean isChatOtherPlayerVoice(ChatMessage message) {
		switch (message.getType()) {
			case PUBLICCHAT:
				return !Objects.equals(Text.standardize(message.getName()), getLocalPlayerUsername());
			case MODCHAT:
			case PRIVATECHAT:
			case MODPRIVATECHAT:
			case FRIENDSCHAT:
			case CLAN_CHAT:
			case CLAN_GUEST_CHAT:
				//			case TRADEREQ:
				return true;
			default:
				return false;
		}
	}

	public static boolean isChatSystemVoice(ChatMessageType messageType) {
		switch (messageType) {
			case ENGINE:
			case LOGINLOGOUTNOTIFICATION:
			case BROADCAST:
			case IGNORENOTIFICATION:
			case CLAN_MESSAGE:
			case CONSOLE:
			case TRADE:
			case PLAYERRELATED:
			case TENSECTIMEOUT:
			case WELCOME:
			case CLAN_CREATION_INVITATION:
			case CLAN_GIM_FORM_GROUP:
			case CLAN_GIM_GROUP_WITH:
			case GAMEMESSAGE:
				return true;
			default:
				return false;
		}
	}

	public boolean isChatMessageMuted(ChatMessage message) {
		if (message.getType() == ChatMessageType.AUTOTYPER) return true;
		// dialog messages are handled in onWidgetLoad
		if (message.getType() == ChatMessageType.DIALOG) return true;

		// example: "::::::))))))" (no alpha numeric, muted)
		if (!TextUtil.containAlphaNumeric(message.getMessage())) {
			log.trace("Muting message. No alpha numeric characters. Message:{}", message.getMessage());
			return true;
		}
		// console messages seems to be errors and warnings from other plugins, mute
		if (message.getType() == ChatMessageType.CONSOLE) {
			log.trace("Muting console message. Message:{}", message.getMessage());
			return true;
		}

		if (isMessageTypeDisabledInConfig(message)) {
			log.trace("Muting message. Disabled message type {}. Message:{}", message.getType(), message.getMessage());
			return true;
		}

		if (isTooCrowded()) return true;

		if (message.getType() == ChatMessageType.PUBLICCHAT && isAreaDisabled()) {
			log.trace("Muting message. Area is disabled. Message:{}", message.getMessage());
			return true;
		}

		if (isSelfMuted(message)) {
			log.trace("Muting message. Self muted. Message:{}", message.getMessage());
			return true;
		}


		if (isMutingOthers(message)) {
			log.trace("Muting message. Muting others. Message:{}", message.getMessage());
			return true;
		}

		if (checkMuteLevelThreshold(message)) {
			log.trace("Muting message. Mute level threshold. Message:{}", message.getMessage());
			return true;
		}

		if (!muteManager.isUsernameAllowed(Text.standardize(Text.removeTags(message.getName())))) {
			log.trace("Muting message. Username is muted. Message:{}", message.getMessage());
			return true;
		}

		//noinspection RedundantIfStatement
		if (spamDetection.isSpam(message.getName(), message.getMessage())) {
			log.trace("Muting message. Spam detected. Message:{}", message.getMessage());
			return true;
		}

		return false;
	}

	private boolean isTooCrowded() {
		Player localPlayer = client.getLocalPlayer();
		if (localPlayer == null) return false;

		int count = (int) client.getPlayers().stream()
			.filter(player -> player != localPlayer) // Exclude the local player themselves
			.filter(player -> player.getWorldLocation().distanceTo(localPlayer.getWorldLocation()) <=
				15) // For example, within 15 tiles
			.count();

		if (PluginHelper.getConfig().muteCrowds() > 0 && PluginHelper.getConfig().muteCrowds() < count) return true;
		log.debug("Number of players around: " + count);
		return false;
	}

	private boolean isAreaDisabled() {
		if (client.getLocalPlayer() == null) return false;
		//noinspection RedundantIfStatement
		if (config.muteGrandExchange() && inGrandExchange(client.getLocalPlayer().getWorldLocation())) return true;

		return false;
	}

	public boolean isMessageTypeDisabledInConfig(ChatMessage message) {
		switch (message.getType()) {
			case PUBLICCHAT:
				if (!config.publicChatEnabled()) return true;
				break;
			case PRIVATECHAT:
				if (!config.privateChatEnabled()) return true;
				break;
			case PRIVATECHATOUT:
				if (!config.privateOutChatEnabled()) return true;
				break;
			case FRIENDSCHAT:
				if (!config.friendsChatEnabled()) return true;
				break;
			case CLAN_CHAT:
				if (!config.clanChatEnabled()) return true;
				break;
			case CLAN_GUEST_CHAT:
				if (!config.clanGuestChatEnabled()) return true;
				break;
			case OBJECT_EXAMINE:
			case ITEM_EXAMINE:
			case NPC_EXAMINE:
				if (!config.examineChatEnabled()) return true;
				break;
			case WELCOME:
			case GAMEMESSAGE:
			case CONSOLE:
				if (!config.systemMesagesEnabled()) return true;
				break;
			case TRADEREQ:
			case CHALREQ_CLANCHAT:
			case CHALREQ_FRIENDSCHAT:
			case CHALREQ_TRADE:
				if (!config.requestsEnabled()) return true;
				break;
		}
		return false;
	}

	private boolean isSelfMuted(ChatMessage message) {
		//noinspection RedundantIfStatement
		if (config.muteSelf() && message.getName().equals(PluginHelper.getLocalPlayerUsername())) return true;
		return false;
	}

	private boolean isMutingOthers(ChatMessage message) {
		if (isNPCChatMessage(message)) return false;
		return config.muteOthers() && !message.getName().equals(PluginHelper.getLocalPlayerUsername());
	}

	private boolean checkMuteLevelThreshold(ChatMessage message) {
		if (isNPCChatMessage(message)) return false;
		if (Objects.equals(MagicUsernames.LOCAL_USER, message.getName())) return false;
		if (message.getType() == ChatMessageType.PRIVATECHAT) return false;
		if (message.getType() == ChatMessageType.PRIVATECHATOUT) return false;
		if (message.getType() == ChatMessageType.CLAN_CHAT) return false;
		if (message.getType() == ChatMessageType.CLAN_GUEST_CHAT) return false;
		//noinspection RedundantIfStatement
		if (getLevel(message.getName()) < config.muteLevelThreshold()) return true;


		return false;
	}


	private static int getGroupId(int component) {
		return component >> 16;
	}

	private static int getChildId(int component) {
		return component & '\uffff';
	}

}

package dev.phyce.naturalspeech.helpers;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;

@Slf4j
public class CustomMenuEntry {
	@Getter
	private final String text;
	private final int index;
	@Getter
	private final Consumer<CustomMenuEntry> action;
	@Getter
	private final List<CustomMenuEntry> children = new ArrayList<>();

	public CustomMenuEntry(String text, int index) {
		this.text = text;
		this.action = entry -> {
			log.info("no function for custom menu entry main");
		};
		this.index = index;
	}

	public CustomMenuEntry(String text, int index, Consumer<CustomMenuEntry> action) {
		this.text = text;
		this.action = action;
		this.index = index;
	}

	public void addChild(CustomMenuEntry child) {
		children.add(child);
	}

	public void addMenuEntry(Client client, String option, Consumer<CustomMenuEntry> action,
							 CustomMenuEntry[] children) {

		MenuEntry parentEntry = client.createMenuEntry(this.index)
			.setOption(option)
			.setTarget("")
			.setType(MenuAction.RUNELITE)
			.onClick(consumer -> action.accept(this));

		for (CustomMenuEntry child : children) {
			MenuEntry childEntry = client.createMenuEntry(child.index)
				.setOption(child.text)
				.setTarget("")
				.setType(MenuAction.RUNELITE)
				.onClick(consumer -> child.action.accept(child));

//			childEntry.setParent(parentEntry);
		}
	}

	public void addTo(Client client) {
		addMenuEntry(client, this.text, this.action, this.children.toArray(new CustomMenuEntry[0]));
	}
}
package dev.phyce.naturalspeech.helpers;

import dev.phyce.naturalspeech.enums.Gender;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import java.util.Collections;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.CheckForNull;
import javax.inject.Inject;
import javax.inject.Singleton;
import lombok.Getter;
import lombok.NonNull;
import net.runelite.api.Actor;
import net.runelite.api.Client;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.util.Text;

// renamed: PlayerCommon
@Singleton
public final class PluginHelper {
	private static PluginHelper instance;
	@Inject
	private NaturalSpeechConfig config;
	@Inject
	private Client client;

	@Getter
	private static final Set<String> allowList = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());
	@Getter
	private static final Set<String> blockList = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());

	public PluginHelper() {
		// single guarantees one instance, no checks needed
		instance = this;
	}

	public static NaturalSpeechConfig getConfig() {
		return instance.config;
	}

	@CheckForNull
	public static String getLocalPlayerUsername() {
		if (instance.client.getLocalPlayer() == null || instance.client.getLocalPlayer().getName() == null) {
			return null;
		}

		String username = instance.client.getLocalPlayer().getName();
		username = Text.standardize(username);
		return username;
	}

	@CheckForNull
	public static Gender getLocalPlayerGender() {
		return Gender.parseInt(instance.client.getLocalPlayer().getPlayerComposition().getGender());
	}

	public static Player findPlayerWithUsername(@NonNull String username) {
		username = Text.standardize(username);
		for (Player player : instance.client.getCachedPlayers()) {
			if (player != null && player.getName() != null && Text.standardize(player.getName()).equals(username)) {
				return player;
			}
		}
		return null;
	}

	public static int getLevel(@NonNull String username) {
		Player targetPlayer = findPlayerWithUsername(username);

		if (targetPlayer == null) return 0;

		return targetPlayer.getCombatLevel();
	}

	public static int getDistance(@NonNull String username) {
		// For local player distance is 0
		if (Objects.equals(getLocalPlayerUsername(), username)) return 0;

		Player localPlayer = instance.client.getLocalPlayer();
		Player targetPlayer = findPlayerWithUsername(username);

		if (localPlayer == null || targetPlayer == null) return 0;

		return localPlayer
			.getWorldLocation()
			.distanceTo(targetPlayer.getWorldLocation());
	}

	public static int getNPCDistance(@NonNull NPC npc) {
		Player localPlayer = instance.client.getLocalPlayer();

		if (localPlayer == null) return 0;

		int distance = localPlayer
			.getWorldLocation()
			.distanceTo(npc.getWorldLocation());

		// FIXME(Louis) Over 15 would play at max volume
		if (distance < 0 || 15 < distance) return 0;

		return distance;
	}

	public static int getActorDistance(@NonNull Actor actor) {
		Player localPlayer = instance.client.getLocalPlayer();

		if (localPlayer == null) return 0;

		int distance = localPlayer
			.getWorldLocation()
			.distanceTo(actor.getWorldLocation());

		// FIXME(Louis) Over 15 would play at max volume
		if (distance < 0 || 15 < distance) return 0;

		return distance;
	}

//	public static boolean isBeingListened(@NonNull String username) {
//		if (allowList.isEmpty() && blockList.isEmpty()) return true;
//		if (!allowList.isEmpty() && allowList.contains(username)) return true;
//		return !blockList.isEmpty() && !blockList.contains(username);
//	}
//
//	public static void listen(@NonNull String username) {
//		blockList.clear();
//		if (allowList.contains(username)) return;
//		allowList.add(username);
//	}
//
//	public static void unlisten(@NonNull String username) {
//		if (allowList.isEmpty()) return;
//		allowList.remove(username);
//	}
//
//	public static void mute(@NonNull String username) {
//		allowList.clear();
//		if (blockList.contains(username)) return;
//		blockList.add(username);
//	}
//
//	public static void unmute(@NonNull String username) {
//		if (blockList.isEmpty()) return;
//		blockList.remove(username);
//	}

	public static boolean isPlayerChatMessage(@NonNull ChatMessage message) {
		return !isNPCChatMessage(message);
	}

	public static boolean isNPCChatMessage(@NonNull ChatMessage message) {
		// From NPC
		switch (message.getType()) {
			case DIALOG:
			case ITEM_EXAMINE:
			case NPC_EXAMINE:
			case OBJECT_EXAMINE:
			case WELCOME:
			case GAMEMESSAGE:
			case CONSOLE:
				return true;
		}
		return false;
	}

//	public static boolean checkMuteAllowAndBlockList(@NonNull ChatMessage message) {
//		switch (message.getType()) {
//			case PUBLICCHAT:
//			case PRIVATECHAT:
//			case PRIVATECHATOUT:
//			case FRIENDSCHAT:
//			case CLAN_CHAT:
//			case CLAN_GUEST_CHAT:
//				if (isBlockedOrNotAllowed(message.getName())) return true;
//		}
//		return false;
//	}

//	public static boolean isBlockedOrNotAllowed(String name) {
//		if (!PluginHelper.getAllowList().isEmpty() &&
//			!PluginHelper.getAllowList().contains(name)) {return true;}
//		if (!PluginHelper.getBlockList().isEmpty() && PluginHelper.getBlockList().contains(name)) {
//			return true;
//		}
//		return false;
//	}
}

package dev.phyce.naturalspeech.macos;

import dev.phyce.naturalspeech.utils.OSValidator;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Path;
import lombok.extern.slf4j.Slf4j;

/**
 * On macOS, browsers, like Chrome/Safari flag themselves with LSFileQuarantineEnabled in the .plist file
 * https://developer.apple.com/documentation/bundleresources/information_property_list/lsfilequarantineenabled
 *
 * For example, here is the flag in the Chromium plist:
 * https://chromium.googlesource.com/chromium/reference_builds/chrome_mac/+/refs/heads/main/Google%20Chrome.app/Contents/Info.plist#320
 *
 * This flag causes all files download by the App to have an extended-file-attribute named com.apple.quarantine
 *
 * Executables and dynamic libraries with this attribute will not be able to link or execute.
 * This is to protect users from opening an executable downloaded by the browser.
 *
 * For Natural Speech, users download the Piper executable through GitHub with the browser, so the executables are
 * flagged with com.apple.quarantine.
 *
 * Using xattr, Natural Speech removes the flags from piper and it's libraries in order to execute.
 * https://opensource.apple.com/source/xnu/xnu-1504.15.3/bsd/sys/xattr.h.auto.html
 */
@Slf4j
public class MacUnquarantine {

	/**
	 *
	 * @param piperExePath path to the piper executable (not the folder)
	 * @return Returns if the un-quarantine was successful
	 */
	public static boolean Unquarantine(Path piperExePath) {
		// check if OS is mac
		if (!OSValidator.IS_MAC) {
			log.error("Only MacOS requires un-quarantining.");
			return true; // return true because it's "un-quarantined", as Windows/Linux never needed it.
		}

		// check if the piper path is valid
		if (!piperExePath.toFile().exists()) {
			log.error("Un-quarantining, but path to piper is invalid/does not exist.");
			return false;
		}

		// Piper executable and dynamic libraries
		String[] exeFilenames = new String[] {
			"piper",
			"libespeak-ng.1.52.0.1.dylib",
			"libpiper_phonemize.1.2.0.dylib",
			"libonnxruntime.1.14.1.dylib"
		};

		boolean success = true;

		// get the folder in order to resolve each file (not using resolveSibling for code clarity)
		Path piperFolder = piperExePath.getParent();

		// go through each file and remove the quarantine
		for (String filename : exeFilenames) {

			Path path = piperFolder.resolve(filename);

			// check if the file exists
			if (path.toFile().exists()) {

				// run xattr
				ProcessBuilder xattr = new ProcessBuilder()
					.command("xattr", "-d", "com.apple.quarantine", path.toString());

				try {
					xattr.start();
					log.trace("Successfully un-quarantined {}", path);
				} catch (IOException e) {
					log.error("Un-quarantining, but xattr crashed with {}",
						xattr.command().stream().reduce("", (a, b) -> a + " " + b));
					success = false;
				}
			}
			else {
				log.error("Un-quarantining, but {} piper executable is missing.", filename);
				success = false;
			}

		}

		return success;
	}
}

package dev.phyce.naturalspeech.exceptions;

import dev.phyce.naturalspeech.tts.VoiceID;

public class PiperNotActiveException extends RuntimeException {
	public PiperNotActiveException(VoiceID voiceID) {
		super(String.format("No Piper instance for %s",
			voiceID.toVoiceIDString()));
	}

	public PiperNotActiveException(String errMessage, VoiceID voiceID) {
		super(String.format("No Piper instance for %s\n%s",
			voiceID.toVoiceIDString(), errMessage));
	}
}

package dev.phyce.naturalspeech.exceptions;

import dev.phyce.naturalspeech.tts.VoiceID;

public class ModelLocalUnavailableException extends RuntimeException {
	public VoiceID voiceID;

	public ModelLocalUnavailableException(String errMessage, VoiceID voiceID) {
		super(String.format("No model files for %s\n%s",
			voiceID.toVoiceIDString(), errMessage));
	}

	public ModelLocalUnavailableException(VoiceID voiceID) {
		super(String.format("No model files for: %s",
			voiceID.toVoiceIDString()));
	}

}

package dev.phyce.naturalspeech.exceptions;

public class VoiceSelectionOutOfOption extends Exception {
}

package dev.phyce.naturalspeech.spamdetection;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.MenuAction;
import net.runelite.api.MenuEntry;
import net.runelite.api.events.MenuOptionClicked;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginManager;

// A "pluglet" is defined as a small or simplified version of a plugin.
// Only things needed (as a bare minimum) to re-implement a single function
// Hub rules disallows reflection, so Natural Speech re-implements the code, but uses Spam Filters' user configs.
@Slf4j
@Singleton
public class SpamFilterPluglet {

	private final PluginManager pluginManager;
	private final ConfigManager configManager;

	private static final String SPAM_FILTER_GROUP_NAME = "spamfilter";
	private static final String SPAM_FILTER_CONFIG_KEY_THRESHOLD = "threshold";
	private static final String SPAM_FILTER_MARK_SPAM_OPTION = "Mark spam";
	private static final String SPAM_FILTER_MARK_HAM_OPTION = "Mark ham";

	private boolean goodCorpusDirty = false;
	private boolean badCorpusDirty = false;

	private int threshold = 100;


	private final List<String> builtinGoodCorpus = new ArrayList<>();
	private final List<String> builtinBadCorpus = new ArrayList<>();
	private final List<String> userGoodCorpus = new ArrayList<>();
	private final List<String> userBadCorpus = new ArrayList<>();

	private final Map<String, Integer> goodCounts = new HashMap<>();
	private final Map<String, Integer> badCounts = new HashMap<>();

	private static final String FILE_NAME_GOOD_CORPUS = "spamfilter_good_corpus.txt";
	private static final String FILE_NAME_BAD_CORPUS = "spamfilter_bad_corpus.txt";

	private boolean isPluginEnabled;

	@Inject
	public SpamFilterPluglet(PluginManager pluginManager, ConfigManager configManager) {
		this.pluginManager = pluginManager;
		this.configManager = configManager;

		// look for spam filter if it's already loaded
		Plugin spamFilterPlugin = null;
		for (Plugin plugin : pluginManager.getPlugins()) {
			if (plugin.getClass().getSimpleName().equals("SpamFilterPlugin")) {
				log.info("Spam Filter Plugin Detected.");
				spamFilterPlugin = plugin;
			}
		}
		isPluginEnabled = spamFilterPlugin != null && pluginManager.isPluginEnabled(spamFilterPlugin);

		// built-in corpus is copied into Natural Speech's resource folder
		// Must be loaded first beauce loadUserCorpus implicitly counts
		// but load Built-in does not. This is to avoid reading the built-in over and over again.
		loadBuiltinCorpus();

		// spam-filter saves user corupus in .runelite/spam-filter/user_good_corpus.txt
		loadUserCorpus();

		// try load threshold
		loadThreshold();
	}

	public boolean isSpam(String text) {
		if (!isPluginEnabled) {
			return false;
		}

		if (goodCorpusDirty) {
//			log.trace("Reloading good corpus, due to dirty flag...");
			loadUserGoodCorpus();
			goodCorpusDirty = false;
		}
		if (badCorpusDirty) {
//			log.trace("Reloading bad corpus, due to dirty flag...");
			loadUserBadCorpus();
			badCorpusDirty = false;

		}

		float spamScore = pMessageBad(text);
		return spamScore > threshold / 100f;
	}

	private void loadThreshold() {
		String result = configManager.getConfiguration(SPAM_FILTER_GROUP_NAME, SPAM_FILTER_CONFIG_KEY_THRESHOLD);
		if (result == null) {
			log.debug("{}.{} config did not exist in configManager",
				SPAM_FILTER_GROUP_NAME, SPAM_FILTER_CONFIG_KEY_THRESHOLD);
			return;
		}
		try {
			threshold = Integer.parseInt(result);
		} catch (NumberFormatException e) {
			log.error("Error parsing threshold value from spam filters' config", e);
		}
	}

	private void loadUserCorpus() {
		loadUserGoodCorpus();
		loadUserBadCorpus();
	}

	private void loadUserBadCorpus() {
		File configDir = new File(RuneLite.RUNELITE_DIR, "spam-filter");
		if (!configDir.exists()) {
			log.trace("No {} found", configDir);
			return;
		}
		File userBadCorpusFile = new File(configDir, "user_bad_corpus.txt");
		if (userBadCorpusFile.exists()) {
			try {
				userBadCorpus.clear();
				userBadCorpus.addAll(Files.readAllLines(userBadCorpusFile.toPath()));
				log.trace("Loaded user bad corpus of {} lines", userBadCorpus.size());

				badCounts.clear();
				countTokens(badCounts, builtinBadCorpus);
				countTokens(badCounts, userBadCorpus);
			} catch (IOException e) {
				log.error("Error reading {}", userBadCorpusFile);
			}
		} else {
			log.trace("No {} found", userBadCorpusFile);
		}
	}

	private void loadUserGoodCorpus() {
		File configDir = new File(RuneLite.RUNELITE_DIR, "spam-filter");

		if (!configDir.exists()) {
			log.trace("No {} found", configDir);
			return;
		}

		File userGoodCorpusFile = new File(configDir, "user_good_corpus.txt");
		if (userGoodCorpusFile.exists()) {
			try {
				userGoodCorpus.clear();
				userGoodCorpus.addAll(Files.readAllLines(userGoodCorpusFile.toPath()));
				log.trace("Loaded user good corpus of {} lines", userGoodCorpus.size());

				goodCounts.clear();
				countTokens(goodCounts, builtinGoodCorpus);
				countTokens(goodCounts, userGoodCorpus);
			} catch (IOException e) {
				log.error("Error reading {}", userGoodCorpusFile);
			}
		} else {
			log.trace("No {} found", userGoodCorpusFile);
		}

	}

	private void loadBuiltinCorpus() {
		InputStream goodCorpusRes = this.getClass().getResourceAsStream(FILE_NAME_GOOD_CORPUS);
		if (goodCorpusRes != null) {
			BufferedReader goodCorpusReader = new BufferedReader(new InputStreamReader(goodCorpusRes, StandardCharsets.UTF_8));
			goodCorpusReader.lines().forEach(builtinGoodCorpus::add);
			try {
				goodCorpusReader.close();
			} catch (IOException e) {
				log.error("Error reading SpamFilter file from {}.", FILE_NAME_GOOD_CORPUS);
			}
		}

		InputStream badCorpusRes = this.getClass().getResourceAsStream(FILE_NAME_BAD_CORPUS);
		if (badCorpusRes != null) {
			BufferedReader badCorpusReader = new BufferedReader(new InputStreamReader(badCorpusRes, StandardCharsets.UTF_8));
			badCorpusReader.lines().forEach(builtinBadCorpus::add);
			try {
				badCorpusReader.close();
			} catch (IOException e) {
				log.error("Error reading SpamFilter file from {}.", FILE_NAME_BAD_CORPUS);
			}
		}
	}

	private float pTokenBad(String token) {
		int goodCount = goodCounts.getOrDefault(token, 0);
		int badCount = badCounts.getOrDefault(token, 0);
		if (goodCount + badCount == 0) {
			return 0.4f;
		}
		float rawProbability = (float) badCount / (float) (goodCount + badCount);
		float clampUpperBound = Math.min(rawProbability, 0.99f);
		//noinspection UnnecessaryLocalVariable
		float clampLowerBound = Math.max(clampUpperBound, 0.01f);

		return clampLowerBound;
	}

	private float pMessageBad(String message) {
		String msg = message.toLowerCase();
		String[] tokens = msg.split("\\s+");
		if (tokens.length == 1 && !message.startsWith("!")) {
			// single-word messages easily induce false positives so we ignore them.
			// however, messages starting with "!" are still processed since they are often commands
			// for gambling bots (e.g. "!w")
			return 0.0f;
		}
		Set<String> tokensUnique = new HashSet<>(Arrays.asList(tokens));
		float pPredictorsCorrect = 1f;
		float pPredictorsIncorrect = 1f;
		for (String token : tokensUnique) {
			float p = pTokenBad(token);
			pPredictorsCorrect *= p;
			pPredictorsIncorrect *= (1 - p);
		}
		return pPredictorsCorrect / (pPredictorsCorrect + pPredictorsIncorrect);
	}
	private static void countTokens(Map<String, Integer> out_result, List<String> corpus) {
		for (String message : corpus) {
			message = message.toLowerCase();
			String[] tokens = message.split("\\s");
			for (String token : tokens) {
				out_result.put(token, out_result.getOrDefault(token, 0) + 1);
			}
		}
	}

	@Subscribe
	private void onPluginChanged(PluginChanged event) {
		// if spam filter was installed after runelite session started
		if (event.getPlugin().getClass().getSimpleName().equals("SpamFilterPlugin")) {
			if (event.isLoaded()) {
				log.trace("Detected SpamFilter plugin activated.");
				loadUserCorpus();
				loadThreshold();
				isPluginEnabled = true;
			} else {
				isPluginEnabled = false;
				log.trace("Detected SpamFilter plugin deactivated.");
			}
		}
	}

	@Subscribe
	private void onConfigChanged(ConfigChanged event) {
		if (!isPluginEnabled) return;

		if (event.getGroup().equals(SPAM_FILTER_GROUP_NAME)
			&& event.getKey().equals(SPAM_FILTER_CONFIG_KEY_THRESHOLD)) {
			loadThreshold();
			log.trace("Detected SpamFilter {} change to {}", SPAM_FILTER_CONFIG_KEY_THRESHOLD, event.getNewValue());
		}
	}

	@Subscribe
	private void onMenuOptionClicked(MenuOptionClicked event) {
		if (!isPluginEnabled) return;

		MenuEntry menuEntry = event.getMenuEntry();
		if (menuEntry.getType() == MenuAction.RUNELITE) {
			if (menuEntry.getOption().equals(SPAM_FILTER_MARK_HAM_OPTION)) {
				goodCorpusDirty = true;
				log.trace("Detected SpamFilter Mark ham. Marking goodCorpus file dirty.");
			}
			if (menuEntry.getOption().equals(SPAM_FILTER_MARK_SPAM_OPTION)) {
				badCorpusDirty = true;
				log.trace("Detected SpamFilter Mark spam. Marking badCorpus file dirty.");
			}
		}
	}
}

package dev.phyce.naturalspeech.spamdetection;

import com.google.common.base.CharMatcher;
import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableSet;
import com.google.inject.Singleton;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import static net.runelite.api.ChatMessageType.*;
import net.runelite.api.Client;
import net.runelite.api.FriendsChatManager;
import net.runelite.api.MessageNode;
import net.runelite.api.clan.ClanChannel;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.events.PluginChanged;
import net.runelite.client.util.Text;
import org.apache.commons.lang3.StringUtils;

// A "pluglet" is defined as a small or simplified version of a plugin.
// Only things needed (as a bare minimum) to re-implement a single function
// Hub rules disallows reflection, so Natural Speech re-implements the code, but uses ChatFilters' user configs.
@Slf4j
@Singleton
public class ChatFilterPluglet {

	private static final Splitter NEWLINE_SPLITTER = Splitter
		.on("\n")
		.omitEmptyStrings()
		.trimResults();

	private static final Set<ChatMessageType> COLLAPSIBLE_MESSAGETYPES = ImmutableSet.of(
		ENGINE,
		GAMEMESSAGE,
		ITEM_EXAMINE,
		NPC_EXAMINE,
		OBJECT_EXAMINE,
		SPAM,
		PUBLICCHAT,
		MODCHAT
	);

	private final CharMatcher jagexPrintableCharMatcher = Text.JAGEX_PRINTABLE_CHAR_MATCHER;
	private List<Pattern> filteredPatterns = Collections.emptyList();
	private List<Pattern> filteredNamePatterns = Collections.emptyList();

	private static class Duplicate {
		int messageId;
		int count;
	}

	private final LinkedHashMap<String, Duplicate> duplicateChatCache = new LinkedHashMap<>() {
		private static final int MAX_ENTRIES = 100;

		@Override
		protected boolean removeEldestEntry(Map.Entry<String, Duplicate> eldest) {
			return size() > MAX_ENTRIES;
		}
	};

	private final Client client;
	private final ConfigManager configManager;

	private boolean isChatFilterEnabled;

	// We avoid using ChatFilterConfig directly to future-proof Natural Speech against ChatFilter updates
	private final ProxyConfig config;
	// region proxyconfig implementation
	private static final String ChatFilterClassName = "chatfilterplugin";
	private static final String CHAT_FILTER_GROUP_NAME = "chatfilter";
	private static final class ConfigKeys {
		private final static String maxRepeatedPublicChats = "maxRepeatedPublicChats";
		private final static String filterFriends = "filterFriends";
		private final static String filterFriendsChat = "filterClan";
		private final static String filterClanChat = "filterClanChat";
		private final static String filteredWords = "filteredWords";
		private final static String filteredRegex = "filteredRegex";
		private final static String filteredNames = "filteredNames";
		private final static String stripAccents = "stripAccents";
	}
	@SuppressWarnings("SameParameterValue")
	private class ProxyConfig {
		private boolean getBoolean(String key, Boolean defaultValue) {
			String result = configManager.getConfiguration(CHAT_FILTER_GROUP_NAME, key);
			if (result != null) {
				return Boolean.parseBoolean(result);
			}
			log.trace("{} doesn't exist in configManager, likely ChatFilter has never been enabled.", key);
			return defaultValue;
		}

		private int getInteger(String key, int defaultValue) {
			String result = configManager.getConfiguration(CHAT_FILTER_GROUP_NAME, key);
			if (result != null) {
				return Integer.parseInt(result);
			}
			log.trace("{} doesn't exist in configManager, likely ChatFilter has never been enabled.", key);
			return defaultValue;
		}

		private String getString(String key, String defaultValue) {
			String result = configManager.getConfiguration(CHAT_FILTER_GROUP_NAME, key);
			if (result != null) {
				return result;
			}
			log.trace("{} doesn't exist in configManager, likely ChatFilter has never been enabled.", key);
			return defaultValue;
		}

		public int maxRepeatedPublicChats() {
			return getInteger(ConfigKeys.maxRepeatedPublicChats, 0);
		}

		public boolean filterFriends() {
			return getBoolean(ConfigKeys.filterFriends, false);
		}

		public boolean filterFriendsChat() {
			return getBoolean(ConfigKeys.filterFriendsChat, false);
		}

		public boolean filterClanChat() {
			return getBoolean(ConfigKeys.filterClanChat, false);
		}

		public String filteredWords() {
			return getString(ConfigKeys.filteredWords, "");
		}

		public String filteredRegex() {
			return getString(ConfigKeys.filteredRegex, "");
		}

		public String filteredNames() {
			return getString(ConfigKeys.filteredNames, "");
		}

		public boolean stripAccents() {
			return getBoolean(ConfigKeys.stripAccents, false);
		}
	}
	// endregion

	@Inject
	public ChatFilterPluglet(Client client, ConfigManager configManager) {
		this.client = client;
		this.configManager = configManager;
		this.config = new ProxyConfig();

		// built-in plugin, guaranteed to exist and be valid bool
		this.isChatFilterEnabled = Boolean.parseBoolean(
			configManager.getConfiguration("runelite", ChatFilterClassName));

		updateFilteredPatterns();
	}

	public boolean isSpam(final String username, final String message) {
		if (!isChatFilterEnabled) return false;

		if (username == null) {
			return false;
		}
		else {
			if (!canFilterPlayer(username)) {
				return false;
			}
			if (isNameFiltered(username)) {
				return true;
			}
		}

		Duplicate duplicateCacheEntry = duplicateChatCache.get(username + ":" + message);
//		log.trace("Duplicate chat entry count:{} for ({})", duplicateCacheEntry.count, duplicateCacheEntry);
		if (config.maxRepeatedPublicChats() > 0 && duplicateCacheEntry.count > config.maxRepeatedPublicChats()) {
//			log.trace("Duplicate chat filtered ({})", duplicateCacheEntry);
			return true;
		}

		String strippedMessage = jagexPrintableCharMatcher.retainFrom(message)
			.replace('\u00A0', ' ')
			.replaceAll("<lt>", "<")
			.replaceAll("<gt>", ">");
		String strippedAccents = stripAccents(strippedMessage);


		for (Pattern pattern : filteredPatterns) {
			Matcher m = pattern.matcher(strippedAccents);
			if (m.find()) {
				return true;
			}
		}

		return false;
	}

	@Subscribe
	private void onPluginChanged(PluginChanged event) {
		// if spam filter was installed after runelite session started
		if (event.getPlugin().getName().equals("Chat Filter") ) {
			if (event.isLoaded()) {
				updateFilteredPatterns();
				log.trace("Detected ChatFilterPlugin activated");
				isChatFilterEnabled = true;
			}
			else {
				filteredPatterns = Collections.emptyList();
				filteredNamePatterns = Collections.emptyList();
				duplicateChatCache.clear();
				log.trace("Detected ChatFilterPlugin deactivated");
				isChatFilterEnabled = false;
			}
		}
	}

	@Subscribe(priority=-2) // run after ChatMessageManager
	public void onChatMessage(ChatMessage chatMessage) {
		if (!isChatFilterEnabled) return;

		if (COLLAPSIBLE_MESSAGETYPES.contains(chatMessage.getType())) {
			final MessageNode messageNode = chatMessage.getMessageNode();
			// remove and re-insert into map to move to end of list
			final String key = messageNode.getName() + ":" + messageNode.getValue();
			Duplicate duplicate = duplicateChatCache.remove(key);
			if (duplicate == null) {
				duplicate = new Duplicate();
			}

			duplicate.count++;
			duplicate.messageId = messageNode.getId();
			duplicateChatCache.put(key, duplicate);
		}
	}
	@Subscribe
	public void onGameStateChanged(GameStateChanged gameStateChanged) {
		if (!isChatFilterEnabled) return;

		switch (gameStateChanged.getGameState())
		{
			// Login drops references to all messages and also resets the global message id counter.
			// Invalidate the message id so it doesn't collide later when rebuilding the chatfilter.
			case CONNECTION_LOST:
			case HOPPING:
			case LOGGING_IN:
				duplicateChatCache.values().forEach(d -> d.messageId = -1);
		}
	}
	@Subscribe
	public void onConfigChanged(ConfigChanged event) {
		if (!CHAT_FILTER_GROUP_NAME.equals(event.getGroup())) {
			return;
		}

		updateFilteredPatterns();
	}

	boolean canFilterPlayer(String playerName) {
		boolean isMessageFromSelf = playerName.equals(client.getLocalPlayer().getName());
		return !isMessageFromSelf &&
			(config.filterFriends() || !client.isFriended(playerName, false)) &&
			(config.filterFriendsChat() || !isFriendsChatMember(playerName)) &&
			(config.filterClanChat() || !isClanChatMember(playerName));
	}

	private boolean isFriendsChatMember(String name) {
		FriendsChatManager friendsChatManager = client.getFriendsChatManager();
		return friendsChatManager != null && friendsChatManager.findByName(name) != null;
	}

	private boolean isClanChatMember(String name) {
		ClanChannel clanChannel = client.getClanChannel();
		if (clanChannel != null && clanChannel.findMember(name) != null) {
			return true;
		}

		clanChannel = client.getGuestClanChannel();
		//noinspection RedundantIfStatement
		if (clanChannel != null && clanChannel.findMember(name) != null) {
			return true;
		}

		return false;
	}

	private void updateFilteredPatterns() {
		log.trace("Updating filtered patterns");
		List<Pattern> patterns = new ArrayList<>();
		List<Pattern> namePatterns = new ArrayList<>();

		Text.fromCSV(config.filteredWords()).stream()
			.map(this::stripAccents)
			.map(s -> Pattern.compile(Pattern.quote(s), Pattern.CASE_INSENSITIVE))
			.forEach(patterns::add);

		//noinspection UnstableApiUsage
		NEWLINE_SPLITTER.splitToList(config.filteredRegex()).stream()
			.map(this::stripAccents)
			.map(ChatFilterPluglet::compilePattern)
			.filter(Objects::nonNull)
			.forEach(patterns::add);

		//noinspection UnstableApiUsage
		NEWLINE_SPLITTER.splitToList(config.filteredNames()).stream()
			.map(this::stripAccents)
			.map(ChatFilterPluglet::compilePattern)
			.filter(Objects::nonNull)
			.forEach(namePatterns::add);

		filteredPatterns = patterns;
		filteredNamePatterns = namePatterns;

	}

	private String stripAccents(String input) {
		return config.stripAccents() ? StringUtils.stripAccents(input) : input;
	}

	private static Pattern compilePattern(String pattern) {
		try {
			return Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);
		} catch (PatternSyntaxException ex) {
			return null;
		}
	}

	private boolean isNameFiltered(final String playerName) {
		String sanitizedName = Text.standardize(playerName);
		for (Pattern pattern : filteredNamePatterns) {
			Matcher m = pattern.matcher(sanitizedName);
			if (m.find()) {
				return true;
			}
		}
		return false;
	}


}

package dev.phyce.naturalspeech.tts;

import dev.phyce.naturalspeech.enums.Gender;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class GenderedVoiceMap {

	public List<VoiceID> MaleList = new ArrayList<>();
	public List<VoiceID> FemaleList = new ArrayList<>();
	public List<VoiceID> OtherList = new ArrayList<>();

	public void addModel(ModelRepository.ModelLocal modelLocal) {
		for (ModelRepository.VoiceMetadata voiceMetadata : modelLocal.getVoiceMetadata()) {
			VoiceID voiceID = voiceMetadata.toVoiceID();
			if (voiceMetadata.getGender() == Gender.MALE) {
				MaleList.add(voiceID);
			} else if (voiceMetadata.getGender() == Gender.FEMALE) {
				FemaleList.add(voiceID);
			} else {
				OtherList.add(voiceID);
			}
		}
	}

	public void removeModel(ModelRepository.ModelLocal modelLocal) {
		for (ModelRepository.VoiceMetadata voiceMetadata : modelLocal.getVoiceMetadata()) {
			VoiceID voiceID = voiceMetadata.toVoiceID();
			if (voiceMetadata.getGender() == Gender.MALE) {
				MaleList.remove(voiceID);
			} else if (voiceMetadata.getGender() == Gender.FEMALE) {
				FemaleList.remove(voiceID);
			} else {
				OtherList.remove(voiceID);
			}
		}
	}

	public List<VoiceID> find(Gender gender) {
		if (gender == Gender.MALE) {
			return Collections.unmodifiableList(MaleList);
		} else if (gender == Gender.FEMALE) {
			return Collections.unmodifiableList(FemaleList);
		} else {
			return Collections.unmodifiableList(OtherList);
		}
	}
}

package dev.phyce.naturalspeech.tts;

import dev.phyce.naturalspeech.helpers.PluginHelper;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.LineUnavailableException;
import javax.sound.sampled.SourceDataLine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.Plugin;

@Slf4j
public class AudioPlayer {
	private final AudioFormat format;

	public AudioPlayer() {
		format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,
			22050.0F, // Sample Rate
			16, // Sample Size in Bits
			1, // Channels
			2, // Frame Size
			22050.0F, // Frame Rate
			false); // Little Endian
	}

	public static void setVolume(SourceDataLine line, float volume) {

		if (line.isControlSupported(FloatControl.Type.MASTER_GAIN)) {
			FloatControl volumeControl = (FloatControl) line.getControl(FloatControl.Type.MASTER_GAIN);
			volumeControl.setValue(volume);
		}
	}

//	public static void setVolume(SourceDataLine line, float masterVolumePercent) {
//		if (line.isControlSupported(FloatControl.Type.MASTER_GAIN)) {
//			FloatControl volumeControl = (FloatControl) line.getControl(FloatControl.Type.MASTER_GAIN);
//
//			float max = volumeControl.getMaximum();
//			float min = volumeControl.getMinimum(); // Often a negative value.
//
//			// Convert the volume from 0-100 scale to the min-max dB scale.
//			float volume = min + masterVolumePercent * (max - min) / 100.0f;
//
//			volumeControl.setValue(volume);
//		}
//	}

	public void stop() {
	}

	// decoupled audio system from plugin logic
	public void playClip(byte[] audioData, float volume) {
		AudioInputStream audioInputStream = null;
		SourceDataLine line = null;

		try {
			audioInputStream = new AudioInputStream(
				new ByteArrayInputStream(audioData),
				this.format,
				audioData.length / this.format.getFrameSize());

			DataLine.Info info = new DataLine.Info(SourceDataLine.class, this.format);
			line = (SourceDataLine) AudioSystem.getLine(info);

			line.open(this.format);
			line.start();

			setVolume(line, volume);

			byte[] buffer = new byte[1024];
			int bytesRead;

			while ((bytesRead = audioInputStream.read(buffer)) != -1) {
				line.write(buffer, 0, bytesRead);
			}
			line.drain();
		} catch (IOException | LineUnavailableException e) {
			log.error("Clip failed to play", e);
		} finally {
			if (line != null) line.close();
			if (audioInputStream != null) {
				try {
					audioInputStream.close();
				} catch (IOException e) {
					log.error("Line failed to close", e);
				}
			}
		}
	}

	//	public static int calculateAudioLength(byte[] audioClip) {
	//		final int bytesPerSample = 2; // 16-bit mono
	//		final int sampleRate = 22050; // Hz
	//
	//		int totalSamples = audioClip.length / bytesPerSample;
	//
	//		return (int) ((totalSamples / (double) sampleRate) * 1000);
	//	}


	//	public AudioInputStream applyEffectsToStream(AudioInputStream inputAudio) {
	//		try {
	//			AudioFormat format = inputAudio.getFormat();
	//			int bytesPerFrame = format.getFrameSize();
	//			float sampleRate = format.getSampleRate();
	//			int delayMilliseconds = 300; // Delay time in milliseconds
	//			int delayBytes = (int) ((delayMilliseconds / 1000.0) * sampleRate * bytesPerFrame);
	//
	//			// Create a circular buffer to hold the delay
	//			byte[] delayBuffer = new byte[delayBytes];
	//			int delayBufferPos = 0;
	//
	//			// Read the entire stream into memory (not efficient for large files)
	//			byte[] inputBytes = inputAudio.readAllBytes();
	//			byte[] outputBytes = new byte[inputBytes.length];
	//
	//			// Apply the echo effect
	//			for (int i = 0; i < inputBytes.length; i++) {
	//				// Mix current sample and delayed sample
	//				int currentSample = inputBytes[i];
	//				int delayedSample = delayBuffer[delayBufferPos];
	//
	//				// Simple mix: average the current sample and the delayed sample
	//				outputBytes[i] = (byte) ((currentSample + delayedSample) / 2);
	//
	//				// Update the delay buffer
	//				delayBuffer[delayBufferPos] = (byte) currentSample;
	//				delayBufferPos = (delayBufferPos + 1) % delayBytes;
	//			}
	//
	//			// Convert the output bytes back into an AudioInputStream
	//			ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(outputBytes);
	//			return new AudioInputStream(byteArrayInputStream, format, outputBytes.length / bytesPerFrame);
	//		} catch (Exception e) {
	//			e.printStackTrace();
	//			return null;
	//		}
	//	}
	//
	//	public double[] bytesToDouble(byte[] byteArray, AudioFormat format) {
	//		double[] doubleArray = new double[byteArray.length / 2];
	//		for (int i = 0; i < doubleArray.length; i++) {
	//			int sample = (byteArray[2 * i] & 0xFF) | (byteArray[2 * i + 1] << 8);
	//			doubleArray[i] = sample / 32768.0; // Normalize to -1.0 to 1.0 for 16-bit audio
	//		}
	//		return doubleArray;
	//	}
	//
	//	public byte[] doubleToBytes(double[] doubleArray, AudioFormat format) {
	//		byte[] byteArray = new byte[doubleArray.length * 2];
	//		for (int i = 0; i < doubleArray.length; i++) {
	//			int sample = (int) (doubleArray[i] * 32768.0);
	//			byteArray[2 * i] = (byte) (sample & 0xFF);
	//			byteArray[2 * i + 1] = (byte) ((sample >> 8) & 0xFF);
	//		}
	//		return byteArray;
	//	}

	//	private byte[] addThoughtEffect(byte[] inputAudio) throws UnsupportedAudioFileException, LineUnavailableException {
	//		// Convert byte array to an AudioInputStream
	//		ByteArrayInputStream inputStream = new ByteArrayInputStream(inputAudio);
	//		AudioInputStream audioStream = new AudioInputStream(inputStream, this.format, inputAudio.length / this.format.getFrameSize());
	//
	//		// Set up TarsosDSP audio processing
	//		TarsosDSPAudioFormat tarsosFormat = new TarsosDSPAudioFormat(this.format.getSampleRate(), this.format.getSampleSizeInBits(),
	//			this.format.getChannels(), this.format.getEncoding().equals(AudioFormat.Encoding.PCM_SIGNED),
	//			this.format.isBigEndian());
	//		AudioDispatcher dispatcher = new AudioDispatcher(new UniversalAudioInputStream(audioStream, tarsosFormat), 1024, 0);
	//
	//		// Apply effects here
	//
	//		// Echo effect (using delay as a simple approximation)
	////		float delayTimeInSeconds = 10f; // Adjust as needed
	////		float decay = 50f; // Decay for echo effect
	////		dispatcher.addAudioProcessor(new DelayEffect(delayTimeInSeconds, decay, this.format.getSampleRate()));
	//
	////		// EQ effect to simulate the muffled sound of thoughts
	////		// This uses a high-pass and low-pass filter to mimic EQ adjustments
	////		float highPassFreq = 300; // High-pass filter cutoff frequency
	////		float lowPassFreq = 3000; // Low-pass filter cutoff frequency
	////		dispatcher.addAudioProcessor(new HighPass(highPassFreq, this.format.getSampleRate()));
	////		dispatcher.addAudioProcessor(new LowPassFS(lowPassFreq, this.format.getSampleRate()));
	//
	//		// Reverb effect: TarsosDSP might not have a direct reverb effect,
	//		// so consider combining multiple delays or using external libraries/effects if necessary.
	//
	//		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
	//		dispatcher.addAudioProcessor(new AudioProcessor() {
	//			@Override
	//			public boolean process(AudioEvent audioEvent) {
	//				byte[] audioBytes = audioEvent.getByteBuffer();
	//				outputStream.write(audioBytes, 0, audioEvent.getBufferSize());
	//				return true;
	//			}
	//
	//			@Override
	//			public void processingFinished() {
	//			}
	//		});
	//
	//		dispatcher.run();
	//
	//		return outputStream.toByteArray();
	//	}


}


package dev.phyce.naturalspeech.tts;

import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import com.google.gson.annotations.Expose;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import dev.phyce.naturalspeech.NaturalSpeechPlugin;
import dev.phyce.naturalspeech.configs.NaturalSpeechRuntimeConfig;
import dev.phyce.naturalspeech.downloader.DownloadTask;
import dev.phyce.naturalspeech.downloader.Downloader;
import dev.phyce.naturalspeech.enums.Gender;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.ScheduledExecutorService;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.HttpUrl;

@Slf4j
@Singleton
public class ModelRepository {

	public final static String EXTENSION = ".onnx";
	public final static String MODEL_METADATA_EXTENSION = ".onnx.json";
	public final static String METADATA_EXTENSION = ".metadata.json";
	public final static String MODEL_REPO_FILENAME = "model_repository.json";
	public final static String MODEL_FOLDER_NAME = "models";

	private final Downloader downloader;

	private final NaturalSpeechRuntimeConfig runtimeConfig;

	@Getter
	private final List<ModelURL> modelURLS;

	@Getter
	private final ScheduledExecutorService executor;

	private final List<ModelRepositoryListener> changeListeners = new ArrayList<>();

	private final Gson gson;

	@Inject
	public ModelRepository(Downloader downloader,
						   NaturalSpeechRuntimeConfig runtimeConfig,
						   ScheduledExecutorService executor,
						   Gson gson) throws IOException {
		this.executor = executor;
		this.gson = gson;

		this.downloader = downloader;
		this.runtimeConfig = runtimeConfig;

		try {
			InputStream is = Objects.requireNonNull(NaturalSpeechPlugin.class.getResource(MODEL_REPO_FILENAME)).openStream();
			// read dictionary index as name
			modelURLS = gson.fromJson(new InputStreamReader(is), new TypeToken<List<ModelURL>>() {
			}.getType());

			modelURLS.stream().map(ModelURL::getModelName).reduce((a, b) -> a + ", " + b)
				.ifPresent(s -> log.info("Loaded voice repository with {} voices. Found: {}", modelURLS.size(), s));

		} catch (IOException e) {
			log.error("Could not read voice repository file: " + MODEL_REPO_FILENAME);
			throw e;
		}
	}

	public ModelURL findModelURLFromModelName(String modelName) {
		for (ModelURL modelURL : modelURLS) {
			if (modelURL.modelName.equals(modelName)) {
				return modelURL;
			}
		}
		return null;
	}

	public boolean hasModelLocal(String modelName) throws IOException {
		// assume true
		boolean localVoiceValid = true;

		// First check if voice folder exist
		Path voiceFolder = runtimeConfig.getPiperPath().resolveSibling(MODEL_FOLDER_NAME).resolve(modelName);
		if (voiceFolder.toFile().exists()) {
			// Check voice is missing any files
			if (!voiceFolder.resolve(modelName + EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// Check if onnx metadata exists
			if (!voiceFolder.resolve(modelName + MODEL_METADATA_EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// Check if speakers metadata exists
			if (!voiceFolder.resolve(modelName + METADATA_EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// TODO(Louis) Check hash for files, right piper-voices doesn't offer hashes for download. Have to offer our own.
		}
		else { // voices folder don't exist, so no voices can exist
			localVoiceValid = false;
		}

		// if local voice files weren't valid, clear the folder and re-download.
		return localVoiceValid;
	}

	public void deleteModelLocal(ModelLocal modelLocal) {
		Path voiceFolder =
			runtimeConfig.getPiperPath().resolveSibling(MODEL_FOLDER_NAME).resolve(modelLocal.getModelName());
		if (voiceFolder.toFile().exists()) {
			// Check voice is missing any files
			File onnxFile = voiceFolder.resolve(modelLocal.getModelName() + EXTENSION).toFile();
			if (!onnxFile.delete()) {
				log.error("Failed to delete onnx file: {}", onnxFile.getPath());
			}
			// Check if onnx metadata exists
			File onnxMeta = voiceFolder.resolve(modelLocal.getModelName() + MODEL_METADATA_EXTENSION).toFile();
			if (!onnxMeta.delete()) {
				log.error("Failed to delete onnx metadata file: {}", onnxMeta.getPath());
			}
			// Check if speakers metadata exists
			File voiceMeta = voiceFolder.resolve(modelLocal.getModelName() + METADATA_EXTENSION).toFile();
			if (!voiceMeta.delete()) {
				log.error("Failed to delete voice speakers file: {}", voiceMeta.getPath());
			}
			if (!voiceFolder.toFile().delete()) {
				log.error("Failed to delete voice folder: {}", voiceFolder);
			}
			triggerOnRepositoryChanged(modelLocal.getModelName());
		}
		log.info("ModalLocal Deleted {}", modelLocal.getModelName());
	}


	public ModelLocal loadModelLocal(String modelName) throws IOException {
		boolean localVoiceValid = true;

		// First check if voice folder exist
		Path voiceFolder = runtimeConfig.getPiperPath().resolveSibling(MODEL_FOLDER_NAME).resolve(modelName);
		if (voiceFolder.toFile().exists()) {
			// Check voice is missing any files
			if (!voiceFolder.resolve(modelName + EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// Check if onnx metadata exists
			if (!voiceFolder.resolve(modelName + MODEL_METADATA_EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// Check if speakers metadata exists
			if (!voiceFolder.resolve(modelName + METADATA_EXTENSION).toFile().exists()) {
				localVoiceValid = false;
			}
			// TODO(Louis) Check hash for files, right piper-voices doesn't offer hashes for download. Have to offer our own.
		}
		else { // voices folder don't exist, so no voices can exist
			localVoiceValid = false;
			// create the folder
			if (!voiceFolder.toFile().mkdirs()) {
				// if we fail to create the folder, just toss an error
				throw new IOException("Failed to create voice folder.");
			}
		}

		ModelURL modelURL = findModelURLFromModelName(modelName);
		if (modelURL == null) {
			log.error("Voice not found in repository: " + modelName);
			return null;
		}

		// if local voice files weren't valid, clear the folder and re-download.
		if (!localVoiceValid) {
			log.info("downloading... {}", modelName);

			// download voice files
			DownloadTask onnxTask =
				downloader.create(HttpUrl.get(modelURL.onnxURL), voiceFolder.resolve(modelName + EXTENSION));
			DownloadTask onnxMetadataTask = downloader.create(HttpUrl.get(modelURL.onnxMetadataURL),
				voiceFolder.resolve(modelName + MODEL_METADATA_EXTENSION));
			DownloadTask speakersTask = downloader.create(HttpUrl.get(modelURL.metadataURL),
				voiceFolder.resolve(modelName + METADATA_EXTENSION));

			// thread blocking download
			File onnx = onnxTask.get();
			File onnxMetadata = onnxMetadataTask.get();
			File speakers = speakersTask.get();

			if (!onnx.exists() || !onnxMetadata.exists() || !speakers.exists()) {
				// if any of the files doesn't exist after validation, throw
				throw new IOException("Voice files downloaded are missing.");
			}

			log.info("done... {}", modelName);
			triggerOnRepositoryChanged(modelName);
		}

		// Read Speaker File into an HashSet of Array of Speaker
		try (FileInputStream fis = new FileInputStream(voiceFolder.resolve(modelName + METADATA_EXTENSION).toFile())) {
			VoiceMetadata[] voiceMetadatas =
				gson.fromJson(new InputStreamReader(fis), new TypeToken<VoiceMetadata[]>() {
				}.getType());

			for (VoiceMetadata voiceMetadata : voiceMetadatas) {
				voiceMetadata.setModelName(modelURL.getModelName());
			}

			return new ModelLocal(
				modelURL.getModelName(),
				voiceFolder.resolve(modelName + EXTENSION).toFile(),
				voiceFolder.resolve(modelName + MODEL_METADATA_EXTENSION).toFile(),
				voiceMetadatas
			);

		} catch (IOException e) {
			log.error("Failed to read speakers file, even after validation: " + e.getMessage());
			throw e;
		}
	}

	public void addRepositoryChangedListener(ModelRepositoryListener listener) {
		changeListeners.add(listener);
	}

	public void removeRepositoryChangedListener(ModelRepositoryListener listener) {
		changeListeners.remove(listener);
	}

	private void triggerOnRepositoryChanged(String modelName) {
		for (ModelRepositoryListener changeListener : changeListeners) {
			changeListener.onRepositoryChanged(modelName);
		}

	}

	public void refresh() {
		for (ModelRepositoryListener changeListener : this.changeListeners) {
			changeListener.onRefresh();
		}
	}

	// Partially Serialized JSON Object
	@Data
	public static class ModelURL {
		// Part of JSON
		@Expose
		String modelName;
		@Expose
		String onnxURL;
		@Expose
		String onnxMetadataURL;
		@Expose
		String metadataURL;
		@Expose
		String description;
		@Expose
		String memorySize;
	}


	// Partially Serialized JSON Object
	@Data
	public static class VoiceMetadata {
		// (Serialized in JSON) The speaker name from the model data set
		@Expose
		String name;
		// (Serialized in JSON) M, F, ...
		@JsonAdapter(GenderStringSerializer.class)
		Gender gender;
		// (Serialized in JSON) The Model ID from the data set
		@Expose
		int piperVoiceID;

		// Model Full name, not serialized, manually set when loading metadata
		String modelName;

		public VoiceID toVoiceID() {
			return new VoiceID(modelName, piperVoiceID);
		}
	}

	private static class GenderStringSerializer implements JsonSerializer<Gender>, JsonDeserializer<Gender> {
		@Override
		public JsonElement serialize(Gender gender, Type type, JsonSerializationContext jsonSerializationContext) {
			if (gender == Gender.MALE) {
				return jsonSerializationContext.serialize("M");
			} else if (gender == Gender.FEMALE) {
				return jsonSerializationContext.serialize("F");
			} else {
				return jsonSerializationContext.serialize("OTHER");
			}
		}

		@Override
		public Gender deserialize(JsonElement jsonElement, Type type,
								  JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
			if (jsonElement.getAsString().equals("M")) {
				return Gender.MALE;
			} else if (jsonElement.getAsString().equals("F")) {
				return Gender.FEMALE;
			} else {
				return Gender.OTHER;
			}
		}
	}

	// Not a Serialized JSON Object
	@Data
	@AllArgsConstructor
	public static class ModelLocal {
		String modelName;
		File onnx;
		File onnxMetadata;
		VoiceMetadata[] voiceMetadata;
	}

	public interface ModelRepositoryListener {
		default void onRefresh() {};
		default void onRepositoryChanged(String modelName) {}
	}
}

package dev.phyce.naturalspeech.tts;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import dev.phyce.naturalspeech.configs.ModelConfig;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import static dev.phyce.naturalspeech.configs.NaturalSpeechConfig.CONFIG_GROUP;
import dev.phyce.naturalspeech.configs.NaturalSpeechRuntimeConfig;
import dev.phyce.naturalspeech.configs.json.ttsconfigs.ModelConfigDatum;
import dev.phyce.naturalspeech.configs.json.ttsconfigs.PiperConfigDatum;
import dev.phyce.naturalspeech.exceptions.ModelLocalUnavailableException;
import dev.phyce.naturalspeech.exceptions.PiperNotActiveException;
import dev.phyce.naturalspeech.helpers.PluginHelper;
import dev.phyce.naturalspeech.macos.MacUnquarantine;
import dev.phyce.naturalspeech.tts.piper.Piper;
import dev.phyce.naturalspeech.tts.piper.PiperProcess;
import dev.phyce.naturalspeech.utils.OSValidator;
import dev.phyce.naturalspeech.utils.TextUtil;
import static dev.phyce.naturalspeech.utils.TextUtil.splitSentence;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;

// Renamed from TTSManager
@Slf4j
@Singleton
public class TextToSpeech {

	//<editor-fold desc="> Properties">
	private static final String CONFIG_KEY_MODEL_CONFIG = "ttsConfig";
	public static final String AUDIO_QUEUE_DIALOGUE = "&dialogue";

	private final ConfigManager configManager;
	private final NaturalSpeechRuntimeConfig runtimeConfig;
	private final ClientThread clientThread;
	private final ModelRepository modelRepository;
	private final NaturalSpeechConfig config;

	private Map<String, String> shortenedPhrases;
	@Getter
	private ModelConfig modelConfig;
	private final Map<String, Piper> pipers = new HashMap<>();
	private final List<TextToSpeechListener> textToSpeechListeners = new ArrayList<>();
	@Getter
	private boolean started = false;
	private boolean isPiperUnquarantined = false;
	//</editor-fold>

	@Inject
	private TextToSpeech(
		ConfigManager configManager,
		ClientThread clientThread,
		ModelRepository modelRepository,
		NaturalSpeechRuntimeConfig runtimeConfig,
		NaturalSpeechConfig config) {
		this.runtimeConfig = runtimeConfig;
		this.configManager = configManager;
		this.clientThread = clientThread;
		this.modelRepository = modelRepository;
		this.config = config;

		loadModelConfig();
	}

	// <editor-fold desc="> API">
	public void start() {
		if (!isPiperPathValid()) {
			triggerOnPiperInvalid();
			return;
		}

		isPiperUnquarantined = false; // set to false for each launch, in case piper path/files were modified
		started = false;
		try {
			for (ModelRepository.ModelURL modelURL : modelRepository.getModelURLS()) {
				try {
					if (modelRepository.hasModelLocal(modelURL.getModelName()) &&
						modelConfig.isModelEnabled(modelURL.getModelName())) {
						ModelRepository.ModelLocal modelLocal = modelRepository.loadModelLocal(modelURL.getModelName());
						startPiperForModel(modelLocal);
						started = true; // if even a single piper started successful, then it's running.
					}
				} catch (IOException e) {
					log.error("Failed to start {}", modelURL.getModelName(), e);
				}
			}
		} catch (RuntimeException e) {
			log.error("Unexpected exception starting text to speech", e);
			return;
		}

		if (started) {
			triggerOnStart();
		}
	}

	public void stop() {
		started = false;
		for (Piper piper : pipers.values()) {
			try {
				piper.stop();
			} catch (RuntimeException e) {
				log.error("Error stopping piper: {}", piper, e);
			}
			triggerOnPiperExit(piper);
		}
		pipers.clear();
		triggerOnStop();
	}

	public void speak(VoiceID voiceID, String text, int distance, String audioQueueName)
		throws ModelLocalUnavailableException, PiperNotActiveException {
		assert distance >= 0;
		try {
			if (!modelRepository.hasModelLocal(voiceID.modelName)) {
				throw new ModelLocalUnavailableException(text, voiceID);
			}

			if (!isModelActive(voiceID.getModelName())) {
				throw new PiperNotActiveException(text, voiceID);
			}

			// Piper should be guaranteed to be present due to checks above
			Piper piper = pipers.get(voiceID.modelName);

			List<String> fragments = splitSentence(text);
			for (String sentence : fragments) {
				piper.speak(sentence, voiceID, getVolumeWithDistance(distance), audioQueueName);
			}
		} catch (IOException e) {
			throw new RuntimeException("Error loading " + voiceID, e);
		}
	}

	public String expandShortenedPhrases(String text) {
		return TextUtil.expandShortenedPhrases(text, shortenedPhrases);
	}

	//</editor-fold>

	//<editor-fold desc="> Audio">
//	public float getVolumeWithDistance(int distance) {
//		if (distance <= 1) {
//			return 0;
//		}
//		return -6.0f * (float) (Math.log(distance) / Math.log(2)); // Log base 2
//	}
	public float getVolumeWithDistance(int distance) {
		float volumeWithDistance;
		if (distance <= 1) {
			volumeWithDistance = 0;
		} else {
			volumeWithDistance = -6.0f * (float) (Math.log(distance) / Math.log(2));
		}

		int masterVolumePercentage = PluginHelper.getConfig().masterVolume();
		if (masterVolumePercentage == 0) return -80;

		float scaleFactor = masterVolumePercentage / 100.0f;

		float maxVolume = 0;
		float minVolume = -35;

		float scaledVolume = minVolume + (volumeWithDistance - minVolume) * scaleFactor;

		scaledVolume = Math.max(minVolume, Math.min(maxVolume, scaledVolume));

		return scaledVolume;
	}

	public void clearAllAudioQueues() {
		for (String modelName : pipers.keySet()) {
			pipers.get(modelName).clearQueue();
		}
	}

	public void clearOtherPlayersAudioQueue(String username) {
		for (String modelName : pipers.keySet()) {
			Piper piper = pipers.get(modelName);
			for (String audioQueueName : piper.getNamedAudioQueueMap().keySet()) {
				if (audioQueueName.equals(AUDIO_QUEUE_DIALOGUE)) continue;
				if (audioQueueName.equals(PluginHelper.getLocalPlayerUsername())) continue;
				if (audioQueueName.equals(username)) continue;
				piper.getNamedAudioQueueMap().get(audioQueueName).queue.clear();
			}
		}
	}

	public void clearPlayerAudioQueue(String username) {
		for (String modelName : pipers.keySet()) {
			Piper piper = pipers.get(modelName);
			for (String audioQueueName : piper.getNamedAudioQueueMap().keySet()) {
				// Don't clear dialogue
				if (audioQueueName.equals(AUDIO_QUEUE_DIALOGUE)) continue;

				if (audioQueueName.equals(username)) {
					piper.getNamedAudioQueueMap().get(audioQueueName).queue.clear();
				}
			}
		}
	}
	//</editor-fold>

	//<editor-fold desc="> Piper">

	/**
	 * Starts Piper for specific ModelLocal
	 */

	public boolean isPiperPathValid() {
		File piper_file = runtimeConfig.getPiperPath().toFile();

		if (OSValidator.IS_WINDOWS) {
			String filename = piper_file.getName();
			// naive canExecute check for windows, 99.99% of humans use .exe extension for executables on Windows
			return filename.endsWith(".exe") && piper_file.exists() && !piper_file.isDirectory();
		} else {
			return piper_file.exists() && piper_file.canExecute() && !piper_file.isDirectory();
		}
	}

	public void startPiperForModel(ModelRepository.ModelLocal modelLocal) throws IOException {
		if (pipers.get(modelLocal.getModelName()) != null) {
			log.warn("Starting piper for {} when there are already pipers running for the model.",
				modelLocal.getModelName());
			Piper duplicate = pipers.remove(modelLocal.getModelName());
			duplicate.stop();
			triggerOnPiperExit(duplicate);
		}

		if (!isPiperUnquarantined && OSValidator.IS_MAC) {
			isPiperUnquarantined = MacUnquarantine.Unquarantine(runtimeConfig.getPiperPath());
		}

		Piper piper = Piper.start(
			modelLocal,
			runtimeConfig.getPiperPath(),
			modelConfig.getModelProcessCount(modelLocal.getModelName())
		);

		// Careful, PiperProcess listeners are not called on the client thread
		piper.addPiperListener(
			new Piper.PiperProcessLifetimeListener() {
				@Override
				public void onPiperProcessExit(PiperProcess process) {
					clientThread.invokeLater(() -> triggerOnPiperExit(piper));
				}
			}
		);

		pipers.put(modelLocal.getModelName(), piper);

		triggerOnPiperStart(piper);
	}

	public void stopPiperForModel(ModelRepository.ModelLocal modelLocal)
		throws PiperNotActiveException {
		Piper piper;
		if ((piper = pipers.remove(modelLocal.getModelName())) != null) {
			piper.stop();
			//			triggerOnPiperExit(piper);
		}
		else {
			throw new RuntimeException("Removing piper for {}, but there are no pipers running that model");
		}
	}

	public int activePiperProcessCount() {
		int result = 0;
		for (String modelName : pipers.keySet()) {
			Piper model = pipers.get(modelName);
			result += model.countAlive();
		}
		return result;
	}

	public boolean isModelActive(ModelRepository.ModelLocal modelLocal) {
		return isModelActive(modelLocal.getModelName());
	}

	public boolean isModelActive(String modelName) {
		Piper piper = pipers.get(modelName);
		return piper != null && piper.countAlive() > 0;
	}

	public void triggerOnPiperStart(Piper piper) {
		for (TextToSpeechListener listener : textToSpeechListeners) {
			listener.onPiperStart(piper);
		}
	}

	public void triggerOnPiperExit(Piper piper) {
		for (TextToSpeechListener listener : textToSpeechListeners) {
			listener.onPiperExit(piper);
		}
	}

	private void triggerOnPiperInvalid() {
		for (TextToSpeechListener listener : textToSpeechListeners) {
			listener.onPiperInvalid();
		}
	}
	//</editor-fold>


	public void loadModelConfig() {
		String json = configManager.getConfiguration(CONFIG_GROUP, CONFIG_KEY_MODEL_CONFIG);

		// no existing configs
		if (json == null) {
			// default text to speech config with libritts
			ModelConfigDatum datum = new ModelConfigDatum();
			datum.getPiperConfigData().add(new PiperConfigDatum("libritts", true, 1));
			this.modelConfig = ModelConfig.fromDatum(datum);
		}
		else { // has existing config, just load the json
			this.modelConfig = ModelConfig.fromJson(json);
		}
	}

	// In method so we can load again when user changes config
	public void loadShortenedPhrases() {
		String phrases = config.shortenedPhrases();
		shortenedPhrases = new HashMap<>();
		String[] lines = phrases.split("\n");
		for (String line : lines) {
			String[] parts = line.split("=", 2);
			if (parts.length == 2) shortenedPhrases.put(parts[0].trim(), parts[1].trim());
		}
	}

	public void saveModelConfig() {
		configManager.setConfiguration(CONFIG_GROUP, CONFIG_KEY_MODEL_CONFIG, modelConfig.toJson());
	}

	public void triggerOnStart() {
		for (TextToSpeechListener listener : textToSpeechListeners) {
			listener.onStart();
		}
	}

	public void triggerOnStop() {
		for (TextToSpeechListener listener : textToSpeechListeners) {
			listener.onStop();
		}
	}

	public void addTextToSpeechListener(TextToSpeechListener listener) {
		textToSpeechListeners.add(listener);
	}

	public void removeTextToSpeechListener(TextToSpeechListener listener) {
		textToSpeechListeners.remove(listener);
	}

	public interface TextToSpeechListener {
		default void onPiperStart(Piper piper) {}

		default void onPiperExit(Piper piper) {}

		default void onPiperInvalid() {}

		default void onStart() {}

		default void onStop() {}

	}
}

package dev.phyce.naturalspeech.tts.piper;

import dev.phyce.naturalspeech.tts.AudioPlayer;
import dev.phyce.naturalspeech.tts.AudioQueue;
import dev.phyce.naturalspeech.tts.ModelRepository;
import dev.phyce.naturalspeech.tts.VoiceID;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Value;
import lombok.extern.slf4j.Slf4j;

// Renamed from TTSModel
@Slf4j
public class Piper {
	@Getter
	private final Map<Long, PiperProcess> processMap = new HashMap<>();
	@Getter
	private final ConcurrentHashMap<String, AudioQueue> namedAudioQueueMap = new ConcurrentHashMap<>();
	private final ConcurrentLinkedQueue<PiperTask> piperTaskQueue = new ConcurrentLinkedQueue<>();
	private final AudioPlayer audioPlayer;

	@Getter
	private final ModelRepository.ModelLocal modelLocal;
	@Getter
	private final Path piperPath;
	private final Thread processPiperTaskThread;
	private final Thread processAudioQueueThread;

	private final List<PiperProcessLifetimeListener> piperProcessLifetimeListeners = new ArrayList<>();

	/**
	 * Create a piper and immediately start
	 *
	 * @throws IOException if piper fails to start an IOException will be thrown. (because stdin cannot be opened).
	 */
	public static Piper start(ModelRepository.ModelLocal modelLocal, Path piperPath, int instanceCount)
		throws IOException {
		return new Piper(modelLocal, piperPath, instanceCount);
	}

	private Piper(ModelRepository.ModelLocal modelLocal, Path piperPath, int instanceCount) throws IOException {
		this.modelLocal = modelLocal;
		this.piperPath = piperPath;

		audioPlayer = new AudioPlayer();

		startMore(instanceCount);

		processPiperTaskThread =
			new Thread(this::processPiperTask, String.format("[%s] Piper::processPiperTask Thread", this));
		processPiperTaskThread.start();

		processAudioQueueThread =
			new Thread(this::processAudioQueue, String.format("[%s] Piper::processAudioQueue Thread", this));
		processAudioQueueThread.start();
	}

	public void startMore(int instanceCount) throws IOException {
		//Instance count should not be more than 2
		for (int index = 0; index < instanceCount; index++) {
			PiperProcess process;
			try {
				process = PiperProcess.start(piperPath, modelLocal.getOnnx().toPath());
				triggerOnPiperProcessStart(process);
			} catch (IOException e) {
				// clean-up stray instances before throwing
				processMap.forEach((pid, piperProcess) -> piperProcess.stop());
				processMap.clear();
				throw e;
			}
			process.onExit().thenAccept(p -> {
				triggerOnPiperProcessExit(p);
			});
			processMap.put(process.getPid(), process);
		}
	}

	//Process message queue
	public void processPiperTask() {
		while (!processPiperTaskThread.isInterrupted()) {
			if (piperTaskQueue.isEmpty()) {
				synchronized (piperTaskQueue) {
					try {
						piperTaskQueue.wait();
					} catch (InterruptedException e) {
						return; // just exit on interrupt
					}
				}
				continue; // double check emptiness after notify.
			}

			PiperTask task = piperTaskQueue.poll();

			if (processMap.isEmpty()) {
			}

			// using iterator to loop, so if an invalid PiperProcess is found we can remove.
			Iterator<Long> iter = processMap.keySet().iterator();
			while (iter.hasNext()) {
				long pid = iter.next();
				PiperProcess process = processMap.get(pid);

				if (!process.isAlive()) {
					iter.remove();
					triggerOnPiperProcessCrash(process);
					continue;
				}

				if (!process.getPiperLocked().get()) {
					byte[] audioClip;
					try {
						triggerOnPiperProcessBusy(process);
						audioClip = process.generateAudio(task.getText(), task.getVoiceID().getPiperVoiceID());
						triggerOnPiperProcessDone(process);
					} catch (IOException | InterruptedException e) {
						// PiperProcess exited unexpectedly, remove the process
						log.error("{} had an unexpected exited, either crashed or terminated by user.", process);
						triggerOnPiperProcessCrash(process);

						process.stop();
						iter.remove();
						continue;
					}
					if (audioClip != null && audioClip.length > 0) {
						AudioQueue audioQueue =
							namedAudioQueueMap.computeIfAbsent(task.audioQueueName, audioQueueName -> new AudioQueue());
						audioQueue.queue.add(new AudioQueue.AudioTask(audioClip, task.getVolume()));

						synchronized (namedAudioQueueMap) {namedAudioQueueMap.notify();}

						break;
					}
				}
			}
		}
	}

	public void processAudioQueue() {
		while (!processAudioQueueThread.isInterrupted()) {

			synchronized (namedAudioQueueMap) {
				try {
					namedAudioQueueMap.wait();
				} catch (InterruptedException e) {
					return;
				}
			}

			namedAudioQueueMap.forEach((queueName, audioQueue) -> {

				if (!audioQueue.isPlaying() && !audioQueue.queue.isEmpty()) {
					audioQueue.setPlaying(true);

					// start a thread for each named audio queue
					new Thread(() -> {
						try {
							AudioQueue.AudioTask task;
							while ((task = audioQueue.queue.poll()) != null) {
								audioPlayer.playClip(task.getAudioClip(), task.getVolume());
							}
						} finally {
							audioQueue.setPlaying(false);
						}
					}, String.format("[%s] AudioPlayer Thread for %s", this, queueName)).start();
				}

			});
		}
	}

	// Refactored to decouple from dependencies
	public void speak(String text, VoiceID voiceID, float volume, String audioQueueName) throws IOException {
		if (countAlive() == 0) {
			throw new IOException("No active PiperProcess instances running for " + voiceID.getModelName());
		}

		if (piperTaskQueue.size() > 10) {
			log.info("Cleared queue because queue size is too large. (more then 10)");
			clearQueue();
		}

		piperTaskQueue.add(new PiperTask(text, voiceID, volume, audioQueueName));
		synchronized (piperTaskQueue) {piperTaskQueue.notify();}
	}

	public void clearQueue() {
		piperTaskQueue.clear();
		namedAudioQueueMap.values().forEach(audioQueue -> {
			audioQueue.queue.clear();
		});
	}

	public int countAlive() {
		int result = 0;
		for (PiperProcess process : processMap.values()) {
			if (process.isAlive()) result++;
		}
		return result;
	}

	public void stop() {
		audioPlayer.stop();

		for (PiperProcess instance : processMap.values()) {
			instance.stop();
		}
		processMap.clear();

		// clear task and audio queue on stop
		clearQueue();

		processAudioQueueThread.interrupt();
		processPiperTaskThread.interrupt();
	}

	/**
	 * @param listener This is not called on the client thread, please be careful.
	 */
	public void addPiperListener(PiperProcessLifetimeListener listener) {
		piperProcessLifetimeListeners.add(listener);
	}

	public void removePiperListener(PiperProcessLifetimeListener listener) {
		piperProcessLifetimeListeners.remove(listener);
	}

	private void triggerOnPiperProcessBusy(PiperProcess process) {
		for (PiperProcessLifetimeListener listener : piperProcessLifetimeListeners) {
			listener.onPiperProcessBusy(process);
		}
	}

	private void triggerOnPiperProcessCrash(PiperProcess process) {
		for (PiperProcessLifetimeListener listener : piperProcessLifetimeListeners) {
			listener.onPiperProcessCrash(process);
		}
	}

	private void triggerOnPiperProcessDone(PiperProcess process) {
		for (PiperProcessLifetimeListener listener : piperProcessLifetimeListeners) {
			listener.onPiperProcessDone(process);
		}
	}

	private void triggerOnPiperProcessStart(PiperProcess process) {
		for (PiperProcessLifetimeListener listener : piperProcessLifetimeListeners) {
			listener.onPiperProcessStart(process);
		}
	}

	private void triggerOnPiperProcessExit(PiperProcess process) {
		for (PiperProcessLifetimeListener listener : piperProcessLifetimeListeners) {
			listener.onPiperProcessExit(process);
		}
	}

	@Override
	public String toString() {
		return String.format("Piper for %s with %d active processes", getModelLocal().getModelName(), countAlive());
	}

	// Renamed from TTSItem, decoupled from dependencies
	@Value
	@AllArgsConstructor
	private static class PiperTask {
		String text;
		VoiceID voiceID;
		float volume;
		String audioQueueName;
	}

	public interface PiperProcessLifetimeListener {
		default void onPiperProcessStart(PiperProcess process) {}

		default void onPiperProcessExit(PiperProcess process) {}

		// Busy generating voices
		default void onPiperProcessBusy(PiperProcess process) {}

		// Done generating voices
		default void onPiperProcessDone(PiperProcess process) {}

		default void onPiperProcessCrash(PiperProcess process) {}
	}
}

package dev.phyce.naturalspeech.tts.piper;

import dev.phyce.naturalspeech.utils.TextUtil;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;


// Renamed from TTSEngine
@Slf4j
public class PiperProcess {
	public static final Pattern piperLogMatcher = Pattern.compile("\\[.+] \\[piper] \\[info] (.+)");
	@Getter
	private final AtomicBoolean piperLocked;
	private final ByteArrayOutputStream streamCapture = new ByteArrayOutputStream();
	private final Path modelPath;
	private final Process process;
	private final BufferedWriter processStdIn;
	private final Thread processStdInThread;
	private final Thread processStdErrThread;

	private PiperProcess(Path piperPath, Path modelPath) throws IOException {
		piperLocked = new AtomicBoolean(false);
		piperLocked.set(false);
		this.modelPath = modelPath;

		ProcessBuilder processBuilder = new ProcessBuilder(
			piperPath.toString(),
			"--model", modelPath.toString(),
			"--output-raw",
			"--json-input"
		);

		process = processBuilder.start();

		processStdIn = new BufferedWriter(new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8));

		processStdInThread =
			new Thread(this::processStdIn, String.format("[%s] PiperProcess::processStdIn Thread", this));
		processStdInThread.start();
		processStdErrThread =
			new Thread(this::processStdErr, String.format("[%s] PiperProcess::processStdErr Thread", this));
		processStdErrThread.start();

		log.info("{}", processBuilder.command().stream().reduce((a, b) -> a + " " + b).orElse(""));
	}

	@Override
	public String toString() {
		if (process.isAlive()) {return String.format("pid:%s model:%s", process.pid(), modelPath.getFileName());}
		else {return String.format("pid:dead model:%s", modelPath.getFileName());}
	}

	public static PiperProcess start(Path piperPath, Path modelPath) throws IOException {
		return new PiperProcess(piperPath, modelPath);
	}

	public void stop() {
		piperLocked.set(true);
		processStdErrThread.interrupt();
		processStdInThread.interrupt();

		if (process != null && process.isAlive()) {
			try {
				if (processStdIn != null) processStdIn.close();
			} catch (IOException exception) {
				log.error("{} failed closing processStdIn on stop.", this, exception);
			}
			process.destroy();
		}

	}

	//Capture audio stream
	public void processStdIn() {
		try (InputStream inputStream = process.getInputStream()) {
			byte[] data = new byte[1024];
			int nRead;
			while (!processStdInThread.isInterrupted() && (nRead = inputStream.read(data, 0, data.length)) != -1) {
				synchronized (streamCapture) {
					streamCapture.write(data, 0, nRead);
				}
			}
		} catch (IOException e) {
			log.error("{}: readStdIn threw", this, e);
		}
	}

	public void processStdErr() {
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getErrorStream()))) {
			String line;
			while (!processStdErrThread.isInterrupted() && (line = reader.readLine()) != null) {
				if (line.endsWith(" sec)")) {
					synchronized (streamCapture) {
						streamCapture.notify();
					}
				}
				log.trace("[pid:{}-StdErr]: {}", this.getPid(), stripPiperLogPrefix(line));
			}
		} catch (IOException e) {
			log.error("{}: readStdErr threw exception", this, e);
		}
	}

	// refactor: inlined the speak(TTSItem) method into one generateAudio function
	public byte[] generateAudio(String text, int piperVoiceID) throws IOException, InterruptedException {
		piperLocked.set(true);
		byte[] audioClip;
		try {
			byte[] result = null;
			boolean valid = false;

			synchronized (streamCapture) {
				streamCapture.reset();
			}

			processStdIn.write(TextUtil.generateJson(text, piperVoiceID));
			processStdIn.newLine();
			processStdIn.flush();

			synchronized (streamCapture) {
				streamCapture.wait();

				if (!valid) {
					result = streamCapture.toByteArray();
				}
			}

			audioClip = result;
		} finally {
			piperLocked.set(false);
		}
		return audioClip;
	}

	public boolean isAlive() {
		return process.isAlive();
	}

	public long getPid() {
		return process.pid();
	}

	public CompletableFuture<PiperProcess> onExit() {
		CompletableFuture<PiperProcess> piperOnExit = new CompletableFuture<PiperProcess>();
		process.onExit().thenRun(() -> piperOnExit.complete(this));
		return piperOnExit;
	}

	private static String stripPiperLogPrefix(String piperLog) {
		// [2024-03-08 16:07:17.781] [piper] [info] Real-time factor: 0.45758559656250003 (infer=0.6640698 sec, audio=1.4512471655328798 sec)
		// ->
		// Real-time factor: 0.45758559656250003 (infer=0.6640698 sec, audio=1.4512471655328798 sec)
		Matcher match;
		if ((match = piperLogMatcher.matcher(piperLog)).matches()) {
			return match.group(1);
		}
		else {
			return piperLog;
		}
	}

}
package dev.phyce.naturalspeech.tts;

public final class MagicUsernames {
	public static final String SYSTEM = "&system";
	public static final String GLOBAL_NPC = "&globalnpc";
	public static final String LOCAL_USER = "&localuser";
}

package dev.phyce.naturalspeech.tts;

import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;
import com.google.common.io.Resources;
import com.google.gson.JsonSyntaxException;
import com.google.inject.Inject;
import com.google.inject.Singleton;
import dev.phyce.naturalspeech.enums.Gender;
import dev.phyce.naturalspeech.NaturalSpeechPlugin;
import static dev.phyce.naturalspeech.configs.NaturalSpeechConfig.CONFIG_GROUP;
import dev.phyce.naturalspeech.configs.VoiceConfig;
import dev.phyce.naturalspeech.exceptions.VoiceSelectionOutOfOption;
import dev.phyce.naturalspeech.helpers.PluginHelper;
import dev.phyce.naturalspeech.tts.piper.Piper;
import java.io.IOException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.CheckForNull;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.Player;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.Text;


@Slf4j
@Singleton
public class VoiceManager {

	public final static String VOICE_CONFIG_FILE = "speaker_config.json";
	private final VoiceConfig voiceConfig;
	private final TextToSpeech textToSpeech;
	private final ConfigManager configManager;
	private final GenderedVoiceMap genderedVoiceMap;

	private final Multimap<ModelRepository.ModelLocal, VoiceID> activeVoiceMap = HashMultimap.create();

	@Inject
	public VoiceManager(TextToSpeech textToSpeech, ConfigManager configManager) {
		this.textToSpeech = textToSpeech;
		this.configManager = configManager;
		this.genderedVoiceMap = new GenderedVoiceMap();
		voiceConfig = new VoiceConfig();

		textToSpeech.addTextToSpeechListener(
			new TextToSpeech.TextToSpeechListener() {
				@Override
				public void onPiperStart(Piper piper) {
					ModelRepository.ModelLocal modelLocal = piper.getModelLocal();
					genderedVoiceMap.addModel(modelLocal);
					for (ModelRepository.VoiceMetadata voiceMetadata : modelLocal.getVoiceMetadata()) {
						activeVoiceMap.put(modelLocal, voiceMetadata.toVoiceID());
					}
				}

				@Override
				public void onPiperExit(Piper piper) {
					genderedVoiceMap.removeModel(piper.getModelLocal());
					activeVoiceMap.removeAll(piper.getModelLocal());
				}
			}
		);

		loadVoiceConfig();
	}

	@CheckForNull
	public List<VoiceID> checkVoiceIDWithUsername(@NonNull String standardized_username) {
		return voiceConfig.findUsername(standardized_username);
	}

	public void loadVoiceConfig() {
		// try to load from existing json in configManager
		String json = configManager.getConfiguration(CONFIG_GROUP, VOICE_CONFIG_FILE);
		if (json != null) {
			try {
				voiceConfig.loadJSON(json);
				log.info("Loaded {} voice config entries from existing VoiceConfig JSON from ConfigManager.",
					voiceConfig.countAll());
				return;
			} catch (JsonSyntaxException ignored) {
				// fallback to default json
				log.error("Invalid voiceConfig stored in ConfigManager, falling back to default: {}", json);
			}
		}
		else {
			log.error("No existing voiceConfig stored in ConfigManager, falling back to default");
		}

		// if configManager fails, load default from resources
		try {
			URL resourceUrl = Objects.requireNonNull(NaturalSpeechPlugin.class.getResource(VOICE_CONFIG_FILE));
			//noinspection UnstableApiUsage
			json = Resources.toString(resourceUrl, StandardCharsets.UTF_8);
		} catch (IOException e) {
			throw new RuntimeException("Default voice config file failed to load. " +
				"Either JSON is incorrect, file path is incorrect, or the file doesn't exist.");
		}

		try {
			voiceConfig.loadJSON(json);
			log.info("Loaded default JSON from ResourceFile " + VOICE_CONFIG_FILE);
		} catch (JsonSyntaxException e) {
			throw new RuntimeException("Failed to parse the default voice config JSON: " + json, e);
		}
	}

	public void saveVoiceConfig() {
		configManager.setConfiguration(CONFIG_GROUP, VOICE_CONFIG_FILE, voiceConfig.toJson());
	}

	@CheckForNull
	public VoiceID randomVoiceFromActiveModels(String standardized_username) {
		int hashCode = standardized_username.hashCode();

		long count = activeVoiceMap.values().size();
		Optional<VoiceID> first = activeVoiceMap.values().stream().skip(Math.abs(hashCode) % count).findFirst();

		return first.orElse(null);
	}

	@CheckForNull
	private VoiceID randomGenderedVoice(String standardized_username, Gender gender) {
		List<VoiceID> voiceIDs = genderedVoiceMap.find(gender);
		if (voiceIDs == null || voiceIDs.isEmpty()) {
			return null;
		}
		int hashCode = standardized_username.hashCode();
		int voice = Math.abs(hashCode) % voiceIDs.size();

		return voiceIDs.get(voice);
	}
	// Ultimate fallback
	@CheckForNull
	public VoiceID randomVoice() {
		long count = activeVoiceMap.values().size();
		Optional<VoiceID> first = activeVoiceMap.values().stream().skip((int) (Math.random() * count)).findFirst();

		return first.orElse(null);
	}

	//<editor-fold desc="> Get">
	@CheckForNull
	private VoiceID getFirstActiveVoice(@NonNull List<VoiceID> voiceIdAndFallbacks) {
		for (VoiceID voiceID : voiceIdAndFallbacks) {
			// if the config is invalid, a null might be present
			if (voiceID == null) continue;

			if (textToSpeech.isModelActive(voiceID.getModelName())) {
				return voiceID;
			}
		}
		return null;
	}

	@NonNull
	public VoiceID getVoiceIDFromNPCId(int npcId, String npcName) throws VoiceSelectionOutOfOption {
		npcName = Text.standardize(npcName);

		VoiceID result;
		{
			// 1. Check NPC ID, takes priority over everything.
			List<VoiceID> results = voiceConfig.findNpcId(npcId);
			if (results != null) {
				result = getFirstActiveVoice(results);
				if (result == null) {
					log.debug("Existing NPC ID voice found for NPC id:{} npcName:{}, but model is not active", npcId, npcName);
				} else {
					log.debug("Existing NPC ID voice found for NPC id:{} npcName:{}, using {}",
						npcId, npcName, result);
				}
			} else {
				result = null;
				log.debug("No existing NPC ID voice was found for NPC id:{} npcName:{}", npcId, npcName);
			}
		}

		if (result == null) {
			// 2. Check NPC Name
			List<VoiceID> results = voiceConfig.findNpcName(npcName);
			if (results != null) {
				result = getFirstActiveVoice(results);
			}
			if (result == null) {
				log.debug("No NPC ID voice found, NPC Name is also not available for NPC id:{} npcName:{}",
					npcId, npcName);
			} else {
				log.debug("No NPC ID voice found, falling back to NPC Name for NPC id:{} npcName:{}, using {}",
					npcId, npcName, result);
			}
		}

		if (result == null) {
			// 3. Fallback to NPC Global (or random if NPC global isn't set).
			log.debug("No NPC ID or NPC Name voice found, falling back to global NPC player username &globalnpc");
			List<VoiceID> results = voiceConfig.findUsername(MagicUsernames.GLOBAL_NPC);
			if (results != null) {
				result = getFirstActiveVoice(results);
			}
		}

		if (result == null) {
			// 4. If no NPC Global is available, randomize using npc name
			result = randomVoiceFromActiveModels(npcName);
		}

		if (result == null) {
			throw new VoiceSelectionOutOfOption();
		}

		return result;
	}

	@NonNull
	public VoiceID getVoiceIdForLocalPlayer() throws VoiceSelectionOutOfOption {
		return getVoiceIDFromUsername(MagicUsernames.LOCAL_USER);
	}

	public boolean containsUsername(@NonNull String standardized_username) {
		List<VoiceID> voiceAndFallback = voiceConfig.findUsername(standardized_username);
		return voiceAndFallback != null && !voiceAndFallback.isEmpty();
	}

	public boolean containsNPC(int npcId, @NonNull String standardized_name) {
		{
			List<VoiceID> voiceAndFallback = voiceConfig.findNpcId(npcId);
			if (voiceAndFallback != null && !voiceAndFallback.isEmpty()) {
				return true;
			}
		}

		{
			List<VoiceID> voiceAndFallback = voiceConfig.findNpcName(standardized_name);
			return voiceAndFallback != null && !voiceAndFallback.isEmpty();
		}
	}

	@NonNull
	public VoiceID getVoiceIDFromUsername(@NonNull String standardized_username) throws VoiceSelectionOutOfOption {
		List<VoiceID> voiceAndFallback = voiceConfig.findUsername(standardized_username);

		VoiceID result;
		if (voiceAndFallback != null) {
			result = getFirstActiveVoice(voiceAndFallback);
		} else {
			result = null;
		}

		if (result == null) {
			Player player = PluginHelper.findPlayerWithUsername(standardized_username);
			if (player != null) {
				Gender gender = Gender.parseInt(player.getPlayerComposition().getGender());
				log.debug("No existing settings found for {}, using randomize gendered voice.", standardized_username);
				VoiceID voiceID = randomGenderedVoice(standardized_username, gender);
				if (voiceID != null) {
					return voiceID;
				} else {
					throw new VoiceSelectionOutOfOption();
				}
			}
			else {
				log.debug("No Player object found with {}, using random voice.", standardized_username);
				VoiceID voiceID = randomVoiceFromActiveModels(standardized_username);
				if (voiceID == null) {
					throw new VoiceSelectionOutOfOption();
				}
				return voiceID;
			}
		} else {
			log.debug("Existing settings found for {} and model is active. using {}.",
				standardized_username, result);
			return result;
		}
	}

	public void setDefaultVoiceIDForUsername(@NonNull String standardized_username, VoiceID voiceID) {
		voiceConfig.setDefaultPlayerVoice(standardized_username, voiceID);
	}


	public void setActorVoiceID(@NonNull Actor actor, VoiceID voiceId) {
		if (actor instanceof NPC) {
			NPC npc = ((NPC) actor);
			// I have no idea what a Composition is
			var compId = npc.getComposition().getId();
			// This is to solve the issue where the ModelID does not match the NPCID
			voiceConfig.setDefaultNpcIdVoice(npc.getId(), voiceId);
			voiceConfig.setDefaultNpcIdVoice(compId, voiceId);

			log.debug("Setting Default NPC Voice for NpcID: {} CompID: {} NpcName: {} to {}",
				npc.getId(), compId, npc.getName(), voiceId);
		}
		else if (actor instanceof Player) {
			String standardized_username = Text.standardize(Objects.requireNonNull(actor.getName()));
			voiceConfig.setDefaultPlayerVoice(standardized_username, voiceId);
			log.debug("Setting Default Player Voice for {} to {}", actor.getName(), voiceId);
		}
		else {
			log.error("Tried setting a voice for neither NPC or player. Possibly for an object.");
		}
	}

	public void setDefaultVoiceIDForNPC(@NonNull String npcName, VoiceID voiceId) {
		voiceConfig.setDefaultNpcNameVoice(npcName, voiceId);
	}

	//</editor-fold>

	//<editor-fold desc="> Reset">
	public void resetForUsername(@NonNull String standardized_username) {
		voiceConfig.resetPlayerVoice(standardized_username);
	}
	public void resetVoiceIDForNPC(@NonNull NPC actor) {
		voiceConfig.resetNpcIdVoices(actor.getId());
		voiceConfig.resetNpcIdVoices(actor.getComposition().getId());

		if (actor.getName() != null) {
			String standardNpcName = Text.standardize(Text.removeTags(actor.getName()));
			voiceConfig.resetNpcNameVoices(standardNpcName);
		}
	}

	public void resetVoiceIDForNPCName(@NonNull String npcName) {
		voiceConfig.resetNpcNameVoices(npcName);
	}

	//</editor-fold>
}

package dev.phyce.naturalspeech.tts;

import lombok.Data;

@Data
public class VoiceID {
	public String modelName;
	public int piperVoiceID;

	public VoiceID() {

	}

	public VoiceID(String modelName, int piperVoiceID) {
		this.modelName = modelName;
		this.piperVoiceID = piperVoiceID;
	}

	/**
	 * Returns the ModelAndVoice in the format of "modelShortName:VoiceID",
	 * ex libritts:360
	 *
	 * @return null if format is invalid, ModelAndVoice otherwise.
	 * Does not verify Model and Voice's actual existence.
	 */
	public static VoiceID fromIDString(String idString) {
		String[] split = idString.split(":");

		// incorrect format
		if (split.length != 2) return null;

		// verify model short name
		if (split[0].isEmpty() || split[0].isBlank()) return null;

		// verify voice ID
		int voiceID;

		try {
			voiceID = Integer.parseUnsignedInt(split[1]);
		} catch (NumberFormatException ignored) {
			return null;
		}

		return new VoiceID(split[0], voiceID);
	}

	public String toVoiceIDString() {
		return String.format("%s:%d", modelName, piperVoiceID);
	}

	public String toString() {
		return toVoiceIDString();
	}
}

package dev.phyce.naturalspeech.tts;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.NonNull;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPC;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.util.Text;

@Slf4j
@Singleton
public class MuteManager {

	private static final String KEY_USERNAME_LISTEN_LIST = "usernameListenList";
	private static final String KEY_LISTEN_MODE = "listenMode";
	private final List<String> usernameListenList = new ArrayList<>();
	private static final String KEY_USERNAME_MUTE_LIST = "usernameMuteList";
	private final List<String> usernameMuteList = new ArrayList<>();


	private static final String KEY_NPC_ID_LISTEN_LIST = "npcIdListenList";

	// WARNING: Most List.remove List.get have overloads for using index,
	// Can easily use List.remove(int index) accidentally
	// When we want to use List.remove(Integer value)
	private final List<Integer> npcIdListenList = new ArrayList<>();
	private static final String KEY_NPC_ID_MUTE_LIST = "npcIdMuteList";
	private final List<Integer> npcIdMuteList = new ArrayList<>();

	private final ConfigManager configManager;

	@Getter
	@Setter
	private boolean listenMode = false;

	@Inject
	public MuteManager(ConfigManager configManager) {
		this.configManager = configManager;

		loadConfig();
	}

	public boolean isNpcAllowed(NPC npc) {
		if (listenMode) {
			return isNpcListened(npc);
		} else {
			return isNpcUnmuted(npc);
		}
	}
	public boolean isNpcIdAllowed(Integer npcId) {
		if (listenMode) {
			return npcIdListenList.contains(npcId);
		} else {
			return !npcIdMuteList.contains(npcId);
		}
	}

	public boolean isNpcListened(NPC npc) {
		int npcId = npc.getId();
		int compId = npc.getComposition().getId();

		return npcIdListenList.contains(npcId) || npcIdListenList.contains(compId);
	}

	public boolean isNpcUnmuted(NPC npc) {
		int npcId = npc.getId();
		int compId = npc.getComposition().getId();

		return !npcIdMuteList.contains(npcId) && !npcIdMuteList.contains(compId);
	}

	public boolean isUsernameAllowed(String standardized_username) {
		if (listenMode) {
			return isUsernameListened(standardized_username);
		} else {
			return isUsernameUnmuted(standardized_username);
		}
	}

	public boolean isUsernameUnmuted(String standardActorName) {
		return !usernameMuteList.contains(standardActorName);
	}

	public boolean isUsernameListened(String standardActorName) {
		return usernameListenList.contains(standardActorName);
	}

	public void muteNpcId(Integer npcId) {
		npcIdMuteList.remove(npcId); // de-duplicate
		npcIdMuteList.add(npcId);
	}

	public void muteNpc(@NonNull NPC npc) {
		muteNpcId(npc.getId());
		muteNpcId(npc.getComposition().getId());
		// deprecating muting NPC names
		log.trace("Muting NpcId:{} CompID:{}",
			npc.getId(), npc.getComposition().getId());
	}

	public void unmuteNpc(@NonNull NPC npc) {
		unmuteNpcId(npc.getId());
		unmuteNpcId(npc.getComposition().getId());
		log.trace("Unmuting NpcId:{} CompID:{}",
			npc.getId(), npc.getComposition().getId());
	}

	public void listenNpc(NPC npc) {
		int npcId = npc.getId();
		int compId = npc.getComposition().getId();

		listenNpcId(npcId);
		listenNpcId(compId);
	}

	public void unlistenNpc(NPC npc) {
		int npcId = npc.getId();
		int compId = npc.getComposition().getId();

		unlistenNpcId(npcId);
		unlistenNpcId(compId);
	}

	public void unmuteNpcId(Integer npcId) {
		npcIdMuteList.remove(npcId);
	}

	public void listenNpcId(Integer npcId) {
		npcIdListenList.remove(npcId); // de-duplicate
		npcIdListenList.add(npcId);
	}

	public void unlistenNpcId(Integer npcId) {
		npcIdListenList.remove(npcId);
	}

	public void muteUsername(String username) {
		usernameMuteList.remove(username); // de-duplicate
		usernameMuteList.add(username);
	}

	public void unmuteUsername(String username) {
		usernameMuteList.remove(username);
	}

	public void listenUsername(String username) {
		usernameListenList.remove(username); // de-duplicate
		usernameListenList.add(username);
	}

	public void unlistenUsername(String username) {
		usernameListenList.remove(username);
	}

	public void clearListens() {
		this.npcIdListenList.clear();
		this.usernameListenList.clear();
	}

	public void saveConfig() {
		saveUsernameConfig();
		saveNpcIdConfig();
		saveListenModeConfig();
	}



	public void loadConfig() {
		loadUsernameConfig();
		loadNpcIdConfig();
		loadListenModeConfig();
	}

	private void saveListenModeConfig() {
		configManager.setConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_LISTEN_MODE, listenMode);
	}


	private void saveNpcIdConfig() {
		configManager.setConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_NPC_ID_LISTEN_LIST,
			Text.toCSV(npcIdListenList
				.stream()
				.map(Object::toString)
				.collect(Collectors.toList()))
		);
		configManager.setConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_NPC_ID_MUTE_LIST,
			Text.toCSV(npcIdMuteList
				.stream()
				.map(Object::toString)
				.collect(Collectors.toList()))
		);
	}

	private void saveUsernameConfig() {
		configManager.setConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_USERNAME_LISTEN_LIST,
			Text.toCSV(usernameListenList));
		configManager.setConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_USERNAME_MUTE_LIST,
			Text.toCSV(usernameMuteList));
	}

	private void loadListenModeConfig() {
		String result = configManager.getConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_LISTEN_MODE);
		if (result != null) {
			listenMode = Boolean.parseBoolean(result);
		} else {
			listenMode = false;
		}
	}


	private void loadNpcIdConfig() {
		{
			npcIdListenList.clear();
			String result = configManager.getConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_NPC_ID_LISTEN_LIST);
			if (result != null) {
				npcIdListenList.addAll(
					Text.fromCSV(result)
						.stream()
						.map(Integer::parseInt)
						.collect(Collectors.toList())
				);
			}
		}

		{
			npcIdMuteList.clear();
			String result = configManager.getConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_NPC_ID_MUTE_LIST);
			if (result != null) {
				npcIdMuteList.addAll(
					Text.fromCSV(result)
						.stream()
						.map(Integer::parseInt)
						.collect(Collectors.toList())
				);
			}
		}
	}

	private void loadUsernameConfig() {
		{
			usernameListenList.clear();
			String result = configManager.getConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_USERNAME_LISTEN_LIST);
			if (result != null) {
				usernameListenList.addAll(Text.fromCSV(result));

			}
		}

		{
			usernameMuteList.clear();
			String result = configManager.getConfiguration(NaturalSpeechConfig.CONFIG_GROUP, KEY_USERNAME_MUTE_LIST);
			if (result != null) {
				usernameMuteList.addAll(Text.fromCSV(result));
			}
		}
	}
}

package dev.phyce.naturalspeech.tts;

import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.atomic.AtomicBoolean;
import lombok.Value;

public class AudioQueue {
	private final AtomicBoolean playing = new AtomicBoolean(false);
	public ConcurrentLinkedQueue<AudioTask> queue = new ConcurrentLinkedQueue<>();

	public boolean isPlaying() {
		return playing.get();
	}

	public void setPlaying(boolean playing) {
		this.playing.set(playing);
	}

	// decoupled audio queue from plugin logic
	@Value
	public static class AudioTask {
		byte[] audioClip;
		float volume;
	}
}

package dev.phyce.naturalspeech;

import com.google.inject.Inject;
import dev.phyce.naturalspeech.spamdetection.ChatFilterPluglet;
import dev.phyce.naturalspeech.spamdetection.SpamFilterPluglet;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class SpamDetection {

	private final ChatFilterPluglet chatFilterPluglet;
	private final SpamFilterPluglet spamFilterPluglet;

	@Inject
	private SpamDetection(ChatFilterPluglet chatFilterPluglet, SpamFilterPluglet spamFilterPluglet
	) {
		this.chatFilterPluglet = chatFilterPluglet;
		this.spamFilterPluglet = spamFilterPluglet;

	}

	public boolean isSpam(String username, String text) {
		return spamFilterPluglet.isSpam(text) || chatFilterPluglet.isSpam(username, text);
	}


}

package dev.phyce.naturalspeech.utils;

public final class OSValidator {

	private static final String OS = System.getProperty("os.name").toLowerCase();
	public static boolean IS_WINDOWS = (OS.contains("win"));
	public static boolean IS_MAC = (OS.contains("mac"));
	public static boolean IS_UNIX = (OS.contains("nix") || OS.contains("nux") || OS.indexOf("aix") > 0);

}
package dev.phyce.naturalspeech.utils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public final class TextUtil {

	public static List<String> splitSentence(String sentence) {
		final int softLimit = 40;
		final int hardLimit = 80;
		List<String> fragments = new ArrayList<>();
		StringBuilder currentFragment = new StringBuilder();

		List<String> tokens = tokenize(sentence);

		for (String token : tokens) {
			if (currentFragment.length() + token.length() <= hardLimit) {
				currentFragment.append(token);

				if (token.matches(".*[.!?]$")) {
					fragments.add(currentFragment.toString().trim());
					currentFragment.setLength(0);
					continue;
				}

				if (token.matches(".*[,-;/]$") && currentFragment.length() > softLimit) {
					fragments.add(currentFragment.toString().trim());
					currentFragment.setLength(0);
					continue;
				}
			}
			else {
				int lastBreakPoint = findLastBreakPoint(currentFragment.toString(), softLimit, hardLimit);
				if (lastBreakPoint > 0) {
					fragments.add(currentFragment.substring(0, lastBreakPoint).trim());
					currentFragment = new StringBuilder(currentFragment.substring(lastBreakPoint).trim());
				}
				else {
					fragments.add(currentFragment.toString().trim());
					currentFragment.setLength(0);
				}
				currentFragment.append(token);
			}

			if (!token.matches("\\p{Punct}")) currentFragment.append(" ");
		}

		if (currentFragment.length() > 0) fragments.add(currentFragment.toString().trim());

		return fragments;
	}

	private static int findLastBreakPoint(String fragment, int softLimit, int hardLimit) {
		int lastSpace = -1;

		for (int i = 0; i < fragment.length(); i++) {
			if (fragment.charAt(i) == ' ' || fragment.charAt(i) == ',') {lastSpace = i + 1;}
			else if (fragment.charAt(i) == '.' || fragment.charAt(i) == '!' || fragment.charAt(i) == '?') return i + 1;
		}
		return lastSpace;
	}

	public static String expandShortenedPhrases(String text, Map<String, String> phrases) {
		List<String> tokens = tokenize(text);
		StringBuilder parsedMessage = new StringBuilder();
		int lastIndex = 0;

		for (String token : tokens) {
			if (text.indexOf(token, lastIndex) > lastIndex) parsedMessage.append(" ");

			String key = token.toLowerCase();
			String replacement = phrases.getOrDefault(key, token);
			parsedMessage.append(replacement);
			lastIndex = text.indexOf(token, lastIndex) + token.length();
		}

		return parsedMessage.toString();
	}

	public static List<String> tokenize(String text) {
		List<String> tokens = new ArrayList<>();
		Matcher matcher = Pattern.compile("[^\\s]+").matcher(text);

		while (matcher.find()) tokens.add(matcher.group());

		return tokens;
	}

	public static final Pattern patternAnyAlphaNumericChar = Pattern.compile(".*[A-Za-zÀ-ÖØ-öø-ÿ].*");
	public static boolean containAlphaNumeric(String text) {
		return patternAnyAlphaNumericChar.matcher(text).matches();
	}

	public static String escape(String text) {
		return text.replace("\\", "\\\\")
			.replace("\"", "\\\"")
			.replace("\b", "\\b")
			.replace("\f", "\\f")
			.replace("\n", "\\n")
			.replace("\r", "\\r")
			.replace("\t", "\\t");
	}

	public static String generateJson(String text, int voiceId) {
		text = escape(text);
		if(voiceId == -1) return String.format("{\"text\":\"%s\"}", text);
		else return String.format("{\"text\":\"%s\", \"speaker_id\":%d}", text, voiceId);
	}

	private static final Pattern patternTargetWithLevel = Pattern.compile("(.+)  \\(level-\\d+\\)");
	/**
	 * For MenuEntry menuTarget name.
	 * Keeps tag information, removes level information.
	 * For example <col=ffffff>Guard</col>  (level-32) -> Guard
	 * @return
	 */
	public static String removeLevelFromTargetName(String menuTarget) {
		Matcher matcher = patternTargetWithLevel.matcher(menuTarget);
		if (matcher.matches()) menuTarget = matcher.group(1);
		return menuTarget;
	}

	public static String removeTags(String input) {
		return input.replaceAll("<[^>]+>", "");
	}

}

package dev.phyce.naturalspeech.configs;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import static dev.phyce.naturalspeech.configs.NaturalSpeechConfig.CONFIG_GROUP;
import dev.phyce.naturalspeech.utils.OSValidator;
import java.nio.file.Path;
import net.runelite.client.config.ConfigManager;

/**
 * Runtime Configs are serialized configurations invisible to the player but used at plugin runtime.
 */
@Singleton
public class NaturalSpeechRuntimeConfig {
	public static final String KEY_TTS_ENGINE_PATH = "ttsEngine";
	private final ConfigManager configManager;

	@Inject
	private NaturalSpeechRuntimeConfig(ConfigManager configManager) {
		this.configManager = configManager;
	}

	public Path getPiperPath() {
		String pathString = configManager.getConfiguration(CONFIG_GROUP, KEY_TTS_ENGINE_PATH);

		Path path;
		if (pathString != null) {path = Path.of(pathString);}
		else {
			if (OSValidator.IS_MAC || OSValidator.IS_UNIX) {
				path = Path.of(System.getProperty("user.home")).resolve("piper").resolve("piper");
			}
			else {path = Path.of(System.getProperty("user.home")).resolve("piper").resolve("piper.exe");}
			savePiperPath(path);
		}

		return path;
	}



	public void savePiperPath(Path path) {
		configManager.setConfiguration(CONFIG_GROUP, KEY_TTS_ENGINE_PATH, path.toString());
	}

	public void reset() {
		configManager.unsetConfiguration(CONFIG_GROUP, KEY_TTS_ENGINE_PATH);
		savePiperPath(getPiperPath());
	}


}

package dev.phyce.naturalspeech.configs;

import static dev.phyce.naturalspeech.configs.NaturalSpeechConfig.CONFIG_GROUP;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Range;

@ConfigGroup(CONFIG_GROUP)
public interface NaturalSpeechConfig extends Config {

	String CONFIG_GROUP = "NaturalSpeech";

	final class ConfigKeys {
		public static final String PERSONAL_VOICE = "personalVoice";
		public static final String GLOBAL_NPC_VOICE = "globalNpcVoice";
		public static final String SYSTEM_VOICE = "systemVoice";
		public static final String AUTO_START = "autoStart";
		public static final String DISTANCE_FADE = "distanceFade";
		public static final String MASTER_VOLUME = "masterVolume";
		public static final String SPEECH_GENERATION = "Speech generation";
		public static final String PUBLIC_CHAT = "publicChat";
		public static final String PRIVATE_CHAT = "privateChat";
		public static final String PRIVATE_OUT_CHAT = "privateOutChat";
		public static final String FRIENDS_CHAT = "friendsChat";
		public static final String CLAN_CHAT = "clanChat";
		public static final String CLAN_GUEST_CHAT = "clanGuestChat";
		public static final String EXAMINE_CHAT = "examineChat";
		public static final String NPC_OVERHEAD = "npcOverhead";
		public static final String DIALOG = "dialog";
		public static final String REQUESTS = "requests";
		public static final String SYSTEM_MESSAGES = "systemMessages";
		public static final String MUTE_GRAND_EXCHANGE = "muteGrandExchange";
		public static final String MUTE_SELF = "muteSelf";
		public static final String MUTE_OTHERS = "muteOthers";
		public static final String MUTE_LEVEL_THRESHOLD = "muteLevelThreshold";
		public static final String MUTE_CROWDS = "muteCrowds";
		public static final String SHORTENED_PHRASES = "shortenedPhrases";
		public static final String HOLD_SHIFT_RIGHT_CLICK_MENU = "holdShiftRightClickMenu";
		public static final String MUTE_GRAND_EXCHANGE_NPC_SPAM = "muteGrandExchangeNpcSpam";
	}

	//<editor-fold desc="> General Settings">
	@ConfigSection(
		name="General",
		description="General settings",
		position=0
	)
	String generalSettingsSection = "generalSettingsSection";

	@ConfigItem(
		position=1,
		keyName=ConfigKeys.PERSONAL_VOICE,
		name="Personal voice ID",
		description="Choose one of the voices for your character, example: libritts:0",
		section=generalSettingsSection

	)
	default String personalVoiceID() {
		return "";
	}

	@ConfigItem(
		position=2,
		keyName=ConfigKeys.GLOBAL_NPC_VOICE,
		name="Global default NPC voice",
		description="Choose one of the voices for all NPCs, example: libritts:0",
		section=generalSettingsSection
	)
	default String globalNpcVoice() {
		return "";
	}

	@ConfigItem(
		position=3,
		keyName=ConfigKeys.SYSTEM_VOICE,
		name="System message voice",
		description="Choose one of the voices for system messages, example: libritts:0",
		section=generalSettingsSection

	)
	default String systemVoice() {
		return "libritts:1";
	}

	@ConfigItem(
		position=4,
		keyName=ConfigKeys.AUTO_START,
		name="Autostart the TTS engine",
		description="If executable and voice models available, autostart the TTS engine when the plugin loads.",
		section=generalSettingsSection
	)
	default boolean autoStart() {return true;}

	@ConfigItem(
		position=5,
		keyName=ConfigKeys.DISTANCE_FADE,
		name="Fade distant sound",
		description="Players standing further away will sound quieter.",
		section=generalSettingsSection

	)
	default boolean distanceFadeEnabled() {
		return true;
	}

	@ConfigItem(
		position=6,
		keyName=ConfigKeys.MASTER_VOLUME,
		name="Master volume control",
		description="Volume percentage",
		section=generalSettingsSection

	)
	@Range(min=0, max=100)
	default int masterVolume() {
		return 100;
	}

	@ConfigItem(
		position=7,
		keyName=ConfigKeys.HOLD_SHIFT_RIGHT_CLICK_MENU,
		name="Hold shift for right-click menu",
		description="Only show the right-click menu when holding shift.",
		section=generalSettingsSection
	)
	default boolean holdShiftRightClickMenu() {
		return false;
	}

	//	@ConfigItem(
	//		position=5,
	//		keyName="playbackSpeed",
	//		name="Playback speed",
	//		description="The speed at which to play audio",
	//		section=generalSettingsSection
	//
	//	)
	//	@Range(min = 1, max = 500)
	//	default int playbackSpeed() {
	//		return 100;
	//	}

	//</editor-fold>

	//<editor-fold desc="> Speech Generation Settings">
	@ConfigSection(
		name=ConfigKeys.SPEECH_GENERATION,
		description="Settings to choose which messages should be played",
		position=1
	)
	String ttsOptionsSection = "ttsOptionsSection";

	@ConfigItem(
		keyName=ConfigKeys.PUBLIC_CHAT,
		name="Public messages",
		description="Enable text-to-speech to the public chat messages.",
		section=ttsOptionsSection,
		position=1
	)
	default boolean publicChatEnabled() {
		return true;
	}

	@ConfigItem(
		keyName=ConfigKeys.PRIVATE_CHAT,
		name="Private received messages",
		description="Enable text-to-speech to the received private chat messages.",
		section=ttsOptionsSection,
		position=2
	)
	default boolean privateChatEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.PRIVATE_OUT_CHAT,
		name="Private sent out messages",
		description="Enable text-to-speech to the sent out private chat messages.",
		section=ttsOptionsSection
		,
		position=3
	)
	default boolean privateOutChatEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.FRIENDS_CHAT,
		name="Friends chat",
		description="Enable text-to-speech to friends chat messages.",
		section=ttsOptionsSection,
		position=4
	)
	default boolean friendsChatEnabled() {
		return true;
	}

	@ConfigItem(
		keyName=ConfigKeys.CLAN_CHAT,
		name="Clan chat",
		description="Enable text-to-speech to the clan chat messages.",
		section=ttsOptionsSection,
		position=5
	)
	default boolean clanChatEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.CLAN_GUEST_CHAT,
		name="Guest clan chat",
		description="Enable text-to-speech to the guest clan chat messages.",
		section=ttsOptionsSection,
		position=6
	)
	default boolean clanGuestChatEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.EXAMINE_CHAT,
		name="Examine text",
		description="Enable text-to-speech to the 'Examine' messages.",
		section=ttsOptionsSection,
		position=7
	)
	default boolean examineChatEnabled() {
		return true;
	}

	//	@ConfigItem(
	//		keyName="playerOverhead",
	//		name="Player overhead dialog",
	//		description="Enable text-to-speech to overhead text that is not a message.",
	//		section=ttsOptionsSection,
	//		position=8
	//	)
	//	default boolean playerOverheadEnabled() {
	//		return true;
	//	}

	@ConfigItem(
		keyName=ConfigKeys.NPC_OVERHEAD,
		name="NPC overhead dialog",
		description="Enable text-to-speech to the overhead dialog for NPCs.",
		section=ttsOptionsSection,
		position=9
	)
	default boolean npcOverheadEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.DIALOG,
		name="Dialogs",
		description="Enable text-to-speech to dialog text.",
		section=ttsOptionsSection,
		position=10
	)
	default boolean dialogEnabled() {
		return true;
	}

	@ConfigItem(
		keyName=ConfigKeys.REQUESTS,
		name="Trade/Challenge requests",
		description="Enable text-to-speech to trade and challenge requests.",
		section=ttsOptionsSection,
		position=11
	)
	default boolean requestsEnabled() {
		return false;
	}

	@ConfigItem(
		keyName=ConfigKeys.SYSTEM_MESSAGES,
		name="System messages",
		description="Generate text-to-speech to game's messages",
		section=ttsOptionsSection,
		position=12
	)
	default boolean systemMesagesEnabled() {
		return true;
	}
	//</editor-fold>

	//<editor-fold desc="> Mute Options">
	@ConfigSection(
		name="Mute",
		description="Change mute settings here",
		position=2
	)
	String muteOptionsSection = "muteOptionsSection";

	@ConfigItem(
		position=1,
		keyName=ConfigKeys.MUTE_OTHERS,
		name="Others",
		description="Do not generate text-to-speech for messages from other players.",
		section=muteOptionsSection

	)
	default boolean muteOthers() {
		return false;
	}

	@ConfigItem(
		position=2,
		keyName=ConfigKeys.MUTE_SELF,
		name="Yourself",
		description="Do not generate text-to-speech for messages that you send.",
		section=muteOptionsSection

	)
	default boolean muteSelf() {
		return false;
	}

	@ConfigItem(
		position=3,
		keyName=ConfigKeys.MUTE_GRAND_EXCHANGE,
		name="Grand Exchange",
		description="Disable text-to-speech in the grand exchange area.",
		section=muteOptionsSection
	)
	default boolean muteGrandExchange() {
		return true;
	}



	@ConfigItem(
		position=6,
		keyName=ConfigKeys.MUTE_LEVEL_THRESHOLD,
		name="Below level",
		description="Do not generate text-to-speech for messages from players with levels lower than this value.",
		section=muteOptionsSection
	)
	@Range(min=3, max=126)
	default int muteLevelThreshold() {
		return 3;
	}

	@ConfigItem(
		position=7,
		keyName=ConfigKeys.MUTE_CROWDS,
		name="Crowds larger than",
		description="When there are more players than the specified number around you, TTS will not trigger. 0 for no limit.",
		section=muteOptionsSection
	)
	default int muteCrowds() {
		return 0;
	}

	//</editor-fold>

	//<editor-fold desc="> Other Settings">
	@ConfigSection(
		name="Other",
		description="Other settings",
		position=3
	)
	String otherOptionsSection = "otherOptionsSection";

	@ConfigItem(
		position=4,
		keyName=ConfigKeys.SHORTENED_PHRASES,
		name="Shortened phrases",
		description="Replace commonly used shortened sentences with whole words",
		section=otherOptionsSection
	)
	default String shortenedPhrases() {
		return "ags=armadyl godsword\n" +
			"ags2=ancient godsword\n" +
			"bgs=bandos godsword\n" +
			"idk=i don't know\n" +
			"imo=in my opinion\n" +
			"afaik=as far as i know\n" +
			"rly=really\n" +
			"tbow=twisted bow\n" +
			"tbows=twisted bows\n" +
			"p2p=pay to play\n" +
			"f2p=free to play\n" +
			"ty=thank you\n" +
			"tysm=thank you so much\n" +
			"tyvm=thank you very much\n" +
			"tyty=thank you thank you\n" +
			"im=i'm\n" +
			"np=no problem\n" +
			"acc=account\n" +
			"irl=in real life\n" +
			"wtf=what the fuck\n" +
			"jk=just kidding\n" +
			"gl=good luck\n" +
			"pls=please\n" +
			"plz=please\n" +
			"osrs=oldschool runescape\n" +
			"rs3=runescape 3\n" +
			"lvl=level\n" +
			"ffs=for fuck's sake\n" +
			"af=as fuck\n" +
			"smh=shake my head\n" +
			"wby=what about you\n" +
			"brb=be right back\n" +
			"ik=i know\n" +
			"<3=heart\n" +
			"fcape=fire cape\n" +
			"xp=experience\n" +
			"nty=no thank you\n" +
			"dhide=dragonhide\n" +
			"pvp=player versus player\n" +
			"wyd=what you doing\n" +
			"bc=because\n" +
			"afk=away from keyboard\n" +
			"tts=text to speech\n" +
			"ea=each\n" +
			"bbq=barbeque\n" +
			"thx=thanks\n" +
			"lmk=let me know\n" +
			"gg=good game\n" +
			"wp=well played\n" +
			"ggwp=good game well played\n" +
			"rn=right now\n" +
			"fr=for real\n" +
			"nmz=nightmare zone\n" +
			"ge=grand exchange\n" +
			"ppl=people\n" +
			"gtfo=get the fuck out\n" +
			"wb=welcome back\n" +
			"ikr=i know right\n" +
			"og=original gangster\n" +
			"cc=clan chat\n" +
			"pk=player killing\n" +
			"pker=player killer\n" +
			"pking=player killing\n" +
			"poh=player owned home\n" +
			"gz=congratulations\n" +
			"tbh=to be honest\n";
	}
	//</editor-fold>
}
package dev.phyce.naturalspeech.configs;

import dev.phyce.naturalspeech.configs.json.ttsconfigs.PiperConfigDatum;
import lombok.Getter;
import lombok.Setter;

public class PiperConfig {

	@Getter
	@Setter
	private boolean enabled;
	@Getter
	private String modelName;
	@Getter
	@Setter
	private int processCount;

	public static PiperConfig fromDatum(PiperConfigDatum datum) {
		return new PiperConfig(datum);
	}

	public PiperConfigDatum toDatum() {
		return new PiperConfigDatum(this.modelName, this.enabled, this.processCount);
	}

	private PiperConfig(PiperConfigDatum datum) {
		this.enabled = datum.isEnabled();
		this.modelName = datum.getModelName();
		this.processCount = datum.getProcessCount();
	}
}

package dev.phyce.naturalspeech.configs;

import com.google.gson.JsonSyntaxException;
import dev.phyce.naturalspeech.configs.json.ttsconfigs.ModelConfigDatum;
import dev.phyce.naturalspeech.configs.json.ttsconfigs.PiperConfigDatum;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import net.runelite.http.api.RuneLiteAPI;

@Slf4j
public class ModelConfig {

	private final List<PiperConfig> piperConfigs;

	public static ModelConfig fromDatum(ModelConfigDatum datum) {
		return new ModelConfig(datum);
	}

	public ModelConfigDatum toDatum() {
		ModelConfigDatum configDatum = new ModelConfigDatum();
		configDatum.getPiperConfigData()
			.addAll(this.piperConfigs.stream().map(PiperConfig::toDatum).collect(Collectors.toList()));
		return configDatum;
	}

	public static ModelConfig fromJson(String json) throws JsonSyntaxException {
		ModelConfigDatum datum = RuneLiteAPI.GSON.fromJson(json, ModelConfigDatum.class);
		return new ModelConfig(datum);
	}

	public String toJson() {
		return RuneLiteAPI.GSON.toJson(toDatum());
	}

	private ModelConfig(ModelConfigDatum datum) {
		piperConfigs = datum.getPiperConfigData().stream().map(PiperConfig::fromDatum).collect(Collectors.toList());
	}

	public void saveModelConfig() {

	}


	public int getModelProcessCount(String modelName) {
		return piperConfigs.stream()
			.filter(p -> p.getModelName().equals(modelName))
			.findFirst()
			.map(PiperConfig::getProcessCount)
			.orElse(1);
	}

	public void setModelProcessCount(String modelName, int processCount) {
		// look for existing config
		for (PiperConfig p : piperConfigs) {
			if (p.getModelName().equals(modelName)) {
				p.setProcessCount(processCount);
				return;
			}
		}

		initializePiperConfig(modelName);
		setModelProcessCount(modelName, processCount);
	}

	public boolean isModelEnabled(String modelName) {
		return piperConfigs.stream().anyMatch(p -> p.getModelName().equals(modelName) && p.isEnabled());
	}

	public void setModelEnabled(String modelName, boolean enabled) {
		// look for existing config
		for (PiperConfig p : piperConfigs) {
			if (p.getModelName().equals(modelName)) {
				p.setEnabled(enabled);
				return;
			}
		}

		initializePiperConfig(modelName);
		setModelEnabled(modelName, enabled);
	}

	private void initializePiperConfig(String modelName) {
		// existing config wasn't found, make new
		PiperConfigDatum piperDatum = new PiperConfigDatum(modelName, false, 1);
		piperConfigs.add(PiperConfig.fromDatum(piperDatum));
	}

	public void resetPiperConfig(String modelName) {
		// look for existing config
		Iterator<PiperConfig> iter = piperConfigs.iterator();
		while (iter.hasNext()) {
			PiperConfig piperConfig = iter.next();
			if (piperConfig.getModelName().equals(modelName)) {
				iter.remove();
				break;
			}
		}

		// existing config wasn't found, make new
		PiperConfigDatum piperDatum = new PiperConfigDatum(modelName, false, 1);
		piperConfigs.add(PiperConfig.fromDatum(piperDatum));
	}

}

package dev.phyce.naturalspeech.configs;

import com.google.gson.JsonSyntaxException;
import dev.phyce.naturalspeech.configs.json.uservoiceconfigs.NPCIDVoiceConfigDatum;
import dev.phyce.naturalspeech.configs.json.uservoiceconfigs.NPCNameVoiceConfigDatum;
import dev.phyce.naturalspeech.configs.json.uservoiceconfigs.PlayerNameVoiceConfigDatum;
import dev.phyce.naturalspeech.configs.json.uservoiceconfigs.VoiceConfigDatum;
import dev.phyce.naturalspeech.tts.VoiceID;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.annotation.CheckForNull;
import lombok.NonNull;
import net.runelite.http.api.RuneLiteAPI;

public class VoiceConfig {
	private final Map<String, PlayerNameVoiceConfigDatum> playerVoices;
	private final Map<Integer, NPCIDVoiceConfigDatum> npcIDVoices;
	private final Map<String, NPCNameVoiceConfigDatum> npcNameVoices;

	public VoiceConfig() {
		playerVoices = new HashMap<>();
		npcIDVoices = new HashMap<>();
		npcNameVoices = new HashMap<>();
	}

	public void setDefaultPlayerVoice(@NonNull String standardized_username, VoiceID voiceID) {
		playerVoices.putIfAbsent(standardized_username, new PlayerNameVoiceConfigDatum(standardized_username));
		PlayerNameVoiceConfigDatum datum = playerVoices.get(standardized_username);
		if (datum.getVoiceIDs().isEmpty()) {
			datum.getVoiceIDs().add(voiceID);
		}
		else {
			// remove duplicates
			datum.getVoiceIDs().remove(0);
			// prepend
			datum.getVoiceIDs().add(0, voiceID);
		}
	}

	public void setDefaultNpcIdVoice(int npcID, VoiceID voiceID) {
		npcIDVoices.putIfAbsent(npcID, new NPCIDVoiceConfigDatum(npcID));
		NPCIDVoiceConfigDatum datum = npcIDVoices.get(npcID);
		if (datum.getVoiceIDs().isEmpty()) {
			datum.getVoiceIDs().add(voiceID);
		}
		else {
			// remove duplicates
			datum.getVoiceIDs().remove(voiceID);
			// prepend
			datum.getVoiceIDs().add(0, voiceID);
		}
	}

	public void setDefaultNpcNameVoice(@NonNull String npcName, VoiceID voiceID) {
		npcNameVoices.putIfAbsent(npcName, new NPCNameVoiceConfigDatum(npcName));
		NPCNameVoiceConfigDatum datum = npcNameVoices.get(npcName);
		if (datum.getVoiceIDs().isEmpty()) {
			datum.getVoiceIDs().add(voiceID);
		}
		else {
			// remove duplicates
			datum.getVoiceIDs().remove(voiceID);
			// prepend
			datum.getVoiceIDs().add(0, voiceID);
		}
	}

	public void unsetPlayerVoice(@NonNull String standardized_username, VoiceID voiceID) {
		PlayerNameVoiceConfigDatum datum = playerVoices.get(standardized_username);
		if (datum == null) return;
		datum.getVoiceIDs().remove(voiceID);
		if (datum.getVoiceIDs().isEmpty()) playerVoices.remove(standardized_username);
	}



	public void removeNpcIdVoice(int npcID, VoiceID voiceID) {
		NPCIDVoiceConfigDatum datum = npcIDVoices.get(npcID);
		if (datum == null) return;
		datum.getVoiceIDs().remove(voiceID);
		if (datum.getVoiceIDs().isEmpty()) npcIDVoices.remove(npcID);
	}


	public void removeNpcNameVoice(@NonNull String npcName, VoiceID voiceID) {
		NPCNameVoiceConfigDatum datum = npcNameVoices.get(npcName);
		if (datum == null) return;
		datum.getVoiceIDs().remove(voiceID);
		if (datum.getVoiceIDs().isEmpty()) npcNameVoices.remove(npcName);
	}

	public void clearPlayerVoices(@NonNull String standardized_username) {
		playerVoices.remove(standardized_username);
	}

	public static VoiceConfig fromDatum(@NonNull VoiceConfigDatum data) {
		VoiceConfig voiceConfig = new VoiceConfig();
		voiceConfig.loadDatum(data);
		return voiceConfig;
	}

	public static VoiceConfig fromJson(@NonNull String json) throws JsonSyntaxException {
		VoiceConfigDatum datum = RuneLiteAPI.GSON.fromJson(json, VoiceConfigDatum.class);
		return fromDatum(datum);
	}

	public int countAll() {
		return playerVoices.size() + npcIDVoices.size() + npcNameVoices.size();
	}

	public void clear() {
		playerVoices.clear();
		npcIDVoices.clear();
		npcNameVoices.clear();
	}

	public void loadJSON(String jsonString) throws JsonSyntaxException {
		clear();

		VoiceConfigDatum data = RuneLiteAPI.GSON.fromJson(jsonString, VoiceConfigDatum.class);
		loadDatum(data);
	}

	public String toJson() {
		return RuneLiteAPI.GSON.toJson(toDatum());
	}

	public void loadDatum(VoiceConfigDatum data) {
		clear();

		for (PlayerNameVoiceConfigDatum datum : data.getPlayerNameVoiceConfigData()) {
			playerVoices.put(datum.getPlayerName(), datum);
		}

		for (NPCIDVoiceConfigDatum datum : data.getNpcIDVoiceConfigData()) {
			npcIDVoices.put(datum.getNpcId(), datum);
		}

		for (NPCNameVoiceConfigDatum datum : data.getNpcNameVoiceConfigData()) {
			npcNameVoices.put(datum.getNpcName(), datum);
		}
	}

	public VoiceConfigDatum toDatum() {
		VoiceConfigDatum voiceConfigDatum = new VoiceConfigDatum();
		voiceConfigDatum.getPlayerNameVoiceConfigData().addAll(playerVoices.values());
		voiceConfigDatum.getNpcIDVoiceConfigData().addAll(npcIDVoices.values());
		voiceConfigDatum.getNpcNameVoiceConfigData().addAll(npcNameVoices.values());
		return voiceConfigDatum;
	}

	@CheckForNull
	public List<VoiceID> findUsername(@NonNull String standardized_username) {
		PlayerNameVoiceConfigDatum playerNameVoiceConfigDatum = this.playerVoices.get(standardized_username);

		if (playerNameVoiceConfigDatum == null) return null;
		if (playerNameVoiceConfigDatum.getVoiceIDs().isEmpty()) return null;

		return playerNameVoiceConfigDatum.getVoiceIDs();
	}

	@CheckForNull
	public List<VoiceID> findNpcId(int npcID) {
		NPCIDVoiceConfigDatum npcIDVoiceConfigDatum = this.npcIDVoices.get(npcID);

		if (npcIDVoiceConfigDatum == null) return null;
		if (npcIDVoiceConfigDatum.getVoiceIDs().isEmpty()) return null;

		return npcIDVoiceConfigDatum.getVoiceIDs();
	}

	@CheckForNull
	public List<VoiceID> findNpcName(@NonNull String npcName) {
		NPCNameVoiceConfigDatum npcNameVoiceConfigDatum = this.npcNameVoices.get(npcName.toLowerCase());

		if (npcNameVoiceConfigDatum == null) return null;
		if (npcNameVoiceConfigDatum.getVoiceIDs().isEmpty()) return null;

		return npcNameVoiceConfigDatum.getVoiceIDs();
	}


	//<editor-fold desc="> Reset">
	public void resetNpcIdVoices(int npcID) {
		npcIDVoices.remove(npcID);
	}
	public void resetNpcNameVoices(@NonNull String npcName) {
		npcNameVoices.remove(npcName);
	}
	public void resetPlayerVoice(@NonNull String username) {
		playerVoices.remove(username);
	}
	//</editor-fold>
}

package dev.phyce.naturalspeech.configs.json.ttsconfigs;

import java.util.ArrayList;
import java.util.List;
import lombok.Value;

@Value
public class ModelConfigDatum {
	List<PiperConfigDatum> piperConfigData = new ArrayList<>();
}

package dev.phyce.naturalspeech.configs.json.ttsconfigs;

import lombok.Value;

@Value
public class PiperConfigDatum {
	String modelName;
	boolean enabled;
	int processCount;
}

package dev.phyce.naturalspeech.configs.json.uservoiceconfigs;

import dev.phyce.naturalspeech.tts.VoiceID;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.Value;

// Used for JSON Serialization
@Data
public class NPCNameVoiceConfigDatum {

	List<VoiceID> voiceIDs = new ArrayList<>();

	/**
	 * Can be wildcard, ex *Bat matches Giant Bat, Little Bat, etc.
	 */
	String npcName;

	public NPCNameVoiceConfigDatum(String npcName) {
		this.npcName = npcName;
	}

}

package dev.phyce.naturalspeech.configs.json.uservoiceconfigs;


import java.util.ArrayList;
import java.util.List;
import lombok.Value;

// Used for JSON Serialization
@Value
public class VoiceConfigDatum {

	public List<PlayerNameVoiceConfigDatum> playerNameVoiceConfigData = new ArrayList<>();
	public List<NPCIDVoiceConfigDatum> npcIDVoiceConfigData = new ArrayList<>();
	public List<NPCNameVoiceConfigDatum> npcNameVoiceConfigData = new ArrayList<>();

}

package dev.phyce.naturalspeech.configs.json.uservoiceconfigs;

import dev.phyce.naturalspeech.tts.VoiceID;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.Value;

// Used for JSON Serialization
@Data
public class PlayerNameVoiceConfigDatum {

	List<VoiceID> voiceIDs = new ArrayList<>();

	String playerName;

	public PlayerNameVoiceConfigDatum(String playerName) {
		this.playerName = playerName;
	}

}

package dev.phyce.naturalspeech.configs.json.uservoiceconfigs;

import dev.phyce.naturalspeech.tts.VoiceID;
import java.util.ArrayList;
import java.util.List;
import lombok.Data;
import lombok.Value;

// Used for JSON Serialization
@Data
public class NPCIDVoiceConfigDatum {

	// implicitly implements ModelAndVoiceConfig::getModelAndVoice through lombok@Data
	List<VoiceID> voiceIDs = new ArrayList<>();

	int npcId;

	public NPCIDVoiceConfigDatum(int npcId) {
		this.npcId = npcId;
	}
}

package dev.phyce.naturalspeech.enums;

import dev.phyce.naturalspeech.tts.ModelRepository;

public enum Gender {
	OTHER,
	MALE,
	FEMALE;

	public static Gender parseInt(int id) {
		if (id == 0) {
			return MALE;
		}
		else if (id == 1) {
			return FEMALE;
		}
		else {
			return OTHER;
		}
	}

}

package dev.phyce.naturalspeech.enums;

import lombok.Getter;
import net.runelite.api.coords.WorldPoint;

@Getter
public enum Locations {
	GRAND_EXCHANGE(new WorldPoint(3148, 3506, 0), new WorldPoint(3181, 3473, 0)),
	// You can add more locations here in a similar manner

	; // Don't forget this semicolon if you're adding more entries

	private final WorldPoint start;
	private final WorldPoint end;

	Locations(WorldPoint start, WorldPoint end) {
		this.start = start;
		this.end = end;
	}

	public boolean isWorldPointInside2D(WorldPoint worldPoint) {
		return isWorldPointInside2D(worldPoint, start, end);
	}

	public static boolean isWorldPointInside2D(WorldPoint position, WorldPoint start, WorldPoint end) {
		int minX = Math.min(start.getX(), end.getX());
		int maxX = Math.max(start.getX(), end.getX());
		int minY = Math.min(start.getY(), end.getY());
		int maxY = Math.max(start.getY(), end.getY());

		return position.getX() >= minX && position.getX() <= maxX
			&& position.getY() >= minY && position.getY() <= maxY;
	}

	public static boolean inGrandExchange(WorldPoint position) {
		return Locations.GRAND_EXCHANGE.isWorldPointInside2D(position);
	}
}
package dev.phyce.naturalspeech.ui.game;

import com.google.gson.Gson;
import com.google.inject.Inject;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.tts.VoiceID;
import dev.phyce.naturalspeech.tts.VoiceManager;
import java.util.concurrent.ScheduledExecutorService;
import javax.annotation.Nullable;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.api.NPC;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetPositionMode;
import net.runelite.api.widgets.WidgetSizeMode;
import net.runelite.api.widgets.WidgetTextAlignment;
import net.runelite.api.widgets.WidgetType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.game.chatbox.ChatboxPanelManager;
import net.runelite.client.game.chatbox.ChatboxTextInput;
import okhttp3.OkHttpClient;

@Slf4j
public class VoiceConfigChatboxTextInput extends ChatboxTextInput {
	private static final int LINE_HEIGHT = 20;
	private static final int CHATBOX_HEIGHT = 120;
	private final ChatboxPanelManager chatboxPanelManager;
	private NPC npc;
	@SuppressWarnings("FieldCanBeLocal")
	private final VoiceManager voiceManager;
	private String standardActorName;

	@Inject
	public VoiceConfigChatboxTextInput(
		ChatboxPanelManager chatboxPanelManager,
		ClientThread clientThread,
		ScheduledExecutorService scheduledExecutorService,
		OkHttpClient okHttpClient, Gson gson, TextToSpeech textToSpeech, VoiceManager voiceManager) {
		super(chatboxPanelManager, clientThread);
		this.chatboxPanelManager = chatboxPanelManager;
		this.voiceManager = voiceManager;
		lines(1);
		prompt("Enter voice in voice:id format. Example: libritts:120");

		onDone(string ->
		{
			if (string == null) return;
			if (!string.isEmpty()) {
				VoiceID voiceId = VoiceID.fromIDString(string);
				if (voiceId != null) {
					if (npc != null) {
						log.info("NPC Name:{} NPC ID:{} set to {}", standardActorName, npc.getId(), voiceId);
						voiceManager.setActorVoiceID(npc, voiceId);
					} else {
						log.info("Username:{} set to {}", standardActorName, voiceId);
						voiceManager.setDefaultVoiceIDForUsername(standardActorName, voiceId);
					}
					voiceManager.saveVoiceConfig();
				} else {
					log.info("Attempting to set invalid voiceID with {}", string);
				}
			} else {
				if (npc != null) {
					voiceManager.resetVoiceIDForNPC(npc);
				} else {
					voiceManager.resetForUsername(standardActorName);
				}
			}
		});
	}

	public VoiceConfigChatboxTextInput configNPC(@Nullable NPC actor) {
		this.npc = actor;
		return this;
	}

	public VoiceConfigChatboxTextInput configUsername(@NonNull String standardActorName) {
		this.standardActorName = standardActorName;
		return this;
	}

	@Override
	protected void update() {
		Widget container = chatboxPanelManager.getContainerWidget();
		container.deleteAllChildren();

		Widget promptWidget = container.createChild(-1, WidgetType.TEXT);
		promptWidget.setText(getPrompt());
		promptWidget.setTextColor(0x800000);
		promptWidget.setFontId(getFontID());
		promptWidget.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		promptWidget.setOriginalX(0);
		promptWidget.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		promptWidget.setOriginalY(5);
		promptWidget.setOriginalHeight(LINE_HEIGHT);
		promptWidget.setXTextAlignment(WidgetTextAlignment.CENTER);
		promptWidget.setYTextAlignment(WidgetTextAlignment.CENTER);
		promptWidget.setWidthMode(WidgetSizeMode.MINUS);
		promptWidget.revalidate();

		buildEdit(0, 5 + LINE_HEIGHT, container.getWidth(), LINE_HEIGHT);

		Widget separator = container.createChild(-1, WidgetType.LINE);
		separator.setXPositionMode(WidgetPositionMode.ABSOLUTE_CENTER);
		separator.setOriginalX(0);
		separator.setYPositionMode(WidgetPositionMode.ABSOLUTE_TOP);
		separator.setOriginalY(4 + (LINE_HEIGHT * 2));
		separator.setOriginalHeight(0);
		separator.setOriginalWidth(16);
		separator.setWidthMode(WidgetSizeMode.MINUS);
		separator.revalidate();
	}
}

package dev.phyce.naturalspeech.ui.panels;

import com.google.common.collect.ImmutableList;
import com.google.inject.Inject;
import dev.phyce.naturalspeech.enums.Gender;
import dev.phyce.naturalspeech.tts.ModelRepository;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.ui.components.IconTextField;
import dev.phyce.naturalspeech.ui.layouts.OnlyVisibleGridLayout;
import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;
import org.apache.commons.lang3.StringUtils;

public class VoiceExplorerPanel extends EditorPanel {

	public static final ImageIcon SECTION_EXPAND_ICON;
	private static final ImageIcon SECTION_RETRACT_ICON;
	private static final ImmutableList<String> SEARCH_HINTS = ImmutableList.of("Male", "Female");

	static {
		BufferedImage sectionRetractIcon =
			ImageUtil.loadImageResource(MainSettingsPanel.class, "section_icons/arrow_right.png");
		sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
		SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
		final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
		SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
	}

	final ImageIcon speechTextIcon = new ImageIcon(ImageUtil.loadImageResource(getClass(), "speechText.png"));
	private final ModelRepository modelRepository;
	private final TextToSpeech textToSpeech;
	@Getter
	private final IconTextField speechText;
	@Getter
	private final IconTextField searchBar;
	@Getter
	private final FixedWidthPanel sectionListPanel;
	@Getter
	private final JScrollPane speakerScrollPane;
	private final List<VoiceListItem> voiceListItems = new ArrayList<>();
	private final ModelRepository.ModelRepositoryListener modelRepositoryListener;

	@Inject
	public VoiceExplorerPanel(ModelRepository modelRepository, TextToSpeech textToSpeech) {
		this.modelRepository = modelRepository;
		this.textToSpeech = textToSpeech;

		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// Search Bar
		searchBar = new IconTextField();
		searchBar.setPlaceholderText("Enter name or gender");
		searchBar.setIcon(IconTextField.Icon.SEARCH);
		searchBar.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		searchBar.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		searchBar.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		SEARCH_HINTS.forEach(searchBar.getSuggestionListModel()::addElement);
		searchBar.getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				searchFilter(searchBar.getText());
			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				searchFilter(searchBar.getText());
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				searchFilter(searchBar.getText());
			}
		});

		// Speech Text Bar
		speechText = new IconTextField();
		speechText.setIcon(speechTextIcon);
		speechText.setPreferredSize(new Dimension(PluginPanel.PANEL_WIDTH - 20, 30));
		speechText.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		speechText.setHoverBackgroundColor(ColorScheme.DARK_GRAY_HOVER_COLOR);
		speechText.setText("Hello, Natural Speech");
		speechText.setToolTipText("Sentence to be spoken.");
		speechText.setPlaceholderText("Enter a sentence");

		// Float Top/North Wrapper Panel, for search and speech text bar.
		JPanel topPanel = new JPanel();
		topPanel.setBorder(new EmptyBorder(10, 10, 10, 10));
		topPanel.setLayout(new GridLayout(0, 1, 0, PluginPanel.BORDER_OFFSET));
		topPanel.add(searchBar);
		topPanel.add(speechText);
		this.add(topPanel, BorderLayout.NORTH);

		// Speakers panel containing individual speaker item panels
		sectionListPanel = new FixedWidthPanel();
		sectionListPanel.setBorder(new EmptyBorder(8, 10, 10, 10));
		sectionListPanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionListPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

		// North panel wraps and fixes the speakerList north
		JPanel speakerListNorthWrapper = new FixedWidthPanel();
		speakerListNorthWrapper.setLayout(new BorderLayout());
		speakerListNorthWrapper.add(sectionListPanel, BorderLayout.NORTH);

		// A parent scroll view pane for speakerListPanel
		speakerScrollPane = new JScrollPane(speakerListNorthWrapper);
		speakerScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);

		this.add(speakerScrollPane);

		modelRepositoryListener = new ModelRepository.ModelRepositoryListener() {
			@Override
			public void onRepositoryChanged(String modelName) {
				SwingUtilities.invokeLater(() -> buildSpeakerList());
			}

			@Override
			public void onRefresh() {
				SwingUtilities.invokeLater(() -> buildSpeakerList());
			}
		};
		this.modelRepository.addRepositoryChangedListener(modelRepositoryListener);

		buildSpeakerList();
	}

	void buildSpeakerList() {
		sectionListPanel.removeAll();
		for (ModelRepository.ModelURL modelURL : modelRepository.getModelURLS()) {
			try {
				if (modelRepository.hasModelLocal(modelURL.getModelName())) {
					buildSpeakerSegmentForVoice(modelURL.getModelName());
				}
			} catch (IOException ignore) {
			}
		}
	}

	private void toggleSpeakerSection(JButton toggleButton, JPanel sectionContent) {
		boolean newState = !sectionContent.isVisible();
		sectionContent.setVisible(newState);
		toggleButton.setIcon(newState? SECTION_RETRACT_ICON: SECTION_EXPAND_ICON);
		toggleButton.setToolTipText(newState? "Retract": "Expand");
		SwingUtilities.invokeLater(sectionContent::revalidate);
	}

	private void buildSpeakerSegmentForVoice(String voice_name) {

		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setLayout(new BorderLayout());
		sectionHeader.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		// For whatever reason, the header extends out by a single pixel when closed. Adding a single pixel of
		// border on the right only affects the width when closed, fixing the issue.
		sectionHeader.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader);

		final JButton sectionToggle = new JButton(SECTION_RETRACT_ICON);
		sectionToggle.setPreferredSize(new Dimension(18, 0));
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Retract");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final String name = voice_name;
		final String description = voice_name;
		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setToolTipText("<html>" + name + ":<br>" + description + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContent = new JPanel();
		sectionContent.setLayout(new OnlyVisibleGridLayout(0, 1, 0, 5));
		sectionContent.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		section.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(BORDER_OFFSET, 0, BORDER_OFFSET, 0)
		));
		section.add(sectionContent, BorderLayout.SOUTH);

		// Add listeners to each part of the header so that it's easier to toggle them
		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSpeakerSection(sectionToggle, sectionContent);
			}
		};
		sectionToggle.addActionListener(actionEvent -> toggleSpeakerSection(sectionToggle, sectionContent));
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);

		try {
			ModelRepository.ModelLocal modelLocal = modelRepository.loadModelLocal(voice_name);

			Arrays.stream(modelLocal.getVoiceMetadata())
				.sorted(Comparator.comparing(a -> a.getName().toLowerCase()))
				.forEach((voiceMetadata) -> {
					VoiceListItem speakerItem = new VoiceListItem(this, textToSpeech, voiceMetadata, modelLocal);
					voiceListItems.add(speakerItem);
					sectionContent.add(speakerItem);
				});

		} catch (IOException e) {throw new RuntimeException(e);}

		sectionListPanel.add(section);
	}

	void searchFilter(String searchInput) {
		if (searchInput.isEmpty()) {
			for (VoiceListItem speakerItems : voiceListItems) {speakerItems.setVisible(true);}
			return;
		}

		// split search by space and comma
		Set<String> searchTerms = Arrays.stream(searchInput.toLowerCase().split("[,\\s]+"))
			.filter(s -> !s.isEmpty())
			.map(String::trim)
			.map(String::toLowerCase).collect(Collectors.toSet());

		Gender genderSearch = null;
		Iterator<String> iterator = searchTerms.iterator();
		while (iterator.hasNext()) {
			String searchTerm = iterator.next();

			if (List.of("m", "male", "guy").contains(searchTerm)) {
				genderSearch = Gender.MALE;
				iterator.remove();
			}
			else if (List.of("f", "female", "girl").contains(searchTerm)) {
				genderSearch = Gender.FEMALE;
				iterator.remove();
			}
		}

		searchInput = StringUtils.join(searchTerms, " ");

		for (VoiceListItem speakerItem : voiceListItems) {
			ModelRepository.VoiceMetadata voiceMetadata = speakerItem.getVoiceMetadata();

			boolean visible = genderSearch == null || genderSearch.equals(voiceMetadata.getGender());

			// name search
			if (!searchInput.isEmpty()) {
				boolean term_matched = false;
				if (!searchTerms.isEmpty() && voiceMetadata.getName().toLowerCase().contains(searchInput)) {
					term_matched = true;
				}

				if (!term_matched) visible = false;
			}
			speakerItem.setVisible(visible);
		}

		sectionListPanel.revalidate();
	}

	public void shutdown() {
		modelRepository.removeRepositoryChangedListener(modelRepositoryListener);
		this.removeAll();
	}

	@Override
	public void onActivate() {
		super.onActivate();

		SwingUtilities.invokeLater(() -> setVisible(true));
	}

	@Override
	public void onDeactivate() {
		super.onDeactivate();

		SwingUtilities.invokeLater(() -> setVisible(false));
	}
}

package dev.phyce.naturalspeech.ui.panels;

import com.google.inject.Inject;
import com.google.inject.Provider;
import java.awt.BorderLayout;
import java.awt.CardLayout;
import java.awt.GridLayout;
import javax.swing.ImageIcon;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.ui.components.materialtabs.MaterialTab;
import net.runelite.client.ui.components.materialtabs.MaterialTabGroup;
import net.runelite.client.util.ImageUtil;

public class TopLevelPanel extends PluginPanel {
	private final MaterialTabGroup tabGroup;
	private final CardLayout layout;
	private final JPanel content;

	@Getter
	private final MainSettingsPanel mainSettingsPanel;
	@Getter
	private final VoiceExplorerPanel voiceExplorerPanel;
	private final MaterialTab mainSettingsTab;
	//	@Getter
	//	private final EditorPanel editorPanel;

	private boolean active = false;
	private PluginPanel current;
	private boolean removeOnTabChange;

	@Inject
	TopLevelPanel(
		MainSettingsPanel mainSettingsPanel,
		VoiceExplorerPanel voiceExplorerPanel
		//			EditorPanel editorPanel
	) {
		super(false);

		this.mainSettingsPanel = mainSettingsPanel;
		this.voiceExplorerPanel = voiceExplorerPanel;
		//		this.editorPanel = editorPanel;

		tabGroup = new MaterialTabGroup();
		tabGroup.setLayout(new GridLayout(1, 0, 7, 7));
		tabGroup.setBorder(new EmptyBorder(10, 10, 0, 10));

		content = new JPanel();
		layout = new CardLayout();
		content.setLayout(layout);

		setLayout(new BorderLayout());
		add(tabGroup, BorderLayout.NORTH);
		add(content, BorderLayout.CENTER);

		// Main Settings Panel Tab
		//		MaterialTab mainSettingsTab = addTab(this.mainSettingsPanel, "config_icon.png", "Natural Speech");
		mainSettingsTab = addTab(this.mainSettingsPanel, "config_icon.png", "Natural Speech Settings");
		tabGroup.select(mainSettingsTab);

		// Speaker Explorer Panel Tab
		addTab(voiceExplorerPanel, "profile_icon.png", "Voice Explorer");

		// Editor Panel Tab
		//		addTab(editorPanel, "plugin_hub_icon.png", "Editor");

	}

	private MaterialTab addTab(PluginPanel panel, String image, String tooltip) {
		MaterialTab materialTab = new MaterialTab(
			new ImageIcon(ImageUtil.loadImageResource(TopLevelPanel.class, image)),
			tabGroup, null);
		materialTab.setToolTipText(tooltip);
		tabGroup.addTab(materialTab);

		content.add(image, panel.getWrappedPanel());

		materialTab.setOnSelectEvent(() -> {
			switchTo(image, panel, false);
			return true;
		});
		return materialTab;
	}

	private MaterialTab addTab(Provider<? extends PluginPanel> panelProvider, String image, String tooltip) {
		MaterialTab materialTab = new MaterialTab(
			new ImageIcon(ImageUtil.loadImageResource(TopLevelPanel.class, image)),
			tabGroup, null);
		materialTab.setToolTipText(tooltip);
		tabGroup.addTab(materialTab);

		materialTab.setOnSelectEvent(() ->
		{
			PluginPanel panel = panelProvider.get();
			content.add(image, panel.getWrappedPanel());
			switchTo(image, panel, true);
			return true;
		});
		return materialTab;
	}

	private void switchTo(String cardName, PluginPanel panel, boolean removeOnTabChange) {
		boolean doRemove = this.removeOnTabChange;
		PluginPanel prevPanel = current;
		if (active) {
			prevPanel.onDeactivate();
			panel.onActivate();
		}

		current = panel;
		this.removeOnTabChange = removeOnTabChange;

		layout.show(content, cardName);

		if (doRemove) {
			content.remove(prevPanel.getWrappedPanel());
		}

		content.revalidate();
	}

	public void shutdown() {
		this.mainSettingsPanel.shutdown();
		this.voiceExplorerPanel.shutdown();
	}

	@Override
	public void onActivate() {
		// FIXME(Louis) First tab always defaults to being visible after deactivate then reactivate
		// Despite the code running water tight, strange behavior.
		// Possible that super onActivate sets visibility
		active = true;
		current.onDeactivate();
		// FIXME(Louis): Temporary workaround the issue where the main tab rendering on top after toggling panel
		// Might as well just select it automatically so intended "correct" behavior for now.
		tabGroup.select(mainSettingsTab);
	}

	@Override
	public void onDeactivate() {
		active = false;
		current.onDeactivate();
	}
}

package dev.phyce.naturalspeech.ui.panels;

import dev.phyce.naturalspeech.enums.Gender;
import dev.phyce.naturalspeech.tts.ModelRepository;
import dev.phyce.naturalspeech.exceptions.ModelLocalUnavailableException;
import dev.phyce.naturalspeech.tts.piper.Piper;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.image.BufferedImage;
import javax.swing.GroupLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
public class VoiceListItem extends JPanel {

	private final VoiceExplorerPanel voiceExplorerPanel;
	private final TextToSpeech textToSpeech;
	@Getter
	private final ModelRepository.VoiceMetadata voiceMetadata;
	private final ModelRepository.ModelLocal modelLocal;

	private static final ImageIcon PLAY_BUTTON;
	private static final ImageIcon PLAY_BUTTON_DISABLED;

	static {
		BufferedImage image = ImageUtil.loadImageResource(VoiceListItem.class, "start.png");
		PLAY_BUTTON = new ImageIcon(image.getScaledInstance(25, 25, Image.SCALE_SMOOTH));
		PLAY_BUTTON_DISABLED = new ImageIcon(
			ImageUtil.luminanceScale(ImageUtil.grayscaleImage(image), 0.61f)
				.getScaledInstance(25, 25, Image.SCALE_SMOOTH));

	}


	public VoiceListItem(
		VoiceExplorerPanel voiceExplorerPanel,
		TextToSpeech textToSpeech,
		ModelRepository.VoiceMetadata voiceMetadata,
		ModelRepository.ModelLocal modelLocal) {
		this.voiceExplorerPanel = voiceExplorerPanel;
		this.textToSpeech = textToSpeech;
		this.voiceMetadata = voiceMetadata;
		this.modelLocal = modelLocal;

		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		this.setOpaque(true);
		this.setToolTipText(String.format("%s %s (%s)", voiceMetadata.getPiperVoiceID(), voiceMetadata.getName(),
			voiceMetadata.getGender()));

		JPanel speakerPanel = new JPanel();
		speakerPanel.setOpaque(false);

		GroupLayout speakerLayout = new GroupLayout(speakerPanel);
		speakerPanel.setLayout(speakerLayout);


		JLabel nameLabel = new JLabel(voiceMetadata.getName());
		nameLabel.setForeground(Color.white);

		String genderString;
		if (voiceMetadata.getGender() == Gender.MALE) {
			genderString = "(M)";
		}
		else if (voiceMetadata.getGender() == Gender.FEMALE) {
			genderString = "(F)";
		}
		else {
			genderString = "(?)";
		}

		JLabel genderLabel = new JLabel(genderString);
		genderLabel.setForeground(Color.white);

		JLabel piperIdLabel = new JLabel(String.format("ID%d", voiceMetadata.getPiperVoiceID()));

		speakerLayout.setHorizontalGroup(speakerLayout
			.createSequentialGroup()
			.addGap(5)
			.addComponent(piperIdLabel, 35, GroupLayout.PREFERRED_SIZE, GroupLayout.PREFERRED_SIZE)
			.addGap(5)
			.addComponent(nameLabel)
			.addGap(5).addComponent(genderLabel));

		int lineHeight = (int) (nameLabel.getFontMetrics(nameLabel.getFont()).getHeight() * 1.5);

		speakerLayout.setVerticalGroup(speakerLayout.createParallelGroup()
			.addGap(5)
			.addComponent(piperIdLabel, lineHeight, GroupLayout.PREFERRED_SIZE, lineHeight)
			.addComponent(nameLabel, lineHeight, GroupLayout.PREFERRED_SIZE, lineHeight)
			.addComponent(genderLabel, lineHeight, GroupLayout.PREFERRED_SIZE, lineHeight)
			.addGap(5));


		JButton playButton = new JButton(PLAY_BUTTON_DISABLED);
		SwingUtil.removeButtonDecorations(playButton);
		playButton.setPreferredSize(
			new Dimension(PLAY_BUTTON_DISABLED.getIconWidth(), PLAY_BUTTON_DISABLED.getIconHeight()));
		playButton.addActionListener(

			event -> {
				if (textToSpeech != null && textToSpeech.activePiperProcessCount() > 0) {
					try {
						if (textToSpeech.isModelActive(modelLocal)) {
							textToSpeech.speak(
								voiceMetadata.toVoiceID(),
								textToSpeech.expandShortenedPhrases(voiceExplorerPanel.getSpeechText().getText()),
								0,
								"&VoiceExplorer");
						}
						else {
							log.info("Model {} is currently not running.", modelLocal.getModelName());
						}
					} catch (ModelLocalUnavailableException e) {
						throw new RuntimeException(e);
					}
				}
			});

		playButton.setEnabled(false);

		BorderLayout rootLayout = new BorderLayout();
		this.setLayout(rootLayout);
		this.add(speakerPanel, BorderLayout.CENTER);
		this.add(playButton, BorderLayout.EAST);

		revalidate();

		textToSpeech.addTextToSpeechListener(
			new TextToSpeech.TextToSpeechListener() {
				@Override
				public void onPiperStart(Piper piper) {
					if (piper.getModelLocal().getModelName().equals(modelLocal.getModelName())) {
						playButton.setIcon(PLAY_BUTTON);
						playButton.setEnabled(true);
					}
				}

				@Override
				public void onPiperExit(Piper piper) {
					if (piper.getModelLocal().getModelName().equals(modelLocal.getModelName())) {
						playButton.setIcon(PLAY_BUTTON_DISABLED);
						playButton.setEnabled(false);
					}
				}
			}
		);
	}
}

package dev.phyce.naturalspeech.ui.panels;

import com.google.inject.Inject;
import dev.phyce.naturalspeech.tts.ModelRepository;
import dev.phyce.naturalspeech.configs.NaturalSpeechConfig;
import dev.phyce.naturalspeech.configs.NaturalSpeechRuntimeConfig;
import dev.phyce.naturalspeech.downloader.Downloader;
import dev.phyce.naturalspeech.tts.piper.Piper;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import dev.phyce.naturalspeech.utils.OSValidator;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Cursor;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.net.URI;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import javax.swing.border.MatteBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
public class MainSettingsPanel extends PluginPanel {

	static {
		BufferedImage sectionRetractIcon =
			ImageUtil.loadImageResource(MainSettingsPanel.class, "section_icons/arrow_right.png");
		sectionRetractIcon = ImageUtil.luminanceOffset(sectionRetractIcon, -121);
		SECTION_EXPAND_ICON = new ImageIcon(sectionRetractIcon);
		final BufferedImage sectionExpandIcon = ImageUtil.rotateImage(sectionRetractIcon, Math.PI / 2);
		SECTION_RETRACT_ICON = new ImageIcon(sectionExpandIcon);
	}

	public static final ImageIcon SECTION_EXPAND_ICON;
	private static final EmptyBorder BORDER_PADDING = new EmptyBorder(6, 6, 6, 6);
	private static final ImageIcon SECTION_RETRACT_ICON;
//	private static final Dimension OUTER_PREFERRED_SIZE = new Dimension(242, 0);


	private final ClientThread clientThread;
	private final FixedWidthPanel mainContentPanel;
	private final ModelRepository modelRepository;
	private final TextToSpeech textToSpeech;
	private final NaturalSpeechRuntimeConfig runtimeConfig;
	private final List<ModelRepository.ModelRepositoryListener> modelRepositoryListeners;

	@Inject
	public MainSettingsPanel(
		NaturalSpeechConfig config,
		ModelRepository modelRepository,
		ConfigManager configManager,
		Downloader downloader, ClientThread clientThread,
		TextToSpeech textToSpeech,
		NaturalSpeechRuntimeConfig runtimeConfig
	) {
		super(false);
		this.textToSpeech = textToSpeech;
		this.modelRepository = modelRepository;
		this.clientThread = clientThread;
		this.runtimeConfig = runtimeConfig;
		this.modelRepositoryListeners = new ArrayList<>();

		this.setLayout(new BorderLayout());
		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		// This panel is where the actual content lives.
		mainContentPanel = new FixedWidthPanel();
		mainContentPanel.setBorder(BORDER_PADDING);
		mainContentPanel.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		mainContentPanel.setAlignmentX(Component.LEFT_ALIGNMENT);

		// wrap for scrolling, fixed to NORTH in-order to grow southward
		JPanel mainContentNorthWrapper = new FixedWidthPanel();
		mainContentNorthWrapper.setLayout(new BorderLayout());
		mainContentNorthWrapper.add(mainContentPanel, BorderLayout.NORTH);

		// scroll pane
		JScrollPane scrollPane = new JScrollPane(mainContentNorthWrapper);
		scrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		// Can't use Short.MAX_VALUE like the docs say because of JDK-8079640
		scrollPane.setPreferredSize(new Dimension(0x7000, 0x7000));

		this.add(scrollPane);

		buildHeaderSegment();
		buildPiperStatusSection();
		buildVoiceRepositorySegment();
//		buildVoiceHistorySegment();

		this.revalidate();
	}

	private void buildVoiceHistorySegment() {
		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setLayout(new BorderLayout());
		sectionHeader.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		// For whatever reason, the header extends out by a single pixel when closed. Adding a single pixel of
		// border on the right only affects the width when closed, fixing the issue.
		sectionHeader.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader);

		final JButton sectionToggle = new JButton(SECTION_RETRACT_ICON);
		sectionToggle.setPreferredSize(new Dimension(18, 0));
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Retract");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final String name = "History";
		final String description = "The history of played voices played.";
		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setToolTipText("<html>" + name + ":<br>" + description + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContent = new JPanel();
		sectionContent.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionContent.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		section.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(BORDER_OFFSET, 0, BORDER_OFFSET, 0)
		));
		section.add(sectionContent, BorderLayout.SOUTH);

		mainContentPanel.add(section);

		// Toggle section action listeners
		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSection(sectionToggle, sectionContent);
			}
		};
		sectionToggle.addActionListener(actionEvent -> toggleSection(sectionToggle, sectionContent));
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);
	}

	public void buildHeaderSegment() {
		JLabel titleLabel = new JLabel("Natural Speech", JLabel.CENTER);
		titleLabel.setFont(new Font("Sans", Font.BOLD, 24));
		titleLabel.setBorder(new EmptyBorder(1, 0, 1, 0));
		mainContentPanel.add(titleLabel);

		// Instructions Link
		JLabel instructionsLink =
			new JLabel("<html>For instructions, click <a href='#'>here</a>.</html>", JLabel.CENTER);
		instructionsLink.setCursor(new Cursor(Cursor.HAND_CURSOR));
		instructionsLink.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				try {
					Desktop.getDesktop().browse(new URI("https://github.com/phyce/rl-natural-speech"));
				} catch (Exception ex) {
					log.error("Error opening instruction link.", ex);
				}
			}
		});
		instructionsLink.setBorder(new EmptyBorder(0, 0, 5, 0));
		mainContentPanel.add(instructionsLink);

	}

	public void buildVoiceRepositorySegment() {
		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setLayout(new BorderLayout());
		sectionHeader.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		// For whatever reason, the header extends out by a single pixel when closed. Adding a single pixel of
		// border on the right only affects the width when closed, fixing the issue.
		sectionHeader.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader);

		final JButton sectionToggle = new JButton(SECTION_RETRACT_ICON);
		sectionToggle.setPreferredSize(new Dimension(18, 0));
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Retract");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final String name = "Voice Packs";
		final String description = "Download and manage your voice models.";
		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setToolTipText("<html>" + name + ":<br>" + description + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContent = new JPanel();
		sectionContent.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionContent.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		section.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(BORDER_OFFSET, 0, BORDER_OFFSET, 0)
		));
		section.add(sectionContent, BorderLayout.SOUTH);

		mainContentPanel.add(section);

		// Toggle section action listeners
		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSection(sectionToggle, sectionContent);
			}
		};
		sectionToggle.addActionListener(actionEvent -> toggleSection(sectionToggle, sectionContent));
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);

		List<ModelRepository.ModelURL> modelURLS = modelRepository.getModelURLS();
		for (ModelRepository.ModelURL modelUrl : modelURLS) {
			ModelListItem listItem = new ModelListItem(textToSpeech, modelRepository, modelUrl);
			sectionContent.add(listItem);

			ModelRepository.ModelRepositoryListener modelRepoListener = new ModelRepository.ModelRepositoryListener() {
				@Override
				public void onRepositoryChanged(String modelName) {
					SwingUtilities.invokeLater(() -> {
						log.debug("Repository change detected. Rebuilding {}", modelName);
						listItem.rebuild();
						revalidate();
					});
				}

				@Override
				public void onRefresh() {
					SwingUtilities.invokeLater(() -> {
						log.debug("Repository refresh. Rebuilding");
						listItem.rebuild();
						revalidate();
					});
				}
			};
			modelRepository.addRepositoryChangedListener(modelRepoListener);
			this.modelRepositoryListeners.add(modelRepoListener);
		}
	}

	public void buildPiperStatusSection() {
		final JPanel section = new JPanel();
		section.setLayout(new BoxLayout(section, BoxLayout.Y_AXIS));
		section.setMinimumSize(new Dimension(PANEL_WIDTH, 0));

		final JPanel sectionHeader = new JPanel();
		sectionHeader.setLayout(new BorderLayout());
		sectionHeader.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		// For whatever reason, the header extends out by a single pixel when closed. Adding a single pixel of
		// border on the right only affects the width when closed, fixing the issue.
		sectionHeader.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(0, 0, 3, 1)));
		section.add(sectionHeader);

		final JButton sectionToggle = new JButton(SECTION_RETRACT_ICON);
		sectionToggle.setPreferredSize(new Dimension(18, 0));
		sectionToggle.setBorder(new EmptyBorder(0, 0, 0, 5));
		sectionToggle.setToolTipText("Retract");
		SwingUtil.removeButtonDecorations(sectionToggle);
		sectionHeader.add(sectionToggle, BorderLayout.WEST);

		final String name = "Piper Status";
		final String description = "Manage your piper instances.";
		final JLabel sectionName = new JLabel(name);
		sectionName.setForeground(ColorScheme.BRAND_ORANGE);
		sectionName.setFont(FontManager.getRunescapeBoldFont());
		sectionName.setToolTipText("<html>" + name + ":<br>" + description + "</html>");
		sectionHeader.add(sectionName, BorderLayout.CENTER);

		final JPanel sectionContent = new JPanel();
		sectionContent.setLayout(new DynamicGridLayout(0, 1, 0, 5));
		sectionContent.setMinimumSize(new Dimension(PANEL_WIDTH, 0));
		section.setBorder(new CompoundBorder(
			new MatteBorder(0, 0, 1, 0, ColorScheme.MEDIUM_GRAY_COLOR),
			new EmptyBorder(BORDER_OFFSET, 0, BORDER_OFFSET, 0)
		));
		section.add(sectionContent, BorderLayout.SOUTH);
		mainContentPanel.add(section);

		// Toggle section action listeners
		final MouseAdapter adapter = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				toggleSection(sectionToggle, sectionContent);
			}
		};
		sectionToggle.addActionListener(actionEvent -> toggleSection(sectionToggle, sectionContent));
		sectionName.addMouseListener(adapter);
		sectionHeader.addMouseListener(adapter);

		// Status Label with dynamic background color
		JPanel statusPanel = buildPiperStatusPanel();
		sectionContent.add(statusPanel);

		JPanel piperFileChoosePanel = buildPiperFileChoose();
		sectionContent.add(piperFileChoosePanel);

		JPanel piperProcessMonitorPanel = buildPiperProcessMonitorPanel();
		sectionContent.add(piperProcessMonitorPanel);
	}

	private JPanel buildPiperProcessMonitorPanel() {
		JPanel panel = new JPanel();
		panel.setLayout(new DynamicGridLayout(0, 1, 0, 2));
		panel.setBorder(new EmptyBorder(5, 0, 5, 0));

		textToSpeech.addTextToSpeechListener(
			new TextToSpeech.TextToSpeechListener() {
				private final Map<Piper, PiperListItem> piperItemList = new HashMap<>();

				@Override
				public void onPiperStart(Piper piper) {
					PiperListItem piperItem = new PiperListItem(piper);
					piperItemList.put(piper, piperItem);
					panel.add(piperItem);
					panel.revalidate();
				}

				@Override
				public void onPiperExit(Piper piper) {
					PiperListItem remove = piperItemList.remove(piper);
					if (remove != null) {
						panel.remove(remove);
						panel.revalidate();
					}
				}
			}
		);
		return panel;
	}

	private JPanel buildPiperStatusPanel() {
		JPanel statusPanel = new JPanel();
		statusPanel.setLayout(new BorderLayout());
		statusPanel.setBorder(new EmptyBorder(5, 0, 5, 0));

		JLabel statusLabel = new JLabel("Not Running", SwingConstants.CENTER);
		statusLabel.setFont(new Font("Sans", Font.BOLD, 20));
		statusLabel.setOpaque(true); // Needed to show background color
		statusLabel.setPreferredSize(new Dimension(statusLabel.getWidth(), 50)); // Set preferred height
		statusLabel.setBackground(Color.DARK_GRAY);
		statusPanel.setToolTipText("Press start to begin text to speech.");

		statusPanel.add(statusLabel, BorderLayout.NORTH);

		textToSpeech.addTextToSpeechListener(
			new TextToSpeech.TextToSpeechListener() {
				@Override
				public void onPiperStart(Piper piper) {
					// FIXME(Louis) Temporary just for testing. Should check if any pipers are running,
					// not just one starting piper
					statusLabel.setText("Running");
					statusLabel.setBackground(Color.GREEN.darker());
					statusLabel.setForeground(Color.WHITE);
					statusPanel.setToolTipText("Text to speech is running.");
				}

				@Override
				public void onPiperExit(Piper piper) {
					// FIXME(Louis) Temporary just for testing. Should check if any pipers are running,
					// not just one starting piper
					if (textToSpeech.isStarted() && textToSpeech.activePiperProcessCount() == 0) {
						// Detect if this was an unintended exit, because the model would still be enabled
						if (textToSpeech.getModelConfig().isModelEnabled(piper.getModelLocal().getModelName())) {
							statusLabel.setText("Crashed (Contact Us)");
							statusLabel.setBackground(Color.RED.darker());
							statusLabel.setForeground(Color.WHITE);
							statusPanel.setToolTipText("Please contact the developers for support.");
						} else {
							statusLabel.setText("No Models Enabled");
							statusLabel.setBackground(Color.ORANGE.darker());
							statusLabel.setForeground(Color.WHITE);
							statusPanel.setToolTipText("Download and enable a model.");
						}
					}
				}

				@Override
				public void onPiperInvalid() {
					statusLabel.setText("Piper Path Invalid");
					statusLabel.setBackground(Color.RED.darker().darker().darker());
					statusLabel.setForeground(Color.WHITE);
					statusPanel.setToolTipText("Please contact the developers for support.");
				}

				@Override
				public void onStart() {
					// FIXME(Louis) Temporary just for testing. Should check if any pipers are running,
					// not just one starting piper
					if (textToSpeech.isStarted() &&
						textToSpeech.activePiperProcessCount() == 0) {
						statusLabel.setText("No Models Enabled");
						statusLabel.setBackground(Color.ORANGE.darker());
						statusLabel.setForeground(Color.WHITE);
						statusPanel.setToolTipText("Download and enable a model.");
					}

				}

				@Override
				public void onStop() {
					statusLabel.setText("Not running");
					statusLabel.setBackground(Color.DARK_GRAY);
					statusLabel.setForeground(null);
					statusPanel.setToolTipText("Press start to begin text to speech.");
				}
			}
		);

		// Button Panel
		JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.CENTER)); // Align buttons in the center

		// Initialize buttons with icons
		JButton playButton = createButton("start.png", "Start");
		JButton stopButton = createButton("stop.png", "Stop");

		playButton.addActionListener(e -> {
			clientThread.invokeLater(() -> {
				textToSpeech.start();
			});
		});
		stopButton.addActionListener(e -> {
			clientThread.invokeLater(() -> {
				textToSpeech.stop();
			});
		});

		buttonPanel.add(playButton);
		buttonPanel.add(stopButton);
		statusPanel.add(buttonPanel, BorderLayout.CENTER);
		return statusPanel;
	}

	private JPanel buildPiperFileChoose() {
		JTextField filePathField = new JTextField(runtimeConfig.getPiperPath().toString());
		filePathField.setToolTipText("Piper binary file path");
		filePathField.setEditable(false);

		JButton browseButton = new JButton("Browse");
		browseButton.setToolTipText("Requires manual download, please read instructions.");
		browseButton.addActionListener(e -> {
			// open in drive top path
			JFileChooser fileChooser = new JFileChooser(System.getProperty("user.home"));
			fileChooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
			int returnValue = fileChooser.showOpenDialog(MainSettingsPanel.this);
			if (returnValue == JFileChooser.APPROVE_OPTION) {
				Path newPath = Path.of(fileChooser.getSelectedFile().getPath());

				// if the user accidentally set the piper folder and not the executable, automatically correct
				if (newPath.toFile().isDirectory()) {
					if (OSValidator.IS_WINDOWS) {
						newPath = newPath.resolve("piper.exe");
					} else { // assume unix based
						newPath = newPath.resolve("piper");
					}
				}

				filePathField.setText(newPath.toString());
				runtimeConfig.savePiperPath(newPath);
				modelRepository.refresh();

				// if text to speech is running, restart
				if (textToSpeech.isStarted()) {
					textToSpeech.stop();
				}

			}

		});

		JPanel fileBrowsePanel = new JPanel(new BorderLayout());
		fileBrowsePanel.setBorder(new EmptyBorder(0, 0, 5, 0));
		fileBrowsePanel.add(filePathField, BorderLayout.CENTER);
		fileBrowsePanel.add(browseButton, BorderLayout.SOUTH);
		return fileBrowsePanel;
	}

	private void toggleSection(JButton toggleButton, JPanel sectionContent) {
		boolean newState = !sectionContent.isVisible();
		sectionContent.setVisible(newState);
		toggleButton.setIcon(newState? SECTION_RETRACT_ICON: SECTION_EXPAND_ICON);
		toggleButton.setToolTipText(newState? "Retract": "Expand");
		SwingUtilities.invokeLater(sectionContent::revalidate);
	}

	private JButton createButton(String iconPath, String toolTipText) {
		BufferedImage icon = ImageUtil.loadImageResource(getClass(), iconPath);
		JButton button = new JButton(new ImageIcon(icon));
		button.setToolTipText(toolTipText);
		return button;
	}

	public void shutdown() {
		this.removeAll();
		for (ModelRepository.ModelRepositoryListener listener : this.modelRepositoryListeners) {
			modelRepository.removeRepositoryChangedListener(listener);
		}
	}

	@Override
	public void onActivate() {
		super.onActivate();

		this.setVisible(true);
	}

	@Override
	public void onDeactivate() {
		super.onDeactivate();

		this.setVisible(false);
	}
}

package dev.phyce.naturalspeech.ui.panels;

import dev.phyce.naturalspeech.tts.piper.Piper;
import dev.phyce.naturalspeech.tts.piper.PiperProcess;
import java.awt.BorderLayout;
import java.awt.Color;
import java.util.HashMap;
import java.util.Map;
import javax.swing.JLabel;
import javax.swing.JPanel;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;

@Slf4j
public class PiperListItem extends JPanel {

	private final Piper piper;
	private final JPanel processListPanel;


	public PiperListItem(Piper piper) {
		this.piper = piper;

		this.setLayout(new BorderLayout());

		// piper
		JLabel piperTitle = new JLabel(piper.getModelLocal().getModelName());
		piperTitle.setFont(FontManager.getRunescapeBoldFont());
		this.add(piperTitle, BorderLayout.NORTH);

		// piperprocess of the piper
		this.processListPanel = new JPanel();
		this.processListPanel.setLayout(new DynamicGridLayout(0, 1));
		this.add(processListPanel, BorderLayout.SOUTH);

		// listener should not leak, do not need to call removePiperListener
		// when piper is removed in TextToSpeech this JPanel is removed by MainSettingsPanel
		// So the both will be garbage collected.
		ItemPiperProcessLifeTimeListener listener = new ItemPiperProcessLifeTimeListener(piper);
		piper.addPiperListener(listener);

	}

	private class ItemPiperProcessLifeTimeListener implements Piper.PiperProcessLifetimeListener {

		public final Map<PiperProcess, JLabel> labelMap = new HashMap<>();

		public ItemPiperProcessLifeTimeListener(Piper piper) {
			piper.getProcessMap().forEach((pid, process) -> {
				AddProcess(process);
			});
		}

		public void AddProcess(PiperProcess process) {
			log.debug("Labeling process {}", process);
			JLabel processLabel = new JLabel(process.toString());
			labelMap.put(process, processLabel);
			processListPanel.add(processLabel);
			processListPanel.revalidate();
		}

		private void RemoveProcess(PiperProcess process) {
			log.debug("Removing label for process {}", process);
			JLabel label = labelMap.remove(process);
			processListPanel.remove(label);
			processListPanel.revalidate();
		}

		@Override
		public void onPiperProcessBusy(PiperProcess process) {
			JLabel label = labelMap.get(process);
			label.setForeground(Color.GREEN);
		}

		@Override
		public void onPiperProcessDone(PiperProcess process) {
			JLabel label = labelMap.get(process);
			label.setForeground(null);
		}

		@Override
		public void onPiperProcessCrash(PiperProcess process) {
		}

		@Override
		public void onPiperProcessStart(PiperProcess process) {
			AddProcess(process);
		}

		@Override
		public void onPiperProcessExit(PiperProcess process) {
			RemoveProcess(process);
		}
	}


}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package dev.phyce.naturalspeech.ui.panels;

import java.awt.Dimension;
import javax.swing.JPanel;
import net.runelite.client.ui.PluginPanel;

class FixedWidthPanel extends JPanel {
	@Override
	public Dimension getPreferredSize() {
		return new Dimension(PluginPanel.PANEL_WIDTH, super.getPreferredSize().height);
	}
}

package dev.phyce.naturalspeech.ui.panels;

import java.awt.Font;
import javax.swing.JLabel;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.PluginPanel;

public class EditorPanel extends PluginPanel {
	public EditorPanel() {
		super(false);
		JLabel titleLabel = new JLabel("Editor", JLabel.CENTER);
		titleLabel.setFont(new Font("Sans", Font.BOLD, 24));
		titleLabel.setBorder(new EmptyBorder(10, 10, 10, 10));
		add(titleLabel);
	}

	@Override
	public void onActivate() {
		super.onActivate();

		setVisible(true);
	}

	@Override
	public void onDeactivate() {
		super.onDeactivate();

		setVisible(false);
	}
}

package dev.phyce.naturalspeech.ui.panels;

import dev.phyce.naturalspeech.tts.ModelRepository;
import dev.phyce.naturalspeech.tts.TextToSpeech;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.IOException;
import javax.swing.GroupLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JToggleButton;
import javax.swing.LayoutStyle;
import javax.swing.SwingUtilities;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.SwingUtil;

@Slf4j
public class ModelListItem extends JPanel {

	private final TextToSpeech textToSpeech;
	private final ModelRepository modelRepository;
	private final ModelRepository.ModelURL modelUrl;

	private static final int BOTTOM_LINE_HEIGHT = 16;
	private static final ImageIcon ON_SWITCHER;
	private static final ImageIcon OFF_SWITCHER;

	static {
		BufferedImage onSwitcher = ImageUtil.loadImageResource(MainSettingsPanel.class, "switcher_on.png");
		ON_SWITCHER = new ImageIcon(onSwitcher);
		OFF_SWITCHER = new ImageIcon(ImageUtil.flipImage(
			ImageUtil.luminanceScale(
				ImageUtil.grayscaleImage(onSwitcher),
				0.61f
			),
			true,
			false
		));
	}

	private MouseAdapter contextMenuMouseListener;

	public ModelListItem(TextToSpeech textToSpeech, ModelRepository modelRepository,
						 ModelRepository.ModelURL modelUrl) {
		this.textToSpeech = textToSpeech;
		this.modelRepository = modelRepository;
		this.modelUrl = modelUrl;

		this.setBackground(ColorScheme.DARKER_GRAY_COLOR);
		this.setOpaque(true);
		this.setBorder(new EmptyBorder(5, 5, 5, 5));

		rebuild();

	}

	public void rebuild() {

		this.removeAll();
		this.removeMouseListener(this.contextMenuMouseListener);

		GroupLayout layout = new GroupLayout(this);
		this.setLayout(layout);

		JLabel name = new JLabel(modelUrl.getModelName());
		name.setFont(FontManager.getRunescapeBoldFont());

		JLabel description = new JLabel(String.format("<html><p>%s</p></html>", modelUrl.getDescription()));
		description.setVerticalAlignment(JLabel.TOP);

		JLabel memorySize = new JLabel(modelUrl.getMemorySize());
		memorySize.setFont(FontManager.getRunescapeSmallFont());

		JToggleButton toggleButton = new JToggleButton();
		SwingUtil.removeButtonDecorations(toggleButton);
		toggleButton.setIcon(OFF_SWITCHER);
		toggleButton.setSelectedIcon(ON_SWITCHER);
		toggleButton.setPreferredSize(new Dimension(25, 0));
		toggleButton.setSelected(textToSpeech.getModelConfig().isModelEnabled(modelUrl.getModelName()));
		toggleButton.addActionListener(
			l -> {
				log.debug("Toggling {} into {}", modelUrl.getModelName(), toggleButton.isSelected());
				textToSpeech.getModelConfig().setModelEnabled(modelUrl.getModelName(), toggleButton.isSelected());
				try {
					ModelRepository.ModelLocal modelLocal = modelRepository.loadModelLocal(modelUrl.getModelName());
					if (textToSpeech.isStarted()) {
						if (toggleButton.isSelected()) {
							textToSpeech.startPiperForModel(modelLocal);
						}
						else {
							textToSpeech.stopPiperForModel(modelLocal);
						}
					}
				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			});

		JButton download = new JButton();
		download.setText("Download");
		if (!textToSpeech.isPiperPathValid()) {
			download.setEnabled(false);
			download.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
			download.setBorder(new LineBorder(download.getBackground().darker()));
		}
		else {
			download.setBackground(new Color(0x28BE28));
			download.setBorder(new LineBorder(download.getBackground().darker()));
			download.addActionListener(l -> {
				download.setText("Downloading");
				download.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
				download.setBorder(new LineBorder(download.getBackground().darker()));
				download.setEnabled(false);

				modelRepository.getExecutor().execute(() -> {
					try {
						// reset model configs, in case there are previous settings
						textToSpeech.getModelConfig().resetPiperConfig(modelUrl.getModelName());

						modelRepository.loadModelLocal(modelUrl.getModelName());

					} catch (IOException ignored) {
						SwingUtilities.invokeLater(this::rebuild);
					}
				});
			});
		}

		boolean hasLocal;
		try {
			hasLocal = modelRepository.hasModelLocal(modelUrl.getModelName());
		} catch (IOException ignored) {
			hasLocal = false;
		}

		if (hasLocal) {
			download.setVisible(false);
		}
		else {
			toggleButton.setVisible(false);
		}

		layout.setHorizontalGroup(layout
			.createParallelGroup()
			.addGroup(layout.createSequentialGroup()
				.addComponent(name, 0, GroupLayout.PREFERRED_SIZE, 0x7000)
				.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 0x7000)
			)
			.addComponent(description, 0, GroupLayout.PREFERRED_SIZE, 0x7000)
			.addGroup(layout.createSequentialGroup()
				.addComponent(memorySize)
				.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 0x7000)
				.addComponent(toggleButton, 25, 25, 25)
				.addComponent(download, 0, 77, GroupLayout.PREFERRED_SIZE)
			)
		);

		int lineHeight = description.getFontMetrics(description.getFont()).getHeight();
		layout.setVerticalGroup(layout
			.createSequentialGroup()
			.addGap(2)
			.addGroup(layout.createParallelGroup()
				.addComponent(name)
			)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 100)
			.addComponent(description, lineHeight, GroupLayout.PREFERRED_SIZE, lineHeight * 4)
			.addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.PREFERRED_SIZE, 100)
			.addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
				.addComponent(memorySize, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT)
				.addComponent(toggleButton, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT)
				.addComponent(download, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT, BOTTOM_LINE_HEIGHT)
			)
			.addGap(2)
		);

		if (hasLocal) {
			this.setToolTipText("Right click for other settings.");
			JMenuItem remove = new JMenuItem("Remove");
			remove.addActionListener(ev -> {
				try {
					ModelRepository.ModelLocal modelLocal = modelRepository.loadModelLocal(modelUrl.getModelName());

					// stop the piper
					if (textToSpeech.isStarted() && textToSpeech.isModelActive(modelLocal)) {
						textToSpeech.stopPiperForModel(modelLocal);
					}

					// reset the model configs
					textToSpeech.getModelConfig().resetPiperConfig(modelUrl.getModelName());

					// delete the files
					modelRepository.deleteModelLocal(modelLocal);

				} catch (IOException e) {
					throw new RuntimeException(e);
				}
			});
			JMenuItem setProcessCount = new JMenuItem("Set Process Count");
			setProcessCount.addActionListener(ev -> {
				JFrame alwaysOnTopFrame = new JFrame();
				alwaysOnTopFrame.setAlwaysOnTop(true);
				// open popup
				Integer result = (Integer) JOptionPane.showInputDialog(alwaysOnTopFrame,
					"<html><p>Text-to-speech will run faster with more processes.</p>" +
						"<p><strong>At the cost of memory</strong>, every process uses ~100MB of memory.</p></html>",
					"Set Number of Processes For This Model",
					JOptionPane.WARNING_MESSAGE,
					null,
					new Integer[] {1, 2, 3},
					textToSpeech.getModelConfig().getModelProcessCount(modelUrl.getModelName()));

				if (result != null) {
					log.debug("Option chose: " + result);
					textToSpeech.getModelConfig().setModelProcessCount(modelUrl.getModelName(), result);

					// TODO(Louis) lazy hack, just reboot all processes with new configuration
					if (textToSpeech.isStarted()) textToSpeech.start();
				}
				else {
					log.debug("Cancelled!");
				}

			});
			this.contextMenuMouseListener = addPopupMenu(this, setProcessCount, remove);
		}
	}

	static MouseAdapter addPopupMenu(JPanel panel, JMenuItem... menuItems) {
		final JPopupMenu menu = new JPopupMenu();
		menu.setBorder(new EmptyBorder(5, 5, 5, 5));

		for (final JMenuItem menuItem : menuItems) {
			if (menuItem == null) {
				continue;
			}
			menu.add(menuItem);
		}

		MouseAdapter listener = new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent mouseEvent) {
				if (mouseEvent.getButton() == MouseEvent.BUTTON3) {
					Component source = (Component) mouseEvent.getSource();
					Point location = MouseInfo.getPointerInfo().getLocation();
					SwingUtilities.convertPointFromScreen(location, source);
					menu.show(source, location.x, location.y);
				}
			}
		};
		panel.addMouseListener(listener);
		return listener;
	}
}

/*
 * Copyright (c) 2017, Adam <Adam@sigterm.info>
 * Copyright (c) 2018, Psikoi <https://github.com/psikoi>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 *  Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package dev.phyce.naturalspeech.ui.components;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionListener;
import java.awt.event.FocusAdapter;
import java.awt.event.FocusEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.List;
import javax.swing.DefaultListModel;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.OverlayLayout;
import javax.swing.SwingUtilities;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.ListDataEvent;
import javax.swing.event.ListDataListener;
import javax.swing.text.Document;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.components.FlatTextField;
import net.runelite.client.util.SwingUtil;
import org.apache.commons.lang3.StringUtils;

/**
 * This component is a FlatTextField with an icon on its left side, and a clear button (×) on its right side.
 */
public class IconTextField extends JPanel {
	// To support gifs, the icon needs to be wrapped in a JLabel
	private final JLabel iconWrapperLabel;
	private final FlatTextField textField;
	private final JButton clearButton;
	private final JButton suggestionButton;

	@Getter
	private final DefaultListModel<String> suggestionListModel;

	private final List<Runnable> clearListeners = new ArrayList<>();
	private final JLabel placeHolderTextField;

	public IconTextField() {
		setLayout(new BorderLayout());

		iconWrapperLabel = new JLabel();
		iconWrapperLabel.setPreferredSize(new Dimension(30, 0));
		iconWrapperLabel.setVerticalAlignment(JLabel.CENTER);
		iconWrapperLabel.setHorizontalAlignment(JLabel.CENTER);

		JPanel textFieldWrapper = new JPanel();
		textFieldWrapper.setLayout(new OverlayLayout(textFieldWrapper));

		textField = new FlatTextField();
		textField.setBorder(null);

		JPanel placeHolderWrapper = new JPanel();
		placeHolderWrapper.setBackground(new Color(0, 0, 0, 0));
		placeHolderWrapper.setLayout(new BorderLayout());

		placeHolderTextField = new JLabel();
		placeHolderTextField.setHorizontalAlignment(JLabel.LEADING);
		placeHolderTextField.setForeground(ColorScheme.MEDIUM_GRAY_COLOR);
		placeHolderWrapper.add(placeHolderTextField);

		textFieldWrapper.add(placeHolderWrapper);
		textFieldWrapper.add(textField);


		final JTextField innerTxt = textField.getTextField();
		innerTxt.removeMouseListener(innerTxt.getMouseListeners()[innerTxt.getMouseListeners().length - 1]);

		final MouseListener hoverEffect = new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				if (textField.isBlocked()) {
					return;
				}

				final Color hoverColor = textField.getHoverBackgroundColor();

				if (hoverColor != null) {
					IconTextField.super.setBackground(hoverColor);
					textField.setBackground(hoverColor, false);
				}

			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				setBackground(textField.getBackgroundColor());
			}
		};

		textField.addMouseListener(hoverEffect);
		innerTxt.addMouseListener(hoverEffect);

		innerTxt.addFocusListener(new FocusAdapter() {
			@Override
			public void focusGained(FocusEvent e) {
				placeHolderWrapper.setVisible(false);
			}

			@Override
			public void focusLost(FocusEvent e) {
				placeHolderWrapper.setVisible(textField.getText().isEmpty());
			}
		});

		clearButton = createRHSButton(ColorScheme.PROGRESS_ERROR_COLOR, Color.PINK, FontManager.getRunescapeBoldFont());
		clearButton.setText("×");
		clearButton.addActionListener(evt -> {
			setText(null);

			for (Runnable listener : clearListeners) {listener.run();}
		});

		suggestionListModel = new DefaultListModel<>();
		suggestionListModel.addListDataListener(new ListDataListener() {
			@Override
			public void intervalAdded(ListDataEvent e) {
				updateContextButton();
			}

			@Override
			public void intervalRemoved(ListDataEvent e) {
				updateContextButton();
			}

			@Override
			public void contentsChanged(ListDataEvent e) {
				updateContextButton();
			}
		});

		JList<String> suggestionList = new JList<>();
		suggestionList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		suggestionList.setModel(suggestionListModel);
		suggestionList.addListSelectionListener(e ->
		{
			String val = suggestionList.getSelectedValue();
			if (val == null) return;

			textField.setText(val);
			textField.getTextField().selectAll();
			textField.getTextField().requestFocusInWindow();
		});

		JPopupMenu popup = new JPopupMenu();
		popup.setLightWeightPopupEnabled(true);
		popup.setLayout(new BorderLayout());
		popup.add(suggestionList, BorderLayout.CENTER);
		popup.addFocusListener(new FocusAdapter() {
			@Override
			public void focusLost(FocusEvent e) {
				popup.setVisible(false);
				suggestionList.clearSelection();
			}
		});

		suggestionButton = createRHSButton(ColorScheme.LIGHT_GRAY_COLOR, ColorScheme.MEDIUM_GRAY_COLOR,
			FontManager.getDefaultBoldFont());
		suggestionButton.setText("▾");
		suggestionButton.addActionListener(e -> {
			suggestionList.setPreferredSize(new Dimension(getWidth(), suggestionList.getPreferredSize().height));
			popup.show(IconTextField.this, 0, suggestionButton.getHeight());
			popup.revalidate();
			popup.requestFocusInWindow();
		});

		// Show the clear button when text is present, and hide again when empty
		textField.getTextField().getDocument().addDocumentListener(new DocumentListener() {
			@Override
			public void insertUpdate(DocumentEvent e) {
				placeHolderWrapper.setVisible(textField.getText().isEmpty());
				updateContextButton();
			}

			@Override
			public void removeUpdate(DocumentEvent e) {
				placeHolderWrapper.setVisible(textField.getText().isEmpty());
				updateContextButton();
			}

			@Override
			public void changedUpdate(DocumentEvent e) {
				placeHolderWrapper.setVisible(textField.getText().isEmpty());
				updateContextButton();
			}
		});

		JPanel rhsButtons = new JPanel();
		rhsButtons.setBackground(new Color(0, 0, 0, 0));
		rhsButtons.setOpaque(false);
		rhsButtons.setLayout(new BorderLayout());
		rhsButtons.add(clearButton, BorderLayout.EAST);
		rhsButtons.add(suggestionButton, BorderLayout.WEST);
		updateContextButton();

		add(iconWrapperLabel, BorderLayout.WEST);
		add(textFieldWrapper, BorderLayout.CENTER);
		add(rhsButtons, BorderLayout.EAST);
	}

	private JButton createRHSButton(Color foregroundColor, Color rollover, Font font) {
		JButton button = new JButton();
		button.setPreferredSize(new Dimension(30, 0));
		button.setFont(font);
		button.setBorder(null);
		button.setRolloverEnabled(true);
		SwingUtil.removeButtonDecorations(button);
		button.setForeground(foregroundColor);

		button.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseEntered(MouseEvent mouseEvent) {
				button.setForeground(rollover);
				textField.dispatchEvent(mouseEvent);
			}

			@Override
			public void mouseExited(MouseEvent mouseEvent) {
				button.setForeground(foregroundColor);
				textField.dispatchEvent(mouseEvent);
			}
		});

		return button;
	}

	private void updateContextButton() {
		boolean empty = StringUtils.isBlank(textField.getText());

		clearButton.setVisible(!empty);
		suggestionButton.setVisible(!suggestionListModel.isEmpty() && empty);
	}

	public void addActionListener(ActionListener actionListener) {
		textField.addActionListener(actionListener);
	}

	public void setIcon(Icon icon) {
		final ImageIcon imageIcon = new ImageIcon(this.getClass().getResource(icon.getFile()));
		iconWrapperLabel.setIcon(imageIcon);
	}

	public void setIcon(ImageIcon imageIcon) {
		iconWrapperLabel.setIcon(imageIcon);
	}

	public String getText() {
		return textField.getText();
	}

	public void setText(String text) {
		assert SwingUtilities.isEventDispatchThread();
		textField.setText(text);
	}

	public void setPlaceholderText(String text) {
		assert SwingUtilities.isEventDispatchThread();
		placeHolderTextField.setText(text);
	}

	@Override
	public void setBackground(Color color) {
		if (color == null) return;

		super.setBackground(color);

		if (textField != null) textField.setBackground(color);
	}

	public void setHoverBackgroundColor(Color hoverBackgroundColor) {
		if (hoverBackgroundColor == null) return;

		this.textField.setHoverBackgroundColor(hoverBackgroundColor);
	}

	@Override
	public void addKeyListener(KeyListener keyListener) {
		textField.addKeyListener(keyListener);
	}

	public void addClearListener(Runnable clearListener) {
		clearListeners.add(clearListener);
	}

	@Override
	public void removeKeyListener(KeyListener keyListener) {
		textField.removeKeyListener(keyListener);
	}

	public void setEditable(boolean editable) {
		textField.setEditable(editable);
		if (!editable) super.setBackground(textField.getBackgroundColor());
	}

	@Override
	public boolean requestFocusInWindow() {
		super.requestFocusInWindow();
		return textField.requestFocusInWindow();
	}

	public Document getDocument() {
		return textField.getDocument();
	}

	@Getter
	@RequiredArgsConstructor
	public enum Icon {
		SEARCH("search.png"),
		LOADING("loading_spinner.gif"),
		LOADING_DARKER("loading_spinner_darker.gif"),
		ERROR("error.png");

		private final String file;
	}
}

package dev.phyce.naturalspeech.ui.layouts;

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.Insets;
import java.util.function.Function;

public class OnlyVisibleGridLayout extends GridLayout {

	public OnlyVisibleGridLayout() {
		this(1, 0, 0, 0);
	}

	public OnlyVisibleGridLayout(int rows, int columns) {
		this(rows, columns, 0, 0);
	}

	public OnlyVisibleGridLayout(int rows, int columns, int horizontalGap, int verticalGap) {
		super(rows, columns, horizontalGap, verticalGap);
	}

	// Pretends invisible components don't exist during layout
	private int getVisibleComponentCount(Container parent) {
		int count = 0;
		for (Component component : parent.getComponents()) {if (component.isVisible()) count++;}
		return count;
	}

	@Override
	public Dimension preferredLayoutSize(Container parent) {
		synchronized (parent.getTreeLock()) {
			return calculateSize(parent, Component::getPreferredSize);
		}
	}

	@Override
	public Dimension minimumLayoutSize(Container parent) {
		synchronized (parent.getTreeLock()) {
			return calculateSize(parent, Component::getMinimumSize);
		}
	}

	@Override
	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			final Insets insets = parent.getInsets();
			final int componentCount = parent.getComponentCount();
			final int visibleComponentCount = getVisibleComponentCount(parent);
			int rowCount = getRows();
			int columnCount = getColumns();

			if (visibleComponentCount == 0) return;

			if (rowCount > 0) {columnCount = (visibleComponentCount + rowCount - 1) / rowCount;}
			else {rowCount = (visibleComponentCount + columnCount - 1) / columnCount;}

			final int horizontalGap = getHgap();
			final int verticalGap = getVgap();

			// scaling factors
			final Dimension preferredDimension = preferredLayoutSize(parent);
			final Insets parentInsets = parent.getInsets();
			int widthBorder = parentInsets.left + parentInsets.right;
			int heightBorder = parentInsets.top + parentInsets.bottom;
			final double widthScale =
				(1.0 * parent.getWidth() - widthBorder) / (preferredDimension.width - widthBorder);
			final double heightScale =
				(1.0 * parent.getHeight() - heightBorder) / (preferredDimension.height - heightBorder);

			final int[] widths = new int[columnCount];
			final int[] heights = new int[rowCount];

			// calculate dimensions for all components + apply scaling
			{
				int visibleIndex = 0;
				int trueIndex = 0;
				while (trueIndex < componentCount) {
					final Component comp = parent.getComponent(trueIndex);

					if (!comp.isVisible()) {
						trueIndex++;
						continue;
					}

					final int row = visibleIndex / columnCount;
					final int column = visibleIndex % columnCount;
					final Dimension dimension = comp.getPreferredSize();

					dimension.width = (int) (widthScale * dimension.width);
					dimension.height = (int) (heightScale * dimension.height);

					if (widths[column] < dimension.width) widths[column] = dimension.width;
					if (heights[row] < dimension.height) heights[row] = dimension.height;

					visibleIndex++;
					trueIndex++;
				}
			}

			// Apply new bounds to all child components
			int visibleIndex = 0;
			int trueIndex = 0;
			while (trueIndex < componentCount) {
				final Component comp = parent.getComponent(trueIndex);

				if (!comp.isVisible()) {
					trueIndex++;
					continue;
				}

				final int row = visibleIndex / columnCount;
				final int column = visibleIndex % columnCount;
				final int x = insets.left + column * (widths[column] + horizontalGap);
				final int y = insets.top + row * (heights[row] + verticalGap);
				comp.setBounds(x, y, widths[column], heights[row]);
				visibleIndex++;
				trueIndex++;
			}
		}
	}

	/**
	 * Calculate outer size of the layout based on it's children and sizer
	 *
	 * @param parent parent component
	 * @param sizer  functioning returning dimension of the child component
	 *
	 * @return outer size
	 */
	private Dimension calculateSize(final Container parent, final Function<Component, Dimension> sizer) {
		final int visibleComponentCount = getVisibleComponentCount(parent);
		final int componentCount = parent.getComponentCount();
		int rowCount = getRows();
		int columnCount = getColumns();

		if (rowCount > 0) {columnCount = (visibleComponentCount + rowCount - 1) / rowCount;}
		else {rowCount = (visibleComponentCount + columnCount - 1) / columnCount;}

		final int[] width = new int[columnCount];
		final int[] height = new int[rowCount];

		// Calculate dimensions for all components
		int visibleIndex = 0;
		int trueIndex = 0;
		while (trueIndex < componentCount) {
			final Component comp = parent.getComponent(trueIndex);

			if (!comp.isVisible()) {
				trueIndex++;
				continue;
			}

			final int row = visibleIndex / columnCount;
			final int column = visibleIndex % columnCount;
			final Dimension dimension = sizer.apply(comp);

			if (width[column] < dimension.width) width[column] = dimension.width;
			if (height[row] < dimension.height) height[row] = dimension.height;

			visibleIndex++;
			trueIndex++;
		}

		// Calculate total width and height of the layout
		int netWidth = 0;

		for (int j = 0; j < columnCount; j++) {netWidth += width[j];}

		int netHeight = 0;

		for (int i = 0; i < rowCount; i++) {netHeight += height[i];}

		final Insets insets = parent.getInsets();

		// Apply insets and horizontal and vertical gap to layout
		return new Dimension(
			insets.left + insets.right + netWidth + (columnCount - 1) * getHgap(),
			insets.top + insets.bottom + netHeight + (rowCount - 1) * getVgap()
		);
	}
}

