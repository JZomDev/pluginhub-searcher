package com.adriansoftware;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class BankHistoryPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(BankHistoryPlugin.class);
		RuneLite.main(args);
	}
}
/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;

@ConfigGroup("bankhistory")
public interface BankHistoryConfig extends Config
{
	@ConfigItem(
		keyName = "defaultAccount",
		name = "Default account",
		description = "The account to show data for by default"
	)
	default String getDefaultAccount()
	{
		return "";
	}

	@ConfigItem(
		keyName = "defaultBankTab",
		name = "Default bank tab",
		description = "The bank tab to select by default"
	)
	default int getDefaultBankTab()
	{
		return 0;
	}

	@ConfigItem(
		keyName = "defaultDatasetEntry",
		name = "Default dataset entry",
		description = "The amount of time in hours that should elapse before adding a new data entry"
	)
	default int getDefaultDatasetEntry()
	{
		return 1;
	}

	@ConfigItem(
		keyName = "onlyManualEntries",
		name = "Only manual entries",
		description = "Only add entries manually, rather than each time the bank is opened."
	)
	default boolean getOnlyManualEntries()
	{
		return false;
	}

	@ConfigItem(
			keyName = "defaultHideAccountStartup",
			name = "Show accounts selection on startup",
			description = "Whether or not to show account drop down on startup"
	)
	default boolean getShowAccounts()
	{
		return true;
	}
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Deserializes a {@link BankValueHistoryContainer}.
 */
public class BankValueHistoryDeserializer implements JsonDeserializer<BankValueHistoryContainer>
{
	@Override
	public BankValueHistoryContainer deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException
	{
		JsonObject jsonObject = jsonElement.getAsJsonObject();

		JsonObject map = jsonObject.getAsJsonObject("pricesMap");
		Map<LocalDateTime, BankValue> bankValue = new HashMap<>();
		for (Map.Entry<String, JsonElement> elems : map.entrySet())
		{
			JsonElement element = elems.getValue();
			JsonObject containerPrices = element.getAsJsonObject();

			bankValue.put(LocalDateTime.parse(elems.getKey()),
				BankValue
					.builder()
					.tab(containerPrices.get("tab").getAsInt())
					.bankValue(containerPrices.get("bankValue").getAsLong())
					.build());
		}

		return new BankValueHistoryContainer(bankValue);
	}
}
/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.lang.reflect.InvocationTargetException;

@PluginDescriptor(
	name = "Bank Value Tracking",
	description = "Track the value of your bank over time",
	tags = {"bank", "value", "history", "tracking"}
)
@Slf4j
public class BankHistoryPlugin extends Plugin
{
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private BankValueHistoryTracker tracker;

	@Inject
	private ClientToolbar clientToolbar;

	private NavigationButton navButton;
	private BankHistoryPanel bankHistoryPanel;

	@Provides
	BankHistoryConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BankHistoryConfig.class);
	}

	@Override
	protected void startUp()
	{
		String username = this.tracker.getAvailableUsers().isEmpty() ? "" : this.tracker.getAvailableUsers().get(0);
		loadPluginPanel(username);
		clientToolbar.addNavigation(navButton);
	}

	private void loadPluginPanel(String username)
	{
		if (navButton == null)
		{
			bankHistoryPanel = injector.getInstance(BankHistoryPanel.class);
			bankHistoryPanel.init(username);
			final BufferedImage icon = ImageUtil.getResourceStreamFromClass(getClass(), "bank_logo.png");
			navButton = NavigationButton.builder()
					.tooltip("Bank Value History")
					.icon(icon)
					.priority(5)
					.panel(bankHistoryPanel)
					.build();

			this.clientToolbar.addNavigation(navButton);
		}
		else
		{
			this.clientToolbar.removeNavigation(navButton);
			this.navButton = null;
			loadPluginPanel(username);
		}
	}

	@Override
	protected void shutDown()
	{
		clientToolbar.removeNavigation(navButton);
	}

	@Subscribe
	public void onWidgetLoaded(final WidgetLoaded event) throws InvocationTargetException, InterruptedException
	{
		if (event.getGroupId() == InterfaceID.BANK)
		{
			log.trace("Player opened the bank");
			SwingUtilities.invokeAndWait(() -> this.loadPluginPanel(client.getLocalPlayer().getName()));
			if (isHistoryPanelActive())
			{
				bankHistoryPanel.setDatasetButton(true);
			}
		}
	}



	private boolean isHistoryPanelActive()
	{
		return bankHistoryPanel != null && navButton.getPanel() == bankHistoryPanel;
	}

	@Subscribe
	public void onWidgetClosed(WidgetClosed event)
	{
		if (event.getGroupId() == InterfaceID.BANK)
		{
			log.debug("onWidgetClosed: Bank closed");
			bankHistoryPanel.setDatasetButton(false);
			tracker.addEntry();
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		switch (event.getGameState().getState())
		{
			case 40:
				bankHistoryPanel.setDatasetButton(false);
				break;
		}
	}
}

package com.adriansoftware;

import java.awt.BorderLayout;
import javax.swing.JLabel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;

/**
 * Panel shown when there is no account data available to display.
 */
public class NoDataBankValuePanel extends PluginPanel
{
	public void init()
	{

	}
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Arrays;
import java.util.Date;
import java.util.Properties;
import java.util.Vector;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JComboBox;
import javax.swing.JPanel;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import net.runelite.client.ui.ColorScheme;
import net.sourceforge.jdatepicker.impl.DateComponentFormatter;
import net.sourceforge.jdatepicker.impl.JDatePanelImpl;
import net.sourceforge.jdatepicker.impl.JDatePickerImpl;
import net.sourceforge.jdatepicker.impl.UtilDateModel;
import org.apache.commons.lang3.StringUtils;

public class DatePickerPanel extends JPanel
{
	private final String labelText;
	private final LocalDateTime localDateTime;
	private final Consumer<Void> callback;
	private UtilDateModel model;
	private JComboBox<String> hour;
	private JComboBox<String> minute;
	private JComboBox<String> amPm;

	public DatePickerPanel(LocalDateTime localDateTime, String labelText, Consumer<Void> callback)
	{
		super();
		this.localDateTime = localDateTime;
		this.labelText = labelText;
		this.callback = callback;
	}

	public void init()
	{
		setLayout(new BorderLayout());
		model = new UtilDateModel(Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()));
		Properties p = new Properties();
		p.put("text.today", "Today");
		p.put("text.month", "Month");
		p.put("text.year", "Year");

		JDatePanelImpl datePanel = new JDatePanelImpl(model);
		JDatePickerImpl picker = new JDatePickerImpl(datePanel, new DateComponentFormatter());

		picker.setTextEditable(true);

		hour = new JComboBox<>(getArrayOfIntegers(1, 12));
		hour.setSelectedItem("12");
		minute = new JComboBox<>(getArrayOfIntegers(0, 60));
		minute.setSelectedItem("00");
		amPm = new JComboBox<>(new Vector<>(Arrays.asList("AM", "PM")));
		amPm.setSelectedItem("AM");

		addListeners();

		JPanel timePanel = new JPanel();
		timePanel.setLayout(new BoxLayout(timePanel, BoxLayout.LINE_AXIS));
		timePanel.add(hour);
		timePanel.add(Box.createHorizontalGlue());
		timePanel.add(minute);
		timePanel.add(Box.createHorizontalGlue());
		timePanel.add(amPm);

		JPanel containerPanel = new JPanel();
		containerPanel.setLayout(new BoxLayout(containerPanel, BoxLayout.PAGE_AXIS));
		containerPanel.add(picker);
		containerPanel.add(Box.createRigidArea(new Dimension(0, 5)));
		containerPanel.add(timePanel);

		add(containerPanel);
		setBorder(new CompoundBorder(new EmptyBorder(5, 5, 5, 5),
			BorderFactory.createTitledBorder(labelText)));
		setBackground(ColorScheme.DARKER_GRAY_COLOR);
	}

	private void addListeners()
	{
		model.addChangeListener((event) -> callback.accept(null));
		hour.addItemListener((event) -> callback.accept(null));
		minute.addItemListener((event) -> callback.accept(null));
		amPm.addItemListener((event) -> callback.accept(null));
	}

	public LocalDateTime getLocalDateTime()
	{
		if (hour == null || amPm == null || model == null || minute == null)
		{
			return null;
		}

		int h = Integer.parseInt(String.valueOf(hour.getSelectedItem()).replaceAll("^0+", "")) - 1;

		if (amPm.getSelectedItem() == "PM")
		{
			h += 12;
		}
		return LocalDateTime.of(model.getYear(),
			model.getMonth() + 1,
			model.getDay(),
			h,
			Integer.parseInt((String) minute.getSelectedItem()),
			0,
			0);
	}

	protected static Vector<String> getArrayOfIntegers(int start, int end, boolean pad)
	{
		return Stream.iterate(start, n -> n + 1)
			.limit(end)
			.map(v -> getFormattedTimeString(String.valueOf(v), pad))
			.collect(Collectors.toCollection(Vector::new));
	}

	protected static Vector<String> getArrayOfIntegers(int start, int end)
	{
		return getArrayOfIntegers(start, end, true);
	}

	protected static String getFormattedTimeString(String s, boolean pad)
	{
		return pad ?  StringUtils.leftPad(s, 2, '0') : s;
	}
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class BankValue
{
	private final int tab;
	private final long bankValue;
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import com.google.inject.Provides;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.events.ScriptCallbackEvent;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.QuantityFormatter;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.StandardChartTheme;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;

/**
 * A panel for showing a visualization of bank value over time.
 */
public class BankHistoryPanel extends PluginPanel
{
	@Inject
	@Setter
	private BankHistoryConfig config;
	@Inject
	@Setter
	private BankValueHistoryTracker tracker;
	private DatePickerPanel toDatePickerPanel;
	private DatePickerPanel startDatePickerPanel;
	private JFreeChart chart;
	private ChartPanel graphPanel = null;
	private SimpleTimeSelection timeSelection = SimpleTimeSelection.ALL;
	private Map<LocalDateTime, Long> currentDataRange;
	private JLabel changeLabel;
	private TimeSeriesCollection dataset;
	private int currentBankTab = -1;
	private JButton addDatasetButton;

	@Provides
	BankHistoryConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BankHistoryConfig.class);
	}

	public void init(String username)
	{
		init(username, false);
	}

	public void init()
	{
		init("", false);
	}

	private void init(String username, boolean isNewWindow)
	{
		if (username.isEmpty()) {
			String html =
					"<html>No account data found.<br/>" +
							"Log in and open the bank to start<br/>" +
							"tracking!<br/>" +
							"</html>";
			JLabel label = new JLabel(html);
			label.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
			label.setHorizontalAlignment(JLabel.CENTER);
			add(label, BorderLayout.NORTH);
		} else {
			setBackground(ColorScheme.DARK_GRAY_COLOR);
			setLayout(new BoxLayout(this, BoxLayout.PAGE_AXIS));
			setBorder(new EmptyBorder(10, 10, 10, 10));
			Set<String> accounts = getAccounts(username);

			//wraps all user ui components to set a maximum height
			JPanel uiWrapperPanel = new JPanel();
			uiWrapperPanel.setLayout(new BoxLayout(uiWrapperPanel, BoxLayout.PAGE_AXIS));
			uiWrapperPanel.setMaximumSize(new Dimension(1280, 500));

			//account selection
			JComboBox<String> accountSelectionCombo = new JComboBox<>(new Vector<>(accounts));
			JCheckBox accountSelectionVisible = new JCheckBox("Show accounts");
			accountSelectionVisible.setSelected(config.getShowAccounts());
			accountSelectionVisible.addItemListener((event) -> {
				accountSelectionCombo.setVisible(accountSelectionVisible.isSelected());
			});

			accountSelectionVisible.setFocusPainted(false);

			accountSelectionCombo.addItemListener((change) ->
			{
				updateDataset(change.getItem().toString());
			});

			String account = config.getDefaultAccount();

			//Simple Date selection
			JComboBox<String> simpleComboBox =
					new JComboBox<>(
							new Vector<>(
									Stream.of(SimpleTimeSelection
													.values())
											.map(SimpleTimeSelection::getFormattedName)
											.collect(Collectors.toList())));

			simpleComboBox
					.addItemListener(event ->
					{
						timeSelection = SimpleTimeSelection.of((String) event.getItem());
						updateDataset((String) accountSelectionCombo.getSelectedItem());
					});

			JButton showAdvancedButton = new JButton("Advanced");
			showAdvancedButton.setFocusPainted(false);

			JPanel simpleContainer = new JPanel();
			simpleContainer.setLayout(new BoxLayout(simpleContainer, BoxLayout.LINE_AXIS));
			simpleContainer.add(simpleComboBox);

			//Date picker
			LocalDate today = LocalDate.now();
			LocalDateTime startOfDay = today.atStartOfDay();
			Consumer<Void> callback = (t) ->
			{
				updateDataset((String) accountSelectionCombo.getSelectedItem());
			};

			startDatePickerPanel = new DatePickerPanel(startOfDay, "Start Date", callback);
			toDatePickerPanel = new DatePickerPanel(startOfDay.plusDays(1), "End Date", callback);
			startDatePickerPanel.init();
			toDatePickerPanel.init();

			JPanel datePickerContainer = new JPanel();
			datePickerContainer.setLayout(new BoxLayout(datePickerContainer, BoxLayout.PAGE_AXIS));
			datePickerContainer.setBackground(ColorScheme.DARKER_GRAY_COLOR);
			datePickerContainer.add(startDatePickerPanel);
			datePickerContainer.add(Box.createRigidArea(new Dimension(0, 10)));
			datePickerContainer.add(toDatePickerPanel);
			datePickerContainer.setVisible(false);
			showAdvancedButton.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseClicked(MouseEvent e)
				{
					boolean visible = datePickerContainer.isVisible();
					datePickerContainer.setVisible(!visible);
					simpleContainer.setVisible(visible);
					if (visible)
					{
						showAdvancedButton.setText("Advanced");
						timeSelection = null;
					}
					else
					{
						showAdvancedButton.setText("Simple");
					}
				}
			});
			//Advanced button
			JPanel advancedContainer = new JPanel();
			advancedContainer.setLayout(new BorderLayout());
			advancedContainer.add(showAdvancedButton, BorderLayout.CENTER);
			advancedContainer.add(Box.createRigidArea(new Dimension(0, 10)), BorderLayout.SOUTH);
			advancedContainer.setMaximumSize(new Dimension(1280, 45));

			//Open in new window
			JPanel openInNewWindowContainer = new JPanel();
			openInNewWindowContainer.setLayout(new BorderLayout());
			openInNewWindowContainer.add(Box.createRigidArea(new Dimension(0, 10)), BorderLayout.SOUTH);
			JButton newWindowButton = new JButton("Open In New Window");
			newWindowButton.setMaximumSize(new Dimension(100, 30));
			newWindowButton.setFocusPainted(false);
			newWindowButton.addMouseListener(new MouseAdapter()
			{
				@Override
				public void mouseReleased(MouseEvent e)
				{
					JFrame frame = (JFrame) SwingUtilities.getWindowAncestor(BankHistoryPanel.this);
					JDialog dialog = new JDialog(frame, "Bank History", false);
					BankHistoryPanel panel = new BankHistoryPanel();
					panel.setTracker(tracker);
					panel.setConfig(config);
					panel.init(username, true);
					dialog.setPreferredSize(new Dimension(500, 500));

					dialog.getContentPane().add(panel, BorderLayout.CENTER);

					dialog.setLocationRelativeTo(null);
					dialog.pack();
					dialog.setVisible(true);
				}
			});

			openInNewWindowContainer.add(newWindowButton, BorderLayout.CENTER);

			//bank tab selection
			JPanel tabPanel = new JPanel();
			JComboBox<String> tabSelectionCombo  = new JComboBox<>(DatePickerPanel.getArrayOfIntegers(0, 10, false));
			tabSelectionCombo.addItemListener((event) ->
			{
				currentBankTab = Integer.parseInt((String) event.getItem());
				updateDataset((String) accountSelectionCombo.getSelectedItem());
			});

			int defaultBankTab = config.getDefaultBankTab();
			tabSelectionCombo.setSelectedIndex(defaultBankTab);
			currentBankTab = defaultBankTab;

			JLabel tabLabel = new JLabel("Bank Tab: ");
			tabPanel.setLayout(new BoxLayout(tabPanel, BoxLayout.LINE_AXIS));
			tabPanel.add(tabLabel);
			tabPanel.add(tabSelectionCombo);

			//Refresh button
			JPanel addDatasetPanel = new JPanel();
			addDatasetPanel.setLayout(new BorderLayout());

			addDatasetButton = new JButton("Add Entry");
			setDatasetButton(false);
			addDatasetButton.setBackground(ColorScheme.GRAND_EXCHANGE_PRICE);
			addDatasetButton.setForeground(Color.WHITE);
			addDatasetButton.setFocusPainted(false);
			addDatasetButton.addActionListener((event) ->
			{
				setDatasetButton(false);
				tracker.addEntry(true, (s) ->
				{
					SwingUtilities.invokeLater(() ->
					{
						updateDataset((String) accountSelectionCombo.getSelectedItem());
						setDatasetButton(true);
					});
				});
			});

			addDatasetPanel.add(addDatasetButton, BorderLayout.CENTER);

			//Refresh button
			JPanel refreshPanel = new JPanel();
			refreshPanel.setLayout(new BorderLayout());

			JButton refreshButton = new JButton("Refresh");
			refreshButton.setFocusPainted(false);
			refreshButton.addActionListener((event) ->
			{
				updateDataset((String) accountSelectionCombo.getSelectedItem());
			});

			refreshPanel.add(refreshButton, BorderLayout.CENTER);

			//render
			add(uiWrapperPanel);

			//add buttons/user interaction components here
			uiWrapperPanel.add(accountSelectionCombo);
			uiWrapperPanel.add(accountSelectionVisible);
			uiWrapperPanel.add(Box.createRigidArea(new Dimension(0, 10)));
			uiWrapperPanel.add(advancedContainer);
			uiWrapperPanel.add(simpleContainer);
			uiWrapperPanel.add(datePickerContainer);
			uiWrapperPanel.add(Box.createRigidArea(new Dimension(0, 10)));
			uiWrapperPanel.add(tabPanel);
			uiWrapperPanel.add(Box.createRigidArea(new Dimension(0, 10)));
			add(Box.createRigidArea(new Dimension(0, 5)));

			loadGraph(account.isEmpty() ? accounts.stream().findFirst().get() : account);

			// Increase/decrease panel (change) panel
			// Done after the graph is loaded so we have the data points available
			JPanel changePanel = new JPanel();
			changePanel.setLayout(new BorderLayout());
			changeLabel = getChangeLabelValue();
			changeLabel.setHorizontalAlignment(JLabel.CENTER);
			changePanel.add(changeLabel, BorderLayout.CENTER);
			uiWrapperPanel.add(changePanel);

			add(Box.createRigidArea(new Dimension(0, 10)));
			add(addDatasetPanel);

			add(Box.createRigidArea(new Dimension(0, 10)));
			add(refreshPanel);

			if (!isNewWindow)
			{
				add(Box.createRigidArea(new Dimension(0, 10)));
				add(openInNewWindowContainer);
			}
		}
	}

	private Set<String> getAccounts(String username) {
		Set<String> result = new HashSet<>(tracker.getAvailableUsers());
		if (!username.isEmpty()) {
			result.add(username);
		}

		if (result.isEmpty()) {
			throw new IllegalStateException("No accounts available");
		}

		return result;
	}

	private void updateDataset(String account)
	{
		dataset = getDataset(account);
		setChangeLabel();

		chart.getXYPlot().setDataset(dataset);
	}

	private void setChangeLabel()
	{
		JLabel result = getChangeLabelValue();
		if (changeLabel != null)
		{
			changeLabel.setForeground(result.getForeground());
			changeLabel.setText(result.getText());
		}
		else
		{
			changeLabel = result;
		}
	}

	private JLabel getChangeLabelValue()
	{
		JLabel result = new JLabel();
		result.setForeground(ColorScheme.BRAND_ORANGE);
		if (currentDataRange == null || currentDataRange.isEmpty())
		{
			result.setText("No Data available for selected range");
			return result;
		}

		LocalDateTime start = Collections.min(currentDataRange.keySet());
		LocalDateTime end = Collections.max(currentDataRange.keySet());

		long startValue = currentDataRange.get(start);
		long endValue = currentDataRange.get(end);
		long finishValue = endValue - startValue;
		DecimalFormat decimalFormat = new DecimalFormat();
		decimalFormat.setRoundingMode(RoundingMode.DOWN);

		String percentChange = decimalFormat.format((endValue - startValue) / (double) Math.abs(startValue) * 100);
		String formattedValue = QuantityFormatter.quantityToStackSize(finishValue);
		String formattedString = "No Change";
		if (finishValue < 0)
		{
			formattedString = formattedValue + " (" + percentChange + "%)";
			result.setForeground(ColorScheme.PROGRESS_ERROR_COLOR);
		}
		else if (finishValue > 0)
		{
			formattedString = formattedValue + " (+ " + percentChange + "%)";
			result.setForeground(ColorScheme.GRAND_EXCHANGE_PRICE);
		}

		result.setText(formattedString);
		return result;
	}

	public void loadGraph(String username)
	{
		dataset = getDataset(username);
		ChartFactory.setChartTheme(StandardChartTheme.createDarknessTheme());
		chart = ChartFactory.createTimeSeriesChart(
			null,
			"Date/time",
			"Bank Value (mil)",
			dataset,
			false,
			true,
			false);

		XYPlot plot = chart.getXYPlot();
		XYItemRenderer r = plot.getRenderer();
		if (r instanceof XYLineAndShapeRenderer)
		{
			XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer) r;
			renderer.setBaseShapesVisible(true);
			renderer.setBaseShapesFilled(true);
		}
		plot.setBackgroundPaint(ColorScheme.DARKER_GRAY_HOVER_COLOR);
		chart.setBackgroundPaint(ColorScheme.DARK_GRAY_HOVER_COLOR);
		if (graphPanel != null)
		{
			remove(graphPanel);
		}

		graphPanel = new ChartPanel(chart);
		graphPanel.setBorder(new EmptyBorder(2, 2, 2, 2));
		graphPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);

		add(graphPanel, BorderLayout.SOUTH);
		revalidate();
		repaint();
	}

	private TimeSeriesCollection getDataset(String username)
	{
		BankValueHistoryContainer container = tracker.getBankValueHistory(username);
		TimeSeriesCollection collection = new TimeSeriesCollection();

		if (container == null)
		{
			return collection;
		}

		TimeSeries timeSeries = new TimeSeries("bankValueVsTime");
		Map<LocalDateTime, Long> currentDataRange = new HashMap<>();
		for (Map.Entry<LocalDateTime, BankValue> entry : container.getPricesMap().entrySet())
		{
			long price = entry.getValue().getBankValue();

			LocalDateTime entryDateTime = entry.getKey();
			LocalDateTime start;
			LocalDateTime end;

			if (timeSelection != null)
			{
				start = SimpleTimeSelection.getPastTime(timeSelection);
				end = LocalDateTime.now();
			}
			else
			{
				start = startDatePickerPanel.getLocalDateTime();
				end = toDatePickerPanel.getLocalDateTime();
			}

			if ((currentBankTab != -1 && currentBankTab == entry.getValue().getTab()) &&
				(timeSelection == SimpleTimeSelection.ALL ||
				end != null && start != null && onOrAfter(entryDateTime, start) && onOrBefore(entryDateTime, end)))
			{
				currentDataRange.put(entryDateTime.atZone(ZoneId.systemDefault()).toLocalDateTime(), price);
				timeSeries.add(new Millisecond(Date.from(entryDateTime.atZone(ZoneId.systemDefault()).toInstant())), price);
			}
		}

		this.currentDataRange = currentDataRange;
		collection.addSeries(timeSeries);

		return collection;
	}

	@Subscribe
	public void onScriptCallbackEvent(ScriptCallbackEvent event)
	{
		if ("setBankTitle".equals(event.getEventName()))
		{
			addDatasetButton.setEnabled(true);
		}
	}

	private boolean onOrBefore(LocalDateTime first, LocalDateTime second)
	{
		return first.compareTo(second) == 0 || first.isBefore(second);
	}

	private boolean onOrAfter(LocalDateTime first, LocalDateTime second)
	{
		return first.compareTo(second) == 0 || first.isAfter(second);
	}

	protected void setDatasetButton(boolean enabled)
	{
		if (addDatasetButton != null && addDatasetButton.isEnabled() != enabled)
		{
			addDatasetButton.setEnabled(enabled);
		}
	}

	@RequiredArgsConstructor
	private enum SimpleTimeSelection
	{
		ALL("All"),
		TODAY("Today"),
		HOUR("1 hour"),
		TWO_HOURS("2 Hours"),
		THREE_HOURS("4 Hours"),
		EIGHT_HOURS("8 Hours"),
		TWENTY_FOUR_HOURS("24 Hours"),
		WEEK("Week"),
		MONTH("Month"),
		SIX_MONTHS("6 Months"),
		YEAR("Year");

		@Getter
		private final String formattedName;

		/**
		 * Get a date/time that is {@link TimeSeriesCollection} in the past from now.
		 *
		 * @param timeSelection human-readable unit of time to go back to.
		 * @return
		 */
		static LocalDateTime getPastTime(SimpleTimeSelection timeSelection)
		{
			LocalDateTime dateTime = LocalDateTime.now();

			switch (timeSelection)
			{
				case ALL:
					return null;
				case TODAY:
					LocalDate date = LocalDate.now();
					return date.atStartOfDay();
				case HOUR:
					return dateTime.minusHours(1);
				case TWO_HOURS:
					return dateTime.minusHours(2);
				case THREE_HOURS:
					return dateTime.minusHours(3);
				case EIGHT_HOURS:
					return dateTime.minusHours(8);
				case TWENTY_FOUR_HOURS:
					return dateTime.minusDays(1);
				case WEEK:
					return dateTime.minusWeeks(1);
				case MONTH:
					return dateTime.minusMonths(1);
				case SIX_MONTHS:
					return dateTime.minusMonths(6);
				case YEAR:
					return dateTime.minusYears(1);
				default:
					throw new IllegalArgumentException("Unable to get past time");
			}
		}

		public static SimpleTimeSelection of(String item)
		{
			for (SimpleTimeSelection t : SimpleTimeSelection.values())
			{
				if (t.getFormattedName().equals(item))
				{
					return t;
				}
			}

			throw new IllegalArgumentException("no SimpleTimeSelection of " + item + " found.");
		}
	}
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import lombok.Data;
import lombok.RequiredArgsConstructor;

/**
 * Wraps a collection of prices mapped to the time recorded.
 */
@Data
@RequiredArgsConstructor
public class BankValueHistoryContainer
{
	private final Map<LocalDateTime, BankValue> pricesMap;

	public BankValueHistoryContainer()
	{
		this(new HashMap<>());
	}

	public void addPrice(BankValue bankValue)
	{
		pricesMap.put(LocalDateTime.now(), bankValue);
	}
}

/*
 * Copyright (c) 2020, Adrian Lee Elder <https://github.com/AdrianLeeElder>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import com.google.common.collect.ImmutableList;
import com.google.gson.Gson;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonParseException;
import com.google.inject.Provides;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Type;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import javax.inject.Inject;
import lombok.NonNull;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemContainer;
import net.runelite.api.Varbits;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.http.api.RuneLiteAPI;

/**
 * Track the change in bank value overtime. Caches values locally.
 */
@Slf4j
public class BankValueHistoryTracker
{
	private static final List<Integer> TAB_VARBITS = ImmutableList.of(
		Varbits.BANK_TAB_ONE_COUNT,
		Varbits.BANK_TAB_TWO_COUNT,
		Varbits.BANK_TAB_THREE_COUNT,
		Varbits.BANK_TAB_FOUR_COUNT,
		Varbits.BANK_TAB_FIVE_COUNT,
		Varbits.BANK_TAB_SIX_COUNT,
		Varbits.BANK_TAB_SEVEN_COUNT,
		Varbits.BANK_TAB_EIGHT_COUNT,
		Varbits.BANK_TAB_NINE_COUNT
	);

	private static final File HISTORY_CACHE;
	private static final Gson GSON =
			RuneLiteAPI.GSON.newBuilder().registerTypeAdapter(BankValueHistoryContainer.class,
					new BankValueHistoryDeserializer()).registerTypeAdapter(LocalDateTime.class, new JsonDeserializer<LocalDateTime>() {
				@Override
				public LocalDateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
					return LocalDateTime.parse(json.getAsString(), DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm"));
				}
			}).create();
	private static final String EXTENTION = ".json";

	@Inject
	private Client client;
	@Inject
	private ClientThread clientThread;
	@Inject
	private BankHistoryConfig config;

	@Inject
	private ContainerCalculation bankCalculation;

	@Provides
	BankHistoryConfig getConfig(ConfigManager configManager)
	{
		return configManager.getConfig(BankHistoryConfig.class);
	}

	static
	{
		HISTORY_CACHE = new File(RuneLite.RUNELITE_DIR, "bank-value-tracker");
		HISTORY_CACHE.mkdirs();
	}

	/**
	 * Adds a group of prices to a local file cache. Uses a configuration
	 * to determine update frequency.
	 *
	 * @param bankValue current bank value
	 */
	public void add(String username, BankValue bankValue)
	{
		BankValueHistoryContainer valueHistory = getBankValueHistory(username);
		if (valueHistory != null)
		{
			valueHistory.addPrice(bankValue);
			try (FileWriter writer = new FileWriter(getFileForUser(username)))
			{
				GSON.toJson(valueHistory, writer);
			}
			catch (IOException e)
			{
				log.error("Unable to write to price value cache", e);
			}

			log.debug("Adding bank value history entry {}", valueHistory);
		}
	}

	/**
	 * Gets the current bank value history from disk.
	 *
	 * @param username username associated with the bank value.
	 * @return the retrieved bank value
	 */
	public BankValueHistoryContainer getBankValueHistory(String username)
	{
		try
		{
			File playerHistoryFile = getFileForUser(username);

			try (FileReader reader = new FileReader(getFileForUser(username)))
			{
				log.debug("Creating bank history cache file at {}", playerHistoryFile.getAbsolutePath());
				BankValueHistoryContainer container = GSON.fromJson(reader, BankValueHistoryContainer.class);
				if (container == null)
				{
					return new BankValueHistoryContainer();
				}

				return container;
			}
		}
		catch (IOException e)
		{
			log.error("Error reading/writing to the cache files", e);
		}

		return null;
	}

	/**
	 * Get the data file for a specific user
	 *
	 * @param username user to get the data for
	 * @return data file for user
	 */
	public File getFileForUser(@NonNull String username) throws IOException
	{
		File file = new File(HISTORY_CACHE, username + EXTENTION);

		if (!file.exists())
		{
			file.createNewFile();
		}

		return file;
	}


	/**
	 * Get all accounts that have tracking data from the local file cache.
	 *
	 * @return available accounts with data
	 */
	public List<String> getAvailableUsers()
	{
		List<String> result = new ArrayList<>();
		File[] accountFiles = HISTORY_CACHE.listFiles();
		if (accountFiles == null)
		{
			return result;
		}

		for (File file : accountFiles)
		{
			result.add(file.getName().replace(EXTENTION, ""));
		}

		return result;
	}

	/**
	 * Gets the last time something was added to the file cache.
	 *
	 * @param username
	 * @return
	 */
	public LocalDateTime getLastDataEntry(String username, int tab)
	{
		BankValueHistoryContainer container = getBankValueHistory(username);
		Set<LocalDateTime> times =
			container
			.getPricesMap()
				.entrySet()
				.parallelStream()
				.filter(bv -> bv.getValue().getTab() == tab)
				.map(Map.Entry::getKey)
				.collect(Collectors.toSet());

		if (times == null || times.isEmpty())
		{
			return null;
		}

		return Collections.max(times);
	}

	/**
	 * Add a new dataset entry.
	 *
	 * @param force force a new entry, regardless of user configuration or last entry time.
	 */
	public void addEntry(boolean force, Consumer<String> callback)
	{
		clientThread.invokeLater(() ->
		{
			int currentBankTab = client.getVarbitValue(Varbits.CURRENT_BANK_TAB);
			LocalDateTime lastEntry = getLastDataEntry(client.getLocalPlayer().getName(), currentBankTab);
			LocalDateTime nextUpdateTime = LocalDateTime.of(0, 1, 1, 0, 0);
			if (lastEntry != null)
			{
				nextUpdateTime = lastEntry.plusHours(config.getDefaultDatasetEntry());
			}

			if (config.getOnlyManualEntries() && !force)
			{
				callback.accept("Automatic entries are currently disabled");

				return;
			}

			if (force || lastEntry == null || LocalDateTime.now().isAfter(nextUpdateTime))
			{
				Item[] items = getBankTabItems();
				if (items != null) {
					BankValueHistoryTracker.this.add(client.getLocalPlayer().getName(),
						BankValue
							.builder()
							.tab(client.getVarbitValue(Varbits.CURRENT_BANK_TAB))
							.bankValue(bankCalculation.calculate(items))
							.build());
				}

				if (callback != null)
				{
					callback.accept("New entry added!");
				}
			}
			else
			{
				if (callback != null)
				{
					callback.accept("No entry added.");
				}
			}
		});
	}

	public void addEntry()
	{
		addEntry(false, null);
	}

	private Item[] getBankTabItems()
	{
		final ItemContainer container = client.getItemContainer(InventoryID.BANK);
		if (container == null)
		{
			return null;
		}

		final Item[] items = container.getItems();
		int currentTab = client.getVarbitValue(Varbits.CURRENT_BANK_TAB);

		if (currentTab > 0)
		{
			int startIndex = 0;

			for (int i = currentTab - 1; i > 0; i--)
			{
				startIndex += client.getVarbitValue(TAB_VARBITS.get(i - 1));
			}

			int itemCount = client.getVarbitValue(TAB_VARBITS.get(currentTab - 1));
			return Arrays.copyOfRange(items, startIndex, startIndex + itemCount);
		}

		return items;
	}

}

/*
 * Copyright (c) 2019, TheStonedTurtle <https://github.com/TheStonedTurtle>
 * Copyright (c) 2019, Adam <Adam@sigterm.info>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.adriansoftware;

import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import javax.inject.Inject;
import net.runelite.api.Item;
import net.runelite.api.ItemID;
import net.runelite.client.game.ItemManager;

class ContainerCalculation
{
	private final ItemManager itemManager;
	private int hash;
	private Long gePrice;

	@Inject
	private ContainerCalculation(ItemManager itemManager)
	{
		this.itemManager = itemManager;
	}

	@Nullable
	long calculate(Item[] items)
	{
		// Returns last calculation if inventory hasn't changed
		final int newHash =  hashItems(items);
		if (gePrice != null && hash == newHash)
		{
			return gePrice;
		}

		hash = newHash;

		long ge = 0;

		for (final Item item : items)
		{
			final int qty = item.getQuantity();
			final int id = item.getId();

			if (id <= 0 || qty == 0)
			{
				continue;
			}

			switch (id)
			{
				case ItemID.COINS_995:
					ge += qty;
					break;
				case ItemID.PLATINUM_TOKEN:
					ge += qty * 1000L;
					break;
				default:
					ge += (long) itemManager.getItemPrice(id) * qty;
					break;
			}
		}

		return ge;
	}

	private int hashItems(final Item[] items)
	{
		final Map<Integer, Integer> mapCheck = new HashMap<>(items.length);
		for (Item item : items)
		{
			mapCheck.put(item.getId(), item.getQuantity());
		}

		return mapCheck.hashCode();
	}
}


