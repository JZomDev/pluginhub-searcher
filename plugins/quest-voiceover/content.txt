package com.quest.voiceover.features;

import com.quest.voiceover.QuestVoiceoverConfig;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.HashSet;
import java.util.Set;

@Singleton
public class QuestListIndicatorHandler {

    private static final int QUEST_LIST_CONTAINER_COMPONENT = 7;
    private static final int WIDGET_TYPE_TEXT = 4;
    private static final int TICKS_BEFORE_ADDING_INDICATORS = 2;
    private static final String SHORT_PREFIX = "[V] ";
    private static final String LONG_PREFIX = "[Voiced] ";

    @Inject
    private Client client;

    @Inject
    private QuestVoiceoverConfig config;

    private Set<String> voicedQuests = new HashSet<>();
    private boolean isQuestListVisible;
    private int ticksSinceOpened;

    public void setVoicedQuests(Set<String> voicedQuests) {
        this.voicedQuests = voicedQuests;
    }

    public void onQuestListOpened() {
        isQuestListVisible = true;
        ticksSinceOpened = 0;
    }

    public void onQuestListClosed() {
        isQuestListVisible = false;
    }

    public void onGameTick() {
        if (!isQuestListVisible) {
            return;
        }

        ticksSinceOpened++;

        if (ticksSinceOpened >= TICKS_BEFORE_ADDING_INDICATORS) {
            if (config.showVoicedIndicator()) {
                updateVoiceIndicators();
            } else {
                removeVoiceIndicators();
            }
        }
    }

    private void updateVoiceIndicators() {
        if (voicedQuests.isEmpty() || !isQuestListActuallyVisible()) {
            return;
        }

        Widget questListContainer = client.getWidget(InterfaceID.QUEST_LIST, QUEST_LIST_CONTAINER_COMPONENT);
        if (questListContainer == null || questListContainer.getChildren() == null) {
            return;
        }

        Point mousePosition = client.getMouseCanvasPosition();
        updateQuestWidgets(questListContainer.getChildren(), mousePosition);
    }

    private void removeVoiceIndicators() {
        if (!isQuestListActuallyVisible()) {
            return;
        }

        Widget questListContainer = client.getWidget(InterfaceID.QUEST_LIST, QUEST_LIST_CONTAINER_COMPONENT);
        if (questListContainer == null || questListContainer.getChildren() == null) {
            return;
        }

        for (Widget questWidget : questListContainer.getChildren()) {
            if (!isTextWidget(questWidget)) {
                continue;
            }

            String currentText = questWidget.getText();
            if (hasVoicePrefix(currentText)) {
                questWidget.setText(extractQuestName(currentText));
                questWidget.revalidate();
            }
        }
    }

    private boolean hasVoicePrefix(String text) {
        return text != null && (text.startsWith(SHORT_PREFIX) || text.startsWith(LONG_PREFIX));
    }

    private boolean isQuestListActuallyVisible() {
        Widget questListPanel = client.getWidget(InterfaceID.QUEST_LIST, 0);

        if (questListPanel == null || questListPanel.isHidden()) {
            return false;
        }

        return questListPanel.getCanvasLocation() != null && questListPanel.getWidth() > 0;
    }

    private void updateQuestWidgets(Widget[] questWidgets, Point mousePosition) {
        for (Widget questWidget : questWidgets) {
            if (!isTextWidget(questWidget)) {
                continue;
            }

            String currentText = questWidget.getText();
            String questName = extractQuestName(currentText);

            if (!isVoicedQuest(questName)) {
                continue;
            }

            boolean isHovered = isMouseOverWidget(questWidget, mousePosition);
            String expectedPrefix = isHovered ? LONG_PREFIX : SHORT_PREFIX;
            String expectedText = expectedPrefix + questName;

            if (!currentText.equals(expectedText)) {
                questWidget.setText(expectedText);
                questWidget.revalidate();
            }
        }
    }

    private String extractQuestName(String text) {
        if (text == null) {
            return null;
        }
        if (text.startsWith(LONG_PREFIX)) {
            return text.substring(LONG_PREFIX.length());
        }
        if (text.startsWith(SHORT_PREFIX)) {
            return text.substring(SHORT_PREFIX.length());
        }
        return text;
    }

    private boolean isVoicedQuest(String questName) {
        return questName != null && voicedQuests.contains(questName);
    }

    private boolean isMouseOverWidget(Widget widget, Point mousePosition) {
        Rectangle bounds = widget.getBounds();
        if (bounds == null || mousePosition == null) {
            return false;
        }
        return bounds.contains(mousePosition.getX(), mousePosition.getY());
    }

    private boolean isTextWidget(Widget widget) {
        return widget != null && widget.getType() == WIDGET_TYPE_TEXT;
    }
}

package com.quest.voiceover.features;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.modules.audio.SoundEngine;
import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.dialog.DialogManager;
import com.quest.voiceover.utility.MessageParser;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

@Slf4j
@Singleton
public class VoiceoverHandler {

    private static final double LEVENSHTEIN_THRESHOLD = 0.70;

    private static final String EXACT_QUERY =
        "SELECT quest, uri, text FROM dialogs WHERE character = ? AND text = ? LIMIT 1";

    private static final String LEVENSHTEIN_QUERY =
        "SELECT quest, uri, text, levenshtein_similarity(text, ?) AS similarity " +
        "FROM dialogs WHERE character = ? " +
        "ORDER BY similarity DESC LIMIT 1";

    @Inject
    private ClientThread clientThread;

    @Inject
    private DatabaseManager databaseManager;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private DialogManager dialogManager;

    @Inject
    private QuestVoiceoverConfig config;

    @Getter
    private boolean activeVoiceover;

    @Getter
    private String currentQuestName;

    private String pendingCharacter;
    private String pendingPlayerName;

    public void handleDialogMessage(String rawMessage, String playerName) {
        MessageParser chatMessage = new MessageParser(rawMessage, playerName);
        String chatText = chatMessage.getDialogText();
        String chatCharacter = chatMessage.getCharacterName();

        String widgetText = dialogManager.getDialogText();
        String widgetCharacter = dialogManager.getDialogCharacterName(playerName);

        if (widgetText != null && widgetCharacter != null) {
            String cleanedWidgetText = cleanWidgetText(widgetText, playerName);

            if (cleanedWidgetText.startsWith(chatText) || chatText.startsWith(cleanedWidgetText)) {
                playVoiceoverIfAvailable(widgetCharacter, cleanedWidgetText);
            } else {
                log.debug("Widget text mismatch, scheduling retry");
                pendingCharacter = chatCharacter;
                pendingPlayerName = playerName;
                clientThread.invokeLater(this::retryWithWidget);
            }
        } else {
            log.debug("Widget not available, scheduling retry");
            pendingCharacter = chatCharacter;
            pendingPlayerName = playerName;
            clientThread.invokeLater(this::retryWithWidget);
        }
    }

    private void retryWithWidget() {
        if (pendingCharacter == null) {
            return;
        }

        String widgetText = dialogManager.getDialogText();
        String widgetCharacter = dialogManager.getDialogCharacterName(pendingPlayerName);

        if (widgetText != null && widgetCharacter != null) {
            String cleanedWidgetText = cleanWidgetText(widgetText, pendingPlayerName);
            playVoiceoverIfAvailable(widgetCharacter, cleanedWidgetText);
        } else {
            log.debug("Widget retry failed");
        }

        pendingCharacter = null;
        pendingPlayerName = null;
    }

    private String cleanWidgetText(String text, String playerName) {
        String cleaned = text
            .replaceAll("<br>", " ")
            .replaceAll("<col=[^>]*>", "")
            .replaceAll("</col>", "")
            .trim();

        if (playerName != null && !playerName.isEmpty()) {
            cleaned = cleaned.replace(playerName, "");
        }

        return cleaned;
    }

    public void handleDialogOpened() {
        if (!dialogManager.isPlayerOrNpcDialogOpen() || !activeVoiceover) {
            return;
        }
        addDialogOverlay();
    }

    private void addDialogOverlay() {
        Widget dialogWidget = dialogManager.getActiveDialogWidget();
        if (dialogWidget == null) {
            return;
        }

        if (config.showMuteButton()) {
            dialogManager.addMuteButton(dialogWidget);
        }

        if (config.showQuestName() && currentQuestName != null) {
            dialogManager.addQuestNameLabel(dialogWidget, currentQuestName);
        }
    }

    public void stopVoiceover() {
        activeVoiceover = false;
        soundEngine.stop();
    }

    /**
     * Query stages (in order of speed/accuracy tradeoff):
     * 1. Exact match - fastest, handles most cases where wiki text matches game text
     * 2. Levenshtein similarity - handles word substitutions (e.g., "called" vs "named")
     *    where wiki transcript differs from actual in-game text
     */
    private void playVoiceoverIfAvailable(String characterName, String dialogText) {
        String escapedCharacter = escapeQuotes(characterName);
        String escapedText = escapeQuotes(dialogText);

        if (tryExactQuery(escapedCharacter, escapedText, characterName, dialogText)) {
            return;
        }

        if (tryLevenshteinQuery(escapedCharacter, escapedText, characterName, dialogText)) {
            return;
        }

        log.info("No voiceover found for {} - '{}'", characterName, dialogText);
        activeVoiceover = false;
    }

    private boolean tryExactQuery(String escapedCharacter, String escapedText, String characterName, String dialogText) {
        try (PreparedStatement statement = databaseManager.prepareStatement(EXACT_QUERY)) {
            statement.setString(1, escapedCharacter);
            statement.setString(2, escapedText);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    log.debug("Match type: exact");
                    return playVoiceoverFromResult(resultSet, characterName, dialogText);
                }
            }
        } catch (SQLException e) {
            log.error("Database query failed (exact)", e);
        }
        return false;
    }

    private boolean tryLevenshteinQuery(String escapedCharacter, String escapedText, String characterName, String dialogText) {
        try (PreparedStatement statement = databaseManager.prepareStatement(LEVENSHTEIN_QUERY)) {
            statement.setString(1, escapedText);
            statement.setString(2, escapedCharacter);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    double similarity = resultSet.getDouble("similarity");
                    if (similarity >= LEVENSHTEIN_THRESHOLD) {
                        log.debug("Match type: levenshtein ({}%)", String.format("%.1f", similarity * 100));
                        return playVoiceoverFromResult(resultSet, characterName, dialogText);
                    }
                    String bestMatchText = resultSet.getString("text");
                    log.info("Levenshtein match below threshold ({}%) for {} - '{}' best match: '{}'",
                        String.format("%.1f", similarity * 100), characterName, dialogText, bestMatchText);
                }
            }
        } catch (SQLException e) {
            log.error("Database query failed (Levenshtein)", e);
        }
        return false;
    }

    private boolean playVoiceoverFromResult(ResultSet resultSet, String characterName, String dialogText) throws SQLException {
        String audioUri = resultSet.getString("uri");
        currentQuestName = resultSet.getString("quest");
        String matchedText = resultSet.getString("text");
        log.info("Playing voiceover: {} - {} - '{}' matched: '{}'", characterName, currentQuestName, dialogText, matchedText);

        if (audioUri != null || currentQuestName != null) {
            activeVoiceover = true;
            soundEngine.play(audioUri);
            addDialogOverlay();
            return true;
        }
        return false;
    }

    private String escapeQuotes(String input) {
        return input.replace("'", "''");
    }
}

package com.quest.voiceover.modules.database;

import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;

@Slf4j
public class DatabaseVersionManager {

    private static final String DATABASE_FILENAME = "quest_voiceover.db";
    private static final String VERSION_FILENAME = ".version";

    private static final HttpUrl RAW_GITHUB_DATABASE_URL =
        HttpUrl.parse("https://github.com/KevinEdry/runelite-quest-voiceover/raw/database");

    private static final Path DOWNLOAD_DIR =
        Path.of(RuneLite.RUNELITE_DIR.getPath(), "quest-voiceover");

    private static final Path VERSION_FILE = DOWNLOAD_DIR.resolve(VERSION_FILENAME);
    private static final Path DATABASE_FILE = DOWNLOAD_DIR.resolve(DATABASE_FILENAME);

    public static String getDatabaseVersion() {
        String version = readVersionFile();
        if (version.isEmpty()) {
            return "Unknown";
        }
        return version.replace("\"", "").substring(0, 7);
    }

    public static void prepareDatabaseSource(OkHttpClient okHttpClient) {
        ensureDownloadDirectoryExists();
        downloadOrUpdateDatabase(okHttpClient);
    }

    public static String getDatabasePath() throws FileNotFoundException {
        if (!Files.exists(DATABASE_FILE)) {
            throw new FileNotFoundException("Database file not found: " + DATABASE_FILE);
        }
        return DATABASE_FILE.toString();
    }

    private static void ensureDownloadDirectoryExists() {
        try {
            Files.createDirectories(DOWNLOAD_DIR);
        } catch (IOException e) {
            log.error("Failed to create download directory", e);
        }
    }

    private static void downloadOrUpdateDatabase(OkHttpClient okHttpClient) {
        try {
            String currentVersion = readVersionFile();
            HttpUrl downloadUrl = buildDownloadUrl();

            Request headRequest = new Request.Builder()
                .url(downloadUrl)
                .header("If-None-Match", currentVersion)
                .head()
                .build();

            try (Response headResponse = okHttpClient.newCall(headRequest).execute()) {
                if (headResponse.code() == 304) {
                    return;
                }

                String remoteEtag = headResponse.header("ETag");
                if (remoteEtag == null) {
                    log.warn("No ETag header in remote response");
                    return;
                }

                if (shouldDownload(remoteEtag, currentVersion)) {
                    downloadDatabase(okHttpClient, downloadUrl, remoteEtag);
                }
            }
        } catch (IOException e) {
            log.error("Failed to download or update database", e);
        }
    }

    private static boolean shouldDownload(String remoteEtag, String currentVersion) {
        return !Files.exists(DATABASE_FILE) || !remoteEtag.equals(currentVersion);
    }

    private static void downloadDatabase(OkHttpClient client, HttpUrl url, String version) throws IOException {
        log.info("Downloading new database version: {}", version);

        Request request = new Request.Builder().url(url).build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful() || response.body() == null) {
                log.error("Failed to download database: {}", response.message());
                return;
            }

            try (InputStream inputStream = response.body().byteStream()) {
                Files.copy(inputStream, DATABASE_FILE, StandardCopyOption.REPLACE_EXISTING);
                writeVersionFile(version);
                log.info("Database updated successfully");
            }
        }
    }

    private static HttpUrl buildDownloadUrl() {
        return RAW_GITHUB_DATABASE_URL.newBuilder()
            .addPathSegment(DATABASE_FILENAME)
            .build();
    }

    private static String readVersionFile() {
        try {
            if (Files.exists(VERSION_FILE)) {
                return Files.readString(VERSION_FILE).trim();
            }
        } catch (IOException e) {
            log.error("Failed to read version file", e);
        }
        return "";
    }

    private static void writeVersionFile(String version) {
        try {
            Files.writeString(VERSION_FILE, version,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE,
                StandardOpenOption.TRUNCATE_EXISTING);
        } catch (IOException e) {
            log.error("Failed to write version file", e);
        }
    }
}

package com.quest.voiceover.modules.database.functions;

import com.quest.voiceover.utility.LevenshteinUtility;
import lombok.extern.slf4j.Slf4j;
import org.sqlite.Function;

import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
public class LevenshteinFunction {

    public static void register(Connection connection) throws SQLException {
        Function.create(connection, "levenshtein", new Function() {
            @Override
            protected void xFunc() throws SQLException {
                String source = value_text(0);
                String target = value_text(1);

                if (source == null || target == null) {
                    result(Integer.MAX_VALUE);
                    return;
                }

                result(LevenshteinUtility.distance(source, target));
            }
        });

        Function.create(connection, "levenshtein_similarity", new Function() {
            @Override
            protected void xFunc() throws SQLException {
                String source = value_text(0);
                String target = value_text(1);

                if (source == null || target == null) {
                    result(0.0);
                    return;
                }

                result(LevenshteinUtility.similarity(source, target));
            }
        });

        log.debug("Registered Levenshtein SQL functions");
    }
}

package com.quest.voiceover.modules.database;

import com.quest.voiceover.modules.database.functions.LevenshteinFunction;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.io.FileNotFoundException;
import java.sql.*;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class DatabaseManager {

    private static final String SQL_PATH_PREFIX = "jdbc:sqlite:";

    private Connection connection;

    public void initializeConnection() {
        getConnection();
    }

    public boolean isConnected() {
        try {
            return connection != null && !connection.isClosed();
        } catch (SQLException e) {
            return false;
        }
    }

    public void closeConnection() throws SQLException {
        if (connection != null) {
            connection.close();
        }
    }

    public PreparedStatement prepareStatement(String query) throws SQLException {
        return getConnection().prepareStatement(query);
    }

    public Set<String> getVoicedQuests() {
        Set<String> voicedQuests = new HashSet<>();

        try (PreparedStatement statement = prepareStatement("SELECT DISTINCT quest FROM dialogs");
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                voicedQuests.add(resultSet.getString("quest"));
            }
        } catch (SQLException e) {
            log.error("Failed to query voiced quests", e);
        }

        return voicedQuests;
    }

    private Connection getConnection() {
        if (connection != null) {
            return connection;
        }

        try {
            Class.forName("org.sqlite.JDBC");
            String databasePath = DatabaseVersionManager.getDatabasePath();
            connection = DriverManager.getConnection(SQL_PATH_PREFIX + databasePath);
            LevenshteinFunction.register(connection);
            log.info("Established connection to voiceover database");
        } catch (FileNotFoundException e) {
            log.error("Database file not found", e);
        } catch (SQLException e) {
            log.error("Failed to connect to database", e);
        } catch (ClassNotFoundException e) {
            log.error("SQLite JDBC driver not found", e);
            throw new RuntimeException(e);
        }

        return connection;
    }
}

package com.quest.voiceover.modules.audio;

import com.quest.voiceover.QuestVoiceoverConfig;
import jaco.mp3.player.MP3Player;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;
import okhttp3.HttpUrl;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.net.URL;

@Slf4j
@Singleton
public class SoundEngine {

    private static final HttpUrl RAW_GITHUB_SOUND_BRANCH_URL =
        HttpUrl.parse("https://github.com/KevinEdry/runelite-quest-voiceover/raw/sounds");
    private static final int PLAYBACK_GRACE_PERIOD_TICKS = 1;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private Client client;

    private volatile MP3Player player;
    private volatile boolean soundPlaying;
    private int playbackStartTick;

    public void play(String fileName) {
        stopPlayback();

        if (fileName == null || fileName.isEmpty()) {
            log.warn("Attempted to play null or empty fileName");
            return;
        }

        URL soundUrl = buildSoundUrl(fileName);
        MP3Player currentPlayer = getOrCreatePlayer();

        int volume = config.mute() ? 0 : config.volume();
        currentPlayer.setVolume(volume);
        currentPlayer.add(soundUrl);
        currentPlayer.play();

        soundPlaying = true;
        playbackStartTick = client.getTickCount();
        log.debug("Playing audio: {}", fileName);
    }

    public void stop() {
        int currentTick = client.getTickCount();
        boolean pastGracePeriod = currentTick > playbackStartTick + PLAYBACK_GRACE_PERIOD_TICKS;
        if (pastGracePeriod) {
            stopPlayback();
        }
    }

    public void stopImmediately() {
        stopPlayback();
    }

    public void setVolume(int volume) {
        getOrCreatePlayer().setVolume(volume);
    }

    public boolean isPlaying() {
        return soundPlaying && player != null && !player.isStopped();
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (player != null && soundPlaying && player.isStopped()) {
            soundPlaying = false;
        }
    }

    private void stopPlayback() {
        if (player == null) {
            return;
        }

        boolean wasPlaying = player.isPlaying();
        soundPlaying = false;
        player.clearPlayList();

        if (wasPlaying) {
            player.stop();
        }
    }

    private URL buildSoundUrl(String fileName) {
        return RAW_GITHUB_SOUND_BRANCH_URL.newBuilder()
            .addPathSegment(fileName)
            .build()
            .url();
    }

    private MP3Player getOrCreatePlayer() {
        if (player == null) {
            synchronized (this) {
                if (player == null) {
                    player = new MP3Player();
                }
            }
        }
        return player;
    }
}

package com.quest.voiceover.modules.dialog;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.modules.audio.SoundEngine;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.*;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class DialogManager {

    private static final String TOGGLE_MUTE_ACTION = "Toggle mute ";
    private static final String PLUGIN_CONFIG_GROUP = "quest.voiceover";
    private static final int FONT_ID = 494;
    private static final int TEXT_COLOR_WHITE = 0xFFFFFF;

    private static final int DIALOG_NPC_TEXT_CHILD = 6;
    private static final int DIALOG_NPC_NAME_CHILD = 4;
    private static final int DIALOG_PLAYER_TEXT_CHILD = 6;

    @Inject
    private Client client;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private SoundEngine soundEngine;

    public boolean isPlayerOrNpcDialogOpen() {
        Widget playerWidget = getPlayerDialogWidget();
        if (playerWidget != null && !playerWidget.isHidden()) {
            return true;
        }

        Widget npcWidget = getNpcDialogWidget();
        return npcWidget != null && !npcWidget.isHidden();
    }

    public Widget getActiveDialogWidget() {
        if (!isPlayerOrNpcDialogOpen()) {
            return null;
        }

        Widget playerWidget = getPlayerDialogWidget();
        return playerWidget != null ? playerWidget : getNpcDialogWidget();
    }

    public void addQuestNameLabel(Widget dialogWidget, String questName) {
        Widget label = dialogWidget.createChild(-1, WidgetType.TEXT);

        label.setText("Quest: " + questName);
        label.setFontId(FONT_ID);
        label.setTextColor(TEXT_COLOR_WHITE);
        label.setTextShadowed(true);
        label.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
        label.setOriginalX(10);
        label.setOriginalY(5);
        label.setOriginalHeight(20);
        label.setOriginalWidth(200);
        label.revalidate();
    }

    public void addMuteButton(Widget dialogWidget) {
        Widget muteButton = dialogWidget.createChild(-1, WidgetType.GRAPHIC);

        muteButton.setSpriteId(getMuteSpriteId());
        muteButton.setOriginalWidth(32);
        muteButton.setOriginalHeight(32);
        muteButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
        muteButton.setOriginalX(5);
        muteButton.setOriginalY(5);
        muteButton.setHasListener(true);
        muteButton.setAction(1, TOGGLE_MUTE_ACTION);
        muteButton.setOnOpListener((JavaScriptCallback) e -> toggleMute(muteButton));
        muteButton.revalidate();
    }

    public String getDialogText() {
        Widget npcTextWidget = client.getWidget(InterfaceID.DIALOG_NPC, DIALOG_NPC_TEXT_CHILD);
        if (npcTextWidget != null) {
            return npcTextWidget.getText();
        }

        Widget playerTextWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, DIALOG_PLAYER_TEXT_CHILD);
        if (playerTextWidget != null) {
            return playerTextWidget.getText();
        }

        return null;
    }

    public String getDialogCharacterName(String playerName) {
        Widget npcNameWidget = client.getWidget(InterfaceID.DIALOG_NPC, DIALOG_NPC_NAME_CHILD);
        if (npcNameWidget != null) {
            return npcNameWidget.getText();
        }

        Widget playerTextWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, DIALOG_PLAYER_TEXT_CHILD);
        if (playerTextWidget != null) {
            return "Player";
        }

        return null;
    }

    private Widget getPlayerDialogWidget() {
        return client.getWidget(InterfaceID.DIALOG_PLAYER, 0);
    }

    private Widget getNpcDialogWidget() {
        return client.getWidget(InterfaceID.DIALOG_NPC, 0);
    }

    private void toggleMute(Widget muteButton) {
        configManager.setConfiguration(PLUGIN_CONFIG_GROUP, "mute", !config.mute());
        soundEngine.setVolume(config.mute() ? 0 : config.volume());
        muteButton.setSpriteId(getMuteSpriteId());
        muteButton.revalidate();
    }

    private int getMuteSpriteId() {
        return config.mute() ? SpriteID.OPTIONS_MUSIC_DISABLED : SpriteID.OPTIONS_MUSIC_VOLUME;
    }
}

package com.quest.voiceover;

import com.google.inject.Provides;
import com.quest.voiceover.features.QuestListIndicatorHandler;
import com.quest.voiceover.features.VoiceoverHandler;
import com.quest.voiceover.modules.audio.SoundEngine;
import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.database.DatabaseVersionManager;
import com.quest.voiceover.modules.dialog.DialogManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(name = "Quest Voiceover")
public class QuestVoiceoverPlugin extends Plugin {

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private DatabaseManager databaseManager;

    @Inject
    private SoundEngine soundEngine;

    @Inject
    private VoiceoverHandler voiceoverHandler;

    @Inject
    private QuestListIndicatorHandler questListIndicatorHandler;

    @Inject
    private DialogManager dialogManager;

    @Inject
    private ClientToolbar clientToolbar;

    private QuestVoiceoverPanel panel;
    private NavigationButton navigationButton;
    private String playerName;

    @Override
    protected void startUp() {
        eventBus.register(soundEngine);

        panel = new QuestVoiceoverPanel();
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
        navigationButton = NavigationButton.builder()
            .tooltip("Quest Voiceover")
            .icon(icon)
            .priority(10)
            .panel(panel)
            .build();
        clientToolbar.addNavigation(navigationButton);

        executor.submit(this::initializeDatabase);
        log.info("Quest Voiceover plugin started");
    }

    @Override
    protected void shutDown() throws Exception {
        eventBus.unregister(soundEngine);
        databaseManager.closeConnection();
        clientToolbar.removeNavigation(navigationButton);
        log.info("Quest Voiceover plugin stopped");
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() != ChatMessageType.DIALOG) {
            return;
        }

        initializePlayerNameIfNeeded();
        voiceoverHandler.handleDialogMessage(event.getMessage(), playerName);
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Continue")) {
            voiceoverHandler.stopVoiceover();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (isDialogWidget(event.getGroupId())) {
            voiceoverHandler.handleDialogOpened();
        }

        if (event.getGroupId() == InterfaceID.QUEST_LIST) {
            questListIndicatorHandler.onQuestListOpened();
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event) {
        if (isDialogWidget(event.getGroupId())) {
            voiceoverHandler.stopVoiceover();
        }

        if (event.getGroupId() == InterfaceID.QUEST_LIST) {
            questListIndicatorHandler.onQuestListClosed();
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        questListIndicatorHandler.onGameTick();

        boolean audioPlaying = soundEngine.isPlaying();
        boolean playerMoving = isPlayerMoving();
        boolean dialogOpen = dialogManager.isPlayerOrNpcDialogOpen();

        if (audioPlaying && !dialogOpen) {
            log.debug("Stopping voiceover - dialog closed");
            soundEngine.stopImmediately();
        }
    }

    private boolean isPlayerMoving() {
        var player = client.getLocalPlayer();
        if (player == null) {
            return false;
        }
        int poseAnimation = player.getPoseAnimation();
        int idleAnimation = player.getIdlePoseAnimation();
        return poseAnimation != idleAnimation || client.getLocalDestinationLocation() != null;
    }

    @Provides
    QuestVoiceoverConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(QuestVoiceoverConfig.class);
    }

    private void initializeDatabase() {
        DatabaseVersionManager.prepareDatabaseSource(okHttpClient);
        databaseManager.initializeConnection();
        Set<String> voicedQuests = databaseManager.getVoicedQuests();
        questListIndicatorHandler.setVoicedQuests(voicedQuests);
        SwingUtilities.invokeLater(() -> panel.updateInfo(databaseManager, voicedQuests));
        log.info("Database initialized");
    }

    private void initializePlayerNameIfNeeded() {
        if (playerName == null) {
            playerName = client.getLocalPlayer().getName();
        }
    }

    private boolean isDialogWidget(int groupId) {
        return groupId == InterfaceID.DIALOG_NPC
            || groupId == InterfaceID.DIALOG_PLAYER
            || groupId == InterfaceID.DIALOG_OPTION;
    }
}

package com.quest.voiceover.utility;

public class MessageParser {

    private static final String PLAYER_NAME_PLACEHOLDER = "Player";

    private final String characterName;
    private final String dialogText;
    private final String messageId;

    public MessageParser(String rawMessage, String playerName) {
        String[] parts = rawMessage.split("\\|", 2);

        this.characterName = normalizeCharacterName(parts[0], playerName);
        this.dialogText = parts[1].trim();
        this.messageId = HashUtil.toMD5(this.characterName + "|" + this.dialogText);
    }

    public String getCharacterName() {
        return characterName;
    }

    public String getDialogText() {
        return dialogText;
    }

    public String getMessageId() {
        return messageId;
    }

    private String normalizeCharacterName(String name, String playerName) {
        return name.equals(playerName) ? PLAYER_NAME_PLACEHOLDER : name;
    }
}

package com.quest.voiceover.utility;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class HashUtil {

    public static String toMD5(String input) {
        return hash(input, "MD5");
    }

    public static String toSHA256(String input) {
        return hash(input, "SHA-256");
    }

    private static String hash(String input, String algorithm) {
        try {
            MessageDigest digest = MessageDigest.getInstance(algorithm);
            byte[] hashBytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Hash algorithm not available: " + algorithm, e);
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }
}

package com.quest.voiceover.utility;

public class LevenshteinUtility {

    public static int distance(String source, String target) {
        if (source.length() < target.length()) {
            String swap = source;
            source = target;
            target = swap;
        }

        int[] previousRow = new int[target.length() + 1];
        int[] currentRow = new int[target.length() + 1];

        for (int targetIndex = 0; targetIndex <= target.length(); targetIndex++) {
            previousRow[targetIndex] = targetIndex;
        }

        for (int sourceIndex = 1; sourceIndex <= source.length(); sourceIndex++) {
            currentRow[0] = sourceIndex;
            for (int targetIndex = 1; targetIndex <= target.length(); targetIndex++) {
                int cost = source.charAt(sourceIndex - 1) == target.charAt(targetIndex - 1) ? 0 : 1;
                currentRow[targetIndex] = Math.min(
                    Math.min(previousRow[targetIndex] + 1, currentRow[targetIndex - 1] + 1),
                    previousRow[targetIndex - 1] + cost
                );
            }
            int[] swap = previousRow;
            previousRow = currentRow;
            currentRow = swap;
        }

        return previousRow[target.length()];
    }

    public static double similarity(String source, String target) {
        int distance = distance(source, target);
        int maxLength = Math.max(source.length(), target.length());
        return maxLength == 0 ? 1.0 : 1.0 - ((double) distance / maxLength);
    }
}

package com.quest.voiceover;

import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.database.DatabaseVersionManager;
import net.runelite.api.Quest;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.Set;

public class QuestVoiceoverPanel extends PluginPanel
{
    private static final String PLUGIN_VERSION;
    private static final String REQUEST_QUEST_URL = "https://github.com/KevinEdry/runelite-quest-voiceover/issues/new?template=quest-request.yml";
    private static final String REPORT_ISSUE_URL = "https://github.com/KevinEdry/runelite-quest-voiceover/issues/new?template=issue-report.yml";
    private static final String DISCORD_URL = "https://discord.com/invite/tkr6tEbXJr";

    private static final ImageIcon ARROW_RIGHT_ICON;
    private static final ImageIcon GITHUB_ICON;
    private static final ImageIcon DISCORD_ICON;

    static
    {
        String version = "Unknown";
        try (InputStream input = QuestVoiceoverPanel.class.getResourceAsStream("version.properties"))
        {
            if (input != null)
            {
                Properties props = new Properties();
                props.load(input);
                version = props.getProperty("version", "Unknown");
            }
        }
        catch (IOException ignored)
        {
        }
        PLUGIN_VERSION = version;

        final BufferedImage arrowRight = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "arrow_right.png");
        ARROW_RIGHT_ICON = new ImageIcon(arrowRight);

        final BufferedImage githubIcon = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "github_icon.png");
        GITHUB_ICON = new ImageIcon(githubIcon);

        final BufferedImage discordIcon = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "discord_icon.png");
        DISCORD_ICON = new ImageIcon(discordIcon);
    }

    private final JLabel databaseVersionLabel;
    private final JLabel connectionStatusLabel;
    private final JLabel questCoverageLabel;
    private final JLabel questPercentageLabel;

    public QuestVoiceoverPanel()
    {
        super(false);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Title
        JLabel titleLabel = new JLabel("Quest Voiceover");
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        add(titleLabel);
        add(Box.createVerticalStrut(10));

        // Plugin section
        JPanel pluginBox = new JPanel();
        pluginBox.setLayout(new BoxLayout(pluginBox, BoxLayout.Y_AXIS));
        pluginBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pluginBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        pluginBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel pluginHeader = new JLabel("Plugin");
        pluginHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        pluginHeader.setForeground(Color.WHITE);
        pluginHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel pluginVersionLabel = new JLabel(htmlLabel("Version: ", PLUGIN_VERSION));
        pluginVersionLabel.setFont(FontManager.getRunescapeSmallFont());
        pluginVersionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        pluginVersionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        pluginBox.add(pluginHeader);
        pluginBox.add(Box.createVerticalStrut(8));
        pluginBox.add(pluginVersionLabel);

        // Database section
        JPanel databaseBox = new JPanel();
        databaseBox.setLayout(new BoxLayout(databaseBox, BoxLayout.Y_AXIS));
        databaseBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        databaseBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        databaseBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel databaseHeader = new JLabel("Database");
        databaseHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        databaseHeader.setForeground(Color.WHITE);
        databaseHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        databaseVersionLabel = new JLabel(htmlLabel("Version: ", "Loading..."));
        databaseVersionLabel.setFont(FontManager.getRunescapeSmallFont());
        databaseVersionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        databaseVersionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        connectionStatusLabel = new JLabel(htmlLabel("Status: ", "Loading..."));
        connectionStatusLabel.setFont(FontManager.getRunescapeSmallFont());
        connectionStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        connectionStatusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        databaseBox.add(databaseHeader);
        databaseBox.add(Box.createVerticalStrut(8));
        databaseBox.add(databaseVersionLabel);
        databaseBox.add(Box.createVerticalStrut(2));
        databaseBox.add(connectionStatusLabel);

        // Coverage section
        JPanel coverageBox = new JPanel();
        coverageBox.setLayout(new BoxLayout(coverageBox, BoxLayout.Y_AXIS));
        coverageBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        coverageBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        coverageBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel coverageHeader = new JLabel("Coverage");
        coverageHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        coverageHeader.setForeground(Color.WHITE);
        coverageHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        questCoverageLabel = new JLabel(htmlLabel("Quests voiced: ", "Loading..."));
        questCoverageLabel.setFont(FontManager.getRunescapeSmallFont());
        questCoverageLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        questCoverageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        questPercentageLabel = new JLabel(htmlLabel("Completion: ", "Loading..."));
        questPercentageLabel.setFont(FontManager.getRunescapeSmallFont());
        questPercentageLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        questPercentageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        coverageBox.add(coverageHeader);
        coverageBox.add(Box.createVerticalStrut(8));
        coverageBox.add(questCoverageLabel);
        coverageBox.add(Box.createVerticalStrut(2));
        coverageBox.add(questPercentageLabel);

        add(pluginBox);
        add(Box.createVerticalStrut(10));
        add(databaseBox);
        add(Box.createVerticalStrut(10));
        add(coverageBox);
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(GITHUB_ICON, "Request a", "new quest", REQUEST_QUEST_URL));
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(GITHUB_ICON, "Report an issue or", "make a suggestion", REPORT_ISSUE_URL));
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(DISCORD_ICON, "Talk to us on our", "Discord server", DISCORD_URL));
        add(Box.createVerticalGlue());
    }

    public void updateInfo(DatabaseManager databaseManager, Set<String> voicedQuests)
    {
        String dbVersion = DatabaseVersionManager.getDatabaseVersion();
        databaseVersionLabel.setText(htmlLabel("Version: ", dbVersion));

        boolean connected = databaseManager.isConnected();
        String statusText = connected ? "Connected" : "Disconnected";
        connectionStatusLabel.setText(htmlLabel("Status: ", statusText));

        int totalQuests = Quest.values().length;
        int voicedCount = voicedQuests != null ? voicedQuests.size() : 0;
        String coverageText = voicedCount + " / " + totalQuests;
        questCoverageLabel.setText(htmlLabel("Quests voiced: ", coverageText));

        double percentage = (voicedCount * 100.0) / totalQuests;
        String percentageText = String.format("%.1f%%", percentage);
        questPercentageLabel.setText(htmlLabel("Completion: ", percentageText));
    }

    private static String htmlLabel(String key, String value)
    {
        return "<html><body>" + key + "<span style='color:white'>" + value + "</span></body></html>";
    }

    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, String url)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(new EmptyBorder(8, 10, 8, 10));
        container.setCursor(new Cursor(Cursor.HAND_CURSOR));
        container.setAlignmentX(Component.LEFT_ALIGNMENT);
        container.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));

        JLabel iconLabel = new JLabel(icon);

        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
        textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textPanel.setBorder(new EmptyBorder(0, 10, 0, 0));

        JLabel topLabel = new JLabel(topText);
        topLabel.setForeground(Color.WHITE);
        topLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel bottomLabel = new JLabel(bottomText);
        bottomLabel.setForeground(Color.WHITE);
        bottomLabel.setFont(FontManager.getRunescapeSmallFont());

        textPanel.add(topLabel);
        textPanel.add(bottomLabel);

        JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);

        container.add(iconLabel, BorderLayout.WEST);
        container.add(textPanel, BorderLayout.CENTER);
        container.add(arrowLabel, BorderLayout.EAST);

        container.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                LinkBrowser.browse(url);
            }

            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                container.setBackground(ColorScheme.DARK_GRAY_COLOR);
                textPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });

        return container;
    }
}

package com.quest.voiceover;

import net.runelite.client.config.*;

@ConfigGroup("quest.voiceover")
public interface QuestVoiceoverConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "General settings",
			position = 10,
			closedByDefault = false
	)
	String generalSettings = "generalSettings";

	@ConfigSection(
			name = "Quest Dialog",
			description = "Settings for the quest dialog overlay",
			position = 20,
			closedByDefault = false
	)
	String questDialogSettings = "questDialogSettings";

	@ConfigSection(
			name = "Quest List",
			description = "Settings for the quest list",
			position = 30,
			closedByDefault = false
	)
	String questListSettings = "questListSettings";

	@Range(min = 1, max = 100)
	@ConfigItem(
			keyName = "volume",
			name = "Volume",
			description = "Volume control for the voiceover sounds.",
			position = 11,
			section = generalSettings
	)
	default int volume() {
		return 75;
	}

	@ConfigItem(
			keyName = "mute",
			name = "Mute",
			description = "Mutes the voiceover sound.",
			section = generalSettings,
			position = 12
	)
	default boolean mute()
	{
		return false;
	}

	@ConfigItem(
			keyName = "showMuteButton",
			name = "Toggle Mute Button",
			description = "Shows the mute button on the quest dialog.",
			section = questDialogSettings,
			position = 21
	)
	default boolean showMuteButton()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showQuestName",
			name = "Toggle Quest Name",
			description = "Shows the quest name on the quest dialog.",
			section = questDialogSettings,
			position = 22
	)
	default boolean showQuestName()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showVoicedIndicator",
			name = "Toggle Voiced Quest Indicator",
			description = "Shows [Voiced] prefix next to quests with voice acting in the quest list.",
			section = questListSettings,
			position = 31
	)
	default boolean showVoicedIndicator()
	{
		return true;
	}
}

package com.quest.voiceover;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class QuestVoiceoverPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(QuestVoiceoverPlugin.class);
		RuneLite.main(args);
	}
}
