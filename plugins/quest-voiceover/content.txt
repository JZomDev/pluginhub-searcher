package com.quest.voiceover.features;

import com.quest.voiceover.QuestVoiceoverConfig;
import net.runelite.api.Client;
import net.runelite.api.Point;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.awt.*;
import java.util.HashSet;
import java.util.Set;

@Singleton
public class QuestListIndicatorHandler {

    private static final int QUEST_LIST_CONTAINER_COMPONENT = 7;
    private static final int WIDGET_TYPE_TEXT = 4;
    private static final int TICKS_BEFORE_ADDING_INDICATORS = 2;
    private static final String SHORT_PREFIX = "[V] ";
    private static final String LONG_PREFIX = "[Voiced] ";

    @Inject
    private Client client;

    @Inject
    private QuestVoiceoverConfig config;

    private Set<String> voicedQuests = new HashSet<>();
    private boolean isQuestListVisible;
    private int ticksSinceOpened;

    public void setVoicedQuests(Set<String> voicedQuests) {
        this.voicedQuests = voicedQuests;
    }

    public void onQuestListOpened() {
        isQuestListVisible = true;
        ticksSinceOpened = 0;
    }

    public void onQuestListClosed() {
        isQuestListVisible = false;
    }

    public void onGameTick() {
        if (!isQuestListVisible) {
            return;
        }

        ticksSinceOpened++;

        if (ticksSinceOpened < TICKS_BEFORE_ADDING_INDICATORS) {
            return;
        }

        if (config.showVoicedIndicator()) {
            updateVoiceIndicators();
        } else {
            removeVoiceIndicators();
        }
    }

    private void updateVoiceIndicators() {
        if (voicedQuests.isEmpty() || !isQuestListActuallyVisible()) {
            return;
        }

        Widget questListContainer = client.getWidget(InterfaceID.QUEST_LIST, QUEST_LIST_CONTAINER_COMPONENT);
        if (questListContainer == null || questListContainer.getChildren() == null) {
            return;
        }

        Point mousePosition = client.getMouseCanvasPosition();
        updateQuestWidgets(questListContainer.getChildren(), mousePosition);
    }

    private void removeVoiceIndicators() {
        if (!isQuestListActuallyVisible()) {
            return;
        }

        Widget questListContainer = client.getWidget(InterfaceID.QUEST_LIST, QUEST_LIST_CONTAINER_COMPONENT);
        if (questListContainer == null || questListContainer.getChildren() == null) {
            return;
        }

        for (Widget questWidget : questListContainer.getChildren()) {
            if (!isTextWidget(questWidget)) {
                continue;
            }

            String currentText = questWidget.getText();
            if (hasVoicePrefix(currentText)) {
                questWidget.setText(extractQuestName(currentText));
                questWidget.revalidate();
            }
        }
    }

    private boolean hasVoicePrefix(String text) {
        return text != null && (text.startsWith(SHORT_PREFIX) || text.startsWith(LONG_PREFIX));
    }

    private boolean isQuestListActuallyVisible() {
        Widget questListPanel = client.getWidget(InterfaceID.QUEST_LIST, 0);

        if (questListPanel == null || questListPanel.isHidden()) {
            return false;
        }

        return questListPanel.getCanvasLocation() != null && questListPanel.getWidth() > 0;
    }

    private void updateQuestWidgets(Widget[] questWidgets, Point mousePosition) {
        for (Widget questWidget : questWidgets) {
            if (!isTextWidget(questWidget)) {
                continue;
            }

            String currentText = questWidget.getText();
            String questName = extractQuestName(currentText);

            if (!isVoicedQuest(questName)) {
                continue;
            }

            boolean isHovered = isMouseOverWidget(questWidget, mousePosition);
            String expectedPrefix = isHovered ? LONG_PREFIX : SHORT_PREFIX;
            String expectedText = expectedPrefix + questName;

            if (!currentText.equals(expectedText)) {
                questWidget.setText(expectedText);
                questWidget.revalidate();
            }
        }
    }

    private String extractQuestName(String text) {
        if (text == null) {
            return null;
        }
        if (text.startsWith(LONG_PREFIX)) {
            return text.substring(LONG_PREFIX.length());
        }
        if (text.startsWith(SHORT_PREFIX)) {
            return text.substring(SHORT_PREFIX.length());
        }
        return text;
    }

    private boolean isVoicedQuest(String questName) {
        return questName != null && voicedQuests.contains(questName);
    }

    private boolean isMouseOverWidget(Widget widget, Point mousePosition) {
        Rectangle bounds = widget.getBounds();
        if (bounds == null || mousePosition == null) {
            return false;
        }
        return bounds.contains(mousePosition.getX(), mousePosition.getY());
    }

    private boolean isTextWidget(Widget widget) {
        return widget != null && widget.getType() == WIDGET_TYPE_TEXT;
    }
}

package com.quest.voiceover.features;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.modules.audio.AudioManager;
import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.dialog.DialogManager;
import com.quest.voiceover.utility.MessageUtility;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

@Slf4j
@Singleton
public class VoiceoverHandler {

    private static final double LEVENSHTEIN_THRESHOLD = 0.70;

    private static final String EXACT_QUERY =
        "SELECT quest, uri, text FROM dialogs WHERE character = ? AND text = ? LIMIT 1";

    private static final String LEVENSHTEIN_QUERY =
        "SELECT quest, uri, text, levenshtein_similarity(text, ?) AS similarity " +
        "FROM dialogs WHERE character = ? " +
        "ORDER BY similarity DESC LIMIT 1";

    @Inject
    private ClientThread clientThread;

    @Inject
    private DatabaseManager databaseManager;

    @Inject
    private AudioManager audioManager;

    @Inject
    private DialogManager dialogManager;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private DialogSpeechHighlightHandler dialogSpeechHighlightHandler;

    @Getter
    private boolean activeVoiceover;

    @Getter
    private String currentQuestName;

    private String pendingCharacter;
    private String pendingPlayerName;
    private String pendingOriginalText;

    /**
     * Chat messages serve as a reliable trigger event, while the dialog widget provides
     * the complete text. Widget-only detection is unreliable because there's no single
     * "dialog changed" event and widget population timing is unpredictable. The chat
     * message signals "dialog happened", then we fetch the full content from the widget.
     */
    public void handleDialogMessage(String rawMessage, String playerName) {
        MessageUtility.ParsedMessage chatMessage = MessageUtility.parseRawMessage(rawMessage, playerName);
        String chatText = chatMessage.dialogText();
        String chatCharacter = chatMessage.characterName();

        String widgetText = dialogManager.getDialogText();
        String widgetCharacter = dialogManager.getDialogCharacterName();

        if (widgetText == null || widgetCharacter == null) {
            log.debug("Widget not available, scheduling retry");
            scheduleRetry(chatCharacter, playerName, null);
            return;
        }

        String cleanedWidgetText = MessageUtility.cleanWidgetText(widgetText, playerName);
        boolean textMatches = cleanedWidgetText.startsWith(chatText) || chatText.startsWith(cleanedWidgetText);

        if (!textMatches) {
            log.debug("Widget text mismatch, scheduling retry");
            scheduleRetry(chatCharacter, playerName, widgetText);
            return;
        }

        playVoiceoverIfAvailable(widgetCharacter, cleanedWidgetText, widgetText);
    }

    private void scheduleRetry(String character, String playerName, String originalText) {
        pendingCharacter = character;
        pendingPlayerName = playerName;
        pendingOriginalText = originalText;
        clientThread.invokeLater(this::retryWithWidget);
    }

    private void retryWithWidget() {
        if (pendingCharacter == null) {
            return;
        }

        String widgetText = dialogManager.getDialogText();
        String widgetCharacter = dialogManager.getDialogCharacterName();

        if (widgetText == null || widgetCharacter == null) {
            log.debug("Widget retry failed");
            clearPendingState();
            return;
        }

        String cleanedWidgetText = MessageUtility.cleanWidgetText(widgetText, pendingPlayerName);
        playVoiceoverIfAvailable(widgetCharacter, cleanedWidgetText, widgetText);
        clearPendingState();
    }

    private void clearPendingState() {
        pendingCharacter = null;
        pendingPlayerName = null;
        pendingOriginalText = null;
    }

    public void handleDialogOpened() {
        if (!dialogManager.isPlayerOrNpcDialogOpen() || !activeVoiceover) {
            return;
        }
        addDialogOverlay();
    }

    private void addDialogOverlay() {
        Widget dialogWidget = dialogManager.getActiveDialogWidget();
        if (dialogWidget == null) {
            return;
        }

        if (config.showMuteButton()) {
            dialogManager.addMuteButton(dialogWidget);
        }

        if (config.showQuestName() && currentQuestName != null) {
            dialogManager.addQuestNameLabel(dialogWidget, currentQuestName);
        }
    }

    public void stopVoiceover() {
        activeVoiceover = false;
        audioManager.stop();
        dialogSpeechHighlightHandler.stop();
    }

    /**
     * Query stages (in order of speed/accuracy tradeoff):
     * 1. Exact match - fastest, handles most cases where wiki text matches game text
     * 2. Levenshtein similarity - handles word substitutions (e.g., "called" vs "named")
     *    where wiki transcript differs from actual in-game text
     */
    private void playVoiceoverIfAvailable(String characterName, String dialogText, String originalText) {
        if (tryExactQuery(characterName, dialogText, originalText)) {
            return;
        }

        if (tryLevenshteinQuery(characterName, dialogText, originalText)) {
            return;
        }

        log.info("No voiceover found for {} - '{}'", characterName, dialogText);
        activeVoiceover = false;
        dialogSpeechHighlightHandler.stop();
        audioManager.stopImmediately();
    }

    private boolean tryExactQuery(String characterName, String dialogText, String originalText) {
        try (PreparedStatement statement = databaseManager.prepareStatement(EXACT_QUERY)) {
            statement.setString(1, characterName);
            statement.setString(2, dialogText);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (resultSet.next()) {
                    log.debug("Match type: exact");
                    return playVoiceoverFromResult(resultSet, characterName, dialogText, originalText);
                }
            }
        } catch (SQLException e) {
            log.error("Database query failed (exact)", e);
        }
        return false;
    }

    private boolean tryLevenshteinQuery(String characterName, String dialogText, String originalText) {
        try (PreparedStatement statement = databaseManager.prepareStatement(LEVENSHTEIN_QUERY)) {
            statement.setString(1, dialogText);
            statement.setString(2, characterName);

            try (ResultSet resultSet = statement.executeQuery()) {
                if (!resultSet.next()) {
                    return false;
                }

                double similarity = resultSet.getDouble("similarity");
                if (similarity < LEVENSHTEIN_THRESHOLD) {
                    String bestMatchText = resultSet.getString("text");
                    log.info("Levenshtein match below threshold ({}%) for {} - '{}' best match: '{}'",
                        String.format("%.1f", similarity * 100), characterName, dialogText, bestMatchText);
                    return false;
                }

                log.debug("Match type: levenshtein ({}%)", String.format("%.1f", similarity * 100));
                return playVoiceoverFromResult(resultSet, characterName, dialogText, originalText);
            }
        } catch (SQLException e) {
            log.error("Database query failed (Levenshtein)", e);
        }
        return false;
    }

    private boolean playVoiceoverFromResult(ResultSet resultSet, String characterName, String dialogText, String originalText) throws SQLException {
        String audioUri = resultSet.getString("uri");
        currentQuestName = resultSet.getString("quest");
        String matchedText = resultSet.getString("text");
        log.info("Playing voiceover: {} - {} - '{}' matched: '{}'", characterName, currentQuestName, dialogText, matchedText);

        if (audioUri == null && currentQuestName == null) {
            return false;
        }

        activeVoiceover = true;
        audioManager.play(audioUri);
        addDialogOverlay();
        dialogSpeechHighlightHandler.startAsync(audioUri, originalText);
        return true;
    }

}

package com.quest.voiceover.features;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.modules.dialog.DialogManager;
import com.quest.voiceover.utility.ColorUtility;
import com.quest.voiceover.Constants;
import com.quest.voiceover.utility.TextUtility;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.callback.ClientThread;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Singleton
public class DialogSpeechHighlightHandler {

    private static final double FALLBACK_WORDS_PER_SECOND = 2.5;
    private static final Pattern WORD_PATTERN = Pattern.compile("\\S+");
    private static final Pattern PUNCTUATION_PAUSE_PATTERN = Pattern.compile("[.!?]+$");
    private static final int PUNCTUATION_PAUSE_WEIGHT = 7;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private DialogManager dialogManager;

    @Inject
    private ClientThread clientThread;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private OkHttpClient okHttpClient;

    private String originalText;
    private List<WordPosition> wordPositions;
    private volatile int currentWordIndex;
    private final List<ScheduledFuture<?>> scheduledTasks = new ArrayList<>();

    public void startAsync(String audioUri, String dialogText) {
        if (!config.speechHighlighting()) {
            return;
        }

        executor.submit(() -> {
            long durationMs = estimateDurationMs(audioUri);
            start(dialogText, durationMs);
        });
    }

    private long estimateDurationMs(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return 0;
        }

        HttpUrl url = Constants.RAW_GITHUB_SOUND_BRANCH_URL.newBuilder()
            .addPathSegment(fileName)
            .build();

        Request request = new Request.Builder()
            .url(url)
            .head()
            .build();

        try (Response response = okHttpClient.newCall(request).execute()) {
            String contentLength = response.header("Content-Length");
            if (contentLength != null) {
                long fileBytes = Long.parseLong(contentLength);
                long bytesPerSecond = (Constants.MP3_BITRATE_KBPS * 1000L) / 8;
                return (fileBytes * 1000) / bytesPerSecond;
            }
        } catch (IOException | NumberFormatException e) {
            log.warn("Failed to estimate audio duration for {}", fileName, e);
        }

        return 0;
    }

    private void start(String dialogText, long durationMs) {
        stop();

        originalText = dialogText;
        wordPositions = parseWordPositions(dialogText);
        currentWordIndex = 0;

        if (wordPositions.isEmpty()) {
            return;
        }

        long effectiveDuration = durationMs > 0 ? durationMs : calculateFallbackDuration();
        scheduleWordHighlights(effectiveDuration);
    }

    public void stop() {
        for (ScheduledFuture<?> task : scheduledTasks) {
            task.cancel(false);
        }
        reset();
    }

    private void reset() {
        scheduledTasks.clear();
        originalText = null;
        wordPositions = null;
        currentWordIndex = 0;
    }

    private List<WordPosition> parseWordPositions(String text) {
        List<WordPosition> positions = new ArrayList<>();
        Matcher matcher = WORD_PATTERN.matcher(text);

        while (matcher.find()) {
            String word = matcher.group();
            String cleanWord = word.replaceAll("<[^>]+>", "");
            int weight = cleanWord.length();

            if (PUNCTUATION_PAUSE_PATTERN.matcher(cleanWord).find()) {
                weight += PUNCTUATION_PAUSE_WEIGHT;
            }

            positions.add(new WordPosition(matcher.start(), matcher.end(), weight));
        }

        return positions;
    }

    private void scheduleWordHighlights(long totalDurationMs) {
        int totalWeight = calculateTotalWeight();
        long cumulativeTime = 0;

        for (int wordIndex = 0; wordIndex < wordPositions.size(); wordIndex++) {
            WordPosition pos = wordPositions.get(wordIndex);
            long wordDuration = calculateWordDuration(pos.weight, totalWeight, totalDurationMs);

            final int targetWordIndex = wordIndex + 1;
            ScheduledFuture<?> task = executor.schedule(
                () -> highlightUpToWord(targetWordIndex),
                cumulativeTime,
                TimeUnit.MILLISECONDS
            );
            scheduledTasks.add(task);
            cumulativeTime += wordDuration;
        }
    }

    private void highlightUpToWord(int wordIndex) {
        if (wordPositions == null || originalText == null) {
            return;
        }

        currentWordIndex = wordIndex;
        String highlightedText = buildHighlightedText();
        clientThread.invokeLater(() -> dialogManager.setDialogText(highlightedText));
    }

    private int calculateTotalWeight() {
        int total = 0;
        for (WordPosition pos : wordPositions) {
            total += pos.weight;
        }
        return Math.max(total, 1);
    }

    private long calculateWordDuration(int weight, int totalWeight, long totalDurationMs) {
        double proportion = (double) weight / totalWeight;
        return (long) (proportion * totalDurationMs);
    }

    private long calculateFallbackDuration() {
        return (long) ((wordPositions.size() / FALLBACK_WORDS_PER_SECOND) * 1000);
    }

    private String buildHighlightedText() {
        if (currentWordIndex <= 0 || wordPositions.isEmpty()) {
            return originalText;
        }

        String colorTag = ColorUtility.toOsrsColorTag(config.speechHighlightColor());
        int highlightEnd = wordPositions.get(Math.min(currentWordIndex, wordPositions.size()) - 1).end;

        String highlightedPortion = originalText.substring(0, highlightEnd);
        String remainingPortion = originalText.substring(highlightEnd);

        highlightedPortion = TextUtility.reapplyColorAfterLineBreaks(highlightedPortion, colorTag);

        return colorTag + highlightedPortion + "</col>" + remainingPortion;
    }

    private static class WordPosition {
        final int start;
        final int end;
        final int weight;

        WordPosition(int start, int end, int weight) {
            this.start = start;
            this.end = end;
            this.weight = weight;
        }
    }
}

package com.quest.voiceover.modules.database;

import com.quest.voiceover.Constants;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.RuneLite;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.StandardOpenOption;

@Slf4j
public class DatabaseVersionManager {

    private static final String DATABASE_FILENAME = "quest_voiceover.db";
    private static final String VERSION_FILENAME = ".version";

    private static final Path DOWNLOAD_DIR =
        Path.of(RuneLite.RUNELITE_DIR.getPath(), "quest-voiceover");

    private static final Path VERSION_FILE = DOWNLOAD_DIR.resolve(VERSION_FILENAME);
    private static final Path DATABASE_FILE = DOWNLOAD_DIR.resolve(DATABASE_FILENAME);

    public static String getDatabaseVersion() {
        String version = readVersionFile();
        if (version.isEmpty()) {
            return "Unknown";
        }
        return version.replace("\"", "").substring(0, 7);
    }

    public static void prepareDatabaseSource(OkHttpClient okHttpClient) {
        ensureDownloadDirectoryExists();
        downloadOrUpdateDatabase(okHttpClient);
    }

    public static String getDatabasePath() throws FileNotFoundException {
        if (!Files.exists(DATABASE_FILE)) {
            throw new FileNotFoundException("Database file not found: " + DATABASE_FILE);
        }
        return DATABASE_FILE.toString();
    }

    private static void ensureDownloadDirectoryExists() {
        try {
            Files.createDirectories(DOWNLOAD_DIR);
        } catch (IOException e) {
            log.error("Failed to create download directory", e);
        }
    }

    private static void downloadOrUpdateDatabase(OkHttpClient okHttpClient) {
        try {
            String currentVersion = readVersionFile();
            HttpUrl downloadUrl = buildDownloadUrl();

            Request headRequest = new Request.Builder()
                .url(downloadUrl)
                .header("If-None-Match", currentVersion)
                .head()
                .build();

            try (Response headResponse = okHttpClient.newCall(headRequest).execute()) {
                if (headResponse.code() == 304) {
                    return;
                }

                String remoteEtag = headResponse.header("ETag");
                if (remoteEtag == null) {
                    log.warn("No ETag header in remote response");
                    return;
                }

                if (shouldDownload(remoteEtag, currentVersion)) {
                    downloadDatabase(okHttpClient, downloadUrl, remoteEtag);
                }
            }
        } catch (IOException e) {
            log.error("Failed to download or update database", e);
        }
    }

    private static boolean shouldDownload(String remoteEtag, String currentVersion) {
        return !Files.exists(DATABASE_FILE) || !remoteEtag.equals(currentVersion);
    }

    private static void downloadDatabase(OkHttpClient client, HttpUrl url, String version) throws IOException {
        log.info("Downloading new database version: {}", version);

        Request request = new Request.Builder().url(url).build();

        try (Response response = client.newCall(request).execute()) {
            if (!response.isSuccessful() || response.body() == null) {
                log.error("Failed to download database: {}", response.message());
                return;
            }

            try (InputStream inputStream = response.body().byteStream()) {
                Files.copy(inputStream, DATABASE_FILE, StandardCopyOption.REPLACE_EXISTING);
                writeVersionFile(version);
                log.info("Database updated successfully");
            }
        }
    }

    private static HttpUrl buildDownloadUrl() {
        return Constants.RAW_GITHUB_DATABASE_BRANCH_URL.newBuilder()
            .addPathSegment(DATABASE_FILENAME)
            .build();
    }

    private static String readVersionFile() {
        if (!Files.exists(VERSION_FILE)) {
            return "";
        }

        try {
            return Files.readString(VERSION_FILE).trim();
        } catch (IOException e) {
            log.error("Failed to read version file", e);
            return "";
        }
    }

    private static void writeVersionFile(String version) {
        try {
            Files.writeString(VERSION_FILE, version,
                StandardOpenOption.CREATE,
                StandardOpenOption.WRITE,
                StandardOpenOption.TRUNCATE_EXISTING);
        } catch (IOException e) {
            log.error("Failed to write version file", e);
        }
    }
}

package com.quest.voiceover.modules.database.functions;

import com.quest.voiceover.utility.LevenshteinUtility;
import lombok.extern.slf4j.Slf4j;
import org.sqlite.Function;

import java.sql.Connection;
import java.sql.SQLException;

@Slf4j
public class LevenshteinFunction {

    public static void register(Connection connection) throws SQLException {
        Function.create(connection, "levenshtein", new Function() {
            @Override
            protected void xFunc() throws SQLException {
                String source = value_text(0);
                String target = value_text(1);

                if (source == null || target == null) {
                    result(Integer.MAX_VALUE);
                    return;
                }

                result(LevenshteinUtility.distance(source, target));
            }
        });

        Function.create(connection, "levenshtein_similarity", new Function() {
            @Override
            protected void xFunc() throws SQLException {
                String source = value_text(0);
                String target = value_text(1);

                if (source == null || target == null) {
                    result(0.0);
                    return;
                }

                result(LevenshteinUtility.similarity(source, target));
            }
        });

        log.debug("Registered Levenshtein SQL functions");
    }
}

package com.quest.voiceover.modules.database;

import com.quest.voiceover.modules.database.functions.LevenshteinFunction;
import lombok.extern.slf4j.Slf4j;

import javax.inject.Singleton;
import java.io.FileNotFoundException;
import java.sql.*;
import java.util.HashSet;
import java.util.Set;

@Slf4j
@Singleton
public class DatabaseManager {

    private static final String SQL_PATH_PREFIX = "jdbc:sqlite:";

    private Connection connection;

    public void initializeConnection() {
        getConnection();
    }

    public boolean isConnected() {
        try {
            return connection != null && !connection.isClosed();
        } catch (SQLException e) {
            return false;
        }
    }

    public void closeConnection() throws SQLException {
        if (connection != null) {
            connection.close();
        }
    }

    public PreparedStatement prepareStatement(String query) throws SQLException {
        return getConnection().prepareStatement(query);
    }

    public Set<String> getVoicedQuests() {
        Set<String> voicedQuests = new HashSet<>();

        try (PreparedStatement statement = prepareStatement("SELECT DISTINCT quest FROM dialogs");
             ResultSet resultSet = statement.executeQuery()) {

            while (resultSet.next()) {
                voicedQuests.add(resultSet.getString("quest"));
            }
        } catch (SQLException e) {
            log.error("Failed to query voiced quests", e);
        }

        return voicedQuests;
    }

    private Connection getConnection() {
        if (connection != null) {
            return connection;
        }

        try {
            Class.forName("org.sqlite.JDBC");
            String databasePath = DatabaseVersionManager.getDatabasePath();
            connection = DriverManager.getConnection(SQL_PATH_PREFIX + databasePath);
            LevenshteinFunction.register(connection);
            log.info("Established connection to voiceover database");
        } catch (FileNotFoundException e) {
            log.error("Database file not found", e);
        } catch (SQLException e) {
            log.error("Failed to connect to database", e);
        } catch (ClassNotFoundException e) {
            log.error("SQLite JDBC driver not found", e);
            throw new RuntimeException(e);
        }

        return connection;
    }
}

package com.quest.voiceover.modules.audio;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.Constants;
import jaco.mp3.player.MP3Player;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import javax.inject.Singleton;
import java.net.URL;

@Slf4j
@Singleton
public class AudioManager {

    private static final int PLAYBACK_GRACE_PERIOD_TICKS = 1;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private Client client;

    @Inject
    private AudioDuckingManager audioDuckingManager;

    private volatile MP3Player player;
    private volatile boolean soundPlaying;
    private int playbackStartTick;

    public void play(String fileName) {
        stopPlayback();

        if (fileName == null || fileName.isEmpty()) {
            log.warn("Attempted to play null or empty fileName");
            return;
        }

        URL soundUrl = buildSoundUrl(fileName);
        MP3Player currentPlayer = getOrCreatePlayer();

        int volume = config.mute() ? 0 : config.volume();
        currentPlayer.setVolume(volume);
        currentPlayer.add(soundUrl);
        currentPlayer.play();

        audioDuckingManager.duck();
        soundPlaying = true;
        playbackStartTick = client.getTickCount();
        log.debug("Playing audio: {}", fileName);
    }

    public void stop() {
        int currentTick = client.getTickCount();
        boolean pastGracePeriod = currentTick > playbackStartTick + PLAYBACK_GRACE_PERIOD_TICKS;
        if (pastGracePeriod) {
            stopPlayback();
        }
    }

    public void stopImmediately() {
        stopPlayback();
    }

    public void setVolume(int volume) {
        getOrCreatePlayer().setVolume(volume);
    }

    public boolean isPlaying() {
        return soundPlaying && player != null && !player.isStopped();
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        if (player != null && soundPlaying && player.isStopped()) {
            soundPlaying = false;
            audioDuckingManager.restore();
        }
    }

    private void stopPlayback() {
        if (player == null) {
            return;
        }

        boolean wasPlaying = player.isPlaying();
        soundPlaying = false;
        player.clearPlayList();

        if (wasPlaying) {
            player.stop();
            audioDuckingManager.restore();
        }
    }

    private URL buildSoundUrl(String fileName) {
        return Constants.RAW_GITHUB_SOUND_BRANCH_URL.newBuilder()
            .addPathSegment(fileName)
            .build()
            .url();
    }

    private MP3Player getOrCreatePlayer() {
        if (player == null) {
            synchronized (this) {
                if (player == null) {
                    player = new MP3Player();
                }
            }
        }
        return player;
    }
}

package com.quest.voiceover.modules.audio;

import net.runelite.api.Client;
import net.runelite.api.VarPlayer;
import net.runelite.client.callback.ClientThread;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AudioChannelsManager {

    // VarPlayer returns 0-100 percentage, but setters expect absolute values
    private static final int MUSIC_MAX = 255;
    private static final int SOUND_EFFECT_MAX = 127;
    private static final int AREA_SOUND_MAX = 127;

    @Inject
    private Client client;

    @Inject
    private ClientThread clientThread;

    public int getMusicVolume() {
        return client.getVarpValue(VarPlayer.MUSIC_VOLUME);
    }

    public int getSoundEffectVolume() {
        return client.getVarpValue(VarPlayer.SOUND_EFFECT_VOLUME);
    }

    public int getAreaEffectVolume() {
        return client.getVarpValue(VarPlayer.AREA_EFFECT_VOLUME);
    }

    public void setMusicVolume(int percentage) {
        int absolute = percentage * MUSIC_MAX / 100;
        clientThread.invokeLater(() -> {
            client.setMusicVolume(absolute);
            return true;
        });
    }

    public void setSoundEffectVolume(int percentage) {
        int absolute = percentage * SOUND_EFFECT_MAX / 100;
        clientThread.invokeLater(() -> {
            client.getPreferences().setSoundEffectVolume(absolute);
            return true;
        });
    }

    public void setAreaEffectVolume(int percentage) {
        int absolute = percentage * AREA_SOUND_MAX / 100;
        clientThread.invokeLater(() -> {
            client.getPreferences().setAreaSoundEffectVolume(absolute);
            return true;
        });
    }

    public void setAllVolumes(int musicPercentage, int soundEffectPercentage, int areaEffectPercentage) {
        int musicAbsolute = musicPercentage * MUSIC_MAX / 100;
        int soundAbsolute = soundEffectPercentage * SOUND_EFFECT_MAX / 100;
        int areaAbsolute = areaEffectPercentage * AREA_SOUND_MAX / 100;

        clientThread.invokeLater(() -> {
            client.setMusicVolume(musicAbsolute);
            client.getPreferences().setSoundEffectVolume(soundAbsolute);
            client.getPreferences().setAreaSoundEffectVolume(areaAbsolute);
            return true;
        });
    }
}

package com.quest.voiceover.modules.audio;

import com.quest.voiceover.QuestVoiceoverConfig;
import net.runelite.api.Client;
import net.runelite.api.GameState;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class AudioDuckingManager {

    @Inject
    private Client client;

    @Inject
    private AudioChannelsManager audioChannelsManager;

    @Inject
    private QuestVoiceoverConfig config;

    private int originalMusicVolume = -1;
    private int originalSoundEffectVolume = -1;
    private int originalAreaEffectVolume = -1;
    private boolean isDucked = false;

    public void duck() {
        if (!config.audioDucking() || isDucked) {
            return;
        }

        if (client.getGameState() != GameState.LOGGED_IN) {
            return;
        }

        originalMusicVolume = audioChannelsManager.getMusicVolume();
        originalSoundEffectVolume = audioChannelsManager.getSoundEffectVolume();
        originalAreaEffectVolume = audioChannelsManager.getAreaEffectVolume();

        int duckPercent = config.audioDuckingAmount();
        int duckedMusic = Math.max(1, originalMusicVolume * duckPercent / 100);
        int duckedSound = Math.max(1, originalSoundEffectVolume * duckPercent / 100);
        int duckedArea = Math.max(1, originalAreaEffectVolume * duckPercent / 100);

        audioChannelsManager.setAllVolumes(duckedMusic, duckedSound, duckedArea);
        isDucked = true;
    }

    public void restore() {
        if (!isDucked) {
            return;
        }

        audioChannelsManager.setAllVolumes(originalMusicVolume, originalSoundEffectVolume, originalAreaEffectVolume);

        originalMusicVolume = -1;
        originalSoundEffectVolume = -1;
        originalAreaEffectVolume = -1;
        isDucked = false;
    }
}

package com.quest.voiceover.modules.dialog;

import com.quest.voiceover.QuestVoiceoverConfig;
import com.quest.voiceover.modules.audio.AudioManager;
import com.quest.voiceover.utility.ColorUtility;
import com.quest.voiceover.Constants;
import net.runelite.api.Client;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.*;
import net.runelite.client.config.ConfigManager;

import javax.inject.Inject;
import javax.inject.Singleton;

@Singleton
public class DialogManager {

    private static final String TOGGLE_MUTE_ACTION = "Toggle mute ";
    private static final int FONT_ID = 494;

    private static final int DIALOG_NPC_TEXT_CHILD = 6;
    private static final int DIALOG_NPC_NAME_CHILD = 4;
    private static final int DIALOG_PLAYER_TEXT_CHILD = 6;

    @Inject
    private Client client;

    @Inject
    private QuestVoiceoverConfig config;

    @Inject
    private ConfigManager configManager;

    @Inject
    private AudioManager audioManager;

    public boolean isPlayerOrNpcDialogOpen() {
        Widget playerWidget = getPlayerDialogWidget();
        if (playerWidget != null && !playerWidget.isHidden()) {
            return true;
        }

        Widget npcWidget = getNpcDialogWidget();
        return npcWidget != null && !npcWidget.isHidden();
    }

    public Widget getActiveDialogWidget() {
        if (!isPlayerOrNpcDialogOpen()) {
            return null;
        }

        Widget playerWidget = getPlayerDialogWidget();
        return playerWidget != null ? playerWidget : getNpcDialogWidget();
    }

    public void addQuestNameLabel(Widget dialogWidget, String questName) {
        Widget label = dialogWidget.createChild(-1, WidgetType.TEXT);

        label.setText("Quest: " + questName);
        label.setFontId(FONT_ID);
        label.setTextColor(ColorUtility.WHITE);
        label.setTextShadowed(true);
        label.setXPositionMode(WidgetPositionMode.ABSOLUTE_LEFT);
        label.setOriginalX(10);
        label.setOriginalY(5);
        label.setOriginalHeight(20);
        label.setOriginalWidth(200);
        label.revalidate();
    }

    public void addMuteButton(Widget dialogWidget) {
        Widget muteButton = dialogWidget.createChild(-1, WidgetType.GRAPHIC);

        muteButton.setSpriteId(getMuteSpriteId());
        muteButton.setOriginalWidth(32);
        muteButton.setOriginalHeight(32);
        muteButton.setXPositionMode(WidgetPositionMode.ABSOLUTE_RIGHT);
        muteButton.setOriginalX(5);
        muteButton.setOriginalY(5);
        muteButton.setHasListener(true);
        muteButton.setAction(1, TOGGLE_MUTE_ACTION);
        muteButton.setOnOpListener((JavaScriptCallback) e -> toggleMute(muteButton));
        muteButton.revalidate();
    }

    public String getDialogText() {
        Widget npcTextWidget = client.getWidget(InterfaceID.DIALOG_NPC, DIALOG_NPC_TEXT_CHILD);
        if (npcTextWidget != null) {
            return npcTextWidget.getText();
        }

        Widget playerTextWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, DIALOG_PLAYER_TEXT_CHILD);
        if (playerTextWidget != null) {
            return playerTextWidget.getText();
        }

        return null;
    }

    public void setDialogText(String text) {
        try {
            Widget npcTextWidget = client.getWidget(InterfaceID.DIALOG_NPC, DIALOG_NPC_TEXT_CHILD);
            Widget playerTextWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, DIALOG_PLAYER_TEXT_CHILD);

            boolean npcVisible = npcTextWidget != null && !npcTextWidget.isHidden();
            boolean playerVisible = playerTextWidget != null && !playerTextWidget.isHidden();

            if (npcVisible) {
                npcTextWidget.setText(text);
                return;
            }

            if (playerVisible) {
                playerTextWidget.setText(text);
            }
        } catch (NullPointerException ignored) {
        }
    }

    public String getDialogCharacterName() {
        Widget npcNameWidget = client.getWidget(InterfaceID.DIALOG_NPC, DIALOG_NPC_NAME_CHILD);
        if (npcNameWidget != null) {
            return npcNameWidget.getText();
        }

        Widget playerTextWidget = client.getWidget(InterfaceID.DIALOG_PLAYER, DIALOG_PLAYER_TEXT_CHILD);
        if (playerTextWidget != null) {
            return "Player";
        }

        return null;
    }

    private Widget getPlayerDialogWidget() {
        return client.getWidget(InterfaceID.DIALOG_PLAYER, 0);
    }

    private Widget getNpcDialogWidget() {
        return client.getWidget(InterfaceID.DIALOG_NPC, 0);
    }

    private void toggleMute(Widget muteButton) {
        configManager.setConfiguration(Constants.PLUGIN_CONFIG_GROUP, "mute", !config.mute());
        audioManager.setVolume(config.mute() ? 0 : config.volume());
        muteButton.setSpriteId(getMuteSpriteId());
        muteButton.revalidate();
    }

    private int getMuteSpriteId() {
        return config.mute() ? SpriteID.OPTIONS_MUSIC_DISABLED : SpriteID.OPTIONS_MUSIC_VOLUME;
    }
}

package com.quest.voiceover;

import okhttp3.HttpUrl;

public final class Constants {

    public static final String PLUGIN_CONFIG_GROUP = "quest.voiceover";
    public static final String PLAYER_NAME_PLACEHOLDER = "Player";

    public static final HttpUrl RAW_GITHUB_SOUND_BRANCH_URL =
        HttpUrl.get("https://github.com/KevinEdry/runelite-quest-voiceover/raw/sounds");

    public static final HttpUrl RAW_GITHUB_DATABASE_BRANCH_URL =
        HttpUrl.get("https://github.com/KevinEdry/runelite-quest-voiceover/raw/database");

    public static final int MP3_BITRATE_KBPS = 96;

    private Constants() {}
}

package com.quest.voiceover;

import com.google.inject.Provides;
import com.quest.voiceover.features.QuestListIndicatorHandler;
import com.quest.voiceover.features.VoiceoverHandler;
import com.quest.voiceover.modules.audio.AudioDuckingManager;
import com.quest.voiceover.modules.audio.AudioManager;
import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.database.DatabaseVersionManager;
import com.quest.voiceover.modules.dialog.DialogManager;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.Client;
import net.runelite.api.events.*;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.ImageUtil;
import okhttp3.OkHttpClient;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.image.BufferedImage;
import java.util.Set;
import java.util.concurrent.ScheduledExecutorService;

@Slf4j
@PluginDescriptor(name = "Quest Voiceover")
public class QuestVoiceoverPlugin extends Plugin {

    @Inject
    private Client client;

    @Inject
    private EventBus eventBus;

    @Inject
    private OkHttpClient okHttpClient;

    @Inject
    private ScheduledExecutorService executor;

    @Inject
    private DatabaseManager databaseManager;

    @Inject
    private AudioManager audioManager;

    @Inject
    private AudioDuckingManager audioDuckingManager;

    @Inject
    private VoiceoverHandler voiceoverHandler;

    @Inject
    private QuestListIndicatorHandler questListIndicatorHandler;

    @Inject
    private DialogManager dialogManager;

    @Inject
    private ClientToolbar clientToolbar;

    private QuestVoiceoverPanel panel;
    private NavigationButton navigationButton;
    private String playerName;

    @Override
    protected void startUp() {
        eventBus.register(audioManager);

        panel = new QuestVoiceoverPanel();
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "icon.png");
        navigationButton = NavigationButton.builder()
            .tooltip("Quest Voiceover")
            .icon(icon)
            .priority(10)
            .panel(panel)
            .build();
        clientToolbar.addNavigation(navigationButton);

        executor.submit(this::initializeDatabase);
        log.info("Quest Voiceover plugin started");
    }

    @Override
    protected void shutDown() throws Exception {
        eventBus.unregister(audioManager);
        audioDuckingManager.restore();
        databaseManager.closeConnection();
        clientToolbar.removeNavigation(navigationButton);
        log.info("Quest Voiceover plugin stopped");
    }

    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (event.getType() != ChatMessageType.DIALOG) {
            return;
        }

        initializePlayerNameIfNeeded();
        voiceoverHandler.handleDialogMessage(event.getMessage(), playerName);
    }

    @Subscribe
    public void onMenuOptionClicked(MenuOptionClicked event) {
        if (event.getMenuOption().equals("Continue")) {
            voiceoverHandler.stopVoiceover();
        }
    }

    @Subscribe
    public void onWidgetLoaded(WidgetLoaded event) {
        if (isDialogWidget(event.getGroupId())) {
            voiceoverHandler.handleDialogOpened();
        }

        if (event.getGroupId() == InterfaceID.QUEST_LIST) {
            questListIndicatorHandler.onQuestListOpened();
        }
    }

    @Subscribe
    public void onWidgetClosed(WidgetClosed event) {
        if (isDialogWidget(event.getGroupId())) {
            voiceoverHandler.stopVoiceover();
        }

        if (event.getGroupId() == InterfaceID.QUEST_LIST) {
            questListIndicatorHandler.onQuestListClosed();
        }
    }

    @Subscribe
    public void onGameTick(GameTick event) {
        questListIndicatorHandler.onGameTick();

        boolean audioPlaying = audioManager.isPlaying();
        boolean playerMoving = isPlayerMoving();
        boolean dialogOpen = dialogManager.isPlayerOrNpcDialogOpen();

        if (audioPlaying && !dialogOpen) {
            log.debug("Stopping voiceover - dialog closed");
            audioManager.stopImmediately();
        }
    }

    private boolean isPlayerMoving() {
        var player = client.getLocalPlayer();
        if (player == null) {
            return false;
        }
        int poseAnimation = player.getPoseAnimation();
        int idleAnimation = player.getIdlePoseAnimation();
        return poseAnimation != idleAnimation || client.getLocalDestinationLocation() != null;
    }

    @Provides
    QuestVoiceoverConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(QuestVoiceoverConfig.class);
    }

    private void initializeDatabase() {
        DatabaseVersionManager.prepareDatabaseSource(okHttpClient);
        databaseManager.initializeConnection();
        Set<String> voicedQuests = databaseManager.getVoicedQuests();
        questListIndicatorHandler.setVoicedQuests(voicedQuests);
        SwingUtilities.invokeLater(() -> panel.updateInfo(databaseManager, voicedQuests));
        log.info("Database initialized");
    }

    private void initializePlayerNameIfNeeded() {
        if (playerName == null) {
            playerName = client.getLocalPlayer().getName();
        }
    }

    private boolean isDialogWidget(int groupId) {
        return groupId == InterfaceID.DIALOG_NPC
            || groupId == InterfaceID.DIALOG_PLAYER
            || groupId == InterfaceID.DIALOG_OPTION;
    }
}

package com.quest.voiceover.utility;

public final class TextUtility {

    private static final String OSRS_COLOR_TAG_PATTERN = "<col=[^>]*>";
    private static final String OSRS_COLOR_CLOSE_TAG = "</col>";
    private static final String OSRS_LINE_BREAK = "<br>";

    private TextUtility() {}

    public static String stripColorTags(String text) {
        return text
            .replaceAll(OSRS_COLOR_TAG_PATTERN, "")
            .replace(OSRS_COLOR_CLOSE_TAG, "");
    }

    public static String stripLineBreaks(String text) {
        return text.replace(OSRS_LINE_BREAK, " ");
    }

    public static String stripAllTags(String text) {
        return text.replaceAll("<[^>]+>", "");
    }

    public static String normalizeWhitespace(String text) {
        return text.replaceAll("\\s+", " ").trim();
    }

    public static String cleanForMatching(String text) {
        return normalizeWhitespace(stripAllTags(text));
    }

    public static String reapplyColorAfterLineBreaks(String text, String colorTag) {
        return text.replace(OSRS_LINE_BREAK, OSRS_COLOR_CLOSE_TAG + OSRS_LINE_BREAK + colorTag);
    }
}

package com.quest.voiceover.utility;

import com.quest.voiceover.Constants;

public final class MessageUtility {

    private MessageUtility() {}

    public static final class ParsedMessage {
        private final String characterName;
        private final String dialogText;
        private final String messageId;

        private ParsedMessage(String characterName, String dialogText, String messageId) {
            this.characterName = characterName;
            this.dialogText = dialogText;
            this.messageId = messageId;
        }

        public String characterName() {
            return characterName;
        }

        public String dialogText() {
            return dialogText;
        }

        public String messageId() {
            return messageId;
        }
    }

    public static ParsedMessage parseRawMessage(String rawMessage, String playerName) {
        String[] parts = rawMessage.split("\\|", 2);

        String characterName = normalizeCharacterName(parts[0], playerName);
        String dialogText = parts[1].trim();
        String messageId = HashUtility.toMD5(characterName + "|" + dialogText);

        return new ParsedMessage(characterName, dialogText, messageId);
    }

    public static String cleanWidgetText(String text, String playerName) {
        String cleaned = TextUtility.cleanForMatching(text);

        if (playerName != null && !playerName.isEmpty()) {
            cleaned = cleaned.replace(playerName, "");
        }

        return cleaned;
    }

    private static String normalizeCharacterName(String name, String playerName) {
        return name.equals(playerName) ? Constants.PLAYER_NAME_PLACEHOLDER : name;
    }
}

package com.quest.voiceover.utility;

import java.awt.Color;

public final class ColorUtility {

    public static final int WHITE = 0xFFFFFF;
    public static final int BLACK = 0x000000;

    private ColorUtility() {}

    public static String toHex(Color color) {
        return String.format("%02x%02x%02x", color.getRed(), color.getGreen(), color.getBlue());
    }

    public static String toOsrsColorTag(Color color) {
        return "<col=" + toHex(color) + ">";
    }

    public static String toOsrsColorTag(String hexColor) {
        return "<col=" + hexColor + ">";
    }

    public static String wrapWithColor(String text, Color color) {
        return toOsrsColorTag(color) + text + "</col>";
    }

    public static String wrapWithColor(String text, String hexColor) {
        return toOsrsColorTag(hexColor) + text + "</col>";
    }
}

package com.quest.voiceover.utility;

public class LevenshteinUtility {

    public static int distance(String source, String target) {
        if (source.length() < target.length()) {
            String swap = source;
            source = target;
            target = swap;
        }

        int[] previousRow = new int[target.length() + 1];
        int[] currentRow = new int[target.length() + 1];

        for (int targetIndex = 0; targetIndex <= target.length(); targetIndex++) {
            previousRow[targetIndex] = targetIndex;
        }

        for (int sourceIndex = 1; sourceIndex <= source.length(); sourceIndex++) {
            currentRow[0] = sourceIndex;
            for (int targetIndex = 1; targetIndex <= target.length(); targetIndex++) {
                int cost = source.charAt(sourceIndex - 1) == target.charAt(targetIndex - 1) ? 0 : 1;
                currentRow[targetIndex] = Math.min(
                    Math.min(previousRow[targetIndex] + 1, currentRow[targetIndex - 1] + 1),
                    previousRow[targetIndex - 1] + cost
                );
            }
            int[] swap = previousRow;
            previousRow = currentRow;
            currentRow = swap;
        }

        return previousRow[target.length()];
    }

    public static double similarity(String source, String target) {
        int distance = distance(source, target);
        int maxLength = Math.max(source.length(), target.length());
        return maxLength == 0 ? 1.0 : 1.0 - ((double) distance / maxLength);
    }
}

package com.quest.voiceover.utility;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public final class HashUtility {

    private HashUtility() {}

    public static String toMD5(String input) {
        return hash(input, "MD5");
    }

    public static String toSHA256(String input) {
        return hash(input, "SHA-256");
    }

    private static String hash(String input, String algorithm) {
        try {
            MessageDigest digest = MessageDigest.getInstance(algorithm);
            byte[] hashBytes = digest.digest(input.getBytes(StandardCharsets.UTF_8));
            return bytesToHex(hashBytes);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Hash algorithm not available: " + algorithm, e);
        }
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder(2 * bytes.length);
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }
}

package com.quest.voiceover;

import com.quest.voiceover.modules.database.DatabaseManager;
import com.quest.voiceover.modules.database.DatabaseVersionManager;
import net.runelite.api.Quest;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;
import java.util.Set;

public class QuestVoiceoverPanel extends PluginPanel
{
    private static final String PLUGIN_VERSION;
    private static final String REQUEST_QUEST_URL = "https://github.com/KevinEdry/runelite-quest-voiceover/issues/new?template=quest-request.yml";
    private static final String REPORT_ISSUE_URL = "https://github.com/KevinEdry/runelite-quest-voiceover/issues/new?template=issue-report.yml";
    private static final String DISCORD_URL = "https://discord.com/invite/tkr6tEbXJr";

    private static final ImageIcon ARROW_RIGHT_ICON;
    private static final ImageIcon GITHUB_ICON;
    private static final ImageIcon DISCORD_ICON;

    static
    {
        String version = "Unknown";
        try (InputStream input = QuestVoiceoverPanel.class.getResourceAsStream("version.properties"))
        {
            if (input != null)
            {
                Properties props = new Properties();
                props.load(input);
                version = props.getProperty("version", "Unknown");
            }
        }
        catch (IOException ignored)
        {
        }
        PLUGIN_VERSION = version;

        final BufferedImage arrowRight = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "arrow_right.png");
        ARROW_RIGHT_ICON = new ImageIcon(arrowRight);

        final BufferedImage githubIcon = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "github_icon.png");
        GITHUB_ICON = new ImageIcon(githubIcon);

        final BufferedImage discordIcon = ImageUtil.loadImageResource(QuestVoiceoverPanel.class, "discord_icon.png");
        DISCORD_ICON = new ImageIcon(discordIcon);
    }

    private final JLabel databaseVersionLabel;
    private final JLabel connectionStatusLabel;
    private final JLabel questCoverageLabel;
    private final JLabel questPercentageLabel;

    public QuestVoiceoverPanel()
    {
        super(false);

        setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new EmptyBorder(10, 10, 10, 10));

        // Title
        JLabel titleLabel = new JLabel("Quest Voiceover");
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setForeground(Color.WHITE);
        titleLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        add(titleLabel);
        add(Box.createVerticalStrut(10));

        // Plugin section
        JPanel pluginBox = new JPanel();
        pluginBox.setLayout(new BoxLayout(pluginBox, BoxLayout.Y_AXIS));
        pluginBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        pluginBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        pluginBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel pluginHeader = new JLabel("Plugin");
        pluginHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        pluginHeader.setForeground(Color.WHITE);
        pluginHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel pluginVersionLabel = new JLabel(htmlLabel("Version: ", PLUGIN_VERSION));
        pluginVersionLabel.setFont(FontManager.getRunescapeSmallFont());
        pluginVersionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        pluginVersionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        pluginBox.add(pluginHeader);
        pluginBox.add(Box.createVerticalStrut(8));
        pluginBox.add(pluginVersionLabel);

        // Database section
        JPanel databaseBox = new JPanel();
        databaseBox.setLayout(new BoxLayout(databaseBox, BoxLayout.Y_AXIS));
        databaseBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        databaseBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        databaseBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel databaseHeader = new JLabel("Database");
        databaseHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        databaseHeader.setForeground(Color.WHITE);
        databaseHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        databaseVersionLabel = new JLabel(htmlLabel("Version: ", "Loading..."));
        databaseVersionLabel.setFont(FontManager.getRunescapeSmallFont());
        databaseVersionLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        databaseVersionLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        connectionStatusLabel = new JLabel(htmlLabel("Status: ", "Loading..."));
        connectionStatusLabel.setFont(FontManager.getRunescapeSmallFont());
        connectionStatusLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        connectionStatusLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        databaseBox.add(databaseHeader);
        databaseBox.add(Box.createVerticalStrut(8));
        databaseBox.add(databaseVersionLabel);
        databaseBox.add(Box.createVerticalStrut(2));
        databaseBox.add(connectionStatusLabel);

        // Coverage section
        JPanel coverageBox = new JPanel();
        coverageBox.setLayout(new BoxLayout(coverageBox, BoxLayout.Y_AXIS));
        coverageBox.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        coverageBox.setBorder(new EmptyBorder(10, 10, 10, 10));
        coverageBox.setAlignmentX(Component.LEFT_ALIGNMENT);

        JLabel coverageHeader = new JLabel("Coverage");
        coverageHeader.setFont(FontManager.getRunescapeSmallFont().deriveFont(Font.BOLD));
        coverageHeader.setForeground(Color.WHITE);
        coverageHeader.setAlignmentX(Component.LEFT_ALIGNMENT);

        questCoverageLabel = new JLabel(htmlLabel("Quests voiced: ", "Loading..."));
        questCoverageLabel.setFont(FontManager.getRunescapeSmallFont());
        questCoverageLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        questCoverageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        questPercentageLabel = new JLabel(htmlLabel("Completion: ", "Loading..."));
        questPercentageLabel.setFont(FontManager.getRunescapeSmallFont());
        questPercentageLabel.setForeground(ColorScheme.LIGHT_GRAY_COLOR);
        questPercentageLabel.setAlignmentX(Component.LEFT_ALIGNMENT);

        coverageBox.add(coverageHeader);
        coverageBox.add(Box.createVerticalStrut(8));
        coverageBox.add(questCoverageLabel);
        coverageBox.add(Box.createVerticalStrut(2));
        coverageBox.add(questPercentageLabel);

        add(pluginBox);
        add(Box.createVerticalStrut(10));
        add(databaseBox);
        add(Box.createVerticalStrut(10));
        add(coverageBox);
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(GITHUB_ICON, "Request a", "new quest", REQUEST_QUEST_URL));
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(GITHUB_ICON, "Report an issue or", "make a suggestion", REPORT_ISSUE_URL));
        add(Box.createVerticalStrut(10));
        add(buildLinkPanel(DISCORD_ICON, "Talk to us on our", "Discord server", DISCORD_URL));
        add(Box.createVerticalGlue());
    }

    public void updateInfo(DatabaseManager databaseManager, Set<String> voicedQuests)
    {
        String dbVersion = DatabaseVersionManager.getDatabaseVersion();
        databaseVersionLabel.setText(htmlLabel("Version: ", dbVersion));

        boolean connected = databaseManager.isConnected();
        String statusText = connected ? "Connected" : "Disconnected";
        connectionStatusLabel.setText(htmlLabel("Status: ", statusText));

        int totalQuests = Quest.values().length;
        int voicedCount = voicedQuests != null ? voicedQuests.size() : 0;
        String coverageText = voicedCount + " / " + totalQuests;
        questCoverageLabel.setText(htmlLabel("Quests voiced: ", coverageText));

        double percentage = (voicedCount * 100.0) / totalQuests;
        String percentageText = String.format("%.1f%%", percentage);
        questPercentageLabel.setText(htmlLabel("Completion: ", percentageText));
    }

    private static String htmlLabel(String key, String value)
    {
        return "<html><body>" + key + "<span style='color:white'>" + value + "</span></body></html>";
    }

    private static JPanel buildLinkPanel(ImageIcon icon, String topText, String bottomText, String url)
    {
        JPanel container = new JPanel(new BorderLayout());
        container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        container.setBorder(new EmptyBorder(8, 10, 8, 10));
        container.setCursor(new Cursor(Cursor.HAND_CURSOR));
        container.setAlignmentX(Component.LEFT_ALIGNMENT);
        container.setMaximumSize(new Dimension(Integer.MAX_VALUE, 50));

        JLabel iconLabel = new JLabel(icon);

        JPanel textPanel = new JPanel();
        textPanel.setLayout(new BoxLayout(textPanel, BoxLayout.Y_AXIS));
        textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        textPanel.setBorder(new EmptyBorder(0, 10, 0, 0));

        JLabel topLabel = new JLabel(topText);
        topLabel.setForeground(Color.WHITE);
        topLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel bottomLabel = new JLabel(bottomText);
        bottomLabel.setForeground(Color.WHITE);
        bottomLabel.setFont(FontManager.getRunescapeSmallFont());

        textPanel.add(topLabel);
        textPanel.add(bottomLabel);

        JLabel arrowLabel = new JLabel(ARROW_RIGHT_ICON);

        container.add(iconLabel, BorderLayout.WEST);
        container.add(textPanel, BorderLayout.CENTER);
        container.add(arrowLabel, BorderLayout.EAST);

        container.addMouseListener(new java.awt.event.MouseAdapter()
        {
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                LinkBrowser.browse(url);
            }

            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                container.setBackground(ColorScheme.DARK_GRAY_COLOR);
                textPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
            }

            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                container.setBackground(ColorScheme.DARKER_GRAY_COLOR);
                textPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });

        return container;
    }
}

package com.quest.voiceover;

import net.runelite.client.config.*;

@ConfigGroup("quest.voiceover")
public interface QuestVoiceoverConfig extends Config
{
	@ConfigSection(
			name = "General",
			description = "General settings",
			position = 10,
			closedByDefault = false
	)
	String generalSettings = "generalSettings";

	@ConfigSection(
			name = "Quest Dialog",
			description = "Settings for the quest dialog overlay",
			position = 20,
			closedByDefault = false
	)
	String questDialogSettings = "questDialogSettings";

	@ConfigSection(
			name = "Quest List",
			description = "Settings for the quest list",
			position = 30,
			closedByDefault = false
	)
	String questListSettings = "questListSettings";

	@Range(min = 1, max = 100)
	@ConfigItem(
			keyName = "volume",
			name = "Volume",
			description = "Volume control for the voiceover sounds.",
			position = 11,
			section = generalSettings
	)
	default int volume() {
		return 75;
	}

	@ConfigItem(
			keyName = "mute",
			name = "Mute",
			description = "Mutes the voiceover sound.",
			section = generalSettings,
			position = 12
	)
	default boolean mute()
	{
		return false;
	}

	@ConfigItem(
			keyName = "audioDucking",
			name = "Audio Ducking",
			description = "Lowers game audio while voiceover plays.",
			section = generalSettings,
			position = 13
	)
	default boolean audioDucking()
	{
		return true;
	}

	@Range(min = 0, max = 100)
	@ConfigItem(
			keyName = "audioDuckingAmount",
			name = "Ducking Amount",
			description = "How much to lower game audio (0 = mute, 100 = no change).",
			section = generalSettings,
			position = 14
	)
	default int audioDuckingAmount()
	{
		return 25;
	}

	@ConfigItem(
			keyName = "showMuteButton",
			name = "Toggle Mute Button",
			description = "Shows the mute button on the quest dialog.",
			section = questDialogSettings,
			position = 21
	)
	default boolean showMuteButton()
	{
		return true;
	}

	@ConfigItem(
			keyName = "showQuestName",
			name = "Toggle Quest Name",
			description = "Shows the quest name on the quest dialog.",
			section = questDialogSettings,
			position = 23
	)
	default boolean showQuestName()
	{
		return true;
	}

	@ConfigItem(
			keyName = "speechHighlighting",
			name = "Speech Highlighting",
			description = "Highlights dialog text word-by-word as it is spoken.",
			section = questDialogSettings,
			position = 24
	)
	default boolean speechHighlighting()
	{
		return false;
	}

	@Alpha
	@ConfigItem(
			keyName = "speechHighlightColor",
			name = "Speech Highlight Color",
			description = "Color used to highlight words that have been spoken.",
			section = questDialogSettings,
			position = 25
	)
	default java.awt.Color speechHighlightColor()
	{
		return new java.awt.Color(0, 255, 0);
	}

	@ConfigItem(
			keyName = "showVoicedIndicator",
			name = "Toggle Voiced Quest Indicator",
			description = "Shows [Voiced] prefix next to quests with voice acting in the quest list.",
			section = questListSettings,
			position = 31
	)
	default boolean showVoicedIndicator()
	{
		return true;
	}
}

package com.quest.voiceover;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class QuestVoiceoverPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(QuestVoiceoverPlugin.class);
		RuneLite.main(args);
	}
}
