package com.creatorskit.swing;

import com.creatorskit.Character;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@AllArgsConstructor
@Getter
@Setter
public class ObjectPanel extends JPanel
{
    private String name;
    private Character character;
    private JPanel programPanel;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.models.ModelImporter;
import com.creatorskit.models.*;
import com.creatorskit.models.exporters.ModelExporter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.filechooser.FileFilter;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

@Slf4j
public class ModelOrganizer extends JPanel
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final ClientThread clientThread;
    private final ModelImporter modelImporter;
    private final ModelExporter modelExporter;
    private final CreatorsConfig config;
    private final BufferedImage CLEAR = ImageUtil.loadImageResource(getClass(), "/Clear.png");
    private final BufferedImage ANVIL = ImageUtil.loadImageResource(getClass(), "/Anvil.png");
    private final BufferedImage SAVE = ImageUtil.loadImageResource(getClass(), "/Save.png");
    private final BufferedImage TRANSMOG = ImageUtil.loadImageResource(getClass(), "/Transmog.png");
    private final BufferedImage EXPORT = ImageUtil.loadImageResource(getClass(), "/Export.png");
    private final Dimension buttonDimension = new Dimension(30, 25);
    private final HashMap<CustomModel, JPanel> panelMap = new HashMap<>();
    private final JPanel modelPanel = new JPanel();
    private final GridBagConstraints c = new GridBagConstraints();
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    public final File BLENDER_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/blender-models");

    @Inject
    public ModelOrganizer(Client client, CreatorsPlugin plugin, ClientThread clientThread, ModelImporter modelImporter, ModelExporter modelExporter, CreatorsConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.modelImporter = modelImporter;
        this.modelExporter = modelExporter;
        this.config = config;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        JScrollPane scrollPane = new JScrollPane();
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new GridBagLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(headerPanel);
        add(scrollPane);

        JPanel viewport = new JPanel();
        viewport.setBorder(new EmptyBorder(6, 4, 6, 4));
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.setLayout(new GridBagLayout());
        scrollPane.setViewportView(viewport);

        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        modelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        modelPanel.setLayout(new GridLayout(0, 8, 8, 8));
        viewport.add(modelPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);
        c.weighty = 0;

        c.gridx = 0;
        c.gridy = 0;
        c.gridheight = 4;
        c.weightx = 10;
        JLabel organizerLabel = new JLabel("Model Organizer");
        organizerLabel.setHorizontalAlignment(SwingConstants.CENTER);
        organizerLabel.setFont(FontManager.getRunescapeBoldFont());
        headerPanel.add(organizerLabel, c);

        c.gridx = 2;
        c.gridy = 0;
        c.gridheight = 4;
        c.weightx = 1;
        JPanel cacheSearcherPanel = new JPanel();
        cacheSearcherPanel.setLayout(new GridLayout(0, 1, 4, 4));
        cacheSearcherPanel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        headerPanel.add(cacheSearcherPanel, c);

        JLabel searcherLabel = new JLabel("Cache Searcher");
        searcherLabel.setHorizontalAlignment(SwingConstants.CENTER);
        searcherLabel.setFont(FontManager.getRunescapeBoldFont());
        cacheSearcherPanel.add(searcherLabel);

        JSpinner idSpinner = new JSpinner(new SpinnerNumberModel(0, 0, 99999, 1));
        idSpinner.setToolTipText("Choose the NPC, Object, or Item Id to find all its associated models");
        cacheSearcherPanel.add(idSpinner);

        JComboBox<CustomModelType> modelTypeComboBox = new JComboBox<>();
        modelTypeComboBox.addItem(CustomModelType.CACHE_NPC);
        modelTypeComboBox.addItem(CustomModelType.CACHE_OBJECT);
        modelTypeComboBox.addItem(CustomModelType.CACHE_GROUND_ITEM);
        modelTypeComboBox.addItem(CustomModelType.CACHE_MAN_WEAR);
        modelTypeComboBox.addItem(CustomModelType.CACHE_WOMAN_WEAR);
        modelTypeComboBox.setFocusable(false);
        modelTypeComboBox.setToolTipText("Pick which part of the cache to search");
        cacheSearcherPanel.add(modelTypeComboBox);

        JButton addCustomModelButton = new JButton("Add Custom Model");
        addCustomModelButton.setToolTipText("Add the chosen NPC, Object, or Item as a Custom Model");
        cacheSearcherPanel.add(addCustomModelButton);
        addCustomModelButton.addActionListener(e ->
        {
            CustomModelType type = (CustomModelType) modelTypeComboBox.getSelectedItem();
            if (type == null)
                return;

            int id = (int) idSpinner.getValue();
            plugin.cacheToCustomModel(type, id, -1);
        });

        c.gridx = 3;
        c.gridy = 0;
        c.gridheight = 1;
        c.gridwidth = 2;
        c.weightx = 0.5;
        JButton loadCustomButton = new JButton("Load Custom Model");
        loadCustomButton.setToolTipText("Loads a previously forged and saved Custom Model");
        headerPanel.add(loadCustomButton, c);
        loadCustomButton.addActionListener(e -> openLoadDialog());

        c.gridx = 3;
        c.gridy = 1;
        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0.5;
        JButton loadBlenderButton = new JButton("Load Blender Model");
        loadBlenderButton.setToolTipText("Loads a model exported from Blender");
        headerPanel.add(loadBlenderButton, c);
        loadBlenderButton.addActionListener(e -> modelImporter.openLoadDialog());

        c.gridx = 4;
        c.gridy = 1;
        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0;
        JButton quickLoadBlenderButton = new JButton("Quick");
        quickLoadBlenderButton.setToolTipText("Loads the latest model exported from Blender in the " + RuneLite.RUNELITE_DIR + "\\creatorskit\\blender-models folder");
        headerPanel.add(quickLoadBlenderButton, c);
        quickLoadBlenderButton.addActionListener(e -> modelImporter.openLatestFile());

        c.gridx = 3;
        c.gridy = 2;
        c.gridheight = 2;
        c.gridwidth = 2;
        c.weightx = 0.5;
        JButton clearButton = new JButton("Clear Unused Models");
        clearButton.setToolTipText("Clears all unused models from Custom Model dropdown menus");
        headerPanel.add(clearButton, c);
        clearButton.addActionListener(e ->
        {
            ArrayList<CustomModel> unusedModels = new ArrayList<>();
            CustomModel transmogModel = plugin.getTransmogModel();

            for (int i = 0; i < plugin.getStoredModels().size(); i++)
            {
                CustomModel customModel = plugin.getStoredModels().get(i);

                if (customModel == transmogModel)
                    continue;

                boolean isBeingUsed = false;
                for (Character character : plugin.getCharacters())
                {
                    if (character.getStoredModel() == customModel)
                    {
                        isBeingUsed = true;
                        break;
                    }
                }

                if (!isBeingUsed)
                    unusedModels.add(customModel);
            }

            for (CustomModel customModel : unusedModels)
                plugin.removeCustomModel(customModel);
        });

        revalidate();
    }

    public void createModelPanel(CustomModel model)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        modelPanel.add(panel);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.weighty = 0;
        c.gridwidth = 1;
        c.gridheight = 1;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridx = 0;
        c.gridy = 0;
        JTextField textField = new JTextField();
        textField.setText(model.getComp().getName());
        textField.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(textField, c);
        panelMap.put(model, panel);
        textField.addActionListener(e ->
        {
            String text = StringHandler.cleanString(textField.getText());
            textField.setText(text);
            model.getComp().setName(text);
            plugin.updatePanelComboBoxes();
            plugin.getCreatorsPanel().getTransmogPanel().getTransmogLabel().setText(text);
        });
        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                String text = StringHandler.cleanString(textField.getText());
                textField.setText(text);
                model.getComp().setName(text);
            }
        });

        c.gridx = 0;
        c.gridy = 1;
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 0, 4, 4));
        panel.add(buttonsPanel, c);

        JButton deleteButton = new JButton(new ImageIcon(CLEAR));
        deleteButton.setPreferredSize(buttonDimension);
        deleteButton.setToolTipText("Remove this model from all Objects and dropdown menus");
        deleteButton.addActionListener(e -> plugin.removeCustomModel(model));
        buttonsPanel.add(deleteButton);

        JButton anvilButton = new JButton(new ImageIcon(ANVIL));
        anvilButton.setPreferredSize(buttonDimension);
        anvilButton.setToolTipText("Send this model to the Anvil");
        buttonsPanel.add(anvilButton);
        anvilButton.addActionListener(e -> plugin.customModelToAnvil(model));

        JButton saveButton = new JButton(new ImageIcon(SAVE));
        saveButton.setPreferredSize(buttonDimension);
        saveButton.setToolTipText("Save this model for future use");
        buttonsPanel.add(saveButton);
        saveButton.addActionListener(e -> openSaveDialog(model, textField.getText()));

        JButton transmogButton = new JButton(new ImageIcon(TRANSMOG));
        transmogButton.setPreferredSize(buttonDimension);
        transmogButton.setToolTipText("Set this as your player transmog");
        buttonsPanel.add(transmogButton);
        transmogButton.addActionListener(e -> setTransmog(model));

        JButton exportButton = new JButton(new ImageIcon(EXPORT));
        exportButton.setPreferredSize(buttonDimension);
        exportButton.setToolTipText("Export this model to a 3D format based on the Model Exporter settings in the config");
        buttonsPanel.add(exportButton);
        exportButton.addActionListener(e ->
        {
            clientThread.invokeLater(() ->
            {
                String name = model.getComp().getName();
                BlenderModel blenderModel = modelExporter.bmFromCustomModel(model);
                modelExporter.saveToFile(name, blenderModel);
            });
        });

        revalidate();
        repaint();
    }

    public void removeModelPanel(CustomModel model)
    {
        JPanel panel = panelMap.get(model);
        modelPanel.remove(panel);
        panelMap.remove(model);
        revalidate();
        repaint();
    }

    private void openLoadDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");
        fileChooser.setMultiSelectionEnabled(true);
        fileChooser.setFileFilter(new FileFilter()
        {
            @Override
            public String getDescription()
            {
                return "Json File (*.json)";
            }

            @Override
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }
                else
                {
                    String filename = f.getName().toLowerCase();
                    return filename.endsWith(".json");
                }
            }
        });

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File[] files = fileChooser.getSelectedFiles();
            for (File selectedFile : files)
            {
                String name = selectedFile.getName();
                if (name.endsWith(".json"))
                    name = replaceLast(name, ".json");

                if (!selectedFile.exists())
                {
                    selectedFile = new File(selectedFile.getPath() + ".json");
                    if (!selectedFile.exists())
                    {
                        plugin.sendChatMessage("Could not find the requested Custom Model file.");
                        continue;
                    }
                }

                plugin.loadCustomModel(selectedFile, false, name);
            }
        }
    }

    private String replaceLast(String string, String from)
    {
        int lastIndex = string.lastIndexOf(from);
        if (lastIndex < 0)
            return string;
        String tail = string.substring(lastIndex).replaceFirst(from, "");
        return string.substring(0, lastIndex) + tail;
    }

    private void openSaveDialog(CustomModel customModel, String name)
    {
        File outputDir = MODELS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save Custom Model");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile, customModel);
        }
    }

    public void saveToFile(File file, CustomModel customModel)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            CustomModelComp comp = customModel.getComp();
            DetailedModel[] detailedModels = comp.getDetailedModels();
            if (detailedModels == null)
            {
                detailedModels = modelToDetailedPanels(customModel);
                comp.setDetailedModels(detailedModels);
            }

            String string = plugin.getGson().toJson(comp);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving Custom Model to file");
        }
    }

    public DetailedModel[] modelToDetailedPanels(CustomModel customModel)
    {
        return modelToDetailedPanels(customModel.getComp());
    }

    public DetailedModel[] modelToDetailedPanels(CustomModelComp comp)
    {
        CustomModelType type = comp.getType();

        ModelStats[] modelStats = comp.getModelStats();
        DetailedModel[] detailedModels = new DetailedModel[modelStats.length];
        int group = 1;
        if (type == CustomModelType.CACHE_NPC)
            group = 8;

        if (type == CustomModelType.CACHE_PLAYER)
            group = 9;

        for (int i = 0; i < modelStats.length; i++)
        {
            ModelStats modelStat = modelStats[i];

            short[] colourFrom = modelStat.getRecolourFrom();
            short[] colourTo = modelStat.getRecolourTo();

            BodyPart bp = modelStat.getBodyPart();
            if (type == CustomModelType.CACHE_PLAYER && modelStat.getBodyPart() != BodyPart.NA)
            {
                colourFrom = ArrayUtils.addAll(colourFrom, KitRecolourer.getKitRecolourFrom(modelStat.getBodyPart()));
                colourTo = ArrayUtils.addAll(colourTo, KitRecolourer.getKitRecolourTo(modelStat.getBodyPart(), comp.getKitRecolours()));
            }

            String bodyPart = "Name";
            if (type == CustomModelType.CACHE_PLAYER)
                bodyPart = "Item";

            if (bp != BodyPart.NA)
                bodyPart = modelStat.getBodyPart().toString();

            DetailedModel detailedModel = new DetailedModel(
                    bodyPart,
                    modelStat.getModelId(),
                    group,
                    0, 0, 0,
                    0, 0, 0,
                    modelStat.getResizeX(),
                    modelStat.getResizeY(),
                    modelStat.getResizeZ(),
                    0,
                    "", "",
                    colourFrom, colourTo,
                    modelStat.getTextureFrom(), modelStat.getTextureTo(),
                    false);
            detailedModels[i] = detailedModel;
        }

        return detailedModels;
    }

    public void setTransmog(CustomModel customModel)
    {
        CKObject transmog = plugin.getTransmog();
        if (transmog == null)
        {
            transmog = new CKObject(client);
            client.registerRuneLiteObject(transmog);
            plugin.setTransmog(transmog);
        }

        plugin.setTransmogModel(customModel);
        plugin.getCreatorsPanel().getTransmogPanel().getTransmogLabel().setText(customModel.getComp().getName());
        transmog.setModel(customModel.getModel());
        transmog.setRadius(plugin.getCreatorsPanel().getTransmogPanel().getRadius());
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.saves.TransmogLoadOption;
import com.creatorskit.saves.TransmogSave;
import com.creatorskit.models.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import org.apache.commons.lang3.ArrayUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;

@Slf4j
@Getter
public class TransmogPanel extends JPanel
{
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final File TRANSMOGS_DIR = new File(Paths.get(RuneLite.RUNELITE_DIR.getPath(), "creatorskit").toString(), "transmogs");
    private final GridBagConstraints c = new GridBagConstraints();
    private final JLabel transmogLabel = new JLabel("None");
    private final JSpinner radiusSpinner = new JSpinner(new SpinnerNumberModel(60, 0, 99999, 1));
    private final JComboBox<TransmogAnimationMode> animationComboBox = new JComboBox<>();
    private final JSpinner poseSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner walkSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner runSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner actionSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner backwardsSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner rightSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner leftSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner rotateSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JPanel animationSwapsPanel = new JPanel();
    private TransmogAnimationMode transmogAnimationMode = TransmogAnimationMode.PLAYER;
    private int[][] animationSwaps = new int[0][2];
    private int poseAnimation = -1;
    private int walkAnimation = -1;
    private int runAnimation = -1;
    private int actionAnimation = -1;
    private int backwardsAnimation = -1;
    private int rightAnimation = -1;
    private int leftAnimation = -1;
    private int rotateAnimation = -1;
    private int radius = 60;

    @Inject
    public TransmogPanel(@Nullable Client client, ClientThread clientThread, CreatorsPlugin plugin)
    {
        this.clientThread = clientThread;
        this.plugin = plugin;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        JScrollPane scrollPane = new JScrollPane();
        add(scrollPane);

        JPanel rowHeaderPanel = new JPanel();
        rowHeaderPanel.setLayout(new GridBagLayout());
        rowHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setRowHeaderView(rowHeaderPanel);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        JLabel currentLabel = new JLabel("Current Transmog");
        currentLabel.setHorizontalAlignment(SwingConstants.CENTER);
        currentLabel.setFont(FontManager.getRunescapeBoldFont());
        rowHeaderPanel.add(currentLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 2;
        transmogLabel.setHorizontalAlignment(SwingConstants.CENTER);
        transmogLabel.setForeground(Color.YELLOW);
        rowHeaderPanel.add(transmogLabel, c);

        c.gridx = 0;
        c.gridy = 3;
        c.gridwidth = 1;
        JLabel radiusLabel = new JLabel("Radius:");
        radiusLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(radiusLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        c.gridwidth = 1;
        radiusSpinner.setToolTipText("Set the radius of your transmog. 60 is best for an object the size of 1 tile");
        radiusSpinner.addChangeListener(e -> {
            radius = (int) radiusSpinner.getValue();
            CKObject CKObject = plugin.getTransmog();
            if (CKObject == null)
                return;

            clientThread.invokeLater(() -> CKObject.setRadius(radius));
        });
        rowHeaderPanel.add(radiusSpinner, c);

        c.gridx = 0;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel swapTitle = new JLabel("Animation Swaps");
        swapTitle.setHorizontalAlignment(SwingConstants.CENTER);
        swapTitle.setFont(FontManager.getRunescapeBoldFont());
        rowHeaderPanel.add(swapTitle, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 6;
        JLabel systemLabel = new JLabel("System:");
        systemLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(systemLabel, c);

        c.gridx = 1;
        c.gridy = 6;
        animationComboBox.addItem(TransmogAnimationMode.PLAYER);
        animationComboBox.addItem(TransmogAnimationMode.MODIFIED);
        animationComboBox.addItem(TransmogAnimationMode.CUSTOM);
        animationComboBox.addItem(TransmogAnimationMode.NONE);
        animationComboBox.setFocusable(false);
        animationComboBox.setToolTipText("<html>" + "Set how to handle your Transmog's animations" + "<br>" +
                "1) Player: Copy your player character's animations," + "<br>" +
                "2) Modified: Use all swaps indicated here; otherwise, copy your player character's animations," + "<br>" +
                "3) Custom: Only use the animations indicated here," + "<br>" +
                "4) None: Don't animate at all" + "<html>");

        animationComboBox.addItemListener(e -> transmogAnimationMode = (TransmogAnimationMode) animationComboBox.getSelectedItem());
        rowHeaderPanel.add(animationComboBox, c);

        c.gridx = 0;
        c.gridy = 7;
        JLabel poseLabel = new JLabel("Pose:");
        poseLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(poseLabel, c);

        c.gridx = 1;
        c.gridy = 7;
        poseSpinner.setToolTipText("Custom only: Set your Transmog's idle/pose animation");
        poseSpinner.addChangeListener(e -> poseAnimation = (int) poseSpinner.getValue());
        rowHeaderPanel.add(poseSpinner, c);

        c.gridx = 0;
        c.gridy = 8;
        JLabel walkLabel = new JLabel("Walk:");
        walkLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(walkLabel, c);

        c.gridx = 1;
        c.gridy = 8;
        walkSpinner.setToolTipText("Custom only: Set your Transmog's walk animation");
        walkSpinner.addChangeListener(e -> walkAnimation = (int) walkSpinner.getValue());
        rowHeaderPanel.add(walkSpinner, c);

        c.gridx = 0;
        c.gridy = 9;
        JLabel runLabel = new JLabel("Run:");
        runLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(runLabel, c);

        c.gridx = 1;
        c.gridy = 9;
        runSpinner.setToolTipText("Custom only: Set your Transmog's run animation");
        runSpinner.addChangeListener(e -> runAnimation = (int) runSpinner.getValue());
        rowHeaderPanel.add(runSpinner, c);

        c.gridx = 0;
        c.gridy = 10;
        JLabel actionLabel = new JLabel("Action:");
        actionLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(actionLabel, c);

        c.gridx = 1;
        c.gridy = 10;
        actionSpinner.setToolTipText("Custom only: Set your Transmog's default interact animation");
        actionSpinner.addChangeListener(e -> actionAnimation = (int) actionSpinner.getValue());
        rowHeaderPanel.add(actionSpinner, c);

        c.gridx = 0;
        c.gridy = 11;
        JLabel backwardsLabel = new JLabel("Backwards:");
        backwardsLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(backwardsLabel, c);

        c.gridx = 1;
        c.gridy = 11;
        backwardsSpinner.setToolTipText("Custom only: Set your Transmog's backwards walk animation");
        backwardsSpinner.addChangeListener(e -> backwardsAnimation = (int) backwardsSpinner.getValue());
        rowHeaderPanel.add(backwardsSpinner, c);

        c.gridx = 0;
        c.gridy = 12;
        JLabel rightLabel = new JLabel("Shuffle Right:");
        rightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(rightLabel, c);

        c.gridx = 1;
        c.gridy = 12;
        rightSpinner.setToolTipText("Custom only: Set your Transmog's shuffle right animation");
        rightSpinner.addChangeListener(e -> rightAnimation = (int) rightSpinner.getValue());
        rowHeaderPanel.add(rightSpinner, c);

        c.gridx = 0;
        c.gridy = 13;
        JLabel leftLabel = new JLabel("Shuffle Left:");
        leftLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(leftLabel, c);

        c.gridx = 1;
        c.gridy = 13;
        leftSpinner.setToolTipText("Custom only: Set your Transmog's shuffle left animation");
        leftSpinner.addChangeListener(e -> leftAnimation = (int) leftSpinner.getValue());
        rowHeaderPanel.add(leftSpinner, c);

        c.gridx = 0;
        c.gridy = 14;
        JLabel rotateLabel = new JLabel("Rotate:");
        rotateLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(rotateLabel, c);

        c.gridx = 1;
        c.gridy = 14;
        rotateSpinner.setToolTipText("Custom only: Set your Transmog's rotate animation");
        rotateSpinner.addChangeListener(e -> rotateAnimation = (int) rotateSpinner.getValue());
        rowHeaderPanel.add(rotateSpinner, c);

        c.gridx = 0;
        c.gridy = 15;
        JButton defaultsButton = new JButton("Defaults");
        defaultsButton.setToolTipText("Sets all the Animation Swaps to player defaults");
        defaultsButton.addActionListener(e ->
        {
            poseSpinner.setValue(808);
            walkSpinner.setValue(819);
            runSpinner.setValue(824);
            actionSpinner.setValue(866);
            backwardsSpinner.setValue(820);
            rightSpinner.setValue(822);
            leftSpinner.setValue(821);
            rotateSpinner.setValue(823);
        });
        rowHeaderPanel.add(defaultsButton, c);

        c.gridx = 1;
        c.gridy = 15;
        JButton resetButton = new JButton("Reset");
        resetButton.setToolTipText("Resets all regular Animation Swaps to -1");
        resetButton.addActionListener(e ->
        {
            resetSidePanel();
        });
        rowHeaderPanel.add(resetButton, c);

        c.gridwidth = 2;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 16;
        JButton addButton = new JButton("Add additional swap");
        addButton.setToolTipText("Add another specific animation swap");
        addButton.addActionListener(e -> addSwapPanel());
        rowHeaderPanel.add(addButton, c);

        JPanel columnHeaderPanel = new JPanel();
        columnHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(columnHeaderPanel);

        JButton saveButton = new JButton("Save");
        saveButton.setToolTipText("Saves your Transmog and Animation Swaps for future use");
        columnHeaderPanel.add(saveButton);
        saveButton.addActionListener(e ->
        {
            openSaveDialog(transmogLabel.getText());
        });

        JButton loadButton = new JButton("Load");
        loadButton.setToolTipText("Load a previously saved Transmog and/or set of Animation Swaps");
        columnHeaderPanel.add(loadButton);
        loadButton.addActionListener(e ->
        {
            openLoadDialog();
        });

        JButton clearButton = new JButton("Clear");
        clearButton.setToolTipText("Clear all Additional Swaps");
        columnHeaderPanel.add(clearButton);
        clearButton.addActionListener(e ->
        {
            clearSwapPanels();
        });

        c.insets = new Insets(0, 0, 0, 0);
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel viewport = new JPanel();
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.setBorder(new EmptyBorder(4, 6, 4, 6));
        viewport.add(animationSwapsPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        scrollPane.setViewportView(viewport);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        animationSwapsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        animationSwapsPanel.setLayout(new GridLayout(0, 8, 8, 8));
        revalidate();
    }

    private void addSwapPanel()
    {
        addSwapPanel(-1, -1);
    }

    private void addSwapPanel(int swapOut, int swapIn)
    {
        JPanel swap = new JPanel();
        swap.setLayout(new GridBagLayout());
        swap.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1, true));

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;
        c.gridwidth = 1;

        final int[] animationSwap = new int[]{swapOut, swapIn};
        if (swapOut != -1)
            addAnimationSwap(swapOut, swapIn);

        c.gridx = 0;
        c.gridy = 0;
        JLabel outLabel = new JLabel("Swap out:");
        outLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        swap.add(outLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        JSpinner outSpinner = new JSpinner(new SpinnerNumberModel(swapOut, -1, 99999, 1));
        outSpinner.setToolTipText("Pick which player animation to swap out");
        swap.add(outSpinner, c);

        c.gridx = 0;
        c.gridy = 1;
        JLabel inLabel = new JLabel("Swap in:");
        inLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        swap.add(inLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner inSpinner = new JSpinner(new SpinnerNumberModel(swapIn, -1, 99999, 1));
        inSpinner.setToolTipText("Pick which new animation to swap in");
        swap.add(inSpinner, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 2;
        JButton removeButton = new JButton("Remove");
        removeButton.setToolTipText("Removes this animation swap");
        removeButton.addActionListener(e ->
        {
            int out = (int) outSpinner.getValue();
            int in = (int) inSpinner.getValue();
            removeSwapPanel(swap, out, in);
        });
        swap.add(removeButton, c);

        inSpinner.addChangeListener(e ->
        {
            int previousIn = animationSwap[1];
            int newIn = (int) inSpinner.getValue();
            int newOut = (int) outSpinner.getValue();

            if (newOut != -1)
            {
                removeAnimationSwap(newOut, previousIn);
                addAnimationSwap(newOut, newIn);
            }

            animationSwap[0] = newOut;
            animationSwap[1] = newIn;
        });

        outSpinner.addChangeListener(e ->
        {
            int previousOut = animationSwap[0];
            int newIn = (int) inSpinner.getValue();
            int newOut = (int) outSpinner.getValue();

            if (newOut == -1)
                removeAnimationSwap(previousOut, newIn);

            if (newOut != -1 && previousOut != -1)
            {
                removeAnimationSwap(previousOut, newIn);
                addAnimationSwap(newOut, newIn);
            }

            if (newOut != -1 && previousOut == -1)
                addAnimationSwap(newOut, newIn);

            animationSwap[0] = newOut;
            animationSwap[1] = newIn;
        });

        animationSwapsPanel.add(swap);
        revalidate();
        repaint();
    }

    private void resetSidePanel()
    {
        poseSpinner.setValue(-1);
        walkSpinner.setValue(-1);
        runSpinner.setValue(-1);
        actionSpinner.setValue(-1);
        backwardsSpinner.setValue(-1);
        rightSpinner.setValue(-1);
        leftSpinner.setValue(-1);
        rotateSpinner.setValue(-1);
    }

    private void clearSwapPanels()
    {
        animationSwaps = new int[0][2];
        animationSwapsPanel.removeAll();
        revalidate();
        repaint();
    }

    private void removeSwapPanel(JPanel panel, int out, int in)
    {
        animationSwapsPanel.remove(panel);
        removeAnimationSwap(out, in);
        revalidate();
        repaint();
    }

    private void removeAnimationSwap(int out, int in)
    {
        int index = -1;
        for (int i = 0; i < animationSwaps.length; i++)
        {
            int[] array = animationSwaps[i];
            if (array[0] == out && array[1] == in)
            {
                index = i;
                break;
            }
        }

        if (index == -1)
            return;

        animationSwaps = ArrayUtils.remove(animationSwaps, index);
    }

    private void addAnimationSwap(int out, int in)
    {
        animationSwaps = ArrayUtils.add(animationSwaps, new int[]{out, in});
    }

    private void openSaveDialog(String name)
    {
        File outputDir = TRANSMOGS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save current model collection");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile);
        }
    }

    public void saveToFile(File file)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            CustomModelComp comp = null;
            CustomModel customModel = plugin.getTransmogModel();
            if (customModel != null && customModel.getComp() != null)
                comp = customModel.getComp();

            TransmogSave transmogSave = new TransmogSave(
                    comp,
                    transmogAnimationMode,
                    animationSwaps,
                    poseAnimation,
                    walkAnimation,
                    runAnimation,
                    actionAnimation,
                    backwardsAnimation,
                    rightAnimation,
                    leftAnimation,
                    rotateAnimation,
                    radius);
            String string = plugin.getGson().toJson(transmogSave);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving model to file via TransmogPanel");
        }
    }

    private void openLoadDialog()
    {
        TRANSMOGS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(TRANSMOGS_DIR);
        fileChooser.setDialogTitle("Choose a transmog to load");

        JComboBox<TransmogLoadOption> comboBox = new JComboBox<>();
        comboBox.setToolTipText("Load the transmog model, animations, or both");
        comboBox.addItem(TransmogLoadOption.BOTH);
        comboBox.addItem(TransmogLoadOption.CUSTOM_MODEL);
        comboBox.addItem(TransmogLoadOption.ANIMATIONS);
        comboBox.setFocusable(false);

        fileChooser.setAccessory(comboBox);

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            plugin.loadTransmog(selectedFile, (TransmogLoadOption) comboBox.getSelectedItem());
        }
    }

    public void loadTransmog(TransmogSave transmogSave)
    {
        transmogAnimationMode = transmogSave.getTransmogAnimationMode();
        poseAnimation = transmogSave.getPoseAnimation();
        walkAnimation = transmogSave.getWalkAnimation();
        runAnimation = transmogSave.getRunAnimation();
        actionAnimation = transmogSave.getActionAnimation();
        backwardsAnimation = transmogSave.getBackwardsAnimation();
        rightAnimation = transmogSave.getRightAnimation();
        leftAnimation = transmogSave.getLeftAnimation();
        rotateAnimation = transmogSave.getRotateAnimation();
        radius = transmogSave.getRadius();

        animationComboBox.setSelectedItem(transmogAnimationMode);
        poseSpinner.setValue(poseAnimation);
        walkSpinner.setValue(walkAnimation);
        runSpinner.setValue(runAnimation);
        actionSpinner.setValue(actionAnimation);
        backwardsSpinner.setValue(backwardsAnimation);
        rightSpinner.setValue(rightAnimation);
        leftSpinner.setValue(leftAnimation);
        rotateSpinner.setValue(rotateAnimation);
        radiusSpinner.setValue(radius);

        clearSwapPanels();
        animationSwaps = transmogSave.getAnimationSwaps();
        if (animationSwaps != null)
        {
            for (int[] swap : animationSwaps)
            {
                addSwapPanel(swap[0], swap[1]);
            }
        }
    }
}

package com.creatorskit.swing.colours;

import com.creatorskit.swing.ComplexPanel;
import com.creatorskit.swing.CreatorsPanel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.ModelData;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.colorchooser.AbstractColorChooserPanel;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class ColourSwapPanel extends JPanel
{
    private final Client client;
    private final ClientThread clientThread;
    private final ArrayList<ComplexPanel> complexPanels;
    private final GridBagConstraints c = new GridBagConstraints();
    private final Dimension LABEL_DIMENSION = new Dimension(250, 30);
    private final Dimension TOP_BAR_DIMENSION = new Dimension(100, 25);
    private final BufferedImage COPY_COLOURS = ImageUtil.loadImageResource(getClass(), "/Copy_Colours.png");
    private final BufferedImage PASTE_COLOURS = ImageUtil.loadImageResource(getClass(), "/Paste_Colours.png");
    private final JColorChooser colourChooser = new JColorChooser();
    @Getter
    private final JComboBox<ComplexPanel> comboBox = new JComboBox<>();
    @Getter
    private ColourPanel[] colourPanels = new ColourPanel[0];
    @Getter
    private TexturePanel[] texturePanels = new TexturePanel[0];
    @Getter
    private final JPanel colourHolder = new JPanel();
    @Getter
    private final JPanel textureHolder = new JPanel();
    @Getter
    @Setter
    private ComplexPanel currentComplexPanel;
    @Getter
    @Setter
    private short[][] copiedColoursTextures = new short[4][0];

    @Inject
    public ColourSwapPanel(Client client, ClientThread clientThread, ArrayList<ComplexPanel> complexPanels)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.complexPanels = complexPanels;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new GridBagLayout());
        setBorder(new EmptyBorder(2, 2, 2, 2));

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.gridwidth = 1;
        c.weightx = 6;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel comboPane = new JPanel();
        comboPane.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        add(comboPane, c);

        JLabel swapLabel = new JLabel("Model:  ", SwingConstants.RIGHT);
        swapLabel.setFont(FontManager.getRunescapeBoldFont());
        swapLabel.setPreferredSize(TOP_BAR_DIMENSION);
        comboPane.add(swapLabel);

        comboBox.addActionListener(e -> onSwapperPressed((ComplexPanel) comboBox.getSelectedItem()));
        comboBox.setPreferredSize(new Dimension(250, 25));
        comboPane.add(comboBox);

        JButton copyButton = new JButton(new ImageIcon(COPY_COLOURS));
        copyButton.setToolTipText("Copy all swapped colours & textures");
        copyButton.setPreferredSize(TOP_BAR_DIMENSION);
        copyButton.addActionListener(e -> copyColoursTextures(currentComplexPanel));
        comboPane.add(copyButton);

        JButton pasteButton = new JButton(new ImageIcon(PASTE_COLOURS));
        pasteButton.setToolTipText("Paste all copied colours & textures");
        pasteButton.setPreferredSize(TOP_BAR_DIMENSION);
        pasteButton.addActionListener(e -> pasteColoursTextures(currentComplexPanel));
        comboPane.add(pasteButton);

        JButton clearEverythingButton = new JButton("Clear Everything");
        clearEverythingButton.setToolTipText("Clears every swapped colour & texture for every model in the Anvil");
        clearEverythingButton.setPreferredSize(new Dimension(130, 25));
        clearEverythingButton.addActionListener(e -> clearColoursEverything());
        comboPane.add(clearEverythingButton);

        JButton setAllModelColours = new JButton("Set Everything");
        setAllModelColours.setToolTipText("Sets colours for every model in the Anvil to the colour currently selected in the Colour Picker");
        setAllModelColours.setPreferredSize(new Dimension(120, 25));
        setAllModelColours.addActionListener(e -> setColoursEverything());
        comboPane.add(setAllModelColours);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 0;
        JPanel previewPanel = new JPanel();
        previewPanel.setBackground(colourChooser.getColor());
        add(previewPanel, c);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 1;
        AbstractColorChooserPanel[] chooserPanels = {colourChooser.getChooserPanels()[1]};
        colourChooser.setChooserPanels(chooserPanels);
        colourChooser.setPreviewPanel(new JPanel());
        colourChooser.setBorder(new LineBorder(colourChooser.getColor(), 2));
        colourChooser.getSelectionModel().addChangeListener(e ->
        {
            colourChooser.setBorder(new LineBorder(colourChooser.getColor(), 2));
            previewPanel.setBackground(colourChooser.getColor());
        });
        add(colourChooser, c);

        c.weighty = 1;
        c.gridx = 1;
        c.gridy = 2;
        JLabel emptyLabel = new JLabel("");
        add(emptyLabel, c);

        c.gridheight = 2;
        c.weightx = 4;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane();
        add(scrollPane, c);

        JPanel swapPanel = new JPanel();
        swapPanel.setLayout(new GridBagLayout());
        swapPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        scrollPane.setViewportView(swapPanel);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel textureLabel = new JLabel("Textures", SwingConstants.CENTER);
        textureLabel.setPreferredSize(LABEL_DIMENSION);
        textureLabel.setFont(FontManager.getRunescapeBoldFont());
        swapPanel.add(textureLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        JLabel colourLabel = new JLabel("Colours", SwingConstants.CENTER);
        colourLabel.setPreferredSize(LABEL_DIMENSION);
        colourLabel.setFont(FontManager.getRunescapeBoldFont());
        swapPanel.add(colourLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        JPanel textureHeader = new JPanel();
        textureHeader.setLayout(new GridLayout(1, 0, 1, 1));
        swapPanel.add(textureHeader, c);

        JLabel oldTextureLabel = new JLabel("Old", SwingConstants.CENTER);
        oldTextureLabel.setFont(FontManager.getRunescapeBoldFont());
        textureHeader.add(oldTextureLabel);

        JLabel newTextureLabel = new JLabel("New", SwingConstants.CENTER);
        newTextureLabel.setFont(FontManager.getRunescapeBoldFont());
        textureHeader.add(newTextureLabel);

        JButton clearTextures = new JButton("Clear");
        clearTextures.setToolTipText("Clear all swapped textures back to default");
        clearTextures.addActionListener(e -> {
            unsetAllTextures();
            removeAllTextureSwaps();
            repaint();
            revalidate();
        });
        textureHeader.add(clearTextures);

        c.gridx = 1;
        c.gridy = 1;
        JPanel colourHeader = new JPanel();
        colourHeader.setLayout(new GridLayout(2, 0, 1, 1));
        swapPanel.add(colourHeader, c);

        JLabel oldColourLabel = new JLabel("Old", SwingConstants.CENTER);
        oldColourLabel.setFont(FontManager.getRunescapeBoldFont());
        colourHeader.add(oldColourLabel);

        JLabel newColourLabel = new JLabel("New", SwingConstants.CENTER);
        newColourLabel.setFont(FontManager.getRunescapeBoldFont());
        colourHeader.add(newColourLabel);

        JButton clearColours = new JButton("Clear");
        clearColours.setToolTipText("Clear all swapped colours back to default");
        clearColours.addActionListener(e -> {
            unsetAllColours();
            removeAllColourSwaps();
            repaint();
            revalidate();
        });
        colourHeader.add(clearColours);

        colourHeader.add(new JLabel(""));
        colourHeader.add(new JLabel(""));

        JButton setAllButton = new JButton("Set All");
        setAllButton.setToolTipText("Sets all colours for this model to the colour currently selected in the Colour Picker");
        setAllButton.addActionListener(e -> {
            setAllColoursHere();
            repaint();
            revalidate();
        });
        colourHeader.add(setAllButton);

        c.gridx = 0;
        c.gridy = 2;
        textureHolder.setLayout(new GridLayout(0, 1, 1, 2));
        textureHolder.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        swapPanel.add(textureHolder, c);

        c.gridx = 1;
        c.gridy = 2;
        colourHolder.setLayout(new GridLayout(0, 1, 1, 2));
        colourHolder.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        swapPanel.add(colourHolder, c);

        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel emptyLabel3 = new JLabel("");
        swapPanel.add(emptyLabel3, c);

        repaint();
        revalidate();
    }

    public void addComplexPanelOption(ComplexPanel complexPanel)
    {
        comboBox.addItem(complexPanel);
    }

    public void removeAllComplexPanelOptions()
    {
        comboBox.removeAllItems();
        unsetSwapper();
        repaint();
        revalidate();
    }

    public void removeComplexPanelOption(ComplexPanel complexPanel)
    {
        if (comboBox.getSelectedItem() == complexPanel)
        {
            unsetSwapper();
            repaint();
            revalidate();
        }

        comboBox.removeItem(complexPanel);
    }

    public void setComboBox(ComplexPanel complexPanel)
    {
        comboBox.setSelectedItem(complexPanel);
    }

    public void onSwapperPressed(ComplexPanel complexPanel)
    {
        unsetSwapper();
        if (complexPanel == null)
        {
            repaint();
            revalidate();
            return;
        }

        int modelId = (int) complexPanel.getModelIdSpinner().getValue();
        if (modelId == -1)
        {
            repaint();
            revalidate();
            return;
        }

        setupSwapper(complexPanel);
    }

    public void setupSwapper(ComplexPanel complexPanel)
    {
        int modelId = (int) complexPanel.getModelIdSpinner().getValue();

        currentComplexPanel = complexPanel;

        HashMap<Short, Short> colourMap = new HashMap<>();
        for (int i = 0; i < complexPanel.getColoursFrom().length; i++)
        {
            colourMap.put(complexPanel.getColoursFrom()[i], complexPanel.getColoursTo()[i]);
        }

        HashMap<Short, Short> textureMap = new HashMap<>();
        for (int i = 0; i < complexPanel.getTexturesFrom().length; i++)
        {
            textureMap.put(complexPanel.getTexturesFrom()[i], complexPanel.getTexturesTo()[i]);
        }

        clientThread.invokeLater(() ->
        {
            ModelData modelData = client.loadModelData(modelId);
            if (modelData == null)
                return;

            short[] colourList = new short[0];
            for (short s : modelData.getFaceColors())
            {
                if (!ArrayUtils.contains(colourList, s))
                    colourList = ArrayUtils.add(colourList, s);
            }

            for (short colour : colourList)
            {
                if (colourMap.containsKey(colour))
                {
                    createColourPanel(colour, colourMap.get(colour), true);
                    continue;
                }

                createColourPanel(colour, colour, false);
            }

            try
            {
                modelData.cloneTextures();
            }
            catch (Exception e)
            {
                repaint();
                revalidate();
                return;
            }

            short[] textureList = new short[0];
            for (short s : modelData.getFaceTextures())
            {
                if (!ArrayUtils.contains(textureList, s))
                    textureList = ArrayUtils.add(textureList, s);
            }

            for (short texture : textureList)
            {
                if (textureMap.containsKey(texture))
                {
                    createTexturePanel(texture, textureMap.get(texture), true);
                    continue;
                }

                createTexturePanel(texture, texture, false);
            }

            repaint();
            revalidate();
        });
    }

    public void unsetSwapper()
    {
        colourHolder.removeAll();
        colourPanels = new ColourPanel[0];

        textureHolder.removeAll();
        texturePanels = new TexturePanel[0];

        currentComplexPanel = null;
    }

    private ColourPanel createColourPanel(short oldColour, short newColour, boolean isColourSet)
    {
        JLabel oldColourLabel = new JLabel("" + oldColour, SwingConstants.CENTER);
        oldColourLabel.setFont(FontManager.getRunescapeSmallFont());
        oldColourLabel.setBorder(new LineBorder(colourFromShort(oldColour), 10));
        oldColourLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton newColourButton = new JButton("" + (isColourSet ? newColour : "Set"));
        newColourButton.setToolTipText("Swap this Old colour to the colour currently selected in the Colour Picker");
        newColourButton.setFont(FontManager.getRunescapeSmallFont());
        newColourButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        if (isColourSet)
            newColourButton.setBorder(new LineBorder(colourFromShort(newColour), 10));

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0, 1, 0, 1));

        JButton findButton = new JButton("Find");
        findButton.setToolTipText("Find the current New colour swap in the colour picker");
        buttonPanel.add(findButton);

        JSpinner spinner = new JSpinner(new SpinnerNumberModel(0, -32768, 32767, 1));
        spinner.setToolTipText("Apply an exact Jagex colour as it is stored in the cache");
        buttonPanel.add(spinner);

        ColourPanel colourPanel = new ColourPanel(isColourSet, oldColour, newColour, oldColourLabel, newColourButton, spinner);
        colourPanel.setLayout(new GridLayout(1, 0, 1, 1));
        colourPanel.add(oldColourLabel);
        colourPanel.add(newColourButton);
        colourPanel.add(buttonPanel);

        spinner.addChangeListener(e ->
        {
            short colourToAdd = (short) ((int) spinner.getValue());
            if (colourPanel.isColourSet())
            {
                replaceColour(colourPanel, colourToAdd);
                replaceColourSwap(colourPanel.getOldColour(), colourToAdd);
                return;
            }

            setColour(colourPanel, colourToAdd);
            addColourSwap(colourPanel.getOldColour(), colourToAdd);
        });
        findButton.addActionListener(e -> colourChooser.setColor(colourFromShort(colourPanel.getNewColour())));
        newColourButton.addActionListener(e ->
        {
            if (colourPanel.isColourSet())
            {
                unsetColour(colourPanel);
                removeColourSwap(colourPanel.getOldColour());
                return;
            }

            setColour(colourPanel, colourChooser.getColor());
            addColourSwap(colourPanel.getOldColour(), colourPanel.getNewColour());
        });

        colourHolder.add(colourPanel);
        colourPanels = ArrayUtils.add(colourPanels, colourPanel);
        return colourPanel;
    }

    private void setAllColoursHere()
    {
        short colour = shortFromColour(colourChooser.getColor());

        for (ColourPanel colourPanel : colourPanels)
        {
            if (colourPanel.isColourSet())
            {
                replaceColour(colourPanel, colour);
                replaceColourSwap(colourPanel.getOldColour(), colour);
                continue;
            }

            setColour(colourPanel, colour);
            addColourSwap(colourPanel.getOldColour(), colourPanel.getNewColour());
        }
    }

    public void setColoursEverything()
    {
        short colour = shortFromColour(colourChooser.getColor());
        clientThread.invokeLater(() ->
        {
            for (ComplexPanel complexPanel : complexPanels)
            {
                int modelId = (int) complexPanel.getModelIdSpinner().getValue();
                if (modelId == -1)
                {
                    continue;
                }

                ModelData modelData = client.loadModelData(modelId);
                if (modelData == null)
                    continue;

                short[] coloursFrom = new short[0];
                for (short s : modelData.getFaceColors())
                {
                    if (!ArrayUtils.contains(coloursFrom, s))
                    {
                        coloursFrom = ArrayUtils.add(coloursFrom, s);
                    }
                }

                short[] coloursTo = new short[coloursFrom.length];
                Arrays.fill(coloursTo, colour);
                complexPanel.setColoursFrom(coloursFrom);
                complexPanel.setColoursTo(coloursTo);
            }

            onSwapperPressed((ComplexPanel) comboBox.getSelectedItem());
        });
    }

    private void clearColoursEverything()
    {
        for (ComplexPanel complexPanel : complexPanels)
        {
            if ((int) complexPanel.getModelIdSpinner().getValue() == -1)
            {
                continue;
            }

            complexPanel.setColoursFrom(new short[0]);
            complexPanel.setColoursTo(new short[0]);
        }

        onSwapperPressed((ComplexPanel) comboBox.getSelectedItem());
    }

    private void setColour(ColourPanel colourPanel, Color rgbColour)
    {
        setColour(colourPanel, shortFromColour(rgbColour));
    }

    private void setColour(ColourPanel colourPanel, short colour)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("" + colour);
        newColourButton.setBorder(new LineBorder(colourFromShort(colour), 10));
        colourPanel.setNewColour(colour);
        colourPanel.setColourSet(true);
    }

    private void unsetColour(ColourPanel colourPanel)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("Set");
        newColourButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 2));
        colourPanel.setNewColour(colourPanel.getOldColour());
        colourPanel.setColourSet(false);
    }

    private void replaceColour(ColourPanel colourPanel, short newColourTo)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("" + newColourTo);
        newColourButton.setBorder(new LineBorder(colourFromShort(newColourTo), 10));
        colourPanel.setNewColour(newColourTo);
    }

    public void unsetAllColours()
    {
        for (ColourPanel colourPanel : colourPanels)
            unsetColour(colourPanel);

        removeAllColourSwaps();
    }

    private void addColourSwap(short colourFrom, short colourTo)
    {
        currentComplexPanel.setColoursFrom(ArrayUtils.add(currentComplexPanel.getColoursFrom(), colourFrom));
        currentComplexPanel.setColoursTo(ArrayUtils.add(currentComplexPanel.getColoursTo(), colourTo));
    }

    public void pasteColourSwaps(ComplexPanel complexPanel, short[] newColoursFrom, short[] newColoursTo)
    {
        short[] coloursFrom = complexPanel.getColoursFrom();
        short[] coloursTo = complexPanel.getColoursTo();

        for (int i = 0; i < newColoursFrom.length; i++)
        {
            boolean contains = false;
            for (int e = 0; e < coloursFrom.length; e++)
            {
                if (coloursFrom[e] == newColoursFrom[i])
                {
                    coloursTo[e] = newColoursTo[i];
                    contains = true;
                    break;
                }
            }

            if (contains)
                continue;

            coloursFrom = ArrayUtils.add(coloursFrom, newColoursFrom[i]);
            coloursTo = ArrayUtils.add(coloursTo, newColoursTo[i]);
        }

        complexPanel.setColoursFrom(coloursFrom);
        complexPanel.setColoursTo(coloursTo);
    }

    private void removeColourSwap(short colourFrom)
    {
        short[] coloursFrom = currentComplexPanel.getColoursFrom();
        short[] coloursTo = currentComplexPanel.getColoursTo();

        int index = ArrayUtils.indexOf(coloursFrom, colourFrom);
        currentComplexPanel.setColoursFrom(ArrayUtils.remove(coloursFrom, index));
        currentComplexPanel.setColoursTo(ArrayUtils.remove(coloursTo, index));
    }

    private void replaceColourSwap(short colourFrom, short newColourTo)
    {
        short[] coloursFrom = currentComplexPanel.getColoursFrom();
        short[] coloursTo = currentComplexPanel.getColoursTo();

        int index = ArrayUtils.indexOf(coloursFrom, colourFrom);
        coloursTo[index] = newColourTo;
    }

    public void removeAllColourSwaps()
    {
        currentComplexPanel.setColoursFrom(new short[0]);
        currentComplexPanel.setColoursTo(new short[0]);
    }

    public static Color colourFromShort(short s)
    {
        float hue = ((float) JagexColor.unpackHue(s) / JagexColor.HUE_MAX) * 360;
        float sat = ((float) JagexColor.unpackSaturation(s) / JagexColor.SATURATION_MAX) * 100;
        float lum = ((float) JagexColor.unpackLuminance(s) / JagexColor.LUMINANCE_MAX) * 100;
        return HSLColor.toRGB(hue, sat, lum);
    }

    public static short shortFromColour(Color color)
    {
        float[] col = HSLColor.fromRGB(color);
        int hue = (int) (col[0] / 360 * JagexColor.HUE_MAX);
        int sat = (int) (col[1] / 100 * JagexColor.SATURATION_MAX);
        int lum = (int) (col[2] / 100 * JagexColor.LUMINANCE_MAX);
        return JagexColor.packHSL(hue, sat, lum);
    }

    private TexturePanel createTexturePanel(short oldTexture, short newTexture, boolean isTextureSet)
    {
        JLabel oldTextureLabel = new JLabel("" + oldTexture, SwingConstants.CENTER);
        oldTextureLabel.setFont(FontManager.getRunescapeSmallFont());
        oldTextureLabel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        oldTextureLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton newTextureButton = new JButton("" + (isTextureSet ? newTexture : "Set"));
        newTextureButton.setFont(FontManager.getRunescapeSmallFont());
        newTextureButton.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0, 1, 0, 1));

        JSpinner spinner = new JSpinner(new SpinnerNumberModel(0, -1, 150, 1));
        spinner.setToolTipText("Apply a Texture Id as it is stored in the cache");
        buttonPanel.add(spinner);

        TexturePanel texturePanel = new TexturePanel(isTextureSet, oldTexture, newTexture, oldTextureLabel, newTextureButton, spinner);
        texturePanel.setLayout(new GridLayout(1, 0, 1, 1));
        texturePanel.add(oldTextureLabel);
        texturePanel.add(newTextureButton);
        texturePanel.add(buttonPanel);

        spinner.addChangeListener(e ->
        {
            short textureToAdd = (short) ((int) spinner.getValue());
            if (texturePanel.isTextureSet())
            {
                replaceTexture(texturePanel, textureToAdd);
                replaceTextureSwap(texturePanel.getOldTexture(), textureToAdd);
                return;
            }

            setTexture(texturePanel, textureToAdd);
            addTextureSwap(texturePanel.getOldTexture(), textureToAdd);
        });
        newTextureButton.addActionListener(e ->
        {
            if (texturePanel.isTextureSet())
            {
                unsetTexture(texturePanel);
                removeTextureSwap(texturePanel.getOldTexture());
                return;
            }

            short textureToAdd = (short) ((int) spinner.getValue());
            setTexture(texturePanel, textureToAdd);
            addTextureSwap(texturePanel.getOldTexture(), texturePanel.getNewTexture());
        });

        textureHolder.add(texturePanel);
        textureHolder.revalidate();
        textureHolder.repaint();
        texturePanels = ArrayUtils.add(texturePanels, texturePanel);
        return texturePanel;
    }

    private void setTexture(TexturePanel texturePanel, short texture)
    {
        JButton newColourButton = texturePanel.getNewTextureButton();
        newColourButton.setText("" + texture);
        texturePanel.setNewTexture(texture);
        texturePanel.setTextureSet(true);
    }

    private void unsetTexture(TexturePanel texturePanel)
    {
        JButton newTextureButton = texturePanel.getNewTextureButton();
        newTextureButton.setText("Set");
        texturePanel.setNewTexture(texturePanel.getOldTexture());
        texturePanel.setTextureSet(false);
    }

    private void replaceTexture(TexturePanel texturePanel, short newTextureTo)
    {
        JButton newTextureButton = texturePanel.getNewTextureButton();
        newTextureButton.setText("" + newTextureTo);
        texturePanel.setNewTexture(newTextureTo);
    }

    public void unsetAllTextures()
    {
        for (TexturePanel texturePanel : texturePanels)
            unsetTexture(texturePanel);

        removeAllTextureSwaps();
    }

    private void addTextureSwap(short textureFrom, short textureTo)
    {
        currentComplexPanel.setTexturesFrom(ArrayUtils.add(currentComplexPanel.getTexturesFrom(), textureFrom));
        currentComplexPanel.setTexturesTo(ArrayUtils.add(currentComplexPanel.getTexturesTo(), textureTo));
    }

    public void pasteTextureSwaps(ComplexPanel complexPanel, short[] newTexturesFrom, short[] newTexturesTo)
    {
        short[] texturesFrom = complexPanel.getTexturesFrom();
        short[] texturesTo = complexPanel.getTexturesTo();

        for (int i = 0; i < newTexturesFrom.length; i++)
        {
            boolean contains = false;
            for (int e = 0; e < texturesFrom.length; e++)
            {
                if (texturesFrom[e] == newTexturesFrom[i])
                {
                    texturesTo[e] = newTexturesTo[i];
                    contains = true;
                    break;
                }
            }

            if (contains)
                continue;

            texturesFrom = ArrayUtils.add(texturesFrom, newTexturesFrom[i]);
            texturesTo = ArrayUtils.add(texturesTo, newTexturesTo[i]);
        }

        complexPanel.setTexturesFrom(texturesFrom);
        complexPanel.setTexturesTo(texturesTo);
    }

    private void removeTextureSwap(short textureFrom)
    {
        short[] texturesFrom = currentComplexPanel.getTexturesFrom();
        short[] texturesTo = currentComplexPanel.getTexturesTo();

        int index = ArrayUtils.indexOf(texturesFrom, textureFrom);
        currentComplexPanel.setTexturesFrom(ArrayUtils.remove(texturesFrom, index));
        currentComplexPanel.setTexturesTo(ArrayUtils.remove(texturesTo, index));
    }

    private void replaceTextureSwap(short textureFrom, short newTextureTo)
    {
        short[] texturesFrom = currentComplexPanel.getTexturesFrom();
        short[] texturesTo = currentComplexPanel.getTexturesTo();

        int index = ArrayUtils.indexOf(texturesFrom, textureFrom);
        texturesTo[index] = newTextureTo;
    }

    public void removeAllTextureSwaps()
    {
        currentComplexPanel.setTexturesFrom(new short[0]);
        currentComplexPanel.setTexturesTo(new short[0]);
    }

    public void copyColoursTextures(ComplexPanel complexPanel)
    {
       copiedColoursTextures = new short[][]{complexPanel.getColoursFrom(), complexPanel.getColoursTo(), complexPanel.getTexturesFrom(), complexPanel.getTexturesTo()};
    }

    public void pasteColoursTextures(ComplexPanel complexPanel)
    {
        pasteColourSwaps(
                complexPanel,
                copiedColoursTextures[0],
                copiedColoursTextures[1]);

        pasteTextureSwaps(
                complexPanel,
                copiedColoursTextures[2],
                copiedColoursTextures[3]);

        if (currentComplexPanel == complexPanel)
            onSwapperPressed(complexPanel);
    }

    public void clearColoursTextures(ComplexPanel complexPanel)
    {
        if (currentComplexPanel == complexPanel)
        {
            unsetAllColours();
            unsetAllTextures();
            return;
        }

        complexPanel.setColoursFrom(new short[0]);
        complexPanel.setColoursTo(new short[0]);
        complexPanel.setTexturesFrom(new short[0]);
        complexPanel.setTexturesTo(new short[0]);
    }
}

package com.creatorskit.swing.colours;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@AllArgsConstructor
@Getter
@Setter
public class ColourPanel extends JPanel
{
    private boolean colourSet;
    private short oldColour;
    private short newColour;
    private JLabel oldColourLabel;
    private JButton newColourButton;
    private JSpinner spinner;
}

package com.creatorskit.swing.colours;

import java.awt.Color;

// Credits to Yona-Appletree: https://gist.github.com/Yona-Appletree/0c4b58763f070ae8cdff7db583c82563

/**
 *  The HSLColor class provides methods to manipulate HSL (Hue, Saturation
 *  Luminance) values to create a corresponding Color object using the RGB
 *  ColorSpace.
 *
 *  The HUE is the color, the Saturation is the purity of the color (with
 *  respect to grey) and Luminance is the brightness of the color (with respect
 *  to black and white)
 *
 *  The Hue is specified as an angel between 0 - 360 degrees where red is 0,
 *  green is 120 and blue is 240. In between you have the colors of the rainbow.
 *  Saturation is specified as a percentage between 0 - 100 where 100 is fully
 *  saturated and 0 approaches gray. Luminance is specified as a percentage
 *  between 0 - 100 where 0 is black and 100 is white.
 *
 *  In particular the HSL color space makes it easier change the Tone or Shade
 *  of a color by adjusting the luminance value.
 */
public class HSLColor
{
    private Color rgb;
    private float[] hsl;
    private float alpha;

    /**
     *  Create a HSLColor object using an RGB Color object.
     *
     *  @param rgb the RGB Color object
     */
    public HSLColor(Color rgb)
    {
        this.rgb = rgb;
        hsl = fromRGB( rgb );
        alpha = rgb.getAlpha() / 255.0f;
    }

    /**
     *  Create a HSLColor object using individual HSL values and a default
     * alpha value of 1.0.
     *
     *  @param h is the Hue value in degrees between 0 - 360
     *  @param s is the Saturation percentage between 0 - 100
     *  @param l is the Lumanance percentage between 0 - 100
     */
    public HSLColor(float h, float s, float l)
    {
        this(h, s, l, 1.0f);
    }

    /**
     *  Create a HSLColor object using individual HSL values.
     *
     *  @param h     the Hue value in degrees between 0 - 360
     *  @param s     the Saturation percentage between 0 - 100
     *  @param l     the Lumanance percentage between 0 - 100
     *  @param alpha the alpha value between 0 - 1
     */
    public HSLColor(float h, float s, float l, float alpha)
    {
        hsl = new float[] {h, s, l};
        this.alpha = alpha;
        rgb = toRGB(hsl, alpha);
    }

    /**
     *  Create a HSLColor object using an an array containing the
     *  individual HSL values and with a default alpha value of 1.
     *
     *  @param hsl  array containing HSL values
     */
    public HSLColor(float[] hsl)
    {
        this(hsl, 1.0f);
    }

    /**
     *  Create a HSLColor object using an an array containing the
     *  individual HSL values.
     *
     *  @param hsl  array containing HSL values
     *  @param alpha the alpha value between 0 - 1
     */
    public HSLColor(float[] hsl, float alpha)
    {
        this.hsl = hsl;
        this.alpha = alpha;
        rgb = toRGB(hsl, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Hue value. The degrees specified is an absolute value.
     *
     *  @param degrees - the Hue value between 0 - 360
     *  @return the RGB Color object
     */
    public Color adjustHue(float degrees)
    {
        return toRGB(degrees, hsl[1], hsl[2], alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Luminance value. The percent specified is an absolute value.
     *
     *  @param percent - the Luminance value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustLuminance(float percent)
    {
        return toRGB(hsl[0], hsl[1], percent, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Saturation value. The percent specified is an absolute value.
     *
     *  @param percent - the Saturation value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustSaturation(float percent)
    {
        return toRGB(hsl[0], percent, hsl[2], alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Shade. Changing the shade will return a darker color. The percent
     *  specified is a relative value.
     *
     *  @param percent - the value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustShade(float percent)
    {
        float multiplier = (100.0f - percent) / 100.0f;
        float l = Math.max(0.0f, hsl[2] * multiplier);

        return toRGB(hsl[0], hsl[1], l, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Tone. Changing the tone will return a lighter color. The percent
     *  specified is a relative value.
     *
     *  @param percent - the value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustTone(float percent)
    {
        float multiplier = (100.0f + percent) / 100.0f;
        float l = Math.min(100.0f, hsl[2] * multiplier);

        return toRGB(hsl[0], hsl[1], l, alpha);
    }

    /**
     *  Get the Alpha value.
     *
     *  @return the Alpha value.
     */
    public float getAlpha()
    {
        return alpha;
    }

    /**
     *  Create a RGB Color object that is the complementary color of this
     *  HSLColor. This is a convenience method. The complementary color is
     *  determined by adding 180 degrees to the Hue value.
     *  @return the RGB Color object
     */
    public Color getComplementary()
    {
        float hue = (hsl[0] + 180.0f) % 360.0f;
        return toRGB(hue, hsl[1], hsl[2]);
    }

    /**
     *  Get the Hue value.
     *
     *  @return the Hue value.
     */
    public float getHue()
    {
        return hsl[0];
    }

    /**
     *  Get the HSL values.
     *
     *  @return the HSL values.
     */
    public float[] getHSL()
    {
        return hsl;
    }

    /**
     *  Get the Luminance value.
     *
     *  @return the Luminance value.
     */
    public float getLuminance()
    {
        return hsl[2];
    }

    /**
     *  Get the RGB Color object represented by this HDLColor.
     *
     *  @return the RGB Color object.
     */
    public Color getRGB()
    {
        return rgb;
    }

    /**
     *  Get the Saturation value.
     *
     *  @return the Saturation value.
     */
    public float getSaturation()
    {
        return hsl[1];
    }

    public String toString()
    {
        String toString =
                "HSLColor[h=" + hsl[0] +
                        ",s=" + hsl[1] +
                        ",l=" + hsl[2] +
                        ",alpha=" + alpha + "]";

        return toString;
    }

    /**
     *  Convert a RGB Color to it corresponding HSL values.
     *
     *  @return an array containing the 3 HSL values.
     */
    public static float[] fromRGB(Color color)
    {
        //  Get RGB values in the range 0 - 1

        float[] rgb = color.getRGBColorComponents( null );
        float r = rgb[0];
        float g = rgb[1];
        float b = rgb[2];

        //	Minimum and Maximum RGB values are used in the HSL calculations

        float min = Math.min(r, Math.min(g, b));
        float max = Math.max(r, Math.max(g, b));

        //  Calculate the Hue

        float h = 0;

        if (max == min)
            h = 0;
        else if (max == r)
            h = ((60 * (g - b) / (max - min)) + 360) % 360;
        else if (max == g)
            h = (60 * (b - r) / (max - min)) + 120;
        else if (max == b)
            h = (60 * (r - g) / (max - min)) + 240;

        //  Calculate the Luminance

        float l = (max + min) / 2;

        //  Calculate the Saturation

        float s = 0;

        if (max == min)
            s = 0;
        else if (l <= .5f)
            s = (max - min) / (max + min);
        else
            s = (max - min) / (2 - max - min);

        return new float[] {h, s * 100, l * 100};
    }

    /**
     *  Convert HSL values to a RGB Color with a default alpha value of 1.
     *  H (Hue) is specified as degrees in the range 0 - 360.
     *  S (Saturation) is specified as a percentage in the range 1 - 100.
     *  L (Lumanance) is specified as a percentage in the range 1 - 100.
     *
     *  @param hsl an array containing the 3 HSL values
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float[] hsl)
    {
        return toRGB(hsl, 1.0f);
    }

    /**
     *  Convert HSL values to a RGB Color.
     *  H (Hue) is specified as degrees in the range 0 - 360.
     *  S (Saturation) is specified as a percentage in the range 1 - 100.
     *  L (Lumanance) is specified as a percentage in the range 1 - 100.
     *
     *  @param hsl    an array containing the 3 HSL values
     *  @param alpha  the alpha value between 0 - 1
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float[] hsl, float alpha)
    {
        return toRGB(hsl[0], hsl[1], hsl[2], alpha);
    }

    /**
     *  Convert HSL values to a RGB Color with a default alpha value of 1.
     *
     *  @param h Hue is specified as degrees in the range 0 - 360.
     *  @param s Saturation is specified as a percentage in the range 1 - 100.
     *  @param l Lumanance is specified as a percentage in the range 1 - 100.
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float h, float s, float l)
    {
        return toRGB(h, s, l, 1.0f);
    }

    /**
     *  Convert HSL values to a RGB Color.
     *
     *  @param h Hue is specified as degrees in the range 0 - 360.
     *  @param s Saturation is specified as a percentage in the range 1 - 100.
     *  @param l Lumanance is specified as a percentage in the range 1 - 100.
     *  @param alpha  the alpha value between 0 - 1
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float h, float s, float l, float alpha)
    {
        if (s <0.0f || s > 100.0f)
        {
            String message = "Color parameter outside of expected range - Saturation";
            throw new IllegalArgumentException( message );
        }

        if (l <0.0f || l > 100.0f)
        {
            String message = "Color parameter outside of expected range - Luminance";
            throw new IllegalArgumentException( message );
        }

        if (alpha <0.0f || alpha > 1.0f)
        {
            String message = "Color parameter outside of expected range - Alpha";
            throw new IllegalArgumentException( message );
        }

        //  Formula needs all values between 0 - 1.

        h = h % 360.0f;
        h /= 360f;
        s /= 100f;
        l /= 100f;

        float q = 0;

        if (l < 0.5)
            q = l * (1 + s);
        else
            q = (l + s) - (s * l);

        float p = 2 * l - q;

        float r = Math.max(0, HueToRGB(p, q, h + (1.0f / 3.0f)));
        float g = Math.max(0, HueToRGB(p, q, h));
        float b = Math.max(0, HueToRGB(p, q, h - (1.0f / 3.0f)));

        r = Math.min(r, 1.0f);
        g = Math.min(g, 1.0f);
        b = Math.min(b, 1.0f);

        return new Color(r, g, b, alpha);
    }

    private static float HueToRGB(float p, float q, float h)
    {
        if (h < 0) h += 1;

        if (h > 1 ) h -= 1;

        if (6 * h < 1)
        {
            return p + ((q - p) * 6 * h);
        }

        if (2 * h < 1 )
        {
            return  q;
        }

        if (3 * h < 2)
        {
            return p + ( (q - p) * 6 * ((2.0f / 3.0f) - h) );
        }

        return p;
    }
}
package com.creatorskit.swing.colours;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@AllArgsConstructor
@Getter
@Setter
public class TexturePanel extends JPanel
{
    private boolean textureSet;
    private short oldTexture;
    private short newTexture;
    private JLabel oldTextureLabel;
    private JButton newTextureButton;
    private JSpinner spinner;
}

package com.creatorskit.swing;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.*;
import com.creatorskit.models.datatypes.ItemData;
import com.creatorskit.models.datatypes.NPCData;
import com.creatorskit.models.datatypes.ObjectData;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import net.runelite.api.Model;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.event.PopupMenuEvent;
import javax.swing.event.PopupMenuListener;
import java.awt.*;
import java.util.List;

public class CacheSearcherTab extends JPanel
{
    private final CreatorsPlugin plugin;
    private ClientThread clientThread;
    private final DataFinder dataFinder;

    private final GridBagConstraints c = new GridBagConstraints();
    private final String NAME = "NAME";
    private final String ID = "ID";
    private final Color ENTRY_COLOUR = new Color(35, 35, 40);

    private final JPanel npcPanel = new JPanel();
    private final JPanel objectPanel = new JPanel();
    private final JPanel itemPanel = new JPanel();

    private boolean npcsFound = false;
    private boolean objectsFound = false;
    private boolean itemsFound = false;

    @Inject
    public CacheSearcherTab(CreatorsPlugin plugin, ClientThread clientThread, DataFinder dataFinder)
    {
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.dataFinder = dataFinder;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new GridBagLayout());

        setupNPCPanel();
        setupObjectPanel();
        setupItemPanel();
        setupLayout();
    }

    private void setupLayout()
    {
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Cache Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        add(title, c);

        c.gridx = 0;
        c.gridy = 1;
        add(npcPanel, c);

        c.gridx = 0;
        c.gridy = 2;
        add(objectPanel, c);

        c.gridx = 0;
        c.gridy = 3;
        add(itemPanel, c);

        repaint();
        revalidate();
    }

    private void setupNPCPanel()
    {
        npcPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        npcPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));

        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(4, 4, 4, 4));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        npcPanel.add(holderPanel);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("NPC Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel modeLabel = new JLabel("Search by: ");
        modeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(modeLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JComboBox<String> mode = new JComboBox<>();
        mode.setToolTipText("Set whether to search the cache via the NPC's name or NPC Id");
        mode.addItem("Name");
        mode.addItem("Id");
        holderPanel.add(mode, c);

        c.gridwidth = 1;
        c.gridx = 2;
        c.gridy = 1;
        JLabel buffer = new JLabel("               ");
        holderPanel.add(buffer, c);

        c.gridx = 3;
        c.gridy = 1;
        JButton addObject = new JButton("Add Object w/Model");
        addObject.setToolTipText("Adds the selected NPC as a new Object and Custom Model, applying the Model to the new Object");
        holderPanel.add(addObject, c);

        c.gridx = 3;
        c.gridy = 2;
        JButton addModel = new JButton("Add Model");
        addModel.setToolTipText("Adds the selected NPC as a new Custom Model");
        holderPanel.add(addModel, c);

        c.gridx = 3;
        c.gridy = 3;
        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the NPC's models to the Model Anvil");
        holderPanel.add(addAnvil, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 2;
        JPanel cardPanel = new JPanel();
        cardPanel.setLayout(new CardLayout());
        holderPanel.add(cardPanel, c);

        JPanel nameCard = new JPanel();
        JPanel idCard = new JPanel();
        cardPanel.add(nameCard, "NAME");
        cardPanel.add(idCard, "ID");

        JLabel nameLabel = new JLabel("NPC name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        nameCard.add(nameLabel);

        JComboBox<NPCData> nameBox = new JComboBox<>();
        nameBox.setBackground(ENTRY_COLOUR);
        nameBox.setPreferredSize(new Dimension(270, 25));
        nameBox.addPopupMenuListener(new PopupMenuListener()
        {
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e)
            {
                if (!npcsFound)
                {
                    List<NPCData> dataList = dataFinder.getNpcData();
                    npcsFound = true;
                    for (NPCData data : dataList)
                    {
                        nameBox.addItem(data);
                    }
                }
            }

            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {

            }

            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {

            }
        });
        AutoCompletion.enable(nameBox);
        nameCard.add(nameBox);

        JLabel idLabel = new JLabel("NPC Id: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        idCard.add(idLabel);

        JSpinner idSpinner = new JSpinner();
        idSpinner.setBackground(ENTRY_COLOUR);
        idSpinner.setPreferredSize(new Dimension(90, 25));
        idCard.add(idSpinner);

        mode.addItemListener(e ->
        {
            if (e.getItem() == null)
            {
                return;
            }

            String item = (String) e.getItem();
            CardLayout cl = (CardLayout)(cardPanel.getLayout());

            if (item.equalsIgnoreCase(NAME))
            {
                cl.show(cardPanel, NAME);
                return;
            }

            cl.show(cardPanel, ID);
        });

        addObject.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                NPCData npcData = (NPCData) nameBox.getSelectedItem();
                if (npcData == null)
                {
                    return;
                }

                addNPCObject((NPCData) nameBox.getSelectedItem());
            }
            else
            {
                addNPCObject((int) idSpinner.getValue());
            }
        });

        addModel.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                NPCData npcData = (NPCData) nameBox.getSelectedItem();
                if (npcData == null)
                {
                    return;
                }

                addCustomModel(CustomModelType.CACHE_NPC, npcData.getId());
            }
            else
            {
                addCustomModel(CustomModelType.CACHE_NPC, (int) idSpinner.getValue());
            }
        });

        addAnvil.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                NPCData npcData = (NPCData) nameBox.getSelectedItem();
                if (npcData == null)
                {
                    return;
                }

                addToAnvil(CustomModelType.CACHE_NPC, npcData.getId());
            }
            else
            {
                addToAnvil(CustomModelType.CACHE_NPC, (int) idSpinner.getValue());
            }

        });
    }

    private void setupObjectPanel()
    {
        objectPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        objectPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));

        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(4, 4, 4, 4));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        objectPanel.add(holderPanel);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Object Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel modeLabel = new JLabel("Search by: ");
        modeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(modeLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JComboBox<String> mode = new JComboBox<>();
        mode.setToolTipText("Set whether to search the cache via the Object's name or Object Id");
        mode.addItem("Name");
        mode.addItem("Id");
        holderPanel.add(mode, c);

        c.gridwidth = 1;
        c.gridx = 2;
        c.gridy = 1;
        JLabel buffer = new JLabel("               ");
        holderPanel.add(buffer, c);

        c.gridx = 3;
        c.gridy = 1;
        JButton addObject = new JButton("Add Object w/Model");
        addObject.setToolTipText("Adds the selected Object as a new Object and Custom Model, applying the Model to the new Object");
        holderPanel.add(addObject, c);

        c.gridx = 3;
        c.gridy = 2;
        JButton addModel = new JButton("Add Model");
        addModel.setToolTipText("Adds the selected Object as a new Custom Model");
        holderPanel.add(addModel, c);

        c.gridx = 3;
        c.gridy = 3;
        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the Object's models to the Model Anvil");
        holderPanel.add(addAnvil, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 2;
        JPanel cardPanel = new JPanel();
        cardPanel.setLayout(new CardLayout());
        holderPanel.add(cardPanel, c);

        JPanel nameCard = new JPanel();
        JPanel idCard = new JPanel();
        cardPanel.add(nameCard, "NAME");
        cardPanel.add(idCard, "ID");

        JLabel nameLabel = new JLabel("Object name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        nameCard.add(nameLabel);

        JComboBox<ObjectData> nameBox = new JComboBox<>();
        nameBox.setBackground(ENTRY_COLOUR);
        nameBox.setPreferredSize(new Dimension(270, 25));
        nameBox.addPopupMenuListener(new PopupMenuListener()
        {
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e)
            {
                if (!objectsFound)
                {
                    List<ObjectData> dataList = dataFinder.getObjectData();
                    objectsFound = true;
                    for (ObjectData data : dataList)
                    {
                        String name = data.getName();
                        if (name.isEmpty()) {
                            continue;
                        }

                        if (name.equals("null")) {
                            continue;
                        }

                        nameBox.addItem(data);
                    }
                }
            }

            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {

            }

            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {

            }
        });
        AutoCompletion.enable(nameBox);
        nameCard.add(nameBox);

        JLabel idLabel = new JLabel("Object Id: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        idCard.add(idLabel);

        JSpinner idSpinner = new JSpinner();
        idSpinner.setBackground(ENTRY_COLOUR);
        idSpinner.setPreferredSize(new Dimension(90, 25));
        idCard.add(idSpinner);

        mode.addItemListener(e ->
        {
            if (e.getItem() == null)
            {
                return;
            }

            String item = (String) e.getItem();
            CardLayout cl = (CardLayout)(cardPanel.getLayout());

            if (item.equalsIgnoreCase(NAME))
            {
                cl.show(cardPanel, NAME);
                return;
            }

            cl.show(cardPanel, ID);
        });

        addObject.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                ObjectData objectData = (ObjectData) nameBox.getSelectedItem();
                if (objectData == null)
                {
                    return;
                }

                addObjectObject((ObjectData) nameBox.getSelectedItem());
            }
            else
            {
                addObjectObject((int) idSpinner.getValue());
            }
        });

        addModel.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                ObjectData objectData = (ObjectData) nameBox.getSelectedItem();
                if (objectData == null)
                {
                    return;
                }

                addCustomModel(CustomModelType.CACHE_OBJECT, objectData.getId());
            }
            else
            {
                addCustomModel(CustomModelType.CACHE_OBJECT, (int) idSpinner.getValue());
            }
        });

        addAnvil.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            if (modeString.equals("Name"))
            {
                ObjectData objectData = (ObjectData) nameBox.getSelectedItem();
                if (objectData == null)
                {
                    return;
                }

                addToAnvil(CustomModelType.CACHE_OBJECT, objectData.getId());
            }
            else
            {
                addToAnvil(CustomModelType.CACHE_OBJECT, (int) idSpinner.getValue());
            }

        });
    }

    private void setupItemPanel()
    {
        itemPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));

        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(4, 4, 4, 4));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        itemPanel.add(holderPanel);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Item Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel modeLabel = new JLabel("Search by: ");
        modeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(modeLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JComboBox<String> mode = new JComboBox<>();
        mode.setToolTipText("Set whether to search the cache via the Item's name or Item Id");
        mode.addItem("Name");
        mode.addItem("Id");
        holderPanel.add(mode, c);

        c.gridx = 0;
        c.gridy = 2;
        JLabel modelTypeLabel = new JLabel("Model type: ");
        modelTypeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(modelTypeLabel, c);

        c.gridx = 1;
        c.gridy = 2;
        JComboBox<CustomModelType> modelTypeBox = new JComboBox<>();
        modelTypeBox.setToolTipText("Set whether to search the cache for the Item's Ground model, Male worn model, or Female worn model");
        modelTypeBox.addItem(CustomModelType.CACHE_GROUND_ITEM);
        modelTypeBox.addItem(CustomModelType.CACHE_MAN_WEAR);
        modelTypeBox.addItem(CustomModelType.CACHE_WOMAN_WEAR);
        holderPanel.add(modelTypeBox, c);

        c.gridwidth = 1;
        c.gridx = 2;
        c.gridy = 1;
        JLabel buffer = new JLabel("               ");
        holderPanel.add(buffer, c);

        c.gridx = 3;
        c.gridy = 1;
        JButton addObject = new JButton("Add Object w/Model");
        addObject.setToolTipText("Adds the selected Item as a new Object and Custom Model, applying the Model to the new Object");
        holderPanel.add(addObject, c);

        c.gridx = 3;
        c.gridy = 2;
        JButton addModel = new JButton("Add Model");
        addModel.setToolTipText("Adds the selected Item as a new Custom Model");
        holderPanel.add(addModel, c);

        c.gridx = 3;
        c.gridy = 3;
        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the Item's models to the Model Anvil");
        holderPanel.add(addAnvil, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 3;
        JPanel cardPanel = new JPanel();
        cardPanel.setLayout(new CardLayout());
        holderPanel.add(cardPanel, c);

        JPanel nameCard = new JPanel();
        JPanel idCard = new JPanel();
        cardPanel.add(nameCard, "NAME");
        cardPanel.add(idCard, "ID");

        JLabel nameLabel = new JLabel("Item name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        nameCard.add(nameLabel);

        JComboBox<ItemData> nameBox = new JComboBox<>();
        nameBox.setBackground(ENTRY_COLOUR);
        nameBox.setPreferredSize(new Dimension(270, 25));
        nameBox.addPopupMenuListener(new PopupMenuListener()
        {
            @Override
            public void popupMenuWillBecomeVisible(PopupMenuEvent e)
            {
                if (!itemsFound)
                {
                    List<ItemData> dataList = dataFinder.getItemData();
                    itemsFound = true;
                    for (ItemData data : dataList)
                    {
                        String name = data.getName();
                        if (name.isEmpty())
                        {
                            continue;
                        }

                        if (name.equals("null"))
                        {
                            continue;
                        }

                        nameBox.addItem(data);
                    }
                }
            }

            @Override
            public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {

            }

            @Override
            public void popupMenuCanceled(PopupMenuEvent e) {

            }
        });
        AutoCompletion.enable(nameBox);
        nameCard.add(nameBox);

        JLabel idLabel = new JLabel("Item Id: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        idCard.add(idLabel);

        JSpinner idSpinner = new JSpinner();
        idSpinner.setBackground(ENTRY_COLOUR);
        idSpinner.setPreferredSize(new Dimension(90, 25));
        idCard.add(idSpinner);

        mode.addItemListener(e ->
        {
            if (e.getItem() == null)
            {
                return;
            }

            String item = (String) e.getItem();
            CardLayout cl = (CardLayout)(cardPanel.getLayout());

            if (item.equalsIgnoreCase(NAME))
            {
                cl.show(cardPanel, NAME);
                return;
            }

            cl.show(cardPanel, ID);
        });

        addObject.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            CustomModelType customModelType = (CustomModelType) modelTypeBox.getSelectedItem();

            if (modeString.equals("Name"))
            {
                ItemData itemData = (ItemData) nameBox.getSelectedItem();
                if (itemData == null)
                {
                    return;
                }

                addItemObject((ItemData) nameBox.getSelectedItem(), customModelType);
            }
            else
            {
                addItemObject((int) idSpinner.getValue(), customModelType);
            }
        });

        addModel.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            CustomModelType customModelType = (CustomModelType) modelTypeBox.getSelectedItem();

            if (modeString.equals("Name"))
            {
                ItemData itemData = (ItemData) nameBox.getSelectedItem();
                if (itemData == null)
                {
                    return;
                }

                addCustomModel(customModelType, itemData.getId());
            }
            else
            {
                addCustomModel(customModelType, (int) idSpinner.getValue());
            }
        });

        addAnvil.addActionListener(e ->
        {
            String modeString = (String) mode.getSelectedItem();
            if (modeString == null)
            {
                return;
            }

            CustomModelType customModelType = (CustomModelType) modelTypeBox.getSelectedItem();

            if (modeString.equals("Name"))
            {
                ItemData itemData = (ItemData) nameBox.getSelectedItem();
                if (itemData == null)
                {
                    return;
                }

                addToAnvil(customModelType, itemData.getId());
            }
            else
            {
                addToAnvil(customModelType, (int) idSpinner.getValue());
            }

        });
    }

    private void addToAnvil(CustomModelType type, int id)
    {
        plugin.cacheToAnvil(type, id);
    }

    private void addCustomModel(CustomModelType type, int id)
    {
        plugin.cacheToCustomModel(type, id, -1);
    }

    private void addItemObject(int id, CustomModelType customModelType)
    {
        List<ItemData> data = dataFinder.getItemData();
        for (ItemData n : data)
        {
            if (n.getId() == id)
            {
                addItemObject(n, customModelType);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the Item you were looking for in the cache.");
    }

    private void addItemObject(ItemData data, CustomModelType customModelType)
    {
        ModelStats[] modelStats = dataFinder.findModelsForGroundItem(data.getId(), customModelType);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the Item you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, false);
            LightingStyle ls;

            switch (customModelType)
            {
                default:
                case CACHE_GROUND_ITEM:
                    ls = LightingStyle.DEFAULT;
                    break;
                case CACHE_MAN_WEAR:
                case CACHE_WOMAN_WEAR:
                    ls = LightingStyle.ACTOR;
            }

            CustomLighting lighting = new CustomLighting(
                    ls.getAmbient(),
                    ls.getContrast(),
                    ls.getX(),
                    ls.getY(),
                    ls.getZ());

            CustomModelComp comp = new CustomModelComp(0, customModelType, data.getId(), modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    -1,
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    creatorsPanel.createEmptyProgram(-1, -1),
                    false,
                    null,
                    null,
                    new int[0],
                    -1,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }

    private void addObjectObject(int id)
    {
        List<ObjectData> data = dataFinder.getObjectData();
        for (ObjectData n : data)
        {
            if (n.getId() == id)
            {
                addObjectObject(n);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the Object you were looking for in the cache.");
    }

    private void addObjectObject(ObjectData data)
    {
        ModelStats[] modelStats = dataFinder.findModelsForObject(data.getId(), -1, LightingStyle.DEFAULT, true);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the Object you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, false);
            CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_OBJECT, data.getId(), modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    data.getAnimationId(),
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    creatorsPanel.createEmptyProgram(data.getAnimationId(), data.getAnimationId()),
                    false,
                    null,
                    null,
                    new int[0],
                    -1,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }

    private void addNPCObject(int id)
    {
        List<NPCData> data = dataFinder.getNpcData();
        for (NPCData n : data)
        {
            if (n.getId() == id)
            {
                addNPCObject(n);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the NPC you were looking for in the cache.");
    }

    private void addNPCObject(NPCData data)
    {
        ModelStats[] modelStats = dataFinder.findModelsForNPC(data.getId());
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the NPC you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, true);
            CustomLighting lighting = new CustomLighting(64, 850, -30, -30, 50);
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_NPC, data.getId(), modelStats, null, null, null, LightingStyle.ACTOR, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    data.getStandingAnimation(),
                    -1,
                    data.getSize() * 60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    creatorsPanel.createEmptyProgram(data.getStandingAnimation(), data.getWalkingAnimation()),
                    false,
                    null,
                    null,
                    new int[0],
                    -1,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.*;
import com.creatorskit.swing.colours.ColourSwapPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Model;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.ArrayList;

@Slf4j
public class ModelAnvil extends JPanel
{
    private ClientThread clientThread;
    private final Client client;
    private final CreatorsPlugin plugin;
    private final BufferedImage DUPLICATE = ImageUtil.loadImageResource(getClass(), "/Duplicate.png");
    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage ARROW_LEFT = ImageUtil.loadImageResource(getClass(), "/Arrow_Left.png");
    private final BufferedImage ARROW_RIGHT = ImageUtil.loadImageResource(getClass(), "/Arrow_Right.png");
    private final BufferedImage ARROW_DOWN = ImageUtil.loadImageResource(getClass(), "/Arrow_Down.png");
    private final BufferedImage ARROW_UP = ImageUtil.loadImageResource(getClass(), "/Arrow_Up.png");
    private final BufferedImage TRANSLATE = ImageUtil.loadImageResource(getClass(), "/Translate.png");
    private final BufferedImage ROTATE = ImageUtil.loadImageResource(getClass(), "/Rotate.png");
    private final BufferedImage TRANSLATE_SUBTILE = ImageUtil.loadImageResource(getClass(), "/Translate subtile.png");
    private final BufferedImage SCALE = ImageUtil.loadImageResource(getClass(), "/Scale.png");
    private final BufferedImage COPY_COLOURS = ImageUtil.loadImageResource(getClass(), "/Copy_Colours.png");
    private final BufferedImage PASTE_COLOURS = ImageUtil.loadImageResource(getClass(), "/Paste_Colours.png");
    private final Dimension SPINNER_DIMENSION = new Dimension(65, 25);
    private final Dimension LIGHT_DIMENSION = new Dimension(70, 25);
    @Getter
    private final JSpinner[] lightingSpinners = new JSpinner[5];
    private final JComboBox<LightingStyle> presetComboBox = new JComboBox<>();
    private final JSpinner ambSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getAmbient(), -1000, 1000, 1));
    private final JSpinner conSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getContrast(), 100, 9999, 1));
    private final JSpinner lightXSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getX(), -1000, 1000, 1));
    private final JSpinner lightYSpinner = new JSpinner((new SpinnerNumberModel(LightingStyle.DEFAULT.getY(), -1000, 1000, 1)));
    private final JSpinner lightZSpinner = new JSpinner((new SpinnerNumberModel(LightingStyle.DEFAULT.getZ(), -1000, 1000, 1)));
    private final Dimension BUTTON_DIMENSION = new Dimension(85, 25);
    @Getter
    private final ArrayList<ComplexPanel> complexPanels = new ArrayList<>();
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    private final JPanel complexMode = new JPanel();
    private final JScrollPane scrollPane = new JScrollPane();
    private final JTabbedPane tabbedPane = new JTabbedPane();
    @Getter
    private final JCheckBox priorityCheckBox = new JCheckBox("Priority");
    @Getter
    private final JTextField nameField = new JTextField();
    private final ColourSwapPanel colourSwapPanel;
    private final GridBagConstraints c = new GridBagConstraints();
    private final int COMPLEX_GRID_COLUMNS = 3;

    @Inject
    public ModelAnvil(Client client, ClientThread clientThread, CreatorsPlugin plugin)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel modelForgeLabel = new JLabel("Model Anvil");
        modelForgeLabel.setFont(FontManager.getRunescapeBoldFont());
        modelForgeLabel.setHorizontalAlignment(SwingConstants.CENTER);
        modelForgeLabel.setVerticalAlignment(SwingConstants.CENTER);
        add(modelForgeLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.ipady = 10;
        JPanel buttonsPanel = new JPanel();
        buttonsPanel.setLayout(new GridLayout(1, 0, 10, 0));
        add(buttonsPanel, c);

        nameField.setText("Name");
        nameField.setHorizontalAlignment(JTextField.CENTER);
        nameField.addActionListener(e -> nameField.setText(StringHandler.cleanString(nameField.getText())));
        nameField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                nameField.setText(StringHandler.cleanString(nameField.getText()));
            }
        });
        buttonsPanel.add(nameField);

        JButton forgeButton = new JButton("Forge");
        buttonsPanel.add(forgeButton);

        JButton forgeSetButton = new JButton("Forge & Set");
        buttonsPanel.add(forgeSetButton);

        c.gridx = 0;
        c.gridy = 2;
        c.weightx = 1;
        c.weighty = 1;
        c.ipady = 0;
        tabbedPane.setBorder(new LineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1));
        add(tabbedPane, c);

        JPanel viewport = new JPanel();
        viewport.setLayout(new GridBagLayout());
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setViewportView(viewport);
        scrollPane.setViewportBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 8));
        tabbedPane.addTab("Model Anvil", scrollPane);

        c.insets = new Insets(0, 0, 0, 0);
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        complexMode.setLayout(new GridLayout(0, COMPLEX_GRID_COLUMNS, 8, 8));
        complexMode.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.add(complexMode, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        colourSwapPanel = new ColourSwapPanel(client, clientThread, complexPanels);
        tabbedPane.addTab("Colour/Texture Swapper", colourSwapPanel);

        JPanel headerPanel = new JPanel();
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(headerPanel);

        JButton addButton = new JButton("Add");
        addButton.addActionListener(e -> createComplexPanel());
        headerPanel.add(addButton);

        JButton clearButton = new JButton("Clear");
        clearButton.addActionListener(e ->
        {
            for (JPanel complexModePanel : complexPanels)
            {
                complexMode.remove(complexModePanel);
                colourSwapPanel.removeAllComplexPanelOptions();
            }

            repaint();
            revalidate();
            complexPanels.clear();
        });
        headerPanel.add(clearButton);

        JPopupMenu loadPopupMenu = new JPopupMenu();
        JMenuItem menuItem = new JMenuItem("Load");
        menuItem.addActionListener(e -> LinkBrowser.open(MODELS_DIR.toString()));
        loadPopupMenu.add(menuItem);

        JButton loadButton = new JButton("Load");
        loadButton.addActionListener(e -> openLoadDialog());
        loadButton.setComponentPopupMenu(loadPopupMenu);
        headerPanel.add(loadButton);

        JButton saveButton = new JButton("Save");

        headerPanel.add(saveButton);

        priorityCheckBox.setToolTipText("Use an oversimplified method of resolving render order issues (can be useful when merging many models)");
        priorityCheckBox.setFocusable(false);
        headerPanel.add(priorityCheckBox);

        JPanel sidePanel = new JPanel();
        sidePanel.setLayout(new GridBagLayout());
        scrollPane.setRowHeaderView(sidePanel);

        JPanel lightPanel = new JPanel();
        lightPanel.setLayout(new GridBagLayout());
        lightPanel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));

        lightingSpinners[0] = ambSpinner;
        lightingSpinners[1] = conSpinner;
        lightingSpinners[2] = lightXSpinner;
        lightingSpinners[3] = lightYSpinner;
        lightingSpinners[4] = lightZSpinner;

        ambSpinner.setToolTipText("<html>Set the ambient lighting level<br>Range: -1000 to 1000</html>");
        conSpinner.setToolTipText("<html>Set the lighting contrast (higher is lower)<br>Range: 100 to 9999</html>");
        lightXSpinner.setToolTipText("<html>Set the sun's x coordinate relative to the player<br>Range: -1000 to 1000</html>");
        lightYSpinner.setToolTipText("<html>Set the sun's y coordinate relative to the player<br>Range: -1000 to 1000</html>");
        lightZSpinner.setToolTipText("<html>Set the sun's z coordinate relative to the player<br>Range: -1000 to 1000</html>");

        presetComboBox.addItem(LightingStyle.DEFAULT);
        presetComboBox.addItem(LightingStyle.ACTOR);
        presetComboBox.addItem(LightingStyle.SPOTANIM);
        presetComboBox.addItem(LightingStyle.DYNAMIC);
        presetComboBox.addItem(LightingStyle.NONE);
        presetComboBox.setFocusable(false);
        presetComboBox.setToolTipText("Quick lighting presets for common cases. Actor = NPCs/Players, SpotAnim = Spells/Effects");

        presetComboBox.addItemListener(e ->
        {
            LightingStyle preset = (LightingStyle) presetComboBox.getSelectedItem();
            if (preset == null)
                return;

            lightingSpinners[0].setValue(preset.getAmbient());
            lightingSpinners[1].setValue(preset.getContrast());
            lightingSpinners[2].setValue(preset.getX());
            lightingSpinners[3].setValue(preset.getY());
            lightingSpinners[4].setValue(preset.getZ());
        });

        c.weightx = 1;
        c.weighty = 0;
        c.insets = new Insets(4, 0, 4, 0);

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 4;
        JLabel lightingLabel = new JLabel("Lighting Settings", SwingConstants.CENTER);
        lightingLabel.setFont(FontManager.getRunescapeBoldFont());
        lightPanel.add(lightingLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        lightPanel.add(new JLabel("Pre ", SwingConstants.RIGHT), c);

        c.gridx = 1;
        c.gridy = 1;
        presetComboBox.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(presetComboBox, c);

        c.gridx = 0;
        c.gridy = 2;
        lightPanel.add(new JLabel("Amb ", SwingConstants.RIGHT), c);

        c.gridx = 0;
        c.gridy = 3;
        lightPanel.add(new JLabel("Con ", SwingConstants.RIGHT), c);

        c.gridx = 1;
        c.gridy = 2;
        ambSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(ambSpinner, c);

        c.gridx = 1;
        c.gridy = 3;
        conSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(conSpinner, c);

        c.gridx = 2;
        c.gridy = 1;
        lightPanel.add(new JLabel("x ", SwingConstants.RIGHT), c);

        c.gridx = 2;
        c.gridy = 2;
        lightPanel.add(new JLabel("y ", SwingConstants.RIGHT), c);

        c.gridx = 2;
        c.gridy = 3;
        lightPanel.add(new JLabel("z ", SwingConstants.RIGHT), c);

        c.gridx = 3;
        c.gridy = 1;
        lightXSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightXSpinner, c);

        c.gridx = 3;
        c.gridy = 2;
        lightYSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightYSpinner, c);

        c.gridx = 3;
        c.gridy = 3;
        lightZSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightZSpinner, c);

        JPanel cacheSearcherPanel = new JPanel();
        cacheSearcherPanel.setLayout(new GridLayout(0, 1, 4, 4));
        cacheSearcherPanel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        cacheSearcherPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JLabel searcherLabel = new JLabel("Cache Searcher");
        searcherLabel.setFont(FontManager.getRunescapeBoldFont());
        searcherLabel.setHorizontalAlignment(SwingConstants.CENTER);
        searcherLabel.setVerticalAlignment(SwingConstants.CENTER);
        cacheSearcherPanel.add(searcherLabel);

        JSpinner idSpinner = new JSpinner(new SpinnerNumberModel(0, 0, 99999, 1));
        idSpinner.setToolTipText("Choose the NPC, Object, or Item Id to find all its associated models");
        cacheSearcherPanel.add(idSpinner);

        JComboBox<CustomModelType> modelTypeComboBox = new JComboBox<>();
        modelTypeComboBox.addItem(CustomModelType.CACHE_NPC);
        modelTypeComboBox.addItem(CustomModelType.CACHE_OBJECT);
        modelTypeComboBox.addItem(CustomModelType.CACHE_GROUND_ITEM);
        modelTypeComboBox.addItem(CustomModelType.CACHE_MAN_WEAR);
        modelTypeComboBox.addItem(CustomModelType.CACHE_WOMAN_WEAR);
        modelTypeComboBox.setFocusable(false);
        modelTypeComboBox.setToolTipText("Pick which part of the cache to search");
        cacheSearcherPanel.add(modelTypeComboBox);

        JPanel groupPanel = new GroupPanel(client, plugin, clientThread);

        c.insets = new Insets(8, 8, 8, 8);

        c.gridx = 0;
        c.gridy = 0;
        sidePanel.add(lightPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        sidePanel.add(cacheSearcherPanel, c);

        c.gridx = 0;
        c.gridy = 2;
        sidePanel.add(groupPanel, c);

        c.gridx = 0;
        c.gridy = 3;
        c.weighty = 1;
        sidePanel.add(new JLabel(""), c);

        JButton addModelsButton = new JButton("Add Models");
        addModelsButton.setToolTipText("Add the chosen NPC, Object, or Item as a Custom Model");
        cacheSearcherPanel.add(addModelsButton);
        addModelsButton.addActionListener(e ->
        {
            CustomModelType type = (CustomModelType) modelTypeComboBox.getSelectedItem();
            if (type == null)
                return;

            int id = (int) idSpinner.getValue();
            plugin.cacheToAnvil(type, id);
        });

        forgeButton.addActionListener(e -> onForgeButtonPressed(client, nameField, false));
        forgeSetButton.addActionListener(e -> onForgeButtonPressed(client, nameField, true));

        saveButton.addActionListener(e ->
        {
            CustomLighting lighting = new CustomLighting(
                    (int) lightingSpinners[0].getValue(),
                    (int) lightingSpinners[1].getValue(),
                    (int) lightingSpinners[2].getValue(),
                    (int) lightingSpinners[3].getValue(),
                    (int) lightingSpinners[4].getValue());

            openSaveDialog(nameField.getText(), priorityCheckBox.isSelected(), LightingStyle.CUSTOM, lighting);
        });

        revalidate();
    }

    public void createComplexPanel()
    {
        createComplexPanel(
                "Name",
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                128,
                128,
                128,
                0,
                "",
                "",
                new short[0],
                new short[0],
                new short[0],
                new short[0],
                false);
    }

    public void createComplexPanel(DetailedModel dm)
    {
        createComplexPanel(
                dm.getName(),
                dm.getModelId(),
                dm.getGroup(),
                dm.getXTile(),
                dm.getYTile(),
                dm.getZTile(),
                dm.getXTranslate(),
                dm.getYTranslate(),
                dm.getZTranslate(),
                dm.getXScale(),
                dm.getYScale(),
                dm.getZScale(),
                dm.getRotate(),
                dm.getRecolourNew(),
                dm.getRecolourOld(),
                dm.getColoursFrom(),
                dm.getColoursTo(),
                dm.getTexturesFrom(),
                dm.getTexturesTo(),
                dm.isInvertFaces());
    }

    public void createComplexPanel(
            String name,
            int modelId,
            int group,
            int xTile,
            int yTile,
            int zTile,
            int xTranslate,
            int yTranslate,
            int zTranslate,
            int scaleX,
            int scaleY,
            int scaleZ,
            int rotate,
            String newColours,
            String oldColours,
            short[] coloursFrom,
            short[] coloursTo,
            short[] texturesFrom,
            short[] texturesTo,
            boolean invertFaces)
    {
        JSpinner modelIdSpinner = new JSpinner();
        JSpinner groupSpinner = new JSpinner();
        JTextField nameField = new JTextField(name);
        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JCheckBox check90 = new JCheckBox();
        JCheckBox check180 = new JCheckBox();
        JCheckBox check270 = new JCheckBox();
        JCheckBox checkInvertFaces = new JCheckBox();

        if (coloursFrom == null)
            coloursFrom = stringToShort(oldColours);

        if (coloursTo == null)
            coloursTo = stringToShort(newColours);

        if (texturesFrom == null)
            texturesFrom = new short[0];

        if (texturesTo == null)
            texturesTo = new short[0];

        ComplexPanel complexModePanel = new ComplexPanel(
                modelIdSpinner,
                groupSpinner,
                nameField,
                coloursFrom, coloursTo,
                texturesFrom, texturesTo,
                xSpinner, ySpinner, zSpinner,
                xTileSpinner, yTileSpinner, zTileSpinner,
                xScaleSpinner, yScaleSpinner, zScaleSpinner,
                check90, check180, check270,
                checkInvertFaces);

        complexModePanel.setLayout(new GridBagLayout());
        complexModePanel.setBorder(new LineBorder(getBorderColour(modelId), 1));

        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 4;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        nameField.setToolTipText("Name for organizational purposes only");
        complexModePanel.add(nameField, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 2;
        JPanel arrowPanel = new JPanel();
        arrowPanel.setLayout(new BorderLayout());
        complexModePanel.add(arrowPanel, c);

        JButton arrowUpButton = new JButton(new ImageIcon(ARROW_UP));
        arrowUpButton.setFocusable(false);
        arrowUpButton.setToolTipText("Move panel up");
        arrowUpButton.addActionListener(e -> setPanelIndex(complexModePanel, -COMPLEX_GRID_COLUMNS));
        arrowPanel.add(arrowUpButton, BorderLayout.PAGE_START);

        JButton arrowLeftButton = new JButton(new ImageIcon(ARROW_LEFT));
        arrowLeftButton.setFocusable(false);
        arrowLeftButton.setToolTipText("Move panel left");
        arrowLeftButton.addActionListener(e -> setPanelIndex(complexModePanel, -1));
        arrowPanel.add(arrowLeftButton, BorderLayout.LINE_START);

        JButton arrowRightButton = new JButton(new ImageIcon(ARROW_RIGHT));
        arrowRightButton.setFocusable(false);
        arrowRightButton.setToolTipText("Move panel right");
        arrowRightButton.addActionListener(e -> setPanelIndex(complexModePanel, 1));
        arrowPanel.add(arrowRightButton, BorderLayout.LINE_END);

        JButton arrowDownButton = new JButton(new ImageIcon(ARROW_DOWN));
        arrowDownButton.setFocusable(false);
        arrowDownButton.setToolTipText("Move panel up");
        arrowDownButton.addActionListener(e -> setPanelIndex(complexModePanel, COMPLEX_GRID_COLUMNS));
        arrowPanel.add(arrowDownButton, BorderLayout.PAGE_END);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 2;
        JPanel xyzPanel = new JPanel();
        xyzPanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(xyzPanel, c);

        JLabel xLabel = new JLabel("x:");
        xLabel.setToolTipText("East/West");
        xLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(xLabel);

        JLabel yLabel = new JLabel("y:");
        yLabel.setToolTipText("North/South");
        yLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(yLabel);

        JLabel zLabel = new JLabel("z:");
        zLabel.setToolTipText("Up/Down");
        zLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(zLabel);

        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 3;
        JLabel colourLabel = new JLabel("Colours:");
        colourLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        colourLabel.setToolTipText("Choose new Colours to replace default Colours");
        complexModePanel.add(colourLabel, c);

        c.gridwidth = 2;
        c.gridx = 4;
        c.gridy = 0;
        SpinnerNumberModel modelIdModel = new SpinnerNumberModel(modelId, -1, 99999, 1);
        modelIdSpinner.setModel(modelIdModel);
        modelIdSpinner.setBackground((modelId == -1) ? ColorScheme.PROGRESS_ERROR_COLOR : ColorScheme.DARK_GRAY_COLOR);
        modelIdSpinner.setToolTipText("Set the id of the model you want to draw from the cache");
        modelIdSpinner.addChangeListener(e ->
        {
            int newValue = (int) modelIdSpinner.getValue();
            complexModePanel.setBorder(new LineBorder(getBorderColour(newValue), 1));
            modelIdSpinner.setBackground((newValue == -1) ? ColorScheme.PROGRESS_ERROR_COLOR : ColorScheme.DARK_GRAY_COLOR);
            if (colourSwapPanel.getComboBox().getSelectedItem() == complexModePanel)
                colourSwapPanel.onSwapperPressed(complexModePanel);
        });
        complexModePanel.add(modelIdSpinner, c);

        c.gridwidth = 2;
        c.gridx = 6;
        c.gridy = 0;
        SpinnerNumberModel groupSpinnerNumberModel = new SpinnerNumberModel(group, 1, 99, 1);
        groupSpinner.setModel(groupSpinnerNumberModel);
        groupSpinner.setToolTipText("Set the group for the purpose of Group Transforms");
        groupSpinner.setBackground(getBorderColour(group * 6));
        complexModePanel.add(groupSpinner, c);
        groupSpinner.addChangeListener(e ->
        {
            int colourPick = ((int) groupSpinner.getValue()) * 6;
            groupSpinner.setBackground(getBorderColour(colourPick));
        });

        c.gridx = 8;
        c.gridy = 0;
        c.gridwidth = 1;
        JButton duplicateButton = new JButton(new ImageIcon(DUPLICATE));
        duplicateButton.setFocusable(false);
        duplicateButton.setToolTipText("Duplicate panel");
        duplicateButton.setPreferredSize(new Dimension(30, 25));
        complexModePanel.add(duplicateButton, c);

        c.gridx = 9;
        c.gridy = 0;
        c.gridwidth = 1;
        JButton removeButton = new JButton(new ImageIcon(CLOSE));
        removeButton.setFocusable(false);
        removeButton.setToolTipText("Remove panel");
        removeButton.setPreferredSize(new Dimension(30, 25));
        complexModePanel.add(removeButton, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        complexModePanel.add(tileLabel, c);

        c.gridx = 4;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        complexModePanel.add(translateLabel, c);

        c.gridx = 6;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        complexModePanel.add(scaleLabel, c);

        c.gridx = 8;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        complexModePanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(tilePanel, c);

        xTileSpinner.setValue(xTile);
        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        tilePanel.add(xTileSpinner);

        yTileSpinner.setValue(yTile);
        yTileSpinner.setToolTipText("N/S");
        tilePanel.add(yTileSpinner);

        zTileSpinner.setValue(zTile);
        zTileSpinner.setToolTipText("U/D");
        tilePanel.add(zTileSpinner);

        c.gridx = 4;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(translatePanel, c);

        xSpinner.setValue(xTranslate);
        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        translatePanel.add(xSpinner);

        ySpinner.setValue(yTranslate);
        ySpinner.setToolTipText("N/S");
        translatePanel.add(ySpinner);

        zSpinner.setValue(zTranslate);
        zSpinner.setToolTipText("U/D");
        translatePanel.add(zSpinner);

        c.gridx = 6;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(scalePanel, c);

        xScaleSpinner.setValue(scaleX);
        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        scalePanel.add(xScaleSpinner);

        yScaleSpinner.setValue(scaleY);
        yScaleSpinner.setToolTipText("N/S");
        scalePanel.add(yScaleSpinner);

        zScaleSpinner.setValue(scaleZ);
        zScaleSpinner.setToolTipText("U/D");
        scalePanel.add(zScaleSpinner);

        c.gridx = 8;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel rotatePanel = new JPanel();
        rotatePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        rotatePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(rotatePanel, c);

        check90.setText("90");
        check90.setHorizontalAlignment(SwingConstants.LEFT);
        check90.setFocusable(false);
        rotatePanel.add(check90);

        check180.setText("180");
        check180.setHorizontalAlignment(SwingConstants.LEFT);
        check180.setFocusable(false);
        rotatePanel.add(check180);

        check270.setText("270");
        check270.setHorizontalAlignment(SwingConstants.LEFT);
        check270.setFocusable(false);
        rotatePanel.add(check270);

        check90.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check180.setSelected(false);
                check270.setSelected(false);
            }
        });

        check180.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check90.setSelected(false);
                check270.setSelected(false);
            }
        });

        check270.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check180.setSelected(false);
                check90.setSelected(false);
            }
        });

        switch (rotate)
        {
            case 0:
                break;
            case 1:
                check270.setSelected(true);
                break;
            case 2:
                check180.setSelected(true);
                break;
            case 3:
                check90.setSelected(true);
        }

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JButton swapperButton = new JButton("Swap");
        swapperButton.setFocusable(false);
        swapperButton.setToolTipText("Opens this model in the Colour/Texture Swapper tab");
        swapperButton.setPreferredSize(BUTTON_DIMENSION);
        complexModePanel.add(swapperButton, c);
        swapperButton.addActionListener(e ->
        {
            colourSwapPanel.setComboBox(complexModePanel);
            tabbedPane.setSelectedIndex(1);
        });

        c.gridx = 4;
        c.gridy = 3;
        c.gridwidth = 1;
        JButton copyButton = new JButton(new ImageIcon(COPY_COLOURS));
        copyButton.setFocusable(false);
        copyButton.setToolTipText("Copy all swapped colours & textures");
        copyButton.addActionListener(e -> colourSwapPanel.copyColoursTextures(complexModePanel));
        complexModePanel.add(copyButton, c);

        c.gridx = 5;
        c.gridy = 3;
        c.gridwidth = 1;
        JButton pasteButton = new JButton(new ImageIcon(PASTE_COLOURS));
        pasteButton.setFocusable(false);
        pasteButton.setToolTipText("Paste all copied colours & textures");
        complexModePanel.add(pasteButton, c);
        pasteButton.addActionListener(e -> colourSwapPanel.pasteColoursTextures(complexModePanel));

        c.gridx = 6;
        c.gridy = 3;
        c.gridwidth = 2;
        JButton clearColoursTextures = new JButton("Clear");
        clearColoursTextures.setFocusable(false);
        clearColoursTextures.setToolTipText("Clears all swapped colours & textures");
        clearColoursTextures.setPreferredSize(BUTTON_DIMENSION);
        complexModePanel.add(clearColoursTextures, c);
        clearColoursTextures.addActionListener(e -> colourSwapPanel.clearColoursTextures(complexModePanel));
        colourSwapPanel.addComplexPanelOption(complexModePanel);

        c.gridx = 8;
        c.gridy = 3;
        c.gridwidth = 1;
        checkInvertFaces.setText("Invert");
        checkInvertFaces.setToolTipText("Inverts all faces. Should be used with scaling the x or y dimensions in the negative direction");
        checkInvertFaces.setSelected(invertFaces);
        checkInvertFaces.setHorizontalAlignment(SwingConstants.LEFT);
        checkInvertFaces.setFocusable(false);
        complexModePanel.add(checkInvertFaces, c);

        duplicateButton.addActionListener(e ->
        {
            int rotation = 0;
            if (check270.isSelected())
            {
                rotation = 1;
            }

            if (check180.isSelected())
            {
                rotation = 2;
            }

            if (check90.isSelected())
            {
                rotation = 3;
            }

            createComplexPanel(
                    nameField.getText(),
                    (int) modelIdSpinner.getValue(),
                    (int) groupSpinner.getValue(),
                    (int) xTileSpinner.getValue(),
                    (int) yTileSpinner.getValue(),
                    (int) zTileSpinner.getValue(),
                    (int) xSpinner.getValue(),
                    (int) ySpinner.getValue(),
                    (int) zSpinner.getValue(),
                    (int) xScaleSpinner.getValue(),
                    (int) yScaleSpinner.getValue(),
                    (int) zScaleSpinner.getValue(),
                    rotation,
                    "",
                    "",
                    complexModePanel.getColoursFrom(),
                    complexModePanel.getColoursTo(),
                    complexModePanel.getTexturesFrom(),
                    complexModePanel.getTexturesTo(),
                    checkInvertFaces.isSelected());
        });

        removeButton.addActionListener(e ->
        {
            colourSwapPanel.removeComplexPanelOption(complexModePanel);
            complexMode.remove(complexModePanel);
            complexPanels.remove(complexModePanel);
            repaint();
            revalidate();
        });

        nameField.addActionListener(e ->
        {
            String text = StringHandler.cleanString(nameField.getText());
            nameField.setText(text.replaceAll("=", ""));
        });

        nameField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                String text = StringHandler.cleanString(nameField.getText());
                nameField.setText(text.replaceAll("=", ""));
            }
        });

        JSpinner[] spinners = new JSpinner[]{xSpinner, ySpinner, zSpinner, xScaleSpinner, yScaleSpinner, zScaleSpinner, xTileSpinner, yTileSpinner, zTileSpinner};
        for (JSpinner spinner : spinners)
        {
            JSpinner.DefaultEditor defaultEditor = (JSpinner.DefaultEditor) spinner.getEditor();
            defaultEditor.getTextField().addMouseListener(new MouseAdapter()
            {
                @Override
                public void mouseClicked(MouseEvent e)
                {
                    if (SwingUtilities.isRightMouseButton(e))
                    {
                        int i = 0;
                        if (spinner == xScaleSpinner || spinner == yScaleSpinner || spinner == zScaleSpinner)
                            i = 128;
                        spinner.setValue(i);
                    }
                }
            });
        }

        complexMode.add(complexModePanel);
        complexModePanel.setEnabled(true);
        complexModePanel.setVisible(true);
        complexPanels.add(complexModePanel);

        revalidate();
        repaint();
    }

    private void setPanelIndex(ComplexPanel panel, int change)
    {
        int newPosition = complexMode.getComponentZOrder(panel) + change;
        if (newPosition < 0)
            newPosition = 0;

        if (newPosition >= complexPanels.size())
            newPosition = complexPanels.size() - 1;

        complexMode.setComponentZOrder(panel, newPosition);
        complexPanels.remove(panel);
        complexPanels.add(newPosition, panel);

        repaint();
        revalidate();
    }

    private void onForgeButtonPressed(Client client, JTextField nameField, boolean forgeAndSet)
    {
        CustomLighting lighting = new CustomLighting(
                (int) lightingSpinners[0].getValue(),
                (int) lightingSpinners[1].getValue(),
                (int) lightingSpinners[2].getValue(),
                (int) lightingSpinners[3].getValue(),
                (int) lightingSpinners[4].getValue());

        if (lighting.getX() == 0 && lighting.getY() == 0 && lighting.getZ() == 0)
            lighting.setZ(1);

        forgeModel(client, nameField, priorityCheckBox.isSelected(), lighting, forgeAndSet);
    }

    private void forgeModel(Client client, JTextField nameField, boolean setPriority, CustomLighting lighting, boolean forgeAndSet)
    {
        if (client == null)
        {
            return;
        }

        if (complexPanels.isEmpty())
            return;

        clientThread.invokeLater(() ->
        {
            DetailedModel[] detailedModels = panelsToDetailedModels();
            Model model = forgeComplexModel(setPriority, detailedModels, LightingStyle.CUSTOM, lighting);
            if (model == null)
            {
                return;
            }

            CustomModelComp comp = new CustomModelComp(plugin.getStoredModels().size(), CustomModelType.FORGED, -1, null, null, detailedModels, null, LightingStyle.CUSTOM, lighting, setPriority, nameField.getText());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, forgeAndSet);
        });
    }

    public Model forgeComplexModel(boolean setPriority, DetailedModel[] detailedModels, LightingStyle lightingStyle, CustomLighting lighting)
    {
        return plugin.createComplexModel(detailedModels, setPriority, lightingStyle, lighting);
    }

    private DetailedModel[] panelsToDetailedModels()
    {
        DetailedModel[] detailedModels = new DetailedModel[0];

        for (int i = 0; i < complexPanels.size(); i++)
        {
            ComplexPanel complexModePanel = complexPanels.get(i);
            String name = complexModePanel.getNameField().getText();
            int modelId = (int) complexModePanel.getModelIdSpinner().getValue();
            if (modelId == -1)
            {
                continue;
            }

            int group = (int) complexModePanel.getGroupSpinner().getValue();
            int xTile = (int) complexModePanel.getXTileSpinner().getValue();
            int yTile = (int) complexModePanel.getYTileSpinner().getValue();
            int zTile = (int) complexModePanel.getZTileSpinner().getValue();
            int xTranslate = (int) complexModePanel.getXSpinner().getValue();
            int yTranslate = (int) complexModePanel.getYSpinner().getValue();
            int zTranslate = (int) complexModePanel.getZSpinner().getValue();
            int xScale = (int) complexModePanel.getXScaleSpinner().getValue();
            int yScale = (int) complexModePanel.getYScaleSpinner().getValue();
            int zScale = (int) complexModePanel.getZScaleSpinner().getValue();
            int rotate = 0;
            short[] coloursFrom = complexModePanel.getColoursFrom();
            short[] coloursTo = complexModePanel.getColoursTo();
            short[] texturesFrom = complexModePanel.getTexturesFrom();
            short[] texturesTo = complexModePanel.getTexturesTo();
            boolean invertFaces = complexModePanel.getInvertFaces().isSelected();
            JCheckBox check90 = complexModePanel.getCheck90();
            JCheckBox check180 = complexModePanel.getCheck180();
            JCheckBox check270 = complexModePanel.getCheck270();

            if (check90.isSelected())
                rotate = 3;

            if (check180.isSelected())
                rotate = 2;

            if (check270.isSelected())
                rotate = 1;

            DetailedModel detailedModel = new DetailedModel(
                    name,
                    modelId,
                    group,
                    xTile, yTile, zTile,
                    xTranslate, yTranslate, zTranslate,
                    xScale, yScale, zScale, rotate,
                    "", "",
                    coloursFrom, coloursTo,
                    texturesFrom, texturesTo,
                    invertFaces);
            detailedModels = ArrayUtils.add(detailedModels, detailedModel);
        }

        return detailedModels;
    }

    private void openSaveDialog(String name, boolean priority, LightingStyle lightingStyle, CustomLighting lighting)
    {
        File outputDir = MODELS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save current model collection");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile, name, priority, lightingStyle, lighting);
        }
    }

    public void saveToFile(File file, String name, boolean priority, LightingStyle lightingStyle, CustomLighting lighting)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            DetailedModel[] detailedModels = panelsToDetailedModels();
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.FORGED, -1, null, null, detailedModels, null, lightingStyle, lighting, priority, name);
            String string = plugin.getGson().toJson(comp);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving Forge model to file");
        }
    }

    private void openLoadDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.exists())
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
                if (!selectedFile.exists())
                {
                    plugin.sendChatMessage("Could not find the requested Custom Model file.");
                    return;
                }
            }

            plugin.loadCustomModelToAnvil(selectedFile, priorityCheckBox.isSelected(), nameField.getText());
        }
    }

    public static short[] stringToShort(String string)
    {
        if (string.isEmpty())
            return new short[0];

        String[] split = string.split(",");
        short[] array = new short[0];
        try
        {
            for (String s : split)
                array = ArrayUtils.add(array, Short.parseShort(s));
        }
        catch (Exception e)
        {
            return new short[0];
        }

        return array;
    }

    public static Color getBorderColour(int i)
    {
        if (i == -1)
        {
            return ColorScheme.MEDIUM_GRAY_COLOR;
        }

        float hue = ((float) i - 25) / 50;
        return Color.getHSBColor(hue, 1, (float) 0.7);
    }

    public void setLightingSettings(LightingStyle preset, int ambience, int contrast, int x, int y, int z)
    {
        if (preset == LightingStyle.CUSTOM)
            preset = LightingStyle.DEFAULT;

        presetComboBox.setSelectedItem(preset);
        ambSpinner.setValue(ambience);
        conSpinner.setValue(contrast);
        lightXSpinner.setValue(x);
        lightYSpinner.setValue(y);
        lightZSpinner.setValue(z);
    }
}

package com.creatorskit.swing;

public enum ParentPanel
{
    MANAGER,
    SIDE_PANEL
}

package com.creatorskit.swing;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.tree.DefaultMutableTreeNode;

@Getter
@Setter
@AllArgsConstructor
public class Folder
{
    private String name;
    private FolderType folderType;
    private DefaultMutableTreeNode linkedManagerNode;
    private DefaultMutableTreeNode parentManagerNode;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@Getter
@Setter
@AllArgsConstructor
public class ComplexPanel extends JPanel
{
    private final JSpinner modelIdSpinner;
    private final JSpinner groupSpinner;
    private final JTextField nameField;
    private short[] coloursFrom;
    private short[] coloursTo;
    private short[] texturesFrom;
    private short[] texturesTo;
    private final JSpinner xSpinner;
    private final JSpinner ySpinner;
    private final JSpinner zSpinner;
    private final JSpinner xTileSpinner;
    private final JSpinner yTileSpinner;
    private final JSpinner zTileSpinner;
    private final JSpinner xScaleSpinner;
    private final JSpinner yScaleSpinner;
    private final JSpinner zScaleSpinner;
    private final JCheckBox check90;
    private final JCheckBox check180;
    private final JCheckBox check270;
    private final JCheckBox invertFaces;

    @Override
    public String toString()
    {
        return nameField.getText() + " (" + modelIdSpinner.getValue() + (")");
    }
}

package com.creatorskit.swing;

public enum GroupOperation
{
    X_TILE_SPINNER,
    Y_TILE_SPINNER,
    Z_TILE_SPINNER,
    X_SPINNER,
    Y_SPINNER,
    Z_SPINNER,
    X_SCALE_SPINNER,
    Y_SCALE_SPINNER,
    Z_SCALE_SPINNER
}

package com.creatorskit.swing;

public enum FolderType
{
    MASTER,
    SIDE_PANEL,
    MANAGER,
    STANDARD
}

package com.creatorskit.swing;

import com.creatorskit.saves.CharacterSave;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.Character;
import com.creatorskit.saves.FolderNodeSave;
import com.creatorskit.saves.SetupSave;
import com.creatorskit.models.*;
import com.creatorskit.programming.Coordinate;
import com.creatorskit.programming.MovementType;
import com.creatorskit.programming.Program;
import com.creatorskit.programming.ProgramComp;
import com.creatorskit.swing.manager.ManagerPanel;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Model;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.ArrayUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.filechooser.FileFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Getter
public class CreatorsPanel extends PluginPanel
{
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final ToolBoxFrame toolBox;
    private final ModelAnvil modelAnvil;
    private final ModelOrganizer modelOrganizer;
    private final DataFinder dataFinder;
    private final ProgrammerPanel programmerPanel;
    private final TransmogPanel transmogPanel;
    private final ModelImporter modelImporter;

    private final JButton addObjectButton = new JButton();
    private final JPanel sidePanel = new JPanel();
    private final Random random = new Random();
    public static final File SETUP_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/setups");
    public static final File CREATORS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    private final Pattern pattern = Pattern.compile("\\(\\d+\\)\\Z");
    private int npcPanels = 0;
    private ArrayList<Character> sidePanelCharacters = new ArrayList<>();
    private final ArrayList<JComboBox<CustomModel>> comboBoxes = new ArrayList<>();
    private final Dimension spinnerSize = new Dimension(72, 30);
    private final Dimension BUTTON_SIZE = new Dimension(25, 25);
    private final int DEFAULT_TURN_SPEED = 40;
    private final BufferedImage SWITCH = ImageUtil.loadImageResource(getClass(), "/Switch.png");
    private final BufferedImage DUPLICATE = ImageUtil.loadImageResource(getClass(), "/Duplicate.png");
    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage HELP = ImageUtil.loadImageResource(getClass(), "/Help.png");
    private final BufferedImage CLEAR = ImageUtil.loadImageResource(getClass(), "/Clear.png");
    private final BufferedImage LOAD = ImageUtil.loadImageResource(getClass(), "/Load.png");
    private final BufferedImage SAVE = ImageUtil.loadImageResource(getClass(), "/Save.png");
    private final BufferedImage FIND = ImageUtil.loadImageResource(getClass(), "/Find.png");
    private final BufferedImage CUSTOM_MODEL = ImageUtil.loadImageResource(getClass(), "/Custom model.png");
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    private final LineBorder defaultBorder = new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1);
    private final LineBorder hoveredBorder = new LineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1);
    private final LineBorder selectedBorder = new LineBorder(Color.WHITE, 1);

    @Inject
    public CreatorsPanel(@Nullable Client client, ClientThread clientThread, CreatorsPlugin plugin, ToolBoxFrame toolBox, DataFinder dataFinder, ModelImporter modelImporter)
    {
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.toolBox = toolBox;
        this.modelOrganizer = toolBox.getModelOrganizer();
        this.programmerPanel = toolBox.getProgramPanel();
        this.modelAnvil = toolBox.getModelAnvil();
        this.transmogPanel = toolBox.getTransmogPanel();
        this.dataFinder = dataFinder;
        this.modelImporter = modelImporter;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 3;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JButton toolBoxButton = new JButton("Toolbox");
        toolBoxButton.setToolTipText("Opens an interface for organizing Objects, creating Custom Models, programming, and more");
        toolBoxButton.setFocusable(false);
        toolBoxButton.addActionListener(e ->
        {
            toolBox.setVisible(!toolBox.isVisible());
            revalidate();
            repaint();
        });
        add(toolBoxButton, c);


        c.gridwidth = 1;
        c.gridheight = 2;
        c.weightx = 5;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 1;
        addObjectButton.setFocusable(false);
        addObjectButton.setText("Add Object");
        addObjectButton.setToolTipText("Add an new Object to the palette");
        addObjectButton.addActionListener(e ->
        {
            Character character = createCharacter(ParentPanel.SIDE_PANEL);
            SwingUtilities.invokeLater(() -> addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
        add(addObjectButton, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 2;
        c.weighty = 0;
        c.gridx = 1;
        c.gridy = 1;
        JButton findButton = new JButton(new ImageIcon(FIND));
        findButton.setFocusable(false);
        findButton.setToolTipText("Open the File Explorer and navigate to the Creator's Kit directory");
        add(findButton, c);
        findButton.addActionListener(e ->
        {
            try
            {
                LinkBrowser.open(CREATORS_DIR.getAbsolutePath());
            }
            catch (Exception exception)
            {
            }
        });

        c.gridx = 2;
        c.gridy = 1;
        JButton helpButton = new JButton(new ImageIcon(HELP));
        helpButton.setToolTipText("Open at YouTube tutorial for help with using this plugin");
        helpButton.setFocusable(false);
        add(helpButton, c);
        helpButton.addActionListener(e ->
        {
            try
            {
                Desktop desk = Desktop.getDesktop();
                desk.browse(new URI("https://www.youtube.com/watch?v=E_9c-LwDRRY"));
            }
            catch (Exception exception)
            {
                plugin.sendChatMessage("Failed to open link...");
            }
        });

        c.gridx = 1;
        c.gridy = 2;
        JButton loadCustomModelButton = new JButton(new ImageIcon(CUSTOM_MODEL));
        loadCustomModelButton.setFocusable(false);
        loadCustomModelButton.setToolTipText("Load a previously saved Custom Model");
        add(loadCustomModelButton, c);
        loadCustomModelButton.addActionListener(e -> openLoadCustomModelDialog());

        c.gridx = 2;
        c.gridy = 2;
        JButton clearButton = new JButton(new ImageIcon(CLEAR));
        clearButton.setFocusable(false);
        clearButton.setToolTipText("Clears all Objects");
        add(clearButton, c);
        clearButton.addActionListener(e -> clearSidePanels(true));

        c.gridwidth = 3;
        c.gridx = 0;
        c.gridy = 3;
        c.weightx = 1;
        c.weighty = 0;
        sidePanel.setLayout(new GridLayout(0, 1, 4, 4));
        sidePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(sidePanel, c);

        c.gridwidth = 3;
        c.gridx = 0;
        c.gridy = 4;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        add(emptyLabel, c);
    }

    public Character createCharacter(ParentPanel parentPanel)
    {
        return createCharacter(
                parentPanel,
                "Object (" + npcPanels + ")",
                7699,
                null,
                false,
                0,
                -1,
                -1,
                60,
                new KeyFrame[KeyFrameType.getTotalFrameTypes()][0],
                createEmptyProgram(-1, -1),
                false, null, null, new int[0], -1, false, false);
    }

    public Character createCharacter(
                              ParentPanel parentPanel,
                              String name,
                              int modelId,
                              CustomModel customModel,
                              boolean customModeActive,
                              int orientation,
                              int animationId,
                              int frame,
                              int radius,
                              KeyFrame[][] keyFrames,
                              Program program,
                              boolean active,
                              WorldPoint worldPoint,
                              LocalPoint localPoint,
                              int[] localPointRegion,
                              int localPointPlane,
                              boolean inInstance,
                              boolean setHoveredLocation)
    {
        JPanel programPanel = program.getProgramPanel();
        ObjectPanel objectPanel = new ObjectPanel(name, null, programPanel);
        objectPanel.setLayout(new GridBagLayout());

        JTextField textField = new JTextField(name);
        Dimension textDimension = new Dimension(140, 30);
        textField.setMaximumSize(textDimension);
        textField.setPreferredSize(textDimension);
        textField.setMinimumSize(textDimension);

        JPanel topButtonsPanel = new JPanel();
        Dimension topButtonsPanelSize = new Dimension(81, 30);
        topButtonsPanel.setMaximumSize(topButtonsPanelSize);
        topButtonsPanel.setPreferredSize(topButtonsPanelSize);
        topButtonsPanel.setMinimumSize(topButtonsPanelSize);
        topButtonsPanel.setLayout(new GridLayout(1, 3, 0, 0));

        JButton switchButton = new JButton(new ImageIcon(SWITCH));
        switchButton.setToolTipText("Switch this Object between the Manager and Side Panel");
        switchButton.setFocusable(false);

        JButton duplicateButton = new JButton(new ImageIcon(DUPLICATE));
        duplicateButton.setToolTipText("Duplicate object");
        duplicateButton.setFocusable(false);

        JButton deleteButton = new JButton(new ImageIcon(CLOSE));
        deleteButton.setToolTipText("Delete object");
        deleteButton.setFocusable(false);

        //Buttons
        JButton modelButton = new JButton();
        modelButton.setFont(FontManager.getRunescapeFont());
        String modelButtonText = customModeActive ? "Custom" : "Id";
        modelButton.setText(modelButtonText);
        modelButton.setToolTipText("Toggle between Custom Model and Model ID");
        modelButton.setFocusable(false);

        JButton spawnButton = new JButton();
        spawnButton.setFont(FontManager.getRunescapeFont());
        spawnButton.setText(active ? "Spawn" : "Despawn");
        spawnButton.setToolTipText("Toggle the NPC on or off");
        spawnButton.setFocusable(false);

        JButton animationButton = new JButton();
        animationButton.setFont(FontManager.getRunescapeFont());
        animationButton.setText("Anim Off");
        animationButton.setToolTipText("Toggle the playing animation");
        animationButton.setPreferredSize(new Dimension(90, 25));
        animationButton.setFocusable(false);

        JPanel framePanel = new JPanel();
        framePanel.setLayout(new BorderLayout());

        JLabel frameLabel = new JLabel(" Frame: ");
        frameLabel.setToolTipText("The animation frame to freeze on");
        frameLabel.setFont(FontManager.getRunescapeSmallFont());
        framePanel.add(frameLabel, BorderLayout.LINE_START);

        JSpinner animationFrameSpinner = new JSpinner(new SpinnerNumberModel(frame, -1, 999, 1));
        animationFrameSpinner.setPreferredSize(new Dimension(60, 25));
        framePanel.add(animationFrameSpinner, BorderLayout.CENTER);

        //Labels
        JLabel modelLabel = new JLabel("Model ID:");
        modelLabel.setToolTipText("The ID number of the model to spawn");
        modelLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel orientationLabel = new JLabel("Rotation:");
        orientationLabel.setToolTipText("0 = South, 512 = West, 1024 = North, 1536 = East, 2048 = Max");
        orientationLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel radiusLabel = new JLabel("Radius:");
        radiusLabel.setToolTipText("Increasing the radius may prevent clipping issues with the ground");
        radiusLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel animationLabel = new JLabel("Anim ID:");
        animationLabel.setToolTipText("The animation ID number. -1 gives no animation");
        animationLabel.setFont(FontManager.getRunescapeSmallFont());

        //Spinners
        JSpinner modelSpinner = new JSpinner();
        modelSpinner.setPreferredSize(topButtonsPanelSize);
        modelSpinner.setMaximumSize(topButtonsPanelSize);
        modelSpinner.setMinimumSize(topButtonsPanelSize);
        modelSpinner.setValue(modelId);
        modelSpinner.setVisible(!customModeActive);

        JComboBox<CustomModel> modelComboBox = new JComboBox<>();
        modelComboBox.setPreferredSize(topButtonsPanelSize);
        modelComboBox.setMaximumSize(topButtonsPanelSize);
        modelComboBox.setMinimumSize(topButtonsPanelSize);
        modelComboBox.setFont(FontManager.getRunescapeFont());
        modelComboBox.setVisible(customModeActive);
        for (CustomModel model : plugin.getStoredModels())
        {
            modelComboBox.addItem(model);
        }
        if (customModel != null)
            modelComboBox.setSelectedItem(customModel);

        SpinnerModel orientationRange = new SpinnerNumberModel(orientation, 0, 2048, 1);
        JSpinner orientationSpinner = new JSpinner(orientationRange);

        JSpinner radiusSpinner = new JSpinner();
        radiusSpinner.setValue(radius);

        JSpinner animationSpinner = new JSpinner();
        animationSpinner.setValue(animationId);

        SwingUtilities.invokeLater(() ->
        {
            GridBagConstraints c = new GridBagConstraints();
            c.fill = GridBagConstraints.BOTH;
            c.insets = new Insets(1, 1, 1, 1);
            c.gridwidth = 2;
            c.gridx = 0;
            c.gridy = 0;
            c.weightx = 1;
            objectPanel.add(textField, c);

            c.gridwidth = 1;
            c.gridx = 2;
            c.gridy = 0;
            c.weightx = 0;
            objectPanel.add(topButtonsPanel, c);
            topButtonsPanel.add(switchButton);
            topButtonsPanel.add(duplicateButton);
            topButtonsPanel.add(deleteButton);

            c.ipadx = 0;
            c.ipady = 5;
            c.gridwidth = 1;
            c.weightx = 1;
            c.gridx = 0;
            c.gridy = 1;
            objectPanel.add(modelButton, c);

            c.gridy++;
            objectPanel.add(spawnButton, c);

            c.gridy++;
            objectPanel.add(animationButton, c);

            c.gridy++;
            objectPanel.add(framePanel, c);

            c.fill = GridBagConstraints.NONE;
            c.anchor = GridBagConstraints.LINE_END;
            c.ipadx = 0;
            c.ipady = 0;
            c.gridwidth = 1;
            c.weightx = 0;
            c.gridx = 1;
            c.gridy = 1;
            objectPanel.add(modelLabel, c);

            c.gridy++;
            objectPanel.add(orientationLabel, c);

            c.gridy++;
            objectPanel.add(radiusLabel, c);

            c.gridy++;
            objectPanel.add(animationLabel, c);

            c.fill = GridBagConstraints.BOTH;
            c.anchor = GridBagConstraints.CENTER;
            c.gridwidth = 1;
            c.gridx = 2;
            c.gridy = 1;
            objectPanel.add(modelSpinner, c);
            objectPanel.add(modelComboBox, c);

            c.gridy++;
            objectPanel.add(orientationSpinner, c);

            c.gridy++;
            objectPanel.add(radiusSpinner, c);

            c.gridy++;
            objectPanel.add(animationSpinner, c);

            objectPanel.repaint();
            objectPanel.revalidate();
        });

        JLabel programmerNameLabel = program.getNameLabel();
        programmerNameLabel.setText(name);
        JSpinner programmerIdleSpinner = program.getIdleAnimSpinner();

        Character character = new Character(
                textField.getText(),
                active,
                worldPoint != null || localPoint != null,
                keyFrames,
                null,
                null,
                program,
                worldPoint,
                localPoint,
                localPointRegion,
                localPointPlane,
                inInstance,
                (CustomModel) modelComboBox.getSelectedItem(),
                parentPanel,
                objectPanel,
                customModeActive,
                textField,
                modelComboBox,
                spawnButton,
                modelButton,
                modelSpinner,
                animationSpinner,
                animationFrameSpinner,
                orientationSpinner,
                radiusSpinner,
                programmerNameLabel,
                programmerIdleSpinner,
                null,
                0);

        objectPanel.setCharacter(character);
        ManagerPanel managerPanel = toolBox.getManagerPanel();

        SwingUtilities.invokeLater(() -> programmerPanel.createProgramPanel(character, programPanel, programmerNameLabel, programmerIdleSpinner));

        textField.addActionListener(e ->
        {
            String text = StringHandler.cleanString(textField.getText());
            textField.setText(text);
            character.setName(text);
            objectPanel.setName(text);
            character.getProgram().getNameLabel().setText(text);
            managerPanel.revalidate();
            managerPanel.repaint();
        });

        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}

            @Override
            public void focusLost(FocusEvent e)
            {
                String text = StringHandler.cleanString(textField.getText());
                textField.setText(text);
                objectPanel.setName(text);
                character.setName(text);
                programmerNameLabel.setText(text);
                managerPanel.revalidate();
                managerPanel.repaint();
            }
        });

        switchButton.addActionListener(e -> onSwitchButtonPressed(character));

        deleteButton.addActionListener(e -> onDeleteButtonPressed(character));

        duplicateButton.addActionListener(e -> onDuplicatePressed(character, false));

        objectPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                setSelectedCharacter(character);
            }
        });

        objectPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered (MouseEvent e)
            {
                setHoveredCharacter(character, objectPanel);
            }

            @Override
            public void mouseExited (MouseEvent e)
            {
                unsetHoveredCharacter(character, objectPanel);
            }
        });

        spawnButton.addActionListener(e -> plugin.toggleSpawn(spawnButton, character));

        animationButton.addActionListener(e ->
        {
            int animId = character.getCKObject().getAnimationId();
            if (animId == -1)
            {
                animationButton.setText("Anim Off");
                programmerIdleSpinner.setValue((int) animationSpinner.getValue());
                plugin.setAnimation(character, (int) animationSpinner.getValue());
                return;
            }

            animationButton.setText("Anim On");
            plugin.unsetAnimation(character);
        });

        modelButton.addActionListener(e ->
        {
            if (character.isCustomMode())
            {
                character.setCustomMode(false);
                modelButton.setText("Id");
                modelSpinner.setVisible(true);
                modelComboBox.setVisible(false);
                plugin.setModel(character, false, (int) modelSpinner.getValue());
            }
            else
            {
                character.setCustomMode(true);
                modelButton.setText("Custom");
                modelSpinner.setVisible(false);
                modelComboBox.setVisible(true);
                plugin.setModel(character, true, -1);
            }
        });

        modelSpinner.addChangeListener(e ->
        {
            int modelNumber = (int) modelSpinner.getValue();
            plugin.setModel(character, false, modelNumber);
        });

        modelComboBox.addItemListener(e ->
        {
            CustomModel m = (CustomModel) modelComboBox.getSelectedItem();
            character.setStoredModel(m);
            if (modelComboBox.isVisible() && character == plugin.getSelectedCharacter())
                plugin.setModel(character, true, -1);
        });

        orientationSpinner.addChangeListener(e ->
        {
            int orient = (int) orientationSpinner.getValue();
            plugin.setOrientation(character, orient);
        });

        animationSpinner.addChangeListener(e ->
        {
            animationButton.setText("Anim Off");
            int animationNumber = (int) animationSpinner.getValue();
            plugin.setAnimation(character, animationNumber);
            plugin.setAnimationFrame(character, (int) animationFrameSpinner.getValue(), true);
            programmerIdleSpinner.setValue(animationNumber);
        });

        animationFrameSpinner.addChangeListener(e ->
        {
            int animFrame = (int) animationFrameSpinner.getValue();
            plugin.setAnimationFrame(character, animFrame, true);
        });

        radiusSpinner.addChangeListener(e ->
        {
            int rad = (int) radiusSpinner.getValue();
            plugin.setRadius(character, rad);
        });

        addAllSelectListeners(
                character,
                objectPanel,
                textField,
                topButtonsPanel,
                duplicateButton,
                deleteButton,
                modelButton,
                spawnButton,
                animationButton,
                animationFrameSpinner,
                frameLabel,
                modelLabel,
                orientationLabel,
                radiusLabel,
                animationLabel,
                modelSpinner,
                modelComboBox,
                orientationSpinner,
                radiusSpinner,
                animationSpinner
        );

        setSelectedCharacter(character);

        plugin.setupRLObject(character, setHoveredLocation);
        plugin.getCharacters().add(character);

        comboBoxes.add(modelComboBox);
        return character;
    }

    private void addAllSelectListeners(
            Character character,
            ObjectPanel objectPanel,
            JTextField textField,
            JPanel topButtonsPanel,
            JButton duplicateButton,
            JButton deleteButton,
            JButton modelButton,
            JButton spawnButton,
            JButton animationButton,
            JSpinner animationFrameSpinner,
            JLabel frameLabel,
            JLabel modelLabel,
            JLabel orientationLabel,
            JLabel radiusLabel,
            JLabel animationLabel,
            JSpinner modelSpinner,
            JComboBox<CustomModel> modelComboBox,
            JSpinner orientationSpinner,
            JSpinner radiusSpinner,
            JSpinner animationSpinner)
    {
        addSelectListeners(objectPanel, character, objectPanel, true);
        addSelectListeners(textField, character, objectPanel, true);
        addSelectListeners(topButtonsPanel, character, objectPanel, true);
        addSelectListeners(duplicateButton, character, objectPanel, false);
        addSelectListeners(deleteButton, character, objectPanel, false);
        addSelectListeners(modelButton, character, objectPanel, true);
        addSelectListeners(spawnButton, character, objectPanel, true);
        addSelectListeners(animationButton, character, objectPanel, true);
        addSelectListeners(animationFrameSpinner, character, objectPanel, true);
        addSelectListeners(frameLabel, character, objectPanel, true);
        addSelectListeners(modelLabel, character, objectPanel, true);
        addSelectListeners(orientationLabel, character, objectPanel, true);
        addSelectListeners(radiusLabel, character, objectPanel, true);
        addSelectListeners(animationLabel, character, objectPanel, true);
        addSelectListeners(modelComboBox, character, objectPanel, true);

        for (Component c : modelSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : orientationSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : radiusSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : animationSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }
    }

    private void addSelectListeners(Component component, Character character, ObjectPanel objectPanel, boolean pressedListener)
    {
        component.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered (MouseEvent e)
            {
                setHoveredCharacter(character, objectPanel);
            }
            @Override
            public void mouseExited (MouseEvent e)
            {
                unsetHoveredCharacter(character, objectPanel);
            }
        });

        if (pressedListener)
        {
            component.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    setSelectedCharacter(character);
                }
            });
        }
    }

    public void addPanel(ParentPanel parentPanel, Character character, boolean revalidate, boolean switching)
    {
        addPanel(parentPanel, character, null, revalidate, switching);
    }

    public void addPanel(ParentPanel parentPanel, Character character, DefaultMutableTreeNode parentNode, boolean revalidate, boolean switching)
    {
        ObjectPanel childPanel = character.getObjectPanel();
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        ManagerTree managerTree = managerPanel.getManagerTree();

        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            sidePanelCharacters.add(character);
            sidePanel.add(childPanel);
            if (parentNode == null)
            {
                managerTree.addCharacterNode(character, ParentPanel.SIDE_PANEL, true, switching);
            }
            else
            {
                managerTree.addCharacterNode(parentNode, character, ParentPanel.SIDE_PANEL, true);
            }

            if (revalidate)
            {
                sidePanel.repaint();
                sidePanel.revalidate();
            }
        }

        if (parentPanel == ParentPanel.MANAGER)
        {
            managerPanel.getManagerCharacters().add(character);

            if (parentNode == null)
            {
                managerTree.addCharacterNode(character, ParentPanel.MANAGER, true, switching);
            }
            else
            {
                managerTree.addCharacterNode(parentNode, character, ParentPanel.MANAGER, true);
            }

            if (revalidate)
            {
                managerTree.resetObjectHolder();
            }
        }

        if (!switching)
        {
            npcPanels++;
        }
    }

    public void onSwitchButtonPressed(Character character)
    {
        ParentPanel parentPanel = character.getParentPanel();
        removePanel(character);

        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            addPanel(ParentPanel.MANAGER, character, true, true);
        }
        else
        {
            addPanel(ParentPanel.SIDE_PANEL, character, true, true);
        }
    }

    public void onDuplicatePressed(Character character, boolean setLocation)
    {
        ProgramComp comp = character.getProgram().getComp();

        WorldPoint[] newSteps = ArrayUtils.clone(comp.getStepsWP());
        WorldPoint[] newPath = ArrayUtils.clone(comp.getPathWP());
        LocalPoint[] newStepsLP = ArrayUtils.clone(comp.getStepsLP());
        LocalPoint[] newPathLP = ArrayUtils.clone(comp.getPathLP());
        Coordinate[] newCoordinates = ArrayUtils.clone(comp.getCoordinates());
        Color newColor = getRandomColor();
        ProgramComp newComp = new ProgramComp(
                newSteps,
                newPath,
                newStepsLP,
                newPathLP,
                newCoordinates,
                comp.isPathFound(),
                0,
                comp.getSpeed(),
                comp.getTurnSpeed(),
                comp.getIdleAnim(),
                comp.getWalkAnim(),
                comp.getMovementType(),
                newColor.getRGB(),
                comp.isLoop(),
                comp.isProgramActive());

        String newName = character.getName();
        Matcher matcher = pattern.matcher(newName);
        if (matcher.find())
        {
            String duplicate = matcher.group();
            duplicate = duplicate.replace("(", "");
            duplicate = duplicate.replace(")", "");

            int duplicateNumber = Integer.parseInt(duplicate) + 1;
            newName = newName.replaceFirst("(?s)" + duplicate + "(?!.*?" + duplicate + ")", "" + duplicateNumber);
        }
        else
        {
            newName = newName + " (1)";
        }

        Program newProgram = new Program(newComp, new JPanel(), new JLabel(), new JSpinner(), newColor);

        ParentPanel parentPanel = character.getParentPanel();

        String finalNewName = newName;
        Thread thread = new Thread(() ->
        {
            Character c = createCharacter(
                    character.getParentPanel(),
                    finalNewName,
                    (int) character.getModelSpinner().getValue(),
                    (CustomModel) character.getComboBox().getSelectedItem(),
                    character.isCustomMode(),
                    (int) character.getOrientationSpinner().getValue(),
                    (int) character.getAnimationSpinner().getValue(),
                    (int) character.getAnimationFrameSpinner().getValue(),
                    (int) character.getRadiusSpinner().getValue(),
                    Arrays.copyOf(character.getFrames(), character.getFrames().length),
                    newProgram,
                    character.isActive(),
                    character.getNonInstancedPoint(),
                    character.getInstancedPoint(),
                    character.getInstancedRegions(),
                    character.getInstancedPlane(),
                    character.isInInstance(),
                    setLocation);

            SwingUtilities.invokeLater(() -> addPanel(parentPanel, c, true, false));
        });
        thread.start();
    }

    public void onDeleteButtonPressed(Character character)
    {
        removePanel(character);
        ArrayList<Character> characters = plugin.getCharacters();
        clientThread.invokeLater(() -> character.getCKObject().setActive(false));
        characters.remove(character);
        if (plugin.getSelectedCharacter() == character)
        {
            plugin.setSelectedCharacter(null);
        }
    }

    public void deleteCharacters(Character[] charactersToRemove)
    {
        removePanels(charactersToRemove);

        ArrayList<Character> characters = plugin.getCharacters();
        for (Character c : charactersToRemove)
        {
            clientThread.invokeLater(() -> c.getCKObject().setActive(false));
            characters.remove(c);
            if (c == plugin.getSelectedCharacter())
            {
                plugin.setSelectedCharacter(null);
            }
        }
    }

    public void removePanels(Character[] characters)
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        JPanel objectHolder = managerPanel.getObjectHolder();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();
        ManagerTree managerTree = managerPanel.getManagerTree();

        for (Character character : characters)
        {
            ObjectPanel objectPanel = character.getObjectPanel();
            ParentPanel parentPanel = character.getParentPanel();
            if (parentPanel == ParentPanel.SIDE_PANEL)
            {
                sidePanel.remove(objectPanel);
                sidePanelCharacters.remove(character);
                managerTree.removeCharacterNode(character);
            }

            if (parentPanel == ParentPanel.MANAGER)
            {
                objectHolder.remove(objectPanel);
                managerTree.removeCharacterNode(character);
                managerCharacters.remove(character);
            }
        }

        sidePanel.repaint();
        sidePanel.revalidate();
        objectHolder.repaint();
        objectHolder.revalidate();
        managerTree.resetObjectHolder();
    }

    public void removePanel(Character character)
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        ManagerTree managerTree = managerPanel.getManagerTree();

        ObjectPanel objectPanel = character.getObjectPanel();
        ParentPanel parentPanel = character.getParentPanel();
        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            sidePanel.remove(objectPanel);
            managerTree.resetObjectHolder();
            sidePanelCharacters.remove(character);
            managerTree.removeCharacterNode(character);
        }

        JPanel objectHolder = managerPanel.getObjectHolder();
        if (parentPanel == ParentPanel.MANAGER)
        {
            objectHolder.remove(objectPanel);
            managerTree.removeCharacterNode(character);
            managerTree.resetObjectHolder();
            managerPanel.getManagerCharacters().remove(character);
        }

        sidePanel.repaint();
        sidePanel.revalidate();
        objectHolder.repaint();
        objectHolder.revalidate();
    }

    public void clearSidePanels(boolean warning)
    {
        if (warning)
        {
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete all Objects from the Side Panel?");
            if (result != JOptionPane.YES_OPTION)
                return;
        }

        for (Character character : sidePanelCharacters)
        {
            if (character == plugin.getSelectedCharacter())
            {
                unsetSelectedCharacter();
                break;
            }
        }

        Character[] charactersToRemove = sidePanelCharacters.toArray(new Character[sidePanelCharacters.size()]);

        sidePanelCharacters.clear();
        Thread thread = new Thread(() -> deleteCharacters(charactersToRemove));
        thread.start();
        sidePanel.removeAll();
        sidePanel.repaint();
        sidePanel.revalidate();
        programmerPanel.repaint();
        programmerPanel.revalidate();
    }

    public void clearManagerPanels()
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        JPanel objectHolder = managerPanel.getObjectHolder();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();

        for (Character character : managerCharacters)
        {
            if (character == plugin.getSelectedCharacter())
            {
                unsetSelectedCharacter();
                break;
            }
        }

        Character[] charactersToRemove = managerCharacters.toArray(new Character[managerCharacters.size()]);

        objectHolder.removeAll();
        managerPanel.getManagerTree().resetObjectHolder();
        plugin.removeCharacters(charactersToRemove);
        programmerPanel.repaint();
        programmerPanel.revalidate();
    }

    public void resetSidePanel()
    {
        sidePanel.removeAll();
        ArrayList<Character> characters = new ArrayList<>();
        toolBox.getManagerPanel().getManagerTree().getSidePanelChildren(characters);
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            sidePanel.add(character.getObjectPanel());
        }

        sidePanelCharacters = characters;

        sidePanel.repaint();
        sidePanel.revalidate();
    }

    public void setSelectedCharacter(Character selected)
    {
        ArrayList<Character> characters = plugin.getCharacters();

        for (int i = 0; i < characters.size(); i++)
        {
            ObjectPanel panel = characters.get(i).getObjectPanel();
            panel.setBorder(defaultBorder);
        }

        selected.getObjectPanel().setBorder(selectedBorder);
        plugin.setSelectedCharacter(selected);
    }

    public void scrollSelectedCharacter(Character selected, int clicks)
    {
        int sidePanelSize = sidePanelCharacters.size();
        Character[] shownCharacters = toolBox.getManagerPanel().getShownCharacters();
        int managerSize = shownCharacters.length;

        boolean selectionFound = false;

        if (selected != null)
        {
            ParentPanel selectedParent = selected.getParentPanel();
            Character[] list = selectedParent == ParentPanel.SIDE_PANEL ? sidePanelCharacters.toArray(new Character[sidePanelCharacters.size()]) : shownCharacters;
            int length = list.length;
            for (int i = 0; i < length; i++)
            {
                if (selected == list[i])
                {
                    int index = clicks + i;
                    while (index >= length)
                    {
                        index -= length;
                    }

                    while (index < 0)
                    {
                        index += length;
                    }

                    unsetSelectedCharacter();
                    setSelectedCharacter(list[index]);
                    selectionFound = true;
                    break;
                }
            }
        }

        if (!selectionFound)
        {
            if (toolBox.isFocused())
            {
                if (managerSize > 0)
                {
                    unsetSelectedCharacter();
                    setSelectedCharacter(shownCharacters[0]);
                    return;
                }
            }

            if (sidePanelSize > 0)
            {
                unsetSelectedCharacter();
                setSelectedCharacter(sidePanelCharacters.get(0));
            }
        }
    }

    public void unsetSelectedCharacter()
    {
        ArrayList<Character> characters = plugin.getCharacters();

        for (int i = 0; i < characters.size(); i++)
        {
            ObjectPanel panel = characters.get(i).getObjectPanel();
            panel.setBorder(defaultBorder);
        }

        plugin.setSelectedCharacter(null);
    }

    public void setHoveredCharacter(Character hovered, JPanel jPanel)
    {
        if (plugin.getSelectedCharacter() == hovered)
        {
            return;
        }

        jPanel.setBorder(hoveredBorder);
        plugin.setHoveredCharacter(hovered);
    }

    public void unsetHoveredCharacter(Character hoverRemoved, JPanel jPanel)
    {
        plugin.setHoveredCharacter(null);

        if (plugin.getSelectedCharacter() == hoverRemoved)
        {
            return;
        }

        jPanel.setBorder(defaultBorder);
    }

    public void addModelOption(CustomModel model, boolean setComboBox)
    {
        modelOrganizer.createModelPanel(model);
        Character selectedNPC = plugin.getSelectedCharacter();

        for (JComboBox<CustomModel> comboBox : comboBoxes)
        {
            comboBox.addItem(model);
            if (!setComboBox || selectedNPC == null)
                continue;

            JComboBox<CustomModel> selectedBox = selectedNPC.getComboBox();
            if (comboBox == selectedBox)
            {
                comboBox.setSelectedItem(model);
                selectedNPC.setCustomMode(true);
                selectedNPC.getModelButton().setText("Custom");

                if (selectedNPC.getModelSpinner().isVisible() || comboBox.isVisible())
                {
                    comboBox.setVisible(true);
                    selectedNPC.getModelSpinner().setVisible(false);
                }
            }

            selectedNPC.setStoredModel(model);
            plugin.setModel(selectedNPC, true, -1);
        }
    }

    public void removeModelOption(CustomModel model)
    {
        for (JComboBox<CustomModel> comboBox : comboBoxes)
        {
            comboBox.removeItem(model);
        }
        modelOrganizer.removeModelPanel(model);
    }

    private Color getRandomColor()
    {
        float r = random.nextFloat();
        float g = random.nextFloat();
        float b = random.nextFloat();
        return new Color(r, g, b);
    }

    public Program createEmptyProgram(int poseAnim, int walkAnim)
    {
        Color color = getRandomColor();
        ProgramComp comp = new ProgramComp(new WorldPoint[0], new WorldPoint[0], new LocalPoint[0], new LocalPoint[0], new Coordinate[0], false, 0, 1, DEFAULT_TURN_SPEED, poseAnim, walkAnim, MovementType.NORMAL, color.getRGB(), false, false);
        return new Program(comp, new JPanel(), new JLabel(), new JSpinner(), color);
    }

    public void openSaveDialog()
    {
        File outputDir = SETUP_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File("setup"));
        fileChooser.setDialogTitle("Save current setup");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile);
        }
    }

    public void saveToFile(File file)
    {
        ArrayList<CustomModel> customModels = plugin.getStoredModels();
        CustomModelComp[] comps = new CustomModelComp[customModels.size()];

        for (int i = 0; i < comps.length; i++)
        {
            comps[i] = customModels.get(i).getComp();
        }

        //Get Folder structure and all characters contained within
        FolderNodeSave folderNodeSave = getFolders(comps);

        SetupSave saveFile = new SetupSave(getPluginVersion(), comps, folderNodeSave, new CharacterSave[0]);

        try
        {
            FileWriter writer = new FileWriter(file, false);
            String string = plugin.getGson().toJson(saveFile);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            plugin.sendChatMessage("An error occurred while writing to file.");
        }
    }

    public FolderNodeSave getFolders(CustomModelComp[] comps)
    {
        FolderNodeSave folderNodeSave = new FolderNodeSave(FolderType.MASTER, "Master Panel", new CharacterSave[0], new FolderNodeSave[0]);
        getFolderChildren(folderNodeSave, toolBox.getManagerPanel().getManagerTree().getRootNode(), comps);
        return folderNodeSave;
    }

    public void getFolderChildren(FolderNodeSave parentNodeSave, DefaultMutableTreeNode parent, CustomModelComp[] comps)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            CharacterSave[] characterSaves = parentNodeSave.getCharacterSaves();
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                Character character = (Character) node.getUserObject();
                CharacterSave characterSave = createCharacterSave(character, comps);
                parentNodeSave.setCharacterSaves(ArrayUtils.add(characterSaves, characterSave));
            }

            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                String name = (folder.getName());
                FolderNodeSave folderNodeSave = new FolderNodeSave(folder.getFolderType(), name, new CharacterSave[0], new FolderNodeSave[0]);
                parentNodeSave.setFolderSaves(ArrayUtils.add(parentNodeSave.getFolderSaves(), folderNodeSave));

                if (!node.isLeaf())
                    getFolderChildren(folderNodeSave, node, comps);
            }
        }
    }

    private CharacterSave createCharacterSave(Character character, CustomModelComp[] comps)
    {
        String name = character.getName();
        boolean locationSet = character.isLocationSet();
        WorldPoint savedWorldPoint = character.getNonInstancedPoint();
        LocalPoint savedLocalPoint = character.getInstancedPoint();
        int[] localPointRegion = character.getInstancedRegions();
        int localPointPlane = character.getInstancedPlane();
        boolean inInstance = character.isInInstance();
        int compId = 0;
        CustomModel storedModel = character.getStoredModel();
        if (storedModel != null)
        {
            for (int e = 0; e < comps.length; e++)
            {
                CustomModelComp comp = comps[e];
                if (storedModel.getComp() == comp)
                {
                    compId = e;
                    break;
                }
            }
        }

        boolean customMode = character.isCustomMode();
        int modelId = (int) character.getModelSpinner().getValue();
        boolean active = character.isActive();
        int radius = character.getCKObject().getRadius();
        int rotation = (int) character.getOrientationSpinner().getValue();
        int animationId = (int) character.getAnimationSpinner().getValue();
        int frame = (int) character.getAnimationFrameSpinner().getValue();
        KeyFrame[][] keyFrames = character.getFrames();
        ProgramComp programComp = character.getProgram().getComp();

        return new CharacterSave(
                name,
                locationSet,
                savedWorldPoint,
                savedLocalPoint,
                localPointRegion,
                localPointPlane,
                inInstance,
                compId,
                customMode,
                modelId,
                active,
                radius,
                rotation,
                animationId,
                frame,
                programComp,
                keyFrames);
    }

    public void openLoadSetupDialog()
    {
        File outputDir = SETUP_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir);
        fileChooser.setDialogTitle("Choose a setup to load");
        fileChooser.setFileFilter(new FileFilter()
        {
            @Override
            public String getDescription()
            {
                return "Json File (*.json)";
            }

            @Override
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }
                else
                {
                    String filename = f.getName().toLowerCase();
                    return filename.endsWith(".json");
                }
            }
        });

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.exists())
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
                if (!selectedFile.exists())
                {
                    plugin.sendChatMessage("Could not find the requested Setup file.");
                    return;
                }
            }

            try
            {
                Reader reader = Files.newBufferedReader(selectedFile.toPath());
                SetupSave saveFile = plugin.getGson().fromJson(reader, SetupSave.class);
                File finalSelectedFile = selectedFile;
                clientThread.invokeLater(() -> loadSetup(finalSelectedFile, saveFile));
                reader.close();
            }
            catch (Exception e)
            {
                plugin.sendChatMessage("An error occurred while attempting to read this file.");
            }
        }
    }

    public void loadSetup(File file)
    {
        try
        {
            Reader reader = Files.newBufferedReader(file.toPath());
            SetupSave saveFile = plugin.getGson().fromJson(reader, SetupSave.class);
            clientThread.invokeLater(() -> loadSetup(file, saveFile));
            reader.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
            plugin.sendChatMessage("An error occurred while attempting to read this file.");
        }
    }

    private void loadSetup(File file, SetupSave saveFile)
    {
        CustomModelComp[] comps = saveFile.getComps();
        FolderNodeSave folderNodeSave = saveFile.getMasterFolderNode();
        CustomModel[] customModels = new CustomModel[comps.length];
        String fileVersion = saveFile.getVersion();
        if (fileVersion == null || fileVersion.isEmpty())
        {
            fileVersion = "1.5.10";
        }

        for (int i = 0; i < comps.length; i++)
        {
            CustomModelComp comp = comps[i];
            Model model;
            CustomModel customModel;
            ModelStats[] modelStats;

            switch (comp.getType())
            {
                case FORGED:
                    model = plugin.createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), comp.getCustomLighting());
                    customModel = new CustomModel(model, comp);
                    break;
                case CACHE_NPC:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, new int[0], false, true);
                    customModel = new CustomModel(model, comp);
                    break;
                case CACHE_PLAYER:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, comp.getKitRecolours(), true, true);
                    customModel = new CustomModel(model, comp);
                    break;
                default:
                case CACHE_OBJECT:
                case CACHE_GROUND_ITEM:
                case CACHE_MAN_WEAR:
                case CACHE_WOMAN_WEAR:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, null, false, false);
                    customModel = new CustomModel(model, comp);
                    break;
                case BLENDER:
                    model = modelImporter.createModel(comp.getBlenderModel(), comp.getLightingStyle());
                    customModel = new CustomModel(model, comp);
            }

            plugin.addCustomModel(customModel, false);
            customModels[i] = customModel;
        }

        ManagerTree managerTree = toolBox.getManagerPanel().getManagerTree();
        DefaultMutableTreeNode rootNode = managerTree.getRootNode();

        final String version = fileVersion;

        SwingUtilities.invokeLater(() ->
        {
            if (folderNodeSave != null)
            {
                openFolderNodeSave(version, managerTree, rootNode, folderNodeSave, customModels);
                sidePanel.repaint();
                sidePanel.revalidate();
                managerTree.resetObjectHolder();
            }
        });

        //Handle pre-v1.5.4 characters saved to the SidePanel
        CharacterSave[] characterSaves = saveFile.getSaves();
        if (characterSaves.length > 0)
        {
            Thread thread = new Thread(() ->
            {
                for (CharacterSave save : characterSaves)
                {
                    Color color = new Color(save.getProgramComp().getRgb());
                    Program program = new Program(save.getProgramComp(), new JPanel(), new JLabel(), new JSpinner(), color);
                    Character character;

                    CustomModel customModel = null;
                    if (customModels.length > 0)
                    {
                        customModel = customModels[save.getCompId()];
                    }

                    int animFrame = save.getFrame();
                    if (isVersionLessThan(version, "1.5.12"))
                    {
                        animFrame = -1;
                    }

                    KeyFrame[][] keyFrames = save.getKeyFrames();
                    if (keyFrames == null)
                    {
                        keyFrames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][0];
                    }

                    if (keyFrames.length < KeyFrameType.getTotalFrameTypes())
                    {
                        keyFrames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][0];
                    }

                    character = createCharacter(
                            ParentPanel.SIDE_PANEL,
                            save.getName(),
                            save.getModelId(),
                            customModel,
                            save.isCustomMode(),
                            save.getRotation(),
                            save.getAnimationId(),
                            animFrame,
                            save.getRadius(),
                            keyFrames,
                            program,
                            save.isActive(),
                            save.getNonInstancedPoint(),
                            save.getInstancedPoint(),
                            save.getInstancedRegions(),
                            save.getInstancedPlane(),
                            save.isInInstance(),
                            false);

                    SwingUtilities.invokeLater(() -> addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                }
            });
            thread.start();
        }
    }

    private void openFolderNodeSave(String fileVersion, ManagerTree managerTree, DefaultMutableTreeNode parentNode, FolderNodeSave folderNodeSave, CustomModel[] customModels)
    {
        String name = folderNodeSave.getName();
        DefaultMutableTreeNode node;
        FolderType folderType = folderNodeSave.getFolderType();

        //Handle pre-v1.5.4 saves
        if (folderType == null)
        {
            node = managerTree.addFolderNode(parentNode, name);
        }
        else
        {
            switch (folderType)
            {
                default:
                case STANDARD:
                    node = managerTree.addFolderNode(parentNode, name);
                    break;
                case MASTER:
                case MANAGER:
                    node = managerTree.getManagerNode();
                    break;
                case SIDE_PANEL:
                    node = managerTree.getSidePanelNode();
            }
        }

        ParentPanel parentPanel;
        if (folderType == FolderType.SIDE_PANEL)
        {
            parentPanel = ParentPanel.SIDE_PANEL;
        }
        else
        {
            parentPanel = ParentPanel.MANAGER;
        }

        for (CharacterSave save : folderNodeSave.getCharacterSaves())
        {
            Color color = new Color(save.getProgramComp().getRgb());
            Program program = new Program(save.getProgramComp(), new JPanel(), new JLabel(), new JSpinner(), color);
            Character character;
            CustomModel customModel = null;
            if (customModels.length > 0)
            {
                customModel = customModels[save.getCompId()];
            }

            int animFrame = save.getFrame();
            if (isVersionLessThan(fileVersion, "1.5.11"))
            {
                animFrame = -1;
            }

            KeyFrame[][] keyFrames = save.getKeyFrames();
            if (keyFrames == null)
            {
                keyFrames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][0];
            }

            if (keyFrames.length < KeyFrameType.getTotalFrameTypes())
            {
                keyFrames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][0];
            }

            character = createCharacter(
                    parentPanel,
                    save.getName(),
                    save.getModelId(),
                    customModel,
                    save.isCustomMode(),
                    save.getRotation(),
                    save.getAnimationId(),
                    animFrame,
                    save.getRadius(),
                    keyFrames,
                    program,
                    save.isActive(),
                    save.getNonInstancedPoint(),
                    save.getInstancedPoint(),
                    save.getInstancedRegions(),
                    save.getInstancedPlane(),
                    save.isInInstance(),
                    false);

            addPanel(parentPanel, character, node, false, false);
        }

        FolderNodeSave[] folderNodeSaves = folderNodeSave.getFolderSaves();
        for (FolderNodeSave fns : folderNodeSaves)
        {
            openFolderNodeSave(fileVersion, managerTree, node, fns, customModels);
        }
    }

    private void openLoadCustomModelDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");

        JCheckBox priorityCheckbox = new JCheckBox("Set Priority?");
        priorityCheckbox.setToolTipText("May resolve some rendering issues by setting all faces to the same priority. Leave off if you're unsure");

        JPanel accessory = new JPanel();
        accessory.setLayout(new GridLayout(0, 1));
        accessory.add(priorityCheckbox);

        fileChooser.setAccessory(accessory);

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            String name = selectedFile.getName();
            if (name.endsWith(".json"))
                name = replaceLast(name, ".json");

            if (name.endsWith(".txt"))
                name = replaceLast(name, ".txt");

            plugin.loadCustomModel(selectedFile, priorityCheckbox.isSelected(), name);
        }
    }

    private String replaceLast(String string, String from)
    {
        int lastIndex = string.lastIndexOf(from);
        if (lastIndex < 0)
            return string;
        String tail = string.substring(lastIndex).replaceFirst(from, "");
        return string.substring(0, lastIndex) + tail;
    }

    private String getPluginVersion()
    {
        try (InputStream is = CreatorsPlugin.class.getResourceAsStream("/version.txt"))
        {
            if (is == null)
            {
                return "0.0.0";
            }

            String text = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8)).readLine();
            String version = text.split("=")[1];
            is.close();
            return version;
        }
        catch (IOException e)
        {
            return "0.0.0";
        }
    }

    private boolean isVersionLessThan(String version1, String version2)
    {
        String[] split1 = version1.split("\\.");
        int first1 = Integer.parseInt(split1[0]);
        int second1 = Integer.parseInt(split1[1]);
        int third1 = Integer.parseInt(split1[2]);

        String[] split2 = version2.split("\\.");
        int first2 = Integer.parseInt(split2[0]);
        int second2 = Integer.parseInt(split2[1]);
        int third2 = Integer.parseInt(split2[2]);

        if (first1 < first2)
        {
            return true;
        }

        if (first1 > first2)
        {
            return false;
        }

        if (second1 < second2)
        {
            return true;
        }

        if (second1 > second2)
        {
            return false;
        }

        if (third1 < third2)
        {
            return true;
        }

        if (third1 > third2)
        {
            return false;
        }

        return false;
    }
}
package com.creatorskit.swing;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class StringHandler
{
    public static String cleanString(String string)
    {
        return string.replaceAll("\\P{Print}", "?");
    }
}

package com.creatorskit.swing;

import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;

/* This work is hereby released into the Public Domain.
 * To view a copy of the public domain dedication, visit
 * http://creativecommons.org/licenses/publicdomain/
 * Code created by Laksitha Ranasingha, see: https://stackoverflow.com/questions/16418925/using-jcombobox-as-a-search
 */
public class AutoCompletion extends PlainDocument
{
    JComboBox comboBox;
    ComboBoxModel model;
    JTextComponent editor;
    // flag to indicate if setSelectedItem has been called
    // subsequent calls to remove/insertString should be ignored
    boolean selecting = false;
    boolean hidePopupOnFocusLoss;
    boolean hitBackspace = false;
    boolean hitBackspaceOnSelection;

    KeyListener editorKeyListener;
    FocusListener editorFocusListener;

    public AutoCompletion(final JComboBox comboBox)
    {
        this.comboBox = comboBox;
        model = comboBox.getModel();
        comboBox.addActionListener(e ->
        {
            if (!selecting) highlightCompletedText(0);
        });

        comboBox.addPropertyChangeListener(e ->
        {
            if (e.getPropertyName().equals("editor")) configureEditor((ComboBoxEditor) e.getNewValue());
            if (e.getPropertyName().equals("model")) model = (ComboBoxModel) e.getNewValue();
        });

        editorKeyListener = new KeyAdapter()
        {
            public void keyPressed(KeyEvent e)
            {
                if (comboBox.isDisplayable()) comboBox.setPopupVisible(true);
                hitBackspace=false;

                switch (e.getKeyCode())
                {
                    // determine if the pressed key is backspace (needed by the remove method)
                    case KeyEvent.VK_BACK_SPACE : hitBackspace=true;
                        hitBackspaceOnSelection=editor.getSelectionStart()!=editor.getSelectionEnd();
                        break;
                    // ignore delete key
                    case KeyEvent.VK_DELETE : e.consume();
                        comboBox.getToolkit().beep();
                        break;
                }
            }
        };

        // Bug 5100422 on Java 1.5: Editable JComboBox won't hide popup when tabbing out
        hidePopupOnFocusLoss=System.getProperty("java.version").startsWith("1.5");

        // Highlight whole text when gaining focus
        editorFocusListener = new FocusAdapter()
        {
            public void focusGained(FocusEvent e)
            {
                highlightCompletedText(0);
            }

            public void focusLost(FocusEvent e)
            {
                // Workaround for Bug 5100422 - Hide Popup on focus loss
                if (hidePopupOnFocusLoss) comboBox.setPopupVisible(false);
            }
        };

        configureEditor(comboBox.getEditor());

        // Handle initially selected object
        Object selected = comboBox.getSelectedItem();
        if (selected!=null) setText(selected.toString());
        highlightCompletedText(0);
    }

    public static void enable(JComboBox comboBox)
    {
        // has to be editable
        comboBox.setEditable(true);
        // change the editor's document
        new AutoCompletion(comboBox);
    }

    void configureEditor(ComboBoxEditor newEditor)
    {
        if (editor != null)
        {
            editor.removeKeyListener(editorKeyListener);
            editor.removeFocusListener(editorFocusListener);
        }

        if (newEditor != null)
        {
            editor = (JTextComponent) newEditor.getEditorComponent();
            editor.addKeyListener(editorKeyListener);
            editor.addFocusListener(editorFocusListener);
            editor.setDocument(this);
        }
    }

    public void remove(int offs, int len) throws BadLocationException
    {
        // return immediately when selecting an item
        if (selecting) return;
        if (hitBackspace)
        {
            // user hit backspace => move the selection backwards
            // old item keeps being selected
            if (offs>0)
            {
                if (hitBackspaceOnSelection) offs--;
            }
            else
            {
                // User hit backspace with the cursor positioned on the start => beep
                comboBox.getToolkit().beep(); // when available use: UIManager.getLookAndFeel().provideErrorFeedback(comboBox);
            }

            highlightCompletedText(offs);
        }
        else
        {
            super.remove(offs, len);
        }
    }

    public void insertString(int offs, String str, AttributeSet a) throws BadLocationException
    {
        // return immediately when selecting an item
        if (selecting) return;
        // insert the string into the document
        super.insertString(offs, str, a);

        // lookup and select a matching item
        Object item = lookupItem(getText(0, getLength()));
        if (item != null)
        {
            setSelectedItem(item);
        }
        else
        {
            // keep old item selected if there is no match
            item = comboBox.getSelectedItem();
            // imitate no insert (later on offs will be incremented by str.length(): selection won't move forward)
            offs = offs-str.length();
            // provide feedback to the user that his input has been received but can not be accepted
            comboBox.getToolkit().beep(); // when available use: UIManager.getLookAndFeel().provideErrorFeedback(comboBox);
        }

        setText(item.toString());
        // select the completed part
        highlightCompletedText(offs+str.length());
    }

    private void setText(String text)
    {
        try
        {
            // remove all text and insert the completed string
            super.remove(0, getLength());
            super.insertString(0, text, null);
        }
        catch (BadLocationException e)
        {
            throw new RuntimeException(e.toString());
        }
    }

    private void highlightCompletedText(int start)
    {
        editor.setCaretPosition(getLength());
        editor.moveCaretPosition(start);
    }

    private void setSelectedItem(Object item)
    {
        selecting = true;
        model.setSelectedItem(item);
        selecting = false;
    }

    private Object lookupItem(String pattern)
    {
        Object selectedItem = model.getSelectedItem();
        // only search for a different item if the currently selected does not match
        if (selectedItem != null && startsWithIgnoreCase(selectedItem.toString(), pattern))
        {
            return selectedItem;
        }
        else
        {
            // iterate over all items
            for (int i = 0, n = model.getSize(); i < n; i++)
            {
                Object currentItem = model.getElementAt(i);
                // current item starts with the pattern?
                if (currentItem != null && startsWithIgnoreCase(currentItem.toString(), pattern))
                {
                    return currentItem;
                }
            }
        }
        // no item starts with the pattern => return null
        return null;
    }

    // checks if str1 starts with str2 - ignores case
    private boolean startsWithIgnoreCase(String str1, String str2)
    {
        return str1.toUpperCase().startsWith(str2.toUpperCase());
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsPlugin;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicSpinnerUI;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class GroupPanel extends JPanel
{
    private final CreatorsPlugin plugin;
    private Client client;
    private final ClientThread clientThread;
    private final GridBagConstraints c = new GridBagConstraints();

    private final BufferedImage ICON = ImageUtil.loadImageResource(getClass(), "/panelicon.png");
    private final BufferedImage TRANSLATE = ImageUtil.loadImageResource(getClass(), "/Translate.png");
    private final BufferedImage ROTATE = ImageUtil.loadImageResource(getClass(), "/Rotate.png");
    private final BufferedImage TRANSLATE_SUBTILE = ImageUtil.loadImageResource(getClass(), "/Translate subtile.png");
    private final BufferedImage SCALE = ImageUtil.loadImageResource(getClass(), "/Scale.png");
    private final Dimension SPINNER_DIMENSION = new Dimension(35, 25);
    private final JSpinner groupSpinner = new JSpinner();

    @Inject
    public GroupPanel(@Nullable Client client, CreatorsPlugin plugin, ClientThread clientThread)
    {
        this.plugin = plugin;
        this.clientThread = clientThread;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        c.gridheight = 1;
        JLabel title = new JLabel("Group Transformer");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setHorizontalAlignment(SwingConstants.CENTER);
        add(title, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        c.gridheight = 1;
        JLabel groupLabel = new JLabel("Group:");
        groupLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        add(groupLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        c.gridwidth = 1;
        c.gridheight = 1;
        SpinnerNumberModel spinnerNumberModel = new SpinnerNumberModel(1, 1, 99, 1);
        groupSpinner.setModel(spinnerNumberModel);
        groupSpinner.setBackground(ModelAnvil.getBorderColour(6));
        groupSpinner.setToolTipText("Pick the Group number to Group Transform");
        add(groupSpinner, c);
        groupSpinner.addChangeListener(e ->
                groupSpinner.setBackground(ModelAnvil.getBorderColour((int) groupSpinner.getValue() * 6)));

        JPanel adjustPanel = createAdjustPanel();
        c.gridx = 0;
        c.gridy = 2;
        c.gridwidth = 1;
        c.gridheight = 1;
        add(adjustPanel, c);

        JPanel setPanel = createSetPanel();
        c.gridx = 1;
        c.gridy = 2;
        c.gridwidth = 1;
        c.gridheight = 1;
        add(setPanel, c);

        revalidate();
        repaint();
    }

    public JPanel createAdjustPanel()
    {
        JPanel adjustPanel = new JPanel();
        adjustPanel.setLayout(new GridBagLayout());
        adjustPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        adjustPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JComboBox<String> rotateBox = new JComboBox<>();
        JButton invertButton = new JButton("Invert");

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 4, 2, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 10;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel setLabel = new JLabel("Adjuster");
        setLabel.setToolTipText("Functions here adjust all values of the given Group BY the value entered");
        setLabel.setHorizontalAlignment(SwingConstants.CENTER);
        adjustPanel.add(setLabel, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        adjustPanel.add(tileLabel, c);

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        adjustPanel.add(translateLabel, c);

        c.gridx = 2;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        adjustPanel.add(scaleLabel, c);

        c.gridx = 2;
        c.gridy = 7;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        adjustPanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(tilePanel, c);

        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        tilePanel.add(xTileSpinner);
        xTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xTileSpinner, this, GroupOperation.X_TILE_SPINNER);
            }
        });

        yTileSpinner.setToolTipText("N/S");
        tilePanel.add(yTileSpinner);
        yTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(yTileSpinner, this, GroupOperation.Y_TILE_SPINNER);
            }
        });

        zTileSpinner.setToolTipText("U/D");
        tilePanel.add(zTileSpinner);
        zTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zTileSpinner, this, GroupOperation.Z_TILE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(translatePanel, c);

        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        translatePanel.add(xSpinner);
        xSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xSpinner, this, GroupOperation.X_SPINNER);
            }
        });

        ySpinner.setToolTipText("N/S");
        translatePanel.add(ySpinner);
        ySpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(ySpinner, this, GroupOperation.Y_SPINNER);
            }
        });

        zSpinner.setToolTipText("U/D");
        translatePanel.add(zSpinner);
        zSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zSpinner, this, GroupOperation.Z_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 6;
        c.gridwidth = 2;
        c.weightx = 0;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(scalePanel, c);

        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        scalePanel.add(xScaleSpinner);
        xScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xScaleSpinner, this, GroupOperation.X_SCALE_SPINNER);
            }
        });

        yScaleSpinner.setToolTipText("N/S");
        scalePanel.add(yScaleSpinner);
        yScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(yScaleSpinner, this, GroupOperation.Y_SCALE_SPINNER);
            }
        });

        zScaleSpinner.setToolTipText("U/D");
        scalePanel.add(zScaleSpinner);
        zScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zScaleSpinner, this, GroupOperation.Z_SCALE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 8;
        c.gridwidth = 2;
        adjustPanel.add(rotateBox, c);
        rotateBox.addItem("Rot");
        rotateBox.addItem("90");
        rotateBox.addItem("180");
        rotateBox.addItem("270");
        rotateBox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                adjustValueComboBox(rotateBox, e, this);
            }
        });

        c.gridx = 2;
        c.gridy = 9;
        c.gridwidth = 2;
        adjustPanel.add(invertButton, c);
        invertButton.addActionListener(e -> adjustValueInvert());

        JFrame swapperFrame = new JFrame("Colour Swapper");
        swapperFrame.setVisible(false);
        swapperFrame.setEnabled(false);
        swapperFrame.setIconImage(ICON);
        swapperFrame.setLayout(new FlowLayout());

        JPanel gridMenu = new JPanel();
        gridMenu.setLayout(new GridLayout(0, 2, 2, 2));
        swapperFrame.add(gridMenu);

        adjustPanel.setEnabled(true);
        adjustPanel.setVisible(true);
        return adjustPanel;
    }

    private void adjustValueSpinner(JSpinner spinner, ChangeListener changeListener, GroupOperation operation)
    {
        int value = (int) spinner.getValue();

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() != groupSpinner.getValue())
                continue;

            JSpinner s;
            switch (operation)
            {
                case X_TILE_SPINNER:
                    s = complexPanel.getXTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_TILE_SPINNER:
                    s = complexPanel.getYTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_TILE_SPINNER:
                    s = complexPanel.getZTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case X_SPINNER:
                    s = complexPanel.getXSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_SPINNER:
                    s = complexPanel.getYSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_SPINNER:
                    s = complexPanel.getZSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case X_SCALE_SPINNER:
                    s = complexPanel.getXScaleSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_SCALE_SPINNER:
                    s = complexPanel.getYScaleSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_SCALE_SPINNER:
                    s = complexPanel.getZScaleSpinner();
                    s.setValue((int) s.getValue() + value);
            }
        }

        spinner.removeChangeListener(changeListener);
        spinner.setValue(0);
        spinner.addChangeListener(changeListener);
    }

    private void adjustValueComboBox(JComboBox<String> comboBox, ItemEvent e, ItemListener itemListener)
    {
        if (e.getItem() == "Rot")
            return;

        int change = Integer.parseInt((String) e.getItem());

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox check90 = complexPanel.getCheck90();
                JCheckBox check180 = complexPanel.getCheck180();
                JCheckBox check270 = complexPanel.getCheck270();

                int currentRotation = 0;
                if (check90.isSelected())
                    currentRotation = 90;

                if (check180.isSelected())
                    currentRotation = 180;

                if (check270.isSelected())
                    currentRotation = 270;

                switch (currentRotation + change)
                {
                    case 90:
                    case 450:
                        complexPanel.getCheck90().setSelected(true);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 180:
                    case 540:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(true);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 270:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(true);
                        break;
                    case 360:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                }
            }
        }

        comboBox.removeItemListener(itemListener);
        comboBox.setSelectedItem("Rot");
        comboBox.addItemListener(itemListener);
    }

    private void adjustValueInvert()
    {
        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox invertFaces = complexPanel.getInvertFaces();
                invertFaces.setSelected(!invertFaces.isSelected());
            }
        }
    }

    public JPanel createSetPanel()
    {
        JPanel setPanel = new JPanel();
        setPanel.setLayout(new GridBagLayout());
        setPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        setPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JTextField colourNewField = new JTextField();
        JTextField colourOldField = new JTextField();
        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JComboBox<String> rotateBox = new JComboBox<>();
        JButton invertButton = new JButton("Inv On");

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 4, 2, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 10;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel setLabel = new JLabel("Setter");
        setLabel.setToolTipText("Functions here set all values of the given Group TO the value entered");
        setLabel.setHorizontalAlignment(SwingConstants.CENTER);
        setPanel.add(setLabel, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        setPanel.add(tileLabel, c);

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        setPanel.add(translateLabel, c);

        c.gridx = 2;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        setPanel.add(scaleLabel, c);

        c.gridx = 2;
        c.gridy = 7;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        setPanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(tilePanel, c);

        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        xTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(xTileSpinner);
        xTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xTileSpinner, this, GroupOperation.X_TILE_SPINNER);
            }
        });

        yTileSpinner.setToolTipText("N/S");
        yTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(yTileSpinner);
        yTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(yTileSpinner, this, GroupOperation.Y_TILE_SPINNER);
            }
        });

        zTileSpinner.setToolTipText("U/D");
        zTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(zTileSpinner);
        zTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zTileSpinner, this, GroupOperation.Z_TILE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(translatePanel, c);

        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        xSpinner.setUI(createEmptySpinner());
        translatePanel.add(xSpinner);
        xSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xSpinner, this, GroupOperation.X_SPINNER);
            }
        });

        ySpinner.setToolTipText("N/S");
        ySpinner.setUI(createEmptySpinner());
        translatePanel.add(ySpinner);
        ySpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(ySpinner, this, GroupOperation.Y_SPINNER);
            }
        });

        zSpinner.setToolTipText("U/D");
        zSpinner.setUI(createEmptySpinner());
        translatePanel.add(zSpinner);
        zSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zSpinner, this, GroupOperation.Z_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(scalePanel, c);

        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        xScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(xScaleSpinner);
        xScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xScaleSpinner, this, GroupOperation.X_SCALE_SPINNER);
            }
        });

        yScaleSpinner.setToolTipText("N/S");
        yScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(yScaleSpinner);
        yScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(yScaleSpinner, this, GroupOperation.Y_SCALE_SPINNER);
            }
        });

        zScaleSpinner.setToolTipText("U/D");
        zScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(zScaleSpinner);
        zScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zScaleSpinner, this, GroupOperation.Z_SCALE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 8;
        c.gridwidth = 2;
        setPanel.add(rotateBox, c);
        rotateBox.addItem("Rot");
        rotateBox.addItem("0");
        rotateBox.addItem("90");
        rotateBox.addItem("180");
        rotateBox.addItem("270");
        rotateBox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                setValueComboBox(rotateBox, e, this);
            }
        });

        c.gridx = 2;
        c.gridy = 9;
        c.gridwidth = 2;
        setPanel.add(invertButton, c);
        invertButton.addActionListener(e -> setValueInvert(invertButton));

        HashMap<Short, Short> colourMap = new HashMap<>();

        colourNewField.setVisible(false);
        setPanel.add(colourNewField);

        colourOldField.setVisible(false);
        setPanel.add(colourOldField);

        JFrame swapperFrame = new JFrame("Colour Swapper");
        swapperFrame.setVisible(false);
        swapperFrame.setEnabled(false);
        swapperFrame.setIconImage(ICON);
        swapperFrame.setLayout(new FlowLayout());

        JPanel gridMenu = new JPanel();
        gridMenu.setLayout(new GridLayout(0, 2, 2, 2));
        swapperFrame.add(gridMenu);

        setPanel.setEnabled(true);
        setPanel.setVisible(true);
        return setPanel;
    }

    private void setValueSpinner(JSpinner spinner, ChangeListener changeListener, GroupOperation operation)
    {
        int value = (int) spinner.getValue();

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() != groupSpinner.getValue())
                continue;

            switch (operation)
            {
                case X_TILE_SPINNER:
                    complexPanel.getXTileSpinner().setValue(value);
                    break;
                case Y_TILE_SPINNER:
                    complexPanel.getYTileSpinner().setValue(value);
                    break;
                case Z_TILE_SPINNER:
                    complexPanel.getZTileSpinner().setValue(value);
                    break;
                case X_SPINNER:
                    complexPanel.getXSpinner().setValue(value);
                    break;
                case Y_SPINNER:
                    complexPanel.getYSpinner().setValue(value);
                    break;
                case Z_SPINNER:
                    complexPanel.getZSpinner().setValue(value);
                    break;
                case X_SCALE_SPINNER:
                    complexPanel.getXScaleSpinner().setValue(value);
                    break;
                case Y_SCALE_SPINNER:
                    complexPanel.getYScaleSpinner().setValue(value);
                    break;
                case Z_SCALE_SPINNER:
                    complexPanel.getZScaleSpinner().setValue(value);
            }
        }
    }

    private void setValueComboBox(JComboBox<String> comboBox, ItemEvent e, ItemListener itemListener)
    {
        if (e.getItem() == "Rot")
            return;

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                switch (Integer.parseInt((String) e.getItem()))
                {
                    case 0:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 90:
                        complexPanel.getCheck90().setSelected(true);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 180:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(true);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 270:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(true);
                }
            }
        }

        comboBox.removeItemListener(itemListener);
        comboBox.setSelectedItem("Rot");
        comboBox.addItemListener(itemListener);
    }

    private void setValueInvert(JButton button)
    {
        boolean invert = button.getText().equals("Inv On");
        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox invertFaces = complexPanel.getInvertFaces();
                invertFaces.setSelected(invert);
            }
        }

        button.setText(invert ? "Inv Off" : "Inv On");
    }

    private JPanel createXYZPanel()
    {
        JPanel xyzPanel = new JPanel();
        xyzPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        xyzPanel.setLayout(new GridLayout(3, 0));

        JLabel xLabel = new JLabel("x:");
        xLabel.setToolTipText("East/West");
        xLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(xLabel);

        JLabel yLabel = new JLabel("y:");
        yLabel.setToolTipText("North/South");
        yLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(yLabel);

        JLabel zLabel = new JLabel("z:");
        zLabel.setToolTipText("Up/Down");
        zLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(zLabel);

        return xyzPanel;
    }

    private BasicSpinnerUI createEmptySpinner() {
        return new BasicSpinnerUI() {
            protected Component createNextButton() {
                return null;
            }

            protected Component createPreviousButton() {
                return null;
            }
        };
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.*;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseWheelEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Enumeration;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.*;

@Getter
public class ManagerTree extends JTree
{
    private final ToolBoxFrame toolBox;
    private final CreatorsPlugin plugin;
    private final JPanel objectHolder;
    private final DefaultMutableTreeNode rootNode;
    private final DefaultMutableTreeNode sidePanelNode;
    private final DefaultMutableTreeNode managerNode;
    private final ManagerTreeModel treeModel;
    private final GridBagConstraints c = new GridBagConstraints();
    private Folder[] selectedFolders = new Folder[0];
    private final int ROW_HEIGHT = 24;

    private final BufferedImage FOLDER_OPEN = ImageUtil.loadImageResource(getClass(), "/Folder_Open.png");
    private final BufferedImage FOLDER_CLOSED = ImageUtil.loadImageResource(getClass(), "/Folder_Closed.png");
    private final BufferedImage OBJECT = ImageUtil.loadImageResource(getClass(), "/Object.png");

    @Inject
    public ManagerTree(ToolBoxFrame toolBox, CreatorsPlugin plugin, JPanel objectHolder, DefaultMutableTreeNode rootNode, DefaultMutableTreeNode sidePanelNode, DefaultMutableTreeNode managerNode)
    {
        this.toolBox = toolBox;
        this.plugin = plugin;
        this.objectHolder = objectHolder;
        this.rootNode = rootNode;
        this.sidePanelNode = sidePanelNode;
        this.managerNode = managerNode;

        setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));

        rootNode.add(sidePanelNode);
        rootNode.add(managerNode);

        treeModel = new ManagerTreeModel(rootNode, sidePanelNode, managerNode, plugin);
        setModel(treeModel);
        expandRow(0);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setEditable(true);
        setRowHeight(ROW_HEIGHT);
        getSelectionModel().setSelectionMode(TreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
        setShowsRootHandles(true);
        setRootVisible(false);
        setDragEnabled(true);
        setDropMode(DropMode.ON_OR_INSERT);
        setTransferHandler(new ManagerTreeTransferHandler(plugin, toolBox));
        addTreeSelectionListener(new MyTreeSelectionListener());
        addTreeExpansionListener(new TreeExpansionListener()
        {
            @Override
            public void treeExpanded(TreeExpansionEvent event)
            {
                updateTreeSelectionIndex();
            }

            @Override
            public void treeCollapsed(TreeExpansionEvent event)
            {
                updateTreeSelectionIndex();
            }
        });

        DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
        renderer.setOpenIcon(new ImageIcon(FOLDER_OPEN));
        renderer.setClosedIcon(new ImageIcon(FOLDER_CLOSED));
        renderer.setLeafIcon(new ImageIcon(OBJECT));
        renderer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        setCellRenderer(renderer);

        setMouseListeners();
    }

    public DefaultMutableTreeNode getParentFolderNode(ParentPanel parentPanel, boolean switching)
    {
        DefaultMutableTreeNode defaultNode = parentPanel == ParentPanel.MANAGER ? managerNode : sidePanelNode;
        DefaultMutableTreeNode parentFolderNode;
        TreePath parentPath = getSelectionPath();

        if (parentPath == null)
        {
            return defaultNode;
        }

        parentFolderNode = (DefaultMutableTreeNode) (parentPath.getLastPathComponent());
        if (parentFolderNode.getUserObject() instanceof Character)
        {
            Character character = (Character) parentFolderNode.getUserObject();
            parentFolderNode = character.getParentManagerNode();
        }

        if (parentFolderNode == null)
        {
            parentFolderNode = defaultNode;
        }

        if (switching)
        {
            if (parentPanel == ParentPanel.SIDE_PANEL && !treeContainsSidePanel(parentFolderNode))
            {
                parentFolderNode = sidePanelNode;
            }

            if (parentPanel == ParentPanel.MANAGER && treeContainsSidePanel(parentFolderNode))
            {
                parentFolderNode = managerNode;
            }
        }

        return parentFolderNode;
    }

    public DefaultMutableTreeNode addFolderNode(String name, ParentPanel parentPanel)
    {
        return addFolderNode(getParentFolderNode(parentPanel, false), name, true);
    }

    public DefaultMutableTreeNode addFolderNode(DefaultMutableTreeNode parent, String name)
    {
        return addFolderNode(parent, name, false);
    }

    public DefaultMutableTreeNode addFolderNode(DefaultMutableTreeNode managerParent, String name, boolean shouldBeVisible)
    {
        if (managerParent == rootNode)
        {
            managerParent = managerNode;
        }

        Folder folder = new Folder(name, FolderType.STANDARD, null, managerParent);
        DefaultMutableTreeNode linkedManagerNode = new DefaultMutableTreeNode(folder);
        folder.setLinkedManagerNode(linkedManagerNode);

        treeModel.insertNodeInto(linkedManagerNode, managerParent, managerParent.getChildCount());

        if (shouldBeVisible)
            scrollPathToVisible(new TreePath(linkedManagerNode.getPath()));

        return linkedManagerNode;
    }

    /**
     * Adds a character node to the currently selected ManagerTree node. Creates a linked ManagerTree node and remembers the selected Parent node
     * @param character the character to add to the selected node
     * @param parentPanel the ParentPanel to which the character will be added (SidePanel or ManagerPanel)
     * @param shouldBeVisible visibility
     * @return the linked ManagerTree node
     */
    public DefaultMutableTreeNode addCharacterNode(Character character, ParentPanel parentPanel, boolean shouldBeVisible, boolean switching)
    {
        return addCharacterNode(getParentFolderNode(parentPanel, switching), character, parentPanel, shouldBeVisible);
    }

    // Adds the character to a previously indicated parent
    public DefaultMutableTreeNode addCharacterNode(DefaultMutableTreeNode parent, Character character, ParentPanel parentPanel)
    {
        return addCharacterNode(parent, character, parentPanel, false);
    }

    /**
     * Adds a character node to the indicated ManagerTree node. Creates a linked ManagerTree node and remembers the indicated Parent node
     * @param managerParent the parent node in the ManagerTree to which to attach the new node
     * @param character the character to add to the selected node
     * @param parentPanel the ParentPanel to which the character will be added (SidePanel or ManagerPanel)
     * @param shouldBeVisible visibility
     * @return the linked ManagerTree node
     */
    public DefaultMutableTreeNode addCharacterNode(DefaultMutableTreeNode managerParent, Character character, ParentPanel parentPanel, boolean shouldBeVisible)
    {
        if (managerParent == rootNode)
        {
            managerParent = parentPanel == ParentPanel.MANAGER ? managerNode : sidePanelNode;
        }

        if (managerParent == managerNode && parentPanel == ParentPanel.SIDE_PANEL)
        {
            managerParent = sidePanelNode;
        }

        if (managerParent == sidePanelNode && parentPanel == ParentPanel.MANAGER)
        {
            managerParent = managerNode;
        }

        DefaultMutableTreeNode linkedManagerNode = new DefaultMutableTreeNode(character);
        character.setParentPanel(parentPanel);
        character.setLinkedManagerNode(linkedManagerNode);
        character.setParentManagerNode(managerParent);

        treeModel.insertNodeInto(linkedManagerNode, managerParent, managerParent.getChildCount());

        if (shouldBeVisible)
            scrollPathToVisible(new TreePath(linkedManagerNode.getPath()));

        return linkedManagerNode;
    }

    public void removeAllNodes()
    {
        TreePath[] treePaths = new TreePath[]{new TreePath(rootNode.getPath())};
        removeNodes(treePaths);
    }

    public void removeNodes(TreePath[] paths)
    {
        ArrayList<DefaultMutableTreeNode> charactersToRemove = new ArrayList<>();
        ArrayList<DefaultMutableTreeNode> foldersToRemove = new ArrayList<>();

        for (TreePath path : paths)
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getUserObject() instanceof Character)
            {
                charactersToRemove.add(node);
                continue;
            }

            Folder folder = (Folder) node.getUserObject();
            {
                FolderType type = folder.getFolderType();
                if (type == FolderType.STANDARD)
                {
                    foldersToRemove.add(node);
                }
            }

            getNodeChildren(node, charactersToRemove, foldersToRemove);
        }

        if (foldersToRemove.isEmpty() && charactersToRemove.isEmpty())
        {
            return;
        }

        if (foldersToRemove.size() + charactersToRemove.size() > 1)
        {
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete all the selected Folders and their Objects?");
            if (result != JOptionPane.YES_OPTION)
            {
                return;
            }
        }

        Character[] characters = new Character[charactersToRemove.size()];
        for (int i = 0; i < characters.length; i++)
        {
            Character character = (Character) charactersToRemove.get(i).getUserObject();
            characters[i] = character;
        }

        Thread thread = new Thread(() ->
        {
            plugin.getCreatorsPanel().deleteCharacters(characters);
            for (DefaultMutableTreeNode node : foldersToRemove)
            {
                removeFolderNode(node);
            }
        });
        thread.start();
    }

    public void removeCharacterNode(Character child)
    {
        treeModel.removeNodeFromParent(child.getLinkedManagerNode());
    }

    public void removeFolderNode(DefaultMutableTreeNode folderNode)
    {
        treeModel.removeNodeFromParent(folderNode);
    }

    public void getNodeChildren(DefaultMutableTreeNode parent, ArrayList<DefaultMutableTreeNode> panelsToRemove, ArrayList<DefaultMutableTreeNode> foldersToRemove)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                panelsToRemove.add(node);
                continue;
            }

            Folder folder = (Folder) node.getUserObject();
            {
                FolderType type = folder.getFolderType();
                if (type == FolderType.STANDARD)
                {
                    foldersToRemove.add(node);
                }
            }

            if (!node.isLeaf())
                getNodeChildren(node, panelsToRemove, foldersToRemove);
        }
    }

    public void getSidePanelChildren(ArrayList<Character> characters)
    {
        getCharacterNodeChildren(sidePanelNode, characters);
    }

    public void getCharacterNodeChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                characters.add((Character) node.getUserObject());
                continue;
            }

            if (!node.isLeaf())
                getCharacterNodeChildren(node, characters);
        }
    }

    public void getAllNodes(DefaultMutableTreeNode parent, ArrayList<DefaultMutableTreeNode> nodes)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            nodes.add(node);
            if (!node.isLeaf())
                getAllNodes(node, nodes);
        }
    }

    public void getObjectPanelChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        if (parent.getUserObject() instanceof Character)
        {
            characters.add((Character) parent.getUserObject());
            return;
        }

        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            Object object = node.getUserObject();
            if (object instanceof Character)
            {
                Character character = (Character) object;
                if (!characters.contains(character))
                    characters.add(character);
            }

            if (!node.isLeaf())
                getObjectPanelChildren(node, characters);
        }
    }

    class MyTreeSelectionListener implements TreeSelectionListener
    {
        @Override
        public void valueChanged(TreeSelectionEvent event)
        {
            TreePath[] treePaths = getSelectionPaths();
            if (treePaths == null)
            {
                return;
            }

            updateTreeSelectionIndex();

            JPanel objectHolder = toolBox.getManagerPanel().getObjectHolder();

            boolean containsSidePanel = false;
            for (TreePath treePath : treePaths)
            {
                if (treePath.getLastPathComponent() == rootNode)
                {
                    objectHolder.removeAll();
                    objectHolder.revalidate();
                    return;
                }

                if (treeContainsSidePanel((TreeNode) treePath.getLastPathComponent()))
                {
                    containsSidePanel = true;
                }
            }

            ArrayList<Character> panelsToAdd = new ArrayList<>();
            Folder[] folders = new Folder[0];

            boolean folderSelected = false;
            String folderName = "";
            for (TreePath treePath : treePaths)
            {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath.getLastPathComponent();
                if (node.getUserObject() instanceof Folder)
                {
                    Folder folder = (Folder) node.getUserObject();
                    if (folderName.isEmpty())
                    {
                        folderName = folder.getName();
                    }

                    folderSelected = true;
                    folders = ArrayUtils.add(folders, folder);
                }
            }

            if (folderSelected)
            {
                for (TreePath treePath : treePaths)
                {
                    getObjectPanelChildren((DefaultMutableTreeNode) treePath.getLastPathComponent(), panelsToAdd);
                }
            }
            else
            {
                TreePath parentPath = treePaths[0].getParentPath();
                if (parentPath == null)
                    return;

                DefaultMutableTreeNode folderNode = (DefaultMutableTreeNode) parentPath.getLastPathComponent();
                Folder folder = (Folder) folderNode.getUserObject();
                folderName = folder.getName();
                getObjectPanelChildren(folderNode, panelsToAdd);
                folders = ArrayUtils.add(folders, folder);
            }

            selectedFolders = folders;

            toolBox.getManagerPanel().getObjectLabel().setText("Current Folder: " + folderName);
            resetObjectHolder(panelsToAdd, containsSidePanel);
        }
    }

    public boolean treeContainsSidePanel(TreeNode node)
    {
        if (node == sidePanelNode)
        {
            return true;
        }

        TreeNode parent = node.getParent();
        if (parent == null || parent == managerNode || parent == rootNode)
        {
            return false;
        }

        if (parent == sidePanelNode)
        {
            return true;
        }

        return treeContainsSidePanel(parent);
    }

    public Character[] getShownCharacters()
    {
        Character[] characters = new Character[0];
        JPanel objectHolder = toolBox.getManagerPanel().getObjectHolder();
        for (Component component : objectHolder.getComponents())
        {
            if (component instanceof ObjectPanel)
            {
                ObjectPanel objectPanel = (ObjectPanel) component;
                characters = ArrayUtils.add(characters, objectPanel.getCharacter());
            }
        }

        return characters;
    }

    public void resetObjectHolder()
    {
        ArrayList<Character> list = new ArrayList<>();
        for (Folder folder : selectedFolders)
        {
            DefaultMutableTreeNode node = folder.getLinkedManagerNode();
            getCharacterNodeChildren(node, list);
        }

        ObjectPanel[] objectPanels = new ObjectPanel[0];
        for (Character character : list)
        {
            if (character.getParentPanel() == ParentPanel.MANAGER)
            {
                objectPanels = ArrayUtils.add(objectPanels, character.getObjectPanel());
            }
        }

        resetObjectHolder(objectPanels, false);
    }

    public void resetObjectHolder(ArrayList<Character> charactersToAdd, boolean sidePanel)
    {
        resetObjectHolder(charactersToAdd.toArray(new Character[charactersToAdd.size()]), sidePanel);
    }

    public void resetObjectHolder(Character[] charactersToAdd, boolean sidePanel)
    {
        ObjectPanel[] panelsToAdd = new ObjectPanel[charactersToAdd.length];

        for (int i = 0; i < charactersToAdd.length; i++)
        {
            panelsToAdd[i] = charactersToAdd[i].getObjectPanel();
        }
        resetObjectHolder(panelsToAdd, sidePanel);
    }

    public void resetObjectHolder(ObjectPanel[] panelsToAdd, boolean sidePanel)
    {
        JPanel[] programPanels = new JPanel[0];

        for (ObjectPanel objectPanel : panelsToAdd)
            programPanels = ArrayUtils.add(programPanels, objectPanel.getProgramPanel());

        resetProgramHolder(programPanels);

        if (sidePanel)
        {
            objectHolder.removeAll();
            objectHolder.revalidate();
            return;
        }

        JPanel managerHolder = toolBox.getManagerPanel().getObjectHolder();
        managerHolder.removeAll();

        for (ObjectPanel objectPanel : panelsToAdd)
        {
            managerHolder.add(objectPanel);
        }

        toolBox.getManagerPanel().revalidate();
        toolBox.getManagerPanel().repaint();
    }

    public void resetProgramHolder(JPanel[] panelsToAdd)
    {
        ProgrammerPanel programmerPanel = plugin.getCreatorsPanel().getProgrammerPanel();
        GridBagConstraints cManager = programmerPanel.getC();
        cManager.fill = GridBagConstraints.NONE;
        cManager.insets = new Insets(2, 2, 2, 2);
        cManager.gridx = 0;
        cManager.gridy = 0;
        cManager.weightx = 0;
        cManager.weighty = 0;
        cManager.gridheight = 1;
        cManager.gridwidth = 1;
        cManager.anchor = GridBagConstraints.FIRST_LINE_START;

        JPanel programHolder = programmerPanel.getManagerProgramHolder();
        programHolder.removeAll();
        int rows = panelsToAdd.length / 5;

        for (int i = 0; i < panelsToAdd.length; i++)
        {
            JPanel panel = panelsToAdd[i];

            cManager.weightx = cManager.gridx == 4 ? 1 : 0;
            if (cManager.gridx == panelsToAdd.length - 1)
                cManager.weightx = 1;

            cManager.weighty = cManager.gridy == rows ? 1 : 0;
            if (i == panelsToAdd.length - 1)
                cManager.weighty = 1;

            programHolder.add(panel, cManager);
            cManager.gridx++;
            if (cManager.gridx > 4)
            {
                cManager.gridx = 0;
                cManager.gridy++;
            }
        }

        programmerPanel.revalidate();
        programmerPanel.repaint();
    }

    public void onPanelScrolled(int scroll)
    {
        toolBox.getTimeSheetPanel().getSummarySheet().onVerticalScrollEvent(scroll);
    }

    private void updateTreeSelectionIndex()
    {
        int[] rows = getSelectionRows();
        {
            if (rows == null || rows.length == 0)
            {
                return;
            }
            toolBox.getTimeSheetPanel().getSummarySheet().setSelectedIndex(rows[0]);
        }
    }

    private void setMouseListeners()
    {
        addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                super.mouseWheelMoved(e);
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    int currentRow = getMinSelectionRow();
                    if (currentRow == -1)
                    {
                        setSelectionRow(0);
                        return;
                    }

                    TreePath path = null;
                    int direction = e.getWheelRotation();
                    if (direction > 0)
                    {
                        while (path == null)
                        {
                            currentRow++;
                            if (currentRow >= getRowCount())
                            {
                                currentRow = 0;
                            }

                            path = getPathForRow(currentRow);
                        }
                    }

                    if (direction < 0)
                    {
                        while (path == null)
                        {
                            currentRow--;
                            if (currentRow < 0)
                            {
                                currentRow = getRowCount() - 1;
                            }

                            path = getPathForRow(currentRow);
                        }
                    }

                    if (path != null)
                    {
                        setSelectionPath(path);
                    }
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    toolBox.getTimeSheetPanel().scrollAttributePanel(e.getWheelRotation());
                }
            }
        });
    }
}


package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.Folder;
import com.creatorskit.swing.StringHandler;

import javax.inject.Inject;
import javax.swing.tree.*;

public class ManagerTreeModel extends DefaultTreeModel
{
    private final CreatorsPlugin plugin;
    private final DefaultMutableTreeNode sidePanelNode;
    private final DefaultMutableTreeNode managerNode;

    @Inject
    public ManagerTreeModel(TreeNode root, DefaultMutableTreeNode sidePanelNode, DefaultMutableTreeNode managerNode, CreatorsPlugin plugin)
    {
        super(root);
        this.plugin = plugin;
        this.sidePanelNode = sidePanelNode;
        this.managerNode = managerNode;
    }

    @Override
    public void valueForPathChanged(TreePath path, Object newValue)
    {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        if (node == root
        || node == sidePanelNode
        || node == managerNode)
        {
            return;
        }

        //Check if node being modified is a Folder
        if (node.getUserObject() instanceof Folder)
        {
            Folder folder = (Folder) node.getUserObject();
            String name = StringHandler.cleanString((String) newValue);
            folder.setName(name);
            node.setUserObject(folder);
            plugin.getCreatorsPanel().getToolBox().getManagerPanel().getObjectLabel().setText("Current Folder: " + name);
        }

        //Check if node being modified is an ObjectPanel
        if (node.getUserObject() instanceof Character)
        {
            Character character = (Character) node.getUserObject();
            String name = StringHandler.cleanString((String) newValue);
            character.setName(name);
            character.getNameField().setText(name);
            character.getProgram().getNameLabel().setText(name);
            node.setUserObject(character);
        }
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.swing.ParentPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.image.BufferedImage;

public class TreeScrollPane extends JScrollPane
{
    private final ManagerTree tree;
    private GridBagConstraints c = new GridBagConstraints();

    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage ADD = ImageUtil.loadImageResource(getClass(), "/Add.png");
    private final BufferedImage CLEAR = ImageUtil.loadImageResource(getClass(), "/Clear.png");

    public TreeScrollPane(ManagerTree tree)
    {
        this.tree = tree;

        JPanel folderHeader = setupFolderHeader();
        setColumnHeaderView(folderHeader);

        JScrollBar scrollBar = getVerticalScrollBar();
        scrollBar.addAdjustmentListener(e -> tree.onPanelScrolled(scrollBar.getValue()));
    }

    private JPanel setupFolderHeader()
    {
        Dimension buttonDimension = new Dimension(40, 18);

        JPanel folderHeader = new JPanel();
        folderHeader.setLayout(new GridBagLayout());
        folderHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
        folderHeader.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        JLabel folderLabel = new JLabel("Folders");
        folderLabel.setHorizontalAlignment(SwingConstants.CENTER);
        folderLabel.setVerticalAlignment(SwingConstants.CENTER);
        folderLabel.setFont(FontManager.getRunescapeBoldFont());
        folderHeader.add(folderLabel, c);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 0;
        JButton addFolderButton = new JButton(new ImageIcon(ADD));
        addFolderButton.setPreferredSize(buttonDimension);
        addFolderButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        addFolderButton.setToolTipText("Add a new Folder to the currently selected Folder");
        addFolderButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        addFolderButton.addActionListener(e ->
        {
            TreePath path = tree.getSelectionPath();
            DefaultMutableTreeNode folderNode;
            if (path == null)
            {
                folderNode = tree.addFolderNode("New Folder", ParentPanel.MANAGER);
            }
            else
            {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                ParentPanel parentPanel = tree.treeContainsSidePanel(node) ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
                folderNode = tree.addFolderNode("New Folder", parentPanel);
            }

            TreePath treePath = new TreePath(folderNode.getPath());
            int row = tree.getRowForPath(new TreePath(folderNode.getPath()));
            tree.expandRow(row);
            tree.setSelectionPath(treePath);
        });
        folderHeader.add(addFolderButton, c);

        c.gridx = 2;
        c.gridy = 0;
        JButton removeFolderButton = new JButton(new ImageIcon(CLOSE));
        removeFolderButton.setPreferredSize(buttonDimension);
        removeFolderButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        removeFolderButton.setToolTipText("Remove the currently selected Object or Folder and all children");
        removeFolderButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        removeFolderButton.addActionListener(e ->
        {
            TreePath[] treePaths = tree.getSelectionPaths();
            if (treePaths == null)
                return;

            tree.removeNodes(treePaths);
        });
        folderHeader.add(removeFolderButton, c);

        c.gridx = 3;
        c.gridy = 0;
        JButton clearFolderButton = new JButton(new ImageIcon(CLEAR));
        clearFolderButton.setPreferredSize(buttonDimension);
        clearFolderButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        clearFolderButton.setToolTipText("Remove all Folders and all Objects in them");
        clearFolderButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        clearFolderButton.addActionListener(e ->
        {
            Thread thread = new Thread(tree::removeAllNodes);
            thread.start();
        });
        folderHeader.add(clearFolderButton, c);

        return folderHeader;
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.*;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.util.*;

@Slf4j
class ManagerTreeTransferHandler extends TransferHandler
{
    private final CreatorsPlugin plugin;
    private final ToolBoxFrame toolBox;
    private DataFlavor nodesFlavor;
    private DataFlavor[] flavors = new DataFlavor[1];
    private DefaultMutableTreeNode[] nodesToRemove;

    public ManagerTreeTransferHandler(CreatorsPlugin plugin, ToolBoxFrame toolBox)
    {
        this.plugin = plugin;
        this.toolBox = toolBox;
        try
        {
            String mimeType = DataFlavor.javaJVMLocalObjectMimeType +
                    ";class=\"" +
                    javax.swing.tree.DefaultMutableTreeNode[].class.getName() +
                    "\"";
            nodesFlavor = new DataFlavor(mimeType);
            flavors[0] = nodesFlavor;
        }
        catch(ClassNotFoundException e)
        {
            log.info("ClassNotFound: " + e.getMessage());
        }
    }

    public boolean canImport(TransferHandler.TransferSupport support)
    {
        if (!support.isDrop())
            return false;

        support.setShowDropLocation(true);
        if (!support.isDataFlavorSupported(nodesFlavor))
            return false;

        // Do not allow a drop on the drag source selections.
        JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
        JTree tree = (JTree) support.getComponent();
        int dropRow = tree.getRowForPath(dl.getPath());
        int[] selRows = tree.getSelectionRows();
        if (selRows == null || selRows.length == 0)
            return false;

        for (int i = 0; i < selRows.length; i++)
        {
            if (selRows[i] == dropRow)
                return false;

            DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getPathForRow(selRows[i]).getLastPathComponent();
            for (TreeNode offspring: Collections.list(treeNode.depthFirstEnumeration()))
            {
                if (tree.getRowForPath(new TreePath(((DefaultMutableTreeNode) offspring).getPath())) == dropRow)
                    return false;
            }
        }

        // If trying to insert into an ObjectPanel, cancel
        int childIndex = dl.getChildIndex();
        TreePath dest = dl.getPath();
        DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) dest.getLastPathComponent();
        if (childIndex == -1 && parentNode.getUserObject() instanceof Character)
            return false;

        if (parentNode.getUserObject() instanceof Folder)
        {
            Folder folder = (Folder) parentNode.getUserObject();
            if (folder.getFolderType() == FolderType.MASTER)
            {
                return false;
            }
        }

        return true;
    }

    protected Transferable createTransferable(JComponent c)
    {
        JTree tree = (JTree) c;
        TreePath[] paths = tree.getSelectionPaths();
        if (paths != null)
        {
            // Make up a node array of copies for transfer and
            // another for/of the nodes that will be removed in
            // exportDone after a successful drop.
            ArrayList<DefaultMutableTreeNode> copies = new ArrayList<>();
            ArrayList<DefaultMutableTreeNode> toRemove = new ArrayList<>();
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) paths[0].getLastPathComponent();
            HashSet<TreeNode> doneItems = new LinkedHashSet<>(paths.length);
            DefaultMutableTreeNode copy = copy(node, doneItems, tree);
            copies.add(copy);
            toRemove.add(node);
            for (int i = 1; i < paths.length; i++)
            {
                DefaultMutableTreeNode next = (DefaultMutableTreeNode)paths[i].getLastPathComponent();
                if (doneItems.contains(next))
                    continue;

                // Do not allow higher level nodes to be added to list.
                if (next.getLevel() < node.getLevel())
                {
                    break;
                }
                else if (next.getLevel() > node.getLevel())  // child node
                {
                    copy.add(copy(next, doneItems, tree));
                    // node already contains child
                }
                else
                {  // sibling
                    copies.add(copy(next, doneItems, tree));
                    toRemove.add(next);
                }
                doneItems.add(next);
            }
            DefaultMutableTreeNode[] nodes = copies.toArray(new DefaultMutableTreeNode[copies.size()]);

            nodesToRemove = toRemove.toArray(new DefaultMutableTreeNode[toRemove.size()]);
            return new ManagerTreeTransferHandler.NodesTransferable(nodes);
        }
        return null;
    }

    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node, HashSet<TreeNode> doneItems, JTree tree)
    {
        DefaultMutableTreeNode copy = new DefaultMutableTreeNode(node.getUserObject());
        if (node.getUserObject() instanceof Folder)
        {
            ((Folder) node.getUserObject()).setLinkedManagerNode(copy);
        }

        if (node.getUserObject() instanceof Character)
        {
            ((Character) node.getUserObject()).setLinkedManagerNode(copy);
        }

        doneItems.add(node);
        for (int i = 0; i < node.getChildCount(); i++)
        {
            copy.add(copy((DefaultMutableTreeNode)((TreeNode)node).getChildAt(i), doneItems, tree));
        }
        int row = tree.getRowForPath(new TreePath(copy.getPath()));
        tree.expandRow(row);
        return copy;
    }

    protected void exportDone(JComponent source, Transferable data, int action)
    {
        if ((action & MOVE) == MOVE)
        {
            JTree tree = (JTree)source;
            DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
            // Remove nodes saved in nodesToRemove in createTransferable.
            for (DefaultMutableTreeNode node : nodesToRemove)
                model.removeNodeFromParent(node);
        }

        plugin.getCreatorsPanel().resetSidePanel();
        toolBox.getManagerPanel().getManagerTree().resetObjectHolder();
    }

    public int getSourceActions(JComponent c)
    {
        return COPY_OR_MOVE;
    }

    public boolean importData(TransferHandler.TransferSupport support)
    {
        if (!canImport(support))
            return false;

        // Extract transfer data.
        DefaultMutableTreeNode[] nodes = null;
        try
        {
            Transferable t = support.getTransferable();
            nodes = (DefaultMutableTreeNode[]) t.getTransferData(nodesFlavor);
        }
        catch(UnsupportedFlavorException ufe)
        {
            log.info("UnsupportedFlavor: " + ufe.getMessage());
        }
        catch(java.io.IOException ioe)
        {
            log.info("I/O error: " + ioe.getMessage());
        }

        // Get drop location info.
        JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
        int childIndex = dl.getChildIndex();
        TreePath dest = dl.getPath();
        DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) (dest.getLastPathComponent());

        ManagerPanel managerPanel = toolBox.getManagerPanel();
        boolean sendToSidePanel = managerPanel.getManagerTree().treeContainsSidePanel(parentNode);
        ParentPanel newParent = sendToSidePanel ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
        ArrayList<Character> sidePanelCharacters = plugin.getCreatorsPanel().getSidePanelCharacters();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();

        ArrayList<Character> arrayTo;
        if (sendToSidePanel)
        {
            arrayTo = sidePanelCharacters;
        }
        else
        {
            arrayTo = managerCharacters;
        }

        // Prevent Protected folders from being transferred
        for (DefaultMutableTreeNode node : nodes)
        {
            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                FolderType type = folder.getFolderType();
                if (type == FolderType.MANAGER
                        || type == FolderType.MASTER
                        || type == FolderType.SIDE_PANEL)
                {
                    return false;
                }
            }
        }

        JTree tree = (JTree) support.getComponent();
        DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
        // Configure for drop mode.
        int index = childIndex;    // DropMode.INSERT
        if (childIndex == -1)     // DropMode.ON
        {
            index = parentNode.getChildCount();
        }

        ArrayList<Character> characters = new ArrayList<>();

        // Add data to model.
        for (int i = 0; i < nodes.length; i++)
        {
            DefaultMutableTreeNode node = nodes[i];
            model.insertNodeInto(node, parentNode, index++);

            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                folder.setParentManagerNode(parentNode);
                getCharacterNodeChildren(node, characters);
            }

            if (node.getUserObject() instanceof Character)
            {
                characters.add((Character) node.getUserObject());
            }
        }

        for (Character character : characters)
        {
            ParentPanel oldParent = character.getParentPanel();
            character.setParentPanel(newParent);
            character.setParentManagerNode(parentNode);

            ArrayList<Character> arrayFrom;
            if (oldParent == ParentPanel.SIDE_PANEL)
            {
                arrayFrom = sidePanelCharacters;
            }
            else
            {
                arrayFrom = managerCharacters;
            }

            arrayFrom.remove(character);
            arrayTo.add(character);
        }

        tree.setSelectionPath(dest);
        tree.expandPath(dest);
        return true;
    }

    public String toString()
    {
        return getClass().getName();
    }

    public class NodesTransferable implements Transferable
    {
        DefaultMutableTreeNode[] nodes;

        public NodesTransferable(DefaultMutableTreeNode[] nodes)
        {
            this.nodes = nodes;
        }

        public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException
        {
            if (!isDataFlavorSupported(flavor))
                throw new UnsupportedFlavorException(flavor);
            return nodes;
        }

        public DataFlavor[] getTransferDataFlavors()
        {
            return flavors;
        }

        public boolean isDataFlavorSupported (DataFlavor flavor)
        {
            return nodesFlavor.equals(flavor);
        }
    }

    public void getCharacterNodeChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                characters.add((Character) node.getUserObject());
                continue;
            }

            if (!node.isLeaf())
                getCharacterNodeChildren(node, characters);
        }
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.CreatorsPanel;
import com.creatorskit.swing.ParentPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.util.ArrayList;

@Slf4j
@Getter
public class ManagerPanel extends JPanel
{
    private final CreatorsPlugin plugin;
    private final Client client;
    private final GridBagConstraints c = new GridBagConstraints();
    private final JPanel objectHolder;
    private final TreeScrollPane treeScrollPane;
    private final ArrayList<Character> managerCharacters = new ArrayList<>();
    private final ManagerTree managerTree;
    private final JLabel objectLabel = new JLabel("Current Folder: Master Folder");

    @Inject
    public ManagerPanel(@Nullable Client client, CreatorsPlugin plugin, JPanel objectHolder, ManagerTree managerTree)
    {
        this.plugin = plugin;
        this.client = client;
        this.objectHolder = objectHolder;
        this.managerTree = managerTree;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        JLabel titleLabel = new JLabel("Manager");
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
        add(titleLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        JPanel headerPanel = new JPanel();
        add(headerPanel, c);

        JButton saveButton = new JButton("Save Setup");
        saveButton.setToolTipText("Save this setup for future use");
        headerPanel.add(saveButton);
        saveButton.addActionListener(e -> plugin.getCreatorsPanel().openSaveDialog());

        JButton loadButton = new JButton("Load Setup");
        loadButton.setToolTipText("Load a previously saved setup");
        headerPanel.add(loadButton);
        loadButton.addActionListener(e -> plugin.getCreatorsPanel().openLoadSetupDialog());

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        c.weightx = 0;
        c.weighty = 1;
        treeScrollPane = new TreeScrollPane(managerTree);
        treeScrollPane.setPreferredSize(new Dimension(350, 0));
        add(treeScrollPane, c);

        c.gridx = 1;
        c.gridy = 2;
        c.weightx = 1;
        JScrollPane objectScrollPane = new JScrollPane();
        objectScrollPane.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        add(objectScrollPane, c);

        JPanel objectHeader = new JPanel();
        objectHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
        objectHeader.setLayout(new BorderLayout());
        objectScrollPane.setColumnHeaderView(objectHeader);

        objectLabel.setFont(FontManager.getRunescapeBoldFont());
        objectHeader.add(objectLabel, BorderLayout.LINE_START);

        JPanel rightButtons = new JPanel();
        objectHeader.add(rightButtons, BorderLayout.LINE_END);

        JButton addObjectButton = new JButton("Add Object");
        addObjectButton.setToolTipText("Add an new Object to the palette");
        addObjectButton.setFocusable(false);
        addObjectButton.setPreferredSize(new Dimension(150, 30));
        addObjectButton.addActionListener(e ->
        {
            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            TreePath path = managerTree.getSelectionPath();

            if (path == null)
            {
                Character character = creatorsPanel.createCharacter(ParentPanel.MANAGER);
                creatorsPanel.addPanel(ParentPanel.MANAGER, character, true, false);
                return;
            }

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            ParentPanel parentPanel = managerTree.treeContainsSidePanel(node) ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
            Character character = creatorsPanel.createCharacter(parentPanel);
            creatorsPanel.addPanel(parentPanel, character, true, false);
        });
        rightButtons.add(addObjectButton);

        JPanel viewport = new JPanel();
        viewport.setLayout(new GridBagLayout());
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 0;
        c.weighty = 0;
        this.objectHolder.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.add(this.objectHolder, c);

        c.gridx = 1;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        viewport.add(new JLabel(""), c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 0;
        c.weighty = 1;
        viewport.add(new JLabel(""), c);

        this.objectHolder.setLayout(new GridLayout(0, 5, 4, 4));
        objectScrollPane.setViewportView(viewport);

        repaint();
        revalidate();
    }

    public Character[] getShownCharacters()
    {
        return managerTree.getShownCharacters();
    }
}

package com.creatorskit.swing.timesheet;

import com.creatorskit.Character;
import com.creatorskit.models.CustomModel;
import com.creatorskit.models.DataFinder;
import com.creatorskit.models.datatypes.NPCData;
import com.creatorskit.programming.Direction;
import com.creatorskit.swing.AutoCompletion;
import com.creatorskit.swing.timesheet.attributes.*;
import com.creatorskit.swing.timesheet.keyframe.*;
import com.creatorskit.swing.timesheet.keyframe.settings.*;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.HeadIcon;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
public class AttributePanel extends JPanel
{
    private TimeSheetPanel timeSheetPanel;
    private DataFinder dataFinder;

    private final BufferedImage HELP = ImageUtil.loadImageResource(getClass(), "/Help.png");
    private final Icon keyframeImage = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Keyframe.png"));
    private final Icon keyframeEmptyImage = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Keyframe_Empty.png"));

    private final GridBagConstraints c = new GridBagConstraints();
    private final JPanel cardPanel = new JPanel();
    private final JLabel objectLabel = new JLabel("Pick an Object");
    private final JLabel cardLabel = new JLabel("");
    private final JLabel keyFramed = new JLabel();

    private final String MOVE_CARD = "Movement";
    private final String ANIM_CARD = "Animation";
    private final String ORI_CARD = "Orientation";
    private final String SPAWN_CARD = "Spawn";
    private final String MODEL_CARD = "Model";
    private final String TEXT_CARD = "Text";
    private final String OVER_CARD = "Overhead";
    private final String HEALTH_CARD = "Health";
    private final String SPOTANIM_CARD = "SpotAnim";

    private KeyFrameType hoveredKeyFrameType;
    private Component hoveredComponent;
    private KeyFrameType selectedKeyFramePage = KeyFrameType.MOVEMENT;

    private final AnimAttributes animAttributes = new AnimAttributes();
    private final OriAttributes oriAttributes = new OriAttributes();
    private final SpawnAttributes spawnAttributes = new SpawnAttributes();
    private final ModelAttributes modelAttributes = new ModelAttributes();
    private final TextAttributes textAttributes = new TextAttributes();
    private final OverheadAttributes overheadAttributes = new OverheadAttributes();
    private final HealthAttributes healthAttributes = new HealthAttributes();
    private final SpotAnimAttributes spotAnimAttributes = new SpotAnimAttributes();

    @Inject
    public AttributePanel(TimeSheetPanel timeSheetPanel, DataFinder dataFinder)
    {
        this.timeSheetPanel = timeSheetPanel;
        this.dataFinder = dataFinder;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        objectLabel.setFont(FontManager.getRunescapeBoldFont());
        objectLabel.setHorizontalAlignment(SwingConstants.LEFT);

        cardPanel.setLayout(new CardLayout());
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.setFocusable(true);
        addMouseFocusListener(cardPanel);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        add(objectLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        c.weightx = 0;
        cardLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        cardLabel.setFont(FontManager.getRunescapeBoldFont());
        cardLabel.setText(MOVE_CARD);
        add(cardLabel, c);

        c.gridx = 2;
        c.gridy = 0;
        keyFramed.setIcon(keyframeEmptyImage);
        keyFramed.setPreferredSize(new Dimension(18, 18));
        keyFramed.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseReleased(MouseEvent e)
            {
                super.mouseReleased(e);
                timeSheetPanel.onKeyFrameIconPressedEvent();
            }
        });
        add(keyFramed, c);

        c.gridwidth = 3;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        add(cardPanel, c);

        JPanel moveCard = new JPanel();
        JPanel animCard = new JPanel();
        JPanel oriCard = new JPanel();
        JPanel spawnCard = new JPanel();
        JPanel modelCard = new JPanel();
        JPanel textCard = new JPanel();
        JPanel overCard = new JPanel();
        JPanel healthCard = new JPanel();
        JPanel spotanimCard = new JPanel();
        cardPanel.add(moveCard, MOVE_CARD);
        cardPanel.add(animCard, ANIM_CARD);
        cardPanel.add(oriCard, ORI_CARD);
        cardPanel.add(spawnCard, SPAWN_CARD);
        cardPanel.add(modelCard, MODEL_CARD);
        cardPanel.add(textCard, TEXT_CARD);
        cardPanel.add(overCard, OVER_CARD);
        cardPanel.add(healthCard, HEALTH_CARD);
        cardPanel.add(spotanimCard, SPOTANIM_CARD);

        setupMoveCard(moveCard);
        setupAnimCard(animCard);
        setupOriCard(oriCard);
        setupSpawnCard(spawnCard);
        setupModelCard(modelCard);
        setupTextCard(textCard);
        setupOverheadCard(overCard);
        setupHealthCard(healthCard);
        setupSpotAnimCard(spotanimCard);

        setupKeyListeners();
    }

    /**
     * Create a keyframe out of the current AttributePanel settings, based on which card is currently being shown
     * @return a keyframe of type depending on which card is currently showing, with settings based on what is displayed on that card
     */
    public KeyFrame createKeyFrame()
    {
        switch (selectedKeyFramePage)
        {
            default:
            case MOVEMENT:
                break;
            case ANIMATION:
                return new AnimationKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        (int) animAttributes.getManual().getValue(),
                        animAttributes.getManualOverride().getSelectedItem() == AnimationToggle.MANUAL_ANIMATION,
                        (int) animAttributes.getIdle().getValue(),
                        (int) animAttributes.getWalk().getValue(),
                        (int) animAttributes.getRun().getValue(),
                        (int) animAttributes.getWalk180().getValue(),
                        (int) animAttributes.getWalkRight().getValue(),
                        (int) animAttributes.getWalkLeft().getValue(),
                        (int) animAttributes.getIdleRight().getValue(),
                        (int) animAttributes.getIdleLeft().getValue()
                );
            case ORIENTATION:
                return new OrientationKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        (int) oriAttributes.getManual().getValue(),
                        oriAttributes.getManualOverride().getSelectedItem() == OrientationToggle.MANUAL_ORIENTATION
                );
            case SPAWN:
                return new SpawnKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        spawnAttributes.getSpawn().getSelectedItem() == Toggle.ENABLE
                );
            case MODEL:
                return new ModelKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        modelAttributes.getModelOverride().getSelectedItem() == ModelToggle.CUSTOM_MODEL,
                        (int) modelAttributes.getModelId().getValue(),
                        (CustomModel) modelAttributes.getCustomModel().getSelectedItem()
                );
            case TEXT:
                return new TextKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        textAttributes.getEnableBox().getSelectedItem() == Toggle.ENABLE,
                        textAttributes.getText().getText(),
                        (int) textAttributes.getHeight().getValue()
                );
            case OVERHEAD:
                return new OverheadKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        overheadAttributes.getEnableBox().getSelectedItem() == Toggle.ENABLE,
                        (HeadIcon) overheadAttributes.getHeadIcon().getSelectedItem(),
                        (int) overheadAttributes.getHeight().getValue()
                );
            case HEALTH:
                return new HealthKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        healthAttributes.getEnableBox().getSelectedItem() == Toggle.ENABLE,
                        (HitsplatType) healthAttributes.getHitsplatType().getSelectedItem(),
                        (int) healthAttributes.getHitsplatHeight().getValue(),
                        (int) healthAttributes.getMaxHealth().getValue(),
                        (int) healthAttributes.getCurrentHealth().getValue(),
                        (int) healthAttributes.getHealthbarHeight().getValue()
                );
            case SPOTANIM:
                return new SpotAnimKeyFrame(
                        timeSheetPanel.getCurrentTime(),
                        (int) spotAnimAttributes.getSpotAnimId1().getValue(),
                        (int) spotAnimAttributes.getSpotAnimId2().getValue()
                );
        }

        return null;
    }

    private void setupMoveCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Movement");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);
    }

    private void setupAnimCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Manual Animation");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Enabling manual animation override lets you exactly control what animation is played at a given time" +
                "<br>Smart animation instead bases your animations off the Object's movement. For example:" +
                "<br>The Idle animation plays when your character is not moving, while the Run animation plays while the Object is moving >1 tile/tick</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel manualLabel = new JLabel("Manual: ");
        manualLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(manualLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner manual = animAttributes.getManual();
        manual.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        manual.setPreferredSize(spinnerSize);
        card.add(manual, c);

        c.gridwidth = 3;
        c.gridx = 2;
        c.gridy = 1;
        JComboBox<AnimationToggle> manualComboBox = animAttributes.getManualOverride();
        manualComboBox.setFocusable(false);
        manualComboBox.addItem(AnimationToggle.SMART_ANIMATION);
        manualComboBox.addItem(AnimationToggle.MANUAL_ANIMATION);
        card.add(manualComboBox, c);

        c.gridwidth = 4;
        c.gridx = 0;
        c.gridy = 2;
        JLabel smartTitle = new JLabel("Smart Animation");
        smartTitle.setFont(FontManager.getRunescapeBoldFont());
        card.add(smartTitle, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel idleLabel = new JLabel("Idle: ");
        idleLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JSpinner idle = animAttributes.getIdle();
        idle.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idle.setPreferredSize(spinnerSize);
        card.add(idle, c);

        c.gridx = 2;
        c.gridy = 3;
        JLabel walk180Label = new JLabel("Walk 180: ");
        walk180Label.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walk180Label, c);

        c.gridx = 3;
        c.gridy = 3;
        JSpinner walk180 = animAttributes.getWalk180();
        walk180.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walk180.setPreferredSize(spinnerSize);
        card.add(walk180, c);

        c.gridx = 0;
        c.gridy = 4;
        JLabel walkLabel = new JLabel("Walk: ");
        walkLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkLabel, c);

        c.gridx = 1;
        c.gridy = 4;
        JSpinner walk = animAttributes.getWalk();
        walk.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walk.setPreferredSize(spinnerSize);
        card.add(walk, c);

        c.gridx = 2;
        c.gridy = 4;
        JLabel walkRLabel = new JLabel("Walk Right: ");
        walkRLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkRLabel, c);

        c.gridx = 3;
        c.gridy = 4;
        JSpinner walkRight = animAttributes.getWalkRight();
        walkRight.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walkRight.setPreferredSize(spinnerSize);
        card.add(walkRight, c);

        c.gridx = 0;
        c.gridy = 5;
        JLabel runLabel = new JLabel("Run: ");
        runLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(runLabel, c);

        c.gridx = 1;
        c.gridy = 5;
        JSpinner run = animAttributes.getRun();
        run.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        run.setPreferredSize(spinnerSize);
        card.add(run, c);

        c.gridx = 2;
        c.gridy = 5;
        JLabel walkLLabel = new JLabel("Walk Left: ");
        walkLLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkLLabel, c);

        c.gridx = 3;
        c.gridy = 5;
        JSpinner walkLeft = animAttributes.getWalkLeft();
        walkLeft.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walkLeft.setPreferredSize(spinnerSize);
        card.add(walkLeft, c);

        c.gridx = 2;
        c.gridy = 6;
        JLabel idleRLabel = new JLabel("Idle Right: ");
        idleRLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleRLabel, c);

        c.gridx = 3;
        c.gridy = 6;
        JSpinner idleRight = animAttributes.getIdleRight();
        idleRight.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idleRight.setPreferredSize(spinnerSize);
        card.add(idleRight, c);

        c.gridx = 2;
        c.gridy = 7;
        JLabel idleLLabel = new JLabel("Idle Left: ");
        idleLLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleLLabel, c);

        c.gridx = 3;
        c.gridy = 7;
        JSpinner idleLeft = animAttributes.getIdleLeft();
        idleLeft.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idleLeft.setPreferredSize(spinnerSize);
        card.add(idleLeft, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 8;
        JLabel searcherLabel = new JLabel("NPC Animation Presets: ");
        searcherLabel.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(searcherLabel, c);

        c.gridwidth = 3;
        c.gridx = 2;
        c.gridy = 8;
        JComboBox<NPCData> searcher = new JComboBox<>();
        AutoCompletion.enable(searcher);
        List<NPCData> npcData = dataFinder.getNpcData();
        NPCData player = new NPCData(
                -1,
                "Player",
                new int[0],
                1,
                808,
                819,
                824,
                823,
                823,
                820,
                821,
                822,
                1,
                1,
                new int[0],
                new int[0]);
        searcher.addItem(player);
        for (NPCData n : npcData)
        {
            searcher.addItem(n);
        }
        searcher.setPreferredSize(new Dimension(270, 25));
        card.add(searcher, c);

        c.gridwidth = 1;
        c.gridx = 5;
        c.gridy = 8;
        JButton searchApply = new JButton("Apply");
        searchApply.addActionListener(e ->
        {
            NPCData data = (NPCData) searcher.getSelectedItem();
            if (data == null)
            {
                return;
            }

            idle.setValue(data.getStandingAnimation());
            walk.setValue(data.getWalkingAnimation());
            run.setValue(data.getRunAnimation());
            walk180.setValue(data.getRotate180Animation());
            walkRight.setValue(data.getRotateRightAnimation());
            walkLeft.setValue(data.getRotateLeftAnimation());
            idleRight.setValue(data.getIdleRotateRightAnimation());
            idleLeft.setValue(data.getIdleRotateLeftAnimation());
        });
        card.add(searchApply, c);


        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupOriCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Manual Orientation");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Enabling manual orientation override lets you exactly control what orientation your Object will face" +
                "<br>Otherwise, the Object's orientation is instead based off of the direction of its movement</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel manualLabel = new JLabel("Manual: ");
        manualLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(manualLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner manual = oriAttributes.getManual();
        manual.setModel(new SpinnerNumberModel(0, 0, 2048, 1));
        manual.setPreferredSize(spinnerSize);
        card.add(manual, c);

        c.gridwidth = 2;
        c.gridx = 2;
        c.gridy = 1;
        JComboBox<OrientationToggle> manualCheckbox = oriAttributes.getManualOverride();
        manualCheckbox.setFocusable(false);
        manualCheckbox.addItem(OrientationToggle.SMART_ORIENTATION);
        manualCheckbox.addItem(OrientationToggle.MANUAL_ORIENTATION);
        card.add(manualCheckbox, c);

        c.gridx = 0;
        c.gridy = 2;
        c.gridwidth = 1;
        JLabel presetLabel = new JLabel("Presets: ");
        presetLabel.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(presetLabel, c);

        c.gridwidth = 3;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<Direction> searcher = new JComboBox<>();
        AutoCompletion.enable(searcher);
        Direction[] directions = Direction.getAllDirections();
        for (Direction d : directions)
        {
            searcher.addItem(d);
        }
        searcher.setPreferredSize(new Dimension(100, 25));
        card.add(searcher, c);

        c.gridwidth = 1;
        c.gridx = 4;
        c.gridy = 2;
        JButton searchApply = new JButton("Apply");
        searchApply.addActionListener(e ->
        {
            Direction direction = (Direction) searcher.getSelectedItem();
            if (direction == null)
            {
                return;
            }

            manual.setValue(direction.getJUnit());
        });
        card.add(searchApply, c);


        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupSpawnCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Set Spawn");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set whether the object appears or not");
        manualTitlePanel.add(manualTitleHelp);

        c.gridx = 0;
        c.gridy = 1;
        JComboBox<Toggle> manualCheckbox = spawnAttributes.getSpawn();
        manualCheckbox.setFocusable(false);
        manualCheckbox.addItem(Toggle.ENABLE);
        manualCheckbox.addItem(Toggle.DISABLE);
        card.add(manualCheckbox, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    public void setupModelCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Model");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Switch between using a 3D model based on the Model Id from the cache," +
                "<br>or a Custom Model that you've grabbed from the environment or created in the Model Anvil</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel idLabel = new JLabel("Model Id: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner id = modelAttributes.getModelId();
        id.setValue(-1);
        id.setPreferredSize(spinnerSize);
        card.add(id, c);

        c.gridwidth = 2;
        c.gridx = 2;
        c.gridy = 1;
        JComboBox<ModelToggle> toggleComboBox = modelAttributes.getModelOverride();
        toggleComboBox.setFocusable(false);
        toggleComboBox.addItem(ModelToggle.MODEL_ID);
        toggleComboBox.addItem(ModelToggle.CUSTOM_MODEL);
        card.add(toggleComboBox, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel customLabel = new JLabel("Custom Model: ");
        customLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(customLabel, c);

        c.gridwidth = 2;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<CustomModel> customComboBox = modelAttributes.getCustomModel();
        customComboBox.setFocusable(false);
        //customComboBox.addItem(ModelToggle.MODEL_ID);
        card.add(customComboBox, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupTextCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Overhead Text");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the text to display over this Object's head");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JComboBox<Toggle> toggleComboBox = textAttributes.getEnableBox();
        toggleComboBox.setFocusable(false);
        toggleComboBox.addItem(Toggle.DISABLE);
        toggleComboBox.addItem(Toggle.ENABLE);
        card.add(toggleComboBox, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel textLabel = new JLabel("Overhead Text: ");
        textLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(textLabel, c);

        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 1;
        c.gridy = 2;
        JTextArea text = textAttributes.getText();
        text.setText("");
        text.setLineWrap(true);
        card.add(text, c);

        c.weightx = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel heightLabel = new JLabel("Height: ");
        heightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(heightLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 3;
        JSpinner height = textAttributes.getHeight();
        height.setValue(60);
        card.add(height, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupOverheadCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Overhead Prayer");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the prayer icon to display over this Object's head");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JComboBox<Toggle> toggleComboBox = overheadAttributes.getEnableBox();
        toggleComboBox.setFocusable(false);
        toggleComboBox.addItem(Toggle.DISABLE);
        toggleComboBox.addItem(Toggle.ENABLE);
        card.add(toggleComboBox, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel textLabel = new JLabel("Overhead Icon: ");
        textLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(textLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<HeadIcon> headIconBox = overheadAttributes.getHeadIcon();
        headIconBox.setFocusable(false);
        headIconBox.addItem(HeadIcon.MAGIC);
        headIconBox.addItem(HeadIcon.RANGED);
        headIconBox.addItem(HeadIcon.MELEE);
        headIconBox.addItem(HeadIcon.REDEMPTION);
        headIconBox.addItem(HeadIcon.RETRIBUTION);
        headIconBox.addItem(HeadIcon.SMITE);
        headIconBox.addItem(HeadIcon.RANGE_MAGE);
        headIconBox.addItem(HeadIcon.RANGE_MELEE);
        headIconBox.addItem(HeadIcon.MAGE_MELEE);
        headIconBox.addItem(HeadIcon.RANGE_MAGE_MELEE);
        headIconBox.addItem(HeadIcon.DEFLECT_MAGE);
        headIconBox.addItem(HeadIcon.DEFLECT_RANGE);
        headIconBox.addItem(HeadIcon.DEFLECT_MELEE);
        headIconBox.addItem(HeadIcon.SOUL_SPLIT);
        headIconBox.addItem(HeadIcon.WRATH);
        card.add(headIconBox, c);

        c.weightx = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel heightLabel = new JLabel("Height: ");
        heightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(heightLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 3;
        JSpinner height = overheadAttributes.getHeight();
        height.setValue(60);
        card.add(height, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupHealthCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Healthbar & Hitsplats");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the healthbar and hitsplats for this Object");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JComboBox<Toggle> toggleComboBox = healthAttributes.getEnableBox();
        toggleComboBox.setFocusable(false);
        toggleComboBox.addItem(Toggle.DISABLE);
        toggleComboBox.addItem(Toggle.ENABLE);
        card.add(toggleComboBox, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel textLabel = new JLabel("Hitsplat Icon: ");
        textLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(textLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<HitsplatType> hitsplatComboBox = healthAttributes.getHitsplatType();
        hitsplatComboBox.setFocusable(false);
        hitsplatComboBox.addItem(HitsplatType.DAMAGE);
        hitsplatComboBox.addItem(HitsplatType.BLOCK);
        card.add(hitsplatComboBox, c);

        c.weightx = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel hitsplatHeightLabel = new JLabel("Hitsplat Height: ");
        hitsplatHeightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(hitsplatHeightLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 3;
        JSpinner hitsplatHeight = healthAttributes.getHitsplatHeight();
        hitsplatHeight.setValue(30);
        card.add(hitsplatHeight, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 4;
        JLabel maxHealthLabel = new JLabel("Max Health: ");
        maxHealthLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(maxHealthLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 4;
        JSpinner maxHealth = healthAttributes.getMaxHealth();
        maxHealth.setValue(99);
        card.add(maxHealth, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 5;
        JLabel currentHealthLabel = new JLabel("Current Health: ");
        currentHealthLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(currentHealthLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 5;
        JSpinner currentHealth = healthAttributes.getCurrentHealth();
        currentHealth.setValue(99);
        card.add(currentHealth, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 6;
        JLabel healthbarHeightLabel = new JLabel("Healthbar Height: ");
        healthbarHeightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(healthbarHeightLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 6;
        JSpinner healthbarHeight = healthAttributes.getHealthbarHeight();
        healthbarHeight.setValue(60);
        card.add(healthbarHeight, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupSpotAnimCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("SpotAnim");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the SpotAnim (like spell effects) to play on the Object");
        manualTitlePanel.add(manualTitleHelp);

        c.weightx = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel spotAnim1Label = new JLabel("SpotAnim 1: ");
        spotAnim1Label.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(spotAnim1Label, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 1;
        JSpinner spotAnim1 = spotAnimAttributes.getSpotAnimId1();
        spotAnim1.setValue(-1);
        card.add(spotAnim1, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel spotAnim2Label = new JLabel("SpotAnim 2: ");
        spotAnim2Label.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(spotAnim2Label, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JSpinner spotAnim2 = spotAnimAttributes.getSpotAnimId2();
        spotAnim2.setValue(-1);
        card.add(spotAnim2, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    public void switchCards(String cardName)
    {
        CardLayout cl = (CardLayout)(cardPanel.getLayout());
        cl.show(cardPanel, cardName);
        cardLabel.setText(cardName);

        switch (cardName)
        {
            default:
            case MOVE_CARD:
                selectedKeyFramePage = KeyFrameType.MOVEMENT;
                break;
            case ANIM_CARD:
                selectedKeyFramePage = KeyFrameType.ANIMATION;
                break;
            case ORI_CARD:
                selectedKeyFramePage = KeyFrameType.ORIENTATION;
                break;
            case SPAWN_CARD:
                selectedKeyFramePage = KeyFrameType.SPAWN;
                break;
            case MODEL_CARD:
                selectedKeyFramePage = KeyFrameType.MODEL;
                break;
            case TEXT_CARD:
                selectedKeyFramePage = KeyFrameType.TEXT;
                break;
            case OVER_CARD:
                selectedKeyFramePage = KeyFrameType.OVERHEAD;
                break;
            case HEALTH_CARD:
                selectedKeyFramePage = KeyFrameType.HEALTH;
                break;
            case SPOTANIM_CARD:
                selectedKeyFramePage = KeyFrameType.SPOTANIM;
        }

        JLabel[] labels = timeSheetPanel.getLabels();
        JLabel selectedLabel;

        selectedLabel = labels[KeyFrameType.getIndex(selectedKeyFramePage) + 1];
        for (int f = 0; f < labels.length; f++)
        {
            JLabel label = labels[f];
            if (label == selectedLabel)
            {
                timeSheetPanel.getAttributeSheet().setSelectedIndex(f);
                label.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }
            else
            {
                label.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        }

        Character character = timeSheetPanel.getSelectedCharacter();
        double currentTick = timeSheetPanel.getCurrentTime();
        if (character == null)
        {
            setKeyFramedIcon(false);
            resetAttributes(null, currentTick);
            return;
        }

        KeyFrame keyFrame = character.findKeyFrame(selectedKeyFramePage, currentTick);
        setKeyFramedIcon(keyFrame != null);
        resetAttributes(character, currentTick);
    }

    public void setSelectedCharacter(Character character)
    {
        double tick = timeSheetPanel.getCurrentTime();

        if (character == null)
        {
            objectLabel.setText("");
            setKeyFramedIcon(false);
            setAttributesEmpty();
            return;
        }

        objectLabel.setText(character.getName());
        KeyFrame keyFrame = character.findKeyFrame(selectedKeyFramePage, tick);
        setKeyFramedIcon(keyFrame != null);
        resetAttributes(character, tick);
    }

    private void setupKeyListeners()
    {
        for (JComponent c : animAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.ANIMATION);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.ANIMATION);
        }

        for (JComponent c : oriAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.ORIENTATION);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.ORIENTATION);
        }

        for (JComponent c : spawnAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.SPAWN);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.SPAWN);
        }

        for (JComponent c : modelAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.MODEL);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.MODEL);
        }

        for (JComponent c : textAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.TEXT);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.TEXT);
        }

        for (JComponent c : overheadAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.OVERHEAD);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.OVERHEAD);
        }

        for (JComponent c : healthAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HEALTH);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HEALTH);
        }

        for (JComponent c : spotAnimAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.SPOTANIM);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.SPOTANIM);
        }
    }

    private void addMouseFocusListener(JComponent component)
    {
        component.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e)
            {
                super.mousePressed(e);
                component.requestFocusInWindow();
            }
        });
    }

    private void addHoverListeners(Component component, KeyFrameType type)
    {
        component.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                super.mouseEntered(e);
                hoveredComponent = component;
                hoveredKeyFrameType = type;
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                super.mouseExited(e);
                hoveredComponent = null;
                hoveredKeyFrameType = KeyFrameType.NULL;
            }
        });
    }

    private void addHoverListenersWithChildren(JComponent component, KeyFrameType type)
    {
        ArrayList<Component> components = new ArrayList<>();
        getAllComponentChildren(components, component);
        for (Component c : components)
        {
            addHoverListeners(c, type);
        }
    }

    private void getAllComponentChildren(ArrayList<Component> components, JComponent component)
    {
        for (Component c : component.getComponents())
        {
            components.add(c);
            getAllComponentChildren(components, (JComponent) c);
        }
    }

    public void resetAttributes(Character character, double tick)
    {
        if (character == null)
        {
            setAttributesEmpty();
            return;
        }

        setKeyFramedIcon(character.findKeyFrame(selectedKeyFramePage, tick) != null);
        KeyFrame keyFrame = character.findPreviousKeyFrame(selectedKeyFramePage, tick, true);

        if (keyFrame == null)
        {
            keyFrame = character.findNextKeyFrame(selectedKeyFramePage, tick);

            if (keyFrame == null)
            {
                switch (selectedKeyFramePage)
                {
                    default:
                    case MOVEMENT:
                        break;
                    case ANIMATION:
                        animAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case ORIENTATION:
                        oriAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case SPAWN:
                        spawnAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case MODEL:
                        modelAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case TEXT:
                        textAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case OVERHEAD:
                        overheadAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case HEALTH:
                        healthAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                    case SPOTANIM:
                        spotAnimAttributes.setBackgroundColours(KeyFrameState.EMPTY);
                        break;
                }

                return;
            }
        }

        KeyFrameState keyFrameState = tick == keyFrame.getTick() ? KeyFrameState.ON_KEYFRAME : KeyFrameState.OFF_KEYFRAME;

        switch (selectedKeyFramePage)
        {
            default:
            case MOVEMENT:
                break;
            case ANIMATION:
                animAttributes.setAttributes(keyFrame);
                animAttributes.setBackgroundColours(keyFrameState);
                break;
            case ORIENTATION:
                oriAttributes.setAttributes(keyFrame);
                oriAttributes.setBackgroundColours(keyFrameState);
                break;
            case SPAWN:
                spawnAttributes.setAttributes(keyFrame);
                spawnAttributes.setBackgroundColours(keyFrameState);
                break;
            case MODEL:
                modelAttributes.setAttributes(keyFrame);
                modelAttributes.setBackgroundColours(keyFrameState);
                break;
            case TEXT:
                textAttributes.setAttributes(keyFrame);
                textAttributes.setBackgroundColours(keyFrameState);
                break;
            case OVERHEAD:
                overheadAttributes.setAttributes(keyFrame);
                overheadAttributes.setBackgroundColours(keyFrameState);
                break;
            case HEALTH:
                healthAttributes.setAttributes(keyFrame);
                healthAttributes.setBackgroundColours(keyFrameState);
                break;
            case SPOTANIM:
                spotAnimAttributes.setAttributes(keyFrame);
                spotAnimAttributes.setBackgroundColours(keyFrameState);
        }
    }

    private void setAttributesEmpty()
    {
        switch (selectedKeyFramePage)
        {
            default:
            case MOVEMENT:
                break;
            case ANIMATION:
                animAttributes.resetAttributes();
                break;
            case ORIENTATION:
                oriAttributes.resetAttributes();
                break;
            case SPAWN:
                spawnAttributes.resetAttributes();
                break;
            case MODEL:
                modelAttributes.resetAttributes();
                break;
            case TEXT:
                textAttributes.resetAttributes();
                break;
            case OVERHEAD:
                overheadAttributes.resetAttributes();
                break;
            case HEALTH:
                healthAttributes.resetAttributes();
                break;
            case SPOTANIM:
                spotAnimAttributes.resetAttributes();
        }
    }

    public void setKeyFramedIcon(boolean isKeyFramed)
    {
        if (isKeyFramed)
        {
            keyFramed.setIcon(keyframeImage);
            return;
        }

        keyFramed.setIcon(keyframeEmptyImage);
    }
}


package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.Character;
import com.creatorskit.swing.Folder;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.ArrayUtils;

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;

@Getter
@Setter
public class SummarySheet extends TimeSheet
{
    private ManagerTree tree;
    private AttributePanel attributePanel;

    public SummarySheet(ToolBoxFrame toolBox, ManagerTree tree, AttributePanel attributePanel)
    {
        super(toolBox, tree, attributePanel);
        this.tree = tree;
        this.attributePanel = attributePanel;
    }

    @Override
    public void drawHighlight(Graphics g)
    {
        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, getSelectedIndex() * ROW_HEIGHT - ROW_HEIGHT_OFFSET - getVScroll(), this.getWidth(), ROW_HEIGHT);
    }

    @Override
    public void drawKeyFrames(Graphics g)
    {
        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;

        ArrayList<DefaultMutableTreeNode> nodes = new ArrayList<>();
        nodes.add(tree.getRootNode());
        tree.getAllNodes(tree.getRootNode(), nodes);
        int index = -2;

        for (DefaultMutableTreeNode node : nodes)
        {
            index++;

            TreePath path = tree.getPathForRow(index);
            if (path == null)
            {
                continue;
            }

            if (node.getUserObject() instanceof Folder)
            {
                continue;
            }

            Character character = (Character) node.getUserObject();
            KeyFrameType keyFrameType = getToolBox().getTimeSheetPanel().getSummaryKeyFrameType();
            switch (keyFrameType)
            {
                default:
                case NULL:
                case SUMMARY:
                    double[] ticks = getSummaryKeyFrames(character);
                    drawFrameIcons(g, ticks, image, index, xImageOffset, yImageOffset);
                    break;
                case MOVEMENT:
                case ANIMATION:
                case SPAWN:
                case MODEL:
                case ORIENTATION:
                case TEXT:
                case OVERHEAD:
                case HEALTH:
                case SPOTANIM:
                    KeyFrame[] keyFrames = character.getKeyFrames(keyFrameType);
                    drawFrameIcons(g, keyFrames, image, index, xImageOffset, yImageOffset);
            }
        }
    }

    private double[] getSummaryKeyFrames(Character character)
    {
        double[] ticks = new double[0];
        KeyFrame[][] frames = character.getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame k = keyFrames[e];
                if (ticks.length == 0)
                {
                    ticks = ArrayUtils.add(ticks, k.getTick());
                }

                double tick = k.getTick();
                boolean contains = false;
                for (double d : ticks)
                {
                    if (tick == d)
                    {
                        contains = true;
                        break;
                    }
                }

                if (contains)
                {
                    continue;
                }

                ticks = ArrayUtils.add(ticks, tick);
            }
        }

        return ticks;
    }

    private void drawFrameIcons(Graphics g, double[] ticks, BufferedImage image, int index, int xImageOffset, int yImageOffset)
    {
        for (int e = 0; e < ticks.length; e++)
        {
            double d = ticks[e];

            double zoomFactor = this.getWidth() / getZoom();
            g.drawImage(
                    image,
                    (int) ((d + getHScroll()) * zoomFactor - xImageOffset),
                    (index * ROW_HEIGHT) - ROW_HEIGHT_OFFSET - yImageOffset - getVScroll(),
                    null);
        }
    }

    private void drawFrameIcons(Graphics g, KeyFrame[] keyFrames, BufferedImage image, int index, int xImageOffset, int yImageOffset)
    {
        for (int e = 0; e < keyFrames.length; e++)
        {
            double d = keyFrames[e].getTick();

            double zoomFactor = this.getWidth() / getZoom();
            g.drawImage(
                    image,
                    (int) ((d + getHScroll()) * zoomFactor - xImageOffset),
                    (index * ROW_HEIGHT) - ROW_HEIGHT_OFFSET - yImageOffset - getVScroll(),
                    null);
        }
    }

    @Override
    public void updateSelectedKeyFrameOnPressed(boolean shiftDown)
    {
        KeyFrame[] clickedKeyFrames = getClickedKeyFrames();
        if (clickedKeyFrames.length == 0)
        {
            return;
        }

        KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
        KeyFrame clickedKeyFrame = clickedKeyFrames[0];
        if (Arrays.stream(selectedKeyFrames).noneMatch(n -> n == clickedKeyFrame))
        {
            if (shiftDown)
            {
                setSelectedKeyFrames(ArrayUtils.add(selectedKeyFrames, clickedKeyFrame));
            }
            else
            {
                setSelectedKeyFrames(new KeyFrame[]{clickedKeyFrame});
            }
        }
    }

    @Override
    public KeyFrame[] getKeyFrameClicked(Point point)
    {
        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrameType keyFrameType = getToolBox().getTimeSheetPanel().getSummaryKeyFrameType();

        ArrayList<DefaultMutableTreeNode> nodes = new ArrayList<>();
        nodes.add(tree.getRootNode());
        tree.getAllNodes(tree.getRootNode(), nodes);

        KeyFrame[] keyFramesClicked = new KeyFrame[0];

        int index = -2;

        for (DefaultMutableTreeNode node : nodes)
        {
            index++;

            TreePath path = tree.getPathForRow(index);
            if (path == null)
            {
                continue;
            }

            if (node.getUserObject() instanceof Folder)
            {
                continue;
            }

            Character character = (Character) node.getUserObject();
            KeyFrame[] keyFrames = character.getKeyFrames(keyFrameType);
            for (KeyFrame keyFrame : keyFrames)
            {
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = (index * ROW_HEIGHT) - ROW_HEIGHT_OFFSET - yImageOffset - getVScroll();
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        keyFramesClicked = ArrayUtils.add(keyFramesClicked, keyFrame);
                    }
                }
            }
        }

        return keyFramesClicked;
    }

    @Override
    public void updateSelectedKeyFrameOnRelease(Point point, boolean shiftKey)
    {
        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrameType keyFrameType = getToolBox().getTimeSheetPanel().getSummaryKeyFrameType();

        ArrayList<DefaultMutableTreeNode> nodes = new ArrayList<>();
        nodes.add(tree.getRootNode());
        tree.getAllNodes(tree.getRootNode(), nodes);

        KeyFrame[] keyFramesClicked = new KeyFrame[0];

        int index = -2;

        for (DefaultMutableTreeNode node : nodes)
        {
            index++;

            TreePath path = tree.getPathForRow(index);
            if (path == null)
            {
                continue;
            }

            if (node.getUserObject() instanceof Folder)
            {
                continue;
            }

            Character character = (Character) node.getUserObject();
            KeyFrame[] keyFrames = character.getKeyFrames(keyFrameType);
            for (KeyFrame keyFrame : keyFrames)
            {
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = (index * ROW_HEIGHT) - ROW_HEIGHT_OFFSET - yImageOffset - getVScroll();
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        if (shiftKey)
                        {
                            KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
                            boolean alreadyContains = false;

                            for (KeyFrame kf : selectedKeyFrames)
                            {
                                if (kf == keyFrame)
                                {
                                    alreadyContains = true;
                                    break;
                                }
                            }

                            if (!alreadyContains)
                            {
                                keyFramesClicked = ArrayUtils.add(keyFramesClicked, keyFrame);
                            }
                        }
                        else
                        {
                            keyFramesClicked = ArrayUtils.add(keyFramesClicked, keyFrame);
                        }
                    }
                }
            }
        }

        setSelectedKeyFrames(keyFramesClicked);
    }
}

package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.Character;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;

import static com.creatorskit.swing.timesheet.TimeSheetPanel.round;

@Getter
@Setter
public class TimeSheet extends JPanel
{
    private ToolBoxFrame toolBox;
    private ManagerTree managerTree;
    private AttributePanel attributePanel;

    private final BufferedImage keyframeImage = ImageUtil.loadImageResource(getClass(), "/Keyframe.png");
    private final BufferedImage keyframeSelected = ImageUtil.loadImageResource(getClass(), "/Keyframe_Selected.png");

    private double zoom = 50;
    private double hScroll = 0;
    private int vScroll = 0;
    private int selectedIndex = 0;

    private double currentTime = 0;
    private double previewTime = 0;
    private boolean timeIndicatorPressed = false;
    private boolean allowRectangleSelect = false;
    private Point mousePointOnPressed = new Point(0, 0);

    public final int ROW_HEIGHT = 24;
    public final int ROW_HEIGHT_OFFSET = 1;
    public final int TEXT_HEIGHT_OFFSET = 5;
    private int indexBuffers = 1;

    public final int SHOW_5_ZOOM = 200;
    public final int SHOW_1_ZOOM = 50;

    private KeyFrame[] visibleKeyFrames = new KeyFrame[0];
    private Character selectedCharacter;
    private boolean keyFrameClicked = false;
    private KeyFrame[] clickedKeyFrames = new KeyFrame[0];

    public TimeSheet(ToolBoxFrame toolBox, ManagerTree managerTree, AttributePanel attributePanel)
    {
        this.toolBox = toolBox;
        this.managerTree = managerTree;
        this.attributePanel = attributePanel;

        setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        setFocusable(true);
        requestFocusInWindow();

        setKeyBindings();
        setMouseListeners(this);

        revalidate();
        repaint();
    }

    public void onVerticalScrollEvent(int scroll)
    {
        vScroll = scroll;
    }

    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setStroke(new BasicStroke(1));
        drawHighlight(g2);
        drawBackgroundLines(g2);
        drawRectangleSelect(g2);
        drawKeyFrames(g2);
        drawPreviewKeyFrames(g2);
        drawTextHeader(g2);
        drawTimeIndicator(g2);
        drawPreviewTimeIndicator(g2);
        revalidate();
        repaint();
    }

    private void drawRectangleSelect(Graphics2D g)
    {
        if (!allowRectangleSelect)
        {
            return;
        }

        Point absoluteMouse = MouseInfo.getPointerInfo().getLocation();

        int x1 = (int) mousePointOnPressed.getX();
        int x2 = (int) (absoluteMouse.getX() - getLocationOnScreen().getX());
        int y1 = (int) mousePointOnPressed.getY();
        int y2 = (int) (absoluteMouse.getY() - getLocationOnScreen().getY());

        if (Math.abs(x1 - x2) < 10 && Math.abs(y1 - y2) < 10)
        {
            return;
        }

        int startX;
        int startY;
        int endX;
        int endY;

        if (x1 < x2)
        {
            startX = x1;
            endX = x2;
        }
        else
        {
            startX = x2;
            endX = x1;
        }

        if (y1 < y2)
        {
            startY = y1;
            endY = y2;
        }
        else
        {
            startY = y2;
            endY = y1;
        }

        int buffer = 1;

        if (startX < buffer)
        {
            startX = buffer;
        }

        if (endX > getWidth() - 2)
        {
            endX = getWidth() - 2;
        }

        if (startY < buffer)
        {
            startY = buffer;
        }

        if (endY > getHeight() - 2)
        {
            endY = getHeight() - 2;
        }

        g.setColor(new Color(93, 93, 93));
        Composite composite = g.getComposite();
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2F));
        g.fillRect(startX, startY, endX - startX, endY - startY);

        g.setColor(new Color(255, 255, 255));
        g.drawRect(startX, startY, endX - startX, endY - startY);
        g.setComposite(composite);
    }

    public void drawHighlight(Graphics g)
    {

    }

    private void drawBackgroundLines(Graphics g)
    {
        if (zoom <= SHOW_1_ZOOM)
        {
            g.setColor(ColorScheme.DARKER_GRAY_COLOR);

            double spacing = this.getWidth() / zoom;
            double startOffset = hScroll;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < zoom + firstIteration; i++)
            {
                g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());
            }
        }

        if (zoom <= SHOW_5_ZOOM)
        {
            g.setColor(ColorScheme.DARKER_GRAY_COLOR.darker());

            double iterations = zoom / 5;
            double spacing = this.getWidth() / iterations;
            double startOffset = hScroll / 5;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < iterations + firstIteration; i++)
            {
                g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());

            }
        }

        g.setColor(ColorScheme.BORDER_COLOR.darker());

        double iterations = zoom / 5;
        double spacing = this.getWidth() / iterations;
        double startOffset = hScroll / 5;
        int firstIteration = (int) Math.ceil(-1 * startOffset);
        boolean skip5Line = firstIteration % 2 != 0;

        for (int i = firstIteration; i < iterations + firstIteration; i++)
        {
            if (skip5Line)
            {
                skip5Line = false;
                continue;
            }

            g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());
            skip5Line = true;
        }
    }

    private void drawTimeIndicator(Graphics g)
    {
        double x = (currentTime + hScroll) * this.getWidth() / zoom;
        char[] c = ("" + currentTime).toCharArray();
        int width = g.getFontMetrics().charsWidth(c, 0, c.length);
        int textBuffer = 16;

        g.setColor(new Color(74, 121, 192));
        g.drawLine((int) x, 0, (int) x, this.getHeight());

        g.fillRoundRect((int) (x - (width + textBuffer) / 2), 0, width + textBuffer, ROW_HEIGHT, 10, 10);

        g.setColor(Color.WHITE);
        g.drawChars(c, 0, c.length, (int) (x - width / 2), ROW_HEIGHT - TEXT_HEIGHT_OFFSET);

    }

    private void drawPreviewTimeIndicator(Graphics g)
    {
        if (!timeIndicatorPressed)
        {
            return;
        }

        double x = (previewTime + hScroll) * this.getWidth() / zoom;
        char[] c = ("" + previewTime).toCharArray();
        int width = g.getFontMetrics().charsWidth(c, 0, c.length);
        int textBuffer = 16;

        g.setColor(new Color(49, 84, 128));
        g.drawLine((int) x, 0, (int) x, this.getHeight());

        g.fillRoundRect((int) (x - (width + textBuffer) / 2), 0, width + textBuffer, ROW_HEIGHT, 10, 10);

        g.setColor(Color.WHITE);
        g.drawChars(c, 0, c.length, (int) (x - width / 2), ROW_HEIGHT - TEXT_HEIGHT_OFFSET);

    }

    private void drawTextHeader(Graphics g)
    {
        g.setColor(Color.WHITE);

        if (zoom <= SHOW_1_ZOOM)
        {
            g.setColor(Color.WHITE.darker().darker());
            g.setFont(FontManager.getRunescapeSmallFont());
            FontMetrics fontMetrics = g.getFontMetrics();

            double spacing = this.getWidth() / zoom;
            double startOffset = hScroll;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < zoom + firstIteration; i++)
            {
                if (i % 5 == 0)
                {
                    continue;
                }

                char[] c = ("" + i).toCharArray();
                int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
                g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), ROW_HEIGHT - TEXT_HEIGHT_OFFSET);
            }
        }

        if (zoom <= SHOW_5_ZOOM)
        {
            g.setColor(Color.WHITE.darker());
            g.setFont(FontManager.getRunescapeSmallFont());
            FontMetrics fontMetrics = g.getFontMetrics();

            double iterations = zoom / 5;
            double spacing = this.getWidth() / iterations;
            double startOffset = hScroll / 5;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < iterations + firstIteration; i++)
            {
                int draw = i * 5;
                if (draw % 10 == 0)
                {
                    continue;
                }

                char[] c = ("" + draw).toCharArray();
                int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
                g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), ROW_HEIGHT - TEXT_HEIGHT_OFFSET);
            }
        }

        g.setColor(Color.WHITE);
        g.setFont(FontManager.getRunescapeFont());
        FontMetrics fontMetrics = g.getFontMetrics();

        double iterations = zoom / 10;
        double spacing = this.getWidth() / iterations;
        double startOffset = hScroll / 10;
        int firstIteration = (int) Math.ceil(-1 * startOffset);

        for (int i = firstIteration; i < iterations + firstIteration; i++)
        {
            char[] c = ("" + i * 10).toCharArray();
            int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
            g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), ROW_HEIGHT - TEXT_HEIGHT_OFFSET);
        }
    }

    public void drawKeyFrames(Graphics g)
    {

    }

    public void drawPreviewKeyFrames(Graphics2D g)
    {

    }

    private void setKeyBindings()
    {
        ActionMap actionMap = getActionMap();
        InputMap inputMap = getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), "VK_LEFT");
        actionMap.put("VK_LEFT", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                getTimeSheetPanel().setCurrentTime(currentTime - 0.1);
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), "VK_RIGHT");
        actionMap.put("VK_RIGHT", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                getTimeSheetPanel().setCurrentTime(currentTime + 0.1);
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0), "VK_DELETE");
        actionMap.put("VK_DELETE", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                if (selectedCharacter == null)
                {
                    return;
                }

                getTimeSheetPanel().removeKeyFrame(selectedCharacter, getTimeSheetPanel().getSelectedKeyFrames());
            }
        });
    }

    public void updateSelectedKeyFrameOnPressed(boolean shiftDown)
    {

    }

    private void setMouseListeners(TimeSheet timeSheet)
    {
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                super.mousePressed(e);
                requestFocusInWindow();

                if (e.getButton() != MouseEvent.BUTTON1)
                {
                    return;
                }

                Point mousePosition = getMousePosition();

                if (mousePosition.getY() < ROW_HEIGHT)
                {
                    timeIndicatorPressed = true;

                    TimeSheetPanel timeSheetPanel = getTimeSheetPanel();
                    double previewTime = getTimeIndicatorPosition();
                    timeSheetPanel.setPreviewTime(previewTime);
                }
                else
                {
                    allowRectangleSelect = true;
                    mousePointOnPressed = mousePosition;
                }

                clickedKeyFrames = getKeyFrameClicked(mousePosition);
                keyFrameClicked = clickedKeyFrames != null;
                if (keyFrameClicked)
                {
                    allowRectangleSelect = false;
                    updateSelectedKeyFrameOnPressed(e.isShiftDown());
                }
            }

            @Override
            public void mouseReleased(MouseEvent e)
            {
                super.mouseClicked(e);
                requestFocusInWindow();

                if (e.getButton() != MouseEvent.BUTTON1)
                {
                    return;
                }

                Point mousePosition = e.getPoint();
                TimeSheetPanel timeSheetPanel = getTimeSheetPanel();

                if (keyFrameClicked)
                {
                    if (mousePosition.distance(mousePointOnPressed) < 1)
                    {
                        updateSelectedKeyFrameOnRelease(mousePosition, e.isShiftDown());
                    }
                    else
                    {
                        KeyFrame[] keyFrames = getSelectedKeyFrames().clone();
                        for (KeyFrame keyFrame : keyFrames)
                        {
                            timeSheetPanel.removeKeyFrame(selectedCharacter, keyFrame);
                        }

                        double mouseX = Math.max(0, Math.min(mousePosition.getX(), getWidth()));
                        double change = (mouseX - mousePointOnPressed.getX()) * zoom / getWidth();

                        for (KeyFrame keyFrame : keyFrames)
                        {
                            keyFrame.setTick(round(keyFrame.getTick() + change));
                            timeSheetPanel.addKeyFrame(selectedCharacter, keyFrame);
                        }

                        setSelectedKeyFrames(keyFrames);
                    }

                    keyFrameClicked = false;
                    allowRectangleSelect = false;
                }
                else
                {
                    setSelectedKeyFrames(new KeyFrame[0]);
                }

                if (allowRectangleSelect)
                {
                    checkRectangleForKeyFrames(mousePosition, e.isShiftDown());
                    allowRectangleSelect = false;
                }

                if (timeIndicatorPressed)
                {
                    double time = getTimeIndicatorPosition();
                    timeSheetPanel.setCurrentTime(time);
                    timeIndicatorPressed = false;
                }

            }
        });

        addMouseMotionListener(new MouseAdapter()
        {
            @Override
            public void mouseDragged(MouseEvent e)
            {
                super.mouseDragged(e);
                requestFocusInWindow();

                TimeSheetPanel timeSheetPanel = getTimeSheetPanel();
                double previewTime = getTimeIndicatorPosition();
                timeSheetPanel.setPreviewTime(previewTime);


            }
        });

        addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                super.mouseWheelMoved(e);
                int amount = e.getWheelRotation();

                if (e.isAltDown())
                {
                    if (e.isControlDown() || e.isShiftDown())
                    {
                        return;
                    }

                    getTimeSheetPanel().onZoomEvent(amount, timeSheet);
                    return;
                }

                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    int currentRow = managerTree.getMinSelectionRow();
                    if (currentRow == -1)
                    {
                        managerTree.setSelectionRow(0);
                        return;
                    }

                    TreePath path = null;
                    int direction = e.getWheelRotation();
                    if (direction > 0)
                    {
                        while (path == null)
                        {
                            currentRow++;
                            if (currentRow >= managerTree.getRowCount())
                            {
                                currentRow = 0;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (direction < 0)
                    {
                        while (path == null)
                        {
                            currentRow--;
                            if (currentRow < 0)
                            {
                                currentRow = managerTree.getRowCount() - 1;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (path != null)
                    {
                        managerTree.setSelectionPath(path);
                    }
                    return;
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    getTimeSheetPanel().scrollAttributePanel(e.getWheelRotation());
                    return;
                }

                getTimeSheetPanel().onHorizontalScrollEvent(amount);
            }
        });
    }

    public KeyFrame[] getKeyFrameClicked(Point point)
    {
        return new KeyFrame[0];
    }

    public void updateSelectedKeyFrameOnRelease(Point point, boolean shiftKey)
    {

    }

    public void checkRectangleForKeyFrames(Point point, boolean shiftKey)
    {

    }

    private double getTimeIndicatorPosition()
    {
        double absoluteMouseX = MouseInfo.getPointerInfo().getLocation().getX();
        double x = absoluteMouseX - getLocationOnScreen().getX();

        double time = round(x / getWidth() * zoom - hScroll);

        if (time < -hScroll)
        {
            time = -hScroll;
        }

        double max = round(zoom - hScroll);
        if (time > max)
        {
            time = max;
        }

        return time;
    }

    public TimeSheetPanel getTimeSheetPanel()
    {
        return toolBox.getTimeSheetPanel();
    }


    public KeyFrame[] getSelectedKeyFrames()
    {
        return getTimeSheetPanel().getSelectedKeyFrames();
    }

    public void setSelectedKeyFrames(KeyFrame[] keyFrames)
    {
        getTimeSheetPanel().setSelectedKeyFrames(keyFrames);
    }
}

package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.Getter;
import lombok.Setter;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.Arrays;

import static com.creatorskit.swing.timesheet.TimeSheetPanel.round;

@Getter
@Setter
public class AttributeSheet extends TimeSheet
{
    private ManagerTree tree;
    private AttributePanel attributePanel;

    public AttributeSheet(ToolBoxFrame toolBox, ManagerTree tree, AttributePanel attributePanel)
    {
        super(toolBox, tree, attributePanel);
        this.tree = tree;
        this.attributePanel = attributePanel;

        setIndexBuffers(0);
        setSelectedIndex(1);
    }

    @Override
    public void drawHighlight(Graphics g)
    {
        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, (getSelectedIndex() + getIndexBuffers()) * ROW_HEIGHT + ROW_HEIGHT_OFFSET - getVScroll(), this.getWidth(), ROW_HEIGHT);
    }

    @Override
    public void drawKeyFrames(Graphics g)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame frame = keyFrames[e];

                BufferedImage endImage = image;
                KeyFrame[] selectedKeyframes = getTimeSheetPanel().getSelectedKeyFrames();
                if (Arrays.stream(selectedKeyframes).anyMatch(s -> s == frame))
                {
                    endImage = getKeyframeSelected();
                }

                g.drawImage(
                        endImage,
                        (int) ((frame.getTick() + getHScroll()) * zoomFactor - xImageOffset),
                        ROW_HEIGHT_OFFSET + ROW_HEIGHT + ROW_HEIGHT * i - yImageOffset,
                        null);
            }
        }
    }

    @Override
    public void drawPreviewKeyFrames(Graphics2D g)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        if (!isKeyFrameClicked())
        {
            return;
        }

        KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
        if (selectedKeyFrames.length == 0)
        {
            return;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        BufferedImage bufferedImage = getKeyframeImage();
        Composite composite = g.getComposite();
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2F));

        double x = MouseInfo.getPointerInfo().getLocation().getX() - getLocationOnScreen().getX();
        double mouseX = Math.max(0, Math.min(x, getWidth()));
        double change = round((mouseX - getMousePointOnPressed().getX()) * getZoom() / getWidth());


        for (int e = 0; e < selectedKeyFrames.length; e++)
        {
            KeyFrame frame = selectedKeyFrames[e];
            int i = KeyFrameType.getIndex(frame.getKeyFrameType());

            g.drawImage(
                    bufferedImage,
                    (int) ((frame.getTick() + getHScroll() + change) * zoomFactor - xImageOffset),
                    ROW_HEIGHT_OFFSET + ROW_HEIGHT + ROW_HEIGHT * i - yImageOffset,
                    null);
        }

        g.setComposite(composite);
    }

    @Override
    public void updateSelectedKeyFrameOnPressed(boolean shiftDown)
    {
        KeyFrame[] clickedKeyFrames = getClickedKeyFrames();
        if (clickedKeyFrames.length == 0)
        {
            return;
        }

        KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
        KeyFrame clickedKeyFrame = clickedKeyFrames[0];
        if (Arrays.stream(selectedKeyFrames).noneMatch(n -> n == clickedKeyFrame))
        {
            if (shiftDown)
            {
                setSelectedKeyFrames(ArrayUtils.add(selectedKeyFrames, clickedKeyFrame));
            }
            else
            {
                setSelectedKeyFrames(new KeyFrame[]{clickedKeyFrame});
            }
        }
    }

    @Override
    public KeyFrame[] getKeyFrameClicked(Point point)
    {
        if (getSelectedCharacter() == null)
        {
            return null;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = ROW_HEIGHT_OFFSET + ROW_HEIGHT + ROW_HEIGHT * i - yImageOffset;
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        return new KeyFrame[]{keyFrame};
                    }
                }
            }
        }

        return null;
    }

    @Override
    public void updateSelectedKeyFrameOnRelease(Point point, boolean shiftKey)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        boolean foundFrame = false;
        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = ROW_HEIGHT_OFFSET + ROW_HEIGHT + ROW_HEIGHT * i - yImageOffset;
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        if (shiftKey)
                        {
                            KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
                            boolean alreadyContains = false;

                            for (KeyFrame kf : selectedKeyFrames)
                            {
                                if (kf == keyFrame)
                                {
                                    alreadyContains = true;
                                    break;
                                }
                            }

                            if (!alreadyContains)
                            {
                                setSelectedKeyFrames(ArrayUtils.add(getSelectedKeyFrames(), keyFrame));
                            }
                        }
                        else
                        {
                            setSelectedKeyFrames(new KeyFrame[]{keyFrame});
                        }

                        foundFrame = true;
                        break;
                    }
                }
            }

            if (foundFrame)
            {
                break;
            }
        }

        if (!foundFrame && !shiftKey)
        {
            setSelectedKeyFrames(new KeyFrame[0]);
        }
    }

    @Override
    public void checkRectangleForKeyFrames(Point point, boolean shiftKey)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        if (!isAllowRectangleSelect())
        {
            return;
        }

        Point absoluteMouse = MouseInfo.getPointerInfo().getLocation();
        Point rectangleSelectStart = getMousePointOnPressed();

        int x1 = (int) rectangleSelectStart.getX();
        int x2 = (int) (absoluteMouse.getX() - getLocationOnScreen().getX());
        int y1 = (int) rectangleSelectStart.getY();
        int y2 = (int) (absoluteMouse.getY() - getLocationOnScreen().getY());

        if (Math.abs(x1 - x2) < 10 && Math.abs(y1 - y2) < 10)
        {
            return;
        }

        int startX;
        int startY;
        int endX;
        int endY;

        if (x1 < x2)
        {
            startX = x1;
            endX = x2;
        }
        else
        {
            startX = x2;
            endX = x1;
        }

        if (y1 < y2)
        {
            startY = y1;
            endY = y2;
        }
        else
        {
            startY = y2;
            endY = y1;
        }

        int buffer = 1;

        if (startX < buffer)
        {
            startX = buffer;
        }

        if (endX > getWidth() - 2)
        {
            endX = getWidth() - 2;
        }

        if (startY < buffer)
        {
            startY = buffer;
        }

        if (endY > getHeight() - 2)
        {
            endY = getHeight() - 2;
        }

        Rectangle2D rectangle = new Rectangle(startX, startY, endX - startX, endY - startY);

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - ROW_HEIGHT) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[] foundKeyFrames = new KeyFrame[0];
        if (shiftKey)
        {
            foundKeyFrames = getSelectedKeyFrames();
        }

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                boolean alreadyContains = false;

                for (KeyFrame kf : foundKeyFrames)
                {
                    if (keyFrame == kf)
                    {
                        alreadyContains = true;
                        break;
                    }
                }

                if (alreadyContains)
                {
                    continue;
                }

                int kx1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int ky1 = ROW_HEIGHT_OFFSET + ROW_HEIGHT + ROW_HEIGHT * i - yImageOffset;

                Rectangle2D frameRect = new Rectangle(kx1, ky1, image.getWidth(), image.getHeight());

                if (rectangle.intersects(frameRect))
                {
                    foundKeyFrames = ArrayUtils.add(foundKeyFrames, keyFrame);
                }
            }
        }

        setSelectedKeyFrames(foundKeyFrames);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.HealthKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatType;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class HealthAttributes extends Attributes
{
    private final JComboBox<Toggle> enableBox = new JComboBox<>();
    private final JComboBox<HitsplatType> hitsplatType = new JComboBox<>();
    private final JSpinner hitsplatHeight = new JSpinner();
    private final JSpinner maxHealth = new JSpinner();
    private final JSpinner currentHealth = new JSpinner();
    private final JSpinner healthbarHeight = new JSpinner();

    public HealthAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        HealthKeyFrame kf = (HealthKeyFrame) keyFrame;
        enableBox.setSelectedItem(kf.isEnabled() ? Toggle.ENABLE : Toggle.DISABLE);
        hitsplatType.setSelectedItem(kf.getHitsplatType());
        hitsplatHeight.setValue(kf.getHitsplatHeight());
        maxHealth.setValue(kf.getMaxHealth());
        currentHealth.setValue(kf.getCurrentHealth());
        healthbarHeight.setValue(kf.getHealthbarHeight());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        enableBox.setBackground(color);
        hitsplatType.setBackground(color);
        hitsplatHeight.setBackground(color);
        maxHealth.setBackground(color);
        currentHealth.setBackground(color);
        healthbarHeight.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        enableBox,
                        hitsplatType,
                        hitsplatHeight,
                        maxHealth,
                        currentHealth,
                        healthbarHeight
                };
    }

    @Override
    public void addChangeListeners()
    {
        enableBox.addItemListener(e ->
        {
            enableBox.setBackground(getRed());
        });

        hitsplatType.addItemListener(e ->
        {
            hitsplatType.setBackground(getRed());
        });

        hitsplatHeight.addChangeListener(e ->
        {
            hitsplatHeight.setBackground(getRed());
        });

        maxHealth.addChangeListener(e ->
        {
            maxHealth.setBackground(getRed());
        });

        currentHealth.addChangeListener(e ->
        {
            currentHealth.setBackground(getRed());
        });

        healthbarHeight.addChangeListener(e ->
        {
            healthbarHeight.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        enableBox.setSelectedItem(Toggle.DISABLE);
        hitsplatType.setSelectedItem(HitsplatType.DAMAGE);
        hitsplatHeight.setValue(30);
        maxHealth.setValue(99);
        currentHealth.setValue(99);
        healthbarHeight.setValue(60);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.OverheadKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;
import net.runelite.api.HeadIcon;

import javax.swing.*;
import java.awt.*;

@Getter
public class OverheadAttributes extends Attributes
{
    private final JComboBox<Toggle> enableBox = new JComboBox<>();
    private final JComboBox<HeadIcon> headIcon = new JComboBox<>();
    private final JSpinner height = new JSpinner();

    public OverheadAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        OverheadKeyFrame kf = (OverheadKeyFrame) keyFrame;
        enableBox.setSelectedItem(kf.isEnabled() ? Toggle.ENABLE : Toggle.DISABLE);
        headIcon.setSelectedItem(kf.getHeadIcon());
        height.setValue(kf.getHeight());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        enableBox.setBackground(color);
        headIcon.setBackground(color);
        height.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        enableBox,
                        headIcon,
                        height
                };
    }

    @Override
    public void addChangeListeners()
    {
        enableBox.addItemListener(e ->
        {
            enableBox.setBackground(getRed());
        });

        headIcon.addItemListener(e ->
        {
            headIcon.setBackground(getRed());
        });

        height.addChangeListener(e ->
        {
            height.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        enableBox.setSelectedItem(Toggle.DISABLE);
        headIcon.setSelectedItem(HeadIcon.MAGIC);
        height.setValue(60);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.SpawnKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class SpawnAttributes extends Attributes
{
    private final JComboBox<Toggle> spawn = new JComboBox<>();

    public SpawnAttributes()
    {
        addChangeListeners();
        spawn.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        SpawnKeyFrame kf = (SpawnKeyFrame) keyFrame;
        spawn.setSelectedItem(kf.isSpawnActive() ? Toggle.ENABLE : Toggle.DISABLE);
    }

    @Override
    public void setBackgroundColours(Color color)
    {
       spawn.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        spawn
                };
    }

    @Override
    public void addChangeListeners()
    {
        spawn.addItemListener(e ->
        {
            spawn.setBackground(getRed().brighter());
        });
    }

    @Override
    public void resetAttributes()
    {
        spawn.setSelectedItem(Toggle.ENABLE);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.MovementKeyFrame;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class MovementAttributes extends Attributes
{
    public void setAttributes(MovementKeyFrame kf)
    {

    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.OrientationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.OrientationToggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class OriAttributes extends Attributes
{
    private final JSpinner manual = new JSpinner();
    private final JComboBox<OrientationToggle> manualOverride = new JComboBox<>();

    public OriAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        OrientationKeyFrame kf = (OrientationKeyFrame) keyFrame;
        manual.setValue(kf.getManualOrientation());
        manualOverride.setSelectedItem(kf.isManualOverride() ? OrientationToggle.MANUAL_ORIENTATION : OrientationToggle.SMART_ORIENTATION);
    }

    public void setBackgroundColours(Color color)
    {
        manual.setBackground(color);
        manualOverride.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        manual,
                        manualOverride
                };
    }

    @Override
    public void addChangeListeners()
    {
        manual.addChangeListener(e ->
        {
            manual.setBackground(getRed());
        });

        manualOverride.addItemListener(e ->
        {
            manualOverride.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        manual.setValue(0);
        manualOverride.setSelectedItem(OrientationToggle.SMART_ORIENTATION);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.models.CustomModel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.ModelKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.ModelToggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class ModelAttributes extends Attributes
{
    private final JSpinner modelId = new JSpinner();
    private final JComboBox<ModelToggle> modelOverride = new JComboBox<>();
    private final JComboBox<CustomModel> customModel = new JComboBox<>();

    public ModelAttributes()
    {
        addChangeListeners();
        modelOverride.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        ModelKeyFrame kf = (ModelKeyFrame) keyFrame;
        modelId.setValue(kf.getModelId());
        modelOverride.setSelectedItem(kf.isUseCustomModel() ? ModelToggle.CUSTOM_MODEL : ModelToggle.MODEL_ID);
        customModel.setSelectedItem(kf.getCustomModel());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        modelId.setBackground(color);
        modelOverride.setBackground(color);
        customModel.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        modelId,
                        modelOverride,
                        customModel
                };
    }

    @Override
    public void addChangeListeners()
    {
        modelId.addChangeListener(e ->
        {
            modelId.setBackground(getRed());
        });

        modelOverride.addItemListener(e ->
        {
            modelOverride.setBackground(getRed());
        });

        customModel.addItemListener(e ->
        {
            customModel.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        modelId.setValue(-1);
        modelOverride.setSelectedItem(ModelToggle.MODEL_ID);
        customModel.setSelectedItem(null);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

@Getter
public class Attributes
{
    private final Color green = new Color(42, 77, 26);
    private final Color yellow = new Color(91, 80, 29);
    private final Color red = new Color(101, 66, 29);

    public void setAttributes(KeyFrame kf)
    {

    }

    public void setBackgroundColours(KeyFrameState keyFrameState)
    {
        Color color;

        switch (keyFrameState)
        {
            default:
            case EMPTY:
                color = ColorScheme.DARKER_GRAY_COLOR;
                break;
            case ON_KEYFRAME:
                color = getYellow();
                break;
            case OFF_KEYFRAME:
                color = getGreen();
        }

        setBackgroundColours(color);
    }

    public void setBackgroundColours(Color color)
    {

    }

    public JComponent[] getAllComponents()
    {
        return new JComponent[0];
    }

    public void addChangeListeners()
    {

    }

    public void resetAttributes()
    {

    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.settings.AnimationToggle;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

@Getter
public class AnimAttributes extends Attributes
{
    private final JSpinner manual = new JSpinner();
    private final JComboBox<AnimationToggle> manualOverride = new JComboBox<>();

    private final JSpinner idle = new JSpinner();
    private final JSpinner walk = new JSpinner();
    private final JSpinner run = new JSpinner();
    private final JSpinner walk180 = new JSpinner();
    private final JSpinner walkRight = new JSpinner();
    private final JSpinner walkLeft = new JSpinner();
    private final JSpinner idleRight = new JSpinner();
    private final JSpinner idleLeft = new JSpinner();

    public AnimAttributes()
    {
        addChangeListeners();
        manualOverride.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        AnimationKeyFrame kf = (AnimationKeyFrame) keyFrame;
        manual.setValue(kf.getManualAnim());
        manualOverride.setSelectedItem(kf.isManualOverride() ? AnimationToggle.MANUAL_ANIMATION : AnimationToggle.SMART_ANIMATION);
        idle.setValue(kf.getIdleAnim());
        walk.setValue(kf.getWalkAnim());
        run.setValue(kf.getRunAnim());
        walk180.setValue(kf.getWalk180Anim());
        walkRight.setValue(kf.getWalkRAnim());
        walkLeft.setValue(kf.getWalkLAnim());
        idleRight.setValue(kf.getIdleRAnim());
        idleLeft.setValue(kf.getIdleLAnim());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        manual.setBackground(color);
        manualOverride.setBackground(color);
        idle.setBackground(color);
        walk.setBackground(color);
        run.setBackground(color);
        walk180.setBackground(color);
        walkRight.setBackground(color);
        walkLeft.setBackground(color);
        idleRight.setBackground(color);
        idleLeft.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        manual,
                        manualOverride,
                        idle,
                        walk,
                        run,
                        walk180,
                        walkRight,
                        walkLeft,
                        idleRight,
                        idleLeft
                };
    }

    @Override
    public void addChangeListeners()
    {
        manual.addChangeListener(e ->
        {
            manual.setBackground(getRed());
        });

        manualOverride.addItemListener(e ->
        {
            manualOverride.setBackground(getRed());
        });

        idle.addChangeListener(e ->
        {
            idle.setBackground(getRed());
        });

        walk.addChangeListener(e ->
        {
            walk.setBackground(getRed());
        });

        run.addChangeListener(e ->
        {
            run.setBackground(getRed());
        });

        walk180.addChangeListener(e ->
        {
            walk180.setBackground(getRed());
        });

        walkRight.addChangeListener(e ->
        {
            walkRight.setBackground(getRed());
        });

        walkLeft.addChangeListener(e ->
        {
            walkLeft.setBackground(getRed());
        });

        idleRight.addChangeListener(e ->
        {
            idleRight.setBackground(getRed());
        });

        idleLeft.addChangeListener(e ->
        {
            idleLeft.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        manual.setValue(-1);
        manualOverride.setSelectedItem(AnimationToggle.SMART_ANIMATION);
        idle.setValue(-1);
        walk.setValue(-1);
        run.setValue(-1);
        walk180.setValue(-1);
        walkRight.setValue(-1);
        walkLeft.setValue(-1);
        idleRight.setValue(-1);
        idleLeft.setValue(-1);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.TextKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;

@Getter
public class TextAttributes extends Attributes
{
    private final JComboBox<Toggle> enableBox = new JComboBox<>();
    private final JTextArea text = new JTextArea("");
    private final JSpinner height = new JSpinner();

    public TextAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        TextKeyFrame kf = (TextKeyFrame) keyFrame;
        enableBox.setSelectedItem(kf.isEnabled() ? Toggle.ENABLE : Toggle.DISABLE);
        text.setText(kf.getText());
        height.setValue(kf.getHeight());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        enableBox.setBackground(color);
        text.setBackground(color);
        height.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        enableBox,
                        text,
                        height
                };
    }

    @Override
    public void addChangeListeners()
    {
        enableBox.addItemListener(e ->
        {
            enableBox.setBackground(getRed());
        });

        text.getDocument().addDocumentListener(new DocumentListener() {

            @Override
            public void removeUpdate(DocumentEvent e) {
                text.setBackground(getRed());
            }

            @Override
            public void insertUpdate(DocumentEvent e) {
                text.setBackground(getRed());
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {

            }
        });

        height.addChangeListener(e ->
        {
            height.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        enableBox.setSelectedItem(Toggle.DISABLE);
        text.setText("");
        height.setValue(60);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.SpotAnimKeyFrame;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class SpotAnimAttributes extends Attributes
{
    private final JSpinner spotAnimId1 = new JSpinner();
    private final JSpinner spotAnimId2 = new JSpinner();

    public SpotAnimAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        SpotAnimKeyFrame kf = (SpotAnimKeyFrame) keyFrame;
        spotAnimId1.setValue(kf.getSpotAnimId1());
        spotAnimId2.setValue(kf.getSpotAnimId2());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        spotAnimId1.setBackground(color);
        spotAnimId2.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        spotAnimId1,
                        spotAnimId2
                };
    }

    @Override
    public void addChangeListeners()
    {
        spotAnimId1.addChangeListener(e ->
        {
            spotAnimId1.setBackground(getRed());
        });

        spotAnimId2.addChangeListener(e ->
        {
            spotAnimId2.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes()
    {
        spotAnimId1.setValue(-1);
        spotAnimId2.setValue(-1);
        setBackgroundColours(KeyFrameState.EMPTY);
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SpawnKeyFrame extends KeyFrame
{
    private boolean spawnActive;

    public SpawnKeyFrame(double tick, boolean spawnActive)
    {
        super(KeyFrameType.SPAWN, tick);
        this.spawnActive = spawnActive;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class AnimationKeyFrame extends KeyFrame
{
    private int manualAnim;
    private boolean manualOverride;
    private int idleAnim;
    private int walkAnim;
    private int runAnim;
    private int walk180Anim;
    private int walkRAnim;
    private int walkLAnim;
    private int idleRAnim;
    private int idleLAnim;

    public AnimationKeyFrame(double tick, int manualAnim, boolean manualOverride, int idleAnim, int walkAnim, int runAnim, int walk180Anim, int walkRAnim, int walkLAnim, int idleRAnim, int idleLAnim)
    {
        super(KeyFrameType.ANIMATION, tick);
        this.manualAnim = manualAnim;
        this.manualOverride = manualOverride;
        this.idleAnim = idleAnim;
        this.walkAnim = walkAnim;
        this.runAnim = runAnim;
        this.walk180Anim = walk180Anim;
        this.walkRAnim = walkRAnim;
        this.walkLAnim = walkLAnim;
        this.idleRAnim = idleRAnim;
        this.idleLAnim = idleLAnim;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class KeyFrame
{
    private KeyFrameType keyFrameType;
    private double tick;

    public KeyFrame createCopy(KeyFrame keyFrame, double tick)
    {
        if (keyFrame instanceof MovementKeyFrame)
        {
            MovementKeyFrame kf = (MovementKeyFrame) keyFrame;
            return new MovementKeyFrame(tick);
        }

        if (keyFrame instanceof AnimationKeyFrame)
        {
            AnimationKeyFrame kf = (AnimationKeyFrame) keyFrame;
            return new AnimationKeyFrame(
                    tick,
                    kf.getManualAnim(),
                    kf.isManualOverride(),
                    kf.getIdleAnim(),
                    kf.getWalkAnim(),
                    kf.getRunAnim(),
                    kf.getWalk180Anim(),
                    kf.getWalkRAnim(),
                    kf.getWalkLAnim(),
                    kf.getIdleRAnim(),
                    kf.getIdleLAnim());
        }

        if (keyFrame instanceof OrientationKeyFrame)
        {
            OrientationKeyFrame kf = (OrientationKeyFrame) keyFrame;
            return new OrientationKeyFrame(
                    tick,
                    kf.getManualOrientation(),
                    kf.isManualOverride());
        }

        if (keyFrame instanceof SpawnKeyFrame)
        {
            SpawnKeyFrame kf = (SpawnKeyFrame) keyFrame;
            return new SpawnKeyFrame(
                    tick,
                    kf.isSpawnActive());
        }

        if (keyFrame instanceof ModelKeyFrame)
        {
            ModelKeyFrame kf = (ModelKeyFrame) keyFrame;
            return new ModelKeyFrame(
                    tick,
                    kf.isUseCustomModel(),
                    kf.getModelId(),
                    kf.getCustomModel());
        }

        if (keyFrame instanceof TextKeyFrame)
        {
            TextKeyFrame kf = (TextKeyFrame) keyFrame;
            return new TextKeyFrame(
                    tick,
                    kf.isEnabled(),
                    kf.getText(),
                    kf.getHeight());
        }

        if (keyFrame instanceof OverheadKeyFrame)
        {
            OverheadKeyFrame kf = (OverheadKeyFrame) keyFrame;
            return new OverheadKeyFrame(
                    tick,
                    kf.isEnabled(),
                    kf.getHeadIcon(),
                    kf.getHeight());
        }

        if (keyFrame instanceof HealthKeyFrame)
        {
            HealthKeyFrame kf = (HealthKeyFrame) keyFrame;
            return new HealthKeyFrame(
                    tick,
                    kf.isEnabled(),
                    kf.getHitsplatType(),
                    kf.getHitsplatHeight(),
                    kf.getMaxHealth(),
                    kf.getCurrentHealth(),
                    kf.getHealthbarHeight());
        }

        if (keyFrame instanceof SpotAnimKeyFrame)
        {
            SpotAnimKeyFrame kf = (SpotAnimKeyFrame) keyFrame;
            return new SpotAnimKeyFrame(
                    tick,
                    kf.getSpotAnimId1(),
                    kf.getSpotAnimId2());
        }

        return null;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.HeadIcon;

@Getter
@Setter
public class OverheadKeyFrame extends KeyFrame
{
    private boolean enabled;
    private HeadIcon headIcon;
    private int height;

    public OverheadKeyFrame(double tick, boolean enabled, HeadIcon headIcon, int height)
    {
        super(KeyFrameType.OVERHEAD, tick);
        this.enabled = enabled;
        this.headIcon = headIcon;
        this.height = height;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class OrientationKeyFrame extends KeyFrame
{
    private int manualOrientation;
    private boolean manualOverride;

    public OrientationKeyFrame(double tick, int manualOrientation, boolean manualOverride)
    {
        super(KeyFrameType.ORIENTATION, tick);
        this.manualOrientation = manualOrientation;
        this.manualOverride = manualOverride;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SpotAnimKeyFrame extends KeyFrame
{
    private int spotAnimId1;
    private int spotAnimId2;

    public SpotAnimKeyFrame(double tick, int spotAnimId1, int spotAnimId2)
    {
        super(KeyFrameType.SPOTANIM, tick);
        this.spotAnimId1 = spotAnimId1;
        this.spotAnimId2 = spotAnimId2;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MovementKeyFrame extends KeyFrame
{
    public MovementKeyFrame(double tick)
    {
        super(KeyFrameType.MOVEMENT, tick);
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum KeyFrameType
{
    NULL("Null"),
    SUMMARY("Summary"),
    MOVEMENT("Movement"),
    ANIMATION("Animation"),
    SPAWN("Spawn"),
    MODEL("Model"),
    ORIENTATION("Orientation"),
    TEXT("Text"),
    OVERHEAD("Overhead"),
    HEALTH("Healtht"),
    SPOTANIM("SpotAnim");

    private String name;

    public String toString()
    {
        return name;
    }

    public static int getIndex(KeyFrameType type)
    {
        switch (type)
        {
            default:
            case MOVEMENT:
                return 0;
            case ANIMATION:
                return 1;
            case ORIENTATION:
                return 2;
            case SPAWN:
                return 3;
            case MODEL:
                return 4;
            case TEXT:
                return 5;
            case OVERHEAD:
                return 6;
            case HEALTH:
                return 7;
            case SPOTANIM:
                return 8;
        }
    }

    public static KeyFrameType getKeyFrameType(int index)
    {
        switch (index)
        {
            default:
            case 0:
                return MOVEMENT;
            case 1:
                return ANIMATION;
            case 2:
                return ORIENTATION;
            case 3:
                return SPAWN;
            case 4:
                return MODEL;
            case 5:
                return TEXT;
            case 6:
                return OVERHEAD;
            case 7:
                return HEALTH;
            case 8:
                return SPOTANIM;
        }
    }

    public static int getTotalFrameTypes()
    {
        return 9;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum OrientationToggle
{
    SMART_ORIENTATION("Smart Orientation"),
    MANUAL_ORIENTATION("Manual Orientation")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Toggle
{
    ENABLE("Enable"),
    DISABLE("Disable")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ModelToggle
{
    MODEL_ID("Use Model Id"),
    CUSTOM_MODEL("Use Custom Model")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;
import net.runelite.api.HitsplatID;

@AllArgsConstructor
public enum HitsplatType
{
    DAMAGE("Damage", HitsplatID.DAMAGE_ME),
    BLOCK("Block", HitsplatID.BLOCK_ME)
    ;

    private final String name;
    private final int hitsplatID;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum AnimationToggle
{
    SMART_ANIMATION("Smart Animation"),
    MANUAL_ANIMATION("Manual Animation")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatType;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class HealthKeyFrame extends KeyFrame
{
    private boolean enabled;
    private HitsplatType hitsplatType;
    private int hitsplatHeight;
    private int maxHealth;
    private int currentHealth;
    private int healthbarHeight;

    public HealthKeyFrame(double tick, boolean enabled, HitsplatType hitsplatType, int hitsplatHeight, int maxHealth, int currentHealth, int healthbarHeight)
    {
        super(KeyFrameType.HEALTH, tick);
        this.enabled = enabled;
        this.hitsplatType = hitsplatType;
        this.hitsplatHeight = hitsplatHeight;
        this.maxHealth = maxHealth;
        this.currentHealth = currentHealth;
        this.healthbarHeight = healthbarHeight;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

public enum KeyFrameState
{
    EMPTY,
    ON_KEYFRAME,
    OFF_KEYFRAME
}

package com.creatorskit.swing.timesheet.keyframe;


import com.creatorskit.models.CustomModel;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ModelKeyFrame extends KeyFrame
{
    private boolean useCustomModel;
    private int modelId;
    private CustomModel customModel;

    public ModelKeyFrame(double tick, boolean useCustomModel, int modelId, CustomModel customModel)
    {
        super(KeyFrameType.MODEL, tick);
        this.useCustomModel = useCustomModel;
        this.modelId = modelId;
        this.customModel = customModel;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TextKeyFrame extends KeyFrame
{
    private boolean enabled;
    private String text;
    private int height;

    public TextKeyFrame(double tick, boolean enabled, String text, int height)
    {
        super(KeyFrameType.TEXT, tick);
        this.enabled = enabled;
        this.text = text;
        this.height = height;
    }
}

package com.creatorskit.swing.timesheet;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.DataFinder;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.manager.TreeScrollPane;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.sheets.AttributeSheet;
import com.creatorskit.swing.timesheet.sheets.SummarySheet;
import com.creatorskit.swing.timesheet.sheets.TimeSheet;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.util.ArrayList;

@Getter
@Setter
public class TimeSheetPanel extends JPanel
{
    private Client client;
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final GridBagConstraints c = new GridBagConstraints();
    private final ToolBoxFrame toolBox;
    private final DataFinder dataFinder;
    private SummarySheet summarySheet;
    private AttributeSheet attributeSheet;
    private TreeScrollPane treeScrollPane;
    private final ManagerTree managerTree;
    private final JComboBox<KeyFrameType> summaryComboBox = new JComboBox<>();
    private final JScrollBar scrollBar;
    private AttributePanel attributePanel;
    private final JPanel labelPanel = new JPanel();
    private final JPanel controlPanel = new JPanel();
    private final JSpinner timeSpinner = new JSpinner();
    private final ImageIcon PLAY = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Play.png"));
    private final ImageIcon STOP = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Stop.png"));
    private final ImageIcon PAUSE = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Pause.png"));
    private final BufferedImage SKIP_LEFT = ImageUtil.loadImageResource(getClass(), "/Skip_Left.png");
    private final BufferedImage SKIP_RIGHT = ImageUtil.loadImageResource(getClass(), "/Skip_Right.png");

    private static final int ROW_HEIGHT = 24;
    private static final int INDEX_BUFFER = 20;
    private static final int ABSOLUTE_MAX_SEQUENCE_LENGTH = 100000;
    private static final int DEFAULT_MIN_H_SCROLL = -10;
    private static final int DEFAULT_MAX_H_SCROLL = 200;
    private static final int ZOOM_MAX = 500;
    private static final int ZOOM_MIN = 5;

    private final String MOVE_CARD = "Movement";
    private final String ANIM_CARD = "Animation";
    private final String ORI_CARD = "Orientation";
    private final String SPAWN_CARD = "Spawn";
    private final String MODEL_CARD = "Model";
    private final String TEXT_CARD = "Text";
    private final String OVER_CARD = "Overhead";
    private final String HEALTH_CARD = "Health";
    private final String SPOTANIM_CARD = "SpotAnim";
    private final String LABEL_OFFSET = "  ";
    private JLabel[] labels = new JLabel[0];

    private double zoom = 50;
    private double hScroll = 0;
    private int vScroll = 0;
    private double maxHScroll = 200;
    private double minHScroll = -10;

    private double currentTime = 0;
    private boolean playActive = false;
    private boolean pauseScrollBarListener = false;
    private Character selectedCharacter;
    private KeyFrameType summaryKeyFrameType = KeyFrameType.SUMMARY;

    private KeyFrame[] selectedKeyFrames = new KeyFrame[0];
    private KeyFrame[] copiedKeyFrames = new KeyFrame[0];

    @Inject
    public TimeSheetPanel(@Nullable Client client, ToolBoxFrame toolBox, CreatorsPlugin plugin, ClientThread clientThread, DataFinder dataFinder, ManagerTree managerTree, JScrollBar scrollBar)
    {
        this.client = client;
        this.toolBox = toolBox;
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.dataFinder = dataFinder;
        this.managerTree = managerTree;
        this.scrollBar = scrollBar;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupSummaryComboBox();
        setupTreeScrollPane();
        setupControlPanel();
        setupAttributePanel();
        setupAttributeSheet();
        setupScrollBar();
        setupTimeTreeListener();
        setupManager();
        setKeyBindings();
        setMouseListeners();
    }

    public void onSummarySkipForward()
    {
        
    }

    public void onSummarySkipPrevious()
    {

    }

    public void onAttributeSkipForward()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findNextKeyFrame(currentTime);
        if (keyFrame == null)
        {
            return;
        }

        setCurrentTime(keyFrame.getTick());
    }

    public void onAttributeSkipPrevious()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findPreviousKeyFrame(currentTime);
        if (keyFrame == null)
        {
            return;
        }

        setCurrentTime(keyFrame.getTick());
    }

    public void onZoomEvent(int amount, TimeSheet source)
    {
        double x = source.getMousePosition(true).getX();
        double change = zoom;
        zoom += 5 * amount;
        if (zoom < ZOOM_MIN)
            zoom = ZOOM_MIN;

        if (zoom > ZOOM_MAX)
            zoom = ZOOM_MAX;

        change -= zoom;
        hScroll = round(hScroll - change * (x / source.getWidth()));
        if (hScroll < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (hScroll > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        boundSliderMinMax();
        updateScrollBar();
        updateSheets();
    }

    public void onHorizontalScrollEvent(double amount)
    {
        hScroll = round(hScroll - amount * zoom / 50);
        if (hScroll < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (hScroll > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        boundSliderMinMax();
        updateScrollBar();
        updateSheets();
    }

    private void boundSliderMinMax()
    {
        if (-hScroll < minHScroll)
        {
            minHScroll = -hScroll;
        }

        if (-hScroll > minHScroll)
        {
            KeyFrame firstKeyFrame = getFirstKeyFrame();
            if (firstKeyFrame == null)
            {
                minHScroll = -hScroll;
            }

            if (firstKeyFrame != null)
            {
                double firstTick = firstKeyFrame.getTick();
                minHScroll = Math.min(-hScroll, firstTick);
            }

            if (minHScroll > DEFAULT_MIN_H_SCROLL)
            {
                minHScroll = DEFAULT_MIN_H_SCROLL;
            }
        }

        double maxVisibleValue = round(zoom - hScroll);
        if (maxVisibleValue > maxHScroll)
        {
            maxHScroll = maxVisibleValue;
        }

        if (maxVisibleValue < maxHScroll)
        {
            KeyFrame lastKeyFrame = getLastKeyFrame();
            if (lastKeyFrame == null)
            {
                maxHScroll = maxVisibleValue;
            }

            if (lastKeyFrame != null)
            {
                double lastTick = lastKeyFrame.getTick();
                maxHScroll = Math.max(maxVisibleValue, lastTick);
            }

            if (maxHScroll < DEFAULT_MAX_H_SCROLL)
            {
                maxHScroll = DEFAULT_MAX_H_SCROLL;
            }
        }
    }

    private KeyFrame getLastKeyFrame()
    {
        ArrayList<Character> characters = plugin.getCharacters();
        if (characters.isEmpty())
        {
            return null;
        }

        KeyFrame lastKeyFrame = null;
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            KeyFrame comparison = character.findLastKeyFrame();
            if (lastKeyFrame == null)
            {
                if (comparison != null)
                {
                    lastKeyFrame = comparison;
                    continue;
                }
            }

            if (comparison == null)
            {
                continue;
            }

            if (comparison.getTick() > lastKeyFrame.getTick())
            {
                lastKeyFrame = comparison;
            }
        }

        return lastKeyFrame;
    }

    private KeyFrame getFirstKeyFrame()
    {
        ArrayList<Character> characters = plugin.getCharacters();
        if (characters.isEmpty())
        {
            return null;
        }

        KeyFrame firstKeyFrame = null;
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            KeyFrame comparison = character.findFirstKeyFrame();
            if (firstKeyFrame == null)
            {
                if (comparison != null)
                {
                    firstKeyFrame = comparison;
                    continue;
                }
            }

            if (comparison == null)
            {
                continue;
            }

            if (comparison.getTick() < firstKeyFrame.getTick())
            {
                firstKeyFrame = comparison;
            }
        }

        return firstKeyFrame;
    }

    public void onKeyFrameIconPressedEvent()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findKeyFrame(attributePanel.getSelectedKeyFramePage(), currentTime);
        if (keyFrame == null)
        {
            KeyFrame kf = attributePanel.createKeyFrame();
            if (kf == null)
            {
                return;
            }

            addKeyFrame(selectedCharacter, kf);
            return;
        }

       removeKeyFrame(selectedCharacter, keyFrame);
    }


    /**
     * Adds the keyframe to a specific character, or replaces a keyframe if the tick matches exactly
     * @param character the character to add the keyframe to
     * @param keyFrame the keyframe to add or modify for the character
     */
    public void addKeyFrame(Character character, KeyFrame keyFrame)
    {
        if (character == null)
        {
            return;
        }

        character.addKeyFrame(keyFrame);
        attributePanel.setKeyFramedIcon(true);
        attributePanel.resetAttributes(character, currentTime);
    }

    /**
     * Removes a keyframe from a specific character of the indicated type, at the indicated tick
     * @param character the character to remove the keyframe from
     * @param type the KeyFrameType
     * @param tick the tick to add the keyframe to
     */
    public void removeKeyFrame(Character character, KeyFrameType type, double tick)
    {
        if (character == null)
        {
            return;
        }

        character.removeKeyFrame(type, tick);
        attributePanel.setKeyFramedIcon(false);
    }

    /**
     * Removes a specific keyframe from the chosen character
     * @param character the character to remove the keyframe from
     * @param keyFrame the keyframe to remove
     */
    public void removeKeyFrame(Character character, KeyFrame keyFrame)
    {
        character.removeKeyFrame(keyFrame);
        attributePanel.resetAttributes(character, currentTime);
    }

    /**
     * Removes the specified keyframes from the chosen character
     * @param character the character to remove the keyframes from
     * @param keyFrames the keyframes to remove
     */
    public void removeKeyFrame(Character character, KeyFrame[] keyFrames)
    {
        for (KeyFrame keyFrame : keyFrames)
        {
            character.removeKeyFrame(keyFrame);
        }

        attributePanel.resetAttributes(character, currentTime);
    }

    private void setSelectedCharacter(Character character)
    {
        selectedCharacter = character;
        summarySheet.setSelectedCharacter(character);
        attributeSheet.setSelectedCharacter(character);
        attributePanel.setSelectedCharacter(character);
    }

    public void setCurrentTime(double tick)
    {
        if (tick < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            tick = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (tick > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            tick = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        currentTime = tick;
        attributeSheet.setCurrentTime(currentTime);
        summarySheet.setCurrentTime(currentTime);

        onCurrentTimeChanged(tick);
    }

    public void onCurrentTimeChanged(double tick)
    {
        timeSpinner.setValue(tick);
        attributePanel.resetAttributes(selectedCharacter, tick);
    }

    public void setPreviewTime(double tick)
    {
        attributeSheet.setPreviewTime(tick);
        summarySheet.setPreviewTime(tick);
    }

    private void setupSummaryComboBox()
    {
        summaryComboBox.setBackground(ColorScheme.DARK_GRAY_COLOR);

        summaryComboBox.addItem(KeyFrameType.SUMMARY);
        summaryComboBox.addItem(KeyFrameType.MOVEMENT);
        summaryComboBox.addItem(KeyFrameType.ANIMATION);
        summaryComboBox.addItem(KeyFrameType.SPAWN);
        summaryComboBox.addItem(KeyFrameType.MODEL);
        summaryComboBox.addItem(KeyFrameType.ORIENTATION);
        summaryComboBox.addItem(KeyFrameType.TEXT);
        summaryComboBox.addItem(KeyFrameType.OVERHEAD);
        summaryComboBox.addItem(KeyFrameType.HEALTH);
        summaryComboBox.addItem(KeyFrameType.SPOTANIM);

        summaryComboBox.addItemListener(e -> summaryKeyFrameType = (KeyFrameType) summaryComboBox.getSelectedItem());
    }

    private void setupTreeScrollPane()
    {
        treeScrollPane = new TreeScrollPane(managerTree);
        treeScrollPane.setPreferredSize(new Dimension(614, 0));
    }

    private void setupControlPanel()
    {
        controlPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controlPanel.setLayout(new GridBagLayout());
        controlPanel.setFocusable(true);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 0;
        controlPanel.add(timeSpinner, c);

        timeSpinner.setBackground(ColorScheme.DARK_GRAY_COLOR);
        timeSpinner.setModel(new SpinnerNumberModel(0, -ABSOLUTE_MAX_SEQUENCE_LENGTH, ABSOLUTE_MAX_SEQUENCE_LENGTH, 0.1));
        JSpinner.NumberEditor editor = (JSpinner.NumberEditor) timeSpinner.getEditor();
        DecimalFormat format = editor.getFormat();
        format.setMinimumFractionDigits(2);
        timeSpinner.setValue(0);
        timeSpinner.addChangeListener(e ->
        {
            double tick = TimeSheetPanel.round((double) timeSpinner.getValue());
            toolBox.getTimeSheetPanel().setCurrentTime(tick);
        });

        JButton playButton = new JButton(PLAY);
        playButton.setPreferredSize(new Dimension(35, 35));
        playButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        playButton.addActionListener(e ->
        {
            playActive = !playActive;
            playButton.setIcon(playActive ? PAUSE : PLAY);
        });

        JPanel backPanel = new JPanel();
        backPanel.setLayout(new BoxLayout(backPanel, BoxLayout.PAGE_AXIS));
        JButton backSummarySheet = new JButton(new ImageIcon(SKIP_LEFT));
        JButton backAttributeSheet = new JButton(new ImageIcon(SKIP_LEFT));
        backSummarySheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        backAttributeSheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        backSummarySheet.addActionListener(e -> onSummarySkipPrevious());
        backAttributeSheet.addActionListener(e -> onAttributeSkipPrevious());
        backPanel.add(backSummarySheet);
        backPanel.add(backAttributeSheet);

        JPanel forwardPanel = new JPanel();
        forwardPanel.setLayout(new BoxLayout(forwardPanel, BoxLayout.PAGE_AXIS));
        JButton forwardSummarySheet = new JButton(new ImageIcon(SKIP_RIGHT));
        JButton forwardAttributeSheet = new JButton(new ImageIcon(SKIP_RIGHT));
        forwardSummarySheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        forwardAttributeSheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        forwardSummarySheet.addActionListener(e -> onSummarySkipForward());
        forwardAttributeSheet.addActionListener(e -> onAttributeSkipForward());
        forwardPanel.add(forwardSummarySheet);
        forwardPanel.add(forwardAttributeSheet);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 1;
        c.gridy = 0;
        JPanel controls = new JPanel();
        controls.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controls.add(backPanel);
        controls.add(playButton);
        controls.add(forwardPanel);
        controlPanel.add(controls, c);
    }

    private void setupAttributePanel()
    {
        attributePanel = new AttributePanel(this, dataFinder);
        summarySheet = new SummarySheet(toolBox, managerTree, attributePanel);
        attributeSheet = new AttributeSheet(toolBox, managerTree, attributePanel);
    }

    private void setupAttributeSheet()
    {
        labelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        labelPanel.setBorder(new EmptyBorder(1, 0, 1, 0));
        labelPanel.setLayout(new GridLayout(0, 1, 0, 0));
        labelPanel.setFocusable(true);
        labels = new JLabel[KeyFrameType.getTotalFrameTypes() + 1];
        for (int i = 0; i < KeyFrameType.getTotalFrameTypes() + 1; i++)
        {
            JLabel label = new JLabel();
            label.setFocusable(true);
            label.setHorizontalAlignment(SwingConstants.RIGHT);
            label.setOpaque(true);
            label.setPreferredSize(new Dimension(100, 24));
            label.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            if (i == 1)
            {
                label.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }

            if (i != 0)
            {
                label.addMouseListener(new MouseAdapter()
                {
                    @Override
                    public void mousePressed(MouseEvent e)
                    {
                        super.mousePressed(e);
                        attributePanel.switchCards(label.getText().replaceAll(LABEL_OFFSET, ""));
                    }
                });
            }

            labels[i] = label;
            labelPanel.add(label);
        }

        labels[1].setText(MOVE_CARD + LABEL_OFFSET);
        labels[2].setText(ANIM_CARD + LABEL_OFFSET);
        labels[3].setText(ORI_CARD + LABEL_OFFSET);
        labels[4].setText(SPAWN_CARD + LABEL_OFFSET);
        labels[5].setText(MODEL_CARD + LABEL_OFFSET);
        labels[6].setText(TEXT_CARD + LABEL_OFFSET);
        labels[7].setText(OVER_CARD + LABEL_OFFSET);
        labels[8].setText(HEALTH_CARD + LABEL_OFFSET);
        labels[9].setText(SPOTANIM_CARD + LABEL_OFFSET);
    }

    private void setupScrollBar()
    {
        scrollBar.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        scrollBar.setPreferredSize(new Dimension(0, 15));
        scrollBar.setMinimum(DEFAULT_MIN_H_SCROLL);
        scrollBar.setMaximum(DEFAULT_MAX_H_SCROLL);
        scrollBar.setBlockIncrement((int) (zoom / 5));
        scrollBar.setUnitIncrement((int) (zoom / 50));
        scrollBar.setVisibleAmount((int) (zoom));
        scrollBar.setValue(0);

        scrollBar.addAdjustmentListener(e ->
        {
            if (pauseScrollBarListener)
            {
                return;
            }

            hScroll = -e.getValue();
            updateScrollBar();
            updateSheets();
        });
    }

    private void setupTimeTreeListener()
    {
        managerTree.addTreeSelectionListener(e ->
        {
            TreePath treePath = e.getPath();
            if (treePath == null)
            {
                return;
            }

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath.getLastPathComponent();
            Object o = node.getUserObject();
            if (o == null)
            {
                return;
            }

            if (o instanceof Character)
            {
                setSelectedCharacter((Character) o);
                return;
            }

            setSelectedCharacter(null);
        });
    }

    private void setKeyBindings()
    {
        ActionMap actionMap = getActionMap();
        InputMap inputMap = getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_I, 0), "VK_I");
        actionMap.put("VK_I", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                if (selectedCharacter == null)
                {
                    return;
                }

                if (attributeSheet.getBounds().contains(MouseInfo.getPointerInfo().getLocation()))
                {
                    KeyFrame keyFrame = attributePanel.createKeyFrame();
                    addKeyFrame(selectedCharacter, keyFrame);
                    return;
                }

                Component component = attributePanel.getHoveredComponent();
                if (component == null)
                {
                    return;
                }

                if (component instanceof JSpinner || component instanceof JTextField)
                {
                    if (component.isFocusOwner())
                    {
                        return;
                    }
                }

                KeyFrameType keyFrameType = attributePanel.getHoveredKeyFrameType();
                if (keyFrameType == null || keyFrameType == KeyFrameType.NULL)
                {
                    return;
                }

                KeyFrame keyFrame = attributePanel.createKeyFrame();
                addKeyFrame(selectedCharacter, keyFrame);
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK), "VK_C");
        actionMap.put("VK_C", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                copiedKeyFrames = selectedKeyFrames;
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK), "VK_V");
        actionMap.put("VK_V", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                if (selectedCharacter == null)
                {
                    return;
                }

                double firstTick = ABSOLUTE_MAX_SEQUENCE_LENGTH;
                for (KeyFrame keyFrame : copiedKeyFrames)
                {
                    if (keyFrame.getTick() < firstTick)
                    {
                        firstTick = keyFrame.getTick();
                    }
                }

                for (KeyFrame keyFrame : copiedKeyFrames)
                {
                    double newTime = keyFrame.getTick() - firstTick + currentTime;
                    KeyFrame copy = keyFrame.createCopy(keyFrame, newTime);
                    if (copy == null)
                    {
                        continue;
                    }

                    addKeyFrame(selectedCharacter, copy);
                }
            }
        });
    }

    private void setMouseListeners()
    {
        addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                super.mouseWheelMoved(e);
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    int currentRow = managerTree.getMinSelectionRow();
                    if (currentRow == -1)
                    {
                        managerTree.setSelectionRow(0);
                        return;
                    }

                    TreePath path = null;
                    int direction = e.getWheelRotation();
                    if (direction > 0)
                    {
                        while (path == null)
                        {
                            currentRow++;
                            if (currentRow >= managerTree.getRowCount())
                            {
                                currentRow = 0;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (direction < 0)
                    {
                        while (path == null)
                        {
                            currentRow--;
                            if (currentRow < 0)
                            {
                                currentRow = managerTree.getRowCount() - 1;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (path != null)
                    {
                        managerTree.setSelectionPath(path);
                    }
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    scrollAttributePanel(e.getWheelRotation());
                }
            }
        });
    }

    public void scrollAttributePanel(int direction)
    {
        int index = KeyFrameType.getIndex(attributePanel.getSelectedKeyFramePage()) + direction;
        int totalFrameTypes = KeyFrameType.getTotalFrameTypes();
        if (index >= totalFrameTypes)
        {
            index = 0;
        }

        if (index == -1)
        {
            index = totalFrameTypes - 1;
        }

        attributePanel.switchCards(KeyFrameType.getKeyFrameType(index).toString());
    }

    private void setupManager()
    {
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 2;
        c.weightx = 0;
        c.weighty = 5;
        c.gridx = 0;
        c.gridy = 0;
        add(treeScrollPane, c);

        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 0;
        add(summaryComboBox, c);

        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 8;
        c.weighty = 5;
        c.gridx = 2;
        c.gridy = 1;
        add(summarySheet, c);

        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 2;
        add(scrollBar, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 3;
        add(controlPanel, c);

        c.gridheight = 3;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 2;
        add(attributePanel, c);

        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 1;
        c.gridy = 4;
        add(labelPanel, c);

        c.weightx = 8;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 4;
        add(attributeSheet, c);
    }

    private void updateSheets()
    {
        summarySheet.setHScroll(hScroll);
        summarySheet.setVScroll(vScroll);
        summarySheet.setZoom(zoom);
        attributeSheet.setHScroll(hScroll);
        attributeSheet.setVScroll(vScroll);
        attributeSheet.setZoom(zoom);
    }

    private void updateScrollBar()
    {
        pauseScrollBarListener = true;
        scrollBar.setMinimum((int) minHScroll);
        scrollBar.setMaximum((int) maxHScroll);
        scrollBar.setBlockIncrement((int) (zoom / 5));
        scrollBar.setUnitIncrement((int) (zoom / 50));
        scrollBar.setVisibleAmount((int) (zoom));
        scrollBar.setValue((int) -hScroll);
        pauseScrollBarListener = false;
    }

    /**
     * Rounds the given value to the nearest 1/10th
     * @param value the value to round
     * @return the value, rounded to 1 decimal place
     */
    public static double round (double value)
    {
        int scale = (int) Math.pow(10, 1);
        return (double) Math.round(value * scale) / scale;
    }
}

package com.creatorskit.swing;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TransmogAnimationMode
{
    PLAYER("Player"),
    MODIFIED("Modified"),
    CUSTOM("Custom"),
    NONE("None")
    ;

    private final String string;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.Character;
import com.creatorskit.programming.MovementType;
import com.creatorskit.programming.Program;
import com.creatorskit.programming.ProgramComp;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.manager.TreeScrollPane;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.util.Random;

@Getter
public class ProgrammerPanel extends JPanel
{
    @Inject
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final ManagerTree tree;
    private final GridBagConstraints c = new GridBagConstraints();
    private final JPanel managerProgramHolder = new JPanel();
    private final TreeScrollPane treeScrollPane;
    private final JPanel[] sidePrograms = new JPanel[0];
    private final Random random = new Random();


    @Inject
    public ProgrammerPanel(@Nullable Client client, ClientThread clientThread, CreatorsPlugin plugin, ManagerTree tree)
    {
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.tree = tree;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);
        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 3;
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new GridBagLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        add(headerPanel, c);

        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.gridwidth = 1;
        JLabel titleLabel = new JLabel("Programmer");
        titleLabel.setFont(FontManager.getRunescapeBoldFont());
        titleLabel.setHorizontalAlignment(SwingConstants.CENTER);
        titleLabel.setVerticalAlignment(SwingConstants.CENTER);
        headerPanel.add(titleLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        c.weightx = 0;
        c.gridwidth = 1;
        JButton syncAllButton = new JButton("Sync All Idles");
        syncAllButton.setToolTipText("Synchronizes the idle animations of all current Objects");
        syncAllButton.setPreferredSize(new Dimension(150, 30));
        headerPanel.add(syncAllButton, c);
        syncAllButton.addActionListener(e ->
        {
            for (Character character : plugin.getCharacters())
            {
                plugin.setAnimation(character, (int) character.getAnimationSpinner().getValue());
            }
        });



        c.gridx = 2;
        c.gridy = 0;
        c.weightx = 0;
        c.gridwidth = 1;
        JButton syncShownButton = new JButton("Sync Shown Idles");
        syncShownButton.setToolTipText("Synchronizes the idle animations of all currently shown Objects");
        syncShownButton.setPreferredSize(new Dimension(150, 30));
        headerPanel.add(syncShownButton, c);
        syncShownButton.addActionListener(e ->
        {
            Character[] shownCharacters = plugin.getCreatorsPanel().getToolBox().getManagerPanel().getShownCharacters();
            for (Character character : shownCharacters)
            {
                plugin.setAnimation(character, (int) character.getAnimationSpinner().getValue());
            }
        });

        c.gridx = 3;
        c.gridy = 0;
        c.weightx = 0;
        c.gridwidth = 1;
        JButton desyncButton = new JButton("Desync All Idles");
        desyncButton.setToolTipText("Deynchronizes the idle animations of all current Objects");
        desyncButton.setPreferredSize(new Dimension(150, 30));
        headerPanel.add(desyncButton, c);
        desyncButton.addActionListener(e ->
        {
            for (Character character : plugin.getCharacters())
            {
                int maxAnimFrames = character.getCKObject().getMaxAnimFrames();
                int animFrame = random.nextInt(maxAnimFrames);
                plugin.setAnimationFrame(character, animFrame, false);
            }
        });

        c.gridx = 4;
        c.gridy = 0;
        c.weightx = 0;
        c.gridwidth = 1;
        JButton desyncShownIdles = new JButton("Desync Shown Idles");
        desyncShownIdles.setToolTipText("Deynchronizes the idle animations of all currently shown Objects");
        desyncShownIdles.setPreferredSize(new Dimension(150, 30));
        headerPanel.add(desyncShownIdles, c);
        desyncShownIdles.addActionListener(e ->
        {
            Character[] shownCharacters = plugin.getCreatorsPanel().getToolBox().getManagerPanel().getShownCharacters();
            for (Character character : shownCharacters)
            {
                int maxAnimFrames = character.getCKObject().getMaxAnimFrames();
                int animFrame = random.nextInt(maxAnimFrames);
                plugin.setAnimationFrame(character, animFrame, false);
            }
        });

        JScrollPane managerScrollPane = new JScrollPane();

        c.fill = GridBagConstraints.BOTH;
        c.gridx = 1;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridwidth = 2;

        JPanel scrollPanel = new JPanel();
        BorderLayout borderLayout = new BorderLayout();
        borderLayout.setHgap(4);
        scrollPanel.setLayout(borderLayout);

        treeScrollPane = new TreeScrollPane(tree);
        treeScrollPane.setPreferredSize(new Dimension(350, 0));

        scrollPanel.add(treeScrollPane, BorderLayout.LINE_START);
        scrollPanel.add(managerScrollPane, BorderLayout.CENTER);
        add(scrollPanel, c);

        managerProgramHolder.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        managerProgramHolder.setBorder(new EmptyBorder(4, 4, 4, 4));
        managerProgramHolder.setLayout(new GridBagLayout());
        managerScrollPane.setViewportView(managerProgramHolder);

        repaint();
        revalidate();
    }

    public void createProgramPanel(Character character, JPanel programPanel, JLabel nameLabel, JSpinner idleAnimSpinner)
    {
        Program program = character.getProgram();
        ProgramComp comp = program.getComp();

        programPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        programPanel.setBorder(new LineBorder(program.getColor(), 1));
        programPanel.setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.VERTICAL;
        c.insets = new Insets(4, 4, 4, 4);
        c.anchor = GridBagConstraints.CENTER;
        c.weightx = 0;
        c.weighty = 0;

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        nameLabel.setText(character.getName());
        nameLabel.setHorizontalAlignment(SwingConstants.CENTER);
        nameLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        programPanel.add(nameLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        JPanel textPanel = new JPanel();
        textPanel.setLayout(new GridLayout(0, 1));
        textPanel.setBorder(new EmptyBorder(2, 2, 2, 0));
        textPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        programPanel.add(textPanel, c);

        JLabel idleAnimLabel = new JLabel("Idle animation:");
        idleAnimLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        idleAnimLabel.setToolTipText("Set the animation for when the object isn't moving");

        JLabel walkAnimLabel = new JLabel("Active animation:");
        walkAnimLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        walkAnimLabel.setToolTipText("Set the animation for when the object is moving");

        JLabel speedLabel = new JLabel("Speed:");
        speedLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        speedLabel.setToolTipText("Set how fast the object moves");

        JLabel turnSpeedLabel = new JLabel("Turn speed:");
        turnSpeedLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        turnSpeedLabel.setToolTipText("Set how fast the object turns. Set to 0 for no turning");

        JLabel movementTypeLabel = new JLabel("Movement Type:");
        movementTypeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        movementTypeLabel.setToolTipText("Determines the terrain on which the object can travel");

        JLabel loopLabel = new JLabel("Loop:");
        loopLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        loopLabel.setToolTipText("Set whether this program should loop once finished");

        textPanel.add(idleAnimLabel);
        textPanel.add(walkAnimLabel);
        textPanel.add(speedLabel);
        textPanel.add(turnSpeedLabel);
        textPanel.add(movementTypeLabel);
        textPanel.add(loopLabel);

        c.gridx = 1;
        c.gridy = 1;
        JPanel optionsPanel = new JPanel();
        optionsPanel.setLayout(new GridLayout(0, 1));
        optionsPanel.setBorder(new EmptyBorder(2, 0, 2, 2));
        optionsPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        programPanel.add(optionsPanel, c);

        idleAnimSpinner.setModel(new SpinnerNumberModel(comp.getIdleAnim(), -1, 99999, 1));
        idleAnimSpinner.addChangeListener(e ->
        {
            int idleAnim = (int) idleAnimSpinner.getValue();
            comp.setIdleAnim(idleAnim);
            character.getAnimationSpinner().setValue(idleAnim);
        });
        optionsPanel.add(idleAnimSpinner);

        JSpinner walkAnimSpinner = new JSpinner(new SpinnerNumberModel(comp.getWalkAnim(), -1, 99999, 1));
        walkAnimSpinner.addChangeListener(e ->
                comp.setWalkAnim((int) walkAnimSpinner.getValue()));
        optionsPanel.add(walkAnimSpinner);

        JSpinner speedSpinner = new JSpinner(new SpinnerNumberModel(comp.getSpeed(), 0, 2, 1));
        speedSpinner.addChangeListener(e ->
                comp.setSpeed((double) speedSpinner.getValue()));
        optionsPanel.add(speedSpinner);

        JSpinner turnSpeedSpinner = new JSpinner();
        turnSpeedSpinner.setValue(comp.getTurnSpeed());
        turnSpeedSpinner.addChangeListener(e ->
                comp.setTurnSpeed((int) turnSpeedSpinner.getValue()));
        optionsPanel.add(turnSpeedSpinner);

        JComboBox<MovementType> movementBox = new JComboBox<>();
        movementBox.addItem(MovementType.NORMAL);
        movementBox.addItem(MovementType.WATERBORNE);
        movementBox.addItem(MovementType.GHOST);
        movementBox.addItemListener(e ->
        {
            comp.setMovementType((MovementType) movementBox.getSelectedItem());
            plugin.updateProgramPath(program, false, character.isInInstance());
        });
        movementBox.setSelectedItem(comp.getMovementType());
        optionsPanel.add(movementBox);

        JCheckBox loopCheckBox = new JCheckBox();
        loopCheckBox.setFocusable(false);
        loopCheckBox.setSelected(comp.isLoop());
        loopCheckBox.addActionListener(e ->
                comp.setLoop(loopCheckBox.isSelected()));
        optionsPanel.add(loopCheckBox);

        c.gridx = 0;
        c.gridy = 2;
        c.gridwidth = 2;
        JButton colourButton = new JButton();
        colourButton.setText("Reroll Colour");
        colourButton.setToolTipText("Rerolls a new random colour for the path");
        colourButton.setFocusable(false);
        colourButton.addActionListener(e ->
                {
                    Color color = getRandomColor();
                    program.setColor(color);
                    program.getComp().setRgb(color.getRGB());
                    programPanel.setBorder(new LineBorder(color, 1));
                });
        programPanel.add(colourButton, c);

        repaint();
        revalidate();
    }

    private Color getRandomColor()
    {
        float r = random.nextFloat();
        float g = random.nextFloat();
        float b = random.nextFloat();
        return new Color(r, g, b);
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.DataFinder;
import com.creatorskit.programming.Programmer;
import com.creatorskit.swing.manager.ManagerPanel;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.image.BufferedImage;

@Getter
public class ToolBoxFrame extends JFrame
{
    private ClientThread clientThread;
    private final Client client;
    private final EventBus eventBus;
    private final CreatorsPlugin plugin;
    private final ConfigManager configManager;
    private final DataFinder dataFinder;
    private final ManagerPanel managerPanel;
    private final ModelOrganizer modelOrganizer;
    private final ModelAnvil modelAnvil;
    private final CacheSearcherTab cacheSearcher;
    private final ProgrammerPanel programPanel;
    private final TransmogPanel transmogPanel;
    private final TimeSheetPanel timeSheetPanel;
    private final Programmer programmer;
    private final BufferedImage ICON = ImageUtil.loadImageResource(getClass(), "/panelicon.png");

    @Inject
    public ToolBoxFrame(Client client, EventBus eventBus, ClientThread clientThread, CreatorsPlugin plugin, ConfigManager configManager, DataFinder dataFinder, ModelOrganizer modelOrganizer, ModelAnvil modelAnvil, TransmogPanel transmogPanel)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.eventBus = eventBus;
        this.configManager = configManager;
        this.dataFinder = dataFinder;
        this.modelOrganizer = modelOrganizer;
        this.modelAnvil = modelAnvil;
        this.transmogPanel = transmogPanel;

        Folder rootFolder = new Folder("Master Folder", FolderType.MASTER, null, null);
        DefaultMutableTreeNode managerRootNode = new DefaultMutableTreeNode(rootFolder);
        rootFolder.setLinkedManagerNode(managerRootNode);

        Folder sidePanelFolder = new Folder("Side Panel", FolderType.SIDE_PANEL, null, managerRootNode);
        Folder managerPanelFolder = new Folder("Manager", FolderType.MANAGER, null, managerRootNode);
        DefaultMutableTreeNode managerSideNode = new DefaultMutableTreeNode(sidePanelFolder);
        DefaultMutableTreeNode managerManagerNode = new DefaultMutableTreeNode(managerPanelFolder);
        sidePanelFolder.setLinkedManagerNode(managerSideNode);
        managerPanelFolder.setLinkedManagerNode(managerManagerNode);

        JPanel objectHolder = new JPanel();
        ManagerTree managerTree = new ManagerTree(this, plugin, objectHolder, managerRootNode, managerSideNode, managerManagerNode);

        JScrollBar scrollBar = new JScrollBar(Adjustable.HORIZONTAL);
        this.timeSheetPanel = new TimeSheetPanel(client, this, plugin, clientThread, dataFinder, managerTree, scrollBar);
        this.managerPanel = new ManagerPanel(client, plugin, objectHolder, managerTree);
        this.cacheSearcher = new CacheSearcherTab(plugin, clientThread, dataFinder);
        this.programPanel = new ProgrammerPanel(client, clientThread, plugin, managerTree);
        this.programmer = new Programmer(client, plugin, timeSheetPanel);

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setTitle("Creator's Kit Toolbox");
        setIconImage(ICON);

        try
        {
            String string = configManager.getConfiguration("creatorssuite", "toolBoxSize");
            String[] dimensions = string.split(",");
            int width = Integer.parseInt(dimensions[0]);
            int height = Integer.parseInt(dimensions[1]);
            if (width < 150)
                width = 150;
            if (height < 150)
                height = 150;
            setPreferredSize(new Dimension(width, height));
        }
        catch (Exception e)
        {
            setPreferredSize(new Dimension(1500, 800));
        }

        addComponentListener(new ComponentAdapter()
        {
            public void componentResized(ComponentEvent componentEvent)
            {
                Dimension dimension = getSize();
                configManager.setConfiguration("creatorssuite", "toolBoxSize", (int) dimension.getWidth() + "," + (int) dimension.getHeight());
            }
        });

        JTabbedPane tabbedPane = new JTabbedPane();
        tabbedPane.setFont(FontManager.getRunescapeBoldFont());
        if (plugin.isTest2_0())
        {
            tabbedPane.addTab("Timesheet", timeSheetPanel);
            timeSheetPanel.getTreeScrollPane().setViewportView(managerTree);
        }
        else
        {
            managerPanel.getTreeScrollPane().setViewportView(managerTree);
        }
        tabbedPane.addTab("Manager", managerPanel);
        tabbedPane.addTab("Model Organizer", modelOrganizer);
        tabbedPane.addTab("Model Anvil", modelAnvil);
        tabbedPane.addTab("Cache Searcher", cacheSearcher);
        tabbedPane.addTab("Programmer", programPanel);
        tabbedPane.addTab("Transmogger", transmogPanel);
        tabbedPane.setToolTipTextAt(0, "Manage and organize all your Objects");
        tabbedPane.setToolTipTextAt(1, "Organize Custom Models you've loaded from the cache or Forged");
        tabbedPane.setToolTipTextAt(2, "Create Custom Models by modifying and merging different models together");
        tabbedPane.setToolTipTextAt(3, "Search the cache for NPCs, Items, and Objects for their models");
        tabbedPane.setToolTipTextAt(4, "Change your Object Programs' animations, speeds, and more");
        tabbedPane.setToolTipTextAt(5, "Set animations for Transmogging your player character");

        //Move the FolderTree between the Manager and Programmer tabs when the given tab is selected
        tabbedPane.addChangeListener(e -> {
            if (e.getSource() instanceof JTabbedPane)
            {
                JTabbedPane jTabbedPane = (JTabbedPane) e.getSource();
                if (jTabbedPane.getSelectedComponent() == managerPanel)
                {
                    managerPanel.getTreeScrollPane().setViewportView(managerTree);
                }

                if (jTabbedPane.getSelectedComponent() == programPanel)
                {
                    programPanel.getTreeScrollPane().setViewportView(managerTree);
                }

                if (jTabbedPane.getSelectedComponent() == timeSheetPanel)
                {
                    timeSheetPanel.getTreeScrollPane().setViewportView(managerTree);
                }
            }
            repaint();
            revalidate();
        });

        add(tabbedPane);
        pack();
        revalidate();
    }
}

package com.creatorskit;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Rotation
{
    _45_DEGREES("45 Degrees", 256),
    _90_DEGREES("90 Degrees", 512),
    _180_DEGREES("180 Degrees", 1024)

    ;
    public final String name;
    public final int degrees;

    @Override
    public String toString()
    {
        return name;
    }

    public static int convertRotation(double x, double y, double angle)
    {
        int jagexDegree = 0;
        if (x >= 0 && y >= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 1536;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 1280;
            }
            else if (angle >= 60)
            {
                jagexDegree = 1024;
            }
        }
        else if (x >= 0 && y <= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 1536;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 1792;
            }
            else if (angle >= 60)
            {
                jagexDegree = 0;
            }
        }
        else if (x <=0 && y >= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 512;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 768;
            }
            else if (angle >= 60)
            {
                jagexDegree = 1024;
            }
        }
        else if (x <=0 && y <= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 512;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 256;
            }
            else if (angle >= 60)
            {
                jagexDegree = 0;
            }
        }

        return jagexDegree;
    }

    public static int roundRotation(int rotation)
    {
        if ((rotation > -128 && rotation <= 128) || (rotation > 1920 && rotation <= 2176))
        {
            return 0;
        }

        if ((rotation > 128 && rotation <= 384) || (rotation > 2176 && rotation <= 2432))
        {
            return 256;
        }

        if (rotation > 384 && rotation <= 640)
        {
            return 512;
        }

        if (rotation > 640 && rotation <= 896)
        {
            return 768;
        }

        if (rotation > 896 && rotation <= 1152)
        {
            return 1024;
        }

        if (rotation > 1152 && rotation <= 1408)
        {
            return 1280;
        }

        if (rotation > 1408 && rotation <= 1664)
        {
            return 1536;
        }

        if ((rotation > 1664 && rotation <= 1920) || (rotation > -384 && rotation <= -128))
        {
            return 1792;
        }

        return 0;
    }

    public static int getJagexDegrees(double x, double y, int yaw, double pitch)
    {
        double degrees = Math.abs((Math.atan(y / x)) * 180 / Math.PI);
        int jagexDegree = Rotation.convertRotation(x, y, degrees) - (Rotation.roundRotation(yaw));
        while (jagexDegree >= 2048)
        {
            jagexDegree -= 2048;
        }

        while (jagexDegree < 0)
        {
            jagexDegree += 2048;
        }

        return jagexDegree;
    }
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class Coordinate
{
    private int column;
    private int row;
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@AllArgsConstructor
@Getter
@Setter
public class ProgramComp
{
    private WorldPoint[] stepsWP;
    private WorldPoint[] pathWP;
    private LocalPoint[] stepsLP;
    private LocalPoint[] pathLP;
    private Coordinate[] coordinates;
    private boolean pathFound;
    private int currentStep;
    private double speed;
    private int turnSpeed;
    private int idleAnim;
    private int walkAnim;
    private MovementType movementType;
    private int rgb;
    private boolean loop;
    private boolean programActive;
}

package com.creatorskit.programming;

public class Orientation
{
    public static int orientationX(double orientation)
    {
        int direction = simplifyOrientation((int) orientation);
        if (direction == 1280 || direction == 1536 || direction == 1792)
        {
            return 1;
        }
        else if (direction == 256 || direction == 512 || direction == 768)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }

    public static int orientationY(double orientation)
    {
        int direction = simplifyOrientation((int) orientation);
        if (direction == 768 || direction == 1024 || direction == 1280)
        {
            return 1;
        }
        else if (direction == 256 || direction == 0 || direction == 2048 || direction == 1792)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }

    public static double radiansToJAngle(double radians, double changeX, double changeY)
    {
        double angle = radians * 1024 / Math.PI;
        if (changeX > 0 && changeY > 0)
        {
            angle = 1536 - angle;
            return angle;
        }

        if (changeX < 0 && changeY > 0)
        {
            angle = 512 - angle;
            return angle;
        }

        if (changeX < 0 && changeY < 0)
        {
            angle = 512 - angle;
            return angle;
        }

        if (changeX > 0 && changeY < 0)
        {
            angle = 1536 - angle;
            return angle;
        }

        if (changeX == 0 && changeY > 0)
        {
            return 1024;
        }

        if (changeX == 0 && changeY < 0)
        {
            return 0;
        }

        if (changeX > 0 && changeY == 0)
        {
            return 1536;
        }

        if (changeX < 0 && changeY == 0)
        {
            return 512;
        }

        return angle;
    }

    public static int simplifyOrientation(int orientation)
    {
        orientation = boundOrientation(orientation);

        if (orientation == 0 || orientation == 512 || orientation == 1024 || orientation == 1536 || orientation == 2048)
        {
            return orientation;
        }

        if (orientation > 0 && orientation < 512)
        {
            return 256;
        }

        if (orientation > 512 && orientation < 1024)
        {
            return 768;
        }

        if (orientation > 1024 && orientation < 1536)
        {
            return 1280;
        }

        if (orientation > 1536 && orientation < 2048)
        {
            return 1792;
        }

        return 0;
    }

    public static int subtract(int first, int second)
    {
        int product = boundOrientation(first - second);
        if (product > 1024)
        {
            return (product - 1024) * -1;
        }

        return product;
    }

    public static int boundOrientation(int orientation)
    {
        while (orientation >= 2048)
        {
            orientation -= 2048;
        }

        while (orientation < 0)
        {
            orientation += 2048;
        }

        return orientation;
    }
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum MovementType
{
    NORMAL("Normal"),
    WATERBORNE("Waterborne"),
    GHOST("Ghost")
    ;

    String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;
import java.awt.*;

@Getter
@Setter
@AllArgsConstructor
public class Program
{
    private ProgramComp comp;
    private JPanel programPanel;
    private JLabel nameLabel;
    private JSpinner idleAnimSpinner;
    private Color color;
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum Direction
{
    UNSET("Unset", 0),
    NORTH("North", 1024),
    SOUTH("South", 0),
    EAST("East", 1536),
    WEST("West", 512),
    NORTHEAST("Northeast", 1280),
    NORTHWEST("Northwest", 768),
    SOUTHEAST("Southeast", 1792),
    SOUTHWEST("Southwest", 256)
    ;

    private String name;
    private int jUnit;

    public static Direction getDirection(int changeX, int changeY)
    {
        switch (changeX)
        {
            case -1:
                switch (changeY)
                {
                    case -1:
                        return SOUTHWEST;
                    case 0:
                        return WEST;
                    case 1:
                        return NORTHWEST;
                }
            case 0:
                switch (changeY)
                {
                    case -1:
                        return SOUTH;
                    case 1:
                        return NORTH;
                }
            case 1:
                switch (changeY)
                {
                    case -1:
                        return SOUTHEAST;
                    case 0:
                        return EAST;
                    case 1:
                        return NORTHEAST;
                }
        }

        return UNSET;
    }

    public static Direction[] getAllDirections()
    {
        return new Direction[]{NORTH, EAST, SOUTH, WEST, NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST};
    }

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.programming;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.GameState;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameTick;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.time.Duration;
import java.time.Instant;

public class Programmer
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final TimeSheetPanel timeSheetPanel;
    private int clientTickAtLastGameTick = -1;
    private double subTick = 0;

    @Inject
    public Programmer(Client client, CreatorsPlugin plugin, TimeSheetPanel timeSheetPanel)
    {
        this.client = client;
        this.plugin = plugin;
        this.timeSheetPanel = timeSheetPanel;
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (clientTickAtLastGameTick == -1)
        {
            clientTickAtLastGameTick = client.getGameCycle();
        }

        if (timeSheetPanel.isPlayActive())
        {
            int currentClientTick = client.getGameCycle();
            int change = currentClientTick - clientTickAtLastGameTick;
            if (change * Constants.CLIENT_TICK_LENGTH >= Constants.GAME_TICK_LENGTH)
            {
                return;
            }

            double nextSubTick = TimeSheetPanel.round((double) change / 30);
            if (subTick < nextSubTick)
            {
                incrementSubTime();
            }
        }
    }

    @Subscribe
    public void onGameTick(GameTick event)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (timeSheetPanel.isPlayActive())
        {
            incrementTime();
            clientTickAtLastGameTick = client.getGameCycle();
        }
    }

    private void incrementSubTime()
    {
        double time = TimeSheetPanel.round(timeSheetPanel.getCurrentTime() + 0.1);
        timeSheetPanel.setCurrentTime(time);
    }

    private void incrementTime()
    {
        subTick = 0;
        timeSheetPanel.setCurrentTime(Math.floor(timeSheetPanel.getCurrentTime()) + 1);
    }

}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;

public class PathFinder
{
    @Inject
    private CreatorsPlugin plugin;

    @Inject
    private Client client;

    @Inject
    private CreatorsConfig config;

    private final int WATER_OVERLAY = 6;
    private final int REGION_ID_X = 256;
    private final int[] directionColumn = new int[]{1, -1, 0, 0, -1, 1, -1, 1};
    private final int[] directionRow = new int[]{0, 0, -1, 1, -1, -1, 1, 1};
    private final int[][] directionBlocks = new int[][]
            {
                    {CollisionDataFlag.BLOCK_MOVEMENT_EAST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_EAST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_EAST}
            };

    public Coordinate[] getPath(LocalPoint startLocation, LocalPoint destLocation, MovementType movementType)
    {
        WorldView worldView = client.getTopLevelWorldView();
        Scene scene = worldView.getScene();
        final ArrayList<Integer> rowQueue = new ArrayList<>();
        final ArrayList<Integer> columnQueue = new ArrayList<>();
        final boolean[][] visited = new boolean[Constants.SCENE_SIZE][Constants.SCENE_SIZE];
        final Coordinate[][] path = new Coordinate[Constants.SCENE_SIZE][Constants.SCENE_SIZE];

        boolean reachedEnd = false;

        if (startLocation == null || destLocation == null)
        {
            return null;
        }

        int startX = startLocation.getSceneX();
        int startY = startLocation.getSceneY();
        int endX = destLocation.getSceneX();
        int endY = destLocation.getSceneY();

        rowQueue.add(startY);
        columnQueue.add(startX);
        visited[startX][startY] = true;
        if (worldView.getCollisionMaps() == null)
        {
            return null;
        }

        CollisionData data = worldView.getCollisionMaps()[worldView.getPlane()];
        short[][] overlays = scene.getOverlayIds()[worldView.getPlane()];

        while (!rowQueue.isEmpty() && !columnQueue.isEmpty())
        {
            int row = rowQueue.get(0);
            int column = columnQueue.get(0);
            rowQueue.remove(0);
            columnQueue.remove(0);
            if (row == endY && column == endX)
            {
                reachedEnd = true;
                break;
            }

            exploreNeighbours(row, column, data, overlays, visited, columnQueue, rowQueue, path, movementType);
        }

        if (reachedEnd)
        {
            return reconstructPath(endX, endY, path);
        }

        return null;
    }

    public Coordinate[] getPath(WorldPoint startLocation, WorldPoint destLocation, MovementType movementType)
    {
        WorldView worldView = client.getTopLevelWorldView();
        Scene scene = worldView.getScene();
        final ArrayList<Integer> rowQueue = new ArrayList<>();
        final ArrayList<Integer> columnQueue = new ArrayList<>();
        final boolean[][] visited = new boolean[Constants.SCENE_SIZE][Constants.SCENE_SIZE];
        final Coordinate[][] path = new Coordinate[Constants.SCENE_SIZE][Constants.SCENE_SIZE];

        boolean reachedEnd = false;
        Collection<WorldPoint> startPoints = WorldPoint.toLocalInstance(scene, startLocation);
        WorldPoint startPoint = startPoints.iterator().next();

        Collection<WorldPoint> destPoints = WorldPoint.toLocalInstance(scene, destLocation);
        WorldPoint destPoint = destPoints.iterator().next();

        LocalPoint startLoc = LocalPoint.fromWorld(worldView, startPoint);
        LocalPoint destLoc = LocalPoint.fromWorld(worldView, destPoint);

        if (startLoc == null || destLoc == null)
        {
            return null;
        }

        int startX = startLoc.getSceneX();
        int startY = startLoc.getSceneY();
        int endX = destLoc.getSceneX();
        int endY = destLoc.getSceneY();
        rowQueue.add(startY);
        columnQueue.add(startX);
        visited[startX][startY] = true;
        if (worldView.getCollisionMaps() == null)
        {
            return null;
        }

        CollisionData data = worldView.getCollisionMaps()[worldView.getPlane()];
        short[][] overlays = scene.getOverlayIds()[worldView.getPlane()];

        while (!rowQueue.isEmpty() && !columnQueue.isEmpty())
        {
            int row = rowQueue.get(0);
            int column = columnQueue.get(0);
            rowQueue.remove(0);
            columnQueue.remove(0);
            if (row == endY && column == endX)
            {
                reachedEnd = true;
                break;
            }

            exploreNeighbours(row, column, data, overlays, visited, columnQueue, rowQueue, path, movementType);
        }

        if (reachedEnd)
        {
            return reconstructPath(endX, endY, path);
        }

        return null;
    }

    private Coordinate[] reconstructPath(int endX, int endY, Coordinate[][] coordinates)
    {
        ArrayList<Coordinate> list = new ArrayList<>();
        Coordinate endCoordinate = new Coordinate(endX, endY);
        for (Coordinate coordinate = endCoordinate; coordinate != null; coordinate = coordinates[coordinate.getColumn()][coordinate.getRow()])
        {
            list.add(coordinate);
        }

        Coordinate[] path = new Coordinate[list.size()];
        for (int i = 0; i < list.size(); i++)
        {
            path[i] = list.get(i);
        }

        ArrayUtils.reverse(path);

        return path;
    }

    private void exploreNeighbours(int row, int column, CollisionData data, short[][] overlays, boolean[][] visited, ArrayList<Integer> columnQueue, ArrayList<Integer> rowQueue, Coordinate[][] path, MovementType movementType)
    {
        for (int i = 0; i < 8; i++)
        {
            int testRow = row + directionRow[i];
            int testColumn = column + directionColumn[i];

            if (testRow >= Constants.SCENE_SIZE || testRow < 0 || testColumn >= Constants.SCENE_SIZE || testColumn < 0)
            {
                continue;
            }

            if (movementType != MovementType.GHOST)
            {
                int setting = data.getFlags()[testColumn][testRow];
                int currentSetting = data.getFlags()[column][row];

                if ((setting & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[testColumn][testRow] == WATER_OVERLAY) || (setting & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0))
                {
                    continue;
                }

                if (movementType == MovementType.WATERBORNE && (setting & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0)
                {
                    continue;
                }

                int[] blocks = directionBlocks[i];
                if ((currentSetting & blocks[0]) != 0)
                {
                    continue;
                }

                if (i >= 4)
                {
                    int settingEW = data.getFlags()[testColumn][row];
                    int settingNS = data.getFlags()[column][testRow];

                    if (((settingEW & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[testColumn][row] == WATER_OVERLAY) || (settingEW & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0))
                            || ((settingNS & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[column][testRow] == WATER_OVERLAY) || (settingNS & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0)))
                    {
                        continue;
                    }

                    if (movementType == MovementType.WATERBORNE && ((settingEW & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0 || (settingNS & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0))
                        continue;

                    if ((settingEW & blocks[1]) != 0 || (settingNS & blocks[2]) != 0)
                        continue;

                    if ((currentSetting & blocks[1]) != 0 || (currentSetting & blocks[2]) != 0)
                        continue;
                }
            }

            if (visited[testColumn][testRow])
            {
                continue;
            }

            columnQueue.add(testColumn);
            rowQueue.add(testRow);
            visited[testColumn][testRow] = true;
            path[testColumn][testRow] = new Coordinate(column, row);
        }
    }

    public void transplantSteps(Character character, int newX, int newY, boolean fromInstance, boolean toInstance)
    {
        if (toInstance)
        {
            transplantInstancedSteps(character, newX, newY, fromInstance);
            return;
        }

        transplantNonInstancedSteps(character, newX, newY, fromInstance);
    }

    public void transplantNonInstancedSteps(Character character, int newX, int newY, boolean fromInstance)
    {
        WorldView worldView = client.getTopLevelWorldView();
        Program program = character.getProgram();
        ProgramComp comp = program.getComp();

        if (!fromInstance)
        {
            WorldPoint[] steps = comp.getStepsWP();
            if (steps.length == 0)
                return;

            int changeX = newX - steps[0].getX();
            int changeY = newY - steps[0].getY();

            WorldPoint[] newSteps = new WorldPoint[steps.length];
            for (int i = 0; i < steps.length; i++)
            {
                WorldPoint wp = steps[i];
                WorldPoint point = new WorldPoint(wp.getX() + changeX, wp.getY() + changeY, worldView.getPlane());
                newSteps[i] = point;
            }

            comp.setStepsWP(newSteps);
            comp.setCurrentStep(0);
            return;
        }

        //Translate from LocalPoints to WorldPoints
        LocalPoint[] steps = comp.getStepsLP();
        if (steps.length == 0)
            return;

        WorldPoint[] newSteps = new WorldPoint[steps.length];
        newSteps[0] = new WorldPoint(newX, newY, worldView.getPlane());

        int[] changeXArray = new int[steps.length];
        int[] changeYArray = new int[steps.length];
        changeXArray[0] = 0;
        changeYArray[0] = 0;

        if (steps.length > 1)
        {
            for (int i = 1; i < steps.length; i++)
            {
                changeXArray[i] = changeXArray[i - 1] + steps[i].getSceneX() - steps[i - 1].getSceneX();
                changeYArray[i] = changeYArray[i - 1] + steps[i].getSceneY() - steps[i - 1].getSceneY();
            }

            for (int i = 1; i < steps.length; i++)
            {
                WorldPoint point = new WorldPoint(newX + changeXArray[i], newY + changeYArray[i], worldView.getPlane());
                newSteps[i] = point;
            }
        }

        comp.setStepsWP(newSteps);
        comp.setCurrentStep(0);

    }

    public void transplantInstancedSteps(Character character, int newX, int newY, boolean fromInstance)
    {
        Scene scene = client.getTopLevelWorldView().getScene();
        Program program = character.getProgram();
        ProgramComp comp = program.getComp();

        if (fromInstance)
        {
            LocalPoint[] steps = comp.getStepsLP();
            if (steps.length == 0)
                return;

            int changeX = newX - steps[0].getSceneX();
            int changeY = newY - steps[0].getSceneY();

            LocalPoint[] newSteps = new LocalPoint[steps.length];
            for (int i = 0; i < steps.length; i++)
            {
                LocalPoint lp = steps[i];
                LocalPoint point = LocalPoint.fromScene(lp.getSceneX() + changeX, lp.getSceneY() + changeY, scene);
                newSteps[i] = point;
            }

            comp.setStepsLP(newSteps);
            comp.setCurrentStep(0);
            return;
        }

        //Translate from WorldPoints to LocalPoints
        WorldPoint[] steps = comp.getStepsWP();
        if (steps.length == 0)
            return;

        LocalPoint[] newSteps = new LocalPoint[steps.length];
        newSteps[0] = LocalPoint.fromScene(newX, newY, scene);

        int[] changeXArray = new int[steps.length];
        int[] changeYArray = new int[steps.length];
        changeXArray[0] = 0;
        changeYArray[0] = 0;

        if (steps.length > 1)
        {
            for (int i = 1; i < steps.length; i++)
            {
                changeXArray[i] = changeXArray[i - 1] + steps[i].getX() - steps[i - 1].getX();
                changeYArray[i] = changeYArray[i - 1] + steps[i].getY() - steps[i - 1].getY();
            }

            for (int i = 1; i < steps.length; i++)
            {
                LocalPoint point = LocalPoint.fromScene(newX + changeXArray[i], newY + changeYArray[i], scene);
                newSteps[i] = point;
            }
        }

        comp.setStepsLP(newSteps);
        comp.setCurrentStep(0);
    }

    /*
    private int[] calibrateForRegions(Character character)
    {
        int[] mapRegions = client.getMapRegions();
        Object[] mapRegionsObject = {mapRegions};

        int[] savedRegions = character.getLocalPointRegions();
        Object[] savedRegionsObject = {savedRegions};

        if (Arrays.deepEquals(mapRegionsObject, savedRegionsObject))
            return new int[]{0, 0};

        int mapRegionCorner = mapRegions[0];
        int savedRegionCorner = savedRegions[0];
        int difference = savedRegionCorner - mapRegionCorner;

        int yChange = 0;
        int xChange = 0;

        while (difference != 0)
        {
            if (difference >= REGION_ID_X)
            {
                difference -= REGION_ID_X;
                xChange++;
            }
            else if (difference <= -REGION_ID_X)
            {
                difference += REGION_ID_X;
                xChange--;
            }
            else
            {
                yChange = difference;
                break;
            }
        }

        return new int[]{xChange * Constants.REGION_SIZE, yChange * Constants.REGION_SIZE};
    }

     */
}

package com.creatorskit.saves;

import com.creatorskit.swing.FolderType;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class FolderNodeSave
{
    private FolderType folderType;
    private String name;
    private CharacterSave[] characterSaves;
    private FolderNodeSave[] folderSaves;
}

package com.creatorskit.saves;

import com.creatorskit.models.CustomModelComp;
import com.creatorskit.swing.TransmogAnimationMode;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class TransmogSave
{
    private CustomModelComp customModelComp;
    private TransmogAnimationMode transmogAnimationMode;
    private int[][] animationSwaps;
    private int poseAnimation;
    private int walkAnimation;
    private int runAnimation;
    private int actionAnimation;
    private int backwardsAnimation;
    private int rightAnimation;
    private int leftAnimation;
    private int rotateAnimation;
    private int radius;
}

package com.creatorskit.saves;

import com.creatorskit.models.CustomModelComp;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class SetupSave
{
    private String version;
    private CustomModelComp[] comps;
    private FolderNodeSave masterFolderNode;
    private CharacterSave[] saves;
}

package com.creatorskit.saves;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TransmogLoadOption
{
    BOTH("Both"),
    CUSTOM_MODEL("Custom Model"),
    ANIMATIONS("Animations")
    ;

    private String string;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.saves;

import com.creatorskit.programming.ProgramComp;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@AllArgsConstructor
@Getter
@Setter
public class CharacterSave
{
    private String name;
    private boolean locationSet;
    private WorldPoint nonInstancedPoint;
    private LocalPoint instancedPoint;
    private int[] instancedRegions;
    private int instancedPlane;
    private boolean inInstance;
    private int compId;
    private boolean customMode;
    private int modelId;
    private boolean active;
    private int radius;
    private int rotation;
    private int animationId;
    private int frame;
    private ProgramComp programComp;
    private KeyFrame[][] keyFrames;
}

package com.creatorskit;

import com.creatorskit.models.*;
import com.creatorskit.models.exporters.ModelExporter;
import com.creatorskit.programming.*;
import com.creatorskit.saves.TransmogLoadOption;
import com.creatorskit.saves.TransmogSave;
import com.creatorskit.swing.*;
import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.util.*;

@Slf4j
@Getter
@Setter
@PluginDescriptor(
		name = "Creator's Kit",
		description = "A suite of tools for creators",
		tags = {"tool", "creator", "content", "kit", "camera", "immersion", "export"}
)
public class CreatorsPlugin extends Plugin implements MouseListener {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CreatorsConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private CreatorsOverlay overlay;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ModelGetter modelGetter;

	@Inject
	private PathFinder pathFinder;

	@Inject
	private DataFinder dataFinder;

	@Inject
	private ModelExporter modelExporter;

	@Inject
	private Gson gson;

	private CreatorsPanel creatorsPanel;
	private NavigationButton navigationButton;
	private boolean overlaysActive = false;
	private final ArrayList<Character> characters = new ArrayList<>();
	private final ArrayList<CustomModel> storedModels = new ArrayList<>();
	private Character selectedCharacter;
	private Character hoveredCharacter;
	private CKObject transmog;
	private CKObject previewObject;
	private Model previewArrow;
	private CustomModel transmogModel;
	private int savedRegion = -1;
	private int savedPlane = -1;
	private AutoRotate autoRotateYaw = AutoRotate.OFF;
	private AutoRotate autoRotatePitch = AutoRotate.OFF;
	private int oculusOrbSpeed = 36;
	private double clickX;
	private double clickY;
	private double mouseX;
	private double mouseY;
	private boolean mousePressed = false;
	private boolean pauseMode = true;
	private boolean autoSetupPathFound = true;
	private boolean autoTransmogFound = true;
	private boolean controlDown = false;

	private boolean test2_0 = false;

	@Override
	protected void startUp() throws Exception
	{
		creatorsPanel = injector.getInstance(CreatorsPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panelicon.png");
		navigationButton = NavigationButton.builder()
				.tooltip("Creator's Kit")
				.icon(icon)
				.priority(10)
				.panel(creatorsPanel)
				.build();

		eventBus.register(creatorsPanel.getToolBox().getProgrammer());

		clientToolbar.addNavigation(navigationButton);
		overlayManager.add(overlay);
		keyManager.registerKeyListener(overlayKeyListener);
		keyManager.registerKeyListener(oculusOrbListener);
		keyManager.registerKeyListener(orbSpeedListener);
		keyManager.registerKeyListener(orbPreset1Listener);
		keyManager.registerKeyListener(orbPreset2Listener);
		keyManager.registerKeyListener(orbPreset3Listener);
		keyManager.registerKeyListener(quickSpawnListener);
		keyManager.registerKeyListener(quickLocationListener);
		keyManager.registerKeyListener(quickDuplicateListener);
		keyManager.registerKeyListener(quickRotateCWListener);
		keyManager.registerKeyListener(quickRotateCCWListener);
		keyManager.registerKeyListener(autoLeftListener);
		keyManager.registerKeyListener(autoRightListener);
		keyManager.registerKeyListener(autoUpListener);
		keyManager.registerKeyListener(autoDownListener);
		keyManager.registerKeyListener(addProgramStepListener);
		keyManager.registerKeyListener(removeProgramStepListener);
		keyManager.registerKeyListener(clearProgramStepListener);
		keyManager.registerKeyListener(resetListener);
		keyManager.registerKeyListener(playPauseListener);
		keyManager.registerKeyListener(playPauseAllListener);
		keyManager.registerKeyListener(resetAllListener);
		mouseManager.registerMouseWheelListener(this::mouseWheelMoved);
		mouseManager.registerMouseListener(this);

		if (config.autoSetup())
		{
			File SETUP_DIR = new File(config.setupPath());
			if (!SETUP_DIR.exists())
			{
				SETUP_DIR = new File(config.setupPath() + ".json");
				if (!SETUP_DIR.exists())
				{
					SETUP_DIR = new File(config.setupPath().replaceAll("/", "\\\\"));
					if (!SETUP_DIR.exists())
					{
						SETUP_DIR = new File(config.setupPath().replaceAll("/", "\\\\") + ".json");
					}
				}
			}

			if (SETUP_DIR.exists())
			{
				creatorsPanel.loadSetup(SETUP_DIR);
			}
			else
			{
				autoSetupPathFound = false;
			}
		}

		if (config.autoTransmog())
		{
			File TRANSMOG_DIR = new File(config.transmogPath());
			if (!TRANSMOG_DIR.exists())
			{
				TRANSMOG_DIR = new File(config.transmogPath() + ".json");
				if (!TRANSMOG_DIR.exists())
				{
					TRANSMOG_DIR = new File(config.transmogPath().replaceAll("/", "\\\\"));
					if (!TRANSMOG_DIR.exists())
					{
						TRANSMOG_DIR = new File(config.transmogPath().replaceAll("/", "\\\\") + ".json");
					}
				}
			}

			if (TRANSMOG_DIR.exists())
			{
				loadTransmog(TRANSMOG_DIR, TransmogLoadOption.BOTH);
			}
			else
			{
				autoTransmogFound = false;
			}
		}

		oculusOrbSpeed = config.orbSpeed();
	}

	@Override
	protected void shutDown() throws Exception
	{
		creatorsPanel.clearSidePanels(false);
		creatorsPanel.clearManagerPanels();

		eventBus.unregister(creatorsPanel.getToolBox().getProgrammer());

		clientToolbar.removeNavigation(navigationButton);
		overlayManager.remove(overlay);
		keyManager.unregisterKeyListener(overlayKeyListener);
		keyManager.unregisterKeyListener(oculusOrbListener);
		keyManager.unregisterKeyListener(orbSpeedListener);
		keyManager.unregisterKeyListener(orbPreset1Listener);
		keyManager.unregisterKeyListener(orbPreset2Listener);
		keyManager.unregisterKeyListener(orbPreset3Listener);
		keyManager.unregisterKeyListener(quickSpawnListener);
		keyManager.unregisterKeyListener(quickLocationListener);
		keyManager.unregisterKeyListener(quickDuplicateListener);
		keyManager.unregisterKeyListener(quickRotateCWListener);
		keyManager.unregisterKeyListener(quickRotateCCWListener);
		keyManager.unregisterKeyListener(autoLeftListener);
		keyManager.unregisterKeyListener(autoRightListener);
		keyManager.unregisterKeyListener(autoUpListener);
		keyManager.unregisterKeyListener(autoDownListener);
		keyManager.unregisterKeyListener(addProgramStepListener);
		keyManager.unregisterKeyListener(removeProgramStepListener);
		keyManager.unregisterKeyListener(clearProgramStepListener);
		keyManager.unregisterKeyListener(resetListener);
		keyManager.unregisterKeyListener(playPauseListener);
		keyManager.unregisterKeyListener(playPauseAllListener);
		keyManager.unregisterKeyListener(resetAllListener);
		mouseManager.unregisterMouseWheelListener(this::mouseWheelMoved);
		mouseManager.unregisterMouseListener(this);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		if (!autoSetupPathFound)
		{
			autoSetupPathFound = true;
			sendChatMessage("Creator's Kit auto-Setup has failed to find the file at the path: " + config.setupPath());
			sendChatMessage("Please ensure the config menu has the appropriate file path.");
		}

		if (!autoTransmogFound)
		{
			autoTransmogFound = true;
			sendChatMessage("Creator's Kit auto-Transmog has failed to find the file at the path: " + config.transmogPath());
			sendChatMessage("Please ensure the config menu has the appropriate file path.");
		}

		if (client.getLocalPlayer() == null)
			return;

		WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
		LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
		WorldView worldView = client.getTopLevelWorldView();

		int region = worldView.getScene().isInstance() ? WorldPoint.fromLocalInstance(client, localPoint).getRegionID() : worldPoint.getRegionID();

		if (savedRegion != region)
			savedRegion = region;

		int plane = worldView.getPlane();
		if (savedPlane != plane)
		{
			savedPlane = plane;
			for (int i = 0; i < characters.size(); i++)
			{
				Character character = characters.get(i);
				boolean active = character.isActive();
				setLocation(character, false, false, false, true);
				resetProgram(character, character.getProgram().getComp().isProgramActive());
				if (!active)
					despawnCharacter(character);
			}
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		updatePreviewObject(client.getTopLevelWorldView().getSelectedSceneTile());

		switch (autoRotateYaw)
		{
			case LEFT:
				client.setCameraYawTarget(client.getCameraYaw() - config.rotateHorizontalSpeed());
				break;
			case RIGHT:
				client.setCameraYawTarget(client.getCameraYaw() + config.rotateHorizontalSpeed());
		}

		switch (autoRotatePitch)
		{
			case UP:
				client.setCameraPitchTarget(client.getCameraPitch() + config.rotateVerticalSpeed());
				break;
			case DOWN:
				client.setCameraPitchTarget(client.getCameraPitch() - config.rotateVerticalSpeed());
		}

		Player player = client.getLocalPlayer();
		WorldView worldView = client.getTopLevelWorldView();

		for (int i = 0; i < characters.size(); i++)
		{
			Character character = characters.get(i);
			Program program = character.getProgram();
			ProgramComp comp = program.getComp();
			CKObject CKObject = character.getCKObject();
			boolean instance = worldView.getScene().isInstance();

			if (CKObject == null)
				continue;

			if (!isInScene(character))
				continue;

			if (!comp.isProgramActive())
			{
				int animId = CKObject.getAnimationId();
				if (animId == -1)
					continue;

				if (animId != comp.getIdleAnim())
					CKObject.setAnimation(comp.getIdleAnim());

				continue;
			}

			double speed = 128 * (comp.getSpeed() * 20 / 600);
			int currentStep = comp.getCurrentStep();

			int pathLength = instance ? comp.getPathLP().length : comp.getPathWP().length;
			if (currentStep >= pathLength)
			{
				if (comp.isLoop())
				{
					resetProgram(character, true);
					continue;
				}

				int animId = CKObject.getAnimationId();
				if (animId == -1)
					continue;

				if (animId != comp.getIdleAnim())
					CKObject.setAnimation(comp.getIdleAnim());

				continue;
			}

			int currentAnim = CKObject.getAnimationId();;
			if (currentAnim != -1 && currentAnim != comp.getWalkAnim())
			{
				int walkAnimId = comp.getWalkAnim();
				if (walkAnimId == -1)
					walkAnimId = comp.getIdleAnim();

				if (currentAnim != walkAnimId)
					CKObject.setAnimation(comp.getWalkAnim());
			}

			LocalPoint start = CKObject.getLocation();
			LocalPoint destination;

			if (instance)
			{
				destination = comp.getPathLP()[currentStep];
			}
			else
			{
				destination = LocalPoint.fromWorld(worldView, comp.getPathWP()[currentStep]);
			}

			if (destination == null)
				continue;

			int startX = start.getX();
			int startY = start.getY();
			int destX = destination.getX();
			int destY = destination.getY();

			int endX = startX;
			int endY = startY;

			double changeX = destX - startX;
			double changeY = destY - startY;
			double angle = Orientation.radiansToJAngle(Math.atan(changeY / changeX), changeX, changeY);

			character.setTargetOrientation((int) angle);

			if (destX != startX)
			{
				int change = ((int) speed * Orientation.orientationX(angle));
				endX = startX + change;
			}

			if (destY != startY)
			{
				int change = ((int) speed * Orientation.orientationY(angle));
				endY = startY + change;
			}

			if (endX == destX && endY == destY)
			{
				int nextStep = currentStep + 1;
				comp.setCurrentStep(nextStep);
				if (nextStep < pathLength)
				{
					LocalPoint nextPath;

					if (instance)
					{
						nextPath = comp.getPathLP()[currentStep];
					}
					else
					{
						nextPath = LocalPoint.fromWorld(worldView, comp.getPathWP()[currentStep]);
					}

					if (nextPath == null)
						continue;

					int nextX = nextPath.getSceneX();
					int nextY = nextPath.getSceneY();
					double nextChangeX = nextX - start.getSceneX();
					double nextChangeY = nextY - start.getSceneY();
					double nextAngle = Orientation.radiansToJAngle(Math.atan(nextChangeY / nextChangeX), nextChangeX, nextChangeY);
					character.setTargetOrientation((int) nextAngle);
				}
			}

			int orientation = CKObject.getOrientation();
			int targetOrientation = character.getTargetOrientation();
			int turnSpeed = comp.getTurnSpeed();
			if (orientation != targetOrientation)
			{
				int newOrientation;
				int difference = Orientation.subtract(targetOrientation, orientation);

				if (difference > (turnSpeed * -1) && difference < turnSpeed)
				{
					newOrientation = targetOrientation;
				}
				else if (difference > 0)
				{
					newOrientation = Orientation.boundOrientation(orientation + turnSpeed);
				}
				else
				{
					newOrientation = Orientation.boundOrientation(orientation - turnSpeed);
				}

				CKObject.setOrientation(newOrientation);
			}

			LocalPoint finalPoint = new LocalPoint(endX, endY, worldView);
			CKObject.setLocation(finalPoint, worldView.getPlane());
		}

		TransmogPanel transmogPanel = creatorsPanel.getTransmogPanel();

		if (config.enableTransmog() && transmog != null)
		{
			if (player == null)
				return;

			LocalPoint localPoint = player.getLocalLocation();
			transmog.setLocation(localPoint, worldView.getPlane());
			transmog.setOrientation(player.getCurrentOrientation());
			transmog.setActive(true);

			int playerAnimation = player.getAnimation();
			int playerPose = player.getPoseAnimation();
			int animId = transmog.getAnimationId();

			int transmogAnimation = -1;
			if (animId != -1)
				transmogAnimation = animId;

			TransmogAnimationMode animationMode = transmogPanel.getTransmogAnimationMode();
			if (animationMode == TransmogAnimationMode.PLAYER)
			{
				if (playerAnimation == -1)
				{
					if (transmogAnimation != playerPose)
						transmog.setAnimation(playerPose);
				}
			}

			if (animationMode == TransmogAnimationMode.CUSTOM || animationMode == TransmogAnimationMode.MODIFIED)
			{
				if (playerAnimation == -1)
				{
					int pose = transmogPanel.getPoseAnimation();
					int walk = transmogPanel.getWalkAnimation();
					int run = transmogPanel.getRunAnimation();
					int backwards = transmogPanel.getBackwardsAnimation();
					int left = transmogPanel.getLeftAnimation();
					int right = transmogPanel.getRightAnimation();
					int rotate = transmogPanel.getRotateAnimation();

					if (animationMode == TransmogAnimationMode.MODIFIED)
					{
						if (pose == -1)
							pose = playerPose;
						if (walk == -1)
							walk = playerPose;
						if (run == -1)
							run = playerPose;
						if (backwards == -1)
							backwards = playerPose;
						if (left == -1)
							left = playerPose;
						if (right == -1)
							right = playerPose;
						if (rotate == -1)
							rotate = playerPose;
					}

					PoseAnimation poseAnimation = AnimationData.getPoseAnimation(playerPose);

					if (pose != -1 && poseAnimation == PoseAnimation.POSE)
					{
						if (transmogAnimation != pose)
							transmog.setAnimation(pose);
					}
					else if (walk != -1 && poseAnimation == PoseAnimation.WALK)
					{
						if (transmogAnimation != walk)
							transmog.setAnimation(walk);
					}
					else if (run != -1 && poseAnimation == PoseAnimation.RUN)
					{
						if (transmogAnimation != run)
							transmog.setAnimation(run);
					}
					else if (backwards != -1 && poseAnimation == PoseAnimation.BACKWARDS)
					{
						if (transmogAnimation != backwards)
							transmog.setAnimation(backwards);
					}
					else if (right != -1 && poseAnimation == PoseAnimation.SHUFFLE_RIGHT)
					{
						if (transmogAnimation != right)
							transmog.setAnimation(right);
					}
					else if (left != -1 && poseAnimation == PoseAnimation.SHUFFLE_LEFT)
					{
						if (transmogAnimation != left)
							transmog.setAnimation(left);
					}
					else if (rotate != -1 && poseAnimation == PoseAnimation.ROTATE)
					{
						if (transmogAnimation != rotate)
							transmog.setAnimation(rotate);
					}
					else if (animationMode == TransmogAnimationMode.MODIFIED)
					{
						transmog.setAnimation(playerPose);
					}
					else
					{
						if (transmogAnimation != walk)
							transmog.setAnimation(walk);
					}
				}
			}
		}
	}

	@Subscribe
	public void onAnimationChanged(AnimationChanged event)
	{
		if (!config.enableTransmog() || transmog == null)
			return;

		TransmogPanel transmogPanel = creatorsPanel.getTransmogPanel();
		TransmogAnimationMode animationMode = transmogPanel.getTransmogAnimationMode();

		if (animationMode == TransmogAnimationMode.NONE)
			return;

		if (event.getActor() instanceof Player)
		{
			Player player = (Player) event.getActor();
			if (player != client.getLocalPlayer())
				return;

			int playerAnimation = player.getAnimation();
			int animId = transmog.getAnimationId();
			int transmogAnimation = -1;
			if (animId != -1)
				transmogAnimation = animId;

			int action = transmogPanel.getActionAnimation();

			if (animationMode == TransmogAnimationMode.PLAYER && transmogAnimation != playerAnimation)
			{
				transmog.setAnimation(playerAnimation);
				return;
			}

			int[][] animationSwaps = transmogPanel.getAnimationSwaps();
			for (int[] swap : animationSwaps)
			{
				if (swap[0] == player.getAnimation() && transmogAnimation != swap[1])
				{
					transmog.setAnimation(swap[1]);
					return;
				}
			}

			if (animationMode == TransmogAnimationMode.MODIFIED && transmogAnimation != playerAnimation && action == -1)
				transmog.setAnimation(playerAnimation);

			if (animationMode == TransmogAnimationMode.MODIFIED && transmogAnimation != action && action != -1)
				transmog.setAnimation(action);

			if (animationMode == TransmogAnimationMode.CUSTOM && transmogAnimation != action)
				transmog.setAnimation(action);
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			WorldView worldView = client.getTopLevelWorldView();
			boolean instance = worldView.getScene().isInstance();

			for (Character character : characters)
			{
				boolean active = character.isActive();
				setLocation(character, false, false, false, true);
				resetProgram(character, character.getProgram().getComp().isProgramActive());
				if ((character.isInInstance() && instance && worldView.getPlane() == character.getInstancedPlane()) || (!character.isInInstance() && !instance))
					updateProgramPath(character.getProgram(), true, character.isInInstance());

				if (!active)
					despawnCharacter(character);
			}

			if (config.enableTransmog() && transmog != null)
			{
				transmog.setActive(false);
				transmog.setActive(true);
			}
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getKey().equals("orbSpeed"))
		{
			client.setFreeCameraSpeed(config.orbSpeed());
			oculusOrbSpeed = config.orbSpeed();
		}

		if (event.getKey().equals("enableTransmog"))
		{
			if (transmog == null)
				return;

			clientThread.invokeLater(() ->
			{
				boolean enableTransmog = config.enableTransmog();
				transmog.setActive(enableTransmog);
				if (!enableTransmog)
				{
					transmog.setAnimation(-1);
				}
			});
		}
	}

	@Subscribe
	public void onPostMenuSort(PostMenuSort event)
	{
		if (config.enableCtrlHotkeys() && client.isKeyPressed(KeyCode.KC_CONTROL))
		{
			if (selectedCharacter != null)
			{
				client.getMenu().createMenuEntry(-1)
						.setOption(ColorUtil.prependColorTag("Relocate", Color.ORANGE))
						.setTarget(ColorUtil.colorTag(Color.GREEN) + selectedCharacter.getName())
						.setType(MenuAction.RUNELITE)
						.onClick(e -> setLocation(selectedCharacter, true, false, true, false));
			}
		}

		WorldView worldView = client.getTopLevelWorldView();
		Tile tile = worldView.getSelectedSceneTile();
		if (tile == null)
		{
			return;
		}

		MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
		boolean hoveringTile = false;
		for (MenuEntry menuEntry : menuEntries)
		{
			if (menuEntry.getOption().equals("Walk here"))
			{
				hoveringTile = true;
				break;
			}
		}

		if (!hoveringTile)
		{
			return;
		}

		modelGetter.addCharacterMenuEntries(tile);
		modelGetter.addLocalPlayerMenuEntries(tile);
		modelGetter.addTileItemMenuEntries(tile);
		modelGetter.addTileObjectMenuEntries(tile);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.rightClick() && !config.transmogRightClick() && !config.rightSpotAnim() && !config.exportRightClick())
			return;

		String target = event.getTarget();
		String option = event.getOption();

		NPC npc = event.getMenuEntry().getNpc();
		if (npc != null && option.equals("Examine"))
		{
			if (config.rightClick())
			{
				if (client.isKeyPressed(KeyCode.KC_CONTROL))
				{
					modelGetter.storeNPC(1, target, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), npc, ModelMenuOption.STORE_AND_ADD);
				}
				else
				{
					modelGetter.storeNPC(1, target, ColorUtil.prependColorTag("Store", Color.ORANGE), npc, ModelMenuOption.STORE);
				}
				modelGetter.sendToAnvilNPC(1, target, npc);
			}

			if (config.transmogRightClick())
			{
				modelGetter.storeNPC(1, target, ColorUtil.prependColorTag("Transmog", Color.ORANGE), npc, ModelMenuOption.TRANSMOG);
			}

			if (config.rightSpotAnim())
			{
				if (client.isKeyPressed(KeyCode.KC_CONTROL))
				{
					modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store-Add", Color.ORANGE), npc.getSpotAnims(), ModelMenuOption.STORE_AND_ADD);
				}
				else
				{
					modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store", Color.ORANGE), npc.getSpotAnims(), ModelMenuOption.STORE);
				}
				modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Anvil", Color.ORANGE), npc.getSpotAnims(), ModelMenuOption.ANVIL);
			}

			if (config.exportRightClick())
			{
				modelGetter.addNPCExporter(1, target, npc, false);
				modelGetter.addNPCExporter(1, target, npc, true);
			}
		}

		Player player = event.getMenuEntry().getPlayer();
		if (player != null && option.equals("Trade with"))
		{
			if (config.rightClick())
			{
				if (client.isKeyPressed(KeyCode.KC_CONTROL))
				{
					modelGetter.addPlayerGetter(1, target, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), player, ModelMenuOption.STORE_AND_ADD);
				}
				else
				{
					modelGetter.addPlayerGetter(1, target, ColorUtil.prependColorTag("Store", Color.ORANGE), player, ModelMenuOption.STORE);
				}

				modelGetter.addPlayerGetter(1, target, ColorUtil.prependColorTag("Anvil", Color.ORANGE), player, ModelMenuOption.ANVIL);
			}

			if (config.transmogRightClick())
			{
				modelGetter.addPlayerGetter(1, target, ColorUtil.prependColorTag("Transmog", Color.ORANGE), player, ModelMenuOption.TRANSMOG);
			}

			if (config.rightSpotAnim())
			{
				if (client.isKeyPressed(KeyCode.KC_CONTROL))
				{
					modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store-Add", Color.ORANGE), player.getSpotAnims(), ModelMenuOption.STORE_AND_ADD);
				}
				else
				{
					modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store", Color.ORANGE), player.getSpotAnims(), ModelMenuOption.STORE);
				}
				modelGetter.addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Anvil", Color.ORANGE), player.getSpotAnims(), ModelMenuOption.ANVIL);
			}

			if (config.exportRightClick())
			{
				modelGetter.addPlayerExporter(1, target, player, false);
				modelGetter.addPlayerExporter(1, target, player, true);
			}
		}
	}

	public void setLocation(Character character, boolean newLocation, boolean setToPlayer, boolean setToHoveredTile, boolean setToPathStart)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		boolean instance = client.getTopLevelWorldView().getScene().isInstance();

		if (!newLocation && !isInScene(character))
			return;

		if (instance)
		{
			setLocationInstance(character, setToPlayer, setToHoveredTile, setToPathStart);
			return;
		}

		setLocationNonInstance(character, setToPlayer, setToHoveredTile, setToPathStart);
	}

	public void setLocationNonInstance(Character character, boolean setToPlayer, boolean setToHoveredTile, boolean setToPathStart)
	{
		clientThread.invoke(() ->
		{
			WorldView worldView = client.getTopLevelWorldView();
			LocalPoint localPoint;
			WorldPoint[] steps = character.getProgram().getComp().getStepsWP();

			if (setToPlayer)
			{
				localPoint = client.getLocalPlayer().getLocalLocation();
			}
			else if (setToHoveredTile)
			{
				Tile tile = worldView.getSelectedSceneTile();
				if (tile == null)
					return;

				localPoint = tile.getLocalLocation();
			}
			else if (setToPathStart && steps.length > 0)
			{
				localPoint = LocalPoint.fromWorld(worldView, steps[0]);
			}
			else
			{
				if (character.getNonInstancedPoint() == null)
				{
					localPoint = client.getLocalPlayer().getLocalLocation();
				}
				else
				{
					localPoint = LocalPoint.fromWorld(worldView, character.getNonInstancedPoint());
				}
			}

			if (localPoint == null)
				return;

			WorldPoint newLocation = WorldPoint.fromLocalInstance(client, localPoint);

			character.setLocationSet(true);

			if (newLocation != null)
			{
				pathFinder.transplantSteps(character, newLocation.getX(), newLocation.getY(), character.isInInstance(), false);
				character.setInInstance(false);
				character.setNonInstancedPoint(newLocation);
				updateProgramPath(character.getProgram(), false, false);
			}

			CKObject CKObject = character.getCKObject();
			CKObject.setActive(false);
			CKObject.setLocation(localPoint, worldView.getPlane());
			CKObject.setActive(true);
			CKObject.setOrientation((int) character.getOrientationSpinner().getValue());
			character.setActive(true);
			character.getSpawnButton().setText("Spawn");
		});
	}

	public void setLocationInstance(Character character, boolean setToPlayer, boolean setToHoveredTile, boolean setToPathStart)
	{
		clientThread.invoke(() ->
		{
			WorldView worldView = client.getTopLevelWorldView();
			LocalPoint localPoint;
			LocalPoint[] steps = character.getProgram().getComp().getStepsLP();

			if (setToPlayer)
			{
				localPoint = client.getLocalPlayer().getLocalLocation();
			}
			else if (setToHoveredTile)
			{
				Tile tile = worldView.getSelectedSceneTile();
				if (tile == null)
					return;

				localPoint = tile.getLocalLocation();
			}
			else if (setToPathStart && steps.length > 0)
			{
				localPoint = steps[0];
			}
			else
			{
				localPoint = character.getInstancedPoint();
			}

			if (localPoint == null)
				return;

			character.setInstancedPoint(localPoint);
			pathFinder.transplantSteps(character, localPoint.getSceneX(), localPoint.getSceneY(), character.isInInstance(), true);
			character.setLocationSet(true);
			character.setInInstance(true);
			character.setInstancedRegions(client.getMapRegions());
			character.setInstancedPlane(worldView.getPlane());
			updateProgramPath(character.getProgram(), false, true);
			CKObject CKObject = character.getCKObject();
			CKObject.setActive(false);
			CKObject.setLocation(localPoint, worldView.getPlane());
			CKObject.setActive(true);
			CKObject.setOrientation((int) character.getOrientationSpinner().getValue());
			character.setActive(true);
			character.getSpawnButton().setText("Spawn");
		});
	}

	public boolean isInScene(Character character)
	{
		WorldView worldView = client.getTopLevelWorldView();
		boolean instance = worldView.getScene().isInstance();
		int[] mapRegions = client.getMapRegions();
		if (instance && character.isInInstance())
		{
			if (character.getInstancedPoint() == null)
				return false;

			if (character.getInstancedPlane() != worldView.getPlane())
				return false;

			//This function is finicky with larger instances, in that only an exact region:region map will load
			//The alternative of finding any match will otherwise make spawns off if the regions don't match because the scenes won't exactly match
			Object[] mapRegionsObjects = {mapRegions};
			Object[] instancedRegionObjects = {character.getInstancedRegions()};
			return Arrays.deepEquals(mapRegionsObjects, instancedRegionObjects);
		}

		if (!instance && !character.isInInstance())
		{
			WorldPoint worldPoint = character.getNonInstancedPoint();
			if (worldPoint == null)
				return false;

			return worldPoint.isInScene(client);
		}

		return false;
	}

	public void toggleSpawn(JButton spawnButton, Character character)
	{
		if (character.isActive())
		{
			despawnCharacter(character);
			spawnButton.setText("Depawn");
			return;
		}

		spawnCharacter(character);
		spawnButton.setText("Spawn");

		if (!character.isLocationSet())
		{
			setLocation(character, true, true, false, false);
		}
	}

	public void spawnCharacter(Character character)
	{
		CKObject CKObject = character.getCKObject();
		character.setActive(true);
		clientThread.invokeLater(() -> CKObject.setActive(true));
	}

	public void despawnCharacter(Character character)
	{
		CKObject CKObject = character.getCKObject();
		character.setActive(false);
		clientThread.invokeLater(() -> CKObject.setActive(false));
	}

	public void setModel(Character character, boolean modelMode, int modelId)
	{
		CKObject CKObject = character.getCKObject();
		clientThread.invokeLater(() -> {
			if (modelMode)
			{
				CustomModel customModel = character.getStoredModel();
				Model model = customModel == null ? client.loadModel(29757) : customModel.getModel();
				CKObject.setModel(model);
				return;
			}

			Model model = client.loadModel(modelId);
			CKObject.setModel(model);
		});
	}

	public void setAnimation(Character character, int animationId)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		CKObject CKObject = character.getCKObject();
		clientThread.invoke(() ->
		{
			CKObject.setAnimation(animationId);
		});
	}

	public void unsetAnimation(Character character)
	{
		CKObject CKObject = character.getCKObject();
		clientThread.invoke(() ->
		{
			CKObject.setAnimation(-1);
		});
	}

	public void setAnimationFrame(Character character, int animFrame, boolean allowPause)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		CKObject CKObject = character.getCKObject();
		clientThread.invoke(() ->
		{
			CKObject.setAnimationFrame(animFrame, allowPause);
		});
	}

	public void setRadius(Character character, int radius)
	{
		CKObject CKObject = character.getCKObject();
		clientThread.invoke(() -> CKObject.setRadius(radius));
	}

	public void addOrientation(Character character, int addition)
	{
		CKObject CKObject = character.getCKObject();
		int orientation = CKObject.getOrientation();
		orientation += addition;
		if (orientation >= 2048)
			orientation -= 2048;

		if (orientation < 0)
			orientation += 2048;

		setOrientation(character, orientation);
	}

	public void setOrientation(Character character, int orientation)
	{
		CKObject CKObject = character.getCKObject();
		character.getOrientationSpinner().setValue(orientation);
		clientThread.invokeLater(() -> CKObject.setOrientation(orientation));
	}

	public void setupRLObject(Character character, boolean setHoveredTile)
	{
		clientThread.invoke(() ->
		{
			CKObject CKObject = new CKObject(client);
			client.registerRuneLiteObject(CKObject);
			character.setCKObject(CKObject);

			CKObject.setRadius((int) character.getRadiusSpinner().getValue());
			CKObject.setOrientation((int) character.getOrientationSpinner().getValue());
			CKObject.setDrawFrontTilesFirst(true);

			boolean active = character.isActive();

			setModel(character, character.isCustomMode(), (int) character.getModelSpinner().getValue());
			setAnimation(character, (int) character.getAnimationSpinner().getValue());
			setAnimationFrame(character, (int) character.getAnimationFrameSpinner().getValue(), true);

			if (setHoveredTile)
			{
				setLocation(character, !character.isLocationSet(), false, true, false);
			}
			else
			{
				setLocation(character, !character.isLocationSet(), false, false, false);
			}

			CKObject.setActive(active);
			character.setActive(active);
		});
	}

	public void removeCharacters(Character[] charactersToRemove)
	{
		clientThread.invokeLater(() -> {
			for (Character character : charactersToRemove)
			{
				CKObject CKObject = character.getCKObject();
				CKObject.setActive(false);
				characters.remove(character);
			}
		});
	}

	public void removeCharacter(ObjectPanel objectPanel)
	{
		for (Character character : characters)
		{
			if (character.getObjectPanel() == objectPanel)
			{
				removeCharacter(character);
				return;
			}
		}
	}

	public void removeCharacter(Character character)
	{
		clientThread.invokeLater(() -> {
				CKObject CKObject = character.getCKObject();
				CKObject.setActive(false);
				characters.remove(character);
		});
	}

	public void sendChatMessage(String chatMessage)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		final String message = new ChatMessageBuilder().append(ChatColorType.HIGHLIGHT).append(chatMessage).build();
		chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage(message).build());
	}

	public Model createComplexModel(DetailedModel[] detailedModels, boolean setPriority, LightingStyle lightingStyle, CustomLighting cl)
	{
		ModelData modelData = createComplexModelData(detailedModels);

		if (cl == null)
		{
			cl = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());
		}

		CustomLighting finalLighting;
		if (lightingStyle == LightingStyle.CUSTOM)
		{
			finalLighting = cl;
		}
		else
		{
			finalLighting = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());
		}

		Model model;
		try
		{
			model = modelData.light(
					finalLighting.getAmbient(),
					finalLighting.getContrast(),
					finalLighting.getX(),
					finalLighting.getZ() * -1,
					finalLighting.getY());
		}
		catch (Exception e)
		{
			sendChatMessage("Could not Forge this model with the chosen Lighting Settings. Please adjust them and try again.");
			return null;
		}

		if (model == null)
			return null;

		if (setPriority)
		{
			byte[] renderPriorities = model.getFaceRenderPriorities();
			if (renderPriorities != null && renderPriorities.length > 0)
				Arrays.fill(renderPriorities, (byte) 0);
		}

		sendChatMessage("Model forged. Faces: " + model.getFaceCount() + ", Vertices: " + model.getVerticesCount());
		if (model.getFaceCount() >= 6200 && model.getVerticesCount() >= 3900)
			sendChatMessage("You've exceeded the max face count of 6200 or vertex count of 3900 in this model; any additional faces or vertices will not render");

		return model;
	}

	public ModelData createComplexModelData(DetailedModel[] detailedModels)
	{
		ModelData[] models = new ModelData[detailedModels.length];
		boolean[] facesToInvert = new boolean[0];

		for (int e = 0; e < detailedModels.length; e++)
		{
			DetailedModel detailedModel = detailedModels[e];
			ModelData modelData = client.loadModelData(detailedModel.getModelId());
			if (modelData == null)
				return null;

			modelData.cloneVertices().cloneColors();

			switch(detailedModel.getRotate())
			{
				case 0:
					break;
				case 1:
					modelData.rotateY270Ccw();
					break;
				case 2:
					modelData.rotateY180Ccw();
					break;
				case 3:
					modelData.rotateY90Ccw();
			}

			//swapping y and z, making y positive to align with traditional axes
			modelData.translate(detailedModel.getXTranslate() + detailedModel.getXTile() * 128, -1 * (detailedModel.getZTranslate() + detailedModel.getZTile() * 128), detailedModel.getYTranslate() + detailedModel.getYTile() * 128);
			modelData.scale(detailedModel.getXScale(), detailedModel.getZScale(), detailedModel.getYScale());

			boolean[] faceInvert = new boolean[modelData.getFaceCount()];
			Arrays.fill(faceInvert, detailedModel.isInvertFaces());
			facesToInvert = ArrayUtils.addAll(facesToInvert, faceInvert);

			short[] coloursFrom = detailedModel.getColoursFrom();
			short[] coloursTo = detailedModel.getColoursTo();

			if (coloursFrom == null || coloursTo == null)
			{
				if (!detailedModel.getRecolourNew().isEmpty() && !detailedModel.getRecolourOld().isEmpty())
				{
					String[] newColoursArray = detailedModel.getRecolourNew().split(",");
					coloursTo = new short[newColoursArray.length];
					String[] oldColoursArray = detailedModel.getRecolourOld().split(",");
					coloursFrom = new short[oldColoursArray.length];

					for (int i = 0; i < coloursFrom.length; i++)
					{
						coloursFrom[i] = Short.parseShort(oldColoursArray[i]);
						coloursTo[i] = Short.parseShort(newColoursArray[i]);
					}
				}
				else
				{
					coloursFrom = new short[0];
					coloursTo = new short[0];
				}

				detailedModel.setColoursFrom(coloursFrom);
				detailedModel.setColoursTo(coloursTo);
			}

			for (int i = 0; i < coloursTo.length; i++)
			{
				modelData.recolor(coloursFrom[i], coloursTo[i]);
			}

			short[] texturesFrom = detailedModel.getTexturesFrom();
			short[] texturesTo = detailedModel.getTexturesTo();
			if (texturesFrom != null && texturesTo != null)
			{
				try
				{
					modelData.cloneTextures();
					for (int i = 0; i < texturesTo.length; i++)
					{
						modelData.retexture(texturesFrom[i], texturesTo[i]);
					}
				}
				catch (Exception f)
				{
				}
			}
			else
			{
				detailedModel.setTexturesFrom(new short[0]);
				detailedModel.setTexturesFrom(new short[0]);
			}

			models[e] = modelData;
		}

		ModelData modelData = client.mergeModels(models);

		int[] faces2 = modelData.getFaceIndices2();
		int[] faces3 = modelData.getFaceIndices3();
		int[] faces2Copy = Arrays.copyOf(faces2, faces2.length);
		for (int i = 0; i < modelData.getFaceCount(); i++)
		{
			if (facesToInvert[i])
			{
				faces2[i] = faces3[i];
				faces3[i] = faces2Copy[i];
			}
		}

		return modelData;
	}

	public void cacheToAnvil(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player)
	{
		SwingUtilities.invokeLater(() ->
		{
			for (ModelStats modelStats : modelStatsArray)
			{
				if (player)
				{
					String name = "Item";
					if (modelStats.getBodyPart() != BodyPart.NA)
						name = modelStats.getBodyPart().toString();

					short[] itemRecolourTo = modelStats.getRecolourTo();
					short[] itemRecolourFrom = modelStats.getRecolourFrom();
					short[] kitRecolourTo = KitRecolourer.getKitRecolourTo(modelStats.getBodyPart(), kitRecolours);
					short[] kitRecolourFrom = KitRecolourer.getKitRecolourFrom(modelStats.getBodyPart());

					itemRecolourTo = ArrayUtils.addAll(itemRecolourTo, kitRecolourTo);
					itemRecolourFrom = ArrayUtils.addAll(itemRecolourFrom, kitRecolourFrom);

					creatorsPanel.getModelAnvil().createComplexPanel(
							name,
							modelStats.getModelId(),
							9,
							0, 0, 0,
							0, 0, modelStats.getTranslateZ(),
							modelStats.getResizeX(), modelStats.getResizeY(), modelStats.getResizeZ(),
							0,
							"", "",
							itemRecolourFrom, itemRecolourTo,
							modelStats.getTextureFrom(), modelStats.getTextureTo(),
							false);

					continue;
				}

				creatorsPanel.getModelAnvil().createComplexPanel(
						"Name",
						modelStats.getModelId(),
						8,
						0, 0, 0,
						0, 0, modelStats.getTranslateZ(),
						modelStats.getResizeX(), modelStats.getResizeY(), modelStats.getResizeZ(),
						0,
						"", "",
						modelStats.getRecolourFrom(), modelStats.getRecolourTo(),
						modelStats.getTextureFrom(), modelStats.getTextureTo(),
						false);
			}
		});
	}

	public void cacheToAnvil(CustomModelType type, int id)
	{
		Thread thread = new Thread(() ->
		{
			ModelStats[] modelStats;
			String name;

			switch (type)
			{
				case CACHE_NPC:
					modelStats = dataFinder.findModelsForNPC(id);
					name = dataFinder.getLastFound();
					break;
				default:
				case CACHE_OBJECT:
					modelStats = dataFinder.findModelsForObject(id, -1, LightingStyle.DEFAULT, true);
					name = dataFinder.getLastFound();
					break;
				case CACHE_GROUND_ITEM:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_GROUND_ITEM);
					name = dataFinder.getLastFound();
					break;
				case CACHE_MAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_MAN_WEAR);
					name = dataFinder.getLastFound();
					break;
				case CACHE_WOMAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_WOMAN_WEAR);
					name = dataFinder.getLastFound();
			}

			if (modelStats == null || modelStats.length == 0)
			{
				sendChatMessage("Could not find the " + type + " you were looking for in the cache.");
				return;
			}

			cacheToAnvil(modelStats, new int[0], false);
			sendChatMessage("Model sent to Anvil: " + name);
		});
		thread.start();
	}

	public void cacheToCustomModel(CustomModelType type, int id, int modelType)
	{
		Thread thread = new Thread(() ->
		{
			ModelStats[] modelStats;
			String name;
			CustomModelComp comp;
			CustomLighting lighting;

			switch (type)
			{
				case CACHE_NPC:
					modelStats = dataFinder.findModelsForNPC(id);
					break;
				default:
				case CACHE_OBJECT:
					modelStats = dataFinder.findModelsForObject(id, modelType, LightingStyle.DEFAULT, false);
					break;
				case CACHE_GROUND_ITEM:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_GROUND_ITEM);
					break;
				case CACHE_MAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_MAN_WEAR);
					break;
				case CACHE_WOMAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_WOMAN_WEAR);
			}

			if (modelStats == null || modelStats.length == 0)
			{
				sendChatMessage("Could not find the " + type + " you were looking for in the cache.");
				return;
			}

			switch (type)
			{
				case CACHE_NPC:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 850, -30, -30, 50);
					comp = new CustomModelComp(0, CustomModelType.CACHE_NPC, id, modelStats, null, null, null, LightingStyle.ACTOR, lighting, false, name);
					break;
				default:
				case CACHE_OBJECT:
					name = dataFinder.getLastFound();
					lighting = modelStats[0].getLighting();
					comp = new CustomModelComp(0, CustomModelType.CACHE_OBJECT, id, modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, name);
					break;
				case CACHE_GROUND_ITEM:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_GROUND_ITEM, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
					break;
				case CACHE_MAN_WEAR:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_MAN_WEAR, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
					break;
				case CACHE_WOMAN_WEAR:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_WOMAN_WEAR, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
			}

			clientThread.invokeLater(() ->
			{
				Model model = constructModelFromCache(modelStats, new int[0], false, true);
				CustomModel customModel = new CustomModel(model, comp);
				addCustomModel(customModel, false);
				sendChatMessage("Model stored: " + name);
			});
		});
		thread.start();
	}

	public Model constructModelFromCache(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player, boolean actorLighting)
	{
		ModelData md = constructModelDataFromCache(modelStatsArray, kitRecolours, player);

		if (actorLighting)
			return client.mergeModels(md).light(64, 850, -30, -50, -30);

		return client.mergeModels(md).light();
	}

	public ModelData constructModelDataFromCache(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player)
	{
		ModelData[] mds = new ModelData[modelStatsArray.length];

		for (int i = 0; i < modelStatsArray.length; i++)
		{
			ModelStats modelStats = modelStatsArray[i];
			ModelData modelData = client.loadModelData(modelStats.getModelId());

			if (modelData == null)
				continue;

			modelData.cloneColors().cloneVertices();

			for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
				modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

			if (player)
				KitRecolourer.recolourKitModel(modelData, modelStats.getBodyPart(), kitRecolours);

			short[] textureFrom = modelStats.getTextureFrom();
			short[] textureTo = modelStats.getTextureTo();

			if (textureFrom == null || textureTo == null)
			{
				modelStats.setTextureFrom(new short[0]);
				modelStats.setTextureTo(new short[0]);
			}

			textureFrom = modelStats.getTextureFrom();
			textureTo = modelStats.getTextureTo();

			if (textureFrom.length > 0 && textureTo.length > 0)
			{
				for (int e = 0; e < textureFrom.length; e++)
				{
					modelData.retexture(textureFrom[e], textureTo[e]);
				}
			}

			if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
			{
				modelStats.setResizeX(128);
				modelStats.setResizeY(128);
				modelStats.setResizeZ(128);
			}

			modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());

			modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

			mds[i] = modelData;
		}

		return client.mergeModels(mds);
	}

	public void customModelToAnvil(CustomModel customModel)
	{
		if (customModel.getComp().getType() == CustomModelType.BLENDER)
		{
			sendChatMessage("Blender models cannot currently be used in the Anvil.");
			return;
		}

		SwingUtilities.invokeLater(() ->
		{
			CustomModelComp comp = customModel.getComp();
			sendChatMessage("Model sent to Anvil: " + comp.getName());
			ModelAnvil modelAnvil = creatorsPanel.getModelAnvil();

			CustomLighting cl;
			LightingStyle lightingStyle = comp.getLightingStyle();
			if (lightingStyle == LightingStyle.CUSTOM)
			{
				cl = comp.getCustomLighting();
			}
			else
			{
				cl = new CustomLighting(
						lightingStyle.getAmbient(),
						lightingStyle.getContrast(),
						lightingStyle.getX(),
						lightingStyle.getY(),
						lightingStyle.getZ());
			}

			modelAnvil.setLightingSettings(
					comp.getLightingStyle(),
					cl.getAmbient(),
					cl.getContrast(),
					cl.getX(),
					cl.getY(),
					cl.getZ());

			modelAnvil.getPriorityCheckBox().setSelected(comp.isPriority());
			modelAnvil.getNameField().setText(comp.getName());

			if (comp.getModelStats() == null)
			{
				DetailedModel[] detailedModels = comp.getDetailedModels();
				for (DetailedModel detailedModel : detailedModels)
					modelAnvil.createComplexPanel(detailedModel);

				return;
			}

			switch(comp.getType())
			{
				case FORGED:
				case CACHE_NPC:
				case CACHE_OBJECT:
				case CACHE_GROUND_ITEM:
				case CACHE_MAN_WEAR:
				case CACHE_WOMAN_WEAR:
					cacheToAnvil(comp.getModelStats(), comp.getKitRecolours(), false);
					break;
				case CACHE_PLAYER:
					cacheToAnvil(comp.getModelStats(), comp.getKitRecolours(), true);
			}
		});
	}

	public void loadCustomModelToAnvil(File file, boolean priority, String name)
	{
		ModelAnvil modelAnvil = creatorsPanel.getModelAnvil();
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			CustomModelComp comp = gson.fromJson(reader, CustomModelComp.class);

			SwingUtilities.invokeLater(() ->
			{
				for (DetailedModel detailedModel : comp.getDetailedModels())
				{
					modelAnvil.createComplexPanel(detailedModel);
				}
			});

			LightingStyle ls = comp.getLightingStyle();
			CustomLighting cl = comp.getCustomLighting();
			if (cl == null)
				cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());

			modelAnvil.setLightingSettings(
					comp.getLightingStyle(),
					cl.getAmbient(),
					cl.getContrast(),
					cl.getX(),
					cl.getY(),
					cl.getZ());

			modelAnvil.getPriorityCheckBox().setSelected(comp.isPriority());
			modelAnvil.getNameField().setText(comp.getName());
			reader.close();
			return;
		}
		catch (Exception e)
		{
			sendChatMessage("The file chosen is possibly in an older v1.2 file. Attempting conversion...");
		}

		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			DetailedModel[] detailedModels = gson.fromJson(reader, DetailedModel[].class);
			SwingUtilities.invokeLater(() ->
			{
				for (DetailedModel detailedModel : detailedModels)
				{
					creatorsPanel.getModelAnvil().createComplexPanel(detailedModel);
				}
			});
			reader.close();

			CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
			CustomModelComp comp = new CustomModelComp(0, CustomModelType.FORGED, -1, null, null, detailedModels, null, LightingStyle.DEFAULT, lighting, priority, name);
			modelAnvil.getPriorityCheckBox().setSelected(comp.isPriority());
			modelAnvil.getNameField().setText(comp.getName());

			try
			{
				file.delete();
				String fileName = file.getPath();
				File newFile = new File(fileName);
				FileWriter writer = new FileWriter(newFile, false);
				String string = gson.toJson(comp);
				writer.write(string);
				writer.close();
				sendChatMessage("The chosen v1.2 file has been successfully updated to a v1.3 file for future use.");
			}
			catch (IOException e)
			{
				e.printStackTrace();
				sendChatMessage("An error occurred while trying to convert this file to a .json file.");
			}
		}
		catch (Exception e)
		{
			sendChatMessage("The file chosen is possibly an older v1.0 file. Please see ScreteMonge for help adapting this.");
		}
	}

	public void loadCustomModel(File file, boolean priority, String name)
	{
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			CustomModelComp comp = gson.fromJson(reader, CustomModelComp.class);
			clientThread.invokeLater(() ->
			{
				LightingStyle ls = comp.getLightingStyle();
				CustomLighting cl = comp.getCustomLighting();
				if (cl == null)
					cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());

				Model model = createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), cl);
				CustomModel customModel = new CustomModel(model, comp);
				addCustomModel(customModel, false);
			});
			reader.close();
			return;
		}
		catch (Exception e)
		{
			sendChatMessage("The file chosen is possibly in an older v1.2 file. Attempting conversion...");
		}

		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			DetailedModel[] detailedModels = gson.fromJson(reader, DetailedModel[].class);
			CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
			CustomModelComp comp = new CustomModelComp(0, CustomModelType.FORGED, -1, null, null, detailedModels, null, LightingStyle.DEFAULT, lighting, priority, name);

			clientThread.invokeLater(() ->
			{
				Model model = createComplexModel(detailedModels, priority, LightingStyle.DEFAULT, lighting);
				CustomModel customModel = new CustomModel(model, comp);
				addCustomModel(customModel, false);
			});
			reader.close();

			try
			{
				file.delete();
				String fileName = file.getPath();
				File newFile = new File(fileName);
				FileWriter writer = new FileWriter(newFile, false);
				String string = gson.toJson(comp);
				writer.write(string);
				writer.close();

				sendChatMessage("The chosen v1.2 file has been successfully updated to a v1.3 file for future use.");
			}
			catch (IOException e)
			{
				e.printStackTrace();
				sendChatMessage("An error occurred while trying to convert this v1.2 file to a v1.3 file.");
			}
		}
		catch (Exception e)
		{
			sendChatMessage("The file chosen is possibly an older v1.0 file. Please see ScreteMonge for help adapting this.");
		}
	}

	public void loadTransmog(File file, TransmogLoadOption transmogLoadOption)
	{
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			TransmogSave transmogSave = gson.fromJson(reader, TransmogSave.class);
			CustomModelComp comp = transmogSave.getCustomModelComp();
			if (comp != null)
			{
				DetailedModel[] detailedModels = comp.getDetailedModels();
				if (detailedModels == null)
				{
					detailedModels = creatorsPanel.getModelOrganizer().modelToDetailedPanels(comp);
					comp.setDetailedModels(detailedModels);
				}
			}

			reader.close();

			boolean loadCustomModel = false;
			switch (transmogLoadOption)
			{
				case ANIMATIONS:
					creatorsPanel.getTransmogPanel().loadTransmog(transmogSave);
					break;
				case CUSTOM_MODEL:
					if (comp != null)
						loadCustomModel = true;
					break;
				case BOTH:
					creatorsPanel.getTransmogPanel().loadTransmog(transmogSave);
					if (comp != null)
						loadCustomModel = true;
			}

			if (loadCustomModel)
			{
				clientThread.invokeLater(() ->
				{
					LightingStyle ls = comp.getLightingStyle();
					CustomLighting cl = comp.getCustomLighting();
					if (cl == null)
						cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());
					Model model = createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), cl);
					CustomModel customModel = new CustomModel(model, comp);
					addCustomModel(customModel, false);
					creatorsPanel.getModelOrganizer().setTransmog(customModel);
				});
			}
		}
		catch (Exception e)
		{
			sendChatMessage("Failed to load the selected Transmog. Make sure you selected an appropriate transmog file.");
		}
	}

	public void addCustomModel(CustomModel customModel, boolean setComboBox)
	{
		SwingUtilities.invokeLater(() -> creatorsPanel.addModelOption(customModel, setComboBox));
		storedModels.add(customModel);
	}

	public void removeCustomModel(CustomModel customModel)
	{
		creatorsPanel.removeModelOption(customModel);
		storedModels.remove(customModel);
	}

	public void updateProgramPath(Program program, boolean gameStateChanged, boolean instanced)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		if (instanced)
		{
			updateInstancedProgramPath(program, gameStateChanged);
			return;
		}

		updateNonInstancedProgramPath(program, gameStateChanged);
	}

	public void updateInstancedProgramPath(Program program, boolean gameStateChanged)
	{
		Scene scene = client.getTopLevelWorldView().getScene();
		ProgramComp comp = program.getComp();
		LocalPoint[] stepsLP = comp.getStepsLP();
		LocalPoint[] pathLP = new LocalPoint[0];
		Coordinate[] allCoordinates = new Coordinate[0];

		if (stepsLP.length < 2)
		{
			comp.setPathLP(pathLP);
			comp.setCoordinates(allCoordinates);
			return;
		}

		for (int i = 0; i < stepsLP.length - 1; i++)
		{
			Coordinate[] coordinates;
			coordinates = pathFinder.getPath(stepsLP[i], stepsLP[i + 1], comp.getMovementType());

			if (coordinates == null)
			{
				if (!gameStateChanged)
					sendChatMessage("A path could not be found.");

				comp.setPathFound(false);
				return;
			}

			comp.setPathFound(true);
			allCoordinates = ArrayUtils.addAll(allCoordinates, coordinates);

			Direction direction = Direction.UNSET;

			for (int c = 0; c < coordinates.length - 1; c++)
			{
				int x = coordinates[c].getColumn();
				int y = coordinates[c].getRow();
				int nextX = coordinates[c + 1].getColumn();
				int nextY = coordinates[c + 1].getRow();
				int changeX = nextX - x;
				int changeY = nextY - y;

				Direction newDirection = Direction.getDirection(changeX, changeY);
				if (direction == Direction.UNSET || direction != newDirection)
				{
					direction = newDirection;
					LocalPoint localPoint = LocalPoint.fromScene(x, y, scene);
					pathLP = ArrayUtils.add(pathLP, localPoint);
				}
			}
		}

		pathLP = ArrayUtils.add(pathLP, stepsLP[stepsLP.length - 1]);
		comp.setPathLP(pathLP);
		comp.setCoordinates(allCoordinates);
	}

	public void updateNonInstancedProgramPath(Program program, boolean gameStateChanged)
	{
		Scene scene = client.getTopLevelWorldView().getScene();
		ProgramComp comp = program.getComp();
		WorldPoint[] stepsWP = comp.getStepsWP();
		WorldPoint[] pathWP = new WorldPoint[0];
		Coordinate[] allCoordinates = new Coordinate[0];

		if (stepsWP.length < 2)
		{
			comp.setPathWP(pathWP);
			comp.setCoordinates(allCoordinates);
			return;
		}

		for (int i = 0; i < stepsWP.length - 1; i++)
		{
			Coordinate[] coordinates;
			coordinates = pathFinder.getPath(stepsWP[i], stepsWP[i + 1], comp.getMovementType());

			if (coordinates == null) {
				if (!gameStateChanged)
					sendChatMessage("A path could not be found.");

				comp.setPathFound(false);
				return;
			}

			comp.setPathFound(true);
			allCoordinates = ArrayUtils.addAll(allCoordinates, coordinates);

			Direction direction = Direction.UNSET;

			for (int c = 0; c < coordinates.length - 1; c++)
			{
				int x = coordinates[c].getColumn();
				int y = coordinates[c].getRow();
				int nextX = coordinates[c + 1].getColumn();
				int nextY = coordinates[c + 1].getRow();
				int changeX = nextX - x;
				int changeY = nextY - y;

				Direction newDirection = Direction.getDirection(changeX, changeY);
				if (direction == Direction.UNSET || direction != newDirection)
				{
					direction = newDirection;
					LocalPoint localPoint = LocalPoint.fromScene(x, y, scene);
					pathWP = ArrayUtils.add(pathWP, WorldPoint.fromLocalInstance(client, localPoint));

				}
			}
		}

		pathWP = ArrayUtils.add(pathWP, stepsWP[stepsWP.length - 1]);
		comp.setPathWP(pathWP);
		comp.setCoordinates(allCoordinates);
	}

	public void resetProgram(Character character, boolean restart)
	{
		Program program = character.getProgram();
		ProgramComp comp = program.getComp();
		comp.setCurrentStep(0);

		if (!isInScene(character))
			return;

		boolean resetLocation = true;
		if (character.isInInstance())
		{
			if (comp.getStepsLP().length == 0)
				return;

			LocalPoint lp = comp.getStepsLP()[0];
			if (lp == null)
				return;

			if (!lp.isInScene())
				return;

			int arrayLength = comp.getStepsLP().length;
			if (restart && lp.distanceTo(comp.getStepsLP()[arrayLength - 1]) == 0)
				resetLocation = false;
		}

		if (!character.isInInstance())
		{
			if (comp.getStepsWP().length == 0)
				return;

			WorldPoint wp = comp.getStepsWP()[0];
			if (wp == null)
				return;

			int arrayLength = comp.getStepsWP().length;
			if (restart && wp.distanceTo(comp.getStepsWP()[arrayLength - 1]) == 0)
				resetLocation = false;
		}

		if (resetLocation)
			setLocation(character, false, false, false, true);

		comp.setProgramActive(restart);
	}

	public void updatePanelComboBoxes()
	{
		SwingUtilities.invokeLater(() ->
		{
			for (JComboBox<CustomModel> comboBox : creatorsPanel.getComboBoxes())
				comboBox.updateUI();
		});
	}

	private void updatePreviewObject(Tile tile)
	{
		if (previewObject == null)
		{
			clientThread.invokeLater(() ->
			{
				previewObject = new CKObject(client);
				client.registerRuneLiteObject(previewObject);
				previewObject.setActive(false);

				ModelData arrow = client.loadModelData(4852);
				ModelData transparent = client.loadModelData(9925);
				if (arrow == null || transparent == null)
				{
					return;
				}

				transparent.cloneVertices();
				float[] tx = transparent.getVerticesX();
				float[] ty = transparent.getVerticesY();
				float[] tz = transparent.getVerticesZ();
				for (int i = 0; i < tx.length; i++)
				{
					tx[i] = 0;
					ty[i] = 0;
					tz[i] = 0;
				}

				arrow.cloneVertices().rotateY180Ccw().scale(256, 256, 256);
				ModelData merge = client.mergeModels(arrow, transparent);
				merge.cloneTransparencies();
				byte[] transparencies = merge.getFaceTransparencies();
				for (byte b = 0; b < merge.getFaceCount(); b++)
				{
					transparencies[b] = 115;
				}

				previewArrow = merge.light();
			});
			return;
		}

		if (!config.enableCtrlHotkeys())
		{
			previewObject.setActive(false);
			return;
		}

		if (!client.isKeyPressed(KeyCode.KC_CONTROL)
			|| client.isMenuOpen()
			|| tile == null
			|| selectedCharacter == null)
		{
			previewObject.setActive(false);
			return;
		}

		CKObject CKObject = selectedCharacter.getCKObject();
		if (CKObject == null)
		{
			return;
		}

		boolean allowArrow = false;
		int orientation;
		if (mousePressed)
		{
			final int yaw = client.getCameraYaw();
			final int pitch = client.getCameraPitch();
			Point p = client.getMouseCanvasPosition();
			double x = p.getX() - clickX;
			double y = -1 * (p.getY() - clickY);
			if (Math.sqrt(x * x + y * y) < 40)
			{
				orientation = Rotation.roundRotation(CKObject.getOrientation());
			}
			else
			{
				allowArrow = true;
				orientation = Rotation.getJagexDegrees(p.getX() - clickX, (p.getY() - clickY) * -1, yaw, pitch);
			}
		}
		else
		{
			orientation = CKObject.getOrientation();
		}

		Model model;
		if (mousePressed && previewArrow != null && allowArrow)
		{
			model = previewArrow;
		}
		else
		{
			if (selectedCharacter.isCustomMode())
			{
				if (selectedCharacter.getStoredModel() == null)
				{
					model = client.loadModel(29757);
				}
				else
				{
					model = selectedCharacter.getStoredModel().getModel();
				}
			}
			else
			{
				model = client.loadModel((int) selectedCharacter.getModelSpinner().getValue());
			}
		}

		LocalPoint lp;
		if (mousePressed)
		{
			lp = CKObject.getLocation();
			if (lp == null)
			{
				lp = tile.getLocalLocation();
			}
		}
		else
		{
			lp = tile.getLocalLocation();
			if (lp == null)
			{
				lp = CKObject.getLocation();
			}
		}

		if (lp == null)
		{
			return;
		}

		int animId;
		if (allowArrow)
		{
			animId = -1;
		}
		else
		{
			animId = CKObject.getAnimationId();
		}

		previewObject.setModel(model);
		previewObject.setOrientation(orientation);
		previewObject.setAnimation(animId);
		previewObject.setDrawFrontTilesFirst(true);
		previewObject.setLocation(lp, client.getTopLevelWorldView().getPlane());
		previewObject.setRadius(CKObject.getRadius());
		previewObject.setActive(true);
	}

	public ArrayList<ComplexPanel> getComplexPanels()
	{
		return creatorsPanel.getModelAnvil().getComplexPanels();
	}

	private final HotkeyListener overlayKeyListener = new HotkeyListener(() -> config.toggleOverlaysHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			overlaysActive = !overlaysActive;
		}
	};

	private final HotkeyListener oculusOrbListener = new HotkeyListener(() -> config.toggleOrbHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (client.getCameraMode() == 1)
			{
				client.setCameraMode(0);
				client.setFreeCameraSpeed(12);
				return;
			}

			client.setCameraMode(1);
			client.setFreeCameraSpeed(oculusOrbSpeed);
		}
	};

	private final HotkeyListener orbSpeedListener = new HotkeyListener(() -> config.setOrbSpeedHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			SwingUtilities.invokeLater(() ->
			{
				String result = JOptionPane.showInputDialog(creatorsPanel, "Set Orb Speed (5 = Walk, 9 = Run)", 36);
				try
				{
					int value = Integer.parseInt(result);
					client.setFreeCameraSpeed(value);
					oculusOrbSpeed = value;
				}
				catch (Exception f)
				{
					sendChatMessage("Invalid input; enter a number to set the Oculus Orb speed.");
				}
			});
		}
	};

	private final HotkeyListener orbPreset1Listener = new HotkeyListener(() -> config.orbSpeedHotkey1())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey1());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey1());
		}
	};

	private final HotkeyListener orbPreset2Listener = new HotkeyListener(() -> config.orbSpeedHotkey2())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey2());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey2());
		}
	};

	private final HotkeyListener orbPreset3Listener = new HotkeyListener(() -> config.orbSpeedHotkey3())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey3());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey3());
		}
	};
	private final HotkeyListener quickSpawnListener = new HotkeyListener(() -> config.quickSpawnHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				toggleSpawn(selectedCharacter.getSpawnButton(), selectedCharacter);
			}
		}
	};

	private final HotkeyListener quickLocationListener = new HotkeyListener(() -> config.quickLocationHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				setLocation(selectedCharacter, true, false, true, false);
			}
		}
	};

	private final HotkeyListener quickDuplicateListener = new HotkeyListener(() -> config.quickDuplicateHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				creatorsPanel.onDuplicatePressed(selectedCharacter, true);
			}
		}
	};

	private final HotkeyListener quickRotateCWListener = new HotkeyListener(() -> config.quickRotateCWHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				addOrientation(selectedCharacter, config.rotateDegrees().degrees * -1);
			}
		}
	};

	private final HotkeyListener quickRotateCCWListener = new HotkeyListener(() -> config.quickRotateCCWHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				addOrientation(selectedCharacter, config.rotateDegrees().degrees);
			}
		}
	};

	private final HotkeyListener autoLeftListener = new HotkeyListener(() -> config.rotateLeftHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotateYaw = (autoRotateYaw == AutoRotate.OFF) ? AutoRotate.LEFT : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoRightListener = new HotkeyListener(() -> config.rotateRightHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotateYaw = (autoRotateYaw == AutoRotate.OFF) ? AutoRotate.RIGHT : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoUpListener = new HotkeyListener(() -> config.rotateUpHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotatePitch = (autoRotatePitch == AutoRotate.OFF) ? AutoRotate.UP : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoDownListener = new HotkeyListener(() -> config.rotateDownHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotatePitch = (autoRotatePitch == AutoRotate.OFF) ? AutoRotate.DOWN : AutoRotate.OFF;
		}
	};

	private final HotkeyListener addProgramStepListener = new HotkeyListener(() -> config.addProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			addProgramStep();
		}
	};

	private void addProgramStep()
	{
		if (selectedCharacter != null)
		{
			WorldView worldView = client.getTopLevelWorldView();
			boolean instance = worldView.getScene().isInstance();

			Tile tile = worldView.getSelectedSceneTile();
			if (tile == null)
				return;

			LocalPoint localPoint = tile.getLocalLocation();
			if (localPoint == null)
				return;

			Program program = selectedCharacter.getProgram();
			boolean isInScene = isInScene(selectedCharacter);

			if (isInScene && instance)
			{
				LocalPoint[] steps = program.getComp().getStepsLP();

				if (steps.length == 0)
				{
					setLocation(selectedCharacter, true, false, true, false);
				}

				if (steps.length > 0)
				{
					Coordinate[] coordinates = pathFinder.getPath(steps[steps.length - 1], localPoint, program.getComp().getMovementType());
					if (coordinates == null)
					{
						sendChatMessage("A path could not be found to this tile");
						return;
					}
				}

				steps = ArrayUtils.add(steps, localPoint);
				program.getComp().setStepsLP(steps);
				updateProgramPath(program, false, selectedCharacter.isInInstance());
				return;
			}

			if (!isInScene && instance)
			{
				program.getComp().setStepsLP(new LocalPoint[]{localPoint});
				program.getComp().setStepsWP(new WorldPoint[0]);
				setLocation(selectedCharacter, true, false, true, false);
				updateProgramPath(program, false, selectedCharacter.isInInstance());
				return;
			}

			if (isInScene && !instance)
			{
				WorldPoint[] steps = program.getComp().getStepsWP();

				if (steps.length == 0)
				{
					setLocation(selectedCharacter, true, false, true, false);
				}

				WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);

				if (steps.length > 0)
				{
					Coordinate[] coordinates = pathFinder.getPath(steps[steps.length - 1], worldPoint, program.getComp().getMovementType());
					if (coordinates == null)
					{
						sendChatMessage("A path could not be found to this tile");
						return;
					}
				}

				steps = ArrayUtils.add(steps, worldPoint);
				program.getComp().setStepsWP(steps);
				updateProgramPath(program, false, selectedCharacter.isInInstance());
				return;
			}

			if (!isInScene && !instance)
			{
				WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
				program.getComp().setStepsWP(new WorldPoint[]{worldPoint});
				program.getComp().setStepsLP(new LocalPoint[0]);
				setLocation(selectedCharacter, true, false, true, false);
				updateProgramPath(program, false, selectedCharacter.isInInstance());
			}
		}
	}

	private final HotkeyListener removeProgramStepListener = new HotkeyListener(() -> config.removeProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			removeProgramStep();
		}
	};

	private void removeProgramStep()
	{
		if (selectedCharacter != null)
		{
			if (!isInScene(selectedCharacter))
				return;

			WorldView worldView = client.getTopLevelWorldView();
			Tile tile = worldView.getSelectedSceneTile();
			if (tile == null)
				return;

			Program program = selectedCharacter.getProgram();
			ProgramComp comp = program.getComp();

			if (worldView.getScene().isInstance())
			{
				LocalPoint[] steps = comp.getStepsLP();
				steps = ArrayUtils.removeElement(steps, tile.getLocalLocation());
				comp.setStepsLP(steps);
			}
			else
			{
				WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, tile.getLocalLocation());
				WorldPoint[] steps = comp.getStepsWP();
				steps = ArrayUtils.removeElement(steps, worldPoint);
				comp.setStepsWP(steps);
			}

			comp.setCurrentStep(0);
			updateProgramPath(program, false, selectedCharacter.isInInstance());
			setLocation(selectedCharacter, false, false, false, true);
		}
	}

	private final HotkeyListener clearProgramStepListener = new HotkeyListener(() -> config.clearProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			clearProgramSteps();
		}
	};

	private void clearProgramSteps()
	{
		if (selectedCharacter != null)
		{
			Program program = selectedCharacter.getProgram();
			program.getComp().setStepsWP(new WorldPoint[0]);
			program.getComp().setStepsLP(new LocalPoint[0]);
			program.getComp().setProgramActive(false);
			updateProgramPath(program, false, selectedCharacter.isInInstance());
			setLocation(selectedCharacter, false, false, false, false);
		}
	}

	private final HotkeyListener playPauseListener = new HotkeyListener(() -> config.playPauseHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				ProgramComp comp = selectedCharacter.getProgram().getComp();
				comp.setProgramActive(!comp.isProgramActive());
			}
		}
	};

	private final HotkeyListener playPauseAllListener = new HotkeyListener(() -> config.playPauseAllHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			pauseMode = !pauseMode;

			for (Character character : characters)
				character.getProgram().getComp().setProgramActive(!pauseMode);
		}
	};

	private final HotkeyListener resetListener = new HotkeyListener(() -> config.resetHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
				resetProgram(selectedCharacter, false);
		}
	};

	private final HotkeyListener resetAllListener = new HotkeyListener(() -> config.resetAllHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			for (Character character : characters)
				resetProgram(character, false);
		}
	};

	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event)
	{
		if (config.enableCtrlHotkeys() && event.isControlDown())
		{
			creatorsPanel.scrollSelectedCharacter(selectedCharacter, event.getWheelRotation());
			event.consume();
		}

		return event;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e)
	{
		if (config.enableCtrlHotkeys()
				&& e.getButton() == MouseEvent.BUTTON1
				&& client.isKeyPressed(KeyCode.KC_CONTROL))
		{
			mousePressed = true;
			clickX = e.getPoint().getX();
			clickY = e.getPoint().getY();
		}

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e)
	{
		mousePressed = false;

		if (config.enableCtrlHotkeys() &&
				e.getButton() == MouseEvent.BUTTON1 &&
				client.isKeyPressed(KeyCode.KC_CONTROL) &&
				selectedCharacter != null)
		{
			double x = e.getX() - clickX;
			double y = -1 * (e.getY() - clickY);
			if (Math.sqrt(x * x + y * y) < 40)
			{
				return e;
			}

			final int yaw = client.getCameraYaw();
			final int pitch = client.getCameraPitch();
			int jUnit = Rotation.getJagexDegrees(x, y, yaw, pitch);
			setOrientation(selectedCharacter, jUnit);
		}

		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e)
	{
		return e;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e)
	{
		return e;
	}

	@Provides
	CreatorsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CreatorsConfig.class);
	}
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class AnimSequence
{
    private AnimSequenceData mainHandData;
    private AnimSequenceData offHandData;
    private int mainHandItemId;
    private int offHandItemId;
}

package com.creatorskit.models;

import com.creatorskit.CreatorsPlugin;
import net.runelite.api.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import java.awt.*;
import java.io.File;
import java.io.Reader;
import java.nio.file.Files;

public class ModelImporter
{
    @Inject
    private CreatorsPlugin plugin;

    @Inject
    private ClientThread clientThread;

    @Inject
    private Client client;

    public static final File BLENDER_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/blender-models");
    private final int BASIC_MODEL = 823;
    private final int TRANSPARENT_MODEL = 18871;
    private final int PRIORITY_MODEL = 6733;
    private final int BASIC_MODEL_2_4 = 15166;
    private final int BASIC_MODEL_3_7 = 21140;
    private final int ANIMATED_MODEL_2_5 = 21201;
    private final int ANIMATED_MODEL_13_13 = 80;
    private final int TEST_MODEL = 23901;

    public void openLoadDialog()
    {
        BLENDER_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(BLENDER_DIR);
        fileChooser.setDialogTitle("Choose a Blender model to load");

        JComboBox<LightingStyle> comboBox = new JComboBox<>();
        comboBox.setToolTipText("Sets the lighting style");
        comboBox.addItem(LightingStyle.ACTOR);
        comboBox.addItem(LightingStyle.DEFAULT);
        comboBox.addItem(LightingStyle.SPOTANIM);
        comboBox.addItem(LightingStyle.DYNAMIC);
        comboBox.addItem(LightingStyle.NONE);
        comboBox.setFocusable(false);

        JPanel accessory = new JPanel();
        accessory.setLayout(new GridLayout(0, 1));
        accessory.add(comboBox);

        fileChooser.setAccessory(accessory);
        fileChooser.setMultiSelectionEnabled(true);
        fileChooser.setFileFilter(new FileFilter()
        {
            @Override
            public String getDescription()
            {
                return "Json File (*.json)";
            }

            @Override
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }
                else
                {
                    String filename = f.getName().toLowerCase();
                    return filename.endsWith(".json");
                }
            }
        });

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File[] files = fileChooser.getSelectedFiles();
            for (File selectedFile : files)
            {
                loadBlenderModel(selectedFile, (LightingStyle) comboBox.getSelectedItem());
            }
        }
    }

    public void openLatestFile()
    {
        File directory = new File(BLENDER_DIR.getPath());
        File[] files = directory.listFiles(File::isFile);

        long lastModifiedTime = Long.MIN_VALUE;
        File chosenFile = null;
        if (files != null)
        {
            for (File file : files)
            {
                if (!file.getName().endsWith(".json"))
                {
                    continue;
                }

                if (file.lastModified() > lastModifiedTime)
                {
                    chosenFile = file;
                    lastModifiedTime = file.lastModified();
                }
            }
        }

        if (chosenFile == null)
        {
            plugin.sendChatMessage("Could not find the latest .json file in the " + RuneLite.RUNELITE_DIR + "\\creatorskit\\blender-models folder.");
            return;
        }

        loadBlenderModel(chosenFile, LightingStyle.ACTOR);
    }

    private void loadBlenderModel(File file, LightingStyle lightingStyle)
    {
        if (!file.exists())
        {
            file = new File(file.getPath() + ".json");
            if (!file.exists())
            {
                file = new File(file.getPath().replaceAll("/", "\\\\"));
                if (!file.exists())
                {
                    file = new File(file.getPath().replaceAll("/", "\\\\") + ".json");
                }
            }
        }

        if (!file.exists())
        {
            plugin.sendChatMessage("Failed to find file.");
            return;
        }

        String name = file.getName();
        if (name.endsWith(".json"))
            name = replaceLast(name);

        String finalName = name;
        File finalSelectedFile = file;
        clientThread.invokeLater(() ->
        {
            BlenderModel blenderModel;

            try
            {
                Reader reader = Files.newBufferedReader(finalSelectedFile.toPath());
                blenderModel = plugin.getGson().fromJson(reader, BlenderModel.class);
                reader.close();
            }
            catch (Exception e)
            {
                plugin.sendChatMessage("The file found was unreadable as a BlenderModel.");
                return;
            }

            if (blenderModel == null)
            {
                plugin.sendChatMessage("File was found but is incompatible or empty.");
                return;
            }

            addModel(blenderModel, lightingStyle, finalName);
        });
    }

    private String replaceLast(String string)
    {
        int lastIndex = string.lastIndexOf(".json");
        if (lastIndex < 0)
            return string;
        String tail = string.substring(lastIndex).replaceFirst(".json", "");
        return string.substring(0, lastIndex) + tail;
    }

    public void addModel(BlenderModel blenderModel, LightingStyle lightingStyle, String name)
    {
        Model model = createModel(blenderModel, lightingStyle);
        if (model == null)
            return;

        CustomLighting lighting = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());

        CustomModelComp comp = new CustomModelComp(0, CustomModelType.BLENDER, -1, null, null, null, blenderModel, lightingStyle, lighting, false, name);
        CustomModel customModel = new CustomModel(model, comp);
        plugin.addCustomModel(customModel, false);
    }

    public Model createModel(BlenderModel blenderModel, LightingStyle lightingStyle)
    {
        int vertexCount = blenderModel.getVertices().length;
        int[] verticesX = new int[vertexCount];
        int[] verticesY = new int[vertexCount];
        int[] verticesZ = new int[vertexCount];

        for (int i = 0; i < vertexCount; i++)
        {
            int[] v = blenderModel.getVertices()[i];
            verticesX[i] = v[0];
            verticesY[i] = v[1];
            verticesZ[i] = v[2];
        }

        int faceCount = blenderModel.getFaces().length;
        int[] faces1 = new int[faceCount];
        int[] faces2 = new int[faceCount];
        int[] faces3 = new int[faceCount];

        for (int i = 0; i < faceCount; i++)
        {
            int[] f = blenderModel.getFaces()[i];
            faces1[i] = f[0];
            faces2[i] = f[1];
            faces3[i] = f[2];
        }

        //{2_6 priority, 1_3, 1_2, 1_0, 1_3 transparent}
        int[] polys = new int[]{1, 0, 0, 0, 1};
        try
        {
            polys = getPolyCount(polys, faces1.length - 3, verticesX.length - 3);
        }
        catch (Exception e)
        {
            plugin.sendChatMessage("Could not import this Blender Model. It's likely that it contains too few faces or vertices.");
            return null;
        }

        //int[] polys = new int[]{0, 1, 0, 0, 0};
        //polys = getPolyCountAnimated(polys, faces1.length - 2, verticesX.length - 4);
        //System.out.println(polys[0] + "," + polys[1] + "," + polys[2] + "," + polys[3] + "," + polys[4]);
        ModelData modelData = constructModel(polys);
        if (modelData == null)
            return null;

        //System.out.println(faceCount + ", " + modelData.getFaceCount());
        //System.out.println(vertexCount + ", " + modelData.getVerticesCount());

        float[] vX = modelData.getVerticesX();
        float[] vY = modelData.getVerticesY();
        float[] vZ = modelData.getVerticesZ();
        int[] f1 = modelData.getFaceIndices1();
        int[] f2 = modelData.getFaceIndices2();
        int[] f3 = modelData.getFaceIndices3();
        short[] cols = modelData.getFaceColors();
        byte[] tps = modelData.getFaceTransparencies();

        for (int i = 0; i < modelData.getVerticesCount(); i++)
        {
            vX[i] = verticesX[i];
            vY[i] = verticesY[i];
            vZ[i] = verticesZ[i];
        }

        for (int i = 0; i < modelData.getFaceCount(); i++)
        {
            f1[i] = faces1[i];
            f2[i] = faces2[i];
            f3[i] = faces3[i];
        }

        if (!blenderModel.isUseVertexColours())
        {
            double[][] faceColours = blenderModel.getFaceColours();
            short[] colours = new short[faceColours.length];
            byte[] transparencies = new byte[faceColours.length];
            for (int i = 0; i < faceColours.length; i++)
            {
                double[] colour = faceColours[i];
                int colorHInt = (int) (63 - (colour[0] * 63));
                int colorLInt = (int) (colour[1] * 127);
                int colorSInt = (int) (colour[2] * 7);
                short jagexColor = JagexColor.packHSL(colorHInt, colorSInt, colorLInt);
                double tp = colour[3];
                tp *= -256;
                if (tp < -128)
                {
                    tp += 256;
                }

                transparencies[i] = (byte) tp;
                colours[i] = jagexColor;
            }

            int[] faceIndices = blenderModel.faceColourIndex;

            for (int i = 0; i < modelData.getFaceCount(); i++)
            {
                int index = faceIndices[i];
                cols[i] = colours[index];
                tps[i] = transparencies[index];
            }
        }

        Model model = modelData.light(
                lightingStyle.getAmbient(),
                lightingStyle.getContrast(),
                lightingStyle.getX(),
                lightingStyle.getZ() * -1,
                lightingStyle.getY());

        if (blenderModel.isUseVertexColours())
        {
            double[][] vertexColours = blenderModel.getVertexColours();
            short[] colours = new short[vertexColours.length];
            byte[] transparencies = new byte[vertexColours.length];
            for (int i = 0; i < vertexColours.length; i++)
            {
                double[] colour = vertexColours[i];
                int colorHInt = (int) (63 - (colour[0] * 63));
                int colorLInt = (int) (colour[1] * 127);
                int colorSInt = (int) (colour[2] * 7);
                short jagexColor = JagexColor.packHSL(colorHInt, colorSInt, colorLInt);
                double tp = colour[3];
                tp *= -256;
                if (tp < -128)
                {
                    tp += 256;
                }

                transparencies[i] = (byte) tp;
                colours[i] = jagexColor;
            }

            int[] fc1 = model.getFaceColors1();
            int[] fc2 = model.getFaceColors2();
            int[] fc3 = model.getFaceColors3();
            byte[] ftp = model.getFaceTransparencies();
            int[] vertexColourIndex = blenderModel.getVertexColourIndex();

            for (int i = 0; i < model.getFaceCount(); i++)
            {
                int col1 = colours[vertexColourIndex[i * 3]];
                int col2 = colours[vertexColourIndex[i * 3 + 1]];
                int col3 = colours[vertexColourIndex[i * 3 + 2]];

                if (col1 < 0)
                {
                    col1 += 65536;
                }

                if (col2 < 0)
                {
                    col2 += 65536;
                }

                if (col3 < 0)
                {
                    col3 += 65536;
                }

                fc1[i] = col1;
                fc2[i] = col2;
                fc3[i] = col3;
                int tp = (transparencies[vertexColourIndex[i * 3]] + transparencies[vertexColourIndex[i * 3 + 1]] + transparencies[vertexColourIndex[i * 3 + 2]]) / 3;
                ftp[i] = (byte) tp;
            }
        }

        byte[] priorities = blenderModel.getPriorities();
        byte[] facePriorities = model.getFaceRenderPriorities();
        for (int i = 0; i < model.getFaceCount(); i++)
        {
            facePriorities[i] = priorities[i];
        }

        return model;
    }

    public int[] getPolyCount(int[] polys, int facesRemaining, int verticesRemaining)
    {
        //int[2_6 priority, 1_3, 1_2, 1_0, 1_3 transparent] for [face_vertices]
        //System.out.println("FacesRemaining " + facesRemaining + ", verticesRemaining: " + verticesRemaining);
        if (facesRemaining == 0 && verticesRemaining == 0)
            return polys;

        double divisor = (double) verticesRemaining / facesRemaining;
        // if there's a 1:3 ratio of faces:vertices, close out the function
        if (divisor == 3)
        {
            polys[1] += facesRemaining;
            return polys;
        }

        // if there's a 1:2 ratio of faces:vertices, close out the function
        if (divisor == 2)
        {
            polys[2] += facesRemaining;
            return polys;
        }

        //Effectively while-loop till face count drops below vertex count
        if (facesRemaining + 2 > verticesRemaining)
        {
            int change = facesRemaining + 2 - verticesRemaining;
            polys[3] += change;
            facesRemaining -= change;
            return getPolyCount(polys, facesRemaining, verticesRemaining);
        }

        //if remaining vertices is even, keep even. If odd, change to even
        if (verticesRemaining % 2 == 0)
        {
            polys[2] += 1;
            facesRemaining--;
            verticesRemaining -= 2;
        }
        else
        {
            polys[1] += 1;
            facesRemaining--;
            verticesRemaining -= 3;
        }

        return getPolyCount(polys, facesRemaining, verticesRemaining);
    }

    private ModelData constructModel(int[] polys)
    {
        ModelData[] modelsToMerge = new ModelData[]{};

        ModelData polyPriority = client.loadModelData(PRIORITY_MODEL);
        if (polyPriority != null)
        {
            polyPriority.cloneColors().cloneVertices();
            float[] vX = polyPriority.getVerticesX();
            float[] vY = polyPriority.getVerticesY();
            float[] vZ = polyPriority.getVerticesZ();

            vX[0] = vX[1] = 64;
            vY[0] = vY[1] = 0;
            vZ[0] = vZ[1] = -64;

            vX[2] = vX[3] = -64;
            vY[2] = vY[3] = 0;
            vZ[2] = vZ[3] = 64;

            vX[4] = vX[5] = -64;
            vY[4] = vY[5] = 0;
            vZ[4] = vZ[5] = -64;

            modelsToMerge = ArrayUtils.add(modelsToMerge, polyPriority);
        }
        else
        {
            return null;
        }

        ModelData poly_transparent = client.loadModelData(TRANSPARENT_MODEL);
        if (poly_transparent != null)
        {
            poly_transparent.cloneColors().cloneVertices().cloneTransparencies();
            float[] vX = poly_transparent.getVerticesX();
            float[] vY = poly_transparent.getVerticesY();
            float[] vZ = poly_transparent.getVerticesZ();

            vX[0] = 64;
            vY[0] = 0;
            vZ[0] = -64;

            vX[1] = -64;
            vY[1] = 0;
            vZ[1] = 64;

            vX[2] = -64;
            vY[2] = 0;
            vZ[2] = -64;

            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_transparent);
        }
        else
        {
            return null;
        }

        for (int i = 0; i < polys[1]; i++)
        {
            ModelData poly_1_3 = client.loadModelData(BASIC_MODEL);
            if (poly_1_3 == null)
                return null;

            poly_1_3.cloneColors().cloneVertices().translate(i + 1, i + 1, i + 1);
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_3);
        }

        int translateBy = 128;
        for (int i = 0; i < polys[2]; i++)
        {
            ModelData poly_1_2 = client.loadModelData(BASIC_MODEL);
            if (poly_1_2 == null)
                return null;

            poly_1_2.cloneColors().cloneVertices().translate((i + 1) * translateBy, 0, 0);
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_2);
        }

        for (int i = 0; i < polys[3]; i++)
        {
            ModelData poly_1_0 = client.loadModelData(BASIC_MODEL);
            if (poly_1_0 == null)
                return null;

            poly_1_0.cloneColors().cloneVertices();
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_0);
        }

        return client.mergeModels(modelsToMerge);
    }
}

package com.creatorskit.models;

import com.creatorskit.models.datatypes.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.NPCComposition;
import net.runelite.api.NpcOverrides;
import net.runelite.api.PlayerComposition;
import okhttp3.*;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.CountDownLatch;

@Slf4j
@Getter
public class DataFinder
{
    private Gson gson;
    OkHttpClient httpClient;

    private String lastFound;
    private int lastAnim;

    private final List<NPCData> npcData = new ArrayList<>();
    private final List<ObjectData> objectData = new ArrayList<>();
    private final List<SpotanimData> spotanimData = new ArrayList<>();
    private final List<ItemData> itemData = new ArrayList<>();
    private final List<KitData> kitData = new ArrayList<>();
    private final List<SeqData> seqData = new ArrayList<>();

    private static final BodyPart[] bodyParts = new BodyPart[]{
            BodyPart.HEAD,
            BodyPart.CAPE,
            BodyPart.AMULET,
            BodyPart.WEAPON,
            BodyPart.TORSO,
            BodyPart.SHIELD,
            BodyPart.ARMS,
            BodyPart.LEGS,
            BodyPart.HAIR,
            BodyPart.HANDS,
            BodyPart.FEET,
            BodyPart.JAW,
            BodyPart.SPOTANIM};
    private static final int WEAPON_IDX = 3;
    private static final int SHIELD_IDX = 5;

    @Inject
    public DataFinder(Gson gson, OkHttpClient httpClient)
    {
        this.gson = gson;
        this.httpClient = httpClient;

        lookupNPCData();
        lookupObjectData();
        lookupSpotAnimData();
        lookupItemData();
        lookupKitData();
        lookupSeqData();
    }

    private void lookupKitData()
    {
        Request kitRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/kit.json")
                .build();
        Call kitCall = httpClient.newCall(kitRequest);
        kitCall.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/kit.json");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                Type listType = new TypeToken<List<KitData>>(){}.getType();
                List<KitData> list = gson.fromJson(reader, listType);
                kitData.addAll(list);

                response.body().close();
            }
        });
    }

    private void lookupSeqData()
    {
        Request seqRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/sequences.json")
                .build();
        Call call = httpClient.newCall(seqRequest);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/sequences.json");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                Type listType = new TypeToken<List<SeqData>>(){}.getType();
                List<SeqData> list = gson.fromJson(reader, listType);
                seqData.addAll(list);

                response.body().close();
            }
        });
    }

    public ModelStats[] findModelsForPlayer(boolean groundItem, boolean maleItem, int[] items, int animId, int[] spotAnims)
    {
        //Convert equipmentId to itemId or kitId as appropriate
        int[] ids = new int[items.length];

        int[] itemShortList = new int[items.length];
        int[] kitShortList = new int[items.length];

        for (int i = 0; i < ids.length; i++)
        {
            int item = items[i];

            if (item >= PlayerComposition.KIT_OFFSET && item <= PlayerComposition.ITEM_OFFSET)
            {
                kitShortList[i] = item - PlayerComposition.KIT_OFFSET;
            }
            else
            {
                kitShortList[i] = -1;
            }

            if (item > PlayerComposition.ITEM_OFFSET)
            {
                itemShortList[i] = item - PlayerComposition.ITEM_OFFSET;
            }
            else
            {
                itemShortList[i] = -1;
            }
        }

        AnimSequence animSequence = new AnimSequence(
                AnimSequenceData.UNALTERED,
                AnimSequenceData.UNALTERED,
                -1,
                -1);

        if (animId != -1)
        {
            removePlayerItems(animSequence, animId);
        }

        //for ItemIds
        ArrayList<ModelStats> itemArray = new ArrayList<>();
        getPlayerItems(itemArray, groundItem, maleItem, itemShortList, animSequence);

        //for KitIds
        ArrayList<ModelStats> kitArray = new ArrayList<>();
        getPlayerKit(kitArray, kitShortList);

        ArrayList<ModelStats> spotAnimArray = new ArrayList<>();
        if (spotAnims.length > 0)
        {
            getPlayerSpotAnims(spotAnims, spotAnimArray);
        }

        itemArray.addAll(kitArray);
        itemArray.addAll(spotAnimArray);
        ArrayList<ModelStats> orderedItems = new ArrayList<>();
        for (int e = 0; e < bodyParts.length; e++)
        {
            for (int i = 0; i < itemArray.size(); i++)
            {
                ModelStats modelStats = itemArray.get(i);
                if (modelStats.getBodyPart() == bodyParts[e])
                {
                    if (!orderedItems.contains(modelStats))
                    {
                        orderedItems.add(modelStats);
                    }
                }
            }
        }

        return orderedItems.toArray(new ModelStats[0]);
    }

    public void removePlayerItems(AnimSequence animSequence, int animId)
    {
        for (SeqData seqDatum : seqData)
        {
            if (seqDatum.getId() == animId)
            {
                int offHandItem = seqDatum.getLeftHandItem();
                switch (offHandItem)
                {
                    case -1:
                        break;
                    case 0:
                        animSequence.setOffHandData(AnimSequenceData.HIDE);
                        break;
                    default:
                        animSequence.setOffHandItemId(offHandItem - 512);
                        animSequence.setOffHandData(AnimSequenceData.SWAP);
                }

                int mainHandItem = seqDatum.getRightHandItem();
                switch (mainHandItem)
                {
                    case -1:
                        break;
                    case 0:
                        animSequence.setMainHandData(AnimSequenceData.HIDE);
                        break;
                    default:
                        animSequence.setMainHandItemId(mainHandItem - 512);
                        animSequence.setMainHandData(AnimSequenceData.SWAP);
                }
                break;
            }
        }
    }

    public void getPlayerItems(ArrayList<ModelStats> modelStats, boolean groundItem, boolean maleItem, int[] itemId, AnimSequence animSequence)
    {
        AnimSequenceData mainHand = animSequence.getMainHandData();
        AnimSequenceData offHand = animSequence.getOffHandData();

        int[] updatedItemIds = Arrays.copyOf(itemId, itemId.length);

        switch (mainHand)
        {
            case UNALTERED:
                switch (offHand)
                {
                    case UNALTERED:
                        break;
                    case HIDE:
                        updatedItemIds[SHIELD_IDX] = -1;
                        break;
                    case SWAP:
                        updatedItemIds[SHIELD_IDX] = animSequence.getOffHandItemId();
                }
                break;
            case SWAP:
                switch (offHand)
                {
                    case UNALTERED:
                        updatedItemIds[WEAPON_IDX] = animSequence.getMainHandItemId();
                        break;
                    case HIDE:
                        updatedItemIds[WEAPON_IDX] = -1;
                        updatedItemIds[SHIELD_IDX] = animSequence.getMainHandItemId();
                        break;
                    case SWAP:
                        updatedItemIds[SHIELD_IDX] = animSequence.getMainHandItemId();
                        updatedItemIds[WEAPON_IDX] = animSequence.getOffHandItemId();
                }
                break;
            case HIDE:
                switch (offHand)
                {
                    case UNALTERED:
                        updatedItemIds[WEAPON_IDX] = -1;
                        break;
                    case HIDE:
                        updatedItemIds[WEAPON_IDX] = -1;
                        updatedItemIds[SHIELD_IDX] = -1;
                        break;
                    case SWAP:
                        updatedItemIds[WEAPON_IDX] = animSequence.getOffHandItemId();
                        updatedItemIds[SHIELD_IDX] = -1;
                }
                break;
        }

        int itemsToComplete = updatedItemIds.length;
        for (int i : updatedItemIds)
        {
            if (i == -1)
            {
                itemsToComplete--;
            }
        }

        for (ItemData itemDatum : itemData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i = 0; i < updatedItemIds.length; i++)
            {
                int item = updatedItemIds[i];
                if (item == -1)
                {
                    continue;
                }

                if (itemDatum.getId() == item)
                {
                    itemsToComplete--;
                    int[] modelIds = new int[0];
                    int offset = 0;

                    if (groundItem)
                    {
                        modelIds = ArrayUtils.add(modelIds, itemDatum.getInventoryModel());
                    }
                    else if (maleItem)
                    {
                        modelIds = ArrayUtils.addAll(modelIds, itemDatum.getMaleModel0(), itemDatum.getMaleModel1(), itemDatum.getMaleModel2());
                        offset = itemDatum.getMaleOffset();
                    }
                    else
                    {
                        modelIds = ArrayUtils.addAll(modelIds, itemDatum.getFemaleModel0(), itemDatum.getFemaleModel1(), itemDatum.getFemaleModel2());
                        offset = itemDatum.getFemaleOffset();
                    }

                    short[] rf = new short[0];
                    short[] rt = new short[0];

                    if (itemDatum.getColorReplace() != null)
                    {
                        int[] recolorToReplace = itemDatum.getColorReplace();
                        int[] recolorToFind = itemDatum.getColorFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    short[] rtFrom = new short[0];
                    short[] rtTo = new short[0];

                    if (itemDatum.getTextureReplace() != null)
                    {
                        int[] textureToReplace = itemDatum.getTextureReplace();
                        int[] retextureToFind = itemDatum.getTextureFind();
                        rtFrom = new short[textureToReplace.length];
                        rtTo = new short[textureToReplace.length];

                        for (int e = 0; e < rtFrom.length; e++)
                        {
                            rtFrom[e] = (short) retextureToFind[e];
                            rtTo[e] = (short) textureToReplace[e];
                        }
                    }

                    LightingStyle ls = LightingStyle.ACTOR;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient(),
                            ls.getContrast(),
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    for (int id : modelIds)
                    {
                        if (id != -1)
                        {
                            modelStats.add(new ModelStats(
                                    id,
                                    bodyParts[i],
                                    rf,
                                    rt,
                                    rtFrom,
                                    rtTo,
                                    itemDatum.getResizeX(),
                                    itemDatum.getResizeZ(),
                                    itemDatum.getResizeY(),
                                    offset * -1,
                                    customLighting
                            ));
                        }
                    }

                    break;
                }
            }
        }
    }

    public void getPlayerKit(ArrayList<ModelStats> modelStats, int[] kitId)
    {
        int itemsToComplete = kitId.length;
        for (int i : kitId)
        {
            if (i == -1)
            {
                itemsToComplete--;
            }
        }

        for (KitData kitData : kitData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i = 0; i < kitId.length; i++)
            {
                int item = kitId[i];
                if (item == -1)
                {
                    continue;
                }

                if (kitData.getId() == item)
                {
                    itemsToComplete--;
                    int[] modelIds = kitData.getModels();

                    short[] rf = new short[0];
                    short[] rt = new short[0];

                    if (kitData.getRecolorToReplace() != null)
                    {
                        int[] recolorToReplace = kitData.getRecolorToReplace();
                        int[] recolorToFind = kitData.getRecolorToFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    LightingStyle ls = LightingStyle.ACTOR;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient(),
                            ls.getContrast(),
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    for (int id : modelIds)
                    {
                        if (id != -1)
                        {
                            modelStats.add(new ModelStats(
                                    id,
                                    bodyParts[i],
                                    rf,
                                    rt,
                                    new short[0],
                                    new short[0],
                                    128,
                                    128,
                                    128,
                                    0,
                                    customLighting
                            ));
                        }
                    }

                    break;
                }
            }
        }
    }

    public void getPlayerSpotAnims(int[] spotAnims, ArrayList<ModelStats> modelStats)
    {
        int itemsToComplete = spotAnims.length;

        for (SpotanimData spotanimData : spotanimData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i : spotAnims)
            {
                if (spotanimData.getId() == i)
                {
                    itemsToComplete--;
                    int modelId = spotanimData.getModelId();

                    short[] rf = new short[0];
                    short[] rt = new short[0];
                    if (spotanimData.getRecolorToReplace() != null)
                    {
                        int[] recolorToReplace = spotanimData.getRecolorToReplace();
                        int[] recolorToFind = spotanimData.getRecolorToFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    int ambient = spotanimData.getAmbient();
                    int contrast = spotanimData.getContrast();

                    LightingStyle ls = LightingStyle.SPOTANIM;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient() + ambient,
                            ls.getContrast() + contrast,
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    modelStats.add(new ModelStats(
                            modelId,
                            BodyPart.SPOTANIM,
                            rf,
                            rt,
                            new short[0],
                            new short[0],
                            spotanimData.getResizeX(),
                            spotanimData.getResizeX(),
                            spotanimData.getResizeY(),
                            0,
                            customLighting
                    ));

                    break;
                }
            }
        }
    }

    private void lookupSpotAnimData()
    {
        Request spotanimRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/spotanims.json")
                .build();
        Call call = httpClient.newCall(spotanimRequest);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/spotanims.json");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                Type listType = new TypeToken<List<SpotanimData>>(){}.getType();
                List<SpotanimData> list = gson.fromJson(reader, listType);

                spotanimData.addAll(list);
                response.body().close();
            }
        });
    }

    public ModelStats[] findSpotAnim(int spotAnimId)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (SpotanimData spotanimData : spotanimData)
        {
            if (spotanimData.getId() == spotAnimId)
            {
                int modelId = spotanimData.getModelId();

                lastFound = "SpotAnim " + spotAnimId;
                lastAnim = spotanimData.getAnimationId();

                short[] rf = new short[0];
                short[] rt = new short[0];
                if (spotanimData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = spotanimData.getRecolorToReplace();
                    int[] recolorToFind = spotanimData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int e = 0; e < rf.length; e++)
                    {
                        int rfi = recolorToFind[e];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[e] = (short) rfi;

                        int rti = recolorToReplace[e];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[e] = (short) rti;
                    }
                }

                int ambient = spotanimData.getAmbient();
                int contrast = spotanimData.getContrast();

                LightingStyle ls = LightingStyle.SPOTANIM;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient() + ambient,
                        ls.getContrast() + contrast,
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                modelStats.add(new ModelStats(
                        modelId,
                        BodyPart.SPOTANIM,
                        rf,
                        rt,
                        new short[0],
                        new short[0],
                        spotanimData.getResizeX(),
                        spotanimData.getResizeX(),
                        spotanimData.getResizeY(),
                        0,
                        customLighting));
            }
        }

        if (modelStats.isEmpty())
        {
            return null;
        }

        return new ModelStats[]{modelStats.get(0)};
    }

    public void lookupNPCData()
    {
        Request request = new Request.Builder().url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/npc_defs.json").build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/npc_defs.json");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                InputStreamReader reader = new InputStreamReader(response.body().byteStream());

                Type listType = new TypeToken<List<NPCData>>(){}.getType();
                List<NPCData> list = gson.fromJson(reader, listType);

                npcData.addAll(list);
                npcData.sort(Comparator.comparing(NPCData::getName));
                response.body().close();
            }
        });
    }

    public ModelStats[] findModelsForNPC(int npcId)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = npcData.getModels();

                short[] rf = new short[0];
                short[] rt = new short[0];

                if (npcData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = npcData.getRecolorToReplace();
                    int[] recolorToFind = npcData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int i = 0; i < rf.length; i++)
                    {
                        int rfi = recolorToFind[i];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[i] = (short) rfi;

                        int rti = recolorToReplace[i];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[i] = (short) rti;
                    }
                }

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            rf,
                            rt,
                            new short[0],
                            new short[0],
                            npcData.getWidthScale(),
                            npcData.getWidthScale(),
                            npcData.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    public ModelStats[] findModelsForNPC(int npcId, NpcOverrides overrides)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = overrides.getModelIds();

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            new short[0],
                            new short[0],
                            new short[0],
                            new short[0],
                            npcData.getWidthScale(),
                            npcData.getWidthScale(),
                            npcData.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    public ModelStats[] findModelsForNPC(int npcId, NPCComposition composition)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = composition.getModels();
                short[] colourToReplace = composition.getColorToReplace();
                short[] colourToReplaceWith = composition.getColorToReplaceWith();

                if (colourToReplace == null || colourToReplaceWith == null)
                {
                    colourToReplace = new short[0];
                    colourToReplaceWith = new short[0];
                }

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            colourToReplace,
                            colourToReplaceWith,
                            new short[0],
                            new short[0],
                            composition.getWidthScale(),
                            composition.getWidthScale(),
                            composition.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    private void lookupObjectData()
    {
        Request request = new Request.Builder().url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/object_defs.json").build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/object_defs.json");
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                //create a reader to read the URL
                InputStreamReader reader = new InputStreamReader(response.body().byteStream());

                Type listType = new TypeToken<List<ObjectData>>(){}.getType();
                List<ObjectData> list = gson.fromJson(reader, listType);

                objectData.addAll(list);
                objectData.sort(Comparator.comparing(ObjectData::getName));
                response.body().close();
            }
        });
    }

    public ModelStats[] findModelsForObject(int objectId, int modelType, LightingStyle ls, boolean firstModelType)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();

        for (ObjectData objectData : objectData)
        {
            if (objectData.getId() == objectId)
            {
                lastFound = objectData.getName();
                int[] modelIds = objectData.getObjectModels();
                if (modelIds == null)
                {
                    return new ModelStats[0];
                }

                int[] objectTypes = objectData.getObjectTypes();
                if (objectTypes != null && objectTypes.length > 0)
                {
                    if (firstModelType)
                    {
                        int modelId = modelIds[0];
                        modelIds = new int[]{modelId};
                    }
                    else
                    {
                        for (int i = 0; i < objectTypes.length; i++)
                        {
                            if (objectTypes[i] == modelType)
                            {
                                int modelId = modelIds[i];
                                modelIds = new int[]{modelId};
                                break;
                            }
                        }
                    }
                }

                short[] rf = new short[0];
                short[] rt = new short[0];
                if (objectData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = objectData.getRecolorToReplace();
                    int[] recolorToFind = objectData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int i = 0; i < rf.length; i++)
                    {
                        int rfi = recolorToFind[i];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[i] = (short) rfi;

                        int rti = recolorToReplace[i];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[i] = (short) rti;
                    }
                }

                short[] rtFrom = new short[0];
                short[] rtTo = new short[0];

                if (objectData.getTextureToReplace() != null)
                {
                    int[] textureToReplace = objectData.getTextureToReplace();
                    int[] retextureToFind = objectData.getRetextureToFind();
                    rtFrom = new short[textureToReplace.length];
                    rtTo = new short[textureToReplace.length];

                    for (int i = 0; i < rtFrom.length; i++)
                    {
                        rtFrom[i] = (short) retextureToFind[i];
                        rtTo[i] = (short) textureToReplace[i];
                    }
                }

                int ambient = objectData.getAmbient();
                int contrast = objectData.getContrast();
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient() + ambient,
                        ls.getContrast() + contrast,
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            rf,
                            rt,
                            rtFrom,
                            rtTo,
                            objectData.getModelSizeX(),
                            objectData.getModelSizeY(),
                            objectData.getModelSizeZ(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    private void lookupItemData()
    {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Request itemRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/item_defs.json")
                .build();
        Call itemCall = httpClient.newCall(itemRequest);
        itemCall.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/item_defs.json");
                countDownLatch.countDown();
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (!response.isSuccessful() || response.body() == null)
                    return;

                InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                Type listType = new TypeToken<List<ItemData>>(){}.getType();
                List<ItemData> list = gson.fromJson(reader, listType);
                itemData.addAll(list);
                itemData.sort(Comparator.comparing(ItemData::getName));

                response.body().close();
            }
        });
    }

    public ModelStats[] findModelsForGroundItem(int itemId, CustomModelType modelType)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();

        for (ItemData item : itemData)
        {
            if (item.getId() == itemId)
            {
                lastFound = item.getName();
                int[] modelIds = new int[0];

                switch (modelType)
                {
                    default:
                    case CACHE_GROUND_ITEM:
                        modelIds = ArrayUtils.add(modelIds, item.getInventoryModel());
                        break;
                    case CACHE_MAN_WEAR:
                        modelIds = ArrayUtils.addAll(modelIds, item.getMaleModel0(), item.getMaleModel1(), item.getMaleModel2());
                        break;
                    case CACHE_WOMAN_WEAR:
                        modelIds = ArrayUtils.addAll(modelIds, item.getFemaleModel0(), item.getFemaleModel1(), item.getFemaleModel2());
                }

                short[] rf = new short[0];
                short[] rt = new short[0];

                if (item.getColorReplace() != null)
                {
                    int[] recolorToReplace = item.getColorReplace();
                    int[] recolorToFind = item.getColorFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int e = 0; e < rf.length; e++)
                    {
                        int rfi = recolorToFind[e];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[e] = (short) rfi;

                        int rti = recolorToReplace[e];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[e] = (short) rti;
                    }
                }

                short[] rtFrom = new short[0];
                short[] rtTo = new short[0];

                if (item.getTextureReplace() != null)
                {
                    int[] textureToReplace = item.getTextureReplace();
                    int[] retextureToFind = item.getTextureFind();
                    rtFrom = new short[textureToReplace.length];
                    rtTo = new short[textureToReplace.length];

                    for (int e = 0; e < rtFrom.length; e++)
                    {
                        rtFrom[e] = (short) retextureToFind[e];
                        rtTo[e] = (short) textureToReplace[e];
                    }
                }

                LightingStyle ls;

                switch (modelType)
                {
                    default:
                    case CACHE_GROUND_ITEM:
                        ls = LightingStyle.DEFAULT;
                        break;
                    case CACHE_MAN_WEAR:
                    case CACHE_WOMAN_WEAR:
                        ls = LightingStyle.ACTOR;
                }

                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int id : modelIds)
                {
                    if (id != -1)
                    {
                        modelStats.add(new ModelStats(
                                id,
                                BodyPart.NA,
                                rf,
                                rt,
                                rtFrom,
                                rtTo,
                                item.getResizeX(),
                                item.getResizeZ(),
                                item.getResizeY(),
                                0,
                                customLighting
                        ));
                    }
                }

                break;
            }
        }

        if (modelStats.isEmpty())
        {
            return null;
        }

        return new ModelStats[]{modelStats.get(0)};
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ModelStats
{
    private int modelId;
    private BodyPart bodyPart;
    private short[] recolourFrom;
    private short[] recolourTo;
    private short[] textureFrom;
    private short[] textureTo;
    private int resizeX;
    private int resizeY;
    private int resizeZ;
    private int translateZ;
    private CustomLighting lighting;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CustomLighting
{
    private int ambient;
    private int contrast;
    private int x;
    private int y;
    private int z;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum BodyPart
{
    NA("Na"),
    HEAD("Head"),
    CAPE("Cape"),
    AMULET("Amulet"),
    WEAPON("Weapon"),
    TORSO("Torso"),
    SHIELD("Shield"),
    ARMS("Arms"),
    LEGS("Legs"),
    HAIR("Hair"),
    HANDS("Hands"),
    FEET("Feet"),
    JAW("Jaw"),
    SPOTANIM("SpotAnim");

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.models;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.models.exporters.ModelExporter;
import com.creatorskit.swing.CreatorsPanel;
import com.creatorskit.swing.ParentPanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ModelGetter
{
    private final Client client;
    private final CreatorsPanel creatorsPanel;
    private final ClientThread clientThread;
    private final CreatorsConfig config;
    private final CreatorsPlugin plugin;
    private final DataFinder dataFinder;
    private final ModelExporter modelExporter;
    private CKObject exportObject;

    @Inject
    public ModelGetter(Client client, CreatorsPanel creatorsPanel, ClientThread clientThread, CreatorsConfig config, CreatorsPlugin plugin, DataFinder dataFinder, ModelExporter modelExporter)
    {
        this.client = client;
        this.creatorsPanel = creatorsPanel;
        this.clientThread = clientThread;
        this.config = config;
        this.plugin = plugin;
        this.dataFinder = dataFinder;
        this.modelExporter = modelExporter;
    }

    public void addCharacterMenuEntries(Tile tile)
    {
        if (!config.rightSelect() && !config.exportRightClick())
        {
            return;
        }

        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            CKObject CKObject = character.getCKObject();
            if (character.isActive() && CKObject != null)
            {
                LocalPoint localPoint = CKObject.getLocation();
                if (localPoint != null && localPoint.equals(tile.getLocalLocation()))
                {
                    if (config.rightSelect())
                    {
                        client.getMenu().createMenuEntry(1)
                                .setOption(ColorUtil.prependColorTag("Select", Color.ORANGE))
                                .setTarget(ColorUtil.colorTag(Color.GREEN) + character.getName())
                                .setType(MenuAction.RUNELITE)
                                .onClick(e -> creatorsPanel.setSelectedCharacter(character));
                    }

                    if (config.exportRightClick())
                    {
                        addRLObjectExporter(1, character, false);
                        addRLObjectExporter(1, character, true);
                    }
                }
            }
        }
    }

    public void addLocalPlayerMenuEntries(Tile tile)
    {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer != null)
        {
            if (tile.getLocalLocation().equals(localPlayer.getLocalLocation()))
            {
                String target = ColorUtil.prependColorTag("Local Player", Color.GREEN);
                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addPlayerGetter(1, target, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), localPlayer, ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addPlayerGetter(1, target, ColorUtil.prependColorTag("Store", Color.ORANGE), localPlayer, ModelMenuOption.STORE);
                    }
                    addPlayerGetter(1, target, ColorUtil.prependColorTag("Anvil", Color.ORANGE), localPlayer, ModelMenuOption.ANVIL);
                }

                if (config.rightSpotAnim())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store-Add", Color.ORANGE), localPlayer.getSpotAnims(), ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Store", Color.ORANGE), localPlayer.getSpotAnims(), ModelMenuOption.STORE);
                    }
                    addSpotAnimGetter(1, target, ColorUtil.prependColorTag("SpotAnim-Anvil", Color.ORANGE), localPlayer.getSpotAnims(), ModelMenuOption.ANVIL);
                }

                if (config.exportRightClick())
                {
                    addPlayerExporter(1, target, localPlayer, false);
                    addPlayerExporter(1, target, localPlayer, true);
                }
            }
        }
    }

    public void addTileItemMenuEntries(Tile tile)
    {
        List<TileItem> tileItems = tile.getGroundItems();
        if (tileItems != null)
        {
            for (TileItem tileItem : tileItems)
            {
                int itemId = tileItem.getId();
                String name = client.getItemDefinition(itemId).getName();
                if (name.equals("null"))
                {
                    name = "Item";
                }

                Model model = tileItem.getModel();
                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addGroundItemGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, model, itemId, 0, ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addGroundItemGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, model, itemId, 0, ModelMenuOption.STORE);
                    }

                    addGroundItemGetterToAnvil(1, name, itemId);
                }

                if (config.transmogRightClick())
                {
                    addGroundItemGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, model, itemId, 0, ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    addGroundItemExporter(1, name, itemId, model);
                }
            }
        }
    }

    public void addTileObjectMenuEntries(Tile tile)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        for (GameObject gameObject : gameObjects)
        {
            if (gameObject == null)
                continue;

            Renderable renderable = gameObject.getRenderable();
            if (renderable == null)
                continue;

            int objectId = gameObject.getId();
            int modelType = gameObject.getConfig() & 31;

            if (renderable instanceof Model)
            {
                ObjectComposition comp = client.getObjectDefinition(objectId);
                String name = comp.getName();
                if (name.equals("null"))
                {
                    name = "GameObj";
                }
                int animationId = -1;

                Model model = (Model) renderable;
                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.STORE);
                    }
                    addObjectGetterToAnvil(1, name, gameObject.getId(), modelType, LightingStyle.DEFAULT);
                }

                if (config.transmogRightClick())
                {
                    addGameObjectGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    addObjectExporter(1, name, objectId, modelType, model);
                }
            }

            if (renderable instanceof DynamicObject)
            {
                ObjectComposition comp = client.getObjectDefinition(objectId);
                DynamicObject dynamicObject = (DynamicObject) renderable;
                if (comp.getImpostorIds() != null)
                {
                    if (comp.getImpostor() != null)
                    {
                        comp = comp.getImpostor();
                    }
                }

                objectId = comp.getId();
                Animation animation = dynamicObject.getAnimation();
                int animationId = -1;
                if (animation != null)
                {
                    animationId = animation.getId();
                }

                String name = comp.getName();
                if (name.equals("null"))
                {
                    name = "GameObj";
                }

                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addDynamicObjectGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addDynamicObjectGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.STORE);
                    }

                    addObjectGetterToAnvil(1, name, objectId, modelType, LightingStyle.DYNAMIC);
                }

                if (config.transmogRightClick())
                {
                    addDynamicObjectGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, gameObject.getOrientation(), ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    Model model = dynamicObject.getModel();
                    if (model != null)
                    {
                        addDynamicObjectExporter(1, name, objectId, modelType, animationId, dynamicObject.getModel(), false);
                        addDynamicObjectExporter(1, name, objectId, modelType, animationId, dynamicObject.getModel(), true);
                    }
                }
            }
        }

        GroundObject groundObject = tile.getGroundObject();
        if (groundObject != null)
        {
            Renderable renderable = groundObject.getRenderable();
            if (renderable instanceof Model)
            {
                Model model = (Model) groundObject.getRenderable();

                int objectId = groundObject.getId();
                int animationId = -1;
                int modelType = 22;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "GroundObj";
                }

                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE);

                    }
                    addObjectGetterToAnvil(1, name, objectId, modelType, LightingStyle.DEFAULT);
                }

                if (config.transmogRightClick())
                {
                    addGameObjectGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    addObjectExporter(1, name, objectId, modelType,  model);
                }
            }
        }

        DecorativeObject decorativeObject = tile.getDecorativeObject();
        if (decorativeObject != null)
        {
            Renderable renderable = decorativeObject.getRenderable();
            if (renderable instanceof Model)
            {
                Model model = (Model) decorativeObject.getRenderable();

                int objectId = decorativeObject.getId();
                int animationId = -1;
                int modelType = 4;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "DecorativeObj";
                }

                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE);

                    }
                    addObjectGetterToAnvil(1, name, objectId, modelType, LightingStyle.DEFAULT);
                }

                if (config.transmogRightClick())
                {
                    addGameObjectGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    addObjectExporter(1, name, objectId, modelType, model);
                }
            }
        }

        WallObject wallObject = tile.getWallObject();
        if (wallObject != null)
        {
            Renderable renderable = wallObject.getRenderable1();
            if (renderable instanceof Model)
            {
                Model model = (Model) renderable;

                int objectId = wallObject.getId();
                int animationId = -1;
                int modelType = tile.getWallObject().getConfig() & 31;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "WallObj";
                }

                if (config.rightClick())
                {
                    if (client.isKeyPressed(KeyCode.KC_CONTROL))
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store-Add", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE_AND_ADD);
                    }
                    else
                    {
                        addGameObjectGetter(1, ColorUtil.prependColorTag("Store", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.STORE);
                    }
                    addObjectGetterToAnvil(1, name, objectId, modelType, LightingStyle.DEFAULT);
                }

                if (config.transmogRightClick())
                {
                    addGameObjectGetter(1, ColorUtil.prependColorTag("Transmog", Color.ORANGE), name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, ModelMenuOption.TRANSMOG);
                }

                if (config.exportRightClick())
                {
                    addObjectExporter(1, name, objectId, modelType, model);
                }
            }
        }
    }

    public void storeNPC(int index, String target, String option, NPC npc, ModelMenuOption menuOption)
    {
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        NPCComposition composition = npc.getTransformedComposition();
                        NpcOverrides overrides = npc.getModelOverrides();

                        ModelStats[] modelStats;
                        if (overrides != null)
                        {
                            modelStats = dataFinder.findModelsForNPC(npc.getId(), overrides);
                        }
                        else if (composition != null)
                        {
                            modelStats = dataFinder.findModelsForNPC(npc.getId(), composition);
                        }
                        else
                        {
                            modelStats = dataFinder.findModelsForNPC(npc.getId());
                        }

                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this NPC in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        clientThread.invokeLater(() ->
                        {
                            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, true);
                            CustomLighting lighting = new CustomLighting(64, 850, -30, -30, 50);
                            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_NPC, npc.getId(), modelStats, null, null, null, LightingStyle.ACTOR, lighting, false, npc.getName());
                            CustomModel customModel = new CustomModel(model, comp);
                            plugin.addCustomModel(customModel, false);
                            plugin.sendChatMessage("Model stored: " + npc.getName());
                            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();

                            if (menuOption == ModelMenuOption.TRANSMOG)
                            {
                                creatorsPanel.getModelOrganizer().setTransmog(customModel);
                            }

                            if (menuOption == ModelMenuOption.STORE_AND_ADD)
                            {
                                Character character = creatorsPanel.createCharacter(
                                        ParentPanel.SIDE_PANEL,
                                        npc.getName(),
                                        7699,
                                        customModel,
                                        true,
                                        npc.getOrientation(),
                                        npc.getPoseAnimation(),
                                        -1,
                                        60,
                                        new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                        creatorsPanel.createEmptyProgram(npc.getPoseAnimation(), npc.getWalkAnimation()),
                                        false,
                                        null,
                                        null,
                                        new int[0],
                                        -1,
                                        false,
                                        false);

                                SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                            }
                        });
                    });
                    thread.start();
                });
    }

    public void sendToAnvilNPC(int index, String target, NPC npc)
    {
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        NPCComposition composition = npc.getTransformedComposition();

                        ModelStats[] modelStats;
                        if (composition == null)
                        {
                            modelStats = dataFinder.findModelsForNPC(npc.getId());
                        }
                        else
                        {
                            modelStats = dataFinder.findModelsForNPC(npc.getId(), composition);
                        }

                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this NPC in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        clientThread.invokeLater(() ->
                        {
                            plugin.cacheToAnvil(modelStats, new int[0], false);
                            plugin.sendChatMessage("Model sent to Anvil: " + npc.getName());
                        });
                    });
                    thread.start();

                });
    }

    public void addNPCExporter(int index, String target, NPC npc, boolean exportAnimation)
    {
        String option = "Export Model";
        if (exportAnimation)
        {
            option = "Export Animation";
        }

        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag(option, Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    int animId = npc.getAnimation();
                    int poseAnimId = npc.getPoseAnimation();
                    if (animId == -1)
                    {
                        animId = poseAnimId;
                    }
                    int finalAnimId = animId;

                    if (exportAnimation && animId == -1)
                    {
                        plugin.sendChatMessage("There is no animation currently playing to export.");
                        return;
                    }

                    int npcId = npc.getId();

                    String name = npc.getName();

                    if (config.vertexColours())
                    {
                        BlenderModel bm = modelExporter.bmVertexColours(npc.getModel());

                        if (exportAnimation)
                        {
                            Thread thread = new Thread(() ->
                            {
                                NPCComposition composition = npc.getTransformedComposition();

                                ModelStats[] modelStats;
                                if (composition == null)
                                {
                                    modelStats = dataFinder.findModelsForNPC(npc.getId());
                                }
                                else
                                {
                                    modelStats = dataFinder.findModelsForNPC(npc.getId(), composition);
                                }

                                if (modelStats == null || modelStats.length == 0)
                                {
                                    plugin.sendChatMessage("Could not find this NPC in the cache.");
                                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                    return;
                                }

                                clientThread.invokeLater(() ->
                                {
                                    initiateAnimationExport(finalAnimId, name, bm, modelStats, new int[0], false, true);
                                });
                            });
                            thread.start();
                        }
                        else
                        {
                            if (config.exportTPose())
                            {
                                npc.setAnimation(-1);
                                npc.setPoseAnimation(-1);
                            }

                            modelExporter.saveToFile(name, bm);
                        }
                    }
                    else
                    {
                        Model model = npc.getModel();
                        int vCount = model.getVerticesCount();
                        int fCount = model.getFaceCount();
                        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
                        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
                        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

                        int[] vX = new int[vCount];
                        int[] vY = new int[vCount];
                        int[] vZ = new int[vCount];

                        for (int i = 0; i < vCount; i++)
                        {
                            vX[i] = (int) fvX[i];
                            vY[i] = (int) fvY[i];
                            vZ[i] = (int) fvZ[i];
                        }

                        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
                        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
                        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
                        byte[] renderPriorities;
                        if (model.getFaceRenderPriorities() == null)
                        {
                            renderPriorities = new byte[fCount];
                            Arrays.fill(renderPriorities, (byte) 0);
                        }
                        else
                        {
                            renderPriorities = model.getFaceRenderPriorities();
                        }

                        byte[] transparencies;
                        if (model.getFaceTransparencies() == null)
                        {
                            transparencies = new byte[fCount];
                            Arrays.fill(transparencies, (byte) 0);
                        }
                        else
                        {
                            transparencies = model.getFaceTransparencies();
                        }

                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForNPC(npcId);
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this NPC in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            clientThread.invokeLater(() ->
                            {
                                if (config.exportTPose() && !exportAnimation)
                                {
                                    npc.setAnimation(-1);
                                    npc.setPoseAnimation(-1);
                                }

                                BlenderModel bm = modelExporter.bmFaceColours(
                                        modelStats,
                                        false,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);

                                if (exportAnimation)
                                {
                                    initiateAnimationExport(finalAnimId, name, bm, modelStats, new int[0], false, true);
                                }
                                else
                                {
                                    modelExporter.saveToFile(name, bm);
                                }
                            });
                        });
                        thread.start();
                    }
                });
    }

    public void addSpotAnimGetter(int index, String target, String option, IterableHashTable<ActorSpotAnim> spotAnims, ModelMenuOption menuOption)
    {
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    //For "Anvil" option on SpotAnims
                    if (menuOption == ModelMenuOption.ANVIL)
                    {
                        for (ActorSpotAnim spotAnim : spotAnims)
                        {
                            Thread thread = new Thread(() ->
                            {
                                ModelStats[] modelStats = dataFinder.findSpotAnim(spotAnim.getId());
                                if (modelStats == null || modelStats.length == 0)
                                {
                                    plugin.sendChatMessage("Could not find this Spotanim in the cache.");
                                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                    return;
                                }

                                clientThread.invokeLater(() ->
                                {
                                    CustomLighting lighting = modelStats[0].getLighting();
                                    plugin.cacheToAnvil(modelStats, new int[0], false);
                                    plugin.sendChatMessage("Model sent to Anvil: " + spotAnim.getId() + "; Anim: " + dataFinder.getLastAnim() + "; Ambient/Contrast: " + lighting.getAmbient() + "/" + lighting.getContrast());
                                });
                            });
                            thread.start();
                        }
                        return;
                    }

                    //For "Store" option on SpotAnims
                    for (ActorSpotAnim spotAnim : spotAnims)
                    {
                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findSpotAnim(spotAnim.getId());
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Spotanim in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            clientThread.invokeLater(() ->
                            {
                                String name = "SpotAnim " + spotAnim.getId();
                                CustomLighting lighting = modelStats[0].getLighting();
                                CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_OBJECT, spotAnim.getId(), modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, name);

                                ModelData modelData = client.loadModelData(modelStats[0].getModelId()).cloneColors().cloneVertices();
                                short[] recolFrom = modelStats[0].getRecolourFrom();
                                short[] recolTo = modelStats[0].getRecolourTo();
                                for (int i = 0; i < recolFrom.length; i++)
                                    modelData.recolor(recolFrom[i], recolTo[i]);
                                modelData.scale(modelStats[0].getResizeX(), modelStats[0].getResizeZ(), modelStats[0].getResizeY());

                                int anim = dataFinder.getLastAnim();
                                Model model = modelData.light(lighting.getAmbient(), lighting.getContrast(), lighting.getX(), lighting.getZ() * -1, lighting.getY());
                                CustomModel customModel = new CustomModel(model, comp);
                                plugin.addCustomModel(customModel, false);
                                plugin.sendChatMessage("Model stored: " + name + "; Anim: " + anim + "; Ambient/Contrast: " + lighting.getAmbient() + "/" + lighting.getContrast());

                                if (menuOption == ModelMenuOption.STORE_AND_ADD)
                                {
                                    CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();

                                    Character character = creatorsPanel.createCharacter(
                                            ParentPanel.SIDE_PANEL,
                                            name,
                                            7699,
                                            customModel,
                                            true,
                                            0,
                                            anim,
                                            -1,
                                            60,
                                            new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                            creatorsPanel.createEmptyProgram(anim, anim),
                                            false,
                                            null,
                                            null,
                                            new int[0],
                                            -1,
                                            false,
                                            false);

                                    SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                                }
                            });
                        });
                        thread.start();
                    }
                });
    }

    public void addSpotAnimExporter(int index, String target, IterableHashTable<ActorSpotAnim> spotAnims)
    {
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Export SpotAnims", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        for (ActorSpotAnim spotAnim : spotAnims)
                        {
                            ModelStats[] modelStats = dataFinder.findSpotAnim(spotAnim.getId());
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Spotanim in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel blenderModel = modelExporter.bmSpotAnimFromCache(modelStats);
                                String name = "SpotAnim " + spotAnim.getId();
                                modelExporter.saveToFile(name, blenderModel);
                            });
                        }
                    });
                    thread.start();
                });
    }

    public void addPlayerGetter(int index, String target, String option, Player player, ModelMenuOption menuOption)
    {
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    PlayerComposition comp = player.getPlayerComposition();
                    final int[] items = comp.getEquipmentIds();
                    final int[] colours = comp.getColors().clone();

                    IterableHashTable<ActorSpotAnim> actorSpotAnims = player.getSpotAnims();
                    int[] spotAnims = new int[0];
                    for (ActorSpotAnim actorSpotAnim : actorSpotAnims)
                    {
                        spotAnims = ArrayUtils.add(spotAnims, actorSpotAnim.getId());
                    }
                    final int[] fSpotAnims = Arrays.copyOf(spotAnims, spotAnims.length);

                    int animId = player.getAnimation();
                    if (animId == -1)
                    {
                        animId = player.getPoseAnimation();
                    }
                    final int anim = animId;

                    String name = player.getName();
                    if (player == client.getLocalPlayer())
                        name = "Local Player";
                    String finalName = name;

                    //For "Anvil" option on players
                    if (menuOption == ModelMenuOption.ANVIL)
                    {
                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, anim, fSpotAnims);

                            clientThread.invokeLater(() ->
                            {
                                plugin.cacheToAnvil(modelStats, colours, true);
                                plugin.sendChatMessage("Model sent to Anvil: " + finalName);
                            });
                        });
                        thread.start();
                        return;
                    }

                    //For "Store" option on players
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, anim, fSpotAnims);
                        clientThread.invokeLater(() ->
                        {
                            Model model = plugin.constructModelFromCache(modelStats, colours, true, true);
                            CustomLighting lighting = new CustomLighting(64, 850, -30, -30, 50);
                            CustomModelComp composition = new CustomModelComp(0, CustomModelType.CACHE_PLAYER, -1, modelStats, colours, null, null, LightingStyle.ACTOR, lighting, false, finalName);
                            CustomModel customModel = new CustomModel(model, composition);
                            plugin.addCustomModel(customModel, false);
                            plugin.sendChatMessage("Model stored: " + finalName);

                            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
                            if (menuOption == ModelMenuOption.TRANSMOG)
                            {
                                creatorsPanel.getModelOrganizer().setTransmog(customModel);
                            }

                            if (menuOption == ModelMenuOption.STORE_AND_ADD)
                            {
                                Character character = creatorsPanel.createCharacter(
                                        ParentPanel.SIDE_PANEL,
                                        finalName,
                                        7699,
                                        customModel,
                                        true,
                                        player.getCurrentOrientation(),
                                        anim,
                                        -1,
                                        60,
                                        new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                        creatorsPanel.createEmptyProgram(player.getPoseAnimation(), player.getWalkAnimation()),
                                        false,
                                        null,
                                        null,
                                        new int[0],
                                        -1,
                                        false,
                                        false);

                                SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                            }
                        });
                    });
                    thread.start();
                });
    }

    public void addPlayerExporter(int index, String target, Player player, boolean exportAnimation)
    {
        String option = "Export Model";
        if (exportAnimation)
        {
            option = "Export Animation";
        }

        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag(option, Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    int animId = player.getAnimation();
                    int poseAnimId = player.getPoseAnimation();
                    if (animId == -1)
                    {
                        animId = poseAnimId;
                    }
                    int finalAnimId = animId;

                    if (exportAnimation && animId == -1)
                    {
                        plugin.sendChatMessage("There is no animation currently playing to export.");
                        return;
                    }

                    PlayerComposition comp = player.getPlayerComposition();
                    int[] items = comp.getEquipmentIds();

                    if (config.exportTPose() && !exportAnimation)
                    {
                        player.setAnimation(-1);
                        player.setPoseAnimation(-1);
                    }

                    Model model = player.getModel();
                    int vCount = model.getVerticesCount();
                    int fCount = model.getFaceCount();
                    float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
                    float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
                    float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

                    int[] vX = new int[vCount];
                    int[] vY = new int[vCount];
                    int[] vZ = new int[vCount];

                    for (int i = 0; i < vCount; i++)
                    {
                        vX[i] = (int) fvX[i];
                        vY[i] = (int) fvY[i];
                        vZ[i] = (int) fvZ[i];
                    }

                    int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
                    int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
                    int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
                    byte[] renderPriorities;
                    if (model.getFaceRenderPriorities() == null)
                    {
                        renderPriorities = new byte[fCount];
                        Arrays.fill(renderPriorities, (byte) 0);
                    }
                    else
                    {
                        renderPriorities = model.getFaceRenderPriorities();
                    }

                    byte[] transparencies;
                    if (model.getFaceTransparencies() == null)
                    {
                        transparencies = new byte[fCount];
                        Arrays.fill(transparencies, (byte) 0);
                    }
                    else
                    {
                        transparencies = model.getFaceTransparencies();
                    }

                    IterableHashTable<ActorSpotAnim> actorSpotAnims = player.getSpotAnims();
                    int[] spotAnims = new int[0];
                    for (ActorSpotAnim actorSpotAnim : actorSpotAnims)
                    {
                        spotAnims = ArrayUtils.add(spotAnims, actorSpotAnim.getId());
                    }
                    final int[] fSpotAnims = Arrays.copyOf(spotAnims, spotAnims.length);

                    String name = player.getName();
                    if (player == client.getLocalPlayer())
                        name = "Local Player";
                    String finalName = name;

                    if (config.vertexColours())
                    {
                        BlenderModel bm = modelExporter.bmVertexColours(model);
                        if (exportAnimation)
                        {
                            Thread thread = new Thread(() ->
                            {
                                ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, finalAnimId, fSpotAnims);
                                clientThread.invokeLater(() ->
                                {
                                    initiateAnimationExport(finalAnimId, finalName, bm, modelStats, comp.getColors(), true, true);
                                });
                            });
                            thread.start();
                        }
                        else
                        {
                            modelExporter.saveToFile(finalName, bm);
                        }
                    }
                    else
                    {
                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, finalAnimId, fSpotAnims);

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel bm = modelExporter.bmFaceColours(
                                        modelStats,
                                        false,
                                        comp.getColors(),
                                        true,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);

                                if (exportAnimation)
                                {
                                    initiateAnimationExport(finalAnimId, finalName, bm, modelStats, comp.getColors(), true, true);
                                }
                                else
                                {
                                    modelExporter.saveToFile(finalName, bm);
                                }
                            });
                        });
                        thread.start();
                    }
                });
    }

    public void addGameObjectGetter(int index, String option, String name, Model model, int objectId, int modelType, CustomModelType type, int animationId, int orientation, ModelMenuOption menuOption)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DEFAULT, false);
                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this Object in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
                        CustomModelComp comp = new CustomModelComp(0, type, objectId, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
                        CustomModel customModel = new CustomModel(model, comp);
                        plugin.addCustomModel(customModel, false);
                        plugin.sendChatMessage("Model stored: " + name);

                        CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
                        if (menuOption == ModelMenuOption.TRANSMOG)
                        {
                            creatorsPanel.getModelOrganizer().setTransmog(customModel);
                        }

                        if (menuOption == ModelMenuOption.STORE_AND_ADD)
                        {
                            Character character = creatorsPanel.createCharacter(
                                    ParentPanel.SIDE_PANEL,
                                    name,
                                    7699,
                                    customModel,
                                    true,
                                    orientation,
                                    animationId,
                                    -1,
                                    60,
                                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                    creatorsPanel.createEmptyProgram(animationId, animationId),
                                    false,
                                    null,
                                    null,
                                    new int[0],
                                    -1,
                                    false,
                                    false);

                            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                        }
                    });
                    thread.start();
                });
    }

    public void addDynamicObjectGetter(int index, String option, String name, int objectId, int modelType, CustomModelType type, int animationId, int orientation, ModelMenuOption menuOption)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DYNAMIC, false);
                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this Object in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        LightingStyle ls = LightingStyle.DYNAMIC;
                        CustomLighting lighting = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());
                        CustomModelComp comp = new CustomModelComp(0, type, objectId, modelStats, null, null, null, ls, lighting, false, name);
                        clientThread.invokeLater(() ->
                        {
                            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, false);
                            CustomModel customModel = new CustomModel(model, comp);
                            plugin.addCustomModel(customModel, false);
                            plugin.sendChatMessage("Model stored: " + name);

                            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
                            if (menuOption == ModelMenuOption.TRANSMOG)
                            {
                                creatorsPanel.getModelOrganizer().setTransmog(customModel);
                            }

                            if (menuOption == ModelMenuOption.STORE_AND_ADD)
                            {
                                Character character = creatorsPanel.createCharacter(
                                        ParentPanel.SIDE_PANEL,
                                        name,
                                        7699,
                                        customModel,
                                        true,
                                        orientation,
                                        animationId,
                                        -1,
                                        60,
                                        new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                        creatorsPanel.createEmptyProgram(animationId, animationId),
                                        false,
                                        null,
                                        null,
                                        new int[0],
                                        -1,
                                        false,
                                        false);

                                SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                            }
                        });
                    });
                    thread.start();
                });
    }

    public void addObjectGetterToAnvil(int index, String name, int objectId, int modelType, LightingStyle lightingStyle)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, lightingStyle, false);
                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this Object in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        clientThread.invokeLater(() ->
                        {
                            plugin.cacheToAnvil(modelStats, new int[0], false);
                            plugin.sendChatMessage("Model sent to Anvil: " + name);
                        });
                    });
                    thread.start();
                });
    }

    public void addObjectExporter(int index, String name, int objectId, int modelType, Model model)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Export", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    if (config.vertexColours())
                    {
                        BlenderModel blenderModel = modelExporter.bmVertexColours(model);
                        modelExporter.saveToFile(name, blenderModel);
                    }
                    else
                    {
                        int vCount = model.getVerticesCount();
                        int fCount = model.getFaceCount();
                        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
                        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
                        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

                        int[] vX = new int[vCount];
                        int[] vY = new int[vCount];
                        int[] vZ = new int[vCount];

                        for (int i = 0; i < vCount; i++)
                        {
                            vX[i] = (int) fvX[i];
                            vY[i] = (int) fvY[i];
                            vZ[i] = (int) fvZ[i];
                        }

                        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
                        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
                        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
                        byte[] renderPriorities;
                        if (model.getFaceRenderPriorities() == null)
                        {
                            renderPriorities = new byte[fCount];
                            Arrays.fill(renderPriorities, (byte) 0);
                        }
                        else
                        {
                            renderPriorities = model.getFaceRenderPriorities();
                        }

                        byte[] transparencies;
                        if (model.getFaceTransparencies() == null)
                        {
                            transparencies = new byte[fCount];
                            Arrays.fill(transparencies, (byte) 0);
                        }
                        else
                        {
                            transparencies = model.getFaceTransparencies();
                        }

                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DEFAULT, false);
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Object in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel blenderModel = modelExporter.bmFaceColours(
                                        modelStats,
                                        true,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);
                                modelExporter.saveToFile(name, blenderModel);
                            });
                        });
                        thread.start();

                    }
                });
    }

    public void addDynamicObjectExporter(int index, String name, int objectId, int modelType, int animId, Model model, boolean exportAnimation)
    {
        int vCount = model.getVerticesCount();
        int fCount = model.getFaceCount();
        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
        byte[] renderPriorities;
        if (model.getFaceRenderPriorities() == null)
        {
            renderPriorities = new byte[fCount];
            Arrays.fill(renderPriorities, (byte) 0);
        }
        else
        {
            renderPriorities = model.getFaceRenderPriorities();
        }

        byte[] transparencies;
        if (model.getFaceTransparencies() == null)
        {
            transparencies = new byte[fCount];
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = model.getFaceTransparencies();
        }

        String option = "Export Model";
        if (exportAnimation)
        {
            option = "Export Animation";
        }

        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag(option, Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    if (exportAnimation && animId == -1)
                    {
                        plugin.sendChatMessage("There is no animation currently playing to export.");
                        return;
                    }

                    if (config.vertexColours())
                    {
                        BlenderModel bm = modelExporter.bmVertexColours(model);

                        if (exportAnimation)
                        {
                            Thread thread = new Thread(() ->
                            {
                                ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DYNAMIC, false);
                                if (modelStats == null || modelStats.length == 0)
                                {
                                    plugin.sendChatMessage("Could not find this Object in the cache.");
                                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                    return;
                                }

                                clientThread.invokeLater(() ->
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, false);
                                });
                            });
                            thread.start();
                        }
                        else
                        {
                            modelExporter.saveToFile(name, bm);
                        }
                    }
                    else
                    {
                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DYNAMIC, false);
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Object in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            int[] vX = new int[vCount];
                            int[] vY = new int[vCount];
                            int[] vZ = new int[vCount];

                            for (int i = 0; i < vCount; i++)
                            {
                                vX[i] = (int) fvX[i];
                                vY[i] = (int) fvY[i];
                                vZ[i] = (int) fvZ[i];
                            }

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel bm = modelExporter.bmFaceColours(
                                        modelStats,
                                        true,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);

                                if (exportAnimation)
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, false);
                                }
                                else
                                {
                                    modelExporter.saveToFile(name, bm);
                                }
                            });
                        });
                        thread.start();

                    }
                });
    }

    public void addRLObjectExporter(int index, Character character, boolean exportAnimation)
    {
        String name = character.getName();
        String target = ColorUtil.prependColorTag(name, Color.GREEN);
        String option = "Export Model";
        if (exportAnimation)
        {
            option = "Export Animation";
        }

        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag(option, Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    int animId = (int) character.getAnimationSpinner().getValue();

                    if (exportAnimation && animId == -1)
                    {
                        plugin.sendChatMessage("There is no animation currently playing to export.");
                        return;
                    }

                    final Model model = character.getCKObject().getModel();
                    if (config.vertexColours())
                    {
                        BlenderModel bm = modelExporter.bmVertexColours(model);

                        if (exportAnimation)
                        {
                            if (character.isCustomMode())
                            {
                                clientThread.invokeLater(() ->
                                {
                                    CustomModelComp comp = character.getStoredModel().getComp();
                                    switch (comp.getType())
                                    {
                                        case FORGED:
                                            ModelData modelData = plugin.createComplexModelData(comp.getDetailedModels());
                                            initiateAnimationExport(animId, name, modelData.light(), bm);
                                            break;
                                        default:
                                        case CACHE_NPC:
                                        case CACHE_OBJECT:
                                        case CACHE_GROUND_ITEM:
                                        case CACHE_MAN_WEAR:
                                        case CACHE_WOMAN_WEAR:
                                            initiateAnimationExport(animId, name, bm, comp.getModelStats(), new int[0], false, false);
                                            break;
                                        case CACHE_PLAYER:
                                            initiateAnimationExport(animId, name, bm, comp.getModelStats(), comp.getKitRecolours(), true, true);
                                            break;
                                        case BLENDER:
                                            plugin.sendChatMessage("This model already came from Blender.");
                                            break;
                                    }
                                });
                            }
                            else
                            {
                                int modelId = (int) character.getModelSpinner().getValue();
                                ModelStats[] modelStats = new ModelStats[]{new ModelStats(
                                        modelId,
                                        BodyPart.NA,
                                        new short[0],
                                        new short[0],
                                        new short[0],
                                        new short[0],
                                        128,
                                        128,
                                        128,
                                        0,
                                        new CustomLighting(64, 768, -50, -50, 10))};

                                clientThread.invokeLater(() ->
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, false);
                                });
                            }
                        }
                        else
                        {
                            modelExporter.saveToFile(name, bm);
                        }
                    }
                    else
                    {
                        int vCount = model.getVerticesCount();
                        int fCount = model.getFaceCount();
                        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
                        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
                        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

                        int[] vX = new int[vCount];
                        int[] vY = new int[vCount];
                        int[] vZ = new int[vCount];

                        for (int i = 0; i < vCount; i++)
                        {
                            vX[i] = (int) fvX[i];
                            vY[i] = (int) fvY[i];
                            vZ[i] = (int) fvZ[i];
                        }

                        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
                        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
                        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
                        byte[] renderPriorities;
                        if (model.getFaceRenderPriorities() == null)
                        {
                            renderPriorities = new byte[fCount];
                            Arrays.fill(renderPriorities, (byte) 0);
                        }
                        else
                        {
                            renderPriorities = model.getFaceRenderPriorities();
                        }

                        byte[] transparencies;
                        if (model.getFaceTransparencies() == null)
                        {
                            transparencies = new byte[fCount];
                            Arrays.fill(transparencies, (byte) 0);
                        }
                        else
                        {
                            transparencies = model.getFaceTransparencies();
                        }

                        if (character.isCustomMode())
                        {
                            clientThread.invokeLater(() ->
                            {
                                CustomModelComp comp = character.getStoredModel().getComp();
                                BlenderModel bm;
                                ModelData modelData = null;
                                switch (comp.getType())
                                {
                                    case FORGED:
                                        modelData = plugin.createComplexModelData(comp.getDetailedModels());
                                        bm = modelExporter.bmFaceColoursForForgedModel(
                                                modelData,
                                                vX,
                                                vY,
                                                vZ,
                                                f1,
                                                f2,
                                                f3,
                                                transparencies,
                                                renderPriorities);
                                        break;
                                    default:
                                    case CACHE_NPC:
                                    case CACHE_OBJECT:
                                    case CACHE_GROUND_ITEM:
                                    case CACHE_MAN_WEAR:
                                    case CACHE_WOMAN_WEAR:
                                        bm = modelExporter.bmFaceColours(
                                                comp.getModelStats(),
                                                comp.getType() == CustomModelType.CACHE_OBJECT,
                                                new int[0],
                                                false,
                                                vX,
                                                vY,
                                                vZ,
                                                f1,
                                                f2,
                                                f3,
                                                transparencies,
                                                renderPriorities);
                                        break;
                                    case CACHE_PLAYER:
                                        bm = modelExporter.bmFaceColours(
                                                comp.getModelStats(),
                                                false,
                                                comp.getKitRecolours(),
                                                true,
                                                vX,
                                                vY,
                                                vZ,
                                                f1,
                                                f2,
                                                f3,
                                                transparencies,
                                                renderPriorities);
                                        break;
                                    case BLENDER:
                                        bm = comp.getBlenderModel();
                                }

                                if (exportAnimation)
                                {
                                    switch (comp.getType())
                                    {
                                        case FORGED:
                                            if (modelData != null)
                                            {
                                                initiateAnimationExport(animId, name, modelData.light(), bm);
                                            }
                                            break;
                                        default:
                                        case CACHE_NPC:
                                        case CACHE_OBJECT:
                                        case CACHE_GROUND_ITEM:
                                        case CACHE_MAN_WEAR:
                                        case CACHE_WOMAN_WEAR:
                                            initiateAnimationExport(animId, name, bm, comp.getModelStats(), new int[0], false, false);
                                            break;
                                        case CACHE_PLAYER:
                                            initiateAnimationExport(animId, name, bm, comp.getModelStats(), comp.getKitRecolours(), true, true);
                                            break;
                                        case BLENDER:
                                            plugin.sendChatMessage("This model already came from Blender.");
                                            break;
                                    }
                                }
                                else
                                {
                                    modelExporter.saveToFile(name, bm);
                                }

                            });

                        }
                        else
                        {
                            int modelId = (int) character.getModelSpinner().getValue();
                            ModelStats[] modelStats = new ModelStats[]{new ModelStats(
                                    modelId,
                                    BodyPart.NA,
                                    new short[0],
                                    new short[0],
                                    new short[0],
                                    new short[0],
                                    128,
                                    128,
                                    128,
                                    0,
                                    new CustomLighting(64, 768, -50, -50, 10))};

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel bm = modelExporter.bmFaceColours(
                                        modelStats,
                                        false,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);

                                if (exportAnimation)
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, false);
                                }
                                else
                                {
                                    modelExporter.saveToFile(name, bm);
                                }
                            });
                        }
                    }
                });
    }

    public void addGroundItemGetter(int index, String option, String name, Model model, int itemId, int orientation, ModelMenuOption menuOption)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(option)
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForGroundItem(itemId, CustomModelType.CACHE_GROUND_ITEM);
                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this Item in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
                        CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_GROUND_ITEM, itemId, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
                        CustomModel customModel = new CustomModel(model, comp);
                        plugin.addCustomModel(customModel, false);
                        plugin.sendChatMessage("Model stored: " + name);

                        CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
                        if (menuOption == ModelMenuOption.TRANSMOG)
                        {
                            creatorsPanel.getModelOrganizer().setTransmog(customModel);
                        }

                        if (menuOption == ModelMenuOption.STORE_AND_ADD)
                        {
                            Character character = creatorsPanel.createCharacter(
                                    ParentPanel.SIDE_PANEL,
                                    name,
                                    7699,
                                    customModel,
                                    true,
                                    orientation,
                                    -1,
                                    -1,
                                    60,
                                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                                    creatorsPanel.createEmptyProgram(-1, -1),
                                    false,
                                    null,
                                    null,
                                    new int[0],
                                    -1,
                                    false,
                                    false);

                            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                        }
                    });
                    thread.start();
                });
    }

    public void addGroundItemGetterToAnvil(int index, String name, int itemId)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    Thread thread = new Thread(() ->
                    {
                        ModelStats[] modelStats = dataFinder.findModelsForGroundItem(itemId, CustomModelType.CACHE_GROUND_ITEM);
                        if (modelStats == null || modelStats.length == 0)
                        {
                            plugin.sendChatMessage("Could not find this Item in the cache.");
                            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                            return;
                        }

                        clientThread.invokeLater(() ->
                        {
                            plugin.cacheToAnvil(modelStats, new int[0], false);
                            plugin.sendChatMessage("Model sent to Anvil: " + name);
                        });
                    });
                    thread.start();
                });
    }

    public void addGroundItemExporter(int index, String name, int itemId, Model model)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);
        client.getMenu().createMenuEntry(index)
                .setOption(ColorUtil.prependColorTag("Export", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e ->
                {
                    if (config.vertexColours())
                    {
                        BlenderModel blenderModel = modelExporter.bmVertexColours(model);
                        modelExporter.saveToFile(name, blenderModel);
                    }
                    else
                    {
                        int vCount = model.getVerticesCount();
                        int fCount = model.getFaceCount();

                        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
                        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
                        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

                        int[] vX = new int[vCount];
                        int[] vY = new int[vCount];
                        int[] vZ = new int[vCount];

                        for (int i = 0; i < vCount; i++)
                        {
                            vX[i] = (int) fvX[i];
                            vY[i] = (int) fvY[i];
                            vZ[i] = (int) fvZ[i];
                        }

                        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
                        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
                        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
                        byte[] renderPriorities;
                        if (model.getFaceRenderPriorities() == null)
                        {
                            renderPriorities = new byte[fCount];
                            Arrays.fill(renderPriorities, (byte) 0);
                        }
                        else
                        {
                            renderPriorities = model.getFaceRenderPriorities();
                        }

                        byte[] transparencies;
                        if (model.getFaceTransparencies() == null)
                        {
                            transparencies = new byte[fCount];
                            Arrays.fill(transparencies, (byte) 0);
                        }
                        else
                        {
                            transparencies = model.getFaceTransparencies();
                        }

                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForGroundItem(itemId, CustomModelType.CACHE_GROUND_ITEM);
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Item in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel blenderModel = modelExporter.bmFaceColours(
                                        modelStats,
                                        false,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);
                                modelExporter.saveToFile(name, blenderModel);
                            });
                        });
                        thread.start();

                    }
                });
    }

    private void initiateAnimationExport(int animId, String name, BlenderModel bm, ModelStats[] modelStats, int[] kitRecolours, boolean player, boolean actorLighting)
    {
        Model model = plugin.constructModelFromCache(modelStats, kitRecolours, player, actorLighting);
        initiateAnimationExport(animId, name, model, bm);
    }

    private void initiateAnimationExport(int animId, String name, Model model, BlenderModel bm)
    {
        exportObject = new CKObject(client);
        client.registerRuneLiteObject(exportObject);

        exportObject.setAnimation(animId);
        exportObject.setModel(model);
        exportObject.setActive(true);
        exportObject.setLocation(client.getLocalPlayer().getLocalLocation(), client.getTopLevelWorldView().getPlane());

        AnimationController ac = exportObject.getAnimationController();
        if (ac == null)
        {
            return;
        }

        Animation animation = ac.getAnimation();
        if (animation == null)
        {
            return;
        }

        int vCount = model.getVerticesCount();

        int[] clientTicks;
        if (animation.isMayaAnim())
        {
            int frames = animation.getNumFrames();
            clientTicks = new int[frames];

            for (int i = 0; i < frames; i++)
            {
                clientTicks[i] = i;
            }
        }
        else
        {
            int[] frameLengths = animation.getFrameLengths();
            int frames = frameLengths.length;
            clientTicks = new int[frames];

            for (int i = 0; i < frameLengths.length; i++)
            {
                int length = 0;
                for (int e = 0; e <= i; e++)
                {
                    length += frameLengths[e];
                }

                clientTicks[i] = length;
            }
        }

        int maxAnimFrames = exportObject.getMaxAnimFrames();
        int[][][] animVerts = new int[maxAnimFrames][model.getVerticesCount()][3];

        for (int e = 0; e < maxAnimFrames; e++)
        {
            exportObject.setAnimationFrame(e, true);
            Model m = exportObject.getModel();

            int[][] verts = animVerts[e];

            float[] fvX = m.getVerticesX();
            float[] fvY = m.getVerticesY();
            float[] fvZ = m.getVerticesZ();

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            for (int i = 0; i < verts.length; i++)
            {
                int[] v = verts[i];
                v[0] = vX[i];
                v[1] = vY[i];
                v[2] = vZ[i];
            }
        }

        exportObject.setActive(false);

        bm.setClientTicks(clientTicks);
        bm.setAnimVertices(animVerts);
        modelExporter.saveToFile(name, bm);
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ModelMenuOption
{
    STORE,
    STORE_AND_ADD,
    TRANSMOG,
    ANVIL
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class NPCData
{
    private final int id;
    private String name;
    private final int[] models;
    private final int size;
    private final int standingAnimation;
    private final int walkingAnimation;
    private final int runAnimation;
    private final int idleRotateLeftAnimation;
    private final int idleRotateRightAnimation;
    private final int rotate180Animation;
    private final int rotateLeftAnimation;
    private final int rotateRightAnimation;
    private final int widthScale;
    private final int heightScale;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class SeqData
{
    private final int id;
    private final int leftHandItem;
    private final int rightHandItem;
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class ItemData
{
    private final int id;
    private final String name;
    private final int inventoryModel;
    private final int maleModel0;
    private final int maleModel1;
    private final int maleModel2;
    private final int maleOffset;
    private final int femaleModel0;
    private final int femaleModel1;
    private final int femaleModel2;
    private final int femaleOffset;
    private final int maleHeadModel;
    private final int maleHeadModel2;
    private final int femaleHeadModel;
    private final int femaleHeadModel2;
    private final int resizeX;
    private final int resizeY;
    private final int resizeZ;
    private final int[] colorReplace;
    private final int[] colorFind;
    private final int[] textureReplace;
    private final int[] textureFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class SpotanimData
{
    private final int id;
    private final int modelId;
    private final int animationId;
    private final int resizeX;
    private final int resizeY;
    private final int ambient;
    private final int contrast;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class ObjectData
{
    private final int id;
    private final String name;
    private final int animationId;
    private final int[] objectModels;
    private final int[] objectTypes;
    private final int modelSizeX;
    private final int modelSizeY;
    private final int modelSizeZ;
    private final int ambient;
    private final int contrast;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;
    private final int[] textureToReplace;
    private final int[] retextureToFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class KitData
{
    private final int id;
    private final int bodyPartId;
    private final int[] models;
    private final int[] chatheadModels;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;
}

package com.creatorskit.models;

public enum AnimSequenceData
{
    UNALTERED,
    SWAP,
    HIDE
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

import java.util.Arrays;

@AllArgsConstructor
public enum AnimationData
{
    POSE(new int[]
            {244, 808, 809, 813, 847, 1421, 1461, 1652, 1662, 1713, 1824, 1832, 1837,
            2061, 2065, 2074, 2148, 2316, 2561, 2911, 3040, 3175, 3296, 3677, 4193, 4646, 5160, 5246, 5253, 5363,
            5869, 6297, 6604, 6657, 6936, 7053, 7220, 7271, 7508, 7518, 7538, 8009, 8057, 8208, 8521, 9018, 9341,
            9460, 9494, 9814, 9857, 10032}),
    WALK(new int[]
            {247, 744, 762, 772, 819, 844, 1205, 1205, 1422, 1660, 1663, 1703, 1830, 1836, 2060, 2064, 2076,
            2317, 2562, 3039, 3177, 3293, 3415, 3680, 4194, 4226, 4682, 5164, 5245, 5250, 5364, 5867, 6607, 6658,
            6936, 6996, 7052, 7223, 7272, 7327, 7510, 7520, 7539, 7629, 8011, 8070, 8492, 8854, 9017, 9051, 9342,
            9461, 9849, 9859, 10076, 10170}),
    RUN(new int[]
            {248, 744, 762, 772, 824, 1210, 1427, 1440, 1661, 1664, 1707, 1836, 2077, 2322, 2563, 2847, 3178, 4228,
            5168, 5253, 5868, 6277, 6603, 6660, 6936, 6995, 7043, 7221, 7273, 7274, 7509, 7519, 7540, 7633, 7703,
            8016, 8070, 8492, 8853, 9019, 9051, 9346, 9459, 9850, 9860, 10077}),
    SHUFFLE_LEFT(new int[]
            {247, 745, 762, 772, 821, 844, 1207, 1424, 1468, 1660, 1663, 1706, 1836, 2060, 2064, 2076, 2319, 2562,
            3177, 3293, 3415, 3680, 4194, 5166, 5245, 5867, 6268, 6610, 6662, 6936, 6996, 7048, 7223, 7510, 7520,
            7631, 8013, 8070, 8492, 9021, 9052, 9343, 9861, 10055, 10076, 10170}),
    SHUFFLE_RIGHT(new int[]
            {247, 745, 762, 772, 822, 844, 1208, 1208, 1425, 1468, 1660, 1663, 1705, 1836, 2060, 2064, 2076, 2320,
            2562, 3177, 3293, 3415, 3680, 4194, 5167, 5245, 5867, 6275, 6609, 6663, 6936, 6996, 7047, 7223, 7510,
            7520, 7632, 8014, 8070, 8492, 9020, 9053, 9344, 9852, 9862, 10054, 10076, 10170}),
    BACKWARDS(new int[]
            {247, 745, 762, 772, 820, 844, 1206, 1423, 1468, 1660, 1663, 1704, 1830, 1836, 2060, 2064, 2076, 2562,
            3177, 3293, 3415, 3680, 4194, 4227, 5165, 5245, 5251, 5438, 5867, 6276, 6608, 6659, 6936, 6996, 7052,
            7223, 7327, 7510, 7520, 7539, 7630, 8012, 8070, 8492, 9017, 9054, 9345, 9461, 9859, 10076, 10170}),
    ROTATE(new int[]
            {745, 762, 765, 773, 823, 845, 1205, 1209,1426, 1468, 1702, 2321, 3177, 3415, 4194, 5161, 5252, 6297,
            6611, 6661, 6936, 6998, 7044, 8015, 8070, 8492, 9050, 9343, 9863, 10055})
    ;

    private final int[] animations;

    public static boolean matchAnimation(AnimationData animationData, int animationId)
    {
        return Arrays.stream(animationData.animations).anyMatch(n -> animationId == n);
    }

    public static PoseAnimation getPoseAnimation(int animationId)
    {
        if (matchAnimation(AnimationData.POSE, animationId))
            return PoseAnimation.POSE;

        if (matchAnimation(AnimationData.WALK, animationId))
            return PoseAnimation.WALK;

        if (matchAnimation(AnimationData.RUN, animationId))
            return PoseAnimation.RUN;

        if (matchAnimation(AnimationData.SHUFFLE_LEFT, animationId))
            return PoseAnimation.SHUFFLE_LEFT;

        if (matchAnimation(AnimationData.SHUFFLE_RIGHT, animationId))
            return PoseAnimation.SHUFFLE_RIGHT;

        if (matchAnimation(AnimationData.BACKWARDS, animationId))
            return PoseAnimation.BACKWARDS;

        if (matchAnimation(AnimationData.ROTATE, animationId))
            return PoseAnimation.ROTATE;

        return PoseAnimation.NONE;
    }
}

package com.creatorskit.models.exporters;

import com.creatorskit.models.BlenderModel;
import com.creatorskit.swing.colours.HSLColor;
import com.creatorskit.models.exporters.GLTFExporter.Vertex;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import static com.creatorskit.models.ModelImporter.BLENDER_DIR;

@Slf4j
public class OBJExporter
{
    final static String HEADER = "# Made with Creator's Kit";
    final static String VERT = "v %f %f %f";
    final static String VERT_COLOUR = "v %f %f %f %f %f %f";
    final static String FACE = "f %d %d %d";
    final static String NEW_MTL = "newmtl c%d";
    final static String KD = "Kd %f %f %f";

    public static boolean saveOBJ(String name, BlenderModel blenderModel)
    {
        if (blenderModel.isUseVertexColours())
        {
            return saveVertColours(name, blenderModel);
        }
        else
        {
            return saveFaceColours(name, blenderModel);
        }
    }

    public static boolean saveVertColours(String name, BlenderModel blenderModel)
    {
        StringBuilder obj = new StringBuilder();
        obj.append(HEADER).append("\n");
        obj.append("o ").append(name).append("\n");

        HashMap<Integer, GLTFExporter.FaceMap> faceMaps = new HashMap<>();

        List<Vertex> uVerts = new ArrayList<>();
        HashMap<Integer, Integer> hashToIndex = new HashMap<>();
        HashMap<Integer, Vertex> hashVertexMap = new HashMap<>();

        // To avoid faces of the model being totally disjointed, while preserving vertex colours,
        // limit vert duplication to identical verts with different colours.
        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            GLTFExporter.FaceMap fm = new GLTFExporter.FaceMap();

            for (int vi = 0; vi < 3; vi++)
            {
                int vertIndex = face[vi];
                Vertex v = new Vertex();

                float[] xyz = new float[3];
                xyz[0] = blenderModel.getVertices()[vertIndex][0] / 128f;
                xyz[1] = -blenderModel.getVertices()[vertIndex][1] / 128f;
                xyz[2] = -blenderModel.getVertices()[vertIndex][2] / 128f;

                v.setXyz(xyz);
                v.setColour(getRGB(blenderModel.getVertexColours()[blenderModel.getVertexColourIndex()[fi * 3 + vi]]));

                if (!hashVertexMap.containsKey(v.hashCode()))
                {
                    hashToIndex.put(v.hashCode(), uVerts.size());
                    hashVertexMap.put(v.hashCode(), v);
                    uVerts.add(v);
                }

                fm.addIndex(vi, hashToIndex.get(v.hashCode()));
            }

            faceMaps.put(fi, fm);
        }

        for (Vertex v : uVerts)
        {
            obj.append(
                    String.format(
                            VERT_COLOUR,
                            v.getXyz()[0],
                            v.getXyz()[1],
                            v.getXyz()[2],
                            v.getColour()[0],
                            v.getColour()[1],
                            v.getColour()[2]
                    )
            ).append("\n");
        }

        for (int fi = 0; fi < faceMaps.size(); fi++)
        {
            GLTFExporter.FaceMap fm = faceMaps.get(fi);
            obj.append(
                    String.format(
                            FACE,
                            fm.getIndices()[0] + 1,
                            fm.getIndices()[1] + 1,
                            fm.getIndices()[2] + 1
                    )
            ).append("\n");
        }

        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".obj";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            writer.write(obj.toString());
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    public static boolean saveFaceColours(String name, BlenderModel blenderModel)
    {
        StringBuilder obj = new StringBuilder();
        StringBuilder mtl = new StringBuilder();

        for (int ci = 0; ci < blenderModel.getFaceColours().length; ci++)
        {
            float[] colour = getRGB(blenderModel.getFaceColours()[ci]);
            mtl.append(String.format(NEW_MTL, ci)).append("\n");
            mtl.append(String.format(KD, colour[0], colour[1], colour[2])).append("\n");
            if (colour[3] != 1.0f)
            {
                mtl.append(String.format("d %f", colour[3])).append("\n");
            }
        }

        obj.append(HEADER).append("\n");
        obj.append("o ").append(name).append("\n");

        for (int vi = 0; vi < blenderModel.getVertices().length; vi++)
        {
            obj.append(
                    String.format(
                            VERT,
                            blenderModel.getVertices()[vi][0] / 128f,
                            -blenderModel.getVertices()[vi][1] / 128f,
                            -blenderModel.getVertices()[vi][2] / 128f
                    )
            ).append("\n");
        }

        int currentMaterial = -1;

        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            if (blenderModel.getFaceColourIndex()[fi] != currentMaterial)
            {
                currentMaterial = blenderModel.getFaceColourIndex()[fi];
                obj.append("usemtl ").append(String.format("c%d", currentMaterial)).append("\n");
            }

            obj.append(
                    String.format(
                            FACE,
                            face[0] + 1,
                            face[1] + 1,
                            face[2] + 1
                    )
            ).append("\n");
        }

        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".obj";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            File fileMtl = new File(file.getAbsolutePath().replace(".obj", ".mtl"));

            FileWriter writer = new FileWriter(file, false);
            writer.write(obj.toString());
            writer.close();

            writer = new FileWriter(fileMtl, false);
            writer.write(mtl.toString());
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    private static float[] getRGB(double[] colour)
    {
        Color rgb = HSLColor.toRGB(new float[] {
                (float) colour[0] * 360f,
                (float) colour[2] * 100f,
                (float) colour[1] * 100f
        });

        return new float[] {
                rgb.getRed() / 255f,
                rgb.getBlue() / 255f,
                rgb.getGreen() / 255f,
                (float) colour[3]
        };
    }

}

package com.creatorskit.models.exporters;

public enum ExportFileFormat
{
    BLENDER,
    OBJ,
    GLTF
}

package com.creatorskit.models.exporters;

import com.creatorskit.models.BlenderModel;
import com.creatorskit.models.exporters.GLTF.*;
import com.creatorskit.swing.colours.HSLColor;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import com.google.common.hash.HashFunction;
import com.google.gson.Gson;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;

import static com.creatorskit.models.ModelImporter.BLENDER_DIR;

@Slf4j
public class GLTFExporter {

    static int UNSIGNED_SHORT = 5123;
    static int FLOAT = 5126;
    static int ARRAY_BUFFER = 34962;
    static int ELEMENT_ARRAY_BUFFER = 34963;

    @Getter
    GLTF gltf;
    BlenderModel blenderModel;

    HashMap<Integer, FaceMap> faceMaps = new HashMap<>();
    HashMap<Integer, float[]> vertexColours = new HashMap<>();

    List<Vertex> uVerts = new ArrayList<>();
    HashMap<Integer, Integer> hashToIndex = new HashMap<>();

    HashMap<Integer, Vertex[]> animVerts = new HashMap<>();
    HashMap<Integer, Vertex> hashVertexMap = new HashMap<>();

    public GLTFExporter(String name, BlenderModel blenderModel) {
        this.blenderModel = blenderModel;

        Vertex v1 = new Vertex();
        v1.setXyz(new float[]{1.0f, 2.0f, 3.0f});
        v1.setColour(new float[]{1.0f, 0.0f, 0.0f, 1.0f});

        Vertex v2 = new Vertex();
        v2.setXyz(new float[]{4.0f, 5.0f, 6.0f});
        v2.setColour(new float[]{1.0f, 0.0f, 0.0f, 1.0f});

        gltf = new GLTF();

        addMesh();
        refineVertices();
        addBasis();

        if (blenderModel.getClientTicks().length > 0)
        {
            createAnimVerts();
            addAnimation();
        }

        gltf.meshes.get(0).setName(name);
    }

    public boolean saveGLTF(Gson gson, String name)
    {
        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".gltf";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            String string = gson.toJson(gltf);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    private void addMesh() {
        Mesh m = new Mesh();
        gltf.meshes.add(m);
        primitive prim = new primitive();
        prim.setAttributes(new Attribute());
        m.primitives.add(prim);
    }

    private float[] convertCoords(int[] xyz)
    {
        float[] xyzf = new float[3];
        for (int i = 0; i < 3; i++)
        {
            int s = i == 0 ? 1 : -1; // y/z are inverted
            xyzf[i] = xyz[i] * s / 128f;
        }
        return xyzf;
    }

    private void refineVertices()
    {
        // To avoid faces of the model being totally disjointed, while preserving vertex colours,
        // limit vert duplication to identical verts with different colours.

        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            FaceMap fm = new FaceMap();

            for (int vi = 0; vi < 3; vi++)
            {
                int vertIndex = face[vi];
                Vertex v = new Vertex();
                v.setXyz(convertCoords(blenderModel.getVertices()[vertIndex]));
                v.setColour(getColours(fi, vi));

                if (!hashVertexMap.containsKey(v.hashCode()))
                {
                    hashToIndex.put(v.hashCode(), uVerts.size());
                    vertexColours.put(uVerts.size(), v.getColour());
                    hashVertexMap.put(v.hashCode(), v);
                    uVerts.add(v);
                }

                fm.addIndex(vi, hashToIndex.get(v.hashCode()));
            }

            faceMaps.put(fi, fm);
        }
    }

    private float[] getColours(int fi, int vi)
    {
        double[] cols;
        if (blenderModel.isUseVertexColours())
        {
            cols = blenderModel.getVertexColours()[blenderModel.getVertexColourIndex()[fi * 3 + vi]];
        } else {
            cols = blenderModel.getFaceColours()[blenderModel.getFaceColourIndex()[fi]];
        }

        Color rgbColor = HSLColor.toRGB(new float[] {
                (float) cols[0] * 360f,
                (float) cols[2] * 100f,
                (float) cols[1] * 100f
        });

        return new float[] {
                (float) Math.pow(rgbColor.getRed() / 255f, 2.2f),
                (float) Math.pow(rgbColor.getBlue() / 255f, 2.2f),
                (float) Math.pow(rgbColor.getGreen() / 255f, 2.2f),
                (float) cols[3]
        };
    }

    private void addBasis() {

        // Verts and colours
        int vertexCount = uVerts.size();

        float[] vertexMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] vertexMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        float[] colourMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] colourMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        ByteBuffer vertices = ByteBuffer.allocateDirect(vertexCount * 3 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);
        ByteBuffer vertColours = ByteBuffer.allocateDirect(vertexCount * 4 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);

        for (Vertex vert : uVerts) {
            for (int i = 0; i < 3; i++)
            {
                float s = vert.getXyz()[i];
                vertices.putFloat(s);
                vertexMin[i] = Math.min(vertexMin[i], s);
                vertexMax[i] = Math.max(vertexMax[i], s);
            }

            for (int l = 0; l < 4; l++)
            {
                vertColours.putFloat(vert.getColour()[l]);
                colourMin[l] = Math.min(colourMin[l], vert.getColour()[l]);
                colourMax[l] = Math.max(colourMax[l], vert.getColour()[l]);
            }
        }

        int vertAccessorIdx = addBuffer(vertices, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC3);
        Accessor vertexAccessor = gltf.accessors.get(vertAccessorIdx);

        for (int i = 0; i < 3; i++) {
            vertexAccessor.min.add(vertexMin[i]);
            vertexAccessor.max.add(vertexMax[i]);
        }

        gltf.meshes.get(0).primitives.get(0).attributes.setPOSITION(vertAccessorIdx);

        int colourAccessorIdx = addBuffer(vertColours, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC4);
        gltf.meshes.get(0).primitives.get(0).attributes.setCOLOR_0(colourAccessorIdx);

        // Faces
        ByteBuffer faces = ByteBuffer.allocateDirect(faceMaps.size() * 3 * 2)
                .order(ByteOrder.LITTLE_ENDIAN);

        short faceMin = Short.MAX_VALUE;
        short faceMax = Short.MIN_VALUE;

        for (int i = 0; i < faceMaps.size(); i++)
        {
            FaceMap fm = faceMaps.get(i);
            for (int j = 0; j < 3; j++)
            {
                faceMin = (short) Math.min(faceMin, fm.getIndices()[j]);
                faceMax = (short) Math.max(faceMax, fm.getIndices()[j]);
                faces.putShort((short) fm.getIndices()[j]);
            }
        }

        int faceAccessorIdx = addBuffer(
                faces, faceMaps.size() * 3, ELEMENT_ARRAY_BUFFER, UNSIGNED_SHORT, AccessorType.SCALAR
        );
        Accessor faceAccessor = gltf.accessors.get(faceAccessorIdx);
        faceAccessor.min.add(faceMin);
        faceAccessor.max.add(faceMax);
        gltf.meshes.get(0).primitives.get(0).setIndices(faceAccessorIdx);
    }

    private void createAnimVerts()
    {
        for (int frame = 0; frame < blenderModel.getAnimVertices().length; frame++)
        {
            int[][] anim = blenderModel.getAnimVertices()[frame];
            Vertex[] verts = new Vertex[uVerts.size()];

            for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
            {
                int[] face = blenderModel.getFaces()[fi];
                for (int vi = 0; vi < 3; vi++)
                {
                    int index = faceMaps.get(fi).getIndices()[vi];
                    Vertex baseV = uVerts.get(index);

                    float[] newPosition = convertCoords(anim[face[vi]]);
                    float[] displacement = new float[3];
                    for (int i = 0; i < 3; i++)
                    {
                        displacement[i] = newPosition[i] - baseV.getXyz()[i];
                    }

                    Vertex v = new Vertex();
                    v.setXyz(displacement);

                    verts[index] = v;
                }
            }

            animVerts.put(frame, verts);
        }
    }

    private void addAnimation()
    {
        // Add morph targets
        for (int frame = 0; frame < blenderModel.getAnimVertices().length; frame++)
        {
            Vertex[] verts = animVerts.get(frame);
            int morphAccessor = addMorphTarget(verts);

            gltf.meshes.get(0).weights.add(frame == 0 ? 1 : 0);

            Target t = new Target();
            t.setPOSITION(morphAccessor);
            gltf.meshes.get(0).primitives.get(0).targets.add(t);
        }

        // Add the weights and keyframes
        int weightsAccessor = addWeights();
        int keyframesAccessor = addKeyframes();

        // Add the animation
        Animation anim = new Animation();

        Sampler sampler = new Sampler();
        sampler.input = keyframesAccessor;
        sampler.output = weightsAccessor;

        Channel channel = new Channel();
        channel.sampler = 0;
        channel.target = new ChannelTarget();

        anim.samplers.add(sampler);
        anim.channels.add(channel);

        gltf.animations.add(anim);
    }

    private int addMorphTarget(Vertex[] verts)
    {
        int vertexCount = verts.length;

        float[] morphMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] morphMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        ByteBuffer morph = ByteBuffer.allocateDirect(vertexCount * 3 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);

        // Add the displacements to the buffer
        for (Vertex vert : verts) {
            for (int i = 0; i < 3; i++)
            {
                float displacement = vert.getXyz()[i];
                morph.putFloat(displacement);
                morphMin[i] = Math.min(morphMin[i], displacement);
                morphMax[i] = Math.max(morphMax[i], displacement);
            }
        }

        int idx = addBuffer(morph, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC3);
        Accessor a = gltf.accessors.get(idx);
        for (int i = 0; i < 3; i++)
        {
            a.min.add(morphMin[i]);
            a.max.add(morphMax[i]);
        }

        return idx;
    }

    private int addWeights()
    {
        int frameCount = blenderModel.getClientTicks().length;
        int capacity = frameCount * frameCount * 4;

        ByteBuffer weights = ByteBuffer.allocateDirect(capacity)
                .order(ByteOrder.LITTLE_ENDIAN);

        for (int frame = 0; frame < frameCount; frame++)
        {
            for (int morph = 0; morph < frameCount; morph++)
            {
                weights.putFloat(morph == frame ? 1.0f : 0.0f);
            }
        }

        return addBuffer(weights, frameCount * frameCount, ARRAY_BUFFER, FLOAT, AccessorType.SCALAR);
    }

    private int addKeyframes()
    {
        int frameCount = blenderModel.getClientTicks().length;
        int capacity = frameCount * 4;

        ByteBuffer keyframes = ByteBuffer.allocateDirect(capacity)
                .order(ByteOrder.LITTLE_ENDIAN);

        float min = Float.MAX_VALUE;
        float max = Float.MIN_VALUE;

        for (int i = 0; i < frameCount; i++)
        {
            float secs = i == 0 ? 0f : blenderModel.getClientTicks()[i] * 20 / 1000f;
            min = Math.min(min, secs);
            max = Math.max(max, secs);
            keyframes.putFloat(secs);
        }

        int idx = addBuffer(keyframes, frameCount, ARRAY_BUFFER, FLOAT, AccessorType.SCALAR);
        Accessor a = gltf.accessors.get(idx);
        a.min.add(min);
        a.max.add(max);

        return idx;
    }

    private int addBuffer(
            ByteBuffer buf,
            int count,
            int target,
            int componentType,
            AccessorType type
    )
    {
        Buffer b = new Buffer();
        BufferView bv = new BufferView();
        Accessor a = new Accessor();

        gltf.buffers.add(b);
        gltf.bufferViews.add(bv);
        gltf.accessors.add(a);

        b.setUri("data:application/octet-stream;base64," + bytesToBase64(buf));
        b.setByteLength(buf.capacity());

        bv.setBuffer(gltf.buffers.size() - 1);
        bv.setByteOffset(0);
        bv.setByteLength(buf.capacity());
        bv.setTarget(target);

        a.setBufferView(gltf.bufferViews.size() - 1);
        a.setByteOffset(0);
        a.setComponentType(componentType);
        a.setNormalized(false);
        a.setCount(count);
        a.setType(type);

        return gltf.accessors.size() - 1;
    }

    private String bytesToBase64(ByteBuffer buffer) {
        buffer.rewind();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        return java.util.Base64.getEncoder().encodeToString(bytes);
    }

    @Data
    static class Vertex
    {
        float[] xyz;
        float[] colour;
        int index;

        @Override
        public boolean equals(Object obj)
        {
            if (!(obj instanceof Vertex))
            {
                return false;
            }

            Vertex v = (Vertex) obj;
            return Arrays.equals(xyz, v.getXyz()) && Arrays.equals(colour, v.getColour());
        }

        @Override
        public int hashCode() {
            HashFunction hashFunction = Hashing.murmur3_32();
            Hasher hasher = hashFunction.newHasher();

            for (float value : xyz) {
                hasher.putFloat(value);
            }

            for (float value : colour) {
                hasher.putFloat(value);
            }

            return hasher.hash().asInt();
        }
    }

    @Data
    static
    class FaceMap
    {
        int[] indices;
        public void addIndex(int pos, int vertIndex)
        {
            if (indices == null)
            {
                indices = new int[3];
            }

            indices[pos] = vertIndex;
        }

        public int get(int i) { return indices[i]; }
    }
}

package com.creatorskit.models.exporters;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

public class GLTF
{
    public int scene = 0;
    public Scene[] scenes = new Scene[]{new Scene()};
    public Node[] nodes = new Node[]{new Node()};
    public BaseSampler[] samplers = new BaseSampler[]{new BaseSampler()};
    public List<Mesh> meshes = new ArrayList<>();
    public List<Buffer> buffers = new ArrayList<>();
    public List<BufferView> bufferViews = new ArrayList<>();
    public List<Accessor> accessors = new ArrayList<>();
    public Asset asset = new Asset();

    public Material[] materials = new Material[]{new Material()};
    public List<Animation> animations = new ArrayList<>();

    enum AccessorType {
        SCALAR,
        VEC3,
        VEC4
    }

    public static class Scene {
        int[] nodes = new int[]{0};
    }

    public static class Node {
        int mesh = 0;
    }

    @Data
    public static class Mesh {
        List<primitive> primitives = new ArrayList<>();
        List<Integer> weights = new ArrayList<>();
        int[] materials = new int[]{0};
        String name = "mesh";
    }

    @Data
    public static class primitive {
        int indices;
        Attribute attributes;
        List<Target> targets = new ArrayList<>();
        int material = 0;
    }

    @Data
    public static class Target {
        int POSITION;
    }

    @Data
    public static class Attribute {
        int POSITION;
        int COLOR_0;
    }

    public static class Material
    {
        String name = "vertexColors";
        float[] baseColorFactor = new float[]{1.0f, 1.0f, 1.0f};
        MetallicRoughness pbrMetallicRoughness = new MetallicRoughness();
    }

    public static class MetallicRoughness
    {
        float[] baseColorFactor = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
        float metallicFactor = 0.0f;
        float roughnessFactor = 1.0f;
    }

    @Data
    public static class Animation {
        List<Channel> channels = new ArrayList<>();
        List<Sampler> samplers = new ArrayList<>();
    }

    public static class BaseSampler {
        int magFilter = 9729;
        int minFilter = 9987;
        int wrapS = 33648;
        int wrapT = 33648;
    }

    @Data
    public static class Sampler {
        int input;
        String interpolation = "STEP";
        int output;
    }

    @Data
    public static class Channel {
        int sampler;
        ChannelTarget target;
    }

    public static class ChannelTarget {
        int node = 0;
        String path = "weights";
    }

    @Data
    public static class Buffer {
        String uri;
        int byteLength;
    }

    @Data
    public static class BufferView {
        int buffer;
        int byteOffset;
        int byteLength;
        int target;
    }

    @Data
    public static class Accessor {
        int bufferView;
        int byteOffset;
        int componentType;
        boolean normalized;
        int count;
        AccessorType type;
        List<Number> max = new ArrayList<>();
        List<Number> min = new ArrayList<>();
    }

    public static class Asset {
        String version = "2.0";
        String generator = "CreatorsKit";
    }
}

package com.creatorskit.models.exporters;

import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import java.nio.file.Paths;

import com.creatorskit.models.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.RuneLite;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;

@Slf4j
public class ModelExporter
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    public final File BLENDER_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/blender-models");

    @Inject
    public ModelExporter(Client client, CreatorsPlugin plugin, CreatorsConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    public void saveToFile(String name, BlenderModel blenderModel)
    {
        boolean success;
        switch (config.exportFileFormat())
        {
            case OBJ:
                if (blenderModel.getAnimVertices().length > 0)
                {
                    plugin.sendChatMessage("You cannot export animations to OBJ format. Falling back to Blender format.");
                    success = saveBlender(name, blenderModel);
                } else {
                    success = OBJExporter.saveOBJ(name, blenderModel);
                }
                break;
            case GLTF:
                GLTFExporter gltfExporter = new GLTFExporter(name, blenderModel);
                success = gltfExporter.saveGLTF(plugin.getGson(), name);
                break;
            default:
            case BLENDER:
                success = saveBlender(name, blenderModel);
                break;
        }

        if (success)
            plugin.sendChatMessage("Exported " + name + " to your /.runelite/creatorskit/blender-models directory.");
    }

    private boolean saveBlender(String name, BlenderModel blenderModel)
    {
        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".json";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            String string = plugin.getGson().toJson(blenderModel);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    public BlenderModel bmVertexColours(Renderable renderable)
    {
        Model model;
        if (renderable instanceof Model)
        {
            model = (Model) renderable;
        }
        else
        {
            model = renderable.getModel();
        }

        int[][] verts = new int[model.getVerticesCount()][3];
        float[] vX = model.getVerticesX();
        float[] vY = model.getVerticesY();
        float[] vZ = model.getVerticesZ();

        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = (int) vX[i];
            v[1] = (int) vY[i];
            v[2] = (int) vZ[i];
        }

        int[][] faces = new int[model.getFaceCount()][3];
        int[] fX = model.getFaceIndices1();
        int[] fY = model.getFaceIndices2();
        int[] fZ = model.getFaceIndices3();

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = fX[i];
            f[1] = fY[i];
            f[2] = fZ[i];
        }

        byte[] transparencies = new byte[model.getFaceCount()];
        if (model.getFaceTransparencies() == null)
        {
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = model.getFaceTransparencies();
        }

        // Each face has 3 vertices, each vertex has a h, l, s, and alpha value
        byte[] vertTransparencies = Arrays.copyOf(transparencies, transparencies.length);
        int[] vt = new int[vertTransparencies.length];
        for (int i = 0; i< model.getFaceCount(); i++)
        {
            int tp = vertTransparencies[i];
            if (tp < 0)
            {
                tp += 256;
            }
            vt[i] = tp;
        }

        int[] fc1 = model.getFaceColors1();
        int[] fc2 = model.getFaceColors2();
        int[] fc3 = model.getFaceColors3();
        int[][] shortList = new int[0][2];
        int[] vertexColourIndex = new int[0];

        for (int i = 0; i < model.getFaceCount(); i++)
        {
            int tp = vt[i];

            int fc1i = fc1[i];
            int fc2i = fc2[i];
            int fc3i = fc3[i];
            boolean shadeFlat = fc3i == -1;
            if (shadeFlat)
            {
                fc3i = fc2i = fc1i;
            }

            boolean alreadyContains1 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc1i && shortList[e][1] == tp)
                {
                    alreadyContains1 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains1)
            {
                int[] colourTransparency = new int[]{fc1i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }


            boolean alreadyContains2 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc2i && shortList[e][1] == tp)
                {
                    alreadyContains2 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains2)
            {
                int[] colourTransparency = new int[]{fc2i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }

            boolean alreadyContains3 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc3i && shortList[e][1] == tp)
                {
                    alreadyContains3 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains3)
            {
                int[] colourTransparency = new int[]{fc3i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }
        }

        /*
        System.out.println("Shortlist length: " + shortList.length);
        System.out.println("index length: " + vertexColourIndex.length);
        System.out.println("Verts: " + model.getVerticesCount());
        System.out.println("Faces: " + model.getFaceCount());

         */

        double[][] vertexColours = new double[shortList.length][4];
        for (int i = 0; i < shortList.length; i++)
        {
            double tp = shortList[i][1];
            tp = -1 * (tp - 255) / 255;

            int intCol = shortList[i][0];
            if (intCol > 32767)
            {
                intCol -= 65536;
            }

            short col = (short) intCol;
            double h0 = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l0 = (double) JagexColor.unpackLuminance(col) / 127;
            double s0 = (double) JagexColor.unpackSaturation(col) / 7;
            vertexColours[i][0] = h0;
            vertexColours[i][1] = l0;
            vertexColours[i][2] = s0;
            vertexColours[i][3] = tp;
        }

        byte[] renderPriorities = model.getFaceRenderPriorities();
        if (model.getFaceRenderPriorities() == null)
        {
            renderPriorities = new byte[model.getFaceCount()];
            Arrays.fill(renderPriorities, (byte) 0);
        }

        return new BlenderModel(
                true,
                verts,
                faces,
                vertexColours,
                vertexColourIndex,
                new double[0][],
                new int[0],
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }

    public BlenderModel bmFaceColours(
            ModelStats[] modelStatsArray,
            boolean object,
            int[] kitRecolours,
            boolean player,
            int[] vX,
            int[] vY,
            int[] vZ,
            int[] f1,
            int[] f2,
            int[] f3,
            byte[] transparencies,
            byte[] renderPriorities)
    {
        ModelData[] mds = new ModelData[modelStatsArray.length];

        for (int i = 0; i < modelStatsArray.length; i++)
        {
            ModelStats modelStats = modelStatsArray[i];
            ModelData modelData = client.loadModelData(modelStats.getModelId());

            if (modelData == null)
                continue;

            modelData.cloneColors().cloneVertices();
            if (modelData.getFaceTransparencies() != null)
            {
                modelData.cloneTransparencies();
            }

            for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
                modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

            if (player)
                KitRecolourer.recolourKitModel(modelData, modelStats.getBodyPart(), kitRecolours);

            short[] textureFrom = modelStats.getTextureFrom();
            short[] textureTo = modelStats.getTextureTo();

            if (textureFrom == null || textureTo == null)
            {
                modelStats.setTextureFrom(new short[0]);
                modelStats.setTextureTo(new short[0]);
            }

            textureFrom = modelStats.getTextureFrom();
            textureTo = modelStats.getTextureTo();

            if (textureFrom.length > 0 && textureTo.length > 0)
            {
                for (int e = 0; e < textureFrom.length; e++)
                {
                    modelData.retexture(textureFrom[e], textureTo[e]);
                }
            }

            if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
            {
                modelStats.setResizeX(128);
                modelStats.setResizeY(128);
                modelStats.setResizeZ(128);
            }

            if (!object)
            {
                modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());
            }
            modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

            mds[i] = modelData;
        }

        ModelData md = client.mergeModels(mds);
        if (object)
        {
            ModelStats ms0 = modelStatsArray[0];
            if (ms0 == null)
            {
                return null;
            }

            md.scale(ms0.getResizeX(), ms0.getResizeZ(), ms0.getResizeY());
        }

        /*
        System.out.println("ModelData FC: " + md.getFaceCount());
        System.out.println(f1.length + "," + f2.length + "," + f3.length);
        System.out.println("ModelData VC: " + md.getVerticesCount());
        System.out.println(vX.length + "," + vY.length + "," + vZ.length);
         */

        int[][] verts = new int[md.getVerticesCount()][3];
        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = vX[i];
            v[1] = vY[i];
            v[2] = vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]

        );
    }

    public BlenderModel bmFaceColoursForForgedModel(
            ModelData md,
            int[] vX,
            int[] vY,
            int[] vZ,
            int[] f1,
            int[] f2,
            int[] f3,
            byte[] transparencies,
            byte[] renderPriorities)
    {
        /*
        System.out.println("ModelData FC: " + md.getFaceCount());
        System.out.println(f1.length + "," + f2.length + "," + f3.length);
         */

        int[][] verts = new int[md.getVerticesCount()][3];
        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = vX[i];
            v[1] = vY[i];
            v[2] = vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }

    public BlenderModel bmFromCustomModel(CustomModel customModel)
    {
        CustomModelComp comp = customModel.getComp();
        Model model = customModel.getModel();

        BlenderModel blenderModel;
        ModelData md;
        int fCount;
        byte[] renderPriorities;
        byte[] transparencies;
        switch (comp.getType())
        {
            case FORGED:
                md = plugin.createComplexModelData(comp.getDetailedModels());
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx = md.getVerticesX();
                float[] fvy = md.getVerticesY();
                float[] fvz = md.getVerticesZ();

                int vCount = md.getVerticesCount();
                int[] vX = new int[vCount];
                int[] vY = new int[vCount];
                int[] vZ = new int[vCount];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX[i] = (int) fvx[i];
                    vY[i] = (int) fvy[i];
                    vZ[i] = (int) fvz[i];
                }

                blenderModel = bmFaceColoursForForgedModel(
                        md,
                        vX,
                        vY,
                        vZ,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            default:
            case CACHE_NPC:
            case CACHE_OBJECT:
            case CACHE_GROUND_ITEM:
            case CACHE_MAN_WEAR:
            case CACHE_WOMAN_WEAR:
                md = plugin.constructModelDataFromCache(comp.getModelStats(), new int[0], false);
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx1 = md.getVerticesX();
                float[] fvy1 = md.getVerticesY();
                float[] fvz1 = md.getVerticesZ();

                int vCount1 = md.getVerticesCount();
                int[] vX1 = new int[vCount1];
                int[] vY1 = new int[vCount1];
                int[] vZ1 = new int[vCount1];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX1[i] = (int) fvx1[i];
                    vY1[i] = (int) fvy1[i];
                    vZ1[i] = (int) fvz1[i];
                }

                blenderModel = bmFaceColours(
                        comp.getModelStats(),
                        comp.getType() == CustomModelType.CACHE_OBJECT,
                        new int[0],
                        false,
                        vX1,
                        vY1,
                        vZ1,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            case CACHE_PLAYER:
                md = plugin.constructModelDataFromCache(comp.getModelStats(), comp.getKitRecolours(), true);
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx2 = md.getVerticesX();
                float[] fvy2 = md.getVerticesY();
                float[] fvz2 = md.getVerticesZ();

                int vCount2 = md.getVerticesCount();
                int[] vX2 = new int[vCount2];
                int[] vY2 = new int[vCount2];
                int[] vZ2 = new int[vCount2];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX2[i] = (int) fvx2[i];
                    vY2[i] = (int) fvy2[i];
                    vZ2[i] = (int) fvz2[i];
                }

                blenderModel = bmFaceColours(
                        comp.getModelStats(),
                        false,
                        comp.getKitRecolours(),
                        true,
                        vX2,
                        vY2,
                        vZ2,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            case BLENDER:
                blenderModel = comp.getBlenderModel();
        }

        return blenderModel;
    }

    public BlenderModel bmSpotAnimFromCache(ModelStats[] modelStatsArray)
    {
        ModelData[] mds = new ModelData[modelStatsArray.length];

        for (int i = 0; i < modelStatsArray.length; i++)
        {
            ModelStats modelStats = modelStatsArray[i];
            ModelData modelData = client.loadModelData(modelStats.getModelId());

            if (modelData == null)
                continue;

            modelData.cloneColors().cloneVertices();
            if (modelData.getFaceTransparencies() != null)
            {
                modelData.cloneTransparencies();
            }

            for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
                modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

            if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
            {
                modelStats.setResizeX(128);
                modelStats.setResizeY(128);
                modelStats.setResizeZ(128);
            }

            modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());
            modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

            mds[i] = modelData;
        }

        ModelData md = client.mergeModels(mds);

        int[][] verts = new int[md.getVerticesCount()][3];
        float[] vX = md.getVerticesX();
        float[] vY = md.getVerticesY();
        float[] vZ = md.getVerticesZ();

        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = (int) vX[i];
            v[1] = (int) vY[i];
            v[2] = (int) vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];
        int[] f1 = md.getFaceIndices1();
        int[] f2 = md.getFaceIndices2();
        int[] f3 = md.getFaceIndices3();

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        byte[] transparencies = new byte[md.getFaceCount()];
        if (md.getFaceTransparencies() == null)
        {
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = md.getFaceTransparencies();
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        byte[] renderPriorities = new byte[md.getFaceCount()];

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum CustomModelType
{
    FORGED("Forged"),
    CACHE_NPC("NPC"),
    CACHE_OBJECT("Object"),
    CACHE_PLAYER("Player"),
    CACHE_GROUND_ITEM("Ground Item"),
    CACHE_MAN_WEAR("Male Worn Item"),
    CACHE_WOMAN_WEAR("Female Worn Item"),
    BLENDER("Blender")

    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Model;

@Getter
@Setter
@AllArgsConstructor
public class CustomModel
{
    private Model model;
    private CustomModelComp comp;

    @Override
    public String toString()
    {
        return comp.getName();
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CustomModelComp
{
    private int customModelId;
    private CustomModelType type;
    private int modelId;
    private ModelStats[] modelStats;
    private int[] kitRecolours;
    private DetailedModel[] detailedModels;
    private BlenderModel blenderModel;
    private LightingStyle lightingStyle;
    private CustomLighting customLighting;
    private boolean priority;
    private String name;
}

package com.creatorskit.models;

import net.runelite.api.ModelData;
import org.apache.commons.lang3.ArrayUtils;

public class KitRecolourer
{
    public static final short[] BODY_COLOURS_1_SOURCE = new short[]{
            6798, 8741, 25238, 4626, 4550
    };
    public static final short[][] BODY_COLOURS_1_DEST = new short[][]{
            {6798, 107, 10283, 16, 4797, 7744, 5799, 4634, -31839, 22433, 2983, -11343, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010, -22122, 937, 8130, -13422, 30385},
            {8741, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 25239, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
            {25238, 8742, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
            {4626, 11146, 6439, 12, 4758, 10270},
            {4550, 4537, 5681, 5673, 5790, 6806, 8076, 4574, 17050, 0, 127, -31821, -17991}
    };
    public static final short[] BODY_COLOURS_2_SOURCE = new short[]{
            -10304, 9104, -1, -1, -1
    };
    public static final short[][] BODY_COLOURS_2_DEST = new short[][]{
            {6554, 115, 10304, 28, 5702, 7756, 5681, 4510, -31835, 22437, 2859, -11339, 16, 5157, 10446, 3658, -27314, -21965, 472, 580, 784, 21966, 28950, -15697, -14002, -22116, 945, 8144, -13414, 30389},
            {9104, 10275, 7595, 3610, 7975, 8526, 918, -26734, 24466, 10145, -6882, 5027, 1457, 16565, -30545, 25486, 24, 5392, 10429, 3673, -27335, -21957, 192, 687, 412, 21821, 28835, -15460, -14019},
            new short[0],
            new short[0],
            new short[0]
    };

                        /*
						0 = hair, jaw
						1 = torso, arms
						2 = legs
						3 = Feet
						4 = Hands
						 */

    public static ModelData recolourKitModel(ModelData modelData, BodyPart bodyPart, int[] kitRecolours)
    {
        switch (bodyPart)
        {
            default:
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HAIR:
            case JAW:
                modelData.recolor(BODY_COLOURS_1_SOURCE[0], BODY_COLOURS_1_DEST[0][kitRecolours[0]]);
                modelData.recolor(BODY_COLOURS_2_SOURCE[0], BODY_COLOURS_2_DEST[0][kitRecolours[0]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case TORSO:
            case ARMS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[1], BODY_COLOURS_1_DEST[1][kitRecolours[1]]);
                modelData.recolor(BODY_COLOURS_2_SOURCE[1], BODY_COLOURS_2_DEST[1][kitRecolours[1]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case LEGS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[2], BODY_COLOURS_1_DEST[2][kitRecolours[2]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case FEET:
                modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HANDS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
        }
        return modelData;
    }

    public static short[] getKitRecolourFrom(BodyPart bodyPart)
    {
        short[] colourFrom = new short[0];

        switch (bodyPart)
        {
            default:
                colourFrom = ArrayUtils.add(colourFrom, BODY_COLOURS_1_SOURCE[4]);
                break;
            case HAIR:
            case JAW:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[0], BODY_COLOURS_2_SOURCE[0], BODY_COLOURS_1_SOURCE[4]);
                break;
            case TORSO:
            case ARMS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[1], BODY_COLOURS_2_SOURCE[1], BODY_COLOURS_1_SOURCE[4]);
                break;
            case LEGS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[2], BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_SOURCE[4]);
                break;
            case FEET:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_SOURCE[4]);
                break;
            case HANDS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[4]);
        }

        return colourFrom;
    }

    public static short[] getKitRecolourTo(BodyPart bodyPart, int[] kitRecolours)
    {
        short[] colourTo = new short[0];

        switch (bodyPart)
        {
            default:
                colourTo = ArrayUtils.add(colourTo, BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HAIR:
            case JAW:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[0][kitRecolours[0]], BODY_COLOURS_2_DEST[0][kitRecolours[0]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case TORSO:
            case ARMS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[1][kitRecolours[1]], BODY_COLOURS_2_DEST[1][kitRecolours[1]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case LEGS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[2][kitRecolours[2]], BODY_COLOURS_1_DEST[3][kitRecolours[3]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case FEET:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[3][kitRecolours[3]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HANDS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
        }

        return colourTo;
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class BlenderModel
{
    boolean useVertexColours;
    int[][] vertices;
    int[][] faces;
    double[][] vertexColours;
    int[] vertexColourIndex;
    double[][] faceColours;
    int[] faceColourIndex;
    byte[] priorities;
    int[] clientTicks;
    int[][][] animVertices;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class DetailedModel
{
    private String name;
    private int modelId;
    private int group;
    private int xTile;
    private int yTile;
    private int zTile;
    private int xTranslate;
    private int yTranslate;
    private int zTranslate;
    private int xScale;
    private int yScale;
    private int zScale;
    private int rotate;
    private String recolourNew;
    private String recolourOld;
    private short[] coloursFrom;
    private short[] coloursTo;
    private short[] texturesFrom;
    private short[] texturesTo;
    private boolean invertFaces;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum LightingStyle
{
    NONE("None", 128, 4000, -50, -50, 10),
    ACTOR("Actor", 64, 850, -30, -30, 50),
    DEFAULT("Default", 64, 768, -50, -50, 10),
    SPOTANIM("SpotAnim", 64, 850, -50, -50, 75),
    DYNAMIC("Dynamic", 100, 850, -10, -10, 10),
    CUSTOM("Custom", 64, 768, -50, -50, 10)
    ;

    private final String string;
    private final int ambient;
    private final int contrast;
    private final int x;
    private final int y;
    private final int z;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.models;

public enum PoseAnimation
{
    POSE,
    WALK,
    RUN,
    BACKWARDS,
    SHUFFLE_LEFT,
    SHUFFLE_RIGHT,
    ROTATE,
    NONE
}

package com.creatorskit;

public enum AutoRotate
{
    OFF,
    LEFT,
    RIGHT,
    UP,
    DOWN
}

package com.creatorskit;

import com.creatorskit.models.exporters.ExportFileFormat;
import net.runelite.client.config.*;

import java.awt.event.KeyEvent;

@ConfigGroup("creatorssuite")
public interface CreatorsConfig extends Config
{
	@ConfigSection(
			name = "Scene",
			description = "Settings for setting up your scene",
			position = 0
	)
	String sceneSettings = "sceneSettings";

	@ConfigItem(
			keyName = "enableRightClick",
			name = "Enable Right-Click Store/Anvil",
			description = "Enables Right-Click menu options Store & Anvil on Objects, NPCs, and Players",
			section = sceneSettings,
			position = 0
	)
	default boolean rightClick()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableCtrlHotkeys",
			name = "Enable Ctrl Hotkeys",
			description = "Enables various additional menu options when holding Ctrl",
			section = sceneSettings,
			position = 1
	)
	default boolean enableCtrlHotkeys()
	{
		return false;
	}

	@ConfigItem(
			keyName = "enableSelect",
			name = "Enable Right-Click Select",
			description = "Enables Right-Click menu option to Select an Object you've spawned",
			section = sceneSettings,
			position = 2
	)
	default boolean rightSelect()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableSpotAnim",
			name = "Enable Right-Click SpotAnim",
			description = "Enables Right-Click menu option to grab a Player's SpotAnims",
			section = sceneSettings,
			position = 3
	)
	default boolean rightSpotAnim()
	{
		return false;
	}

	@ConfigItem(
			keyName = "exportRightClick",
			name = "Enable Right-Click Export",
			description = "Enables Right-Click menu option to Export an Object, NPC, or Player to a .json for Blender",
			section = sceneSettings,
			position = 4
	)
	default boolean exportRightClick()
	{
		return false;
	}

	@ConfigItem(
			keyName = "transmogRightClick",
			name = "Enable Right-Click Transmog",
			description = "Provides a right-click option to Transmog on Objects, NPCs, and Players",
			section = transmogrification,
			position = 5
	)
	default boolean transmogRightClick()
	{
		return false;
	}

	@ConfigItem(
			keyName = "toggleAutoSetup",
			name = "Enable Auto-Setup",
			description = "Automatically loads the saved Setup from the file path below" +
				"<br>Please note that enabling this feature will slow down client start-up",
			section = sceneSettings,
			position = 6
	)
	default boolean autoSetup()
	{
		return false;
	}

	@ConfigItem(
			keyName = "setupPath",
			name = "Auto-Setup Path",
			description = "Enter the file path of a previously saved setup to automatically load on client start-up",
			section = sceneSettings,
			position = 7
	)
	default String setupPath()
	{
		return "";
	}

	@ConfigItem(
			keyName = "quickSpawn",
			name = "Spawn Hotkey",
			description = "Hotkey to toggle the spawn or despawn state of the selected object",
			section = sceneSettings,
			position = 8
	)
	default Keybind quickSpawnHotkey()
	{
		return new Keybind(KeyEvent.VK_INSERT, 0);
	}

	@ConfigItem(
			keyName = "quickLocation",
			name = "Set Relocate Hotkey",
			description = "Hotkey to set the selected object to the mouse location",
			section = sceneSettings,
			position = 9
	)
	default Keybind quickLocationHotkey()
	{
		return new Keybind(KeyEvent.VK_HOME, 0);
	}

	@ConfigItem(
			keyName = "quickDuplicate",
			name = "Duplicate Hotkey",
			description = "Hotkey to duplicate the selected object",
			section = sceneSettings,
			position = 10
	)
	default Keybind quickDuplicateHotkey()
	{
		return new Keybind(KeyEvent.VK_D, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "quickRotateCW",
			name = "Rotate CW Hotkey",
			description = "Hotkey to rotate the selected object clockwise",
			section = sceneSettings,
			position = 11
	)
	default Keybind quickRotateCWHotkey()
	{
		return new Keybind(KeyEvent.VK_DELETE, 0);
	}

	@ConfigItem(
			keyName = "quickRotateCCW",
			name = "Rotate CCW Hotkey",
			description = "Hotkey to rotate the selected object counter-clockwise",
			section = sceneSettings,
			position = 12
	)
	default Keybind quickRotateCCWHotkey()
	{
		return new Keybind(KeyEvent.VK_END, 0);
	}

	@ConfigItem(
			keyName = "rotateDegrees",
			name = "Rotate Degrees",
			description = "Determines how much the Rotate Hotkeys rotate the Object by",
			section = sceneSettings,
			position = 13
	)
	default Rotation rotateDegrees()
	{
		return Rotation._90_DEGREES;
	}

	@ConfigSection(
			name = "Overlays",
			description = "Settings for enabling/disabling overlays",
			position = 1
	)
	String overlaySettings = "overlaySettings";

	@ConfigItem(
			keyName = "toggleOverlays",
			name = "Toggle Overlays",
			description = "Hotkey to toggle all overlays. Unset to disable",
			section = overlaySettings,
			position = 0
	)
	default Keybind toggleOverlaysHotkey()
	{
		return new Keybind(KeyEvent.VK_PAGE_DOWN, 0);
	}

	@ConfigItem(
			keyName = "myObjectOverlay",
			name = "My Object Overlay",
			description = "Enables an overlay for objects introduced via this plugin",
			section = overlaySettings,
			position = 1
	)
	default boolean myObjectOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "pathOverlay",
			name = "Object Path Overlay",
			description = "Enables an overlay for the pathing of programmed objects introduced via this plugin",
			section = overlaySettings,
			position = 2
	)
	default boolean pathOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "gameObjectOverlay",
			name = "Game Object Overlay",
			description = "Enables an overlay for GameObjects",
			section = overlaySettings,
			position = 3
	)
	default boolean gameObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "playerOverlay",
			name = "Player Overlay",
			description = "Enables an overlay for Players",
			section = overlaySettings,
			position = 4
	)
	default boolean playerOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "npcOverlay",
			name = "NPC Overlay",
			description = "Enables an overlay for NPCs",
			section = overlaySettings,
			position = 5
	)
	default boolean npcOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "groundObjectOverlay",
			name = "Ground Object Overlay",
			description = "Enables an overlay for GroundObjects",
			section = overlaySettings,
			position = 6
	)
	default boolean groundObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "wallObjectOverlay",
			name = "Wall Object Overlay",
			description = "Enables an overlay for TileObjects",
			section = overlaySettings,
			position = 7
	)
	default boolean wallObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "decorativeObjectOverlay",
			name = "Decorative Object Overlay",
			description = "Enables an overlay for DecorativeObjects",
			section = overlaySettings,
			position = 8
	)
	default boolean decorativeObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "projectileOverlay",
			name = "Projectile Overlay",
			description = "Enables an overlay for Projectiles",
			section = overlaySettings,
			position = 9
	)
	default boolean projectileOverlay()
	{
		return false;
	}

	@ConfigSection(
			name = "Programmer",
			description = "Settings for quickly programming the selected object",
			position = 2
	)
	String programmer = "programmer";

	@ConfigItem(
			keyName = "addStep",
			name = "Add Program Step",
			description = "Hotkey to add the hovered location to the selected object's program",
			section = programmer,
			position = 0
	)
	default Keybind addProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_A, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "removeStep",
			name = "Remove Program Step",
			description = "Hotkey to remove the hovered location from the selected object's program",
			section = programmer,
			position = 1
	)
	default Keybind removeProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "clearSteps",
			name = "Clear Program Steps",
			description = "Hotkey to clear all steps from the selected object's program",
			section = programmer,
			position = 2
	)
	default Keybind clearProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_C, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "playPauseToggle",
			name = "Play/Pause Toggle",
			description = "Hotkey to play/pause selected object",
			section = programmer,
			position = 3
	)
	default Keybind playPauseHotkey()
	{
		return new Keybind(KeyEvent.VK_SPACE, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "playPauseAllToggle",
			name = "Play/Pause All",
			description = "Hotkey to play/pause all programs",
			section = programmer,
			position = 4
	)
	default Keybind playPauseAllHotkey()
	{
		return new Keybind(KeyEvent.VK_END, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "resetLocations",
			name = "Reset Locations",
			description = "Hotkey to set selected object to its start location",
			section = programmer,
			position = 5
	)
	default Keybind resetHotkey()
	{
		return new Keybind(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "resetAllLocations",
			name = "Reset All Locations",
			description = "Hotkey to set all objects to their start location",
			section = programmer,
			position = 6
	)
	default Keybind resetAllHotkey()
	{
		return new Keybind(KeyEvent.VK_HOME, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigSection(
			name = "Transmogrification",
			description = "Settings for replacing your player character with a saved Custom Model",
			position = 3
	)
	String transmogrification = "Transmogrification";

	@ConfigItem(
			keyName = "enableTransmog",
			name = "Enable Transmogrification",
			description = "Allow your character to be transmogrified into a chosen Custom Model",
			section = transmogrification,
			position = 0
	)
	default boolean enableTransmog()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableAutoTransmog",
			name = "Enable Auto-Transmog",
			description = "Automatically loads the Transmog from the file path below" +
					"<br>Please note that enabling this feature will slow down client start-up",
			section = transmogrification,
			position = 1
	)
	default boolean autoTransmog()
	{
		return false;
	}

	@ConfigItem(
			keyName = "transmogPath",
			name = "Auto-Transmog Path",
			description = "Enter the file path of a previously saved Transmog to automatically load on client start-up",
			section = transmogrification,
			position = 2
	)
	default String transmogPath()
	{
		return "";
	}

	@ConfigSection(
			name = "Oculus Orb",
			description = "Settings for enabling and modifying Oculus Orb mode",
			position = 4
	)
	String cameraSettings = "cameraSettings";

	@ConfigItem(
			keyName = "orbToggle",
			name = "Toggle Oculus Orb Mode",
			description = "Hotkey to toggle Oculus Orb mode",
			section = cameraSettings,
			position = 0
	)
	default Keybind toggleOrbHotkey()
	{
		return new Keybind(KeyEvent.VK_PAGE_UP, 0);
	}

	@ConfigItem(
			keyName = "orbSpeed",
			name = "Default Orb Speed",
			description = "Set the default normal speed of the Oculus Orb when the client starts",
			section = cameraSettings,
			position = 1
	)
	default int orbSpeed()
	{
		return 36;
	}

	@ConfigItem(
			keyName = "setOrbSpeed",
			name = "Set Orb Speed",
			description = "Hotkey to quickly set Oculus Orb speed",
			section = cameraSettings,
			position = 2
	)
	default Keybind setOrbSpeedHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbPreset1",
			name = "Orb Speed Hotkey 1",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 1",
			section = cameraSettings,
			position = 3
	)
	default Keybind orbSpeedHotkey1()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbPreset2",
			name = "Orb Speed Hotkey 2",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 2",
			section = cameraSettings,
			position = 4
	)
	default Keybind orbSpeedHotkey2()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbPreset3",
			name = "Orb Speed Hotkey 3",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 3",
			section = cameraSettings,
			position = 5
	)
	default Keybind orbSpeedHotkey3()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbSpeed1",
			name = "Orb Speed Preset 1",
			description = "Set the Orb Speed for Hotkey 1",
			section = cameraSettings,
			position = 6
	)
	default int speedHotkey1()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "orbSpeed2",
			name = "Orb Speed Preset 2",
			description = "Set the Orb Speed for Hotkey 2",
			section = cameraSettings,
			position = 7
	)
	default int speedHotkey2()
	{
		return 9;
	}

	@ConfigItem(
			keyName = "orbSpeed3",
			name = "Orb Speed Preset 3",
			description = "Set the Orb Speed for Hotkey 3",
			section = cameraSettings,
			position = 8
	)
	default int speedHotkey3()
	{
		return 36;
	}

	@ConfigItem(
			keyName = "rotateLeft",
			name = "AutoRotate Left",
			description = "Hotkey to toggle automatic camera rotation to the left",
			section = cameraSettings,
			position = 9
	)
	default Keybind rotateLeftHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateRight",
			name = "AutoRotate Right",
			description = "Hotkey to toggle automatic camera rotation to the right",
			section = cameraSettings,
			position = 10
	)
	default Keybind rotateRightHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateUp",
			name = "AutoRotate Up",
			description = "Hotkey to toggle automatic camera rotation up",
			section = cameraSettings,
			position = 11
	)
	default Keybind rotateUpHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateDown",
			name = "AutoRotate Down",
			description = "Hotkey to toggle automatic camera rotation down",
			section = cameraSettings,
			position = 12
	)
	default Keybind rotateDownHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateHorizontalSpeed",
			name = "Rotate Horizontal Speed",
			description = "Set the horizontal automatic camera rotation speed",
			section = cameraSettings,
			position = 13
	)
	default int rotateHorizontalSpeed()
	{
		return 3;
	}

	@ConfigItem(
			keyName = "rotateVerticalSpeed",
			name = "Rotate Vertical Speed",
			description = "Set the vertical automatic camera rotation speed",
			section = cameraSettings,
			position = 14
	)
	default int rotateVerticalSpeed()
	{
		return 3;
	}

	@ConfigSection(
			name = "Model Exporter",
			description = "Settings for changing how Models are Exported to 3D model formats",
			position = 5
	)
	String modelExporter = "modelExporter";

	@ConfigItem(
			keyName = "exportFileFormat",
			name = "Export File Format",
			description = "Pick the file format for exported Models" +
					"<br>Blender json files are intended to be used with the associated Runescape Import addon" +
					"<br>See ScreteMonge for more details",
			section = modelExporter,
			position = 0
	)
	default ExportFileFormat exportFileFormat()
	{
		return ExportFileFormat.BLENDER;
	}

	@ConfigItem(
			keyName = "vertexColours",
			name = "Vertex Colours",
			description = "Makes Blender Model .json files export with Vertex Colours instead of Face Colours",
			section = modelExporter,
			position = 1
	)
	default boolean vertexColours()
	{
		return false;
	}

	@ConfigItem(
			keyName = "exportTPose",
			name = "Export Neutral Pose",
			description = "Puts the Model into its neutral pose (disables animations) for exporting",
			section = modelExporter,
			position = 2
	)
	default boolean exportTPose()
	{
		return false;
	}
}

package com.creatorskit;

import com.creatorskit.models.CustomModel;
import com.creatorskit.programming.Program;
import com.creatorskit.swing.ObjectPanel;
import com.creatorskit.swing.ParentPanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.ArrayUtils;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;

@Getter
@Setter
@AllArgsConstructor
public class Character
{
    private String name;
    private boolean active;
    private boolean locationSet;
    private KeyFrame[][] frames;
    private DefaultMutableTreeNode linkedManagerNode;
    private DefaultMutableTreeNode parentManagerNode;
    private Program program;
    private WorldPoint nonInstancedPoint;
    private LocalPoint instancedPoint;
    private int[] instancedRegions;
    private int instancedPlane;
    private boolean inInstance;
    private CustomModel storedModel;
    private ParentPanel parentPanel;
    private ObjectPanel objectPanel;
    private boolean customMode;
    private JTextField nameField;
    private JComboBox<CustomModel> comboBox;
    private JButton spawnButton;
    private JButton modelButton;
    private JSpinner modelSpinner;
    private JSpinner animationSpinner;
    private JSpinner animationFrameSpinner;
    private JSpinner orientationSpinner;
    private JSpinner radiusSpinner;
    private JLabel programmerLabel;
    private JSpinner programmerIdleSpinner;
    private CKObject CKObject;
    private int targetOrientation;

    @Override
    public String toString()
    {
        return name;
    }

    public KeyFrame[] getKeyFrames(KeyFrameType type)
    {
        return frames[KeyFrameType.getIndex(type)];
    }

    public void setKeyFrames(KeyFrame[] keyFrames, KeyFrameType type)
    {
        frames[KeyFrameType.getIndex(type)] = keyFrames;
    }

    /**
     * find a keyframe of the given type at the given tick
     * @param type the type of keyframe to look for
     * @param tick the tick at which the requested keyframe should exist
     * @return the keyframe, if one is found; otherwise, returns null
     */
    public KeyFrame findKeyFrame(KeyFrameType type, double tick)
    {
        KeyFrame[] frames = getKeyFrames(type);
        if (frames == null)
        {
            return null;
        }

        for (KeyFrame keyFrame : frames)
        {
            if (keyFrame.getTick() == tick)
            {
                return keyFrame;
            }
        }

        return null;
    }

    public KeyFrame findFirstKeyFrame()
    {
        KeyFrame firstFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            for (KeyFrame keyFrame : keyFrames)
            {
                if (firstFrame == null)
                {
                    firstFrame = keyFrame;
                }

                if (keyFrame.getTick() < firstFrame.getTick())
                {
                    firstFrame = keyFrame;
                }
            }
        }

        return firstFrame;
    }

    public KeyFrame findLastKeyFrame()
    {
        KeyFrame lastFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            for (KeyFrame keyFrame : keyFrames)
            {
                if (lastFrame == null)
                {
                    lastFrame = keyFrame;
                }

                if (keyFrame.getTick() > lastFrame.getTick())
                {
                    lastFrame = keyFrame;
                }
            }
        }

        return lastFrame;
    }

    /**
     * Finds the next keyframe for this character of any given KeyFrameType, excluding any keyframes on the current tick
     * @param tick the tick at which to start searching
     * @return the next keyframe
     */
    public KeyFrame findNextKeyFrame(double tick)
    {
        KeyFrame nextFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            if (keyFrames.length == 0)
            {
                continue;
            }

            for (int i = keyFrames.length - 1; i >= 0; i--)
            {
                KeyFrame keyFrame = keyFrames[i];

                if (nextFrame == null)
                {
                    nextFrame = keyFrame;
                    continue;
                }

                if (nextFrame.getTick() <= tick)
                {
                    nextFrame = keyFrame;
                    continue;
                }

                double test = keyFrame.getTick();
                if (test <= tick)
                {
                    continue;
                }

                if (test < nextFrame.getTick())
                {
                    nextFrame = keyFrame;
                }
            }
        }

        if (nextFrame == null)
        {
            return null;
        }

        if (nextFrame.getTick() < tick)
        {
            return null;
        }

        return nextFrame;
    }

    public KeyFrame findNextKeyFrame(KeyFrameType type, double tick)
    {
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return null;
        }

        if (keyFrames.length == 0)
        {
            return null;
        }

        for (int i = 0; i < keyFrames.length; i++)
        {
            KeyFrame keyFrame = keyFrames[i];
            if (keyFrame.getTick() > tick)
            {
                return keyFrames[i];
            }
        }

        return null;
    }

    /**
     * Finds the previous keyframe for this character of any given KeyFrameType, excluding any keyframes on the current tick
     * @param tick the tick at which to start searching
     * @return the previous keyframe
     */
    public KeyFrame findPreviousKeyFrame(double tick)
    {
        KeyFrame nextFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            if (keyFrames.length == 0)
            {
                continue;
            }

            for (int i = 0; i < keyFrames.length; i++)
            {
                KeyFrame keyFrame = keyFrames[i];

                double test = keyFrame.getTick();
                if (test >= tick)
                {
                    continue;
                }

                if (nextFrame == null)
                {
                    nextFrame = keyFrame;
                }

                if (test > nextFrame.getTick())
                {
                    nextFrame = keyFrame;
                }
            }
        }

        if (nextFrame == null)
        {
            return null;
        }

        if (nextFrame.getTick() > tick)
        {
            return null;
        }

        return nextFrame;
    }

    /**
     * Finds the last KeyFrame of the given type relative to the current time
     * @param type the type of KeyFrame to search for
     * @param tick the current time indicator
     * @param includeCurrentKeyFrame whether to include the keyframe at the current time (if any), or to skip and find the keyframe before
     * @return the last keyframe relative to the current time indicator
     */
    public KeyFrame findPreviousKeyFrame(KeyFrameType type, double tick, boolean includeCurrentKeyFrame)
    {
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return null;
        }

        if (keyFrames.length == 0)
        {
            return null;
        }

        for (int i = 0; i < keyFrames.length; i++)
        {
            KeyFrame keyFrame = keyFrames[i];

            if (!includeCurrentKeyFrame && keyFrame.getTick() == tick)
            {
                if (i == 0)
                {
                    return null;
                }

                return keyFrames[i - 1];
            }

            if (keyFrame.getTick() > tick)
            {
                if (i == 0)
                {
                    return null;
                }

                return keyFrames[i - 1];
            }
        }

        return keyFrames[keyFrames.length - 1];
    }

    /**
     * Adds the keyframe to a specific character, or replaces a keyframe if the tick matches exactly
     * @param keyFrame the keyframe to add or modify for the character
     */
    public void addKeyFrame(KeyFrame keyFrame)
    {
        KeyFrameType type = keyFrame.getKeyFrameType();
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            keyFrames = new KeyFrame[]{keyFrame};
            setKeyFrames(keyFrames, type);
            return;
        }

        int[] framePosition = getFramePosition(keyFrames, keyFrame.getTick());

        // Check first if the new keyframe is replacing a previous one
        if (framePosition[1] == 1)
        {
            keyFrames[framePosition[0]] = keyFrame;
        }
        else
        {
            keyFrames = ArrayUtils.insert(framePosition[0], keyFrames, keyFrame);
        }

        setKeyFrames(keyFrames, type);
    }

    /**
     * Removes the indicated keyframe from the character
     * @param keyFrame the keyframe to remove
     */
    public void removeKeyFrame(KeyFrame keyFrame)
    {
        KeyFrameType type = keyFrame.getKeyFrameType();
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return;
        }

        keyFrames = ArrayUtils.removeElement(keyFrames, keyFrame);
        setKeyFrames(keyFrames, type);
    }

    /**
     * Removes a keyframe from the character (if it exists) of the chosen type, at the chosen tick
     * @param type the KeyFrameType to remove
     * @param tick the tick at which to find the keyframe
     */
    public void removeKeyFrame(KeyFrameType type, double tick)
    {
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return;
        }

        for (int i = 0; i < keyFrames.length; i++)
        {
            KeyFrame keyFrame = keyFrames[i];
            if (keyFrame.getTick() == tick)
            {
                removeKeyFrame(keyFrame);
                return;
            }
        }
    }

    /**
     * Gets the new position of the keyframe to add as an int[] of {index, boolean}
     * @param keyFrames the keyframe array to add to
     * @param newTick the tick of the new keyframe to be added
     * @return an int[] of {index, boolean}. The boolean determines whether the new keyframe will replace a previously existing keyframe of the exact same tick
     */
    private int[] getFramePosition(KeyFrame[] keyFrames, double newTick)
    {
        if (keyFrames == null)
        {
            return new int[]{0, 0};
        }

        int frameIndex = 0;
        for (int i = 0; i < keyFrames.length; i++)
        {
            if (keyFrames[i].getTick() == newTick)
            {
                return new int[]{i, 1};
            }

            if (keyFrames[i].getTick() > newTick)
            {
                if (i == 0)
                {
                    return new int[]{0, 0};
                }

                return new int[]{i, 0};
            }

            frameIndex++;
        }

        return new int[]{frameIndex, 0};
    }
}

package com.creatorskit;

import com.creatorskit.programming.Coordinate;
import com.creatorskit.programming.Program;
import com.creatorskit.programming.ProgramComp;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;

public class CreatorsOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    private static final Color HOVERED_COLOUR = new Color(146, 206, 193, 255);
    private static final Color SELECTED_COLOUR = new Color(220, 253, 245);
    private static final Color MY_OBJECT_COLOUR = new Color(35, 208, 187);
    private static final Color GAME_OBJECT_COLOUR = new Color(255, 138, 18);
    private static final Color DYNAMIC_OBJECT_COLOUR = new Color(255, 190, 130);
    private static final Color GROUND_OBJECT_COLOUR = new Color(73, 255, 0);
    private static final Color WALL_OBJECT_COLOUR = new Color(255, 70, 70);
    private static final Color DECORATIVE_OBJECT_COLOUR = new Color(183, 126, 255);
    private static final Color PROJECTILE_COLOUR = new Color(255, 222, 2);
    private static final Color NPC_COLOUR = new Color(188, 198, 255);
    private static final Color PLAYER_COLOUR = new Color(221, 133, 255);
    private static final int MAX_DISTANCE = 2400;

    @Inject
    private CreatorsOverlay(Client client, CreatorsPlugin plugin, CreatorsConfig config)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        WorldView worldView = client.getTopLevelWorldView();
        Scene scene = worldView.getScene();

        boolean keyHeld = config.enableCtrlHotkeys() && client.isKeyPressed(KeyCode.KC_CONTROL);
        if (keyHeld)
        {
            renderSelectedRLObject(graphics);
        }

        if (!plugin.isOverlaysActive())
        {
            return null;
        }

        renderRLObjects(graphics, keyHeld);

        renderObjectsOverlay(graphics, worldView);

        if (config.pathOverlay())
        {
            if (scene.isInstance())
            {
                renderInstancedProgramOverlay(graphics, worldView);
            }
            else
            {
                renderNonInstancedProgramOverlay(graphics, worldView);
            }
        }

        if (config.npcOverlay())
            renderNPCOverlay(graphics, worldView);

        if (config.playerOverlay())
            renderPlayerOverlay(graphics, worldView);

        if (config.projectileOverlay())
            renderProjectiles(graphics, worldView);

        return null;
    }

    public void renderNonInstancedProgramOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (int e = 0; e < plugin.getCharacters().size(); e++)
        {
            Character character = plugin.getCharacters().get(e);
            if (!plugin.isInScene(character))
                continue;

            Program program = character.getProgram();
            if (program == null)
                continue;

            ProgramComp comp = program.getComp();

            Coordinate[] coordinates = comp.getCoordinates();
            for (int i = 0; i < coordinates.length - 1; i++)
            {
                if (coordinates[i] == null)
                    continue;

                if (!comp.isPathFound())
                    continue;

                LocalPoint lpStart = LocalPoint.fromScene(coordinates[i].getColumn(), coordinates[i].getRow(), worldView.getScene());
                LocalPoint lpEnd = LocalPoint.fromScene(coordinates[i + 1].getColumn(), coordinates[i + 1].getRow(), worldView.getScene());
                Point startPoint = Perspective.localToCanvas(client, lpStart, worldView.getPlane());
                Point endPoint = Perspective.localToCanvas(client, lpEnd, worldView.getPlane());
                if (startPoint == null || endPoint == null)
                    continue;

                graphics.setColor(program.getColor());
                graphics.setStroke(new BasicStroke(1));
                graphics.drawLine(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
            }

            WorldPoint[] points = comp.getStepsWP();
            String name = character.getName();
            String abbreviation = "";
            int abbreviationLength = 3;
            int nameLength = name.length();

            if (abbreviationLength > nameLength)
            {
                abbreviation = character.getName().substring(0, nameLength);
            }
            else
            {
                abbreviation = character.getName().substring(0, 3);
            }

            for (int i = 0; i < points.length; i++)
            {
                LocalPoint localPoint = LocalPoint.fromWorld(worldView, points[i]);
                if (localPoint == null)
                    continue;

                Point textPoint = Perspective.getCanvasTextLocation(client, graphics, localPoint, abbreviation, 0);
                if (textPoint == null)
                    continue;

                OverlayUtil.renderTextLocation(graphics, textPoint, abbreviation, program.getColor());
            }
        }
    }

    public void renderInstancedProgramOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (int e = 0; e < plugin.getCharacters().size(); e++)
        {
            Character character = plugin.getCharacters().get(e);
            if (!plugin.isInScene(character))
                continue;

            LocalPoint savedLocation = character.getInstancedPoint();
            if (savedLocation == null || !savedLocation.isInScene())
                continue;

            Program program = character.getProgram();
            if (program == null)
                continue;

            ProgramComp comp = program.getComp();

            Coordinate[] coordinates = comp.getCoordinates();
            for (int i = 0; i < coordinates.length - 1; i++)
            {
                if (coordinates[i] == null)
                    continue;

                if (!comp.isPathFound())
                    continue;

                LocalPoint lpStart = LocalPoint.fromScene(coordinates[i].getColumn(), coordinates[i].getRow(), worldView.getScene());
                LocalPoint lpEnd = LocalPoint.fromScene(coordinates[i + 1].getColumn(), coordinates[i + 1].getRow(), worldView.getScene());
                Point startPoint = Perspective.localToCanvas(client, lpStart, worldView.getPlane());
                Point endPoint = Perspective.localToCanvas(client, lpEnd, worldView.getPlane());
                if (startPoint == null || endPoint == null)
                    continue;

                graphics.setColor(program.getColor());
                graphics.setStroke(new BasicStroke(1));
                graphics.drawLine(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
            }

            LocalPoint[] points = comp.getStepsLP();
            String name = character.getName();
            String abbreviation = "";
            int abbreviationLength = 3;
            int nameLength = name.length();

            if (abbreviationLength > nameLength)
            {
                abbreviation = character.getName().substring(0, nameLength - 1);
            }
            else
            {
                abbreviation = character.getName().substring(0, 3);
            }

            for (int i = 0; i < points.length; i++)
            {
                LocalPoint localPoint = points[i];
                if (localPoint == null)
                    continue;

                Point textPoint = Perspective.getCanvasTextLocation(client, graphics, localPoint, abbreviation, 0);
                if (textPoint == null)
                    continue;

                OverlayUtil.renderTextLocation(graphics, textPoint, abbreviation, program.getColor());
            }
        }
    }

    public void renderPlayerOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (Player player : worldView.players())
        {
            LocalPoint localPoint = player.getLocalLocation();
            if (localPoint == null)
                continue;

            StringBuilder spotAnims = new StringBuilder();
            for (ActorSpotAnim spotAnim : player.getSpotAnims())
            {
                spotAnims.append(", G: ");
                spotAnims.append(spotAnim.getId());
            }

            OverlayUtil.renderActorOverlay(graphics, player, "A: " + player.getAnimation() + ", P: " + player.getPoseAnimation() + spotAnims, PLAYER_COLOUR);
        }
    }

    public void renderNPCOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (NPC npc : worldView.npcs())
        {
            LocalPoint localPoint = npc.getLocalLocation();
            if (localPoint == null)
                continue;

            StringBuilder spotAnims = new StringBuilder();
            for (ActorSpotAnim spotAnim : npc.getSpotAnims())
            {
                spotAnims.append(", G: ");
                spotAnims.append(spotAnim.getId());
            }

            OverlayUtil.renderActorOverlay(graphics, npc, "ID: " + npc.getId() + ", A: " + npc.getAnimation() + ", P: " + npc.getPoseAnimation() + spotAnims, NPC_COLOUR);
        }
    }

    public void renderObjectsOverlay(Graphics2D graphics, WorldView worldView)
    {
        Scene scene = worldView.getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = worldView.getPlane();

        for (int x = 0; x < Constants.SCENE_SIZE; x++)
        {
            for (int y = 0; y < Constants.SCENE_SIZE; y++)
            {
                Tile tile = tiles[z][x][y];

                if (tile == null)
                {
                    continue;
                }

                Player player = client.getLocalPlayer();
                if (player == null)
                {
                    continue;
                }

                if (config.gameObjectOverlay() || config.myObjectOverlay())
                {
                    renderGameObjects(graphics, tile, worldView);
                }

                if (config.groundObjectOverlay())
                {
                    renderGroundObjects(graphics, tile, worldView);
                }

                if (config.wallObjectOverlay())
                {
                    renderWallObjects(graphics, tile, worldView);
                }

                if (config.decorativeObjectOverlay())
                {
                    renderDecorativeObjects(graphics, tile, worldView);
                }
            }
        }
    }

    public void renderSelectedRLObject(Graphics2D graphics)
    {
        Character character = plugin.getSelectedCharacter();
        if (character == null)
        {
            return;
        }

        CKObject CKObject = character.getCKObject();
        if (CKObject == null)
        {
            return;
        }

        LocalPoint lp = CKObject.getLocation();
        if (lp == null || !plugin.isInScene(character))
        {
            return;
        }

        Point p = Perspective.getCanvasTextLocation(client, graphics, lp, character.getName(), 0);
        if (p != null)
        {
            OverlayUtil.renderTextLocation(graphics, p, character.getName(), SELECTED_COLOUR);
        }
    }

    public void renderRLObjects(Graphics2D graphics, boolean keyHeld)
    {
        for (int i = 0; i < plugin.getCharacters().size(); i++)
        {
            Character character = plugin.getCharacters().get(i);
            if (!plugin.isInScene(character) || !character.isActive())
            {
                continue;
            }

            CKObject CKObject = character.getCKObject();
            if (CKObject == null)
            {
                continue;
            }

            LocalPoint lp = CKObject.getLocation();
            if (lp == null)
            {
                continue;
            }

            String name = character.getName();
            Point point = Perspective.getCanvasTextLocation(client, graphics, lp, name, 0);

            if (plugin.getSelectedCharacter() == character)
            {
                if (keyHeld)
                {
                    continue;
                }

                OverlayUtil.renderTextLocation(graphics, point, name, SELECTED_COLOUR);
                continue;
            }

            if (!config.myObjectOverlay())
            {
                continue;
            }

            if (plugin.getHoveredCharacter() == character)
            {
                OverlayUtil.renderTextLocation(graphics, point, name, HOVERED_COLOUR);
                continue;
            }

            OverlayUtil.renderTextLocation(graphics, point, name, MY_OBJECT_COLOUR);
        }
    }

    public void renderGameObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        if (gameObjects != null)
        {
            for (GameObject gameObject : gameObjects)
            {
                if (gameObject != null && gameObject.getSceneMinLocation().equals(tile.getSceneLocation()))
                {
                    if (gameObject.getRenderable() instanceof Actor)
                    {
                        continue;
                    }

                    StringBuilder stringBuilder = new StringBuilder();

                    if (gameObject.getRenderable() instanceof RuneLiteObject)
                    {
                        continue;
                    }

                    LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
                    if (gameObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
                    {
                        if (!config.gameObjectOverlay())
                        {
                            continue;
                        }

                        stringBuilder.append("ID: ").append(gameObject.getId());
                        Color color = GAME_OBJECT_COLOUR;
                        if (gameObject.getRenderable() instanceof DynamicObject)
                        {
                            Animation animation = ((DynamicObject) gameObject.getRenderable()).getAnimation();
                            if (animation != null)
                            {
                                stringBuilder.append(" A: ").append(animation.getId());
                            }
                            else
                            {
                                stringBuilder.append(" A: -1");
                            }

                            color = DYNAMIC_OBJECT_COLOUR;
                        }
                        else
                        {
                            stringBuilder.append(" A: -1");
                        }

                        OverlayUtil.renderTileOverlay(graphics, gameObject, stringBuilder.toString(), color);
                    }
                }
            }
        }
    }

    public void renderGroundObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        GroundObject groundObject = tile.getGroundObject();
        if (groundObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (groundObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, groundObject, "ID: " + groundObject.getId(), GROUND_OBJECT_COLOUR);
            }
        }
    }

    public void renderWallObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        TileObject tileObject = tile.getWallObject();
        if (tileObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (tileObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, tileObject, "ID: " + tileObject.getId(), WALL_OBJECT_COLOUR);
            }
        }
    }

    public void renderDecorativeObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        TileObject tileObject = tile.getDecorativeObject();
        if (tileObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (tileObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, tileObject, "ID: " + tileObject.getId(), DECORATIVE_OBJECT_COLOUR);
            }
        }
    }

    private void renderProjectiles(Graphics2D graphics, WorldView worldView)
    {
        for (Projectile projectile : worldView.getProjectiles())
        {
            int projectileId = projectile.getId();
            String text = "ID: " + projectileId;
            int x = (int) projectile.getX();
            int y = (int) projectile.getY();
            LocalPoint projectilePoint = new LocalPoint(x, y, worldView);
            Point textLocation = Perspective.getCanvasTextLocation(client, graphics, projectilePoint, text, 0);
            if (textLocation != null)
            {
                OverlayUtil.renderTextLocation(graphics, textLocation, text, PROJECTILE_COLOUR);
            }
        }
    }
}

package com.creatorskit;

import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;

import javax.annotation.Nullable;

@Getter
@Setter
@RequiredArgsConstructor
public class CKObject extends RuneLiteObjectController
{
    private final Client client;
    private Model baseModel;
    private boolean pause;

    @Nullable
    private AnimationController animationController;

    @Nullable
    private AnimationController poseAnimationController;

    private int startCycle;

    public void setModel(Model baseModel)
    {
        this.baseModel = baseModel;
    }

    @Override
    public void setLocation(LocalPoint point, int level)
    {
        boolean needReregister = isActive() && point.getWorldView() != getWorldView();
        if (needReregister)
        {
            setActive(false);
        }

        super.setLocation(point, level);
        setZ(Perspective.getTileHeight(client, point, level));

        if (needReregister)
        {
            setActive(true);
        }
    }

    public void setAnimationController(@Nullable AnimationController animationController)
    {
        this.animationController = animationController;
    }

    public void setActive(boolean active)
    {
        if (active)
        {
            client.registerRuneLiteObject(this);
        }
        else
        {
            client.removeRuneLiteObject(this);
        }
    }

    public boolean isActive()
    {
        return client.isRuneLiteObjectRegistered(this);
    }

    @Override
    public void tick(int ticksSinceLastFrame)
    {
        if (pause)
        {
            return;
        }

        if (animationController != null)
        {
            animationController.tick(ticksSinceLastFrame);
        }
    }

    @Override
    public Model getModel()
    {
        if (animationController != null)
        {
            return animationController.animate(this.baseModel, this.poseAnimationController);
        }
        else if (poseAnimationController != null)
        {
            return poseAnimationController.animate(this.baseModel);
        }
        else
        {
            return baseModel;
        }
    }

    public void setAnimation(int animId)
    {
        if (animationController == null)
        {
            animationController = new AnimationController(client, animId);
            return;
        }

        animationController.setAnimation(client.loadAnimation(animId));
    }

    public void setAnimationFrame(int animFrame, boolean allowPause)
    {
        if (animationController == null)
        {
            return;
        }

        Animation animation = animationController.getAnimation();
        if (animation == null)
        {
            return;
        }

        if (animFrame >= animation.getDuration())
        {
            animFrame = animation.getDuration() - 1;
        }

        if (allowPause)
        {
            if (animFrame == -1)
            {
                pause = false;
                animationController.setFrame(0);
                return;
            }

            pause = true;
            animationController.setFrame(animFrame);
            return;
        }

        pause = false;
        animationController.setFrame(animFrame);
    }

    public int getAnimationFrame()
    {
        if (animationController == null)
        {
            return 0;
        }

        Animation animation = animationController.getAnimation();
        if (animation == null)
        {
            return 0;
        }

        return animationController.getFrame();
    }

    public int getMaxAnimFrames()
    {
        if (animationController == null)
        {
            return 0;
        }

        Animation animation = animationController.getAnimation();
        if (animation == null)
        {
            return 0;
        }

        return animationController.getAnimation().getDuration();
    }

    public int getAnimationId()
    {
        if (animationController != null)
        {
            Animation animation = animationController.getAnimation();
            if (animation != null)
            {
                return animation.getId();
            }
        }

        if (poseAnimationController != null)
        {
            Animation animation = poseAnimationController.getAnimation();
            if (animation != null)
            {
                return animation.getId();
            }
        }

        return -1;
    }
}

package com.creatorskit;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CreatorsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CreatorsPlugin.class);
		RuneLite.main(args);
	}
}
