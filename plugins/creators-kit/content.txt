package com.creatorskit;

public enum ActiveOption
{
    ACTIVE,
    INACTIVE,
    UNCHANGED
}

package com.creatorskit.swing;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.models.ModelImporter;
import com.creatorskit.models.*;
import com.creatorskit.models.exporters.ModelExporter;
import com.creatorskit.programming.AnimationType;
import com.creatorskit.swing.timesheet.keyframe.ModelKeyFrame;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.filechooser.FileFilter;
import java.awt.*;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

@Slf4j
public class ModelOrganizer extends JPanel
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    private final ClientThread clientThread;
    private final ModelImporter modelImporter;
    private final ModelExporter modelExporter;
    private final BufferedImage CLEAR = ImageUtil.loadImageResource(getClass(), "/Clear.png");
    private final BufferedImage ANVIL = ImageUtil.loadImageResource(getClass(), "/Anvil.png");
    private final BufferedImage SAVE = ImageUtil.loadImageResource(getClass(), "/Save.png");
    private final BufferedImage TRANSMOG = ImageUtil.loadImageResource(getClass(), "/Transmog.png");
    private final BufferedImage EXPORT = ImageUtil.loadImageResource(getClass(), "/Export.png");
    private final Dimension buttonDimension = new Dimension(30, 25);
    private final HashMap<CustomModel, JPanel> panelMap = new HashMap<>();
    private final JPanel modelPanel = new JPanel();
    private final GridBagConstraints c = new GridBagConstraints();
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");

    @Inject
    public ModelOrganizer(Client client, CreatorsPlugin plugin, CreatorsConfig config, ClientThread clientThread, ModelImporter modelImporter, ModelExporter modelExporter)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
        this.clientThread = clientThread;
        this.modelImporter = modelImporter;
        this.modelExporter = modelExporter;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        JScrollPane scrollPane = new JScrollPane();
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new GridBagLayout());
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(headerPanel);
        add(scrollPane);

        JPanel viewport = new JPanel();
        viewport.setBorder(new EmptyBorder(6, 4, 6, 4));
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.setLayout(new GridBagLayout());
        scrollPane.setViewportView(viewport);

        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        modelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        modelPanel.setLayout(new GridLayout(0, 8, 8, 8));
        viewport.add(modelPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);
        c.weighty = 0;

        c.gridx = 0;
        c.gridy = 0;
        c.gridheight = 4;
        c.weightx = 10;
        JLabel organizerLabel = new JLabel("Model Organizer");
        organizerLabel.setHorizontalAlignment(SwingConstants.CENTER);
        organizerLabel.setFont(FontManager.getRunescapeBoldFont());
        headerPanel.add(organizerLabel, c);

        c.gridx = 2;
        c.gridy = 0;
        c.gridheight = 1;
        c.gridwidth = 2;
        c.weightx = 0.5;
        JButton loadCustomButton = new JButton("Load Saved Model");
        loadCustomButton.setToolTipText("Loads a previously forged and saved Custom Model");
        headerPanel.add(loadCustomButton, c);
        loadCustomButton.addActionListener(e -> openLoadDialog());

        c.gridx = 2;
        c.gridy = 1;
        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0.5;
        JButton loadBlenderButton = new JButton("Load Blender Model");
        loadBlenderButton.setToolTipText("Loads a model exported from Blender");
        headerPanel.add(loadBlenderButton, c);
        loadBlenderButton.addActionListener(e -> modelImporter.openLoadDialog());

        c.gridx = 3;
        c.gridy = 1;
        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0;
        JButton quickLoadBlenderButton = new JButton("Quick");
        quickLoadBlenderButton.setToolTipText("Loads the latest model exported from Blender in the " + RuneLite.RUNELITE_DIR + "\\creatorskit\\blender-models folder");
        headerPanel.add(quickLoadBlenderButton, c);
        quickLoadBlenderButton.addActionListener(e -> modelImporter.openLatestFile());

        c.gridx = 2;
        c.gridy = 2;
        c.gridheight = 2;
        c.gridwidth = 2;
        c.weightx = 0.5;
        JButton clearButton = new JButton("Clear Unused Models");
        clearButton.setToolTipText("Clears all unused models from Custom Model dropdown menus");
        headerPanel.add(clearButton, c);
        clearButton.addActionListener(e ->
        {
            ArrayList<CustomModel> unusedModels = new ArrayList<>();
            CustomModel transmogModel = plugin.getTransmogModel();
            ArrayList<Character> characters = plugin.getCharacters();

            for (int i = 0; i < plugin.getStoredModels().size(); i++)
            {
                CustomModel customModel = plugin.getStoredModels().get(i);

                if (customModel == transmogModel)
                    continue;

                boolean isBeingUsed = false;
                for (int x = 0; x < characters.size(); x++)
                {
                    Character character = characters.get(x);
                    if (character.getStoredModel() == customModel)
                    {
                        isBeingUsed = true;
                        break;
                    }

                    ModelKeyFrame[] modelKeyFrames = character.getModelKeyFrames();
                    if (modelKeyFrames == null || modelKeyFrames.length == 0)
                    {
                        continue;
                    }

                    for (int f = 0; f < modelKeyFrames.length; f++)
                    {
                        ModelKeyFrame keyFrame = modelKeyFrames[f];
                        if (keyFrame.isUseCustomModel() && keyFrame.getCustomModel() == customModel)
                        {
                            isBeingUsed = true;
                            break;
                        }
                    }

                    if (isBeingUsed)
                    {
                        break;
                    }
                }

                if (!isBeingUsed)
                    unusedModels.add(customModel);
            }

            for (CustomModel customModel : unusedModels)
                plugin.removeCustomModel(customModel);
        });

        revalidate();
    }

    public void createModelPanel(CustomModel model)
    {
        JPanel panel = new JPanel();
        panel.setLayout(new GridBagLayout());
        panel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        panel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        modelPanel.add(panel);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.weightx = 1;
        c.weighty = 0;
        c.gridwidth = 1;
        c.gridheight = 1;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridx = 0;
        c.gridy = 0;
        JTextField textField = new JTextField();
        textField.setText(model.getComp().getName());
        textField.setHorizontalAlignment(SwingConstants.CENTER);
        panel.add(textField, c);
        panelMap.put(model, panel);
        textField.addActionListener(e ->
        {
            String text = StringHandler.cleanString(textField.getText());
            textField.setText(text);
            model.getComp().setName(text);
            plugin.updatePanelComboBoxes();
            plugin.getCreatorsPanel().getTransmogPanel().getTransmogLabel().setText(text);
        });
        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                String text = StringHandler.cleanString(textField.getText());
                textField.setText(text);
                model.getComp().setName(text);
            }
        });

        c.gridx = 0;
        c.gridy = 1;
        JPanel buttonsPanel = new JPanel(new GridLayout(1, 0, 4, 4));
        panel.add(buttonsPanel, c);

        JButton deleteButton = new JButton(new ImageIcon(CLEAR));
        deleteButton.setPreferredSize(buttonDimension);
        deleteButton.setToolTipText("Remove this model from all Objects and dropdown menus");
        deleteButton.addActionListener(e -> plugin.removeCustomModel(model));
        buttonsPanel.add(deleteButton);

        JButton anvilButton = new JButton(new ImageIcon(ANVIL));
        anvilButton.setPreferredSize(buttonDimension);
        anvilButton.setToolTipText("Send this model to the Anvil");
        buttonsPanel.add(anvilButton);
        anvilButton.addActionListener(e -> plugin.customModelToAnvil(model));

        JButton saveButton = new JButton(new ImageIcon(SAVE));
        saveButton.setPreferredSize(buttonDimension);
        saveButton.setToolTipText("Save this model for future use");
        buttonsPanel.add(saveButton);
        saveButton.addActionListener(e -> openSaveDialog(model, textField.getText()));

        JButton transmogButton = new JButton(new ImageIcon(TRANSMOG));
        transmogButton.setPreferredSize(buttonDimension);
        transmogButton.setToolTipText("Set this as your player transmog");
        buttonsPanel.add(transmogButton);
        transmogButton.addActionListener(e -> setTransmog(model));

        JButton exportButton = new JButton(new ImageIcon(EXPORT));
        exportButton.setPreferredSize(buttonDimension);
        exportButton.setToolTipText("Export this model to a 3D format based on the Model Exporter settings in the config");
        buttonsPanel.add(exportButton);
        exportButton.addActionListener(e ->
        {
            clientThread.invokeLater(() ->
            {
                String name = model.getComp().getName();
                BlenderModel blenderModel = modelExporter.bmFromCustomModel(model);
                modelExporter.saveToFile(name, blenderModel);
            });
        });

        revalidate();
        repaint();
    }

    public void removeModelPanel(CustomModel model)
    {
        JPanel panel = panelMap.get(model);
        modelPanel.remove(panel);
        panelMap.remove(model);
        revalidate();
        repaint();
    }

    private void openLoadDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");
        fileChooser.setMultiSelectionEnabled(true);
        fileChooser.setFileFilter(new FileFilter()
        {
            @Override
            public String getDescription()
            {
                return "Json File (*.json)";
            }

            @Override
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }
                else
                {
                    String filename = f.getName().toLowerCase();
                    return filename.endsWith(".json");
                }
            }
        });

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File[] files = fileChooser.getSelectedFiles();
            for (File selectedFile : files)
            {
                String name = selectedFile.getName();
                if (name.endsWith(".json"))
                    name = replaceLast(name, ".json");

                if (!selectedFile.exists())
                {
                    selectedFile = new File(selectedFile.getPath() + ".json");
                    if (!selectedFile.exists())
                    {
                        plugin.sendChatMessage("Could not find the requested Custom Model file.");
                        continue;
                    }
                }

                plugin.loadCustomModel(selectedFile);
            }
        }
    }

    private String replaceLast(String string, String from)
    {
        int lastIndex = string.lastIndexOf(from);
        if (lastIndex < 0)
            return string;
        String tail = string.substring(lastIndex).replaceFirst(from, "");
        return string.substring(0, lastIndex) + tail;
    }

    private void openSaveDialog(CustomModel customModel, String name)
    {
        File outputDir = MODELS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save Custom Model");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile, customModel);
        }
    }

    public void saveToFile(File file, CustomModel customModel)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            CustomModelComp comp = customModel.getComp();
            DetailedModel[] detailedModels = comp.getDetailedModels();
            if (detailedModels == null)
            {
                detailedModels = modelToDetailedPanels(customModel);
                comp.setDetailedModels(detailedModels);
            }

            String string = plugin.getGson().toJson(comp);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving Custom Model to file");
        }
    }

    public DetailedModel[] modelToDetailedPanels(CustomModel customModel)
    {
        return modelToDetailedPanels(customModel.getComp());
    }

    public DetailedModel[] modelToDetailedPanels(CustomModelComp comp)
    {
        CustomModelType type = comp.getType();

        ModelStats[] modelStats = comp.getModelStats();
        DetailedModel[] detailedModels = new DetailedModel[modelStats.length];
        int group = 1;
        if (type == CustomModelType.CACHE_NPC)
            group = 8;

        if (type == CustomModelType.CACHE_PLAYER)
            group = 9;

        for (int i = 0; i < modelStats.length; i++)
        {
            ModelStats modelStat = modelStats[i];

            short[] colourFrom = modelStat.getRecolourFrom();
            short[] colourTo = modelStat.getRecolourTo();

            BodyPart bp = modelStat.getBodyPart();
            if (type == CustomModelType.CACHE_PLAYER && modelStat.getBodyPart() != BodyPart.NA)
            {
                colourFrom = ArrayUtils.addAll(colourFrom, KitRecolourer.getKitRecolourFrom(modelStat.getBodyPart()));
                colourTo = ArrayUtils.addAll(colourTo, KitRecolourer.getKitRecolourTo(modelStat.getBodyPart(), comp.getKitRecolours()));
            }

            String bodyPart = "Name";
            if (type == CustomModelType.CACHE_PLAYER)
                bodyPart = "Item";

            if (bp != BodyPart.NA)
                bodyPart = modelStat.getBodyPart().toString();

            DetailedModel detailedModel = new DetailedModel(
                    bodyPart,
                    modelStat.getModelId(),
                    group,
                    0, 0, 0,
                    0, 0, 0,
                    modelStat.getResizeX(),
                    modelStat.getResizeY(),
                    modelStat.getResizeZ(),
                    0,
                    "", "",
                    colourFrom, colourTo,
                    modelStat.getTextureFrom(), modelStat.getTextureTo(),
                    false);
            detailedModels[i] = detailedModel;
        }

        return detailedModels;
    }

    public void setTransmog(CustomModel customModel)
    {
        CKObject transmog = plugin.getTransmog();
        TransmogPanel transmogPanel = plugin.getCreatorsPanel().getTransmogPanel();

        if (transmog == null)
        {
            clientThread.invokeLater(() ->
            {
                CKObject newTransmog = new CKObject(client);
                client.registerRuneLiteObject(newTransmog);

                newTransmog.setLoop(false);
                newTransmog.setFreeze(false);
                newTransmog.setHasAnimKeyFrame(false);
                newTransmog.setActive(true);
                newTransmog.setModel(customModel.getModel());
                newTransmog.setRadius(transmogPanel.getRadius());
                newTransmog.setupAnimController(AnimationType.ACTIVE, 0);
                newTransmog.setupAnimController(AnimationType.POSE, 0);
                newTransmog.setPlaying(true);

                LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
                if (localPoint != null)
                {
                    newTransmog.setLocation(localPoint, client.getTopLevelWorldView().getPlane());
                }

                plugin.setTransmog(newTransmog);
                plugin.setTransmogModel(customModel);
                transmogPanel.getTransmogLabel().setText(customModel.getComp().getName());
            });
            return;
        }

        clientThread.invokeLater(() ->
        {
            transmog.setActive(false);
            transmog.setActive(true);
            LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
            if (localPoint != null)
            {
                transmog.setLocation(localPoint, client.getTopLevelWorldView().getPlane());
            }
        });
        plugin.setTransmogModel(customModel);
        transmogPanel.getTransmogLabel().setText(customModel.getComp().getName());
        transmog.setModel(customModel.getModel());
        transmog.setRadius(transmogPanel.getRadius());
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.programming.AnimationType;
import com.creatorskit.programming.CKAnimationController;
import com.creatorskit.saves.TransmogLoadOption;
import com.creatorskit.saves.TransmogSave;
import com.creatorskit.models.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.ClientTick;
import net.runelite.api.events.GameStateChanged;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import org.apache.commons.lang3.ArrayUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;

@Slf4j
@Getter
public class TransmogPanel extends JPanel
{
    private Client client;
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;

    private final File TRANSMOGS_DIR = new File(Paths.get(RuneLite.RUNELITE_DIR.getPath(), "creatorskit").toString(), "transmogs");
    private final GridBagConstraints c = new GridBagConstraints();
    private final JLabel transmogLabel = new JLabel("None");
    private final JSpinner radiusSpinner = new JSpinner(new SpinnerNumberModel(60, 0, 99999, 1));
    private final JComboBox<TransmogAnimationMode> animationComboBox = new JComboBox<>();
    private final JSpinner poseSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner walkSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner runSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner actionSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner backwardsSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner rightSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner leftSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JSpinner rotateSpinner = new JSpinner(new SpinnerNumberModel(-1, -1, 99999, 1));
    private final JPanel animationSwapsPanel = new JPanel();
    private TransmogAnimationMode animationMode = TransmogAnimationMode.PLAYER;
    private int[][] animationSwaps = new int[0][2];
    private int pose = -1;
    private int walk = -1;
    private int run = -1;
    private int active = -1;
    private int backwards = -1;
    private int shuffleRight = -1;
    private int shuffleLeft = -1;
    private int rotate = -1;
    private int radius = 60;

    @Inject
    public TransmogPanel(@Nullable Client client, ClientThread clientThread, CreatorsPlugin plugin, CreatorsConfig config)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.config = config;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());

        JScrollPane scrollPane = new JScrollPane();
        add(scrollPane);

        JPanel rowHeaderPanel = new JPanel();
        rowHeaderPanel.setLayout(new GridBagLayout());
        rowHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setRowHeaderView(rowHeaderPanel);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        JLabel currentLabel = new JLabel("Current Transmog");
        currentLabel.setHorizontalAlignment(SwingConstants.CENTER);
        currentLabel.setFont(FontManager.getRunescapeBoldFont());
        rowHeaderPanel.add(currentLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 2;
        transmogLabel.setHorizontalAlignment(SwingConstants.CENTER);
        transmogLabel.setForeground(Color.YELLOW);
        rowHeaderPanel.add(transmogLabel, c);

        c.gridx = 0;
        c.gridy = 3;
        c.gridwidth = 1;
        JLabel radiusLabel = new JLabel("Radius:");
        radiusLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(radiusLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        c.gridwidth = 1;
        radiusSpinner.setToolTipText("Set the radius of your transmog. 60 is best for an object the size of 1 tile");
        radiusSpinner.addChangeListener(e -> {
            radius = (int) radiusSpinner.getValue();
            CKObject ckObject = plugin.getTransmog();
            if (ckObject == null)
                return;

            clientThread.invokeLater(() -> ckObject.setRadius(radius));
        });
        rowHeaderPanel.add(radiusSpinner, c);

        c.gridx = 0;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel swapTitle = new JLabel("Animation Swaps");
        swapTitle.setHorizontalAlignment(SwingConstants.CENTER);
        swapTitle.setFont(FontManager.getRunescapeBoldFont());
        rowHeaderPanel.add(swapTitle, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 6;
        JLabel systemLabel = new JLabel("System:");
        systemLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(systemLabel, c);

        c.gridx = 1;
        c.gridy = 6;
        animationComboBox.addItem(TransmogAnimationMode.PLAYER);
        animationComboBox.addItem(TransmogAnimationMode.MODIFIED);
        animationComboBox.addItem(TransmogAnimationMode.CUSTOM);
        animationComboBox.addItem(TransmogAnimationMode.NONE);
        animationComboBox.setFocusable(false);
        animationComboBox.setToolTipText("<html>" + "Set how to handle your Transmog's animations" + "<br>" +
                "1) Player: Copy your player character's animations," + "<br>" +
                "2) Modified: Use all swaps indicated here; otherwise, copy your player character's animations," + "<br>" +
                "3) Custom: Only use the animations indicated here," + "<br>" +
                "4) None: Don't animate at all" + "<html>");

        animationComboBox.addItemListener(e -> animationMode = (TransmogAnimationMode) animationComboBox.getSelectedItem());
        rowHeaderPanel.add(animationComboBox, c);

        c.gridx = 0;
        c.gridy = 7;
        JLabel poseLabel = new JLabel("Pose:");
        poseLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(poseLabel, c);

        c.gridx = 1;
        c.gridy = 7;
        poseSpinner.setToolTipText("Custom only: Set your Transmog's idle/pose animation");
        poseSpinner.addChangeListener(e -> pose = (int) poseSpinner.getValue());
        rowHeaderPanel.add(poseSpinner, c);

        c.gridx = 0;
        c.gridy = 8;
        JLabel walkLabel = new JLabel("Walk:");
        walkLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(walkLabel, c);

        c.gridx = 1;
        c.gridy = 8;
        walkSpinner.setToolTipText("Custom only: Set your Transmog's walk animation");
        walkSpinner.addChangeListener(e -> walk = (int) walkSpinner.getValue());
        rowHeaderPanel.add(walkSpinner, c);

        c.gridx = 0;
        c.gridy = 9;
        JLabel runLabel = new JLabel("Run:");
        runLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(runLabel, c);

        c.gridx = 1;
        c.gridy = 9;
        runSpinner.setToolTipText("Custom only: Set your Transmog's run animation");
        runSpinner.addChangeListener(e -> run = (int) runSpinner.getValue());
        rowHeaderPanel.add(runSpinner, c);

        c.gridx = 0;
        c.gridy = 10;
        JLabel actionLabel = new JLabel("Action:");
        actionLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(actionLabel, c);

        c.gridx = 1;
        c.gridy = 10;
        actionSpinner.setToolTipText("Custom only: Set your Transmog's default interact animation");
        actionSpinner.addChangeListener(e -> active = (int) actionSpinner.getValue());
        rowHeaderPanel.add(actionSpinner, c);

        c.gridx = 0;
        c.gridy = 11;
        JLabel backwardsLabel = new JLabel("Backwards:");
        backwardsLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(backwardsLabel, c);

        c.gridx = 1;
        c.gridy = 11;
        backwardsSpinner.setToolTipText("Custom only: Set your Transmog's backwards walk animation");
        backwardsSpinner.addChangeListener(e -> backwards = (int) backwardsSpinner.getValue());
        rowHeaderPanel.add(backwardsSpinner, c);

        c.gridx = 0;
        c.gridy = 12;
        JLabel rightLabel = new JLabel("Shuffle Right:");
        rightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(rightLabel, c);

        c.gridx = 1;
        c.gridy = 12;
        rightSpinner.setToolTipText("Custom only: Set your Transmog's shuffle right animation");
        rightSpinner.addChangeListener(e -> shuffleRight = (int) rightSpinner.getValue());
        rowHeaderPanel.add(rightSpinner, c);

        c.gridx = 0;
        c.gridy = 13;
        JLabel leftLabel = new JLabel("Shuffle Left:");
        leftLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(leftLabel, c);

        c.gridx = 1;
        c.gridy = 13;
        leftSpinner.setToolTipText("Custom only: Set your Transmog's shuffle left animation");
        leftSpinner.addChangeListener(e -> shuffleLeft = (int) leftSpinner.getValue());
        rowHeaderPanel.add(leftSpinner, c);

        c.gridx = 0;
        c.gridy = 14;
        JLabel rotateLabel = new JLabel("Rotate:");
        rotateLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        rowHeaderPanel.add(rotateLabel, c);

        c.gridx = 1;
        c.gridy = 14;
        rotateSpinner.setToolTipText("Custom only: Set your Transmog's rotate animation");
        rotateSpinner.addChangeListener(e -> rotate = (int) rotateSpinner.getValue());
        rowHeaderPanel.add(rotateSpinner, c);

        c.gridx = 0;
        c.gridy = 15;
        JButton defaultsButton = new JButton("Defaults");
        defaultsButton.setToolTipText("Sets all the Animation Swaps to player defaults");
        defaultsButton.addActionListener(e ->
        {
            poseSpinner.setValue(808);
            walkSpinner.setValue(819);
            runSpinner.setValue(824);
            actionSpinner.setValue(866);
            backwardsSpinner.setValue(820);
            rightSpinner.setValue(822);
            leftSpinner.setValue(821);
            rotateSpinner.setValue(823);
        });
        rowHeaderPanel.add(defaultsButton, c);

        c.gridx = 1;
        c.gridy = 15;
        JButton resetButton = new JButton("Reset");
        resetButton.setToolTipText("Resets all regular Animation Swaps to -1");
        resetButton.addActionListener(e -> resetSidePanel());
        rowHeaderPanel.add(resetButton, c);

        c.gridwidth = 2;
        c.weightx = 1;
        c.gridx = 0;
        c.gridy = 16;
        JButton addButton = new JButton("Add additional swap");
        addButton.setToolTipText("Add another specific animation swap");
        addButton.addActionListener(e -> addSwapPanel());
        rowHeaderPanel.add(addButton, c);

        JPanel columnHeaderPanel = new JPanel();
        columnHeaderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(columnHeaderPanel);

        JButton saveButton = new JButton("Save");
        saveButton.setToolTipText("Saves your Transmog and Animation Swaps for future use");
        columnHeaderPanel.add(saveButton);
        saveButton.addActionListener(e -> openSaveDialog(transmogLabel.getText()));

        JButton loadButton = new JButton("Load");
        loadButton.setToolTipText("Load a previously saved Transmog and/or set of Animation Swaps");
        columnHeaderPanel.add(loadButton);
        loadButton.addActionListener(e -> openLoadDialog());

        JButton clearButton = new JButton("Clear");
        clearButton.setToolTipText("Clear all Additional Swaps");
        columnHeaderPanel.add(clearButton);
        clearButton.addActionListener(e -> clearSwapPanels());

        c.insets = new Insets(0, 0, 0, 0);
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel viewport = new JPanel();
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.setBorder(new EmptyBorder(4, 6, 4, 6));
        viewport.add(animationSwapsPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        scrollPane.setViewportView(viewport);
        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        animationSwapsPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        animationSwapsPanel.setLayout(new GridLayout(0, 8, 8, 8));
        revalidate();
    }

    @Subscribe
    public void onAnimationChanged(AnimationChanged event)
    {
        CKObject transmog = plugin.getTransmog();
        if (!config.enableTransmog() || transmog == null)
        {
            return;
        }

        if (animationMode == TransmogAnimationMode.NONE)
            return;

        if (event.getActor() instanceof Player)
        {
            Player player = (Player) event.getActor();
            if (player != client.getLocalPlayer())
                return;

            int playerAnimation = player.getAnimation();
            int animId = transmog.getAnimationId();
            int transmogAnimation = -1;
            if (animId != -1)
                transmogAnimation = animId;

            if (animationMode == TransmogAnimationMode.PLAYER && transmogAnimation != playerAnimation)
            {
                transmog.setAnimation(AnimationType.ACTIVE, playerAnimation);
                return;
            }

            for (int[] swap : animationSwaps)
            {
                if (swap[0] == player.getAnimation() && transmogAnimation != swap[1])
                {
                    transmog.setAnimation(AnimationType.ACTIVE, swap[1]);
                    return;
                }
            }

            if (animationMode == TransmogAnimationMode.MODIFIED && transmogAnimation != playerAnimation && active == -1)
                transmog.setAnimation(AnimationType.ACTIVE, playerAnimation);

            if (animationMode == TransmogAnimationMode.MODIFIED && transmogAnimation != active && active != -1)
                transmog.setAnimation(AnimationType.ACTIVE, active);

            if (animationMode == TransmogAnimationMode.CUSTOM && transmogAnimation != active)
                transmog.setAnimation(AnimationType.ACTIVE, active);
        }
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        Player player = client.getLocalPlayer();
        WorldView worldView = client.getTopLevelWorldView();
        CKObject transmog = plugin.getTransmog();

        if (config.enableTransmog() && transmog != null)
        {
            if (player == null)
                return;

            LocalPoint localPoint = player.getLocalLocation();
            transmog.setLocation(localPoint, worldView.getPlane());
            transmog.setOrientation(player.getCurrentOrientation());

            int playerActive = player.getAnimation();
            int playerPose = player.getPoseAnimation();
            Animation[] animations = transmog.getAnimations();
            Animation activeAnim = animations[0];
            Animation poseAnim = animations[1];

            if (activeAnim != null)
            {
                int activeId = activeAnim.getId();
                if (animationMode == TransmogAnimationMode.PLAYER)
                {
                    if (activeId != playerActive && activeId != -1)
                    {
                        transmog.setAnimation(AnimationType.ACTIVE, playerActive);
                    }
                }
                return;
            }

            if (poseAnim == null)
            {
                return;
            }

            int poseId = poseAnim.getId();

            if (animationMode == TransmogAnimationMode.PLAYER)
            {
                if (poseId != playerPose)
                {
                    transmog.setAnimation(AnimationType.POSE, playerPose);
                }
            }

            if (animationMode == TransmogAnimationMode.CUSTOM || animationMode == TransmogAnimationMode.MODIFIED)
            {
                if (animationMode == TransmogAnimationMode.MODIFIED)
                {
                    if (pose == -1)
                        pose = playerPose;
                    if (walk == -1)
                        walk = playerPose;
                    if (run == -1)
                        run = playerPose;
                    if (backwards == -1)
                        backwards = playerPose;
                    if (shuffleLeft == -1)
                        shuffleLeft = playerPose;
                    if (shuffleRight == -1)
                        shuffleRight = playerPose;
                    if (rotate == -1)
                        rotate = playerPose;
                }

                PoseAnimation poseAnimation = AnimationData.getPoseAnimation(playerPose);
                int poseAnimId = -1;

                switch (poseAnimation)
                {
                    case POSE:
                        poseAnimId = pose;
                        break;
                    case WALK:
                        poseAnimId = walk;
                        break;
                    case RUN:
                        poseAnimId = run;
                        break;
                    case BACKWARDS:
                        poseAnimId = backwards;
                        break;
                    case SHUFFLE_RIGHT:
                        poseAnimId = shuffleRight;
                        break;
                    case SHUFFLE_LEFT:
                        poseAnimId = shuffleLeft;
                        break;
                    case ROTATE:
                        poseAnimId = rotate;
                }

                if (poseId != poseAnimId)
                {
                    transmog.setAnimation(AnimationType.POSE, poseAnimId);
                }
            }
        }
    }

    @Subscribe
    public void onGameStateChanged(GameStateChanged event)
    {
        if (event.getGameState() == GameState.LOGGED_IN)
        {
            CKObject transmog = plugin.getTransmog();
            if (config.enableTransmog() && transmog != null)
            {
                transmog.setActive(false);
                transmog.setActive(true);
            }
        }
    }

    private void addSwapPanel()
    {
        addSwapPanel(-1, -1);
    }

    private void addSwapPanel(int swapOut, int swapIn)
    {
        JPanel swap = new JPanel();
        swap.setLayout(new GridBagLayout());
        swap.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1, true));

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;
        c.gridwidth = 1;

        final int[] animationSwap = new int[]{swapOut, swapIn};
        if (swapOut != -1)
            addAnimationSwap(swapOut, swapIn);

        c.gridx = 0;
        c.gridy = 0;
        JLabel outLabel = new JLabel("Swap out:");
        outLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        swap.add(outLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        JSpinner outSpinner = new JSpinner(new SpinnerNumberModel(swapOut, -1, 99999, 1));
        outSpinner.setToolTipText("Pick which player animation to swap out");
        swap.add(outSpinner, c);

        c.gridx = 0;
        c.gridy = 1;
        JLabel inLabel = new JLabel("Swap in:");
        inLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        swap.add(inLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner inSpinner = new JSpinner(new SpinnerNumberModel(swapIn, -1, 99999, 1));
        inSpinner.setToolTipText("Pick which new animation to swap in");
        swap.add(inSpinner, c);

        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 2;
        JButton removeButton = new JButton("Remove");
        removeButton.setToolTipText("Removes this animation swap");
        removeButton.addActionListener(e ->
        {
            int out = (int) outSpinner.getValue();
            int in = (int) inSpinner.getValue();
            removeSwapPanel(swap, out, in);
        });
        swap.add(removeButton, c);

        inSpinner.addChangeListener(e ->
        {
            int previousIn = animationSwap[1];
            int newIn = (int) inSpinner.getValue();
            int newOut = (int) outSpinner.getValue();

            if (newOut != -1)
            {
                removeAnimationSwap(newOut, previousIn);
                addAnimationSwap(newOut, newIn);
            }

            animationSwap[0] = newOut;
            animationSwap[1] = newIn;
        });

        outSpinner.addChangeListener(e ->
        {
            int previousOut = animationSwap[0];
            int newIn = (int) inSpinner.getValue();
            int newOut = (int) outSpinner.getValue();

            if (newOut == -1)
                removeAnimationSwap(previousOut, newIn);

            if (newOut != -1 && previousOut != -1)
            {
                removeAnimationSwap(previousOut, newIn);
                addAnimationSwap(newOut, newIn);
            }

            if (newOut != -1 && previousOut == -1)
                addAnimationSwap(newOut, newIn);

            animationSwap[0] = newOut;
            animationSwap[1] = newIn;
        });

        animationSwapsPanel.add(swap);
        revalidate();
        repaint();
    }

    private void resetSidePanel()
    {
        poseSpinner.setValue(-1);
        walkSpinner.setValue(-1);
        runSpinner.setValue(-1);
        actionSpinner.setValue(-1);
        backwardsSpinner.setValue(-1);
        rightSpinner.setValue(-1);
        leftSpinner.setValue(-1);
        rotateSpinner.setValue(-1);
    }

    private void clearSwapPanels()
    {
        animationSwaps = new int[0][2];
        animationSwapsPanel.removeAll();
        revalidate();
        repaint();
    }

    private void removeSwapPanel(JPanel panel, int out, int in)
    {
        animationSwapsPanel.remove(panel);
        removeAnimationSwap(out, in);
        revalidate();
        repaint();
    }

    private void removeAnimationSwap(int out, int in)
    {
        int index = -1;
        for (int i = 0; i < animationSwaps.length; i++)
        {
            int[] array = animationSwaps[i];
            if (array[0] == out && array[1] == in)
            {
                index = i;
                break;
            }
        }

        if (index == -1)
            return;

        animationSwaps = ArrayUtils.remove(animationSwaps, index);
    }

    private void addAnimationSwap(int out, int in)
    {
        animationSwaps = ArrayUtils.add(animationSwaps, new int[]{out, in});
    }

    private void openSaveDialog(String name)
    {
        File outputDir = TRANSMOGS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save current model collection");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile);
        }
    }

    public void saveToFile(File file)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            CustomModelComp comp = null;
            CustomModel customModel = plugin.getTransmogModel();
            if (customModel != null && customModel.getComp() != null)
                comp = customModel.getComp();

            TransmogSave transmogSave = new TransmogSave(
                    comp,
                    animationMode,
                    animationSwaps,
                    pose,
                    walk,
                    run,
                    active,
                    backwards,
                    shuffleRight,
                    shuffleLeft,
                    rotate,
                    radius);
            String string = plugin.getGson().toJson(transmogSave);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving model to file via TransmogPanel");
        }
    }

    private void openLoadDialog()
    {
        TRANSMOGS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(TRANSMOGS_DIR);
        fileChooser.setDialogTitle("Choose a transmog to load");

        JComboBox<TransmogLoadOption> comboBox = new JComboBox<>();
        comboBox.setToolTipText("Load the transmog model, animations, or both");
        comboBox.addItem(TransmogLoadOption.BOTH);
        comboBox.addItem(TransmogLoadOption.CUSTOM_MODEL);
        comboBox.addItem(TransmogLoadOption.ANIMATIONS);
        comboBox.setFocusable(false);

        fileChooser.setAccessory(comboBox);

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            plugin.loadTransmog(selectedFile, (TransmogLoadOption) comboBox.getSelectedItem());
        }
    }

    public void loadTransmog(TransmogSave transmogSave)
    {
        animationMode = transmogSave.getTransmogAnimationMode();
        pose = transmogSave.getPoseAnimation();
        walk = transmogSave.getWalkAnimation();
        run = transmogSave.getRunAnimation();
        active = transmogSave.getActionAnimation();
        backwards = transmogSave.getBackwardsAnimation();
        shuffleRight = transmogSave.getRightAnimation();
        shuffleLeft = transmogSave.getLeftAnimation();
        rotate = transmogSave.getRotateAnimation();
        radius = transmogSave.getRadius();

        animationComboBox.setSelectedItem(animationMode);
        poseSpinner.setValue(pose);
        walkSpinner.setValue(walk);
        runSpinner.setValue(run);
        actionSpinner.setValue(active);
        backwardsSpinner.setValue(backwards);
        rightSpinner.setValue(shuffleRight);
        leftSpinner.setValue(shuffleLeft);
        rotateSpinner.setValue(rotate);
        radiusSpinner.setValue(radius);

        clearSwapPanels();
        animationSwaps = transmogSave.getAnimationSwaps();
        if (animationSwaps != null)
        {
            for (int[] swap : animationSwaps)
            {
                addSwapPanel(swap[0], swap[1]);
            }
        }
    }
}

package com.creatorskit.swing.colours;

import com.creatorskit.swing.anvil.ComplexPanel;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Client;
import net.runelite.api.JagexColor;
import net.runelite.api.ModelData;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.colorchooser.AbstractColorChooserPanel;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

public class ColourSwapPanel extends JPanel
{
    private final Client client;
    private final ClientThread clientThread;
    private final ArrayList<ComplexPanel> complexPanels;
    private final GridBagConstraints c = new GridBagConstraints();
    private final Dimension LABEL_DIMENSION = new Dimension(250, 30);
    private final Dimension TOP_BAR_DIMENSION = new Dimension(100, 25);
    private final BufferedImage COPY_COLOURS = ImageUtil.loadImageResource(getClass(), "/Copy_Colours.png");
    private final BufferedImage PASTE_COLOURS = ImageUtil.loadImageResource(getClass(), "/Paste_Colours.png");
    private final JColorChooser colourChooser = new JColorChooser();
    @Getter
    private final JComboBox<ComplexPanel> comboBox = new JComboBox<>();
    @Getter
    private ColourPanel[] colourPanels = new ColourPanel[0];
    @Getter
    private TexturePanel[] texturePanels = new TexturePanel[0];
    @Getter
    private final JPanel colourHolder = new JPanel();
    @Getter
    private final JPanel textureHolder = new JPanel();
    @Getter
    @Setter
    private ComplexPanel currentComplexPanel;
    @Getter
    @Setter
    private short[][] copiedColoursTextures = new short[4][0];

    @Inject
    public ColourSwapPanel(Client client, ClientThread clientThread, ArrayList<ComplexPanel> complexPanels)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.complexPanels = complexPanels;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new GridBagLayout());
        setBorder(new EmptyBorder(2, 2, 2, 2));

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.gridwidth = 1;
        c.weightx = 6;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel comboPane = new JPanel();
        comboPane.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        add(comboPane, c);

        JLabel swapLabel = new JLabel("Model:  ", SwingConstants.RIGHT);
        swapLabel.setFont(FontManager.getRunescapeBoldFont());
        swapLabel.setPreferredSize(TOP_BAR_DIMENSION);
        comboPane.add(swapLabel);

        comboBox.addActionListener(e -> onSwapperPressed((ComplexPanel) comboBox.getSelectedItem()));
        comboBox.setPreferredSize(new Dimension(250, 25));
        comboPane.add(comboBox);

        JButton copyButton = new JButton(new ImageIcon(COPY_COLOURS));
        copyButton.setToolTipText("Copy all swapped colours & textures");
        copyButton.setPreferredSize(TOP_BAR_DIMENSION);
        copyButton.addActionListener(e -> copyColoursTextures(currentComplexPanel));
        comboPane.add(copyButton);

        JButton pasteButton = new JButton(new ImageIcon(PASTE_COLOURS));
        pasteButton.setToolTipText("Paste all copied colours & textures");
        pasteButton.setPreferredSize(TOP_BAR_DIMENSION);
        pasteButton.addActionListener(e -> pasteColoursTextures(currentComplexPanel));
        comboPane.add(pasteButton);

        JButton clearEverythingButton = new JButton("Clear Everything");
        clearEverythingButton.setToolTipText("Clears every swapped colour & texture for every model in the Anvil");
        clearEverythingButton.setPreferredSize(new Dimension(130, 25));
        clearEverythingButton.addActionListener(e -> clearColoursEverything());
        comboPane.add(clearEverythingButton);

        JButton setAllModelColours = new JButton("Set Everything");
        setAllModelColours.setToolTipText("Sets colours for every model in the Anvil to the colour currently selected in the Colour Picker");
        setAllModelColours.setPreferredSize(new Dimension(120, 25));
        setAllModelColours.addActionListener(e -> setColoursEverything());
        comboPane.add(setAllModelColours);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 0;
        JPanel previewPanel = new JPanel();
        previewPanel.setBackground(colourChooser.getColor());
        add(previewPanel, c);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 1;
        AbstractColorChooserPanel[] chooserPanels = {colourChooser.getChooserPanels()[1]};
        colourChooser.setChooserPanels(chooserPanels);
        colourChooser.setPreviewPanel(new JPanel());
        colourChooser.setBorder(new LineBorder(colourChooser.getColor(), 2));
        colourChooser.getSelectionModel().addChangeListener(e ->
        {
            colourChooser.setBorder(new LineBorder(colourChooser.getColor(), 2));
            previewPanel.setBackground(colourChooser.getColor());
        });
        add(colourChooser, c);

        c.weighty = 1;
        c.gridx = 1;
        c.gridy = 2;
        JLabel emptyLabel = new JLabel("");
        add(emptyLabel, c);

        c.gridheight = 2;
        c.weightx = 4;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane();
        add(scrollPane, c);

        JPanel swapPanel = new JPanel();
        swapPanel.setLayout(new GridBagLayout());
        swapPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        scrollPane.setViewportView(swapPanel);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel textureLabel = new JLabel("Textures", SwingConstants.CENTER);
        textureLabel.setPreferredSize(LABEL_DIMENSION);
        textureLabel.setFont(FontManager.getRunescapeBoldFont());
        swapPanel.add(textureLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        JLabel colourLabel = new JLabel("Colours", SwingConstants.CENTER);
        colourLabel.setPreferredSize(LABEL_DIMENSION);
        colourLabel.setFont(FontManager.getRunescapeBoldFont());
        swapPanel.add(colourLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        JPanel textureHeader = new JPanel();
        textureHeader.setLayout(new GridLayout(1, 0, 1, 1));
        swapPanel.add(textureHeader, c);

        JLabel oldTextureLabel = new JLabel("Old", SwingConstants.CENTER);
        oldTextureLabel.setFont(FontManager.getRunescapeBoldFont());
        textureHeader.add(oldTextureLabel);

        JLabel newTextureLabel = new JLabel("New", SwingConstants.CENTER);
        newTextureLabel.setFont(FontManager.getRunescapeBoldFont());
        textureHeader.add(newTextureLabel);

        JButton clearTextures = new JButton("Clear");
        clearTextures.setToolTipText("Clear all swapped textures back to default");
        clearTextures.addActionListener(e -> {
            unsetAllTextures();
            removeAllTextureSwaps();
            repaint();
            revalidate();
        });
        textureHeader.add(clearTextures);

        c.gridx = 1;
        c.gridy = 1;
        JPanel colourHeader = new JPanel();
        colourHeader.setLayout(new GridLayout(2, 0, 1, 1));
        swapPanel.add(colourHeader, c);

        JLabel oldColourLabel = new JLabel("Old", SwingConstants.CENTER);
        oldColourLabel.setFont(FontManager.getRunescapeBoldFont());
        colourHeader.add(oldColourLabel);

        JLabel newColourLabel = new JLabel("New", SwingConstants.CENTER);
        newColourLabel.setFont(FontManager.getRunescapeBoldFont());
        colourHeader.add(newColourLabel);

        JButton clearColours = new JButton("Clear");
        clearColours.setToolTipText("Clear all swapped colours back to default");
        clearColours.addActionListener(e -> {
            unsetAllColours();
            removeAllColourSwaps();
            repaint();
            revalidate();
        });
        colourHeader.add(clearColours);

        colourHeader.add(new JLabel(""));
        colourHeader.add(new JLabel(""));

        JButton setAllButton = new JButton("Set All");
        setAllButton.setToolTipText("Sets all colours for this model to the colour currently selected in the Colour Picker");
        setAllButton.addActionListener(e -> {
            setAllColoursHere();
            repaint();
            revalidate();
        });
        colourHeader.add(setAllButton);

        c.gridx = 0;
        c.gridy = 2;
        textureHolder.setLayout(new GridLayout(0, 1, 1, 2));
        textureHolder.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        swapPanel.add(textureHolder, c);

        c.gridx = 1;
        c.gridy = 2;
        colourHolder.setLayout(new GridLayout(0, 1, 1, 2));
        colourHolder.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        swapPanel.add(colourHolder, c);

        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel emptyLabel3 = new JLabel("");
        swapPanel.add(emptyLabel3, c);

        repaint();
        revalidate();
    }

    public void addComplexPanelOption(ComplexPanel complexPanel)
    {
        comboBox.addItem(complexPanel);
    }

    public void removeAllComplexPanelOptions()
    {
        comboBox.removeAllItems();
        unsetSwapper();
        repaint();
        revalidate();
    }

    public void removeComplexPanelOption(ComplexPanel complexPanel)
    {
        if (comboBox.getSelectedItem() == complexPanel)
        {
            unsetSwapper();
            repaint();
            revalidate();
        }

        comboBox.removeItem(complexPanel);
    }

    public void setComboBox(ComplexPanel complexPanel)
    {
        comboBox.setSelectedItem(complexPanel);
    }

    public void onSwapperPressed(ComplexPanel complexPanel)
    {
        unsetSwapper();
        if (complexPanel == null)
        {
            repaint();
            revalidate();
            return;
        }

        int modelId = (int) complexPanel.getModelIdSpinner().getValue();
        if (modelId == -1)
        {
            repaint();
            revalidate();
            return;
        }

        setupSwapper(complexPanel);
    }

    public void setupSwapper(ComplexPanel complexPanel)
    {
        int modelId = (int) complexPanel.getModelIdSpinner().getValue();

        currentComplexPanel = complexPanel;

        HashMap<Short, Short> colourMap = new HashMap<>();
        for (int i = 0; i < complexPanel.getColoursFrom().length; i++)
        {
            colourMap.put(complexPanel.getColoursFrom()[i], complexPanel.getColoursTo()[i]);
        }

        HashMap<Short, Short> textureMap = new HashMap<>();
        for (int i = 0; i < complexPanel.getTexturesFrom().length; i++)
        {
            textureMap.put(complexPanel.getTexturesFrom()[i], complexPanel.getTexturesTo()[i]);
        }

        clientThread.invokeLater(() ->
        {
            ModelData modelData = client.loadModelData(modelId);
            if (modelData == null)
                return;

            short[] colourList = new short[0];
            for (short s : modelData.getFaceColors())
            {
                if (!ArrayUtils.contains(colourList, s))
                    colourList = ArrayUtils.add(colourList, s);
            }

            for (short colour : colourList)
            {
                if (colourMap.containsKey(colour))
                {
                    createColourPanel(colour, colourMap.get(colour), true);
                    continue;
                }

                createColourPanel(colour, colour, false);
            }

            try
            {
                modelData.cloneTextures();
            }
            catch (Exception e)
            {
                repaint();
                revalidate();
                return;
            }

            short[] textureList = new short[0];
            for (short s : modelData.getFaceTextures())
            {
                if (!ArrayUtils.contains(textureList, s))
                    textureList = ArrayUtils.add(textureList, s);
            }

            for (short texture : textureList)
            {
                if (textureMap.containsKey(texture))
                {
                    createTexturePanel(texture, textureMap.get(texture), true);
                    continue;
                }

                createTexturePanel(texture, texture, false);
            }

            repaint();
            revalidate();
        });
    }

    public void unsetSwapper()
    {
        colourHolder.removeAll();
        colourPanels = new ColourPanel[0];

        textureHolder.removeAll();
        texturePanels = new TexturePanel[0];

        currentComplexPanel = null;
    }

    private ColourPanel createColourPanel(short oldColour, short newColour, boolean isColourSet)
    {
        JLabel oldColourLabel = new JLabel("" + oldColour, SwingConstants.CENTER);
        oldColourLabel.setFont(FontManager.getRunescapeSmallFont());
        oldColourLabel.setBorder(new LineBorder(colourFromShort(oldColour), 10));
        oldColourLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton newColourButton = new JButton("" + (isColourSet ? newColour : "Set"));
        newColourButton.setToolTipText("Swap this Old colour to the colour currently selected in the Colour Picker");
        newColourButton.setFont(FontManager.getRunescapeSmallFont());
        newColourButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        if (isColourSet)
            newColourButton.setBorder(new LineBorder(colourFromShort(newColour), 10));

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0, 1, 0, 1));

        JButton findButton = new JButton("Find");
        findButton.setToolTipText("Find the current New colour swap in the colour picker");
        buttonPanel.add(findButton);

        JSpinner spinner = new JSpinner(new SpinnerNumberModel(0, -32768, 32767, 1));
        spinner.setToolTipText("Apply an exact Jagex colour as it is stored in the cache");
        buttonPanel.add(spinner);

        ColourPanel colourPanel = new ColourPanel(isColourSet, oldColour, newColour, oldColourLabel, newColourButton, spinner);
        colourPanel.setLayout(new GridLayout(1, 0, 1, 1));
        colourPanel.add(oldColourLabel);
        colourPanel.add(newColourButton);
        colourPanel.add(buttonPanel);

        spinner.addChangeListener(e ->
        {
            short colourToAdd = (short) ((int) spinner.getValue());
            if (colourPanel.isColourSet())
            {
                replaceColour(colourPanel, colourToAdd);
                replaceColourSwap(colourPanel.getOldColour(), colourToAdd);
                return;
            }

            setColour(colourPanel, colourToAdd);
            addColourSwap(colourPanel.getOldColour(), colourToAdd);
        });
        findButton.addActionListener(e -> colourChooser.setColor(colourFromShort(colourPanel.getNewColour())));
        newColourButton.addActionListener(e ->
        {
            if (colourPanel.isColourSet())
            {
                unsetColour(colourPanel);
                removeColourSwap(colourPanel.getOldColour());
                return;
            }

            setColour(colourPanel, colourChooser.getColor());
            addColourSwap(colourPanel.getOldColour(), colourPanel.getNewColour());
        });

        colourHolder.add(colourPanel);
        colourPanels = ArrayUtils.add(colourPanels, colourPanel);
        return colourPanel;
    }

    private void setAllColoursHere()
    {
        short colour = shortFromColour(colourChooser.getColor());

        for (ColourPanel colourPanel : colourPanels)
        {
            if (colourPanel.isColourSet())
            {
                replaceColour(colourPanel, colour);
                replaceColourSwap(colourPanel.getOldColour(), colour);
                continue;
            }

            setColour(colourPanel, colour);
            addColourSwap(colourPanel.getOldColour(), colourPanel.getNewColour());
        }
    }

    public void setColoursEverything()
    {
        short colour = shortFromColour(colourChooser.getColor());
        clientThread.invokeLater(() ->
        {
            for (ComplexPanel complexPanel : complexPanels)
            {
                int modelId = (int) complexPanel.getModelIdSpinner().getValue();
                if (modelId == -1)
                {
                    continue;
                }

                ModelData modelData = client.loadModelData(modelId);
                if (modelData == null)
                    continue;

                short[] coloursFrom = new short[0];
                for (short s : modelData.getFaceColors())
                {
                    if (!ArrayUtils.contains(coloursFrom, s))
                    {
                        coloursFrom = ArrayUtils.add(coloursFrom, s);
                    }
                }

                short[] coloursTo = new short[coloursFrom.length];
                Arrays.fill(coloursTo, colour);
                complexPanel.setColoursFrom(coloursFrom);
                complexPanel.setColoursTo(coloursTo);
            }

            onSwapperPressed((ComplexPanel) comboBox.getSelectedItem());
        });
    }

    private void clearColoursEverything()
    {
        for (ComplexPanel complexPanel : complexPanels)
        {
            if ((int) complexPanel.getModelIdSpinner().getValue() == -1)
            {
                continue;
            }

            complexPanel.setColoursFrom(new short[0]);
            complexPanel.setColoursTo(new short[0]);
        }

        onSwapperPressed((ComplexPanel) comboBox.getSelectedItem());
    }

    private void setColour(ColourPanel colourPanel, Color rgbColour)
    {
        setColour(colourPanel, shortFromColour(rgbColour));
    }

    private void setColour(ColourPanel colourPanel, short colour)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("" + colour);
        newColourButton.setBorder(new LineBorder(colourFromShort(colour), 10));
        colourPanel.setNewColour(colour);
        colourPanel.setColourSet(true);
    }

    private void unsetColour(ColourPanel colourPanel)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("Set");
        newColourButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 2));
        colourPanel.setNewColour(colourPanel.getOldColour());
        colourPanel.setColourSet(false);
    }

    private void replaceColour(ColourPanel colourPanel, short newColourTo)
    {
        JButton newColourButton = colourPanel.getNewColourButton();
        newColourButton.setText("" + newColourTo);
        newColourButton.setBorder(new LineBorder(colourFromShort(newColourTo), 10));
        colourPanel.setNewColour(newColourTo);
    }

    public void unsetAllColours()
    {
        for (ColourPanel colourPanel : colourPanels)
            unsetColour(colourPanel);

        removeAllColourSwaps();
    }

    private void addColourSwap(short colourFrom, short colourTo)
    {
        currentComplexPanel.setColoursFrom(ArrayUtils.add(currentComplexPanel.getColoursFrom(), colourFrom));
        currentComplexPanel.setColoursTo(ArrayUtils.add(currentComplexPanel.getColoursTo(), colourTo));
    }

    public void pasteColourSwaps(ComplexPanel complexPanel, short[] newColoursFrom, short[] newColoursTo)
    {
        short[] coloursFrom = complexPanel.getColoursFrom();
        short[] coloursTo = complexPanel.getColoursTo();

        for (int i = 0; i < newColoursFrom.length; i++)
        {
            boolean contains = false;
            for (int e = 0; e < coloursFrom.length; e++)
            {
                if (coloursFrom[e] == newColoursFrom[i])
                {
                    coloursTo[e] = newColoursTo[i];
                    contains = true;
                    break;
                }
            }

            if (contains)
                continue;

            coloursFrom = ArrayUtils.add(coloursFrom, newColoursFrom[i]);
            coloursTo = ArrayUtils.add(coloursTo, newColoursTo[i]);
        }

        complexPanel.setColoursFrom(coloursFrom);
        complexPanel.setColoursTo(coloursTo);
    }

    private void removeColourSwap(short colourFrom)
    {
        short[] coloursFrom = currentComplexPanel.getColoursFrom();
        short[] coloursTo = currentComplexPanel.getColoursTo();

        int index = ArrayUtils.indexOf(coloursFrom, colourFrom);
        currentComplexPanel.setColoursFrom(ArrayUtils.remove(coloursFrom, index));
        currentComplexPanel.setColoursTo(ArrayUtils.remove(coloursTo, index));
    }

    private void replaceColourSwap(short colourFrom, short newColourTo)
    {
        short[] coloursFrom = currentComplexPanel.getColoursFrom();
        short[] coloursTo = currentComplexPanel.getColoursTo();

        int index = ArrayUtils.indexOf(coloursFrom, colourFrom);
        coloursTo[index] = newColourTo;
    }

    public void removeAllColourSwaps()
    {
        currentComplexPanel.setColoursFrom(new short[0]);
        currentComplexPanel.setColoursTo(new short[0]);
    }

    public static Color colourFromShort(short s)
    {
        float hue = ((float) JagexColor.unpackHue(s) / JagexColor.HUE_MAX) * 360;
        float sat = ((float) JagexColor.unpackSaturation(s) / JagexColor.SATURATION_MAX) * 100;
        float lum = ((float) JagexColor.unpackLuminance(s) / JagexColor.LUMINANCE_MAX) * 100;
        return HSLColor.toRGB(hue, sat, lum);
    }

    public static short shortFromColour(Color color)
    {
        float[] col = HSLColor.fromRGB(color);
        int hue = (int) (col[0] / 360 * JagexColor.HUE_MAX);
        int sat = (int) (col[1] / 100 * JagexColor.SATURATION_MAX);
        int lum = (int) (col[2] / 100 * JagexColor.LUMINANCE_MAX);
        return JagexColor.packHSL(hue, sat, lum);
    }

    private TexturePanel createTexturePanel(short oldTexture, short newTexture, boolean isTextureSet)
    {
        JLabel oldTextureLabel = new JLabel("" + oldTexture, SwingConstants.CENTER);
        oldTextureLabel.setFont(FontManager.getRunescapeSmallFont());
        oldTextureLabel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        oldTextureLabel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JButton newTextureButton = new JButton("" + (isTextureSet ? newTexture : "Set"));
        newTextureButton.setFont(FontManager.getRunescapeSmallFont());
        newTextureButton.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JPanel buttonPanel = new JPanel();
        buttonPanel.setLayout(new GridLayout(0, 1, 0, 1));

        JSpinner spinner = new JSpinner(new SpinnerNumberModel(0, -1, 150, 1));
        spinner.setToolTipText("Apply a Texture Id as it is stored in the cache");
        buttonPanel.add(spinner);

        TexturePanel texturePanel = new TexturePanel(isTextureSet, oldTexture, newTexture, oldTextureLabel, newTextureButton, spinner);
        texturePanel.setLayout(new GridLayout(1, 0, 1, 1));
        texturePanel.add(oldTextureLabel);
        texturePanel.add(newTextureButton);
        texturePanel.add(buttonPanel);

        spinner.addChangeListener(e ->
        {
            short textureToAdd = (short) ((int) spinner.getValue());
            if (texturePanel.isTextureSet())
            {
                replaceTexture(texturePanel, textureToAdd);
                replaceTextureSwap(texturePanel.getOldTexture(), textureToAdd);
                return;
            }

            setTexture(texturePanel, textureToAdd);
            addTextureSwap(texturePanel.getOldTexture(), textureToAdd);
        });
        newTextureButton.addActionListener(e ->
        {
            if (texturePanel.isTextureSet())
            {
                unsetTexture(texturePanel);
                removeTextureSwap(texturePanel.getOldTexture());
                return;
            }

            short textureToAdd = (short) ((int) spinner.getValue());
            setTexture(texturePanel, textureToAdd);
            addTextureSwap(texturePanel.getOldTexture(), texturePanel.getNewTexture());
        });

        textureHolder.add(texturePanel);
        textureHolder.revalidate();
        textureHolder.repaint();
        texturePanels = ArrayUtils.add(texturePanels, texturePanel);
        return texturePanel;
    }

    private void setTexture(TexturePanel texturePanel, short texture)
    {
        JButton newColourButton = texturePanel.getNewTextureButton();
        newColourButton.setText("" + texture);
        texturePanel.setNewTexture(texture);
        texturePanel.setTextureSet(true);
    }

    private void unsetTexture(TexturePanel texturePanel)
    {
        JButton newTextureButton = texturePanel.getNewTextureButton();
        newTextureButton.setText("Set");
        texturePanel.setNewTexture(texturePanel.getOldTexture());
        texturePanel.setTextureSet(false);
    }

    private void replaceTexture(TexturePanel texturePanel, short newTextureTo)
    {
        JButton newTextureButton = texturePanel.getNewTextureButton();
        newTextureButton.setText("" + newTextureTo);
        texturePanel.setNewTexture(newTextureTo);
    }

    public void unsetAllTextures()
    {
        for (TexturePanel texturePanel : texturePanels)
            unsetTexture(texturePanel);

        removeAllTextureSwaps();
    }

    private void addTextureSwap(short textureFrom, short textureTo)
    {
        currentComplexPanel.setTexturesFrom(ArrayUtils.add(currentComplexPanel.getTexturesFrom(), textureFrom));
        currentComplexPanel.setTexturesTo(ArrayUtils.add(currentComplexPanel.getTexturesTo(), textureTo));
    }

    public void pasteTextureSwaps(ComplexPanel complexPanel, short[] newTexturesFrom, short[] newTexturesTo)
    {
        short[] texturesFrom = complexPanel.getTexturesFrom();
        short[] texturesTo = complexPanel.getTexturesTo();

        for (int i = 0; i < newTexturesFrom.length; i++)
        {
            boolean contains = false;
            for (int e = 0; e < texturesFrom.length; e++)
            {
                if (texturesFrom[e] == newTexturesFrom[i])
                {
                    texturesTo[e] = newTexturesTo[i];
                    contains = true;
                    break;
                }
            }

            if (contains)
                continue;

            texturesFrom = ArrayUtils.add(texturesFrom, newTexturesFrom[i]);
            texturesTo = ArrayUtils.add(texturesTo, newTexturesTo[i]);
        }

        complexPanel.setTexturesFrom(texturesFrom);
        complexPanel.setTexturesTo(texturesTo);
    }

    private void removeTextureSwap(short textureFrom)
    {
        short[] texturesFrom = currentComplexPanel.getTexturesFrom();
        short[] texturesTo = currentComplexPanel.getTexturesTo();

        int index = ArrayUtils.indexOf(texturesFrom, textureFrom);
        currentComplexPanel.setTexturesFrom(ArrayUtils.remove(texturesFrom, index));
        currentComplexPanel.setTexturesTo(ArrayUtils.remove(texturesTo, index));
    }

    private void replaceTextureSwap(short textureFrom, short newTextureTo)
    {
        short[] texturesFrom = currentComplexPanel.getTexturesFrom();
        short[] texturesTo = currentComplexPanel.getTexturesTo();

        int index = ArrayUtils.indexOf(texturesFrom, textureFrom);
        texturesTo[index] = newTextureTo;
    }

    public void removeAllTextureSwaps()
    {
        currentComplexPanel.setTexturesFrom(new short[0]);
        currentComplexPanel.setTexturesTo(new short[0]);
    }

    public void copyColoursTextures(ComplexPanel complexPanel)
    {
       copiedColoursTextures = new short[][]{complexPanel.getColoursFrom(), complexPanel.getColoursTo(), complexPanel.getTexturesFrom(), complexPanel.getTexturesTo()};
    }

    public void pasteColoursTextures(ComplexPanel complexPanel)
    {
        pasteColourSwaps(
                complexPanel,
                copiedColoursTextures[0],
                copiedColoursTextures[1]);

        pasteTextureSwaps(
                complexPanel,
                copiedColoursTextures[2],
                copiedColoursTextures[3]);

        if (currentComplexPanel == complexPanel)
            onSwapperPressed(complexPanel);
    }

    public void clearColoursTextures(ComplexPanel complexPanel)
    {
        if (currentComplexPanel == complexPanel)
        {
            unsetAllColours();
            unsetAllTextures();
            return;
        }

        complexPanel.setColoursFrom(new short[0]);
        complexPanel.setColoursTo(new short[0]);
        complexPanel.setTexturesFrom(new short[0]);
        complexPanel.setTexturesTo(new short[0]);
    }
}

package com.creatorskit.swing.colours;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@AllArgsConstructor
@Getter
@Setter
public class ColourPanel extends JPanel
{
    private boolean colourSet;
    private short oldColour;
    private short newColour;
    private JLabel oldColourLabel;
    private JButton newColourButton;
    private JSpinner spinner;
}

package com.creatorskit.swing.colours;

import java.awt.Color;

// Credits to Yona-Appletree: https://gist.github.com/Yona-Appletree/0c4b58763f070ae8cdff7db583c82563

/**
 *  The HSLColor class provides methods to manipulate HSL (Hue, Saturation
 *  Luminance) values to create a corresponding Color object using the RGB
 *  ColorSpace.
 *
 *  The HUE is the color, the Saturation is the purity of the color (with
 *  respect to grey) and Luminance is the brightness of the color (with respect
 *  to black and white)
 *
 *  The Hue is specified as an angel between 0 - 360 degrees where red is 0,
 *  green is 120 and blue is 240. In between you have the colors of the rainbow.
 *  Saturation is specified as a percentage between 0 - 100 where 100 is fully
 *  saturated and 0 approaches gray. Luminance is specified as a percentage
 *  between 0 - 100 where 0 is black and 100 is white.
 *
 *  In particular the HSL color space makes it easier change the Tone or Shade
 *  of a color by adjusting the luminance value.
 */
public class HSLColor
{
    private Color rgb;
    private float[] hsl;
    private float alpha;

    /**
     *  Create a HSLColor object using an RGB Color object.
     *
     *  @param rgb the RGB Color object
     */
    public HSLColor(Color rgb)
    {
        this.rgb = rgb;
        hsl = fromRGB( rgb );
        alpha = rgb.getAlpha() / 255.0f;
    }

    /**
     *  Create a HSLColor object using individual HSL values and a default
     * alpha value of 1.0.
     *
     *  @param h is the Hue value in degrees between 0 - 360
     *  @param s is the Saturation percentage between 0 - 100
     *  @param l is the Lumanance percentage between 0 - 100
     */
    public HSLColor(float h, float s, float l)
    {
        this(h, s, l, 1.0f);
    }

    /**
     *  Create a HSLColor object using individual HSL values.
     *
     *  @param h     the Hue value in degrees between 0 - 360
     *  @param s     the Saturation percentage between 0 - 100
     *  @param l     the Lumanance percentage between 0 - 100
     *  @param alpha the alpha value between 0 - 1
     */
    public HSLColor(float h, float s, float l, float alpha)
    {
        hsl = new float[] {h, s, l};
        this.alpha = alpha;
        rgb = toRGB(hsl, alpha);
    }

    /**
     *  Create a HSLColor object using an an array containing the
     *  individual HSL values and with a default alpha value of 1.
     *
     *  @param hsl  array containing HSL values
     */
    public HSLColor(float[] hsl)
    {
        this(hsl, 1.0f);
    }

    /**
     *  Create a HSLColor object using an an array containing the
     *  individual HSL values.
     *
     *  @param hsl  array containing HSL values
     *  @param alpha the alpha value between 0 - 1
     */
    public HSLColor(float[] hsl, float alpha)
    {
        this.hsl = hsl;
        this.alpha = alpha;
        rgb = toRGB(hsl, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Hue value. The degrees specified is an absolute value.
     *
     *  @param degrees - the Hue value between 0 - 360
     *  @return the RGB Color object
     */
    public Color adjustHue(float degrees)
    {
        return toRGB(degrees, hsl[1], hsl[2], alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Luminance value. The percent specified is an absolute value.
     *
     *  @param percent - the Luminance value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustLuminance(float percent)
    {
        return toRGB(hsl[0], hsl[1], percent, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Saturation value. The percent specified is an absolute value.
     *
     *  @param percent - the Saturation value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustSaturation(float percent)
    {
        return toRGB(hsl[0], percent, hsl[2], alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Shade. Changing the shade will return a darker color. The percent
     *  specified is a relative value.
     *
     *  @param percent - the value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustShade(float percent)
    {
        float multiplier = (100.0f - percent) / 100.0f;
        float l = Math.max(0.0f, hsl[2] * multiplier);

        return toRGB(hsl[0], hsl[1], l, alpha);
    }

    /**
     *  Create a RGB Color object based on this HSLColor with a different
     *  Tone. Changing the tone will return a lighter color. The percent
     *  specified is a relative value.
     *
     *  @param percent - the value between 0 - 100
     *  @return the RGB Color object
     */
    public Color adjustTone(float percent)
    {
        float multiplier = (100.0f + percent) / 100.0f;
        float l = Math.min(100.0f, hsl[2] * multiplier);

        return toRGB(hsl[0], hsl[1], l, alpha);
    }

    /**
     *  Get the Alpha value.
     *
     *  @return the Alpha value.
     */
    public float getAlpha()
    {
        return alpha;
    }

    /**
     *  Create a RGB Color object that is the complementary color of this
     *  HSLColor. This is a convenience method. The complementary color is
     *  determined by adding 180 degrees to the Hue value.
     *  @return the RGB Color object
     */
    public Color getComplementary()
    {
        float hue = (hsl[0] + 180.0f) % 360.0f;
        return toRGB(hue, hsl[1], hsl[2]);
    }

    /**
     *  Get the Hue value.
     *
     *  @return the Hue value.
     */
    public float getHue()
    {
        return hsl[0];
    }

    /**
     *  Get the HSL values.
     *
     *  @return the HSL values.
     */
    public float[] getHSL()
    {
        return hsl;
    }

    /**
     *  Get the Luminance value.
     *
     *  @return the Luminance value.
     */
    public float getLuminance()
    {
        return hsl[2];
    }

    /**
     *  Get the RGB Color object represented by this HDLColor.
     *
     *  @return the RGB Color object.
     */
    public Color getRGB()
    {
        return rgb;
    }

    /**
     *  Get the Saturation value.
     *
     *  @return the Saturation value.
     */
    public float getSaturation()
    {
        return hsl[1];
    }

    public String toString()
    {
        String toString =
                "HSLColor[h=" + hsl[0] +
                        ",s=" + hsl[1] +
                        ",l=" + hsl[2] +
                        ",alpha=" + alpha + "]";

        return toString;
    }

    /**
     *  Convert a RGB Color to it corresponding HSL values.
     *
     *  @return an array containing the 3 HSL values.
     */
    public static float[] fromRGB(Color color)
    {
        //  Get RGB values in the range 0 - 1

        float[] rgb = color.getRGBColorComponents( null );
        float r = rgb[0];
        float g = rgb[1];
        float b = rgb[2];

        //	Minimum and Maximum RGB values are used in the HSL calculations

        float min = Math.min(r, Math.min(g, b));
        float max = Math.max(r, Math.max(g, b));

        //  Calculate the Hue

        float h = 0;

        if (max == min)
            h = 0;
        else if (max == r)
            h = ((60 * (g - b) / (max - min)) + 360) % 360;
        else if (max == g)
            h = (60 * (b - r) / (max - min)) + 120;
        else if (max == b)
            h = (60 * (r - g) / (max - min)) + 240;

        //  Calculate the Luminance

        float l = (max + min) / 2;

        //  Calculate the Saturation

        float s = 0;

        if (max == min)
            s = 0;
        else if (l <= .5f)
            s = (max - min) / (max + min);
        else
            s = (max - min) / (2 - max - min);

        return new float[] {h, s * 100, l * 100};
    }

    /**
     *  Convert HSL values to a RGB Color with a default alpha value of 1.
     *  H (Hue) is specified as degrees in the range 0 - 360.
     *  S (Saturation) is specified as a percentage in the range 1 - 100.
     *  L (Lumanance) is specified as a percentage in the range 1 - 100.
     *
     *  @param hsl an array containing the 3 HSL values
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float[] hsl)
    {
        return toRGB(hsl, 1.0f);
    }

    /**
     *  Convert HSL values to a RGB Color.
     *  H (Hue) is specified as degrees in the range 0 - 360.
     *  S (Saturation) is specified as a percentage in the range 1 - 100.
     *  L (Lumanance) is specified as a percentage in the range 1 - 100.
     *
     *  @param hsl    an array containing the 3 HSL values
     *  @param alpha  the alpha value between 0 - 1
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float[] hsl, float alpha)
    {
        return toRGB(hsl[0], hsl[1], hsl[2], alpha);
    }

    /**
     *  Convert HSL values to a RGB Color with a default alpha value of 1.
     *
     *  @param h Hue is specified as degrees in the range 0 - 360.
     *  @param s Saturation is specified as a percentage in the range 1 - 100.
     *  @param l Lumanance is specified as a percentage in the range 1 - 100.
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float h, float s, float l)
    {
        return toRGB(h, s, l, 1.0f);
    }

    /**
     *  Convert HSL values to a RGB Color.
     *
     *  @param h Hue is specified as degrees in the range 0 - 360.
     *  @param s Saturation is specified as a percentage in the range 1 - 100.
     *  @param l Lumanance is specified as a percentage in the range 1 - 100.
     *  @param alpha  the alpha value between 0 - 1
     *
     *  @return the RGB Color object
     */
    public static Color toRGB(float h, float s, float l, float alpha)
    {
        if (s <0.0f || s > 100.0f)
        {
            String message = "Color parameter outside of expected range - Saturation";
            throw new IllegalArgumentException( message );
        }

        if (l <0.0f || l > 100.0f)
        {
            String message = "Color parameter outside of expected range - Luminance";
            throw new IllegalArgumentException( message );
        }

        if (alpha <0.0f || alpha > 1.0f)
        {
            String message = "Color parameter outside of expected range - Alpha";
            throw new IllegalArgumentException( message );
        }

        //  Formula needs all values between 0 - 1.

        h = h % 360.0f;
        h /= 360f;
        s /= 100f;
        l /= 100f;

        float q = 0;

        if (l < 0.5)
            q = l * (1 + s);
        else
            q = (l + s) - (s * l);

        float p = 2 * l - q;

        float r = Math.max(0, HueToRGB(p, q, h + (1.0f / 3.0f)));
        float g = Math.max(0, HueToRGB(p, q, h));
        float b = Math.max(0, HueToRGB(p, q, h - (1.0f / 3.0f)));

        r = Math.min(r, 1.0f);
        g = Math.min(g, 1.0f);
        b = Math.min(b, 1.0f);

        return new Color(r, g, b, alpha);
    }

    private static float HueToRGB(float p, float q, float h)
    {
        if (h < 0) h += 1;

        if (h > 1 ) h -= 1;

        if (6 * h < 1)
        {
            return p + ((q - p) * 6 * h);
        }

        if (2 * h < 1 )
        {
            return  q;
        }

        if (3 * h < 2)
        {
            return p + ( (q - p) * 6 * ((2.0f / 3.0f) - h) );
        }

        return p;
    }
}
package com.creatorskit.swing.colours;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@AllArgsConstructor
@Getter
@Setter
public class TexturePanel extends JPanel
{
    private boolean textureSet;
    private short oldTexture;
    private short newTexture;
    private JLabel oldTextureLabel;
    private JButton newTextureButton;
    private JSpinner spinner;
}

package com.creatorskit.swing;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.*;
import com.creatorskit.models.datatypes.*;
import com.creatorskit.swing.searchabletable.JFilterableTable;
import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import net.runelite.api.Model;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.List;

public class CacheSearcherTab extends JPanel
{
    private final CreatorsPlugin plugin;
    private ClientThread clientThread;
    private final DataFinder dataFinder;

    private final GridBagConstraints c = new GridBagConstraints();
    private final String NPC = "NPC";
    private final String OBJECT = "OBJECT";
    private final String ITEM = "ITEM";
    private final String ANIM = "ANIM";
    private final String SPOTANIM = "SPOTANIM";

    private final JPanel npcPanel = new JPanel();
    private final JPanel objectPanel = new JPanel();
    private final JPanel itemPanel = new JPanel();
    private final JPanel animPanel = new JPanel();
    private final JPanel spotAnimPanel = new JPanel();

    private final JFilterableTable npcTable = new JFilterableTable("NPCs");
    private final JFilterableTable objectTable = new JFilterableTable("Objects");
    private final JFilterableTable itemTable = new JFilterableTable("Items");
    private final JFilterableTable animTable = new JFilterableTable("Animations");
    private final JFilterableTable spotAnimTable = new JFilterableTable("SpotAnims");

    private final JComboBox<CustomModelType> itemType = new JComboBox<>();

    private final JPanel display = new JPanel();

    @Inject
    public CacheSearcherTab(CreatorsPlugin plugin, ClientThread clientThread, DataFinder dataFinder)
    {
        this.plugin = plugin;
        this.clientThread = clientThread;
        this.dataFinder = dataFinder;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new GridBagLayout());

        setupNPCPanel();
        setupObjectPanel();
        setupItemPanel();
        setupAnimPanel();
        setupSpotAnimPanel();
        setupDisplay();
        setupLayout();
    }

    private void setupDisplay()
    {
        display.setLayout(new CardLayout());
        display.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));

        JPanel npcCard = new JPanel();
        setupNPCCard(npcCard);
        display.add(npcCard, NPC);

        JPanel objectCard = new JPanel();
        setupObjectCard(objectCard);
        display.add(objectCard, OBJECT);

        JPanel itemCard = new JPanel();
        setupItemCard(itemCard);
        display.add(itemCard, ITEM);

        JPanel spotAnimCard = new JPanel();
        setupSpotAnimCard(spotAnimCard);
        display.add(spotAnimCard, SPOTANIM);

        JPanel animCard = new JPanel();
        setupAnimCard(animCard);
        display.add(animCard, ANIM);
    }

    private void setupLayout()
    {
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 2;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel empty = new JLabel("");
        empty.setFocusable(true);
        add(empty, c);

        c.gridwidth = 1;
        c.weightx = 2;
        c.weighty = 0;
        c.gridx = 1;
        c.gridy = 1;
        add(npcPanel, c);

        c.gridx = 1;
        c.gridy = 2;
        add(objectPanel, c);

        c.gridx = 1;
        c.gridy = 3;
        add(itemPanel, c);

        c.gridx = 1;
        c.gridy = 4;
        add(spotAnimPanel, c);

        c.gridx = 1;
        c.gridy = 5;
        add(animPanel, c);

        c.gridx = 1;
        c.gridy = 6;
        add(new JLabel(""), c);

        c.gridheight = 6;
        c.weighty = 5;
        c.weightx = 2;
        c.gridx = 2;
        c.gridy = 1;
        add(display, c);

        c.weighty = 1;
        c.weightx = 2;
        c.gridx = 3;
        c.gridy = 7;
        add(new JLabel(""), c);

        repaint();
        revalidate();
    }

    private void setupNPCCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(8, 8, 8, 8));
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("NPCs Found:");
        title.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32));
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane(npcTable);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        card.add(scrollPane, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 2;
        JLabel buffer = new JLabel(" ");
        card.add(buffer, c);

        c.gridx = 0;
        c.gridy = 3;
        JPanel grid = new JPanel();
        grid.setLayout(new GridLayout(0, 4, 2, 0));
        card.add(grid, c);

        JButton addObject = new JButton("Store & Add");
        addObject.setToolTipText("Stores the selected NPC as a Custom Model, then creates a new Object and attaches the model");
        grid.add(addObject);

        JButton addObjectAnim = new JButton("Store/Add/Animate");
        addObjectAnim.setToolTipText("Stores the selected NPC as a Custom Model, then creates a new Object and attaches the model," +
                "<br>and creates an Animation KeyFrame with the appropriate NPC animations");
        grid.add(addObjectAnim);

        JButton addModel = new JButton("Store Only");
        addModel.setToolTipText("Stores the selected NPC as a new Custom Model");
        grid.add(addModel);

        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the NPC's models to the Model Anvil");
        grid.add(addAnvil);

        addObject.addActionListener(e ->
        {
            Object o = npcTable.getSelectedObject();
            if (o instanceof NPCData)
            {
                NPCData data = (NPCData) o;
                addNPCObject(data, false);
            }
        });

        addObjectAnim.addActionListener(e ->
        {
            Object o = npcTable.getSelectedObject();
            if (o instanceof NPCData)
            {
                NPCData data = (NPCData) o;
                addNPCObject(data, true);
            }
        });

        addModel.addActionListener(e ->
        {
            Object o = npcTable.getSelectedObject();
            if (o instanceof NPCData)
            {
                NPCData data = (NPCData) o;
                addCustomModel(CustomModelType.CACHE_NPC, data.getId());
            }
        });

        addAnvil.addActionListener(e ->
        {
            Object o = npcTable.getSelectedObject();
            if (o instanceof NPCData)
            {
                NPCData data = (NPCData) o;
                addToAnvil(CustomModelType.CACHE_NPC, data.getId());
            }
        });

        c.gridx = 0;
        c.gridy = 4;
        JPanel anims = new JPanel();
        anims.setLayout(new GridLayout(0, 3, 2, 2));
        anims.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        anims.setBorder(new EmptyBorder(8, 8, 8, 8));
        card.add(anims, c);

        JLabel idle = new JLabel("Idle: -1");
        JLabel walk180 = new JLabel("Walk 180: -1");
        JLabel walk = new JLabel("Walk: -1");
        JLabel walkRight = new JLabel("Walk Right: -1");
        JLabel walkLeft = new JLabel("Walk Left: -1");
        JLabel idleRight = new JLabel("Idle Right: -1");
        JLabel idleLeft = new JLabel("Idle Left: -1");
        JLabel run = new JLabel("Run: -1");
        anims.add(idle);
        anims.add(walk180);
        anims.add(new JLabel(""));
        anims.add(walk);
        anims.add(walkRight);
        anims.add(idleRight);
        anims.add(run);
        anims.add(walkLeft);
        anims.add(idleLeft);

        npcTable.getSelectionModel().addListSelectionListener(e ->
        {
            Object o = npcTable.getSelectedObject();
            if (o instanceof NPCData)
            {
                NPCData data = (NPCData) o;

                idle.setText("Idle: " + data.getStandingAnimation());
                walk.setText("Walk: " + data.getWalkingAnimation());
                run.setText("Run: " + data.getRunAnimation());
                walk180.setText("Walk 180: " + data.getRotate180Animation());
                walkRight.setText("Walk Right: " + data.getRotateRightAnimation());
                walkLeft.setText("Walk Left: " + data.getRotateLeftAnimation());
                idleRight.setText("Idle Right: " + data.getIdleRotateRightAnimation());
                idleLeft.setText("Idle Left: " + data.getIdleRotateLeftAnimation());
            }
        });
    }

    private void setupObjectCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(8, 8, 8, 8));
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Objects Found:");
        title.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32));
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane(objectTable);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        card.add(scrollPane, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel buffer = new JLabel(" ");
        card.add(buffer, c);

        c.gridx = 0;
        c.gridy = 3;
        JPanel grid = new JPanel();
        grid.setLayout(new GridLayout(0, 3, 2, 0));
        card.add(grid, c);

        JButton addObject = new JButton("Store & Add");
        addObject.setToolTipText("Stores the selected Object as a Custom Model, then creates a new Object and attaches the model");
        grid.add(addObject);

        JButton addModel = new JButton("Store Only");
        addModel.setToolTipText("Stores the selected Object as a new Custom Model");
        grid.add(addModel);

        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the Object's models to the Model Anvil");
        grid.add(addAnvil);

        addObject.addActionListener(e ->
        {
            Object o = objectTable.getSelectedObject();
            if (o instanceof ObjectData)
            {
                ObjectData data = (ObjectData) o;
                addObjectObject(data);
            }
        });

        addModel.addActionListener(e ->
        {
            Object o = objectTable.getSelectedObject();
            if (o instanceof ObjectData)
            {
                ObjectData data = (ObjectData) o;
                addCustomModel(CustomModelType.CACHE_OBJECT, data.getId());
            }
        });

        addAnvil.addActionListener(e ->
        {
            Object o = objectTable.getSelectedObject();
            if (o instanceof ObjectData)
            {
                ObjectData data = (ObjectData) o;
                addToAnvil(CustomModelType.CACHE_OBJECT, data.getId());
            }
        });
    }

    private void setupItemCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(8, 8, 8, 8));
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Items Found:");
        title.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32));
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane(itemTable);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        card.add(scrollPane, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel buffer = new JLabel(" ");
        card.add(buffer, c);

        c.gridx = 0;
        c.gridy = 3;
        JPanel grid = new JPanel();
        grid.setLayout(new GridLayout(0, 4, 2, 0));
        card.add(grid, c);

        JButton addObject = new JButton("Store & Add");
        addObject.setToolTipText("Stores the selected Item as a Custom Model, then creates a new Object and attaches the model");
        grid.add(addObject);

        JButton addKeyFrame = new JButton("KeyFrame Animation");
        addKeyFrame.setToolTipText("Finds the animations for the given item (if a weapon) and applies it to the currently selected Object as an Animation KeyFrame");
        grid.add(addKeyFrame);

        JButton addModel = new JButton("Store Only");
        addModel.setToolTipText("Stores the selected Item as a new Custom Model");
        grid.add(addModel);

        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the Item's models to the Model Anvil");
        grid.add(addAnvil);

        addObject.addActionListener(e ->
        {
            Object o = itemTable.getSelectedObject();
            if (o instanceof ItemData)
            {
                CustomModelType type = (CustomModelType) itemType.getSelectedItem();
                ItemData data = (ItemData) o;
                addItemObject(data, type);
            }
        });

        addKeyFrame.addActionListener(e ->
        {
            if (plugin.getSelectedCharacter() == null)
            {
                return;
            }

            Object o = itemTable.getSelectedObject();
            if (o instanceof ItemData)
            {
                ItemData data = (ItemData) o;
                int itemId = data.getId();
                WeaponAnimData weaponAnimData = dataFinder.findWeaponAnimData(itemId);
                if (weaponAnimData == null)
                {
                    return;
                }

                plugin.getCreatorsPanel().getToolBox().getTimeSheetPanel().addAnimationKeyFrameFromCache(weaponAnimData);
            }
        });

        addModel.addActionListener(e ->
        {
            Object o = itemTable.getSelectedObject();
            if (o instanceof ItemData)
            {
                CustomModelType type = (CustomModelType) itemType.getSelectedItem();
                ItemData data = (ItemData) o;
                addCustomModel(type, data.getId());
            }
        });

        addAnvil.addActionListener(e ->
        {
            Object o = itemTable.getSelectedObject();
            if (o instanceof ItemData)
            {
                CustomModelType type = (CustomModelType) itemType.getSelectedItem();
                ItemData data = (ItemData) o;
                addToAnvil(type, data.getId());
            }
        });


        c.gridx = 0;
        c.gridy = 4;
        JPanel anims = new JPanel();
        anims.setLayout(new GridLayout(0, 3, 2, 2));
        anims.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        anims.setBorder(new EmptyBorder(8, 8, 8, 8));
        card.add(anims, c);

        JLabel idle = new JLabel("Idle: -1");
        JLabel walk180 = new JLabel("Walk 180: -1");
        JLabel walk = new JLabel("Walk: -1");
        JLabel walkRight = new JLabel("Walk Right: -1");
        JLabel walkLeft = new JLabel("Walk Left: -1");
        JLabel idleRight = new JLabel("Idle Right: -1");
        JLabel idleLeft = new JLabel("Idle Left: -1");
        JLabel run = new JLabel("Run: -1");
        JLabel special = new JLabel("Special: -1");
        JLabel stab = new JLabel("Stab: -1");
        JLabel slash = new JLabel("Slash: -1");
        JLabel crush = new JLabel("Crush: -1");
        JLabel slash2 = new JLabel("Slash2: -1");
        JLabel crush2 = new JLabel("Crush2: -1");
        JLabel defend = new JLabel("Defend: -1");
        anims.add(idle);
        anims.add(walk180);
        anims.add(new JLabel(""));
        anims.add(walk);
        anims.add(walkRight);
        anims.add(idleRight);
        anims.add(run);
        anims.add(walkLeft);
        anims.add(idleLeft);
        anims.add(special);
        anims.add(defend);
        anims.add(new JLabel(""));
        anims.add(stab);
        anims.add(slash);
        anims.add(crush);
        anims.add(new JLabel(""));
        anims.add(slash2);
        anims.add(crush2);

        itemTable.getSelectionModel().addListSelectionListener(e ->
        {
            Object o = itemTable.getSelectedObject();
            if (o instanceof ItemData)
            {
                ItemData data = (ItemData) o;
                int itemId = data.getId();

                boolean foundMatch = false;

                List<WeaponAnimData> weaponAnimSets = dataFinder.getWeaponAnimData();
                for (WeaponAnimData weaponAnim : weaponAnimSets)
                {
                    int[] ids = weaponAnim.getId();
                    if (ids == null || ids.length == 0)
                    {
                        continue;
                    }

                    for (int i : ids)
                    {
                        if (i == itemId)
                        {
                            idle.setText("Idle: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE));
                            walk.setText("Walk: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.WALK));
                            run.setText("Run: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.RUN));
                            walk180.setText("Walk 180: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_180));
                            walkRight.setText("Walk Right: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_RIGHT));
                            walkLeft.setText("Walk Left: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_LEFT));
                            idleRight.setText("Idle Right: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_RIGHT));
                            idleLeft.setText("Idle Left: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_LEFT));
                            special.setText("Special: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.SPECIAL));
                            stab.setText("Stab: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.STAB));
                            slash.setText("Slash: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.SLASH));
                            crush.setText("Crush: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.CRUSH));
                            slash2.setText("Slash2: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.SLASH_2));
                            crush2.setText("Crush2: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.CRUSH_2));
                            defend.setText("Defend: " + WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.DEFEND));
                            foundMatch = true;
                            break;
                        }
                    }

                    if (foundMatch)
                    {
                        break;
                    }
                }

                if (!foundMatch)
                {
                    idle.setText("Idle: " + -1);
                    walk.setText("Walk: " + -1);
                    run.setText("Run: " + -1);
                    walk180.setText("Walk 180: " + -1);
                    walkRight.setText("Walk Right: " + -1);
                    walkLeft.setText("Walk Left: " + -1);
                    idleRight.setText("Idle Right: " + -1);
                    idleLeft.setText("Idle Left: " + -1);
                    special.setText("Special: " + -1);
                    stab.setText("Stab: " + -1);
                    slash.setText("Slash: " + -1);
                    crush.setText("Crush: " + -1);
                    slash2.setText("Slash2: " + -1);
                    crush2.setText("Crush2: " + -1);
                    defend.setText("Defend: " + -1);
                }
            }
        });
    }

    private void setupSpotAnimCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(8, 8, 8, 8));
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("SpotAnims Found:");
        title.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32));
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane(spotAnimTable);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        card.add(scrollPane, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel buffer = new JLabel("                                                    ");
        card.add(buffer, c);

        c.gridx = 0;
        c.gridy = 3;
        JPanel grid = new JPanel();
        grid.setLayout(new GridLayout(0, 4, 2, 0));
        card.add(grid, c);

        JButton addObject = new JButton("Store & Add");
        addObject.setToolTipText("Stores the selected SpotAnim as a Custom Model, then creates a new Object and attaches the model");
        grid.add(addObject);

        JButton addKeyFrame = new JButton("KeyFrame SpotAnim");
        addKeyFrame.setToolTipText("Adds the currently selected SpotAnim as a KeyFrame to the currently selected Object");
        grid.add(addKeyFrame);

        JButton addModel = new JButton("Store Only");
        addModel.setToolTipText("Stores the selected SpotAnim as a new Custom Model");
        grid.add(addModel);

        JButton addAnvil = new JButton("Add to Anvil");
        addAnvil.setToolTipText("Sends the SpotAnim's models to the Model Anvil");
        grid.add(addAnvil);

        addObject.addActionListener(e ->
        {
            Object o = spotAnimTable.getSelectedObject();
            if (o instanceof SpotanimData)
            {
                SpotanimData data = (SpotanimData) o;
                addSpotAnimObject(data);
            }
        });

        addKeyFrame.addActionListener(e ->
        {
            if (plugin.getSelectedCharacter() == null)
            {
                return;
            }

            Object o = spotAnimTable.getSelectedObject();
            if (o instanceof SpotanimData)
            {
                SpotanimData data = (SpotanimData) o;
                plugin.getCreatorsPanel().getToolBox().getTimeSheetPanel().addSpotAnimKeyFrameFromCache(data);
            }
        });

        addModel.addActionListener(e ->
        {
            Object o = spotAnimTable.getSelectedObject();
            if (o instanceof SpotanimData)
            {
                SpotanimData data = (SpotanimData) o;
                addCustomModel(CustomModelType.CACHE_SPOTANIM, data.getId());
            }
        });

        addAnvil.addActionListener(e ->
        {
            Object o = spotAnimTable.getSelectedObject();
            if (o instanceof SpotanimData)
            {
                SpotanimData data = (SpotanimData) o;
                addToAnvil(CustomModelType.CACHE_SPOTANIM, data.getId());
            }
        });
    }

    private void setupAnimCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(8, 8, 8, 8));
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Animations Found:");
        title.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32));
        title.setHorizontalAlignment(SwingConstants.LEFT);
        card.add(title, c);

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        JScrollPane scrollPane = new JScrollPane(animTable);
        scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        card.add(scrollPane, c);

        animTable.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
                {
                    Object o = animTable.getSelectedObject();
                    if (o instanceof AnimData)
                    {
                        AnimData data = (AnimData) o;
                        Character character = plugin.getSelectedCharacter();
                        if (character != null)
                        {
                            int animId = data.getId();
                            character.getAnimationSpinner().setValue(animId);
                        }
                    }
                }
            }
        });

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 2;
        JLabel buffer = new JLabel(" ");
        card.add(buffer, c);

        c.gridx = 0;
        c.gridy = 3;
        JLabel instructionLabel = new JLabel("Double click any Animation to set it to the currently selected Object");
        card.add(instructionLabel, c);
    }

    private void switchCards(String cardName)
    {
        CardLayout cl = (CardLayout) (display.getLayout());
        cl.show(display, cardName);
    }

    private void setupNPCPanel()
    {
        npcPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        npcPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        npcPanel.setLayout(new BorderLayout());
        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        npcPanel.add(holderPanel, BorderLayout.CENTER);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("NPC Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 1;
        JLabel nameLabel = new JLabel("NPC name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(nameLabel, c);

        c.gridwidth = 1;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 1;
        JTextField field = new JTextField("");
        field.setFont(FontManager.getRunescapeBoldFont());
        field.setForeground(ColorScheme.BRAND_ORANGE);
        holderPanel.add(field, c);

        field.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                switchCards(NPC);
            }

            @Override
            public void focusLost(FocusEvent e)
            {

            }
        });

        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                switchCards(NPC);
                String text = field.getText();
                npcTable.searchAndListEntries(text);
            }
        };
        field.addKeyListener(keyListener);

        if (dataFinder.isDataLoaded(DataFinder.DataType.NPC))
        {
            List<NPCData> dataList = dataFinder.getNpcData();
            List<Object> list = new ArrayList<>(dataList);
            npcTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.NPC, () ->
            {
                List<NPCData> dataList = dataFinder.getNpcData();
                List<Object> list = new ArrayList<>(dataList);
                npcTable.initialize(list);
            });
        }
    }

    private void setupObjectPanel()
    {
        objectPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        objectPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        objectPanel.setLayout(new BorderLayout());
        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        objectPanel.add(holderPanel, BorderLayout.CENTER);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Object Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 1;
        JLabel nameLabel = new JLabel("Object name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(nameLabel, c);

        c.gridwidth = 1;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 1;
        JTextField field = new JTextField("");
        field.setFont(FontManager.getRunescapeBoldFont());
        field.setForeground(ColorScheme.BRAND_ORANGE);
        holderPanel.add(field, c);

        field.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                switchCards(OBJECT);
            }

            @Override
            public void focusLost(FocusEvent e)
            {

            }
        });

        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                switchCards(OBJECT);
                String text = field.getText();
                objectTable.searchAndListEntries(text);
            }
        };
        field.addKeyListener(keyListener);

        if (dataFinder.isDataLoaded(DataFinder.DataType.OBJECT))
        {
            List<ObjectData> dataList = dataFinder.getObjectData();
            List<Object> list = new ArrayList<>(dataList);
            objectTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.OBJECT, () ->
            {
                List<ObjectData> dataList = dataFinder.getObjectData();
                List<Object> list = new ArrayList<>(dataList);
                objectTable.initialize(list);
            });
        }
    }

    private void setupItemPanel()
    {
        itemPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        itemPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        itemPanel.setLayout(new BorderLayout());
        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        itemPanel.add(holderPanel, BorderLayout.CENTER);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Item Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 1;
        JLabel modelTypeLabel = new JLabel("Model type: ");
        modelTypeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(modelTypeLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        itemType.setToolTipText("Set whether to search the cache for the Item's Ground model, Male worn model, or Female worn model");
        itemType.addItem(CustomModelType.CACHE_GROUND_ITEM);
        itemType.addItem(CustomModelType.CACHE_MAN_WEAR);
        itemType.addItem(CustomModelType.CACHE_WOMAN_WEAR);
        holderPanel.add(itemType, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 2;
        JLabel nameLabel = new JLabel("Item name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(nameLabel, c);

        c.gridwidth = 1;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 2;
        JTextField field = new JTextField("");
        field.setFont(FontManager.getRunescapeBoldFont());
        field.setForeground(ColorScheme.BRAND_ORANGE);
        holderPanel.add(field, c);

        field.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                switchCards(ITEM);
            }

            @Override
            public void focusLost(FocusEvent e)
            {

            }
        });

        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                switchCards(ITEM);
                String text = field.getText();
                itemTable.searchAndListEntries(text);
            }
        };
        field.addKeyListener(keyListener);

        if (dataFinder.isDataLoaded(DataFinder.DataType.ITEM))
        {
            List<ItemData> dataList = dataFinder.getItemData();
            List<Object> list = new ArrayList<>(dataList);
            itemTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.ITEM, () ->
            {
                List<ItemData> dataList = dataFinder.getItemData();
                List<Object> list = new ArrayList<>(dataList);
                itemTable.initialize(list);
            });
        }
    }

    private void setupSpotAnimPanel()
    {
        spotAnimPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        spotAnimPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        spotAnimPanel.setLayout(new BorderLayout());
        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        spotAnimPanel.add(holderPanel, BorderLayout.CENTER);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("SpotAnim Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 1;
        JLabel nameLabel = new JLabel("SpotAnim name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(nameLabel, c);

        c.gridwidth = 1;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 1;
        JTextField field = new JTextField("");
        field.setFont(FontManager.getRunescapeBoldFont());
        field.setForeground(ColorScheme.BRAND_ORANGE);
        holderPanel.add(field, c);

        field.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                switchCards(SPOTANIM);
            }

            @Override
            public void focusLost(FocusEvent e)
            {

            }
        });

        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                switchCards(SPOTANIM);
                String text = field.getText();
                spotAnimTable.searchAndListEntries(text);
            }
        };
        field.addKeyListener(keyListener);

        if (dataFinder.isDataLoaded(DataFinder.DataType.SPOTANIM))
        {
            List<SpotanimData> dataList = dataFinder.getSpotanimData();
            List<Object> list = new ArrayList<>(dataList);
            spotAnimTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.SPOTANIM, () ->
            {
                List<SpotanimData> dataList = dataFinder.getSpotanimData();
                List<Object> list = new ArrayList<>(dataList);
                spotAnimTable.initialize(list);
            });
        }
    }

    private void setupAnimPanel()
    {
        animPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        animPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        animPanel.setLayout(new BorderLayout());
        JPanel holderPanel = new JPanel();
        holderPanel.setBorder(new EmptyBorder(8, 8, 8, 8));
        holderPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        holderPanel.setLayout(new GridBagLayout());
        animPanel.add(holderPanel, BorderLayout.CENTER);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel title = new JLabel("Animation Searcher");
        title.setFont(FontManager.getRunescapeBoldFont());
        holderPanel.add(title, c);

        c.gridwidth = 1;
        c.weightx = 0;
        c.gridx = 0;
        c.gridy = 1;
        JLabel nameLabel = new JLabel("Animation name: ");
        nameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        holderPanel.add(nameLabel, c);

        c.gridwidth = 1;
        c.weightx = 1;
        c.gridx = 1;
        c.gridy = 1;
        JTextField field = new JTextField("");
        field.setFont(FontManager.getRunescapeBoldFont());
        field.setForeground(ColorScheme.BRAND_ORANGE);
        holderPanel.add(field, c);

        field.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {
                switchCards(ANIM);
            }

            @Override
            public void focusLost(FocusEvent e)
            {

            }
        });

        KeyListener keyListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                switchCards(ANIM);
                String text = field.getText();
                animTable.searchAndListEntries(text);
            }
        };
        field.addKeyListener(keyListener);

        if (dataFinder.isDataLoaded(DataFinder.DataType.ANIM))
        {
            List<AnimData> dataList = dataFinder.getAnimData();
            List<Object> list = new ArrayList<>(dataList);
            animTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.ANIM, () ->
            {
                List<AnimData> dataList = dataFinder.getAnimData();
                List<Object> list = new ArrayList<>(dataList);
                animTable.initialize(list);
            });
        }
    }

    private void addToAnvil(CustomModelType type, int id)
    {
        plugin.cacheToAnvil(type, id);
    }

    private void addCustomModel(CustomModelType type, int id)
    {
        plugin.cacheToCustomModel(type, id, -1);
    }

    private void addItemObject(int id, CustomModelType customModelType)
    {
        List<ItemData> data = dataFinder.getItemData();
        for (ItemData n : data)
        {
            if (n.getId() == id)
            {
                addItemObject(n, customModelType);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the Item you were looking for in the cache.");
    }

    private void addItemObject(ItemData data, CustomModelType customModelType)
    {
        ModelStats[] modelStats = dataFinder.findModelsForGroundItem(data.getId(), customModelType);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the Item you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            LightingStyle ls;

            switch (customModelType)
            {
                default:
                case CACHE_GROUND_ITEM:
                    ls = LightingStyle.DEFAULT;
                    break;
                case CACHE_MAN_WEAR:
                case CACHE_WOMAN_WEAR:
                    ls = LightingStyle.ACTOR;
            }

            CustomLighting lighting = new CustomLighting(
                    ls.getAmbient(),
                    ls.getContrast(),
                    ls.getX(),
                    ls.getY(),
                    ls.getZ());

            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, ls, lighting);

            CustomModelComp comp = new CustomModelComp(0, customModelType, data.getId(), modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    -1,
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    KeyFrameType.createDefaultSummary(),
                    creatorsPanel.getRandomColor(),
                    false,
                    null,
                    null,
                    -1,
                    false,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }

    private void addObjectObject(int id)
    {
        List<ObjectData> data = dataFinder.getObjectData();
        for (ObjectData n : data)
        {
            if (n.getId() == id)
            {
                addObjectObject(n);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the Object you were looking for in the cache.");
    }

    private void addObjectObject(ObjectData data)
    {
        ModelStats[] modelStats = dataFinder.findModelsForObject(data.getId(), -1, LightingStyle.DEFAULT, true);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the Object you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            CustomLighting lighting = new CustomLighting(64, 768, -50, -50, 10);
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, LightingStyle.DEFAULT, lighting);
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_OBJECT, data.getId(), modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    data.getAnimationId(),
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    KeyFrameType.createDefaultSummary(),
                    creatorsPanel.getRandomColor(),
                    false,
                    null,
                    null,
                    -1,
                    false,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }

    private void addNPCObject(int id)
    {
        List<NPCData> data = dataFinder.getNpcData();
        for (NPCData n : data)
        {
            if (n.getId() == id)
            {
                addNPCObject(n, false);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the NPC you were looking for in the cache.");
    }

    private void addNPCObject(NPCData data, boolean addAnimKeyFrame)
    {
        ModelStats[] modelStats = dataFinder.findModelsForNPC(data.getId());
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the NPC you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            CustomLighting lighting = new CustomLighting(64, 850, -30, -30, 50);
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, LightingStyle.ACTOR, lighting);
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_NPC, data.getId(), modelStats, null, null, null, LightingStyle.ACTOR, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    data.getStandingAnimation(),
                    -1,
                    data.getSize() * 60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    KeyFrameType.createDefaultSummary(),
                    creatorsPanel.getRandomColor(),
                    false,
                    null,
                    null,
                    -1,
                    false,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));

            if (addAnimKeyFrame)
            {
                AnimationKeyFrame keyFrame = new AnimationKeyFrame(
                        plugin.getCurrentTick(),
                        false,
                        -1,
                        0,
                        false,
                        false,
                        data.getStandingAnimation(),
                        data.getWalkingAnimation(),
                        data.getRunAnimation(),
                        data.getRotate180Animation(),
                        data.getRotateRightAnimation(),
                        data.getRotateLeftAnimation(),
                        data.getIdleRotateRightAnimation(),
                        data.getIdleRotateRightAnimation());

                character.setKeyFrames(new KeyFrame[]{keyFrame}, KeyFrameType.ANIMATION);
                creatorsPanel.getToolBox().getProgrammer().updateProgram(character);
            }
        });
    }

    private void addSpotAnimObject(int id)
    {
        List<SpotanimData> data = dataFinder.getSpotanimData();
        for (SpotanimData n : data)
        {
            if (n.getId() == id)
            {
                addSpotAnimObject(n);
                return;
            }
        }

        plugin.sendChatMessage("Could not find the SpotAnim you were looking for in the cache.");
    }

    private void addSpotAnimObject(SpotanimData data)
    {
        ModelStats[] modelStats = dataFinder.findSpotAnim(data);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find the SpotAnim you were looking for in the cache.");
            return;
        }

        clientThread.invokeLater(() ->
        {
            LightingStyle ls = LightingStyle.SPOTANIM;
            CustomLighting lighting = new CustomLighting(ls.getAmbient() + data.getAmbient(), ls.getContrast() + data.getContrast(), ls.getX(), ls.getY(), ls.getZ());
            Model model = plugin.constructModelFromCache(modelStats, new int[0], false, LightingStyle.CUSTOM, lighting);
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_SPOTANIM, data.getId(), modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, data.getName());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, false);

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    data.getName(),
                    7699,
                    customModel,
                    true,
                    0,
                    data.getAnimationId(),
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    KeyFrameType.createDefaultSummary(),
                    creatorsPanel.getRandomColor(),
                    false,
                    null,
                    null,
                    -1,
                    false,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
    }
}

package com.creatorskit.swing;

public enum ParentPanel
{
    MANAGER,
    SIDE_PANEL
}

package com.creatorskit.swing.searchabletable;

import lombok.Setter;

import javax.swing.table.AbstractTableModel;

@Setter
public class DataTableModel extends AbstractTableModel
{
    private Object[] data;

    public DataTableModel(Object[] data)
    {
        super();
        this.data = data;
    }

    public int getColumnCount()
    {
        return 1;
    }

    public int getRowCount()
    {
        return data.length;
    }

    public Object getValueAt(int row, int col)
    {
        return data[row];
    }

}

package com.creatorskit.swing.searchabletable;

import javax.swing.*;
import javax.swing.table.JTableHeader;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

public class JFilterableTable extends JTable
{
    private List<Object> itemBackup;

    public JFilterableTable(String name)
    {
        super();
        this.setName(name);
        this.setDefaultRenderer(Object.class, new JFilterableRenderer());
        this.setTableHeader(new JTableHeader());
        setModel(new DataTableModel(new Object[0]));
    }

    public void initialize(List<Object> list)
    {
        itemBackup = list;
    }

    public void searchAndListEntries(Object searchFor)
    {
        List<Object> found = new ArrayList<>();

        //showingAll = false;
        for (int i = 0; i < this.itemBackup.size(); i++)
        {
            Object tmp = this.itemBackup.get(i);
            if (tmp == null || searchFor == null)
            {
                continue;
            }

            String s = tmp.toString();

            if (searchFor instanceof String)
            {
                String search = (String) searchFor;
                if (s.matches("(?i).*" + Pattern.quote(search) + ".*"))
                {
                    found.add(new Object[]{tmp, searchFor});
                }
            }
        }

        setModel(new DataTableModel(found.toArray()));
    }

    public Object getSelectedObject()
    {
        int row = getSelectedRow();
        if (row == -1)
        {
            return null;
        }

        Object[] o = (Object[]) this.getModel().getValueAt(row, 0);
        return o[0];
    }
}

package com.creatorskit.swing.searchabletable;

import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import javax.swing.table.TableCellRenderer;
import java.awt.*;
import java.util.ArrayList;

public class JFilterableRenderer extends JLabel implements TableCellRenderer
{
    @Override
    public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column)
    {
        Object[] v = (Object[]) value;
        String s = v[0].toString();
        String lowerS = s.toLowerCase();
        String sf = v[1].toString();
        String lowerSf = sf.toLowerCase();
        ArrayList<String> notMatching = new ArrayList<>();

        if (!sf.equals(""))
        {
            int fs = -1;
            int lastFs = 0;
            while ((fs = lowerS.indexOf(lowerSf, (lastFs == 0) ? -1 : lastFs)) > -1)
            {
                notMatching.add(s.substring(lastFs, fs));
                lastFs = fs + sf.length();
            }
            notMatching.add(s.substring(lastFs));
        }

        String html = "";
        if (notMatching.size() > 1)
        {
            html = notMatching.get(0);
            int start = html.length();
            int sfl = sf.length();
            for (int i = 1; i < notMatching.size(); i++)
            {
                String t = notMatching.get(i);
                html += "<b style=\"color: orange;\">" + s.substring(start, start + sfl) + "</b>" + t;
                start += sfl + t.length();
            }
        }

        if (html.isEmpty())
        {
            html = s;
        }

        this.setText("<html><head></head><body style=\"color: gray;\">" + html + "</body></head>");

        if (isSelected)
        {
            setOpaque(true);
            setBackground(Color.DARK_GRAY);
        }
        else
        {
            setBackground(ColorScheme.DARKER_GRAY_COLOR);
        }
        return this;
    }
}

package com.creatorskit.swing;

import com.creatorskit.CKObject;
import com.creatorskit.saves.CharacterSave;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.Character;
import com.creatorskit.saves.FolderNodeSave;
import com.creatorskit.saves.ModelKeyFrameSave;
import com.creatorskit.saves.SetupSave;
import com.creatorskit.models.*;
import com.creatorskit.swing.anvil.ModelAnvil;
import com.creatorskit.swing.manager.Folder;
import com.creatorskit.swing.manager.FolderType;
import com.creatorskit.swing.manager.ManagerPanel;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Model;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.ArrayUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.filechooser.FileFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreeNode;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.time.LocalTime;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Slf4j
@Getter
public class CreatorsPanel extends PluginPanel
{
    private ClientThread clientThread;
    private final Client client;
    private final CreatorsPlugin plugin;
    private final ToolBoxFrame toolBox;
    private final ModelAnvil modelAnvil;
    private final ModelOrganizer modelOrganizer;
    private final DataFinder dataFinder;
    private final TransmogPanel transmogPanel;
    private final ModelImporter modelImporter;

    private final JButton addObjectButton = new JButton();
    private final JPanel sidePanel = new JPanel();
    private final Random random = new Random();

    public static final File SETUP_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/setups");
    public static final File CREATORS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    public File lastFileLoaded;

    private final Pattern pattern = Pattern.compile("\\(\\d+\\)\\Z");
    private int npcPanels = 0;
    private ArrayList<Character> sidePanelCharacters = new ArrayList<>();
    private final ArrayList<JComboBox<CustomModel>> comboBoxes = new ArrayList<>();
    private final BufferedImage SWITCH = ImageUtil.loadImageResource(getClass(), "/Switch.png");
    private final BufferedImage DUPLICATE = ImageUtil.loadImageResource(getClass(), "/Duplicate.png");
    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage HELP = ImageUtil.loadImageResource(getClass(), "/Help.png");
    private final BufferedImage NEW = ImageUtil.loadImageResource(getClass(), "/New.png");
    private final BufferedImage FIND = ImageUtil.loadImageResource(getClass(), "/Find.png");
    private final BufferedImage CUSTOM_MODEL = ImageUtil.loadImageResource(getClass(), "/Custom model.png");
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    private final LineBorder defaultBorder = new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1);
    private final LineBorder hoveredBorder = new LineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1);
    private final LineBorder selectedBorder = new LineBorder(Color.WHITE, 1);

    @Inject
    public CreatorsPanel(@Nullable Client client, ClientThread clientThread, CreatorsPlugin plugin, ToolBoxFrame toolBox, DataFinder dataFinder, ModelImporter modelImporter)
    {
        this.clientThread = clientThread;
        this.client = client;
        this.plugin = plugin;
        this.toolBox = toolBox;
        this.modelOrganizer = toolBox.getModelOrganizer();
        this.modelAnvil = toolBox.getModelAnvil();
        this.transmogPanel = toolBox.getTransmogPanel();
        this.dataFinder = dataFinder;
        this.modelImporter = modelImporter;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 3;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JButton toolBoxButton = new JButton("Toolbox");
        toolBoxButton.setToolTipText("Opens an interface for organizing Objects, creating Custom Models, programming, and more");
        toolBoxButton.setFocusable(false);
        toolBoxButton.addActionListener(e ->
        {
            toolBox.setVisible(!toolBox.isVisible());
            revalidate();
            repaint();
        });
        add(toolBoxButton, c);


        c.gridwidth = 1;
        c.gridheight = 2;
        c.weightx = 5;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 1;
        addObjectButton.setFocusable(false);
        addObjectButton.setText("Add Object");
        addObjectButton.setToolTipText("Add an new Object to the palette");
        addObjectButton.addActionListener(e ->
        {
            if (client == null)
            {
                return;
            }

            Character character = createCharacter(ParentPanel.SIDE_PANEL);
            SwingUtilities.invokeLater(() -> addPanel(ParentPanel.SIDE_PANEL, character, true, false));
        });
        add(addObjectButton, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 2;
        c.weighty = 0;
        c.gridx = 1;
        c.gridy = 1;
        JButton findButton = new JButton(new ImageIcon(FIND));
        findButton.setFocusable(false);
        findButton.setToolTipText("Open the File Explorer and navigate to the Creator's Kit directory");
        add(findButton, c);
        findButton.addActionListener(e ->
        {
            try
            {
                LinkBrowser.open(CREATORS_DIR.getAbsolutePath());
            }
            catch (Exception exception)
            {
            }
        });

        c.gridx = 2;
        c.gridy = 1;
        JButton helpButton = new JButton(new ImageIcon(HELP));
        helpButton.setToolTipText("Open a YouTube tutorial for help with using this plugin");
        helpButton.setFocusable(false);
        add(helpButton, c);
        helpButton.addActionListener(e -> toolBox.openLink("https://www.youtube.com/playlist?list=PL5-mTiHdZKNgcEbhEdadHzX-F4VNE0G9O"));

        c.gridx = 1;
        c.gridy = 2;
        JButton loadCustomModelButton = new JButton(new ImageIcon(CUSTOM_MODEL));
        loadCustomModelButton.setFocusable(false);
        loadCustomModelButton.setToolTipText("Load a previously Saved Model");
        add(loadCustomModelButton, c);
        loadCustomModelButton.addActionListener(e -> openLoadCustomModelDialog());

        c.gridx = 2;
        c.gridy = 2;
        JButton newSetupButton = new JButton(new ImageIcon(NEW));
        newSetupButton.setFocusable(false);
        newSetupButton.setToolTipText("Create a new Setup file");
        add(newSetupButton, c);
        newSetupButton.addActionListener(e ->
        {
            Thread thread = new Thread(() -> toolBox.getManagerPanel().getManagerTree().removeAllNodes());
            thread.start();
        });

        c.gridwidth = 3;
        c.gridx = 0;
        c.gridy = 3;
        c.weightx = 1;
        c.weighty = 0;
        sidePanel.setLayout(new GridLayout(0, 1, 4, 4));
        sidePanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        add(sidePanel, c);

        setKeyBindings();

        c.gridwidth = 3;
        c.gridx = 0;
        c.gridy = 4;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        add(emptyLabel, c);
    }

    public Character createCharacter(ParentPanel parentPanel)
    {
        return createCharacter(
                parentPanel,
                "Object (" + npcPanels + ")",
                7699,
                null,
                false,
                0,
                -1,
                -1,
                60,
                new KeyFrame[KeyFrameType.getTotalFrameTypes()][0],
                KeyFrameType.createDefaultSummary(),
                getRandomColor(),
                false, null, null, -1, false, false, false);
    }

    public Character createCharacter(
                              ParentPanel parentPanel,
                              String name,
                              int modelId,
                              CustomModel customModel,
                              boolean customModeActive,
                              int orientation,
                              int animationId,
                              int frame,
                              int radius,
                              KeyFrame[][] keyFrames,
                              KeyFrameType[] summary,
                              Color color,
                              boolean active,
                              WorldPoint worldPoint,
                              LocalPoint localPoint,
                              int plane,
                              boolean inPOH,
                              boolean transplant,
                              boolean setHoveredLocation)
    {
        JPanel objectPanel = new JPanel();
        objectPanel.setLayout(new GridBagLayout());

        JTextField textField = new JTextField(name);
        Dimension textDimension = new Dimension(140, 30);
        textField.setMaximumSize(textDimension);
        textField.setPreferredSize(textDimension);
        textField.setMinimumSize(textDimension);

        JPanel topButtonsPanel = new JPanel();
        Dimension topButtonsPanelSize = new Dimension(81, 30);
        topButtonsPanel.setMaximumSize(topButtonsPanelSize);
        topButtonsPanel.setPreferredSize(topButtonsPanelSize);
        topButtonsPanel.setMinimumSize(topButtonsPanelSize);
        topButtonsPanel.setLayout(new GridLayout(1, 3, 0, 0));

        JButton switchButton = new JButton(new ImageIcon(SWITCH));
        switchButton.setToolTipText("Switch this Object between the Manager and Side Panel");
        switchButton.setFocusable(false);

        JButton duplicateButton = new JButton(new ImageIcon(DUPLICATE));
        duplicateButton.setToolTipText("Duplicate Object");
        duplicateButton.setFocusable(false);

        JButton deleteButton = new JButton(new ImageIcon(CLOSE));
        deleteButton.setToolTipText("Delete Object");
        deleteButton.setFocusable(false);

        //Buttons
        JButton modelButton = new JButton();
        modelButton.setFont(FontManager.getRunescapeFont());
        String modelButtonText = customModeActive ? "Custom" : "Id";
        modelButton.setText(modelButtonText);
        modelButton.setToolTipText("Toggle between Custom Model and Model ID");
        modelButton.setFocusable(false);

        JButton spawnButton = new JButton();
        spawnButton.setFont(FontManager.getRunescapeFont());
        spawnButton.setText(active ? "Spawn" : "Despawn");
        spawnButton.setToolTipText("Toggle the Object on or off");
        spawnButton.setFocusable(false);

        JButton colourButton = new JButton();
        colourButton.setFont(FontManager.getRunescapeFont());
        colourButton.setText("Recolour");
        colourButton.setToolTipText("Rerolls the Object's colour overlays");
        colourButton.setPreferredSize(new Dimension(90, 25));
        colourButton.setFocusable(false);
        colourButton.setForeground(color);

        JPanel framePanel = new JPanel();
        framePanel.setLayout(new BorderLayout());

        JLabel frameLabel = new JLabel(" Frame: ");
        frameLabel.setToolTipText("The animation frame to freeze on");
        frameLabel.setFont(FontManager.getRunescapeSmallFont());
        framePanel.add(frameLabel, BorderLayout.LINE_START);

        JSpinner animationFrameSpinner = new JSpinner(new SpinnerNumberModel(frame, -1, 999, 1));
        animationFrameSpinner.setPreferredSize(new Dimension(60, 25));
        framePanel.add(animationFrameSpinner, BorderLayout.CENTER);

        //Labels
        JLabel modelLabel = new JLabel("Model ID:");
        modelLabel.setToolTipText("The ID number of the model to spawn");
        modelLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel orientationLabel = new JLabel("Rotation:");
        orientationLabel.setToolTipText("0 = South, 512 = West, 1024 = North, 1536 = East, 2048 = Max");
        orientationLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel radiusLabel = new JLabel("Radius:");
        radiusLabel.setToolTipText("Increasing the radius may prevent clipping issues with the ground");
        radiusLabel.setFont(FontManager.getRunescapeSmallFont());

        JLabel animationLabel = new JLabel("Anim ID:");
        animationLabel.setToolTipText("The animation ID number. -1 gives no animation");
        animationLabel.setFont(FontManager.getRunescapeSmallFont());

        //Spinners
        JSpinner modelSpinner = new JSpinner();
        modelSpinner.setPreferredSize(topButtonsPanelSize);
        modelSpinner.setMaximumSize(topButtonsPanelSize);
        modelSpinner.setMinimumSize(topButtonsPanelSize);
        modelSpinner.setValue(modelId);
        modelSpinner.setVisible(!customModeActive);

        JComboBox<CustomModel> modelComboBox = new JComboBox<>();
        modelComboBox.setPreferredSize(topButtonsPanelSize);
        modelComboBox.setMaximumSize(topButtonsPanelSize);
        modelComboBox.setMinimumSize(topButtonsPanelSize);
        modelComboBox.setFont(FontManager.getRunescapeFont());
        modelComboBox.setVisible(customModeActive);
        for (CustomModel model : plugin.getStoredModels())
        {
            modelComboBox.addItem(model);
        }
        if (customModel != null)
            modelComboBox.setSelectedItem(customModel);

        SpinnerModel orientationRange = new SpinnerNumberModel(orientation, 0, 2048, 1);
        JSpinner orientationSpinner = new JSpinner(orientationRange);

        JSpinner radiusSpinner = new JSpinner();
        radiusSpinner.setValue(radius);

        JSpinner animationSpinner = new JSpinner();
        animationSpinner.setValue(animationId);

        SwingUtilities.invokeLater(() ->
        {
            GridBagConstraints c = new GridBagConstraints();
            c.fill = GridBagConstraints.BOTH;
            c.insets = new Insets(1, 1, 1, 1);
            c.gridwidth = 2;
            c.gridx = 0;
            c.gridy = 0;
            c.weightx = 1;
            objectPanel.add(textField, c);

            c.gridwidth = 1;
            c.gridx = 2;
            c.gridy = 0;
            c.weightx = 0;
            objectPanel.add(topButtonsPanel, c);
            topButtonsPanel.add(switchButton);
            topButtonsPanel.add(duplicateButton);
            topButtonsPanel.add(deleteButton);

            c.ipadx = 0;
            c.ipady = 5;
            c.gridwidth = 1;
            c.weightx = 1;
            c.gridx = 0;
            c.gridy = 1;
            objectPanel.add(modelButton, c);

            c.gridy++;
            objectPanel.add(spawnButton, c);

            c.gridy++;
            objectPanel.add(colourButton, c);

            c.gridy++;
            objectPanel.add(framePanel, c);

            c.fill = GridBagConstraints.NONE;
            c.anchor = GridBagConstraints.LINE_END;
            c.ipadx = 0;
            c.ipady = 0;
            c.gridwidth = 1;
            c.weightx = 0;
            c.gridx = 1;
            c.gridy = 1;
            objectPanel.add(modelLabel, c);

            c.gridy++;
            objectPanel.add(orientationLabel, c);

            c.gridy++;
            objectPanel.add(radiusLabel, c);

            c.gridy++;
            objectPanel.add(animationLabel, c);

            c.fill = GridBagConstraints.BOTH;
            c.anchor = GridBagConstraints.CENTER;
            c.gridwidth = 1;
            c.gridx = 2;
            c.gridy = 1;
            objectPanel.add(modelSpinner, c);
            objectPanel.add(modelComboBox, c);

            c.gridy++;
            objectPanel.add(orientationSpinner, c);

            c.gridy++;
            objectPanel.add(radiusSpinner, c);

            c.gridy++;
            objectPanel.add(animationSpinner, c);

            objectPanel.repaint();
            objectPanel.revalidate();
        });

        Character character = new Character(
                textField.getText(),
                active,
                false,
                keyFrames,
                new KeyFrame[KeyFrameType.getTotalFrameTypes()],
                summary,
                null,
                null,
                color,
                worldPoint,
                localPoint,
                plane,
                inPOH,
                (CustomModel) modelComboBox.getSelectedItem(),
                parentPanel,
                objectPanel,
                customModeActive,
                textField,
                modelComboBox,
                spawnButton,
                modelButton,
                modelSpinner,
                animationSpinner,
                animationFrameSpinner,
                orientationSpinner,
                radiusSpinner,
                new CKObject(client),
                null,
                null,
                0);

        textField.addActionListener(e -> onNameTextFieldChanged(character));

        textField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {}

            @Override
            public void focusLost(FocusEvent e)
            {
                onNameTextFieldChanged(character);
            }
        });

        switchButton.addActionListener(e -> onSwitchButtonPressed(character));

        deleteButton.addActionListener(e -> onDeleteButtonPressed(character));

        duplicateButton.addActionListener(e -> onDuplicatePressed(character, false));

        objectPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                setSelectedCharacter(character);
            }
        });

        objectPanel.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered (MouseEvent e)
            {
                setHoveredCharacter(character, objectPanel);
            }

            @Override
            public void mouseExited (MouseEvent e)
            {
                unsetHoveredCharacter(character, objectPanel);
            }
        });

        spawnButton.addActionListener(e -> character.toggleActive(clientThread));

        colourButton.addActionListener(e ->
        {
            Color colour = getRandomColor();
            character.setColor(colour);
            colourButton.setForeground(colour);
        });

        modelButton.addActionListener(e ->
        {
            if (character.isCustomMode())
            {
                character.setCustomMode(false);
                modelButton.setText("Id");
                modelSpinner.setVisible(true);
                modelComboBox.setVisible(false);
                plugin.setModel(character, false, (int) modelSpinner.getValue());
            }
            else
            {
                character.setCustomMode(true);
                modelButton.setText("Custom");
                modelSpinner.setVisible(false);
                modelComboBox.setVisible(true);
                plugin.setModel(character, true, -1);
            }
        });

        modelSpinner.addChangeListener(e ->
        {
            int modelNumber = (int) modelSpinner.getValue();
            plugin.setModel(character, false, modelNumber);
        });

        modelComboBox.addItemListener(e ->
        {
            CustomModel m = (CustomModel) modelComboBox.getSelectedItem();
            character.setStoredModel(m);
            if (modelComboBox.isVisible() && character == plugin.getSelectedCharacter())
                plugin.setModel(character, true, -1);
        });

        orientationSpinner.addChangeListener(e ->
        {
            int orient = (int) orientationSpinner.getValue();
            plugin.setOrientation(character, orient);
        });

        animationSpinner.addChangeListener(e ->
        {
            int animationNumber = (int) animationSpinner.getValue();
            plugin.setAnimation(character, animationNumber);
            plugin.setAnimationFrame(character, (int) animationFrameSpinner.getValue(), true);
        });

        animationFrameSpinner.addChangeListener(e ->
        {
            int animFrame = (int) animationFrameSpinner.getValue();
            plugin.setAnimationFrame(character, animFrame, true);
        });

        radiusSpinner.addChangeListener(e ->
        {
            int rad = (int) radiusSpinner.getValue();
            plugin.setRadius(character, rad);
        });

        addAllSelectListeners(
                character,
                objectPanel,
                textField,
                topButtonsPanel,
                duplicateButton,
                switchButton,
                deleteButton,
                modelButton,
                spawnButton,
                colourButton,
                animationFrameSpinner,
                frameLabel,
                modelLabel,
                orientationLabel,
                radiusLabel,
                animationLabel,
                modelSpinner,
                modelComboBox,
                orientationSpinner,
                radiusSpinner,
                animationSpinner
        );

        plugin.setupRLObject(character, transplant, setHoveredLocation);
        plugin.getCharacters().add(character);

        comboBoxes.add(modelComboBox);
        return character;
    }

    private void addAllSelectListeners(
            Character character,
            JPanel objectPanel,
            JTextField textField,
            JPanel topButtonsPanel,
            JButton duplicateButton,
            JButton switchButton,
            JButton deleteButton,
            JButton modelButton,
            JButton spawnButton,
            JButton colourButton,
            JSpinner animationFrameSpinner,
            JLabel frameLabel,
            JLabel modelLabel,
            JLabel orientationLabel,
            JLabel radiusLabel,
            JLabel animationLabel,
            JSpinner modelSpinner,
            JComboBox<CustomModel> modelComboBox,
            JSpinner orientationSpinner,
            JSpinner radiusSpinner,
            JSpinner animationSpinner)
    {
        addSelectListeners(objectPanel, character, objectPanel, true);
        addSelectListeners(textField, character, objectPanel, true);
        addSelectListeners(topButtonsPanel, character, objectPanel, true);
        addSelectListeners(switchButton, character, objectPanel, true);
        addSelectListeners(duplicateButton, character, objectPanel, false);
        addSelectListeners(deleteButton, character, objectPanel, false);
        addSelectListeners(modelButton, character, objectPanel, true);
        addSelectListeners(spawnButton, character, objectPanel, true);
        addSelectListeners(colourButton, character, objectPanel, true);
        addSelectListeners(animationFrameSpinner, character, objectPanel, true);
        addSelectListeners(frameLabel, character, objectPanel, true);
        addSelectListeners(modelLabel, character, objectPanel, true);
        addSelectListeners(orientationLabel, character, objectPanel, true);
        addSelectListeners(radiusLabel, character, objectPanel, true);
        addSelectListeners(animationLabel, character, objectPanel, true);
        addSelectListeners(modelComboBox, character, objectPanel, true);

        for (Component c : modelSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : orientationSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : radiusSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }

        for (Component c : animationSpinner.getEditor().getComponents())
        {
            addSelectListeners(c, character, objectPanel, true);
        }
    }

    private void addSelectListeners(Component component, Character character, JPanel objectPanel, boolean pressedListener)
    {
        component.addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered (MouseEvent e)
            {
                setHoveredCharacter(character, objectPanel);
            }
            @Override
            public void mouseExited (MouseEvent e)
            {
                unsetHoveredCharacter(character, objectPanel);
            }
        });

        if (pressedListener)
        {
            component.addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    setSelectedCharacter(character);
                }
            });
        }
    }

    public void addPanel(ParentPanel parentPanel, Character character, boolean revalidate, boolean switching)
    {
        addPanel(parentPanel, character, null, revalidate, switching);
    }

    public void addPanel(ParentPanel parentPanel, Character character, DefaultMutableTreeNode parentNode, boolean revalidate, boolean switching)
    {
        JPanel childPanel = character.getObjectPanel();
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        ManagerTree managerTree = managerPanel.getManagerTree();

        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            sidePanelCharacters.add(character);
            sidePanel.add(childPanel);
            if (parentNode == null)
            {
                managerTree.addCharacterNode(character, ParentPanel.SIDE_PANEL, true, switching);
            }
            else
            {
                managerTree.addCharacterNode(parentNode, character, ParentPanel.SIDE_PANEL, true);
            }

            if (revalidate)
            {
                sidePanel.repaint();
                sidePanel.revalidate();
            }
        }

        if (parentPanel == ParentPanel.MANAGER)
        {
            managerPanel.getManagerCharacters().add(character);

            if (parentNode == null)
            {
                managerTree.addCharacterNode(character, ParentPanel.MANAGER, true, switching);
            }
            else
            {
                managerTree.addCharacterNode(parentNode, character, ParentPanel.MANAGER, true);
            }

            if (revalidate)
            {
                managerTree.resetObjectHolder();
            }
        }

        if (!switching)
        {
            npcPanels++;
        }

        setSelectedCharacter(character);
    }

    public void onSwitchButtonPressed(Character character)
    {
        ParentPanel parentPanel = character.getParentPanel();
        removePanel(character);

        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            addPanel(ParentPanel.MANAGER, character, true, true);
        }
        else
        {
            addPanel(ParentPanel.SIDE_PANEL, character, true, true);
        }
    }

    public void onDuplicatePressed(Character character, boolean setLocation)
    {
        String newName = character.getName();
        Matcher matcher = pattern.matcher(newName);
        if (matcher.find())
        {
            String duplicate = matcher.group();
            duplicate = duplicate.replace("(", "");
            duplicate = duplicate.replace(")", "");

            int duplicateNumber = Integer.parseInt(duplicate) + 1;
            newName = newName.replaceFirst("(?s)" + duplicate + "(?!.*?" + duplicate + ")", "" + duplicateNumber);
        }
        else
        {
            newName = newName + " (1)";
        }

        KeyFrameType[] keyFrameTypes = character.getSummary();
        KeyFrameType[] summary = new KeyFrameType[]{keyFrameTypes[0], keyFrameTypes[1], keyFrameTypes[2]};

        ParentPanel parentPanel = character.getParentPanel();

        String finalNewName = newName;
        Thread thread = new Thread(() ->
        {
            Character c = createCharacter(
                    character.getParentPanel(),
                    finalNewName,
                    (int) character.getModelSpinner().getValue(),
                    (CustomModel) character.getComboBox().getSelectedItem(),
                    character.isCustomMode(),
                    (int) character.getOrientationSpinner().getValue(),
                    (int) character.getAnimationSpinner().getValue(),
                    (int) character.getAnimationFrameSpinner().getValue(),
                    (int) character.getRadiusSpinner().getValue(),
                    duplicateKeyFrames(character),
                    summary,
                    getRandomColor(),
                    character.isActive(),
                    character.getNonInstancedPoint(),
                    character.getInstancedPoint(),
                    character.getInstancedPlane(),
                    character.isInPOH(),
                    true,
                    setLocation);

            SwingUtilities.invokeLater(() -> addPanel(parentPanel, c, true, false));
        });
        thread.start();
    }

    private KeyFrame[][] duplicateKeyFrames(Character character)
    {
        KeyFrame[][] duplicatesArrays = new KeyFrame[KeyFrameType.getTotalFrameTypes()][];

        KeyFrame[][] originalArrays = character.getFrames();
        for (int i = 0; i < originalArrays.length; i++)
        {
            KeyFrame[] originalArray = originalArrays[i];
            if (originalArray == null || originalArray.length == 0)
            {
                duplicatesArrays[i] = new KeyFrame[0];
                continue;
            }

            KeyFrame[] duplicateArray = new KeyFrame[originalArray.length];
            for (int e = 0; e < originalArray.length; e++)
            {
                KeyFrame original = originalArray[e];
                KeyFrame duplicate = KeyFrame.createCopy(original, original.getTick());
                duplicateArray[e] = duplicate;
            }

            duplicatesArrays[i] = duplicateArray;
        }

        return duplicatesArrays;
    }

    public void onNameTextFieldChanged(Character character)
    {
        JTextField textField = character.getNameField();
        String text = StringHandler.cleanString(textField.getText());
        textField.setText(text);
        character.setName(text);

        DefaultMutableTreeNode node = character.getLinkedManagerNode();
        if (node == null)
        {
            return;
        }

        toolBox.getManagerPanel().getManagerTree().getTreeModel().nodeChanged(node);
        toolBox.getTimeSheetPanel().getAttributePanel().updateObjectLabel(character);

        toolBox.revalidate();
        toolBox.repaint();
    }

    public void onDeleteButtonPressed(Character character)
    {
        deleteCharacters(new Character[]{character});
    }

    public void deleteCharacters(Character[] charactersToRemove)
    {
        removePanels(charactersToRemove);
        TimeSheetPanel timeSheetPanel = toolBox.getTimeSheetPanel();

        ArrayList<Character> characters = plugin.getCharacters();
        Character selectedCharacter = plugin.getSelectedCharacter();
        Character tspSelectedCharacter = timeSheetPanel.getSelectedCharacter();

        for (Character c : charactersToRemove)
        {
            clientThread.invokeLater(() ->
            {
                c.getCkObject().setActive(false);

                CKObject sp1 = c.getSpotAnim1();
                if (sp1 != null)
                {
                    sp1.setActive(false);
                }

                CKObject sp2 = c.getSpotAnim2();
                if (sp2 != null)
                {
                    sp2.setActive(false);
                }
            });
            characters.remove(c);
            if (c == selectedCharacter)
            {
                plugin.setSelectedCharacter(null);
            }

            if (c == tspSelectedCharacter)
            {
                timeSheetPanel.setSelectedCharacter(null);
            }

            toolBox.getTimeSheetPanel().removeKeyFrameActions(c);
        }
    }

    public void removePanels(Character[] characters)
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        JPanel objectHolder = managerPanel.getObjectHolder();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();
        ManagerTree managerTree = managerPanel.getManagerTree();

        for (Character character : characters)
        {
            JPanel objectPanel = character.getObjectPanel();
            ParentPanel parentPanel = character.getParentPanel();
            if (parentPanel == ParentPanel.SIDE_PANEL)
            {
                sidePanel.remove(objectPanel);
                sidePanelCharacters.remove(character);
                managerTree.removeCharacterNode(character);
            }

            if (parentPanel == ParentPanel.MANAGER)
            {
                objectHolder.remove(objectPanel);
                managerTree.removeCharacterNode(character);
                managerCharacters.remove(character);
            }
        }

        sidePanel.repaint();
        sidePanel.revalidate();
        objectHolder.repaint();
        objectHolder.revalidate();
        managerTree.updateTreeSelectionIndex();
        managerTree.resetObjectHolder();
    }

    public void removePanel(Character character)
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        ManagerTree managerTree = managerPanel.getManagerTree();

        JPanel objectPanel = character.getObjectPanel();
        ParentPanel parentPanel = character.getParentPanel();
        if (parentPanel == ParentPanel.SIDE_PANEL)
        {
            sidePanel.remove(objectPanel);
            managerTree.resetObjectHolder();
            sidePanelCharacters.remove(character);
            managerTree.removeCharacterNode(character);
        }

        JPanel objectHolder = managerPanel.getObjectHolder();
        if (parentPanel == ParentPanel.MANAGER)
        {
            objectHolder.remove(objectPanel);
            managerTree.removeCharacterNode(character);
            managerTree.resetObjectHolder();
            managerPanel.getManagerCharacters().remove(character);
        }

        sidePanel.repaint();
        sidePanel.revalidate();
        objectHolder.repaint();
        objectHolder.revalidate();
        managerTree.updateTreeSelectionIndex();
    }

    public void clearSidePanels(boolean warning)
    {
        if (warning)
        {
            int result = JOptionPane.showConfirmDialog(this, "Are you sure you want to delete all Objects from the Side Panel?");
            if (result != JOptionPane.YES_OPTION)
                return;
        }

        for (Character character : sidePanelCharacters)
        {
            if (character == plugin.getSelectedCharacter())
            {
                unsetSelectedCharacter();
                break;
            }
        }

        Character[] charactersToRemove = sidePanelCharacters.toArray(new Character[sidePanelCharacters.size()]);

        sidePanelCharacters.clear();
        Thread thread = new Thread(() -> deleteCharacters(charactersToRemove));
        thread.start();
        sidePanel.removeAll();
        sidePanel.repaint();
        sidePanel.revalidate();
    }

    public void clearManagerPanels()
    {
        ManagerPanel managerPanel = toolBox.getManagerPanel();
        JPanel objectHolder = managerPanel.getObjectHolder();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();

        for (Character character : managerCharacters)
        {
            if (character == plugin.getSelectedCharacter())
            {
                unsetSelectedCharacter();
                break;
            }
        }

        Character[] charactersToRemove = managerCharacters.toArray(new Character[managerCharacters.size()]);

        objectHolder.removeAll();
        managerPanel.getManagerTree().resetObjectHolder();
        Thread thread = new Thread(() -> deleteCharacters(charactersToRemove));
        thread.start();
    }

    public void resetSidePanel()
    {
        sidePanel.removeAll();
        ArrayList<Character> characters = new ArrayList<>();
        toolBox.getManagerPanel().getManagerTree().getSidePanelChildren(characters);
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            sidePanel.add(character.getObjectPanel());
        }

        sidePanelCharacters = characters;

        sidePanel.repaint();
        sidePanel.revalidate();
    }

    public void setSelectedCharacter(Character selected)
    {
        setSelectedCharacter(selected, true);
    }

    public void setSelectedCharacter(Character selected, boolean updateManagerTree)
    {
        ArrayList<Character> characters = plugin.getCharacters();

        for (int i = 0; i < characters.size(); i++)
        {
            JPanel panel = characters.get(i).getObjectPanel();
            panel.setBorder(defaultBorder);
        }

        plugin.setSelectedCharacter(selected);

        ManagerTree tree = toolBox.getManagerPanel().getManagerTree();
        if (updateManagerTree)
        {
            tree.setTreeSelection(selected);
        }

        if (selected != null)
        {
            selected.getObjectPanel().setBorder(selectedBorder);
        }
    }

    public void scrollSelectedCharacter(int clicks)
    {
        toolBox.getManagerPanel().
                getManagerTree().
                scrollSelectedIndex(clicks);
    }

    public void unsetSelectedCharacter()
    {
        ArrayList<Character> characters = plugin.getCharacters();

        for (int i = 0; i < characters.size(); i++)
        {
            JPanel panel = characters.get(i).getObjectPanel();
            panel.setBorder(defaultBorder);
        }

        plugin.setSelectedCharacter(null);
    }

    public void setHoveredCharacter(Character hovered, JPanel jPanel)
    {
        if (plugin.getSelectedCharacter() == hovered)
        {
            return;
        }

        jPanel.setBorder(hoveredBorder);
        plugin.setHoveredCharacter(hovered);
    }

    public void unsetHoveredCharacter(Character hoverRemoved, JPanel jPanel)
    {
        plugin.setHoveredCharacter(null);

        if (plugin.getSelectedCharacter() == hoverRemoved)
        {
            return;
        }

        jPanel.setBorder(defaultBorder);
    }

    public void addModelOption(CustomModel model, boolean setComboBox)
    {
        modelOrganizer.createModelPanel(model);
        Character selectedCharacter = plugin.getSelectedCharacter();

        toolBox.getTimeSheetPanel()
                .getAttributePanel()
                .getModelAttributes()
                .getCustomModel()
                .addItem(model);

        for (JComboBox<CustomModel> comboBox : comboBoxes)
        {
            comboBox.addItem(model);
            if (!setComboBox || selectedCharacter == null)
            {
                continue;
            }

            JComboBox<CustomModel> selectedBox = selectedCharacter.getComboBox();
            if (comboBox == selectedBox)
            {
                comboBox.setSelectedItem(model);
                selectedCharacter.setCustomMode(true);
                selectedCharacter.getModelButton().setText("Custom");

                if (selectedCharacter.getModelSpinner().isVisible() || comboBox.isVisible())
                {
                    comboBox.setVisible(true);
                    selectedCharacter.getModelSpinner().setVisible(false);
                }
            }

            selectedCharacter.setStoredModel(model);
            plugin.setModel(selectedCharacter, true, -1);
        }
    }

    public void removeModelOption(CustomModel model)
    {
        toolBox.getTimeSheetPanel()
                .getAttributePanel()
                .getModelAttributes()
                .getCustomModel()
                .removeItem(model);

        for (JComboBox<CustomModel> comboBox : comboBoxes)
        {
            comboBox.removeItem(model);
        }
        modelOrganizer.removeModelPanel(model);
    }

    public Color getRandomColor()
    {
        int max = 90;
        int min = 35;
        float r = (float) (random.nextInt(max - min + 1) + min) / 100;
        float g = (float) (random.nextInt(max - min + 1) + min) / 100;
        float b = (float) (random.nextInt(max - min + 1) + min) / 100;
        return new Color(r, g, b);
    }

    public void updateLoadedFile(File file)
    {
        lastFileLoaded = file;
        String fileName = "";
        if (file != null)
        {
            fileName = " - " + getFileName(lastFileLoaded);
        }

        toolBox.setTitle("Creator's Kit Toolbox" + fileName);
    }

    private String getFileName(File file)
    {
        String fileName = file.getName();
        int lastDotIndex = fileName.lastIndexOf('.');
        if (lastDotIndex != -1)
        {
            return fileName.substring(0, lastDotIndex);
        }

        return fileName;
    }

    public void openSaveDialog()
    {
        File outputDir = SETUP_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File("setup"));
        fileChooser.setDialogTitle("Save current setup");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile);
        }
    }

    public void quickSaveToFile()
    {
        if (lastFileLoaded == null)
        {
            openSaveDialog();
            return;
        }

        saveToFile(lastFileLoaded);
    }

    public void saveToFile(File file)
    {
        ArrayList<CustomModel> customModels = plugin.getStoredModels();
        CustomModelComp[] comps = new CustomModelComp[customModels.size()];

        for (int i = 0; i < comps.length; i++)
        {
            comps[i] = customModels.get(i).getComp();
        }

        //Get Folder structure and all characters contained within
        FolderNodeSave folderNodeSave = getFolders(comps);

        SetupSave saveFile = new SetupSave(getPluginVersion(), comps, folderNodeSave, new CharacterSave[0]);

        try
        {
            FileWriter writer = new FileWriter(file, false);
            String string = plugin.getGson().toJson(saveFile);
            writer.write(string);
            writer.close();
            updateLoadedFile(file);
            LocalTime time = LocalTime.now();
            plugin.sendChatMessage("[" + time.getHour() + ":" + time.getMinute() + "] Saved successfully to: " + getFileName(file));
        }
        catch (IOException e)
        {
            plugin.sendChatMessage("An error occurred while writing to file.");
        }
    }

    public FolderNodeSave getFolders(CustomModelComp[] comps)
    {
        FolderNodeSave folderNodeSave = new FolderNodeSave(FolderType.MASTER, "Master Panel", new CharacterSave[0], new FolderNodeSave[0]);
        getFolderChildren(folderNodeSave, toolBox.getManagerPanel().getManagerTree().getRootNode(), comps);
        return folderNodeSave;
    }

    public void getFolderChildren(FolderNodeSave parentNodeSave, DefaultMutableTreeNode parent, CustomModelComp[] comps)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            CharacterSave[] characterSaves = parentNodeSave.getCharacterSaves();
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                Character character = (Character) node.getUserObject();
                CharacterSave characterSave = createCharacterSave(character, comps);
                parentNodeSave.setCharacterSaves(ArrayUtils.add(characterSaves, characterSave));
            }

            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                String name = (folder.getName());
                FolderNodeSave folderNodeSave = new FolderNodeSave(folder.getFolderType(), name, new CharacterSave[0], new FolderNodeSave[0]);
                parentNodeSave.setFolderSaves(ArrayUtils.add(parentNodeSave.getFolderSaves(), folderNodeSave));

                if (!node.isLeaf())
                    getFolderChildren(folderNodeSave, node, comps);
            }
        }
    }

    private ModelKeyFrameSave[] saveModelKeyFrames(ModelKeyFrame[] keyFrames, CustomModelComp[] comps)
    {
        if (keyFrames == null)
        {
            return null;
        }

        ModelKeyFrameSave[] saves = new ModelKeyFrameSave[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            ModelKeyFrame keyFrame = keyFrames[i];
            CustomModel storedModel = keyFrame.getCustomModel();
            int compId = 0;

            for (int e = 0; e < comps.length; e++)
            {
                CustomModelComp comp = comps[e];
                if (storedModel.getComp() == comp)
                {
                    compId = e;
                    break;
                }
            }

            saves[i] = new ModelKeyFrameSave(keyFrame.getTick(), keyFrame.isUseCustomModel(), keyFrame.getModelId(), compId, keyFrame.getRadius());
        }

        return saves;
    }

    private ModelKeyFrame[] loadModelKeyFrames(ModelKeyFrameSave[] saves, CustomModel[] customModels)
    {
        ModelKeyFrame[] keyFrames = new ModelKeyFrame[saves.length];

        for (int i = 0; i < saves.length; i++)
        {
            ModelKeyFrameSave save = saves[i];
            CustomModel customModel = null;
            if (customModels.length > 0)
            {
                customModel = customModels[save.getCustomModel()];
            }

            keyFrames[i] = new ModelKeyFrame(save.getTick(), save.isUseCustomModel(), save.getModelId(), customModel, save.getRadius());
        }

        return keyFrames;
    }

    private CharacterSave createCharacterSave(Character character, CustomModelComp[] comps)
    {
        String name = character.getName();
        WorldPoint savedWorldPoint = character.getNonInstancedPoint();
        LocalPoint savedLocalPoint = character.getInstancedPoint();
        int localPointPlane = character.getInstancedPlane();
        boolean inPOH = character.isInPOH();
        int compId = 0;
        CustomModel storedModel = character.getStoredModel();
        if (storedModel != null)
        {
            for (int e = 0; e < comps.length; e++)
            {
                CustomModelComp comp = comps[e];
                if (storedModel.getComp() == comp)
                {
                    compId = e;
                    break;
                }
            }
        }

        boolean customMode = character.isCustomMode();
        int modelId = (int) character.getModelSpinner().getValue();
        boolean active = character.isActive();
        int radius = character.getCkObject().getRadius();
        int rotation = (int) character.getOrientationSpinner().getValue();
        int animationId = (int) character.getAnimationSpinner().getValue();
        int frame = (int) character.getAnimationFrameSpinner().getValue();
        int rgb = character.getColor().getRGB();
        ModelKeyFrameSave[] modelKeyFrameSaves = saveModelKeyFrames(character.getModelKeyFrames(), comps);

        SpotAnimKeyFrame[][] spotAnimKeyFrames = new SpotAnimKeyFrame[][]
                {
                        character.getSpotAnimKeyFrames(KeyFrameType.SPOTANIM),
                        character.getSpotAnimKeyFrames(KeyFrameType.SPOTANIM2)
                };

        HitsplatKeyFrame[][] hitsplatKeyFrames = new HitsplatKeyFrame[][]
                {
                        character.getHitsplatKeyFrames(KeyFrameType.HITSPLAT_1),
                        character.getHitsplatKeyFrames(KeyFrameType.HITSPLAT_2),
                        character.getHitsplatKeyFrames(KeyFrameType.HITSPLAT_3),
                        character.getHitsplatKeyFrames(KeyFrameType.HITSPLAT_4)
                };

        return new CharacterSave(
                name,
                savedWorldPoint,
                savedLocalPoint,
                localPointPlane,
                inPOH,
                compId,
                customMode,
                modelId,
                active,
                radius,
                rotation,
                animationId,
                frame,
                rgb,
                character.getMovementKeyFrames(),
                character.getAnimationKeyFrames(),
                character.getSpawnKeyFrames(),
                modelKeyFrameSaves,
                character.getOrientationKeyFrames(),
                character.getTextKeyFrames(),
                character.getOverheadKeyFrames(),
                character.getHealthKeyFrames(),
                spotAnimKeyFrames,
                hitsplatKeyFrames,
                character.getSummary());
    }

    public void openLoadSetupDialog()
    {
        SwingUtilities.invokeLater(() ->
        {
            File outputDir = SETUP_DIR;
            outputDir.mkdirs();

            JFileChooser fileChooser = new JFileChooser(outputDir);
            fileChooser.setDialogTitle("Choose a setup to load");
            fileChooser.setFileFilter(new FileFilter()
            {
                @Override
                public String getDescription()
                {
                    return "Json File (*.json)";
                }

                @Override
                public boolean accept(File f)
                {
                    if (f.isDirectory())
                    {
                        return true;
                    }
                    else
                    {
                        String filename = f.getName().toLowerCase();
                        return filename.endsWith(".json");
                    }
                }
            });

            int option = fileChooser.showOpenDialog(null);
            if (option == JFileChooser.APPROVE_OPTION)
            {
                File selectedFile = fileChooser.getSelectedFile();
                if (!selectedFile.exists())
                {
                    selectedFile = new File(selectedFile.getPath() + ".json");
                    if (!selectedFile.exists())
                    {
                        plugin.sendChatMessage("Could not find the requested Setup file.");
                        return;
                    }
                }

                try
                {
                    Reader reader = Files.newBufferedReader(selectedFile.toPath());
                    SetupSave saveFile = plugin.getGson().fromJson(reader, SetupSave.class);
                    File finalSelectedFile = selectedFile;
                    clientThread.invokeLater(() -> loadSetup(finalSelectedFile, saveFile));
                    reader.close();
                    LocalTime time = LocalTime.now();
                    plugin.sendChatMessage("[" + time.getHour() + ":" + time.getMinute() + "] Loaded file: " + getFileName(finalSelectedFile));
                }
                catch (Exception e)
                {
                    plugin.sendChatMessage("An error occurred while attempting to read this file.");
                }
            }
        });
    }

    public void loadSetup(File file)
    {
        try
        {
            Reader reader = Files.newBufferedReader(file.toPath());
            SetupSave saveFile = plugin.getGson().fromJson(reader, SetupSave.class);
            clientThread.invokeLater(() -> loadSetup(file, saveFile));
            reader.close();
            LocalTime time = LocalTime.now();
            plugin.sendChatMessage("[" + time.getHour() + ":" + time.getMinute() + "] Loaded file: " + getFileName(file));
        }
        catch (Exception e)
        {
            plugin.sendChatMessage("An error occurred while attempting to read this file.");
        }
    }

    private void loadSetup(File file, SetupSave saveFile)
    {
        updateLoadedFile(file);
        CustomModelComp[] comps = saveFile.getComps();
        FolderNodeSave folderNodeSave = saveFile.getMasterFolderNode();
        CustomModel[] customModels = new CustomModel[comps.length];
        String fileVersion = saveFile.getVersion();
        if (fileVersion == null || fileVersion.isEmpty())
        {
            fileVersion = "1.5.0";
        }

        for (int i = 0; i < comps.length; i++)
        {
            CustomModelComp comp = comps[i];
            Model model;
            CustomModel customModel;
            ModelStats[] modelStats;

            switch (comp.getType())
            {
                case FORGED:
                    model = plugin.createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), comp.getCustomLighting(), false);
                    customModel = new CustomModel(model, comp);
                    break;
                case CACHE_NPC:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, new int[0], false, LightingStyle.ACTOR, null);
                    customModel = new CustomModel(model, comp);
                    break;
                case CACHE_PLAYER:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, comp.getKitRecolours(), true, LightingStyle.ACTOR, null);
                    customModel = new CustomModel(model, comp);
                    break;
                default:
                case CACHE_OBJECT:
                case CACHE_SPOTANIM:
                case CACHE_GROUND_ITEM:
                case CACHE_MAN_WEAR:
                case CACHE_WOMAN_WEAR:
                    modelStats = comp.getModelStats();
                    model = plugin.constructModelFromCache(modelStats, null, false, LightingStyle.DEFAULT, null);
                    customModel = new CustomModel(model, comp);
                    break;
                case BLENDER:
                    model = modelImporter.createModel(comp.getBlenderModel(), comp.getLightingStyle());
                    customModel = new CustomModel(model, comp);
            }

            plugin.addCustomModel(customModel, false);
            customModels[i] = customModel;
        }

        ManagerTree managerTree = toolBox.getManagerPanel().getManagerTree();
        DefaultMutableTreeNode rootNode = managerTree.getRootNode();

        final String version = fileVersion;

        SwingUtilities.invokeLater(() ->
        {
            if (folderNodeSave != null)
            {
                openFolderNodeSave(version, managerTree, rootNode, folderNodeSave, customModels);
                toolBox.repaint();
                toolBox.revalidate();
            }
        });

        if (isVersionLessThan(fileVersion, "1.5.4"))
        {
            CharacterSave[] characterSaves = saveFile.getSaves();
            if (characterSaves.length > 0)
            {
                Thread thread = new Thread(() ->
                {
                    boolean resetAnimFrames = isVersionLessThan(version, "1.5.12");

                    for (CharacterSave save : characterSaves)
                    {
                        Character character;

                        CustomModel customModel = null;
                        if (customModels.length > 0)
                        {
                            customModel = customModels[save.getCompId()];
                        }

                        int animFrame = save.getFrame();
                        if (resetAnimFrames)
                        {
                            animFrame = -1;
                        }

                        KeyFrame[][] frames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][];

                        character = createCharacter(
                                ParentPanel.SIDE_PANEL,
                                save.getName(),
                                save.getModelId(),
                                customModel,
                                save.isCustomMode(),
                                save.getRotation(),
                                save.getAnimationId(),
                                animFrame,
                                save.getRadius(),
                                frames,
                                save.getSummary(),
                                new Color(save.getRgb()),
                                save.isActive(),
                                save.getNonInstancedPoint(),
                                save.getInstancedPoint(),
                                save.getInstancedPlane(),
                                save.isInInstance(),
                                false,
                                false);

                        SwingUtilities.invokeLater(() -> addPanel(ParentPanel.SIDE_PANEL, character, true, false));
                    }
                });
                thread.start();
            }
        }
    }

    private void openFolderNodeSave(String fileVersion, ManagerTree managerTree, DefaultMutableTreeNode parentNode, FolderNodeSave folderNodeSave, CustomModel[] customModels)
    {
        String name = folderNodeSave.getName();
        DefaultMutableTreeNode node;
        FolderType folderType = folderNodeSave.getFolderType();

        if (isVersionLessThan(fileVersion, "1.5.4"))
        {
            node = managerTree.addFolderNode(parentNode, name);
        }
        else
        {
            switch (folderType)
            {
                default:
                case STANDARD:
                    node = managerTree.addFolderNode(parentNode, name);
                    break;
                case MASTER:
                case MANAGER:
                    node = managerTree.getManagerNode();
                    break;
                case SIDE_PANEL:
                    node = managerTree.getSidePanelNode();
            }
        }

        ParentPanel parentPanel;
        if (folderType == FolderType.SIDE_PANEL)
        {
            parentPanel = ParentPanel.SIDE_PANEL;
        }
        else
        {
            parentPanel = ParentPanel.MANAGER;
        }

        boolean resetAnimFrame = isVersionLessThan(fileVersion, "1.5.12");
        boolean resetTurnRate = isVersionLessThan(fileVersion, "2.0.1");

        for (CharacterSave save : folderNodeSave.getCharacterSaves())
        {
            Character character;
            CustomModel customModel = null;
            if (customModels.length > 0)
            {
                customModel = customModels[save.getCompId()];
            }

            int animFrame = save.getFrame();
            if (resetAnimFrame)
            {
                animFrame = -1;
            }

            KeyFrame[][] frames = new KeyFrame[KeyFrameType.getTotalFrameTypes()][];
            if (save.getMovementKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.MOVEMENT)] = save.getMovementKeyFrames();

                if (resetTurnRate)
                {
                    for (KeyFrame kf : frames[KeyFrameType.getIndex(KeyFrameType.MOVEMENT)])
                    {
                        MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
                        if (keyFrame.getTurnRate() == -1)
                        {
                            keyFrame.setTurnRate(OrientationKeyFrame.TURN_RATE);
                        }
                    }
                }
            }

            if (save.getAnimationKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.ANIMATION)] = save.getAnimationKeyFrames();
            }

            if (save.getSpawnKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.SPAWN)] = save.getSpawnKeyFrames();
            }

            ModelKeyFrameSave[] modelKeyFrameSaves = save.getModelKeyFrameSaves();
            if (modelKeyFrameSaves != null)
            {
                ModelKeyFrame[] modelKeyFrames = loadModelKeyFrames(modelKeyFrameSaves, customModels);
                frames[KeyFrameType.getIndex(KeyFrameType.MODEL)] = modelKeyFrames;
            }

            if (save.getOrientationKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.ORIENTATION)] = save.getOrientationKeyFrames();

                if (resetTurnRate)
                {
                    for (KeyFrame kf : frames[KeyFrameType.getIndex(KeyFrameType.ORIENTATION)])
                    {
                        OrientationKeyFrame keyFrame = (OrientationKeyFrame) kf;
                        if (keyFrame.getTurnRate() == -1)
                        {
                            keyFrame.setTurnRate(OrientationKeyFrame.TURN_RATE);
                        }
                    }
                }
            }

            if (save.getTextKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.TEXT)] = save.getTextKeyFrames();
            }

            if (save.getOverheadKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.OVERHEAD)] = save.getOverheadKeyFrames();
            }

            if (save.getHealthKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.HEALTH)] = save.getHealthKeyFrames();
            }

            SpotAnimKeyFrame[][] spotAnimKeyFrames = save.getSpotanimKeyFrames();
            if (save.getSpotanimKeyFrames() != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.SPOTANIM)] = spotAnimKeyFrames[0];
                frames[KeyFrameType.getIndex(KeyFrameType.SPOTANIM2)] = spotAnimKeyFrames[1];
            }

            HitsplatKeyFrame[][] hitsplatKeyFrames = save.getHitsplatKeyFrames();
            if (hitsplatKeyFrames != null)
            {
                frames[KeyFrameType.getIndex(KeyFrameType.HITSPLAT_1)] = hitsplatKeyFrames[0];
                frames[KeyFrameType.getIndex(KeyFrameType.HITSPLAT_2)] = hitsplatKeyFrames[1];
                frames[KeyFrameType.getIndex(KeyFrameType.HITSPLAT_3)] = hitsplatKeyFrames[2];
                frames[KeyFrameType.getIndex(KeyFrameType.HITSPLAT_4)] = hitsplatKeyFrames[3];
            }

            KeyFrameType[] summary;
            if (save.getSummary() == null)
            {
                summary = KeyFrameType.createDefaultSummary();
            }
            else
            {
                summary = save.getSummary();
            }

            character = createCharacter(
                    parentPanel,
                    save.getName(),
                    save.getModelId(),
                    customModel,
                    save.isCustomMode(),
                    save.getRotation(),
                    save.getAnimationId(),
                    animFrame,
                    save.getRadius(),
                    frames,
                    summary,
                    new Color(save.getRgb()),
                    save.isActive(),
                    save.getNonInstancedPoint(),
                    save.getInstancedPoint(),
                    save.getInstancedPlane(),
                    save.isInInstance(),
                    false,
                    false);

            addPanel(parentPanel, character, node, false, false);
        }

        FolderNodeSave[] folderNodeSaves = folderNodeSave.getFolderSaves();
        for (FolderNodeSave fns : folderNodeSaves)
        {
            openFolderNodeSave(fileVersion, managerTree, node, fns, customModels);
        }
    }

    private void openLoadCustomModelDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");

        JCheckBox priorityCheckbox = new JCheckBox("Set Priority?");
        priorityCheckbox.setToolTipText("May resolve some rendering issues by setting all faces to the same priority. Leave off if you're unsure");

        JPanel accessory = new JPanel();
        accessory.setLayout(new GridLayout(0, 1));
        accessory.add(priorityCheckbox);

        fileChooser.setAccessory(accessory);

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            plugin.loadCustomModel(selectedFile);
        }
    }

    private String getPluginVersion()
    {
        try (InputStream is = CreatorsPlugin.class.getResourceAsStream("/version.txt"))
        {
            if (is == null)
            {
                return "0.0.0";
            }

            String text = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8)).readLine();
            String version = text.split("=")[1];
            is.close();
            return version;
        }
        catch (IOException e)
        {
            return "0.0.0";
        }
    }

    private boolean isVersionLessThan(String version1, String version2)
    {
        String[] split1 = version1.split("\\.");
        int first1 = Integer.parseInt(split1[0]);
        int second1 = Integer.parseInt(split1[1]);
        int third1 = Integer.parseInt(split1[2]);

        String[] split2 = version2.split("\\.");
        int first2 = Integer.parseInt(split2[0]);
        int second2 = Integer.parseInt(split2[1]);
        int third2 = Integer.parseInt(split2[2]);

        if (first1 < first2)
        {
            return true;
        }

        if (first1 > first2)
        {
            return false;
        }

        if (second1 < second2)
        {
            return true;
        }

        if (second1 > second2)
        {
            return false;
        }

        if (third1 < third2)
        {
            return true;
        }

        if (third1 > third2)
        {
            return false;
        }

        return false;
    }

    private void setKeyBindings()
    {
        ActionMap actionMap = getActionMap();
        InputMap inputMap = getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK), "VK_S");
        actionMap.put("VK_S", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                plugin.getCreatorsPanel().quickSaveToFile();
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK), "VK_O");
        actionMap.put("VK_O", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                plugin.getCreatorsPanel().openLoadSetupDialog();
            }
        });
    }
}
package com.creatorskit.swing;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public class StringHandler
{
    public static String cleanString(String string)
    {
        return string.replaceAll("\\P{Print}", "?");
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.*;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.Enumeration;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.*;

@Getter
public class ManagerTree extends JTree
{
    private final ToolBoxFrame toolBox;
    private final CreatorsPlugin plugin;
    private final JPanel objectHolder;
    private final DefaultMutableTreeNode rootNode;
    private final DefaultMutableTreeNode sidePanelNode;
    private final DefaultMutableTreeNode managerNode;
    private final ManagerTreeModel treeModel;
    private final GridBagConstraints c = new GridBagConstraints();
    private Folder[] selectedFolders = new Folder[0];
    private final int ROW_HEIGHT = 28;

    private final BufferedImage FOLDER_OPEN = ImageUtil.loadImageResource(getClass(), "/Folder_Open.png");
    private final BufferedImage FOLDER_CLOSED = ImageUtil.loadImageResource(getClass(), "/Folder_Closed.png");
    private final BufferedImage OBJECT = ImageUtil.loadImageResource(getClass(), "/Object.png");

    private final Color backgroundSelectionColor = ColorScheme.MEDIUM_GRAY_COLOR;
    private final Color backgroundNonSelectionColor1 = ColorScheme.DARKER_GRAY_COLOR;
    private final Color backgroundNonSelectionColor2 = new Color(33, 33, 33);

    @Inject
    public ManagerTree(ToolBoxFrame toolBox, CreatorsPlugin plugin, JPanel objectHolder, DefaultMutableTreeNode rootNode, DefaultMutableTreeNode sidePanelNode, DefaultMutableTreeNode managerNode)
    {
        this.toolBox = toolBox;
        this.plugin = plugin;
        this.objectHolder = objectHolder;
        this.rootNode = rootNode;
        this.sidePanelNode = sidePanelNode;
        this.managerNode = managerNode;

        setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));

        rootNode.add(sidePanelNode);
        rootNode.add(managerNode);

        treeModel = new ManagerTreeModel(rootNode, sidePanelNode, managerNode, plugin);
        setModel(treeModel);
        expandRow(0);
        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setEditable(true);
        setOpaque(false);
        setRowHeight(ROW_HEIGHT);
        getSelectionModel().setSelectionMode(TreeSelectionModel.CONTIGUOUS_TREE_SELECTION);
        setShowsRootHandles(true);
        setRootVisible(false);
        setDragEnabled(true);
        setDropMode(DropMode.ON_OR_INSERT);
        setTransferHandler(new ManagerTreeTransferHandler(plugin, toolBox));
        addTreeSelectionListener(new MyTreeSelectionListener());
        addTreeExpansionListener(new TreeExpansionListener()
        {
            @Override
            public void treeExpanded(TreeExpansionEvent event)
            {
                updateTreeSelectionIndex();
            }

            @Override
            public void treeCollapsed(TreeExpansionEvent event)
            {
                updateTreeSelectionIndex();
            }
        });

        ActionMap actionMap = getActionMap();
        actionMap.put("cut", null);
        actionMap.put("copy", null);
        actionMap.put("paste", null);
        actionMap.getParent().put("cut", null);
        actionMap.getParent().put("copy", null);
        actionMap.getParent().put("paste", null);

        ManagerTreeCellRenderer renderer = new ManagerTreeCellRenderer();
        setCellRenderer(renderer);

        setMouseListeners();
    }

    @Override
    public void paintComponent(Graphics g)
    {
        g.setColor(ColorScheme.DARKER_GRAY_COLOR);
        g.fillRect(0, 0, getWidth(), getHeight());

        boolean colour1 = true;
        for (int i = 0; i < getRowCount(); i++)
        {
            Rectangle r = getRowBounds(i);
            g.setColor(colour1 ? backgroundNonSelectionColor1 : backgroundNonSelectionColor2);
            g.fillRect(0, r.y, getWidth(), r.height);
            colour1 = !colour1;
        }

        super.paintComponent(g);
    }

    public DefaultMutableTreeNode getParentFolderNode(ParentPanel parentPanel, boolean switching)
    {
        DefaultMutableTreeNode defaultNode = parentPanel == ParentPanel.MANAGER ? managerNode : sidePanelNode;
        DefaultMutableTreeNode parentFolderNode;
        TreePath parentPath = getSelectionPath();

        if (parentPath == null)
        {
            return defaultNode;
        }

        parentFolderNode = (DefaultMutableTreeNode) (parentPath.getLastPathComponent());
        if (parentFolderNode.getUserObject() instanceof Character)
        {
            Character character = (Character) parentFolderNode.getUserObject();
            parentFolderNode = character.getParentManagerNode();
        }

        if (parentFolderNode == null)
        {
            parentFolderNode = defaultNode;
        }

        if (switching)
        {
            if (parentPanel == ParentPanel.SIDE_PANEL && !treeContainsSidePanel(parentFolderNode))
            {
                parentFolderNode = sidePanelNode;
            }

            if (parentPanel == ParentPanel.MANAGER && treeContainsSidePanel(parentFolderNode))
            {
                parentFolderNode = managerNode;
            }
        }

        return parentFolderNode;
    }

    public DefaultMutableTreeNode addFolderNode(String name, ParentPanel parentPanel)
    {
        return addFolderNode(getParentFolderNode(parentPanel, false), name, true);
    }

    public DefaultMutableTreeNode addFolderNode(DefaultMutableTreeNode parent, String name)
    {
        return addFolderNode(parent, name, false);
    }

    public DefaultMutableTreeNode addFolderNode(DefaultMutableTreeNode managerParent, String name, boolean shouldBeVisible)
    {
        if (managerParent == rootNode)
        {
            managerParent = managerNode;
        }

        Folder folder = new Folder(name, FolderType.STANDARD, null, managerParent);
        DefaultMutableTreeNode linkedManagerNode = new DefaultMutableTreeNode(folder);
        folder.setLinkedManagerNode(linkedManagerNode);

        treeModel.insertNodeInto(linkedManagerNode, managerParent, managerParent.getChildCount());

        if (shouldBeVisible)
            scrollPathToVisible(new TreePath(linkedManagerNode.getPath()));

        return linkedManagerNode;
    }

    /**
     * Adds a character node to the currently selected ManagerTree node. Creates a linked ManagerTree node and remembers the selected Parent node
     * @param character the character to add to the selected node
     * @param parentPanel the ParentPanel to which the character will be added (SidePanel or ManagerPanel)
     * @param shouldBeVisible visibility
     * @return the linked ManagerTree node
     */
    public DefaultMutableTreeNode addCharacterNode(Character character, ParentPanel parentPanel, boolean shouldBeVisible, boolean switching)
    {
        return addCharacterNode(getParentFolderNode(parentPanel, switching), character, parentPanel, shouldBeVisible);
    }

    // Adds the character to a previously indicated parent
    public DefaultMutableTreeNode addCharacterNode(DefaultMutableTreeNode parent, Character character, ParentPanel parentPanel)
    {
        return addCharacterNode(parent, character, parentPanel, false);
    }

    /**
     * Adds a character node to the indicated ManagerTree node. Creates a linked ManagerTree node and remembers the indicated Parent node
     * @param managerParent the parent node in the ManagerTree to which to attach the new node
     * @param character the character to add to the selected node
     * @param parentPanel the ParentPanel to which the character will be added (SidePanel or ManagerPanel)
     * @param shouldBeVisible visibility
     * @return the linked ManagerTree node
     */
    public DefaultMutableTreeNode addCharacterNode(DefaultMutableTreeNode managerParent, Character character, ParentPanel parentPanel, boolean shouldBeVisible)
    {
        if (managerParent == rootNode)
        {
            managerParent = parentPanel == ParentPanel.MANAGER ? managerNode : sidePanelNode;
        }

        if (managerParent == managerNode && parentPanel == ParentPanel.SIDE_PANEL)
        {
            managerParent = sidePanelNode;
        }

        if (managerParent == sidePanelNode && parentPanel == ParentPanel.MANAGER)
        {
            managerParent = managerNode;
        }

        DefaultMutableTreeNode linkedManagerNode = new DefaultMutableTreeNode(character);
        character.setParentPanel(parentPanel);
        character.setLinkedManagerNode(linkedManagerNode);
        character.setParentManagerNode(managerParent);

        treeModel.insertNodeInto(linkedManagerNode, managerParent, managerParent.getChildCount());

        if (shouldBeVisible)
            scrollPathToVisible(new TreePath(linkedManagerNode.getPath()));

        return linkedManagerNode;
    }

    public void removeAllNodes()
    {
        int result = JOptionPane.showConfirmDialog(null, "Are you sure you want to create a new Setup file? All unsaved changes will be lost");
        if (result != JOptionPane.YES_OPTION)
        {
            return;
        }

        TreePath[] treePaths = new TreePath[]{new TreePath(rootNode.getPath())};
        removeNodes(treePaths, false);

        plugin.getCreatorsPanel().updateLoadedFile(null);
        SwingUtilities.invokeLater(() ->
        {
            toolBox.repaint();
            toolBox.revalidate();
        });
    }

    public void removeNodes(TreePath[] paths, boolean showWarning)
    {
        ArrayList<DefaultMutableTreeNode> charactersToRemove = new ArrayList<>();
        ArrayList<DefaultMutableTreeNode> foldersToRemove = new ArrayList<>();

        for (TreePath path : paths)
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            if (node.getUserObject() instanceof Character)
            {
                charactersToRemove.add(node);
                continue;
            }

            Folder folder = (Folder) node.getUserObject();
            {
                FolderType type = folder.getFolderType();
                if (type == FolderType.STANDARD)
                {
                    foldersToRemove.add(node);
                }
            }

            getNodeChildren(node, charactersToRemove, foldersToRemove);
        }

        if (foldersToRemove.isEmpty() && charactersToRemove.isEmpty())
        {
            return;
        }

        if (showWarning && foldersToRemove.size() + charactersToRemove.size() > 1)
        {
            int result = JOptionPane.showConfirmDialog(null, "Are you sure you want to delete all the selected Folders and their Objects?");
            if (result != JOptionPane.YES_OPTION)
            {
                return;
            }
        }

        Character[] characters = new Character[charactersToRemove.size()];
        for (int i = 0; i < characters.length; i++)
        {
            Character character = (Character) charactersToRemove.get(i).getUserObject();
            characters[i] = character;
        }

        Thread thread = new Thread(() ->
        {
            plugin.getCreatorsPanel().deleteCharacters(characters);
            for (DefaultMutableTreeNode node : foldersToRemove)
            {
                removeFolderNode(node);
            }

            getCellEditor().cancelCellEditing();
        });
        thread.start();
    }

    public void removeCharacterNode(Character child)
    {
        treeModel.removeNodeFromParent(child.getLinkedManagerNode());
    }

    public void removeFolderNode(DefaultMutableTreeNode folderNode)
    {
        treeModel.removeNodeFromParent(folderNode);
    }

    public void getNodeChildren(DefaultMutableTreeNode parent, ArrayList<DefaultMutableTreeNode> panelsToRemove, ArrayList<DefaultMutableTreeNode> foldersToRemove)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                panelsToRemove.add(node);
                continue;
            }

            Folder folder = (Folder) node.getUserObject();
            {
                FolderType type = folder.getFolderType();
                if (type == FolderType.STANDARD)
                {
                    foldersToRemove.add(node);
                }
            }

            if (!node.isLeaf())
                getNodeChildren(node, panelsToRemove, foldersToRemove);
        }
    }

    public void getSidePanelChildren(ArrayList<Character> characters)
    {
        getCharacterNodeChildren(sidePanelNode, characters);
    }

    public void getCharacterNodeChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                characters.add((Character) node.getUserObject());
                continue;
            }

            if (!node.isLeaf())
                getCharacterNodeChildren(node, characters);
        }
    }

    public void getAllNodes(DefaultMutableTreeNode parent, ArrayList<DefaultMutableTreeNode> nodes)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            nodes.add(node);
            if (!node.isLeaf())
                getAllNodes(node, nodes);
        }
    }

    public void getObjectPanelChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        if (parent.getUserObject() instanceof Character)
        {
            characters.add((Character) parent.getUserObject());
            return;
        }

        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            Object object = node.getUserObject();
            if (object instanceof Character)
            {
                Character character = (Character) object;
                if (!characters.contains(character))
                    characters.add(character);
            }

            if (!node.isLeaf())
                getObjectPanelChildren(node, characters);
        }
    }

    class MyTreeSelectionListener implements TreeSelectionListener
    {
        @Override
        public void valueChanged(TreeSelectionEvent event)
        {
            TreePath[] treePaths = getSelectionPaths();
            if (treePaths == null)
            {
                plugin.getCreatorsPanel().setSelectedCharacter(null, false);
                return;
            }

            updateTreeSelectionIndex();

            DefaultMutableTreeNode first = (DefaultMutableTreeNode) (treePaths[0].getLastPathComponent());
            if (first.getUserObject() instanceof Character)
            {
                plugin.getCreatorsPanel().setSelectedCharacter((Character) first.getUserObject(), false);
            }
            else
            {
                plugin.getCreatorsPanel().setSelectedCharacter(null, false);
            }

            JPanel objectHolder = toolBox.getManagerPanel().getObjectHolder();

            boolean containsSidePanel = false;
            for (TreePath treePath : treePaths)
            {
                if (treePath.getLastPathComponent() == rootNode)
                {
                    objectHolder.removeAll();
                    objectHolder.revalidate();
                    return;
                }

                if (treeContainsSidePanel((TreeNode) treePath.getLastPathComponent()))
                {
                    containsSidePanel = true;
                }
            }

            ArrayList<Character> panelsToAdd = new ArrayList<>();
            Folder[] folders = new Folder[0];

            boolean folderSelected = false;
            String folderName = "";
            for (TreePath treePath : treePaths)
            {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath.getLastPathComponent();
                if (node.getUserObject() instanceof Folder)
                {
                    Folder folder = (Folder) node.getUserObject();
                    if (folderName.isEmpty())
                    {
                        folderName = folder.getName();
                    }

                    folderSelected = true;
                    folders = ArrayUtils.add(folders, folder);
                }
            }

            if (folderSelected)
            {
                for (TreePath treePath : treePaths)
                {
                    getObjectPanelChildren((DefaultMutableTreeNode) treePath.getLastPathComponent(), panelsToAdd);
                }
            }
            else
            {
                TreePath parentPath = treePaths[0].getParentPath();
                if (parentPath == null)
                    return;

                DefaultMutableTreeNode folderNode = (DefaultMutableTreeNode) parentPath.getLastPathComponent();
                Folder folder = (Folder) folderNode.getUserObject();
                folderName = folder.getName();
                getObjectPanelChildren(folderNode, panelsToAdd);
                folders = ArrayUtils.add(folders, folder);
            }

            selectedFolders = folders;

            toolBox.getManagerPanel().getObjectLabel().setText("Current Folder: " + folderName);
            resetObjectHolder(panelsToAdd, containsSidePanel);
        }
    }

    public boolean treeContainsSidePanel(TreeNode node)
    {
        if (node == sidePanelNode)
        {
            return true;
        }

        TreeNode parent = node.getParent();
        if (parent == null || parent == managerNode || parent == rootNode)
        {
            return false;
        }

        if (parent == sidePanelNode)
        {
            return true;
        }

        return treeContainsSidePanel(parent);
    }

    public void resetObjectHolder()
    {
        ArrayList<Character> list = new ArrayList<>();
        for (Folder folder : selectedFolders)
        {
            DefaultMutableTreeNode node = folder.getLinkedManagerNode();
            getCharacterNodeChildren(node, list);
        }

        JPanel[] objectPanels = new JPanel[0];
        for (Character character : list)
        {
            if (character.getParentPanel() == ParentPanel.MANAGER)
            {
                objectPanels = ArrayUtils.add(objectPanels, character.getObjectPanel());
            }
        }

        resetObjectHolder(objectPanels, false);
    }

    public void resetObjectHolder(ArrayList<Character> charactersToAdd, boolean sidePanel)
    {
        resetObjectHolder(charactersToAdd.toArray(new Character[charactersToAdd.size()]), sidePanel);
    }

    public void resetObjectHolder(Character[] charactersToAdd, boolean sidePanel)
    {
        JPanel[] panelsToAdd = new JPanel[charactersToAdd.length];

        for (int i = 0; i < charactersToAdd.length; i++)
        {
            panelsToAdd[i] = charactersToAdd[i].getObjectPanel();
        }
        resetObjectHolder(panelsToAdd, sidePanel);
    }

    public void resetObjectHolder(JPanel[] panelsToAdd, boolean sidePanel)
    {
        if (sidePanel)
        {
            objectHolder.removeAll();
            objectHolder.revalidate();
            return;
        }

        JPanel managerHolder = toolBox.getManagerPanel().getObjectHolder();
        managerHolder.removeAll();

        for (JPanel objectPanel : panelsToAdd)
        {
            managerHolder.add(objectPanel);
        }

        toolBox.getManagerPanel().revalidate();
        toolBox.getManagerPanel().repaint();
    }

    public void onPanelScrolled(int scroll)
    {
        toolBox.getTimeSheetPanel().getSummarySheet().onVerticalScrollEvent(scroll);
    }

    public void setTreeSelection(Character character)
    {
        if (character == null)
        {
            updateTreeSelectionIndex();
            return;
        }

        TreePath treePath = new TreePath(character.getLinkedManagerNode().getPath());
        setSelectionPath(treePath);
        scrollPathToVisible(treePath);
        updateTreeSelectionIndex();
    }

    public void scrollSelectedIndex(int direction)
    {
        int current = getLeadSelectionRow();
        int rows = getRowCount();

        int index = current + direction;
        if (current == -1)
        {
            if (direction >= 0)
            {
                index = 0;
            }

            if (direction < 0)
            {
                index = rows - 1;
            }
        }

        if (index > rows - 1)
        {
            index = 0;
        }

        if (index < 0)
        {
            index = rows - 1;
        }

        setSelectionRow(index);
        updateTreeSelectionIndex();
    }

    public void updateTreeSelectionIndex()
    {
        int[] rows = getSelectionRows();
        int current = getLeadSelectionRow();
        if (current == -1)
        {
            toolBox.getTimeSheetPanel().getSummarySheet().setSelectedIndex(-1);
            return;
        }

        int row = 0;
        if (rows != null && rows.length > 0)
        {
            row = rows[0];
        }

        toolBox.getTimeSheetPanel().getSummarySheet().setSelectedIndex(row);
    }

    private void setMouseListeners()
    {
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                super.mousePressed(e);
                if (e.getButton() == MouseEvent.BUTTON3)
                {
                    onMouseButton3Pressed(e.getPoint());
                }
            }
        });
    }

    public void setRowSelection(Point p)
    {
        int x = (int) p.getX();
        int y = (int) p.getY();
        int row = getClosestRowForLocation(x, y);

        TreePath path = getPathForRow(row);
        if (path == null)
        {
            return;
        }

        setSelectionRow(row);
    }

    private void onMouseButton3Pressed(Point p)
    {
        int x = (int) p.getX();
        int y = (int) p.getY();
        int row = getClosestRowForLocation(x, y);

        TreePath path = getPathForRow(row);
        if (path == null)
        {
            return;
        }

        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();

        if (!(node.getUserObject() instanceof Character))
        {
            return;
        }

        Character character = (Character) node.getUserObject();
        toolBox.getTimeSheetPanel().getSummarySheet().showSummaryPopup(this, character, x, y);
    }
}


package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.StringHandler;
import com.creatorskit.swing.ToolBoxFrame;

import javax.inject.Inject;
import javax.swing.tree.*;

public class ManagerTreeModel extends DefaultTreeModel
{
    private final CreatorsPlugin plugin;
    private final DefaultMutableTreeNode sidePanelNode;
    private final DefaultMutableTreeNode managerNode;

    @Inject
    public ManagerTreeModel(TreeNode root, DefaultMutableTreeNode sidePanelNode, DefaultMutableTreeNode managerNode, CreatorsPlugin plugin)
    {
        super(root);
        this.plugin = plugin;
        this.sidePanelNode = sidePanelNode;
        this.managerNode = managerNode;
    }

    @Override
    public void valueForPathChanged(TreePath path, Object newValue)
    {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
        if (node == root
                || node == sidePanelNode
                || node == managerNode)
        {
            return;
        }

        ToolBoxFrame toolBox = plugin.getCreatorsPanel().getToolBox();

        //Check if node being modified is a Folder
        if (node.getUserObject() instanceof Folder)
        {
            Folder folder = (Folder) node.getUserObject();
            String name = StringHandler.cleanString((String) newValue);
            folder.setName(name);
            node.setUserObject(folder);
            nodeChanged(node);
            toolBox.getManagerPanel().getObjectLabel().setText("Current Folder: " + name);
        }

        //Check if node being modified is an ObjectPanel
        if (node.getUserObject() instanceof Character)
        {
            Character character = (Character) node.getUserObject();
            String name = StringHandler.cleanString((String) newValue);
            character.setName(name);
            character.getNameField().setText(name);
            node.setUserObject(character);
            nodeChanged(node);
            toolBox.getTimeSheetPanel().getAttributePanel().updateObjectLabel(character);
        }
    }
}

package com.creatorskit.swing.manager;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.tree.DefaultMutableTreeNode;

@Getter
@Setter
@AllArgsConstructor
public class Folder
{
    private String name;
    private FolderType folderType;
    private DefaultMutableTreeNode linkedManagerNode;
    private DefaultMutableTreeNode parentManagerNode;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.swing.ParentPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.image.BufferedImage;

public class TreeScrollPane extends JScrollPane
{
    private final ManagerTree tree;
    private final GridBagConstraints c = new GridBagConstraints();

    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage ADD = ImageUtil.loadImageResource(getClass(), "/Add.png");
    private final BufferedImage NEW = ImageUtil.loadImageResource(getClass(), "/New.png");

    public TreeScrollPane(ManagerTree tree)
    {
        this.tree = tree;

        JPanel folderHeader = setupFolderHeader();
        setColumnHeaderView(folderHeader);

        JScrollBar scrollBar = getVerticalScrollBar();
        scrollBar.addAdjustmentListener(e -> tree.onPanelScrolled(scrollBar.getValue()));
    }

    private JPanel setupFolderHeader()
    {
        Dimension buttonDimension = new Dimension(40, 18);

        JPanel folderHeader = new JPanel();
        folderHeader.setLayout(new GridBagLayout());
        folderHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 1;
        c.weighty = 0;
        JLabel folderLabel = new JLabel("Folders");
        folderLabel.setHorizontalAlignment(SwingConstants.CENTER);
        folderLabel.setVerticalAlignment(SwingConstants.CENTER);
        folderLabel.setFont(FontManager.getRunescapeBoldFont());
        folderHeader.add(folderLabel, c);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 0;
        JButton addFolderButton = new JButton(new ImageIcon(ADD));
        addFolderButton.setPreferredSize(buttonDimension);
        addFolderButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        addFolderButton.setToolTipText("Add a new Folder to the currently selected Folder");
        addFolderButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        addFolderButton.addActionListener(e ->
        {
            TreePath path = tree.getSelectionPath();
            DefaultMutableTreeNode folderNode;
            if (path == null)
            {
                folderNode = tree.addFolderNode("New Folder", ParentPanel.MANAGER);
            }
            else
            {
                DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
                ParentPanel parentPanel = tree.treeContainsSidePanel(node) ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
                folderNode = tree.addFolderNode("New Folder", parentPanel);
            }

            TreePath treePath = new TreePath(folderNode.getPath());
            int row = tree.getRowForPath(new TreePath(folderNode.getPath()));
            tree.expandRow(row);
            tree.setSelectionPath(treePath);
        });
        folderHeader.add(addFolderButton, c);

        c.gridx = 2;
        c.gridy = 0;
        JButton removeFolderButton = new JButton(new ImageIcon(CLOSE));
        removeFolderButton.setPreferredSize(buttonDimension);
        removeFolderButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        removeFolderButton.setToolTipText("Remove the currently selected Object or Folder and all children");
        removeFolderButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        removeFolderButton.addActionListener(e ->
        {
            TreePath[] treePaths = tree.getSelectionPaths();
            if (treePaths == null)
                return;

            tree.removeNodes(treePaths, true);
        });
        folderHeader.add(removeFolderButton, c);

        c.gridx = 3;
        c.gridy = 0;
        JButton newSetupButton = new JButton(new ImageIcon(NEW));
        newSetupButton.setPreferredSize(buttonDimension);
        newSetupButton.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR));
        newSetupButton.setToolTipText("Create a new Setup file");
        newSetupButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        newSetupButton.addActionListener(e ->
        {
            Thread thread = new Thread(tree::removeAllNodes);
            thread.start();
        });
        folderHeader.add(newSetupButton, c);

        return folderHeader;
    }
}

package com.creatorskit.swing.manager;

public enum FolderType
{
    MASTER,
    SIDE_PANEL,
    MANAGER,
    STANDARD
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import net.runelite.client.util.ImageUtil;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.TreeCellRenderer;
import java.awt.*;

public class ManagerTreeCellRenderer implements TreeCellRenderer
{
    DefaultTreeCellRenderer defaultRenderer = new DefaultTreeCellRenderer();

    private final ImageIcon FOLDER_OPEN = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Folder_Open.png"));
    private final ImageIcon FOLDER_CLOSED = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Folder_Closed.png"));
    private final ImageIcon OBJECT = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Object.png"));

    private final JPanel renderer = new JPanel();
    private final JLabel icon = new JLabel();
    private final JLabel name = new JLabel();

    public ManagerTreeCellRenderer()
    {
        renderer.add(icon);
        renderer.add(name);
    }

    @Override
    public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded, boolean leaf, int row, boolean hasFocus)
    {
        if (!(value instanceof DefaultMutableTreeNode))
        {
            return defaultRenderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
        }

        DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
        renderer.setOpaque(false);

        Object o = node.getUserObject();
        if (o instanceof Folder)
        {
            Folder folder = (Folder) o;

            if (expanded)
            {
                icon.setIcon(FOLDER_OPEN);
            }
            else
            {
                icon.setIcon(FOLDER_CLOSED);
            }

            name.setText(folder.getName());

            renderer.setEnabled(tree.isEnabled());
            return renderer;
        }

        if (o instanceof Character)
        {
            Character character = (Character) o;

            icon.setIcon(OBJECT);
            name.setText(character.getName());

            renderer.setEnabled(tree.isEnabled());
            return renderer;
        }

        return defaultRenderer.getTreeCellRendererComponent(tree, value, selected, expanded, leaf, row, hasFocus);
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.*;
import lombok.extern.slf4j.Slf4j;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.util.*;

@Slf4j
class ManagerTreeTransferHandler extends TransferHandler
{
    private final CreatorsPlugin plugin;
    private final ToolBoxFrame toolBox;
    private DataFlavor nodesFlavor;
    private DataFlavor[] flavors = new DataFlavor[1];
    private DefaultMutableTreeNode[] nodesToRemove;

    public ManagerTreeTransferHandler(CreatorsPlugin plugin, ToolBoxFrame toolBox)
    {
        this.plugin = plugin;
        this.toolBox = toolBox;
        try
        {
            String mimeType = DataFlavor.javaJVMLocalObjectMimeType +
                    ";class=\"" +
                    javax.swing.tree.DefaultMutableTreeNode[].class.getName() +
                    "\"";
            nodesFlavor = new DataFlavor(mimeType);
            flavors[0] = nodesFlavor;
        }
        catch(ClassNotFoundException e)
        {
            log.info("ClassNotFound: " + e.getMessage());
        }
    }

    public boolean canImport(TransferHandler.TransferSupport support)
    {
        if (!support.isDrop())
            return false;

        support.setShowDropLocation(true);
        if (!support.isDataFlavorSupported(nodesFlavor))
            return false;

        // Do not allow a drop on the drag source selections.
        JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
        JTree tree = (JTree) support.getComponent();
        int dropRow = tree.getRowForPath(dl.getPath());
        int[] selRows = tree.getSelectionRows();
        if (selRows == null || selRows.length == 0)
            return false;

        for (int i = 0; i < selRows.length; i++)
        {
            if (selRows[i] == dropRow)
                return false;

            DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)tree.getPathForRow(selRows[i]).getLastPathComponent();
            for (TreeNode offspring: Collections.list(treeNode.depthFirstEnumeration()))
            {
                if (tree.getRowForPath(new TreePath(((DefaultMutableTreeNode) offspring).getPath())) == dropRow)
                    return false;
            }
        }

        // If trying to insert into an ObjectPanel, cancel
        int childIndex = dl.getChildIndex();
        TreePath dest = dl.getPath();
        DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) dest.getLastPathComponent();
        if (childIndex == -1 && parentNode.getUserObject() instanceof Character)
            return false;

        if (parentNode.getUserObject() instanceof Folder)
        {
            Folder folder = (Folder) parentNode.getUserObject();
            if (folder.getFolderType() == FolderType.MASTER)
            {
                return false;
            }
        }

        return true;
    }

    protected Transferable createTransferable(JComponent c)
    {
        JTree tree = (JTree) c;
        TreePath[] paths = tree.getSelectionPaths();
        if (paths != null)
        {
            // Make up a node array of copies for transfer and
            // another for/of the nodes that will be removed in
            // exportDone after a successful drop.
            ArrayList<DefaultMutableTreeNode> copies = new ArrayList<>();
            ArrayList<DefaultMutableTreeNode> toRemove = new ArrayList<>();
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) paths[0].getLastPathComponent();
            HashSet<TreeNode> doneItems = new LinkedHashSet<>(paths.length);
            DefaultMutableTreeNode copy = copy(node, doneItems, tree);
            copies.add(copy);
            toRemove.add(node);
            for (int i = 1; i < paths.length; i++)
            {
                DefaultMutableTreeNode next = (DefaultMutableTreeNode)paths[i].getLastPathComponent();
                if (doneItems.contains(next))
                    continue;

                // Do not allow higher level nodes to be added to list.
                if (next.getLevel() < node.getLevel())
                {
                    break;
                }
                else if (next.getLevel() > node.getLevel())  // child node
                {
                    copy.add(copy(next, doneItems, tree));
                    // node already contains child
                }
                else
                {  // sibling
                    copies.add(copy(next, doneItems, tree));
                    toRemove.add(next);
                }
                doneItems.add(next);
            }
            DefaultMutableTreeNode[] nodes = copies.toArray(new DefaultMutableTreeNode[copies.size()]);

            nodesToRemove = toRemove.toArray(new DefaultMutableTreeNode[toRemove.size()]);
            return new ManagerTreeTransferHandler.NodesTransferable(nodes);
        }
        return null;
    }

    private DefaultMutableTreeNode copy(DefaultMutableTreeNode node, HashSet<TreeNode> doneItems, JTree tree)
    {
        DefaultMutableTreeNode copy = new DefaultMutableTreeNode(node.getUserObject());
        doneItems.add(node);
        for (int i = 0; i < node.getChildCount(); i++)
        {
            copy.add(copy((DefaultMutableTreeNode)((TreeNode)node).getChildAt(i), doneItems, tree));
        }
        int row = tree.getRowForPath(new TreePath(copy.getPath()));
        tree.expandRow(row);
        return copy;
    }

    protected void exportDone(JComponent source, Transferable data, int action)
    {
        if ((action & MOVE) == MOVE)
        {
            JTree tree = (JTree)source;
            DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
            // Remove nodes saved in nodesToRemove in createTransferable.
            for (DefaultMutableTreeNode node : nodesToRemove)
                model.removeNodeFromParent(node);
        }

        plugin.getCreatorsPanel().resetSidePanel();
        toolBox.getManagerPanel().getManagerTree().resetObjectHolder();
    }

    public int getSourceActions(JComponent c)
    {
        return COPY_OR_MOVE;
    }

    public boolean importData(TransferHandler.TransferSupport support)
    {
        if (!canImport(support))
            return false;

        // Extract transfer data.
        DefaultMutableTreeNode[] nodes = null;
        try
        {
            Transferable t = support.getTransferable();
            nodes = (DefaultMutableTreeNode[]) t.getTransferData(nodesFlavor);
        }
        catch(UnsupportedFlavorException ufe)
        {
            log.info("UnsupportedFlavor: " + ufe.getMessage());
        }
        catch(java.io.IOException ioe)
        {
            log.info("I/O error: " + ioe.getMessage());
        }

        // Get drop location info.
        JTree.DropLocation dl = (JTree.DropLocation) support.getDropLocation();
        int childIndex = dl.getChildIndex();
        TreePath dest = dl.getPath();
        DefaultMutableTreeNode parentNode = (DefaultMutableTreeNode) (dest.getLastPathComponent());

        ManagerPanel managerPanel = toolBox.getManagerPanel();
        boolean sendToSidePanel = managerPanel.getManagerTree().treeContainsSidePanel(parentNode);
        ParentPanel newParent = sendToSidePanel ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
        ArrayList<Character> sidePanelCharacters = plugin.getCreatorsPanel().getSidePanelCharacters();
        ArrayList<Character> managerCharacters = managerPanel.getManagerCharacters();

        ArrayList<Character> arrayTo;
        if (sendToSidePanel)
        {
            arrayTo = sidePanelCharacters;
        }
        else
        {
            arrayTo = managerCharacters;
        }

        // Prevent Protected folders from being transferred
        for (DefaultMutableTreeNode node : nodes)
        {
            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                FolderType type = folder.getFolderType();
                if (type == FolderType.MANAGER
                        || type == FolderType.MASTER
                        || type == FolderType.SIDE_PANEL)
                {
                    return false;
                }
            }
        }

        JTree tree = (JTree) support.getComponent();
        DefaultTreeModel model = (DefaultTreeModel) tree.getModel();
        // Configure for drop mode.
        int index = childIndex;    // DropMode.INSERT
        if (childIndex == -1)     // DropMode.ON
        {
            index = parentNode.getChildCount();
        }

        ArrayList<Character> characters = new ArrayList<>();

        // Add data to model.
        for (int i = 0; i < nodes.length; i++)
        {
            DefaultMutableTreeNode node = nodes[i];
            model.insertNodeInto(node, parentNode, index++);

            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                folder.setLinkedManagerNode(node);
                folder.setParentManagerNode(parentNode);
                getCharacterNodeChildren(node, characters);
                updateChildren(node);
            }

            if (node.getUserObject() instanceof Character)
            {
                Character character = (Character) node.getUserObject();
                character.setLinkedManagerNode(node);
                character.setParentManagerNode((DefaultMutableTreeNode) node.getParent());
                characters.add(character);
            }
        }

        for (Character character : characters)
        {
            ParentPanel oldParent = character.getParentPanel();
            character.setParentPanel(newParent);

            ArrayList<Character> arrayFrom;
            if (oldParent == ParentPanel.SIDE_PANEL)
            {
                arrayFrom = sidePanelCharacters;
            }
            else
            {
                arrayFrom = managerCharacters;
            }

            arrayFrom.remove(character);
            arrayTo.add(character);
        }

        tree.setSelectionPath(dest);
        tree.expandPath(dest);
        return true;
    }

    private void updateChildren(DefaultMutableTreeNode parent)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Folder)
            {
                Folder folder = (Folder) node.getUserObject();
                folder.setLinkedManagerNode(node);
                folder.setParentManagerNode(parent);
            }

            if (node.getUserObject() instanceof Character)
            {
                Character character = (Character) node.getUserObject();
                character.setLinkedManagerNode(node);
                character.setParentManagerNode(parent);
            }

            if (!node.isLeaf())
                updateChildren(node);
        }
    }

    public String toString()
    {
        return getClass().getName();
    }

    public class NodesTransferable implements Transferable
    {
        DefaultMutableTreeNode[] nodes;

        public NodesTransferable(DefaultMutableTreeNode[] nodes)
        {
            this.nodes = nodes;
        }

        public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException
        {
            if (!isDataFlavorSupported(flavor))
                throw new UnsupportedFlavorException(flavor);
            return nodes;
        }

        public DataFlavor[] getTransferDataFlavors()
        {
            return flavors;
        }

        public boolean isDataFlavorSupported (DataFlavor flavor)
        {
            return nodesFlavor.equals(flavor);
        }
    }

    public void getCharacterNodeChildren(DefaultMutableTreeNode parent, ArrayList<Character> characters)
    {
        Enumeration<TreeNode> children = parent.children();
        while (children.hasMoreElements())
        {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode) children.nextElement();
            if (node.getUserObject() instanceof Character)
            {
                characters.add((Character) node.getUserObject());
                continue;
            }

            if (!node.isLeaf())
                getCharacterNodeChildren(node, characters);
        }
    }
}

package com.creatorskit.swing.manager;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.CreatorsPanel;
import com.creatorskit.swing.ParentPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;

@Slf4j
@Getter
public class ManagerPanel extends JPanel
{
    private final CreatorsPlugin plugin;
    private final Client client;
    private final GridBagConstraints c = new GridBagConstraints();
    private final JPanel objectHolder;
    private final TreeScrollPane treeScrollPane;
    private final ArrayList<Character> managerCharacters = new ArrayList<>();
    private final ManagerTree managerTree;
    private final JLabel objectLabel = new JLabel("Current Folder: Master Folder");

    @Inject
    public ManagerPanel(@Nullable Client client, CreatorsPlugin plugin, JPanel objectHolder, ManagerTree managerTree)
    {
        this.plugin = plugin;
        this.client = client;
        this.objectHolder = objectHolder;
        this.managerTree = managerTree;

        setBackground(ColorScheme.DARKER_GRAY_COLOR);
        setLayout(new BorderLayout(2, 2));
        setBorder(new EmptyBorder(2, 2, 2, 2));

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        treeScrollPane = new TreeScrollPane(managerTree);
        treeScrollPane.setPreferredSize(new Dimension(350, 0));

        MouseWheelListener[] mouseWheelListeners = treeScrollPane.getMouseWheelListeners();
        for (int i = 0; i < mouseWheelListeners.length; i++)
        {
            treeScrollPane.removeMouseWheelListener(mouseWheelListeners[i]);
        }

        treeScrollPane.addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    managerTree.scrollSelectedIndex(e.getWheelRotation());
                    return;
                }

                JScrollBar bar = treeScrollPane.getVerticalScrollBar();
                bar.setValue(bar.getValue() + e.getWheelRotation() * 15);
            }
        });

        add(treeScrollPane, BorderLayout.LINE_START);

        JScrollPane objectScrollPane = new JScrollPane();
        add(objectScrollPane, BorderLayout.CENTER);

        JPanel objectHeader = new JPanel();
        objectHeader.setBackground(ColorScheme.DARK_GRAY_COLOR);
        objectHeader.setLayout(new BorderLayout());
        objectScrollPane.setColumnHeaderView(objectHeader);

        objectLabel.setFont(FontManager.getRunescapeBoldFont());
        objectHeader.add(objectLabel, BorderLayout.LINE_START);

        JPanel rightButtons = new JPanel();
        objectHeader.add(rightButtons, BorderLayout.LINE_END);

        JButton addObjectButton = new JButton("Add Object");
        addObjectButton.setToolTipText("Add an new Object to the palette");
        addObjectButton.setFocusable(false);
        addObjectButton.setPreferredSize(new Dimension(150, 30));
        addObjectButton.addActionListener(e ->
        {
            if (client == null)
            {
                return;
            }

            CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();
            TreePath path = managerTree.getSelectionPath();

            if (path == null)
            {
                Character character = creatorsPanel.createCharacter(ParentPanel.MANAGER);
                creatorsPanel.addPanel(ParentPanel.MANAGER, character, true, false);
                return;
            }

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();
            ParentPanel parentPanel = managerTree.treeContainsSidePanel(node) ? ParentPanel.SIDE_PANEL : ParentPanel.MANAGER;
            Character character = creatorsPanel.createCharacter(parentPanel);
            creatorsPanel.addPanel(parentPanel, character, true, false);
        });
        rightButtons.add(addObjectButton);

        JPanel viewport = new JPanel();
        viewport.setLayout(new GridBagLayout());
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        c.fill = GridBagConstraints.VERTICAL;
        c.gridx = 0;
        c.gridy = 0;
        c.weightx = 0;
        c.weighty = 0;
        this.objectHolder.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.add(this.objectHolder, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 0;
        c.weighty = 1;
        viewport.add(new JLabel(""), c);

        this.objectHolder.setLayout(new GridLayout(0, 5, 4, 4));
        objectScrollPane.setViewportView(viewport);

        repaint();
        revalidate();
    }
}

package com.creatorskit.swing.anvil;

import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.*;
import com.creatorskit.swing.StringHandler;
import com.creatorskit.swing.colours.ColourSwapPanel;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.api.Model;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.ArrayList;

@Slf4j
public class ModelAnvil extends JPanel
{
    private ClientThread clientThread;
    private final Client client;
    private final CreatorsPlugin plugin;
    private final BufferedImage DUPLICATE = ImageUtil.loadImageResource(getClass(), "/Duplicate.png");
    private final BufferedImage CLOSE = ImageUtil.loadImageResource(getClass(), "/Close.png");
    private final BufferedImage ARROW_LEFT = ImageUtil.loadImageResource(getClass(), "/Arrow_Left.png");
    private final BufferedImage ARROW_RIGHT = ImageUtil.loadImageResource(getClass(), "/Arrow_Right.png");
    private final BufferedImage ARROW_DOWN = ImageUtil.loadImageResource(getClass(), "/Arrow_Down.png");
    private final BufferedImage ARROW_UP = ImageUtil.loadImageResource(getClass(), "/Arrow_Up.png");
    private final BufferedImage TRANSLATE = ImageUtil.loadImageResource(getClass(), "/Translate.png");
    private final BufferedImage ROTATE = ImageUtil.loadImageResource(getClass(), "/Rotate.png");
    private final BufferedImage TRANSLATE_SUBTILE = ImageUtil.loadImageResource(getClass(), "/Translate subtile.png");
    private final BufferedImage SCALE = ImageUtil.loadImageResource(getClass(), "/Scale.png");
    private final BufferedImage COPY_COLOURS = ImageUtil.loadImageResource(getClass(), "/Copy_Colours.png");
    private final BufferedImage PASTE_COLOURS = ImageUtil.loadImageResource(getClass(), "/Paste_Colours.png");
    private final Dimension SPINNER_DIMENSION = new Dimension(65, 25);
    private final Dimension LIGHT_DIMENSION = new Dimension(70, 25);
    @Getter
    private final JSpinner[] lightingSpinners = new JSpinner[5];
    private final JComboBox<LightingStyle> presetComboBox = new JComboBox<>();
    private final JSpinner ambSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getAmbient(), -1000, 1000, 1));
    private final JSpinner conSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getContrast(), 100, 9999, 1));
    private final JSpinner lightXSpinner = new JSpinner(new SpinnerNumberModel(LightingStyle.DEFAULT.getX(), -1000, 1000, 1));
    private final JSpinner lightYSpinner = new JSpinner((new SpinnerNumberModel(LightingStyle.DEFAULT.getY(), -1000, 1000, 1)));
    private final JSpinner lightZSpinner = new JSpinner((new SpinnerNumberModel(LightingStyle.DEFAULT.getZ(), -1000, 1000, 1)));
    private final Dimension BUTTON_DIMENSION = new Dimension(85, 25);
    @Getter
    private final ArrayList<ComplexPanel> complexPanels = new ArrayList<>();
    public static final File MODELS_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit");
    private final JPanel complexMode = new JPanel();
    private final JScrollPane scrollPane = new JScrollPane();
    private final JTabbedPane tabbedPane = new JTabbedPane();
    @Getter
    private final JCheckBox priorityCheckBox = new JCheckBox("Priority");
    @Getter
    private final JTextField nameField = new JTextField();
    private final ColourSwapPanel colourSwapPanel;
    private final GridBagConstraints c = new GridBagConstraints();
    private final int COMPLEX_GRID_COLUMNS = 3;

    @Inject
    public ModelAnvil(Client client, ClientThread clientThread, CreatorsPlugin plugin)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JLabel modelForgeLabel = new JLabel("Model Anvil");
        modelForgeLabel.setFont(FontManager.getRunescapeBoldFont());
        modelForgeLabel.setHorizontalAlignment(SwingConstants.CENTER);
        modelForgeLabel.setVerticalAlignment(SwingConstants.CENTER);
        add(modelForgeLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.ipady = 10;
        JPanel buttonsPanel = new JPanel();
        buttonsPanel.setLayout(new GridLayout(1, 0, 10, 0));
        add(buttonsPanel, c);

        nameField.setText("Name");
        nameField.setHorizontalAlignment(JTextField.CENTER);
        nameField.addActionListener(e -> nameField.setText(StringHandler.cleanString(nameField.getText())));
        nameField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                nameField.setText(StringHandler.cleanString(nameField.getText()));
            }
        });
        buttonsPanel.add(nameField);

        JButton forgeButton = new JButton("Forge");
        buttonsPanel.add(forgeButton);

        JButton forgeSetButton = new JButton("Forge & Set");
        buttonsPanel.add(forgeSetButton);

        c.gridx = 0;
        c.gridy = 2;
        c.weightx = 1;
        c.weighty = 1;
        c.ipady = 0;
        tabbedPane.setBorder(new LineBorder(ColorScheme.LIGHT_GRAY_COLOR, 1));
        add(tabbedPane, c);

        JPanel viewport = new JPanel();
        viewport.setLayout(new GridBagLayout());
        viewport.setBackground(ColorScheme.DARKER_GRAY_COLOR);

        scrollPane.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setViewportView(viewport);
        scrollPane.setViewportBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 8));
        tabbedPane.addTab("Model Anvil", scrollPane);

        c.insets = new Insets(0, 0, 0, 0);
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        complexMode.setLayout(new GridLayout(0, COMPLEX_GRID_COLUMNS, 8, 8));
        complexMode.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        viewport.add(complexMode, c);

        c.gridx = 0;
        c.gridy = 1;
        c.weightx = 1;
        c.weighty = 1;
        JLabel emptyLabel = new JLabel("");
        viewport.add(emptyLabel, c);

        colourSwapPanel = new ColourSwapPanel(client, clientThread, complexPanels);
        tabbedPane.addTab("Colour/Texture Swapper", colourSwapPanel);

        JPanel headerPanel = new JPanel();
        headerPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        scrollPane.setColumnHeaderView(headerPanel);

        JButton addButton = new JButton("Add");
        addButton.addActionListener(e -> createComplexPanel());
        headerPanel.add(addButton);

        JButton clearButton = new JButton("Clear");
        clearButton.addActionListener(e ->
        {
            for (JPanel complexModePanel : complexPanels)
            {
                complexMode.remove(complexModePanel);
                colourSwapPanel.removeAllComplexPanelOptions();
            }

            repaint();
            revalidate();
            complexPanels.clear();
        });
        headerPanel.add(clearButton);

        JPopupMenu loadPopupMenu = new JPopupMenu();
        JMenuItem menuItem = new JMenuItem("Load");
        menuItem.addActionListener(e -> LinkBrowser.open(MODELS_DIR.toString()));
        loadPopupMenu.add(menuItem);

        JButton loadButton = new JButton("Load");
        loadButton.addActionListener(e -> openLoadDialog());
        loadButton.setComponentPopupMenu(loadPopupMenu);
        headerPanel.add(loadButton);

        JButton saveButton = new JButton("Save");

        headerPanel.add(saveButton);

        priorityCheckBox.setToolTipText("Use an oversimplified method of resolving render order issues (can be useful when merging many models)");
        priorityCheckBox.setFocusable(false);
        headerPanel.add(priorityCheckBox);

        JPanel sidePanel = new JPanel();
        sidePanel.setLayout(new GridBagLayout());
        scrollPane.setRowHeaderView(sidePanel);

        JPanel lightPanel = new JPanel();
        lightPanel.setLayout(new GridBagLayout());
        lightPanel.setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));

        lightingSpinners[0] = ambSpinner;
        lightingSpinners[1] = conSpinner;
        lightingSpinners[2] = lightXSpinner;
        lightingSpinners[3] = lightYSpinner;
        lightingSpinners[4] = lightZSpinner;

        ambSpinner.setToolTipText("<html>Set the ambient lighting level<br>Range: -1000 to 1000</html>");
        conSpinner.setToolTipText("<html>Set the lighting contrast (higher is lower)<br>Range: 100 to 9999</html>");
        lightXSpinner.setToolTipText("<html>Set the sun's x coordinate relative to the player<br>Range: -1000 to 1000</html>");
        lightYSpinner.setToolTipText("<html>Set the sun's y coordinate relative to the player<br>Range: -1000 to 1000</html>");
        lightZSpinner.setToolTipText("<html>Set the sun's z coordinate relative to the player<br>Range: -1000 to 1000</html>");

        presetComboBox.addItem(LightingStyle.DEFAULT);
        presetComboBox.addItem(LightingStyle.ACTOR);
        presetComboBox.addItem(LightingStyle.SPOTANIM);
        presetComboBox.addItem(LightingStyle.DYNAMIC);
        presetComboBox.addItem(LightingStyle.NONE);
        presetComboBox.setFocusable(false);
        presetComboBox.setToolTipText("Quick lighting presets for common cases. Actor = NPCs/Players, SpotAnim = Spells/Effects");

        presetComboBox.addItemListener(e ->
        {
            LightingStyle preset = (LightingStyle) presetComboBox.getSelectedItem();
            if (preset == null)
                return;

            lightingSpinners[0].setValue(preset.getAmbient());
            lightingSpinners[1].setValue(preset.getContrast());
            lightingSpinners[2].setValue(preset.getX());
            lightingSpinners[3].setValue(preset.getY());
            lightingSpinners[4].setValue(preset.getZ());
        });

        c.weightx = 1;
        c.weighty = 0;
        c.insets = new Insets(4, 0, 4, 0);

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 4;
        JLabel lightingLabel = new JLabel("Lighting Settings", SwingConstants.CENTER);
        lightingLabel.setFont(FontManager.getRunescapeBoldFont());
        lightPanel.add(lightingLabel, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        lightPanel.add(new JLabel("Pre ", SwingConstants.RIGHT), c);

        c.gridx = 1;
        c.gridy = 1;
        presetComboBox.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(presetComboBox, c);

        c.gridx = 0;
        c.gridy = 2;
        lightPanel.add(new JLabel("Amb ", SwingConstants.RIGHT), c);

        c.gridx = 0;
        c.gridy = 3;
        lightPanel.add(new JLabel("Con ", SwingConstants.RIGHT), c);

        c.gridx = 1;
        c.gridy = 2;
        ambSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(ambSpinner, c);

        c.gridx = 1;
        c.gridy = 3;
        conSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(conSpinner, c);

        c.gridx = 2;
        c.gridy = 1;
        lightPanel.add(new JLabel("x ", SwingConstants.RIGHT), c);

        c.gridx = 2;
        c.gridy = 2;
        lightPanel.add(new JLabel("y ", SwingConstants.RIGHT), c);

        c.gridx = 2;
        c.gridy = 3;
        lightPanel.add(new JLabel("z ", SwingConstants.RIGHT), c);

        c.gridx = 3;
        c.gridy = 1;
        lightXSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightXSpinner, c);

        c.gridx = 3;
        c.gridy = 2;
        lightYSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightYSpinner, c);

        c.gridx = 3;
        c.gridy = 3;
        lightZSpinner.setPreferredSize(LIGHT_DIMENSION);
        lightPanel.add(lightZSpinner, c);

        JPanel groupPanel = new GroupPanel(client, plugin, clientThread);

        c.insets = new Insets(8, 8, 8, 8);

        c.gridx = 0;
        c.gridy = 0;
        sidePanel.add(lightPanel, c);

        c.gridx = 0;
        c.gridy = 1;
        sidePanel.add(groupPanel, c);

        c.gridx = 0;
        c.gridy = 2;
        c.weighty = 1;
        sidePanel.add(new JLabel(""), c);

        forgeButton.addActionListener(e -> onForgeButtonPressed(client, nameField, false));
        forgeSetButton.addActionListener(e -> onForgeButtonPressed(client, nameField, true));

        saveButton.addActionListener(e ->
        {
            CustomLighting lighting = new CustomLighting(
                    (int) lightingSpinners[0].getValue(),
                    (int) lightingSpinners[1].getValue(),
                    (int) lightingSpinners[2].getValue(),
                    (int) lightingSpinners[3].getValue(),
                    (int) lightingSpinners[4].getValue());

            openSaveDialog(nameField.getText(), priorityCheckBox.isSelected(), LightingStyle.CUSTOM, lighting);
        });

        revalidate();
    }

    public void createComplexPanel()
    {
        createComplexPanel(
                "Name",
                -1,
                1,
                0,
                0,
                0,
                0,
                0,
                0,
                128,
                128,
                128,
                0,
                "",
                "",
                new short[0],
                new short[0],
                new short[0],
                new short[0],
                false);
    }

    public void createComplexPanel(DetailedModel dm)
    {
        createComplexPanel(
                dm.getName(),
                dm.getModelId(),
                dm.getGroup(),
                dm.getXTile(),
                dm.getYTile(),
                dm.getZTile(),
                dm.getXTranslate(),
                dm.getYTranslate(),
                dm.getZTranslate(),
                dm.getXScale(),
                dm.getYScale(),
                dm.getZScale(),
                dm.getRotate(),
                dm.getRecolourNew(),
                dm.getRecolourOld(),
                dm.getColoursFrom(),
                dm.getColoursTo(),
                dm.getTexturesFrom(),
                dm.getTexturesTo(),
                dm.isInvertFaces());
    }

    public void createComplexPanel(
            String name,
            int modelId,
            int group,
            int xTile,
            int yTile,
            int zTile,
            int xTranslate,
            int yTranslate,
            int zTranslate,
            int scaleX,
            int scaleY,
            int scaleZ,
            int rotate,
            String newColours,
            String oldColours,
            short[] coloursFrom,
            short[] coloursTo,
            short[] texturesFrom,
            short[] texturesTo,
            boolean invertFaces)
    {
        JSpinner modelIdSpinner = new JSpinner();
        JSpinner groupSpinner = new JSpinner();
        JTextField nameField = new JTextField(name);
        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JCheckBox check90 = new JCheckBox();
        JCheckBox check180 = new JCheckBox();
        JCheckBox check270 = new JCheckBox();
        JCheckBox checkInvertFaces = new JCheckBox();

        if (coloursFrom == null)
            coloursFrom = stringToShort(oldColours);

        if (coloursTo == null)
            coloursTo = stringToShort(newColours);

        if (texturesFrom == null)
            texturesFrom = new short[0];

        if (texturesTo == null)
            texturesTo = new short[0];

        ComplexPanel complexModePanel = new ComplexPanel(
                modelIdSpinner,
                groupSpinner,
                nameField,
                coloursFrom, coloursTo,
                texturesFrom, texturesTo,
                xSpinner, ySpinner, zSpinner,
                xTileSpinner, yTileSpinner, zTileSpinner,
                xScaleSpinner, yScaleSpinner, zScaleSpinner,
                check90, check180, check270,
                checkInvertFaces);

        complexModePanel.setLayout(new GridBagLayout());
        complexModePanel.setBorder(new LineBorder(getBorderColour(modelId), 1));

        c.insets = new Insets(4, 4, 4, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 4;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        nameField.setToolTipText("Name for organizational purposes only");
        complexModePanel.add(nameField, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 2;
        JPanel arrowPanel = new JPanel();
        arrowPanel.setLayout(new BorderLayout());
        complexModePanel.add(arrowPanel, c);

        JButton arrowUpButton = new JButton(new ImageIcon(ARROW_UP));
        arrowUpButton.setFocusable(false);
        arrowUpButton.setToolTipText("Move panel up");
        arrowUpButton.addActionListener(e -> setPanelIndex(complexModePanel, -COMPLEX_GRID_COLUMNS));
        arrowPanel.add(arrowUpButton, BorderLayout.PAGE_START);

        JButton arrowLeftButton = new JButton(new ImageIcon(ARROW_LEFT));
        arrowLeftButton.setFocusable(false);
        arrowLeftButton.setToolTipText("Move panel left");
        arrowLeftButton.addActionListener(e -> setPanelIndex(complexModePanel, -1));
        arrowPanel.add(arrowLeftButton, BorderLayout.LINE_START);

        JButton arrowRightButton = new JButton(new ImageIcon(ARROW_RIGHT));
        arrowRightButton.setFocusable(false);
        arrowRightButton.setToolTipText("Move panel right");
        arrowRightButton.addActionListener(e -> setPanelIndex(complexModePanel, 1));
        arrowPanel.add(arrowRightButton, BorderLayout.LINE_END);

        JButton arrowDownButton = new JButton(new ImageIcon(ARROW_DOWN));
        arrowDownButton.setFocusable(false);
        arrowDownButton.setToolTipText("Move panel up");
        arrowDownButton.addActionListener(e -> setPanelIndex(complexModePanel, COMPLEX_GRID_COLUMNS));
        arrowPanel.add(arrowDownButton, BorderLayout.PAGE_END);

        c.weightx = 0;
        c.gridx = 1;
        c.gridy = 2;
        JPanel xyzPanel = new JPanel();
        xyzPanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(xyzPanel, c);

        JLabel xLabel = new JLabel("x:");
        xLabel.setToolTipText("East/West");
        xLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(xLabel);

        JLabel yLabel = new JLabel("y:");
        yLabel.setToolTipText("North/South");
        yLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(yLabel);

        JLabel zLabel = new JLabel("z:");
        zLabel.setToolTipText("Up/Down");
        zLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(zLabel);

        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 0;
        c.gridy = 3;
        JLabel colourLabel = new JLabel("Colours:");
        colourLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        colourLabel.setToolTipText("Choose new Colours to replace default Colours");
        complexModePanel.add(colourLabel, c);

        c.gridwidth = 2;
        c.gridx = 4;
        c.gridy = 0;
        SpinnerNumberModel modelIdModel = new SpinnerNumberModel(modelId, -1, 99999, 1);
        modelIdSpinner.setModel(modelIdModel);
        modelIdSpinner.setBackground((modelId == -1) ? ColorScheme.PROGRESS_ERROR_COLOR : ColorScheme.DARK_GRAY_COLOR);
        modelIdSpinner.setToolTipText("Set the id of the model you want to draw from the cache");
        modelIdSpinner.addChangeListener(e ->
        {
            int newValue = (int) modelIdSpinner.getValue();
            complexModePanel.setBorder(new LineBorder(getBorderColour(newValue), 1));
            modelIdSpinner.setBackground((newValue == -1) ? ColorScheme.PROGRESS_ERROR_COLOR : ColorScheme.DARK_GRAY_COLOR);
            if (colourSwapPanel.getComboBox().getSelectedItem() == complexModePanel)
                colourSwapPanel.onSwapperPressed(complexModePanel);
        });
        complexModePanel.add(modelIdSpinner, c);

        c.gridwidth = 2;
        c.gridx = 6;
        c.gridy = 0;
        SpinnerNumberModel groupSpinnerNumberModel = new SpinnerNumberModel(group, 1, 99, 1);
        groupSpinner.setModel(groupSpinnerNumberModel);
        groupSpinner.setToolTipText("Set the group for the purpose of Group Transforms");
        groupSpinner.setBackground(getBorderColour(group * 6));
        complexModePanel.add(groupSpinner, c);
        groupSpinner.addChangeListener(e ->
        {
            int colourPick = ((int) groupSpinner.getValue()) * 6;
            groupSpinner.setBackground(getBorderColour(colourPick));
        });

        c.gridx = 8;
        c.gridy = 0;
        c.gridwidth = 1;
        JButton duplicateButton = new JButton(new ImageIcon(DUPLICATE));
        duplicateButton.setFocusable(false);
        duplicateButton.setToolTipText("Duplicate panel");
        duplicateButton.setPreferredSize(new Dimension(30, 25));
        complexModePanel.add(duplicateButton, c);

        c.gridx = 9;
        c.gridy = 0;
        c.gridwidth = 1;
        JButton removeButton = new JButton(new ImageIcon(CLOSE));
        removeButton.setFocusable(false);
        removeButton.setToolTipText("Remove panel");
        removeButton.setPreferredSize(new Dimension(30, 25));
        complexModePanel.add(removeButton, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        complexModePanel.add(tileLabel, c);

        c.gridx = 4;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        complexModePanel.add(translateLabel, c);

        c.gridx = 6;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        complexModePanel.add(scaleLabel, c);

        c.gridx = 8;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        complexModePanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(tilePanel, c);

        xTileSpinner.setValue(xTile);
        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        tilePanel.add(xTileSpinner);

        yTileSpinner.setValue(yTile);
        yTileSpinner.setToolTipText("N/S");
        tilePanel.add(yTileSpinner);

        zTileSpinner.setValue(zTile);
        zTileSpinner.setToolTipText("U/D");
        tilePanel.add(zTileSpinner);

        c.gridx = 4;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(translatePanel, c);

        xSpinner.setValue(xTranslate);
        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        translatePanel.add(xSpinner);

        ySpinner.setValue(yTranslate);
        ySpinner.setToolTipText("N/S");
        translatePanel.add(ySpinner);

        zSpinner.setValue(zTranslate);
        zSpinner.setToolTipText("U/D");
        translatePanel.add(zSpinner);

        c.gridx = 6;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(scalePanel, c);

        xScaleSpinner.setValue(scaleX);
        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        scalePanel.add(xScaleSpinner);

        yScaleSpinner.setValue(scaleY);
        yScaleSpinner.setToolTipText("N/S");
        scalePanel.add(yScaleSpinner);

        zScaleSpinner.setValue(scaleZ);
        zScaleSpinner.setToolTipText("U/D");
        scalePanel.add(zScaleSpinner);

        c.gridx = 8;
        c.gridy = 2;
        c.gridwidth = 2;
        JPanel rotatePanel = new JPanel();
        rotatePanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        rotatePanel.setLayout(new GridLayout(3, 0));
        complexModePanel.add(rotatePanel, c);

        check90.setText("90");
        check90.setHorizontalAlignment(SwingConstants.LEFT);
        check90.setFocusable(false);
        rotatePanel.add(check90);

        check180.setText("180");
        check180.setHorizontalAlignment(SwingConstants.LEFT);
        check180.setFocusable(false);
        rotatePanel.add(check180);

        check270.setText("270");
        check270.setHorizontalAlignment(SwingConstants.LEFT);
        check270.setFocusable(false);
        rotatePanel.add(check270);

        check90.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check180.setSelected(false);
                check270.setSelected(false);
            }
        });

        check180.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check90.setSelected(false);
                check270.setSelected(false);
            }
        });

        check270.addItemListener(e -> {
            if (e.getStateChange() == ItemEvent.SELECTED)
            {
                check180.setSelected(false);
                check90.setSelected(false);
            }
        });

        switch (rotate)
        {
            case 0:
                break;
            case 1:
                check270.setSelected(true);
                break;
            case 2:
                check180.setSelected(true);
                break;
            case 3:
                check90.setSelected(true);
        }

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JButton swapperButton = new JButton("Swap");
        swapperButton.setFocusable(false);
        swapperButton.setToolTipText("Opens this model in the Colour/Texture Swapper tab");
        swapperButton.setPreferredSize(BUTTON_DIMENSION);
        complexModePanel.add(swapperButton, c);
        swapperButton.addActionListener(e ->
        {
            colourSwapPanel.setComboBox(complexModePanel);
            tabbedPane.setSelectedIndex(1);
        });

        c.gridx = 4;
        c.gridy = 3;
        c.gridwidth = 1;
        JButton copyButton = new JButton(new ImageIcon(COPY_COLOURS));
        copyButton.setFocusable(false);
        copyButton.setToolTipText("Copy all swapped colours & textures");
        copyButton.addActionListener(e -> colourSwapPanel.copyColoursTextures(complexModePanel));
        complexModePanel.add(copyButton, c);

        c.gridx = 5;
        c.gridy = 3;
        c.gridwidth = 1;
        JButton pasteButton = new JButton(new ImageIcon(PASTE_COLOURS));
        pasteButton.setFocusable(false);
        pasteButton.setToolTipText("Paste all copied colours & textures");
        complexModePanel.add(pasteButton, c);
        pasteButton.addActionListener(e -> colourSwapPanel.pasteColoursTextures(complexModePanel));

        c.gridx = 6;
        c.gridy = 3;
        c.gridwidth = 2;
        JButton clearColoursTextures = new JButton("Clear");
        clearColoursTextures.setFocusable(false);
        clearColoursTextures.setToolTipText("Clears all swapped colours & textures");
        clearColoursTextures.setPreferredSize(BUTTON_DIMENSION);
        complexModePanel.add(clearColoursTextures, c);
        clearColoursTextures.addActionListener(e -> colourSwapPanel.clearColoursTextures(complexModePanel));
        colourSwapPanel.addComplexPanelOption(complexModePanel);

        c.gridx = 8;
        c.gridy = 3;
        c.gridwidth = 1;
        checkInvertFaces.setText("Invert");
        checkInvertFaces.setToolTipText("Inverts all faces. Should be used with scaling the x or y dimensions in the negative direction");
        checkInvertFaces.setSelected(invertFaces);
        checkInvertFaces.setHorizontalAlignment(SwingConstants.LEFT);
        checkInvertFaces.setFocusable(false);
        complexModePanel.add(checkInvertFaces, c);

        duplicateButton.addActionListener(e ->
        {
            int rotation = 0;
            if (check270.isSelected())
            {
                rotation = 1;
            }

            if (check180.isSelected())
            {
                rotation = 2;
            }

            if (check90.isSelected())
            {
                rotation = 3;
            }

            createComplexPanel(
                    nameField.getText(),
                    (int) modelIdSpinner.getValue(),
                    (int) groupSpinner.getValue(),
                    (int) xTileSpinner.getValue(),
                    (int) yTileSpinner.getValue(),
                    (int) zTileSpinner.getValue(),
                    (int) xSpinner.getValue(),
                    (int) ySpinner.getValue(),
                    (int) zSpinner.getValue(),
                    (int) xScaleSpinner.getValue(),
                    (int) yScaleSpinner.getValue(),
                    (int) zScaleSpinner.getValue(),
                    rotation,
                    "",
                    "",
                    complexModePanel.getColoursFrom(),
                    complexModePanel.getColoursTo(),
                    complexModePanel.getTexturesFrom(),
                    complexModePanel.getTexturesTo(),
                    checkInvertFaces.isSelected());
        });

        removeButton.addActionListener(e ->
        {
            colourSwapPanel.removeComplexPanelOption(complexModePanel);
            complexMode.remove(complexModePanel);
            complexPanels.remove(complexModePanel);
            repaint();
            revalidate();
        });

        nameField.addActionListener(e ->
        {
            String text = StringHandler.cleanString(nameField.getText());
            nameField.setText(text.replaceAll("=", ""));
        });

        nameField.addFocusListener(new FocusListener() {
            @Override
            public void focusGained(FocusEvent e) {
            }

            @Override
            public void focusLost(FocusEvent e) {
                String text = StringHandler.cleanString(nameField.getText());
                nameField.setText(text.replaceAll("=", ""));
            }
        });

        JSpinner[] spinners = new JSpinner[]{xSpinner, ySpinner, zSpinner, xScaleSpinner, yScaleSpinner, zScaleSpinner, xTileSpinner, yTileSpinner, zTileSpinner};
        for (JSpinner spinner : spinners)
        {
            JSpinner.DefaultEditor defaultEditor = (JSpinner.DefaultEditor) spinner.getEditor();
            defaultEditor.getTextField().addMouseListener(new MouseAdapter()
            {
                @Override
                public void mouseClicked(MouseEvent e)
                {
                    if (SwingUtilities.isRightMouseButton(e))
                    {
                        int i = 0;
                        if (spinner == xScaleSpinner || spinner == yScaleSpinner || spinner == zScaleSpinner)
                            i = 128;
                        spinner.setValue(i);
                    }
                }
            });
        }

        complexMode.add(complexModePanel);
        complexModePanel.setEnabled(true);
        complexModePanel.setVisible(true);
        complexPanels.add(complexModePanel);

        revalidate();
        repaint();
    }

    private void setPanelIndex(ComplexPanel panel, int change)
    {
        int newPosition = complexMode.getComponentZOrder(panel) + change;
        if (newPosition < 0)
            newPosition = 0;

        if (newPosition >= complexPanels.size())
            newPosition = complexPanels.size() - 1;

        complexMode.setComponentZOrder(panel, newPosition);
        complexPanels.remove(panel);
        complexPanels.add(newPosition, panel);

        repaint();
        revalidate();
    }

    private void onForgeButtonPressed(Client client, JTextField nameField, boolean forgeAndSet)
    {
        CustomLighting lighting = new CustomLighting(
                (int) lightingSpinners[0].getValue(),
                (int) lightingSpinners[1].getValue(),
                (int) lightingSpinners[2].getValue(),
                (int) lightingSpinners[3].getValue(),
                (int) lightingSpinners[4].getValue());

        if (lighting.getX() == 0 && lighting.getY() == 0 && lighting.getZ() == 0)
            lighting.setZ(1);

        forgeModel(client, nameField, priorityCheckBox.isSelected(), lighting, forgeAndSet);
    }

    private void forgeModel(Client client, JTextField nameField, boolean setPriority, CustomLighting lighting, boolean forgeAndSet)
    {
        if (client == null)
        {
            return;
        }

        if (complexPanels.isEmpty())
            return;

        clientThread.invokeLater(() ->
        {
            DetailedModel[] detailedModels = panelsToDetailedModels();
            Model model = forgeComplexModel(setPriority, detailedModels, LightingStyle.CUSTOM, lighting);
            if (model == null)
            {
                return;
            }

            CustomModelComp comp = new CustomModelComp(plugin.getStoredModels().size(), CustomModelType.FORGED, -1, null, null, detailedModels, null, LightingStyle.CUSTOM, lighting, setPriority, nameField.getText());
            CustomModel customModel = new CustomModel(model, comp);
            plugin.addCustomModel(customModel, forgeAndSet);
        });
    }

    public Model forgeComplexModel(boolean setPriority, DetailedModel[] detailedModels, LightingStyle lightingStyle, CustomLighting lighting)
    {
        return plugin.createComplexModel(detailedModels, setPriority, lightingStyle, lighting, true);
    }

    private DetailedModel[] panelsToDetailedModels()
    {
        DetailedModel[] detailedModels = new DetailedModel[0];

        for (int i = 0; i < complexPanels.size(); i++)
        {
            ComplexPanel complexModePanel = complexPanels.get(i);
            String name = complexModePanel.getNameField().getText();
            int modelId = (int) complexModePanel.getModelIdSpinner().getValue();
            if (modelId == -1)
            {
                continue;
            }

            int group = (int) complexModePanel.getGroupSpinner().getValue();
            int xTile = (int) complexModePanel.getXTileSpinner().getValue();
            int yTile = (int) complexModePanel.getYTileSpinner().getValue();
            int zTile = (int) complexModePanel.getZTileSpinner().getValue();
            int xTranslate = (int) complexModePanel.getXSpinner().getValue();
            int yTranslate = (int) complexModePanel.getYSpinner().getValue();
            int zTranslate = (int) complexModePanel.getZSpinner().getValue();
            int xScale = (int) complexModePanel.getXScaleSpinner().getValue();
            int yScale = (int) complexModePanel.getYScaleSpinner().getValue();
            int zScale = (int) complexModePanel.getZScaleSpinner().getValue();
            int rotate = 0;
            short[] coloursFrom = complexModePanel.getColoursFrom();
            short[] coloursTo = complexModePanel.getColoursTo();
            short[] texturesFrom = complexModePanel.getTexturesFrom();
            short[] texturesTo = complexModePanel.getTexturesTo();
            boolean invertFaces = complexModePanel.getInvertFaces().isSelected();
            JCheckBox check90 = complexModePanel.getCheck90();
            JCheckBox check180 = complexModePanel.getCheck180();
            JCheckBox check270 = complexModePanel.getCheck270();

            if (check90.isSelected())
                rotate = 3;

            if (check180.isSelected())
                rotate = 2;

            if (check270.isSelected())
                rotate = 1;

            DetailedModel detailedModel = new DetailedModel(
                    name,
                    modelId,
                    group,
                    xTile, yTile, zTile,
                    xTranslate, yTranslate, zTranslate,
                    xScale, yScale, zScale, rotate,
                    "", "",
                    coloursFrom, coloursTo,
                    texturesFrom, texturesTo,
                    invertFaces);
            detailedModels = ArrayUtils.add(detailedModels, detailedModel);
        }

        return detailedModels;
    }

    private void openSaveDialog(String name, boolean priority, LightingStyle lightingStyle, CustomLighting lighting)
    {
        File outputDir = MODELS_DIR;
        outputDir.mkdirs();

        JFileChooser fileChooser = new JFileChooser(outputDir)
        {
            @Override
            public void approveSelection()
            {
                File f = getSelectedFile();
                if (!f.getName().endsWith(".json"))
                {
                    f = new File(f.getPath() + ".json");
                }
                if (f.exists() && getDialogType() == SAVE_DIALOG)
                {
                    int result = JOptionPane.showConfirmDialog(
                            this,
                            "File already exists, overwrite?",
                            "Warning",
                            JOptionPane.YES_NO_CANCEL_OPTION
                    );
                    switch (result)
                    {
                        case JOptionPane.YES_OPTION:
                            super.approveSelection();
                            return;
                        case JOptionPane.NO_OPTION:
                        case JOptionPane.CLOSED_OPTION:
                            return;
                        case JOptionPane.CANCEL_OPTION:
                            cancelSelection();
                            return;
                    }
                }
                super.approveSelection();
            }
        };
        fileChooser.setSelectedFile(new File(name));
        fileChooser.setDialogTitle("Save current model collection");

        int option = fileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.getName().endsWith(".json"))
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
            }
            saveToFile(selectedFile, name, priority, lightingStyle, lighting);
        }
    }

    public void saveToFile(File file, String name, boolean priority, LightingStyle lightingStyle, CustomLighting lighting)
    {
        try {
            FileWriter writer = new FileWriter(file, false);

            DetailedModel[] detailedModels = panelsToDetailedModels();
            CustomModelComp comp = new CustomModelComp(0, CustomModelType.FORGED, -1, null, null, detailedModels, null, lightingStyle, lighting, priority, name);
            String string = plugin.getGson().toJson(comp);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when saving Forge model to file");
        }
    }

    private void openLoadDialog()
    {
        MODELS_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(MODELS_DIR);
        fileChooser.setDialogTitle("Choose a model to load");

        int option = fileChooser.showOpenDialog(this);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File selectedFile = fileChooser.getSelectedFile();
            if (!selectedFile.exists())
            {
                selectedFile = new File(selectedFile.getPath() + ".json");
                if (!selectedFile.exists())
                {
                    plugin.sendChatMessage("Could not find the requested Custom Model file.");
                    return;
                }
            }

            plugin.loadCustomModelToAnvil(selectedFile);
        }
    }

    public static short[] stringToShort(String string)
    {
        if (string.isEmpty())
            return new short[0];

        String[] split = string.split(",");
        short[] array = new short[0];
        try
        {
            for (String s : split)
                array = ArrayUtils.add(array, Short.parseShort(s));
        }
        catch (Exception e)
        {
            return new short[0];
        }

        return array;
    }

    public static Color getBorderColour(int i)
    {
        if (i == -1)
        {
            return ColorScheme.MEDIUM_GRAY_COLOR;
        }

        float hue = ((float) i - 25) / 50;
        return Color.getHSBColor(hue, 1, (float) 0.7);
    }

    public void setLightingSettings(LightingStyle preset, int ambience, int contrast, int x, int y, int z)
    {
        if (preset == LightingStyle.CUSTOM)
            preset = LightingStyle.DEFAULT;

        presetComboBox.setSelectedItem(preset);
        ambSpinner.setValue(ambience);
        conSpinner.setValue(contrast);
        lightXSpinner.setValue(x);
        lightYSpinner.setValue(y);
        lightZSpinner.setValue(z);
    }
}

package com.creatorskit.swing.anvil;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import javax.swing.*;

@Getter
@Setter
@AllArgsConstructor
public class ComplexPanel extends JPanel
{
    private final JSpinner modelIdSpinner;
    private final JSpinner groupSpinner;
    private final JTextField nameField;
    private short[] coloursFrom;
    private short[] coloursTo;
    private short[] texturesFrom;
    private short[] texturesTo;
    private final JSpinner xSpinner;
    private final JSpinner ySpinner;
    private final JSpinner zSpinner;
    private final JSpinner xTileSpinner;
    private final JSpinner yTileSpinner;
    private final JSpinner zTileSpinner;
    private final JSpinner xScaleSpinner;
    private final JSpinner yScaleSpinner;
    private final JSpinner zScaleSpinner;
    private final JCheckBox check90;
    private final JCheckBox check180;
    private final JCheckBox check270;
    private final JCheckBox invertFaces;

    @Override
    public String toString()
    {
        return nameField.getText() + " (" + modelIdSpinner.getValue() + (")");
    }
}

package com.creatorskit.swing.anvil;

public enum GroupOperation
{
    X_TILE_SPINNER,
    Y_TILE_SPINNER,
    Z_TILE_SPINNER,
    X_SPINNER,
    Y_SPINNER,
    Z_SPINNER,
    X_SCALE_SPINNER,
    Y_SCALE_SPINNER,
    Z_SCALE_SPINNER
}

package com.creatorskit.swing.anvil;

import com.creatorskit.CreatorsPlugin;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.plaf.basic.BasicSpinnerUI;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.image.BufferedImage;
import java.util.HashMap;

public class GroupPanel extends JPanel
{
    private final CreatorsPlugin plugin;
    private Client client;
    private final ClientThread clientThread;
    private final GridBagConstraints c = new GridBagConstraints();

    private final BufferedImage ICON = ImageUtil.loadImageResource(getClass(), "/panelicon.png");
    private final BufferedImage TRANSLATE = ImageUtil.loadImageResource(getClass(), "/Translate.png");
    private final BufferedImage ROTATE = ImageUtil.loadImageResource(getClass(), "/Rotate.png");
    private final BufferedImage TRANSLATE_SUBTILE = ImageUtil.loadImageResource(getClass(), "/Translate subtile.png");
    private final BufferedImage SCALE = ImageUtil.loadImageResource(getClass(), "/Scale.png");
    private final Dimension SPINNER_DIMENSION = new Dimension(35, 25);
    private final JSpinner groupSpinner = new JSpinner();

    @Inject
    public GroupPanel(@Nullable Client client, CreatorsPlugin plugin, ClientThread clientThread)
    {
        this.plugin = plugin;
        this.clientThread = clientThread;

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setBorder(new LineBorder(ColorScheme.DARKER_GRAY_COLOR, 1));
        setLayout(new GridBagLayout());

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(4, 4, 4, 4);

        c.gridx = 0;
        c.gridy = 0;
        c.gridwidth = 2;
        c.gridheight = 1;
        JLabel title = new JLabel("Group Transformer");
        title.setFont(FontManager.getRunescapeBoldFont());
        title.setHorizontalAlignment(SwingConstants.CENTER);
        add(title, c);

        c.gridx = 0;
        c.gridy = 1;
        c.gridwidth = 1;
        c.gridheight = 1;
        JLabel groupLabel = new JLabel("Group:");
        groupLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        add(groupLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        c.gridwidth = 1;
        c.gridheight = 1;
        SpinnerNumberModel spinnerNumberModel = new SpinnerNumberModel(1, 1, 99, 1);
        groupSpinner.setModel(spinnerNumberModel);
        groupSpinner.setBackground(ModelAnvil.getBorderColour(6));
        groupSpinner.setToolTipText("Pick the Group number to Group Transform");
        add(groupSpinner, c);
        groupSpinner.addChangeListener(e ->
                groupSpinner.setBackground(ModelAnvil.getBorderColour((int) groupSpinner.getValue() * 6)));

        JPanel adjustPanel = createAdjustPanel();
        c.gridx = 0;
        c.gridy = 2;
        c.gridwidth = 1;
        c.gridheight = 1;
        add(adjustPanel, c);

        JPanel setPanel = createSetPanel();
        c.gridx = 1;
        c.gridy = 2;
        c.gridwidth = 1;
        c.gridheight = 1;
        add(setPanel, c);

        revalidate();
        repaint();
    }

    public JPanel createAdjustPanel()
    {
        JPanel adjustPanel = new JPanel();
        adjustPanel.setLayout(new GridBagLayout());
        adjustPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        adjustPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JComboBox<String> rotateBox = new JComboBox<>();
        JButton invertButton = new JButton("Invert");

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 4, 2, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 10;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel setLabel = new JLabel("Adjuster");
        setLabel.setToolTipText("Functions here adjust all values of the given Group BY the value entered");
        setLabel.setHorizontalAlignment(SwingConstants.CENTER);
        adjustPanel.add(setLabel, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        adjustPanel.add(tileLabel, c);

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        adjustPanel.add(translateLabel, c);

        c.gridx = 2;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        adjustPanel.add(scaleLabel, c);

        c.gridx = 2;
        c.gridy = 7;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        adjustPanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(tilePanel, c);

        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        tilePanel.add(xTileSpinner);
        xTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xTileSpinner, this, GroupOperation.X_TILE_SPINNER);
            }
        });

        yTileSpinner.setToolTipText("N/S");
        tilePanel.add(yTileSpinner);
        yTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(yTileSpinner, this, GroupOperation.Y_TILE_SPINNER);
            }
        });

        zTileSpinner.setToolTipText("U/D");
        tilePanel.add(zTileSpinner);
        zTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zTileSpinner, this, GroupOperation.Z_TILE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(translatePanel, c);

        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        translatePanel.add(xSpinner);
        xSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xSpinner, this, GroupOperation.X_SPINNER);
            }
        });

        ySpinner.setToolTipText("N/S");
        translatePanel.add(ySpinner);
        ySpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(ySpinner, this, GroupOperation.Y_SPINNER);
            }
        });

        zSpinner.setToolTipText("U/D");
        translatePanel.add(zSpinner);
        zSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zSpinner, this, GroupOperation.Z_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        adjustPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 6;
        c.gridwidth = 2;
        c.weightx = 0;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0, 0, 1));
        adjustPanel.add(scalePanel, c);

        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        scalePanel.add(xScaleSpinner);
        xScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(xScaleSpinner, this, GroupOperation.X_SCALE_SPINNER);
            }
        });

        yScaleSpinner.setToolTipText("N/S");
        scalePanel.add(yScaleSpinner);
        yScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(yScaleSpinner, this, GroupOperation.Y_SCALE_SPINNER);
            }
        });

        zScaleSpinner.setToolTipText("U/D");
        scalePanel.add(zScaleSpinner);
        zScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                adjustValueSpinner(zScaleSpinner, this, GroupOperation.Z_SCALE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 8;
        c.gridwidth = 2;
        adjustPanel.add(rotateBox, c);
        rotateBox.addItem("Rot");
        rotateBox.addItem("90");
        rotateBox.addItem("180");
        rotateBox.addItem("270");
        rotateBox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                adjustValueComboBox(rotateBox, e, this);
            }
        });

        c.gridx = 2;
        c.gridy = 9;
        c.gridwidth = 2;
        adjustPanel.add(invertButton, c);
        invertButton.addActionListener(e -> adjustValueInvert());

        JFrame swapperFrame = new JFrame("Colour Swapper");
        swapperFrame.setVisible(false);
        swapperFrame.setEnabled(false);
        swapperFrame.setIconImage(ICON);
        swapperFrame.setLayout(new FlowLayout());

        JPanel gridMenu = new JPanel();
        gridMenu.setLayout(new GridLayout(0, 2, 2, 2));
        swapperFrame.add(gridMenu);

        adjustPanel.setEnabled(true);
        adjustPanel.setVisible(true);
        return adjustPanel;
    }

    private void adjustValueSpinner(JSpinner spinner, ChangeListener changeListener, GroupOperation operation)
    {
        int value = (int) spinner.getValue();

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() != groupSpinner.getValue())
                continue;

            JSpinner s;
            switch (operation)
            {
                case X_TILE_SPINNER:
                    s = complexPanel.getXTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_TILE_SPINNER:
                    s = complexPanel.getYTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_TILE_SPINNER:
                    s = complexPanel.getZTileSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case X_SPINNER:
                    s = complexPanel.getXSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_SPINNER:
                    s = complexPanel.getYSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_SPINNER:
                    s = complexPanel.getZSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case X_SCALE_SPINNER:
                    s = complexPanel.getXScaleSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Y_SCALE_SPINNER:
                    s = complexPanel.getYScaleSpinner();
                    s.setValue((int) s.getValue() + value);
                    break;
                case Z_SCALE_SPINNER:
                    s = complexPanel.getZScaleSpinner();
                    s.setValue((int) s.getValue() + value);
            }
        }

        spinner.removeChangeListener(changeListener);
        spinner.setValue(0);
        spinner.addChangeListener(changeListener);
    }

    private void adjustValueComboBox(JComboBox<String> comboBox, ItemEvent e, ItemListener itemListener)
    {
        if (e.getItem() == "Rot")
            return;

        int change = Integer.parseInt((String) e.getItem());

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox check90 = complexPanel.getCheck90();
                JCheckBox check180 = complexPanel.getCheck180();
                JCheckBox check270 = complexPanel.getCheck270();

                int currentRotation = 0;
                if (check90.isSelected())
                    currentRotation = 90;

                if (check180.isSelected())
                    currentRotation = 180;

                if (check270.isSelected())
                    currentRotation = 270;

                switch (currentRotation + change)
                {
                    case 90:
                    case 450:
                        complexPanel.getCheck90().setSelected(true);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 180:
                    case 540:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(true);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 270:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(true);
                        break;
                    case 360:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                }
            }
        }

        comboBox.removeItemListener(itemListener);
        comboBox.setSelectedItem("Rot");
        comboBox.addItemListener(itemListener);
    }

    private void adjustValueInvert()
    {
        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox invertFaces = complexPanel.getInvertFaces();
                invertFaces.setSelected(!invertFaces.isSelected());
            }
        }
    }

    public JPanel createSetPanel()
    {
        JPanel setPanel = new JPanel();
        setPanel.setLayout(new GridBagLayout());
        setPanel.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        setPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);

        JTextField colourNewField = new JTextField();
        JTextField colourOldField = new JTextField();
        JSpinner xTileSpinner = new JSpinner();
        JSpinner yTileSpinner = new JSpinner();
        JSpinner zTileSpinner = new JSpinner();
        JSpinner xSpinner = new JSpinner();
        JSpinner ySpinner = new JSpinner();
        JSpinner zSpinner = new JSpinner();
        JSpinner xScaleSpinner = new JSpinner();
        JSpinner yScaleSpinner = new JSpinner();
        JSpinner zScaleSpinner = new JSpinner();
        JComboBox<String> rotateBox = new JComboBox<>();
        JButton invertButton = new JButton("Inv On");

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 4, 2, 4);
        c.weightx = 1;
        c.weighty = 0;

        c.gridwidth = 10;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 0;
        JLabel setLabel = new JLabel("Setter");
        setLabel.setToolTipText("Functions here set all values of the given Group TO the value entered");
        setLabel.setHorizontalAlignment(SwingConstants.CENTER);
        setPanel.add(setLabel, c);

        c.gridx = 2;
        c.gridy = 1;
        c.gridwidth = 2;
        JLabel tileLabel = new JLabel(new ImageIcon(TRANSLATE));
        tileLabel.setToolTipText("Translate by full tile");
        tileLabel.setBackground(Color.BLACK);
        setPanel.add(tileLabel, c);

        c.gridx = 2;
        c.gridy = 3;
        c.gridwidth = 2;
        JLabel translateLabel = new JLabel(new ImageIcon(TRANSLATE_SUBTILE));
        translateLabel.setToolTipText("Translate by sub-tile (1/128 of a tile)");
        translateLabel.setBackground(Color.BLACK);
        setPanel.add(translateLabel, c);

        c.gridx = 2;
        c.gridy = 5;
        c.gridwidth = 2;
        JLabel scaleLabel = new JLabel(new ImageIcon(SCALE));
        scaleLabel.setToolTipText("Scale. 128 is default scale");
        scaleLabel.setBackground(Color.BLACK);
        setPanel.add(scaleLabel, c);

        c.gridx = 2;
        c.gridy = 7;
        c.gridwidth = 2;
        JLabel rotateLabel = new JLabel(new ImageIcon(ROTATE));
        rotateLabel.setToolTipText("Rotate");
        rotateLabel.setBackground(Color.BLACK);
        setPanel.add(rotateLabel, c);

        c.gridx = 2;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 2;
        c.gridwidth = 1;
        c.weightx = 0;
        JPanel tilePanel = new JPanel();
        tilePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(tilePanel, c);

        xTileSpinner.setToolTipText("E/W");
        xTileSpinner.setPreferredSize(SPINNER_DIMENSION);
        xTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(xTileSpinner);
        xTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xTileSpinner, this, GroupOperation.X_TILE_SPINNER);
            }
        });

        yTileSpinner.setToolTipText("N/S");
        yTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(yTileSpinner);
        yTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(yTileSpinner, this, GroupOperation.Y_TILE_SPINNER);
            }
        });

        zTileSpinner.setToolTipText("U/D");
        zTileSpinner.setUI(createEmptySpinner());
        tilePanel.add(zTileSpinner);
        zTileSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zTileSpinner, this, GroupOperation.Z_TILE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 4;
        c.gridwidth = 1;
        c.weightx = 1;
        JPanel translatePanel = new JPanel();
        translatePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(translatePanel, c);

        xSpinner.setToolTipText("E/W");
        xSpinner.setPreferredSize(SPINNER_DIMENSION);
        xSpinner.setUI(createEmptySpinner());
        translatePanel.add(xSpinner);
        xSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xSpinner, this, GroupOperation.X_SPINNER);
            }
        });

        ySpinner.setToolTipText("N/S");
        ySpinner.setUI(createEmptySpinner());
        translatePanel.add(ySpinner);
        ySpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(ySpinner, this, GroupOperation.Y_SPINNER);
            }
        });

        zSpinner.setToolTipText("U/D");
        zSpinner.setUI(createEmptySpinner());
        translatePanel.add(zSpinner);
        zSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zSpinner, this, GroupOperation.Z_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        setPanel.add(createXYZPanel(), c);

        c.gridx = 3;
        c.gridy = 6;
        c.gridwidth = 1;
        c.weightx = 0;
        JPanel scalePanel = new JPanel();
        scalePanel.setLayout(new GridLayout(3, 0, 0, 1));
        setPanel.add(scalePanel, c);

        xScaleSpinner.setPreferredSize(SPINNER_DIMENSION);
        xScaleSpinner.setToolTipText("E/W");
        xScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(xScaleSpinner);
        xScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(xScaleSpinner, this, GroupOperation.X_SCALE_SPINNER);
            }
        });

        yScaleSpinner.setToolTipText("N/S");
        yScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(yScaleSpinner);
        yScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(yScaleSpinner, this, GroupOperation.Y_SCALE_SPINNER);
            }
        });

        zScaleSpinner.setToolTipText("U/D");
        zScaleSpinner.setUI(createEmptySpinner());
        scalePanel.add(zScaleSpinner);
        zScaleSpinner.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                setValueSpinner(zScaleSpinner, this, GroupOperation.Z_SCALE_SPINNER);
            }
        });

        c.gridx = 2;
        c.gridy = 8;
        c.gridwidth = 2;
        setPanel.add(rotateBox, c);
        rotateBox.addItem("Rot");
        rotateBox.addItem("0");
        rotateBox.addItem("90");
        rotateBox.addItem("180");
        rotateBox.addItem("270");
        rotateBox.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                setValueComboBox(rotateBox, e, this);
            }
        });

        c.gridx = 2;
        c.gridy = 9;
        c.gridwidth = 2;
        setPanel.add(invertButton, c);
        invertButton.addActionListener(e -> setValueInvert(invertButton));

        HashMap<Short, Short> colourMap = new HashMap<>();

        colourNewField.setVisible(false);
        setPanel.add(colourNewField);

        colourOldField.setVisible(false);
        setPanel.add(colourOldField);

        JFrame swapperFrame = new JFrame("Colour Swapper");
        swapperFrame.setVisible(false);
        swapperFrame.setEnabled(false);
        swapperFrame.setIconImage(ICON);
        swapperFrame.setLayout(new FlowLayout());

        JPanel gridMenu = new JPanel();
        gridMenu.setLayout(new GridLayout(0, 2, 2, 2));
        swapperFrame.add(gridMenu);

        setPanel.setEnabled(true);
        setPanel.setVisible(true);
        return setPanel;
    }

    private void setValueSpinner(JSpinner spinner, ChangeListener changeListener, GroupOperation operation)
    {
        int value = (int) spinner.getValue();

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() != groupSpinner.getValue())
                continue;

            switch (operation)
            {
                case X_TILE_SPINNER:
                    complexPanel.getXTileSpinner().setValue(value);
                    break;
                case Y_TILE_SPINNER:
                    complexPanel.getYTileSpinner().setValue(value);
                    break;
                case Z_TILE_SPINNER:
                    complexPanel.getZTileSpinner().setValue(value);
                    break;
                case X_SPINNER:
                    complexPanel.getXSpinner().setValue(value);
                    break;
                case Y_SPINNER:
                    complexPanel.getYSpinner().setValue(value);
                    break;
                case Z_SPINNER:
                    complexPanel.getZSpinner().setValue(value);
                    break;
                case X_SCALE_SPINNER:
                    complexPanel.getXScaleSpinner().setValue(value);
                    break;
                case Y_SCALE_SPINNER:
                    complexPanel.getYScaleSpinner().setValue(value);
                    break;
                case Z_SCALE_SPINNER:
                    complexPanel.getZScaleSpinner().setValue(value);
            }
        }
    }

    private void setValueComboBox(JComboBox<String> comboBox, ItemEvent e, ItemListener itemListener)
    {
        if (e.getItem() == "Rot")
            return;

        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                switch (Integer.parseInt((String) e.getItem()))
                {
                    case 0:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 90:
                        complexPanel.getCheck90().setSelected(true);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 180:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(true);
                        complexPanel.getCheck270().setSelected(false);
                        break;
                    case 270:
                        complexPanel.getCheck90().setSelected(false);
                        complexPanel.getCheck180().setSelected(false);
                        complexPanel.getCheck270().setSelected(true);
                }
            }
        }

        comboBox.removeItemListener(itemListener);
        comboBox.setSelectedItem("Rot");
        comboBox.addItemListener(itemListener);
    }

    private void setValueInvert(JButton button)
    {
        boolean invert = button.getText().equals("Inv On");
        for (ComplexPanel complexPanel : plugin.getComplexPanels())
        {
            if (complexPanel.getGroupSpinner().getValue() == groupSpinner.getValue())
            {
                JCheckBox invertFaces = complexPanel.getInvertFaces();
                invertFaces.setSelected(invert);
            }
        }

        button.setText(invert ? "Inv Off" : "Inv On");
    }

    private JPanel createXYZPanel()
    {
        JPanel xyzPanel = new JPanel();
        xyzPanel.setBackground(ColorScheme.DARK_GRAY_COLOR);
        xyzPanel.setLayout(new GridLayout(3, 0));

        JLabel xLabel = new JLabel("x:");
        xLabel.setToolTipText("East/West");
        xLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(xLabel);

        JLabel yLabel = new JLabel("y:");
        yLabel.setToolTipText("North/South");
        yLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(yLabel);

        JLabel zLabel = new JLabel("z:");
        zLabel.setToolTipText("Up/Down");
        zLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        xyzPanel.add(zLabel);

        return xyzPanel;
    }

    private BasicSpinnerUI createEmptySpinner() {
        return new BasicSpinnerUI() {
            protected Component createNextButton() {
                return null;
            }

            protected Component createPreviousButton() {
                return null;
            }
        };
    }
}

package com.creatorskit.swing.timesheet;

import com.creatorskit.CKObject;
import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.models.CustomModel;
import com.creatorskit.models.DataFinder;
import com.creatorskit.models.datatypes.*;
import com.creatorskit.programming.MovementManager;
import com.creatorskit.programming.orientation.Orientation;
import com.creatorskit.programming.orientation.OrientationGoal;
import com.creatorskit.swing.searchabletable.JFilterableTable;
import com.creatorskit.swing.timesheet.attributes.*;
import com.creatorskit.swing.timesheet.keyframe.*;
import com.creatorskit.swing.timesheet.keyframe.settings.*;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Animation;
import net.runelite.api.Client;
import net.runelite.api.Constants;
import net.runelite.api.WorldView;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

@Getter
@Setter
public class AttributePanel extends JPanel
{
    private Client client;
    private ClientThread clientThread;
    private CreatorsConfig config;
    private TimeSheetPanel timeSheetPanel;
    private DataFinder dataFinder;

    private final BufferedImage HELP = ImageUtil.loadImageResource(getClass(), "/Help.png");
    private final BufferedImage COMPASS = ImageUtil.loadImageResource(getClass(), "/Orientation_compass.png");
    private final BufferedImage RESET = ImageUtil.loadImageResource(getClass(), "/Reset.png");
    private final Icon keyframeImage = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Keyframe.png"));
    private final Icon keyframeEmptyImage = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Keyframe_Empty.png"));

    private final GridBagConstraints c = new GridBagConstraints();
    private final JPanel cardPanel = new JPanel();
    private final JLabel objectLabel = new JLabel("[No Object Selected]");
    private final JLabel cardLabel = new JLabel("");
    private final JButton keyFramed = new JButton();

    private final JFilterableTable npcTable = new JFilterableTable("NPCs");
    private final JFilterableTable itemTable = new JFilterableTable("Items");
    private final JFilterableTable animTable = new JFilterableTable("Animations");
    private final JFilterableTable spotanimTable = new JFilterableTable("SpotAnims");

    private final JPopupMenu spotanimPopup = new JPopupMenu("SpotAnims");

    public static final String MOVE_CARD = "Movement";
    public static final String ANIM_CARD = "Animation";
    public static final String ORI_CARD = "Orientation";
    public static final String SPAWN_CARD = "Spawn";
    public static final String MODEL_CARD = "Model";
    public static final String TEXT_CARD = "Text";
    public static final String OVER_CARD = "Overhead";
    public static final String HEALTH_CARD = "Health";
    public static final String SPOTANIM_CARD = "SpotAnim 1";
    public static final String SPOTANIM2_CARD = "SpotAnim 2";
    public static final String HITSPLAT_1_CARD = "Hitsplat 1";
    public static final String HITSPLAT_2_CARD = "Hitsplat 2";
    public static final String HITSPLAT_3_CARD = "Hitsplat 3";
    public static final String HITSPLAT_4_CARD = "Hitsplat 4";

    private final String NO_OBJECT_SELECTED = "[No Object Selected]";
    private Font attributeFont = new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 32);

    private KeyFrameType hoveredKeyFrameType;
    private Component hoveredComponent;
    private KeyFrameType selectedKeyFramePage = KeyFrameType.MOVEMENT;

    private final MovementAttributes movementAttributes = new MovementAttributes();
    private final AnimAttributes animAttributes = new AnimAttributes();
    private final OriAttributes oriAttributes = new OriAttributes();
    private final SpawnAttributes spawnAttributes = new SpawnAttributes();
    private final ModelAttributes modelAttributes = new ModelAttributes();
    private final TextAttributes textAttributes = new TextAttributes();
    private final OverheadAttributes overheadAttributes = new OverheadAttributes();
    private final HealthAttributes healthAttributes = new HealthAttributes();
    private final SpotAnimAttributes spotAnimAttributes = new SpotAnimAttributes();
    private final SpotAnimAttributes spotAnim2Attributes = new SpotAnimAttributes();
    private final HitsplatAttributes hitsplat1Attributes = new HitsplatAttributes();
    private final HitsplatAttributes hitsplat2Attributes = new HitsplatAttributes();
    private final HitsplatAttributes hitsplat3Attributes = new HitsplatAttributes();
    private final HitsplatAttributes hitsplat4Attributes = new HitsplatAttributes();

    private final Random random = new Random();

    @Inject
    public AttributePanel(Client client, ClientThread clientThread, CreatorsConfig config, TimeSheetPanel timeSheetPanel, DataFinder dataFinder)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.config = config;
        this.timeSheetPanel = timeSheetPanel;
        this.dataFinder = dataFinder;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        objectLabel.setFont(attributeFont);
        objectLabel.setForeground(Color.WHITE);
        objectLabel.setHorizontalAlignment(SwingConstants.LEFT);

        cardPanel.setLayout(new CardLayout());
        cardPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        cardPanel.setFocusable(true);
        addMouseFocusListener(cardPanel);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        add(objectLabel, c);

        c.gridx = 1;
        c.gridy = 0;
        c.weightx = 0;
        cardLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        cardLabel.setFont(FontManager.getRunescapeBoldFont());
        cardLabel.setText(MOVE_CARD);
        add(cardLabel, c);

        c.gridx = 2;
        c.gridy = 0;
        JButton update = new JButton("Update");
        update.setBackground(ColorScheme.DARK_GRAY_COLOR);
        update.addActionListener(e -> timeSheetPanel.onUpdateButtonPressed());
        add(update, c);

        c.gridx = 3;
        c.gridy = 0;
        JButton reset = new JButton(new ImageIcon(RESET));
        reset.setBackground(ColorScheme.DARK_GRAY_COLOR);
        reset.setToolTipText("Reset all the parameters of the currently visible KeyFrame");
        reset.addActionListener(e -> setAttributesEmpty(false));
        add(reset, c);

        c.gridx = 4;
        c.gridy = 0;
        keyFramed.setIcon(keyframeEmptyImage);
        keyFramed.setPreferredSize(new Dimension(32, 32));
        keyFramed.setBackground(ColorScheme.DARK_GRAY_COLOR);
        keyFramed.addActionListener(e -> timeSheetPanel.onKeyFrameIconPressedEvent());
        add(keyFramed, c);

        c.gridwidth = 5;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 1;
        add(cardPanel, c);

        JPanel moveCard = new JPanel();
        JPanel animCard = new JPanel();
        JPanel oriCard = new JPanel();
        JPanel spawnCard = new JPanel();
        JPanel modelCard = new JPanel();
        JPanel textCard = new JPanel();
        JPanel overCard = new JPanel();
        JPanel healthCard = new JPanel();
        JPanel spotanimCard = new JPanel();
        JPanel spotanim2Card = new JPanel();
        JPanel hitsplat1Card = new JPanel();
        JPanel hitsplat2Card = new JPanel();
        JPanel hitsplat3Card = new JPanel();
        JPanel hitsplat4Card = new JPanel();
        cardPanel.add(moveCard, MOVE_CARD);
        cardPanel.add(animCard, ANIM_CARD);
        cardPanel.add(oriCard, ORI_CARD);
        cardPanel.add(spawnCard, SPAWN_CARD);
        cardPanel.add(modelCard, MODEL_CARD);
        cardPanel.add(textCard, TEXT_CARD);
        cardPanel.add(overCard, OVER_CARD);
        cardPanel.add(healthCard, HEALTH_CARD);
        cardPanel.add(spotanimCard, SPOTANIM_CARD);
        cardPanel.add(spotanim2Card, SPOTANIM2_CARD);
        cardPanel.add(hitsplat1Card, HITSPLAT_1_CARD);
        cardPanel.add(hitsplat2Card, HITSPLAT_2_CARD);
        cardPanel.add(hitsplat3Card, HITSPLAT_3_CARD);
        cardPanel.add(hitsplat4Card, HITSPLAT_4_CARD);

        setupMoveCard(moveCard);
        setupAnimCard(animCard);
        setupOriCard(oriCard);
        setupSpawnCard(spawnCard);
        setupModelCard(modelCard);
        setupTextCard(textCard);
        setupOverheadCard(overCard);
        setupHealthCard(healthCard);
        setupSpotAnimFinder();
        setupSpotAnimCard(spotanimCard, KeyFrameType.SPOTANIM);
        setupSpotAnimCard(spotanim2Card, KeyFrameType.SPOTANIM2);
        setupHitsplatCard(hitsplat1Card, KeyFrameType.HITSPLAT_1);
        setupHitsplatCard(hitsplat2Card, KeyFrameType.HITSPLAT_2);
        setupHitsplatCard(hitsplat3Card, KeyFrameType.HITSPLAT_3);
        setupHitsplatCard(hitsplat4Card, KeyFrameType.HITSPLAT_4);

        setupKeyListeners();
    }

    /**
     * Create a keyframe out of the current AttributePanel settings, based on which card is currently being shown
     * @return a keyframe of type depending on which card is currently showing, with settings based on what is displayed on that card
     */
    public KeyFrame createKeyFrame(double tick)
    {
        return createKeyFrame(selectedKeyFramePage, tick);
    }

    /**
     * Create a keyframe of a specified type out of the current AttributePanel settings for the given card of the specified KeyFrameType
     * @param keyFrameType the type of keyframe to add
     * @return a keyframe of indicated type, with settings based on what is displayed on that card
     */
    public KeyFrame createKeyFrame(KeyFrameType keyFrameType, double tick)
    {
        switch (keyFrameType)
        {
            default:
            case MOVEMENT:
                WorldView worldView = client.getTopLevelWorldView();
                if (worldView == null || worldView.getMapRegions() == null)
                {
                    return null;
                }

                return new MovementKeyFrame(
                        tick,
                        worldView.getPlane(),
                        MovementManager.useLocalLocations(worldView),
                        new int[0][],
                        0,
                        0,
                        movementAttributes.getLoop().getSelectedItem() == Toggle.ENABLE,
                        (double) movementAttributes.getSpeed().getValue(),
                        (int) movementAttributes.getTurnRate().getValue()
                );
            case ANIMATION:
                return new AnimationKeyFrame(
                        tick,
                        animAttributes.getStall().getSelectedItem() == Toggle.ENABLE,
                        (int) animAttributes.getActive().getValue(),
                        (int) animAttributes.getStartFrame().getValue(),
                        animAttributes.getLoop().getSelectedItem() == Toggle.ENABLE,
                        animAttributes.getFreeze().getSelectedItem() == Toggle.ENABLE,
                        (int) animAttributes.getIdle().getValue(),
                        (int) animAttributes.getWalk().getValue(),
                        (int) animAttributes.getRun().getValue(),
                        (int) animAttributes.getWalk180().getValue(),
                        (int) animAttributes.getWalkRight().getValue(),
                        (int) animAttributes.getWalkLeft().getValue(),
                        (int) animAttributes.getIdleRight().getValue(),
                        (int) animAttributes.getIdleLeft().getValue()
                );
            case ORIENTATION:
                return new OrientationKeyFrame(
                        tick,
                        OrientationGoal.POINT,
                        (int) oriAttributes.getStart().getValue(),
                        (int) oriAttributes.getEnd().getValue(),
                        (double) oriAttributes.getDuration().getValue(),
                        (int) oriAttributes.getTurnRate().getValue()
                );
            case SPAWN:
                return new SpawnKeyFrame(
                        tick,
                        spawnAttributes.getSpawn().getSelectedItem() == Toggle.ENABLE
                );
            case MODEL:
                return new ModelKeyFrame(
                        tick,
                        modelAttributes.getModelOverride().getSelectedItem() == ModelToggle.CUSTOM_MODEL,
                        (int) modelAttributes.getModelId().getValue(),
                        (CustomModel) modelAttributes.getCustomModel().getSelectedItem(),
                        (int) modelAttributes.getRadius().getValue()
                );
            case TEXT:
                return new TextKeyFrame(
                        tick,
                        (double) textAttributes.getDuration().getValue(),
                        textAttributes.getText().getText()
                );
            case OVERHEAD:
                return new OverheadKeyFrame(
                        tick,
                        (OverheadSprite) overheadAttributes.getSkullSprite().getSelectedItem(),
                        (OverheadSprite) overheadAttributes.getPrayerSprite().getSelectedItem()
                );
            case HEALTH:
                return new HealthKeyFrame(
                        tick,
                        (double) healthAttributes.getDuration().getValue(),
                        (HealthbarSprite) healthAttributes.getHealthbarSprite().getSelectedItem(),
                        (int) healthAttributes.getMaxHealth().getValue(),
                        (int) healthAttributes.getCurrentHealth().getValue()
                );
            case SPOTANIM:
            case SPOTANIM2:
                SpotAnimAttributes spAttributes;
                switch (keyFrameType)
                {
                    default:
                    case SPOTANIM:
                        spAttributes = spotAnimAttributes;
                        break;
                    case SPOTANIM2:
                        spAttributes = spotAnim2Attributes;
                }
                return new SpotAnimKeyFrame(
                        tick,
                        keyFrameType,
                        (int) spAttributes.getSpotAnimId().getValue(),
                        spAttributes.getLoop().getSelectedItem() == Toggle.ENABLE,
                        (int) spAttributes.getHeight().getValue()
                );
            case HITSPLAT_1:
            case HITSPLAT_2:
            case HITSPLAT_3:
            case HITSPLAT_4:
                HitsplatAttributes attributes;
                switch (keyFrameType)
                {
                    default:
                    case HITSPLAT_1:
                        attributes = hitsplat1Attributes;
                        break;
                    case HITSPLAT_2:
                        attributes = hitsplat2Attributes;
                        break;
                    case HITSPLAT_3:
                        attributes = hitsplat3Attributes;
                        break;
                    case HITSPLAT_4:
                        attributes = hitsplat4Attributes;
                }

                return new HitsplatKeyFrame(
                        tick,
                        keyFrameType,
                        (int) attributes.getDuration().getValue(),
                        (HitsplatSprite) attributes.getSprite().getSelectedItem(),
                        (HitsplatVariant) attributes.getVariant().getSelectedItem(),
                        (int) attributes.getDamage().getValue()
                );
        }
    }

    private void setupMoveCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Movement");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Set how the Object moves. Hotkeys for adding and removing steps in the scene are as follows: " +
                "<br>" + config.addProgramStepHotkey().toString() + ": adds program steps to the hovered tile" +
                "<br>" + config.removeProgramStepHotkey().toString() + ": removes the last program step" +
                "<br>" + config.clearProgramStepHotkey().toString() + ": clears all steps for the current Movement KeyFrame</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel loopLabel = new JLabel("Loop: ");
        loopLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        //card.add(loopLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JComboBox<Toggle> loop = movementAttributes.getLoop();
        loop.setToolTipText("Choose whether the program should loop its designated path");
        loop.setFocusable(false);
        loop.addItem(Toggle.DISABLE);
        loop.addItem(Toggle.ENABLE);
        loop.setBackground(ColorScheme.DARK_GRAY_COLOR);
        //card.add(loop, c);

        c.gridx = 0;
        c.gridy = 2;
        JLabel speedLabel = new JLabel("Speed: ");
        speedLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(speedLabel, c);

        c.gridx = 1;
        c.gridy = 2;
        JSpinner speed = movementAttributes.getSpeed();
        speed.setToolTipText("Set the speed at which the Object moves, in tiles/tick");
        speed.setModel(new SpinnerNumberModel(1.0, 0.5, 10, 0.5));
        card.add(speed, c);

        c.gridx = 0;
        c.gridy = 3;
        JLabel turnRateLabel = new JLabel("Turn Rate: ");
        turnRateLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(turnRateLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JSpinner turnRate = movementAttributes.getTurnRate();
        turnRate.setToolTipText("Determines the rate at which the Object rotates during movement in JUnits/clientTick");
        turnRate.setModel(new SpinnerNumberModel(OrientationKeyFrame.TURN_RATE, 0, 2048, 1));
        card.add(turnRate, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupAnimCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel generalTitlePanel = new JPanel();
        generalTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(generalTitlePanel, c);

        JLabel generalTitle = new JLabel("General");
        generalTitle.setHorizontalAlignment(SwingConstants.LEFT);
        generalTitle.setFont(FontManager.getRunescapeBoldFont());
        generalTitlePanel.add(generalTitle);

        JLabel help = new JLabel(new ImageIcon(HELP));
        help.setHorizontalAlignment(SwingConstants.LEFT);
        help.setBorder(new EmptyBorder(0, 4, 0, 4));
        help.setToolTipText("<html>Pose Animations dynamically update your Object based on its current movement trajectory" +
                "<br>For example: an Object that isn't moving will use the given Idle animation; an Object taking a 90 degree right turn will use Walk Right animation." +
                "<br>Active Animations will instead override the current Pose Animation, playing regardless of the Object's movement trajectory</html>");
        generalTitlePanel.add(help);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel startFrameLabel = new JLabel("1st Frame: ");
        startFrameLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(startFrameLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner startFrame = animAttributes.getStartFrame();
        startFrame.setToolTipText("Set the frame at which the animation starts at");
        startFrame.setModel(new SpinnerNumberModel(0, 0, 99999, 1));
        startFrame.setPreferredSize(spinnerSize);
        card.add(startFrame, c);

        c.gridx = 2;
        c.gridy = 1;
        JButton randomize = new JButton("Random");
        randomize.setToolTipText("Sets a random starting frame between 0 to the maximum number of frames for the animation that is currently playing");
        card.add(randomize, c);

        /*
        c.gridx = 0;
        c.gridy = 2;
        JLabel stallLabel = new JLabel("Stall: ");
        stallLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(stallLabel, c);

        c.gridx = 1;
        c.gridy = 2;
        JComboBox<Toggle> stall = animAttributes.getStall();
        stall.setFocusable(false);
        stall.addItem(Toggle.DISABLE);
        stall.addItem(Toggle.ENABLE);
        card.add(stall, c);

         */

        c.gridwidth = 4;
        c.gridx = 0;
        c.gridy = 3;
        JLabel manualTitle = new JLabel("Active Animation");
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        card.add(manualTitle, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 4;
        JLabel manualLabel = new JLabel("Active: ");
        manualLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(manualLabel, c);

        c.gridx = 1;
        c.gridy = 4;
        JSpinner manual = animAttributes.getActive();
        manual.setToolTipText("Set the Active animation. This animation overrides the Pose animation, and should be used when performing an action like an attack or emote");
        manual.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        manual.setPreferredSize(spinnerSize);
        card.add(manual, c);

        c.gridx = 2;
        c.gridy = 4;
        JLabel loopLabel = new JLabel("Loop: ");
        loopLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(loopLabel, c);

        c.gridx = 3;
        c.gridy = 4;
        JComboBox<Toggle> loop = animAttributes.getLoop();
        loop.setToolTipText("Sets whether the Active animation should loop until the next Animation KeyFrame");
        loop.setFocusable(false);
        loop.addItem(Toggle.DISABLE);
        loop.addItem(Toggle.ENABLE);
        card.add(loop, c);

        c.gridx = 4;
        c.gridy = 4;
        JLabel freezeLabel = new JLabel("Freeze: ");
        freezeLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(freezeLabel, c);

        c.gridx = 5;
        c.gridy = 4;
        JComboBox<Toggle> freeze = animAttributes.getFreeze();
        freeze.setToolTipText("Set whether the animation should freeze on the frame indicated by 1st Frame");
        freeze.setFocusable(false);
        freeze.addItem(Toggle.DISABLE);
        freeze.addItem(Toggle.ENABLE);
        card.add(freeze, c);

        c.gridwidth = 4;
        c.gridx = 0;
        c.gridy = 5;
        JLabel smartTitle = new JLabel("Pose Animations");
        smartTitle.setFont(FontManager.getRunescapeBoldFont());
        card.add(smartTitle, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 6;
        JLabel idleLabel = new JLabel("Idle: ");
        idleLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleLabel, c);

        c.gridx = 1;
        c.gridy = 6;
        JSpinner idle = animAttributes.getIdle();
        idle.setToolTipText("The animation to play while standing idly without moving");
        idle.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idle.setPreferredSize(spinnerSize);
        card.add(idle, c);

        c.gridx = 2;
        c.gridy = 6;
        JLabel walk180Label = new JLabel("Walk 180: ");
        walk180Label.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walk180Label, c);

        c.gridx = 3;
        c.gridy = 6;
        JSpinner walk180 = animAttributes.getWalk180();
        walk180.setToolTipText("The animation to play while moving and turning in a 180");
        walk180.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walk180.setPreferredSize(spinnerSize);
        card.add(walk180, c);

        c.gridx = 0;
        c.gridy = 7;
        JLabel walkLabel = new JLabel("Walk: ");
        walkLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkLabel, c);

        c.gridx = 1;
        c.gridy = 7;
        JSpinner walk = animAttributes.getWalk();
        walk.setToolTipText("The animation to play while walking");
        walk.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walk.setPreferredSize(spinnerSize);
        card.add(walk, c);

        c.gridx = 2;
        c.gridy = 7;
        JLabel walkRLabel = new JLabel("Walk Right: ");
        walkRLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkRLabel, c);

        c.gridx = 3;
        c.gridy = 7;
        JSpinner walkRight = animAttributes.getWalkRight();
        walkRight.setToolTipText("The animation to play while walking and rotating to the right");
        walkRight.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walkRight.setPreferredSize(spinnerSize);
        card.add(walkRight, c);

        c.gridx = 4;
        c.gridy = 7;
        JLabel idleRLabel = new JLabel("Idle Right: ");
        idleRLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleRLabel, c);

        c.gridx = 5;
        c.gridy = 7;
        JSpinner idleRight = animAttributes.getIdleRight();
        idleRight.setToolTipText("The animation to play while standing and rotating to the right");
        idleRight.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idleRight.setPreferredSize(spinnerSize);
        card.add(idleRight, c);

        c.gridx = 0;
        c.gridy = 8;
        JLabel runLabel = new JLabel("Run: ");
        runLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(runLabel, c);

        c.gridx = 1;
        c.gridy = 8;
        JSpinner run = animAttributes.getRun();
        run.setToolTipText("The animation to play while running");
        run.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        run.setPreferredSize(spinnerSize);
        card.add(run, c);

        c.gridx = 2;
        c.gridy = 8;
        JLabel walkLLabel = new JLabel("Walk Left: ");
        walkLLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(walkLLabel, c);

        c.gridx = 3;
        c.gridy = 8;
        JSpinner walkLeft = animAttributes.getWalkLeft();
        walkLeft.setToolTipText("The animation to play while walking and rotating to the left");
        walkLeft.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        walkLeft.setPreferredSize(spinnerSize);
        card.add(walkLeft, c);

        c.gridx = 4;
        c.gridy = 8;
        JLabel idleLLabel = new JLabel("Idle Left: ");
        idleLLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idleLLabel, c);

        c.gridx = 5;
        c.gridy = 8;
        JSpinner idleLeft = animAttributes.getIdleLeft();
        idleLeft.setToolTipText("The animation to play while standing and rotating to the left");
        idleLeft.setModel(new SpinnerNumberModel(-1, -1, 99999, 1));
        idleLeft.setPreferredSize(spinnerSize);
        card.add(idleLeft, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 11;
        JLabel npcSearcherLabel = new JLabel("NPC Presets: ");
        npcSearcherLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(npcSearcherLabel, c);

        c.gridwidth = 3;
        c.gridx = 1;
        c.gridy = 11;
        JTextField npcField = new JTextField("");
        npcField.setToolTipText("Search up different NPCs, and double click the name to apply all of its Pose animations");
        npcField.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.add(npcField, c);

        JPopupMenu npcPopup = new JPopupMenu("NPCs");
        JScrollPane npcScrollPane = new JScrollPane(npcTable);
        npcPopup.add(npcScrollPane);

        KeyListener npcListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                String text = npcField.getText();
                npcTable.searchAndListEntries(text);
                npcPopup.setVisible(true);
                Point p = npcField.getLocationOnScreen();
                npcPopup.setLocation(new Point((int) p.getX() + npcField.getWidth(), (int) p.getY()));
            }
        };
        npcField.addKeyListener(npcListener);

        npcField.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {

            }

            @Override
            public void focusLost(FocusEvent e)
            {
                npcPopup.setVisible(false);
            }
        });

        npcTable.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);
                if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
                {
                    Object o = npcTable.getSelectedObject();
                    if (o instanceof NPCData)
                    {
                        NPCData data = (NPCData) o;
                        idle.setValue(data.getStandingAnimation());
                        walk.setValue(data.getWalkingAnimation());
                        run.setValue(data.getRunAnimation());
                        walk180.setValue(data.getRotate180Animation());
                        walkRight.setValue(data.getRotateRightAnimation());
                        walkLeft.setValue(data.getRotateLeftAnimation());
                        idleRight.setValue(data.getIdleRotateRightAnimation());
                        idleLeft.setValue(data.getIdleRotateLeftAnimation());
                    }

                    npcPopup.setVisible(false);
                }
            }
        });

        if (dataFinder.isDataLoaded(DataFinder.DataType.NPC))
        {
            List<NPCData> dataList = dataFinder.getNpcData();
            List<Object> list = new ArrayList<>(dataList);
            npcTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.NPC, () ->
            {
                List<NPCData> dataList = dataFinder.getNpcData();
                List<Object> list = new ArrayList<>(dataList);
                npcTable.initialize(list);
            });
        }

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 12;
        JLabel itemSearcherLabel = new JLabel("Weapon Presets: ");
        itemSearcherLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(itemSearcherLabel, c);

        c.gridwidth = 3;
        c.gridx = 1;
        c.gridy = 12;
        JTextField itemField = new JTextField("");
        itemField.setToolTipText("Search up all items, and double click the name to apply all of its Pose animations");
        itemField.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.add(itemField, c);

        JPopupMenu itemPopup = new JPopupMenu("Items");
        JScrollPane itemScrollPane = new JScrollPane(itemTable);
        itemPopup.add(itemScrollPane);

        KeyListener itemListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                String text = itemField.getText();
                itemTable.searchAndListEntries(text);
                itemPopup.setVisible(true);
                Point p = itemField.getLocationOnScreen();
                itemPopup.setLocation(new Point((int) p.getX() + itemField.getWidth(), (int) p.getY()));
            }
        };
        itemField.addKeyListener(itemListener);

        itemField.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {

            }

            @Override
            public void focusLost(FocusEvent e)
            {
                itemPopup.setVisible(false);
            }
        });

        itemTable.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);
                if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
                {
                    Object o = itemTable.getSelectedObject();
                    if (o instanceof ItemData)
                    {
                        ItemData data = (ItemData) o;
                        int itemId = data.getId();

                        boolean foundMatch = false;

                        List<WeaponAnimData> weaponAnimSets = dataFinder.getWeaponAnimData();
                        for (WeaponAnimData weaponAnim : weaponAnimSets)
                        {
                            int[] ids = weaponAnim.getId();
                            if (ids == null || ids.length == 0)
                            {
                                continue;
                            }

                            for (int i : ids)
                            {
                                if (i == itemId)
                                {
                                    idle.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE));
                                    walk.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.WALK));
                                    run.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.RUN));
                                    walk180.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_180));
                                    walkRight.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_RIGHT));
                                    walkLeft.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_LEFT));
                                    idleRight.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_RIGHT));
                                    idleLeft.setValue(WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_LEFT));
                                    foundMatch = true;
                                    break;
                                }
                            }

                            if (foundMatch)
                            {
                                break;
                            }
                        }

                        if (!foundMatch)
                        {
                            idle.setValue(-1);
                            walk.setValue(-1);
                            run.setValue(-1);
                            walk180.setValue(-1);
                            walkRight.setValue(-1);
                            walkLeft.setValue(-1);
                            idleRight.setValue(-1);
                            idleLeft.setValue(-1);
                        }
                    }

                    itemPopup.setVisible(false);
                }
            }
        });

        if (dataFinder.isDataLoaded(DataFinder.DataType.ITEM))
        {
            List<ItemData> dataList = dataFinder.getItemData();
            List<Object> list = new ArrayList<>(dataList);
            itemTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.ITEM, () ->
            {
                List<ItemData> dataList = dataFinder.getItemData();
                List<Object> list = new ArrayList<>(dataList);
                itemTable.initialize(list);
            });
        }

        NPCData player = new NPCData(
                -1,
                "Player",
                new int[0],
                1,
                808,
                819,
                824,
                823,
                823,
                820,
                821,
                822,
                1,
                1,
                new int[0],
                new int[0]);

        c.gridwidth = 2;
        c.gridx = 4;
        c.gridy = 12;
        JButton addPlayer = new JButton("Unarmed");
        addPlayer.setToolTipText("Apply all the default Pose animations for an unarmed player");
        addPlayer.setBackground(ColorScheme.DARK_GRAY_COLOR);
        addPlayer.addActionListener(e ->
        {
            idle.setValue(player.getStandingAnimation());
            walk.setValue(player.getWalkingAnimation());
            run.setValue(player.getRunAnimation());
            walk180.setValue(player.getRotate180Animation());
            walkRight.setValue(player.getRotateRightAnimation());
            walkLeft.setValue(player.getRotateLeftAnimation());
            idleRight.setValue(player.getIdleRotateRightAnimation());
            idleLeft.setValue(player.getIdleRotateLeftAnimation());
        });
        card.add(addPlayer, c);

        randomize.addActionListener(e ->
        {
            Character character = timeSheetPanel.getSelectedCharacter();
            if (character == null)
            {
                return;
            }

            CKObject ckObject = character.getCkObject();

            clientThread.invokeLater(() ->
            {
                Animation[] animations = ckObject.getAnimations();
                int animId;
                Animation activeAnim = animations[0];
                Animation poseAnim = animations[1];

                if (activeAnim == null || activeAnim.getId() == -1)
                {
                    if (poseAnim == null || poseAnim.getId() == -1)
                    {
                        return;
                    }

                    animId = poseAnim.getId();
                }
                else
                {
                    animId = activeAnim.getId();
                }

                Animation animation = client.loadAnimation(animId);
                if (animation == null)
                {
                    return;
                }

                int frames = animation.getNumFrames();
                int randomFrame = random.nextInt(frames);
                startFrame.setValue(randomFrame);
            });
        });

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 13;
        JLabel animSearcherLabel = new JLabel("Animations: ");
        animSearcherLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(animSearcherLabel, c);

        c.gridwidth = 3;
        c.gridx = 1;
        c.gridy = 13;
        JTextField animField = new JTextField("");
        animField.setToolTipText("Search up all animations, and double click the name to apply it as the Active animation");
        animField.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.add(animField, c);

        JPopupMenu animPopup = new JPopupMenu("Animations");
        JScrollPane animScrollPane = new JScrollPane(animTable);
        animPopup.add(animScrollPane);

        KeyListener animListener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                String text = animField.getText();
                animTable.searchAndListEntries(text);
                animPopup.setVisible(true);
                Point p = animField.getLocationOnScreen();
                animPopup.setLocation(new Point((int) p.getX() + animField.getWidth(), (int) p.getY()));
            }
        };
        animField.addKeyListener(animListener);

        animField.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {

            }

            @Override
            public void focusLost(FocusEvent e)
            {
                animPopup.setVisible(false);
            }
        });

        animTable.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);
                if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
                {
                    Object o = animTable.getSelectedObject();
                    if (o instanceof AnimData)
                    {
                        AnimData data = (AnimData) o;
                        manual.setValue(data.getId());

                    }

                    animPopup.setVisible(false);
                }
            }
        });

        if (dataFinder.isDataLoaded(DataFinder.DataType.ANIM))
        {
            List<AnimData> dataList = dataFinder.getAnimData();
            List<Object> list = new ArrayList<>(dataList);
            animTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.ANIM, () ->
            {
                List<AnimData> dataList = dataFinder.getAnimData();
                List<Object> list = new ArrayList<>(dataList);
                animTable.initialize(list);
            });
        }

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupOriCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Orientation");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Setting an Orientation keyframe allows you to take direct control of an Object's orientation" +
                "<br>Otherwise, the Object's orientation is instead based off of the direction of its movement" +
                "<br>Start is the orientation to set at the start of the keyframe, while End determines where the Object will eventually point" +
                "<br>Use Ctrl+[ on a tile to set that orientation, relative to the Object's current tile, as the Start" +
                "<br>Use Ctrl+] on a tile to set that orientation, relative to the Object's current tile, as the End</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel startLabel = new JLabel("Start Orientation: ");
        startLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(startLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner start = oriAttributes.getStart();
        start.setToolTipText("Set the starting orientation that will apply at the beginning of the KeyFrame");
        start.setModel(new SpinnerNumberModel(0, 0, 2048, 1));
        start.setPreferredSize(spinnerSize);
        card.add(start, c);

        c.gridwidth = 1;
        c.gridx = 2;
        c.gridy = 1;
        JLabel endLabel = new JLabel("End Orientation: ");
        endLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(endLabel, c);

        c.gridx = 3;
        c.gridy = 1;
        JSpinner end = oriAttributes.getEnd();
        end.setToolTipText("Set the ending orientation that the KeyFrame will try to reach");
        end.setModel(new SpinnerNumberModel(0, 0, 2048, 1));
        end.setPreferredSize(spinnerSize);
        card.add(end, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JButton getStart = new JButton("Grab");
        getStart.setToolTipText("Grab the current orientation of the Object, and apply it as the Start");
        getStart.addActionListener(e ->
        {
            Character selectedCharacter = timeSheetPanel.getSelectedCharacter();
            if (selectedCharacter == null)
            {
                return;
            }

            CKObject ckObject = selectedCharacter.getCkObject();
            if (ckObject == null)
            {
                return;
            }

            start.setValue(ckObject.getOrientation());
        });
        card.add(getStart, c);

        c.gridwidth = 1;
        c.gridx = 3;
        c.gridy = 2;
        JButton getEnd = new JButton("Grab");
        getEnd.setToolTipText("Grab the current Orientation of the Object, and apply it as the End");
        getEnd.addActionListener(e ->
        {
            Character selectedCharacter = timeSheetPanel.getSelectedCharacter();
            if (selectedCharacter == null)
            {
                return;
            }

            CKObject ckObject = selectedCharacter.getCkObject();
            if (ckObject == null)
            {
                return;
            }

            end.setValue(ckObject.getOrientation());
        });
        card.add(getEnd, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel durationLabel = new JLabel("Duration: ");
        durationLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(durationLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JSpinner duration = oriAttributes.getDuration();
        duration.setToolTipText("<html>Set the duration for how long the Object will attempt to point towards its End orientation" +
                "<br>If the Object reaches the End orientation, it will remain in that state until the Duration is over, regardless of its movement trajectory</html>");
        duration.setModel(new SpinnerNumberModel(1.0, 0, TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH, 0.1));
        duration.setPreferredSize(spinnerSize);
        card.add(duration, c);

        c.gridwidth = 2;
        c.gridx = 2;
        c.gridy = 3;
        JButton calculate = new JButton("Calculate");
        calculate.setToolTipText("Calculates the exact duration based on the start and end orientation and the current turn rate");
        calculate.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.add(calculate, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 4;
        JLabel turnRateLabel = new JLabel("Turn Rate: ");
        turnRateLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(turnRateLabel, c);

        c.gridx = 1;
        c.gridy = 4;
        JSpinner turnRate = oriAttributes.getTurnRate();
        turnRate.setToolTipText("Determines the rate at which the Object rotates in JUnits/clientTick");
        turnRate.setModel(new SpinnerNumberModel(OrientationKeyFrame.TURN_RATE, 0, 2048, 1));
        card.add(turnRate, c);

        calculate.addActionListener(e ->
        {
            double turnDuration = calculateOrientationDuration((int) start.getValue(), (int) end.getValue(), (int) turnRate.getValue());
            duration.setValue(turnDuration);

        });

        c.gridx = 5;
        c.gridy = 5;
        c.weightx = 1;
        c.weighty = 1;
        c.gridwidth = 1;
        JLabel compass = new JLabel(new ImageIcon(COMPASS));
        compass.setHorizontalAlignment(SwingConstants.CENTER);
        card.add(compass, c);
    }

    public static double calculateOrientationDuration(int start, int end, double turnRate)
    {
        int difference = Orientation.subtract(end, start);
        double ticks = (double) difference / turnRate * Constants.CLIENT_TICK_LENGTH / Constants.GAME_TICK_LENGTH;
        int scale = (int) Math.pow(10, 1);
        return Math.abs(Math.ceil(ticks * scale) / scale);
    }

    private void setupSpawnCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Spawn");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set whether the object appears or not");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel spawnLabel = new JLabel("Spawn status: ");
        spawnLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(spawnLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JComboBox<Toggle> manualCheckbox = spawnAttributes.getSpawn();
        manualCheckbox.setToolTipText("Sets whether the Object is spawned or not");
        manualCheckbox.setFocusable(false);
        manualCheckbox.addItem(Toggle.ENABLE);
        manualCheckbox.addItem(Toggle.DISABLE);
        card.add(manualCheckbox, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    public void setupModelCard(JPanel card)
    {
        Dimension spinnerSize = new Dimension(90, 25);
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Model");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("<html>Switch between using a 3D model based on the Model Id from the cache," +
                "<br>or a Custom Model that you've grabbed from the environment, found via the Cache Searcher, or created in the Model Anvil</html>");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel modelLabel = new JLabel("Model Type");
        modelLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(modelLabel, c);

        c.gridwidth = 2;
        c.gridx = 1;
        c.gridy = 1;
        JComboBox<ModelToggle> modelOverride = modelAttributes.getModelOverride();
        modelOverride.setToolTipText("Set whether to use a 3D model based on Model Id, or a Custom Model found via this plugin");
        modelOverride.setFocusable(false);
        modelOverride.addItem(ModelToggle.CUSTOM_MODEL);
        modelOverride.addItem(ModelToggle.MODEL_ID);
        card.add(modelOverride, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel customLabel = new JLabel("Custom Model: ");
        customLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(customLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<CustomModel> customComboBox = modelAttributes.getCustomModel();
        customComboBox.setToolTipText("The Custom Model to apply, if Model Type is set to Custom");
        customComboBox.setFocusable(false);
        card.add(customComboBox, c);

        c.gridx = 2;
        c.gridy = 2;
        JButton grab = new JButton("Grab");
        grab.setToolTipText("Grabs the original Custom Model and Radius set to the Object");
        card.add(grab, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel idLabel = new JLabel("Model Id: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JSpinner id = modelAttributes.getModelId();
        id.setToolTipText("The Model Id from the cache to apply, if Model Type is set to Model Id");
        id.setValue(-1);
        id.setPreferredSize(spinnerSize);
        card.add(id, c);

        c.gridx = 0;
        c.gridy = 4;
        JLabel radiusLabel = new JLabel("Radius: ");
        radiusLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(radiusLabel, c);

        c.gridx = 1;
        c.gridy = 4;
        JSpinner radius = modelAttributes.getRadius();
        radius.setToolTipText("How far the Model should render vs clip with other tiles around it, measured in 1/128th tiles");
        radius.setValue(60);
        radius.setPreferredSize(spinnerSize);
        card.add(radius, c);

        grab.addActionListener(e ->
        {
            Character selectedCharacter = timeSheetPanel.getSelectedCharacter();
            if (selectedCharacter == null)
            {
                return;
            }

            customComboBox.setSelectedItem(selectedCharacter.getStoredModel());
            radius.setValue((int) selectedCharacter.getRadiusSpinner().getValue());
        });

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupTextCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Text");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the text to display over this Object's head");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel durationLabel = new JLabel("Duration: ");
        durationLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(durationLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 1;
        JSpinner duration = textAttributes.getDuration();
        duration.setToolTipText("How long the text should render for");
        duration.setModel(new SpinnerNumberModel(5.0, 0, 1000000, 0.1));
        card.add(duration, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel textLabel = new JLabel("Overhead Text: ");
        textLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(textLabel, c);

        c.weightx = 1;
        c.gridwidth = 2;
        c.gridx = 1;
        c.gridy = 2;
        JTextArea text = textAttributes.getText();
        text.setToolTipText("The text to show overhead");
        text.setText("");
        text.setLineWrap(true);
        card.add(text, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupOverheadCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Overhead");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the prayer and/or skull icon to display over this Object's head");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel skullLabel = new JLabel("Enable Skull: ");
        skullLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(skullLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 1;
        JComboBox<OverheadSprite> toggleSkull = overheadAttributes.getSkullSprite();
        toggleSkull.setToolTipText("Set the skull icon to display overhead");
        toggleSkull.setFocusable(false);
        toggleSkull.addItem(OverheadSprite.NONE);
        toggleSkull.addItem(OverheadSprite.SKULL);
        toggleSkull.addItem(OverheadSprite.SKULL_HIGH_RISK);
        toggleSkull.addItem(OverheadSprite.SKULL_BH_1);
        toggleSkull.addItem(OverheadSprite.SKULL_BH_2);
        toggleSkull.addItem(OverheadSprite.SKULL_BH_3);
        toggleSkull.addItem(OverheadSprite.SKULL_BH_4);
        toggleSkull.addItem(OverheadSprite.SKULL_BH_5);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY_1);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY_2);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY_3);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY_4);
        toggleSkull.addItem(OverheadSprite.SKULL_FORINTHRY_5);
        toggleSkull.addItem(OverheadSprite.SKULL_DEADMAN_1);
        toggleSkull.addItem(OverheadSprite.SKULL_DEADMAN_2);
        toggleSkull.addItem(OverheadSprite.SKULL_DEADMAN_3);
        toggleSkull.addItem(OverheadSprite.SKULL_DEADMAN_4);
        toggleSkull.addItem(OverheadSprite.SKULL_DEADMAN_5);
        card.add(toggleSkull, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel textLabel = new JLabel("Overhead Icon: ");
        textLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(textLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<OverheadSprite> spriteBox = overheadAttributes.getPrayerSprite();
        spriteBox.setToolTipText("Set the prayer icon to display overhead");
        spriteBox.setFocusable(false);
        spriteBox.addItem(OverheadSprite.NONE);
        spriteBox.addItem(OverheadSprite.PROTECT_MAGIC);
        spriteBox.addItem(OverheadSprite.PROTECT_RANGED);
        spriteBox.addItem(OverheadSprite.PROTECT_MELEE);
        spriteBox.addItem(OverheadSprite.REDEMPTION);
        spriteBox.addItem(OverheadSprite.RETRIBUTION);
        spriteBox.addItem(OverheadSprite.SMITE);
        spriteBox.addItem(OverheadSprite.PROTECT_RANGE_MAGE);
        spriteBox.addItem(OverheadSprite.PROTECT_RANGE_MELEE);
        spriteBox.addItem(OverheadSprite.PROTECT_MAGE_MELEE);
        spriteBox.addItem(OverheadSprite.PROTECT_RANGE_MAGE_MELEE);
        spriteBox.addItem(OverheadSprite.DEFLECT_MAGE);
        spriteBox.addItem(OverheadSprite.DEFLECT_RANGE);
        spriteBox.addItem(OverheadSprite.DEFLECT_MELEE);
        spriteBox.addItem(OverheadSprite.SOUL_SPLIT);
        spriteBox.addItem(OverheadSprite.WRATH);
        card.add(spriteBox, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupHealthCard(JPanel card)
    {
        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("Healthbar");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the healthbar state for this Object. The amount of damage that will be shown is the Current health relative to the Maximum health");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel durationLabel = new JLabel("Duration: ");
        durationLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(durationLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 1;
        JSpinner duration = healthAttributes.getDuration();
        duration.setToolTipText("Set how long the healthbar should appear for");
        duration.setModel(new SpinnerNumberModel(5.0, 0, 1000000, 1));
        card.add(duration, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel healthbarLabel = new JLabel("Healthbar Sprite: ");
        healthbarLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(healthbarLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 2;
        JComboBox<HealthbarSprite> healthbarSprite = healthAttributes.getHealthbarSprite();
        healthbarSprite.setToolTipText("Set the sprite for the healthbar to show");
        healthbarSprite.setFocusable(false);
        healthbarSprite.addItem(HealthbarSprite.DEFAULT);
        card.add(healthbarSprite, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 3;
        JLabel maxHealthLabel = new JLabel("Max Health: ");
        maxHealthLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(maxHealthLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 3;
        JSpinner maxHealth = healthAttributes.getMaxHealth();
        maxHealth.setToolTipText("Set the Object's maximum health");
        maxHealth.setModel(new SpinnerNumberModel(99, 0, 99999, 1));
        maxHealth.setValue(99);
        card.add(maxHealth, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 4;
        JLabel currentHealthLabel = new JLabel("Current Health: ");
        currentHealthLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(currentHealthLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 4;
        JSpinner currentHealth = healthAttributes.getCurrentHealth();
        currentHealth.setToolTipText("Set the Object's current health remaining");
        currentHealth.setModel(new SpinnerNumberModel(99, 0, 99999, 1));
        currentHealth.setValue(99);
        card.add(currentHealth, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 8;
        c.gridy = 15;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);
    }

    private void setupSpotAnimCard(JPanel card, KeyFrameType spotAnimType)
    {
        SpotAnimAttributes spAttributes;
        if (spotAnimType == KeyFrameType.SPOTANIM)
        {
            spAttributes = spotAnimAttributes;
        }
        else
        {
            spAttributes = spotAnim2Attributes;
        }

        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel("SpotAnim");
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the SpotAnim (like spell effects) to play on the Object");
        manualTitlePanel.add(manualTitleHelp);

        c.weightx = 0;
        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel idLabel = new JLabel("SpotAnim: ");
        idLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(idLabel, c);

        c.gridwidth = 1;
        c.gridx = 1;
        c.gridy = 1;
        JSpinner id = spAttributes.getSpotAnimId();
        id.setValue(-1);
        card.add(id, c);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 2;
        JLabel loop1Label = new JLabel("Loop: ");
        loop1Label.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(loop1Label, c);

        c.gridx = 1;
        c.gridy = 2;
        JComboBox<Toggle> loop = spAttributes.getLoop();
        loop.setToolTipText("Set whether the SpotAnim animation should loop");
        loop.setFocusable(false);
        loop.addItem(Toggle.DISABLE);
        loop.addItem(Toggle.ENABLE);
        card.add(loop, c);

        c.gridx = 0;
        c.gridy = 3;
        JLabel heightLabel = new JLabel("Height");
        heightLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(heightLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JSpinner height = spAttributes.getHeight();
        height.setToolTipText("Sets the height at which the SpotAnim spawns");
        height.setModel(new SpinnerNumberModel(92, 0, 9999, 1));
        card.add(height, c);

        c.gridx = 0;
        c.gridy = 4;
        JLabel searcherLabel = new JLabel("SpotAnims: ");
        searcherLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(searcherLabel, c);

        c.gridwidth = 3;
        c.gridx = 1;
        c.gridy = 4;
        JTextField spotanimField = new JTextField("");
        spotanimField.setToolTipText("Find all SpotAnims from the cache, and double click the name to apply its Id");
        spotanimField.setBackground(ColorScheme.DARK_GRAY_COLOR);
        card.add(spotanimField, c);

        KeyListener listener = new KeyListener() {
            @Override
            public void keyTyped(KeyEvent e) {

            }

            @Override
            public void keyPressed(KeyEvent e) {

            }

            @Override
            public void keyReleased(KeyEvent e)
            {
                String text = spotanimField.getText();
                spotanimTable.searchAndListEntries(text);
                spotanimPopup.setVisible(true);
                Point p = spotanimField.getLocationOnScreen();
                spotanimPopup.setLocation(new Point((int) p.getX() + spotanimField.getWidth(), (int) p.getY()));
            }
        };
        spotanimField.addKeyListener(listener);

        spotanimField.addFocusListener(new FocusListener()
        {
            @Override
            public void focusGained(FocusEvent e)
            {

            }

            @Override
            public void focusLost(FocusEvent e)
            {
                spotanimPopup.setVisible(false);
            }
        });

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 2;
        c.gridy = 5;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 3;
        c.gridy = 6;
        JPanel duplicatePanel = new JPanel();
        duplicatePanel.setLayout(new GridLayout(0, 1, 2, 2));
        card.add(duplicatePanel, c);
        duplicatePanel.add(new JLabel("Duplicate To:"));

        if (spotAnimType == KeyFrameType.SPOTANIM)
        {
            JLabel emptySpotAnim = new JLabel("Spotanim 1");
            emptySpotAnim.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptySpotAnim);
        }
        else
        {
            JButton type1 = new JButton("SpotAnim 1");
            type1.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type1);
            type1.addActionListener(e -> timeSheetPanel.duplicateSpotanimKeyFrame(spotAnimType, KeyFrameType.SPOTANIM));
        }

        if (spotAnimType == KeyFrameType.SPOTANIM2)
        {
            JLabel emptySpotAnim = new JLabel("Spotanim 2");
            emptySpotAnim.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptySpotAnim);
        }
        else
        {
            JButton type2 = new JButton("SpotAnim 2");
            type2.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type2);
            type2.addActionListener(e -> timeSheetPanel.duplicateSpotanimKeyFrame(spotAnimType, KeyFrameType.SPOTANIM2));
        }
    }

    private void setupSpotAnimFinder()
    {
        spotanimTable.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseClicked(MouseEvent e)
            {
                super.mouseClicked(e);

                KeyFrameType spotAnimType = selectedKeyFramePage;
                if (selectedKeyFramePage != KeyFrameType.SPOTANIM && selectedKeyFramePage != KeyFrameType.SPOTANIM2)
                {
                    return;
                }

                if (e.getClickCount() == 2 && e.getButton() == MouseEvent.BUTTON1)
                {
                    Object o = spotanimTable.getSelectedObject();
                    if (o instanceof SpotanimData)
                    {
                        SpotanimData data = (SpotanimData) o;
                        JSpinner id;
                        if (spotAnimType == KeyFrameType.SPOTANIM)
                        {
                            id = spotAnimAttributes.getSpotAnimId();
                        }
                        else
                        {
                            id = spotAnim2Attributes.getSpotAnimId();
                        }

                        id.setValue(data.getId());
                    }

                    spotanimPopup.setVisible(false);
                }
            }
        });

        if (dataFinder.isDataLoaded(DataFinder.DataType.SPOTANIM))
        {
            List<SpotanimData> dataList = dataFinder.getSpotanimData();
            List<Object> list = new ArrayList<>(dataList);
            spotanimTable.initialize(list);
        }
        else
        {
            dataFinder.addLoadCallback(DataFinder.DataType.SPOTANIM, () ->
            {
                List<SpotanimData> dataList = dataFinder.getSpotanimData();
                List<Object> list = new ArrayList<>(dataList);
                spotanimTable.initialize(list);
            });
        }

        JScrollPane scrollPane = new JScrollPane(spotanimTable);
        spotanimPopup.add(scrollPane);
    }

    private void setupHitsplatCard(JPanel card, KeyFrameType hitsplatType)
    {
        HitsplatAttributes attributes;
        String name;

        switch (hitsplatType)
        {
            default:
            case HITSPLAT_1:
                attributes = hitsplat1Attributes;
                name = HITSPLAT_1_CARD;
                break;
            case HITSPLAT_2:
                attributes = hitsplat2Attributes;
                name = HITSPLAT_2_CARD;
                break;
            case HITSPLAT_3:
                attributes = hitsplat3Attributes;
                name = HITSPLAT_3_CARD;
                break;
            case HITSPLAT_4:
                attributes = hitsplat4Attributes;
                name = HITSPLAT_4_CARD;
        }

        card.setLayout(new GridBagLayout());
        card.setBorder(new EmptyBorder(4, 4, 4, 4));
        card.setFocusable(true);
        addMouseFocusListener(card);

        c.fill = GridBagConstraints.HORIZONTAL;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 4;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 0;
        JPanel manualTitlePanel = new JPanel();
        manualTitlePanel.setLayout(new FlowLayout(FlowLayout.LEFT, 0, 0));
        card.add(manualTitlePanel, c);

        JLabel manualTitle = new JLabel(name);
        manualTitle.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitle.setFont(FontManager.getRunescapeBoldFont());
        manualTitlePanel.add(manualTitle);

        JLabel manualTitleHelp = new JLabel(new ImageIcon(HELP));
        manualTitleHelp.setHorizontalAlignment(SwingConstants.LEFT);
        manualTitleHelp.setBorder(new EmptyBorder(0, 4, 0, 4));
        manualTitleHelp.setToolTipText("Set the hitsplat sprite and damage to overlay on the Object");
        manualTitlePanel.add(manualTitleHelp);

        c.gridwidth = 1;
        c.gridx = 0;
        c.gridy = 1;
        JLabel durationLabel = new JLabel("Duration: ");
        durationLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(durationLabel, c);

        c.gridx = 1;
        c.gridy = 1;
        JSpinner duration = attributes.getDuration();
        duration.setToolTipText("Set the duration, in game ticks, for how long the Hitsplat lasts. -1 sets it to default value, which is 5/3 ticks");
        duration.setModel(new SpinnerNumberModel(-1, -1, 1000000, 1));
        card.add(duration, c);

        c.gridx = 0;
        c.gridy = 2;
        JLabel spriteLabel = new JLabel("Sprite: ");
        spriteLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(spriteLabel, c);

        c.gridx = 1;
        c.gridy = 2;
        JComboBox<HitsplatSprite> sprite = attributes.getSprite();
        sprite.setToolTipText("Set the Hitsplat sprite to display");
        sprite.setFocusable(false);
        sprite.addItem(HitsplatSprite.BLOCK);
        sprite.addItem(HitsplatSprite.DAMAGE);
        sprite.addItem(HitsplatSprite.POISON);
        sprite.addItem(HitsplatSprite.VENOM);
        sprite.addItem(HitsplatSprite.HEAL);
        sprite.addItem(HitsplatSprite.SHIELD);
        sprite.addItem(HitsplatSprite.DISEASE);
        sprite.addItem(HitsplatSprite.FREEZE);
        sprite.addItem(HitsplatSprite.NO_KILL_CREDIT);
        sprite.addItem(HitsplatSprite.ARMOUR);
        sprite.addItem(HitsplatSprite.BURN);
        sprite.addItem(HitsplatSprite.BLEED);
        sprite.addItem(HitsplatSprite.CORRUPTION);
        sprite.addItem(HitsplatSprite.DOOM);
        sprite.addItem(HitsplatSprite.POISE);
        sprite.addItem(HitsplatSprite.PRAYER_DRAIN);
        sprite.addItem(HitsplatSprite.SANITY_DRAIN);
        sprite.addItem(HitsplatSprite.SANITY_RESTORE);
        sprite.addItem(HitsplatSprite.CHARGE_UP);
        sprite.addItem(HitsplatSprite.CHARGE_DOWN);
        card.add(sprite, c);

        c.gridx = 0;
        c.gridy = 3;
        JLabel variantLabel = new JLabel("Variant: ");
        variantLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(variantLabel, c);

        c.gridx = 1;
        c.gridy = 3;
        JComboBox<HitsplatVariant> variant = attributes.getVariant();
        variant.setToolTipText("Set the Hitsplat variant to display");
        variant.setFocusable(false);
        variant.addItem(HitsplatVariant.NORMAL);
        variant.addItem(HitsplatVariant.MAX);
        variant.addItem(HitsplatVariant.OTHER);
        card.add(variant, c);

        c.gridx = 0;
        c.gridy = 4;
        JLabel damageLabel = new JLabel("Damage: ");
        damageLabel.setHorizontalAlignment(SwingConstants.RIGHT);
        card.add(damageLabel, c);

        c.gridx = 1;
        c.gridy = 4;
        JSpinner damage = attributes.getDamage();
        damage.setToolTipText("Set the damage value to show on the hisplat. -1 will not render any damage number");
        damage.setModel(new SpinnerNumberModel(0, -1, 999, 1));
        card.add(damage, c);

        c.gridx = 2;
        c.gridy = 4;
        JButton keyFrameHealth = new JButton("Quick KeyFrame Hitsplat/Health");
        keyFrameHealth.setToolTipText("Creates the Hitsplat KeyFrame and an appropriate Health KeyFrame as if this damage were applied");
        keyFrameHealth.setBackground(ColorScheme.DARK_GRAY_COLOR);
        keyFrameHealth.addActionListener(e -> timeSheetPanel.initializeHealthKeyFrame(hitsplatType));
        card.add(keyFrameHealth, c);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 3;
        c.gridy = 5;
        JLabel empty1 = new JLabel("");
        card.add(empty1, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 5;
        c.gridy = 7;
        JPanel duplicatePanel = new JPanel();
        duplicatePanel.setLayout(new GridLayout(0, 1, 2, 2));
        card.add(duplicatePanel, c);
        duplicatePanel.add(new JLabel("Duplicate To:"));

        if (hitsplatType == KeyFrameType.HITSPLAT_1)
        {
            JLabel emptyHitsplat = new JLabel("Hitsplat 1");
            emptyHitsplat.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptyHitsplat);
        }
        else
        {
            JButton type1 = new JButton("Hitsplat 1");
            type1.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type1);
            type1.addActionListener(e -> timeSheetPanel.duplicateHitsplatKeyFrame(hitsplatType, KeyFrameType.HITSPLAT_1));
        }

        if (hitsplatType == KeyFrameType.HITSPLAT_2)
        {
            JLabel emptyHitsplat = new JLabel("Hitsplat 2");
            emptyHitsplat.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptyHitsplat);
        }
        else
        {
            JButton type2 = new JButton("Hitsplat 2");
            type2.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type2);
            type2.addActionListener(e -> timeSheetPanel.duplicateHitsplatKeyFrame(hitsplatType, KeyFrameType.HITSPLAT_2));
        }

        if (hitsplatType == KeyFrameType.HITSPLAT_3)
        {
            JLabel emptyHitsplat = new JLabel("Hitsplat 3");
            emptyHitsplat.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptyHitsplat);
        }
        else
        {
            JButton type3 = new JButton("Hitsplat 3");
            type3.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type3);
            type3.addActionListener(e -> timeSheetPanel.duplicateHitsplatKeyFrame(hitsplatType, KeyFrameType.HITSPLAT_3));
        }

        if (hitsplatType == KeyFrameType.HITSPLAT_4)
        {
            JLabel emptyHitsplat = new JLabel("Hitsplat 4");
            emptyHitsplat.setHorizontalAlignment(SwingConstants.CENTER);
            duplicatePanel.add(emptyHitsplat);
        }
        else
        {
            JButton type4 = new JButton("Hitsplat 4");
            type4.setBackground(ColorScheme.DARK_GRAY_COLOR);
            duplicatePanel.add(type4);
            type4.addActionListener(e -> timeSheetPanel.duplicateHitsplatKeyFrame(hitsplatType, KeyFrameType.HITSPLAT_4));
        }
    }

    public void switchCards(String cardName)
    {
        KeyFrameType type;
        switch (cardName)
        {
            default:
            case MOVE_CARD:
                type = KeyFrameType.MOVEMENT;
                break;
            case ANIM_CARD:
                type = KeyFrameType.ANIMATION;
                break;
            case ORI_CARD:
                type = KeyFrameType.ORIENTATION;
                break;
            case SPAWN_CARD:
                type = KeyFrameType.SPAWN;
                break;
            case MODEL_CARD:
                type = KeyFrameType.MODEL;
                break;
            case TEXT_CARD:
                type = KeyFrameType.TEXT;
                break;
            case OVER_CARD:
                type = KeyFrameType.OVERHEAD;
                break;
            case HEALTH_CARD:
                type = KeyFrameType.HEALTH;
                break;
            case SPOTANIM_CARD:
                type = KeyFrameType.SPOTANIM;
                break;
            case SPOTANIM2_CARD:
                type = KeyFrameType.SPOTANIM2;
                break;
            case HITSPLAT_1_CARD:
                type = KeyFrameType.HITSPLAT_1;
                break;
            case HITSPLAT_2_CARD:
                type = KeyFrameType.HITSPLAT_2;
                break;
            case HITSPLAT_3_CARD:
                type = KeyFrameType.HITSPLAT_3;
                break;
            case HITSPLAT_4_CARD:
                type = KeyFrameType.HITSPLAT_4;
        }

        switchCards(type);
    }

    public void switchCards(KeyFrameType type)
    {
        selectedKeyFramePage = type;
        String cardName = selectedKeyFramePage.getName();
        CardLayout cl = (CardLayout)(cardPanel.getLayout());
        cl.show(cardPanel, cardName);
        cardLabel.setText(cardName);

        JLabel[] labels = timeSheetPanel.getLabels();
        JLabel selectedLabel;

        selectedLabel = labels[KeyFrameType.getIndex(selectedKeyFramePage) + 1];
        for (int f = 0; f < labels.length; f++)
        {
            JLabel label = labels[f];
            if (label == selectedLabel)
            {
                timeSheetPanel.getAttributeSheet().setSelectedIndex(f);
                label.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }
            else
            {
                label.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        }

        Character character = timeSheetPanel.getSelectedCharacter();
        double currentTick = timeSheetPanel.getCurrentTime();
        if (character == null)
        {
            setKeyFramedIcon(false);
            resetAttributes(null, currentTick);
            return;
        }

        KeyFrame keyFrame = character.findKeyFrame(selectedKeyFramePage, currentTick);
        setKeyFramedIcon(keyFrame != null);
        resetAttributes(character, currentTick);
    }

    public void setSelectedCharacter(Character character)
    {
        double tick = timeSheetPanel.getCurrentTime();
        updateObjectLabel(character);

        if (character == null)
        {
            setKeyFramedIcon(false);
            resetAttributes(null, tick);
            return;
        }

        KeyFrame keyFrame = character.findKeyFrame(selectedKeyFramePage, tick);
        setKeyFramedIcon(keyFrame != null);
        resetAttributes(character, tick);
    }

    public void updateObjectLabel(Character character)
    {
        if (character == null)
        {
            objectLabel.setForeground(Color.WHITE);
            objectLabel.setText(NO_OBJECT_SELECTED);
            return;
        }

        objectLabel.setForeground(ColorScheme.BRAND_ORANGE);
        StringBuilder name = new StringBuilder(character.getName());

        FontMetrics metrics = objectLabel.getFontMetrics(attributeFont);
        int maxWidth = 275;
        while (metrics.stringWidth(name.toString()) > maxWidth)
        {
            name = name.deleteCharAt(name.length() - 1);
        }

        objectLabel.setText(name.toString());
    }

    private void setupKeyListeners()
    {
        for (JComponent c : movementAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.MOVEMENT);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.MOVEMENT);
        }

        for (JComponent c : animAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.ANIMATION);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.ANIMATION);
        }

        for (JComponent c : oriAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.ORIENTATION);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.ORIENTATION);
        }

        for (JComponent c : spawnAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.SPAWN);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.SPAWN);
        }

        for (JComponent c : modelAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.MODEL);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.MODEL);
        }

        for (JComponent c : textAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.TEXT);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.TEXT);
        }

        for (JComponent c : overheadAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.OVERHEAD);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.OVERHEAD);
        }

        for (JComponent c : healthAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HEALTH);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HEALTH);
        }

        for (JComponent c : spotAnimAttributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.SPOTANIM);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.SPOTANIM);
        }

        for (JComponent c : spotAnim2Attributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.SPOTANIM2);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.SPOTANIM2);
        }

        for (JComponent c : hitsplat1Attributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HITSPLAT_1);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HITSPLAT_1);
        }


        for (JComponent c : hitsplat2Attributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HITSPLAT_2);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HITSPLAT_2);
        }


        for (JComponent c : hitsplat3Attributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HITSPLAT_3);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HITSPLAT_3);
        }


        for (JComponent c : hitsplat4Attributes.getAllComponents())
        {
            if (c instanceof JComboBox)
            {
                addHoverListeners(c, KeyFrameType.HITSPLAT_4);
                continue;
            }

            addHoverListenersWithChildren(c, KeyFrameType.HITSPLAT_4);
        }
    }

    private void addMouseFocusListener(JComponent component)
    {
        component.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e)
            {
                super.mousePressed(e);
                component.requestFocusInWindow();
            }
        });
    }

    private void addHoverListeners(Component component, KeyFrameType type)
    {
        component.addMouseListener(new MouseAdapter()
        {
            @Override
            public void mouseEntered(MouseEvent e)
            {
                super.mouseEntered(e);
                hoveredComponent = component;
                hoveredKeyFrameType = type;
            }

            @Override
            public void mouseExited(MouseEvent e)
            {
                super.mouseExited(e);
                hoveredComponent = null;
                hoveredKeyFrameType = KeyFrameType.NULL;
            }
        });
    }

    private void addHoverListenersWithChildren(JComponent component, KeyFrameType type)
    {
        ArrayList<Component> components = new ArrayList<>();
        getAllComponentChildren(components, component);
        for (Component c : components)
        {
            addHoverListeners(c, type);
        }
    }

    private void getAllComponentChildren(ArrayList<Component> components, JComponent component)
    {
        for (Component c : component.getComponents())
        {
            components.add(c);
            getAllComponentChildren(components, (JComponent) c);
        }
    }

    public void resetAttributes(Character character, double tick)
    {
        if (character == null)
        {
            setAttributesEmpty(true);
            return;
        }

        setKeyFramedIcon(character.findKeyFrame(selectedKeyFramePage, tick) != null);
        KeyFrame keyFrame = character.findPreviousKeyFrame(selectedKeyFramePage, tick, true);

        if (keyFrame == null)
        {
            keyFrame = character.findNextKeyFrame(selectedKeyFramePage, tick);

            if (keyFrame == null)
            {
                setAttributesEmpty(true);
                return;
            }
        }

        KeyFrameState keyFrameState = tick == keyFrame.getTick() ? KeyFrameState.ON_KEYFRAME : KeyFrameState.OFF_KEYFRAME;

        switch (selectedKeyFramePage)
        {
            default:
            case MOVEMENT:
                movementAttributes.setAttributes(keyFrame);
                movementAttributes.setBackgroundColours(keyFrameState);
                break;
            case ANIMATION:
                animAttributes.setAttributes(keyFrame);
                animAttributes.setBackgroundColours(keyFrameState);
                break;
            case ORIENTATION:
                oriAttributes.setAttributes(keyFrame);
                oriAttributes.setBackgroundColours(keyFrameState);
                break;
            case SPAWN:
                spawnAttributes.setAttributes(keyFrame);
                spawnAttributes.setBackgroundColours(keyFrameState);
                break;
            case MODEL:
                modelAttributes.setAttributes(keyFrame);
                modelAttributes.setBackgroundColours(keyFrameState);
                break;
            case TEXT:
                textAttributes.setAttributes(keyFrame);
                textAttributes.setBackgroundColours(keyFrameState);
                break;
            case OVERHEAD:
                overheadAttributes.setAttributes(keyFrame);
                overheadAttributes.setBackgroundColours(keyFrameState);
                break;
            case HEALTH:
                healthAttributes.setAttributes(keyFrame);
                healthAttributes.setBackgroundColours(keyFrameState);
                break;
            case SPOTANIM:
                spotAnimAttributes.setAttributes(keyFrame);
                spotAnimAttributes.setBackgroundColours(keyFrameState);
                break;
            case SPOTANIM2:
                spotAnim2Attributes.setAttributes(keyFrame);
                spotAnim2Attributes.setBackgroundColours(keyFrameState);
                break;
            case HITSPLAT_1:
                hitsplat1Attributes.setAttributes(keyFrame);
                hitsplat1Attributes.setBackgroundColours(keyFrameState);
                break;
            case HITSPLAT_2:
                hitsplat2Attributes.setAttributes(keyFrame);
                hitsplat2Attributes.setBackgroundColours(keyFrameState);
                break;
            case HITSPLAT_3:
                hitsplat3Attributes.setAttributes(keyFrame);
                hitsplat3Attributes.setBackgroundColours(keyFrameState);
                break;
            case HITSPLAT_4:
                hitsplat4Attributes.setAttributes(keyFrame);
                hitsplat4Attributes.setBackgroundColours(keyFrameState);
        }
    }

    public void setAttributesEmpty(boolean resetBackground)
    {
        switch (selectedKeyFramePage)
        {
            default:
            case MOVEMENT:
                movementAttributes.resetAttributes(resetBackground);
                break;
            case ANIMATION:
                animAttributes.resetAttributes(resetBackground);
                break;
            case ORIENTATION:
                oriAttributes.resetAttributes(resetBackground);
                break;
            case SPAWN:
                spawnAttributes.resetAttributes(resetBackground);
                break;
            case MODEL:
                modelAttributes.resetAttributes(resetBackground);
                break;
            case TEXT:
                textAttributes.resetAttributes(resetBackground);
                break;
            case OVERHEAD:
                overheadAttributes.resetAttributes(resetBackground);
                break;
            case HEALTH:
                healthAttributes.resetAttributes(resetBackground);
                break;
            case SPOTANIM:
                spotAnimAttributes.resetAttributes(resetBackground);
                break;
            case SPOTANIM2:
                spotAnim2Attributes.resetAttributes(resetBackground);
                break;
            case HITSPLAT_1:
                hitsplat1Attributes.resetAttributes(resetBackground);
                break;
            case HITSPLAT_2:
                hitsplat2Attributes.resetAttributes(resetBackground);
                break;
            case HITSPLAT_3:
                hitsplat3Attributes.resetAttributes(resetBackground);
                break;
            case HITSPLAT_4:
                hitsplat4Attributes.resetAttributes(resetBackground);
        }
    }

    public void setKeyFramedIcon(boolean isKeyFramed)
    {
        if (isKeyFramed)
        {
            keyFramed.setIcon(keyframeImage);
            return;
        }

        keyFramed.setIcon(keyframeEmptyImage);
    }
}
package com.creatorskit.swing.timesheet;

import javax.swing.*;

public class InvisibleScrollBar extends JScrollBar
{
    @Override
    public boolean isVisible()
    {
        return true;
    }
}

package com.creatorskit.swing.timesheet.sheets;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum TimelineUnits
{
    GAMETICKS("Gameticks", 1),
    SECONDS("Seconds", 0.6)
    ;

    private final String name;
    private final double multiplier;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.swing.manager.Folder;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.util.ArrayList;

@Getter
@Setter
public class SummarySheet extends TimeSheet
{
    private ManagerTree tree;
    private CreatorsConfig config;
    private AttributePanel attributePanel;
    private JPopupMenu popupMenu;
    private Character rightClickedCharacter;
    private JLabel popupTitle;
    private JMenu[] menuItems;
    private final int FONT_SPACER = 9;

    public SummarySheet(ToolBoxFrame toolBox, CreatorsConfig config, ManagerTree tree, AttributePanel attributePanel)
    {
        super(toolBox, config, tree, attributePanel);
        this.tree = tree;
        this.attributePanel = attributePanel;

        setupPopupMenu();
    }

    private void setupPopupMenu()
    {
        popupMenu = new JPopupMenu();
        popupTitle = new JLabel("");
        popupTitle.setFont(FontManager.getRunescapeBoldFont());
        popupMenu.add(popupTitle);

        menuItems = new JMenu[]
                {
                        new JMenu(KeyFrameType.MOVEMENT.getName()),
                        new JMenu(KeyFrameType.ANIMATION.getName()),
                        new JMenu(KeyFrameType.ORIENTATION.getName())
                };

        for (int i = 0; i < menuItems.length; i++)
        {
            int finalI = i;
            JMenu menuItem = menuItems[i];
            popupMenu.add(menuItem);

            JMenuItem movement = new JMenuItem(KeyFrameType.MOVEMENT.getName());
            movement.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.MOVEMENT));
            menuItem.add(movement);

            JMenuItem animation = new JMenuItem(KeyFrameType.ANIMATION.getName());
            animation.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.ANIMATION));
            menuItem.add(animation);

            JMenuItem orientation = new JMenuItem(KeyFrameType.ORIENTATION.getName());
            orientation.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.ORIENTATION));
            menuItem.add(orientation);

            JMenuItem spawn = new JMenuItem(KeyFrameType.SPAWN.getName());
            spawn.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.SPAWN));
            menuItem.add(spawn);

            JMenuItem model = new JMenuItem(KeyFrameType.MODEL.getName());
            model.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.MODEL));
            menuItem.add(model);

            for (KeyFrameType spotanimType : KeyFrameType.SPOTANIM_TYPES)
            {
                JMenuItem spotanim = new JMenuItem(spotanimType.getName());
                spotanim.addActionListener(e -> onKeyFrameTypePressed(finalI, spotanimType));
                menuItem.add(spotanim);
            }

            JMenuItem text = new JMenuItem(KeyFrameType.TEXT.getName());
            text.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.TEXT));
            menuItem.add(text);

            JMenuItem overhead = new JMenuItem(KeyFrameType.OVERHEAD.getName());
            overhead.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.OVERHEAD));
            menuItem.add(overhead);

            JMenuItem health = new JMenuItem(KeyFrameType.HEALTH.getName());
            health.addActionListener(e -> onKeyFrameTypePressed(finalI, KeyFrameType.HEALTH));
            menuItem.add(health);

            for (KeyFrameType hitsplatType : KeyFrameType.HITSPLAT_TYPES)
            {
                JMenuItem hitsplat = new JMenuItem(hitsplatType.getName());
                hitsplat.addActionListener(e -> onKeyFrameTypePressed(finalI, hitsplatType));
                menuItem.add(hitsplat);
            }
        }
    }

    @Override
    public void drawHighlight(Graphics g)
    {
        g.setColor(Color.DARK_GRAY);
        int selectedIndex = getSelectedIndex();
        if (selectedIndex == -1)
        {
            return;
        }

        g.fillRect(0, selectedIndex * rowHeight - rowHeightOffset - getVScroll(), this.getWidth(), rowHeight);
    }

    @Override
    public void drawKeyFrames(Graphics g)
    {
        ArrayList<DefaultMutableTreeNode> nodes = new ArrayList<>();
        nodes.add(tree.getRootNode());
        tree.getAllNodes(tree.getRootNode(), nodes);
        int index = -2;

        g.setFont(FontManager.getRunescapeSmallFont());
        g.setColor(ColorScheme.BRAND_ORANGE);

        for (DefaultMutableTreeNode node : nodes)
        {
            index++;

            TreePath path = tree.getPathForRow(index);
            if (path == null)
            {
                continue;
            }

            if (node.getUserObject() instanceof Folder)
            {
                continue;
            }

            Character character = (Character) node.getUserObject();
            drawFrameIcons(g, character, index);
        }
    }

    private void drawFrameIcons(Graphics g, Character character, int index)
    {
        KeyFrameType[] types = character.getSummary();
        FontMetrics fontMetrics = g.getFontMetrics();
        int stringHeight = fontMetrics.getHeight();

        for (int i = 0; i < types.length; i++)
        {
            KeyFrameType type = types[i];
            KeyFrame[] keyFrames = character.getKeyFrames(type);
            if (keyFrames == null || keyFrames.length == 0)
            {
                continue;
            }

            String name = type.getShortHand();

            int xStringOffset = fontMetrics.stringWidth(name) / 2;
            int yStringOffset = fontMetrics.getHeight() - 1 + i * FONT_SPACER;

            drawFrameIcons(
                    g,
                    keyFrames,
                    type,
                    name,
                    index,
                    stringHeight,
                    xStringOffset,
                    yStringOffset
            );
        }
    }

    private void drawFrameIcons(Graphics g, KeyFrame[] keyFrames, KeyFrameType type, String name, int index, int stringHeight, int xStringOffset, int yStringOffset)
    {
        for (int e = 0; e < keyFrames.length; e++)
        {
            KeyFrame keyFrame = keyFrames[e];

            double zoomFactor = this.getWidth() / getZoom();
            int x = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor);
            int y = (index * rowHeight) - rowHeightOffset - getVScroll() + yStringOffset;

            switch (type)
            {
                case MOVEMENT:
                    MovementKeyFrame movementKeyFrame = (MovementKeyFrame) keyFrame;
                    int steps = (movementKeyFrame.getPath().length - 1);
                    if (steps > 0)
                    {
                        double ticks = steps / movementKeyFrame.getSpeed();
                        boolean round = true;
                        if (e + 1 < keyFrames.length)
                        {
                            KeyFrame next = keyFrames[e + 1];
                            double difference = next.getTick() - keyFrame.getTick();
                            if (difference < ticks)
                            {
                                ticks = difference;
                                round = false;
                            }
                        }

                        if (round)
                        {
                            ticks = Math.ceil(ticks);
                        }

                        int pathLength = (int) (ticks * zoomFactor);
                        g.drawLine(x + xStringOffset, y - stringHeight / 2, x + pathLength - 1, y - stringHeight / 2);
                    }
                    break;
                case ORIENTATION:
                    OrientationKeyFrame okf = (OrientationKeyFrame) keyFrame;
                    drawTail(g, e, keyFrames, okf.getDuration(), zoomFactor, okf.getTick(), x, y, xStringOffset, stringHeight);
                    break;
                case TEXT:
                    TextKeyFrame tkf = (TextKeyFrame) keyFrame;
                    drawTail(g, e, keyFrames, tkf.getDuration(), zoomFactor, tkf.getTick(), x, y, xStringOffset, stringHeight);
                    break;
                case HEALTH:
                    HealthKeyFrame hkf = (HealthKeyFrame) keyFrame;
                    drawTail(g, e, keyFrames, hkf.getDuration(), zoomFactor, hkf.getTick(), x, y, xStringOffset, stringHeight);
                    break;
                case HITSPLAT_1:
                case HITSPLAT_2:
                case HITSPLAT_3:
                case HITSPLAT_4:
                    HitsplatKeyFrame hskf = (HitsplatKeyFrame) keyFrame;
                    double duration = hskf.getDuration();
                    if (duration == -1)
                    {
                        duration = HitsplatKeyFrame.DEFAULT_DURATION;
                    }

                    drawTail(g, e, keyFrames, duration, zoomFactor, hskf.getTick(), x, y, xStringOffset, stringHeight);
                    break;
                default:
                    break;
            }


            g.drawString(
                    name,
                    x - xStringOffset,
                    y);
        }
    }

    private void drawTail(Graphics g, int e, KeyFrame[] keyFrames, double duration, double zoomFactor, double tick, int x, int y, int xStringOffset, int stringHeight)
    {
        if (e + 1 < keyFrames.length)
        {
            KeyFrame next = keyFrames[e + 1];
            double difference = next.getTick() - tick;
            if (difference < duration)
            {
                duration = difference;
            }
        }

        int pathLength = (int) (duration * zoomFactor);
        g.drawLine(x  + xStringOffset, y - stringHeight / 2, x + pathLength - 1, y - stringHeight / 2);
    }

    @Override
    public void onMouseButton1DoublePressed(Point p)
    {
        getTree().setRowSelection(p);
    }

    @Override
    public void onMouseButton3Pressed(Point p)
    {
        int x = (int) p.getX();
        int y = (int) p.getY();
        int row = tree.getClosestRowForLocation(x, y);

        TreePath path = tree.getPathForRow(row);
        if (path == null)
        {
            return;
        }

        DefaultMutableTreeNode node = (DefaultMutableTreeNode) path.getLastPathComponent();

        if (!(node.getUserObject() instanceof Character))
        {
            return;
        }

        Character character = (Character) node.getUserObject();
        showSummaryPopup(this, character, x, y);
    }

    private void onKeyFrameTypePressed(int index, KeyFrameType type)
    {
        if (rightClickedCharacter == null)
        {
            return;
        }

        KeyFrameType[] summary = rightClickedCharacter.getSummary();
        summary[index] = type;
    }

    public void showSummaryPopup(JComponent component, Character character, int x, int y)
    {
        if (character == null)
        {
            return;
        }

        rightClickedCharacter = character;
        KeyFrameType[] summary = rightClickedCharacter.getSummary();
        for (int i = 0; i < summary.length; i++)
        {
            menuItems[i].setText(summary[i].getName());
        }

        popupTitle.setText(character.getName() + " showing:");
        popupMenu.show(component, x, y);
    }
}

package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameCharacterAction;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameAction;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameCharacterActionType;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;

@Getter
@Setter
public class TimeSheet extends JPanel
{
    private ToolBoxFrame toolBox;
    private CreatorsConfig config;
    private ManagerTree managerTree;
    private AttributePanel attributePanel;

    private final BufferedImage keyframeImage = ImageUtil.loadImageResource(getClass(), "/Keyframe.png");
    private final BufferedImage keyframeSelected = ImageUtil.loadImageResource(getClass(), "/Keyframe_Selected.png");

    private double zoom = 50;
    private double hScroll = 0;
    private int vScroll = 0;
    private int selectedIndex = 0;

    private double currentTime = 0;
    private double previewTime = 0;
    private boolean timeIndicatorPressed = false;
    private boolean allowRectangleSelect = false;
    private Point mousePointOnPressed = new Point(0, 0);
    public final int DRAG_STICK_RANGE = 15;

    public int rowHeight = 28;
    public int rowHeightOffset = 0;
    public final int TEXT_HEIGHT_OFFSET = 5;
    private int indexBuffers = 1;

    private final Color background1 = new Color(40, 40, 40);
    private final Color background2 = new Color(42, 42, 42);

    public final int SHOW_5_ZOOM = 200;
    public final int SHOW_1_ZOOM = 50;

    private KeyFrame[] visibleKeyFrames = new KeyFrame[0];
    private Character selectedCharacter;
    private boolean keyFrameClicked = false;
    private KeyFrame[] clickedKeyFrames = new KeyFrame[0];

    public TimeSheet(ToolBoxFrame toolBox, CreatorsConfig config, ManagerTree managerTree, AttributePanel attributePanel)
    {
        this.toolBox = toolBox;
        this.config = config;
        this.managerTree = managerTree;
        this.attributePanel = attributePanel;

        setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setLayout(new BorderLayout());
        setFocusable(true);
        requestFocusInWindow();

        setKeyBindings();
        setMouseListeners(this);

        revalidate();
        repaint();
    }

    public void onVerticalScrollEvent(int scroll)
    {
        vScroll = scroll;
    }

    public void paintComponent(Graphics g)
    {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setStroke(new BasicStroke(1));
        drawBackground(g2);
        drawBackgroundText(g2);
        drawHighlight(g2);
        drawBackgroundLines(g2);
        drawRectangleSelect(g2);
        drawKeyFrames(g2);
        drawPreviewKeyFrames(g2);
        drawTextHeader(g2);
        drawTimeIndicator(g2);
        drawPreviewTimeIndicator(g2);
        revalidate();
        repaint();
    }

    private void drawRectangleSelect(Graphics2D g)
    {
        if (!allowRectangleSelect)
        {
            return;
        }

        Point absoluteMouse = MouseInfo.getPointerInfo().getLocation();

        int x1 = (int) mousePointOnPressed.getX();
        int x2 = (int) (absoluteMouse.getX() - getLocationOnScreen().getX());
        int y1 = (int) mousePointOnPressed.getY();
        int y2 = (int) (absoluteMouse.getY() - getLocationOnScreen().getY());

        if (Math.abs(x1 - x2) < 10 && Math.abs(y1 - y2) < 10)
        {
            return;
        }

        int startX;
        int startY;
        int endX;
        int endY;

        if (x1 < x2)
        {
            startX = x1;
            endX = x2;
        }
        else
        {
            startX = x2;
            endX = x1;
        }

        if (y1 < y2)
        {
            startY = y1;
            endY = y2;
        }
        else
        {
            startY = y2;
            endY = y1;
        }

        int buffer = 1;

        if (startX < buffer)
        {
            startX = buffer;
        }

        if (endX > getWidth() - 2)
        {
            endX = getWidth() - 2;
        }

        if (startY < buffer)
        {
            startY = buffer;
        }

        if (endY > getHeight() - 2)
        {
            endY = getHeight() - 2;
        }

        g.setColor(new Color(93, 93, 93));
        Composite composite = g.getComposite();
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2F));
        g.fillRect(startX, startY, endX - startX, endY - startY);

        g.setColor(new Color(255, 255, 255));
        g.drawRect(startX, startY, endX - startX, endY - startY);
        g.setComposite(composite);
    }

    private void drawBackground(Graphics g)
    {
        g.setColor(Color.DARK_GRAY);
        int iterations = (this.getHeight() + getVScroll() / rowHeight) + 1;
        boolean alternate = false;
        for (int i = 0; i < iterations; i++)
        {
            if (alternate)
            {
                g.setColor(background2);
            }
            else
            {
                g.setColor(background1);
            }

            g.fillRect(0, i * rowHeight + rowHeightOffset - getVScroll(), this.getWidth(), rowHeight);
            alternate = !alternate;
        }
    }

    public void drawBackgroundText(Graphics g)
    {

    }

    public void drawHighlight(Graphics g)
    {

    }

    private void drawBackgroundLines(Graphics g)
    {
        double modeMultiplier = config.timelineUnits().getMultiplier();

        if (zoom <= SHOW_1_ZOOM)
        {
            g.setColor(ColorScheme.DARKER_GRAY_COLOR);

            double spacing = this.getWidth() / zoom / modeMultiplier;
            double startOffset = hScroll * modeMultiplier;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < zoom / modeMultiplier + firstIteration; i++)
            {
                g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());
            }
        }

        if (zoom <= SHOW_5_ZOOM)
        {
            g.setColor(ColorScheme.DARKER_GRAY_COLOR.darker());

            double iterations = zoom / 5 * modeMultiplier;
            double spacing = this.getWidth() / iterations;
            double startOffset = hScroll * modeMultiplier / 5;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < iterations + firstIteration; i++)
            {
                g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());
            }
        }

        g.setColor(ColorScheme.BORDER_COLOR.darker());

        double iterations = zoom / 5 * modeMultiplier;
        double spacing = this.getWidth() / iterations;
        double startOffset = hScroll * modeMultiplier / 5;
        int firstIteration = (int) Math.ceil(-1 * startOffset);
        boolean skip5Line = firstIteration % 2 != 0;

        for (int i = firstIteration; i < iterations + firstIteration; i++)
        {
            if (skip5Line)
            {
                skip5Line = false;
                continue;
            }

            g.drawLine((int) (i * spacing + startOffset * spacing), 0, (int) (i * spacing + startOffset * spacing), this.getHeight());
            skip5Line = true;
        }
    }

    private void drawTimeIndicator(Graphics g)
    {
        TimelineUnits timelineUnits = config.timelineUnits();
        double modeMultiplier = timelineUnits.getMultiplier();

        double x = (currentTime + hScroll) * this.getWidth() / zoom;
        char[] c = ("" + round(timelineUnits, currentTime * modeMultiplier)).toCharArray();
        double width = g.getFontMetrics().charsWidth(c, 0, c.length);
        int textBuffer = 16;

        g.setColor(new Color(74, 121, 192));
        g.drawLine((int) x, 0, (int) x, this.getHeight());

        g.fillRoundRect((int) (x - (width + textBuffer) / 2), 0, (int) width + textBuffer, rowHeight, 10, 10);

        g.setColor(Color.WHITE);
        g.drawChars(c, 0, c.length, (int) (x - width / 2), rowHeight - TEXT_HEIGHT_OFFSET);

    }

    private void drawPreviewTimeIndicator(Graphics g)
    {
        if (!timeIndicatorPressed)
        {
            return;
        }

        TimelineUnits timelineUnits = config.timelineUnits();
        double modeMultiplier = timelineUnits.getMultiplier();

        double x = (previewTime + hScroll)  * this.getWidth() / zoom;
        char[] c = ("" + round(timelineUnits, previewTime * modeMultiplier)).toCharArray();
        double width = g.getFontMetrics().charsWidth(c, 0, c.length);
        int textBuffer = 16;

        g.setColor(new Color(49, 84, 128));
        g.drawLine((int) x, 0, (int) x, this.getHeight());

        g.fillRoundRect((int) (x - (width + textBuffer) / 2), 0, (int) width + textBuffer, rowHeight, 10, 10);

        g.setColor(Color.WHITE);
        g.drawChars(c, 0, c.length, (int) (x - width / 2), rowHeight - TEXT_HEIGHT_OFFSET);

    }

    private void drawTextHeader(Graphics g)
    {
        double modeMultiplier = config.timelineUnits().getMultiplier();

        g.setColor(Color.WHITE);

        if (zoom <= SHOW_1_ZOOM)
        {
            g.setColor(Color.WHITE.darker().darker());
            g.setFont(FontManager.getRunescapeSmallFont());
            FontMetrics fontMetrics = g.getFontMetrics();

            double spacing = this.getWidth() / zoom / modeMultiplier;
            double startOffset = hScroll * modeMultiplier;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < zoom / modeMultiplier + firstIteration; i++)
            {
                if (i % 5 == 0)
                {
                    continue;
                }

                char[] c = ("" + i).toCharArray();
                int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
                g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), rowHeight - TEXT_HEIGHT_OFFSET);
            }
        }

        if (zoom <= SHOW_5_ZOOM)
        {
            g.setColor(Color.WHITE.darker());
            g.setFont(FontManager.getRunescapeSmallFont());
            FontMetrics fontMetrics = g.getFontMetrics();

            double iterations = zoom / 5 * modeMultiplier;
            double spacing = this.getWidth() / iterations;
            double startOffset = hScroll * modeMultiplier / 5;
            int firstIteration = (int) Math.ceil(-1 * startOffset);

            for (int i = firstIteration; i < iterations + firstIteration; i++)
            {
                int draw = i * 5;
                if (draw % 10 == 0)
                {
                    continue;
                }

                char[] c = ("" + draw).toCharArray();
                int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
                g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), rowHeight - TEXT_HEIGHT_OFFSET);
            }
        }

        g.setColor(Color.WHITE);
        g.setFont(FontManager.getRunescapeFont());
        FontMetrics fontMetrics = g.getFontMetrics();

        double iterations = zoom / 10 * modeMultiplier;
        double spacing = this.getWidth() / iterations;
        double startOffset = hScroll * modeMultiplier / 10;
        int firstIteration = (int) Math.ceil(-1 * startOffset);

        for (int i = firstIteration; i < iterations + firstIteration; i++)
        {
            char[] c = ("" + i * 10).toCharArray();
            int width = fontMetrics.charsWidth(c, 0, c.length) / 2;
            g.drawChars(c, 0, c.length, (int) (i * spacing - width + startOffset * spacing), rowHeight - TEXT_HEIGHT_OFFSET);
        }
    }

    public void drawKeyFrames(Graphics g)
    {

    }

    public void drawPreviewKeyFrames(Graphics2D g)
    {

    }

    private void setKeyBindings()
    {
        ActionMap actionMap = getActionMap();
        InputMap inputMap = getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), "VK_LEFT");
        actionMap.put("VK_LEFT", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {

                getTimeSheetPanel().setCurrentTime(TimeSheetPanel.round(currentTime - 0.1), false);
            }
        });

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), "VK_RIGHT");
        actionMap.put("VK_RIGHT", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                getTimeSheetPanel().setCurrentTime(TimeSheetPanel.round(currentTime + 0.1), false);
            }
        });
    }

    public void updateSelectedKeyFrameOnPressed(boolean shiftDown)
    {

    }

    private void setMouseListeners(TimeSheet timeSheet)
    {
        addMouseListener(new MouseAdapter()
        {
            @Override
            public void mousePressed(MouseEvent e)
            {
                super.mousePressed(e);
                requestFocusInWindow();

                if (e.getButton() != MouseEvent.BUTTON1)
                {
                    return;
                }

                Point mousePosition = getMousePosition();
                if (mousePosition == null)
                {
                    return;
                }

                if (mousePosition.getY() < rowHeight)
                {
                    timeIndicatorPressed = true;
                    updatePreviewTime(getTimeIndicatorPosition());
                    return;
                }
                else
                {
                    allowRectangleSelect = true;
                    mousePointOnPressed = mousePosition;
                }

                clickedKeyFrames = getKeyFrameClicked(mousePosition);
                keyFrameClicked = clickedKeyFrames != null;
                if (keyFrameClicked)
                {
                    allowRectangleSelect = false;
                    updateSelectedKeyFrameOnPressed(e.isShiftDown());
                }
            }

            @Override
            public void mouseReleased(MouseEvent e)
            {
                super.mouseClicked(e);
                requestFocusInWindow();

                Point mousePosition = e.getPoint();

                if (e.getButton() == MouseEvent.BUTTON3)
                {
                    onMouseButton3Pressed(mousePosition);
                    return;
                }

                if (e.getButton() != MouseEvent.BUTTON1)
                {
                    return;
                }

                TimeSheetPanel timeSheetPanel = getTimeSheetPanel();

                if (timeIndicatorPressed)
                {
                    double time = getTimeIndicatorPosition();
                    setCurrentTime(time, false);
                    timeIndicatorPressed = false;
                    return;
                }

                if (e.getClickCount() == 2)
                {
                    onMouseButton1DoublePressed(mousePosition);
                }

                if (keyFrameClicked)
                {
                    if (mousePosition.distance(mousePointOnPressed) < 1)
                    {
                        updateSelectedKeyFrameOnRelease(mousePosition, e.isShiftDown());
                    }
                    else
                    {
                        TimelineUnits timelineUnits = config.timelineUnits();
                        double modeMultiplier = timelineUnits.getMultiplier();

                        KeyFrame[] keyFrames = getSelectedKeyFrames();
                        KeyFrameAction[] kfa = new KeyFrameAction[0];

                        for (KeyFrame keyFrame : keyFrames)
                        {
                            timeSheetPanel.removeKeyFrame(selectedCharacter, keyFrame);
                            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
                        }

                        double mouseX = Math.max(0, Math.min(mousePosition.getX(), getWidth()));
                        double xCurrentTime = currentTimeToMouseX();

                        double change;
                        if (Math.abs(Math.abs(mouseX) - Math.abs(xCurrentTime)) > DRAG_STICK_RANGE)
                        {
                            change = round(timelineUnits, (mouseX - getMousePointOnPressed().getX()) * getZoom() / getWidth());
                        }
                        else
                        {
                            KeyFrame[] clickedFrames = getClickedKeyFrames();
                            change = 0;

                            if (clickedFrames.length > 0)
                            {
                                KeyFrame keyFrame = clickedFrames[0];
                                change = round(timelineUnits, getCurrentTime() - keyFrame.getTick());
                            }
                        }

                        KeyFrame[] copies = new KeyFrame[keyFrames.length];
                        for (int i = 0; i < keyFrames.length; i++)
                        {
                            KeyFrame keyFrame = keyFrames[i];
                            KeyFrame copy = KeyFrame.createCopy(keyFrame, round(timelineUnits, keyFrame.getTick() + change));
                            copies[i] = copy;
                            KeyFrame keyFrameToReplace = timeSheetPanel.addKeyFrame(selectedCharacter, copy);
                            if (keyFrameToReplace != null)
                            {
                                kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
                            }

                            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(copy, selectedCharacter, KeyFrameCharacterActionType.ADD));
                        }

                        setSelectedKeyFrames(copies);
                        timeSheetPanel.addKeyFrameActions(kfa);
                    }

                    keyFrameClicked = false;
                    allowRectangleSelect = false;
                }
                else
                {
                    setSelectedKeyFrames(new KeyFrame[0]);
                }

                if (allowRectangleSelect)
                {
                    checkRectangleForKeyFrames(mousePosition, e.isShiftDown());
                    allowRectangleSelect = false;
                }
            }
        });

        addMouseMotionListener(new MouseAdapter()
        {
            @Override
            public void mouseDragged(MouseEvent e)
            {
                super.mouseDragged(e);
                requestFocusInWindow();
                updatePreviewTime(getTimeIndicatorPosition());
            }
        });

        addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                super.mouseWheelMoved(e);
                int amount = e.getWheelRotation();

                if (e.isAltDown())
                {
                    if (e.isControlDown() || e.isShiftDown())
                    {
                        return;
                    }

                    getTimeSheetPanel().onZoomEvent(amount, timeSheet);
                    return;
                }

                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    int currentRow = managerTree.getMinSelectionRow();
                    if (currentRow == -1)
                    {
                        managerTree.setSelectionRow(0);
                        return;
                    }

                    TreePath path = null;
                    int direction = e.getWheelRotation();
                    if (direction > 0)
                    {
                        while (path == null)
                        {
                            currentRow++;
                            if (currentRow >= managerTree.getRowCount())
                            {
                                currentRow = 0;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (direction < 0)
                    {
                        while (path == null)
                        {
                            currentRow--;
                            if (currentRow < 0)
                            {
                                currentRow = managerTree.getRowCount() - 1;
                            }

                            path = managerTree.getPathForRow(currentRow);
                        }
                    }

                    if (path != null)
                    {
                        managerTree.setSelectionPath(path);
                    }
                    return;
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    getTimeSheetPanel().scrollAttributePanel(e.getWheelRotation());
                    return;
                }

                getTimeSheetPanel().onHorizontalScrollEvent(amount);
            }
        });
    }

    public void onMouseButton3Pressed(Point p) {};

    public void onMouseButton1DoublePressed(Point p) {};

    public KeyFrame[] getKeyFrameClicked(Point point)
    {
        return new KeyFrame[0];
    }

    public void updateSelectedKeyFrameOnRelease(Point point, boolean shiftKey)
    {

    }

    public void checkRectangleForKeyFrames(Point point, boolean shiftKey)
    {

    }

    private double getTimeIndicatorPosition()
    {
        double absoluteMouseX = MouseInfo.getPointerInfo().getLocation().getX();
        double x = absoluteMouseX - getLocationOnScreen().getX();

        TimelineUnits timelineUnits = config.timelineUnits();
        double modeMultiplier = timelineUnits.getMultiplier();

        double time = round(timelineUnits, (x / getWidth() * zoom - hScroll) * modeMultiplier);

        if (time < -hScroll * modeMultiplier)
        {
            time = -hScroll * modeMultiplier;
        }

        double max = round(timelineUnits, (zoom - hScroll) * modeMultiplier);
        if (time > max)
        {
            time = max;
        }

        return time;
    }

    public double currentTimeToMouseX()
    {
        return (currentTime + hScroll) * getWidth() / zoom;
    }

    public TimeSheetPanel getTimeSheetPanel()
    {
        return toolBox.getTimeSheetPanel();
    }


    public KeyFrame[] getSelectedKeyFrames()
    {
        return getTimeSheetPanel().getSelectedKeyFrames();
    }

    public void setSelectedKeyFrames(KeyFrame[] keyFrames)
    {
        getTimeSheetPanel().setSelectedKeyFrames(keyFrames);
        if (keyFrames != null && keyFrames.length > 0)
        {
            KeyFrameType type = keyFrames[keyFrames.length - 1].getKeyFrameType();
            attributePanel.switchCards(type);
        }
    }

    private void updatePreviewTime(double time)
    {
        if (config.timelineUnits() == TimelineUnits.GAMETICKS)
        {
            getTimeSheetPanel().updatePreviewTime(time);
            return;
        }

        getTimeSheetPanel().updatePreviewTime(round_10(time / 0.6));
    }

    private void setCurrentTime(double time, boolean playing)
    {
        if (config.timelineUnits() == TimelineUnits.GAMETICKS)
        {
            getTimeSheetPanel().setCurrentTime(time, playing);
            return;
        }

        getTimeSheetPanel().setCurrentTime(round_10(time / 0.6), playing);
    }

    /**
     * Rounds the given value to the nearest 1/100th
     * @param value the value to round
     * @return the value, rounded to 1 decimal place
     */
    public static double round(TimelineUnits timelineUnits, double value)
    {
        if (timelineUnits == TimelineUnits.GAMETICKS)
        {
            return round_10(value);
        }

        return round_100(roundToGametick(value));
    }

    public static double roundToGametick(double value)
    {
        double gameTicks = round_10(value / 0.6);
        return gameTicks * 0.6;
    }

    /**
     * Rounds the given value to the nearest 1/100th
     * @param value the value to round
     * @return the value, rounded to 1 decimal place
     */
    public static double round_10(double value)
    {
        int scale = (int) Math.pow(10, 1);
        return (double) Math.round(value * scale) / scale;
    }

    /**
     * Rounds the given value to the nearest 1/100th
     * @param value the value to round
     * @return the value, rounded to 2 decimal places
     */
    public static double round_100(double value)
    {
        int scale = (int) Math.pow(100, 1);
        return (double) Math.round(value * scale) / scale;
    }
}

package com.creatorskit.swing.timesheet.sheets;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.AttributePanel;
import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.Getter;
import lombok.Setter;
import net.runelite.client.ui.FontManager;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.util.Arrays;

@Getter
@Setter
public class AttributeSheet extends TimeSheet
{
    private ManagerTree tree;
    private CreatorsConfig config;
    private AttributePanel attributePanel;

    public AttributeSheet(ToolBoxFrame toolBox, CreatorsConfig config, ManagerTree tree, AttributePanel attributePanel)
    {
        super(toolBox, config, tree, attributePanel);
        this.config = config;
        this.tree = tree;
        this.attributePanel = attributePanel;

        setIndexBuffers(0);
        setSelectedIndex(1);
        this.rowHeightOffset = 1;
        this.rowHeight = 24;
    }

    @Override
    public void drawBackgroundText(Graphics g)
    {
        Character character = getSelectedCharacter();
        if (character == null)
        {
            return;
        }

        String name = character.getName();

        g.setFont(new Font(FontManager.getRunescapeBoldFont().getName(), Font.PLAIN, 64));
        g.setColor(new Color(77, 77, 77, 50));
        FontMetrics fm = g.getFontMetrics();

        g.drawString(name, this.getWidth() / 2 - fm.stringWidth(name) / 2, this.getHeight() / 2 + fm.getHeight() / 2);
    }

    @Override
    public void drawHighlight(Graphics g)
    {
        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, (getSelectedIndex() + getIndexBuffers()) * rowHeight + rowHeightOffset - getVScroll(), this.getWidth(), rowHeight);
    }

    @Override
    public void drawKeyFrames(Graphics g)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        g.setColor(new Color(219, 137, 0));

        BufferedImage image = getKeyframeImage();
        int imageHeight = image.getHeight();
        int yImageOffset = (imageHeight - rowHeight) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrameType type = KeyFrameType.getKeyFrameType(i);

            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];

                BufferedImage endImage = image;
                KeyFrame[] selectedKeyframes = getTimeSheetPanel().getSelectedKeyFrames();
                if (Arrays.stream(selectedKeyframes).anyMatch(s -> s == keyFrame))
                {
                    endImage = getKeyframeSelected();
                }

                int x = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor);
                int y = rowHeightOffset + rowHeight + rowHeight * i - getVScroll() - yImageOffset;

                switch (type)
                {
                    case MOVEMENT:
                        MovementKeyFrame movementKeyFrame = (MovementKeyFrame) keyFrame;
                        int steps = (movementKeyFrame.getPath().length - 1);
                        if (steps > 0)
                        {
                            double ticks = steps / movementKeyFrame.getSpeed();
                            boolean round = true;
                            if (e + 1 < keyFrames.length)
                            {
                                KeyFrame next = keyFrames[e + 1];
                                double difference = next.getTick() - keyFrame.getTick();
                                if (difference < ticks)
                                {
                                    ticks = difference;
                                    round = false;
                                }
                            }

                            if (round)
                            {
                                ticks = Math.ceil(ticks);
                            }

                            int pathLength = (int) (ticks * zoomFactor);
                            g.drawLine(x, y + image.getHeight() / 2, x + pathLength - 1, y + image.getHeight() / 2);
                        }
                        break;
                    case ORIENTATION:
                        OrientationKeyFrame okf = (OrientationKeyFrame) keyFrame;
                        drawTail(g, e, keyFrames, okf.getDuration(), zoomFactor, okf.getTick(), x, y, imageHeight);
                        break;
                    case TEXT:
                        TextKeyFrame tkf = (TextKeyFrame) keyFrame;
                        drawTail(g, e, keyFrames, tkf.getDuration(), zoomFactor, tkf.getTick(), x, y, imageHeight);
                        break;
                    case HEALTH:
                        HealthKeyFrame hkf = (HealthKeyFrame) keyFrame;
                        drawTail(g, e, keyFrames, hkf.getDuration(), zoomFactor, hkf.getTick(), x, y, imageHeight);
                        break;
                    case HITSPLAT_1:
                    case HITSPLAT_2:
                    case HITSPLAT_3:
                    case HITSPLAT_4:
                        HitsplatKeyFrame hskf = (HitsplatKeyFrame) keyFrame;
                        double duration = hskf.getDuration();
                        if (duration == -1)
                        {
                            duration = HitsplatKeyFrame.DEFAULT_DURATION;
                        }

                        drawTail(g, e, keyFrames, duration, zoomFactor, hskf.getTick(), x, y, imageHeight);
                        break;
                    default:
                        break;
                }


                g.drawImage(endImage, x - xImageOffset, y, null);
            }
        }
    }

    private void drawTail(Graphics g, int e, KeyFrame[] keyFrames, double duration, double zoomFactor, double tick, int x, int y, int imageHeight)
    {
        if (e + 1 < keyFrames.length)
        {
            KeyFrame next = keyFrames[e + 1];
            double difference = next.getTick() - tick;
            if (difference < duration)
            {
                duration = difference;
            }
        }

        int pathLength = (int) (duration * zoomFactor);
        g.drawLine(x, y + imageHeight / 2, x + pathLength - 1, y + imageHeight / 2);
    }

    @Override
    public void drawPreviewKeyFrames(Graphics2D g)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        if (!isKeyFrameClicked())
        {
            return;
        }

        KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
        if (selectedKeyFrames.length == 0)
        {
            return;
        }

        TimelineUnits timelineUnits = config.timelineUnits();
        double modeMultiplier = timelineUnits.getMultiplier();

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - rowHeight) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        BufferedImage bufferedImage = getKeyframeImage();
        Composite composite = g.getComposite();
        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.2F));

        double pointerX = MouseInfo.getPointerInfo().getLocation().getX() - getLocationOnScreen().getX();
        double mouseX = Math.max(0, Math.min(pointerX, getWidth()));

        double xCurrentTime = currentTimeToMouseX();

        double change;
        if (Math.abs(Math.abs(mouseX) - Math.abs(xCurrentTime)) > DRAG_STICK_RANGE)
        {
            change = round(timelineUnits, (mouseX - getMousePointOnPressed().getX()) * getZoom() / getWidth());
        }
        else
        {
            KeyFrame keyFrame = getClickedKeyFrames()[0];
            change = round(timelineUnits, getCurrentTime() - keyFrame.getTick());
        }

        int imageHeight = image.getHeight();

        for (int e = 0; e < selectedKeyFrames.length; e++)
        {
            KeyFrame keyFrame = selectedKeyFrames[e];
            int i = KeyFrameType.getIndex(keyFrame.getKeyFrameType());
            KeyFrameType type = KeyFrameType.getKeyFrameType(i);

            int x = (int) ((keyFrame.getTick() + getHScroll() + change) * zoomFactor);
            int y = rowHeightOffset + rowHeight + rowHeight * i - getVScroll() - yImageOffset;

            switch (type)
            {
                case MOVEMENT:
                    MovementKeyFrame mkf = (MovementKeyFrame) keyFrame;
                    int steps = (mkf.getPath().length - 1);
                    if (steps > 0)
                    {
                        double ticks = Math.ceil(steps / mkf.getSpeed());
                        int pathLength = (int) (ticks * zoomFactor);
                        g.drawLine(x, y + imageHeight / 2, x + pathLength - 1, y + imageHeight / 2);
                    }
                    break;
                case ORIENTATION:
                    OrientationKeyFrame okf = (OrientationKeyFrame) keyFrame;
                    drawPreviewTail(g, x, y, imageHeight, okf.getDuration(), zoomFactor);
                    break;
                case TEXT:
                    TextKeyFrame tkf = (TextKeyFrame) keyFrame;
                    drawPreviewTail(g, x, y, imageHeight, tkf.getDuration(), zoomFactor);
                    break;
                case HEALTH:
                    HealthKeyFrame hkf = (HealthKeyFrame) keyFrame;
                    drawPreviewTail(g, x, y, imageHeight, hkf.getDuration(), zoomFactor);
                    break;
                case HITSPLAT_1:
                case HITSPLAT_2:
                case HITSPLAT_3:
                case HITSPLAT_4:
                    HitsplatKeyFrame hskf = (HitsplatKeyFrame) keyFrame;
                    double duration = hskf.getDuration();
                    if (duration == -1)
                    {
                        duration = HitsplatKeyFrame.DEFAULT_DURATION;
                    }

                    drawPreviewTail(g, x, y, imageHeight, duration, zoomFactor);
                    break;
                default:
                    break;
            }

            g.drawImage(bufferedImage, x - xImageOffset, y, null);
        }

        g.setComposite(composite);
    }

    private void drawPreviewTail(Graphics g, int x, int y, int imageHeight, double duration, double zoomFactor)
    {
        int pathLength = (int) (duration * zoomFactor);
        g.drawLine(x, y + imageHeight / 2, x + pathLength - 1, y + imageHeight / 2);
    }

    @Override
    public void updateSelectedKeyFrameOnPressed(boolean shiftDown)
    {
        KeyFrame[] clickedKeyFrames = getClickedKeyFrames();
        if (clickedKeyFrames.length == 0)
        {
            return;
        }

        KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
        KeyFrame clickedKeyFrame = clickedKeyFrames[0];
        if (Arrays.stream(selectedKeyFrames).noneMatch(n -> n == clickedKeyFrame))
        {
            if (shiftDown)
            {
                setSelectedKeyFrames(ArrayUtils.add(selectedKeyFrames, clickedKeyFrame));
            }
            else
            {
                setSelectedKeyFrames(new KeyFrame[]{clickedKeyFrame});
            }
        }
    }

    @Override
    public KeyFrame[] getKeyFrameClicked(Point point)
    {
        if (getSelectedCharacter() == null)
        {
            return null;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - rowHeight) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = rowHeightOffset + rowHeight + rowHeight * i - getVScroll() - yImageOffset;
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        return new KeyFrame[]{keyFrame};
                    }
                }
            }
        }

        return null;
    }

    @Override
    public void updateSelectedKeyFrameOnRelease(Point point, boolean shiftKey)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - rowHeight) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        boolean foundFrame = false;
        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                int x1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int x2 = x1 + image.getWidth();
                int y1 = rowHeightOffset + rowHeight + rowHeight * i - getVScroll() - yImageOffset;
                int y2 = y1 + image.getHeight();

                if (point.getX() >= x1 && point.getX() <= x2)
                {
                    if (point.getY() >= y1 && point.getY() <= y2)
                    {
                        if (shiftKey)
                        {
                            KeyFrame[] selectedKeyFrames = getSelectedKeyFrames();
                            boolean alreadyContains = false;

                            for (KeyFrame kf : selectedKeyFrames)
                            {
                                if (kf == keyFrame)
                                {
                                    alreadyContains = true;
                                    break;
                                }
                            }

                            if (!alreadyContains)
                            {
                                setSelectedKeyFrames(ArrayUtils.add(getSelectedKeyFrames(), keyFrame));
                            }
                        }
                        else
                        {
                            setSelectedKeyFrames(new KeyFrame[]{keyFrame});
                        }

                        foundFrame = true;
                        break;
                    }
                }
            }

            if (foundFrame)
            {
                break;
            }
        }

        if (!foundFrame && !shiftKey)
        {
            setSelectedKeyFrames(new KeyFrame[0]);
        }
    }

    @Override
    public void checkRectangleForKeyFrames(Point point, boolean shiftKey)
    {
        if (getSelectedCharacter() == null)
        {
            return;
        }

        if (!isAllowRectangleSelect())
        {
            return;
        }

        Point absoluteMouse = MouseInfo.getPointerInfo().getLocation();
        Point rectangleSelectStart = getMousePointOnPressed();

        int x1 = (int) rectangleSelectStart.getX();
        int x2 = (int) (absoluteMouse.getX() - getLocationOnScreen().getX());
        int y1 = (int) rectangleSelectStart.getY();
        int y2 = (int) (absoluteMouse.getY() - getLocationOnScreen().getY());

        if (Math.abs(x1 - x2) < 10 && Math.abs(y1 - y2) < 10)
        {
            return;
        }

        int startX;
        int startY;
        int endX;
        int endY;

        if (x1 < x2)
        {
            startX = x1;
            endX = x2;
        }
        else
        {
            startX = x2;
            endX = x1;
        }

        if (y1 < y2)
        {
            startY = y1;
            endY = y2;
        }
        else
        {
            startY = y2;
            endY = y1;
        }

        int buffer = 1;

        if (startX < buffer)
        {
            startX = buffer;
        }

        if (endX > getWidth() - 2)
        {
            endX = getWidth() - 2;
        }

        if (startY < buffer)
        {
            startY = buffer;
        }

        if (endY > getHeight() - 2)
        {
            endY = getHeight() - 2;
        }

        Rectangle2D rectangle = new Rectangle(startX, startY, endX - startX, endY - startY);

        BufferedImage image = getKeyframeImage();
        int yImageOffset = (image.getHeight() - rowHeight) / 2;
        int xImageOffset = image.getWidth() / 2;
        double zoomFactor = this.getWidth() / getZoom();

        KeyFrame[] foundKeyFrames = new KeyFrame[0];
        if (shiftKey)
        {
            foundKeyFrames = getSelectedKeyFrames();
        }

        KeyFrame[][] frames = getSelectedCharacter().getFrames();
        for (int i = 0; i < frames.length; i++)
        {
            KeyFrame[] keyFrames = frames[i];
            if (keyFrames == null)
            {
                continue;
            }

            for (int e = 0; e < keyFrames.length; e++)
            {
                KeyFrame keyFrame = keyFrames[e];
                boolean alreadyContains = false;

                for (KeyFrame kf : foundKeyFrames)
                {
                    if (keyFrame == kf)
                    {
                        alreadyContains = true;
                        break;
                    }
                }

                if (alreadyContains)
                {
                    continue;
                }

                int kx1 = (int) ((keyFrame.getTick() + getHScroll()) * zoomFactor - xImageOffset);
                int ky1 = rowHeightOffset + rowHeight + rowHeight * i - getVScroll() - yImageOffset;

                Rectangle2D frameRect = new Rectangle(kx1, ky1, image.getWidth(), image.getHeight());

                if (rectangle.intersects(frameRect))
                {
                    foundKeyFrames = ArrayUtils.add(foundKeyFrames, keyFrame);
                }
            }
        }

        setSelectedKeyFrames(foundKeyFrames);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.HealthKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.settings.HealthbarSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class HealthAttributes extends Attributes
{
    private final JSpinner duration = new JSpinner();
    private final JComboBox<HealthbarSprite> healthbarSprite = new JComboBox<>();
    private final JSpinner maxHealth = new JSpinner();
    private final JSpinner currentHealth = new JSpinner();

    public HealthAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        HealthKeyFrame kf = (HealthKeyFrame) keyFrame;
        duration.setValue(kf.getDuration());
        healthbarSprite.setSelectedItem(kf.getHealthbarSprite());
        maxHealth.setValue(kf.getMaxHealth());
        currentHealth.setValue(kf.getCurrentHealth());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        duration.setBackground(color);
        healthbarSprite.setBackground(color);
        maxHealth.setBackground(color);
        currentHealth.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        duration,
                        healthbarSprite,
                        maxHealth,
                        currentHealth
                };
    }

    @Override
    public void addChangeListeners()
    {
        duration.addChangeListener(e ->
        {
            duration.setBackground(getRed());
        });

        healthbarSprite.addItemListener(e ->
        {
            healthbarSprite.setBackground(getRed());
        });

        maxHealth.addChangeListener(e ->
        {
            maxHealth.setBackground(getRed());
        });

        currentHealth.addChangeListener(e ->
        {
            currentHealth.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        duration.setValue(5.0);
        healthbarSprite.setSelectedItem(HealthbarSprite.DEFAULT);
        maxHealth.setValue(99);
        currentHealth.setValue(99);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.OverheadKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.OverheadSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class OverheadAttributes extends Attributes
{
    private final JComboBox<OverheadSprite> skullSprite = new JComboBox<>();
    private final JComboBox<OverheadSprite> prayerSprite = new JComboBox<>();

    public OverheadAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        OverheadKeyFrame kf = (OverheadKeyFrame) keyFrame;
        skullSprite.setSelectedItem(kf.getSkullSprite());
        prayerSprite.setSelectedItem(kf.getPrayerSprite());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        skullSprite.setBackground(color);
        prayerSprite.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        skullSprite,
                        prayerSprite
                };
    }

    @Override
    public void addChangeListeners()
    {
        skullSprite.addItemListener(e ->
        {
            skullSprite.setBackground(getRed());
        });

        prayerSprite.addItemListener(e ->
        {
            prayerSprite.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        skullSprite.setSelectedItem(OverheadSprite.NONE);
        prayerSprite.setSelectedItem(OverheadSprite.NONE);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.SpawnKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class SpawnAttributes extends Attributes
{
    private final JComboBox<Toggle> spawn = new JComboBox<>();

    public SpawnAttributes()
    {
        addChangeListeners();
        spawn.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        SpawnKeyFrame kf = (SpawnKeyFrame) keyFrame;
        spawn.setSelectedItem(kf.isSpawnActive() ? Toggle.ENABLE : Toggle.DISABLE);
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        spawn.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        spawn
                };
    }

    @Override
    public void addChangeListeners()
    {
        spawn.addItemListener(e ->
        {
            spawn.setBackground(getRed().brighter());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        spawn.setSelectedItem(Toggle.ENABLE);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.programming.MovementType;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.MovementKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.OrientationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class MovementAttributes extends Attributes
{
    private final JComboBox<Toggle> loop = new JComboBox<>();
    private final JSpinner speed = new JSpinner();
    private final JSpinner turnRate = new JSpinner();

    public MovementAttributes()
    {
        addChangeListeners();
        loop.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        MovementKeyFrame kf = (MovementKeyFrame) keyFrame;
        loop.setSelectedItem(kf.isLoop() ? Toggle.ENABLE : Toggle.DISABLE);
        speed.setValue(kf.getSpeed());
        turnRate.setValue(kf.getTurnRate());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        loop.setBackground(color);
        speed.setBackground(color);
        turnRate.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        loop,
                        speed,
                        turnRate
                };
    }

    @Override
    public void addChangeListeners()
    {
        loop.addItemListener(e ->
        {
            loop.setBackground(getRed());
        });

        speed.addChangeListener(e ->
        {
            speed.setBackground(getRed());
        });

        turnRate.addChangeListener(e ->
        {
            turnRate.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        loop.setSelectedItem(Toggle.DISABLE);
        speed.setValue(1.0);
        turnRate.setValue(OrientationKeyFrame.TURN_RATE);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.OrientationKeyFrame;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class OriAttributes extends Attributes
{
    private final JSpinner start = new JSpinner();
    private final JSpinner end = new JSpinner();
    private final JSpinner duration = new JSpinner();
    private final JSpinner turnRate = new JSpinner();

    public OriAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        OrientationKeyFrame kf = (OrientationKeyFrame) keyFrame;
        start.setValue(kf.getStart());
        end.setValue(kf.getEnd());
        duration.setValue(kf.getDuration());
        turnRate.setValue(kf.getTurnRate());
    }

    public void setBackgroundColours(Color color)
    {
        start.setBackground(color);
        end.setBackground(color);
        duration.setBackground(color);
        turnRate.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        start,
                        end,
                        duration,
                        turnRate
                };
    }

    @Override
    public void addChangeListeners()
    {
        start.addChangeListener(e ->
        {
            start.setBackground(getRed());
        });

        end.addChangeListener(e ->
        {
            end.setBackground(getRed());
        });

        duration.addChangeListener(e ->
        {
            duration.setBackground(getRed());
        });

        turnRate.addChangeListener(e ->
        {
            turnRate.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        start.setValue(0);
        end.setValue(0);
        duration.setValue(1.0);
        turnRate.setValue(OrientationKeyFrame.TURN_RATE);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.models.CustomModel;
import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.ModelKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.ModelToggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class ModelAttributes extends Attributes
{
    private final JSpinner modelId = new JSpinner();
    private final JComboBox<ModelToggle> modelOverride = new JComboBox<>();
    private final JComboBox<CustomModel> customModel = new JComboBox<>();
    private final JSpinner radius = new JSpinner();

    public ModelAttributes()
    {
        addChangeListeners();
        modelOverride.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        ModelKeyFrame kf = (ModelKeyFrame) keyFrame;
        modelId.setValue(kf.getModelId());
        modelOverride.setSelectedItem(kf.isUseCustomModel() ? ModelToggle.CUSTOM_MODEL : ModelToggle.MODEL_ID);
        customModel.setSelectedItem(kf.getCustomModel());
        radius.setValue(kf.getRadius());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        modelId.setBackground(color);
        modelOverride.setBackground(color);
        customModel.setBackground(color);
        radius.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        modelId,
                        modelOverride,
                        customModel,
                        radius
                };
    }

    @Override
    public void addChangeListeners()
    {
        modelId.addChangeListener(e ->
        {
            modelId.setBackground(getRed());
        });

        modelOverride.addItemListener(e ->
        {
            modelOverride.setBackground(getRed());
        });

        customModel.addItemListener(e ->
        {
            customModel.setBackground(getRed());
        });

        radius.addChangeListener(e ->
        {
            radius.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        modelId.setValue(-1);
        modelOverride.setSelectedItem(ModelToggle.CUSTOM_MODEL);
        customModel.setSelectedItem(null);
        radius.setValue(60);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import lombok.Getter;
import net.runelite.client.ui.ColorScheme;

import javax.swing.*;
import java.awt.*;

@Getter
public class Attributes
{
    private final Color green = new Color(42, 77, 26);
    private final Color yellow = new Color(91, 80, 29);
    private final Color red = new Color(101, 66, 29);

    public void setAttributes(KeyFrame kf)
    {

    }

    public void setBackgroundColours(KeyFrameState keyFrameState)
    {
        Color color;

        switch (keyFrameState)
        {
            default:
            case EMPTY:
                color = ColorScheme.DARKER_GRAY_COLOR;
                break;
            case ON_KEYFRAME:
                color = getYellow();
                break;
            case OFF_KEYFRAME:
                color = getGreen();
        }

        setBackgroundColours(color);
    }

    public void setBackgroundColours(Color color)
    {

    }

    public JComponent[] getAllComponents()
    {
        return new JComponent[0];
    }

    public void addChangeListeners()
    {

    }

    public void resetAttributes(boolean resetBackground)
    {
        if (resetBackground)
        {
            setBackgroundColours(KeyFrameState.EMPTY);
        }
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class AnimAttributes extends Attributes
{
    private final JComboBox<Toggle> stall = new JComboBox<>();
    private final JSpinner active = new JSpinner();
    private final JSpinner startFrame = new JSpinner();
    private final JComboBox<Toggle> loop = new JComboBox<>();
    private final JComboBox<Toggle> freeze = new JComboBox<>();

    private final JSpinner idle = new JSpinner();
    private final JSpinner walk = new JSpinner();
    private final JSpinner run = new JSpinner();
    private final JSpinner walk180 = new JSpinner();
    private final JSpinner walkRight = new JSpinner();
    private final JSpinner walkLeft = new JSpinner();
    private final JSpinner idleRight = new JSpinner();
    private final JSpinner idleLeft = new JSpinner();

    public AnimAttributes()
    {
        addChangeListeners();
        active.setOpaque(true);
        loop.setOpaque(true);
        freeze.setOpaque(true);
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        if (keyFrame == null)
        {
            resetAttributes(true);
            return;
        }
        
        AnimationKeyFrame kf = (AnimationKeyFrame) keyFrame;
        stall.setSelectedItem(kf.isStall() ? Toggle.ENABLE : Toggle.DISABLE);
        active.setValue(kf.getActive());
        startFrame.setValue(kf.getStartFrame());
        loop.setSelectedItem(kf.isLoop() ? Toggle.ENABLE : Toggle.DISABLE);
        freeze.setSelectedItem(kf.isFreeze() ? Toggle.ENABLE : Toggle.DISABLE);
        idle.setValue(kf.getIdle());
        walk.setValue(kf.getWalk());
        run.setValue(kf.getRun());
        walk180.setValue(kf.getWalk180());
        walkRight.setValue(kf.getWalkRight());
        walkLeft.setValue(kf.getWalkLeft());
        idleRight.setValue(kf.getIdleRight());
        idleLeft.setValue(kf.getIdleLeft());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        stall.setBackground(color);
        active.setBackground(color);
        startFrame.setBackground(color);
        loop.setBackground(color);
        freeze.setBackground(color);
        idle.setBackground(color);
        walk.setBackground(color);
        run.setBackground(color);
        walk180.setBackground(color);
        walkRight.setBackground(color);
        walkLeft.setBackground(color);
        idleRight.setBackground(color);
        idleLeft.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        stall,
                        active,
                        startFrame,
                        loop,
                        freeze,
                        idle,
                        walk,
                        run,
                        walk180,
                        walkRight,
                        walkLeft,
                        idleRight,
                        idleLeft
                };
    }

    @Override
    public void addChangeListeners()
    {
        stall.addItemListener(e ->
        {
            stall.setBackground(getRed());
        });

        active.addChangeListener(e ->
        {
            active.setBackground(getRed());
        });

        startFrame.addChangeListener(e ->
        {
            startFrame.setBackground(getRed());
        });

        loop.addItemListener(e ->
        {
            loop.setBackground(getRed());
        });

        freeze.addItemListener(e ->
        {
            freeze.setBackground(getRed());
        });

        idle.addChangeListener(e ->
        {
            idle.setBackground(getRed());
        });

        walk.addChangeListener(e ->
        {
            walk.setBackground(getRed());
        });

        run.addChangeListener(e ->
        {
            run.setBackground(getRed());
        });

        walk180.addChangeListener(e ->
        {
            walk180.setBackground(getRed());
        });

        walkRight.addChangeListener(e ->
        {
            walkRight.setBackground(getRed());
        });

        walkLeft.addChangeListener(e ->
        {
            walkLeft.setBackground(getRed());
        });

        idleRight.addChangeListener(e ->
        {
            idleRight.setBackground(getRed());
        });

        idleLeft.addChangeListener(e ->
        {
            idleLeft.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        stall.setSelectedItem(Toggle.DISABLE);
        active.setValue(-1);
        startFrame.setValue(0);
        loop.setSelectedItem(Toggle.DISABLE);
        freeze.setSelectedItem(Toggle.DISABLE);
        idle.setValue(-1);
        walk.setValue(-1);
        run.setValue(-1);
        walk180.setValue(-1);
        walkRight.setValue(-1);
        walkLeft.setValue(-1);
        idleRight.setValue(-1);
        idleLeft.setValue(-1);
        super.resetAttributes(resetBackground);
    }
}

package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.HitsplatKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatVariant;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class HitsplatAttributes extends Attributes
{
    private final JSpinner duration = new JSpinner();
    private final JComboBox<HitsplatSprite> sprite = new JComboBox<>();
    private final JComboBox<HitsplatVariant> variant = new JComboBox<>();
    private final JSpinner damage = new JSpinner();

    public HitsplatAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        HitsplatKeyFrame kf = (HitsplatKeyFrame) keyFrame;
        duration.setValue(kf.getDuration());
        sprite.setSelectedItem(kf.getSprite());
        variant.setSelectedItem(kf.getVariant());
        damage.setValue(kf.getDamage());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        duration.setBackground(color);
        sprite.setBackground(color);
        variant.setBackground(color);
        damage.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        duration,
                        sprite,
                        variant,
                        damage
                };
    }

    @Override
    public void addChangeListeners()
    {
        duration.addChangeListener(e ->
        {
            duration.setBackground(getRed());
        });

        sprite.addItemListener(e ->
        {
            sprite.setBackground(getRed());
        });

        variant.addItemListener(e ->
        {
            variant.setBackground(getRed());
        });

        damage.addChangeListener(e ->
        {
            damage.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        duration.setValue(-1);
        sprite.setSelectedItem(HitsplatSprite.BLOCK);
        variant.setSelectedItem(HitsplatVariant.NORMAL);
        damage.setValue(0);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.TextKeyFrame;
import lombok.Getter;

import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import java.awt.*;

@Getter
public class TextAttributes extends Attributes
{
    private final JSpinner duration = new JSpinner();
    private final JTextArea text = new JTextArea("");

    public TextAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        TextKeyFrame kf = (TextKeyFrame) keyFrame;
        duration.setValue(kf.getDuration());
        text.setText(kf.getText());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        duration.setBackground(color);
        text.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        duration,
                        text
                };
    }

    @Override
    public void addChangeListeners()
    {
        duration.addChangeListener(e ->
        {
            duration.setBackground(getRed());
        });

        text.getDocument().addDocumentListener(new DocumentListener() {

            @Override
            public void removeUpdate(DocumentEvent e) {
                text.setBackground(getRed());
            }

            @Override
            public void insertUpdate(DocumentEvent e) {
                text.setBackground(getRed());
            }

            @Override
            public void changedUpdate(DocumentEvent e)
            {

            }
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        duration.setValue(5.0);
        text.setText("");
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.attributes;

import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameState;
import com.creatorskit.swing.timesheet.keyframe.SpotAnimKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.Toggle;
import lombok.Getter;

import javax.swing.*;
import java.awt.*;

@Getter
public class SpotAnimAttributes extends Attributes
{
    private final JSpinner spotAnimId = new JSpinner();
    private final JComboBox<Toggle> loop = new JComboBox<>();
    private final JSpinner height = new JSpinner();

    public SpotAnimAttributes()
    {
        addChangeListeners();
    }

    @Override
    public void setAttributes(KeyFrame keyFrame)
    {
        SpotAnimKeyFrame kf = (SpotAnimKeyFrame) keyFrame;
        spotAnimId.setValue(kf.getSpotAnimId());
        loop.setSelectedItem(kf.isLoop() ? Toggle.ENABLE : Toggle.DISABLE);
        height.setValue(kf.getHeight());
    }

    @Override
    public void setBackgroundColours(Color color)
    {
        spotAnimId.setBackground(color);
        loop.setBackground(color);
        height.setBackground(color);
    }

    @Override
    public JComponent[] getAllComponents()
    {
        return new JComponent[]
                {
                        spotAnimId,
                        loop,
                        height
                };
    }

    @Override
    public void addChangeListeners()
    {
        spotAnimId.addChangeListener(e ->
        {
            spotAnimId.setBackground(getRed());
        });

        loop.addItemListener(e ->
        {
            loop.setBackground(getRed());
        });

        height.addChangeListener(e ->
        {
            height.setBackground(getRed());
        });
    }

    @Override
    public void resetAttributes(boolean resetBackground)
    {
        spotAnimId.setValue(-1);
        loop.setSelectedItem(Toggle.DISABLE);
        height.setValue(92);
        super.resetAttributes(resetBackground);
    }
}
package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SpawnKeyFrame extends KeyFrame
{
    private boolean spawnActive;

    public SpawnKeyFrame(double tick, boolean spawnActive)
    {
        super(KeyFrameType.SPAWN, tick);
        this.spawnActive = spawnActive;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class AnimationKeyFrame extends KeyFrame
{
    private boolean stall;
    private int active;
    private int startFrame;
    private boolean loop;
    private boolean freeze;
    private int idle;
    private int walk;
    private int run;
    private int walk180;
    private int walkRight;
    private int walkLeft;
    private int idleRight;
    private int idleLeft;

    public AnimationKeyFrame(double tick, boolean stall, int active, int startFrame, boolean loop, boolean freeze, int idle, int walk, int run, int walk180, int walkRight, int walkLeft, int idleRight, int idleLeft)
    {
        super(KeyFrameType.ANIMATION, tick);
        this.stall = stall;
        this.active = active;
        this.startFrame = startFrame;
        this.loop = loop;
        this.freeze = freeze;
        this.idle = idle;
        this.walk = walk;
        this.run = run;
        this.walk180 = walk180;
        this.walkRight = walkRight;
        this.walkLeft = walkLeft;
        this.idleRight = idleRight;
        this.idleLeft = idleLeft;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class KeyFrame
{
    private KeyFrameType keyFrameType;
    private double tick;

    public static KeyFrame createCopy(KeyFrame keyFrame, double tick)
    {
        KeyFrameType type = keyFrame.getKeyFrameType();
        switch (type)
        {
            default:
            case MOVEMENT:
                MovementKeyFrame moveKF = (MovementKeyFrame) keyFrame;
                int[][] path = moveKF.getPath();
                int[][] pathCopy = new int[path.length][];
                for (int i = 0; i < path.length; i++)
                {
                    int[] coordinates = path[i];
                    pathCopy[i] = new int[]{coordinates[0], coordinates[1]};
                }

                return new MovementKeyFrame(
                        tick,
                        moveKF.getPlane(),
                        moveKF.isPoh(),
                        pathCopy,
                        moveKF.getCurrentStep(),
                        moveKF.getStepClientTick(),
                        moveKF.isLoop(),
                        moveKF.getSpeed(),
                        moveKF.getTurnRate());
            case ANIMATION:
                AnimationKeyFrame animKF = (AnimationKeyFrame) keyFrame;
                return new AnimationKeyFrame(
                        tick,
                        animKF.isStall(),
                        animKF.getActive(),
                        animKF.getStartFrame(),
                        animKF.isLoop(),
                        animKF.isFreeze(),
                        animKF.getIdle(),
                        animKF.getWalk(),
                        animKF.getRun(),
                        animKF.getWalk180(),
                        animKF.getWalkRight(),
                        animKF.getWalkLeft(),
                        animKF.getIdleRight(),
                        animKF.getIdleLeft());
            case ORIENTATION:
                OrientationKeyFrame oriKF = (OrientationKeyFrame) keyFrame;
                return new OrientationKeyFrame(
                        tick,
                        oriKF.getGoal(),
                        oriKF.getStart(),
                        oriKF.getEnd(),
                        oriKF.getDuration(),
                        oriKF.getTurnRate());
            case SPAWN:
                SpawnKeyFrame spawnKF = (SpawnKeyFrame) keyFrame;
                return new SpawnKeyFrame(
                        tick,
                        spawnKF.isSpawnActive());
            case MODEL:
                ModelKeyFrame modelKF = (ModelKeyFrame) keyFrame;
                return new ModelKeyFrame(
                        tick,
                        modelKF.isUseCustomModel(),
                        modelKF.getModelId(),
                        modelKF.getCustomModel(),
                        modelKF.getRadius());
            case TEXT:
                TextKeyFrame textKF = (TextKeyFrame) keyFrame;
                return new TextKeyFrame(
                        tick,
                        textKF.getDuration(),
                        textKF.getText());
            case OVERHEAD:
                OverheadKeyFrame overKF = (OverheadKeyFrame) keyFrame;
                return new OverheadKeyFrame(
                        tick,
                        overKF.getSkullSprite(),
                        overKF.getPrayerSprite());
            case HEALTH:
                HealthKeyFrame healthKF = (HealthKeyFrame) keyFrame;
                return new HealthKeyFrame(
                        tick,
                        healthKF.getDuration(),
                        healthKF.getHealthbarSprite(),
                        healthKF.getMaxHealth(),
                        healthKF.getCurrentHealth());
            case SPOTANIM:
            case SPOTANIM2:
                SpotAnimKeyFrame spotKF = (SpotAnimKeyFrame) keyFrame;
                return new SpotAnimKeyFrame(
                        tick,
                        type,
                        spotKF.getSpotAnimId(),
                        spotKF.isLoop(),
                        spotKF.getHeight());
            case HITSPLAT_1:
            case HITSPLAT_2:
            case HITSPLAT_3:
            case HITSPLAT_4:
                HitsplatKeyFrame hitsplatKF = (HitsplatKeyFrame) keyFrame;
                return new HitsplatKeyFrame(
                        tick,
                        type,
                        hitsplatKF.getDuration(),
                        hitsplatKF.getSprite(),
                        hitsplatKF.getVariant(),
                        hitsplatKF.getDamage());
        }
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.swing.timesheet.keyframe.settings.OverheadSprite;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class OverheadKeyFrame extends KeyFrame
{
    private OverheadSprite skullSprite;
    private OverheadSprite prayerSprite;

    public OverheadKeyFrame(double tick, OverheadSprite skullSprite, OverheadSprite prayerSprite)
    {
        super(KeyFrameType.OVERHEAD, tick);
        this.skullSprite = skullSprite;
        this.prayerSprite = prayerSprite;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatVariant;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class HitsplatKeyFrame extends KeyFrame
{
    public static final double DEFAULT_DURATION = (double) 5 / 3;

    private int duration;
    private HitsplatSprite sprite;
    private HitsplatVariant variant;
    private int damage;

    public HitsplatKeyFrame(double tick, KeyFrameType hitsplatType, int duration, HitsplatSprite sprite, HitsplatVariant variant, int damage)
    {
        super(hitsplatType, tick);
        this.duration = duration;
        this.sprite = sprite;
        this.variant = variant;
        this.damage = damage;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.programming.orientation.OrientationGoal;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class OrientationKeyFrame extends KeyFrame
{
    public static final int TURN_RATE = 32; //In JUnits/clientTick

    private OrientationGoal goal;
    private int start;
    private int end;
    private double duration;
    private int turnRate;

    public OrientationKeyFrame(double tick, OrientationGoal goal, int start, int end, double duration, int turnRate)
    {
        super(KeyFrameType.ORIENTATION, tick);
        this.goal = goal;
        this.start = start;
        this.end = end;
        this.duration = duration;
        this.turnRate = turnRate;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.programming.orientation.OrientationHotkeyMode;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import net.runelite.api.Menu;
import net.runelite.api.MenuAction;
import net.runelite.client.util.ColorUtil;

import java.awt.*;

public class SubMenuCreator
{
    private static final KeyFrameType[] types = new KeyFrameType[]
            {
                    KeyFrameType.MOVEMENT,
                    KeyFrameType.ANIMATION,
                    KeyFrameType.ORIENTATION,
                    KeyFrameType.SPAWN,
                    KeyFrameType.MODEL,
                    KeyFrameType.TEXT,
                    KeyFrameType.OVERHEAD,
                    KeyFrameType.HEALTH,
                    KeyFrameType.SPOTANIM,
                    KeyFrameType.SPOTANIM2
            };

    public static void createSubMenus(TimeSheetPanel timeSheetPanel, Menu menu)
    {
        double currentTime = timeSheetPanel.getCurrentTime();

        for (KeyFrameType type : types)
        {
            if (type == KeyFrameType.MOVEMENT)
            {
                menu.createMenuEntry(0)
                        .setOption(ColorUtil.prependColorTag("Add", Color.ORANGE))
                        .setTarget(ColorUtil.colorTag(Color.WHITE) + KeyFrameType.MOVEMENT)
                        .setType(MenuAction.RUNELITE)
                        .onClick(e -> timeSheetPanel.onAddMovementMenuOptionPressed());
                continue;
            }

            if (type == KeyFrameType.ORIENTATION)
            {
                menu.createMenuEntry(0)
                        .setOption(ColorUtil.prependColorTag("Add", Color.ORANGE))
                        .setTarget(ColorUtil.colorTag(Color.WHITE) + KeyFrameType.ORIENTATION)
                        .setType(MenuAction.RUNELITE)
                        .onClick(e -> timeSheetPanel.onAddOrientationMenuOptionPressed());
                continue;
            }

            menu.createMenuEntry(0)
                    .setOption(ColorUtil.prependColorTag("Add", Color.ORANGE))
                    .setTarget(ColorUtil.colorTag(Color.WHITE) + type)
                    .setType(MenuAction.RUNELITE)
                    .onClick(e -> timeSheetPanel.onKeyFrameIconPressedEvent(currentTime, type));
        }
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class SpotAnimKeyFrame extends KeyFrame
{
    private KeyFrameType spotAnimType;
    private int spotAnimId;
    private boolean loop;
    private int height;

    public SpotAnimKeyFrame(double tick, KeyFrameType spotAnimType, int spotAnimId, boolean loop, int height)
    {
        super(spotAnimType, tick);
        this.spotAnimId = spotAnimId;
        this.loop = loop;
        this.height = height;
    }
}

package com.creatorskit.swing.timesheet.keyframe.keyframeactions;

import com.creatorskit.Character;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import lombok.Getter;

@Getter
public class KeyFrameCharacterAction extends KeyFrameAction
{
    private final Character character;
    private final KeyFrameCharacterActionType characterActionType;

    public KeyFrameCharacterAction(KeyFrame keyFrame, Character character, KeyFrameCharacterActionType characterActionType)
    {
        super(KeyFrameActionType.CHARACTER, keyFrame);
        this.character = character;
        this.characterActionType = characterActionType;
    }
}

package com.creatorskit.swing.timesheet.keyframe.keyframeactions;

import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class KeyFrameAction
{
    private KeyFrameActionType actionType;
    private KeyFrame keyFrame;
}

package com.creatorskit.swing.timesheet.keyframe.keyframeactions;

public enum KeyFrameActionType
{
    CHARACTER,
    CAMERA,
    SOUND
}

package com.creatorskit.swing.timesheet.keyframe.keyframeactions;

public enum KeyFrameCharacterActionType
{
    ADD,
    REMOVE
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.programming.MovementType;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class MovementKeyFrame extends KeyFrame
{
    private int plane;
    private boolean poh;
    private int[][] path;
    private int currentStep;
    private int stepClientTick;
    private boolean loop;
    private double speed;
    private int turnRate;

    public MovementKeyFrame(double tick, int plane, boolean poh, int[][] path, int currentStep, int stepClientTick, boolean loop, double speed, int turnRate)
    {
        super(KeyFrameType.MOVEMENT, tick);
        this.plane = plane;
        this.poh = poh;
        this.path = path;
        this.currentStep = currentStep;
        this.stepClientTick = stepClientTick;
        this.loop = loop;
        this.speed = speed;
        this.turnRate = turnRate;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum KeyFrameType
{
    NULL("Null", "N"),
    MOVEMENT("Movement","M"),
    ANIMATION("Animation","A"),
    ORIENTATION("Orientation","O"),
    SPAWN("Spawn","S"),
    MODEL("Model","MD"),
    SPOTANIM("SpotAnim 1","S1"),
    SPOTANIM2("SpotAnim 2","S2"),
    TEXT("Text","T"),
    OVERHEAD("Overhead","OH"),
    HEALTH("Health","H"),
    HITSPLAT_1("Hitsplat 1","H1"),
    HITSPLAT_2("Hitsplat 2","H2"),
    HITSPLAT_3("Hitsplat 3","H3"),
    HITSPLAT_4("Hitsplat 4","H4");

    private final String name;
    private final String shortHand;

    public String toString()
    {
        return name;
    }

    public static final KeyFrameType[] ALL_KEYFRAME_TYPES = new KeyFrameType[]{
            MOVEMENT,
            ANIMATION,
            ORIENTATION,
            SPAWN,
            MODEL,
            SPOTANIM,
            SPOTANIM2,
            TEXT,
            OVERHEAD,
            HEALTH,
            HITSPLAT_1,
            HITSPLAT_2,
            HITSPLAT_3,
            HITSPLAT_4
    };

    public static final KeyFrameType[] HITSPLAT_TYPES = new KeyFrameType[]{KeyFrameType.HITSPLAT_1, KeyFrameType.HITSPLAT_2, KeyFrameType.HITSPLAT_3, KeyFrameType.HITSPLAT_4};
    public static final KeyFrameType[] SPOTANIM_TYPES = new KeyFrameType[]{KeyFrameType.SPOTANIM, KeyFrameType.SPOTANIM2};

    public static int getIndex(KeyFrameType type)
    {
        switch (type)
        {
            default:
            case MOVEMENT:
                return 0;
            case ANIMATION:
                return 1;
            case ORIENTATION:
                return 2;
            case SPAWN:
                return 3;
            case MODEL:
                return 4;
            case SPOTANIM:
                return 5;
            case SPOTANIM2:
                return 6;
            case TEXT:
                return 7;
            case OVERHEAD:
                return 8;
            case HEALTH:
                return 9;
            case HITSPLAT_1:
                return 10;
            case HITSPLAT_2:
                return 11;
            case HITSPLAT_3:
                return 12;
            case HITSPLAT_4:
                return 13;
        }
    }

    public static KeyFrameType getKeyFrameType(int index)
    {
        switch (index)
        {
            default:
            case 0:
                return MOVEMENT;
            case 1:
                return ANIMATION;
            case 2:
                return ORIENTATION;
            case 3:
                return SPAWN;
            case 4:
                return MODEL;
            case 5:
                return SPOTANIM;
            case 6:
                return SPOTANIM2;
            case 7:
                return TEXT;
            case 8:
                return OVERHEAD;
            case 9:
                return HEALTH;
            case 10:
                return HITSPLAT_1;
            case 11:
                return HITSPLAT_2;
            case 12:
                return HITSPLAT_3;
            case 13:
                return HITSPLAT_4;
        }
    }

    public static int getTotalFrameTypes()
    {
        return 14;
    }

    public static KeyFrameType[] createDefaultSummary()
    {
        return new KeyFrameType[]{MOVEMENT, ANIMATION, ORIENTATION};
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.SpriteID;

@Getter
@AllArgsConstructor
public enum OverheadSprite
{
    NONE("None", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 0),
    SKULL("Skull", SpriteID.PLAYER_KILLER_SKULL, 0),
    SKULL_HIGH_RISK("High Risk", 525, 0),
    SKULL_BH_1("Bounty Hunter 1", 6316, 0),
    SKULL_BH_2("Bounty Hunter 2", 6333, 0),
    SKULL_BH_3("Bounty Hunter 3", 6334, 0),
    SKULL_BH_4("Bounty Hunter 4", 6335, 0),
    SKULL_BH_5("Bounty Hunter 5", 6336, 0),
    SKULL_FORINTHRY("Forinthry", 526, 0),
    SKULL_FORINTHRY_1("Forinthry 1", 2271, 0),
    SKULL_FORINTHRY_2("Forinthry 2", 2501, 0),
    SKULL_FORINTHRY_3("Forinthry 3", 2502, 0),
    SKULL_FORINTHRY_4("Forinthry 4", 2503, 0),
    SKULL_FORINTHRY_5("Forinthry 5", 2504, 0),
    SKULL_DEADMAN_1("Deadman 1", 1097, 0),
    SKULL_DEADMAN_2("Deadman 2", 1221, 0),
    SKULL_DEADMAN_3("Deadman 3", 1222, 0),
    SKULL_DEADMAN_4("Deadman 4", 1223, 0),
    SKULL_DEADMAN_5("Deadman 5", 1224, 0),
    PROTECT_MAGIC("Protect Magic", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 2),
    PROTECT_RANGED("Protect Ranged", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 1),
    PROTECT_MELEE("Protect Melee", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 0),
    REDEMPTION("Redemption", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 5),
    RETRIBUTION("Retribution", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 3),
    SMITE("Smite", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 4),
    PROTECT_RANGE_MAGE("Protect Ranged + Mage", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 6),
    PROTECT_RANGE_MELEE("Protect Ranged + Melee", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 7),
    PROTECT_MAGE_MELEE("Protect Mage + Melee", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 8),
    PROTECT_RANGE_MAGE_MELEE("Protect All", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 9),
    DEFLECT_MAGE("Deflect Magic", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 14),
    DEFLECT_RANGE("Deflect Ranged", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 13),
    DEFLECT_MELEE("Deflect Melee", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 12),
    SOUL_SPLIT("Soul Split", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 11),
    WRATH("Wrath", SpriteID.OVERHEAD_PROTECT_FROM_MELEE, 10),
    ;

    private final String name;
    private final int spriteID;
    private final int file;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum HitsplatVariant
{
    NORMAL("Normal"),
    OTHER("Other"),
    MAX("Max")

    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.SpriteID;

@Getter
@AllArgsConstructor
public enum HitsplatSprite
{
    ARMOUR("Armour", 1628, 0),
    ARMOUR_MAX("Armour Max", 4557, 0),
    BURN("Burn", 4767, 0),
    BLEED("Bleed", 4564, 0),
    BLOCK("Block", SpriteID.HITSPLAT_BLUE_MISS, 0),
    BLOCK_OTHER("Block Other", 1630, 0),
    CHARGE_UP("Charge Up", 3519, 0),
    CHARGE_UP_OTHER("Charge Up Other", 3569, 0),
    CHARGE_DOWN("Charge Down", 3520, 0),
    CHARGE_DOWN_OTHER("Charge Down Other", 3570, 0),
    CORRUPTION("Corruption", 2270, 0),
    DAMAGE("Damage", 1359, 0),
    DAMAGE_OTHER("Damage Other", 1631, 0),
    DAMAGE_MAX("Max", 3571, 0),
    DISEASE("Disease", 1361, 0),
    DOOM("Doom", 4766, 0),
    FREEZE("Freeze", 4768, 0),
    FREEZE_OTHER("Freeze Other", 4769, 0),
    NO_KILL_CREDIT("No Kill Credit", 3521, 0),
    HEAL("Heal", 1629, 0),
    NONE("None", SpriteID.HITSPLAT_BLUE_MISS, 0),
    POISE("Poise", 4558, 0),
    POISE_OTHER("Poise Other", 4559, 0),
    POISE_MAX("Poise Max", 4560, 0),
    POISON("Poison", SpriteID.HITSPLAT_GREEN_POISON, 0),
    POISON_OTHER("Poison Other", 1632, 0),
    POISON_MAX("Poison Max", 4763, 0),
    PRAYER_DRAIN("Prayer Drain", 4561, 0),
    PRAYER_DRAIN_OTHER("Prayer Drain Other", 4562, 0),
    PRAYER_DRAIN_MAX("Prayer Drain Max", 4563, 0),
    SANITY_DRAIN("Sanity Drain", 4764, 0),
    SANITY_RESTORE("Sanity Restore", 4765, 0),
    SHIELD("Shield", 1419, 0),
    SHIELD_OTHER("Shield Other", 1339, 0),
    SHIELD_MAX("Shield Max", 4556, 0),
    TOTEM_UP_OTHER("Totem Up Other", 1634, 0),
    TOTEM_UP_MAX("Totem Up Max", 3572, 0),
    TOTEM_DOWN_MAX("Totem Down Max", 3573, 0),
    VENOM("Venom", SpriteID.HITSPLAT_DARK_GREEN_VENOM, 0),
    VENOM_OTHER("Venom Other", 2245, 0),
    ;

    private final String name;
    private final int spriteID;
    private final int file;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Toggle
{
    ENABLE("Enable"),
    DISABLE("Disable")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ModelToggle
{
    MODEL_ID("Model Id"),
    CUSTOM_MODEL("Custom Model")
    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe.settings;

import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.SpriteID;

@Getter
@AllArgsConstructor
public enum HealthbarSprite
{
    DEFAULT("Default", 2176, SpriteID.HEALTHBAR_DEFAULT_BACK_30PX),
    ;

    private final String name;
    private final int foregroundSpriteID;
    private final int backgroundSpriteID;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import com.creatorskit.swing.timesheet.keyframe.settings.HealthbarSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatSprite;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class HealthKeyFrame extends KeyFrame
{
    private double duration;
    private HealthbarSprite healthbarSprite;
    private int maxHealth;
    private int currentHealth;

    public HealthKeyFrame(double tick, double duration,
                          HealthbarSprite healthbarSprite,
                          int maxHealth, int currentHealth)
    {
        super(KeyFrameType.HEALTH, tick);
        this.duration = duration;
        this.healthbarSprite = healthbarSprite;
        this.maxHealth = maxHealth;
        this.currentHealth = currentHealth;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

public enum KeyFrameState
{
    EMPTY,
    ON_KEYFRAME,
    OFF_KEYFRAME
}

package com.creatorskit.swing.timesheet.keyframe;


import com.creatorskit.models.CustomModel;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class ModelKeyFrame extends KeyFrame
{
    private boolean useCustomModel;
    private int modelId;
    private CustomModel customModel;
    private int radius;

    public ModelKeyFrame(double tick, boolean useCustomModel, int modelId, CustomModel customModel, int radius)
    {
        super(KeyFrameType.MODEL, tick);
        this.useCustomModel = useCustomModel;
        this.modelId = modelId;
        this.customModel = customModel;
        this.radius = radius;
    }
}

package com.creatorskit.swing.timesheet.keyframe;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
public class TextKeyFrame extends KeyFrame
{
    private double duration;
    private String text;

    public TextKeyFrame(double tick, double duration, String text)
    {
        super(KeyFrameType.TEXT, tick);
        this.duration = duration;
        this.text = text;
    }
}

package com.creatorskit.swing.timesheet;

import com.creatorskit.CKObject;
import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.DataFinder;
import com.creatorskit.models.datatypes.PlayerAnimationType;
import com.creatorskit.models.datatypes.SpotanimData;
import com.creatorskit.models.datatypes.WeaponAnimData;
import com.creatorskit.programming.MovementManager;
import com.creatorskit.programming.Programmer;
import com.creatorskit.programming.orientation.Orientation;
import com.creatorskit.programming.orientation.OrientationGoal;
import com.creatorskit.programming.orientation.OrientationHotkeyMode;
import com.creatorskit.swing.ToolBoxFrame;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.manager.TreeScrollPane;
import com.creatorskit.swing.timesheet.keyframe.*;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameCharacterAction;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameAction;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameCharacterActionType;
import com.creatorskit.swing.timesheet.keyframe.keyframeactions.KeyFrameActionType;
import com.creatorskit.swing.timesheet.keyframe.settings.HealthbarSprite;
import com.creatorskit.swing.timesheet.sheets.AttributeSheet;
import com.creatorskit.swing.timesheet.sheets.SummarySheet;
import com.creatorskit.swing.timesheet.sheets.TimeSheet;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.annotation.Nullable;
import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.EmptyBorder;
import javax.swing.border.LineBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.TreePath;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.text.DecimalFormat;
import java.util.ArrayList;

@Getter
@Setter
public class TimeSheetPanel extends JPanel
{
    private Client client;
    private ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;

    private final GridBagConstraints c = new GridBagConstraints();
    private final ToolBoxFrame toolBox;
    private final DataFinder dataFinder;
    private SummarySheet summarySheet;
    private AttributeSheet attributeSheet;
    private TreeScrollPane treeScrollPane;
    private final ManagerTree managerTree;
    private MovementManager movementManager;
    private final JComboBox<KeyFrameType> summaryComboBox = new JComboBox<>();
    private JScrollBar scrollBar;
    private AttributePanel attributePanel;
    private final JScrollPane labelScrollPane = new JScrollPane();
    private final JPanel controlPanel = new JPanel();
    private final JButton playButton = new JButton();
    private final ImageIcon PLAY = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Play.png"));
    private final ImageIcon STOP = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Stop.png"));
    private final ImageIcon PAUSE = new ImageIcon(ImageUtil.loadImageResource(getClass(), "/Pause.png"));
    private final BufferedImage SKIP_LEFT = ImageUtil.loadImageResource(getClass(), "/Skip_Left.png");
    private final BufferedImage SKIP_RIGHT = ImageUtil.loadImageResource(getClass(), "/Skip_Right.png");

    public static final int ABSOLUTE_MAX_SEQUENCE_LENGTH = 100000;
    private static final int DEFAULT_MIN_H_SCROLL = -10;
    private static final int DEFAULT_MAX_H_SCROLL = 200;
    private static final int ZOOM_MAX = 500;
    private static final int ZOOM_MIN = 5;

    private final String LABEL_OFFSET = "  ";
    private JLabel[] labels = new JLabel[0];

    private double zoom = 50;
    private double hScroll = 0;
    private double maxHScroll = 200;
    private double minHScroll = -10;

    private double currentTime = 0;
    private boolean pauseScrollBarListener = false;
    private Character selectedCharacter;

    private ArrayList<KeyFrameAction> keyFrameStack = new ArrayList<>();
    private KeyFrame[] selectedKeyFrames = new KeyFrame[0];
    private KeyFrame[] copiedKeyFrames = new KeyFrame[0];
    private KeyFrameAction[][] keyFrameActions = new KeyFrameAction[0][];

    private final int UNDO_LIMIT = 15;
    private int undoStack = 0;

    @Inject
    public TimeSheetPanel(@Nullable Client client, ToolBoxFrame toolBox, CreatorsPlugin plugin, CreatorsConfig config, ClientThread clientThread, DataFinder dataFinder, ManagerTree managerTree, MovementManager movementManager)
    {
        this.client = client;
        this.toolBox = toolBox;
        this.plugin = plugin;
        this.config = config;
        this.clientThread = clientThread;
        this.dataFinder = dataFinder;
        this.managerTree = managerTree;
        this.movementManager = movementManager;

        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARKER_GRAY_COLOR);

        setupTreeScrollPane();
        setupControlPanel();
        setupAttributePanel();
        setupAttributeSheet();
        setupScrollBar();
        setupTimeTreeListener();
        setupManager();
        setKeyBindings();
        setMouseListeners();
    }

    public void onAttributeSkipForward()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findNextKeyFrame(currentTime);
        if (keyFrame == null)
        {
            return;
        }

        setCurrentTime(keyFrame.getTick(), false);
    }

    public void onAttributeSkipPrevious()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findPreviousKeyFrame(currentTime);
        if (keyFrame == null)
        {
            return;
        }

        setCurrentTime(keyFrame.getTick(), false);
    }

    public void onZoomEvent(int amount, TimeSheet source)
    {
        double x = source.getMousePosition(true).getX();
        double change = zoom;
        zoom += 5 * amount;
        if (zoom < ZOOM_MIN)
            zoom = ZOOM_MIN;

        if (zoom > ZOOM_MAX)
            zoom = ZOOM_MAX;

        change -= zoom;
        hScroll = round(hScroll - change * (x / source.getWidth()));
        if (hScroll < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (hScroll > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        boundSliderMinMax();
        updateScrollBar();
        updateSheets();
    }

    public void onHorizontalScrollEvent(double amount)
    {
        hScroll = round(hScroll - amount * zoom / 50);
        if (hScroll < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (hScroll > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            hScroll = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        boundSliderMinMax();
        updateScrollBar();
        updateSheets();
    }

    private void boundSliderMinMax()
    {
        if (-hScroll < minHScroll)
        {
            minHScroll = -hScroll;
        }

        if (-hScroll > minHScroll)
        {
            KeyFrame firstKeyFrame = getFirstKeyFrame();
            if (firstKeyFrame == null)
            {
                minHScroll = -hScroll;
            }

            if (firstKeyFrame != null)
            {
                double firstTick = firstKeyFrame.getTick();
                minHScroll = Math.min(-hScroll, firstTick);
            }

            if (minHScroll > DEFAULT_MIN_H_SCROLL)
            {
                minHScroll = DEFAULT_MIN_H_SCROLL;
            }
        }

        double maxVisibleValue = round(zoom - hScroll);
        if (maxVisibleValue > maxHScroll)
        {
            maxHScroll = maxVisibleValue;
        }

        if (maxVisibleValue < maxHScroll)
        {
            KeyFrame lastKeyFrame = getLastKeyFrame();
            if (lastKeyFrame == null)
            {
                maxHScroll = maxVisibleValue;
            }

            if (lastKeyFrame != null)
            {
                double lastTick = lastKeyFrame.getTick();
                maxHScroll = Math.max(maxVisibleValue, lastTick);
            }

            if (maxHScroll < DEFAULT_MAX_H_SCROLL)
            {
                maxHScroll = DEFAULT_MAX_H_SCROLL;
            }
        }
    }

    private KeyFrame getLastKeyFrame()
    {
        ArrayList<Character> characters = plugin.getCharacters();
        if (characters.isEmpty())
        {
            return null;
        }

        KeyFrame lastKeyFrame = null;
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            KeyFrame comparison = character.findLastKeyFrame();
            if (lastKeyFrame == null)
            {
                if (comparison != null)
                {
                    lastKeyFrame = comparison;
                    continue;
                }
            }

            if (comparison == null)
            {
                continue;
            }

            if (comparison.getTick() > lastKeyFrame.getTick())
            {
                lastKeyFrame = comparison;
            }
        }

        return lastKeyFrame;
    }

    private KeyFrame getFirstKeyFrame()
    {
        ArrayList<Character> characters = plugin.getCharacters();
        if (characters.isEmpty())
        {
            return null;
        }

        KeyFrame firstKeyFrame = null;
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            KeyFrame comparison = character.findFirstKeyFrame();
            if (firstKeyFrame == null)
            {
                if (comparison != null)
                {
                    firstKeyFrame = comparison;
                    continue;
                }
            }

            if (comparison == null)
            {
                continue;
            }

            if (comparison.getTick() < firstKeyFrame.getTick())
            {
                firstKeyFrame = comparison;
            }
        }

        return firstKeyFrame;
    }

    public void onKeyFrameIconPressedEvent()
    {
        onKeyFrameIconPressedEvent(currentTime, attributePanel.getSelectedKeyFramePage());
    }

    public void onKeyFrameIconPressedEvent(double currentTick, KeyFrameType type)
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame keyFrame = selectedCharacter.findKeyFrame(type, currentTick);
        if (keyFrame == null)
        {
            KeyFrame kf = attributePanel.createKeyFrame(type, currentTick);
            if (kf == null)
            {
                return;
            }

            addKeyFrameAction(kf);
            return;
        }

       removeKeyFrameAction(keyFrame);
    }

    public void addKeyFrameAction(KeyFrame keyFrame)
    {
        KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.ADD)};
        KeyFrame keyFrameToReplace = addKeyFrame(selectedCharacter, keyFrame);

        if (keyFrameToReplace != null)
        {
            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
        }
        addKeyFrameActions(kfa);
    }

    public void removeKeyFrameAction(KeyFrame keyFrame)
    {
        removeKeyFrame(selectedCharacter, keyFrame);
        KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.REMOVE)};
        addKeyFrameActions(kfa);
    }

    public void onUpdateButtonPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrameType type = attributePanel.getSelectedKeyFramePage();
        KeyFrame keyFrame = selectedCharacter.findPreviousKeyFrame(type, currentTime, true);
        if (keyFrame == null)
        {
            return;
        }

        KeyFrame kf = attributePanel.createKeyFrame(type, keyFrame.getTick());
        if (kf == null)
        {
            return;
        }

        if (type == KeyFrameType.MOVEMENT)
        {
            MovementKeyFrame oldKF = (MovementKeyFrame) keyFrame;

            MovementKeyFrame newKF = (MovementKeyFrame) kf;
            newKF.setPlane(oldKF.getPlane());
            newKF.setPoh(oldKF.isPoh());
            newKF.setPath(oldKF.getPath());
            newKF.setCurrentStep(0);
            newKF.setStepClientTick(0);
        }

        KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(kf, selectedCharacter, KeyFrameCharacterActionType.ADD), new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.REMOVE)};
        addKeyFrame(selectedCharacter, kf);
        addKeyFrameActions(kfa);
    }

    public void onOrientationKeyPressed(OrientationHotkeyMode hotkeyMode)
    {
        if (selectedCharacter == null)
        {
            return;
        }

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        Tile tile = worldView.getSelectedSceneTile();
        if (tile == null)
        {
            return;
        }

        LocalPoint localPoint = tile.getLocalLocation();
        if (localPoint == null || !localPoint.isInScene())
        {
            return;
        }

        Programmer programmer = toolBox.getProgrammer();

        CKObject ckObject = selectedCharacter.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        KeyFrame okf = selectedCharacter.getCurrentKeyFrame(KeyFrameType.ORIENTATION);
        if (okf == null)
        {
            int orientation = ckObject.getOrientation();

            initializeOrientationKeyFrame(
                    selectedCharacter,
                    hotkeyMode,
                    localPoint,
                    currentTime,
                    orientation,
                    orientation,
                    OrientationGoal.POINT,
                    OrientationKeyFrame.TURN_RATE);
        }
        else
        {
            OrientationKeyFrame keyFrame = (OrientationKeyFrame) okf;
            initializeOrientationKeyFrame(
                    selectedCharacter,
                    hotkeyMode,
                    localPoint,
                    keyFrame.getTick(),
                    keyFrame.getStart(),
                    keyFrame.getEnd(),
                    keyFrame.getGoal(),
                    keyFrame.getTurnRate());
        }

        programmer.register3DChanges(selectedCharacter);
        selectedCharacter.setVisible(true, clientThread);
    }

    public void initializeOrientationKeyFrame(Character character, OrientationHotkeyMode hotkeyMode, LocalPoint localPoint, double tick, int start, int end, OrientationGoal og, int turnRate)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        LocalPoint lp = ckObject.getLocation();
        if (lp == null || !lp.isInScene())
        {
            return;
        }

        int startOrientation = start;
        int endOrientation = end;
        int angle = (int) Orientation.getAngleBetween(lp, localPoint);

        if (hotkeyMode == OrientationHotkeyMode.SET_START)
        {
            startOrientation = angle;
        }
        else
        {
            endOrientation = angle;
        }

        double turnDuration = AttributePanel.calculateOrientationDuration(startOrientation, endOrientation, turnRate);

        OrientationKeyFrame okf = new OrientationKeyFrame(
                tick,
                og,
                startOrientation,
                endOrientation,
                turnDuration,
                turnRate);

        addKeyFrameAction(okf);
    }

    public void onAddOrientationMenuOptionPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        CKObject ckObject = selectedCharacter.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        int orientation = ckObject.getOrientation();

        OrientationKeyFrame okf = new OrientationKeyFrame(
                currentTime,
                OrientationGoal.POINT,
                orientation,
                orientation,
                1,
                OrientationKeyFrame.TURN_RATE);

        addKeyFrameAction(okf);
    }

    public void onAddMovementKeyPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        Tile tile = worldView.getSelectedSceneTile();
        if (tile == null)
        {
            return;
        }

        LocalPoint localPoint = tile.getLocalLocation();
        if (localPoint == null || !localPoint.isInScene())
        {
            return;
        }

        onAddMovement(false, localPoint);
    }

    public void onAddMovementMenuOptionPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        CKObject ckObject = selectedCharacter.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        LocalPoint localPoint = ckObject.getLocation();
        if (localPoint == null || !localPoint.isInScene())
        {
            return;
        }

        onAddMovement(true, localPoint);
    }

    public void onAddMovement(boolean newKeyFrame, LocalPoint localPoint)
    {
        WorldView worldView = client.getTopLevelWorldView();
        if (worldView == null)
        {
            return;
        }

        selectedCharacter.setInScene(true);
        selectedCharacter.setActive(true, true, true, clientThread);

        Programmer programmer = toolBox.getProgrammer();

        boolean poh = MovementManager.useLocalLocations(worldView);

        KeyFrame kf = selectedCharacter.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
        if (newKeyFrame || kf == null)
        {
            int x = localPoint.getSceneX();
            int y = localPoint.getSceneY();
            if (!poh)
            {
                WorldPoint wp = WorldPoint.fromLocalInstance(client, localPoint, worldView.getPlane());
                x = wp.getX();
                y = wp.getY();
            }

            int[][] path = new int[][]{new int[]{x, y}};
            initializeMovementKeyFrame(selectedCharacter, currentTime, worldView.getPlane(), poh, path, false, 1, OrientationKeyFrame.TURN_RATE);
        }
        else
        {
            MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
            int[][] path = movementManager.addProgramStep(keyFrame, worldView, localPoint);
            initializeMovementKeyFrame(selectedCharacter, keyFrame.getTick(), worldView.getPlane(), poh, path, keyFrame.isLoop(), keyFrame.getSpeed(), keyFrame.getTurnRate());
        }

        programmer.register3DChanges(selectedCharacter);
    }

    public void initializeMovementKeyFrame(Character character, double tick, int plane, boolean poh, int[][] path, boolean loop, double speed, int turnRate)
    {
        KeyFrame kf = new MovementKeyFrame(
                tick,
                plane,
                poh,
                path,
                0,
                0,
                loop,
                speed,
                turnRate);

        KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(kf, character, KeyFrameCharacterActionType.ADD)};
        KeyFrame keyFrameToReplace = addKeyFrame(character, kf);

        if (keyFrameToReplace != null)
        {
            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, character, KeyFrameCharacterActionType.REMOVE));
        }
        addKeyFrameActions(kfa);
    }

    /**
     * Adds a new HealthKeyFrame based on the last HealthKeyFrame as if the HitsplatKeyFrame argument were applied
     */
    public void initializeHealthKeyFrame(KeyFrameType type)
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrame hitsplatKeyFrame = attributePanel.createKeyFrame(type, currentTime);
        addKeyFrameAction(hitsplatKeyFrame);

        HitsplatKeyFrame hitsKF = (HitsplatKeyFrame) hitsplatKeyFrame;

        double duration;
        HealthbarSprite sprite;
        int maxHealth;
        int currentHealth;

        KeyFrame healthKeyFrame = selectedCharacter.findPreviousKeyFrame(KeyFrameType.HEALTH, currentTime, true);
        if (healthKeyFrame == null)
        {
            duration = 3.0;
            sprite = HealthbarSprite.DEFAULT;
            maxHealth = 99;
            currentHealth = 99;
        }
        else
        {
            HealthKeyFrame healthKF = (HealthKeyFrame) healthKeyFrame;
            duration = healthKF.getDuration();
            sprite = healthKF.getHealthbarSprite();
            maxHealth = healthKF.getMaxHealth();
            currentHealth = healthKF.getCurrentHealth();
        }

        int damage = hitsKF.getDamage();

        int remaining = currentHealth - damage;
        if (remaining < 0)
        {
            remaining = 0;
        }

        HealthKeyFrame nextKF = new HealthKeyFrame(
                currentTime,
                duration,
                sprite,
                maxHealth,
                remaining);

        addKeyFrameAction(nextKF);
    }

    public void addAnimationKeyFrameFromCache(WeaponAnimData weaponAnim)
    {
        AnimationKeyFrame keyFrame = new AnimationKeyFrame(
                currentTime,
                false,
                -1,
                0,
                false,
                false,
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.WALK),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.RUN),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_180),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_RIGHT),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_LEFT),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_RIGHT),
                WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_LEFT));

        addKeyFrameAction(keyFrame);
    }

    public void addSpotAnimKeyFrameFromCache(SpotanimData spotanimData)
    {
        KeyFrameType type = KeyFrameType.SPOTANIM;
        KeyFrame sp1 = selectedCharacter.findKeyFrame(KeyFrameType.SPOTANIM, currentTime);
        if (sp1 != null)
        {
            KeyFrame sp2 = selectedCharacter.findKeyFrame(KeyFrameType.SPOTANIM2, currentTime);
            if (sp2 == null)
            {
                type = KeyFrameType.SPOTANIM2;
            }
        }

        SpotAnimKeyFrame keyFrame = new SpotAnimKeyFrame(
                plugin.getCurrentTick(),
                type,
                spotanimData.getId(),
                false,
                92);

        addKeyFrameAction(keyFrame);
    }

    public void duplicateHitsplatKeyFrame(KeyFrameType previousType, KeyFrameType targetType)
    {
        KeyFrame kf = selectedCharacter.findPreviousKeyFrame(previousType, currentTime, true);
        if (kf == null)
        {
            return;
        }

        HitsplatKeyFrame keyFrame = (HitsplatKeyFrame) kf;

        HitsplatKeyFrame hkf = new HitsplatKeyFrame(
                keyFrame.getTick(),
                targetType,
                keyFrame.getDuration(),
                keyFrame.getSprite(),
                keyFrame.getVariant(),
                keyFrame.getDamage());

        addKeyFrameAction(hkf);
    }

    public void duplicateSpotanimKeyFrame(KeyFrameType previousType, KeyFrameType targetType)
    {
        KeyFrame kf = selectedCharacter.findPreviousKeyFrame(previousType, currentTime, true);
        if (kf == null)
        {
            return;
        }

        SpotAnimKeyFrame keyFrame = (SpotAnimKeyFrame) kf;

        SpotAnimKeyFrame spkf = new SpotAnimKeyFrame(
                keyFrame.getTick(),
                targetType,
                keyFrame.getSpotAnimId(),
                keyFrame.isLoop(),
                keyFrame.getHeight());

        addKeyFrameAction(spkf);
    }

    /**
     * Adds the keyframe to a specific character, or replaces a keyframe if the tick matches exactly
     * @param character the character to add the keyframe to
     * @param keyFrame the keyframe to add or modify for the character
     * @return the keyframe that is being replaced; null if there is no keyframe being replaced
     */
    public KeyFrame addKeyFrame(Character character, KeyFrame keyFrame)
    {
        if (character == null)
        {
            return null;
        }

        KeyFrame keyFrameToReplace = character.addKeyFrame(keyFrame, currentTime);
        attributePanel.setKeyFramedIcon(true);
        attributePanel.resetAttributes(character, currentTime);
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            toolBox.getProgrammer().updateProgram(character, currentTime);
        }

        return keyFrameToReplace;
    }

    /**
     * Removes a specific keyframe from the chosen character
     * @param character the character to remove the keyframe from
     * @param keyFrame the keyframe to remove
     */
    public void removeKeyFrame(Character character, KeyFrame keyFrame)
    {
        character.removeKeyFrame(keyFrame);
        attributePanel.resetAttributes(character, currentTime);
        if (client.getGameState() == GameState.LOGGED_IN)
        {
            toolBox.getProgrammer().updateProgram(character, currentTime);
        }
    }

    /**
     * Removes the specified keyframes from the chosen character
     * @param character the character to remove the keyframes from
     * @param keyFrames the keyframes to remove
     */
    public void removeKeyFrame(Character character, KeyFrame[] keyFrames)
    {
        for (KeyFrame keyFrame : keyFrames)
        {
            character.removeKeyFrame(keyFrame);
        }

        attributePanel.resetAttributes(character, currentTime);
        toolBox.getProgrammer().updateProgram(character, currentTime);
    }

    public void addKeyFrameActions(KeyFrameAction[] actions)
    {
        if (keyFrameActions.length == UNDO_LIMIT)
        {
            keyFrameActions = ArrayUtils.remove(keyFrameActions, 0);
        }

        if (keyFrameActions.length > 0)
        {
            while (keyFrameActions.length - 1 > undoStack)
            {
                keyFrameActions = ArrayUtils.remove(keyFrameActions, keyFrameActions.length - 1);
            }
        }

        keyFrameActions = ArrayUtils.add(keyFrameActions, actions);
        undoStack = keyFrameActions.length - 1;
    }

    public void removeKeyFrameActions(Character character)
    {
        for (int i = 0; i < keyFrameActions.length; i++)
        {
            KeyFrameAction[] actions = keyFrameActions[i];
            for (int e = 0; e < actions.length; e++)
            {
                KeyFrameAction kfa = actions[e];
                if (kfa.getActionType() == KeyFrameActionType.CHARACTER)
                {
                    KeyFrameCharacterAction kfca = (KeyFrameCharacterAction) kfa;
                    if (kfca.getCharacter() == character)
                    {
                        keyFrameActions = ArrayUtils.removeElement(keyFrameActions, actions);
                        break;
                    }
                }
            }
        }
        undoStack = keyFrameActions.length - 1;
    }

    public void undo()
    {
        if (undoStack == -1 || keyFrameActions.length == 0)
        {
            return;
        }

        selectedKeyFrames = new KeyFrame[0];
        KeyFrameAction[] lastActions = keyFrameActions[undoStack];
        for (int i = 0; i < lastActions.length; i++)
        {
            KeyFrameAction keyFrameAction = lastActions[i];

            if (keyFrameAction.getActionType() == KeyFrameActionType.CHARACTER)
            {
                KeyFrameCharacterAction kfca = (KeyFrameCharacterAction) keyFrameAction;

                KeyFrameCharacterActionType actionType = kfca.getCharacterActionType();
                if (actionType == KeyFrameCharacterActionType.ADD)
                {
                    removeKeyFrame(kfca.getCharacter(), keyFrameAction.getKeyFrame());
                }

                if (actionType == KeyFrameCharacterActionType.REMOVE)
                {
                    KeyFrame keyFrame = keyFrameAction.getKeyFrame();
                    addKeyFrame(kfca.getCharacter(), keyFrameAction.getKeyFrame());
                    selectedKeyFrames = ArrayUtils.add(selectedKeyFrames, keyFrame);
                }
            }
        }

        undoStack--;
    }

    public void redo()
    {
        if (undoStack + 1 >= keyFrameActions.length)
        {
            return;
        }

        undoStack++;

        selectedKeyFrames = new KeyFrame[0];
        KeyFrameAction[] lastUndoneActions = keyFrameActions[undoStack];
        for (KeyFrameAction keyFrameAction : lastUndoneActions)
        {
            if (keyFrameAction.getActionType() == KeyFrameActionType.CHARACTER)
            {
                KeyFrameCharacterAction keyFrameCharacterAction = (KeyFrameCharacterAction) keyFrameAction;
                KeyFrameCharacterActionType actionType = keyFrameCharacterAction.getCharacterActionType();
                if (actionType == KeyFrameCharacterActionType.ADD)
                {
                    KeyFrame keyFrame = keyFrameAction.getKeyFrame();
                    addKeyFrame(keyFrameCharacterAction.getCharacter(), keyFrame);
                    selectedKeyFrames = ArrayUtils.add(selectedKeyFrames, keyFrame);
                }

                if (actionType == KeyFrameCharacterActionType.REMOVE)
                {
                    removeKeyFrame(keyFrameCharacterAction.getCharacter(), keyFrameAction.getKeyFrame());
                }
            }
        }
    }

    public void setSelectedCharacter(Character character)
    {
        selectedCharacter = character;
        summarySheet.setSelectedCharacter(character);
        attributeSheet.setSelectedCharacter(character);
        attributePanel.setSelectedCharacter(character);
        attributePanel.resetAttributes(character, currentTime);
    }

    public void setCurrentTime(double tick, boolean playing)
    {
        if (!playing)
        {
            toolBox.getProgrammer().pause();
        }

        if (tick < -ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            tick = -ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        if (tick > ABSOLUTE_MAX_SEQUENCE_LENGTH)
        {
            tick = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        }

        currentTime = tick;
        attributeSheet.setCurrentTime(currentTime);
        summarySheet.setCurrentTime(currentTime);

        Programmer programmer = toolBox.getProgrammer();

        if (client.getGameState() == GameState.LOGGED_IN)
        {
            if (playing)
            {
                programmer.updateProgramsOnTick();
            }
            else
            {
                programmer.updatePrograms(tick);
            }
        }

        onCurrentTimeChanged(tick);
    }

    public void onCurrentTimeChanged(double tick)
    {
        attributePanel.resetAttributes(selectedCharacter, tick);
    }

    public void setPlayButtonIcon(boolean playing)
    {
        playButton.setIcon(playing ? PAUSE : PLAY);
    }

    public void updatePreviewTime(double tick)
    {
        attributeSheet.setPreviewTime(tick);
        summarySheet.setPreviewTime(tick);
    }

    private void setupTreeScrollPane()
    {
        treeScrollPane = new TreeScrollPane(managerTree);
        treeScrollPane.setPreferredSize(new Dimension(614, 0));

        MouseWheelListener[] mouseWheelListeners = treeScrollPane.getMouseWheelListeners();
        for (int i = 0; i < mouseWheelListeners.length; i++)
        {
            treeScrollPane.removeMouseWheelListener(mouseWheelListeners[i]);
        }

        treeScrollPane.addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    managerTree.scrollSelectedIndex(e.getWheelRotation());
                    return;
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    scrollAttributePanel(e.getWheelRotation());
                    return;
                }

                JScrollBar bar = treeScrollPane.getVerticalScrollBar();
                bar.setValue(bar.getValue() + e.getWheelRotation() * 15);
            }
        });
    }

    private void setupControlPanel()
    {
        controlPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controlPanel.setLayout(new GridBagLayout());
        controlPanel.setFocusable(true);

        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 1;
        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 1;
        c.gridx = 0;
        c.gridy = 0;
        JSpinner timeSpinner = new JSpinner();
        timeSpinner.setBackground(ColorScheme.DARK_GRAY_COLOR);
        timeSpinner.setModel(new SpinnerNumberModel(0, -ABSOLUTE_MAX_SEQUENCE_LENGTH, ABSOLUTE_MAX_SEQUENCE_LENGTH, 0.1));
        JSpinner.NumberEditor editor = (JSpinner.NumberEditor) timeSpinner.getEditor();
        DecimalFormat format = editor.getFormat();
        format.setMinimumFractionDigits(2);
        timeSpinner.setValue(0);
        timeSpinner.addChangeListener(e ->
        {
            double tick = TimeSheetPanel.round((double) timeSpinner.getValue());
            toolBox.getTimeSheetPanel().setCurrentTime(tick, false);
        });
        controlPanel.add(timeSpinner, c);

        playButton.setIcon(PLAY);
        playButton.setPreferredSize(new Dimension(35, 35));
        playButton.setBackground(ColorScheme.DARK_GRAY_COLOR);
        playButton.addActionListener(e -> toolBox.getProgrammer().togglePlay());

        JButton backAttributeSheet = new JButton(new ImageIcon(SKIP_LEFT));
        backAttributeSheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        backAttributeSheet.setPreferredSize(new Dimension(50, 35));
        backAttributeSheet.addActionListener(e -> onAttributeSkipPrevious());

        JButton forwardAttributeSheet = new JButton(new ImageIcon(SKIP_RIGHT));
        forwardAttributeSheet.setBackground(ColorScheme.DARK_GRAY_COLOR);
        forwardAttributeSheet.setPreferredSize(new Dimension(50, 35));
        forwardAttributeSheet.addActionListener(e -> onAttributeSkipForward());

        c.weightx = 1;
        c.weighty = 1;
        c.gridx = 2;
        c.gridy = 0;
        JPanel controls = new JPanel();
        controls.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        controls.add(backAttributeSheet);
        controls.add(playButton);
        controls.add(forwardAttributeSheet);
        controlPanel.add(controls, c);
    }

    private void setupAttributePanel()
    {
        attributePanel = new AttributePanel(client, clientThread, config, this, dataFinder);
        summarySheet = new SummarySheet(toolBox, config, managerTree, attributePanel);
        attributeSheet = new AttributeSheet(toolBox, config, managerTree, attributePanel);
    }

    private void setupAttributeSheet()
    {
        JPanel labelPanel = new JPanel();
        labelPanel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        labelPanel.setLayout(new GridLayout(0, 1, 0, 0));
        labelPanel.setFocusable(true);

        labelScrollPane.setViewportView(labelPanel);
        labelScrollPane.setBorder(new EmptyBorder(1, 0, 1, 0));
        labelScrollPane.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        labelScrollPane.setPreferredSize(new Dimension(100, 150));
        labelScrollPane.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        labelScrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        MouseWheelListener[] mouseWheelListeners = labelScrollPane.getMouseWheelListeners();
        for (int i = 0; i < mouseWheelListeners.length; i++)
        {
            labelScrollPane.removeMouseWheelListener(mouseWheelListeners[i]);
        }

        InvisibleScrollBar labelScrollBar = new InvisibleScrollBar();
        labelScrollBar.addAdjustmentListener(e -> attributeSheet.onVerticalScrollEvent(e.getValue()));
        labelScrollPane.setVerticalScrollBar(labelScrollBar);

        labelScrollPane.addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    managerTree.scrollSelectedIndex(e.getWheelRotation());
                    return;
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    scrollAttributePanel(e.getWheelRotation());
                    return;
                }

                labelScrollBar.setValue(labelScrollBar.getValue() + e.getWheelRotation() * 15);
            }
        });

        labels = new JLabel[KeyFrameType.getTotalFrameTypes() + 1];
        for (int i = 0; i < KeyFrameType.getTotalFrameTypes() + 1; i++)
        {
            JLabel label = new JLabel();
            label.setFocusable(true);
            label.setHorizontalAlignment(SwingConstants.RIGHT);
            label.setOpaque(true);
            label.setPreferredSize(new Dimension(100, 24));
            label.setBackground(ColorScheme.DARKER_GRAY_COLOR);

            // Skip the empty label
            if (i == 1)
            {
                label.setBackground(ColorScheme.MEDIUM_GRAY_COLOR);
            }

            if (i != 0)
            {
                label.addMouseListener(new MouseAdapter()
                {
                    @Override
                    public void mousePressed(MouseEvent e)
                    {
                        super.mousePressed(e);
                        attributePanel.switchCards(label.getText().replaceAll(LABEL_OFFSET, ""));
                        label.requestFocusInWindow();
                    }
                });

                label.addKeyListener(new KeyAdapter()
                {
                    @Override
                    public void keyReleased(KeyEvent e)
                    {
                        if (e.getKeyCode() == KeyEvent.VK_DOWN)
                        {
                            scrollAttributePanel(1);
                        }

                        if (e.getKeyCode() == KeyEvent.VK_UP)
                        {
                            scrollAttributePanel(-1);
                        }
                    }
                });
            }

            labels[i] = label;
            labelPanel.add(label);
        }

        labels[1].setText(AttributePanel.MOVE_CARD + LABEL_OFFSET);
        labels[2].setText(AttributePanel.ANIM_CARD + LABEL_OFFSET);
        labels[3].setText(AttributePanel.ORI_CARD + LABEL_OFFSET);
        labels[4].setText(AttributePanel.SPAWN_CARD + LABEL_OFFSET);
        labels[5].setText(AttributePanel.MODEL_CARD + LABEL_OFFSET);
        labels[6].setText(AttributePanel.SPOTANIM_CARD + LABEL_OFFSET);
        labels[7].setText(AttributePanel.SPOTANIM2_CARD + LABEL_OFFSET);
        labels[8].setText(AttributePanel.TEXT_CARD + LABEL_OFFSET);
        labels[9].setText(AttributePanel.OVER_CARD + LABEL_OFFSET);
        labels[10].setText(AttributePanel.HEALTH_CARD + LABEL_OFFSET);
        labels[11].setText(AttributePanel.HITSPLAT_1_CARD + LABEL_OFFSET);
        labels[12].setText(AttributePanel.HITSPLAT_2_CARD + LABEL_OFFSET);
        labels[13].setText(AttributePanel.HITSPLAT_3_CARD + LABEL_OFFSET);
        labels[14].setText(AttributePanel.HITSPLAT_4_CARD + LABEL_OFFSET);
    }

    private void setupScrollBar()
    {
        scrollBar = new JScrollBar(Adjustable.HORIZONTAL);
        scrollBar.setBorder(new LineBorder(ColorScheme.MEDIUM_GRAY_COLOR, 1));
        scrollBar.setPreferredSize(new Dimension(0, 15));
        scrollBar.setMinimum(DEFAULT_MIN_H_SCROLL);
        scrollBar.setMaximum(DEFAULT_MAX_H_SCROLL);
        scrollBar.setBlockIncrement((int) (zoom / 5));
        scrollBar.setUnitIncrement((int) (zoom / 50));
        scrollBar.setVisibleAmount((int) (zoom));
        scrollBar.setValue(0);

        scrollBar.addAdjustmentListener(e ->
        {
            if (pauseScrollBarListener)
            {
                return;
            }

            hScroll = -e.getValue();
            updateScrollBar();
            updateSheets();
        });
    }

    private void setupTimeTreeListener()
    {
        managerTree.addTreeSelectionListener(e ->
        {
            TreePath treePath = e.getPath();
            if (treePath == null)
            {
                return;
            }

            DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath.getLastPathComponent();
            Object o = node.getUserObject();
            if (o == null)
            {
                return;
            }

            if (o instanceof Character)
            {
                setSelectedCharacter((Character) o);
                return;
            }

            setSelectedCharacter(null);
        });
    }

    public void copyKeyFrames()
    {
        copiedKeyFrames = selectedKeyFrames;
    }

    public void pasteKeyFrames()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        if (copiedKeyFrames == null || copiedKeyFrames.length == 0)
        {
            return;
        }

        double firstTick = ABSOLUTE_MAX_SEQUENCE_LENGTH;
        for (KeyFrame keyFrame : copiedKeyFrames)
        {
            if (keyFrame.getTick() < firstTick)
            {
                firstTick = keyFrame.getTick();
            }
        }

        selectedKeyFrames = new KeyFrame[0];
        KeyFrameAction[] kfa = new KeyFrameAction[0];
        for (KeyFrame keyFrame : copiedKeyFrames)
        {
            double newTime = round(keyFrame.getTick() - firstTick + currentTime);
            KeyFrame copy = KeyFrame.createCopy(keyFrame, newTime);
            selectedKeyFrames = ArrayUtils.add(selectedKeyFrames, copy);

            KeyFrame keyFrameToReplace = addKeyFrame(selectedCharacter, copy);
            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(copy, selectedCharacter, KeyFrameCharacterActionType.ADD));

            if (keyFrameToReplace != null)
            {
                kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
            }
        }

        addKeyFrameActions(kfa);
    }

    private void setKeyBindings()
    {
        ActionMap actionMap = getActionMap();
        InputMap inputMap = getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);

        inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_I, 0), "VK_I");
        actionMap.put("VK_I", new AbstractAction()
        {
            @Override
            public void actionPerformed(ActionEvent e)
            {
                if (selectedCharacter == null)
                {
                    return;
                }

                if (attributeSheet.getBounds().contains(MouseInfo.getPointerInfo().getLocation()))
                {
                    KeyFrame keyFrame = attributePanel.createKeyFrame(currentTime);
                    KeyFrame keyFrameToReplace = addKeyFrame(selectedCharacter, keyFrame);
                    KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.ADD)};

                    if (keyFrameToReplace != null)
                    {
                        kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
                    }
                    addKeyFrameActions(kfa);
                    return;
                }

                Component component = attributePanel.getHoveredComponent();
                if (component == null)
                {
                    return;
                }

                if (component instanceof JSpinner || component instanceof JTextField)
                {
                    if (component.isFocusOwner())
                    {
                        return;
                    }
                }

                KeyFrameType keyFrameType = attributePanel.getHoveredKeyFrameType();
                if (keyFrameType == null || keyFrameType == KeyFrameType.NULL)
                {
                    return;
                }

                KeyFrame keyFrame = attributePanel.createKeyFrame(currentTime);
                KeyFrame keyFrameToReplace = addKeyFrame(selectedCharacter, keyFrame);
                KeyFrameAction[] kfa = new KeyFrameAction[]{new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.ADD)};

                if (keyFrameToReplace != null)
                {
                    kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrameToReplace, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
                }
                addKeyFrameActions(kfa);
            }
        });
    }

    public void onSelectAllPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        setSelectedKeyFrames(selectedCharacter.getAllKeyFrames());
    }

    public void onDeleteKeyPressed()
    {
        if (selectedCharacter == null)
        {
            return;
        }

        KeyFrameAction[] kfa = new KeyFrameAction[0];
        for (KeyFrame keyFrame : selectedKeyFrames)
        {
            kfa = ArrayUtils.add(kfa, new KeyFrameCharacterAction(keyFrame, selectedCharacter, KeyFrameCharacterActionType.REMOVE));
            removeKeyFrame(selectedCharacter, keyFrame);
        }

        addKeyFrameActions(kfa);
    }

    public void skipListener(double modifier)
    {
        setCurrentTime(round(currentTime + modifier), false);
    }

    private void setMouseListeners()
    {
        addMouseWheelListener(new MouseAdapter()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                super.mouseWheelMoved(e);
                if (e.isControlDown())
                {
                    if (e.isAltDown() || e.isShiftDown())
                    {
                        return;
                    }

                    managerTree.scrollSelectedIndex(e.getWheelRotation());
                    return;
                }

                if (e.isShiftDown())
                {
                    if (e.isControlDown() || e.isAltDown())
                    {
                        return;
                    }

                    scrollAttributePanel(e.getWheelRotation());
                }
            }
        });
    }

    public void scrollAttributePanel(int direction)
    {
        int index = KeyFrameType.getIndex(attributePanel.getSelectedKeyFramePage()) + direction;
        int totalFrameTypes = KeyFrameType.getTotalFrameTypes();
        if (index >= totalFrameTypes)
        {
            index = 0;
        }

        if (index == -1)
        {
            index = totalFrameTypes - 1;
        }

        attributePanel.switchCards(KeyFrameType.getKeyFrameType(index).toString());
    }

    private void setupManager()
    {
        c.fill = GridBagConstraints.BOTH;
        c.insets = new Insets(2, 2, 2, 2);

        c.gridwidth = 2;
        c.gridheight = 2;
        c.weightx = 0;
        c.weighty = 5;
        c.gridx = 0;
        c.gridy = 0;
        add(treeScrollPane, c);

        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 0;
        JLabel summaryLabel = new JLabel("Summary");
        summaryLabel.setFont(FontManager.getRunescapeBoldFont());
        summaryLabel.setBorder(new EmptyBorder(1, 2, 2, 2));
        add(summaryLabel, c);

        c.gridheight = 1;
        c.gridwidth = 1;
        c.weightx = 8;
        c.weighty = 5;
        c.gridx = 2;
        c.gridy = 1;
        add(summarySheet, c);

        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 2;
        add(scrollBar, c);

        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 3;
        add(controlPanel, c);

        c.gridheight = 3;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 0;
        c.gridy = 2;
        add(attributePanel, c);

        c.gridheight = 1;
        c.weightx = 0;
        c.weighty = 0;
        c.gridx = 1;
        c.gridy = 4;
        add(labelScrollPane, c);

        c.weightx = 8;
        c.weighty = 0;
        c.gridx = 2;
        c.gridy = 4;
        add(attributeSheet, c);
    }

    private void updateSheets()
    {
        summarySheet.setHScroll(hScroll);
        summarySheet.setZoom(zoom);
        attributeSheet.setHScroll(hScroll);
        attributeSheet.setZoom(zoom);
    }

    private void updateScrollBar()
    {
        pauseScrollBarListener = true;
        scrollBar.setMinimum((int) minHScroll);
        scrollBar.setMaximum((int) maxHScroll);
        scrollBar.setBlockIncrement((int) (zoom / 5));
        scrollBar.setUnitIncrement((int) (zoom / 50));
        scrollBar.setVisibleAmount((int) (zoom));
        scrollBar.setValue((int) -hScroll);
        pauseScrollBarListener = false;
    }

    /**
     * Rounds the given value to the nearest 1/10th
     * @param value the value to round
     * @return the value, rounded to 1 decimal place
     */
    public static double round (double value)
    {
        int scale = (int) Math.pow(10, 1);
        return (double) Math.round(value * scale) / scale;
    }
}

package com.creatorskit.swing;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TransmogAnimationMode
{
    PLAYER("Player"),
    MODIFIED("Modified"),
    CUSTOM("Custom"),
    NONE("None")
    ;

    private final String string;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.swing;

import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.models.DataFinder;
import com.creatorskit.programming.MovementManager;
import com.creatorskit.programming.PathFinder;
import com.creatorskit.programming.Programmer;
import com.creatorskit.swing.anvil.ModelAnvil;
import com.creatorskit.swing.manager.Folder;
import com.creatorskit.swing.manager.FolderType;
import com.creatorskit.swing.manager.ManagerPanel;
import com.creatorskit.swing.manager.ManagerTree;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.LinkBrowser;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.border.MatteBorder;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;

@Getter
public class ToolBoxFrame extends JFrame
{
    private ClientThread clientThread;
    private final Client client;
    private final EventBus eventBus;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    private final ConfigManager configManager;
    private final JMenuBar jMenuBar;
    private final DataFinder dataFinder;
    private final ManagerPanel managerPanel;
    private final ModelOrganizer modelOrganizer;
    private final ModelAnvil modelAnvil;
    private final CacheSearcherTab cacheSearcher;
    private final TransmogPanel transmogPanel;
    private final TimeSheetPanel timeSheetPanel;
    private final Programmer programmer;
    private final PathFinder pathFinder;
    private final JTabbedPane tabbedPane = new JTabbedPane();
    private final BufferedImage ICON = ImageUtil.loadImageResource(getClass(), "/panelicon.png");

    @Inject
    public ToolBoxFrame(Client client, EventBus eventBus, ClientThread clientThread, CreatorsPlugin plugin, CreatorsConfig config, ConfigManager configManager, DataFinder dataFinder, ModelOrganizer modelOrganizer, ModelAnvil modelAnvil, TransmogPanel transmogPanel, PathFinder pathFinder)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.config = config;
        this.eventBus = eventBus;
        this.configManager = configManager;
        this.jMenuBar = new JMenuBar();
        this.dataFinder = dataFinder;
        this.modelOrganizer = modelOrganizer;
        this.modelAnvil = modelAnvil;
        this.transmogPanel = transmogPanel;
        this.pathFinder = pathFinder;

        Folder rootFolder = new Folder("Master Folder", FolderType.MASTER, null, null);
        DefaultMutableTreeNode managerRootNode = new DefaultMutableTreeNode(rootFolder);
        rootFolder.setLinkedManagerNode(managerRootNode);

        Folder sidePanelFolder = new Folder("Side Panel", FolderType.SIDE_PANEL, null, managerRootNode);
        Folder managerPanelFolder = new Folder("Manager", FolderType.MANAGER, null, managerRootNode);
        DefaultMutableTreeNode managerSideNode = new DefaultMutableTreeNode(sidePanelFolder);
        DefaultMutableTreeNode managerManagerNode = new DefaultMutableTreeNode(managerPanelFolder);
        sidePanelFolder.setLinkedManagerNode(managerSideNode);
        managerPanelFolder.setLinkedManagerNode(managerManagerNode);

        JPanel objectHolder = new JPanel();
        ManagerTree managerTree = new ManagerTree(this, plugin, objectHolder, managerRootNode, managerSideNode, managerManagerNode);
        MovementManager movementManager = new MovementManager(client, config, pathFinder);

        setupMenuBar();
        this.timeSheetPanel = new TimeSheetPanel(client, this, plugin, config, clientThread, dataFinder, managerTree, movementManager);
        this.managerPanel = new ManagerPanel(client, plugin, objectHolder, managerTree);
        this.cacheSearcher = new CacheSearcherTab(plugin, clientThread, dataFinder);
        this.programmer = new Programmer(client, clientThread, plugin, timeSheetPanel, dataFinder);

        setBackground(ColorScheme.DARK_GRAY_COLOR);
        setTitle("Creator's Kit Toolbox");
        setIconImage(ICON);
        setLayout(new BorderLayout());
        setupWindow();

        addComponentListener(new ComponentAdapter()
        {
            public void componentResized(ComponentEvent componentEvent)
            {
                Dimension dimension = getSize();
                configManager.setConfiguration("creatorssuite", "toolBoxSize", (int) dimension.getWidth() + "," + (int) dimension.getHeight());

                if (getExtendedState() == Frame.NORMAL)
                {
                    configManager.setConfiguration("creatorssuite", "toolBoxMaximized", "false");
                }

                if (getExtendedState() == Frame.MAXIMIZED_BOTH)
                {
                    configManager.setConfiguration("creatorssuite", "toolBoxMaximized", "true");
                }
            }

            public void componentMoved(ComponentEvent componentEvent)
            {
                try
                {
                    Point p = getLocationOnScreen();
                    configManager.setConfiguration("creatorssuite", "toolBoxPoint", (int) p.getX() + "," + (int) p.getY());
                }
                catch (Exception e) {}
            }
        });

        tabbedPane.setFont(FontManager.getRunescapeBoldFont());

        tabbedPane.addTab("Timeline", timeSheetPanel);
        timeSheetPanel.getTreeScrollPane().setViewportView(managerTree);
        tabbedPane.addTab("Manager", managerPanel);
        tabbedPane.addTab("Model Organizer", modelOrganizer);
        tabbedPane.addTab("Model Anvil", modelAnvil);
        tabbedPane.addTab("Cache Searcher", cacheSearcher);
        tabbedPane.addTab("Transmogger", transmogPanel);
        tabbedPane.setToolTipTextAt(0, "Manage and organize all your Objects");
        tabbedPane.setToolTipTextAt(1, "Organize Custom Models you've loaded from the cache or Forged");
        tabbedPane.setToolTipTextAt(2, "Create Custom Models by modifying and merging different models together");
        tabbedPane.setToolTipTextAt(3, "Search the cache for NPCs, Items, and Objects for their models");
        tabbedPane.setToolTipTextAt(5, "Set animations for Transmogging your player character");

        //Move the FolderTree between the Manager and Programmer tabs when the given tab is selected
        tabbedPane.addChangeListener(e -> {
            if (e.getSource() instanceof JTabbedPane)
            {
                JTabbedPane jTabbedPane = (JTabbedPane) e.getSource();
                if (jTabbedPane.getSelectedComponent() == managerPanel)
                {
                    managerPanel.getTreeScrollPane().setViewportView(managerTree);
                }

                if (jTabbedPane.getSelectedComponent() == timeSheetPanel)
                {
                    timeSheetPanel.getTreeScrollPane().setViewportView(managerTree);
                }
            }
            repaint();
            revalidate();
        });

        add(jMenuBar, BorderLayout.PAGE_START);
        add(tabbedPane, BorderLayout.CENTER);
        pack();
        revalidate();
    }

    private void setupWindow()
    {
        try
        {
            String string = configManager.getConfiguration("creatorssuite", "toolBoxSize");
            String[] dimensions = string.split(",");
            int width = Integer.parseInt(dimensions[0]);
            int height = Integer.parseInt(dimensions[1]);
            if (width < 150)
                width = 150;
            if (height < 150)
                height = 150;
            setPreferredSize(new Dimension(width, height));
        }
        catch (Exception e)
        {
            setPreferredSize(new Dimension(1500, 800));
        }

        try
        {
            String string = configManager.getConfiguration("creatorssuite", "toolBoxPoint");
            String[] point = string.split(",");
            int x = Integer.parseInt(point[0]);
            int y = Integer.parseInt(point[1]);
            setLocation(x, y);
        }
        catch (Exception e)
        {
            setLocation(0, 0);
        }

        try
        {
            String string = configManager.getConfiguration("creatorssuite", "toolBoxMaximized");
            boolean maximize = Boolean.parseBoolean(string);
            if (maximize)
            {
                setExtendedState(Frame.MAXIMIZED_BOTH);
            }
            else
            {
                setExtendedState(Frame.NORMAL);
            }
        }
        catch (Exception e)
        {
            setExtendedState(Frame.NORMAL);
        }
    }

    private void setupMenuBar()
    {
        jMenuBar.setBackground(ColorScheme.DARK_GRAY_COLOR);
        jMenuBar.setFont(FontManager.getRunescapeBoldFont());
        jMenuBar.setBorder(new MatteBorder(0, 0, 1, 0, ColorScheme.DARKER_GRAY_COLOR));

        JMenu file = new JMenu("File");
        jMenuBar.add(file);

        JMenuItem save = new JMenuItem("Save Setup");
        save.addActionListener(e -> plugin.getCreatorsPanel().quickSaveToFile());
        save.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK));
        file.add(save);

        JMenuItem saveAs = new JMenuItem("Save Setup As...");
        saveAs.addActionListener(e -> plugin.getCreatorsPanel().openSaveDialog());
        file.add(saveAs);

        JMenuItem load = new JMenuItem("Load Setup");
        load.addActionListener(e -> plugin.getCreatorsPanel().openLoadSetupDialog());
        load.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK));
        file.add(load);

        JMenu timeSheet = new JMenu("Timeline");
        jMenuBar.add(timeSheet);

        JMenuItem togglePlay = new JMenuItem("Play/Pause");
        togglePlay.addActionListener(e -> programmer.togglePlay());
        togglePlay.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(togglePlay);

        JMenuItem reset = new JMenuItem("Reset Timeline");
        reset.addActionListener(e ->
        {
            programmer.pause();
            timeSheetPanel.setCurrentTime(0, false);
        });
        reset.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_R, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(reset);

        JMenuItem selectAll = new JMenuItem("Select All");
        selectAll.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.onSelectAllPressed();
            }
        });
        selectAll.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(selectAll);

        JMenuItem delete = new JMenuItem("Delete");
        delete.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.onDeleteKeyPressed();
            }
        });
        delete.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0));
        timeSheet.add(delete);

        JMenuItem copyKeyFrames = new JMenuItem("Copy");
        copyKeyFrames.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.copyKeyFrames();
            }
        });
        copyKeyFrames.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(copyKeyFrames);

        JMenuItem pasteKeyFrames = new JMenuItem("Paste");
        pasteKeyFrames.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.pasteKeyFrames();
            }
        });
        pasteKeyFrames.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(pasteKeyFrames);

        JMenuItem undo = new JMenuItem("Undo");
        undo.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.undo();
            }
        });
        undo.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Z, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(undo);

        JMenuItem redo = new JMenuItem("Redo");
        redo.addActionListener(e ->
        {
            if (tabbedPane.getSelectedComponent() == timeSheetPanel)
            {
                timeSheetPanel.redo();
            }
        });
        redo.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Y, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(redo);

        JMenuItem skipRight = new JMenuItem("Next KeyFrame");
        skipRight.addActionListener(e -> timeSheetPanel.onAttributeSkipForward());
        skipRight.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(skipRight);

        JMenuItem skipLeft = new JMenuItem("Last KeyFrame");
        skipLeft.addActionListener(e -> timeSheetPanel.onAttributeSkipPrevious());
        skipLeft.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK));
        timeSheet.add(skipLeft);

        JMenu resources = new JMenu("Resources");
        jMenuBar.add(resources);

        JMenuItem wikiDB = new JMenuItem("Minimal OSRS Database");
        wikiDB.addActionListener(e -> openLink("https://chisel.weirdgloop.org/moid/index.html"));
        resources.add(wikiDB);

        JMenuItem runeMonk = new JMenuItem("RuneMonk");
        runeMonk.addActionListener(e -> openLink("https://runemonk.com/tools/entityviewer-beta/"));
        resources.add(runeMonk);


        JMenu help = new JMenu("Help");
        jMenuBar.add(help);

        JMenuItem youtube = new JMenuItem("Youtube Tutorial");
        youtube.addActionListener(e -> openLink("https://www.youtube.com/playlist?list=PL5-mTiHdZKNgcEbhEdadHzX-F4VNE0G9O"));
        help.add(youtube);

        JMenuItem discord = new JMenuItem("Discord");
        discord.addActionListener(e -> openLink("https://discord.gg/DSpPfC2Ebh"));
        help.add(discord);

        JMenuItem twitter = new JMenuItem("X/Twitter");
        twitter.addActionListener(e -> openLink("https://x.com/ScreteMonge"));
        help.add(twitter);

        JMenuItem github = new JMenuItem("Github");
        github.addActionListener(e -> openLink("https://github.com/ScreteMonge/creators-kit"));
        help.add(github);


        JMenu donate = new JMenu("Donate");
        jMenuBar.add(donate);

        JMenuItem patreon = new JMenuItem("Patreon");
        patreon.addActionListener(e -> openLink("https://www.patreon.com/ScreteMonge"));
        donate.add(patreon);
    }

    public void openLink(String url)
    {
        try
        {
            LinkBrowser.browse(url);
        }
        catch (Exception exception)
        {
            plugin.sendChatMessage("Failed to open link.");
        }
    }
}

package com.creatorskit;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum Rotation
{
    _45_DEGREES("45 Degrees", 256),
    _90_DEGREES("90 Degrees", 512),
    _180_DEGREES("180 Degrees", 1024)

    ;
    public final String name;
    public final int degrees;

    @Override
    public String toString()
    {
        return name;
    }

    public static int convertRotation(double x, double y, double angle)
    {
        int jagexDegree = 0;
        if (x >= 0 && y >= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 1536;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 1280;
            }
            else if (angle >= 60)
            {
                jagexDegree = 1024;
            }
        }
        else if (x >= 0 && y <= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 1536;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 1792;
            }
            else if (angle >= 60)
            {
                jagexDegree = 0;
            }
        }
        else if (x <=0 && y >= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 512;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 768;
            }
            else if (angle >= 60)
            {
                jagexDegree = 1024;
            }
        }
        else if (x <=0 && y <= 0)
        {
            if (angle <= 30)
            {
                jagexDegree = 512;
            }
            else if (angle > 30 && angle < 60)
            {
                jagexDegree = 256;
            }
            else if (angle >= 60)
            {
                jagexDegree = 0;
            }
        }

        return jagexDegree;
    }

    public static int roundRotation(int rotation)
    {
        if ((rotation > -128 && rotation <= 128) || (rotation > 1920 && rotation <= 2176))
        {
            return 0;
        }

        if ((rotation > 128 && rotation <= 384) || (rotation > 2176 && rotation <= 2432))
        {
            return 256;
        }

        if (rotation > 384 && rotation <= 640)
        {
            return 512;
        }

        if (rotation > 640 && rotation <= 896)
        {
            return 768;
        }

        if (rotation > 896 && rotation <= 1152)
        {
            return 1024;
        }

        if (rotation > 1152 && rotation <= 1408)
        {
            return 1280;
        }

        if (rotation > 1408 && rotation <= 1664)
        {
            return 1536;
        }

        if ((rotation > 1664 && rotation <= 1920) || (rotation > -384 && rotation <= -128))
        {
            return 1792;
        }

        return 0;
    }

    public static int getJagexDegrees(double x, double y, int yaw, double pitch)
    {
        double degrees = Math.abs((Math.atan(y / x)) * 180 / Math.PI);
        int jagexDegree = Rotation.convertRotation(x, y, degrees) - (Rotation.roundRotation(yaw));
        while (jagexDegree >= 2048)
        {
            jagexDegree -= 2048;
        }

        while (jagexDegree < 0)
        {
            jagexDegree += 2048;
        }

        return jagexDegree;
    }
}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.swing.timesheet.keyframe.HealthKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.TextKeyFrame;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Model;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class HealthOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final SpriteManager spriteManager;

    private final int MODEL_HEIGHT_BUFFER = 18;
    private final int Y_BUFFER = -1;
    private final int TEXT_BUFFER = -12;
    private final int X_BUFFER = -1;

    @Inject
    private HealthOverlay(Client client, CreatorsPlugin plugin, SpriteManager spriteManager)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.spriteManager = spriteManager;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        graphics.setFont(FontManager.getRunescapeSmallFont());

        ArrayList<com.creatorskit.Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            if (!character.isActive())
            {
                continue;
            }

            HealthKeyFrame healthKeyFrame = (HealthKeyFrame) character.getCurrentKeyFrame(KeyFrameType.HEALTH);
            if (healthKeyFrame == null)
            {
                continue;
            }

            CKObject ckObject = character.getCkObject();
            if (!ckObject.isActive())
            {
                continue;
            }

            LocalPoint lp = ckObject.getLocation();
            if (lp == null || !lp.isInScene())
            {
                continue;
            }

            BufferedImage redBar = spriteManager.getSprite(healthKeyFrame.getHealthbarSprite().getBackgroundSpriteID(), 0);
            if (redBar == null)
            {
                continue;
            }

            BufferedImage greenBar = spriteManager.getSprite(healthKeyFrame.getHealthbarSprite().getForegroundSpriteID(), 0);
            if (greenBar == null)
            {
                continue;
            }

            double duration = healthKeyFrame.getDuration();
            double startTick = healthKeyFrame.getTick();
            double currentTick = plugin.getCurrentTick();
            if (currentTick > duration + startTick)
            {
                continue;
            }

            double ratio = (double) healthKeyFrame.getCurrentHealth() / (double) healthKeyFrame.getMaxHealth();
            int barWidth = (int) (ratio * redBar.getWidth());
            if (barWidth == 0 && ratio > 0)
            {
                barWidth = 1;
            }

            if (barWidth > greenBar.getWidth())
            {
                barWidth = greenBar.getWidth();
            }

            Model model = ckObject.getModel();
            if (model == null)
            {
                continue;
            }

            model.calculateBoundsCylinder();
            int height = model.getModelHeight();

            int textBuffer = 0;
            TextKeyFrame textKeyFrame = (TextKeyFrame) character.getCurrentKeyFrame(KeyFrameType.TEXT);
            if (textKeyFrame != null)
            {
                double textDuration = textKeyFrame.getDuration();
                double textStartTick = textKeyFrame.getTick();
                if (currentTick <= textDuration + textStartTick)
                {
                    textBuffer = TEXT_BUFFER;
                }
            }

            Point base = Perspective.getCanvasImageLocation(client, lp, redBar, height + MODEL_HEIGHT_BUFFER);
            if (base == null)
            {
                continue;
            }

            Point p = new Point(base.getX() + X_BUFFER, base.getY() + Y_BUFFER + textBuffer);

            OverlayUtil.renderImageLocation(graphics, p, redBar);

            if (barWidth > 0)
            {
                BufferedImage subImage = greenBar.getSubimage(0, 0, barWidth, redBar.getHeight());
                OverlayUtil.renderImageLocation(graphics, p, subImage);
            }
        }

        return null;
    }
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class Coordinate
{
    private int column;
    private int row;
}

package com.creatorskit.programming;

import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.swing.timesheet.keyframe.MovementKeyFrame;
import net.runelite.api.Client;
import net.runelite.api.WorldView;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.util.Arrays;

public class MovementManager
{
    private Client client;
    private CreatorsConfig config;
    private PathFinder pathFinder;
    private static final int[] POH_REGIONS = new int[]{7257, 7513, 7514, 7769, 7770, 8025, 8026};
    private static final int[] GAUNTLET_REGIONS = new int[]{7512, 7768};

    @Inject
    public MovementManager(Client client, CreatorsConfig config, PathFinder pathFinder)
    {
        this.client = client;
        this.config = config;
        this.pathFinder = pathFinder;
    }

    public int[][] addProgramStep(MovementKeyFrame keyFrame, WorldView worldView, LocalPoint localPoint)
    {
        if (localPoint == null)
        {
            return new int[0][2];
        }

        if (useLocalLocations(worldView))
        {
            return addPOHStep(keyFrame, worldView, localPoint);
        }

        return addWorldStep(keyFrame, worldView, WorldPoint.fromLocalInstance(client, localPoint));
    }

    public int[][] addWorldStep(MovementKeyFrame keyFrame, WorldView worldView, WorldPoint worldPoint)
    {
        int[][] path = keyFrame.getPath();
        if (path.length == 0)
        {
            return new int[][]{new int[]{worldPoint.getX(), worldPoint.getY()}};
        }

        int[] lastStep = path[path.length - 1];
        int[][] stepsToAdd = pathFinder.findPath(worldView, new WorldPoint(lastStep[0], lastStep[1], worldView.getPlane()), worldPoint, config.movementAlgorithm());

        return ArrayUtils.addAll(path, stepsToAdd);
    }

    public int[][] addPOHStep(MovementKeyFrame keyFrame, WorldView worldView, LocalPoint localPoint)
    {
        int[][] path = keyFrame.getPath();
        if (path.length == 0)
        {
            return new int[][]{new int[]{localPoint.getSceneX(), localPoint.getSceneY()}};
        }

        int[] lastStep = path[path.length - 1];
        int[][] stepsToAdd = pathFinder.findPath(LocalPoint.fromScene(lastStep[0], lastStep[1], worldView), localPoint, config.movementAlgorithm());

        return ArrayUtils.addAll(path, stepsToAdd);
    }

    public static boolean useLocalLocations(WorldView worldView)
    {
        if (Arrays.stream(worldView.getMapRegions()).anyMatch(x -> Arrays.stream(POH_REGIONS).anyMatch(y -> y == x)))
        {
            return true;
        }

        if (Arrays.stream(worldView.getMapRegions()).anyMatch(x -> Arrays.stream(GAUNTLET_REGIONS).anyMatch(y -> y == x)))
        {
            return true;
        }

        return false;
    }
}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.swing.timesheet.keyframe.*;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatSprite;
import com.creatorskit.swing.timesheet.keyframe.settings.HitsplatVariant;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Model;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class HitsplatOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final SpriteManager spriteManager;

    private final int Y_BUFFER = -1;
    private final int X_BUFFER = -1;
    private final int[][] buffers = { {0, 0}, {0, -20}, {-15, -10}, {15, -10} };

    @Inject
    private HitsplatOverlay(Client client, CreatorsPlugin plugin, SpriteManager spriteManager)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.spriteManager = spriteManager;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            if (!character.isActive())
            {
                continue;
            }

            CKObject ckObject = character.getCkObject();
            if (!ckObject.isActive())
            {
                continue;
            }

            LocalPoint lp = ckObject.getLocation();
            if (lp == null || !lp.isInScene())
            {
                continue;
            }

            Model model = ckObject.getModel();
            if (model == null)
            {
                continue;
            }

            model.calculateBoundsCylinder();
            int height = model.getModelHeight();

            for (int e = 0; e < KeyFrameType.HITSPLAT_TYPES.length; e++)
            {
                KeyFrameType hitsplat = KeyFrameType.HITSPLAT_TYPES[e];
                KeyFrame kf = character.getCurrentKeyFrame(hitsplat);
                if (kf == null)
                {
                    continue;
                }

                HitsplatKeyFrame keyFrame = (HitsplatKeyFrame) kf;
                double duration = keyFrame.getDuration();
                if (duration == -1)
                {
                    duration = HitsplatKeyFrame.DEFAULT_DURATION;
                }

                double startTick = keyFrame.getTick();
                double currentTick = plugin.getCurrentTick();
                if (currentTick > duration + startTick)
                {
                    continue;
                }

                HitsplatSprite sprite = keyFrame.getSprite();
                HitsplatVariant variant = keyFrame.getVariant();
                sprite = getVariant(sprite, variant);

                int damage = keyFrame.getDamage();

                renderHitsplat(graphics, sprite, height, buffers[e][0], buffers[e][1], damage, lp);
            }
        }

        return null;
    }

    private void renderHitsplat(Graphics2D graphics, HitsplatSprite sprite, int height, int xBuffer, int yBuffer, int damage, LocalPoint lp)
    {
        if (sprite == HitsplatSprite.NONE)
        {
            return;
        }

        BufferedImage spriteImage = spriteManager.getSprite(sprite.getSpriteID(), 0);
        if (spriteImage == null)
        {
            return;
        }

        int width = spriteImage.getWidth();

        Point base = Perspective.getCanvasImageLocation(client, lp, spriteImage, height / 2);
        if (base == null)
        {
            return;
        }

        Point p = new Point(base.getX() + xBuffer, base.getY() + yBuffer + Y_BUFFER);
        OverlayUtil.renderImageLocation(graphics, p, spriteImage);

        if (damage == -1)
        {
            return;
        }

        String text = "" + damage;
        FontMetrics metrics = graphics.getFontMetrics();
        int textHeight = metrics.getHeight() / 2;

        Point textPoint = Perspective.getCanvasTextLocation(client, graphics, lp, text, height / 2);

        int textXBuffer = 0;
        if (width % 2 == 0)
        {
            textXBuffer = X_BUFFER;
        }

        Point textP = new Point(textPoint.getX() + xBuffer + textXBuffer, textPoint.getY() + textHeight + yBuffer + Y_BUFFER);
        OverlayUtil.renderTextLocation(graphics, textP, text, Color.WHITE);
    }

    private HitsplatSprite getVariant(HitsplatSprite sprite, HitsplatVariant variant)
    {
        if (variant == null || variant == HitsplatVariant.NORMAL)
        {
            return sprite;
        }

        switch (sprite)
        {
            case BLOCK:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.BLOCK;
                    case OTHER:
                        return HitsplatSprite.BLOCK_OTHER;
                }
            case DAMAGE:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.DAMAGE_MAX;
                    case OTHER:
                        return HitsplatSprite.DAMAGE_OTHER;
                }
            case POISON:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.POISON_MAX;
                    case OTHER:
                        return HitsplatSprite.POISON_OTHER;
                }
            case VENOM:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.VENOM;
                    case OTHER:
                        return HitsplatSprite.VENOM_OTHER;
                }
            case SHIELD:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.SHIELD_MAX;
                    case OTHER:
                        return HitsplatSprite.SHIELD_OTHER;
                }
            case FREEZE:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.FREEZE;
                    case OTHER:
                        return HitsplatSprite.FREEZE_OTHER;
                }
            case ARMOUR:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.ARMOUR_MAX;
                    case OTHER:
                        return HitsplatSprite.ARMOUR;
                }
            case POISE:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.POISE_MAX;
                    case OTHER:
                        return HitsplatSprite.POISE_OTHER;
                }
            case PRAYER_DRAIN:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.PRAYER_DRAIN_MAX;
                    case OTHER:
                        return HitsplatSprite.PRAYER_DRAIN_OTHER;
                }
            case CHARGE_UP:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.CHARGE_UP;
                    case OTHER:
                        return HitsplatSprite.CHARGE_UP_OTHER;
                }
            case CHARGE_DOWN:
                switch (variant)
                {
                    case MAX:
                        return HitsplatSprite.CHARGE_DOWN;
                    case OTHER:
                        return HitsplatSprite.CHARGE_DOWN_OTHER;
                }
        }

        return sprite;
    }
}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.OverheadKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.TextKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.settings.OverheadSprite;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;

public class OverheadOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final SpriteManager spriteManager;

    private final int HEIGHT_BUFFER = 18;
    private final int OVERHEAD_Y_BUFFER = -18;
    private final int SKULL_Y_BUFFER = -25;
    private final int TEXT_BUFFER = -12;
    private final int X_BUFFER = -1;

    @Inject
    private OverheadOverlay(Client client, CreatorsPlugin plugin, SpriteManager spriteManager)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.spriteManager = spriteManager;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            if (!character.isActive())
            {
                continue;
            }

            OverheadKeyFrame overheadKeyFrame = (OverheadKeyFrame) character.getCurrentKeyFrame(KeyFrameType.OVERHEAD);
            if (overheadKeyFrame == null)
            {
                continue;
            }

            OverheadSprite prayerSprite = overheadKeyFrame.getPrayerSprite();
            OverheadSprite skullSprite = overheadKeyFrame.getSkullSprite();
            if (prayerSprite == OverheadSprite.NONE && skullSprite == OverheadSprite.NONE)
            {
                continue;
            }

            CKObject ckObject = character.getCkObject();
            if (!ckObject.isActive())
            {
                continue;
            }

            LocalPoint lp = ckObject.getLocation();
            if (lp == null || !lp.isInScene())
            {
                continue;
            }

            BufferedImage icon = spriteManager.getSprite(prayerSprite.getSpriteID(), prayerSprite.getFile());
            if (icon == null)
            {
                continue;
            }

            Model model = ckObject.getModel();
            if (model == null)
            {
                continue;
            }

            model.calculateBoundsCylinder();
            int height = model.getModelHeight();

            int textBuffer = 0;
            TextKeyFrame textKeyFrame = (TextKeyFrame) character.getCurrentKeyFrame(KeyFrameType.TEXT);
            if (textKeyFrame != null)
            {
                double duration = textKeyFrame.getDuration();
                double startTick = textKeyFrame.getTick();
                double currentTick = plugin.getCurrentTick();
                if (currentTick <= duration + startTick)
                {
                    textBuffer = TEXT_BUFFER;
                }
            }

            Point base = Perspective.getCanvasImageLocation(client, lp, icon, height + HEIGHT_BUFFER);
            if (base == null)
            {
                continue;
            }

            int skullBuffer = 0;
            if (skullSprite != OverheadSprite.NONE)
            {
                Point p = new Point(base.getX() + X_BUFFER, base.getY() + OVERHEAD_Y_BUFFER + textBuffer);
                skullBuffer = SKULL_Y_BUFFER;
                BufferedImage skull = spriteManager.getSprite(skullSprite.getSpriteID(), skullSprite.getFile());
                OverlayUtil.renderImageLocation(graphics, p, skull);
            }

            if (prayerSprite != OverheadSprite.NONE)
            {
                Point p = new Point(base.getX() + X_BUFFER, base.getY() + OVERHEAD_Y_BUFFER + skullBuffer + textBuffer);
                OverlayUtil.renderImageLocation(graphics, p, icon);
            }
        }

        return null;
    }
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum MovementType
{
    NORMAL("Normal"),
    WATERBORNE("Waterborne"),
    GHOST("Ghost")
    ;

    String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.programming;

public enum AnimationType
{
    ACTIVE,
    POSE
}

package com.creatorskit.programming;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum Direction
{
    UNSET("Unset", 0),
    NORTH("North", 1024),
    SOUTH("South", 0),
    EAST("East", 1536),
    WEST("West", 512),
    NORTHEAST("North-East", 1280),
    NORTHWEST("North-West", 768),
    SOUTHEAST("South-East", 1792),
    SOUTHWEST("South_West", 256)
    ;

    private String name;
    private int jUnit;

    public static Direction getDirection(int changeX, int changeY)
    {
        switch (changeX)
        {
            case -1:
                switch (changeY)
                {
                    case -1:
                        return SOUTHWEST;
                    case 0:
                        return WEST;
                    case 1:
                        return NORTHWEST;
                }
            case 0:
                switch (changeY)
                {
                    case -1:
                        return SOUTH;
                    case 1:
                        return NORTH;
                }
            case 1:
                switch (changeY)
                {
                    case -1:
                        return SOUTHEAST;
                    case 0:
                        return EAST;
                    case 1:
                        return NORTHEAST;
                }
        }

        return UNSET;
    }

    public static Direction[] getAllDirections()
    {
        return new Direction[]{NORTH, EAST, SOUTH, WEST, NORTHEAST, NORTHWEST, SOUTHEAST, SOUTHWEST};
    }

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.programming;

import com.creatorskit.programming.orientation.OrientationAction;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.LocalPoint;

@AllArgsConstructor
@Getter
@Setter
public class MovementComposition
{
    private boolean moving;
    private LocalPoint localPoint;
    private OrientationAction orientationAction;
    private int orientationGoal;
    private int orientationToSet;
}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.TextKeyFrame;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;

public class TextOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final int TEXT_BUFFER = 4;

    @Inject
    private TextOverlay(Client client, CreatorsPlugin plugin)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        graphics.setFont(FontManager.getRunescapeBoldFont());

        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            if (!character.isActive())
            {
                continue;
            }

            TextKeyFrame textKeyFrame = (TextKeyFrame) character.getCurrentKeyFrame(KeyFrameType.TEXT);
            if (textKeyFrame == null)
            {
                continue;
            }

            CKObject ckObject = character.getCkObject();
            if (!ckObject.isActive())
            {
                continue;
            }

            LocalPoint lp = ckObject.getLocation();
            if (lp == null || !lp.isInScene())
            {
                continue;
            }

            double duration = textKeyFrame.getDuration();
            double startTick = textKeyFrame.getTick();
            double currentTick = plugin.getCurrentTick();
            if (currentTick > duration + startTick)
            {
                continue;
            }

            String text = textKeyFrame.getText();
            if (text.isEmpty())
            {
                continue;
            }

            Model model = ckObject.getModel();
            if (model == null)
            {
                continue;
            }

            model.calculateBoundsCylinder();
            int height = model.getModelHeight();

            Point point = Perspective.getCanvasTextLocation(client, graphics, lp, text, height);
            if (point == null)
            {
                continue;
            }

            Point p = new Point(point.getX(), point.getY() + TEXT_BUFFER);
            OverlayUtil.renderTextLocation(graphics, p, text, Color.YELLOW);
        }

        return null;
    }
}
package com.creatorskit.programming;

import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Animation;
import net.runelite.api.AnimationController;
import net.runelite.api.Client;

public class CKAnimationController extends AnimationController
{
    @Getter
    @Setter
    private boolean loop;

    @Getter
    @Setter
    private boolean finished;

    public CKAnimationController(Client client, int animationID, boolean loop)
    {
        super(client, animationID);
        this.loop = loop;
    }

    public CKAnimationController(Client client, Animation animation, boolean loop)
    {
        super(client, animation);
        this.loop = loop;
    }
}

package com.creatorskit.programming.orientation;

public enum OrientationGoal
{
    POINT,
    FOLLOW
}

package com.creatorskit.programming.orientation;

import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class OrientationInstruction
{
    private KeyFrameType type;
    private boolean setOrientation;
}

package com.creatorskit.programming.orientation;

import net.runelite.api.coords.LocalPoint;

public class Orientation
{
    public static int orientationX(double orientation)
    {
        int direction = simplifyOrientation((int) orientation);
        if (direction == 1280 || direction == 1536 || direction == 1792)
        {
            return 1;
        }

        if (direction == 256 || direction == 512 || direction == 768)
        {
            return -1;
        }

        return 0;
    }

    public static int orientationY(double orientation)
    {
        int direction = simplifyOrientation((int) orientation);
        if (direction == 768 || direction == 1024 || direction == 1280)
        {
            return 1;
        }

        if (direction == 256 || direction == 0 || direction == 2048 || direction == 1792)
        {
            return -1;
        }

        return 0;
    }

    public static double radiansToJAngle(double radians, double changeX, double changeY)
    {
        double angle = radians * 1024 / Math.PI;
        if (changeX > 0 && changeY > 0)
        {
            angle = 1536 - angle;
            return angle;
        }

        if (changeX < 0 && changeY > 0)
        {
            angle = 512 - angle;
            return angle;
        }

        if (changeX < 0 && changeY < 0)
        {
            angle = 512 - angle;
            return angle;
        }

        if (changeX > 0 && changeY < 0)
        {
            angle = 1536 - angle;
            return angle;
        }

        if (changeX == 0 && changeY > 0)
        {
            return 1024;
        }

        if (changeX == 0 && changeY < 0)
        {
            return 0;
        }

        if (changeX > 0 && changeY == 0)
        {
            return 1536;
        }

        if (changeX < 0 && changeY == 0)
        {
            return 512;
        }

        return angle;
    }

    public static int simplifyOrientation(int orientation)
    {
        orientation = boundOrientation(orientation);

        if (orientation == 0 || orientation == 512 || orientation == 1024 || orientation == 1536 || orientation == 2048)
        {
            return orientation;
        }

        if (orientation > 0 && orientation < 512)
        {
            return 256;
        }

        if (orientation > 512 && orientation < 1024)
        {
            return 768;
        }

        if (orientation > 1024 && orientation < 1536)
        {
            return 1280;
        }

        if (orientation > 1536 && orientation < 2048)
        {
            return 1792;
        }

        return 0;
    }

    public static int subtract(int first, int second)
    {
        int product = boundOrientation(first - second);
        if (product > 1024)
        {
            return (2048 - product) * -1;
        }

        if (product < -1024)
        {
            return 2048 + product;
        }

        return product;
    }

    public static int boundOrientation(int orientation)
    {
        while (orientation >= 2048)
        {
            orientation -= 2048;
        }

        while (orientation < 0)
        {
            orientation += 2048;
        }

        return orientation;
    }

    public static double getAngleBetween(LocalPoint firstPoint, LocalPoint secondPoint)
    {
        int secondX = secondPoint.getX();
        int secondY = secondPoint.getY();
        int firstX = firstPoint.getX();
        int firstY = firstPoint.getY();
        double differenceX = secondX - firstX;
        double differenceY = secondY - firstY;
        return Orientation.radiansToJAngle(Math.atan(differenceY / differenceX), differenceX, differenceY);
    }
}

package com.creatorskit.programming.orientation;

public enum OrientationHotkeyMode
{
    SET_START,
    SET_GOAL
}

package com.creatorskit.programming.orientation;

public enum OrientationAction
{
    FREEZE,
    SET,
    ADJUST
}

package com.creatorskit.programming;

import com.creatorskit.*;
import com.creatorskit.Character;
import com.creatorskit.models.*;
import com.creatorskit.models.datatypes.SpotanimData;
import com.creatorskit.programming.orientation.Orientation;
import com.creatorskit.programming.orientation.OrientationAction;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.programming.orientation.OrientationInstruction;
import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ClientTick;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.eventbus.Subscribe;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;

public class Programmer
{
    private final Client client;
    private final ClientThread clientThread;
    private final CreatorsPlugin plugin;
    private final TimeSheetPanel timeSheetPanel;
    private final DataFinder dataFinder;
    private int clientTickAtLastProgramTick = 0;
    private final int GOLDEN_CHIN = 29757;
    private final int TILE_LENGTH = 128;
    private final int TILE_DIAGONAL = 181; //Math.sqrt(Math.pow(128, 2) + Math.pow(128, 2))

    @Getter
    @Setter
    private boolean playing = false;
    private boolean triggerPause = false;

    @Inject
    public Programmer(Client client, ClientThread clientThread, CreatorsPlugin plugin, TimeSheetPanel timeSheetPanel, DataFinder dataFinder)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.plugin = plugin;
        this.timeSheetPanel = timeSheetPanel;
        this.dataFinder = dataFinder;
    }

    @Subscribe
    public void onClientTick(ClientTick event)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (playing)
        {
            clientTickAtLastProgramTick++;
            if (clientTickAtLastProgramTick >= 3)
            {
                clientTickAtLastProgramTick = 0;
                incrementSubTime();
            }

            updateCharacter3D();
            if (clientTickAtLastProgramTick == 0 && triggerPause)
            {
                pause();
            }
        }
    }

    private void updateCharacter3D()
    {
        WorldView worldView = client.getTopLevelWorldView();
        double currentClientTick = (timeSheetPanel.getCurrentTime() * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH) + clientTickAtLastProgramTick;

        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            CKObject ckObject = character.getCkObject();
            if (ckObject == null)
            {
                character.setInScene(false);
                continue;
            }

            KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
            if (kf == null)
            {
                transform3D(worldView, character, currentClientTick);
                continue;
            }

            MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
            if (keyFrame.getPlane() != worldView.getPlane())
            {
                character.setInScene(false);
                continue;
            }

            int[][] path = keyFrame.getPath();
            int currentStep = keyFrame.getCurrentStep();
            int pathLength = path.length;
            if (currentStep >= pathLength || currentStep == -1)
            {
                transform3D(worldView, character, currentClientTick);
                continue;
            }

            double tileSpeed = keyFrame.getSpeed();
            double speed = tileSpeed * Constants.CLIENT_TICK_LENGTH / Constants.GAME_TICK_LENGTH;
            int clientTicksPassed = client.getGameCycle() - keyFrame.getStepClientTick();
            double stepsComplete = clientTicksPassed * speed;
            currentStep = (int) Math.floor(stepsComplete);

            double endSpeed = (pathLength - 1) - (Math.floor(((pathLength - 1) / tileSpeed)) * tileSpeed);
            double finalSpeed = tileSpeed;

            if (stepsComplete + endSpeed > pathLength - 1)
            {
                double jumps = (pathLength - 1) % tileSpeed;
                if (jumps != 0)
                {
                    double ticksPreSlowdown = (pathLength - 1 - endSpeed) / tileSpeed;
                    double stepsPreSlowdown = ticksPreSlowdown * tileSpeed;

                    stepsComplete = ((clientTicksPassed) - (ticksPreSlowdown * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH)) * endSpeed * Constants.CLIENT_TICK_LENGTH / Constants.GAME_TICK_LENGTH + stepsPreSlowdown;
                    currentStep = (int) (stepsComplete);
                    finalSpeed = endSpeed;
                }
            }

            if (currentStep > pathLength)
            {
                currentStep = pathLength;
            }

            keyFrame.setCurrentStep(currentStep);

            transform3D(worldView, character, keyFrame, OrientationAction.ADJUST, currentStep, stepsComplete, clientTicksPassed, currentClientTick, finalSpeed);
        }
    }

    /**
     * Transforms the Character by Animation, Orientation, and based on its next MovementKeyFrame. For intended use when no current MovementKeyFrame exists
     * @param character the Character to animate
     */
    public void transform3D(WorldView worldView, Character character, double currentClientTick)
    {
        if (!playing)
        {
            KeyFrame mkf = character.findNextKeyFrame(KeyFrameType.MOVEMENT, timeSheetPanel.getCurrentTime());
            KeyFrame okf = character.findPreviousKeyFrame(KeyFrameType.ORIENTATION, timeSheetPanel.getCurrentTime(), true);

            if (okf == null)
            {
                okf = character.findNextKeyFrame(KeyFrameType.ORIENTATION, timeSheetPanel.getCurrentTime());
            }

            if (mkf == null && okf == null)
            {
                setAnimation(character, false, 0, 0);
                setOrientation(character, currentClientTick);
                plugin.setLocation(character, false, false, ActiveOption.UNCHANGED, LocationOption.TO_SAVED_LOCATION);
                return;
            }

            boolean useMovement = false;

            if (mkf == null)
            {
                useMovement = false;
            }

            if (okf == null)
            {
                useMovement = true;
            }

            if (mkf != null && okf != null)
            {
                useMovement = !(okf.getTick() <= mkf.getTick());
            }

            if (useMovement)
            {
                MovementKeyFrame keyFrame = (MovementKeyFrame) mkf;
                transform3D(worldView, character, keyFrame, OrientationAction.SET, 0, 0, 0, 0, 0);
                return;
            }

            setAnimation(character, false, 0, 0);
            setOrientationStatic(character);
            plugin.setLocation(character, false, false, ActiveOption.UNCHANGED, LocationOption.TO_SAVED_LOCATION);
            return;
        }

        setAnimation(character, false, 0, 0);
        setOrientation(character, currentClientTick);
    }

    /**
     * Transforms the Character's 3D model, by location with the intent to move it to the next subtile based on its current location and the predefined path,
     * by orientation to align with the current trajectory, and by animation according to what idle pose should be playing based on the direction of motion and orientation.
     * For intended use when playing the Programmer, not when setting the time manually
     * @param worldView the current worldview
     * @param character the Character to transform
     * @param mkf the MovementKeyFrame from which the location is being drawn
     * @param orientationAction indicate whether to set, adjust, or freeze orientation
     * @param currentStep the number of whole steps that have already been performed
     * @param stepsComplete the number of whole + sub steps that have already been performed
     * @param clientTicksPassed the number of client ticks that have passed since the start of the keyframe
     * @param finalSpeed the speed of the keyframe
     */
    public void transform3D(WorldView worldView, Character character, MovementKeyFrame mkf, OrientationAction orientationAction, int currentStep, double stepsComplete, int clientTicksPassed, double currentClientTick, double finalSpeed)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            character.setInScene(false);
            return;
        }

        if (mkf.getPlane() != worldView.getPlane())
        {
            character.setInScene(false);
            return;
        }

        double turnRate = mkf.getTurnRate();

        MovementComposition mc = getMovementComposition(worldView, character, mkf, currentStep, stepsComplete, orientationAction, clientTicksPassed, turnRate);
        if (mc == null)
        {
            character.setInScene(false);
            setAnimation(character, false, 0, 0);
            setOrientation(character, currentClientTick);
            return;
        }

        character.setInScene(true);
        setLocation(character, mkf, mc);

        int orientation = ckObject.getOrientation();
        int orientationGoal = mc.getOrientationGoal();
        int difference = Orientation.subtract(orientationGoal, orientation);

        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ORIENTATION);
        if (kf == null)
        {
            setOrientation(character, mc, orientationGoal, difference, stepsComplete, turnRate);
            setAnimation(character, mc.isMoving(), difference, finalSpeed);
            return;
        }

        OrientationKeyFrame okf = (OrientationKeyFrame) kf;
        OrientationInstruction instruction = findLastOrientation(mkf, okf, currentClientTick);
        if (instruction.getType() == KeyFrameType.ORIENTATION)
        {
            setOrientation(character, currentClientTick);
            setAnimation(character, mc.isMoving(), difference, finalSpeed);
            return;
        }

        if (instruction.isSetOrientation())
        {
            mc.setOrientationAction(OrientationAction.SET);
        }

        setOrientation(character, mc, orientationGoal, difference, stepsComplete, turnRate);
        setAnimation(character, mc.isMoving(), difference, finalSpeed);
    }

    private OrientationInstruction findLastOrientation(MovementKeyFrame mkf, OrientationKeyFrame okf, double clientTicksForCurrentTime)
    {
        double oriEndClientTick = (okf.getTick() + okf.getDuration()) * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

        if (clientTicksForCurrentTime <= oriEndClientTick)
        {
            return new OrientationInstruction(KeyFrameType.ORIENTATION, false);
        }

        double pathDuration = Math.ceil((mkf.getPath().length - 1) / mkf.getSpeed());
        double movementEndTick = (mkf.getTick() + pathDuration) * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

        if (oriEndClientTick >= movementEndTick)
        {
            return new OrientationInstruction(KeyFrameType.ORIENTATION, false);
        }

        boolean setOrientation = Math.round(clientTicksForCurrentTime - oriEndClientTick) == 1;
        return new OrientationInstruction(KeyFrameType.MOVEMENT, setOrientation);
    }


    /**
     * Transforms the Character's 3D model, by location according to the last MovementKeyFrame, by orientation based on the last OrientationKeyFrame (or MovementKeyFrame, if later),
     * and by animation according to what idle pose should be playing based on the direction of motion and orientation.
     * For intended use when setting the keyframe manually
     * @param worldView the current worldview
     * @param character the Character to transform
     * @param mkf the MovementKeyFrame from which the location is being drawn
     * @param currentStep the number of whole steps that have already been performed
     * @param stepsComplete the number of whole + sub steps that have already been performed
     * @param clientTicksPassed the number of client ticks that have passed since the start of the keyframe
     * @param finalSpeed the speed of the keyframe
     */
    public void transform3DStatic(WorldView worldView, Character character, MovementKeyFrame mkf, int currentStep, double stepsComplete, int clientTicksPassed, double finalSpeed)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            character.setInScene(false);
            return;
        }

        if (mkf.getPlane() != worldView.getPlane())
        {
            character.setInScene(false);
            return;
        }

        double turnRate = mkf.getTurnRate();

        MovementComposition mc = getMovementComposition(worldView, character, mkf, currentStep, stepsComplete, OrientationAction.SET, clientTicksPassed, turnRate);

        int orientation = ckObject.getOrientation();
        int orientationGoal = 0;
        int difference = 0;
        int differenceToGoal = 0;
        boolean isMoving = false;

        if (mc == null)
        {
            character.setInScene(false);
            setAnimation(character, false, 0, 0);
        }
        else
        {
            character.setInScene(true);
            setLocation(character, mkf, mc);
            orientationGoal = mc.getOrientationGoal();
            difference = Orientation.subtract(orientationGoal, orientation);
            differenceToGoal = Orientation.subtract(mc.getOrientationToSet(), orientation);
            isMoving = mc.isMoving();
        }

        KeyFrameType orientationDeterminant = findLastOrientation(character);

        if (orientationDeterminant == KeyFrameType.ORIENTATION)
        {
            setOrientationStatic(character);
            setAnimation(character, isMoving, differenceToGoal, finalSpeed);
            return;
        }

        if (orientationDeterminant == KeyFrameType.MOVEMENT)
        {
            if (mc == null)
            {
                setAnimation(character, false, 0, 0);
                return;
            }

            setOrientation(character, mc, orientationGoal, difference, stepsComplete, turnRate);
            orientation = ckObject.getOrientation();
            difference = Orientation.subtract(orientationGoal, orientation);
            setAnimation(character, mc.isMoving(), difference, finalSpeed);
            return;
        }

        setAnimation(character, false, 0, 0);
    }

    /**
     * Sets the location if a Movement keyframe is present
     * @param character the character to set the location for
     * @param keyFrame the Movement keyframe of interest
     * @param mc the MovementComposition regarding the current character's intended location
     */
    private void setLocation(Character character, MovementKeyFrame keyFrame, MovementComposition mc)
    {
        LocalPoint lp = mc.getLocalPoint();
        if (lp == null)
        {
            return;
        }

        character.setLocation(lp, keyFrame.getPlane());
    }

    /**
     * Sets the orientation of the Character based on its Orientation KeyFrame
     * Intended for use when playing the programmer
     * @param character the character to modify
     * @param currentClientTick the current time, in client ticks
     */
    private void setOrientation(Character character, double currentClientTick)
    {
        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ORIENTATION);
        if (kf == null)
        {
            return;
        }

        OrientationKeyFrame keyFrame = (OrientationKeyFrame) kf;
        double ticksPassed = currentClientTick - (keyFrame.getTick() * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH);
        double duration = keyFrame.getDuration() * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;
        if (ticksPassed > duration)
        {
            return;
        }

        int orientation = getOrientation(keyFrame, ticksPassed, duration);
        character.setOrientation(orientation);
    }

    /**
     * Gets the current intended orientation of the Character, assuming that no movement keyframe exists, or the last movement keyframe has ended.
     * Intended for use when playing the programmer
     * @param keyFrame the Orientation keyframe of interest
     * @param ticksPassed the current time, in client ticks
     * @param duration the keyframe duration, in client ticks
     * @return the orientation the Character should be set to
     */
    private int getOrientation(OrientationKeyFrame keyFrame, double ticksPassed, double duration)
    {
        if (ticksPassed > duration)
        {
            ticksPassed = duration;
        }

        int start = keyFrame.getStart();
        int end = keyFrame.getEnd();

        int difference = Orientation.subtract(end, start);
        double turnRate = keyFrame.getTurnRate();

        double rotation = turnRate * ticksPassed;

        int newOrientation;
        if (difference > (rotation * -1) && difference < rotation)
        {
            newOrientation = end;
        }
        else if (difference > 0)
        {
            newOrientation = Orientation.boundOrientation((int) (start + rotation));
        }
        else
        {
            newOrientation = Orientation.boundOrientation((int) (start - rotation));
        }

        return newOrientation;
    }

    /**
     * Sets the orientation of the Character based on its Orientation KeyFrame
     * Intended for use when manually setting the program time
     * @param character the character to modify
     */
    private void setOrientationStatic(Character character)
    {
        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ORIENTATION);
        if (kf == null)
        {
            int orientation = (int) character.getOrientationSpinner().getValue();
            character.setOrientation(orientation);
            return;
        }

        OrientationKeyFrame keyFrame = (OrientationKeyFrame) kf;
        int orientation = getOrientationStatic(keyFrame);
        character.setOrientation(orientation);
    }

    /**
     * Gets the orientation dictated by the current OrientationKeyFrame for the current tick. Intended for use when setting the time, not running the program
     * @param keyFrame the keyframe to examine
     * @return the appropriate orientation for the given keyframe
     */
    public int getOrientationStatic(OrientationKeyFrame keyFrame)
    {
        double ticksPassed = timeSheetPanel.getCurrentTime() - keyFrame.getTick();
        double duration = keyFrame.getDuration();
        if (ticksPassed > duration)
        {
            ticksPassed = duration;
        }

        int start = keyFrame.getStart();
        int end = keyFrame.getEnd();

        int difference = Orientation.subtract(end, start);
        double turnRate = keyFrame.getTurnRate();

        double rotation = turnRate * ticksPassed * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH;

        int newOrientation;
        if (difference > (rotation * -1) && difference < rotation)
        {
            newOrientation = end;
        }
        else if (difference > 0)
        {
            newOrientation = Orientation.boundOrientation((int) (start + rotation));
        }
        else
        {
            newOrientation = Orientation.boundOrientation((int) (start - rotation));
        }

        return newOrientation;
    }

    /**
     * Sets the orientation of the character based on its movement keyframe
     * Intended for use while playing the programmer
     * @param character the character to modify
     * @param mc the MovementComposition, based on its movement keyframe
     * @param orientationGoal the orientation end-goal, determined by the trajectory of movement
     * @param difference the difference between the current orientation and end goal orientation
     * @param stepsComplete the number of steps complete
     * @param turnRate the rate at which the Character should turn
     */
    private void setOrientation(Character character, MovementComposition mc, int orientationGoal, int difference, double stepsComplete, double turnRate)
    {
        OrientationAction orientationAction = mc.getOrientationAction();
        CKObject ckObject = character.getCkObject();
        if (orientationAction == OrientationAction.SET)
        {
            if (ckObject.getOrientation() != orientationGoal)
            {
                character.setOrientation(orientationGoal);
            }

            return;
        }

        if (orientationAction == OrientationAction.FREEZE)
        {
            return;
        }

        if (difference != 0)
        {
            if (Math.ceil(stepsComplete) == Math.floor(stepsComplete))
            {
                return;
            }

            int orientation = ckObject.getOrientation();
            int turnSpeed = (int) (turnRate);

            int newOrientation;
            if (difference > (turnSpeed * -1) && difference < turnSpeed)
            {
                newOrientation = orientationGoal;
            }
            else if (difference > 0)
            {
                newOrientation = Orientation.boundOrientation(orientation + turnSpeed);
            }
            else
            {
                newOrientation = Orientation.boundOrientation(orientation - turnSpeed);
            }

            character.setOrientation(newOrientation);
        }
    }

    private void setAnimation(Character character, boolean isMoving, int orientationDifference, double speed)
    {
        CKObject ckObject = character.getCkObject();

        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ANIMATION);
        if (kf == null)
        {
            int animId = (int) character.getAnimationSpinner().getValue();
            Animation animation = ckObject.getAnimations()[0];
            if (animation == null || animation.getId() != animId)
            {
                plugin.setAnimation(character, animId);
            }
            return;
        }

        AnimationKeyFrame keyFrame = (AnimationKeyFrame) kf;
        int active = keyFrame.getActive();
        int pose = getPoseAnimation(keyFrame, isMoving, orientationDifference, speed);
        int poseStartFrame = 0;
        if (pose == keyFrame.getIdle() || pose == keyFrame.getWalk() || pose == keyFrame.getRun())
        {
            poseStartFrame = keyFrame.getStartFrame();
        }

        int finalPoseStartFrame = poseStartFrame;
        clientThread.invoke(() ->
        {
            Animation currentPose = ckObject.getAnimations()[1];

            if (pose == -1)
            {
                if (currentPose != null && currentPose.getId() != -1)
                {
                    ckObject.unsetAnimation(AnimationType.POSE);
                }
            }

            if (pose != -1)
            {
                if (currentPose == null || currentPose.getId() != pose)
                {
                    ckObject.setAnimation(AnimationType.POSE, pose);
                    ckObject.setAnimationFrame(AnimationType.POSE, finalPoseStartFrame, false);
                }

                if (!playing)
                {
                    setPoseAnimationFrame(ckObject, timeSheetPanel.getCurrentTime(), keyFrame.getTick(), finalPoseStartFrame);
                }
            }
        });
    }

    private int getPoseAnimation(AnimationKeyFrame keyFrame, boolean isMoving, int orientationDifference, double speed)
    {
        if (speed == 0 || !isMoving)
        {
            return keyFrame.getIdle();
        }

        int idle = keyFrame.getIdle();
        int move = keyFrame.getWalk();
        int run = keyFrame.getRun();
        if (speed > 1 && run != -1)
        {
            move = keyFrame.getRun();
        }

        if (orientationDifference <= 256 && orientationDifference >= -256)
        {
            if (move == -1)
            {
                return idle;
            }

            return move;
        }

        if (orientationDifference > 256 && orientationDifference < 736)
        {
            int animId = keyFrame.getWalkRight();
            if (animId == -1)
            {
                if (move == -1)
                {
                    return idle;
                }

                return move;
            }

            return animId;
        }

        if (orientationDifference < -256 && orientationDifference > -736)
        {
            int animId = keyFrame.getWalkLeft();
            if (animId == -1)
            {
                if (move == -1)
                {
                    return idle;
                }

                return move;
            }

            return animId;
        }

        int animId = keyFrame.getWalk180();
        if (animId == -1)
        {
            if (move == -1)
            {
                return idle;
            }

            return move;
        }

        return animId;
    }

    /**
     * Gets the LocalPoint corresponding to the exact tick for the current time, including both full tile and sub tile coordinates.
     * @param worldView the current WorldView
     * @param character the character to find the location for
     * @param keyFrame the keyframe from the character to get the path from
     * @param currentStep the current whole number step
     * @param stepsComplete the current non-whole number step
     * @return the LocalPoint corresponding to the current tick along the character's currently defined path
     */
    public MovementComposition getMovementComposition(WorldView worldView, Character character, MovementKeyFrame keyFrame, int currentStep, double stepsComplete, OrientationAction orientationAction, int clientTicksPassed, double turnRate)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            return null;
        }

        int pathLength = keyFrame.getPath().length;
        if (currentStep >= pathLength)
        {
            LocalPoint secondLast = getLocation(worldView, keyFrame, pathLength - 2);
            LocalPoint last = getLocation(worldView, keyFrame, pathLength - 1);
            if (last == null)
            {
                return null;
            }

            if (secondLast == null)
            {
                return new MovementComposition(false, last, OrientationAction.FREEZE, 0, 0);
            }

            double directionX = last.getSceneX() - secondLast.getSceneX();
            double directionY = last.getSceneY() - secondLast.getSceneY();
            double angle = Orientation.radiansToJAngle(Math.atan(directionY / directionX), directionX, directionY);
            return new MovementComposition(false, last, OrientationAction.SET, (int) angle, 0);
        }

        LocalPoint previous = getLocation(worldView, keyFrame, currentStep - 1);
        LocalPoint start = getLocation(worldView, keyFrame, currentStep);
        LocalPoint destination = getLocation(worldView, keyFrame, currentStep + 1);

        if (start == null && destination == null)
        {
            return null;
        }

        if (start != null && destination != null)
        {
            double percentComplete = stepsComplete - currentStep;
            double subSteps = percentComplete * TILE_LENGTH;

            double angle = Orientation.getAngleBetween(start, destination);
            int startX = start.getX();
            int startY = start.getY();

            int changeX = (int) (subSteps * Orientation.orientationX(angle));
            int currentX = startX + changeX;

            int changeY = (int) (subSteps * Orientation.orientationY(angle));
            int currentY = startY + changeY;

            LocalPoint lp = new LocalPoint(currentX, currentY, worldView);
            if (orientationAction == OrientationAction.ADJUST)
            {
                return new MovementComposition(true, lp, OrientationAction.ADJUST, (int) angle, 0);
            }

            //Only relevant when OrientationAction.SET, in other words, when setting the time manually and not playing
            int orientationFromTick = getOrientationFromTick(previous, start, angle, clientTicksPassed, currentStep, keyFrame.getSpeed(), turnRate);
            return new MovementComposition(true, lp, OrientationAction.SET, orientationFromTick, (int) angle);
        }

        if (start == null)
        {
            if (previous == null)
            {
                return new MovementComposition(false, destination, OrientationAction.FREEZE, 0, 0);
            }

            double directionX = destination.getSceneX() - previous.getSceneX();
            double directionY = destination.getSceneY() - previous.getSceneY();
            double angle = Orientation.radiansToJAngle(Math.atan(directionY / directionX), directionX, directionY);

            return new MovementComposition(false, destination, orientationAction, (int) angle, 0);
        }

        if (previous == null)
        {
            return new MovementComposition(false, start, OrientationAction.FREEZE, 0, 0);
        }

        double angle = Orientation.getAngleBetween(previous, start);
        return new MovementComposition(false, start, OrientationAction.SET, (int) angle, 0);
    }

    private int getOrientationFromTick(LocalPoint previous, LocalPoint start, double angle, int clientTicksPassed, int currentStep, double speed, double turnRate)
    {
        if (previous == null)
        {
            return (int) angle;
        }

        double originalAngle = Orientation.getAngleBetween(previous, start);


        int angleDifference = Orientation.subtract((int) angle, (int) originalAngle);
        if (angleDifference == 0)
        {
            return (int) angle;
        }

        double ticksSinceLastStep = (clientTicksPassed * speed) - (((double) currentStep) * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH);
        double change = turnRate * ticksSinceLastStep;

        if (angleDifference > (change * -1) && angleDifference < change)
        {
            return (int) angle;
        }

        if (angleDifference > 0)
        {
            return Orientation.boundOrientation((int) (originalAngle + change));
        }

        return Orientation.boundOrientation((int) (originalAngle - change));
    }



    /**
     * Gets the LocalPoint of a specific integer step. Used primarily to assess the start and end tiles of a path in order to calculate the movement between
     * @param keyFrame the keyframe for which to grab the path
     * @param step the number of whole number steps complete
     * @return the LocalPoint pertaining to the current step for the keyframe
     */
    private LocalPoint getLocation(WorldView worldView, MovementKeyFrame keyFrame, int step)
    {
        boolean isInPOH = MovementManager.useLocalLocations(worldView);
        if (keyFrame.isPoh() != isInPOH)
        {
            return null;
        }

        int[][] path = keyFrame.getPath();
        if (step >= path.length || step < 0)
        {
            return null;
        }

        int[] currentStep = path[step];

        if (isInPOH)
        {
            LocalPoint lp = LocalPoint.fromScene(currentStep[0], currentStep[1], worldView);
            if (!lp.isInScene())
            {
                return null;
            }

            return lp;
        }

        WorldPoint wp = new WorldPoint(currentStep[0], currentStep[1], keyFrame.getPlane());
        if (worldView.isInstance())
        {
            Collection<WorldPoint> wps = WorldPoint.toLocalInstance(worldView, wp);
            if (!wps.isEmpty())
            {
                wp = wps.iterator().next();
            }
        }

        LocalPoint lp = LocalPoint.fromWorld(worldView, wp);
        if (lp == null || !lp.isInScene())
        {
            return null;
        }

        return lp;
    }

    private void incrementSubTime()
    {
        double time = TimeSheetPanel.round(timeSheetPanel.getCurrentTime() + 0.1);
        timeSheetPanel.setCurrentTime(time, true);
    }

    public void togglePlay()
    {
        togglePlay(!playing);
    }

    public void togglePlay(boolean play)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return;
        }

        if (play)
        {
            triggerPause = false;
            playing = true;
            timeSheetPanel.setPlayButtonIcon(true);
            double currentTime = timeSheetPanel.getCurrentTime();

            ArrayList<Character> characters = plugin.getCharacters();
            for (int i = 0; i < characters.size(); i++)
            {
                Character character = characters.get(i);

                character.play();
                character.resetMovementKeyFrame(client.getGameCycle(), currentTime);
            }
            return;
        }

        triggerPause = true;
    }

    public void pause()
    {
        triggerPause = false;
        playing = false;
        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            character.pause();
        }

        timeSheetPanel.setPlayButtonIcon(false);
    }

    /**
     * Updates the program with their current KeyFrame at the current time in the TimeSheetPanel
     * Intended for use adding or removing a KeyFrame from a specific Character
     */
    public void updateProgram(Character character)
    {
        updateProgram(character, timeSheetPanel.getCurrentTime());
    }

    /**
     * Updates the program with their current KeyFrame for the given time
     * Intended for use adding or removing a KeyFrame from a specific Character
     * @param character the character to update
     * @param tick the tick at which to look for KeyFrames
     */
    public void updateProgram(Character character, double tick)
    {
        character.updateProgram(tick);
        character.setPlaying(playing);
        registerSpotAnimChanges(character, KeyFrameType.SPOTANIM, tick);
        registerSpotAnimChanges(character, KeyFrameType.SPOTANIM2, tick);
        register3DChanges(character);
        registerActiveAnimationChanges(character);
        registerModelChanges(character);
        registerSpawnChanges(character);
    }

    /**
     * Loops through all Characters and updates their current KeyFrame for the given time
     * Intended for use when manually setting the current tick in the program
     * @param tick the tick at which to look for KeyFrames
     */
    public void updatePrograms(double tick)
    {
        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            updateProgram(characters.get(i), tick);
        }
    }

    /**
     * Loops through all Characters and updates their current KeyFrame for the current time in the TimeSheetPanel
     * Intended for use when Playing the programmer, not when manually setting the time
     */
    public void updateProgramsOnTick()
    {
        double currentTime = timeSheetPanel.getCurrentTime();
        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            KeyFrame[] currentFrames = character.getCurrentFrames();

            KeyFrame currentMovement = currentFrames[KeyFrameType.getIndex(KeyFrameType.MOVEMENT)];
            double lastMovementTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentMovement != null)
            {
                lastMovementTick = currentMovement.getTick();
            }

            KeyFrame nextMovement = character.findNextKeyFrame(KeyFrameType.MOVEMENT, lastMovementTick);
            if (nextMovement != null)
            {
                if (nextMovement.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextMovement, KeyFrameType.MOVEMENT);
                    character.resetMovementKeyFrame(client.getGameCycle(), currentTime);
                    register3DChanges(character);
                }
            }


            KeyFrame currentAnimation = currentFrames[KeyFrameType.getIndex(KeyFrameType.ANIMATION)];
            double lastAnimationTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentAnimation != null)
            {
                lastAnimationTick = currentAnimation.getTick();
            }

            KeyFrame nextAnimation = character.findNextKeyFrame(KeyFrameType.ANIMATION, lastAnimationTick);
            if (nextAnimation != null)
            {
                if (nextAnimation.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextAnimation, KeyFrameType.ANIMATION);
                    registerActiveAnimationChanges(character);
                }
            }


            KeyFrame currentSpawn = currentFrames[KeyFrameType.getIndex(KeyFrameType.SPAWN)];
            double lastSpawnTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentSpawn != null)
            {
                lastSpawnTick = currentSpawn.getTick();
            }

            KeyFrame nextSpawn = character.findNextKeyFrame(KeyFrameType.SPAWN, lastSpawnTick);
            if (nextSpawn != null)
            {
                if (nextSpawn.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextSpawn, KeyFrameType.SPAWN);
                    registerSpawnChanges(character);
                }
            }


            KeyFrame currentModel = currentFrames[KeyFrameType.getIndex(KeyFrameType.MODEL)];
            double lastModelTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentModel != null)
            {
                lastModelTick = currentModel.getTick();
            }

            KeyFrame nextModel = character.findNextKeyFrame(KeyFrameType.MODEL, lastModelTick);
            if (nextModel != null)
            {
                if (nextModel.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextModel, KeyFrameType.MODEL);
                    registerModelChanges(character);
                }
            }


            KeyFrame currentOrientation = currentFrames[KeyFrameType.getIndex(KeyFrameType.ORIENTATION)];
            double lastOrientationTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentOrientation != null)
            {
                lastOrientationTick = currentOrientation.getTick();
            }

            KeyFrame nextOrientation = character.findNextKeyFrame(KeyFrameType.ORIENTATION, lastOrientationTick);
            if (nextOrientation != null)
            {
                if (nextOrientation.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextOrientation, KeyFrameType.ORIENTATION);
                    registerOrientationChanges(character);
                }
            }


            KeyFrame currentText = currentFrames[KeyFrameType.getIndex(KeyFrameType.TEXT)];
            double lastTextTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentText != null)
            {
                lastTextTick = currentText.getTick();
            }

            KeyFrame nextText = character.findNextKeyFrame(KeyFrameType.TEXT, lastTextTick);
            if (nextText != null)
            {
                if (nextText.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextText, KeyFrameType.TEXT);
                }
            }


            KeyFrame currentOverhead = currentFrames[KeyFrameType.getIndex(KeyFrameType.OVERHEAD)];
            double lastOverheadTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentOverhead != null)
            {
                lastOverheadTick = currentOverhead.getTick();
            }

            KeyFrame nextOverhead = character.findNextKeyFrame(KeyFrameType.OVERHEAD, lastOverheadTick);
            if (nextOverhead != null)
            {
                if (nextOverhead.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextOverhead, KeyFrameType.OVERHEAD);
                }
            }


            KeyFrame currentHealth = currentFrames[KeyFrameType.getIndex(KeyFrameType.HEALTH)];
            double lastHealthTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
            if (currentHealth != null)
            {
                lastHealthTick = currentHealth.getTick();
            }

            KeyFrame nextHealth = character.findNextKeyFrame(KeyFrameType.HEALTH, lastHealthTick);
            if (nextHealth != null)
            {
                if (nextHealth.getTick() <= currentTime)
                {
                    character.setCurrentKeyFrame(nextHealth, KeyFrameType.HEALTH);
                }
            }


            for (KeyFrameType spotanimType : KeyFrameType.SPOTANIM_TYPES)
            {
                KeyFrame currentSpotAnim = currentFrames[KeyFrameType.getIndex(spotanimType)];
                double lastSpotAnimTick = -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH;
                if (currentSpotAnim != null)
                {
                    lastSpotAnimTick = currentSpotAnim.getTick();
                }

                KeyFrame nextSpotAnim = character.findNextKeyFrame(spotanimType, lastSpotAnimTick);
                if (nextSpotAnim != null)
                {
                    if (nextSpotAnim.getTick() <= currentTime)
                    {
                        character.setCurrentKeyFrame(nextSpotAnim, spotanimType);
                        registerSpotAnimChanges(character, spotanimType, currentTime);
                    }
                }
            }


            for (KeyFrameType hitsplatType : KeyFrameType.HITSPLAT_TYPES)
            {
                KeyFrame currentHitsplat = currentFrames[KeyFrameType.getIndex(hitsplatType)];
                double lastHitsplatTick = 0;
                if (currentHitsplat != null)
                {
                    lastHitsplatTick = currentHitsplat.getTick();
                }

                KeyFrame nextHitsplat = character.findNextKeyFrame(hitsplatType, lastHitsplatTick);
                if (nextHitsplat != null)
                {
                    if (nextHitsplat.getTick() <= currentTime)
                    {
                        character.setCurrentKeyFrame(nextHitsplat, hitsplatType);
                    }
                }
            }
        }
    }

    private void registerSpawnChanges(Character character)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        if (!character.isInScene())
        {
            character.setActive(false, character.isActive(), false, clientThread);
            return;
        }

        WorldView worldView = client.getTopLevelWorldView();
        boolean poh = MovementManager.useLocalLocations(worldView);

        SpawnKeyFrame spawnKeyFrame = (SpawnKeyFrame) character.getCurrentKeyFrame(KeyFrameType.SPAWN);
        if (spawnKeyFrame == null)
        {
            boolean active = character.isActive();
            character.setActive(active, active, active, clientThread);
            return;
        }

        boolean active = spawnKeyFrame.isSpawnActive();
        if (active)
        {
            if ((poh && character.isInPOH()) || (!poh && !character.isInPOH()))
            {
                character.setActive(true, true, true, clientThread);
                return;
            }

            character.setActive(false, true, false, clientThread);
            return;
        }

        character.setActive(false, false, false, clientThread);
    }

    public void register3DChanges(Character character)
    {
        WorldView worldView = client.getTopLevelWorldView();
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        double currentTime = timeSheetPanel.getCurrentTime();

        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
        if (kf == null)
        {
            transform3D(worldView, character, currentTime);
            return;
        }

        MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
        if (keyFrame.getPlane() != worldView.getPlane())
        {
            character.setInScene(false);
            return;
        }

        int[][] path = keyFrame.getPath();
        int pathLength = path.length;

        double tileSpeed = keyFrame.getSpeed();
        double timePassed = timeSheetPanel.getCurrentTime() - keyFrame.getTick();
        int clientTicksPassed = (int) (timePassed * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH);
        double stepsComplete = timePassed * tileSpeed;
        int currentStep = (int) Math.floor(stepsComplete);
        double endSpeed = (pathLength - 1) - (Math.floor(((pathLength - 1) / tileSpeed)) * tileSpeed);
        double finalSpeed = tileSpeed;

        if (stepsComplete + endSpeed > pathLength - 1)
        {
            double jumps = (pathLength - 1) % tileSpeed;
            if (jumps != 0)
            {
                double ticksPreSlowdown = (pathLength - 1 - endSpeed) / tileSpeed;
                double stepsPreSlowdown = ticksPreSlowdown * tileSpeed;

                stepsComplete = (timePassed - ticksPreSlowdown) * endSpeed + stepsPreSlowdown;
                currentStep = (int) (stepsComplete);
                finalSpeed = endSpeed;
            }
        }

        if (currentStep > pathLength)
        {
            currentStep = pathLength;
        }

        keyFrame.setCurrentStep(currentStep);

        transform3DStatic(worldView,
                character,
                keyFrame,
                currentStep,
                stepsComplete,
                clientTicksPassed,
                finalSpeed);
    }

    private void registerOrientationChanges(Character character)
    {
        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ORIENTATION);
        if (kf == null)
        {
            return;
        }

        OrientationKeyFrame keyFrame = (OrientationKeyFrame) kf;
        double ticksPassed = timeSheetPanel.getCurrentTime() - keyFrame.getTick();
        double duration = keyFrame.getDuration();
        if (ticksPassed > duration)
        {
            return;
        }

        int orientation = getOrientationStatic(keyFrame);
        character.setOrientation(orientation);
    }

    public KeyFrameType findLastOrientation(Character character)
    {
        KeyFrame movement = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
        KeyFrame orientation = character.getCurrentKeyFrame(KeyFrameType.ORIENTATION);

        if (movement == null && orientation == null)
        {
            return null;
        }

        if (movement == null)
        {
            return KeyFrameType.ORIENTATION;
        }

        if (orientation == null)
        {
            return KeyFrameType.MOVEMENT;
        }

        MovementKeyFrame mkf = (MovementKeyFrame) movement;
        OrientationKeyFrame okf = (OrientationKeyFrame) orientation;

        double oriEndTick = okf.getTick() + okf.getDuration();
        if (timeSheetPanel.getCurrentTime() <= oriEndTick)
        {
            return KeyFrameType.ORIENTATION;
        }

        double pathDuration = Math.ceil((mkf.getPath().length - 1) / mkf.getSpeed());
        double movementEndTick = mkf.getTick() + pathDuration;

        if (oriEndTick >= movementEndTick)
        {
            return KeyFrameType.ORIENTATION;
        }

        return KeyFrameType.MOVEMENT;
    }

    private void registerActiveAnimationChanges(Character character)
    {
        CKObject ckObject = character.getCkObject();

        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ANIMATION);
        if (kf == null)
        {
            ckObject.setHasAnimKeyFrame(false);
            int animId = (int) character.getAnimationSpinner().getValue();
            Animation current = ckObject.getAnimations()[0];
            if (current == null)
            {
                plugin.setAnimation(character, animId);
                return;
            }

            if (current.getId() != animId)
            {
                plugin.setAnimation(character, animId);
            }

            return;
        }

        AnimationKeyFrame keyFrame = (AnimationKeyFrame) kf;
        setActiveAnimationFrame(ckObject, keyFrame.getActive(), timeSheetPanel.getCurrentTime(), keyFrame.getTick(), keyFrame.getStartFrame(), keyFrame.isLoop(), keyFrame.isFreeze(), false);
    }

    private void registerModelChanges(Character character)
    {
        CKObject ckObject = character.getCkObject();
        if (ckObject == null)
        {
            return;
        }

        ModelKeyFrame modelKeyFrame = (ModelKeyFrame) character.getCurrentKeyFrame(KeyFrameType.MODEL);

        if (modelKeyFrame == null)
        {
            plugin.setModel(character, character.isCustomMode(), (int) character.getModelSpinner().getValue());
            ckObject.setRadius((int) character.getRadiusSpinner().getValue());
            return;
        }

        ckObject.setRadius(modelKeyFrame.getRadius());

        if (modelKeyFrame.isUseCustomModel())
        {
            CustomModel customModel = modelKeyFrame.getCustomModel();
            if (customModel == null)
            {
                clientThread.invokeLater(() -> ckObject.setModel(client.loadModel(GOLDEN_CHIN)));
                return;
            }

            Model model = customModel.getModel();
            if (model == null)
            {
                return;
            }

            ckObject.setModel(model);
        }
        else
        {
            int modelId = modelKeyFrame.getModelId();
            if (modelId == -1)
            {
                modelId = 7699;
            }

            final int id = modelId;

            clientThread.invokeLater(() -> ckObject.setModel(client.loadModel(id)));
        }
    }

    private void registerSpotAnimChanges(Character character, KeyFrameType keyFrameType, double currentTime)
    {
        CKObject ckObject = character.getCkObject();
        CKObject spotAnim;
        if (keyFrameType == KeyFrameType.SPOTANIM)
        {
            spotAnim = character.getSpotAnim1();
        }
        else
        {
            spotAnim = character.getSpotAnim2();
        }

        SpotAnimKeyFrame spotAnimKeyFrame = (SpotAnimKeyFrame) character.getCurrentKeyFrame(keyFrameType);

        if (spotAnimKeyFrame == null)
        {
            clientThread.invokeLater(() ->
            {
                if (spotAnim == null)
                {
                    return;
                }

                spotAnim.setActive(false);
            });
            return;
        }

        LocalPoint lp = ckObject.getLocation();
        int plane = ckObject.getLevel();

        updateSpotAnim(keyFrameType, spotAnimKeyFrame.getSpotAnimId(), spotAnimKeyFrame.getHeight(), character, currentTime, spotAnimKeyFrame.getTick(), spotAnimKeyFrame.isLoop(), lp, plane, ckObject.getOrientation());
    }

    private void updateSpotAnim(KeyFrameType keyFrameType, int spotAnimId, int height, Character character, double currentTime, double startTick, boolean loop, LocalPoint lp, int plane, int orientation)
    {
        CKObject spotAnim;
        if (keyFrameType == KeyFrameType.SPOTANIM)
        {
            spotAnim = character.getSpotAnim1();
        }
        else
        {
            spotAnim = character.getSpotAnim2();
        }

        if (spotAnim == null)
        {
            if (spotAnimId == -1)
            {
                return;
            }
        }

        SpotanimData data = dataFinder.getSpotAnimData(spotAnimId);

        if (data != null)
        {
            ModelStats[] stats = dataFinder.findSpotAnim(data);
            clientThread.invokeLater(() ->
            {
                CKObject ckObject;
                if (spotAnim == null)
                {
                    ckObject = new CKObject(client);
                    client.registerRuneLiteObject(ckObject);
                    ckObject.setDrawFrontTilesFirst(true);
                    ckObject.setDespawnOnFinish(true);
                    ckObject.setHasAnimKeyFrame(true);
                    character.setSpotAnim(ckObject, keyFrameType);
                }
                else
                {
                    ckObject = spotAnim;
                }

                ckObject.setOrientation(orientation);
                ckObject.setPlaying(playing);
                ckObject.setActive(false);
                ckObject.setActive(true);

                LightingStyle ls = LightingStyle.SPOTANIM;
                CustomLighting cl = new CustomLighting(ls.getAmbient() + data.getAmbient(), ls.getContrast() + data.getContrast(), ls.getX(), ls.getY(), ls.getZ());
                for (ModelStats ms : stats)
                {
                    ms.setTranslateZ(height);
                }

                Model model = plugin.constructModelFromCache(stats, new int[0], false, LightingStyle.CUSTOM, cl);

                ckObject.setModel(model);
                setActiveAnimationFrame(ckObject, data.getAnimationId(), currentTime, startTick, 0, loop, false, true);
            });
        }
    }

    public void setActiveAnimationFrame(CKObject ckObject, int animId, double currentTime, double startTime, int startFrame, boolean loop, boolean freeze, boolean despawnOnFinished)
    {
        if (animId == -1)
        {
            clientThread.invoke(() ->
            {
                ckObject.unsetAnimation(AnimationType.ACTIVE);
                ckObject.setLoop(false);
                ckObject.setFreeze(false);
                ckObject.setHasAnimKeyFrame(true);
                ckObject.setFinished(true);
            });
            return;
        }

        Animation[] animations = ckObject.getAnimations();
        Animation active = animations[0];
        if (active == null || active.getId() != animId)
        {
            clientThread.invoke(() ->
            {
                Animation animation = client.loadAnimation(animId);
                setActiveAnimationFrame(ckObject, animation, currentTime, startTime, startFrame, loop, freeze, despawnOnFinished);
            });
            return;
        }

        clientThread.invoke(() ->
        {
            setActiveAnimationFrame(ckObject, active, currentTime, startTime, startFrame, loop, freeze, despawnOnFinished);
        });
    }

    public void setActiveAnimationFrame(CKObject ckObject, Animation animation, double currentTime, double startTime, int startFrame, boolean loop, boolean freeze, boolean despawnOnFinished)
    {
        int[] animFrame = getAnimFrame(animation, currentTime, startTime, startFrame, loop);
        int frame = animFrame[0];
        int tick = animFrame[1];

        if (freeze)
        {
            frame = startFrame;
            tick = 0;
        }

        if (!freeze && animFrame[0] == -1)
        {
            ckObject.setFinished(true);
            ckObject.unsetAnimation(AnimationType.ACTIVE);
            ckObject.setLoop(false);
            ckObject.setFreeze(false);
            if (despawnOnFinished)
            {
                ckObject.setActive(false);
            }
        }
        else
        {
            ckObject.setAnimation(AnimationType.ACTIVE, animation);
            ckObject.setAnimationFrame(AnimationType.ACTIVE, frame, freeze);
            ckObject.tick(tick);
            ckObject.setLoop(loop);
            ckObject.setFinished(false);
            ckObject.setHasAnimKeyFrame(true);
        }
    }

    public void setPoseAnimationFrame(CKObject ckObject, double currentTime, double startTime, int startFrame)
    {
        Animation[] animations = ckObject.getAnimations();

        Animation pose = animations[1];
        if (pose != null && pose.getId() != -1)
        {
            int[] animFrame = getAnimFrame(pose, currentTime, startTime, startFrame, true);
            if (animFrame[0] != -1)
            {
                clientThread.invoke(() ->
                {
                    ckObject.setAnimationFrame(AnimationType.POSE, animFrame[0], false);
                    ckObject.tick(animFrame[1]);
                });
            }
        }
    }

    /**
     * Gets the current Animation Frame and Client Ticks that have passed that should be playing from the given time
     * @param animation The animation playing
     * @param currentTime The current time from which to calculate
     * @param startTime The start of the KeyFrame
     * @param startFrame The frame the animation started on
     * @param loop Whether the animation is looping
     * @return an int[] consisting of {frame from which to play, number of Client Ticks that have passed this frame}
     */
    private int[] getAnimFrame(Animation animation, double currentTime, double startTime, int startFrame, boolean loop)
    {
        double gameTicksPassed = currentTime - startTime;
        int clientTicksPassed = (int) (gameTicksPassed * 30);

        if (animation.isMayaAnim())
        {
            int duration = animation.getDuration();
            int totalTicksPassed = clientTicksPassed + startFrame;
            if (loop)
            {
                int loops = (totalTicksPassed) / duration;
                totalTicksPassed = totalTicksPassed - loops * duration;
                if (totalTicksPassed < 0)
                {
                    totalTicksPassed = 0;
                }

                return new int[]{totalTicksPassed, 0};
            }

            if (totalTicksPassed >= duration)
            {
                return new int[]{-1, 0};
            }

            if (totalTicksPassed < 0)
            {
                totalTicksPassed = 0;
            }

            return new int[]{totalTicksPassed, 0};
        }

        int[] frameLengths = animation.getFrameLengths();

        int duration = 0;
        int startTick = 0;
        for (int i = 0; i < frameLengths.length; i++)
        {
            int frameLength = frameLengths[i];
            duration += frameLength;

            if (i < startFrame)
            {
                startTick += frameLength;
            }
        }

        int totalTicksPassed = clientTicksPassed + startTick;
        if (loop)
        {
            int loops = totalTicksPassed / duration;
            totalTicksPassed = totalTicksPassed - loops * duration;

            int framesPassed = 0;
            for (int i = 0; i < frameLengths.length; i++)
            {
                int frameLength = frameLengths[i];
                if (framesPassed + frameLength > totalTicksPassed)
                {
                    int ticksPassed = totalTicksPassed - framesPassed;
                    if (ticksPassed < 0)
                    {
                        ticksPassed = 0;
                    }

                    return new int[]{i, ticksPassed};
                }

                framesPassed += frameLength;
            }

            return new int[]{-1, 0};
        }

        if (totalTicksPassed >= duration)
        {
            return new int[]{-1, 0};
        }

        int framesPassed = 0;
        for (int i = 0; i < frameLengths.length; i++)
        {
            int frameLength = frameLengths[i];
            if (framesPassed + frameLength > totalTicksPassed)
            {
                int ticksPassed = totalTicksPassed - framesPassed;
                if (ticksPassed < 0)
                {
                    ticksPassed = 0;
                }

                return new int[]{i, ticksPassed};
            }

            framesPassed += frameLength;
        }

        return new int[]{-1, 0};
    }
}

package com.creatorskit.programming;

import com.creatorskit.Character;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.MovementKeyFrame;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.util.ArrayList;
import java.util.Collection;

public class PathFinder
{
    @Inject
    private Client client;

    private final int WATER_OVERLAY = 6;
    private final int[] directionColumn = new int[]{1, -1, 0, 0, -1, 1, -1, 1};
    private final int[] directionRow = new int[]{0, 0, -1, 1, -1, -1, 1, 1};
    private final int[][] directionBlocks = new int[][]
            {
                    {CollisionDataFlag.BLOCK_MOVEMENT_EAST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_SOUTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH, CollisionDataFlag.BLOCK_MOVEMENT_EAST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH_WEST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_WEST},
                    {CollisionDataFlag.BLOCK_MOVEMENT_NORTH_EAST, CollisionDataFlag.BLOCK_MOVEMENT_NORTH, CollisionDataFlag.BLOCK_MOVEMENT_EAST}
            };

    public int[][] findPath(LocalPoint startLocation, LocalPoint destLocation, MovementType movementType)
    {
        Coordinate[] coordinates = getPath(startLocation, destLocation, movementType);
        if (coordinates == null || coordinates.length == 0)
        {
            return null;
        }

        int[][] path = new int[coordinates.length][2];

        for (int i = 0; i < coordinates.length; i++)
        {
            Coordinate c = coordinates[i];
            path[i] = new int[]{c.getColumn(), c.getRow()};
        }

        return path;
    }

    public Coordinate[] getPath(LocalPoint startLocation, LocalPoint destLocation, MovementType movementType)
    {
        WorldView worldView = client.getTopLevelWorldView();
        Scene scene = worldView.getScene();
        final ArrayList<Integer> rowQueue = new ArrayList<>();
        final ArrayList<Integer> columnQueue = new ArrayList<>();
        final boolean[][] visited = new boolean[Constants.SCENE_SIZE][Constants.SCENE_SIZE];
        final Coordinate[][] path = new Coordinate[Constants.SCENE_SIZE][Constants.SCENE_SIZE];

        boolean reachedEnd = false;

        if (startLocation == null || destLocation == null)
        {
            return null;
        }

        int startX = startLocation.getSceneX();
        int startY = startLocation.getSceneY();
        int endX = destLocation.getSceneX();
        int endY = destLocation.getSceneY();

        rowQueue.add(startY);
        columnQueue.add(startX);
        visited[startX][startY] = true;
        if (worldView.getCollisionMaps() == null)
        {
            return null;
        }

        CollisionData data = worldView.getCollisionMaps()[worldView.getPlane()];
        short[][] overlays = scene.getOverlayIds()[worldView.getPlane()];

        while (!rowQueue.isEmpty() && !columnQueue.isEmpty())
        {
            int row = rowQueue.get(0);
            int column = columnQueue.get(0);
            rowQueue.remove(0);
            columnQueue.remove(0);
            if (row == endY && column == endX)
            {
                reachedEnd = true;
                break;
            }

            exploreNeighbours(row, column, data, overlays, visited, columnQueue, rowQueue, path, movementType);
        }

        if (reachedEnd)
        {
            return reconstructPath(endX, endY, path);
        }

        return null;
    }

    public int[][] findPath(WorldView worldView, WorldPoint startLocation, WorldPoint destLocation, MovementType movementType)
    {
        Coordinate[] coordinates = getPath(worldView.isInstance(), startLocation, destLocation, movementType);
        if (coordinates == null || coordinates.length == 0)
        {
            return null;
        }

        int[][] path = new int[coordinates.length][2];

        for (int i = 0; i < coordinates.length; i++)
        {
            Coordinate c = coordinates[i];
            LocalPoint lp = LocalPoint.fromScene(c.getColumn(), c.getRow(), worldView);
            WorldPoint wp = WorldPoint.fromLocalInstance(client, lp, worldView.getPlane());
            path[i] = new int[]{wp.getX(), wp.getY()};
        }

        return path;
    }

    public Coordinate[] getPath(boolean instance, WorldPoint startLocation, WorldPoint destLocation, MovementType movementType)
    {
        WorldView worldView = client.getTopLevelWorldView();
        Scene scene = worldView.getScene();
        final ArrayList<Integer> rowQueue = new ArrayList<>();
        final ArrayList<Integer> columnQueue = new ArrayList<>();
        final boolean[][] visited = new boolean[Constants.SCENE_SIZE][Constants.SCENE_SIZE];
        final Coordinate[][] path = new Coordinate[Constants.SCENE_SIZE][Constants.SCENE_SIZE];

        boolean reachedEnd = false;
        if (instance)
        {
            Collection<WorldPoint> startPoints = WorldPoint.toLocalInstance(scene, startLocation);
            startLocation = startPoints.iterator().next();

            Collection<WorldPoint> destPoints = WorldPoint.toLocalInstance(scene, destLocation);
            destLocation = destPoints.iterator().next();
        }

        LocalPoint startLoc = LocalPoint.fromWorld(worldView, startLocation);
        LocalPoint destLoc = LocalPoint.fromWorld(worldView, destLocation);

        if (startLoc == null || destLoc == null)
        {
            return null;
        }

        int startX = startLoc.getSceneX();
        int startY = startLoc.getSceneY();
        int endX = destLoc.getSceneX();
        int endY = destLoc.getSceneY();
        rowQueue.add(startY);
        columnQueue.add(startX);
        visited[startX][startY] = true;
        if (worldView.getCollisionMaps() == null)
        {
            return null;
        }

        CollisionData data = worldView.getCollisionMaps()[worldView.getPlane()];
        short[][] overlays = scene.getOverlayIds()[worldView.getPlane()];

        while (!rowQueue.isEmpty() && !columnQueue.isEmpty())
        {
            int row = rowQueue.get(0);
            int column = columnQueue.get(0);
            rowQueue.remove(0);
            columnQueue.remove(0);
            if (row == endY && column == endX)
            {
                reachedEnd = true;
                break;
            }

            exploreNeighbours(row, column, data, overlays, visited, columnQueue, rowQueue, path, movementType);
        }

        if (reachedEnd)
        {
            return reconstructPath(endX, endY, path);
        }

        return null;
    }

    private Coordinate[] reconstructPath(int endX, int endY, Coordinate[][] coordinates)
    {
        ArrayList<Coordinate> list = new ArrayList<>();
        Coordinate endCoordinate = new Coordinate(endX, endY);
        for (Coordinate coordinate = endCoordinate; coordinate != null; coordinate = coordinates[coordinate.getColumn()][coordinate.getRow()])
        {
            list.add(coordinate);
        }

        Coordinate[] path = new Coordinate[list.size()];
        for (int i = 0; i < list.size(); i++)
        {
            path[i] = list.get(i);
        }

        ArrayUtils.reverse(path);
        path = ArrayUtils.remove(path, 0);

        return path;
    }

    private void exploreNeighbours(int row, int column, CollisionData data, short[][] overlays, boolean[][] visited, ArrayList<Integer> columnQueue, ArrayList<Integer> rowQueue, Coordinate[][] path, MovementType movementType)
    {
        for (int i = 0; i < 8; i++)
        {
            int testRow = row + directionRow[i];
            int testColumn = column + directionColumn[i];

            if (testRow >= Constants.SCENE_SIZE || testRow < 0 || testColumn >= Constants.SCENE_SIZE || testColumn < 0)
            {
                continue;
            }

            if (movementType != MovementType.GHOST)
            {
                int setting = data.getFlags()[testColumn][testRow];
                int currentSetting = data.getFlags()[column][row];

                if ((setting & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[testColumn][testRow] == WATER_OVERLAY) || (setting & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0))
                {
                    continue;
                }

                if (movementType == MovementType.WATERBORNE && (setting & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0)
                {
                    continue;
                }

                int[] blocks = directionBlocks[i];
                if ((currentSetting & blocks[0]) != 0)
                {
                    continue;
                }

                if (i >= 4)
                {
                    int settingEW = data.getFlags()[testColumn][row];
                    int settingNS = data.getFlags()[column][testRow];

                    if (((settingEW & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[testColumn][row] == WATER_OVERLAY) || (settingEW & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0))
                            || ((settingNS & CollisionDataFlag.BLOCK_MOVEMENT_FULL) != 0 && (movementType != MovementType.WATERBORNE || !(overlays[column][testRow] == WATER_OVERLAY) || (settingNS & CollisionDataFlag.BLOCK_MOVEMENT_OBJECT) != 0)))
                    {
                        continue;
                    }

                    if (movementType == MovementType.WATERBORNE && ((settingEW & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0 || (settingNS & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0))
                        continue;

                    if ((settingEW & blocks[1]) != 0 || (settingNS & blocks[2]) != 0)
                        continue;

                    if ((currentSetting & blocks[1]) != 0 || (currentSetting & blocks[2]) != 0)
                        continue;
                }
            }

            if (visited[testColumn][testRow])
            {
                continue;
            }

            columnQueue.add(testColumn);
            rowQueue.add(testRow);
            visited[testColumn][testRow] = true;
            path[testColumn][testRow] = new Coordinate(column, row);
        }
    }

    public void transplantSteps(Character character, WorldView worldView, int newX, int newY)
    {
        boolean poh = MovementManager.useLocalLocations(worldView);

        KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
        if (kf == null)
        {
            if (poh)
            {
                LocalPoint lp = character.getInstancedPoint();
                if (lp == null)
                {
                    return;
                }

                int changeX = newX - lp.getSceneX();
                int changeY = newY - lp.getSceneY();
                transplantKeyFrames(character, worldView, changeX, changeY);
                return;
            }

            WorldPoint startPoint = character.getNonInstancedPoint();
            if (startPoint == null)
            {
                return;
            }

            if (worldView.isInstance())
            {
                Collection<WorldPoint> wps = WorldPoint.toLocalInstance(worldView, startPoint);
                if (wps.isEmpty())
                {
                    return;
                }
                startPoint = wps.iterator().next();
            }

            int changeX = newX - startPoint.getX();
            int changeY = newY - startPoint.getY();
            transplantKeyFrames(character, worldView, changeX, changeY);
            return;
        }

        MovementKeyFrame keyFrame = (MovementKeyFrame) kf;

        keyFrame.setPoh(poh);
        keyFrame.setPlane(worldView.getPlane());

        int[][] path = keyFrame.getPath();
        if (path.length == 0)
        {
            return;
        }

        int[] start = path[0];
        int changeX = newX - start[0];
        int changeY = newY - start[1];

        transplantKeyFrames(character, worldView, changeX, changeY);
    }

    private void transplantKeyFrames(Character character, WorldView worldView, int changeX, int changeY)
    {
        MovementKeyFrame[] kfs = character.getMovementKeyFrames();
        if (kfs == null)
        {
            return;
        }

        for (MovementKeyFrame keyFrame : kfs)
        {
            if (keyFrame == null)
            {
                continue;
            }

            boolean poh = MovementManager.useLocalLocations(worldView);
            keyFrame.setPoh(poh);
            keyFrame.setPlane(worldView.getPlane());

            int[][] path = keyFrame.getPath();

            for (int[] coordinates : path)
            {
                coordinates[0] = coordinates[0] + changeX;
                coordinates[1] = coordinates[1] + changeY;
            }
        }
    }
}

package com.creatorskit.saves;

import com.creatorskit.swing.manager.FolderType;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class FolderNodeSave
{
    private FolderType folderType;
    private String name;
    private CharacterSave[] characterSaves;
    private FolderNodeSave[] folderSaves;
}

package com.creatorskit.saves;

import com.creatorskit.models.CustomModelComp;
import com.creatorskit.swing.TransmogAnimationMode;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class TransmogSave
{
    private CustomModelComp customModelComp;
    private TransmogAnimationMode transmogAnimationMode;
    private int[][] animationSwaps;
    private int poseAnimation;
    private int walkAnimation;
    private int runAnimation;
    private int actionAnimation;
    private int backwardsAnimation;
    private int rightAnimation;
    private int leftAnimation;
    private int rotateAnimation;
    private int radius;
}

package com.creatorskit.saves;

import com.creatorskit.models.CustomModelComp;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class SetupSave
{
    private String version;
    private CustomModelComp[] comps;
    private FolderNodeSave masterFolderNode;
    private CharacterSave[] saves;
}

package com.creatorskit.saves;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum TransmogLoadOption
{
    BOTH("Both"),
    CUSTOM_MODEL("Custom Model"),
    ANIMATIONS("Animations")
    ;

    private String string;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.saves;


import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import lombok.Getter;

@Getter
public class ModelKeyFrameSave extends KeyFrame
{
    private boolean useCustomModel;
    private int modelId;
    private int customModel;
    private int radius;

    public ModelKeyFrameSave(double tick, boolean useCustomModel, int modelId, int customModel, int radius)
    {
        super(KeyFrameType.MODEL, tick);
        this.useCustomModel = useCustomModel;
        this.modelId = modelId;
        this.customModel = customModel;
        this.radius = radius;
    }
}

package com.creatorskit.saves;

import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;

@AllArgsConstructor
@Getter
@Setter
public class CharacterSave
{
    private String name;
    private WorldPoint nonInstancedPoint;
    private LocalPoint instancedPoint;
    private int instancedPlane;
    private boolean inInstance;
    private int compId;
    private boolean customMode;
    private int modelId;
    private boolean active;
    private int radius;
    private int rotation;
    private int animationId;
    private int frame;
    private int rgb;
    private MovementKeyFrame[] movementKeyFrames;
    private AnimationKeyFrame[] animationKeyFrames;
    private SpawnKeyFrame[] spawnKeyFrames;
    private ModelKeyFrameSave[] modelKeyFrameSaves;
    private OrientationKeyFrame[] orientationKeyFrames;
    private TextKeyFrame[] textKeyFrames;
    private OverheadKeyFrame[] overheadKeyFrames;
    private HealthKeyFrame[] healthKeyFrames;
    private SpotAnimKeyFrame[][] spotanimKeyFrames;
    private HitsplatKeyFrame[][] hitsplatKeyFrames;
    private KeyFrameType[] summary;
}

package com.creatorskit;

import com.creatorskit.models.*;
import com.creatorskit.programming.*;
import com.creatorskit.programming.orientation.OrientationHotkeyMode;
import com.creatorskit.saves.TransmogLoadOption;
import com.creatorskit.saves.TransmogSave;
import com.creatorskit.swing.*;
import com.creatorskit.swing.anvil.ComplexPanel;
import com.creatorskit.swing.anvil.ModelAnvil;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.swing.timesheet.keyframe.*;
import com.google.gson.Gson;
import com.google.inject.Provides;
import javax.inject.Inject;
import javax.swing.*;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.Menu;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.*;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.chat.ChatColorType;
import net.runelite.client.chat.ChatMessageBuilder;
import net.runelite.client.chat.ChatMessageManager;
import net.runelite.client.chat.QueuedMessage;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.config.Keybind;
import net.runelite.client.eventbus.EventBus;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.input.MouseListener;
import net.runelite.client.input.MouseManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import org.apache.commons.lang3.ArrayUtils;

import java.awt.*;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Files;
import java.util.*;

@Slf4j
@Getter
@Setter
@PluginDescriptor(
		name = "Creator's Kit",
		description = "A suite of tools for creators",
		tags = {"tool", "creator", "content", "kit", "camera", "immersion", "export"}
)
public class CreatorsPlugin extends Plugin implements MouseListener {
	@Inject
	private Client client;

	@Inject
	private ClientThread clientThread;

	@Inject
	private EventBus eventBus;

	@Inject
	private CreatorsConfig config;

	@Inject
	private ConfigManager configManager;

	@Inject
	private ClientToolbar clientToolbar;

	@Inject
	private OverlayManager overlayManager;

	@Inject
	private CreatorsOverlay overlay;

	@Inject
	private TextOverlay textOverlay;

	@Inject
	private OverheadOverlay overheadOverlay;

	@Inject
	private HealthOverlay healthOverlay;

	@Inject
	private HitsplatOverlay hitsplatOverlay;

	@Inject
	private KeyManager keyManager;

	@Inject
	private MouseManager mouseManager;

	@Inject
	private ChatMessageManager chatMessageManager;

	@Inject
	private ModelGetter modelGetter;

	@Inject
	private PathFinder pathFinder;

	@Inject
	private DataFinder dataFinder;

	@Inject
	private Gson gson;

	private CreatorsPanel creatorsPanel;
	private NavigationButton navigationButton;
	private boolean overlaysActive = false;
	private final ArrayList<Character> characters = new ArrayList<>();
	private final ArrayList<CustomModel> storedModels = new ArrayList<>();
	private Character selectedCharacter;
	private Character hoveredCharacter;
	private CKObject transmog;
	private CKObject previewObject;
	private Model previewArrow;
	private CustomModel transmogModel;
	private final int GOLDEN_CHIN = 29757;
	private int savedRegion = -1;
	private int savedPlane = -1;
	private AutoRotate autoRotateYaw = AutoRotate.OFF;
	private AutoRotate autoRotatePitch = AutoRotate.OFF;
	private int oculusOrbSpeed = 36;
	private double clickX;
	private double clickY;
	private boolean mousePressed = false;
	private boolean autoSetupPathFound = true;
	private boolean autoTransmogFound = true;
	private boolean addProgramStep = false;

	@Override
	protected void startUp() throws Exception
	{
		creatorsPanel = injector.getInstance(CreatorsPanel.class);
		final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "/panelicon.png");
		navigationButton = NavigationButton.builder()
				.tooltip("Creator's Kit")
				.icon(icon)
				.priority(10)
				.panel(creatorsPanel)
				.build();

		eventBus.register(creatorsPanel.getToolBox().getProgrammer());
		eventBus.register(creatorsPanel.getToolBox().getTransmogPanel());

		clientToolbar.addNavigation(navigationButton);
		overlayManager.add(overlay);
		overlayManager.add(overheadOverlay);
		overlayManager.add(healthOverlay);
		overlayManager.add(hitsplatOverlay);
		overlayManager.add(textOverlay);

		keyManager.registerKeyListener(overlayKeyListener);
		keyManager.registerKeyListener(oculusOrbListener);
		keyManager.registerKeyListener(orbPreset1Listener);
		keyManager.registerKeyListener(orbPreset2Listener);
		keyManager.registerKeyListener(orbPreset3Listener);
		keyManager.registerKeyListener(quickSpawnListener);
		keyManager.registerKeyListener(quickLocationListener);
		keyManager.registerKeyListener(quickDuplicateListener);
		keyManager.registerKeyListener(quickRotateCWListener);
		keyManager.registerKeyListener(quickRotateCCWListener);
		keyManager.registerKeyListener(autoLeftListener);
		keyManager.registerKeyListener(autoRightListener);
		keyManager.registerKeyListener(autoUpListener);
		keyManager.registerKeyListener(autoDownListener);
		keyManager.registerKeyListener(addProgramStepListener);
		keyManager.registerKeyListener(removeProgramStepListener);
		keyManager.registerKeyListener(clearProgramStepListener);
		keyManager.registerKeyListener(addOrientationStartListener);
		keyManager.registerKeyListener(addOrientationGoalListener);
		keyManager.registerKeyListener(playPauseListener);
		keyManager.registerKeyListener(resetTimelineListener);
		keyManager.registerKeyListener(skipForwardListener);
		keyManager.registerKeyListener(skipSubForwardListener);
		keyManager.registerKeyListener(skipBackwardListener);
		keyManager.registerKeyListener(skipSubBackwardListener);
		keyManager.registerKeyListener(saveListener);
		keyManager.registerKeyListener(openListener);
		keyManager.registerKeyListener(undoListener);
		keyManager.registerKeyListener(redoListener);
		mouseManager.registerMouseWheelListener(this::mouseWheelMoved);
		mouseManager.registerMouseListener(this);

		if (config.autoSetup())
		{
			File SETUP_DIR = new File(config.setupPath());
			if (!SETUP_DIR.exists())
			{
				SETUP_DIR = new File(config.setupPath() + ".json");
				if (!SETUP_DIR.exists())
				{
					SETUP_DIR = new File(config.setupPath().replaceAll("/", "\\\\"));
					if (!SETUP_DIR.exists())
					{
						SETUP_DIR = new File(config.setupPath().replaceAll("/", "\\\\") + ".json");
					}
				}
			}

			if (SETUP_DIR.exists())
			{
				creatorsPanel.loadSetup(SETUP_DIR);
			}
			else
			{
				autoSetupPathFound = false;
			}
		}

		if (config.autoTransmog())
		{
			File TRANSMOG_DIR = new File(config.transmogPath());
			if (!TRANSMOG_DIR.exists())
			{
				TRANSMOG_DIR = new File(config.transmogPath() + ".json");
				if (!TRANSMOG_DIR.exists())
				{
					TRANSMOG_DIR = new File(config.transmogPath().replaceAll("/", "\\\\"));
					if (!TRANSMOG_DIR.exists())
					{
						TRANSMOG_DIR = new File(config.transmogPath().replaceAll("/", "\\\\") + ".json");
					}
				}
			}

			if (TRANSMOG_DIR.exists())
			{
				loadTransmog(TRANSMOG_DIR, TransmogLoadOption.BOTH);
			}
			else
			{
				autoTransmogFound = false;
			}
		}

		oculusOrbSpeed = config.orbSpeed();

		String string = configManager.getConfiguration("creatorssuite", "overlaysActive");
		try
		{
            overlaysActive = Boolean.parseBoolean(string);
		}
		catch (Exception e)
		{
			overlaysActive = false;
		}
	}

	@Override
	protected void shutDown() throws Exception
	{
		creatorsPanel.clearSidePanels(false);
		creatorsPanel.clearManagerPanels();
		creatorsPanel.getToolBox().dispose();

		eventBus.unregister(creatorsPanel.getToolBox().getProgrammer());
		eventBus.unregister(creatorsPanel.getToolBox().getTransmogPanel());

		clientToolbar.removeNavigation(navigationButton);
		overlayManager.remove(overlay);
		overlayManager.remove(textOverlay);
		overlayManager.remove(overheadOverlay);
		overlayManager.remove(healthOverlay);
		overlayManager.remove(hitsplatOverlay);

		keyManager.unregisterKeyListener(overlayKeyListener);
		keyManager.unregisterKeyListener(oculusOrbListener);
		keyManager.unregisterKeyListener(orbPreset1Listener);
		keyManager.unregisterKeyListener(orbPreset2Listener);
		keyManager.unregisterKeyListener(orbPreset3Listener);
		keyManager.unregisterKeyListener(quickSpawnListener);
		keyManager.unregisterKeyListener(quickLocationListener);
		keyManager.unregisterKeyListener(quickDuplicateListener);
		keyManager.unregisterKeyListener(quickRotateCWListener);
		keyManager.unregisterKeyListener(quickRotateCCWListener);
		keyManager.unregisterKeyListener(autoLeftListener);
		keyManager.unregisterKeyListener(autoRightListener);
		keyManager.unregisterKeyListener(autoUpListener);
		keyManager.unregisterKeyListener(autoDownListener);
		keyManager.unregisterKeyListener(addProgramStepListener);
		keyManager.unregisterKeyListener(removeProgramStepListener);
		keyManager.unregisterKeyListener(clearProgramStepListener);
		keyManager.unregisterKeyListener(addOrientationStartListener);
		keyManager.unregisterKeyListener(addOrientationGoalListener);
		keyManager.unregisterKeyListener(playPauseListener);
		keyManager.unregisterKeyListener(resetTimelineListener);
		keyManager.unregisterKeyListener(skipForwardListener);
		keyManager.unregisterKeyListener(skipSubForwardListener);
		keyManager.unregisterKeyListener(skipBackwardListener);
		keyManager.unregisterKeyListener(skipSubBackwardListener);
		keyManager.unregisterKeyListener(saveListener);
		keyManager.unregisterKeyListener(openListener);
		keyManager.unregisterKeyListener(undoListener);
		keyManager.unregisterKeyListener(redoListener);
		mouseManager.unregisterMouseWheelListener(this::mouseWheelMoved);
		mouseManager.unregisterMouseListener(this);
	}

	@Subscribe
	public void onGameTick(GameTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		if (!autoSetupPathFound)
		{
			autoSetupPathFound = true;
			sendChatMessage("Creator's Kit auto-Setup has failed to find the file at the path: " + config.setupPath());
			sendChatMessage("Please ensure the config menu has the appropriate file path.");
		}

		if (!autoTransmogFound)
		{
			autoTransmogFound = true;
			sendChatMessage("Creator's Kit auto-Transmog has failed to find the file at the path: " + config.transmogPath());
			sendChatMessage("Please ensure the config menu has the appropriate file path.");
		}

		if (client.getLocalPlayer() == null)
			return;

		WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
		LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
		WorldView worldView = client.getTopLevelWorldView();

		int region = worldView.getScene().isInstance() ? WorldPoint.fromLocalInstance(client, localPoint).getRegionID() : worldPoint.getRegionID();

		if (savedRegion != region)
			savedRegion = region;

		int plane = worldView.getPlane();
		if (savedPlane != plane)
		{
			savedPlane = plane;
			for (int i = 0; i < characters.size(); i++)
			{
				Character character = characters.get(i);
				setLocation(character, false, false, character.isActive() ? ActiveOption.ACTIVE : ActiveOption.INACTIVE, LocationOption.TO_CURRENT_TICK);
			}
		}
	}

	@Subscribe
	public void onClientTick(ClientTick event)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		updatePreviewObject(client.getTopLevelWorldView().getSelectedSceneTile());

		if (addProgramStep)
		{
			addProgramStep = false;
			addProgramStep();
		}

		switch (autoRotateYaw)
		{
			case LEFT:
				client.setCameraYawTarget(client.getCameraYaw() - config.rotateHorizontalSpeed());
				break;
			case RIGHT:
				client.setCameraYawTarget(client.getCameraYaw() + config.rotateHorizontalSpeed());
		}

		switch (autoRotatePitch)
		{
			case UP:
				client.setCameraPitchTarget(client.getCameraPitch() + config.rotateVerticalSpeed());
				break;
			case DOWN:
				client.setCameraPitchTarget(client.getCameraPitch() - config.rotateVerticalSpeed());
		}
	}

	@Subscribe
	public void onGameStateChanged(GameStateChanged event)
	{
		if (event.getGameState() == GameState.LOGGED_IN)
		{
			creatorsPanel.getToolBox().getProgrammer().updatePrograms(getCurrentTick());
		}
	}

	@Subscribe
	public void onConfigChanged(ConfigChanged event)
	{
		if (event.getKey().equals("orbSpeed"))
		{
			client.setFreeCameraSpeed(config.orbSpeed());
			oculusOrbSpeed = config.orbSpeed();
		}

		if (event.getKey().equals("enableTransmog"))
		{
			if (transmog == null)
				return;

			clientThread.invokeLater(() ->
			{
				transmog.setActive(config.enableTransmog());
			});
		}
	}

	@Subscribe
	public void onPostMenuSort(PostMenuSort event)
	{
		if (config.enableCtrlHotkeys() && client.isKeyPressed(KeyCode.KC_CONTROL))
		{
			if (selectedCharacter != null)
			{
				client.getMenu().createMenuEntry(-1)
						.setOption(ColorUtil.prependColorTag("Relocate", Color.ORANGE))
						.setTarget(ColorUtil.colorTag(Color.GREEN) + selectedCharacter.getName())
						.setType(MenuAction.RUNELITE)
						.onClick(e -> setLocation(selectedCharacter, false, true, ActiveOption.ACTIVE, LocationOption.TO_HOVERED_TILE));

				MenuEntry me = client.getMenu().createMenuEntry(-2)
						.setOption(ColorUtil.prependColorTag("Keyframe", Color.ORANGE))
						.setTarget(ColorUtil.colorTag(Color.GREEN) + selectedCharacter.getName())
						.setType(MenuAction.RUNELITE);

				Menu menu = me.createSubMenu();
				SubMenuCreator.createSubMenus(creatorsPanel.getToolBox().getTimeSheetPanel(), menu);
			}
		}

		if (!config.rightClick())
		{
			return;
		}

		WorldView worldView = client.getTopLevelWorldView();
		Tile tile = worldView.getSelectedSceneTile();
		if (tile == null)
		{
			return;
		}

		MenuEntry[] menuEntries = client.getMenu().getMenuEntries();
		boolean hoveringTile = false;
		for (MenuEntry menuEntry : menuEntries)
		{
			if (menuEntry.getOption().equals("Walk here"))
			{
				hoveringTile = true;
				break;
			}
		}

		if (!hoveringTile)
		{
			return;
		}

		modelGetter.addCharacterMenuEntries(tile);
		modelGetter.addLocalPlayerMenuEntries(tile);
		modelGetter.addTileItemMenuEntries(tile);
		modelGetter.addTileObjectMenuEntries(tile);
	}

	@Subscribe
	public void onMenuEntryAdded(MenuEntryAdded event)
	{
		if (!config.rightClick())
		{
			return;
		}

		String target = event.getTarget();
		String option = event.getOption();

		NPC npc = event.getMenuEntry().getNpc();
		if (npc != null && option.equals("Examine"))
		{
			modelGetter.addNPCMenuEntries(target, npc);
		}

		Player player = event.getMenuEntry().getPlayer();
		if (player != null && option.equals("Trade with"))
		{
			modelGetter.addPlayerMenuEntries(target, player);
		}
	}

	public void setLocation(Character character, boolean initialize, boolean transplant, ActiveOption activeOption, LocationOption locationOption)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
		{
			return;
		}

		boolean poh = MovementManager.useLocalLocations(client.getTopLevelWorldView());

		if (poh)
		{
			setLocationPOH(character, initialize, transplant, activeOption, locationOption);
			return;
		}

		setLocationWorld(character, initialize, transplant, activeOption, locationOption);
	}

	public void setLocationWorld(Character character, boolean initialize, boolean transplant, ActiveOption activeOption, LocationOption locationOption)
	{
		WorldView worldView = client.getTopLevelWorldView();
		LocalPoint localPoint = null;
		WorldPoint wp = character.getNonInstancedPoint();
		if (wp != null)
		{
			Collection<WorldPoint> wps = WorldPoint.toLocalInstance(worldView, wp);
			if (!wps.isEmpty())
			{
				wp = wps.iterator().next();
				localPoint = LocalPoint.fromWorld(worldView, wp);
			}
		}

		switch (locationOption)
		{
			case TO_PLAYER:
				localPoint = client.getLocalPlayer().getLocalLocation();
				break;
			case TO_HOVERED_TILE:
				Tile tile = worldView.getSelectedSceneTile();
				if (tile == null)
				{
					return;
				}

				localPoint = tile.getLocalLocation();
				break;
			case TO_SAVED_LOCATION:
			case TO_CURRENT_TICK:
			default:
				break;
		}

		if (localPoint == null || !localPoint.isInScene())
		{
			character.setInScene(false);
			return;
		}

		character.setInScene(true);

		if (initialize)
		{
			WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
			character.setNonInstancedPoint(worldPoint);
			character.setInPOH(false);
		}

		if (transplant)
		{
			WorldPoint worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
			pathFinder.transplantSteps(character, worldView, worldPoint.getX(), worldPoint.getY());

			KeyFrame kf = character.findNextKeyFrame(KeyFrameType.MOVEMENT, -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH);
			if (kf != null)
			{
				MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
				int[][] step = keyFrame.getPath();
				if (step.length != 0)
				{
					int[] first = step[0];
					worldPoint = new WorldPoint(first[0], first[1], worldView.getPlane());
				}
			}

			character.setNonInstancedPoint(worldPoint);
			character.setInPOH(false);
		}

		LocalPoint finalLocalPoint = localPoint;
		clientThread.invokeLater(() -> character.setLocation(finalLocalPoint, worldView.getPlane()));

		if (locationOption == LocationOption.TO_HOVERED_TILE)
		{
			creatorsPanel.getToolBox().getProgrammer().register3DChanges(character);
		}

		switch (activeOption)
		{
			case ACTIVE:
				character.setActive(true, true, true, clientThread);
				break;
			case INACTIVE:
				character.setActive(false, false, false, clientThread);
				break;
			case UNCHANGED:
				character.resetActive(clientThread);
		}
	}

	public void setLocationPOH(Character character, boolean initialize, boolean transplant, ActiveOption activeOption, LocationOption locationOption)
	{
		WorldView worldView = client.getTopLevelWorldView();
		LocalPoint localPoint = null;
		if (character.getInstancedPoint() != null)
		{
			localPoint = character.getInstancedPoint();
		}

		switch (locationOption)
		{
			case TO_PLAYER:
				localPoint = client.getLocalPlayer().getLocalLocation();
				break;
			case TO_HOVERED_TILE:
				Tile tile = worldView.getSelectedSceneTile();
				if (tile == null)
				{
					return;
				}

				localPoint = tile.getLocalLocation();
				break;
			case TO_CURRENT_TICK:
			case TO_SAVED_LOCATION:
			default:
				break;
		}

		if (localPoint == null || !localPoint.isInScene())
		{
			character.setInScene(false);
			return;
		}

		character.setInScene(true);

		if (initialize)
		{
			character.setInstancedPoint(localPoint);
			character.setInstancedPlane(worldView.getPlane());
			character.setInPOH(true);
		}

		if (transplant)
		{
			pathFinder.transplantSteps(character, worldView, localPoint.getSceneX(), localPoint.getSceneY());
			LocalPoint savedPoint = localPoint;

			KeyFrame kf = character.findNextKeyFrame(KeyFrameType.MOVEMENT, -TimeSheetPanel.ABSOLUTE_MAX_SEQUENCE_LENGTH);
			if (kf != null)
			{
				MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
				int[][] step = keyFrame.getPath();
				if (step.length != 0)
				{
					int[] first = step[0];
					savedPoint = new LocalPoint(first[0], first[1], worldView);
				}
			}

			character.setInstancedPoint(savedPoint);
			character.setInstancedPlane(worldView.getPlane());
			character.setInPOH(true);
		}

		LocalPoint finalLocalPoint = localPoint;
		clientThread.invokeLater(() -> character.setLocation(finalLocalPoint, worldView.getPlane()));

		if (locationOption == LocationOption.TO_HOVERED_TILE)
		{
			creatorsPanel.getToolBox().getProgrammer().register3DChanges(character);
		}

		switch (activeOption)
		{
			case ACTIVE:
				character.setActive(true, true, true, clientThread);
				break;
			case INACTIVE:
				character.setActive(true, false, false, clientThread);
				break;
			case UNCHANGED:
				character.resetActive(clientThread);
		}
	}

	public double getCurrentTick()
	{
		return creatorsPanel.getToolBox().getTimeSheetPanel().getCurrentTime();
	}

	public void setModel(Character character, boolean modelMode, int modelId)
	{
		CKObject ckObject = character.getCkObject();
		if (ckObject == null)
		{
			return;
		}

		clientThread.invokeLater(() -> {
			if (modelMode)
			{
				CustomModel customModel = character.getStoredModel();
				Model model = customModel == null ? client.loadModel(GOLDEN_CHIN) : customModel.getModel();
				ckObject.setModel(model);
				return;
			}

			Model model = client.loadModel(modelId);
			ckObject.setModel(model);
		});
	}

	public void setAnimation(Character character, int animationId)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		CKObject ckObject = character.getCkObject();
		clientThread.invokeLater(() ->
		{
			ckObject.setAnimation(AnimationType.ACTIVE, animationId);
			KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ANIMATION);
			if (kf == null)
			{
				int frame = (int) character.getAnimationFrameSpinner().getValue();
				ckObject.setLoop(true);
				ckObject.setHasAnimKeyFrame(false);
				ckObject.setAnimationFrame(AnimationType.ACTIVE, frame, true);
			}
			else
			{
				character.pause();
				ckObject.setHasAnimKeyFrame(true);
			}
		});
	}

	public void setAnimationFrame(Character character, int animFrame, boolean allowPause)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		CKObject ckObject = character.getCkObject();
		clientThread.invoke(() -> ckObject.setAnimationFrame(AnimationType.ACTIVE, animFrame, allowPause));
	}

	public void setAnimationWithFrame(Character character, int animationId, int animFrame)
	{
		CKObject ckObject = character.getCkObject();
		ckObject.setAnimation(AnimationType.ACTIVE, animationId);
		ckObject.setAnimationFrame(AnimationType.ACTIVE, animFrame, true);
		KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.ANIMATION);
		if (kf == null)
		{
			ckObject.setPlaying(true);
			ckObject.setLoop(true);
			ckObject.setHasAnimKeyFrame(false);
		}
		else
		{
			character.pause();
			ckObject.setHasAnimKeyFrame(true);
		}
	}

	public void setRadius(Character character, int radius)
	{
		CKObject ckObject = character.getCkObject();
		clientThread.invoke(() -> ckObject.setRadius(radius));
	}

	public void addOrientation(Character character, int addition)
	{
		CKObject ckObject = character.getCkObject();
		int orientation = ckObject.getOrientation();
		orientation += addition;
		if (orientation >= 2048)
			orientation -= 2048;

		if (orientation < 0)
			orientation += 2048;

		setOrientation(character, orientation);
	}

	public void setOrientation(Character character, int orientation)
	{
		CKObject ckObject = character.getCkObject();
		character.getOrientationSpinner().setValue(orientation);
		clientThread.invokeLater(() -> ckObject.setOrientation(orientation));
	}

	public void setupRLObject(Character character, boolean setHoveredTile, boolean transplant)
	{
		clientThread.invoke(() ->
		{
			CKObject ckObject = character.getCkObject();
			client.registerRuneLiteObject(ckObject);

			ckObject.setRadius((int) character.getRadiusSpinner().getValue());
			ckObject.setOrientation((int) character.getOrientationSpinner().getValue());

			boolean active = character.isActive();

			setModel(character, character.isCustomMode(), (int) character.getModelSpinner().getValue());
			setAnimationWithFrame(character, (int) character.getAnimationSpinner().getValue(), (int) character.getAnimationFrameSpinner().getValue());

			LocationOption locationOption = setHoveredTile ? LocationOption.TO_HOVERED_TILE : LocationOption.TO_SAVED_LOCATION;
			setLocation(character, true, transplant, active ? ActiveOption.ACTIVE : ActiveOption.INACTIVE, locationOption);

			if (client.getGameState() == GameState.LOGGED_IN)
			{
				creatorsPanel.getToolBox().getProgrammer().updateProgram(character);
			}
		});
	}

	public void sendChatMessage(String chatMessage)
	{
		if (client.getGameState() != GameState.LOGGED_IN)
			return;

		final String message = new ChatMessageBuilder().append(ChatColorType.HIGHLIGHT).append(chatMessage).build();
		chatMessageManager.queue(QueuedMessage.builder().type(ChatMessageType.GAMEMESSAGE).runeLiteFormattedMessage(message).build());
	}

	public Model createComplexModel(DetailedModel[] detailedModels, boolean setPriority, LightingStyle lightingStyle, CustomLighting cl, boolean sendModelStats)
	{
		ModelData modelData = createComplexModelData(detailedModels);

		if (cl == null)
		{
			cl = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());
		}

		CustomLighting finalLighting;
		if (lightingStyle == LightingStyle.CUSTOM)
		{
			finalLighting = cl;
		}
		else
		{
			finalLighting = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());
		}

		Model model;
		try
		{
			model = modelData.light(
					finalLighting.getAmbient(),
					finalLighting.getContrast(),
					finalLighting.getX(),
					finalLighting.getZ() * -1,
					finalLighting.getY());
		}
		catch (Exception e)
		{
			sendChatMessage("Could not Forge this model with the chosen Lighting Settings. Please adjust them and try again.");
			return null;
		}

		if (model == null)
			return null;

		if (setPriority)
		{
			byte[] renderPriorities = model.getFaceRenderPriorities();
			if (renderPriorities != null && renderPriorities.length > 0)
				Arrays.fill(renderPriorities, (byte) 0);
		}

		if (sendModelStats)
		{
			sendChatMessage("Model forged. Faces: " + model.getFaceCount() + ", Vertices: " + model.getVerticesCount());
		}

		if (model.getFaceCount() >= 6200 && model.getVerticesCount() >= 3900)
			sendChatMessage("You've exceeded the max face count of 6200 or vertex count of 3900 in this model; any additional faces or vertices will not render");

		return model;
	}

	public ModelData createComplexModelData(DetailedModel[] detailedModels)
	{
		ModelData[] models = new ModelData[detailedModels.length];
		boolean[] facesToInvert = new boolean[0];

		for (int e = 0; e < detailedModels.length; e++)
		{
			DetailedModel detailedModel = detailedModels[e];
			ModelData modelData = client.loadModelData(detailedModel.getModelId());
			if (modelData == null)
				return null;

			modelData.cloneVertices().cloneColors();

			switch(detailedModel.getRotate())
			{
				case 0:
					break;
				case 1:
					modelData.rotateY270Ccw();
					break;
				case 2:
					modelData.rotateY180Ccw();
					break;
				case 3:
					modelData.rotateY90Ccw();
			}

			//swapping y and z, making y positive to align with traditional axes
			modelData.translate(detailedModel.getXTranslate() + detailedModel.getXTile() * 128, -1 * (detailedModel.getZTranslate() + detailedModel.getZTile() * 128), detailedModel.getYTranslate() + detailedModel.getYTile() * 128);
			modelData.scale(detailedModel.getXScale(), detailedModel.getZScale(), detailedModel.getYScale());

			boolean[] faceInvert = new boolean[modelData.getFaceCount()];
			Arrays.fill(faceInvert, detailedModel.isInvertFaces());
			facesToInvert = ArrayUtils.addAll(facesToInvert, faceInvert);

			short[] coloursFrom = detailedModel.getColoursFrom();
			short[] coloursTo = detailedModel.getColoursTo();

			if (coloursFrom == null || coloursTo == null)
			{
				if (!detailedModel.getRecolourNew().isEmpty() && !detailedModel.getRecolourOld().isEmpty())
				{
					String[] newColoursArray = detailedModel.getRecolourNew().split(",");
					coloursTo = new short[newColoursArray.length];
					String[] oldColoursArray = detailedModel.getRecolourOld().split(",");
					coloursFrom = new short[oldColoursArray.length];

					for (int i = 0; i < coloursFrom.length; i++)
					{
						coloursFrom[i] = Short.parseShort(oldColoursArray[i]);
						coloursTo[i] = Short.parseShort(newColoursArray[i]);
					}
				}
				else
				{
					coloursFrom = new short[0];
					coloursTo = new short[0];
				}

				detailedModel.setColoursFrom(coloursFrom);
				detailedModel.setColoursTo(coloursTo);
			}

			for (int i = 0; i < coloursTo.length; i++)
			{
				modelData.recolor(coloursFrom[i], coloursTo[i]);
			}

			short[] texturesFrom = detailedModel.getTexturesFrom();
			short[] texturesTo = detailedModel.getTexturesTo();
			if (texturesFrom != null && texturesTo != null)
			{
				try
				{
					modelData.cloneTextures();
					for (int i = 0; i < texturesTo.length; i++)
					{
						modelData.retexture(texturesFrom[i], texturesTo[i]);
					}
				}
				catch (Exception f)
				{
				}
			}
			else
			{
				detailedModel.setTexturesFrom(new short[0]);
				detailedModel.setTexturesFrom(new short[0]);
			}

			models[e] = modelData;
		}

		ModelData modelData = client.mergeModels(models);

		int[] faces2 = modelData.getFaceIndices2();
		int[] faces3 = modelData.getFaceIndices3();
		int[] faces2Copy = Arrays.copyOf(faces2, faces2.length);
		for (int i = 0; i < modelData.getFaceCount(); i++)
		{
			if (facesToInvert[i])
			{
				faces2[i] = faces3[i];
				faces3[i] = faces2Copy[i];
			}
		}

		return modelData;
	}

	public void cacheToAnvil(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player)
	{
		SwingUtilities.invokeLater(() ->
		{
			for (ModelStats modelStats : modelStatsArray)
			{
				if (player)
				{
					String name = modelStats.getBodyPart().getName();
					if (modelStats.getBodyPart() == BodyPart.NA)
						name = "Item";

					short[] itemRecolourTo = modelStats.getRecolourTo();
					short[] itemRecolourFrom = modelStats.getRecolourFrom();
					short[] kitRecolourTo = KitRecolourer.getKitRecolourTo(modelStats.getBodyPart(), kitRecolours);
					short[] kitRecolourFrom = KitRecolourer.getKitRecolourFrom(modelStats.getBodyPart());

					itemRecolourTo = ArrayUtils.addAll(itemRecolourTo, kitRecolourTo);
					itemRecolourFrom = ArrayUtils.addAll(itemRecolourFrom, kitRecolourFrom);

					creatorsPanel.getModelAnvil().createComplexPanel(
							name,
							modelStats.getModelId(),
							9,
							0, 0, 0,
							0, 0, modelStats.getTranslateZ(),
							modelStats.getResizeX(), modelStats.getResizeY(), modelStats.getResizeZ(),
							0,
							"", "",
							itemRecolourFrom, itemRecolourTo,
							modelStats.getTextureFrom(), modelStats.getTextureTo(),
							false);

					continue;
				}

				creatorsPanel.getModelAnvil().createComplexPanel(
						modelStats.getBodyPart().getName(),
						modelStats.getModelId(),
						8,
						0, 0, 0,
						0, 0, modelStats.getTranslateZ(),
						modelStats.getResizeX(), modelStats.getResizeY(), modelStats.getResizeZ(),
						0,
						"", "",
						modelStats.getRecolourFrom(), modelStats.getRecolourTo(),
						modelStats.getTextureFrom(), modelStats.getTextureTo(),
						false);
			}
		});
	}

	public void cacheToAnvil(CustomModelType type, int id)
	{
		Thread thread = new Thread(() ->
		{
			ModelStats[] modelStats;
			String name;

			switch (type)
			{
				case CACHE_NPC:
					modelStats = dataFinder.findModelsForNPC(id);
					name = dataFinder.getLastFound();
					break;
				default:
				case CACHE_OBJECT:
					modelStats = dataFinder.findModelsForObject(id, -1, LightingStyle.DEFAULT, true);
					name = dataFinder.getLastFound();
					break;
				case CACHE_GROUND_ITEM:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_GROUND_ITEM);
					name = dataFinder.getLastFound();
					break;
				case CACHE_MAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_MAN_WEAR);
					name = dataFinder.getLastFound();
					break;
				case CACHE_WOMAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_WOMAN_WEAR);
					name = dataFinder.getLastFound();
					break;
				case CACHE_SPOTANIM:
					modelStats = dataFinder.findSpotAnim(id);
					name = dataFinder.getLastFound();
			}

			if (modelStats == null || modelStats.length == 0)
			{
				sendChatMessage("Could not find the " + type + " you were looking for in the cache.");
				return;
			}

			cacheToAnvil(modelStats, new int[0], false);
			sendChatMessage("Model sent to Anvil: " + name);
		});
		thread.start();
	}

	public void cacheToCustomModel(CustomModelType type, int id, int modelType)
	{
		Thread thread = new Thread(() ->
		{
			ModelStats[] modelStats;
			String name;
			CustomModelComp comp;
			CustomLighting lighting;

			switch (type)
			{
				case CACHE_NPC:
					modelStats = dataFinder.findModelsForNPC(id);
					break;
				default:
				case CACHE_OBJECT:
					modelStats = dataFinder.findModelsForObject(id, modelType, LightingStyle.DEFAULT, false);
					break;
				case CACHE_GROUND_ITEM:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_GROUND_ITEM);
					break;
				case CACHE_MAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_MAN_WEAR);
					break;
				case CACHE_WOMAN_WEAR:
					modelStats = dataFinder.findModelsForGroundItem(id, CustomModelType.CACHE_WOMAN_WEAR);
					break;
				case CACHE_SPOTANIM:
					modelStats = dataFinder.findSpotAnim(id);
			}

			if (modelStats == null || modelStats.length == 0)
			{
				sendChatMessage("Could not find the " + type + " you were looking for in the cache.");
				return;
			}

			switch (type)
			{
				case CACHE_NPC:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 850, -30, -30, 50);
					comp = new CustomModelComp(0, CustomModelType.CACHE_NPC, id, modelStats, null, null, null, LightingStyle.ACTOR, lighting, false, name);
					break;
				default:
				case CACHE_OBJECT:
					name = dataFinder.getLastFound();
					lighting = modelStats[0].getLighting();
					comp = new CustomModelComp(0, CustomModelType.CACHE_OBJECT, id, modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, name);
					break;
				case CACHE_GROUND_ITEM:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_GROUND_ITEM, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
					break;
				case CACHE_MAN_WEAR:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_MAN_WEAR, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
					break;
				case CACHE_WOMAN_WEAR:
					name = dataFinder.getLastFound();
					lighting = new CustomLighting(64, 768, -50, -50, 10);
					comp = new CustomModelComp(0, CustomModelType.CACHE_WOMAN_WEAR, id, modelStats, null, null, null, LightingStyle.DEFAULT, lighting, false, name);
					break;
				case CACHE_SPOTANIM:
					name = dataFinder.getLastFound();
					lighting = modelStats[0].getLighting();
					comp = new CustomModelComp(0, CustomModelType.CACHE_SPOTANIM, id, modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, name);
					break;
			}

			clientThread.invokeLater(() ->
			{
				Model model = constructModelFromCache(modelStats, new int[0], false, LightingStyle.CUSTOM, lighting);
				CustomModel customModel = new CustomModel(model, comp);
				addCustomModel(customModel, false);
				sendChatMessage("Model stored: " + name);
			});
		});
		thread.start();
	}

	public Model constructModelFromCache(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player, LightingStyle ls, CustomLighting cl)
	{
		ModelData md = constructModelDataFromCache(modelStatsArray, kitRecolours, player);
		if (ls == LightingStyle.CUSTOM)
		{
			return client.mergeModels(md).light(cl.getAmbient(), cl.getContrast(), cl.getX(), -cl.getZ(), cl.getY());
		}

		return client.mergeModels(md).light(ls.getAmbient(), ls.getContrast(), ls.getX(), -ls.getZ(), ls.getY());
	}

	public ModelData constructModelDataFromCache(ModelStats[] modelStatsArray, int[] kitRecolours, boolean player)
	{
		ModelData[] mds = new ModelData[modelStatsArray.length];

		for (int i = 0; i < modelStatsArray.length; i++)
		{
			ModelStats modelStats = modelStatsArray[i];
			ModelData modelData = client.loadModelData(modelStats.getModelId());

			if (modelData == null)
				continue;

			modelData.cloneColors().cloneVertices();

			for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
				modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

			if (player)
				KitRecolourer.recolourKitModel(modelData, modelStats.getBodyPart(), kitRecolours);

			short[] textureFrom = modelStats.getTextureFrom();
			short[] textureTo = modelStats.getTextureTo();

			if (textureFrom == null || textureTo == null)
			{
				modelStats.setTextureFrom(new short[0]);
				modelStats.setTextureTo(new short[0]);
			}

			textureFrom = modelStats.getTextureFrom();
			textureTo = modelStats.getTextureTo();

			if (textureFrom.length > 0 && textureTo.length > 0)
			{
				for (int e = 0; e < textureFrom.length; e++)
				{
					modelData.retexture(textureFrom[e], textureTo[e]);
				}
			}

			if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
			{
				modelStats.setResizeX(128);
				modelStats.setResizeY(128);
				modelStats.setResizeZ(128);
			}

			modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());

			modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

			mds[i] = modelData;
		}

		return client.mergeModels(mds);
	}

	public void customModelToAnvil(CustomModel customModel)
	{
		if (customModel.getComp().getType() == CustomModelType.BLENDER)
		{
			sendChatMessage("Blender models cannot currently be used in the Anvil.");
			return;
		}

		SwingUtilities.invokeLater(() ->
		{
			CustomModelComp comp = customModel.getComp();
			sendChatMessage("Model sent to Anvil: " + comp.getName());
			ModelAnvil modelAnvil = creatorsPanel.getModelAnvil();

			CustomLighting cl;
			LightingStyle lightingStyle = comp.getLightingStyle();
			if (lightingStyle == LightingStyle.CUSTOM)
			{
				cl = comp.getCustomLighting();
			}
			else
			{
				cl = new CustomLighting(
						lightingStyle.getAmbient(),
						lightingStyle.getContrast(),
						lightingStyle.getX(),
						lightingStyle.getY(),
						lightingStyle.getZ());
			}

			modelAnvil.setLightingSettings(
					comp.getLightingStyle(),
					cl.getAmbient(),
					cl.getContrast(),
					cl.getX(),
					cl.getY(),
					cl.getZ());

			modelAnvil.getPriorityCheckBox().setSelected(comp.isPriority());
			modelAnvil.getNameField().setText(comp.getName());

			if (comp.getModelStats() == null)
			{
				DetailedModel[] detailedModels = comp.getDetailedModels();
				for (DetailedModel detailedModel : detailedModels)
					modelAnvil.createComplexPanel(detailedModel);

				return;
			}

			switch(comp.getType())
			{
				case FORGED:
				case CACHE_SPOTANIM:
				case CACHE_NPC:
				case CACHE_OBJECT:
				case CACHE_GROUND_ITEM:
				case CACHE_MAN_WEAR:
				case CACHE_WOMAN_WEAR:
					cacheToAnvil(comp.getModelStats(), comp.getKitRecolours(), false);
					break;
				case CACHE_PLAYER:
					cacheToAnvil(comp.getModelStats(), comp.getKitRecolours(), true);
			}
		});
	}

	public void loadCustomModelToAnvil(File file)
	{
		ModelAnvil modelAnvil = creatorsPanel.getModelAnvil();
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			CustomModelComp comp = gson.fromJson(reader, CustomModelComp.class);

			SwingUtilities.invokeLater(() ->
			{
				for (DetailedModel detailedModel : comp.getDetailedModels())
				{
					modelAnvil.createComplexPanel(detailedModel);
				}
			});

			LightingStyle ls = comp.getLightingStyle();
			CustomLighting cl = comp.getCustomLighting();
			if (cl == null)
				cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());

			modelAnvil.setLightingSettings(
					comp.getLightingStyle(),
					cl.getAmbient(),
					cl.getContrast(),
					cl.getX(),
					cl.getY(),
					cl.getZ());

			modelAnvil.getPriorityCheckBox().setSelected(comp.isPriority());
			modelAnvil.getNameField().setText(comp.getName());
			reader.close();
		}
		catch (Exception e)
		{
			sendChatMessage("Failed to load this Saved Model file.");
		}
	}

	public void loadCustomModel(File file)
	{
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			CustomModelComp comp = gson.fromJson(reader, CustomModelComp.class);
			clientThread.invokeLater(() ->
			{
				LightingStyle ls = comp.getLightingStyle();
				CustomLighting cl = comp.getCustomLighting();
				if (cl == null)
					cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());

				Model model = createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), cl, true);
				CustomModel customModel = new CustomModel(model, comp);
				addCustomModel(customModel, false);
			});
			reader.close();
		}
		catch (Exception e)
		{
			sendChatMessage("Failed to load this Saved Model file.");
		}
	}

	public void loadTransmog(File file, TransmogLoadOption transmogLoadOption)
	{
		try
		{
			Reader reader = Files.newBufferedReader(file.toPath());
			TransmogSave transmogSave = gson.fromJson(reader, TransmogSave.class);
			CustomModelComp comp = transmogSave.getCustomModelComp();
			if (comp != null)
			{
				DetailedModel[] detailedModels = comp.getDetailedModels();
				if (detailedModels == null)
				{
					detailedModels = creatorsPanel.getModelOrganizer().modelToDetailedPanels(comp);
					comp.setDetailedModels(detailedModels);
				}
			}

			reader.close();

			boolean loadCustomModel = false;
			switch (transmogLoadOption)
			{
				case ANIMATIONS:
					creatorsPanel.getTransmogPanel().loadTransmog(transmogSave);
					break;
				case CUSTOM_MODEL:
					if (comp != null)
						loadCustomModel = true;
					break;
				case BOTH:
					creatorsPanel.getTransmogPanel().loadTransmog(transmogSave);
					if (comp != null)
						loadCustomModel = true;
			}

			if (loadCustomModel)
			{
				clientThread.invokeLater(() ->
				{
					LightingStyle ls = comp.getLightingStyle();
					CustomLighting cl = comp.getCustomLighting();
					if (cl == null)
						cl = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());
					Model model = createComplexModel(comp.getDetailedModels(), comp.isPriority(), comp.getLightingStyle(), cl, false);
					CustomModel customModel = new CustomModel(model, comp);
					addCustomModel(customModel, false);
					creatorsPanel.getModelOrganizer().setTransmog(customModel);
				});
			}
		}
		catch (Exception e)
		{
			sendChatMessage("Failed to load the selected Transmog. Make sure you selected an appropriate transmog file.");
		}
	}

	public void addCustomModel(CustomModel customModel, boolean setComboBox)
	{
		SwingUtilities.invokeLater(() -> creatorsPanel.addModelOption(customModel, setComboBox));
		storedModels.add(customModel);
	}

	public void removeCustomModel(CustomModel customModel)
	{
		creatorsPanel.removeModelOption(customModel);
		storedModels.remove(customModel);
	}

	public void updatePanelComboBoxes()
	{
		SwingUtilities.invokeLater(() ->
		{
			for (JComboBox<CustomModel> comboBox : creatorsPanel.getComboBoxes())
				comboBox.updateUI();
		});
	}

	private void updatePreviewObject(Tile tile)
	{
		if (previewObject == null)
		{
			clientThread.invokeLater(() ->
			{
				previewObject = new CKObject(client);
				client.registerRuneLiteObject(previewObject);
				previewObject.setActive(false);

				ModelData arrow = client.loadModelData(4852);
				ModelData transparent = client.loadModelData(9925);
				if (arrow == null || transparent == null)
				{
					return;
				}

				transparent.cloneVertices();
				float[] tx = transparent.getVerticesX();
				float[] ty = transparent.getVerticesY();
				float[] tz = transparent.getVerticesZ();
				for (int i = 0; i < tx.length; i++)
				{
					tx[i] = 0;
					ty[i] = 0;
					tz[i] = 0;
				}

				arrow.cloneVertices().rotateY180Ccw().scale(256, 256, 256);
				ModelData merge = client.mergeModels(arrow, transparent);
				merge.cloneTransparencies();
				byte[] transparencies = merge.getFaceTransparencies();
				for (byte b = 0; b < merge.getFaceCount(); b++)
				{
					transparencies[b] = 115;
				}

				previewArrow = merge.light();
			});
			return;
		}

		if (!config.enableCtrlHotkeys())
		{
			previewObject.setActive(false);
			return;
		}

		if (!client.isKeyPressed(KeyCode.KC_CONTROL)
			|| client.isMenuOpen()
			|| tile == null
			|| selectedCharacter == null)
		{
			previewObject.setActive(false);
			return;
		}

		CKObject ckObject = selectedCharacter.getCkObject();
		if (ckObject == null)
		{
			return;
		}

		boolean allowArrow = false;
		int orientation;
		if (mousePressed)
		{
			final int yaw = client.getCameraYaw();
			final int pitch = client.getCameraPitch();
			Point p = client.getMouseCanvasPosition();
			double x = p.getX() - clickX;
			double y = -1 * (p.getY() - clickY);
			if (Math.sqrt(x * x + y * y) < 40)
			{
				orientation = Rotation.roundRotation(ckObject.getOrientation());
			}
			else
			{
				allowArrow = true;
				orientation = Rotation.getJagexDegrees(p.getX() - clickX, (p.getY() - clickY) * -1, yaw, pitch);
			}
		}
		else
		{
			orientation = ckObject.getOrientation();
		}

		Model model;
		if (mousePressed && previewArrow != null && allowArrow)
		{
			model = previewArrow;
		}
		else
		{
			if (selectedCharacter.isCustomMode())
			{
				if (selectedCharacter.getStoredModel() == null)
				{
					model = client.loadModel(29757);
				}
				else
				{
					model = selectedCharacter.getStoredModel().getModel();
				}
			}
			else
			{
				model = client.loadModel((int) selectedCharacter.getModelSpinner().getValue());
			}
		}

		LocalPoint lp;
		if (mousePressed)
		{
			lp = ckObject.getLocation();
			if (lp == null)
			{
				lp = tile.getLocalLocation();
			}
		}
		else
		{
			lp = tile.getLocalLocation();
			if (lp == null)
			{
				lp = ckObject.getLocation();
			}
		}

		if (lp == null || !lp.isInScene())
		{
			return;
		}

		int animId;
		if (allowArrow)
		{
			animId = -1;
		}
		else
		{
			animId = ckObject.getAnimationId();
		}

		AnimationController ac = ckObject.getAnimationController();
		previewObject.setModel(model);
		previewObject.setOrientation(orientation);
		previewObject.setAnimation(AnimationType.ACTIVE, animId);
		previewObject.setAnimationFrame(AnimationType.ACTIVE, ckObject.getAnimationFrame(AnimationType.ACTIVE), true);
		previewObject.setLocation(lp, client.getTopLevelWorldView().getPlane());
		previewObject.setRadius(ckObject.getRadius());
		previewObject.setActive(true);
	}

	public ArrayList<ComplexPanel> getComplexPanels()
	{
		return creatorsPanel.getModelAnvil().getComplexPanels();
	}

	private final HotkeyListener overlayKeyListener = new HotkeyListener(() -> config.toggleOverlaysHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			overlaysActive = !overlaysActive;
			configManager.setConfiguration("creatorssuite", "overlaysActive", String.valueOf(overlaysActive));
		}
	};

	private final HotkeyListener oculusOrbListener = new HotkeyListener(() -> config.toggleOrbHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (client.getCameraMode() == 1)
			{
				client.setCameraMode(0);
				client.setFreeCameraSpeed(12);
				return;
			}

			client.setCameraMode(1);
			client.setFreeCameraSpeed(oculusOrbSpeed);
		}
	};

	private final HotkeyListener orbPreset1Listener = new HotkeyListener(() -> config.orbSpeedHotkey1())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey1());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey1());
		}
	};

	private final HotkeyListener orbPreset2Listener = new HotkeyListener(() -> config.orbSpeedHotkey2())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey2());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey2());
		}
	};

	private final HotkeyListener orbPreset3Listener = new HotkeyListener(() -> config.orbSpeedHotkey3())
	{
		@Override
		public void hotkeyPressed()
		{
			client.setFreeCameraSpeed(config.speedHotkey3());
			sendChatMessage("Oculus Orb set to speed: " + config.speedHotkey3());
		}
	};
	private final HotkeyListener quickSpawnListener = new HotkeyListener(() -> config.quickSpawnHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				selectedCharacter.toggleActive(clientThread);
			}
		}
	};

	private final HotkeyListener quickLocationListener = new HotkeyListener(() -> config.quickLocationHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				setLocation(selectedCharacter, false, true, ActiveOption.ACTIVE, LocationOption.TO_HOVERED_TILE);
			}
		}
	};

	private final HotkeyListener quickDuplicateListener = new HotkeyListener(() -> config.quickDuplicateHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				creatorsPanel.onDuplicatePressed(selectedCharacter, true);
			}
		}
	};

	private final HotkeyListener quickRotateCWListener = new HotkeyListener(() -> config.quickRotateCWHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				addOrientation(selectedCharacter, config.rotateDegrees().degrees * -1);
			}
		}
	};

	private final HotkeyListener quickRotateCCWListener = new HotkeyListener(() -> config.quickRotateCCWHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			if (selectedCharacter != null)
			{
				addOrientation(selectedCharacter, config.rotateDegrees().degrees);
			}
		}
	};

	private final HotkeyListener autoLeftListener = new HotkeyListener(() -> config.rotateLeftHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotateYaw = (autoRotateYaw == AutoRotate.OFF) ? AutoRotate.LEFT : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoRightListener = new HotkeyListener(() -> config.rotateRightHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotateYaw = (autoRotateYaw == AutoRotate.OFF) ? AutoRotate.RIGHT : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoUpListener = new HotkeyListener(() -> config.rotateUpHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotatePitch = (autoRotatePitch == AutoRotate.OFF) ? AutoRotate.UP : AutoRotate.OFF;
		}
	};

	private final HotkeyListener autoDownListener = new HotkeyListener(() -> config.rotateDownHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			autoRotatePitch = (autoRotatePitch == AutoRotate.OFF) ? AutoRotate.DOWN : AutoRotate.OFF;
		}
	};

	private final HotkeyListener addProgramStepListener = new HotkeyListener(() -> config.addProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			addProgramStep = true;
		}
	};

	private void addProgramStep()
	{
		creatorsPanel.getToolBox().getTimeSheetPanel().onAddMovementKeyPressed();
	}

	private final HotkeyListener removeProgramStepListener = new HotkeyListener(() -> config.removeProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			removeProgramStep();
		}
	};

	private void removeProgramStep()
	{
		if (selectedCharacter == null)
		{
			return;
		}

		KeyFrame kf = selectedCharacter.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
		if (kf == null)
		{
			return;
		}

		MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
		int[][] path = keyFrame.getPath();

		if (path.length == 0)
		{
			return;
		}

		int newLength = path.length - 1;
		keyFrame.setPath(ArrayUtils.remove(path, newLength));
		creatorsPanel.getToolBox().getProgrammer().register3DChanges(selectedCharacter);
	}

	private final HotkeyListener clearProgramStepListener = new HotkeyListener(() -> config.clearProgramStepHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			clearProgramSteps();
		}
	};

	private void clearProgramSteps()
	{
		if (selectedCharacter == null)
		{
			return;
		}

		KeyFrame kf = selectedCharacter.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
		if (kf == null)
		{
			return;
		}

		MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
		keyFrame.setPath(new int[0][2]);
		keyFrame.setCurrentStep(0);
	}

	private final HotkeyListener addOrientationStartListener = new HotkeyListener(() -> config.orientationStart()) {
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().onOrientationKeyPressed(OrientationHotkeyMode.SET_START);
		}
	};

	private final HotkeyListener addOrientationGoalListener = new HotkeyListener(() -> config.orientationEnd()) {
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().onOrientationKeyPressed(OrientationHotkeyMode.SET_GOAL);
		}
	};

	private final HotkeyListener playPauseListener = new HotkeyListener(() -> config.playPauseHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getProgrammer().togglePlay();
		}
	};

	private final HotkeyListener resetTimelineListener = new HotkeyListener(() -> config.resetTimelineHotkey())
	{
		@Override
		public void hotkeyPressed()
		{
			ToolBoxFrame toolBox = creatorsPanel.getToolBox();
			toolBox.getTimeSheetPanel().setCurrentTime(0, false);
		}
	};

	private final HotkeyListener skipForwardListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().onAttributeSkipForward();
		}
	};

	private final HotkeyListener skipBackwardListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().onAttributeSkipPrevious();
		}
	};

	private final HotkeyListener skipSubForwardListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_RIGHT, InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().skipListener(0.1);
		}
	};

	private final HotkeyListener skipSubBackwardListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_LEFT, InputEvent.CTRL_DOWN_MASK | InputEvent.ALT_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().skipListener(-0.1);
		}
	};

	private final HotkeyListener saveListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_S, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.quickSaveToFile();
		}
	};

	private final HotkeyListener openListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_O, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.openLoadSetupDialog();
		}
	};

	private final HotkeyListener undoListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_Z, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().undo();
		}
	};

	private final HotkeyListener redoListener = new HotkeyListener(() -> new Keybind(KeyEvent.VK_Y, InputEvent.CTRL_DOWN_MASK))
	{
		@Override
		public void hotkeyPressed()
		{
			creatorsPanel.getToolBox().getTimeSheetPanel().redo();
		}
	};

	public MouseWheelEvent mouseWheelMoved(MouseWheelEvent event)
	{
		if (config.enableCtrlHotkeys() && event.isControlDown())
		{
			creatorsPanel.scrollSelectedCharacter(event.getWheelRotation());
			event.consume();
		}

		return event;
	}

	@Override
	public MouseEvent mousePressed(MouseEvent e)
	{
		if (config.enableCtrlHotkeys()
				&& e.getButton() == MouseEvent.BUTTON1
				&& client.isKeyPressed(KeyCode.KC_CONTROL))
		{
			mousePressed = true;
			clickX = e.getPoint().getX();
			clickY = e.getPoint().getY();
		}

		return e;
	}

	@Override
	public MouseEvent mouseReleased(MouseEvent e)
	{
		mousePressed = false;

		if (config.enableCtrlHotkeys() &&
				e.getButton() == MouseEvent.BUTTON1 &&
				client.isKeyPressed(KeyCode.KC_CONTROL) &&
				selectedCharacter != null)
		{
			double x = e.getX() - clickX;
			double y = -1 * (e.getY() - clickY);
			if (Math.sqrt(x * x + y * y) < 40)
			{
				return e;
			}

			final int yaw = client.getCameraYaw();
			final int pitch = client.getCameraPitch();
			int jUnit = Rotation.getJagexDegrees(x, y, yaw, pitch);
			setOrientation(selectedCharacter, jUnit);
		}

		return e;
	}

	@Override
	public MouseEvent mouseDragged(MouseEvent e)
	{
		return e;
	}

	@Override
	public MouseEvent mouseClicked(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseEntered(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseExited(MouseEvent e) {
		return e;
	}

	@Override
	public MouseEvent mouseMoved(MouseEvent e)
	{
		return e;
	}

	@Provides
	CreatorsConfig provideConfig(ConfigManager configManager)
	{
		return configManager.getConfig(CreatorsConfig.class);
	}
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class AnimSequence
{
    private AnimSequenceData mainHandData;
    private AnimSequenceData offHandData;
    private int mainHandItemId;
    private int offHandItemId;
}

package com.creatorskit.models;

import com.creatorskit.CreatorsPlugin;
import net.runelite.api.*;
import net.runelite.client.RuneLite;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import javax.swing.filechooser.FileFilter;
import java.awt.*;
import java.io.File;
import java.io.Reader;
import java.nio.file.Files;

public class ModelImporter
{
    @Inject
    private CreatorsPlugin plugin;

    @Inject
    private ClientThread clientThread;

    @Inject
    private Client client;

    public static final File BLENDER_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/blender-models");
    private final int BASIC_MODEL = 823;
    private final int TRANSPARENT_MODEL = 18871;
    private final int PRIORITY_MODEL = 6733;
    private final int BASIC_MODEL_2_4 = 15166;
    private final int BASIC_MODEL_3_7 = 21140;
    private final int ANIMATED_MODEL_2_5 = 21201;
    private final int ANIMATED_MODEL_13_13 = 80;
    private final int TEST_MODEL = 23901;

    public void openLoadDialog()
    {
        BLENDER_DIR.mkdirs();

        JFileChooser fileChooser = new JFileChooser(BLENDER_DIR);
        fileChooser.setDialogTitle("Choose a Blender model to load");

        JComboBox<LightingStyle> comboBox = new JComboBox<>();
        comboBox.setToolTipText("Sets the lighting style");
        comboBox.addItem(LightingStyle.ACTOR);
        comboBox.addItem(LightingStyle.DEFAULT);
        comboBox.addItem(LightingStyle.SPOTANIM);
        comboBox.addItem(LightingStyle.DYNAMIC);
        comboBox.addItem(LightingStyle.NONE);
        comboBox.setFocusable(false);

        JPanel accessory = new JPanel();
        accessory.setLayout(new GridLayout(0, 1));
        accessory.add(comboBox);

        fileChooser.setAccessory(accessory);
        fileChooser.setMultiSelectionEnabled(true);
        fileChooser.setFileFilter(new FileFilter()
        {
            @Override
            public String getDescription()
            {
                return "Json File (*.json)";
            }

            @Override
            public boolean accept(File f)
            {
                if (f.isDirectory())
                {
                    return true;
                }
                else
                {
                    String filename = f.getName().toLowerCase();
                    return filename.endsWith(".json");
                }
            }
        });

        int option = fileChooser.showOpenDialog(fileChooser);
        if (option == JFileChooser.APPROVE_OPTION)
        {
            File[] files = fileChooser.getSelectedFiles();
            for (File selectedFile : files)
            {
                loadBlenderModel(selectedFile, (LightingStyle) comboBox.getSelectedItem());
            }
        }
    }

    public void openLatestFile()
    {
        File directory = new File(BLENDER_DIR.getPath());
        File[] files = directory.listFiles(File::isFile);

        long lastModifiedTime = Long.MIN_VALUE;
        File chosenFile = null;
        if (files != null)
        {
            for (File file : files)
            {
                if (!file.getName().endsWith(".json"))
                {
                    continue;
                }

                if (file.lastModified() > lastModifiedTime)
                {
                    chosenFile = file;
                    lastModifiedTime = file.lastModified();
                }
            }
        }

        if (chosenFile == null)
        {
            plugin.sendChatMessage("Could not find the latest .json file in the " + RuneLite.RUNELITE_DIR + "\\creatorskit\\blender-models folder.");
            return;
        }

        loadBlenderModel(chosenFile, LightingStyle.ACTOR);
    }

    private void loadBlenderModel(File file, LightingStyle lightingStyle)
    {
        if (!file.exists())
        {
            file = new File(file.getPath() + ".json");
            if (!file.exists())
            {
                file = new File(file.getPath().replaceAll("/", "\\\\"));
                if (!file.exists())
                {
                    file = new File(file.getPath().replaceAll("/", "\\\\") + ".json");
                }
            }
        }

        if (!file.exists())
        {
            plugin.sendChatMessage("Failed to find file.");
            return;
        }

        String name = file.getName();
        if (name.endsWith(".json"))
            name = replaceLast(name);

        String finalName = name;
        File finalSelectedFile = file;
        clientThread.invokeLater(() ->
        {
            BlenderModel blenderModel;

            try
            {
                Reader reader = Files.newBufferedReader(finalSelectedFile.toPath());
                blenderModel = plugin.getGson().fromJson(reader, BlenderModel.class);
                reader.close();
            }
            catch (Exception e)
            {
                plugin.sendChatMessage("The file found was unreadable as a BlenderModel.");
                return;
            }

            if (blenderModel == null)
            {
                plugin.sendChatMessage("File was found but is incompatible or empty.");
                return;
            }

            addModel(blenderModel, lightingStyle, finalName);
        });
    }

    private String replaceLast(String string)
    {
        int lastIndex = string.lastIndexOf(".json");
        if (lastIndex < 0)
            return string;
        String tail = string.substring(lastIndex).replaceFirst(".json", "");
        return string.substring(0, lastIndex) + tail;
    }

    public void addModel(BlenderModel blenderModel, LightingStyle lightingStyle, String name)
    {
        Model model = createModel(blenderModel, lightingStyle);
        if (model == null)
            return;

        CustomLighting lighting = new CustomLighting(lightingStyle.getAmbient(), lightingStyle.getContrast(), lightingStyle.getX(), lightingStyle.getY(), lightingStyle.getZ());

        CustomModelComp comp = new CustomModelComp(0, CustomModelType.BLENDER, -1, null, null, null, blenderModel, lightingStyle, lighting, false, name);
        CustomModel customModel = new CustomModel(model, comp);
        plugin.addCustomModel(customModel, false);
    }

    public Model createModel(BlenderModel blenderModel, LightingStyle lightingStyle)
    {
        int vertexCount = blenderModel.getVertices().length;
        int[] verticesX = new int[vertexCount];
        int[] verticesY = new int[vertexCount];
        int[] verticesZ = new int[vertexCount];

        for (int i = 0; i < vertexCount; i++)
        {
            int[] v = blenderModel.getVertices()[i];
            verticesX[i] = v[0];
            verticesY[i] = v[1];
            verticesZ[i] = v[2];
        }

        int faceCount = blenderModel.getFaces().length;
        int[] faces1 = new int[faceCount];
        int[] faces2 = new int[faceCount];
        int[] faces3 = new int[faceCount];

        for (int i = 0; i < faceCount; i++)
        {
            int[] f = blenderModel.getFaces()[i];
            faces1[i] = f[0];
            faces2[i] = f[1];
            faces3[i] = f[2];
        }

        //{2_6 priority, 1_3, 1_2, 1_0, 1_3 transparent}
        int[] polys = new int[]{1, 0, 0, 0, 1};
        try
        {
            polys = getPolyCount(polys, faces1.length - 3, verticesX.length - 3);
        }
        catch (Exception e)
        {
            plugin.sendChatMessage("Could not import this Blender Model. It's likely that it contains too few faces or vertices.");
            return null;
        }

        //int[] polys = new int[]{0, 1, 0, 0, 0};
        //polys = getPolyCountAnimated(polys, faces1.length - 2, verticesX.length - 4);
        //System.out.println(polys[0] + "," + polys[1] + "," + polys[2] + "," + polys[3] + "," + polys[4]);
        ModelData modelData = constructModel(polys);
        if (modelData == null)
            return null;

        //System.out.println(faceCount + ", " + modelData.getFaceCount());
        //System.out.println(vertexCount + ", " + modelData.getVerticesCount());

        float[] vX = modelData.getVerticesX();
        float[] vY = modelData.getVerticesY();
        float[] vZ = modelData.getVerticesZ();
        int[] f1 = modelData.getFaceIndices1();
        int[] f2 = modelData.getFaceIndices2();
        int[] f3 = modelData.getFaceIndices3();
        short[] cols = modelData.getFaceColors();
        byte[] tps = modelData.getFaceTransparencies();

        for (int i = 0; i < modelData.getVerticesCount(); i++)
        {
            vX[i] = verticesX[i];
            vY[i] = verticesY[i];
            vZ[i] = verticesZ[i];
        }

        for (int i = 0; i < modelData.getFaceCount(); i++)
        {
            f1[i] = faces1[i];
            f2[i] = faces2[i];
            f3[i] = faces3[i];
        }

        if (!blenderModel.isUseVertexColours())
        {
            double[][] faceColours = blenderModel.getFaceColours();
            short[] colours = new short[faceColours.length];
            byte[] transparencies = new byte[faceColours.length];
            for (int i = 0; i < faceColours.length; i++)
            {
                double[] colour = faceColours[i];
                int colorHInt = (int) (63 - (colour[0] * 63));
                int colorLInt = (int) (colour[1] * 127);
                int colorSInt = (int) (colour[2] * 7);
                short jagexColor = JagexColor.packHSL(colorHInt, colorSInt, colorLInt);
                double tp = colour[3];
                tp *= -256;
                if (tp < -128)
                {
                    tp += 256;
                }

                transparencies[i] = (byte) tp;
                colours[i] = jagexColor;
            }

            int[] faceIndices = blenderModel.faceColourIndex;

            for (int i = 0; i < modelData.getFaceCount(); i++)
            {
                int index = faceIndices[i];
                cols[i] = colours[index];
                tps[i] = transparencies[index];
            }
        }

        Model model = modelData.light(
                lightingStyle.getAmbient(),
                lightingStyle.getContrast(),
                lightingStyle.getX(),
                lightingStyle.getZ() * -1,
                lightingStyle.getY());

        if (blenderModel.isUseVertexColours())
        {
            double[][] vertexColours = blenderModel.getVertexColours();
            short[] colours = new short[vertexColours.length];
            byte[] transparencies = new byte[vertexColours.length];
            for (int i = 0; i < vertexColours.length; i++)
            {
                double[] colour = vertexColours[i];
                int colorHInt = (int) (63 - (colour[0] * 63));
                int colorLInt = (int) (colour[1] * 127);
                int colorSInt = (int) (colour[2] * 7);
                short jagexColor = JagexColor.packHSL(colorHInt, colorSInt, colorLInt);
                double tp = colour[3];
                tp *= -256;
                if (tp < -128)
                {
                    tp += 256;
                }

                transparencies[i] = (byte) tp;
                colours[i] = jagexColor;
            }

            int[] fc1 = model.getFaceColors1();
            int[] fc2 = model.getFaceColors2();
            int[] fc3 = model.getFaceColors3();
            byte[] ftp = model.getFaceTransparencies();
            int[] vertexColourIndex = blenderModel.getVertexColourIndex();

            for (int i = 0; i < model.getFaceCount(); i++)
            {
                int col1 = colours[vertexColourIndex[i * 3]];
                int col2 = colours[vertexColourIndex[i * 3 + 1]];
                int col3 = colours[vertexColourIndex[i * 3 + 2]];

                if (col1 < 0)
                {
                    col1 += 65536;
                }

                if (col2 < 0)
                {
                    col2 += 65536;
                }

                if (col3 < 0)
                {
                    col3 += 65536;
                }

                fc1[i] = col1;
                fc2[i] = col2;
                fc3[i] = col3;
                int tp = (transparencies[vertexColourIndex[i * 3]] + transparencies[vertexColourIndex[i * 3 + 1]] + transparencies[vertexColourIndex[i * 3 + 2]]) / 3;
                ftp[i] = (byte) tp;
            }
        }

        byte[] priorities = blenderModel.getPriorities();
        byte[] facePriorities = model.getFaceRenderPriorities();
        for (int i = 0; i < model.getFaceCount(); i++)
        {
            facePriorities[i] = priorities[i];
        }

        return model;
    }

    public int[] getPolyCount(int[] polys, int facesRemaining, int verticesRemaining)
    {
        //int[2_6 priority, 1_3, 1_2, 1_0, 1_3 transparent] for [face_vertices]
        //System.out.println("FacesRemaining " + facesRemaining + ", verticesRemaining: " + verticesRemaining);
        if (facesRemaining == 0 && verticesRemaining == 0)
            return polys;

        double divisor = (double) verticesRemaining / facesRemaining;
        // if there's a 1:3 ratio of faces:vertices, close out the function
        if (divisor == 3)
        {
            polys[1] += facesRemaining;
            return polys;
        }

        // if there's a 1:2 ratio of faces:vertices, close out the function
        if (divisor == 2)
        {
            polys[2] += facesRemaining;
            return polys;
        }

        //Effectively while-loop till face count drops below vertex count
        if (facesRemaining + 2 > verticesRemaining)
        {
            int change = facesRemaining + 2 - verticesRemaining;
            polys[3] += change;
            facesRemaining -= change;
            return getPolyCount(polys, facesRemaining, verticesRemaining);
        }

        //if remaining vertices is even, keep even. If odd, change to even
        if (verticesRemaining % 2 == 0)
        {
            polys[2] += 1;
            facesRemaining--;
            verticesRemaining -= 2;
        }
        else
        {
            polys[1] += 1;
            facesRemaining--;
            verticesRemaining -= 3;
        }

        return getPolyCount(polys, facesRemaining, verticesRemaining);
    }

    private ModelData constructModel(int[] polys)
    {
        ModelData[] modelsToMerge = new ModelData[]{};

        ModelData polyPriority = client.loadModelData(PRIORITY_MODEL);
        if (polyPriority != null)
        {
            polyPriority.cloneColors().cloneVertices();
            float[] vX = polyPriority.getVerticesX();
            float[] vY = polyPriority.getVerticesY();
            float[] vZ = polyPriority.getVerticesZ();

            vX[0] = vX[1] = 64;
            vY[0] = vY[1] = 0;
            vZ[0] = vZ[1] = -64;

            vX[2] = vX[3] = -64;
            vY[2] = vY[3] = 0;
            vZ[2] = vZ[3] = 64;

            vX[4] = vX[5] = -64;
            vY[4] = vY[5] = 0;
            vZ[4] = vZ[5] = -64;

            modelsToMerge = ArrayUtils.add(modelsToMerge, polyPriority);
        }
        else
        {
            return null;
        }

        ModelData poly_transparent = client.loadModelData(TRANSPARENT_MODEL);
        if (poly_transparent != null)
        {
            poly_transparent.cloneColors().cloneVertices().cloneTransparencies();
            float[] vX = poly_transparent.getVerticesX();
            float[] vY = poly_transparent.getVerticesY();
            float[] vZ = poly_transparent.getVerticesZ();

            vX[0] = 64;
            vY[0] = 0;
            vZ[0] = -64;

            vX[1] = -64;
            vY[1] = 0;
            vZ[1] = 64;

            vX[2] = -64;
            vY[2] = 0;
            vZ[2] = -64;

            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_transparent);
        }
        else
        {
            return null;
        }

        for (int i = 0; i < polys[1]; i++)
        {
            ModelData poly_1_3 = client.loadModelData(BASIC_MODEL);
            if (poly_1_3 == null)
                return null;

            poly_1_3.cloneColors().cloneVertices().translate(i + 1, i + 1, i + 1);
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_3);
        }

        int translateBy = 128;
        for (int i = 0; i < polys[2]; i++)
        {
            ModelData poly_1_2 = client.loadModelData(BASIC_MODEL);
            if (poly_1_2 == null)
                return null;

            poly_1_2.cloneColors().cloneVertices().translate((i + 1) * translateBy, 0, 0);
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_2);
        }

        for (int i = 0; i < polys[3]; i++)
        {
            ModelData poly_1_0 = client.loadModelData(BASIC_MODEL);
            if (poly_1_0 == null)
                return null;

            poly_1_0.cloneColors().cloneVertices();
            modelsToMerge = ArrayUtils.add(modelsToMerge, poly_1_0);
        }

        return client.mergeModels(modelsToMerge);
    }
}

package com.creatorskit.models;

import com.creatorskit.models.datatypes.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.kit.KitType;
import okhttp3.*;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CountDownLatch;

@Slf4j
@Getter
public class DataFinder
{

    public enum DataType
    {
        NPC,
        OBJECT,
        SPOTANIM,
        ITEM,
        KIT,
        SEQ,
        ANIM,
        WEAPON_ANIM
    }

    @Data
    private static class LoadCallback
    {
        private final Runnable callback;
        private boolean done = false;
        public void run() { if (!done) { done = true; callback.run(); } }
    }

    private final ConcurrentHashMap<DataType, List<LoadCallback>> loadCallbacks = new ConcurrentHashMap<>(){{
        Arrays.stream(DataType.values()).forEach(d -> this.put(d, new ArrayList<>()));
    }};
    private final ConcurrentHashMap<DataType, Boolean> loadState = new ConcurrentHashMap<>(){{
        Arrays.stream(DataType.values()).forEach(d -> this.put(d, false));
    }};

    private Gson gson;
    OkHttpClient httpClient;

    private String lastFound;
    private int lastAnim;

    private final List<NPCData> npcData = new ArrayList<>();
    private final List<ObjectData> objectData = new ArrayList<>();
    private final List<SpotanimData> spotanimData = new ArrayList<>();
    private final List<ItemData> itemData = new ArrayList<>();
    private final List<KitData> kitData = new ArrayList<>();
    private final List<SeqData> seqData = new ArrayList<>();
    private final List<AnimData> animData = new ArrayList<>();
    private final List<WeaponAnimData> weaponAnimData = new ArrayList<>();

    private static final BodyPart[] bodyParts = new BodyPart[]{
            BodyPart.HEAD,
            BodyPart.CAPE,
            BodyPart.AMULET,
            BodyPart.WEAPON,
            BodyPart.TORSO,
            BodyPart.SHIELD,
            BodyPart.ARMS,
            BodyPart.LEGS,
            BodyPart.HAIR,
            BodyPart.HANDS,
            BodyPart.FEET,
            BodyPart.JAW,
            BodyPart.SPOTANIM};
    private static final int WEAPON_IDX = 3;
    private static final int SHIELD_IDX = 5;

    @Inject
    public DataFinder(Gson gson, OkHttpClient httpClient)
    {
        this.gson = gson;
        this.httpClient = httpClient;

        lookupNPCData();
        lookupObjectData();
        lookupSpotAnimData();
        lookupItemData();
        lookupKitData();
        lookupSeqData();
        lookupAnimData();
        lookupWeaponAnimationData();
    }

    /**
     * <p>Adds a callback to be executed once the specified data type has been loaded.</p>
     * <p>The callback will run on the same thread that executes the load operation.</p>
     * <p>If thread-specific execution is needed, it should be handled within the callback.</p>
     * @param dataType The DataType for which to add the callback
     * @param callback The Runnable to execute once the data has been loaded
     */
    public void addLoadCallback(DataType dataType, Runnable callback)
    {
        LoadCallback cbe = new LoadCallback(callback);
        boolean shouldRun;
        synchronized (dataType)
        {
            shouldRun = loadState.get(dataType);
            if(!shouldRun) loadCallbacks.get(dataType).add(cbe);
        }
        if (shouldRun) cbe.run();
    }

    private void executeCallbacks(DataType dataType)
    {
        List<LoadCallback> callbacksToExecute;
        synchronized (dataType)
        {
            loadState.put(dataType, true);
            callbacksToExecute = new ArrayList<>(loadCallbacks.get(dataType));
            loadCallbacks.get(dataType).clear();
        }
        callbacksToExecute.forEach(LoadCallback::run);
    }

    public boolean isDataLoaded(DataType dataType) { return loadState.get(dataType); }

    private void lookupKitData()
    {
        Request kitRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/kit.json")
                .build();
        Call kitCall = httpClient.newCall(kitRequest);
        kitCall.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/kit.json");
                executeCallbacks(DataType.KIT);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                    Type listType = new TypeToken<List<KitData>>() {}.getType();
                    List<KitData> list = gson.fromJson(reader, listType);
                    kitData.addAll(list);

                    response.body().close();
                }
                executeCallbacks(DataType.KIT);
            }
        });
    }

    private void lookupSeqData()
    {
        Request seqRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/sequences.json")
                .build();
        Call call = httpClient.newCall(seqRequest);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/sequences.json");
                executeCallbacks(DataType.SEQ);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                    Type listType = new TypeToken<List<SeqData>>() {}.getType();
                    List<SeqData> list = gson.fromJson(reader, listType);
                    seqData.addAll(list);

                    response.body().close();
                }
                executeCallbacks(DataType.SEQ);
            }
        });
    }

    private void lookupAnimData()
    {
        Request animRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/anims.json")
                .build();
        Call call = httpClient.newCall(animRequest);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/anims.json");
                executeCallbacks(DataType.ANIM);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                    Type listType = new TypeToken<List<AnimData>>() {}.getType();
                    List<AnimData> list = gson.fromJson(reader, listType);
                    animData.addAll(list);

                    response.body().close();
                }
                executeCallbacks(DataType.ANIM);
            }
        });
    }

    public ModelStats[] findModelsForPlayer(boolean groundItem, boolean maleItem, int[] items, int animId, int[] spotAnims)
    {
        //Convert equipmentId to itemId or kitId as appropriate
        int[] ids = new int[items.length];

        int[] itemShortList = new int[items.length];
        int[] kitShortList = new int[items.length];

        for (int i = 0; i < ids.length; i++)
        {
            int item = items[i];

            if (item >= PlayerComposition.KIT_OFFSET && item <= PlayerComposition.ITEM_OFFSET)
            {
                kitShortList[i] = item - PlayerComposition.KIT_OFFSET;
            }
            else
            {
                kitShortList[i] = -1;
            }

            if (item > PlayerComposition.ITEM_OFFSET)
            {
                itemShortList[i] = item - PlayerComposition.ITEM_OFFSET;
            }
            else
            {
                itemShortList[i] = -1;
            }
        }

        AnimSequence animSequence = new AnimSequence(
                AnimSequenceData.UNALTERED,
                AnimSequenceData.UNALTERED,
                -1,
                -1);

        if (animId != -1)
        {
            removePlayerItems(animSequence, animId);
        }

        //for ItemIds
        ArrayList<ModelStats> itemArray = new ArrayList<>();
        getPlayerItems(itemArray, groundItem, maleItem, itemShortList, animSequence);

        //for KitIds
        ArrayList<ModelStats> kitArray = new ArrayList<>();
        getPlayerKit(kitArray, kitShortList);

        ArrayList<ModelStats> spotAnimArray = new ArrayList<>();
        if (spotAnims.length > 0)
        {
            getPlayerSpotAnims(spotAnims, spotAnimArray);
        }

        itemArray.addAll(kitArray);
        itemArray.addAll(spotAnimArray);
        ArrayList<ModelStats> orderedItems = new ArrayList<>();
        for (int e = 0; e < bodyParts.length; e++)
        {
            for (int i = 0; i < itemArray.size(); i++)
            {
                ModelStats modelStats = itemArray.get(i);
                if (modelStats.getBodyPart() == bodyParts[e])
                {
                    if (!orderedItems.contains(modelStats))
                    {
                        orderedItems.add(modelStats);
                    }
                }
            }
        }

        return orderedItems.toArray(new ModelStats[0]);
    }

    public void removePlayerItems(AnimSequence animSequence, int animId)
    {
        for (SeqData seqDatum : seqData)
        {
            if (seqDatum.getId() == animId)
            {
                int offHandItem = seqDatum.getLeftHandItem();
                switch (offHandItem)
                {
                    case -1:
                        break;
                    case 0:
                        animSequence.setOffHandData(AnimSequenceData.HIDE);
                        break;
                    default:
                        animSequence.setOffHandItemId(offHandItem - 512);
                        animSequence.setOffHandData(AnimSequenceData.SWAP);
                }

                int mainHandItem = seqDatum.getRightHandItem();
                switch (mainHandItem)
                {
                    case -1:
                        break;
                    case 0:
                        animSequence.setMainHandData(AnimSequenceData.HIDE);
                        break;
                    default:
                        animSequence.setMainHandItemId(mainHandItem - 512);
                        animSequence.setMainHandData(AnimSequenceData.SWAP);
                }
                break;
            }
        }
    }

    public void getPlayerItems(ArrayList<ModelStats> modelStats, boolean groundItem, boolean maleItem, int[] itemId, AnimSequence animSequence)
    {
        AnimSequenceData mainHand = animSequence.getMainHandData();
        AnimSequenceData offHand = animSequence.getOffHandData();

        int[] updatedItemIds = Arrays.copyOf(itemId, itemId.length);

        switch (mainHand)
        {
            case UNALTERED:
                switch (offHand)
                {
                    case UNALTERED:
                        break;
                    case HIDE:
                        updatedItemIds[SHIELD_IDX] = -1;
                        break;
                    case SWAP:
                        updatedItemIds[SHIELD_IDX] = animSequence.getOffHandItemId();
                }
                break;
            case SWAP:
                switch (offHand)
                {
                    case UNALTERED:
                        updatedItemIds[WEAPON_IDX] = animSequence.getMainHandItemId();
                        break;
                    case HIDE:
                        updatedItemIds[WEAPON_IDX] = -1;
                        updatedItemIds[SHIELD_IDX] = animSequence.getMainHandItemId();
                        break;
                    case SWAP:
                        updatedItemIds[SHIELD_IDX] = animSequence.getMainHandItemId();
                        updatedItemIds[WEAPON_IDX] = animSequence.getOffHandItemId();
                }
                break;
            case HIDE:
                switch (offHand)
                {
                    case UNALTERED:
                        updatedItemIds[WEAPON_IDX] = -1;
                        break;
                    case HIDE:
                        updatedItemIds[WEAPON_IDX] = -1;
                        updatedItemIds[SHIELD_IDX] = -1;
                        break;
                    case SWAP:
                        updatedItemIds[WEAPON_IDX] = animSequence.getOffHandItemId();
                        updatedItemIds[SHIELD_IDX] = -1;
                }
                break;
        }

        int itemsToComplete = updatedItemIds.length;
        for (int i : updatedItemIds)
        {
            if (i == -1)
            {
                itemsToComplete--;
            }
        }

        for (ItemData itemDatum : itemData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i = 0; i < updatedItemIds.length; i++)
            {
                int item = updatedItemIds[i];
                if (item == -1)
                {
                    continue;
                }

                if (itemDatum.getId() == item)
                {
                    itemsToComplete--;
                    int[] modelIds = new int[0];
                    int offset = 0;

                    if (groundItem)
                    {
                        modelIds = ArrayUtils.add(modelIds, itemDatum.getInventoryModel());
                    }
                    else if (maleItem)
                    {
                        modelIds = ArrayUtils.addAll(modelIds, itemDatum.getMaleModel0(), itemDatum.getMaleModel1(), itemDatum.getMaleModel2());
                        offset = itemDatum.getMaleOffset();
                    }
                    else
                    {
                        modelIds = ArrayUtils.addAll(modelIds, itemDatum.getFemaleModel0(), itemDatum.getFemaleModel1(), itemDatum.getFemaleModel2());
                        offset = itemDatum.getFemaleOffset();
                    }

                    short[] rf = new short[0];
                    short[] rt = new short[0];

                    if (itemDatum.getColorReplace() != null)
                    {
                        int[] recolorToReplace = itemDatum.getColorReplace();
                        int[] recolorToFind = itemDatum.getColorFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    short[] rtFrom = new short[0];
                    short[] rtTo = new short[0];

                    if (itemDatum.getTextureReplace() != null)
                    {
                        int[] textureToReplace = itemDatum.getTextureReplace();
                        int[] retextureToFind = itemDatum.getTextureFind();
                        rtFrom = new short[textureToReplace.length];
                        rtTo = new short[textureToReplace.length];

                        for (int e = 0; e < rtFrom.length; e++)
                        {
                            rtFrom[e] = (short) retextureToFind[e];
                            rtTo[e] = (short) textureToReplace[e];
                        }
                    }

                    LightingStyle ls = LightingStyle.ACTOR;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient(),
                            ls.getContrast(),
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    for (int id : modelIds)
                    {
                        if (id != -1)
                        {
                            modelStats.add(new ModelStats(
                                    id,
                                    bodyParts[i],
                                    rf,
                                    rt,
                                    rtFrom,
                                    rtTo,
                                    itemDatum.getResizeX(),
                                    itemDatum.getResizeZ(),
                                    itemDatum.getResizeY(),
                                    offset * -1,
                                    customLighting
                            ));
                        }
                    }

                    break;
                }
            }
        }
    }

    public void getPlayerKit(ArrayList<ModelStats> modelStats, int[] kitId)
    {
        int itemsToComplete = kitId.length;
        for (int i : kitId)
        {
            if (i == -1)
            {
                itemsToComplete--;
            }
        }

        for (KitData kitData : kitData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i = 0; i < kitId.length; i++)
            {
                int item = kitId[i];
                if (item == -1)
                {
                    continue;
                }

                if (kitData.getId() == item)
                {
                    itemsToComplete--;
                    int[] modelIds = kitData.getModels();

                    short[] rf = new short[0];
                    short[] rt = new short[0];

                    if (kitData.getRecolorToReplace() != null)
                    {
                        int[] recolorToReplace = kitData.getRecolorToReplace();
                        int[] recolorToFind = kitData.getRecolorToFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    LightingStyle ls = LightingStyle.ACTOR;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient(),
                            ls.getContrast(),
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    for (int id : modelIds)
                    {
                        if (id != -1)
                        {
                            modelStats.add(new ModelStats(
                                    id,
                                    bodyParts[i],
                                    rf,
                                    rt,
                                    new short[0],
                                    new short[0],
                                    128,
                                    128,
                                    128,
                                    0,
                                    customLighting
                            ));
                        }
                    }

                    break;
                }
            }
        }
    }

    public void getPlayerSpotAnims(int[] spotAnims, ArrayList<ModelStats> modelStats)
    {
        int itemsToComplete = spotAnims.length;

        for (SpotanimData spotanimData : spotanimData)
        {
            if (itemsToComplete == 0)
            {
                break;
            }

            for (int i : spotAnims)
            {
                if (spotanimData.getId() == i)
                {
                    itemsToComplete--;
                    int modelId = spotanimData.getModelId();

                    short[] rf = new short[0];
                    short[] rt = new short[0];
                    if (spotanimData.getRecolorToReplace() != null)
                    {
                        int[] recolorToReplace = spotanimData.getRecolorToReplace();
                        int[] recolorToFind = spotanimData.getRecolorToFind();
                        rf = new short[recolorToReplace.length];
                        rt = new short[recolorToReplace.length];

                        for (int e = 0; e < rf.length; e++)
                        {
                            int rfi = recolorToFind[e];
                            if (rfi > 32767)
                            {
                                rfi -= 65536;
                            }
                            rf[e] = (short) rfi;

                            int rti = recolorToReplace[e];
                            if (rti > 32767)
                            {
                                rti -= 65536;
                            }
                            rt[e] = (short) rti;
                        }
                    }

                    int ambient = spotanimData.getAmbient();
                    int contrast = spotanimData.getContrast();

                    LightingStyle ls = LightingStyle.SPOTANIM;
                    CustomLighting customLighting = new CustomLighting(
                            ls.getAmbient() + ambient,
                            ls.getContrast() + contrast,
                            ls.getX(),
                            ls.getY(),
                            ls.getZ());

                    modelStats.add(new ModelStats(
                            modelId,
                            BodyPart.SPOTANIM,
                            rf,
                            rt,
                            new short[0],
                            new short[0],
                            spotanimData.getResizeX(),
                            spotanimData.getResizeX(),
                            spotanimData.getResizeY(),
                            0,
                            customLighting
                    ));

                    break;
                }
            }
        }
    }

    private void lookupSpotAnimData()
    {
        Request spotanimRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/spotanims.json")
                .build();
        Call call = httpClient.newCall(spotanimRequest);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/spotanims.json");
                executeCallbacks(DataType.SPOTANIM);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {

                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                    Type listType = new TypeToken<List<SpotanimData>>() {}.getType();
                    List<SpotanimData> list = gson.fromJson(reader, listType);

                    spotanimData.addAll(list);
                    response.body().close();
                }
                executeCallbacks(DataType.SPOTANIM);
            }
        });
    }

    public ModelStats[] findSpotAnim(int spotAnimId)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (SpotanimData spotanimData : spotanimData)
        {
            if (spotanimData.getId() == spotAnimId)
            {
                int modelId = spotanimData.getModelId();

                lastFound = spotanimData.getName();
                lastAnim = spotanimData.getAnimationId();

                short[] rf = new short[0];
                short[] rt = new short[0];
                if (spotanimData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = spotanimData.getRecolorToReplace();
                    int[] recolorToFind = spotanimData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int e = 0; e < rf.length; e++)
                    {
                        int rfi = recolorToFind[e];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[e] = (short) rfi;

                        int rti = recolorToReplace[e];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[e] = (short) rti;
                    }
                }

                int ambient = spotanimData.getAmbient();
                int contrast = spotanimData.getContrast();

                LightingStyle ls = LightingStyle.SPOTANIM;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient() + ambient,
                        ls.getContrast() + contrast,
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                modelStats.add(new ModelStats(
                        modelId,
                        BodyPart.SPOTANIM,
                        rf,
                        rt,
                        new short[0],
                        new short[0],
                        spotanimData.getResizeX(),
                        spotanimData.getResizeX(),
                        spotanimData.getResizeY(),
                        0,
                        customLighting));
            }
        }

        if (modelStats.isEmpty())
        {
            return null;
        }

        return new ModelStats[]{modelStats.get(0)};
    }

    public ModelStats[] findSpotAnim(SpotanimData spotanimData)
    {
        if (spotanimData == null)
        {
            return null;
        }

        ArrayList<ModelStats> modelStats = new ArrayList<>();
        int modelId = spotanimData.getModelId();

        lastFound = spotanimData.getName();
        lastAnim = spotanimData.getAnimationId();

        short[] rf = new short[0];
        short[] rt = new short[0];
        if (spotanimData.getRecolorToReplace() != null)
        {
            int[] recolorToReplace = spotanimData.getRecolorToReplace();
            int[] recolorToFind = spotanimData.getRecolorToFind();
            rf = new short[recolorToReplace.length];
            rt = new short[recolorToReplace.length];

            for (int e = 0; e < rf.length; e++)
            {
                int rfi = recolorToFind[e];
                if (rfi > 32767)
                {
                    rfi -= 65536;
                }
                rf[e] = (short) rfi;

                int rti = recolorToReplace[e];
                if (rti > 32767)
                {
                    rti -= 65536;
                }
                rt[e] = (short) rti;
            }
        }

        int ambient = spotanimData.getAmbient();
        int contrast = spotanimData.getContrast();

        LightingStyle ls = LightingStyle.SPOTANIM;
        CustomLighting customLighting = new CustomLighting(
                ls.getAmbient() + ambient,
                ls.getContrast() + contrast,
                ls.getX(),
                ls.getY(),
                ls.getZ());

        modelStats.add(new ModelStats(
                modelId,
                BodyPart.SPOTANIM,
                rf,
                rt,
                new short[0],
                new short[0],
                spotanimData.getResizeX(),
                spotanimData.getResizeX(),
                spotanimData.getResizeY(),
                0,
                customLighting));

        return new ModelStats[]{modelStats.get(0)};
    }

    public SpotanimData getSpotAnimData(int spotAnimId)
    {
        for (SpotanimData data : spotanimData)
        {
            if (data.getId() == spotAnimId)
            {
                return data;
            }
        }

        return null;
    }

    public void lookupNPCData()
    {
        Request request = new Request.Builder().url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/npc_defs.json").build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/npc_defs.json");
                executeCallbacks(DataType.NPC);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());

                    Type listType = new TypeToken<List<NPCData>>() {}.getType();
                    List<NPCData> list = gson.fromJson(reader, listType);

                    npcData.addAll(list);
                    npcData.sort(Comparator.comparing(NPCData::getName));
                    response.body().close();
                }
                executeCallbacks(DataType.NPC);
            }
        });
    }

    public NPCData findNPCData(NPC npc)
    {
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npc.getId())
            {
                return npcData;
            }
        }

        return null;
    }

    public ModelStats[] findModelsForNPC(int npcId)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = npcData.getModels();

                short[] rf = new short[0];
                short[] rt = new short[0];

                if (npcData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = npcData.getRecolorToReplace();
                    int[] recolorToFind = npcData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int i = 0; i < rf.length; i++)
                    {
                        int rfi = recolorToFind[i];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[i] = (short) rfi;

                        int rti = recolorToReplace[i];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[i] = (short) rti;
                    }
                }

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            rf,
                            rt,
                            new short[0],
                            new short[0],
                            npcData.getWidthScale(),
                            npcData.getWidthScale(),
                            npcData.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    public ModelStats[] findModelsForNPC(int npcId, NpcOverrides overrides)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = overrides.getModelIds();

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            new short[0],
                            new short[0],
                            new short[0],
                            new short[0],
                            npcData.getWidthScale(),
                            npcData.getWidthScale(),
                            npcData.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    public ModelStats[] findModelsForNPC(int npcId, NPCComposition composition)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();
        for (NPCData npcData : npcData)
        {
            if (npcData.getId() == npcId)
            {
                lastFound = npcData.getName();
                lastAnim = npcData.getStandingAnimation();

                int[] modelIds = composition.getModels();
                short[] colourToReplace = composition.getColorToReplace();
                short[] colourToReplaceWith = composition.getColorToReplaceWith();

                if (colourToReplace == null || colourToReplaceWith == null)
                {
                    colourToReplace = new short[0];
                    colourToReplaceWith = new short[0];
                }

                LightingStyle ls = LightingStyle.ACTOR;
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            colourToReplace,
                            colourToReplaceWith,
                            new short[0],
                            new short[0],
                            composition.getWidthScale(),
                            composition.getWidthScale(),
                            composition.getHeightScale(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    private void lookupObjectData()
    {
        Request request = new Request.Builder().url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/object_defs.json").build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/object_defs.json");
                executeCallbacks(DataType.OBJECT);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    //create a reader to read the URL
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());

                    Type listType = new TypeToken<List<ObjectData>>() {}.getType();
                    List<ObjectData> list = gson.fromJson(reader, listType);

                    objectData.addAll(list);
                    objectData.sort(Comparator.comparing(ObjectData::getName));
                    response.body().close();
                }
                executeCallbacks(DataType.OBJECT);
            }
        });
    }

    public ModelStats[] findModelsForObject(int objectId, int modelType, LightingStyle ls, boolean firstModelType)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();

        for (ObjectData objectData : objectData)
        {
            if (objectData.getId() == objectId)
            {
                lastFound = objectData.getName();
                int[] modelIds = objectData.getObjectModels();
                if (modelIds == null)
                {
                    return new ModelStats[0];
                }

                int[] objectTypes = objectData.getObjectTypes();
                if (objectTypes != null && objectTypes.length > 0)
                {
                    if (firstModelType)
                    {
                        int modelId = modelIds[0];
                        modelIds = new int[]{modelId};
                    }
                    else
                    {
                        for (int i = 0; i < objectTypes.length; i++)
                        {
                            if (objectTypes[i] == modelType)
                            {
                                int modelId = modelIds[i];
                                modelIds = new int[]{modelId};
                                break;
                            }
                        }
                    }
                }

                short[] rf = new short[0];
                short[] rt = new short[0];
                if (objectData.getRecolorToReplace() != null)
                {
                    int[] recolorToReplace = objectData.getRecolorToReplace();
                    int[] recolorToFind = objectData.getRecolorToFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int i = 0; i < rf.length; i++)
                    {
                        int rfi = recolorToFind[i];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[i] = (short) rfi;

                        int rti = recolorToReplace[i];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[i] = (short) rti;
                    }
                }

                short[] rtFrom = new short[0];
                short[] rtTo = new short[0];

                if (objectData.getTextureToReplace() != null && objectData.getRetextureToFind() != null)
                {
                    int[] textureToReplace = objectData.getTextureToReplace();
                    int[] retextureToFind = objectData.getRetextureToFind();
                    rtFrom = new short[textureToReplace.length];
                    rtTo = new short[textureToReplace.length];

                    for (int i = 0; i < rtFrom.length; i++)
                    {
                        rtFrom[i] = (short) retextureToFind[i];
                        rtTo[i] = (short) textureToReplace[i];
                    }
                }

                int ambient = objectData.getAmbient();
                int contrast = objectData.getContrast();
                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient() + ambient,
                        ls.getContrast() + contrast,
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i : modelIds)
                {
                    modelStats.add(new ModelStats(
                            i,
                            BodyPart.NA,
                            rf,
                            rt,
                            rtFrom,
                            rtTo,
                            objectData.getModelSizeX(),
                            objectData.getModelSizeY(),
                            objectData.getModelSizeZ(),
                            0,
                            customLighting
                    ));
                }

                break;
            }
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    private void lookupItemData()
    {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        Request itemRequest = new Request.Builder()
                .url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/item_defs.json")
                .build();
        Call itemCall = httpClient.newCall(itemRequest);
        itemCall.enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/master/.venv/item_defs.json");
                countDownLatch.countDown();
                executeCallbacks(DataType.ITEM);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());
                    Type listType = new TypeToken<List<ItemData>>() {}.getType();
                    List<ItemData> list = gson.fromJson(reader, listType);
                    itemData.addAll(list);
                    itemData.sort(Comparator.comparing(ItemData::getName));

                    response.body().close();
                }
                executeCallbacks(DataType.ITEM);
            }
        });
    }

    public ModelStats[] findModelsForGroundItem(int itemId, CustomModelType modelType)
    {
        ArrayList<ModelStats> modelStats = new ArrayList<>();

        for (ItemData item : itemData)
        {
            if (item.getId() == itemId)
            {
                lastFound = item.getName();
                int[] modelIds = new int[0];

                switch (modelType)
                {
                    default:
                    case CACHE_GROUND_ITEM:
                        modelIds = ArrayUtils.add(modelIds, item.getInventoryModel());
                        break;
                    case CACHE_MAN_WEAR:
                        modelIds = ArrayUtils.addAll(modelIds, item.getMaleModel0(), item.getMaleModel1(), item.getMaleModel2());
                        break;
                    case CACHE_WOMAN_WEAR:
                        modelIds = ArrayUtils.addAll(modelIds, item.getFemaleModel0(), item.getFemaleModel1(), item.getFemaleModel2());
                }

                short[] rf = new short[0];
                short[] rt = new short[0];

                if (item.getColorReplace() != null)
                {
                    int[] recolorToReplace = item.getColorReplace();
                    int[] recolorToFind = item.getColorFind();
                    rf = new short[recolorToReplace.length];
                    rt = new short[recolorToReplace.length];

                    for (int e = 0; e < rf.length; e++)
                    {
                        int rfi = recolorToFind[e];
                        if (rfi > 32767)
                        {
                            rfi -= 65536;
                        }
                        rf[e] = (short) rfi;

                        int rti = recolorToReplace[e];
                        if (rti > 32767)
                        {
                            rti -= 65536;
                        }
                        rt[e] = (short) rti;
                    }
                }

                short[] rtFrom = new short[0];
                short[] rtTo = new short[0];

                if (item.getTextureReplace() != null)
                {
                    int[] textureToReplace = item.getTextureReplace();
                    int[] retextureToFind = item.getTextureFind();
                    rtFrom = new short[textureToReplace.length];
                    rtTo = new short[textureToReplace.length];

                    for (int e = 0; e < rtFrom.length; e++)
                    {
                        rtFrom[e] = (short) retextureToFind[e];
                        rtTo[e] = (short) textureToReplace[e];
                    }
                }

                LightingStyle ls;

                switch (modelType)
                {
                    default:
                    case CACHE_GROUND_ITEM:
                        ls = LightingStyle.DEFAULT;
                        break;
                    case CACHE_MAN_WEAR:
                    case CACHE_WOMAN_WEAR:
                        ls = LightingStyle.ACTOR;
                }

                CustomLighting customLighting = new CustomLighting(
                        ls.getAmbient(),
                        ls.getContrast(),
                        ls.getX(),
                        ls.getY(),
                        ls.getZ());

                for (int i = 0; i < modelIds.length; i++)
                {
                    int id = modelIds[i];
                    int wearPos;
                    switch (i)
                    {
                        default:
                        case 0:
                            wearPos = item.getWearPos0();
                            break;
                        case 1:
                            wearPos = item.getWearPos1();
                            break;
                        case 2:
                            wearPos = item.getWearPos2();
                    }

                    if (id != -1)
                    {
                        modelStats.add(new ModelStats(
                                id,
                                BodyPart.wearPosToBodyPart(wearPos),
                                rf,
                                rt,
                                rtFrom,
                                rtTo,
                                item.getResizeX(),
                                item.getResizeZ(),
                                item.getResizeY(),
                                0,
                                customLighting
                        ));
                    }
                }

                break;
            }
        }

        if (modelStats.isEmpty())
        {
            return null;
        }

        ModelStats[] stats = new ModelStats[modelStats.size()];
        for (int i = 0; i < modelStats.size(); i++)
        {
            stats[i] = modelStats.get(i);
        }

        return stats;
    }

    private void lookupWeaponAnimationData()
    {
        Request request = new Request.Builder().url("https://raw.githubusercontent.com/ScreteMonge/cache-converter/refs/heads/master/.venv/weapon_animations.json").build();
        Call call = httpClient.newCall(request);
        call.enqueue(new Callback()
        {
            @Override
            public void onFailure(Call call, IOException e)
            {
                log.debug("Failed to access URL: https://raw.githubusercontent.com/ScreteMonge/cache-converter/refs/heads/master/.venv/weapon_animations.json");
                executeCallbacks(DataType.WEAPON_ANIM);
            }

            @Override
            public void onResponse(Call call, Response response)
            {
                if (response.isSuccessful() && response.body() != null)
                {
                    //create a reader to read the URL
                    InputStreamReader reader = new InputStreamReader(response.body().byteStream());

                    Type listType = new TypeToken<List<WeaponAnimData>>() {}.getType();
                    List<WeaponAnimData> list = gson.fromJson(reader, listType);

                    weaponAnimData.addAll(list);
                    response.body().close();
                }
                executeCallbacks(DataType.WEAPON_ANIM);
            }
        });
    }

    public WeaponAnimData findWeaponAnimData(int itemId)
    {
        for (WeaponAnimData weaponAnim : weaponAnimData)
        {
            int[] ids = weaponAnim.getId();
            if (ids == null || ids.length == 0)
            {
                continue;
            }

            for (int i : ids)
            {
                if (i == itemId)
                {
                    return weaponAnim;
                }
            }
        }

        return null;
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class ModelStats
{
    private int modelId;
    private BodyPart bodyPart;
    private short[] recolourFrom;
    private short[] recolourTo;
    private short[] textureFrom;
    private short[] textureTo;
    private int resizeX;
    private int resizeY;
    private int resizeZ;
    private int translateZ;
    private CustomLighting lighting;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CustomLighting
{
    private int ambient;
    private int contrast;
    private int x;
    private int y;
    private int z;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public enum BodyPart
{
    NA("Name"),
    HEAD("Head"),
    CAPE("Cape"),
    AMULET("Amulet"),
    WEAPON("Weapon"),
    TORSO("Torso"),
    SHIELD("Shield"),
    ARMS("Arms"),
    LEGS("Legs"),
    HAIR("Hair"),
    HANDS("Hands"),
    FEET("Feet"),
    JAW("Jaw"),
    SPOTANIM("SpotAnim");

    private final String name;

    public static BodyPart wearPosToBodyPart(int wearPos)
    {
        switch (wearPos)
        {
            case 0:
                return HEAD;
            case 1:
                return CAPE;
            case 2:
                return AMULET;
            case 3:
                return WEAPON;
            case 4:
                return TORSO;
            case 5:
                return SHIELD;
            case 6:
                return ARMS;
            case 7:
                return LEGS;
            case 8:
                return HAIR;
            case 9:
                return HANDS;
            case 10:
                return FEET;
            case 11:
                return JAW;
            case 12:
                return SPOTANIM;
            case -1:
            default:
                return NA;
        }
    }

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.models;

import com.creatorskit.Character;
import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import com.creatorskit.CKObject;
import com.creatorskit.models.datatypes.NPCData;
import com.creatorskit.models.datatypes.PlayerAnimationType;
import com.creatorskit.models.datatypes.WeaponAnimData;
import com.creatorskit.models.exporters.ModelExporter;
import com.creatorskit.programming.AnimationType;
import com.creatorskit.swing.CreatorsPanel;
import com.creatorskit.swing.ParentPanel;
import com.creatorskit.swing.timesheet.keyframe.AnimationKeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.SpotAnimKeyFrame;
import net.runelite.api.*;
import net.runelite.api.Menu;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.kit.KitType;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.util.ColorUtil;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class ModelGetter
{
    private final Client client;
    private final ClientThread clientThread;
    private final CreatorsConfig config;
    private final CreatorsPlugin plugin;
    private final DataFinder dataFinder;
    private final ModelExporter modelExporter;
    private CKObject exportObject;

    @Inject
    public ModelGetter(Client client, ClientThread clientThread, CreatorsConfig config, CreatorsPlugin plugin, DataFinder dataFinder, ModelExporter modelExporter)
    {
        this.client = client;
        this.clientThread = clientThread;
        this.config = config;
        this.plugin = plugin;
        this.dataFinder = dataFinder;
        this.modelExporter = modelExporter;
    }

    public void addCharacterMenuEntries(Tile tile)
    {
        ArrayList<Character> characters = plugin.getCharacters();
        for (int i = 0; i < characters.size(); i++)
        {
            Character character = characters.get(i);
            CKObject ckObject = character.getCkObject();
            if (character.isActive() && ckObject != null)
            {
                LocalPoint localPoint = ckObject.getLocation();
                if (localPoint != null && localPoint.equals(tile.getLocalLocation()))
                {
                    MenuEntry menuEntry = client.getMenu().createMenuEntry(1)
                            .setOption(ColorUtil.prependColorTag("Select", Color.ORANGE))
                            .setTarget(ColorUtil.colorTag(Color.GREEN) + character.getName())
                            .setType(MenuAction.RUNELITE)
                            .onClick(e -> plugin.getCreatorsPanel().setSelectedCharacter(character));

                    Menu menu = menuEntry.createSubMenu();

                    menu.createMenuEntry(0)
                            .setOption(ColorUtil.prependColorTag("Export 3D", Color.WHITE))
                            .setType(MenuAction.RUNELITE)
                            .onClick(e -> exportRLObject(character, false));

                    menu.createMenuEntry(0)
                            .setOption(ColorUtil.prependColorTag("Export Animation", Color.WHITE))
                            .setType(MenuAction.RUNELITE)
                            .onClick(e -> exportRLObject(character, true));
                }
            }
        }
    }

    public void addLocalPlayerMenuEntries(Tile tile)
    {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer != null)
        {
            if (tile.getLocalLocation().equals(localPlayer.getLocalLocation()))
            {
                String target = ColorUtil.prependColorTag("Local Player", Color.GREEN);
                addPlayerMenuEntries(target, localPlayer);
            }
        }
    }

    public void addTileItemMenuEntries(Tile tile)
    {
        List<TileItem> tileItems = tile.getGroundItems();
        if (tileItems != null)
        {
            for (TileItem tileItem : tileItems)
            {
                int itemId = tileItem.getId();
                String name = client.getItemDefinition(itemId).getName();
                if (name.equals("null"))
                {
                    name = "Item";
                }

                Model model = tileItem.getModel();
                addGroundItemMenuEntries(name, model, itemId);
            }
        }
    }

    public void addTileObjectMenuEntries(Tile tile)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        for (GameObject gameObject : gameObjects)
        {
            if (gameObject == null)
                continue;

            Renderable renderable = gameObject.getRenderable();
            if (renderable == null)
                continue;

            int objectId = gameObject.getId();
            int modelType = gameObject.getConfig() & 31;
            int orientation = gameObject.getOrientation();

            if (renderable instanceof Model)
            {
                ObjectComposition comp = client.getObjectDefinition(objectId);
                String name = comp.getName();
                if (name.equals("null"))
                {
                    name = "GameObj";
                }
                int animationId = -1;

                Model model = (Model) renderable;
                addGameObjectMenuEntries(name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, orientation, LightingStyle.DEFAULT, false);
            }

            if (renderable instanceof DynamicObject)
            {
                ObjectComposition comp = client.getObjectDefinition(objectId);
                DynamicObject dynamicObject = (DynamicObject) renderable;
                if (comp.getImpostorIds() != null)
                {
                    if (comp.getImpostor() != null)
                    {
                        comp = comp.getImpostor();
                    }
                }

                objectId = comp.getId();
                Animation animation = dynamicObject.getAnimation();
                int animationId = -1;
                if (animation != null)
                {
                    animationId = animation.getId();
                }

                String name = comp.getName();
                if (name.equals("null"))
                {
                    name = "GameObj";
                }
                addGameObjectMenuEntries(name, dynamicObject.getModel(), objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, orientation, LightingStyle.DYNAMIC, true);
            }
        }

        DecorativeObject decorativeObject = tile.getDecorativeObject();
        if (decorativeObject != null)
        {
            Renderable renderable = decorativeObject.getRenderable();
            if (renderable instanceof Model)
            {
                Model model = (Model) decorativeObject.getRenderable();

                int objectId = decorativeObject.getId();
                int animationId = -1;
                int modelType = 4;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "DecorativeObj";
                }
                addGameObjectMenuEntries(name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, LightingStyle.DEFAULT, false);
            }
        }

        WallObject wallObject = tile.getWallObject();
        if (wallObject != null)
        {
            Renderable renderable = wallObject.getRenderable1();
            if (renderable instanceof Model)
            {
                Model model = (Model) renderable;

                int objectId = wallObject.getId();
                int animationId = -1;
                int modelType = tile.getWallObject().getConfig() & 31;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "WallObj";
                }
                addGameObjectMenuEntries(name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, LightingStyle.DEFAULT, false);
            }
        }

        GroundObject groundObject = tile.getGroundObject();
        if (groundObject != null)
        {
            Renderable renderable = groundObject.getRenderable();
            if (renderable instanceof Model)
            {
                Model model = (Model) groundObject.getRenderable();

                int objectId = groundObject.getId();
                int animationId = -1;
                int modelType = 22;
                String name = client.getObjectDefinition(objectId).getName();
                if (name.equals("null"))
                {
                    name = "GroundObj";
                }
                addGameObjectMenuEntries(name, model, objectId, modelType, CustomModelType.CACHE_OBJECT, animationId, 0, LightingStyle.DEFAULT, false);
            }
        }
    }

    public void addNPCMenuEntries(String target, NPC npc)
    {
        MenuEntry menuEntry = client.getMenu().createMenuEntry(1)
                .setOption(ColorUtil.prependColorTag("Store-Add", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeNPC(npc, ModelMenuOption.STORE_AND_ADD));

        Menu menu = menuEntry.createSubMenu();

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Add-Animate", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeNPC(npc, ModelMenuOption.STORE_ADD_ANIMATE));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Only", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeNPC(npc, ModelMenuOption.STORE));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeNPC(npc, ModelMenuOption.ANVIL));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Transmog", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeNPC(npc, ModelMenuOption.TRANSMOG));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Export 3D", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> exportNPC(npc, false));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Export Animation", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> exportNPC(npc, true));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Add Spotanims", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeSpotAnims(npc.getSpotAnims()));
    }

    public void storeNPC(NPC npc, ModelMenuOption menuOption)
    {
        NPCComposition composition = npc.getTransformedComposition();
        NpcOverrides overrides = npc.getModelOverrides();

        ModelStats[] modelStats;
        if (overrides != null)
        {
            modelStats = dataFinder.findModelsForNPC(npc.getId(), overrides);
        }
        else if (composition != null)
        {
            modelStats = dataFinder.findModelsForNPC(npc.getId(), composition);
        }
        else
        {
            modelStats = dataFinder.findModelsForNPC(npc.getId());
        }

        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find this NPC in the cache.");
            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
            return;
        }

        String name = npc.getName();

        if (menuOption == ModelMenuOption.ANVIL)
        {
            handleAnvilOption(modelStats, new int[0], false, name);
            return;
        }

        AnimationKeyFrame akf = null;
        SpotAnimKeyFrame[] spkfs = new SpotAnimKeyFrame[0];
        if (menuOption == ModelMenuOption.STORE_ADD_ANIMATE)
        {
            NPCData npcData = dataFinder.findNPCData(npc);
            if (npcData != null)
            {
                akf = new AnimationKeyFrame(
                        plugin.getCurrentTick(),
                        false,
                        npc.getAnimation(),
                        0,
                        false,
                        false,
                        npcData.getStandingAnimation(),
                        npcData.getWalkingAnimation(),
                        npcData.getRunAnimation(),
                        npcData.getRotate180Animation(),
                        npcData.getRotateRightAnimation(),
                        npcData.getRotateLeftAnimation(),
                        npcData.getIdleRotateRightAnimation(),
                        npcData.getIdleRotateLeftAnimation());
            }

            int i = 0;
            for (ActorSpotAnim actorSpotAnim : npc.getSpotAnims())
            {
                if (i == 2)
                {
                    break;
                }

                KeyFrameType type = i == 0 ? KeyFrameType.SPOTANIM : KeyFrameType.SPOTANIM2;

                SpotAnimKeyFrame spkf = new SpotAnimKeyFrame(
                        plugin.getCurrentTick(),
                        type,
                        actorSpotAnim.getId(),
                        false,
                        actorSpotAnim.getHeight());

                spkfs = ArrayUtils.add(spkfs, spkf);

                i++;
            }
        }

        handleStoreOptions(modelStats, menuOption, CustomModelType.CACHE_NPC, name, new int[0], false, LightingStyle.ACTOR, npc.getOrientation(), npc.getPoseAnimation(), akf, spkfs);
    }

    public void exportNPC(NPC npc, boolean exportAnimation)
    {
        int animId = npc.getAnimation();
        int poseAnimId = npc.getPoseAnimation();
        if (animId == -1)
        {
            animId = poseAnimId;
        }
        int finalAnimId = animId;

        if (exportAnimation && animId == -1)
        {
            plugin.sendChatMessage("There is no animation currently playing to export.");
            return;
        }

        int npcId = npc.getId();

        String name = npc.getName();

        if (config.vertexColours())
        {
            BlenderModel bm = modelExporter.bmVertexColours(npc.getModel());

            if (exportAnimation)
            {
                Thread thread = new Thread(() ->
                {
                    NPCComposition composition = npc.getTransformedComposition();

                    ModelStats[] modelStats;
                    if (composition == null)
                    {
                        modelStats = dataFinder.findModelsForNPC(npc.getId());
                    }
                    else
                    {
                        modelStats = dataFinder.findModelsForNPC(npc.getId(), composition);
                    }

                    if (modelStats == null || modelStats.length == 0)
                    {
                        plugin.sendChatMessage("Could not find this NPC in the cache.");
                        plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                        return;
                    }

                    clientThread.invokeLater(() ->
                    {
                        initiateAnimationExport(finalAnimId, name, bm, modelStats, new int[0], false, LightingStyle.ACTOR, null);
                    });
                });
                thread.start();
            }
            else
            {
                if (config.exportTPose())
                {
                    npc.setAnimation(-1);
                    npc.setPoseAnimation(-1);
                }

                modelExporter.saveToFile(name, bm);
            }
        }
        else
        {
            Model model = npc.getModel();
            int vCount = model.getVerticesCount();
            int fCount = model.getFaceCount();
            float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
            float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
            float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
            int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
            int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
            byte[] renderPriorities;
            if (model.getFaceRenderPriorities() == null)
            {
                renderPriorities = new byte[fCount];
                Arrays.fill(renderPriorities, (byte) 0);
            }
            else
            {
                renderPriorities = model.getFaceRenderPriorities();
            }

            byte[] transparencies;
            if (model.getFaceTransparencies() == null)
            {
                transparencies = new byte[fCount];
                Arrays.fill(transparencies, (byte) 0);
            }
            else
            {
                transparencies = model.getFaceTransparencies();
            }

            Thread thread = new Thread(() ->
            {
                ModelStats[] modelStats = dataFinder.findModelsForNPC(npcId);
                if (modelStats == null || modelStats.length == 0)
                {
                    plugin.sendChatMessage("Could not find this NPC in the cache.");
                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                    return;
                }

                clientThread.invokeLater(() ->
                {
                    if (config.exportTPose() && !exportAnimation)
                    {
                        npc.setAnimation(-1);
                        npc.setPoseAnimation(-1);
                    }

                    BlenderModel bm = modelExporter.bmFaceColours(
                            modelStats,
                            false,
                            new int[0],
                            false,
                            vX,
                            vY,
                            vZ,
                            f1,
                            f2,
                            f3,
                            transparencies,
                            renderPriorities);

                    if (exportAnimation)
                    {
                        initiateAnimationExport(finalAnimId, name, bm, modelStats, new int[0], false, LightingStyle.ACTOR, null);
                    }
                    else
                    {
                        modelExporter.saveToFile(name, bm);
                    }
                });
            });
            thread.start();
        }
    }

    public void storeSpotAnims(IterableHashTable<ActorSpotAnim> spotAnims)
    {
        for (ActorSpotAnim spotAnim : spotAnims)
        {
            ModelStats[] modelStats = dataFinder.findSpotAnim(spotAnim.getId());
            if (modelStats == null || modelStats.length == 0)
            {
                plugin.sendChatMessage("Could not find this Spotanim in the cache.");
                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                continue;
            }

            String name = "SpotAnim " + spotAnim.getId();
            clientThread.invokeLater(() ->
            {
                CustomLighting lighting = modelStats[0].getLighting();
                CustomModelComp comp = new CustomModelComp(0, CustomModelType.CACHE_SPOTANIM, spotAnim.getId(), modelStats, null, null, null, LightingStyle.CUSTOM, lighting, false, name);

                ModelData modelData = client.loadModelData(modelStats[0].getModelId()).cloneColors().cloneVertices();
                short[] recolFrom = modelStats[0].getRecolourFrom();
                short[] recolTo = modelStats[0].getRecolourTo();
                for (int i = 0; i < recolFrom.length; i++)
                    modelData.recolor(recolFrom[i], recolTo[i]);
                modelData.scale(modelStats[0].getResizeX(), modelStats[0].getResizeZ(), modelStats[0].getResizeY());

                int anim = dataFinder.getLastAnim();
                Model model = modelData.light(lighting.getAmbient(), lighting.getContrast(), lighting.getX(), lighting.getZ() * -1, lighting.getY());
                CustomModel customModel = new CustomModel(model, comp);
                plugin.addCustomModel(customModel, false);
                plugin.sendChatMessage("Model stored: " + name + "; Anim: " + anim + "; Ambient/Contrast: " + lighting.getAmbient() + "/" + lighting.getContrast());
                CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();

                Character character = creatorsPanel.createCharacter(
                        ParentPanel.SIDE_PANEL,
                        name,
                        7699,
                        customModel,
                        true,
                        0,
                        anim,
                        -1,
                        60,
                        new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                        KeyFrameType.createDefaultSummary(),
                        creatorsPanel.getRandomColor(),
                        false,
                        null,
                        null,
                        -1,
                        false,
                        false,
                        false);

                SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));
            });
        }
    }

    public void addPlayerMenuEntries(String target, Player player)
    {
        MenuEntry menuEntry = client.getMenu().createMenuEntry(1)
                .setOption(ColorUtil.prependColorTag("Store-Add", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storePlayer(player, ModelMenuOption.STORE_AND_ADD, false));

        Menu menu = menuEntry.createSubMenu();

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Add-Animate", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storePlayer(player, ModelMenuOption.STORE_ADD_ANIMATE, false));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Only", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storePlayer(player, ModelMenuOption.STORE, false));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storePlayer(player, ModelMenuOption.ANVIL, true));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Transmog", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storePlayer(player, ModelMenuOption.TRANSMOG, false));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Export 3D", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> exportPlayer(player, false));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Export Animation", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> exportPlayer(player, true));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Add Spotanims", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeSpotAnims(player.getSpotAnims()));
    }

    public void storePlayer(Player player, ModelMenuOption menuOption, boolean allowSpotAnim)
    {
        PlayerComposition comp = player.getPlayerComposition();
        final int[] items = comp.getEquipmentIds();
        final int[] colours = comp.getColors().clone();

        IterableHashTable<ActorSpotAnim> actorSpotAnims = player.getSpotAnims();
        int[] spotAnims = new int[0];
        for (ActorSpotAnim actorSpotAnim : actorSpotAnims)
        {
            spotAnims = ArrayUtils.add(spotAnims, actorSpotAnim.getId());
        }

        int[] fSpotAnims = new int[0];
        if (allowSpotAnim)
        {
            fSpotAnims = Arrays.copyOf(spotAnims, spotAnims.length);
        }

        int animId = player.getAnimation();
        if (animId == -1)
        {
            animId = player.getPoseAnimation();
        }

        String name = player.getName();
        if (player == client.getLocalPlayer())
        {
            name = "Local Player";
        }

        ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, animId, fSpotAnims);

        if (menuOption == ModelMenuOption.ANVIL)
        {
            handleAnvilOption(modelStats, colours, true, name);
            return;
        }

        AnimationKeyFrame akf = null;
        SpotAnimKeyFrame[] spkfs = new SpotAnimKeyFrame[0];
        if (menuOption == ModelMenuOption.STORE_ADD_ANIMATE)
        {
            int itemId = player.getPlayerComposition().getEquipmentId(KitType.WEAPON);
            WeaponAnimData weaponAnim = dataFinder.findWeaponAnimData(itemId);
            if (weaponAnim != null)
            {
                akf = new AnimationKeyFrame(
                        plugin.getCurrentTick(),
                        false,
                        player.getAnimation(),
                        0,
                        false,
                        false,
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.WALK),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.RUN),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_180),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_RIGHT),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.ROTATE_LEFT),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_RIGHT),
                        WeaponAnimData.getAnimation(weaponAnim, PlayerAnimationType.IDLE_ROTATE_LEFT));
            }

            int i = 0;
            for (ActorSpotAnim actorSpotAnim : actorSpotAnims)
            {
                if (i == 2)
                {
                    break;
                }

                KeyFrameType type = i == 0 ? KeyFrameType.SPOTANIM : KeyFrameType.SPOTANIM2;

                SpotAnimKeyFrame spkf = new SpotAnimKeyFrame(
                        plugin.getCurrentTick(),
                        type,
                        actorSpotAnim.getId(),
                        false,
                        actorSpotAnim.getHeight());

                spkfs = ArrayUtils.add(spkfs, spkf);

                i++;
            }
        }

        handleStoreOptions(modelStats, menuOption, CustomModelType.CACHE_PLAYER, name, colours, true, LightingStyle.ACTOR, player.getOrientation(), animId, akf, spkfs);
    }

    public void exportPlayer(Player player, boolean exportAnimation)
    {
        int animId = player.getAnimation();
        int poseAnimId = player.getPoseAnimation();
        if (animId == -1)
        {
            animId = poseAnimId;
        }
        int finalAnimId = animId;

        if (exportAnimation && animId == -1)
        {
            plugin.sendChatMessage("There is no animation currently playing to export.");
            return;
        }

        PlayerComposition comp = player.getPlayerComposition();
        int[] items = comp.getEquipmentIds();

        if (config.exportTPose() && !exportAnimation)
        {
            player.setAnimation(-1);
            player.setPoseAnimation(-1);
        }

        Model model = player.getModel();
        int vCount = model.getVerticesCount();
        int fCount = model.getFaceCount();
        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

        int[] vX = new int[vCount];
        int[] vY = new int[vCount];
        int[] vZ = new int[vCount];

        for (int i = 0; i < vCount; i++)
        {
            vX[i] = (int) fvX[i];
            vY[i] = (int) fvY[i];
            vZ[i] = (int) fvZ[i];
        }

        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
        byte[] renderPriorities;
        if (model.getFaceRenderPriorities() == null)
        {
            renderPriorities = new byte[fCount];
            Arrays.fill(renderPriorities, (byte) 0);
        }
        else
        {
            renderPriorities = model.getFaceRenderPriorities();
        }

        byte[] transparencies;
        if (model.getFaceTransparencies() == null)
        {
            transparencies = new byte[fCount];
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = model.getFaceTransparencies();
        }

        IterableHashTable<ActorSpotAnim> actorSpotAnims = player.getSpotAnims();
        int[] spotAnims = new int[0];
        for (ActorSpotAnim actorSpotAnim : actorSpotAnims)
        {
            spotAnims = ArrayUtils.add(spotAnims, actorSpotAnim.getId());
        }
        final int[] fSpotAnims = Arrays.copyOf(spotAnims, spotAnims.length);

        String name = player.getName();
        if (player == client.getLocalPlayer())
            name = "Local Player";
        String finalName = name;

        if (config.vertexColours())
        {
            BlenderModel bm = modelExporter.bmVertexColours(model);
            if (exportAnimation)
            {
                Thread thread = new Thread(() ->
                {
                    ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, finalAnimId, fSpotAnims);
                    clientThread.invokeLater(() ->
                    {
                        initiateAnimationExport(finalAnimId, finalName, bm, modelStats, comp.getColors(), true, LightingStyle.ACTOR, null);
                    });
                });
                thread.start();
            }
            else
            {
                modelExporter.saveToFile(finalName, bm);
            }
        }
        else
        {
            Thread thread = new Thread(() ->
            {
                ModelStats[] modelStats = dataFinder.findModelsForPlayer(false, comp.getGender() == 0, items, finalAnimId, fSpotAnims);

                clientThread.invokeLater(() ->
                {
                    BlenderModel bm = modelExporter.bmFaceColours(
                            modelStats,
                            false,
                            comp.getColors(),
                            true,
                            vX,
                            vY,
                            vZ,
                            f1,
                            f2,
                            f3,
                            transparencies,
                            renderPriorities);

                    if (exportAnimation)
                    {
                        initiateAnimationExport(finalAnimId, finalName, bm, modelStats, comp.getColors(), true, LightingStyle.ACTOR, null);
                    }
                    else
                    {
                        modelExporter.saveToFile(finalName, bm);
                    }
                });
            });
            thread.start();
        }
    }

    public void addGameObjectMenuEntries(String name, Model model, int objectId, int modelType, CustomModelType type, int animationId, int orientation, LightingStyle ls, boolean dynamicObject)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);

        MenuEntry menuEntry = client.getMenu().createMenuEntry(1)
                .setOption(ColorUtil.prependColorTag("Store-Add", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGameObject(name, model, objectId, modelType, type, animationId, orientation, ls, dynamicObject, ModelMenuOption.STORE_AND_ADD));

        Menu menu = menuEntry.createSubMenu();

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Only", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGameObject(name, model, objectId, modelType, type, animationId, orientation, ls, dynamicObject, ModelMenuOption.STORE));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGameObject(name, model, objectId, modelType, type, animationId, orientation, ls, dynamicObject, ModelMenuOption.ANVIL));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Transmog", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGameObject(name, model, objectId, modelType, type, animationId, orientation, ls, dynamicObject, ModelMenuOption.TRANSMOG));

        if (dynamicObject)
        {
            if (model != null)
            {
                addDynamicObjectExporter(menu, name, objectId, modelType, animationId, model, false);
                addDynamicObjectExporter(menu, name, objectId, modelType, animationId, model, true);
            }
        }
        else
        {
            menu.createMenuEntry(0)
                    .setOption(ColorUtil.prependColorTag("Export 3D", Color.WHITE))
                    .setType(MenuAction.RUNELITE)
                    .onClick(e -> exportObject(name, objectId, modelType, model));
        }
    }

    public void storeGameObject(String name, Model model, int objectId, int modelType, CustomModelType type, int animationId, int orientation, LightingStyle ls, boolean dynamicObject, ModelMenuOption menuOption)
    {
        ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, ls, false);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find this Object in the cache.");
            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
            return;
        }

        if (menuOption == ModelMenuOption.ANVIL)
        {
            handleAnvilOption(modelStats, new int[0], false, name);
            return;
        }

        if (dynamicObject)
        {
            handleStoreOptions(modelStats, menuOption, type, name, new int[0], false, ls, orientation, animationId, null, new SpotAnimKeyFrame[0]);
            return;
        }

        handleStoreOptions(model, modelStats, menuOption, type, name, new int[0], false, ls, orientation, animationId, null, new SpotAnimKeyFrame[0]);
    }

    public void exportObject(String name, int objectId, int modelType, Model model)
    {
        if (config.vertexColours())
        {
            BlenderModel blenderModel = modelExporter.bmVertexColours(model);
            modelExporter.saveToFile(name, blenderModel);
        }
        else
        {
            int vCount = model.getVerticesCount();
            int fCount = model.getFaceCount();
            float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
            float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
            float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
            int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
            int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
            byte[] renderPriorities;
            if (model.getFaceRenderPriorities() == null)
            {
                renderPriorities = new byte[fCount];
                Arrays.fill(renderPriorities, (byte) 0);
            }
            else
            {
                renderPriorities = model.getFaceRenderPriorities();
            }

            byte[] transparencies;
            if (model.getFaceTransparencies() == null)
            {
                transparencies = new byte[fCount];
                Arrays.fill(transparencies, (byte) 0);
            }
            else
            {
                transparencies = model.getFaceTransparencies();
            }

            Thread thread = new Thread(() ->
            {
                ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DEFAULT, false);
                if (modelStats == null || modelStats.length == 0)
                {
                    plugin.sendChatMessage("Could not find this Object in the cache.");
                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                    return;
                }

                clientThread.invokeLater(() ->
                {
                    BlenderModel blenderModel = modelExporter.bmFaceColours(
                            modelStats,
                            true,
                            new int[0],
                            false,
                            vX,
                            vY,
                            vZ,
                            f1,
                            f2,
                            f3,
                            transparencies,
                            renderPriorities);
                    modelExporter.saveToFile(name, blenderModel);
                });
            });
            thread.start();
        }
    }

    public void addDynamicObjectExporter(Menu menu, String name, int objectId, int modelType, int animId, Model model, boolean exportAnimation)
    {
        int vCount = model.getVerticesCount();
        int fCount = model.getFaceCount();
        float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
        float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
        float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

        int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
        int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
        int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
        byte[] renderPriorities;
        if (model.getFaceRenderPriorities() == null)
        {
            renderPriorities = new byte[fCount];
            Arrays.fill(renderPriorities, (byte) 0);
        }
        else
        {
            renderPriorities = model.getFaceRenderPriorities();
        }

        byte[] transparencies;
        if (model.getFaceTransparencies() == null)
        {
            transparencies = new byte[fCount];
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = model.getFaceTransparencies();
        }

        String option = "Export Model";
        if (exportAnimation)
        {
            option = "Export Animation";
        }

        menu.createMenuEntry(0)
            .setOption(ColorUtil.prependColorTag(option, Color.WHITE))
            .setType(MenuAction.RUNELITE)
            .onClick(e ->
                {
                    if (exportAnimation && animId == -1)
                    {
                        plugin.sendChatMessage("There is no animation currently playing to export.");
                        return;
                    }

                    if (config.vertexColours())
                    {
                        BlenderModel bm = modelExporter.bmVertexColours(model);

                        if (exportAnimation)
                        {
                            Thread thread = new Thread(() ->
                            {
                                ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DYNAMIC, false);
                                if (modelStats == null || modelStats.length == 0)
                                {
                                    plugin.sendChatMessage("Could not find this Object in the cache.");
                                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                    return;
                                }

                                clientThread.invokeLater(() ->
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, LightingStyle.DYNAMIC, null);
                                });
                            });
                            thread.start();
                        }
                        else
                        {
                            modelExporter.saveToFile(name, bm);
                        }
                    }
                    else
                    {
                        Thread thread = new Thread(() ->
                        {
                            ModelStats[] modelStats = dataFinder.findModelsForObject(objectId, modelType, LightingStyle.DYNAMIC, false);
                            if (modelStats == null || modelStats.length == 0)
                            {
                                plugin.sendChatMessage("Could not find this Object in the cache.");
                                plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                                return;
                            }

                            int[] vX = new int[vCount];
                            int[] vY = new int[vCount];
                            int[] vZ = new int[vCount];

                            for (int i = 0; i < vCount; i++)
                            {
                                vX[i] = (int) fvX[i];
                                vY[i] = (int) fvY[i];
                                vZ[i] = (int) fvZ[i];
                            }

                            clientThread.invokeLater(() ->
                            {
                                BlenderModel bm = modelExporter.bmFaceColours(
                                        modelStats,
                                        true,
                                        new int[0],
                                        false,
                                        vX,
                                        vY,
                                        vZ,
                                        f1,
                                        f2,
                                        f3,
                                        transparencies,
                                        renderPriorities);

                                if (exportAnimation)
                                {
                                    initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, LightingStyle.DYNAMIC, null);
                                }
                                else
                                {
                                    modelExporter.saveToFile(name, bm);
                                }
                            });
                        });
                        thread.start();

                    }
                });
    }

    public void exportRLObject(Character character, boolean exportAnimation)
    {
        String name = character.getName();
        int animId = (int) character.getAnimationSpinner().getValue();

        if (exportAnimation && animId == -1)
        {
            plugin.sendChatMessage("There is no animation currently playing to export.");
            return;
        }

        final Model model = character.getCkObject().getModel();
        if (config.vertexColours())
        {
            BlenderModel bm = modelExporter.bmVertexColours(model);

            if (exportAnimation)
            {
                if (character.isCustomMode())
                {
                    clientThread.invokeLater(() ->
                    {
                        CustomModelComp comp = character.getStoredModel().getComp();
                        switch (comp.getType())
                        {
                            case FORGED:
                                ModelData modelData = plugin.createComplexModelData(comp.getDetailedModels());
                                initiateAnimationExport(animId, name, modelData.light(), bm);
                                break;
                            default:
                            case CACHE_NPC:
                            case CACHE_OBJECT:
                            case CACHE_SPOTANIM:
                            case CACHE_GROUND_ITEM:
                            case CACHE_MAN_WEAR:
                            case CACHE_WOMAN_WEAR:
                                initiateAnimationExport(animId, name, bm, comp.getModelStats(), new int[0], false, comp.getLightingStyle(), comp.getCustomLighting());
                                break;
                            case CACHE_PLAYER:
                                initiateAnimationExport(animId, name, bm, comp.getModelStats(), comp.getKitRecolours(), true, comp.getLightingStyle(), comp.getCustomLighting());
                                break;
                            case BLENDER:
                                plugin.sendChatMessage("This model already came from Blender.");
                                break;
                        }
                    });
                }
                else
                {
                    int modelId = (int) character.getModelSpinner().getValue();
                    ModelStats[] modelStats = new ModelStats[]{new ModelStats(
                            modelId,
                            BodyPart.NA,
                            new short[0],
                            new short[0],
                            new short[0],
                            new short[0],
                            128,
                            128,
                            128,
                            0,
                            new CustomLighting(64, 768, -50, -50, 10))};

                    clientThread.invokeLater(() ->
                    {
                        initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, LightingStyle.DEFAULT, null);
                    });
                }
            }
            else
            {
                modelExporter.saveToFile(name, bm);
            }
        }
        else
        {
            int vCount = model.getVerticesCount();
            int fCount = model.getFaceCount();
            float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
            float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
            float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
            int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
            int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
            byte[] renderPriorities;
            if (model.getFaceRenderPriorities() == null)
            {
                renderPriorities = new byte[fCount];
                Arrays.fill(renderPriorities, (byte) 0);
            }
            else
            {
                renderPriorities = model.getFaceRenderPriorities();
            }

            byte[] transparencies;
            if (model.getFaceTransparencies() == null)
            {
                transparencies = new byte[fCount];
                Arrays.fill(transparencies, (byte) 0);
            }
            else
            {
                transparencies = model.getFaceTransparencies();
            }

            if (character.isCustomMode())
            {
                clientThread.invokeLater(() ->
                {
                    CustomModelComp comp = character.getStoredModel().getComp();
                    BlenderModel bm;
                    ModelData modelData = null;
                    switch (comp.getType())
                    {
                        case FORGED:
                            modelData = plugin.createComplexModelData(comp.getDetailedModels());
                            bm = modelExporter.bmFaceColoursForForgedModel(
                                    modelData,
                                    vX,
                                    vY,
                                    vZ,
                                    f1,
                                    f2,
                                    f3,
                                    transparencies,
                                    renderPriorities);
                            break;
                        default:
                        case CACHE_NPC:
                        case CACHE_OBJECT:
                        case CACHE_SPOTANIM:
                        case CACHE_GROUND_ITEM:
                        case CACHE_MAN_WEAR:
                        case CACHE_WOMAN_WEAR:
                            bm = modelExporter.bmFaceColours(
                                    comp.getModelStats(),
                                    comp.getType() == CustomModelType.CACHE_OBJECT,
                                    new int[0],
                                    false,
                                    vX,
                                    vY,
                                    vZ,
                                    f1,
                                    f2,
                                    f3,
                                    transparencies,
                                    renderPriorities);
                            break;
                        case CACHE_PLAYER:
                            bm = modelExporter.bmFaceColours(
                                    comp.getModelStats(),
                                    false,
                                    comp.getKitRecolours(),
                                    true,
                                    vX,
                                    vY,
                                    vZ,
                                    f1,
                                    f2,
                                    f3,
                                    transparencies,
                                    renderPriorities);
                            break;
                        case BLENDER:
                            bm = comp.getBlenderModel();
                    }

                    if (exportAnimation)
                    {
                        switch (comp.getType())
                        {
                            case FORGED:
                                if (modelData != null)
                                {
                                    initiateAnimationExport(animId, name, modelData.light(), bm);
                                }
                                break;
                            default:
                            case CACHE_NPC:
                            case CACHE_OBJECT:
                            case CACHE_SPOTANIM:
                            case CACHE_GROUND_ITEM:
                            case CACHE_MAN_WEAR:
                            case CACHE_WOMAN_WEAR:
                                initiateAnimationExport(animId, name, bm, comp.getModelStats(), new int[0], false, comp.getLightingStyle(), comp.getCustomLighting());
                                break;
                            case CACHE_PLAYER:
                                initiateAnimationExport(animId, name, bm, comp.getModelStats(), comp.getKitRecolours(), true, comp.getLightingStyle(), comp.getCustomLighting());
                                break;
                            case BLENDER:
                                plugin.sendChatMessage("This model already came from Blender.");
                                break;
                        }
                    }
                    else
                    {
                        modelExporter.saveToFile(name, bm);
                    }

                });

            }
            else
            {
                int modelId = (int) character.getModelSpinner().getValue();
                ModelStats[] modelStats = new ModelStats[]{new ModelStats(
                        modelId,
                        BodyPart.NA,
                        new short[0],
                        new short[0],
                        new short[0],
                        new short[0],
                        128,
                        128,
                        128,
                        0,
                        new CustomLighting(64, 768, -50, -50, 10))};

                clientThread.invokeLater(() ->
                {
                    BlenderModel bm = modelExporter.bmFaceColours(
                            modelStats,
                            false,
                            new int[0],
                            false,
                            vX,
                            vY,
                            vZ,
                            f1,
                            f2,
                            f3,
                            transparencies,
                            renderPriorities);

                    if (exportAnimation)
                    {
                        initiateAnimationExport(animId, name, bm, modelStats, new int[0], false, LightingStyle.DEFAULT, null);
                    }
                    else
                    {
                        modelExporter.saveToFile(name, bm);
                    }
                });
            }
        }
    }

    public void addGroundItemMenuEntries(String name, Model model, int itemId)
    {
        String target = ColorUtil.prependColorTag(name, Color.CYAN);

        MenuEntry menuEntry = client.getMenu().createMenuEntry(1)
                .setOption(ColorUtil.prependColorTag("Store-Add", Color.ORANGE))
                .setTarget(target)
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGroundItem(name, model, itemId, ModelMenuOption.STORE_AND_ADD));

        Menu menu = menuEntry.createSubMenu();

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Store-Only", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGroundItem(name, model, itemId, ModelMenuOption.STORE));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Anvil", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGroundItem(name, model, itemId, ModelMenuOption.ANVIL));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Transmog", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> storeGroundItem(name, model, itemId, ModelMenuOption.TRANSMOG));

        menu.createMenuEntry(0)
                .setOption(ColorUtil.prependColorTag("Export 3D", Color.WHITE))
                .setType(MenuAction.RUNELITE)
                .onClick(e -> exportGroundItem(name, itemId, model));
    }

    public void storeGroundItem(String name, Model model, int itemId, ModelMenuOption menuOption)
    {
        ModelStats[] modelStats = dataFinder.findModelsForGroundItem(itemId, CustomModelType.CACHE_GROUND_ITEM);
        if (modelStats == null || modelStats.length == 0)
        {
            plugin.sendChatMessage("Could not find this Item in the cache.");
            plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
            return;
        }

        if (menuOption == ModelMenuOption.ANVIL)
        {
            handleAnvilOption(modelStats, new int[0], false, name);
            return;
        }

        handleStoreOptions(model, modelStats, menuOption, CustomModelType.CACHE_GROUND_ITEM, name, new int[0], false, LightingStyle.DEFAULT, 0, -1, null, new SpotAnimKeyFrame[0]);
    }

    public void exportGroundItem(String name, int itemId, Model model)
    {
        if (config.vertexColours())
        {
            BlenderModel blenderModel = modelExporter.bmVertexColours(model);
            modelExporter.saveToFile(name, blenderModel);
        }
        else
        {
            int vCount = model.getVerticesCount();
            int fCount = model.getFaceCount();

            float[] fvX = Arrays.copyOf(model.getVerticesX(), vCount);
            float[] fvY = Arrays.copyOf(model.getVerticesY(), vCount);
            float[] fvZ = Arrays.copyOf(model.getVerticesZ(), vCount);

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            int[] f1 = Arrays.copyOf(model.getFaceIndices1(), fCount);
            int[] f2 = Arrays.copyOf(model.getFaceIndices2(), fCount);
            int[] f3 = Arrays.copyOf(model.getFaceIndices3(), fCount);
            byte[] renderPriorities;
            if (model.getFaceRenderPriorities() == null)
            {
                renderPriorities = new byte[fCount];
                Arrays.fill(renderPriorities, (byte) 0);
            }
            else
            {
                renderPriorities = model.getFaceRenderPriorities();
            }

            byte[] transparencies;
            if (model.getFaceTransparencies() == null)
            {
                transparencies = new byte[fCount];
                Arrays.fill(transparencies, (byte) 0);
            }
            else
            {
                transparencies = model.getFaceTransparencies();
            }

            Thread thread = new Thread(() ->
            {
                ModelStats[] modelStats = dataFinder.findModelsForGroundItem(itemId, CustomModelType.CACHE_GROUND_ITEM);
                if (modelStats == null || modelStats.length == 0)
                {
                    plugin.sendChatMessage("Could not find this Item in the cache.");
                    plugin.sendChatMessage("This may be because Creator's Kit's cache dumps have not yet been updated to the latest game update.");
                    return;
                }

                clientThread.invokeLater(() ->
                {
                    BlenderModel blenderModel = modelExporter.bmFaceColours(
                            modelStats,
                            false,
                            new int[0],
                            false,
                            vX,
                            vY,
                            vZ,
                            f1,
                            f2,
                            f3,
                            transparencies,
                            renderPriorities);
                    modelExporter.saveToFile(name, blenderModel);
                });
            });
            thread.start();

        }
    }

    private void handleAnvilOption(ModelStats[] modelStats, int[] kitRecolours, boolean player, String name)
    {
        clientThread.invokeLater(() ->
        {
            plugin.cacheToAnvil(modelStats, kitRecolours, player);
            plugin.sendChatMessage("Model sent to Anvil: " + name);
        });
    }

    private void handleStoreOptions(ModelStats[] modelStats, ModelMenuOption menuOption, CustomModelType customModelType, String name, int[] kitRecolours, boolean player, LightingStyle ls, int orientation, int poseAnimation, AnimationKeyFrame keyFrame, SpotAnimKeyFrame[] spkfs)
    {
        clientThread.invokeLater(() ->
        {
            Model model = plugin.constructModelFromCache(modelStats, kitRecolours, player, ls, null);
            store(model, modelStats, menuOption, customModelType, name, kitRecolours, ls, orientation, poseAnimation, keyFrame, spkfs);
        });
    }

    private void handleStoreOptions(Model model, ModelStats[] modelStats, ModelMenuOption menuOption, CustomModelType customModelType, String name, int[] kitRecolours, boolean player, LightingStyle ls, int orientation, int poseAnimation, AnimationKeyFrame keyFrame, SpotAnimKeyFrame[] spkfs)
    {
        Thread thread = new Thread(() ->
        {
            store(model, modelStats, menuOption, customModelType, name, kitRecolours, ls, orientation, poseAnimation, keyFrame, spkfs);
        });
        thread.start();
    }

    private void store(Model model, ModelStats[] modelStats, ModelMenuOption menuOption, CustomModelType customModelType, String name, int[] kitRecolours, LightingStyle ls, int orientation, int poseAnimation, AnimationKeyFrame keyFrame, SpotAnimKeyFrame[] spkfs)
    {
        CustomLighting lighting = new CustomLighting(ls.getAmbient(), ls.getContrast(), ls.getX(), ls.getY(), ls.getZ());
        CustomModelComp comp = new CustomModelComp(0, customModelType, 7699, modelStats, kitRecolours, null, null, ls, lighting, false, name);
        CustomModel customModel = new CustomModel(model, comp);
        plugin.addCustomModel(customModel, false);
        plugin.sendChatMessage("Model stored: " + name);
        CreatorsPanel creatorsPanel = plugin.getCreatorsPanel();

        if (menuOption == ModelMenuOption.TRANSMOG)
        {
            creatorsPanel.getModelOrganizer().setTransmog(customModel);
        }

        if (menuOption == ModelMenuOption.STORE_AND_ADD || menuOption == ModelMenuOption.STORE_ADD_ANIMATE)
        {
            Character character = creatorsPanel.createCharacter(
                    ParentPanel.SIDE_PANEL,
                    name,
                    7699,
                    customModel,
                    true,
                    orientation,
                    poseAnimation,
                    -1,
                    60,
                    new KeyFrame[KeyFrameType.getTotalFrameTypes()][],
                    KeyFrameType.createDefaultSummary(),
                    creatorsPanel.getRandomColor(),
                    false,
                    null,
                    null,
                    -1,
                    false,
                    false,
                    false);

            SwingUtilities.invokeLater(() -> creatorsPanel.addPanel(ParentPanel.SIDE_PANEL, character, true, false));

            if (menuOption == ModelMenuOption.STORE_ADD_ANIMATE)
            {
                character.setKeyFrames(new KeyFrame[]{keyFrame}, KeyFrameType.ANIMATION);

                for (SpotAnimKeyFrame spkf : spkfs)
                {
                    character.setKeyFrames(new KeyFrame[]{spkf}, spkf.getKeyFrameType());
                }

                creatorsPanel.getToolBox().getProgrammer().updateProgram(character);
            }
        }
    }

    private void initiateAnimationExport(int animId, String name, BlenderModel bm, ModelStats[] modelStats, int[] kitRecolours, boolean player, LightingStyle ls, CustomLighting cl)
    {
        Model model = plugin.constructModelFromCache(modelStats, kitRecolours, player, ls, cl);
        initiateAnimationExport(animId, name, model, bm);
    }

    private void initiateAnimationExport(int animId, String name, Model model, BlenderModel bm)
    {
        exportObject = new CKObject(client);
        client.registerRuneLiteObject(exportObject);

        exportObject.setAnimation(AnimationType.ACTIVE, animId);
        exportObject.setModel(model);
        exportObject.setActive(true);
        exportObject.setLocation(client.getLocalPlayer().getLocalLocation(), client.getTopLevelWorldView().getPlane());

        AnimationController ac = exportObject.getAnimationController();
        if (ac == null)
        {
            return;
        }

        Animation animation = ac.getAnimation();
        if (animation == null)
        {
            return;
        }

        int vCount = model.getVerticesCount();

        int[] clientTicks;
        if (animation.isMayaAnim())
        {
            int frames = animation.getNumFrames();
            clientTicks = new int[frames];

            for (int i = 0; i < frames; i++)
            {
                clientTicks[i] = i;
            }
        }
        else
        {
            int[] frameLengths = animation.getFrameLengths();
            int frames = frameLengths.length;
            clientTicks = new int[frames];

            for (int i = 0; i < frameLengths.length; i++)
            {
                int length = 0;
                for (int e = 0; e <= i; e++)
                {
                    length += frameLengths[e];
                }

                clientTicks[i] = length;
            }
        }

        int maxAnimFrames = exportObject.getMaxAnimFrames(AnimationType.ACTIVE);
        int[][][] animVerts = new int[maxAnimFrames][model.getVerticesCount()][3];

        for (int e = 0; e < maxAnimFrames; e++)
        {
            exportObject.setAnimationFrame(AnimationType.ACTIVE, e, true);
            Model m = exportObject.getModel();

            int[][] verts = animVerts[e];

            float[] fvX = m.getVerticesX();
            float[] fvY = m.getVerticesY();
            float[] fvZ = m.getVerticesZ();

            int[] vX = new int[vCount];
            int[] vY = new int[vCount];
            int[] vZ = new int[vCount];

            for (int i = 0; i < vCount; i++)
            {
                vX[i] = (int) fvX[i];
                vY[i] = (int) fvY[i];
                vZ[i] = (int) fvZ[i];
            }

            for (int i = 0; i < verts.length; i++)
            {
                int[] v = verts[i];
                v[0] = vX[i];
                v[1] = vY[i];
                v[2] = vZ[i];
            }
        }

        exportObject.setActive(false);

        bm.setClientTicks(clientTicks);
        bm.setAnimVertices(animVerts);
        modelExporter.saveToFile(name, bm);
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum ModelMenuOption
{
    STORE,
    STORE_AND_ADD,
    STORE_ADD_ANIMATE,
    TRANSMOG,
    ANVIL
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class WeaponAnimData
{
    private final int[] id;
    private final int[] animations;

    public static int getAnimation(WeaponAnimData weaponAnimData, PlayerAnimationType type)
    {
        int[] animations = weaponAnimData.getAnimations();
        switch (type)
        {
            default:
            case IDLE:
                return animations[0];
            case WALK:
                return animations[1];
            case RUN:
                return animations[2];
            case IDLE_ROTATE_LEFT:
            case IDLE_ROTATE_RIGHT:
                return animations[6];
            case ROTATE_180:
                return animations[3];
            case ROTATE_LEFT:
                return animations[4];
            case ROTATE_RIGHT:
                return animations[5];
            case SPECIAL:
                return animations[10];
            case STAB:
                return animations[7];
            case SLASH:
                return animations[8];
            case SLASH_2:
                return animations[12];
            case CRUSH:
                return animations[9];
            case CRUSH_2:
                return animations[13];
            case DEFEND:
                return animations[11];
        }
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class NPCData
{
    private final int id;
    private String name;
    private final int[] models;
    private final int size;
    private final int standingAnimation;
    private final int walkingAnimation;
    private final int runAnimation;
    private final int idleRotateLeftAnimation;
    private final int idleRotateRightAnimation;
    private final int rotate180Animation;
    private final int rotateLeftAnimation;
    private final int rotateRightAnimation;
    private final int widthScale;
    private final int heightScale;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

public enum PlayerAnimationType
{
    IDLE,
    WALK,
    RUN,
    IDLE_ROTATE_LEFT,
    IDLE_ROTATE_RIGHT,
    ROTATE_180,
    ROTATE_LEFT,
    ROTATE_RIGHT,
    SPECIAL,
    STAB,
    SLASH,
    SLASH_2,
    CRUSH,
    CRUSH_2,
    DEFEND
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class SeqData
{
    private final String name;
    private final int id;
    private final int leftHandItem;
    private final int rightHandItem;
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class ItemData
{
    private final int id;
    private final String name;
    private final int inventoryModel;
    private final int maleModel0;
    private final int maleModel1;
    private final int maleModel2;
    private final int maleOffset;
    private final int femaleModel0;
    private final int femaleModel1;
    private final int femaleModel2;
    private final int wearPos0;
    private final int wearPos1;
    private final int wearPos2;
    private final int femaleOffset;
    private final int maleHeadModel;
    private final int maleHeadModel2;
    private final int femaleHeadModel;
    private final int femaleHeadModel2;
    private final int resizeX;
    private final int resizeY;
    private final int resizeZ;
    private final int[] colorReplace;
    private final int[] colorFind;
    private final int[] textureReplace;
    private final int[] textureFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class SpotanimData
{
    private final String name;
    private final int id;
    private final int modelId;
    private final int animationId;
    private final int resizeX;
    private final int resizeY;
    private final int ambient;
    private final int contrast;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class ObjectData
{
    private final int id;
    private final String name;
    private final int animationId;
    private final int[] objectModels;
    private final int[] objectTypes;
    private final int modelSizeX;
    private final int modelSizeY;
    private final int modelSizeZ;
    private final int ambient;
    private final int contrast;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;
    private final int[] textureToReplace;
    private final int[] retextureToFind;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class KitData
{
    private final int id;
    private final int bodyPartId;
    private final int[] models;
    private final int[] chatheadModels;
    private final int[] recolorToReplace;
    private final int[] recolorToFind;
}

package com.creatorskit.models.datatypes;

import lombok.AllArgsConstructor;
import lombok.Getter;

@Getter
@AllArgsConstructor
public class AnimData
{
    private final int id;
    private final String name;

    @Override
    public String toString()
    {
        return name + " (" + id + ")";
    }
}

package com.creatorskit.models;

public enum AnimSequenceData
{
    UNALTERED,
    SWAP,
    HIDE
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

import java.util.Arrays;

@AllArgsConstructor
public enum AnimationData
{
    POSE(new int[]
            {244, 808, 809, 813, 847, 1421, 1461, 1652, 1662, 1713, 1824, 1832, 1837,
            2061, 2065, 2074, 2148, 2316, 2561, 2911, 3040, 3175, 3296, 3677, 4193, 4646, 5160, 5246, 5253, 5363,
            5869, 6297, 6604, 6657, 6936, 7053, 7220, 7271, 7508, 7518, 7538, 8009, 8057, 8208, 8521, 9018, 9341,
            9460, 9494, 9814, 9857, 10032}),
    WALK(new int[]
            {247, 744, 762, 772, 819, 844, 1205, 1205, 1422, 1660, 1663, 1703, 1830, 1836, 2060, 2064, 2076,
            2317, 2562, 3039, 3177, 3293, 3415, 3680, 4194, 4226, 4682, 5164, 5245, 5250, 5364, 5867, 6607, 6658,
            6936, 6996, 7052, 7223, 7272, 7327, 7510, 7520, 7539, 7629, 8011, 8070, 8492, 8854, 9017, 9051, 9342,
            9461, 9849, 9859, 10076, 10170}),
    RUN(new int[]
            {248, 744, 762, 772, 824, 1210, 1427, 1440, 1661, 1664, 1707, 1836, 2077, 2322, 2563, 2847, 3178, 4228,
            5168, 5253, 5868, 6277, 6603, 6660, 6936, 6995, 7043, 7221, 7273, 7274, 7509, 7519, 7540, 7633, 7703,
            8016, 8070, 8492, 8853, 9019, 9051, 9346, 9459, 9850, 9860, 10077}),
    SHUFFLE_LEFT(new int[]
            {247, 745, 762, 772, 821, 844, 1207, 1424, 1468, 1660, 1663, 1706, 1836, 2060, 2064, 2076, 2319, 2562,
            3177, 3293, 3415, 3680, 4194, 5166, 5245, 5867, 6268, 6610, 6662, 6936, 6996, 7048, 7223, 7510, 7520,
            7631, 8013, 8070, 8492, 9021, 9052, 9343, 9861, 10055, 10076, 10170}),
    SHUFFLE_RIGHT(new int[]
            {247, 745, 762, 772, 822, 844, 1208, 1208, 1425, 1468, 1660, 1663, 1705, 1836, 2060, 2064, 2076, 2320,
            2562, 3177, 3293, 3415, 3680, 4194, 5167, 5245, 5867, 6275, 6609, 6663, 6936, 6996, 7047, 7223, 7510,
            7520, 7632, 8014, 8070, 8492, 9020, 9053, 9344, 9852, 9862, 10054, 10076, 10170}),
    BACKWARDS(new int[]
            {247, 745, 762, 772, 820, 844, 1206, 1423, 1468, 1660, 1663, 1704, 1830, 1836, 2060, 2064, 2076, 2562,
            3177, 3293, 3415, 3680, 4194, 4227, 5165, 5245, 5251, 5438, 5867, 6276, 6608, 6659, 6936, 6996, 7052,
            7223, 7327, 7510, 7520, 7539, 7630, 8012, 8070, 8492, 9017, 9054, 9345, 9461, 9859, 10076, 10170}),
    ROTATE(new int[]
            {745, 762, 765, 773, 823, 845, 1205, 1209,1426, 1468, 1702, 2321, 3177, 3415, 4194, 5161, 5252, 6297,
            6611, 6661, 6936, 6998, 7044, 8015, 8070, 8492, 9050, 9343, 9863, 10055})
    ;

    private final int[] animations;

    public static boolean matchAnimation(AnimationData animationData, int animationId)
    {
        return Arrays.stream(animationData.animations).anyMatch(n -> animationId == n);
    }

    public static PoseAnimation getPoseAnimation(int animationId)
    {
        if (matchAnimation(AnimationData.POSE, animationId))
            return PoseAnimation.POSE;

        if (matchAnimation(AnimationData.WALK, animationId))
            return PoseAnimation.WALK;

        if (matchAnimation(AnimationData.RUN, animationId))
            return PoseAnimation.RUN;

        if (matchAnimation(AnimationData.SHUFFLE_LEFT, animationId))
            return PoseAnimation.SHUFFLE_LEFT;

        if (matchAnimation(AnimationData.SHUFFLE_RIGHT, animationId))
            return PoseAnimation.SHUFFLE_RIGHT;

        if (matchAnimation(AnimationData.BACKWARDS, animationId))
            return PoseAnimation.BACKWARDS;

        if (matchAnimation(AnimationData.ROTATE, animationId))
            return PoseAnimation.ROTATE;

        return PoseAnimation.NONE;
    }
}

package com.creatorskit.models.exporters;

import com.creatorskit.models.BlenderModel;
import com.creatorskit.swing.colours.HSLColor;
import com.creatorskit.models.exporters.GLTFExporter.Vertex;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import static com.creatorskit.models.ModelImporter.BLENDER_DIR;

@Slf4j
public class OBJExporter
{
    final static String HEADER = "# Made with Creator's Kit";
    final static String VERT = "v %f %f %f";
    final static String VERT_COLOUR = "v %f %f %f %f %f %f";
    final static String FACE = "f %d %d %d";
    final static String NEW_MTL = "newmtl c%d";
    final static String KD = "Kd %f %f %f";

    public static boolean saveOBJ(String name, BlenderModel blenderModel)
    {
        if (blenderModel.isUseVertexColours())
        {
            return saveVertColours(name, blenderModel);
        }
        else
        {
            return saveFaceColours(name, blenderModel);
        }
    }

    public static boolean saveVertColours(String name, BlenderModel blenderModel)
    {
        StringBuilder obj = new StringBuilder();
        obj.append(HEADER).append("\n");
        obj.append("o ").append(name).append("\n");

        HashMap<Integer, GLTFExporter.FaceMap> faceMaps = new HashMap<>();

        List<Vertex> uVerts = new ArrayList<>();
        HashMap<Integer, Integer> hashToIndex = new HashMap<>();
        HashMap<Integer, Vertex> hashVertexMap = new HashMap<>();

        // To avoid faces of the model being totally disjointed, while preserving vertex colours,
        // limit vert duplication to identical verts with different colours.
        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            GLTFExporter.FaceMap fm = new GLTFExporter.FaceMap();

            for (int vi = 0; vi < 3; vi++)
            {
                int vertIndex = face[vi];
                Vertex v = new Vertex();

                float[] xyz = new float[3];
                xyz[0] = blenderModel.getVertices()[vertIndex][0] / 128f;
                xyz[1] = -blenderModel.getVertices()[vertIndex][1] / 128f;
                xyz[2] = -blenderModel.getVertices()[vertIndex][2] / 128f;

                v.setXyz(xyz);
                v.setColour(getRGB(blenderModel.getVertexColours()[blenderModel.getVertexColourIndex()[fi * 3 + vi]]));

                if (!hashVertexMap.containsKey(v.hashCode()))
                {
                    hashToIndex.put(v.hashCode(), uVerts.size());
                    hashVertexMap.put(v.hashCode(), v);
                    uVerts.add(v);
                }

                fm.addIndex(vi, hashToIndex.get(v.hashCode()));
            }

            faceMaps.put(fi, fm);
        }

        for (Vertex v : uVerts)
        {
            obj.append(
                    String.format(
                            VERT_COLOUR,
                            v.getXyz()[0],
                            v.getXyz()[1],
                            v.getXyz()[2],
                            v.getColour()[0],
                            v.getColour()[1],
                            v.getColour()[2]
                    )
            ).append("\n");
        }

        for (int fi = 0; fi < faceMaps.size(); fi++)
        {
            GLTFExporter.FaceMap fm = faceMaps.get(fi);
            obj.append(
                    String.format(
                            FACE,
                            fm.getIndices()[0] + 1,
                            fm.getIndices()[1] + 1,
                            fm.getIndices()[2] + 1
                    )
            ).append("\n");
        }

        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".obj";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            writer.write(obj.toString());
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    public static boolean saveFaceColours(String name, BlenderModel blenderModel)
    {
        StringBuilder obj = new StringBuilder();
        StringBuilder mtl = new StringBuilder();

        for (int ci = 0; ci < blenderModel.getFaceColours().length; ci++)
        {
            float[] colour = getRGB(blenderModel.getFaceColours()[ci]);
            mtl.append(String.format(NEW_MTL, ci)).append("\n");
            mtl.append(String.format(KD, colour[0], colour[1], colour[2])).append("\n");
            if (colour[3] != 1.0f)
            {
                mtl.append(String.format("d %f", colour[3])).append("\n");
            }
        }

        obj.append(HEADER).append("\n");
        obj.append("o ").append(name).append("\n");

        for (int vi = 0; vi < blenderModel.getVertices().length; vi++)
        {
            obj.append(
                    String.format(
                            VERT,
                            blenderModel.getVertices()[vi][0] / 128f,
                            -blenderModel.getVertices()[vi][1] / 128f,
                            -blenderModel.getVertices()[vi][2] / 128f
                    )
            ).append("\n");
        }

        int currentMaterial = -1;

        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            if (blenderModel.getFaceColourIndex()[fi] != currentMaterial)
            {
                currentMaterial = blenderModel.getFaceColourIndex()[fi];
                obj.append("usemtl ").append(String.format("c%d", currentMaterial)).append("\n");
            }

            obj.append(
                    String.format(
                            FACE,
                            face[0] + 1,
                            face[1] + 1,
                            face[2] + 1
                    )
            ).append("\n");
        }

        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".obj";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            File fileMtl = new File(file.getAbsolutePath().replace(".obj", ".mtl"));

            FileWriter writer = new FileWriter(file, false);
            writer.write(obj.toString());
            writer.close();

            writer = new FileWriter(fileMtl, false);
            writer.write(mtl.toString());
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    private static float[] getRGB(double[] colour)
    {
        Color rgb = HSLColor.toRGB(new float[] {
                (float) colour[0] * 360f,
                (float) colour[2] * 100f,
                (float) colour[1] * 100f
        });

        return new float[] {
                rgb.getRed() / 255f,
                rgb.getBlue() / 255f,
                rgb.getGreen() / 255f,
                (float) colour[3]
        };
    }

}

package com.creatorskit.models.exporters;

public enum ExportFileFormat
{
    BLENDER,
    OBJ,
    GLTF
}

package com.creatorskit.models.exporters;

import com.creatorskit.models.BlenderModel;
import com.creatorskit.models.exporters.GLTF.*;
import com.creatorskit.swing.colours.HSLColor;
import com.google.common.hash.Hasher;
import com.google.common.hash.Hashing;
import com.google.common.hash.HashFunction;
import com.google.gson.Gson;
import lombok.Data;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.awt.*;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Paths;
import java.util.*;
import java.util.List;

import static com.creatorskit.models.ModelImporter.BLENDER_DIR;

@Slf4j
public class GLTFExporter {

    static int UNSIGNED_SHORT = 5123;
    static int FLOAT = 5126;
    static int ARRAY_BUFFER = 34962;
    static int ELEMENT_ARRAY_BUFFER = 34963;

    @Getter
    GLTF gltf;
    BlenderModel blenderModel;

    HashMap<Integer, FaceMap> faceMaps = new HashMap<>();
    HashMap<Integer, float[]> vertexColours = new HashMap<>();

    List<Vertex> uVerts = new ArrayList<>();
    HashMap<Integer, Integer> hashToIndex = new HashMap<>();

    HashMap<Integer, Vertex[]> animVerts = new HashMap<>();
    HashMap<Integer, Vertex> hashVertexMap = new HashMap<>();

    public GLTFExporter(String name, BlenderModel blenderModel) {
        this.blenderModel = blenderModel;

        Vertex v1 = new Vertex();
        v1.setXyz(new float[]{1.0f, 2.0f, 3.0f});
        v1.setColour(new float[]{1.0f, 0.0f, 0.0f, 1.0f});

        Vertex v2 = new Vertex();
        v2.setXyz(new float[]{4.0f, 5.0f, 6.0f});
        v2.setColour(new float[]{1.0f, 0.0f, 0.0f, 1.0f});

        gltf = new GLTF();

        addMesh();
        refineVertices();
        addBasis();

        if (blenderModel.getClientTicks().length > 0)
        {
            createAnimVerts();
            addAnimation();
        }

        gltf.meshes.get(0).setName(name);
    }

    public boolean saveGLTF(Gson gson, String name)
    {
        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".gltf";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            String string = gson.toJson(gltf);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    private void addMesh() {
        Mesh m = new Mesh();
        gltf.meshes.add(m);
        primitive prim = new primitive();
        prim.setAttributes(new Attribute());
        m.primitives.add(prim);
    }

    private float[] convertCoords(int[] xyz)
    {
        float[] xyzf = new float[3];
        for (int i = 0; i < 3; i++)
        {
            int s = i == 0 ? 1 : -1; // y/z are inverted
            xyzf[i] = xyz[i] * s / 128f;
        }
        return xyzf;
    }

    private void refineVertices()
    {
        // To avoid faces of the model being totally disjointed, while preserving vertex colours,
        // limit vert duplication to identical verts with different colours.

        for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
        {
            int[] face = blenderModel.getFaces()[fi];
            FaceMap fm = new FaceMap();

            for (int vi = 0; vi < 3; vi++)
            {
                int vertIndex = face[vi];
                Vertex v = new Vertex();
                v.setXyz(convertCoords(blenderModel.getVertices()[vertIndex]));
                v.setColour(getColours(fi, vi));

                if (!hashVertexMap.containsKey(v.hashCode()))
                {
                    hashToIndex.put(v.hashCode(), uVerts.size());
                    vertexColours.put(uVerts.size(), v.getColour());
                    hashVertexMap.put(v.hashCode(), v);
                    uVerts.add(v);
                }

                fm.addIndex(vi, hashToIndex.get(v.hashCode()));
            }

            faceMaps.put(fi, fm);
        }
    }

    private float[] getColours(int fi, int vi)
    {
        double[] cols;
        if (blenderModel.isUseVertexColours())
        {
            cols = blenderModel.getVertexColours()[blenderModel.getVertexColourIndex()[fi * 3 + vi]];
        } else {
            cols = blenderModel.getFaceColours()[blenderModel.getFaceColourIndex()[fi]];
        }

        Color rgbColor = HSLColor.toRGB(new float[] {
                (float) cols[0] * 360f,
                (float) cols[2] * 100f,
                (float) cols[1] * 100f
        });

        return new float[] {
                (float) Math.pow(rgbColor.getRed() / 255f, 2.2f),
                (float) Math.pow(rgbColor.getBlue() / 255f, 2.2f),
                (float) Math.pow(rgbColor.getGreen() / 255f, 2.2f),
                (float) cols[3]
        };
    }

    private void addBasis() {

        // Verts and colours
        int vertexCount = uVerts.size();

        float[] vertexMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] vertexMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        float[] colourMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] colourMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        ByteBuffer vertices = ByteBuffer.allocateDirect(vertexCount * 3 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);
        ByteBuffer vertColours = ByteBuffer.allocateDirect(vertexCount * 4 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);

        for (Vertex vert : uVerts) {
            for (int i = 0; i < 3; i++)
            {
                float s = vert.getXyz()[i];
                vertices.putFloat(s);
                vertexMin[i] = Math.min(vertexMin[i], s);
                vertexMax[i] = Math.max(vertexMax[i], s);
            }

            for (int l = 0; l < 4; l++)
            {
                vertColours.putFloat(vert.getColour()[l]);
                colourMin[l] = Math.min(colourMin[l], vert.getColour()[l]);
                colourMax[l] = Math.max(colourMax[l], vert.getColour()[l]);
            }
        }

        int vertAccessorIdx = addBuffer(vertices, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC3);
        Accessor vertexAccessor = gltf.accessors.get(vertAccessorIdx);

        for (int i = 0; i < 3; i++) {
            vertexAccessor.min.add(vertexMin[i]);
            vertexAccessor.max.add(vertexMax[i]);
        }

        gltf.meshes.get(0).primitives.get(0).attributes.setPOSITION(vertAccessorIdx);

        int colourAccessorIdx = addBuffer(vertColours, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC4);
        gltf.meshes.get(0).primitives.get(0).attributes.setCOLOR_0(colourAccessorIdx);

        // Faces
        ByteBuffer faces = ByteBuffer.allocateDirect(faceMaps.size() * 3 * 2)
                .order(ByteOrder.LITTLE_ENDIAN);

        short faceMin = Short.MAX_VALUE;
        short faceMax = Short.MIN_VALUE;

        for (int i = 0; i < faceMaps.size(); i++)
        {
            FaceMap fm = faceMaps.get(i);
            for (int j = 0; j < 3; j++)
            {
                faceMin = (short) Math.min(faceMin, fm.getIndices()[j]);
                faceMax = (short) Math.max(faceMax, fm.getIndices()[j]);
                faces.putShort((short) fm.getIndices()[j]);
            }
        }

        int faceAccessorIdx = addBuffer(
                faces, faceMaps.size() * 3, ELEMENT_ARRAY_BUFFER, UNSIGNED_SHORT, AccessorType.SCALAR
        );
        Accessor faceAccessor = gltf.accessors.get(faceAccessorIdx);
        faceAccessor.min.add(faceMin);
        faceAccessor.max.add(faceMax);
        gltf.meshes.get(0).primitives.get(0).setIndices(faceAccessorIdx);
    }

    private void createAnimVerts()
    {
        for (int frame = 0; frame < blenderModel.getAnimVertices().length; frame++)
        {
            int[][] anim = blenderModel.getAnimVertices()[frame];
            Vertex[] verts = new Vertex[uVerts.size()];

            for (int fi = 0; fi < blenderModel.getFaces().length; fi++)
            {
                int[] face = blenderModel.getFaces()[fi];
                for (int vi = 0; vi < 3; vi++)
                {
                    int index = faceMaps.get(fi).getIndices()[vi];
                    Vertex baseV = uVerts.get(index);

                    float[] newPosition = convertCoords(anim[face[vi]]);
                    float[] displacement = new float[3];
                    for (int i = 0; i < 3; i++)
                    {
                        displacement[i] = newPosition[i] - baseV.getXyz()[i];
                    }

                    Vertex v = new Vertex();
                    v.setXyz(displacement);

                    verts[index] = v;
                }
            }

            animVerts.put(frame, verts);
        }
    }

    private void addAnimation()
    {
        // Add morph targets
        for (int frame = 0; frame < blenderModel.getAnimVertices().length; frame++)
        {
            Vertex[] verts = animVerts.get(frame);
            int morphAccessor = addMorphTarget(verts);

            gltf.meshes.get(0).weights.add(frame == 0 ? 1 : 0);

            Target t = new Target();
            t.setPOSITION(morphAccessor);
            gltf.meshes.get(0).primitives.get(0).targets.add(t);
        }

        // Add the weights and keyframes
        int weightsAccessor = addWeights();
        int keyframesAccessor = addKeyframes();

        // Add the animation
        Animation anim = new Animation();

        Sampler sampler = new Sampler();
        sampler.input = keyframesAccessor;
        sampler.output = weightsAccessor;

        Channel channel = new Channel();
        channel.sampler = 0;
        channel.target = new ChannelTarget();

        anim.samplers.add(sampler);
        anim.channels.add(channel);

        gltf.animations.add(anim);
    }

    private int addMorphTarget(Vertex[] verts)
    {
        int vertexCount = verts.length;

        float[] morphMin = new float[]{Float.MAX_VALUE, Float.MAX_VALUE, Float.MAX_VALUE};
        float[] morphMax = new float[]{Float.MIN_VALUE, Float.MIN_VALUE, Float.MIN_VALUE};

        ByteBuffer morph = ByteBuffer.allocateDirect(vertexCount * 3 * 4)
                .order(ByteOrder.LITTLE_ENDIAN);

        // Add the displacements to the buffer
        for (Vertex vert : verts) {
            for (int i = 0; i < 3; i++)
            {
                float displacement = vert.getXyz()[i];
                morph.putFloat(displacement);
                morphMin[i] = Math.min(morphMin[i], displacement);
                morphMax[i] = Math.max(morphMax[i], displacement);
            }
        }

        int idx = addBuffer(morph, vertexCount, ARRAY_BUFFER, FLOAT, AccessorType.VEC3);
        Accessor a = gltf.accessors.get(idx);
        for (int i = 0; i < 3; i++)
        {
            a.min.add(morphMin[i]);
            a.max.add(morphMax[i]);
        }

        return idx;
    }

    private int addWeights()
    {
        int frameCount = blenderModel.getClientTicks().length;
        int capacity = frameCount * frameCount * 4;

        ByteBuffer weights = ByteBuffer.allocateDirect(capacity)
                .order(ByteOrder.LITTLE_ENDIAN);

        for (int frame = 0; frame < frameCount; frame++)
        {
            for (int morph = 0; morph < frameCount; morph++)
            {
                weights.putFloat(morph == frame ? 1.0f : 0.0f);
            }
        }

        return addBuffer(weights, frameCount * frameCount, ARRAY_BUFFER, FLOAT, AccessorType.SCALAR);
    }

    private int addKeyframes()
    {
        int frameCount = blenderModel.getClientTicks().length;
        int capacity = frameCount * 4;

        ByteBuffer keyframes = ByteBuffer.allocateDirect(capacity)
                .order(ByteOrder.LITTLE_ENDIAN);

        float min = Float.MAX_VALUE;
        float max = Float.MIN_VALUE;

        for (int i = 0; i < frameCount; i++)
        {
            float secs = i == 0 ? 0f : blenderModel.getClientTicks()[i] * 20 / 1000f;
            min = Math.min(min, secs);
            max = Math.max(max, secs);
            keyframes.putFloat(secs);
        }

        int idx = addBuffer(keyframes, frameCount, ARRAY_BUFFER, FLOAT, AccessorType.SCALAR);
        Accessor a = gltf.accessors.get(idx);
        a.min.add(min);
        a.max.add(max);

        return idx;
    }

    private int addBuffer(
            ByteBuffer buf,
            int count,
            int target,
            int componentType,
            AccessorType type
    )
    {
        Buffer b = new Buffer();
        BufferView bv = new BufferView();
        Accessor a = new Accessor();

        gltf.buffers.add(b);
        gltf.bufferViews.add(bv);
        gltf.accessors.add(a);

        b.setUri("data:application/octet-stream;base64," + bytesToBase64(buf));
        b.setByteLength(buf.capacity());

        bv.setBuffer(gltf.buffers.size() - 1);
        bv.setByteOffset(0);
        bv.setByteLength(buf.capacity());
        bv.setTarget(target);

        a.setBufferView(gltf.bufferViews.size() - 1);
        a.setByteOffset(0);
        a.setComponentType(componentType);
        a.setNormalized(false);
        a.setCount(count);
        a.setType(type);

        return gltf.accessors.size() - 1;
    }

    private String bytesToBase64(ByteBuffer buffer) {
        buffer.rewind();
        byte[] bytes = new byte[buffer.remaining()];
        buffer.get(bytes);
        return java.util.Base64.getEncoder().encodeToString(bytes);
    }

    @Data
    static class Vertex
    {
        float[] xyz;
        float[] colour;
        int index;

        @Override
        public boolean equals(Object obj)
        {
            if (!(obj instanceof Vertex))
            {
                return false;
            }

            Vertex v = (Vertex) obj;
            return Arrays.equals(xyz, v.getXyz()) && Arrays.equals(colour, v.getColour());
        }

        @Override
        public int hashCode() {
            HashFunction hashFunction = Hashing.murmur3_32();
            Hasher hasher = hashFunction.newHasher();

            for (float value : xyz) {
                hasher.putFloat(value);
            }

            for (float value : colour) {
                hasher.putFloat(value);
            }

            return hasher.hash().asInt();
        }
    }

    @Data
    static
    class FaceMap
    {
        int[] indices;
        public void addIndex(int pos, int vertIndex)
        {
            if (indices == null)
            {
                indices = new int[3];
            }

            indices[pos] = vertIndex;
        }

        public int get(int i) { return indices[i]; }
    }
}

package com.creatorskit.models.exporters;

import lombok.Data;
import java.util.ArrayList;
import java.util.List;

public class GLTF
{
    public int scene = 0;
    public Scene[] scenes = new Scene[]{new Scene()};
    public Node[] nodes = new Node[]{new Node()};
    public BaseSampler[] samplers = new BaseSampler[]{new BaseSampler()};
    public List<Mesh> meshes = new ArrayList<>();
    public List<Buffer> buffers = new ArrayList<>();
    public List<BufferView> bufferViews = new ArrayList<>();
    public List<Accessor> accessors = new ArrayList<>();
    public Asset asset = new Asset();

    public Material[] materials = new Material[]{new Material()};
    public List<Animation> animations = new ArrayList<>();

    enum AccessorType {
        SCALAR,
        VEC3,
        VEC4
    }

    public static class Scene {
        int[] nodes = new int[]{0};
    }

    public static class Node {
        int mesh = 0;
    }

    @Data
    public static class Mesh {
        List<primitive> primitives = new ArrayList<>();
        List<Integer> weights = new ArrayList<>();
        int[] materials = new int[]{0};
        String name = "mesh";
    }

    @Data
    public static class primitive {
        int indices;
        Attribute attributes;
        List<Target> targets = new ArrayList<>();
        int material = 0;
    }

    @Data
    public static class Target {
        int POSITION;
    }

    @Data
    public static class Attribute {
        int POSITION;
        int COLOR_0;
    }

    public static class Material
    {
        String name = "vertexColors";
        float[] baseColorFactor = new float[]{1.0f, 1.0f, 1.0f};
        MetallicRoughness pbrMetallicRoughness = new MetallicRoughness();
    }

    public static class MetallicRoughness
    {
        float[] baseColorFactor = new float[]{1.0f, 1.0f, 1.0f, 1.0f};
        float metallicFactor = 0.0f;
        float roughnessFactor = 1.0f;
    }

    @Data
    public static class Animation {
        List<Channel> channels = new ArrayList<>();
        List<Sampler> samplers = new ArrayList<>();
    }

    public static class BaseSampler {
        int magFilter = 9729;
        int minFilter = 9987;
        int wrapS = 33648;
        int wrapT = 33648;
    }

    @Data
    public static class Sampler {
        int input;
        String interpolation = "STEP";
        int output;
    }

    @Data
    public static class Channel {
        int sampler;
        ChannelTarget target;
    }

    public static class ChannelTarget {
        int node = 0;
        String path = "weights";
    }

    @Data
    public static class Buffer {
        String uri;
        int byteLength;
    }

    @Data
    public static class BufferView {
        int buffer;
        int byteOffset;
        int byteLength;
        int target;
    }

    @Data
    public static class Accessor {
        int bufferView;
        int byteOffset;
        int componentType;
        boolean normalized;
        int count;
        AccessorType type;
        List<Number> max = new ArrayList<>();
        List<Number> min = new ArrayList<>();
    }

    public static class Asset {
        String version = "2.0";
        String generator = "CreatorsKit";
    }
}

package com.creatorskit.models.exporters;

import com.creatorskit.CreatorsConfig;
import com.creatorskit.CreatorsPlugin;
import java.nio.file.Paths;

import com.creatorskit.models.*;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.client.RuneLite;
import org.apache.commons.lang3.ArrayUtils;

import javax.inject.Inject;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Arrays;

@Slf4j
public class ModelExporter
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    public final File BLENDER_DIR = new File(RuneLite.RUNELITE_DIR, "creatorskit/blender-models");

    @Inject
    public ModelExporter(Client client, CreatorsPlugin plugin, CreatorsConfig config)
    {
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    public void saveToFile(String name, BlenderModel blenderModel)
    {
        boolean success;
        switch (config.exportFileFormat())
        {
            case OBJ:
                if (blenderModel.getAnimVertices().length > 0)
                {
                    plugin.sendChatMessage("You cannot export animations to OBJ format. Falling back to Blender format.");
                    success = saveBlender(name, blenderModel);
                } else {
                    success = OBJExporter.saveOBJ(name, blenderModel);
                }
                break;
            case GLTF:
                GLTFExporter gltfExporter = new GLTFExporter(name, blenderModel);
                success = gltfExporter.saveGLTF(plugin.getGson(), name);
                break;
            default:
            case BLENDER:
                success = saveBlender(name, blenderModel);
                break;
        }

        if (success)
            plugin.sendChatMessage("Exported " + name + " to your /.runelite/creatorskit/blender-models directory.");
    }

    private boolean saveBlender(String name, BlenderModel blenderModel)
    {
        try
        {
            BLENDER_DIR.mkdirs();

            String path = Paths.get(BLENDER_DIR.getPath(), name).toString();
            String ext = ".json";
            int iteration = 0;
            File file = new File(path + ext);
            while (file.exists())
            {
                iteration++;
                file = new File(path + " (" + iteration + ")" + ext);
            }

            FileWriter writer = new FileWriter(file, false);
            String string = plugin.getGson().toJson(blenderModel);
            writer.write(string);
            writer.close();
        }
        catch (IOException e)
        {
            log.debug("Error when exporting model to file");
            return false;
        }

        return true;
    }

    public BlenderModel bmVertexColours(Renderable renderable)
    {
        Model model;
        if (renderable instanceof Model)
        {
            model = (Model) renderable;
        }
        else
        {
            model = renderable.getModel();
        }

        int[][] verts = new int[model.getVerticesCount()][3];
        float[] vX = model.getVerticesX();
        float[] vY = model.getVerticesY();
        float[] vZ = model.getVerticesZ();

        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = (int) vX[i];
            v[1] = (int) vY[i];
            v[2] = (int) vZ[i];
        }

        int[][] faces = new int[model.getFaceCount()][3];
        int[] fX = model.getFaceIndices1();
        int[] fY = model.getFaceIndices2();
        int[] fZ = model.getFaceIndices3();

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = fX[i];
            f[1] = fY[i];
            f[2] = fZ[i];
        }

        byte[] transparencies = new byte[model.getFaceCount()];
        if (model.getFaceTransparencies() == null)
        {
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = model.getFaceTransparencies();
        }

        // Each face has 3 vertices, each vertex has a h, l, s, and alpha value
        byte[] vertTransparencies = Arrays.copyOf(transparencies, transparencies.length);
        int[] vt = new int[vertTransparencies.length];
        for (int i = 0; i< model.getFaceCount(); i++)
        {
            int tp = vertTransparencies[i];
            if (tp < 0)
            {
                tp += 256;
            }
            vt[i] = tp;
        }

        int[] fc1 = model.getFaceColors1();
        int[] fc2 = model.getFaceColors2();
        int[] fc3 = model.getFaceColors3();
        int[][] shortList = new int[0][2];
        int[] vertexColourIndex = new int[0];

        for (int i = 0; i < model.getFaceCount(); i++)
        {
            int tp = vt[i];

            int fc1i = fc1[i];
            int fc2i = fc2[i];
            int fc3i = fc3[i];
            boolean shadeFlat = fc3i == -1;
            if (shadeFlat)
            {
                fc3i = fc2i = fc1i;
            }

            boolean alreadyContains1 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc1i && shortList[e][1] == tp)
                {
                    alreadyContains1 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains1)
            {
                int[] colourTransparency = new int[]{fc1i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }


            boolean alreadyContains2 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc2i && shortList[e][1] == tp)
                {
                    alreadyContains2 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains2)
            {
                int[] colourTransparency = new int[]{fc2i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }

            boolean alreadyContains3 = false;
            for (int e = 0; e < shortList.length; e++)
            {
                if (shortList[e][0] == fc3i && shortList[e][1] == tp)
                {
                    alreadyContains3 = true;
                    vertexColourIndex = ArrayUtils.add(vertexColourIndex, e);
                    break;
                }
            }

            if (!alreadyContains3)
            {
                int[] colourTransparency = new int[]{fc3i, tp};
                shortList = ArrayUtils.add(shortList, colourTransparency);
                vertexColourIndex = ArrayUtils.add(vertexColourIndex, shortList.length - 1);
            }
        }

        /*
        System.out.println("Shortlist length: " + shortList.length);
        System.out.println("index length: " + vertexColourIndex.length);
        System.out.println("Verts: " + model.getVerticesCount());
        System.out.println("Faces: " + model.getFaceCount());

         */

        double[][] vertexColours = new double[shortList.length][4];
        for (int i = 0; i < shortList.length; i++)
        {
            double tp = shortList[i][1];
            tp = -1 * (tp - 255) / 255;

            int intCol = shortList[i][0];
            if (intCol > 32767)
            {
                intCol -= 65536;
            }

            short col = (short) intCol;
            double h0 = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l0 = (double) JagexColor.unpackLuminance(col) / 127;
            double s0 = (double) JagexColor.unpackSaturation(col) / 7;
            vertexColours[i][0] = h0;
            vertexColours[i][1] = l0;
            vertexColours[i][2] = s0;
            vertexColours[i][3] = tp;
        }

        byte[] renderPriorities = model.getFaceRenderPriorities();
        if (model.getFaceRenderPriorities() == null)
        {
            renderPriorities = new byte[model.getFaceCount()];
            Arrays.fill(renderPriorities, (byte) 0);
        }

        return new BlenderModel(
                true,
                verts,
                faces,
                vertexColours,
                vertexColourIndex,
                new double[0][],
                new int[0],
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }

    public BlenderModel bmFaceColours(
            ModelStats[] modelStatsArray,
            boolean object,
            int[] kitRecolours,
            boolean player,
            int[] vX,
            int[] vY,
            int[] vZ,
            int[] f1,
            int[] f2,
            int[] f3,
            byte[] transparencies,
            byte[] renderPriorities)
    {
        ModelData[] mds = new ModelData[modelStatsArray.length];

        for (int i = 0; i < modelStatsArray.length; i++)
        {
            ModelStats modelStats = modelStatsArray[i];
            ModelData modelData = client.loadModelData(modelStats.getModelId());

            if (modelData == null)
                continue;

            modelData.cloneColors().cloneVertices();
            if (modelData.getFaceTransparencies() != null)
            {
                modelData.cloneTransparencies();
            }

            for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
                modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

            if (player)
                KitRecolourer.recolourKitModel(modelData, modelStats.getBodyPart(), kitRecolours);

            short[] textureFrom = modelStats.getTextureFrom();
            short[] textureTo = modelStats.getTextureTo();

            if (textureFrom == null || textureTo == null)
            {
                modelStats.setTextureFrom(new short[0]);
                modelStats.setTextureTo(new short[0]);
            }

            textureFrom = modelStats.getTextureFrom();
            textureTo = modelStats.getTextureTo();

            if (textureFrom.length > 0 && textureTo.length > 0)
            {
                for (int e = 0; e < textureFrom.length; e++)
                {
                    modelData.retexture(textureFrom[e], textureTo[e]);
                }
            }

            if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
            {
                modelStats.setResizeX(128);
                modelStats.setResizeY(128);
                modelStats.setResizeZ(128);
            }

            if (!object)
            {
                modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());
            }
            modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

            mds[i] = modelData;
        }

        ModelData md = client.mergeModels(mds);
        if (object)
        {
            ModelStats ms0 = modelStatsArray[0];
            if (ms0 == null)
            {
                return null;
            }

            md.scale(ms0.getResizeX(), ms0.getResizeZ(), ms0.getResizeY());
        }

        /*
        System.out.println("ModelData FC: " + md.getFaceCount());
        System.out.println(f1.length + "," + f2.length + "," + f3.length);
        System.out.println("ModelData VC: " + md.getVerticesCount());
        System.out.println(vX.length + "," + vY.length + "," + vZ.length);
         */

        int[][] verts = new int[md.getVerticesCount()][3];
        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = vX[i];
            v[1] = vY[i];
            v[2] = vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]

        );
    }

    public BlenderModel bmFaceColoursForForgedModel(
            ModelData md,
            int[] vX,
            int[] vY,
            int[] vZ,
            int[] f1,
            int[] f2,
            int[] f3,
            byte[] transparencies,
            byte[] renderPriorities)
    {
        /*
        System.out.println("ModelData FC: " + md.getFaceCount());
        System.out.println(f1.length + "," + f2.length + "," + f3.length);
         */

        int[][] verts = new int[md.getVerticesCount()][3];
        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = vX[i];
            v[1] = vY[i];
            v[2] = vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }

    public BlenderModel bmFromCustomModel(CustomModel customModel)
    {
        CustomModelComp comp = customModel.getComp();
        Model model = customModel.getModel();

        BlenderModel blenderModel;
        ModelData md;
        int fCount;
        byte[] renderPriorities;
        byte[] transparencies;
        switch (comp.getType())
        {
            case FORGED:
                md = plugin.createComplexModelData(comp.getDetailedModels());
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx = md.getVerticesX();
                float[] fvy = md.getVerticesY();
                float[] fvz = md.getVerticesZ();

                int vCount = md.getVerticesCount();
                int[] vX = new int[vCount];
                int[] vY = new int[vCount];
                int[] vZ = new int[vCount];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX[i] = (int) fvx[i];
                    vY[i] = (int) fvy[i];
                    vZ[i] = (int) fvz[i];
                }

                blenderModel = bmFaceColoursForForgedModel(
                        md,
                        vX,
                        vY,
                        vZ,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            default:
            case CACHE_NPC:
            case CACHE_OBJECT:
            case CACHE_SPOTANIM:
            case CACHE_GROUND_ITEM:
            case CACHE_MAN_WEAR:
            case CACHE_WOMAN_WEAR:
                md = plugin.constructModelDataFromCache(comp.getModelStats(), new int[0], false);
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx1 = md.getVerticesX();
                float[] fvy1 = md.getVerticesY();
                float[] fvz1 = md.getVerticesZ();

                int vCount1 = md.getVerticesCount();
                int[] vX1 = new int[vCount1];
                int[] vY1 = new int[vCount1];
                int[] vZ1 = new int[vCount1];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX1[i] = (int) fvx1[i];
                    vY1[i] = (int) fvy1[i];
                    vZ1[i] = (int) fvz1[i];
                }

                blenderModel = bmFaceColours(
                        comp.getModelStats(),
                        comp.getType() == CustomModelType.CACHE_OBJECT,
                        new int[0],
                        false,
                        vX1,
                        vY1,
                        vZ1,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            case CACHE_PLAYER:
                md = plugin.constructModelDataFromCache(comp.getModelStats(), comp.getKitRecolours(), true);
                fCount = md.getFaceCount();

                if (model.getFaceRenderPriorities() == null)
                {
                    renderPriorities = new byte[fCount];
                    Arrays.fill(renderPriorities, (byte) 0);
                }
                else
                {
                    renderPriorities = model.getFaceRenderPriorities();
                }

                if (model.getFaceTransparencies() == null)
                {
                    transparencies = new byte[fCount];
                    Arrays.fill(transparencies, (byte) 0);
                }
                else
                {
                    transparencies = model.getFaceTransparencies();
                }

                float[] fvx2 = md.getVerticesX();
                float[] fvy2 = md.getVerticesY();
                float[] fvz2 = md.getVerticesZ();

                int vCount2 = md.getVerticesCount();
                int[] vX2 = new int[vCount2];
                int[] vY2 = new int[vCount2];
                int[] vZ2 = new int[vCount2];

                for (int i = 0; i < md.getVerticesCount(); i++)
                {
                    vX2[i] = (int) fvx2[i];
                    vY2[i] = (int) fvy2[i];
                    vZ2[i] = (int) fvz2[i];
                }

                blenderModel = bmFaceColours(
                        comp.getModelStats(),
                        false,
                        comp.getKitRecolours(),
                        true,
                        vX2,
                        vY2,
                        vZ2,
                        md.getFaceIndices1(),
                        md.getFaceIndices2(),
                        md.getFaceIndices3(),
                        transparencies,
                        renderPriorities);
                break;
            case BLENDER:
                blenderModel = comp.getBlenderModel();
        }

        return blenderModel;
    }

    public BlenderModel bmSpotAnimFromCache(ModelStats[] modelStatsArray)
    {
        ModelData[] mds = new ModelData[modelStatsArray.length];

        for (int i = 0; i < modelStatsArray.length; i++)
        {
            ModelStats modelStats = modelStatsArray[i];
            ModelData modelData = client.loadModelData(modelStats.getModelId());

            if (modelData == null)
                continue;

            modelData.cloneColors().cloneVertices();
            if (modelData.getFaceTransparencies() != null)
            {
                modelData.cloneTransparencies();
            }

            for (short s = 0; s < modelStats.getRecolourFrom().length; s++)
                modelData.recolor(modelStats.getRecolourFrom()[s], modelStats.getRecolourTo()[s]);

            if (modelStats.getResizeX() == 0 && modelStats.getResizeY() == 0 && modelStats.getResizeZ() == 0)
            {
                modelStats.setResizeX(128);
                modelStats.setResizeY(128);
                modelStats.setResizeZ(128);
            }

            modelData.scale(modelStats.getResizeX(), modelStats.getResizeZ(), modelStats.getResizeY());
            modelData.translate(0, -1 * modelStats.getTranslateZ(), 0);

            mds[i] = modelData;
        }

        ModelData md = client.mergeModels(mds);

        int[][] verts = new int[md.getVerticesCount()][3];
        float[] vX = md.getVerticesX();
        float[] vY = md.getVerticesY();
        float[] vZ = md.getVerticesZ();

        for (int i = 0; i < verts.length; i++)
        {
            int[] v = verts[i];
            v[0] = (int) vX[i];
            v[1] = (int) vY[i];
            v[2] = (int) vZ[i];
        }

        int[][] faces = new int[md.getFaceCount()][3];
        int[] f1 = md.getFaceIndices1();
        int[] f2 = md.getFaceIndices2();
        int[] f3 = md.getFaceIndices3();

        for (int i = 0; i < faces.length; i++)
        {
            int[] f = faces[i];
            f[0] = f1[i];
            f[1] = f2[i];
            f[2] = f3[i];
        }

        byte[] transparencies = new byte[md.getFaceCount()];
        if (md.getFaceTransparencies() == null)
        {
            Arrays.fill(transparencies, (byte) 0);
        }
        else
        {
            transparencies = md.getFaceTransparencies();
        }

        short[] mdFaceColours = md.getFaceColors();
        int[] faceColourIndex = new int[mdFaceColours.length];
        short[][] fcShortList = new short[0][2];
        for (int i = 0; i < md.getFaceCount(); i++)
        {
            short col = mdFaceColours[i];
            short tp = transparencies[i];
            boolean alreadyContains = false;
            for (int e = 0; e < fcShortList.length; e++)
            {
                if (col == fcShortList[e][0] && tp == fcShortList[e][1])
                {
                    faceColourIndex[i] = e;
                    alreadyContains = true;
                    break;
                }
            }

            if (alreadyContains)
            {
                continue;
            }

            fcShortList = ArrayUtils.add(fcShortList, new short[]{col, tp});
            faceColourIndex[i] = fcShortList.length - 1;
        }

        int shortListSize = fcShortList.length;
        double[][] faceColours = new double[shortListSize][4];
        for (int i = 0; i < shortListSize; i++)
        {
            short col = fcShortList[i][0];
            double h = (double) (63 - JagexColor.unpackHue(col)) / 63;
            double l = (double) JagexColor.unpackLuminance(col) / 127;
            double s = (double) JagexColor.unpackSaturation(col) / 7;

            double a = (fcShortList[i][1]);
            if (a < 0)
            {
                a += 256;
            }
            a = (255 - a) / 255;

            double[] array = faceColours[i];
            array[0] = h;
            array[1] = l;
            array[2] = s;
            array[3] = a;
        }

        byte[] renderPriorities = new byte[md.getFaceCount()];

        return new BlenderModel(
                false,
                verts,
                faces,
                new double[0][],
                new int[0],
                faceColours,
                faceColourIndex,
                renderPriorities,
                new int[0],
                new int[0][][]
        );
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;

@AllArgsConstructor
public enum CustomModelType
{
    FORGED("Forged"),
    CACHE_NPC("NPC"),
    CACHE_OBJECT("Object"),
    CACHE_PLAYER("Player"),
    CACHE_GROUND_ITEM("Ground Item"),
    CACHE_MAN_WEAR("Male Worn Item"),
    CACHE_WOMAN_WEAR("Female Worn Item"),
    CACHE_SPOTANIM("SpotAnim"),
    BLENDER("Blender")

    ;

    private final String name;

    @Override
    public String toString()
    {
        return name;
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Model;

@Getter
@Setter
@AllArgsConstructor
public class CustomModel
{
    private Model model;
    private CustomModelComp comp;

    @Override
    public String toString()
    {
        return comp.getName();
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CustomModelComp
{
    private int customModelId;
    private CustomModelType type;
    private int modelId;
    private ModelStats[] modelStats;
    private int[] kitRecolours;
    private DetailedModel[] detailedModels;
    private BlenderModel blenderModel;
    private LightingStyle lightingStyle;
    private CustomLighting customLighting;
    private boolean priority;
    private String name;
}

package com.creatorskit.models;

import net.runelite.api.ModelData;
import org.apache.commons.lang3.ArrayUtils;

public class KitRecolourer
{
    public static final short[] BODY_COLOURS_1_SOURCE = new short[]{
            6798, 8741, 25238, 4626, 4550
    };
    public static final short[][] BODY_COLOURS_1_DEST = new short[][]{
            {6798, 107, 10283, 16, 4797, 7744, 5799, 4634, -31839, 22433, 2983, -11343, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010, -22122, 937, 8130, -13422, 30385},
            {8741, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 25239, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
            {25238, 8742, 12, -1506, -22374, 7735, 8404, 1701, -27106, 24094, 10153, -8915, 4783, 1341, 16578, -30533, 8, 5281, 10438, 3650, -27322, -21845, 200, 571, 908, 21830, 28946, -15701, -14010},
            {4626, 11146, 6439, 12, 4758, 10270},
            {4550, 4537, 5681, 5673, 5790, 6806, 8076, 4574, 17050, 0, 127, -31821, -17991}
    };
    public static final short[] BODY_COLOURS_2_SOURCE = new short[]{
            -10304, 9104, -1, -1, -1
    };
    public static final short[][] BODY_COLOURS_2_DEST = new short[][]{
            {6554, 115, 10304, 28, 5702, 7756, 5681, 4510, -31835, 22437, 2859, -11339, 16, 5157, 10446, 3658, -27314, -21965, 472, 580, 784, 21966, 28950, -15697, -14002, -22116, 945, 8144, -13414, 30389},
            {9104, 10275, 7595, 3610, 7975, 8526, 918, -26734, 24466, 10145, -6882, 5027, 1457, 16565, -30545, 25486, 24, 5392, 10429, 3673, -27335, -21957, 192, 687, 412, 21821, 28835, -15460, -14019},
            new short[0],
            new short[0],
            new short[0]
    };

                        /*
						0 = hair, jaw
						1 = torso, arms
						2 = legs
						3 = Feet
						4 = Hands
						 */

    public static ModelData recolourKitModel(ModelData modelData, BodyPart bodyPart, int[] kitRecolours)
    {
        switch (bodyPart)
        {
            default:
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HAIR:
            case JAW:
                modelData.recolor(BODY_COLOURS_1_SOURCE[0], BODY_COLOURS_1_DEST[0][kitRecolours[0]]);
                modelData.recolor(BODY_COLOURS_2_SOURCE[0], BODY_COLOURS_2_DEST[0][kitRecolours[0]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case TORSO:
            case ARMS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[1], BODY_COLOURS_1_DEST[1][kitRecolours[1]]);
                modelData.recolor(BODY_COLOURS_2_SOURCE[1], BODY_COLOURS_2_DEST[1][kitRecolours[1]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case LEGS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[2], BODY_COLOURS_1_DEST[2][kitRecolours[2]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case FEET:
                modelData.recolor(BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_DEST[3][kitRecolours[3]]);
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HANDS:
                modelData.recolor(BODY_COLOURS_1_SOURCE[4], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
        }
        return modelData;
    }

    public static short[] getKitRecolourFrom(BodyPart bodyPart)
    {
        short[] colourFrom = new short[0];

        switch (bodyPart)
        {
            default:
                colourFrom = ArrayUtils.add(colourFrom, BODY_COLOURS_1_SOURCE[4]);
                break;
            case HAIR:
            case JAW:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[0], BODY_COLOURS_2_SOURCE[0], BODY_COLOURS_1_SOURCE[4]);
                break;
            case TORSO:
            case ARMS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[1], BODY_COLOURS_2_SOURCE[1], BODY_COLOURS_1_SOURCE[4]);
                break;
            case LEGS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[2], BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_SOURCE[4]);
                break;
            case FEET:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[3], BODY_COLOURS_1_SOURCE[4]);
                break;
            case HANDS:
                colourFrom = ArrayUtils.addAll(colourFrom, BODY_COLOURS_1_SOURCE[4]);
        }

        return colourFrom;
    }

    public static short[] getKitRecolourTo(BodyPart bodyPart, int[] kitRecolours)
    {
        short[] colourTo = new short[0];

        switch (bodyPart)
        {
            default:
                colourTo = ArrayUtils.add(colourTo, BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HAIR:
            case JAW:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[0][kitRecolours[0]], BODY_COLOURS_2_DEST[0][kitRecolours[0]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case TORSO:
            case ARMS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[1][kitRecolours[1]], BODY_COLOURS_2_DEST[1][kitRecolours[1]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case LEGS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[2][kitRecolours[2]], BODY_COLOURS_1_DEST[3][kitRecolours[3]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case FEET:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[3][kitRecolours[3]], BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
                break;
            case HANDS:
                colourTo = ArrayUtils.addAll(colourTo, BODY_COLOURS_1_DEST[4][kitRecolours[4]]);
        }

        return colourTo;
    }
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
public class BlenderModel
{
    boolean useVertexColours;
    int[][] vertices;
    int[][] faces;
    double[][] vertexColours;
    int[] vertexColourIndex;
    double[][] faceColours;
    int[] faceColourIndex;
    byte[] priorities;
    int[] clientTicks;
    int[][][] animVertices;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class DetailedModel
{
    private String name;
    private int modelId;
    private int group;
    private int xTile;
    private int yTile;
    private int zTile;
    private int xTranslate;
    private int yTranslate;
    private int zTranslate;
    private int xScale;
    private int yScale;
    private int zScale;
    private int rotate;
    private String recolourNew;
    private String recolourOld;
    private short[] coloursFrom;
    private short[] coloursTo;
    private short[] texturesFrom;
    private short[] texturesTo;
    private boolean invertFaces;
}

package com.creatorskit.models;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public enum LightingStyle
{
    NONE("None", 128, 4000, -50, -50, 10),
    ACTOR("Actor", 64, 850, -30, -30, 50),
    DEFAULT("Default", 64, 768, -50, -50, 10),
    SPOTANIM("SpotAnim", 64, 850, -50, -50, 75),
    DYNAMIC("Dynamic", 100, 850, -10, -10, 10),
    CUSTOM("Custom", 64, 768, -50, -50, 10)
    ;

    private final String string;
    private final int ambient;
    private final int contrast;
    private final int x;
    private final int y;
    private final int z;

    @Override
    public String toString()
    {
        return string;
    }
}

package com.creatorskit.models;

public enum PoseAnimation
{
    POSE,
    WALK,
    RUN,
    BACKWARDS,
    SHUFFLE_LEFT,
    SHUFFLE_RIGHT,
    ROTATE,
    NONE
}

package com.creatorskit;

public enum AutoRotate
{
    OFF,
    LEFT,
    RIGHT,
    UP,
    DOWN
}

package com.creatorskit;

import com.creatorskit.models.exporters.ExportFileFormat;
import com.creatorskit.programming.MovementType;
import com.creatorskit.swing.timesheet.sheets.TimelineUnits;
import net.runelite.client.config.*;

import java.awt.event.KeyEvent;

@ConfigGroup("creatorssuite")
public interface CreatorsConfig extends Config
{
	@ConfigSection(
			name = "Scene",
			description = "Settings for setting up your scene",
			position = 0
	)
	String sceneSettings = "sceneSettings";

	@ConfigItem(
			keyName = "enableRightClick",
			name = "Enable Right-Click Options",
			description = "Enables Right-Click menu options for on Objects, NPCs, and Players",
			section = sceneSettings,
			position = 0
	)
	default boolean rightClick()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableCtrlHotkeys",
			name = "Enable Ctrl Hotkeys",
			description = "Enables various additional menu options when holding Ctrl",
			section = sceneSettings,
			position = 1
	)
	default boolean enableCtrlHotkeys()
	{
		return false;
	}

	@ConfigItem(
			keyName = "toggleAutoSetup",
			name = "Enable Auto-Setup",
			description = "Automatically loads the saved Setup from the file path below" +
				"<br>Please note that enabling this feature will slow down client start-up",
			section = sceneSettings,
			position = 6
	)
	default boolean autoSetup()
	{
		return false;
	}

	@ConfigItem(
			keyName = "setupPath",
			name = "Auto-Setup Path",
			description = "Enter the file path of a previously saved setup to automatically load on client start-up",
			section = sceneSettings,
			position = 7
	)
	default String setupPath()
	{
		return "";
	}

	@ConfigItem(
			keyName = "quickSpawn",
			name = "Spawn Hotkey",
			description = "Hotkey to toggle the spawn or despawn state of the selected object",
			section = sceneSettings,
			position = 8
	)
	default Keybind quickSpawnHotkey()
	{
		return new Keybind(KeyEvent.VK_INSERT, 0);
	}

	@ConfigItem(
			keyName = "quickLocation",
			name = "Set Relocate Hotkey",
			description = "Hotkey to set the selected object to the mouse location",
			section = sceneSettings,
			position = 9
	)
	default Keybind quickLocationHotkey()
	{
		return new Keybind(KeyEvent.VK_HOME, 0);
	}

	@ConfigItem(
			keyName = "quickDuplicate",
			name = "Duplicate Hotkey",
			description = "Hotkey to duplicate the selected object",
			section = sceneSettings,
			position = 10
	)
	default Keybind quickDuplicateHotkey()
	{
		return new Keybind(KeyEvent.VK_D, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "quickRotateCW",
			name = "Rotate CW Hotkey",
			description = "Hotkey to rotate the selected object clockwise",
			section = sceneSettings,
			position = 11
	)
	default Keybind quickRotateCWHotkey()
	{
		return new Keybind(KeyEvent.VK_DELETE, 0);
	}

	@ConfigItem(
			keyName = "quickRotateCCW",
			name = "Rotate CCW Hotkey",
			description = "Hotkey to rotate the selected object counter-clockwise",
			section = sceneSettings,
			position = 12
	)
	default Keybind quickRotateCCWHotkey()
	{
		return new Keybind(KeyEvent.VK_END, 0);
	}

	@ConfigItem(
			keyName = "rotateDegrees",
			name = "Rotate Degrees",
			description = "Determines how much the Rotate Hotkeys rotate the Object by",
			section = sceneSettings,
			position = 13
	)
	default Rotation rotateDegrees()
	{
		return Rotation._90_DEGREES;
	}

	@ConfigItem(
			keyName = "orientationStart",
			name = "Set Orientation Start",
			description = "Hotkey to set the Start Orientation of an Orientation Keyframe",
			section = sceneSettings,
			position = 14
	)
	default Keybind orientationStart()
	{
		return new Keybind(KeyEvent.VK_OPEN_BRACKET, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "orientationEnd",
			name = "Set Orientation End",
			description = "Hotkey to set the End Orientation of an Orientation Keyframe",
			section = sceneSettings,
			position = 15
	)
	default Keybind orientationEnd()
	{
		return new Keybind(KeyEvent.VK_CLOSE_BRACKET, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigSection(
			name = "Overlays",
			description = "Settings for enabling/disabling overlays",
			position = 1
	)
	String overlaySettings = "overlaySettings";

	@ConfigItem(
			keyName = "toggleOverlays",
			name = "Toggle Overlays",
			description = "Hotkey to toggle all overlays. Unset to disable",
			section = overlaySettings,
			position = 0
	)
	default Keybind toggleOverlaysHotkey()
	{
		return new Keybind(KeyEvent.VK_PAGE_DOWN, 0);
	}

	@ConfigItem(
			keyName = "myObjectOverlay",
			name = "My Object Overlay",
			description = "Enables an overlay for objects introduced via this plugin",
			section = overlaySettings,
			position = 1
	)
	default boolean myObjectOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "pathOverlay",
			name = "Object Path Overlay",
			description = "Enables an overlay for the pathing of programmed objects introduced via this plugin",
			section = overlaySettings,
			position = 2
	)
	default boolean pathOverlay()
	{
		return true;
	}

	@ConfigItem(
			keyName = "gameObjectOverlay",
			name = "Game Object Overlay",
			description = "Enables an overlay for GameObjects",
			section = overlaySettings,
			position = 3
	)
	default boolean gameObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "playerOverlay",
			name = "Player Overlay",
			description = "Enables an overlay for Players",
			section = overlaySettings,
			position = 4
	)
	default boolean playerOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "npcOverlay",
			name = "NPC Overlay",
			description = "Enables an overlay for NPCs",
			section = overlaySettings,
			position = 5
	)
	default boolean npcOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "groundObjectOverlay",
			name = "Ground Object Overlay",
			description = "Enables an overlay for GroundObjects",
			section = overlaySettings,
			position = 6
	)
	default boolean groundObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "wallObjectOverlay",
			name = "Wall Object Overlay",
			description = "Enables an overlay for TileObjects",
			section = overlaySettings,
			position = 7
	)
	default boolean wallObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "decorativeObjectOverlay",
			name = "Decorative Object Overlay",
			description = "Enables an overlay for DecorativeObjects",
			section = overlaySettings,
			position = 8
	)
	default boolean decorativeObjectOverlay()
	{
		return false;
	}

	@ConfigItem(
			keyName = "projectileOverlay",
			name = "Projectile Overlay",
			description = "Enables an overlay for Projectiles",
			section = overlaySettings,
			position = 9
	)
	default boolean projectileOverlay()
	{
		return false;
	}

	@ConfigSection(
			name = "Programmer",
			description = "Settings for quickly programming the selected object",
			position = 2
	)
	String programmer = "programmer";

	@ConfigItem(
			keyName = "pathAlgorithm",
			name = "Path Algorithm",
			description = "The Object pathing algorithm by which to modify Movement Keyframes",
			section = programmer,
			position = 0
	)
	default MovementType movementAlgorithm()
	{
		return MovementType.NORMAL;
	}

	@ConfigItem(
			keyName = "addStep",
			name = "Add Program Step",
			description = "Hotkey to add the hovered location to the selected object's program",
			section = programmer,
			position = 1
	)
	default Keybind addProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_A, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "deleteStep",
			name = "Remove Program Step",
			description = "Hotkey to remove the last step from the selected object's program",
			section = programmer,
			position = 2
	)
	default Keybind removeProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_X, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "clearSteps",
			name = "Clear Program Steps",
			description = "Hotkey to clear all steps from the selected object's program",
			section = programmer,
			position = 3
	)
	default Keybind clearProgramStepHotkey()
	{
		return new Keybind(KeyEvent.VK_C, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "playPauseToggle",
			name = "Play/Pause Toggle",
			description = "Hotkey to play/pause selected object",
			section = programmer,
			position = 4
	)
	default Keybind playPauseHotkey()
	{
		return new Keybind(KeyEvent.VK_SPACE, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "resetTimeline",
			name = "Reset Timeline",
			description = "Hotkey to set reset the Timeline to 0",
			section = programmer,
			position = 5
	)
	default Keybind resetTimelineHotkey()
	{
		return new Keybind(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK);
	}

	@ConfigItem(
			keyName = "timelineUnits",
			name = "Timeline Units",
			description = "Set whether the timeline displays in game ticks or seconds",
			section = programmer,
			position = 6
	)
	default TimelineUnits timelineUnits()
	{
		return TimelineUnits.GAMETICKS;
	}

	@ConfigSection(
			name = "Transmogrification",
			description = "Settings for replacing your player character with a saved Custom Model",
			position = 3
	)
	String transmogrification = "Transmogrification";

	@ConfigItem(
			keyName = "enableTransmog",
			name = "Enable Transmogrification",
			description = "Allow your character to be transmogrified into a chosen Custom Model",
			section = transmogrification,
			position = 0
	)
	default boolean enableTransmog()
	{
		return true;
	}

	@ConfigItem(
			keyName = "enableAutoTransmog",
			name = "Enable Auto-Transmog",
			description = "Automatically loads the Transmog from the file path below" +
					"<br>Please note that enabling this feature will slow down client start-up",
			section = transmogrification,
			position = 1
	)
	default boolean autoTransmog()
	{
		return false;
	}

	@ConfigItem(
			keyName = "transmogPath",
			name = "Auto-Transmog Path",
			description = "Enter the file path of a previously saved Transmog to automatically load on client start-up",
			section = transmogrification,
			position = 2
	)
	default String transmogPath()
	{
		return "";
	}

	@ConfigSection(
			name = "Oculus Orb",
			description = "Settings for enabling and modifying Oculus Orb mode",
			position = 4
	)
	String cameraSettings = "cameraSettings";

	@ConfigItem(
			keyName = "orbToggle",
			name = "Toggle Oculus Orb Mode",
			description = "Hotkey to toggle Oculus Orb mode",
			section = cameraSettings,
			position = 0
	)
	default Keybind toggleOrbHotkey()
	{
		return new Keybind(KeyEvent.VK_PAGE_UP, 0);
	}

	@ConfigItem(
			keyName = "orbSpeed",
			name = "Default Orb Speed",
			description = "Set the default normal speed of the Oculus Orb when the client starts",
			section = cameraSettings,
			position = 1
	)
	default int orbSpeed()
	{
		return 36;
	}

	@ConfigItem(
			keyName = "orbPreset1",
			name = "Orb Speed Hotkey 1",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 1",
			section = cameraSettings,
			position = 3
	)
	default Keybind orbSpeedHotkey1()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbPreset2",
			name = "Orb Speed Hotkey 2",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 2",
			section = cameraSettings,
			position = 4
	)
	default Keybind orbSpeedHotkey2()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbPreset3",
			name = "Orb Speed Hotkey 3",
			description = "Hotkey to quickly set Oculus Orb speed to Preset 3",
			section = cameraSettings,
			position = 5
	)
	default Keybind orbSpeedHotkey3()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "orbSpeed1",
			name = "Orb Speed Preset 1",
			description = "Set the Orb Speed for Hotkey 1",
			section = cameraSettings,
			position = 6
	)
	default int speedHotkey1()
	{
		return 5;
	}

	@ConfigItem(
			keyName = "orbSpeed2",
			name = "Orb Speed Preset 2",
			description = "Set the Orb Speed for Hotkey 2",
			section = cameraSettings,
			position = 7
	)
	default int speedHotkey2()
	{
		return 9;
	}

	@ConfigItem(
			keyName = "orbSpeed3",
			name = "Orb Speed Preset 3",
			description = "Set the Orb Speed for Hotkey 3",
			section = cameraSettings,
			position = 8
	)
	default int speedHotkey3()
	{
		return 36;
	}

	@ConfigItem(
			keyName = "rotateLeft",
			name = "AutoRotate Left",
			description = "Hotkey to toggle automatic camera rotation to the left",
			section = cameraSettings,
			position = 9
	)
	default Keybind rotateLeftHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateRight",
			name = "AutoRotate Right",
			description = "Hotkey to toggle automatic camera rotation to the right",
			section = cameraSettings,
			position = 10
	)
	default Keybind rotateRightHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateUp",
			name = "AutoRotate Up",
			description = "Hotkey to toggle automatic camera rotation up",
			section = cameraSettings,
			position = 11
	)
	default Keybind rotateUpHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateDown",
			name = "AutoRotate Down",
			description = "Hotkey to toggle automatic camera rotation down",
			section = cameraSettings,
			position = 12
	)
	default Keybind rotateDownHotkey()
	{
		return Keybind.NOT_SET;
	}

	@ConfigItem(
			keyName = "rotateHorizontalSpeed",
			name = "Rotate Horizontal Speed",
			description = "Set the horizontal automatic camera rotation speed",
			section = cameraSettings,
			position = 13
	)
	default int rotateHorizontalSpeed()
	{
		return 3;
	}

	@ConfigItem(
			keyName = "rotateVerticalSpeed",
			name = "Rotate Vertical Speed",
			description = "Set the vertical automatic camera rotation speed",
			section = cameraSettings,
			position = 14
	)
	default int rotateVerticalSpeed()
	{
		return 3;
	}

	@ConfigSection(
			name = "Model Exporter",
			description = "Settings for changing how Models are Exported to 3D model formats",
			position = 5
	)
	String modelExporter = "modelExporter";

	@ConfigItem(
			keyName = "exportFileFormat",
			name = "Export File Format",
			description = "Pick the file format for exported Models" +
					"<br>Blender json files are intended to be used with the associated Runescape Import addon" +
					"<br>See ScreteMonge for more details",
			section = modelExporter,
			position = 0
	)
	default ExportFileFormat exportFileFormat()
	{
		return ExportFileFormat.BLENDER;
	}

	@ConfigItem(
			keyName = "vertexColours",
			name = "Vertex Colours",
			description = "Makes Blender Model .json files export with Vertex Colours instead of Face Colours",
			section = modelExporter,
			position = 1
	)
	default boolean vertexColours()
	{
		return false;
	}

	@ConfigItem(
			keyName = "exportTPose",
			name = "Export Neutral Pose",
			description = "Puts the Model into its neutral pose (disables animations) for exporting",
			section = modelExporter,
			position = 2
	)
	default boolean exportTPose()
	{
		return false;
	}
}

package com.creatorskit;

import com.creatorskit.models.CustomModel;
import com.creatorskit.swing.ParentPanel;
import com.creatorskit.swing.timesheet.TimeSheetPanel;
import com.creatorskit.swing.timesheet.keyframe.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.Constants;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.callback.ClientThread;
import org.apache.commons.lang3.ArrayUtils;

import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.*;

@Getter
@Setter
@AllArgsConstructor
public class Character
{
    private String name;
    private boolean active;
    private boolean inScene;
    private KeyFrame[][] frames;
    private KeyFrame[] currentFrames;
    private KeyFrameType[] summary;
    private DefaultMutableTreeNode linkedManagerNode;
    private DefaultMutableTreeNode parentManagerNode;
    private Color color;
    private WorldPoint nonInstancedPoint;
    private LocalPoint instancedPoint;
    private int instancedPlane;
    private boolean inPOH;
    private CustomModel storedModel;
    private ParentPanel parentPanel;
    private JPanel objectPanel;
    private boolean customMode;
    private JTextField nameField;
    private JComboBox<CustomModel> comboBox;
    private JButton spawnButton;
    private JButton modelButton;
    private JSpinner modelSpinner;
    private JSpinner animationSpinner;
    private JSpinner animationFrameSpinner;
    private JSpinner orientationSpinner;
    private JSpinner radiusSpinner;
    private CKObject ckObject;
    private CKObject spotAnim1;
    private CKObject spotAnim2;
    private int targetOrientation;

    @Override
    public String toString()
    {
        return name;
    }

    public void setPlaying(boolean playing)
    {
        if (playing)
        {
            play();
            return;
        }

        pause();
    }

    public void play()
    {
        ckObject.setPlaying(true);
        if (spotAnim1 != null)
        {
            spotAnim1.setPlaying(true);
        }

        if (spotAnim2 != null)
        {
            spotAnim2.setPlaying(true);
        }
    }

    public void pause()
    {
        ckObject.setPlaying(false);
        if (spotAnim1 != null)
        {
            spotAnim1.setPlaying(false);
        }

        if (spotAnim2 != null)
        {
            spotAnim2.setPlaying(false);
        }
    }

    /**
     * Updates the Character's current KeyFrame for the given time
     * @param tick the tick at which to look for KeyFrames
     */
    public void updateProgram(double tick)
    {
        for (KeyFrameType type : KeyFrameType.ALL_KEYFRAME_TYPES)
        {
            KeyFrame current = findPreviousKeyFrame(type, tick, true);
            setCurrentKeyFrame(current, type);
        }
    }

    public void setOrientation(int orientation)
    {
        if (ckObject != null)
        {
            ckObject.setOrientation(orientation);
        }

        if (spotAnim1 != null)
        {
            spotAnim1.setOrientation(orientation);
        }

        if (spotAnim2 != null)
        {
            spotAnim2.setOrientation(orientation);
        }
    }

    public void setLocation(LocalPoint lp, int plane)
    {
        if (ckObject != null)
        {
            ckObject.setLocation(lp, plane);
        }

        if (spotAnim1 != null)
        {
            spotAnim1.setLocation(lp, plane);
        }

        if (spotAnim2 != null)
        {
            spotAnim2.setLocation(lp, plane);
        }
    }

    public void setSpotAnim(CKObject spotAnim, KeyFrameType spotAnimType)
    {
        if (spotAnimType == KeyFrameType.SPOTANIM)
        {
            setSpotAnim1(spotAnim);
        }

        if (spotAnimType == KeyFrameType.SPOTANIM2)
        {
            setSpotAnim2(spotAnim);
        }
    }

    public KeyFrame getCurrentKeyFrame(KeyFrameType type)
    {
        return currentFrames[KeyFrameType.getIndex(type)];
    }

    public void setCurrentKeyFrame(KeyFrame keyFrame, KeyFrameType type)
    {
        currentFrames[KeyFrameType.getIndex(type)] = keyFrame;
    }

    public void resetMovementKeyFrame(int clientTick, double currentTime)
    {
        KeyFrame kf = getCurrentKeyFrame(KeyFrameType.MOVEMENT);
        if (kf == null)
        {
            return;
        }

        MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
        double diff = TimeSheetPanel.round(currentTime - keyFrame.getTick());
        int cTickDiff = (int) (diff * Constants.GAME_TICK_LENGTH / Constants.CLIENT_TICK_LENGTH);
        int stepCTick = clientTick - cTickDiff;
        keyFrame.setStepClientTick(stepCTick);
    }

    public KeyFrame[] getKeyFrames(KeyFrameType type)
    {
        return frames[KeyFrameType.getIndex(type)];
    }

    public KeyFrame[] getAllKeyFrames()
    {
        KeyFrame[] keyFrames = new KeyFrame[0];
        for (KeyFrame[] kfs : frames)
        {
            keyFrames = ArrayUtils.addAll(keyFrames, kfs);
        }

        return keyFrames;
    }

    public void setKeyFrames(KeyFrame[] keyFrames, KeyFrameType type)
    {
        frames[KeyFrameType.getIndex(type)] = keyFrames;
    }

    /**
     * find a keyframe of the given type at the given tick
     * @param type the type of keyframe to look for
     * @param tick the tick at which the requested keyframe should exist
     * @return the keyframe, if one is found; otherwise, returns null
     */
    public KeyFrame findKeyFrame(KeyFrameType type, double tick)
    {
        KeyFrame[] frames = getKeyFrames(type);
        if (frames == null)
        {
            return null;
        }

        for (KeyFrame keyFrame : frames)
        {
            if (keyFrame.getTick() == tick)
            {
                return keyFrame;
            }
        }

        return null;
    }

    public KeyFrame findFirstKeyFrame()
    {
        KeyFrame firstFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            for (KeyFrame keyFrame : keyFrames)
            {
                if (firstFrame == null)
                {
                    firstFrame = keyFrame;
                }

                if (keyFrame.getTick() < firstFrame.getTick())
                {
                    firstFrame = keyFrame;
                }
            }
        }

        return firstFrame;
    }

    public KeyFrame findLastKeyFrame()
    {
        KeyFrame lastFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            for (KeyFrame keyFrame : keyFrames)
            {
                if (lastFrame == null)
                {
                    lastFrame = keyFrame;
                }

                if (keyFrame.getTick() > lastFrame.getTick())
                {
                    lastFrame = keyFrame;
                }
            }
        }

        return lastFrame;
    }

    /**
     * Finds the next keyframe for this character of any given KeyFrameType, excluding any keyframes on the current tick
     * @param tick the tick at which to start searching
     * @return the next keyframe
     */
    public KeyFrame findNextKeyFrame(double tick)
    {
        KeyFrame nextFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            if (keyFrames.length == 0)
            {
                continue;
            }

            for (int i = keyFrames.length - 1; i >= 0; i--)
            {
                KeyFrame keyFrame = keyFrames[i];

                if (nextFrame == null)
                {
                    nextFrame = keyFrame;
                    continue;
                }

                if (nextFrame.getTick() <= tick)
                {
                    nextFrame = keyFrame;
                    continue;
                }

                double test = keyFrame.getTick();
                if (test <= tick)
                {
                    continue;
                }

                if (test < nextFrame.getTick())
                {
                    nextFrame = keyFrame;
                }
            }
        }

        if (nextFrame == null)
        {
            return null;
        }

        if (nextFrame.getTick() < tick)
        {
            return null;
        }

        return nextFrame;
    }

    /**
     * Finds the next keyframe for this character of the given KeyFrameType, excluding any keyframes on the current tick
     * @param type the KeyFrameType to look for
     * @param tick the tick at which to start looking
     * @return the next Keyframe of the given KeyFrameType
     */
    public KeyFrame findNextKeyFrame(KeyFrameType type, double tick)
    {
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return null;
        }

        if (keyFrames.length == 0)
        {
            return null;
        }

        for (int i = 0; i < keyFrames.length; i++)
        {
            KeyFrame keyFrame = keyFrames[i];
            if (keyFrame.getTick() > tick)
            {
                return keyFrames[i];
            }
        }

        return null;
    }

    /**
     * Finds the previous keyframe for this character of any given KeyFrameType, excluding any keyframes on the current tick
     * @param tick the tick at which to start searching
     * @return the previous keyframe
     */
    public KeyFrame findPreviousKeyFrame(double tick)
    {
        KeyFrame nextFrame = null;

        for (KeyFrame[] keyFrames : frames)
        {
            if (keyFrames == null)
            {
                continue;
            }

            if (keyFrames.length == 0)
            {
                continue;
            }

            for (int i = 0; i < keyFrames.length; i++)
            {
                KeyFrame keyFrame = keyFrames[i];

                double test = keyFrame.getTick();
                if (test >= tick)
                {
                    continue;
                }

                if (nextFrame == null)
                {
                    nextFrame = keyFrame;
                }

                if (test > nextFrame.getTick())
                {
                    nextFrame = keyFrame;
                }
            }
        }

        if (nextFrame == null)
        {
            return null;
        }

        if (nextFrame.getTick() > tick)
        {
            return null;
        }

        return nextFrame;
    }

    /**
     * Finds the last KeyFrame of the given type relative to the given time
     * @param type the type of KeyFrame to search for
     * @param tick the given time
     * @param includeCurrentKeyFrame whether to include the keyframe at the given time (if any), or to skip and find the keyframe before
     * @return the last keyframe relative to the given time
     */
    public KeyFrame findPreviousKeyFrame(KeyFrameType type, double tick, boolean includeCurrentKeyFrame)
    {
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return null;
        }

        if (keyFrames.length == 0)
        {
            return null;
        }

        for (int i = 0; i < keyFrames.length; i++)
        {
            KeyFrame keyFrame = keyFrames[i];

            if (!includeCurrentKeyFrame && keyFrame.getTick() == tick)
            {
                if (i == 0)
                {
                    return null;
                }

                return keyFrames[i - 1];
            }

            if (keyFrame.getTick() > tick)
            {
                if (i == 0)
                {
                    return null;
                }

                return keyFrames[i - 1];
            }
        }

        return keyFrames[keyFrames.length - 1];
    }

    /**
     * Adds the keyframe to a specific character, or replaces a keyframe if the tick matches exactly
     * @param keyFrame the keyframe to add or modify for the character
     * @return the keyframe that is being replaced; null if there is no keyframe being replaced
     */
    public KeyFrame addKeyFrame(KeyFrame keyFrame, double currentTime)
    {
        KeyFrameType type = keyFrame.getKeyFrameType();
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            keyFrames = new KeyFrame[]{keyFrame};
            setKeyFrames(keyFrames, type);

            KeyFrame currentKeyFrame = findPreviousKeyFrame(type, currentTime, true);
            setCurrentKeyFrame(currentKeyFrame, type);
            return null;
        }

        int[] framePosition = getFramePosition(keyFrames, keyFrame.getTick());
        KeyFrame keyFrameToReplace = null;

        // Check first if the new keyframe is replacing a previous one
        if (framePosition[1] == 1)
        {
            keyFrameToReplace = keyFrames[framePosition[0]];
            keyFrames[framePosition[0]] = keyFrame;
        }
        else
        {
            keyFrames = ArrayUtils.insert(framePosition[0], keyFrames, keyFrame);
        }

        setKeyFrames(keyFrames, type);

        KeyFrame currentKeyFrame = findPreviousKeyFrame(type, currentTime, true);
        setCurrentKeyFrame(currentKeyFrame, type);
        return keyFrameToReplace;
    }

    /**
     * Removes the indicated keyframe from the character
     * @param keyFrame the keyframe to remove
     */
    public void removeKeyFrame(KeyFrame keyFrame)
    {
        KeyFrameType type = keyFrame.getKeyFrameType();
        KeyFrame[] keyFrames = getKeyFrames(type);
        if (keyFrames == null)
        {
            return;
        }

        keyFrames = ArrayUtils.removeElement(keyFrames, keyFrame);
        setKeyFrames(keyFrames, type);

        if (getCurrentKeyFrame(type) == keyFrame)
        {
            setCurrentKeyFrame(null, type);
        }
    }

    /**
     * Gets the new position of the keyframe to add as an int[] of {index, boolean}
     * @param keyFrames the keyframe array to add to
     * @param newTick the tick of the new keyframe to be added
     * @return an int[] of {index, boolean}. The boolean determines whether the new keyframe will replace a previously existing keyframe of the exact same tick
     */
    private int[] getFramePosition(KeyFrame[] keyFrames, double newTick)
    {
        if (keyFrames == null)
        {
            return new int[]{0, 0};
        }

        int frameIndex = 0;
        for (int i = 0; i < keyFrames.length; i++)
        {
            if (keyFrames[i].getTick() == newTick)
            {
                return new int[]{i, 1};
            }

            if (keyFrames[i].getTick() > newTick)
            {
                if (i == 0)
                {
                    return new int[]{0, 0};
                }

                return new int[]{i, 0};
            }

            frameIndex++;
        }

        return new int[]{frameIndex, 0};
    }

    public MovementKeyFrame[] getMovementKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.MOVEMENT);
        if (keyFrames == null)
        {
            return null;
        }

        MovementKeyFrame[] keyFrame = new MovementKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (MovementKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public AnimationKeyFrame[] getAnimationKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.ANIMATION);
        if (keyFrames == null)
        {
            return null;
        }

        AnimationKeyFrame[] keyFrame = new AnimationKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (AnimationKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public SpawnKeyFrame[] getSpawnKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.SPAWN);
        if (keyFrames == null)
        {
            return null;
        }

        SpawnKeyFrame[] keyFrame = new SpawnKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (SpawnKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public ModelKeyFrame[] getModelKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.MODEL);
        if (keyFrames == null)
        {
            return null;
        }

        ModelKeyFrame[] keyFrame = new ModelKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (ModelKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public OrientationKeyFrame[] getOrientationKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.ORIENTATION);
        if (keyFrames == null)
        {
            return null;
        }

        OrientationKeyFrame[] keyFrame = new OrientationKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (OrientationKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public TextKeyFrame[] getTextKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.TEXT);
        if (keyFrames == null)
        {
            return null;
        }

        TextKeyFrame[] keyFrame = new TextKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (TextKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public OverheadKeyFrame[] getOverheadKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.OVERHEAD);
        if (keyFrames == null)
        {
            return null;
        }

        OverheadKeyFrame[] keyFrame = new OverheadKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (OverheadKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public HealthKeyFrame[] getHealthKeyFrames()
    {
        KeyFrame[] keyFrames = getKeyFrames(KeyFrameType.HEALTH);
        if (keyFrames == null)
        {
            return null;
        }

        HealthKeyFrame[] keyFrame = new HealthKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (HealthKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }

    public SpotAnimKeyFrame[] getSpotAnimKeyFrames(KeyFrameType spotAnimNumber)
    {
        KeyFrame[] keyFrames = getKeyFrames(spotAnimNumber);
        if (keyFrames == null)
        {
            return null;
        }

        SpotAnimKeyFrame[] keyFrame = new SpotAnimKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (SpotAnimKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }


    public void toggleActive(ClientThread clientThread)
    {
        setActive(!active, !active, true, clientThread);
    }

    public void setVisible(boolean visible, ClientThread clientThread)
    {
        clientThread.invokeLater(() -> ckObject.setActive(visible));
    }

    public void resetActive(ClientThread clientThread)
    {
        setActive(active, active, active, clientThread);
    }

    public void setActive(boolean setActive, boolean shouldBeActive, boolean reset, ClientThread clientThread)
    {
        active = shouldBeActive;

        clientThread.invokeLater(() ->
        {
            if (setActive)
            {
                if (reset)
                {
                    ckObject.setActive(false);
                }
                ckObject.setActive(true);
                spawnButton.setText("Spawn");
                return;
            }

            ckObject.setActive(false);
            spawnButton.setText("Despawn");
        });
    }

    public HitsplatKeyFrame[] getHitsplatKeyFrames(KeyFrameType hitsplatType)
    {
        KeyFrame[] keyFrames = getKeyFrames(hitsplatType);
        if (keyFrames == null)
        {
            return null;
        }

        HitsplatKeyFrame[] keyFrame = new HitsplatKeyFrame[keyFrames.length];
        for (int i = 0; i < keyFrames.length; i++)
        {
            keyFrame[i] = (HitsplatKeyFrame) keyFrames[i];
        }
        return keyFrame;
    }
}

package com.creatorskit;

import com.creatorskit.programming.MovementManager;
import com.creatorskit.swing.timesheet.keyframe.KeyFrame;
import com.creatorskit.swing.timesheet.keyframe.KeyFrameType;
import com.creatorskit.swing.timesheet.keyframe.MovementKeyFrame;
import net.runelite.api.*;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.OverlayUtil;

import javax.inject.Inject;
import java.awt.*;
import java.util.Collection;

public class CreatorsOverlay extends Overlay
{
    private final Client client;
    private final CreatorsPlugin plugin;
    private final CreatorsConfig config;
    private static final Color HOVERED_COLOUR = new Color(146, 206, 193, 255);
    private static final Color SELECTED_COLOUR = new Color(220, 253, 245);
    private static final Color GAME_OBJECT_COLOUR = new Color(255, 138, 18);
    private static final Color DYNAMIC_OBJECT_COLOUR = new Color(255, 190, 130);
    private static final Color GROUND_OBJECT_COLOUR = new Color(73, 255, 0);
    private static final Color WALL_OBJECT_COLOUR = new Color(255, 70, 70);
    private static final Color DECORATIVE_OBJECT_COLOUR = new Color(183, 126, 255);
    private static final Color PROJECTILE_COLOUR = new Color(255, 222, 2);
    private static final Color NPC_COLOUR = new Color(188, 198, 255);
    private static final Color PLAYER_COLOUR = new Color(221, 133, 255);
    private static final int MAX_DISTANCE = 2400;
    private final BasicStroke dashedLine = new BasicStroke(2.5f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_ROUND, 1f, new float[] { 5, 5, 5, 5 }, 0f);


    @Inject
    private CreatorsOverlay(Client client, CreatorsPlugin plugin, CreatorsConfig config)
    {
        setPosition(OverlayPosition.DYNAMIC);
        setLayer(OverlayLayer.ABOVE_SCENE);
        this.client = client;
        this.plugin = plugin;
        this.config = config;
    }

    @Override
    public Dimension render(Graphics2D graphics)
    {
        if (client.getGameState() != GameState.LOGGED_IN)
        {
            return null;
        }

        WorldView worldView = client.getTopLevelWorldView();

        boolean keyHeld = config.enableCtrlHotkeys() && client.isKeyPressed(KeyCode.KC_CONTROL);
        if (keyHeld)
        {
            renderSelectedRLObject(graphics, worldView);
        }

        if (!plugin.isOverlaysActive())
        {
            return null;
        }

        if (config.myObjectOverlay())
        {
            renderRLObjects(graphics, keyHeld, worldView);
        }

        renderObjectsOverlay(graphics, worldView);

        if (config.pathOverlay())
        {
            if (MovementManager.useLocalLocations(worldView))
            {
                renderPOHProgramOverlay(graphics, worldView);
            }
            else
            {
                renderWorldProgramOverlay(graphics, worldView);
            }
        }

        if (config.npcOverlay())
            renderNPCOverlay(graphics, worldView);

        if (config.playerOverlay())
            renderPlayerOverlay(graphics, worldView);

        if (config.projectileOverlay())
            renderProjectiles(graphics, worldView);

        return null;
    }

    public void renderWorldProgramOverlay(Graphics2D graphics, WorldView worldView)
    {
        graphics.setStroke(new BasicStroke(1));
        
        for (int e = 0; e < plugin.getCharacters().size(); e++)
        {
            Character character = plugin.getCharacters().get(e);
            if (!character.isInScene())
            {
                continue;
            }

            boolean poh = MovementManager.useLocalLocations(worldView);
            if ((!poh && character.isInPOH()) || (poh && !character.isInPOH()))
            {
                continue;
            }

            KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
            if (kf == null)
            {
                continue;
            }

            MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
            int plane = keyFrame.getPlane();
            if (worldView.getPlane() != plane)
            {
                continue;
            }

            int[][] path = keyFrame.getPath();

            boolean selectedCharacter = character == plugin.getSelectedCharacter();
            Color color = character.getColor();
            if (selectedCharacter)
            {
                color = SELECTED_COLOUR;
            }

            if (path.length > 0)
            {
                WorldPoint startPoint = new WorldPoint(path[0][0], path[0][1], plane);
                if (worldView.isInstance())
                {
                    Collection<WorldPoint> wps = WorldPoint.toLocalInstance(worldView, startPoint);
                    if (!wps.isEmpty())
                    {
                        startPoint = wps.iterator().next();
                    }
                }

                LocalPoint localPoint = LocalPoint.fromWorld(worldView, startPoint);
                if (localPoint != null && localPoint.isInScene())
                {
                    Point p = Perspective.localToCanvas(client, localPoint, plane);
                    String abbreviation = getAbbreviation(character);
                    if (p != null)
                    {
                        OverlayUtil.renderTextLocation(graphics, p, abbreviation, color);
                    }
                }
            }
            
            for (int i = 0; i < path.length - 1; i++)
            {
                WorldPoint wpStart = new WorldPoint(path[i][0], path[i][1], plane);
                WorldPoint wpEnd = new WorldPoint(path[i + 1][0], path[i + 1][1], plane);

                if (worldView.isInstance())
                {
                    Collection<WorldPoint> wpsStart = WorldPoint.toLocalInstance(worldView, wpStart);
                    if (!wpsStart.isEmpty())
                    {
                        wpStart = wpsStart.iterator().next();
                    }

                    Collection<WorldPoint> wpsEnd = WorldPoint.toLocalInstance(worldView, wpEnd);
                    if (!wpsEnd.isEmpty())
                    {
                        wpEnd = wpsEnd.iterator().next();
                    }
                }

                LocalPoint lpStart = LocalPoint.fromWorld(worldView, wpStart.getX(), wpStart.getY());
                LocalPoint lpEnd = LocalPoint.fromWorld(worldView, wpEnd.getX(), wpEnd.getY());

                if (lpStart == null && lpEnd == null)
                {
                    continue;
                }

                if (lpStart != null && lpEnd == null)
                {
                    Point startPoint = Perspective.localToCanvas(client, lpStart, plane);
                    if (startPoint == null)
                    {
                        continue;
                    }

                    graphics.setColor(color);
                    graphics.drawRect(startPoint.getX() - 5, startPoint.getY() - 5, 10, 10);
                    continue;
                }

                if (lpStart == null && lpEnd != null)
                {
                    Point endPoint = Perspective.localToCanvas(client, lpEnd, plane);
                    if (endPoint == null)
                    {
                        continue;
                    }

                    graphics.setColor(color);
                    graphics.drawRect(endPoint.getX() - 5, endPoint.getY() - 5, 10, 10);
                    continue;
                }

                Point startPoint = Perspective.localToCanvas(client, lpStart, plane);
                if (startPoint == null)
                {
                    continue;
                }

                Point endPoint = Perspective.localToCanvas(client, lpEnd, plane);
                if (endPoint == null)
                {
                    continue;
                }

                graphics.setColor(color);
                graphics.setStroke(new BasicStroke(3));
                if (!selectedCharacter)
                {
                    graphics.setStroke(dashedLine);
                }

                graphics.drawLine(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
            }
        }
    }

    public void renderPOHProgramOverlay(Graphics2D graphics, WorldView worldView)
    {
        graphics.setStroke(new BasicStroke(1));

        for (int e = 0; e < plugin.getCharacters().size(); e++)
        {
            Character character = plugin.getCharacters().get(e);
            if (!character.isInScene())
            {
                continue;
            }

            boolean poh = MovementManager.useLocalLocations(worldView);
            if ((!poh && character.isInPOH()) || (poh && !character.isInPOH()))
            {
                continue;
            }

            KeyFrame kf = character.getCurrentKeyFrame(KeyFrameType.MOVEMENT);
            if (kf == null)
            {
                continue;
            }

            MovementKeyFrame keyFrame = (MovementKeyFrame) kf;
            int plane = keyFrame.getPlane();
            if (worldView.getPlane() != plane)
            {
                continue;
            }

            boolean selectedCharacter = character == plugin.getSelectedCharacter();
            Color color = character.getColor().brighter();
            if (selectedCharacter)
            {
                color = SELECTED_COLOUR;
            }

            int[][] path = keyFrame.getPath();

            if (path.length > 0)
            {
                LocalPoint localPoint = LocalPoint.fromScene(path[0][0], path[0][1], worldView);
                Point p = Perspective.localToCanvas(client, localPoint, plane);
                String abbreviation = getAbbreviation(character);
                if (p != null)
                {
                    OverlayUtil.renderTextLocation(graphics, p, abbreviation, color);
                }
            }

            for (int i = 0; i < path.length - 1; i++)
            {
                LocalPoint lpStart = LocalPoint.fromScene(path[i][0], path[i][1], worldView);
                LocalPoint lpEnd = LocalPoint.fromScene(path[i + 1][0], path[i + 1][1], worldView);

                if (!lpStart.isInScene() && !lpEnd.isInScene())
                {
                    continue;
                }

                if (lpStart.isInScene() && !lpEnd.isInScene())
                {
                    Point startPoint = Perspective.localToCanvas(client, lpStart, plane);
                    if (startPoint == null)
                    {
                        continue;
                    }

                    graphics.setColor(color);
                    graphics.drawRect(startPoint.getX() - 5, startPoint.getY() - 5, 10, 10);
                    continue;
                }

                if (!lpStart.isInScene() && lpEnd.isInScene())
                {
                    Point endPoint = Perspective.localToCanvas(client, lpEnd, plane);
                    if (endPoint == null)
                    {
                        continue;
                    }

                    graphics.setColor(color);
                    graphics.drawRect(endPoint.getX() - 5, endPoint.getY() - 5, 10, 10);
                    continue;
                }

                Point startPoint = Perspective.localToCanvas(client, lpStart, plane);
                if (startPoint == null)
                {
                    continue;
                }

                Point endPoint = Perspective.localToCanvas(client, lpEnd, plane);
                if (endPoint == null)
                {
                    continue;
                }

                graphics.setColor(color);
                graphics.setStroke(new BasicStroke(3));
                if (!selectedCharacter)
                {
                    graphics.setStroke(dashedLine);
                }

                graphics.drawLine(startPoint.getX(), startPoint.getY(), endPoint.getX(), endPoint.getY());
            }
        }
    }

    private static String getAbbreviation(Character character)
    {
        String name = character.getName();
        String abbreviation;
        int abbreviationLength = 3;
        int nameLength = name.length();

        if (abbreviationLength > nameLength)
        {
            abbreviation = character.getName().substring(0, nameLength);
        }
        else
        {
            abbreviation = character.getName().substring(0, 3);
        }

        return abbreviation;
    }

    public void renderPlayerOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (Player player : worldView.players())
        {
            LocalPoint localPoint = player.getLocalLocation();
            if (localPoint == null)
                continue;

            StringBuilder spotAnims = new StringBuilder();
            for (ActorSpotAnim spotAnim : player.getSpotAnims())
            {
                spotAnims.append(", G: ");
                spotAnims.append(spotAnim.getId());
                spotAnims.append(", H: ");
                spotAnims.append(spotAnim.getHeight());
            }

            OverlayUtil.renderActorOverlay(graphics, player, "A: " + player.getAnimation() + ", P: " + player.getPoseAnimation() + spotAnims, PLAYER_COLOUR);
        }
    }

    public void renderNPCOverlay(Graphics2D graphics, WorldView worldView)
    {
        for (NPC npc : worldView.npcs())
        {
            LocalPoint localPoint = npc.getLocalLocation();
            if (localPoint == null)
                continue;

            StringBuilder spotAnims = new StringBuilder();
            for (ActorSpotAnim spotAnim : npc.getSpotAnims())
            {
                spotAnims.append(", G: ");
                spotAnims.append(spotAnim.getId());
                spotAnims.append(", H: ");
                spotAnims.append(spotAnim.getHeight());
            }

            OverlayUtil.renderActorOverlay(graphics, npc, "ID: " + npc.getId() + ", A: " + npc.getAnimation() + ", P: " + npc.getPoseAnimation() + spotAnims, NPC_COLOUR);
        }
    }

    public void renderObjectsOverlay(Graphics2D graphics, WorldView worldView)
    {
        Scene scene = worldView.getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = worldView.getPlane();

        for (int x = 0; x < Constants.SCENE_SIZE; x++)
        {
            for (int y = 0; y < Constants.SCENE_SIZE; y++)
            {
                Tile tile = tiles[z][x][y];

                if (tile == null)
                {
                    continue;
                }

                Player player = client.getLocalPlayer();
                if (player == null)
                {
                    continue;
                }

                if (config.gameObjectOverlay() || config.myObjectOverlay())
                {
                    renderGameObjects(graphics, tile, worldView);
                }

                if (config.groundObjectOverlay())
                {
                    renderGroundObjects(graphics, tile, worldView);
                }

                if (config.wallObjectOverlay())
                {
                    renderWallObjects(graphics, tile, worldView);
                }

                if (config.decorativeObjectOverlay())
                {
                    renderDecorativeObjects(graphics, tile, worldView);
                }
            }
        }
    }

    public void renderSelectedRLObject(Graphics2D graphics, WorldView worldView)
    {
        Character character = plugin.getSelectedCharacter();
        if (character == null)
        {
            return;
        }

        if (!character.isInScene())
        {
            return;
        }

        boolean poh = MovementManager.useLocalLocations(worldView);
        if ((!poh && character.isInPOH()) || (poh && !character.isInPOH()))
        {
            return;
        }

        CKObject ckObject = character.getCkObject();
        if (ckObject == null || !ckObject.isActive())
        {
            return;
        }

        LocalPoint lp = ckObject.getLocation();
        if (lp == null || !lp.isInScene())
        {
            return;
        }

        Model model = ckObject.getModel();
        if (model == null)
        {
            return;
        }

        model.calculateBoundsCylinder();

        Point p = Perspective.getCanvasTextLocation(client, graphics, lp, character.getName(), model.getModelHeight());
        if (p != null)
        {
            OverlayUtil.renderTextLocation(graphics, p, character.getName(), SELECTED_COLOUR);
        }
    }

    public void renderRLObjects(Graphics2D graphics, boolean keyHeld, WorldView worldView)
    {
        for (int i = 0; i < plugin.getCharacters().size(); i++)
        {
            Character character = plugin.getCharacters().get(i);
            if (!character.isInScene())
            {
                continue;
            }

            CKObject ckObject = character.getCkObject();
            if (ckObject == null || !ckObject.isActive())
            {
                continue;
            }

            LocalPoint lp = ckObject.getLocation();
            if (lp == null || !lp.isInScene())
            {
                continue;
            }

            String name = character.getName();
            Model model = ckObject.getModel();
            if (model == null)
            {
                continue;
            }

            model.calculateBoundsCylinder();

            Point point = Perspective.getCanvasTextLocation(client, graphics, lp, name, model.getModelHeight());

            if (point == null)
            {
                continue;
            }

            if (plugin.getSelectedCharacter() == character)
            {
                if (keyHeld)
                {
                    continue;
                }

                OverlayUtil.renderTextLocation(graphics, point, name, SELECTED_COLOUR);
                continue;
            }

            if (!config.myObjectOverlay())
            {
                continue;
            }

            if (plugin.getHoveredCharacter() == character)
            {
                OverlayUtil.renderTextLocation(graphics, point, name, HOVERED_COLOUR);
                continue;
            }

            Color colour = character.getColor();
            if (plugin.getSelectedCharacter() == character)
            {
                colour = SELECTED_COLOUR;
            }

            OverlayUtil.renderTextLocation(graphics, point, name, colour);
        }
    }

    public void renderGameObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        GameObject[] gameObjects = tile.getGameObjects();
        if (gameObjects != null)
        {
            for (GameObject gameObject : gameObjects)
            {
                if (gameObject != null && gameObject.getSceneMinLocation().equals(tile.getSceneLocation()))
                {
                    if (gameObject.getRenderable() instanceof Actor)
                    {
                        continue;
                    }

                    StringBuilder stringBuilder = new StringBuilder();

                    if (gameObject.getRenderable() instanceof RuneLiteObject)
                    {
                        continue;
                    }

                    LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
                    if (gameObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
                    {
                        if (!config.gameObjectOverlay())
                        {
                            continue;
                        }

                        stringBuilder.append("ID: ").append(gameObject.getId());
                        Color color = GAME_OBJECT_COLOUR;
                        if (gameObject.getRenderable() instanceof DynamicObject)
                        {
                            Animation animation = ((DynamicObject) gameObject.getRenderable()).getAnimation();
                            if (animation != null)
                            {
                                stringBuilder.append(" A: ").append(animation.getId());
                            }
                            else
                            {
                                stringBuilder.append(" A: -1");
                            }

                            color = DYNAMIC_OBJECT_COLOUR;
                        }
                        else
                        {
                            stringBuilder.append(" A: -1");
                        }

                        OverlayUtil.renderTileOverlay(graphics, gameObject, stringBuilder.toString(), color);
                    }
                }
            }
        }
    }

    public void renderGroundObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        GroundObject groundObject = tile.getGroundObject();
        if (groundObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (groundObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, groundObject, "ID: " + groundObject.getId(), GROUND_OBJECT_COLOUR);
            }
        }
    }

    public void renderWallObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        TileObject tileObject = tile.getWallObject();
        if (tileObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (tileObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, tileObject, "ID: " + tileObject.getId(), WALL_OBJECT_COLOUR);
            }
        }
    }

    public void renderDecorativeObjects(Graphics2D graphics, Tile tile, WorldView worldView)
    {
        TileObject tileObject = tile.getDecorativeObject();
        if (tileObject != null)
        {
            LocalPoint camera = new LocalPoint(client.getCameraX(), client.getCameraY(), worldView);
            if (tileObject.getLocalLocation().distanceTo(camera) <= MAX_DISTANCE)
            {
                OverlayUtil.renderTileOverlay(graphics, tileObject, "ID: " + tileObject.getId(), DECORATIVE_OBJECT_COLOUR);
            }
        }
    }

    private void renderProjectiles(Graphics2D graphics, WorldView worldView)
    {
        for (Projectile projectile : client.getProjectiles())
        {
            int projectileId = projectile.getId();
            String text = "ID: " + projectileId;
            int x = (int) projectile.getX();
            int y = (int) projectile.getY();
            LocalPoint projectilePoint = new LocalPoint(x, y, worldView);
            Point textLocation = Perspective.getCanvasTextLocation(client, graphics, projectilePoint, text, 0);
            if (textLocation != null)
            {
                OverlayUtil.renderTextLocation(graphics, textLocation, text, PROJECTILE_COLOUR);
            }
        }
    }
}

package com.creatorskit;

import com.creatorskit.programming.AnimationType;
import com.creatorskit.programming.CKAnimationController;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;

@Getter
@Setter
public class CKObject extends RuneLiteObjectController
{
    private final Client client;
    private Model baseModel;
    private boolean freeze;
    private boolean playing;
    private boolean hasAnimKeyFrame;
    private boolean despawnOnFinish;
    private Animation activeAnimation;
    private CKAnimationController animationController;
    private CKAnimationController poseAnimationController;

    public CKObject(Client client)
    {
        this.client = client;
    }

    private int startCycle;

    public void setModel(Model baseModel)
    {
        this.baseModel = baseModel;
    }

    @Override
    public void setLocation(LocalPoint point, int level)
    {
        if (point == null)
        {
            return;
        }

        super.setLocation(point, level);
        setZ(Perspective.getTileHeight(client, point, level));

        /*
        boolean needReregister = isActive() && point.getWorldView() != getWorldView();
        if (needReregister)
        {
            setActive(false);
        }

        super.setLocation(point, level);
        setZ(Perspective.getTileHeight(client, point, level));

        if (needReregister)
        {
            setActive(true);
        }

         */
    }

    public void setupAnimController(AnimationType type, int animId)
    {
        if (type == AnimationType.ACTIVE)
        {
            animationController = new CKAnimationController(client, animId, false);
            setOnFinished(AnimationType.ACTIVE);
        }
        else
        {
            poseAnimationController = new CKAnimationController(client, animId, true);
            setOnFinished(AnimationType.POSE);
        }
    }

    public void setupAnimController(AnimationType type, Animation animation)
    {
        if (type == AnimationType.ACTIVE)
        {
            animationController = new CKAnimationController(client, animation, false);
            setOnFinished(AnimationType.ACTIVE);
        }
        else
        {
            poseAnimationController = new CKAnimationController(client, animation, true);
            setOnFinished(AnimationType.POSE);
        }
    }

    private void setOnFinished(AnimationType type)
    {
        CKAnimationController ac = getController(type);
        ac.setOnFinished(e ->
        {
            if (ac.isLoop())
            {
                setActive(true);
                ac.setFinished(false);
                ac.loop();
            }
            else
            {
                ac.setFinished(true);
                setAnimation(type, -1);
            }

            if (ac.isFinished() && despawnOnFinish)
            {
                setActive(false);
            }
        });
    }

    public void setActive(boolean active)
    {
        if (active)
        {
            client.registerRuneLiteObject(this);
        }
        else
        {
            client.removeRuneLiteObject(this);
        }
    }

    public boolean isActive()
    {
        return client.isRuneLiteObjectRegistered(this);
    }

    public void setLoop(boolean loop)
    {
        if (animationController == null)
        {
            return;
        }

        animationController.setLoop(loop);
    }

    @Override
    public void tick(int ticksSinceLastFrame)
    {
        if (!playing && hasAnimKeyFrame)
        {
            return;
        }

        if (animationController == null)
        {
            setupAnimController(AnimationType.ACTIVE, -1);
        }

        if (poseAnimationController == null)
        {
            setupAnimController(AnimationType.POSE, -1);
        }

        if (!freeze)
        {
            animationController.tick(ticksSinceLastFrame);
            poseAnimationController.tick(ticksSinceLastFrame);
        }
    }

    @Override
    public Model getModel()
    {
        if (animationController != null)
        {
            return animationController.animate(this.baseModel, this.poseAnimationController);
        }
        else if (poseAnimationController != null)
        {
            return poseAnimationController.animate(this.baseModel);
        }
        else
        {
            return baseModel;
        }
    }

    public boolean isFinished()
    {
        if (animationController == null)
        {
            return true;
        }

        return animationController.isFinished();
    }

    public void setFinished(boolean finished)
    {
        if (animationController == null)
        {
            return;
        }

        animationController.setFinished(finished);
    }

    public void unsetAnimation(AnimationType type)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            setupAnimController(type, -1);
            return;
        }

        ac.setAnimation(client.loadAnimation(-1));
    }

    public void setAnimation(AnimationType type, Animation animation)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            setupAnimController(type, animation);
            return;
        }

        ac.setAnimation(animation);
    }

    public void setAnimation(AnimationType type, int animId)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            setupAnimController(type, animId);
            return;
        }

        ac.setAnimation(client.loadAnimation(animId));
    }

    public Animation[] getAnimations()
    {
        if (animationController == null)
        {
            setupAnimController(AnimationType.ACTIVE, -1);
        }

        if (poseAnimationController == null)
        {
            setupAnimController(AnimationType.POSE, -1);
        }

        return new Animation[]{animationController.getAnimation(), poseAnimationController.getAnimation()};
    }

    public void setAnimationFrame(AnimationType type, int animFrame, boolean allowFreeze)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            setupAnimController(type, -1);
        }

        Animation animation = ac.getAnimation();
        if (animation == null)
        {
            return;
        }

        if (animFrame >= animation.getDuration())
        {
            animFrame = animation.getDuration() - 1;
        }

        if (allowFreeze)
        {
            if (animFrame == -1)
            {
                freeze = false;
                ac.setFrame(0);
                return;
            }

            freeze = true;
            ac.setFrame(animFrame);
            return;
        }

        freeze = false;
        ac.setFrame(animFrame);
    }

    public int getAnimationFrame(AnimationType type)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            return 0;
        }

        Animation animation = ac.getAnimation();
        if (animation == null)
        {
            return 0;
        }

        return animationController.getFrame();
    }

    public int getMaxAnimFrames(AnimationType type)
    {
        CKAnimationController ac = getController(type);
        if (ac == null)
        {
            return 0;
        }

        Animation animation = ac.getAnimation();
        if (animation == null)
        {
            return 0;
        }

        return animation.getDuration();
    }

    public int getAnimationId()
    {
        if (animationController != null)
        {
            Animation animation = animationController.getAnimation();
            if (animation != null)
            {
                return animation.getId();
            }
        }

        if (poseAnimationController != null)
        {
            Animation animation = poseAnimationController.getAnimation();
            if (animation != null)
            {
                return animation.getId();
            }
        }

        return -1;
    }

    private CKAnimationController getController(AnimationType type)
    {
        if (type == AnimationType.ACTIVE)
        {
            return animationController;
        }

        return poseAnimationController;
    }
}

package com.creatorskit;

public enum LocationOption
{
    TO_PLAYER,
    TO_HOVERED_TILE,
    TO_SAVED_LOCATION,
    TO_CURRENT_TICK
}

package com.creatorskit;

import net.runelite.client.RuneLite;
import net.runelite.client.externalplugins.ExternalPluginManager;

public class CreatorsPluginTest
{
	public static void main(String[] args) throws Exception
	{
		ExternalPluginManager.loadBuiltin(CreatorsPlugin.class);
		RuneLite.main(args);
	}
}
